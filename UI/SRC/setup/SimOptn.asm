; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\UI\SRC\setup\SimOptn.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
PUBLIC	?GetFlightModelType@PlayerOptionsClass@@QAEHXZ	; PlayerOptionsClass::GetFlightModelType
PUBLIC	?GetWeaponEffectiveness@PlayerOptionsClass@@QAEHXZ ; PlayerOptionsClass::GetWeaponEffectiveness
PUBLIC	?GetAvionicsType@PlayerOptionsClass@@QAEHXZ	; PlayerOptionsClass::GetAvionicsType
PUBLIC	?GetAutopilotMode@PlayerOptionsClass@@QAEHXZ	; PlayerOptionsClass::GetAutopilotMode
PUBLIC	?AutoTargetingOn@PlayerOptionsClass@@QAEHXZ	; PlayerOptionsClass::AutoTargetingOn
PUBLIC	?BlackoutOn@PlayerOptionsClass@@QAEHXZ		; PlayerOptionsClass::BlackoutOn
PUBLIC	?UnlimitedFuel@PlayerOptionsClass@@QAEHXZ	; PlayerOptionsClass::UnlimitedFuel
PUBLIC	?UnlimitedAmmo@PlayerOptionsClass@@QAEHXZ	; PlayerOptionsClass::UnlimitedAmmo
PUBLIC	?UnlimitedChaff@PlayerOptionsClass@@QAEHXZ	; PlayerOptionsClass::UnlimitedChaff
PUBLIC	?CollisionsOn@PlayerOptionsClass@@QAEHXZ	; PlayerOptionsClass::CollisionsOn
PUBLIC	?NameTagsOn@PlayerOptionsClass@@QAEHXZ		; PlayerOptionsClass::NameTagsOn
PUBLIC	?SetSimFlag@PlayerOptionsClass@@QAEXH@Z		; PlayerOptionsClass::SetSimFlag
PUBLIC	?ClearSimFlag@PlayerOptionsClass@@QAEXH@Z	; PlayerOptionsClass::ClearSimFlag
PUBLIC	?InitSimOptionStuff@@YAXPAUHWND__@@@Z		; InitSimOptionStuff
PUBLIC	?UpdateSimOptions@@YAXPAUHWND__@@@Z		; UpdateSimOptions
PUBLIC	?DoSimOptions@@YAHPAUHWND__@@IIJ@Z		; DoSimOptions
PUBLIC	??_C@_06MIPDDPP@Simple?$AA@			; `string'
PUBLIC	??_C@_08FDNKDHKO@Moderate?$AA@			; `string'
PUBLIC	??_C@_07NFKBFEEI@Acurate?$AA@			; `string'
PUBLIC	??_C@_0M@CEOEGBJB@Exaggerated?$AA@		; `string'
PUBLIC	??_C@_08HDHPPHEE@Enhanced?$AA@			; `string'
PUBLIC	??_C@_03MDIFNIHN@360?$AA@			; `string'
PUBLIC	??_C@_04ICBOFLAL@Easy?$AA@			; `string'
PUBLIC	??_C@_06PBPJFIAF@APG?568?$AA@			; `string'
PUBLIC	??_C@_0M@IENNDIF@Intelligent?$AA@		; `string'
PUBLIC	??_C@_06EFAGIKOH@Normal?$AA@			; `string'
PUBLIC	??_C@_07MCAEODGB@Default?$AA@			; `string'
EXTRN	__imp__EndDialog@8:PROC
EXTRN	__imp__CheckDlgButton@12:PROC
EXTRN	__imp__IsDlgButtonChecked@8:PROC
EXTRN	__imp__SendDlgItemMessageA@20:PROC
EXTRN	?SaveOptions@PlayerOptionsClass@@QAEHPAD@Z:PROC	; PlayerOptionsClass::SaveOptions
EXTRN	?PlayerOptions@@3VPlayerOptionsClass@@A:BYTE	; PlayerOptions
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
_allocator_arg DB 01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT ??_C@_07MCAEODGB@Default?$AA@
CONST	SEGMENT
??_C@_07MCAEODGB@Default?$AA@ DB 'Default', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06EFAGIKOH@Normal?$AA@
CONST	SEGMENT
??_C@_06EFAGIKOH@Normal?$AA@ DB 'Normal', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IENNDIF@Intelligent?$AA@
CONST	SEGMENT
??_C@_0M@IENNDIF@Intelligent?$AA@ DB 'Intelligent', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06PBPJFIAF@APG?568?$AA@
CONST	SEGMENT
??_C@_06PBPJFIAF@APG?568?$AA@ DB 'APG 68', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04ICBOFLAL@Easy?$AA@
CONST	SEGMENT
??_C@_04ICBOFLAL@Easy?$AA@ DB 'Easy', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03MDIFNIHN@360?$AA@
CONST	SEGMENT
??_C@_03MDIFNIHN@360?$AA@ DB '360', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08HDHPPHEE@Enhanced?$AA@
CONST	SEGMENT
??_C@_08HDHPPHEE@Enhanced?$AA@ DB 'Enhanced', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CEOEGBJB@Exaggerated?$AA@
CONST	SEGMENT
??_C@_0M@CEOEGBJB@Exaggerated?$AA@ DB 'Exaggerated', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07NFKBFEEI@Acurate?$AA@
CONST	SEGMENT
??_C@_07NFKBFEEI@Acurate?$AA@ DB 'Acurate', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08FDNKDHKO@Moderate?$AA@
CONST	SEGMENT
??_C@_08FDNKDHKO@Moderate?$AA@ DB 'Moderate', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06MIPDDPP@Simple?$AA@
CONST	SEGMENT
??_C@_06MIPDDPP@Simple?$AA@ DB 'Simple', 00H		; `string'
CONST	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\setup\simoptn.cpp
_TEXT	SEGMENT
tv69 = -12						; size = 4
tv64 = -8						; size = 4
_retval$ = -4						; size = 4
_hDlg$ = 8						; size = 4
_message$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
?DoSimOptions@@YAHPAUHWND__@@IIJ@Z PROC			; DoSimOptions

; 114  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 115  : int retval = FALSE;

	mov	DWORD PTR _retval$[ebp], 0

; 116  : 
; 117  :    switch (message)

	mov	eax, DWORD PTR _message$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 272		; 00000110H
	je	SHORT $LN7@DoSimOptio
	cmp	DWORD PTR tv64[ebp], 273		; 00000111H
	je	SHORT $LN6@DoSimOptio
	jmp	SHORT $LN8@DoSimOptio
$LN7@DoSimOptio:

; 118  :    {
; 119  :       case WM_INITDIALOG:
; 120  :          InitSimOptionStuff(hDlg);

	mov	ecx, DWORD PTR _hDlg$[ebp]
	push	ecx
	call	?InitSimOptionStuff@@YAXPAUHWND__@@@Z	; InitSimOptionStuff
	add	esp, 4

; 121  :          retval = TRUE;

	mov	DWORD PTR _retval$[ebp], 1

; 122  :      	break;

	jmp	SHORT $LN8@DoSimOptio
$LN6@DoSimOptio:

; 123  : 
; 124  :       case WM_COMMAND:                		/* message: received a command */
; 125  :          switch (LOWORD(wParam))

	mov	edx, DWORD PTR _wParam$[ebp]
	and	edx, 65535				; 0000ffffH
	movzx	eax, dx
	mov	DWORD PTR tv69[ebp], eax
	cmp	DWORD PTR tv69[ebp], 1
	je	SHORT $LN3@DoSimOptio
	cmp	DWORD PTR tv69[ebp], 2
	je	SHORT $LN2@DoSimOptio
	jmp	SHORT $LN4@DoSimOptio
$LN3@DoSimOptio:

; 126  :          {
; 127  :             case IDOK:
; 128  :                UpdateSimOptions(hDlg);

	mov	ecx, DWORD PTR _hDlg$[ebp]
	push	ecx
	call	?UpdateSimOptions@@YAXPAUHWND__@@@Z	; UpdateSimOptions
	add	esp, 4
$LN2@DoSimOptio:

; 129  :             case IDCANCEL:
; 130  :                EndDialog(hDlg, TRUE);        /* Exits the dialog box        */

	push	1
	mov	edx, DWORD PTR _hDlg$[ebp]
	push	edx
	call	DWORD PTR __imp__EndDialog@8
$LN4@DoSimOptio:

; 131  :             break;
; 132  :          }
; 133  :          retval = TRUE;

	mov	DWORD PTR _retval$[ebp], 1
$LN8@DoSimOptio:

; 134  :       break;
; 135  : 
; 136  :       default:
; 137  : //         retval = DefDlgProc(hDlg, message, wParam, lParam);
; 138  :       break;
; 139  :    }
; 140  :    lParam = wParam;

	mov	eax, DWORD PTR _wParam$[ebp]
	mov	DWORD PTR _lParam$[ebp], eax

; 141  :    return (retval);

	mov	eax, DWORD PTR _retval$[ebp]

; 142  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DoSimOptions@@YAHPAUHWND__@@IIJ@Z ENDP			; DoSimOptions
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\setup\simoptn.cpp
_TEXT	SEGMENT
_hDlg$ = 8						; size = 4
?UpdateSimOptions@@YAXPAUHWND__@@@Z PROC		; UpdateSimOptions

; 70   : {

	push	ebp
	mov	ebp, esp

; 71   :    if (IsDlgButtonChecked (hDlg, IDC_SIMOPTION_AUTOTARGET))

	push	1000					; 000003e8H
	mov	eax, DWORD PTR _hDlg$[ebp]
	push	eax
	call	DWORD PTR __imp__IsDlgButtonChecked@8
	test	eax, eax
	je	SHORT $LN14@UpdateSimO

; 72   :       PlayerOptions.SetSimFlag (SIM_AUTO_TARGET);

	push	1
	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?SetSimFlag@PlayerOptionsClass@@QAEXH@Z	; PlayerOptionsClass::SetSimFlag

; 73   :    else

	jmp	SHORT $LN13@UpdateSimO
$LN14@UpdateSimO:

; 74   :       PlayerOptions.ClearSimFlag (SIM_AUTO_TARGET);

	push	1
	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?ClearSimFlag@PlayerOptionsClass@@QAEXH@Z ; PlayerOptionsClass::ClearSimFlag
$LN13@UpdateSimO:

; 75   : 
; 76   :    if (IsDlgButtonChecked (hDlg, IDC_SIMOPTION_BLACKOUT))

	push	1001					; 000003e9H
	mov	ecx, DWORD PTR _hDlg$[ebp]
	push	ecx
	call	DWORD PTR __imp__IsDlgButtonChecked@8
	test	eax, eax
	je	SHORT $LN12@UpdateSimO

; 77   :       PlayerOptions.ClearSimFlag (SIM_NO_BLACKOUT);

	push	2
	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?ClearSimFlag@PlayerOptionsClass@@QAEXH@Z ; PlayerOptionsClass::ClearSimFlag

; 78   :    else

	jmp	SHORT $LN11@UpdateSimO
$LN12@UpdateSimO:

; 79   :       PlayerOptions.SetSimFlag (SIM_NO_BLACKOUT);

	push	2
	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?SetSimFlag@PlayerOptionsClass@@QAEXH@Z	; PlayerOptionsClass::SetSimFlag
$LN11@UpdateSimO:

; 80   : 
; 81   :    if (IsDlgButtonChecked (hDlg, IDC_SIMOPTION_FUEL))

	push	1002					; 000003eaH
	mov	edx, DWORD PTR _hDlg$[ebp]
	push	edx
	call	DWORD PTR __imp__IsDlgButtonChecked@8
	test	eax, eax
	je	SHORT $LN10@UpdateSimO

; 82   :       PlayerOptions.SetSimFlag (SIM_UNLIMITED_FUEL);

	push	4
	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?SetSimFlag@PlayerOptionsClass@@QAEXH@Z	; PlayerOptionsClass::SetSimFlag

; 83   :    else

	jmp	SHORT $LN9@UpdateSimO
$LN10@UpdateSimO:

; 84   :       PlayerOptions.ClearSimFlag (SIM_UNLIMITED_FUEL);

	push	4
	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?ClearSimFlag@PlayerOptionsClass@@QAEXH@Z ; PlayerOptionsClass::ClearSimFlag
$LN9@UpdateSimO:

; 85   : 
; 86   :    if (IsDlgButtonChecked (hDlg, IDC_SIMOPTION_CHAFF))

	push	1004					; 000003ecH
	mov	eax, DWORD PTR _hDlg$[ebp]
	push	eax
	call	DWORD PTR __imp__IsDlgButtonChecked@8
	test	eax, eax
	je	SHORT $LN8@UpdateSimO

; 87   :       PlayerOptions.SetSimFlag (SIM_UNLIMITED_CHAFF);

	push	16					; 00000010H
	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?SetSimFlag@PlayerOptionsClass@@QAEXH@Z	; PlayerOptionsClass::SetSimFlag

; 88   :    else

	jmp	SHORT $LN7@UpdateSimO
$LN8@UpdateSimO:

; 89   :       PlayerOptions.ClearSimFlag (SIM_UNLIMITED_CHAFF);

	push	16					; 00000010H
	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?ClearSimFlag@PlayerOptionsClass@@QAEXH@Z ; PlayerOptionsClass::ClearSimFlag
$LN7@UpdateSimO:

; 90   : 
; 91   :    if (IsDlgButtonChecked (hDlg, IDC_SIMOPTION_AMMO))

	push	1003					; 000003ebH
	mov	ecx, DWORD PTR _hDlg$[ebp]
	push	ecx
	call	DWORD PTR __imp__IsDlgButtonChecked@8
	test	eax, eax
	je	SHORT $LN6@UpdateSimO

; 92   :       PlayerOptions.SetSimFlag (SIM_UNLIMITED_AMMO);

	push	8
	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?SetSimFlag@PlayerOptionsClass@@QAEXH@Z	; PlayerOptionsClass::SetSimFlag

; 93   :    else

	jmp	SHORT $LN5@UpdateSimO
$LN6@UpdateSimO:

; 94   :       PlayerOptions.ClearSimFlag (SIM_UNLIMITED_AMMO);

	push	8
	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?ClearSimFlag@PlayerOptionsClass@@QAEXH@Z ; PlayerOptionsClass::ClearSimFlag
$LN5@UpdateSimO:

; 95   : 
; 96   :    if (IsDlgButtonChecked (hDlg, IDC_SIMOPTION_COLLISION))

	push	1005					; 000003edH
	mov	edx, DWORD PTR _hDlg$[ebp]
	push	edx
	call	DWORD PTR __imp__IsDlgButtonChecked@8
	test	eax, eax
	je	SHORT $LN4@UpdateSimO

; 97   :       PlayerOptions.ClearSimFlag (SIM_NO_COLLISIONS);

	push	32					; 00000020H
	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?ClearSimFlag@PlayerOptionsClass@@QAEXH@Z ; PlayerOptionsClass::ClearSimFlag

; 98   :    else

	jmp	SHORT $LN3@UpdateSimO
$LN4@UpdateSimO:

; 99   :       PlayerOptions.SetSimFlag (SIM_NO_COLLISIONS);

	push	32					; 00000020H
	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?SetSimFlag@PlayerOptionsClass@@QAEXH@Z	; PlayerOptionsClass::SetSimFlag
$LN3@UpdateSimO:

; 100  : 
; 101  :    if (IsDlgButtonChecked (hDlg, IDC_SIMOPTION_NAMETAGS))

	push	1006					; 000003eeH
	mov	eax, DWORD PTR _hDlg$[ebp]
	push	eax
	call	DWORD PTR __imp__IsDlgButtonChecked@8
	test	eax, eax
	je	SHORT $LN2@UpdateSimO

; 102  :       PlayerOptions.SetSimFlag (SIM_NAMETAGS);

	push	64					; 00000040H
	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?SetSimFlag@PlayerOptionsClass@@QAEXH@Z	; PlayerOptionsClass::SetSimFlag

; 103  :    else

	jmp	SHORT $LN1@UpdateSimO
$LN2@UpdateSimO:

; 104  :       PlayerOptions.ClearSimFlag (SIM_NAMETAGS);

	push	64					; 00000040H
	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?ClearSimFlag@PlayerOptionsClass@@QAEXH@Z ; PlayerOptionsClass::ClearSimFlag
$LN1@UpdateSimO:

; 105  : 
; 106  :    PlayerOptions.BldDeaggLevel = SendDlgItemMessage (hDlg, IDC_SIMOPTION_FEAT_DETAIL, TBM_GETPOS, 0, 0);

	push	0
	push	0
	push	1024					; 00000400H
	push	1321					; 00000529H
	mov	ecx, DWORD PTR _hDlg$[ebp]
	push	ecx
	call	DWORD PTR __imp__SendDlgItemMessageA@20
	mov	DWORD PTR ?PlayerOptions@@3VPlayerOptionsClass@@A+28, eax

; 107  :    PlayerOptions.ObjDeaggLevel = SendDlgItemMessage (hDlg, IDC_SIMOPTION_VEH_DETAIL, TBM_GETPOS, 0, 0);

	push	0
	push	0
	push	1024					; 00000400H
	push	1322					; 0000052aH
	mov	edx, DWORD PTR _hDlg$[ebp]
	push	edx
	call	DWORD PTR __imp__SendDlgItemMessageA@20
	mov	DWORD PTR ?PlayerOptions@@3VPlayerOptionsClass@@A+24, eax

; 108  :    PlayerOptions.ObjMagnification = static_cast<float>(SendDlgItemMessage (hDlg, IDC_SIMOPTION_MAGNIFICATION, TBM_GETPOS, 0, 0));

	push	0
	push	0
	push	1024					; 00000400H
	push	1319					; 00000527H
	mov	eax, DWORD PTR _hDlg$[ebp]
	push	eax
	call	DWORD PTR __imp__SendDlgItemMessageA@20
	cvtsi2ss xmm0, eax
	movss	DWORD PTR ?PlayerOptions@@3VPlayerOptionsClass@@A+20, xmm0

; 109  : 
; 110  :    PlayerOptions.SaveOptions ("Default");

	push	OFFSET ??_C@_07MCAEODGB@Default?$AA@
	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?SaveOptions@PlayerOptionsClass@@QAEHPAD@Z ; PlayerOptionsClass::SaveOptions

; 111  : }

	pop	ebp
	ret	0
?UpdateSimOptions@@YAXPAUHWND__@@@Z ENDP		; UpdateSimOptions
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\setup\simoptn.cpp
_TEXT	SEGMENT
tv142 = -28						; size = 4
tv135 = -24						; size = 4
tv128 = -20						; size = 4
tv89 = -16						; size = 4
tv82 = -12						; size = 4
tv75 = -8						; size = 4
tv68 = -4						; size = 4
_hDlg$ = 8						; size = 4
?InitSimOptionStuff@@YAXPAUHWND__@@@Z PROC		; InitSimOptionStuff

; 11   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 12   :    CheckDlgButton (hDlg, IDC_SIMOPTION_AUTOTARGET, PlayerOptions.AutoTargetingOn() ? BST_CHECKED : BST_UNCHECKED);

	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?AutoTargetingOn@PlayerOptionsClass@@QAEHXZ ; PlayerOptionsClass::AutoTargetingOn
	test	eax, eax
	je	SHORT $LN3@InitSimOpt
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@InitSimOpt
$LN3@InitSimOpt:
	mov	DWORD PTR tv68[ebp], 0
$LN4@InitSimOpt:
	mov	eax, DWORD PTR tv68[ebp]
	push	eax
	push	1000					; 000003e8H
	mov	ecx, DWORD PTR _hDlg$[ebp]
	push	ecx
	call	DWORD PTR __imp__CheckDlgButton@12

; 13   :    CheckDlgButton (hDlg, IDC_SIMOPTION_BLACKOUT,   PlayerOptions.BlackoutOn() ? BST_CHECKED : BST_UNCHECKED);

	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?BlackoutOn@PlayerOptionsClass@@QAEHXZ	; PlayerOptionsClass::BlackoutOn
	test	eax, eax
	je	SHORT $LN5@InitSimOpt
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN6@InitSimOpt
$LN5@InitSimOpt:
	mov	DWORD PTR tv75[ebp], 0
$LN6@InitSimOpt:
	mov	edx, DWORD PTR tv75[ebp]
	push	edx
	push	1001					; 000003e9H
	mov	eax, DWORD PTR _hDlg$[ebp]
	push	eax
	call	DWORD PTR __imp__CheckDlgButton@12

; 14   :    CheckDlgButton (hDlg, IDC_SIMOPTION_FUEL,       PlayerOptions.UnlimitedFuel() ? BST_CHECKED : BST_UNCHECKED);

	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?UnlimitedFuel@PlayerOptionsClass@@QAEHXZ ; PlayerOptionsClass::UnlimitedFuel
	test	eax, eax
	je	SHORT $LN7@InitSimOpt
	mov	DWORD PTR tv82[ebp], 1
	jmp	SHORT $LN8@InitSimOpt
$LN7@InitSimOpt:
	mov	DWORD PTR tv82[ebp], 0
$LN8@InitSimOpt:
	mov	ecx, DWORD PTR tv82[ebp]
	push	ecx
	push	1002					; 000003eaH
	mov	edx, DWORD PTR _hDlg$[ebp]
	push	edx
	call	DWORD PTR __imp__CheckDlgButton@12

; 15   :    CheckDlgButton (hDlg, IDC_SIMOPTION_AMMO,       PlayerOptions.UnlimitedAmmo() ? BST_CHECKED : BST_UNCHECKED);

	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?UnlimitedAmmo@PlayerOptionsClass@@QAEHXZ ; PlayerOptionsClass::UnlimitedAmmo
	test	eax, eax
	je	SHORT $LN9@InitSimOpt
	mov	DWORD PTR tv89[ebp], 1
	jmp	SHORT $LN10@InitSimOpt
$LN9@InitSimOpt:
	mov	DWORD PTR tv89[ebp], 0
$LN10@InitSimOpt:
	mov	eax, DWORD PTR tv89[ebp]
	push	eax
	push	1003					; 000003ebH
	mov	ecx, DWORD PTR _hDlg$[ebp]
	push	ecx
	call	DWORD PTR __imp__CheckDlgButton@12

; 16   :    CheckDlgButton (hDlg, IDC_SIMOPTION_CHAFF,      PlayerOptions.UnlimitedChaff() ? BST_CHECKED : BST_UNCHECKED);

	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?UnlimitedChaff@PlayerOptionsClass@@QAEHXZ ; PlayerOptionsClass::UnlimitedChaff
	test	eax, eax
	je	SHORT $LN11@InitSimOpt
	mov	DWORD PTR tv128[ebp], 1
	jmp	SHORT $LN12@InitSimOpt
$LN11@InitSimOpt:
	mov	DWORD PTR tv128[ebp], 0
$LN12@InitSimOpt:
	mov	edx, DWORD PTR tv128[ebp]
	push	edx
	push	1004					; 000003ecH
	mov	eax, DWORD PTR _hDlg$[ebp]
	push	eax
	call	DWORD PTR __imp__CheckDlgButton@12

; 17   :    CheckDlgButton (hDlg, IDC_SIMOPTION_COLLISION,  PlayerOptions.CollisionsOn() ? BST_CHECKED : BST_UNCHECKED);

	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?CollisionsOn@PlayerOptionsClass@@QAEHXZ ; PlayerOptionsClass::CollisionsOn
	test	eax, eax
	je	SHORT $LN13@InitSimOpt
	mov	DWORD PTR tv135[ebp], 1
	jmp	SHORT $LN14@InitSimOpt
$LN13@InitSimOpt:
	mov	DWORD PTR tv135[ebp], 0
$LN14@InitSimOpt:
	mov	ecx, DWORD PTR tv135[ebp]
	push	ecx
	push	1005					; 000003edH
	mov	edx, DWORD PTR _hDlg$[ebp]
	push	edx
	call	DWORD PTR __imp__CheckDlgButton@12

; 18   :    CheckDlgButton (hDlg, IDC_SIMOPTION_NAMETAGS,   PlayerOptions.NameTagsOn() ? BST_CHECKED : BST_UNCHECKED);

	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?NameTagsOn@PlayerOptionsClass@@QAEHXZ	; PlayerOptionsClass::NameTagsOn
	test	eax, eax
	je	SHORT $LN15@InitSimOpt
	mov	DWORD PTR tv142[ebp], 1
	jmp	SHORT $LN16@InitSimOpt
$LN15@InitSimOpt:
	mov	DWORD PTR tv142[ebp], 0
$LN16@InitSimOpt:
	mov	eax, DWORD PTR tv142[ebp]
	push	eax
	push	1006					; 000003eeH
	mov	ecx, DWORD PTR _hDlg$[ebp]
	push	ecx
	call	DWORD PTR __imp__CheckDlgButton@12

; 19   : 
; 20   :    // Flight Model
; 21   :    SendDlgItemMessage (hDlg, IDC_SIMOPTION_FLIGHTMODEL, CB_ADDSTRING,
; 22   :    0, (LPARAM)"Simple");

	push	OFFSET ??_C@_06MIPDDPP@Simple?$AA@
	push	0
	push	323					; 00000143H
	push	1007					; 000003efH
	mov	edx, DWORD PTR _hDlg$[ebp]
	push	edx
	call	DWORD PTR __imp__SendDlgItemMessageA@20

; 23   :    SendDlgItemMessage (hDlg, IDC_SIMOPTION_FLIGHTMODEL, CB_ADDSTRING,
; 24   :    0, (LPARAM)"Moderate");

	push	OFFSET ??_C@_08FDNKDHKO@Moderate?$AA@
	push	0
	push	323					; 00000143H
	push	1007					; 000003efH
	mov	eax, DWORD PTR _hDlg$[ebp]
	push	eax
	call	DWORD PTR __imp__SendDlgItemMessageA@20

; 25   :    SendDlgItemMessage (hDlg, IDC_SIMOPTION_FLIGHTMODEL, CB_ADDSTRING,
; 26   :    0, (LPARAM)"Acurate");

	push	OFFSET ??_C@_07NFKBFEEI@Acurate?$AA@
	push	0
	push	323					; 00000143H
	push	1007					; 000003efH
	mov	ecx, DWORD PTR _hDlg$[ebp]
	push	ecx
	call	DWORD PTR __imp__SendDlgItemMessageA@20

; 27   :    SendDlgItemMessage (hDlg, IDC_SIMOPTION_FLIGHTMODEL, CB_SETCURSEL,
; 28   :       PlayerOptions.GetFlightModelType(), 0);

	push	0
	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?GetFlightModelType@PlayerOptionsClass@@QAEHXZ ; PlayerOptionsClass::GetFlightModelType
	push	eax
	push	334					; 0000014eH
	push	1007					; 000003efH
	mov	edx, DWORD PTR _hDlg$[ebp]
	push	edx
	call	DWORD PTR __imp__SendDlgItemMessageA@20

; 29   : 
; 30   :    // Weapon Model
; 31   :    SendDlgItemMessage (hDlg, IDC_SIMOPTION_WEAPONEFFECT, CB_ADDSTRING,
; 32   :    0, (LPARAM)"Exaggerated");

	push	OFFSET ??_C@_0M@CEOEGBJB@Exaggerated?$AA@
	push	0
	push	323					; 00000143H
	push	1008					; 000003f0H
	mov	eax, DWORD PTR _hDlg$[ebp]
	push	eax
	call	DWORD PTR __imp__SendDlgItemMessageA@20

; 33   :    SendDlgItemMessage (hDlg, IDC_SIMOPTION_WEAPONEFFECT, CB_ADDSTRING,
; 34   :    0, (LPARAM)"Enhanced");

	push	OFFSET ??_C@_08HDHPPHEE@Enhanced?$AA@
	push	0
	push	323					; 00000143H
	push	1008					; 000003f0H
	mov	ecx, DWORD PTR _hDlg$[ebp]
	push	ecx
	call	DWORD PTR __imp__SendDlgItemMessageA@20

; 35   :    SendDlgItemMessage (hDlg, IDC_SIMOPTION_WEAPONEFFECT, CB_ADDSTRING,
; 36   :    0, (LPARAM)"Acurate");

	push	OFFSET ??_C@_07NFKBFEEI@Acurate?$AA@
	push	0
	push	323					; 00000143H
	push	1008					; 000003f0H
	mov	edx, DWORD PTR _hDlg$[ebp]
	push	edx
	call	DWORD PTR __imp__SendDlgItemMessageA@20

; 37   :    SendDlgItemMessage (hDlg, IDC_SIMOPTION_WEAPONEFFECT, CB_SETCURSEL,
; 38   :       PlayerOptions.GetWeaponEffectiveness(), 0);

	push	0
	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?GetWeaponEffectiveness@PlayerOptionsClass@@QAEHXZ ; PlayerOptionsClass::GetWeaponEffectiveness
	push	eax
	push	334					; 0000014eH
	push	1008					; 000003f0H
	mov	eax, DWORD PTR _hDlg$[ebp]
	push	eax
	call	DWORD PTR __imp__SendDlgItemMessageA@20

; 39   : 
; 40   :    // Radar Model
; 41   :    SendDlgItemMessage (hDlg, IDC_SIMOPTION_RADARTYPE, CB_ADDSTRING,
; 42   :    0, (LPARAM)"360");

	push	OFFSET ??_C@_03MDIFNIHN@360?$AA@
	push	0
	push	323					; 00000143H
	push	1009					; 000003f1H
	mov	ecx, DWORD PTR _hDlg$[ebp]
	push	ecx
	call	DWORD PTR __imp__SendDlgItemMessageA@20

; 43   :    SendDlgItemMessage (hDlg, IDC_SIMOPTION_RADARTYPE, CB_ADDSTRING,
; 44   :    0, (LPARAM)"Easy");

	push	OFFSET ??_C@_04ICBOFLAL@Easy?$AA@
	push	0
	push	323					; 00000143H
	push	1009					; 000003f1H
	mov	edx, DWORD PTR _hDlg$[ebp]
	push	edx
	call	DWORD PTR __imp__SendDlgItemMessageA@20

; 45   :    SendDlgItemMessage (hDlg, IDC_SIMOPTION_RADARTYPE, CB_ADDSTRING,
; 46   :    0, (LPARAM)"APG 68");

	push	OFFSET ??_C@_06PBPJFIAF@APG?568?$AA@
	push	0
	push	323					; 00000143H
	push	1009					; 000003f1H
	mov	eax, DWORD PTR _hDlg$[ebp]
	push	eax
	call	DWORD PTR __imp__SendDlgItemMessageA@20

; 47   :    SendDlgItemMessage (hDlg, IDC_SIMOPTION_RADARTYPE, CB_SETCURSEL,
; 48   :       PlayerOptions.GetAvionicsType(), 0);

	push	0
	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?GetAvionicsType@PlayerOptionsClass@@QAEHXZ ; PlayerOptionsClass::GetAvionicsType
	push	eax
	push	334					; 0000014eH
	push	1009					; 000003f1H
	mov	ecx, DWORD PTR _hDlg$[ebp]
	push	ecx
	call	DWORD PTR __imp__SendDlgItemMessageA@20

; 49   : 
; 50   :    // Autopilot
; 51   :    SendDlgItemMessage (hDlg, IDC_SIMOPTION_AUTOPILOT, CB_ADDSTRING,
; 52   :    0, (LPARAM)"Intelligent");

	push	OFFSET ??_C@_0M@IENNDIF@Intelligent?$AA@
	push	0
	push	323					; 00000143H
	push	1010					; 000003f2H
	mov	edx, DWORD PTR _hDlg$[ebp]
	push	edx
	call	DWORD PTR __imp__SendDlgItemMessageA@20

; 53   :    SendDlgItemMessage (hDlg, IDC_SIMOPTION_AUTOPILOT, CB_ADDSTRING,
; 54   :    0, (LPARAM)"Enhanced");

	push	OFFSET ??_C@_08HDHPPHEE@Enhanced?$AA@
	push	0
	push	323					; 00000143H
	push	1010					; 000003f2H
	mov	eax, DWORD PTR _hDlg$[ebp]
	push	eax
	call	DWORD PTR __imp__SendDlgItemMessageA@20

; 55   :    SendDlgItemMessage (hDlg, IDC_SIMOPTION_AUTOPILOT, CB_ADDSTRING,
; 56   :    0, (LPARAM)"Normal");

	push	OFFSET ??_C@_06EFAGIKOH@Normal?$AA@
	push	0
	push	323					; 00000143H
	push	1010					; 000003f2H
	mov	ecx, DWORD PTR _hDlg$[ebp]
	push	ecx
	call	DWORD PTR __imp__SendDlgItemMessageA@20

; 57   :    SendDlgItemMessage (hDlg, IDC_SIMOPTION_AUTOPILOT, CB_SETCURSEL,
; 58   :       PlayerOptions.GetAutopilotMode(), 0);

	push	0
	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?GetAutopilotMode@PlayerOptionsClass@@QAEHXZ ; PlayerOptionsClass::GetAutopilotMode
	push	eax
	push	334					; 0000014eH
	push	1010					; 000003f2H
	mov	edx, DWORD PTR _hDlg$[ebp]
	push	edx
	call	DWORD PTR __imp__SendDlgItemMessageA@20

; 59   : 
; 60   :    // Detail levels
; 61   :    SendDlgItemMessage (hDlg, IDC_SIMOPTION_FEAT_DETAIL, TBM_SETRANGE, 0, (LPARAM)MAKELONG(0,4));

	push	262144					; 00040000H
	push	0
	push	1030					; 00000406H
	push	1321					; 00000529H
	mov	eax, DWORD PTR _hDlg$[ebp]
	push	eax
	call	DWORD PTR __imp__SendDlgItemMessageA@20

; 62   :    SendDlgItemMessage (hDlg, IDC_SIMOPTION_VEH_DETAIL, TBM_SETRANGE, 0, (LPARAM)MAKELONG(0,15));

	push	983040					; 000f0000H
	push	0
	push	1030					; 00000406H
	push	1322					; 0000052aH
	mov	ecx, DWORD PTR _hDlg$[ebp]
	push	ecx
	call	DWORD PTR __imp__SendDlgItemMessageA@20

; 63   :    SendDlgItemMessage (hDlg, IDC_SIMOPTION_MAGNIFICATION, TBM_SETRANGE, 0, (LPARAM)MAKELONG(0,9));

	push	589824					; 00090000H
	push	0
	push	1030					; 00000406H
	push	1319					; 00000527H
	mov	edx, DWORD PTR _hDlg$[ebp]
	push	edx
	call	DWORD PTR __imp__SendDlgItemMessageA@20

; 64   :    SendDlgItemMessage (hDlg, IDC_SIMOPTION_FEAT_DETAIL, TBM_SETPOS, (WPARAM)TRUE, (LPARAM)PlayerOptions.BldDeaggLevel);

	mov	eax, DWORD PTR ?PlayerOptions@@3VPlayerOptionsClass@@A+28
	push	eax
	push	1
	push	1029					; 00000405H
	push	1321					; 00000529H
	mov	ecx, DWORD PTR _hDlg$[ebp]
	push	ecx
	call	DWORD PTR __imp__SendDlgItemMessageA@20

; 65   :    SendDlgItemMessage (hDlg, IDC_SIMOPTION_VEH_DETAIL, TBM_SETPOS, (WPARAM)TRUE, (LPARAM)PlayerOptions.ObjDeaggLevel);

	mov	edx, DWORD PTR ?PlayerOptions@@3VPlayerOptionsClass@@A+24
	push	edx
	push	1
	push	1029					; 00000405H
	push	1322					; 0000052aH
	mov	eax, DWORD PTR _hDlg$[ebp]
	push	eax
	call	DWORD PTR __imp__SendDlgItemMessageA@20

; 66   :    SendDlgItemMessage (hDlg, IDC_SIMOPTION_MAGNIFICATION, TBM_SETPOS, (WPARAM)TRUE, (LPARAM)PlayerOptions.ObjMagnification);

	cvttss2si ecx, DWORD PTR ?PlayerOptions@@3VPlayerOptionsClass@@A+20
	push	ecx
	push	1
	push	1029					; 00000405H
	push	1319					; 00000527H
	mov	edx, DWORD PTR _hDlg$[ebp]
	push	edx
	call	DWORD PTR __imp__SendDlgItemMessageA@20

; 67   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?InitSimOptionStuff@@YAXPAUHWND__@@@Z ENDP		; InitSimOptionStuff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\playerop.h
;	COMDAT ?ClearSimFlag@PlayerOptionsClass@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_flag$ = 8						; size = 4
?ClearSimFlag@PlayerOptionsClass@@QAEXH@Z PROC		; PlayerOptionsClass::ClearSimFlag, COMDAT
; _this$ = ecx

; 188  : 	void ClearSimFlag (int flag)							{SimFlags &= ~flag;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _flag$[ebp]
	not	eax
	mov	ecx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [ecx+52]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+52], eax
	mov	esp, ebp
	pop	ebp
	ret	4
?ClearSimFlag@PlayerOptionsClass@@QAEXH@Z ENDP		; PlayerOptionsClass::ClearSimFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\playerop.h
;	COMDAT ?SetSimFlag@PlayerOptionsClass@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_flag$ = 8						; size = 4
?SetSimFlag@PlayerOptionsClass@@QAEXH@Z PROC		; PlayerOptionsClass::SetSimFlag, COMDAT
; _this$ = ecx

; 187  : 	void SetSimFlag (int flag)								{SimFlags |= flag;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	or	ecx, DWORD PTR _flag$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+52], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSimFlag@PlayerOptionsClass@@QAEXH@Z ENDP		; PlayerOptionsClass::SetSimFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\playerop.h
;	COMDAT ?NameTagsOn@PlayerOptionsClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
?NameTagsOn@PlayerOptionsClass@@QAEHXZ PROC		; PlayerOptionsClass::NameTagsOn, COMDAT
; _this$ = ecx

; 155  : 	int NameTagsOn (void)									{ return (SimFlags & SIM_NAMETAGS) && TRUE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	and	ecx, 64					; 00000040H
	je	SHORT $LN3@NameTagsOn
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN3@NameTagsOn
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@NameTagsOn
$LN3@NameTagsOn:
	mov	DWORD PTR tv68[ebp], 0
$LN4@NameTagsOn:
	mov	eax, DWORD PTR tv68[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?NameTagsOn@PlayerOptionsClass@@QAEHXZ ENDP		; PlayerOptionsClass::NameTagsOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\playerop.h
;	COMDAT ?CollisionsOn@PlayerOptionsClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
?CollisionsOn@PlayerOptionsClass@@QAEHXZ PROC		; PlayerOptionsClass::CollisionsOn, COMDAT
; _this$ = ecx

; 153  : 	int CollisionsOn (void)									{ return !(SimFlags & SIM_NO_COLLISIONS) && TRUE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	and	ecx, 32					; 00000020H
	jne	SHORT $LN3@Collisions
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN3@Collisions
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@Collisions
$LN3@Collisions:
	mov	DWORD PTR tv68[ebp], 0
$LN4@Collisions:
	mov	eax, DWORD PTR tv68[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?CollisionsOn@PlayerOptionsClass@@QAEHXZ ENDP		; PlayerOptionsClass::CollisionsOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\playerop.h
;	COMDAT ?UnlimitedChaff@PlayerOptionsClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
?UnlimitedChaff@PlayerOptionsClass@@QAEHXZ PROC		; PlayerOptionsClass::UnlimitedChaff, COMDAT
; _this$ = ecx

; 152  : 	int UnlimitedChaff (void)								{ return (SimFlags & SIM_UNLIMITED_CHAFF) && TRUE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	and	ecx, 16					; 00000010H
	je	SHORT $LN3@UnlimitedC
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN3@UnlimitedC
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@UnlimitedC
$LN3@UnlimitedC:
	mov	DWORD PTR tv68[ebp], 0
$LN4@UnlimitedC:
	mov	eax, DWORD PTR tv68[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?UnlimitedChaff@PlayerOptionsClass@@QAEHXZ ENDP		; PlayerOptionsClass::UnlimitedChaff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\playerop.h
;	COMDAT ?UnlimitedAmmo@PlayerOptionsClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
?UnlimitedAmmo@PlayerOptionsClass@@QAEHXZ PROC		; PlayerOptionsClass::UnlimitedAmmo, COMDAT
; _this$ = ecx

; 151  : 	int UnlimitedAmmo (void)								{ return (SimFlags & SIM_UNLIMITED_AMMO) && TRUE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	and	ecx, 8
	je	SHORT $LN3@UnlimitedA
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN3@UnlimitedA
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@UnlimitedA
$LN3@UnlimitedA:
	mov	DWORD PTR tv68[ebp], 0
$LN4@UnlimitedA:
	mov	eax, DWORD PTR tv68[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?UnlimitedAmmo@PlayerOptionsClass@@QAEHXZ ENDP		; PlayerOptionsClass::UnlimitedAmmo
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\playerop.h
;	COMDAT ?UnlimitedFuel@PlayerOptionsClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
?UnlimitedFuel@PlayerOptionsClass@@QAEHXZ PROC		; PlayerOptionsClass::UnlimitedFuel, COMDAT
; _this$ = ecx

; 150  : 	int UnlimitedFuel (void)								{ return (SimFlags & SIM_UNLIMITED_FUEL) && TRUE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	and	ecx, 4
	je	SHORT $LN3@UnlimitedF
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN3@UnlimitedF
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@UnlimitedF
$LN3@UnlimitedF:
	mov	DWORD PTR tv68[ebp], 0
$LN4@UnlimitedF:
	mov	eax, DWORD PTR tv68[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?UnlimitedFuel@PlayerOptionsClass@@QAEHXZ ENDP		; PlayerOptionsClass::UnlimitedFuel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\playerop.h
;	COMDAT ?BlackoutOn@PlayerOptionsClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
?BlackoutOn@PlayerOptionsClass@@QAEHXZ PROC		; PlayerOptionsClass::BlackoutOn, COMDAT
; _this$ = ecx

; 148  : 	int BlackoutOn (void)									{ return !(SimFlags & SIM_NO_BLACKOUT) && TRUE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	and	ecx, 2
	jne	SHORT $LN3@BlackoutOn
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN3@BlackoutOn
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@BlackoutOn
$LN3@BlackoutOn:
	mov	DWORD PTR tv68[ebp], 0
$LN4@BlackoutOn:
	mov	eax, DWORD PTR tv68[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?BlackoutOn@PlayerOptionsClass@@QAEHXZ ENDP		; PlayerOptionsClass::BlackoutOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\playerop.h
;	COMDAT ?AutoTargetingOn@PlayerOptionsClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
?AutoTargetingOn@PlayerOptionsClass@@QAEHXZ PROC	; PlayerOptionsClass::AutoTargetingOn, COMDAT
; _this$ = ecx

; 147  : 	int AutoTargetingOn (void)								{ return (SimFlags & SIM_AUTO_TARGET) && TRUE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	and	ecx, 1
	je	SHORT $LN3@AutoTarget
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN3@AutoTarget
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@AutoTarget
$LN3@AutoTarget:
	mov	DWORD PTR tv68[ebp], 0
$LN4@AutoTarget:
	mov	eax, DWORD PTR tv68[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?AutoTargetingOn@PlayerOptionsClass@@QAEHXZ ENDP	; PlayerOptionsClass::AutoTargetingOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\playerop.h
;	COMDAT ?GetAutopilotMode@PlayerOptionsClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAutopilotMode@PlayerOptionsClass@@QAEHXZ PROC	; PlayerOptionsClass::GetAutopilotMode, COMDAT
; _this$ = ecx

; 143  : 	int GetAutopilotMode (void)								{ return SimAutopilotType; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+68]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetAutopilotMode@PlayerOptionsClass@@QAEHXZ ENDP	; PlayerOptionsClass::GetAutopilotMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\playerop.h
;	COMDAT ?GetAvionicsType@PlayerOptionsClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAvionicsType@PlayerOptionsClass@@QAEHXZ PROC	; PlayerOptionsClass::GetAvionicsType, COMDAT
; _this$ = ecx

; 142  : 	int GetAvionicsType (void)								{ return SimAvionicsType; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+64]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetAvionicsType@PlayerOptionsClass@@QAEHXZ ENDP	; PlayerOptionsClass::GetAvionicsType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\playerop.h
;	COMDAT ?GetWeaponEffectiveness@PlayerOptionsClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWeaponEffectiveness@PlayerOptionsClass@@QAEHXZ PROC	; PlayerOptionsClass::GetWeaponEffectiveness, COMDAT
; _this$ = ecx

; 141  : 	int GetWeaponEffectiveness (void)						{ return SimWeaponEffect; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+60]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetWeaponEffectiveness@PlayerOptionsClass@@QAEHXZ ENDP	; PlayerOptionsClass::GetWeaponEffectiveness
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\playerop.h
;	COMDAT ?GetFlightModelType@PlayerOptionsClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFlightModelType@PlayerOptionsClass@@QAEHXZ PROC	; PlayerOptionsClass::GetFlightModelType, COMDAT
; _this$ = ecx

; 140  : 	int GetFlightModelType (void)							{ return SimFlightModel; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+56]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFlightModelType@PlayerOptionsClass@@QAEHXZ ENDP	; PlayerOptionsClass::GetFlightModelType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
END
