; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\UI\SRC\comms\stats.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
PUBLIC	??0PlayerStats@@QAE@XZ				; PlayerStats::PlayerStats
PUBLIC	??1PlayerStats@@QAE@XZ				; PlayerStats::~PlayerStats
PUBLIC	?LoadStats@PlayerStats@@QAEXXZ			; PlayerStats::LoadStats
PUBLIC	?SaveStats@PlayerStats@@QAEXXZ			; PlayerStats::SaveStats
PUBLIC	?AddStat@PlayerStats@@QAEXJJJFFFFFD@Z		; PlayerStats::AddStat
PUBLIC	?Find@PlayerStats@@QAEPAUStatList@@JJJ@Z	; PlayerStats::Find
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
PUBLIC	??_C@_02GMLFBBN@wb?$AA@				; `string'
PUBLIC	__real@00000000
PUBLIC	__real@3f000000
PUBLIC	__real@41c80000
PUBLIC	__real@42c80000
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_fclose:PROC
EXTRN	_fopen:PROC
EXTRN	_fread:PROC
EXTRN	_fwrite:PROC
EXTRN	?EncryptBuffer@@YAXEPAEJ@Z:PROC			; EncryptBuffer
EXTRN	?DecryptBuffer@@YAXEPAEJ@Z:PROC			; DecryptBuffer
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
_allocator_arg DB 01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@41c80000
CONST	SEGMENT
__real@41c80000 DD 041c80000r			; 25
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_02GMLFBBN@wb?$AA@
CONST	SEGMENT
??_C@_02GMLFBBN@wb?$AA@ DB 'wb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
CONST	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\comms\stats.cpp
_TEXT	SEGMENT
_this$ = -12						; size = 4
_Found$ = -8						; size = 4
_cur$ = -4						; size = 4
_IP$ = 8						; size = 4
_Date$ = 12						; size = 4
_Rev$ = 16						; size = 4
?Find@PlayerStats@@QAEPAUStatList@@JJJ@Z PROC		; PlayerStats::Find
; _this$ = ecx

; 167  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 168  : 	StatList *cur,*Found;
; 169  : 
; 170  : 	Found=NULL;

	mov	DWORD PTR _Found$[ebp], 0

; 171  : 	cur=Root_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _cur$[ebp], ecx
$LN3@Find:

; 172  : 	while(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN2@Find

; 173  : 	{
; 174  : 		if(cur->data.IP == IP && cur->data.Date == Date && cur->data.Rev <= Rev)

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _IP$[ebp]
	jne	SHORT $LN1@Find
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _Date$[ebp]
	jne	SHORT $LN1@Find
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR _Rev$[ebp]
	jg	SHORT $LN1@Find

; 175  : 		{
; 176  : 			Found=cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _Found$[ebp], edx
$LN1@Find:

; 177  : 		}
; 178  : 		cur=cur->Next;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _cur$[ebp], ecx

; 179  : 	}

	jmp	SHORT $LN3@Find
$LN2@Find:

; 180  : 	return(Found);

	mov	eax, DWORD PTR _Found$[ebp]

; 181  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?Find@PlayerStats@@QAEPAUStatList@@JJJ@Z ENDP		; PlayerStats::Find
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\comms\stats.cpp
_TEXT	SEGMENT
$T1 = -16						; size = 4
_this$ = -12						; size = 4
_newrec$ = -8						; size = 4
_cur$ = -4						; size = 4
_IP$ = 8						; size = 4
_Date$ = 12						; size = 4
_Rev$ = 16						; size = 4
_aa$ = 20						; size = 2
_ag$ = 24						; size = 2
_an$ = 28						; size = 2
_as$ = 32						; size = 2
_missions$ = 36						; size = 2
_rating$ = 40						; size = 1
?AddStat@PlayerStats@@QAEXJJJFFFFFD@Z PROC		; PlayerStats::AddStat
; _this$ = ecx

; 112  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 113  : 	StatList *newrec,*cur;
; 114  : 
; 115  : 	if(!aa && ! ag && !an && !as && !missions && !rating)

	movsx	eax, WORD PTR _aa$[ebp]
	test	eax, eax
	jne	SHORT $LN8@AddStat
	movsx	ecx, WORD PTR _ag$[ebp]
	test	ecx, ecx
	jne	SHORT $LN8@AddStat
	movsx	edx, WORD PTR _an$[ebp]
	test	edx, edx
	jne	SHORT $LN8@AddStat
	movsx	eax, WORD PTR _as$[ebp]
	test	eax, eax
	jne	SHORT $LN8@AddStat
	movsx	ecx, WORD PTR _missions$[ebp]
	test	ecx, ecx
	jne	SHORT $LN8@AddStat
	movsx	edx, BYTE PTR _rating$[ebp]
	test	edx, edx
	jne	SHORT $LN8@AddStat

; 116  : 		return;

	jmp	$LN9@AddStat
$LN8@AddStat:

; 117  : 
; 118  : 	cur=Find(IP,Date,Rev);

	mov	eax, DWORD PTR _Rev$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Date$[ebp]
	push	ecx
	mov	edx, DWORD PTR _IP$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Find@PlayerStats@@QAEPAUStatList@@JJJ@Z ; PlayerStats::Find
	mov	DWORD PTR _cur$[ebp], eax

; 119  : 	if(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	$LN7@AddStat

; 120  : 	{
; 121  : 		if( cur->data.aa_kills == aa && 
; 122  : 			cur->data.ag_kills == ag &&
; 123  : 			cur->data.an_kills == an &&
; 124  : 			cur->data.as_kills == as &&
; 125  : 			cur->data.missions == missions &&
; 126  : 			cur->data.rating == rating ) // No reason to save if nothing changed

	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, WORD PTR [eax+12]
	movsx	edx, WORD PTR _aa$[ebp]
	cmp	ecx, edx
	jne	SHORT $LN6@AddStat
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, WORD PTR [eax+14]
	movsx	edx, WORD PTR _ag$[ebp]
	cmp	ecx, edx
	jne	SHORT $LN6@AddStat
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, WORD PTR [eax+16]
	movsx	edx, WORD PTR _an$[ebp]
	cmp	ecx, edx
	jne	SHORT $LN6@AddStat
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, WORD PTR [eax+18]
	movsx	edx, WORD PTR _as$[ebp]
	cmp	ecx, edx
	jne	SHORT $LN6@AddStat
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, WORD PTR [eax+20]
	movsx	edx, WORD PTR _missions$[ebp]
	cmp	ecx, edx
	jne	SHORT $LN6@AddStat
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax+22]
	movsx	edx, BYTE PTR _rating$[ebp]
	cmp	ecx, edx
	jne	SHORT $LN6@AddStat

; 127  : 				return;

	jmp	$LN9@AddStat
$LN6@AddStat:

; 128  : 		if(cur->data.IP == IP && cur->data.Date == Date && cur->data.Rev == Rev)

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _IP$[ebp]
	jne	SHORT $LN7@AddStat
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR _Date$[ebp]
	jne	SHORT $LN7@AddStat
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR _Rev$[ebp]
	jne	SHORT $LN7@AddStat

; 129  : 		{
; 130  : 			cur->data.aa_kills=aa;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	cx, WORD PTR _aa$[ebp]
	mov	WORD PTR [eax+12], cx

; 131  : 			cur->data.ag_kills=ag;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	ax, WORD PTR _ag$[ebp]
	mov	WORD PTR [edx+14], ax

; 132  : 			cur->data.an_kills=an;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	dx, WORD PTR _an$[ebp]
	mov	WORD PTR [ecx+16], dx

; 133  : 			cur->data.as_kills=as;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	cx, WORD PTR _as$[ebp]
	mov	WORD PTR [eax+18], cx

; 134  : 			cur->data.missions=missions;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	ax, WORD PTR _missions$[ebp]
	mov	WORD PTR [edx+20], ax

; 135  : 			cur->data.rating=rating;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	dl, BYTE PTR _rating$[ebp]
	mov	BYTE PTR [ecx+22], dl

; 136  : 			SaveStats();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SaveStats@PlayerStats@@QAEXXZ		; PlayerStats::SaveStats

; 137  : 			return;

	jmp	$LN9@AddStat
$LN7@AddStat:

; 138  : 		}
; 139  : 	}
; 140  : 	newrec=new StatList;

	push	28					; 0000001cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR _newrec$[ebp], eax

; 141  : 	newrec->Next=NULL;

	mov	ecx, DWORD PTR _newrec$[ebp]
	mov	DWORD PTR [ecx+24], 0

; 142  : 
; 143  : 	newrec->data.IP=IP;

	mov	edx, DWORD PTR _newrec$[ebp]
	mov	eax, DWORD PTR _IP$[ebp]
	mov	DWORD PTR [edx], eax

; 144  : 	newrec->data.Date=Date;

	mov	ecx, DWORD PTR _newrec$[ebp]
	mov	edx, DWORD PTR _Date$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 145  : 	newrec->data.Rev=Rev;

	mov	eax, DWORD PTR _newrec$[ebp]
	mov	ecx, DWORD PTR _Rev$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 146  : 	newrec->data.aa_kills=aa;

	mov	edx, DWORD PTR _newrec$[ebp]
	mov	ax, WORD PTR _aa$[ebp]
	mov	WORD PTR [edx+12], ax

; 147  : 	newrec->data.ag_kills=ag;

	mov	ecx, DWORD PTR _newrec$[ebp]
	mov	dx, WORD PTR _ag$[ebp]
	mov	WORD PTR [ecx+14], dx

; 148  : 	newrec->data.an_kills=an;

	mov	eax, DWORD PTR _newrec$[ebp]
	mov	cx, WORD PTR _an$[ebp]
	mov	WORD PTR [eax+16], cx

; 149  : 	newrec->data.as_kills=as;

	mov	edx, DWORD PTR _newrec$[ebp]
	mov	ax, WORD PTR _as$[ebp]
	mov	WORD PTR [edx+18], ax

; 150  : 	newrec->data.missions=missions;

	mov	ecx, DWORD PTR _newrec$[ebp]
	mov	dx, WORD PTR _missions$[ebp]
	mov	WORD PTR [ecx+20], dx

; 151  : 	newrec->data.rating=rating;

	mov	eax, DWORD PTR _newrec$[ebp]
	mov	cl, BYTE PTR _rating$[ebp]
	mov	BYTE PTR [eax+22], cl

; 152  : 	newrec->data.CheckSum=0;

	mov	edx, DWORD PTR _newrec$[ebp]
	mov	BYTE PTR [edx+23], 0

; 153  : 
; 154  : 	if(!Root_)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN4@AddStat

; 155  : 		Root_=newrec;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _newrec$[ebp]
	mov	DWORD PTR [ecx], edx

; 156  : 	else

	jmp	SHORT $LN3@AddStat
$LN4@AddStat:

; 157  : 	{
; 158  : 		cur=Root_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _cur$[ebp], ecx
$LN2@AddStat:

; 159  : 		while(cur->Next)

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+24], 0
	je	SHORT $LN1@AddStat

; 160  : 			cur=cur->Next;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _cur$[ebp], ecx
	jmp	SHORT $LN2@AddStat
$LN1@AddStat:

; 161  : 		cur->Next=newrec;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR _newrec$[ebp]
	mov	DWORD PTR [edx+24], eax
$LN3@AddStat:

; 162  : 	}
; 163  : 	SaveStats();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SaveStats@PlayerStats@@QAEXXZ		; PlayerStats::SaveStats
$LN9@AddStat:

; 164  : }

	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
?AddStat@PlayerStats@@QAEXJJJFFFFFD@Z ENDP		; PlayerStats::AddStat
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\comms\stats.cpp
_TEXT	SEGMENT
_fp$ = -40						; size = 4
_this$ = -36						; size = 4
_cur$ = -32						; size = 4
_rec$ = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
?SaveStats@PlayerStats@@QAEXXZ PROC			; PlayerStats::SaveStats
; _this$ = ecx

; 88   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 89   : 	StatRec rec;
; 90   : 	StatList *cur;
; 91   : 	FILE *fp;
; 92   : 
; 93   : 	if(!Root_)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN4@SaveStats

; 94   : 		return;

	jmp	SHORT $LN5@SaveStats
$LN4@SaveStats:

; 95   : 
; 96   : 	fp=fopen(SaveName_,"wb");

	push	OFFSET ??_C@_02GMLFBBN@wb?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	push	ecx
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$[ebp], eax

; 97   : 	if(fp)

	cmp	DWORD PTR _fp$[ebp], 0
	je	SHORT $LN5@SaveStats

; 98   : 	{
; 99   : 		cur=Root_;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _cur$[ebp], eax
$LN2@SaveStats:

; 100  : 		while(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN1@SaveStats

; 101  : 		{
; 102  : 			memcpy(&rec,&cur->data,sizeof(StatRec));

	push	24					; 00000018H
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	lea	edx, DWORD PTR _rec$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 103  : 			EncryptBuffer(0x25,(uchar*)&rec,sizeof(StatRec));

	push	24					; 00000018H
	lea	eax, DWORD PTR _rec$[ebp]
	push	eax
	push	37					; 00000025H
	call	?EncryptBuffer@@YAXEPAEJ@Z		; EncryptBuffer
	add	esp, 12					; 0000000cH

; 104  : 			fwrite(&rec,sizeof(StatRec),1,fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	push	1
	push	24					; 00000018H
	lea	edx, DWORD PTR _rec$[ebp]
	push	edx
	call	_fwrite
	add	esp, 16					; 00000010H

; 105  : 			cur=cur->Next;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _cur$[ebp], ecx

; 106  : 		}

	jmp	SHORT $LN2@SaveStats
$LN1@SaveStats:

; 107  : 		fclose(fp);

	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_fclose
	add	esp, 4
$LN5@SaveStats:

; 108  : 	}
; 109  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?SaveStats@PlayerStats@@QAEXXZ ENDP			; PlayerStats::SaveStats
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\comms\stats.cpp
_TEXT	SEGMENT
_last$ = -68						; size = 4
$T1 = -64						; size = 4
$T2 = -60						; size = 4
tv196 = -56						; size = 4
tv176 = -52						; size = 4
tv195 = -48						; size = 4
_fp$ = -44						; size = 4
_newrec$ = -40						; size = 4
_this$ = -36						; size = 4
_cur$ = -32						; size = 4
_rec$ = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
?LoadStats@PlayerStats@@QAEXXZ PROC			; PlayerStats::LoadStats
; _this$ = ecx

; 32   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 33   : 	StatList *cur,*newrec,*last;
; 34   : 	StatRec rec;
; 35   : 	FILE *fp;
; 36   : 
; 37   : 	// dispose of previous Stats
; 38   : 	cur=Root_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _cur$[ebp], ecx
$LN16@LoadStats:

; 39   : 	while(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN15@LoadStats

; 40   : 	{
; 41   : 		last=cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _last$[ebp], edx

; 42   : 		cur=cur->Next;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _cur$[ebp], ecx

; 43   : 		delete last;

	mov	edx, DWORD PTR _last$[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 44   : 	}

	jmp	SHORT $LN16@LoadStats
$LN15@LoadStats:

; 45   : 	Root_=NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], 0

; 46   : 
; 47   : 	fp=fopen(SaveName_,"rb");

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4
	push	edx
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$[ebp], eax

; 48   : 	if(fp)

	cmp	DWORD PTR _fp$[ebp], 0
	je	$LN14@LoadStats
$LN13@LoadStats:

; 49   : 	{
; 50   : 		while(fread(&rec,sizeof(StatRec),1,fp))

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	24					; 00000018H
	lea	ecx, DWORD PTR _rec$[ebp]
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H
	test	eax, eax
	je	$LN12@LoadStats

; 51   : 		{
; 52   : 			DecryptBuffer(0x25,(uchar*)&rec,sizeof(StatRec));

	push	24					; 00000018H
	lea	edx, DWORD PTR _rec$[ebp]
	push	edx
	push	37					; 00000025H
	call	?DecryptBuffer@@YAXEPAEJ@Z		; DecryptBuffer
	add	esp, 12					; 0000000cH

; 53   : 			if(!rec.CheckSum) // No tampering... keep it

	movsx	eax, BYTE PTR _rec$[ebp+23]
	test	eax, eax
	jne	$LN7@LoadStats

; 54   : 			{
; 55   : 				if(rec.aa_kills || rec.ag_kills || rec.as_kills || rec.an_kills || rec.rating || rec.missions)

	movsx	ecx, WORD PTR _rec$[ebp+12]
	test	ecx, ecx
	jne	SHORT $LN9@LoadStats
	movsx	edx, WORD PTR _rec$[ebp+14]
	test	edx, edx
	jne	SHORT $LN9@LoadStats
	movsx	eax, WORD PTR _rec$[ebp+18]
	test	eax, eax
	jne	SHORT $LN9@LoadStats
	movsx	ecx, WORD PTR _rec$[ebp+16]
	test	ecx, ecx
	jne	SHORT $LN9@LoadStats
	movsx	edx, BYTE PTR _rec$[ebp+22]
	test	edx, edx
	jne	SHORT $LN9@LoadStats
	movsx	eax, WORD PTR _rec$[ebp+20]
	test	eax, eax
	je	SHORT $LN7@LoadStats
$LN9@LoadStats:

; 56   : 				{
; 57   : 					newrec=new StatList;

	push	28					; 0000001cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR _newrec$[ebp], ecx

; 58   : 					newrec->Next=NULL;

	mov	edx, DWORD PTR _newrec$[ebp]
	mov	DWORD PTR [edx+24], 0

; 59   : 					memcpy(&newrec->data,&rec,sizeof(StatRec));

	push	24					; 00000018H
	lea	eax, DWORD PTR _rec$[ebp]
	push	eax
	mov	ecx, DWORD PTR _newrec$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 60   : 					if(!Root_)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN8@LoadStats

; 61   : 						Root_=newrec;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newrec$[ebp]
	mov	DWORD PTR [eax], ecx

; 62   : 					else

	jmp	SHORT $LN7@LoadStats
$LN8@LoadStats:

; 63   : 					{
; 64   : 						cur=Root_;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _cur$[ebp], eax
$LN6@LoadStats:

; 65   : 						while(cur->Next)

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	je	SHORT $LN5@LoadStats

; 66   : 							cur=cur->Next;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _cur$[ebp], eax
	jmp	SHORT $LN6@LoadStats
$LN5@LoadStats:

; 67   : 						cur->Next=newrec;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _newrec$[ebp]
	mov	DWORD PTR [ecx+24], edx
$LN7@LoadStats:

; 68   : 					}
; 69   : 				}
; 70   : 			}
; 71   : 		}

	jmp	$LN13@LoadStats
$LN12@LoadStats:

; 72   : 		fclose(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fclose
	add	esp, 4
$LN14@LoadStats:

; 73   : 	}
; 74   : 	if(!Find(-1,-1,-1))

	push	-1
	push	-1
	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Find@PlayerStats@@QAEPAUStatList@@JJJ@Z ; PlayerStats::Find
	test	eax, eax
	jne	$LN4@LoadStats

; 75   : 	{
; 76   : 		cur=Root_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _cur$[ebp], edx
$LN3@LoadStats:

; 77   : 		while(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	$LN2@LoadStats

; 78   : 		{
; 79   : 			if(cur->data.missions)

	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, WORD PTR [eax+20]
	test	ecx, ecx
	je	$LN1@LoadStats

; 80   : 				cur->data.rating = (char)min(100.0f,max(0,((float)cur->data.rating + 0.5f) * 25.0f));

	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx+22]
	cvtsi2ss xmm0, eax
	addss	xmm0, DWORD PTR __real@3f000000
	mulss	xmm0, DWORD PTR __real@41c80000
	movss	xmm1, DWORD PTR __real@00000000
	comiss	xmm1, xmm0
	jbe	SHORT $LN19@LoadStats
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv176[ebp], xmm0
	jmp	SHORT $LN20@LoadStats
$LN19@LoadStats:
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx+22]
	cvtsi2ss xmm0, edx
	addss	xmm0, DWORD PTR __real@3f000000
	mulss	xmm0, DWORD PTR __real@41c80000
	movss	DWORD PTR tv176[ebp], xmm0
$LN20@LoadStats:
	movss	xmm0, DWORD PTR tv176[ebp]
	comiss	xmm0, DWORD PTR __real@42c80000
	jbe	SHORT $LN23@LoadStats
	movss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR tv196[ebp], xmm0
	jmp	SHORT $LN24@LoadStats
$LN23@LoadStats:
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax+22]
	cvtsi2ss xmm0, ecx
	addss	xmm0, DWORD PTR __real@3f000000
	mulss	xmm0, DWORD PTR __real@41c80000
	movss	xmm1, DWORD PTR __real@00000000
	comiss	xmm1, xmm0
	jbe	SHORT $LN21@LoadStats
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv195[ebp], xmm0
	jmp	SHORT $LN22@LoadStats
$LN21@LoadStats:
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx+22]
	cvtsi2ss xmm0, eax
	addss	xmm0, DWORD PTR __real@3f000000
	mulss	xmm0, DWORD PTR __real@41c80000
	movss	DWORD PTR tv195[ebp], xmm0
$LN22@LoadStats:
	movss	xmm0, DWORD PTR tv195[ebp]
	movss	DWORD PTR tv196[ebp], xmm0
$LN24@LoadStats:
	cvttss2si ecx, DWORD PTR tv196[ebp]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	BYTE PTR [edx+22], cl
$LN1@LoadStats:

; 81   : 			cur=cur->Next;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _cur$[ebp], ecx

; 82   : 		}

	jmp	$LN3@LoadStats
$LN2@LoadStats:

; 83   : 		AddStat(-1,-1,-1,-1,-1,-1,-1,-1,-1);

	push	-1
	push	-1
	push	-1
	push	-1
	push	-1
	push	-1
	push	-1
	push	-1
	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddStat@PlayerStats@@QAEXJJJFFFFFD@Z	; PlayerStats::AddStat
$LN4@LoadStats:

; 84   : 	}
; 85   : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?LoadStats@PlayerStats@@QAEXXZ ENDP			; PlayerStats::LoadStats
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\comms\stats.cpp
_TEXT	SEGMENT
$T1 = -16						; size = 4
_last$ = -12						; size = 4
_this$ = -8						; size = 4
_cur$ = -4						; size = 4
??1PlayerStats@@QAE@XZ PROC				; PlayerStats::~PlayerStats
; _this$ = ecx

; 18   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 19   : 	StatList *cur,*last;
; 20   : 
; 21   : 	cur=Root_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _cur$[ebp], ecx

; 22   : 	Root_=NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], 0
$LN2@PlayerStat:

; 23   : 	while(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN3@PlayerStat

; 24   : 	{
; 25   : 		last=cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _last$[ebp], eax

; 26   : 		cur=cur->Next;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _cur$[ebp], edx

; 27   : 		delete last;

	mov	eax, DWORD PTR _last$[ebp]
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 28   : 	}

	jmp	SHORT $LN2@PlayerStat
$LN3@PlayerStat:

; 29   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??1PlayerStats@@QAE@XZ ENDP				; PlayerStats::~PlayerStats
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\comms\stats.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0PlayerStats@@QAE@XZ PROC				; PlayerStats::PlayerStats
; _this$ = ecx

; 12   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 13   : 	Root_=NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 14   : 	memset(SaveName_,0,MAX_PATH);

	push	260					; 00000104H
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 15   : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0PlayerStats@@QAE@XZ ENDP				; PlayerStats::PlayerStats
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
END
