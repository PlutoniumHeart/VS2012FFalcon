; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\UI\SRC\common\filters.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?ObjectiveFilters@@3PAUFILTER_TABLE@@A		; ObjectiveFilters
PUBLIC	?AirIcons@@3PAUAIR_ICONS@@A			; AirIcons
PUBLIC	?OBJ_TypeList@@3PAJA				; OBJ_TypeList
PUBLIC	?NAV_TypeList@@3PAJA				; NAV_TypeList
PUBLIC	?AIR_TypeList@@3PAJA				; AIR_TypeList
PUBLIC	?GND_TypeList@@3PAJA				; GND_TypeList
PUBLIC	?GND_LevelList@@3PAJA				; GND_LevelList
PUBLIC	?THR_TypeList@@3PAJA				; THR_TypeList
PUBLIC	?BullsEyeLines@@3PAY03MA			; BullsEyeLines
PUBLIC	?BullsEyeRadius@@3PAMA				; BullsEyeRadius
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
_DATA	SEGMENT
?ObjectiveFilters@@3PAUFILTER_TABLE@@A DB 03H		; ObjectiveFilters
	DB	04H
	DB	015H
	DB	00H
	DD	01H
	DD	020000H
	DB	03H
	DB	04H
	DB	01fH
	DB	00H
	DD	01H
	DD	020000H
	DB	03H
	DB	04H
	DB	01H
	DB	00H
	DD	02H
	DD	010000H
	DB	03H
	DB	04H
	DB	02H
	DB	00H
	DD	02H
	DD	010000H
	DB	03H
	DB	04H
	DB	03H
	DB	00H
	DD	04H
	DD	020000H
	DB	03H
	DB	04H
	DB	0dH
	DB	00H
	DD	04H
	DD	020000H
	DB	03H
	DB	04H
	DB	01eH
	DB	00H
	DD	04H
	DD	020000H
	DB	03H
	DB	04H
	DB	09H
	DB	00H
	DD	08H
	DD	080000H
	DB	03H
	DB	04H
	DB	016H
	DB	00H
	DD	08H
	DD	080000H
	DB	03H
	DB	04H
	DB	06H
	DB	00H
	DD	010H
	DD	080000H
	DB	03H
	DB	04H
	DB	014H
	DB	00H
	DD	0200H
	DD	080000H
	DB	03H
	DB	04H
	DB	017H
	DB	00H
	DD	010H
	DD	080000H
	DB	03H
	DB	04H
	DB	018H
	DB	00H
	DD	010H
	DD	080000H
	DB	03H
	DB	04H
	DB	0aH
	DB	00H
	DD	020H
	DD	080000H
	DB	03H
	DB	04H
	DB	013H
	DB	00H
	DD	020H
	DD	040000H
	DB	03H
	DB	04H
	DB	04H
	DB	00H
	DD	040H
	DD	080000H
	DB	03H
	DB	04H
	DB	0cH
	DB	00H
	DD	040H
	DD	080000H
	DB	03H
	DB	04H
	DB	0eH
	DB	00H
	DD	040H
	DD	080000H
	DB	03H
	DB	04H
	DB	012H
	DB	00H
	DD	040H
	DD	080000H
	DB	03H
	DB	04H
	DB	01aH
	DB	00H
	DD	040H
	DD	080000H
	DB	03H
	DB	04H
	DB	01bH
	DB	00H
	DD	040H
	DD	040000H
	DB	03H
	DB	04H
	DB	010H
	DB	00H
	DD	080H
	DD	080000H
	DB	03H
	DB	04H
	DB	05H
	DB	00H
	DD	040H
	DD	080000H
	DB	03H
	DB	04H
	DB	08H
	DB	00H
	DD	0100H
	DD	080000H
	DB	03H
	DB	04H
	DB	01cH
	DB	00H
	DD	0100H
	DD	080000H
	DB	03H
	DB	04H
	DB	01dH
	DB	00H
	DD	0100H
	DD	080000H
	DB	03H
	DB	04H
	DB	07H
	DB	00H
	DD	0200H
	DD	080000H
	DB	03H
	DB	04H
	DB	0bH
	DB	00H
	DD	0200H
	DD	080000H
	DB	03H
	DB	04H
	DB	011H
	DB	00H
	DD	0200H
	DD	080000H
	DB	03H
	DB	04H
	DB	019H
	DB	00H
	DD	0200H
	DD	080000H
	DB	02H
	DB	06H
	DB	03H
	DB	00H
	DD	0800H
	DD	00H
	DB	02H
	DB	06H
	DB	02H
	DB	00H
	DD	01000H
	DD	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DD	00H
	DD	00H
?AIR_TypeList@@3PAJA DD 04H				; AIR_TypeList
	DD	010H
	DD	020H
	DD	040H
	DD	080H
?AirIcons@@3PAUAIR_ICONS@@A DB 01H			; AirIcons
	ORG $+3
	DD	00H
	DD	00H
	DD	00H
	DD	04H
	DB	02H
	ORG $+3
	DD	00H
	DD	00H
	DD	00H
	DD	04H
	DB	03H
	ORG $+3
	DD	00H
	DD	00H
	DD	00H
	DD	010H
	DB	04H
	ORG $+3
	DD	00H
	DD	00H
	DD	00H
	DD	020H
	DB	05H
	ORG $+3
	DD	00H
	DD	00H
	DD	00H
	DD	04H
	DB	06H
	ORG $+3
	DD	00H
	DD	00H
	DD	00H
	DD	040H
	DB	07H
	ORG $+3
	DD	00H
	DD	00H
	DD	00H
	DD	04H
	DB	08H
	ORG $+3
	DD	00H
	DD	00H
	DD	00H
	DD	080H
	DB	09H
	ORG $+3
	DD	00H
	DD	00H
	DD	00H
	DD	080H
	DB	0aH
	ORG $+3
	DD	00H
	DD	00H
	DD	00H
	DD	04H
	DB	0bH
	ORG $+3
	DD	00H
	DD	00H
	DD	00H
	DD	04H
	DB	0cH
	ORG $+3
	DD	00H
	DD	00H
	DD	00H
	DD	020H
	DB	0dH
	ORG $+3
	DD	00H
	DD	00H
	DD	00H
	DD	04H
	DB	0eH
	ORG $+3
	DD	00H
	DD	00H
	DD	00H
	DD	020H
	DB	00H
	ORG $+3
	DD	00H
	DD	00H
	DD	00H
	DD	00H
?OBJ_TypeList@@3PAJA DD 02000H				; OBJ_TypeList
	DD	01H
	DD	02H
	DD	04H
	DD	08H
	DD	010H
	DD	020H
	DD	040H
	DD	080H
	DD	0100H
	DD	0200H
	DD	0400H
	DD	01000H
	DD	0800H
?NAV_TypeList@@3PAJA DD 02H				; NAV_TypeList
	DD	04H
?GND_TypeList@@3PAJA DD 01H				; GND_TypeList
	DD	02H
	DD	04H
	DD	08H
?GND_LevelList@@3PAJA DD 04000000H			; GND_LevelList
	DD	02000000H
	DD	01000000H
?THR_TypeList@@3PAJA DD 01H				; THR_TypeList
	DD	02H
	DD	04H
	DD	08H
?BullsEyeLines@@3PAY03MA DD 000000000r		; 0	; BullsEyeLines
	DD	0c98ced81r			; -1.15448e+006
	DD	000000000r			; 0
	DD	0498ced81r			; 1.15448e+006
	DD	0490ced81r			; 577240
	DD	0c9741812r			; -999809
	DD	0c90ced81r			; -577240
	DD	049741812r			; 999809
	DD	049741812r			; 999809
	DD	0c90ced81r			; -577240
	DD	0c9741812r			; -999809
	DD	0490ced81r			; 577240
	DD	0498ced81r			; 1.15448e+006
	DD	000000000r			; 0
	DD	0c98ced81r			; -1.15448e+006
	DD	000000000r			; 0
	DD	049741812r			; 999809
	DD	0490ced81r			; 577240
	DD	0c9741812r			; -999809
	DD	0c90ced81r			; -577240
	DD	0490ced81r			; 577240
	DD	049741812r			; 999809
	DD	0c90ced81r			; -577240
	DD	0c9741812r			; -999809
?BullsEyeRadius@@3PAMA DD 048320395r		; 182286 ; BullsEyeRadius
	DD	048b20395r			; 364573
	DD	0490582b0r			; 546859
	DD	049320395r			; 729145
	DD	0495e847ar			; 911432
	DD	0498582b0r			; 1.09372e+006
_UI_VU_ANY DB	0ffH
_DATA	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
PUBLIC	?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ	; VuEntity::EntityType
PUBLIC	?GetDomain@CampBaseClass@@QBEEXZ		; CampBaseClass::GetDomain
PUBLIC	?GetClass@CampBaseClass@@QBEEXZ			; CampBaseClass::GetClass
PUBLIC	?GetType@CampBaseClass@@QBEEXZ			; CampBaseClass::GetType
PUBLIC	?GetSType@CampBaseClass@@QBEEXZ			; CampBaseClass::GetSType
PUBLIC	?FindTypeIndex@@YAJJQAJH@Z			; FindTypeIndex
PUBLIC	?FindObjectiveIndex@@YAJPAVObjectiveClass@@@Z	; FindObjectiveIndex
PUBLIC	?GetObjectiveType@@YAJPAVCampBaseClass@@@Z	; GetObjectiveType
PUBLIC	?GetObjectiveCategory@@YAJPAVObjectiveClass@@@Z	; GetObjectiveCategory
PUBLIC	?GetAirIcon@@YAJE@Z				; GetAirIcon
PUBLIC	?FindDivisionType@@YAJE@Z			; FindDivisionType
PUBLIC	?FindUnitType@@YAJPAVUnitClass@@@Z		; FindUnitType
PUBLIC	?FindUnitCategory@@YAJPAVUnitClass@@@Z		; FindUnitCategory
PUBLIC	?UnitFilters@@3PAUFILTER_TABLE@@A		; UnitFilters
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
_allocator_arg DB 01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
_DATA	SEGMENT
	ORG $+7
?UnitFilters@@3PAUFILTER_TABLE@@A DB 03H		; UnitFilters
	DB	06H
	DB	01H
	DB	02H
	DD	01000002H
	DD	020000H
	DB	03H
	DB	06H
	DB	01H
	DB	02H
	DD	01000002H
	DD	020000H
	DB	03H
	DB	06H
	DB	01H
	DB	01H
	DD	01000001H
	DD	020000H
	DB	03H
	DB	06H
	DB	01H
	DB	03H
	DD	01000002H
	DD	020000H
	DB	03H
	DB	06H
	DB	01H
	DB	04H
	DD	01000002H
	DD	020000H
	DB	03H
	DB	06H
	DB	01H
	DB	05H
	DD	01000004H
	DD	020000H
	DB	03H
	DB	06H
	DB	01H
	DB	06H
	DD	01000004H
	DD	020000H
	DB	03H
	DB	06H
	DB	01H
	DB	07H
	DD	01000002H
	DD	020000H
	DB	03H
	DB	06H
	DB	01H
	DB	08H
	DD	01000002H
	DD	020000H
	DB	03H
	DB	06H
	DB	01H
	DB	09H
	DD	01000002H
	DD	020000H
	DB	03H
	DB	06H
	DB	01H
	DB	0aH
	DD	01000004H
	DD	020000H
	DB	03H
	DB	06H
	DB	01H
	DB	0bH
	DD	01000004H
	DD	020000H
	DB	03H
	DB	06H
	DB	01H
	DB	0cH
	DD	01000004H
	DD	020000H
	DB	03H
	DB	06H
	DB	01H
	DB	0dH
	DD	01000004H
	DD	020000H
	DB	03H
	DB	06H
	DB	01H
	DB	0eH
	DD	01000004H
	DD	020000H
	DB	03H
	DB	06H
	DB	02H
	DB	02H
	DD	02000002H
	DD	020000H
	DB	03H
	DB	06H
	DB	02H
	DB	02H
	DD	02000002H
	DD	020000H
	DB	03H
	DB	06H
	DB	02H
	DB	01H
	DD	02000001H
	DD	020000H
	DB	03H
	DB	06H
	DB	02H
	DB	03H
	DD	02000002H
	DD	020000H
	DB	03H
	DB	06H
	DB	02H
	DB	04H
	DD	02000002H
	DD	020000H
	DB	03H
	DB	06H
	DB	02H
	DB	05H
	DD	02000004H
	DD	020000H
	DB	03H
	DB	06H
	DB	02H
	DB	06H
	DD	02000004H
	DD	020000H
	DB	03H
	DB	06H
	DB	02H
	DB	07H
	DD	02000002H
	DD	020000H
	DB	03H
	DB	06H
	DB	02H
	DB	08H
	DD	02000002H
	DD	020000H
	DB	03H
	DB	06H
	DB	02H
	DB	09H
	DD	02000002H
	DD	020000H
	DB	03H
	DB	06H
	DB	02H
	DB	0aH
	DD	02000004H
	DD	020000H
	DB	03H
	DB	06H
	DB	02H
	DB	0bH
	DD	02000004H
	DD	020000H
	DB	03H
	DB	06H
	DB	02H
	DB	0cH
	DD	02000004H
	DD	020000H
	DB	03H
	DB	06H
	DB	02H
	DB	0dH
	DD	02000004H
	DD	020000H
	DB	03H
	DB	06H
	DB	02H
	DB	0eH
	DD	02000004H
	DD	020000H
	DB	04H
	DB	06H
	DB	01H
	DB	01H
	DD	08000002H
	DD	040000H
	DB	04H
	DB	06H
	DB	01H
	DB	03H
	DD	08000002H
	DD	040000H
	DB	04H
	DB	06H
	DB	01H
	DB	04H
	DD	08000002H
	DD	040000H
	DB	04H
	DB	06H
	DB	01H
	DB	05H
	DD	08000002H
	DD	040000H
	DB	04H
	DB	06H
	DB	01H
	DB	06H
	DD	08000002H
	DD	040000H
	DB	04H
	DB	06H
	DB	01H
	DB	07H
	DD	08000002H
	DD	040000H
	DB	04H
	DB	06H
	DB	01H
	DB	08H
	DD	08000004H
	DD	040000H
	DB	04H
	DB	06H
	DB	01H
	DB	09H
	DD	08000004H
	DD	040000H
	DB	02H
	DB	06H
	DB	03H
	ORG $+21
_DATA	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_UnitFilters$initializer$ DD FLAT:??__EUnitFilters@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\common\filters.cpp
;	COMDAT ??__EUnitFilters@@YAXXZ
text$yc	SEGMENT
??__EUnitFilters@@YAXXZ PROC				; `dynamic initializer for 'UnitFilters'', COMDAT

; 96   : 	{ DOMAIN_AIR,CLASS_UNIT,TYPE_SQUADRON, UI_VU_ANY,            0,                         OOB_AIRFORCE},

	push	ebp
	mov	ebp, esp
	mov	al, BYTE PTR _UI_VU_ANY
	mov	BYTE PTR ?UnitFilters@@3PAUFILTER_TABLE@@A+459, al
	mov	DWORD PTR ?UnitFilters@@3PAUFILTER_TABLE@@A+460, 0
	mov	DWORD PTR ?UnitFilters@@3PAUFILTER_TABLE@@A+464, 65536 ; 00010000H

; 97   : 	{ 0,0,0,0,0,0},

	mov	BYTE PTR ?UnitFilters@@3PAUFILTER_TABLE@@A+468, 0
	mov	BYTE PTR ?UnitFilters@@3PAUFILTER_TABLE@@A+469, 0
	mov	BYTE PTR ?UnitFilters@@3PAUFILTER_TABLE@@A+470, 0
	mov	BYTE PTR ?UnitFilters@@3PAUFILTER_TABLE@@A+471, 0
	mov	DWORD PTR ?UnitFilters@@3PAUFILTER_TABLE@@A+472, 0
	mov	DWORD PTR ?UnitFilters@@3PAUFILTER_TABLE@@A+476, 0

; 98   : };

	pop	ebp
	ret	0
??__EUnitFilters@@YAXXZ ENDP				; `dynamic initializer for 'UnitFilters''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\common\filters.cpp
_TEXT	SEGMENT
_i$ = -4						; size = 4
_unit$ = 8						; size = 4
?FindUnitCategory@@YAJPAVUnitClass@@@Z PROC		; FindUnitCategory

; 326  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 327  : 	int i;
; 328  : 
; 329  : 	i=0;

	mov	DWORD PTR _i$[ebp], 0
$LN4@FindUnitCa:

; 330  : 	while(UnitFilters[i].Domain)

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	movsx	ecx, BYTE PTR ?UnitFilters@@3PAUFILTER_TABLE@@A[eax]
	test	ecx, ecx
	je	$LN3@FindUnitCa

; 331  : 	{
; 332  : 		if(unit->GetDomain() == UnitFilters[i].Domain && unit->GetClass() == UnitFilters[i].Class && unit->GetType() == UnitFilters[i].Type && (unit->GetSType() == UnitFilters[i].SubType || UnitFilters[i].SubType == UI_VU_ANY))

	mov	ecx, DWORD PTR _unit$[ebp]
	call	?GetDomain@CampBaseClass@@QBEEXZ	; CampBaseClass::GetDomain
	movzx	edx, al
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	movsx	ecx, BYTE PTR ?UnitFilters@@3PAUFILTER_TABLE@@A[eax]
	cmp	edx, ecx
	jne	SHORT $LN2@FindUnitCa
	mov	ecx, DWORD PTR _unit$[ebp]
	call	?GetClass@CampBaseClass@@QBEEXZ		; CampBaseClass::GetClass
	movzx	edx, al
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	movsx	ecx, BYTE PTR ?UnitFilters@@3PAUFILTER_TABLE@@A[eax+1]
	cmp	edx, ecx
	jne	SHORT $LN2@FindUnitCa
	mov	ecx, DWORD PTR _unit$[ebp]
	call	?GetType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetType
	movzx	edx, al
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	movsx	ecx, BYTE PTR ?UnitFilters@@3PAUFILTER_TABLE@@A[eax+2]
	cmp	edx, ecx
	jne	SHORT $LN2@FindUnitCa
	mov	ecx, DWORD PTR _unit$[ebp]
	call	?GetSType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetSType
	movzx	edx, al
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	movsx	ecx, BYTE PTR ?UnitFilters@@3PAUFILTER_TABLE@@A[eax+3]
	cmp	edx, ecx
	je	SHORT $LN1@FindUnitCa
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 12					; 0000000cH
	movsx	eax, BYTE PTR ?UnitFilters@@3PAUFILTER_TABLE@@A[edx+3]
	movsx	ecx, BYTE PTR _UI_VU_ANY
	cmp	eax, ecx
	jne	SHORT $LN2@FindUnitCa
$LN1@FindUnitCa:

; 333  : 			return(UnitFilters[i].OOBCategory);

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR ?UnitFilters@@3PAUFILTER_TABLE@@A[edx+8]
	jmp	SHORT $LN5@FindUnitCa
$LN2@FindUnitCa:

; 334  : 		i++;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax

; 335  : 	}

	jmp	$LN4@FindUnitCa
$LN3@FindUnitCa:

; 336  : 	return(0);

	xor	eax, eax
$LN5@FindUnitCa:

; 337  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FindUnitCategory@@YAJPAVUnitClass@@@Z ENDP		; FindUnitCategory
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\common\filters.cpp
_TEXT	SEGMENT
_i$ = -4						; size = 4
_unit$ = 8						; size = 4
?FindUnitType@@YAJPAVUnitClass@@@Z PROC			; FindUnitType

; 312  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 313  : 	int i;
; 314  : 
; 315  : 	i=0;

	mov	DWORD PTR _i$[ebp], 0
$LN3@FindUnitTy:

; 316  : 	while(UnitFilters[i].UIType)

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	cmp	DWORD PTR ?UnitFilters@@3PAUFILTER_TABLE@@A[eax+4], 0
	je	$LN2@FindUnitTy

; 317  : 	{
; 318  : 		if(unit->GetDomain() == UnitFilters[i].Domain && unit->GetClass() == UnitFilters[i].Class && unit->GetType() == UnitFilters[i].Type && unit->GetSType() == UnitFilters[i].SubType)

	mov	ecx, DWORD PTR _unit$[ebp]
	call	?GetDomain@CampBaseClass@@QBEEXZ	; CampBaseClass::GetDomain
	movzx	ecx, al
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 12					; 0000000cH
	movsx	eax, BYTE PTR ?UnitFilters@@3PAUFILTER_TABLE@@A[edx]
	cmp	ecx, eax
	jne	SHORT $LN1@FindUnitTy
	mov	ecx, DWORD PTR _unit$[ebp]
	call	?GetClass@CampBaseClass@@QBEEXZ		; CampBaseClass::GetClass
	movzx	ecx, al
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 12					; 0000000cH
	movsx	eax, BYTE PTR ?UnitFilters@@3PAUFILTER_TABLE@@A[edx+1]
	cmp	ecx, eax
	jne	SHORT $LN1@FindUnitTy
	mov	ecx, DWORD PTR _unit$[ebp]
	call	?GetType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetType
	movzx	ecx, al
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 12					; 0000000cH
	movsx	eax, BYTE PTR ?UnitFilters@@3PAUFILTER_TABLE@@A[edx+2]
	cmp	ecx, eax
	jne	SHORT $LN1@FindUnitTy
	mov	ecx, DWORD PTR _unit$[ebp]
	call	?GetSType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetSType
	movzx	ecx, al
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 12					; 0000000cH
	movsx	eax, BYTE PTR ?UnitFilters@@3PAUFILTER_TABLE@@A[edx+3]
	cmp	ecx, eax
	jne	SHORT $LN1@FindUnitTy

; 319  : 			return(UnitFilters[i].UIType);

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	eax, DWORD PTR ?UnitFilters@@3PAUFILTER_TABLE@@A[ecx+4]
	jmp	SHORT $LN4@FindUnitTy
$LN1@FindUnitTy:

; 320  : 		i++;

	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx

; 321  : 	}

	jmp	$LN3@FindUnitTy
$LN2@FindUnitTy:

; 322  : 	return(0);

	xor	eax, eax
$LN4@FindUnitTy:

; 323  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FindUnitType@@YAJPAVUnitClass@@@Z ENDP			; FindUnitType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\common\filters.cpp
_TEXT	SEGMENT
_i$ = -4						; size = 4
_type$ = 8						; size = 1
?FindDivisionType@@YAJE@Z PROC				; FindDivisionType

; 298  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 299  : 	int i;
; 300  : 
; 301  : 	i=0;

	mov	DWORD PTR _i$[ebp], 0
$LN3@FindDivisi:

; 302  : 	while(UnitFilters[i].UIType)

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	cmp	DWORD PTR ?UnitFilters@@3PAUFILTER_TABLE@@A[eax+4], 0
	je	SHORT $LN2@FindDivisi

; 303  : 	{
; 304  : 		if(type == (UnitFilters[i].SubType & 0x00ffffff))

	movzx	ecx, BYTE PTR _type$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 12					; 0000000cH
	movsx	eax, BYTE PTR ?UnitFilters@@3PAUFILTER_TABLE@@A[edx+3]
	and	eax, 16777215				; 00ffffffH
	cmp	ecx, eax
	jne	SHORT $LN1@FindDivisi

; 305  : 			return((UnitFilters[i].UIType & 0x00ffffff) | _UNIT_DIVISION);

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	eax, DWORD PTR ?UnitFilters@@3PAUFILTER_TABLE@@A[ecx+4]
	and	eax, 16777215				; 00ffffffH
	or	eax, 67108864				; 04000000H
	jmp	SHORT $LN4@FindDivisi
$LN1@FindDivisi:

; 306  : 		i++;

	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx

; 307  : 	}

	jmp	SHORT $LN3@FindDivisi
$LN2@FindDivisi:

; 308  : 	return(0);

	xor	eax, eax
$LN4@FindDivisi:

; 309  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FindDivisionType@@YAJE@Z ENDP				; FindDivisionType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\common\filters.cpp
_TEXT	SEGMENT
_i$ = -4						; size = 4
_STYPE$ = 8						; size = 1
?GetAirIcon@@YAJE@Z PROC				; GetAirIcon

; 284  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 285  : 	int i;
; 286  : 
; 287  : 	i=0;

	mov	DWORD PTR _i$[ebp], 0
$LN3@GetAirIcon:

; 288  : 	while(AirIcons[i].SubType)

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 20					; 00000014H
	movsx	ecx, BYTE PTR ?AirIcons@@3PAUAIR_ICONS@@A[eax]
	test	ecx, ecx
	je	SHORT $LN2@GetAirIcon

; 289  : 	{
; 290  : 		if(AirIcons[i].SubType == STYPE)

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 20					; 00000014H
	movsx	eax, BYTE PTR ?AirIcons@@3PAUAIR_ICONS@@A[edx]
	movzx	ecx, BYTE PTR _STYPE$[ebp]
	cmp	eax, ecx
	jne	SHORT $LN1@GetAirIcon

; 291  : 			return(i);

	mov	eax, DWORD PTR _i$[ebp]
	jmp	SHORT $LN4@GetAirIcon
$LN1@GetAirIcon:

; 292  : 		i++;

	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx

; 293  : 	}

	jmp	SHORT $LN3@GetAirIcon
$LN2@GetAirIcon:

; 294  : 	return(0);

	xor	eax, eax
$LN4@GetAirIcon:

; 295  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetAirIcon@@YAJE@Z ENDP				; GetAirIcon
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\common\filters.cpp
_TEXT	SEGMENT
_i$ = -4						; size = 4
_Obj$ = 8						; size = 4
?GetObjectiveCategory@@YAJPAVObjectiveClass@@@Z PROC	; GetObjectiveCategory

; 270  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 271  : 	int i;
; 272  : 
; 273  : 	i=0;

	mov	DWORD PTR _i$[ebp], 0
$LN3@GetObjecti:

; 274  : 	while(ObjectiveFilters[i].UIType)

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	cmp	DWORD PTR ?ObjectiveFilters@@3PAUFILTER_TABLE@@A[eax+4], 0
	je	SHORT $LN2@GetObjecti

; 275  : 	{
; 276  : 		if(Obj->GetClass() == ObjectiveFilters[i].Class && Obj->GetType() == ObjectiveFilters[i].Type)

	mov	ecx, DWORD PTR _Obj$[ebp]
	call	?GetClass@CampBaseClass@@QBEEXZ		; CampBaseClass::GetClass
	movzx	ecx, al
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 12					; 0000000cH
	movsx	eax, BYTE PTR ?ObjectiveFilters@@3PAUFILTER_TABLE@@A[edx+1]
	cmp	ecx, eax
	jne	SHORT $LN1@GetObjecti
	mov	ecx, DWORD PTR _Obj$[ebp]
	call	?GetType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetType
	movzx	ecx, al
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 12					; 0000000cH
	movsx	eax, BYTE PTR ?ObjectiveFilters@@3PAUFILTER_TABLE@@A[edx+2]
	cmp	ecx, eax
	jne	SHORT $LN1@GetObjecti

; 277  : 			return(ObjectiveFilters[i].OOBCategory);

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	eax, DWORD PTR ?ObjectiveFilters@@3PAUFILTER_TABLE@@A[ecx+8]
	jmp	SHORT $LN4@GetObjecti
$LN1@GetObjecti:

; 278  : 		i++;

	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx

; 279  : 	}

	jmp	SHORT $LN3@GetObjecti
$LN2@GetObjecti:

; 280  : 	return(0);

	xor	eax, eax
$LN4@GetObjecti:

; 281  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetObjectiveCategory@@YAJPAVObjectiveClass@@@Z ENDP	; GetObjectiveCategory
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\common\filters.cpp
_TEXT	SEGMENT
_i$ = -4						; size = 4
_ent$ = 8						; size = 4
?GetObjectiveType@@YAJPAVCampBaseClass@@@Z PROC		; GetObjectiveType

; 256  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 257  : 	int i;
; 258  : 
; 259  : 	i=0;

	mov	DWORD PTR _i$[ebp], 0
$LN3@GetObjecti:

; 260  : 	while(ObjectiveFilters[i].UIType)

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	cmp	DWORD PTR ?ObjectiveFilters@@3PAUFILTER_TABLE@@A[eax+4], 0
	je	SHORT $LN2@GetObjecti

; 261  : 	{
; 262  : 		if(ent->GetDomain() == ObjectiveFilters[i].Domain && ent->GetClass() == ObjectiveFilters[i].Class && ent->GetType() == ObjectiveFilters[i].Type)

	mov	ecx, DWORD PTR _ent$[ebp]
	call	?GetDomain@CampBaseClass@@QBEEXZ	; CampBaseClass::GetDomain
	movzx	ecx, al
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 12					; 0000000cH
	movsx	eax, BYTE PTR ?ObjectiveFilters@@3PAUFILTER_TABLE@@A[edx]
	cmp	ecx, eax
	jne	SHORT $LN1@GetObjecti
	mov	ecx, DWORD PTR _ent$[ebp]
	call	?GetClass@CampBaseClass@@QBEEXZ		; CampBaseClass::GetClass
	movzx	ecx, al
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 12					; 0000000cH
	movsx	eax, BYTE PTR ?ObjectiveFilters@@3PAUFILTER_TABLE@@A[edx+1]
	cmp	ecx, eax
	jne	SHORT $LN1@GetObjecti
	mov	ecx, DWORD PTR _ent$[ebp]
	call	?GetType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetType
	movzx	ecx, al
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 12					; 0000000cH
	movsx	eax, BYTE PTR ?ObjectiveFilters@@3PAUFILTER_TABLE@@A[edx+2]
	cmp	ecx, eax
	jne	SHORT $LN1@GetObjecti

; 263  : 			return(ObjectiveFilters[i].UIType);

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	eax, DWORD PTR ?ObjectiveFilters@@3PAUFILTER_TABLE@@A[ecx+4]
	jmp	SHORT $LN4@GetObjecti
$LN1@GetObjecti:

; 264  : 		i++;

	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx

; 265  : 	}

	jmp	SHORT $LN3@GetObjecti
$LN2@GetObjecti:

; 266  : 	return(0);

	xor	eax, eax
$LN4@GetObjecti:

; 267  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetObjectiveType@@YAJPAVCampBaseClass@@@Z ENDP		; GetObjectiveType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\common\filters.cpp
_TEXT	SEGMENT
_i$ = -4						; size = 4
_Obj$ = 8						; size = 4
?FindObjectiveIndex@@YAJPAVObjectiveClass@@@Z PROC	; FindObjectiveIndex

; 242  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 243  : 	int i;
; 244  : 
; 245  : 	i=0;

	mov	DWORD PTR _i$[ebp], 0
$LN3@FindObject:

; 246  : 	while(ObjectiveFilters[i].UIType)

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	cmp	DWORD PTR ?ObjectiveFilters@@3PAUFILTER_TABLE@@A[eax+4], 0
	je	SHORT $LN2@FindObject

; 247  : 	{
; 248  : 		if(Obj->GetClass() == ObjectiveFilters[i].Class && Obj->GetType() == ObjectiveFilters[i].Type)

	mov	ecx, DWORD PTR _Obj$[ebp]
	call	?GetClass@CampBaseClass@@QBEEXZ		; CampBaseClass::GetClass
	movzx	ecx, al
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 12					; 0000000cH
	movsx	eax, BYTE PTR ?ObjectiveFilters@@3PAUFILTER_TABLE@@A[edx+1]
	cmp	ecx, eax
	jne	SHORT $LN1@FindObject
	mov	ecx, DWORD PTR _Obj$[ebp]
	call	?GetType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetType
	movzx	ecx, al
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 12					; 0000000cH
	movsx	eax, BYTE PTR ?ObjectiveFilters@@3PAUFILTER_TABLE@@A[edx+2]
	cmp	ecx, eax
	jne	SHORT $LN1@FindObject

; 249  : 			return(i);

	mov	eax, DWORD PTR _i$[ebp]
	jmp	SHORT $LN4@FindObject
$LN1@FindObject:

; 250  : 		i++;

	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx

; 251  : 	}

	jmp	SHORT $LN3@FindObject
$LN2@FindObject:

; 252  : 	return(-1);

	or	eax, -1
$LN4@FindObject:

; 253  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FindObjectiveIndex@@YAJPAVObjectiveClass@@@Z ENDP	; FindObjectiveIndex
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\common\filters.cpp
_TEXT	SEGMENT
_i$ = -4						; size = 4
_type$ = 8						; size = 4
_TypeList$ = 12						; size = 4
_size$ = 16						; size = 4
?FindTypeIndex@@YAJJQAJH@Z PROC				; FindTypeIndex

; 232  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 233  : 	int i;
; 234  : 
; 235  : 	for(i=0;i<size;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@FindTypeIn
$LN3@FindTypeIn:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@FindTypeIn:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _size$[ebp]
	jge	SHORT $LN2@FindTypeIn

; 236  : 		if(type == TypeList[i])

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _TypeList$[ebp]
	mov	ecx, DWORD PTR _type$[ebp]
	cmp	ecx, DWORD PTR [eax+edx*4]
	jne	SHORT $LN1@FindTypeIn

; 237  : 			return(i);

	mov	eax, DWORD PTR _i$[ebp]
	jmp	SHORT $LN5@FindTypeIn
$LN1@FindTypeIn:

; 238  : 	return(-1);

	jmp	SHORT $LN3@FindTypeIn
$LN2@FindTypeIn:
	or	eax, -1
$LN5@FindTypeIn:

; 239  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FindTypeIndex@@YAJJQAJH@Z ENDP				; FindTypeIndex
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetSType@CampBaseClass@@QBEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSType@CampBaseClass@@QBEEXZ PROC			; CampBaseClass::GetSType, COMDAT
; _this$ = ecx

; 290  : 	uchar GetSType (void)	const						{	return (EntityType())->classInfo_[VU_STYPE]; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ ; VuEntity::EntityType
	mov	ecx, 1
	imul	ecx, 3
	mov	al, BYTE PTR [eax+ecx+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSType@CampBaseClass@@QBEEXZ ENDP			; CampBaseClass::GetSType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetType@CampBaseClass@@QBEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetType@CampBaseClass@@QBEEXZ PROC			; CampBaseClass::GetType, COMDAT
; _this$ = ecx

; 289  : 	uchar GetType()	const						{	return (EntityType())->classInfo_[VU_TYPE]; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ ; VuEntity::EntityType
	mov	ecx, 1
	shl	ecx, 1
	mov	al, BYTE PTR [eax+ecx+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetType@CampBaseClass@@QBEEXZ ENDP			; CampBaseClass::GetType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetClass@CampBaseClass@@QBEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetClass@CampBaseClass@@QBEEXZ PROC			; CampBaseClass::GetClass, COMDAT
; _this$ = ecx

; 288  : 	uchar GetClass (void)	const						{	return (EntityType())->classInfo_[VU_CLASS]; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ ; VuEntity::EntityType
	mov	ecx, 1
	shl	ecx, 0
	mov	al, BYTE PTR [eax+ecx+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetClass@CampBaseClass@@QBEEXZ ENDP			; CampBaseClass::GetClass
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetDomain@CampBaseClass@@QBEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetDomain@CampBaseClass@@QBEEXZ PROC			; CampBaseClass::GetDomain, COMDAT
; _this$ = ecx

; 287  : 	uchar GetDomain (void)	const						{	return (EntityType())->classInfo_[VU_DOMAIN]; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ ; VuEntity::EntityType
	mov	ecx, 1
	imul	ecx, 0
	mov	al, BYTE PTR [eax+ecx+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDomain@CampBaseClass@@QBEEXZ ENDP			; CampBaseClass::GetDomain
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ PROC	; VuEntity::EntityType, COMDAT
; _this$ = ecx

; 176  : 	VuEntityType *EntityType() const { return const_cast<VuEntityType*>(entityTypePtr_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+112]
	mov	esp, ebp
	pop	ebp
	ret	0
?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ ENDP	; VuEntity::EntityType
_TEXT	ENDS
END
