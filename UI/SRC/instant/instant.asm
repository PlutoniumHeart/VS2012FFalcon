; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\UI\SRC\instant\instant.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B ; std::ios_base::failure::_Stream_err
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?gUBuffer@@3PADA				; gUBuffer
PUBLIC	?gInstantBites@@3PAVC_SoundBite@@A		; gInstantBites
PUBLIC	?TotalScore@@3JA				; TotalScore
PUBLIC	?Bonus@@3JA					; Bonus
PUBLIC	?Penalty@@3JA					; Penalty
PUBLIC	?LandingBonus@@3JA				; LandingBonus
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?LivingBonus@@3JA				; LivingBonus
PUBLIC	?WeaponUsage@@3PAUkill_list@@A			; WeaponUsage
PUBLIC	?AircraftKills@@3PAUkill_list@@A		; AircraftKills
PUBLIC	?ObjectKills@@3PAUkill_list@@A			; ObjectKills
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?BonusList@@3PAUkill_list@@A			; BonusList
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?Scores@@3UHighScoreList@@A			; Scores
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?InstantActionSettings@@3UUI_IA@@A		; InstantActionSettings
PUBLIC	?VisualIDCost@@3PAY01HA				; VisualIDCost
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
_BSS	SEGMENT
?gUBuffer@@3PADA DD 01H DUP (?)				; gUBuffer
?gInstantBites@@3PAVC_SoundBite@@A DD 01H DUP (?)	; gInstantBites
?TotalScore@@3JA DD 01H DUP (?)				; TotalScore
?Bonus@@3JA DD	01H DUP (?)				; Bonus
?Penalty@@3JA DD 01H DUP (?)				; Penalty
?LandingBonus@@3JA DD 01H DUP (?)			; LandingBonus
?LivingBonus@@3JA DD 01H DUP (?)			; LivingBonus
?WeaponUsage@@3PAUkill_list@@A DD 01H DUP (?)		; WeaponUsage
?AircraftKills@@3PAUkill_list@@A DD 01H DUP (?)		; AircraftKills
?ObjectKills@@3PAUkill_list@@A DD 01H DUP (?)		; ObjectKills
?BonusList@@3PAUkill_list@@A DD 01H DUP (?)		; BonusList
?Scores@@3UHighScoreList@@A DB 01b4H DUP (?)		; Scores
?InstantActionSettings@@3UUI_IA@@A DB 010H DUP (?)	; InstantActionSettings
_BSS	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B
CONST	SEGMENT
?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B DD 01H ; std::ios_base::failure::_Stream_err
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
_DATA	SEGMENT
_cloudPntList DD 0c5bcc000r			; -6040
	DD	0c4070000r			; -540
	DD	0c694ac00r			; -19030
	DD	0c6de1c00r			; -28430
	DD	0c4dfc000r			; -1790
	DD	046dcc800r			; 28260
	DD	047104200r			; 36930
	DD	045732000r			; 3890
	DD	04744ea00r			; 50410
	DD	045336000r			; 2870
	DD	0c4d48000r			; -1700
	DD	04736da00r			; 46810
	DD	0c763ee00r			; -58350
	DD	0c4d48000r			; -1700
	DD	0c64c1000r			; -13060
	DD	046f2bc00r			; 31070
	DD	045480000r			; 3200
	DD	0c7293800r			; -43320
	DD	0c7bdc400r			; -97160
	DD	0c4d48000r			; -1700
	DD	04576e000r			; 3950
	DD	0c792e000r			; -75200
	DD	0c4bb8000r			; -1500
	DD	047957400r			; 76520
	DD	04759ee00r			; 55790
	DD	0c5a1e000r			; -5180
	DD	0c7a24e00r			; -83100
	DD	0c7473800r			; -51000
	DD	0c3a00000r			; -320
	DD	0c7829100r			; -66850
	DD	047733400r			; 62260
	DD	0c3a00000r			; -320
	DD	047708200r			; 61570
	DD	0c7710e00r			; -61710
	DD	0c550c000r			; -3340
	DD	046fb7c00r			; 32190
	DD	0c7719a00r			; -61850
	DD	0c7483200r			; -51250
	DD	047543a00r			; 54330
	DD	0c5bcc000r			; -6040
	DD	0c7495400r			; -51540
	DD	0c694ac00r			; -19030
	DD	0c6a7a800r			; -21460
	DD	0c74b0200r			; -51970
	DD	0468e8000r			; 18240
	DD	047298800r			; 43400
	DD	0c74bf200r			; -52210
	DD	046bc7000r			; 24120
	DD	0c749f400r			; -51700
	DD	0c74bc000r			; -52160
	DD	046948400r			; 19010
	DD	0c605e800r			; -8570
	DD	0c7488200r			; -51330
	DD	0c74ca600r			; -52390
	DD	04731bc00r			; 45500
	DD	0c7509800r			; -53400
	DD	0c6725800r			; -15510
	DD	0c7719a00r			; -61850
	DD	0c7483200r			; -51250
	DD	047543a00r			; 54330
	DD	047553400r			; 54580
	DD	0c74ddc00r			; -52700
	DD	0479a5600r			; 79020
	DD	047a7e400r			; 85960
	DD	0c74c5600r			; -52310
	DD	0477d4800r			; 64840
	DD	0c7c44500r			; -100490
	DD	0c74d1400r			; -52500
	DD	047ac2600r			; 88140
	DD	0c7a1ae00r			; -82780
	DD	0c749ea00r			; -51690
	DD	0c7bce300r			; -96710
	DD	0c6126800r			; -9370
	DD	0c7495400r			; -51540
	DD	043cd0000r			; 410
	DD	0c6a7a800r			; -21460
	DD	0c74a8a00r			; -51850
	DD	0473fae00r			; 49070
	DD	0457c8000r			; 4040
	DD	0c74e4a00r			; -52810
	DD	047871e00r			; 69180
	DD	0c6cbc000r			; -26080
	DD	0c74bc000r			; -52160
	DD	046984400r			; 19490
	DD	0452fa000r			; 2810
	DD	0c7488200r			; -51330
	DD	0c7081800r			; -34840
	DD	0c7719a00r			; -61850
	DD	0c749d600r			; -51670
	DD	047b17600r			; 90860
	DD	047553400r			; 54580
	DD	0c74ddc00r			; -52700
	DD	0479a5600r			; 79020
	DD	047a7e400r			; 85960
	DD	0c74c5600r			; -52310
	DD	0477d4800r			; 64840
	DD	0c7c44500r			; -100490
	DD	0c74d1400r			; -52500
	DD	047ac2600r			; 88140
	DD	047c04e00r			; 98460
	DD	0c74d1400r			; -52500
	DD	0c732a200r			; -45730
	DD	0467b9000r			; 16100
	DD	0c7487800r			; -51320
	DD	0c749a400r			; -51620
	DD	047636c00r			; 58220
	DD	0c74e0400r			; -52740
	DD	0c760b000r			; -57520
	DD	0c6126800r			; -9370
	DD	0c4070000r			; -540
	DD	043cd0000r			; 410
	DD	0c4e60000r			; -1840
	DD	0c6a30c00r			; -20870
	DD	0470a6600r			; 35430
	DD	0c7230c00r			; -41740
	DD	046924000r			; 18720
	DD	04797d600r			; 77740
	DD	0460d9000r			; 9060
	DD	0c616c800r			; -9650
	DD	0c7921300r			; -74790
_lightningPosList DD 041300000r			; 11
	DD	000000000r			; 0
	DD	040e00000r			; 7
	DD	040a00000r			; 5
	DD	041100000r			; 9
	DD	041000000r			; 8
	DD	041000000r			; 8
	DD	041600000r			; 14
	DD	041800000r			; 16
	DD	041a00000r			; 20
	DD	041200000r			; 10
	DD	041c00000r			; 24
	DD	041300000r			; 11
	DD	041d80000r			; 27
	DD	040c00000r			; 6
	DD	041f00000r			; 30
	DD	040e00000r			; 7
	DD	042040000r			; 33
	DD	03f800000r			; 1
	DD	042180000r			; 38
	DD	040a00000r			; 5
	DD	042280000r			; 42
	DD	040a00000r			; 5
	DD	042340000r			; 45
	DD	041400000r			; 12
	DD	042400000r			; 48
	DD	041a00000r			; 20
	DD	042500000r			; 52
	DD	041a00000r			; 20
	DD	042680000r			; 58
	DD	041b80000r			; 23
	DD	042740000r			; 61
	DD	041b00000r			; 22
	DD	0427c0000r			; 63
	DD	041b00000r			; 22
	DD	042840000r			; 66
	DD	041c80000r			; 25
	DD	042880000r			; 68
	DD	041a00000r			; 20
	DD	0428c0000r			; 70
	DD	041c00000r			; 24
	DD	042960000r			; 75
	DD	041c00000r			; 24
	DD	0429a0000r			; 77
	DD	041f80000r			; 31
	DD	042a00000r			; 80
	DD	041f80000r			; 31
	DD	042a60000r			; 83
	DD	042040000r			; 33
	DD	042b00000r			; 88
	DD	041f80000r			; 31
	DD	042b80000r			; 92
	DD	0423c0000r			; 47
	DD	042ce0000r			; 103
	DD	042380000r			; 46
	DD	042d20000r			; 105
	DD	0423c0000r			; 47
	DD	042d60000r			; 107
	DD	042340000r			; 45
	DD	042e00000r			; 112
	DD	042400000r			; 48
	DD	042e40000r			; 114
	DD	042380000r			; 46
	DD	042ea0000r			; 117
	DD	0422c0000r			; 43
	DD	043000000r			; 128
?VisualIDCost@@3PAY01HA DD 0376H			; VisualIDCost
	DD	03e8H
	DD	041eH
	DD	064H
	DD	0377H
	DD	0c8H
	DD	03a8H
	DD	032H
	DD	03a9H
	DD	032H
	DD	03aaH
	DD	032H
	DD	03acH
	DD	032H
	DD	0386H
	DD	03e8H
	DD	0393H
	DD	07d0H
	DD	0391H
	DD	09c4H
	DD	038cH
	DD	01388H
	DD	038dH
	DD	02710H
	DD	038eH
	DD	02710H
	DD	038fH
	DD	03a98H
	DD	04aH
	DD	03a98H
	DD	0392H
	DD	04e20H
	DD	0381H
	DD	0ffff3cb0H
	DD	0382H
	DD	0ffff3cb0H
	DD	041cH
	DD	0ffff3cb0H
	DD	08bH
	DD	0ffff3cb0H
	DD	08aH
	DD	0ffff3cb0H
	DD	041bH
	DD	0ffff3cb0H
	DD	038bH
	DD	0ffff3cb0H
	DD	037bH
	DD	0ffff3cb0H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
_NEAR_CLIP DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
PUBLIC	??8VU_SESSION_ID@@QBEHABV0@@Z			; VU_SESSION_ID::operator==
PUBLIC	??8VU_ID@@QBE_NABV0@@Z				; VU_ID::operator==
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	??0id@locale@std@@QAE@I@Z			; std::locale::id::id
PUBLIC	?generic_category@std@@YAABVerror_category@1@XZ	; std::generic_category
PUBLIC	?system_category@std@@YAABVerror_category@1@XZ	; std::system_category
PUBLIC	??0error_category@std@@QAE@XZ			; std::error_category::error_category
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??8error_category@std@@QBE_NABV01@@Z		; std::error_category::operator==
PUBLIC	??_Gerror_category@std@@UAEPAXI@Z		; std::error_category::`scalar deleting destructor'
PUBLIC	?value@error_code@std@@QBEHXZ			; std::error_code::value
PUBLIC	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
PUBLIC	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?value@error_condition@std@@QBEHXZ		; std::error_condition::value
PUBLIC	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
PUBLIC	??8error_condition@std@@QBE_NABV01@@Z		; std::error_condition::operator==
PUBLIC	??0_Generic_error_category@std@@QAE@XZ		; std::_Generic_error_category::_Generic_error_category
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	??1_Generic_error_category@std@@UAE@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	??0_Iostream_error_category@std@@QAE@XZ		; std::_Iostream_error_category::_Iostream_error_category
PUBLIC	?name@_Iostream_error_category@std@@UBEPBDXZ	; std::_Iostream_error_category::name
PUBLIC	?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	??1_Iostream_error_category@std@@UAE@XZ		; std::_Iostream_error_category::~_Iostream_error_category
PUBLIC	??_G_Iostream_error_category@std@@UAEPAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	??0_System_error_category@std@@QAE@XZ		; std::_System_error_category::_System_error_category
PUBLIC	?name@_System_error_category@std@@UBEPBDXZ	; std::_System_error_category::name
PUBLIC	?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message
PUBLIC	?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition
PUBLIC	??1_System_error_category@std@@UAE@XZ		; std::_System_error_category::~_System_error_category
PUBLIC	??_G_System_error_category@std@@UAEPAXI@Z	; std::_System_error_category::`scalar deleting destructor'
PUBLIC	__tcsncpy
PUBLIC	__tcsclen
PUBLIC	?PlaySoundA@C_Sound@@QAEHJ@Z			; C_Sound::PlaySoundA
PUBLIC	?SetClient@C_Base@@QAEXF@Z			; C_Base::SetClient
PUBLIC	?GetID@C_Base@@QAEJXZ				; C_Base::GetID
PUBLIC	?GetX@C_Base@@QAEJXZ				; C_Base::GetX
PUBLIC	?GetY@C_Base@@QAEJXZ				; C_Base::GetY
PUBLIC	?GetW@C_Base@@QAEJXZ				; C_Base::GetW
PUBLIC	?GetH@C_Base@@QAEJXZ				; C_Base::GetH
PUBLIC	?GetMinInteger@C_EditBox@@QAEJXZ		; C_EditBox::GetMinInteger
PUBLIC	?GetMaxInteger@C_EditBox@@QAEJXZ		; C_EditBox::GetMaxInteger
PUBLIC	?GetInteger@C_EditBox@@QAEJXZ			; C_EditBox::GetInteger
PUBLIC	?SetDay@C_Clock@@QAEXJ@Z			; C_Clock::SetDay
PUBLIC	?SetHour@C_Clock@@QAEXJ@Z			; C_Clock::SetHour
PUBLIC	?SetMinute@C_Clock@@QAEXJ@Z			; C_Clock::SetMinute
PUBLIC	?SetSecond@C_Clock@@QAEXJ@Z			; C_Clock::SetSecond
PUBLIC	?SetLast@C_Clock@@QAEXJ@Z			; C_Clock::SetLast
PUBLIC	?GetDay@C_Clock@@QAEJXZ				; C_Clock::GetDay
PUBLIC	?GetHour@C_Clock@@QAEJXZ			; C_Clock::GetHour
PUBLIC	?GetMinute@C_Clock@@QAEJXZ			; C_Clock::GetMinute
PUBLIC	?GetSecond@C_Clock@@QAEJXZ			; C_Clock::GetSecond
PUBLIC	?GetLast@C_Clock@@QAEJXZ			; C_Clock::GetLast
PUBLIC	?GetCurrentCtrl@C_Clock@@QAEPAVC_EditBox@@XZ	; C_Clock::GetCurrentCtrl
PUBLIC	?GetDayCtrl@C_Clock@@QAEPAVC_EditBox@@XZ	; C_Clock::GetDayCtrl
PUBLIC	?GetHourCtrl@C_Clock@@QAEPAVC_EditBox@@XZ	; C_Clock::GetHourCtrl
PUBLIC	?GetMinuteCtrl@C_Clock@@QAEPAVC_EditBox@@XZ	; C_Clock::GetMinuteCtrl
PUBLIC	?GetSecondCtrl@C_Clock@@QAEPAVC_EditBox@@XZ	; C_Clock::GetSecondCtrl
PUBLIC	?GetFirstWindowLoaded@C_Parser@@QAEJXZ		; C_Parser::GetFirstWindowLoaded
PUBLIC	?GetNextWindowLoaded@C_Parser@@QAEJXZ		; C_Parser::GetNextWindowLoaded
PUBLIC	?GetGroup@C_Window@@QAEJXZ			; C_Window::GetGroup
PUBLIC	?GetAppWnd@C_Handler@@QAEPAUHWND__@@XZ		; C_Handler::GetAppWnd
PUBLIC	?Name@LogBookData@@QAEPADXZ			; LogBookData::Name
PUBLIC	?IsLoaded@CampaignClass@@QAEHXZ			; CampaignClass::IsLoaded
PUBLIC	?FTperBLOCK@TLevel@@QAEMXZ			; TLevel::FTperBLOCK
PUBLIC	?BlocksWide@TLevel@@QAEIXZ			; TLevel::BlocksWide
PUBLIC	?BlocksHigh@TLevel@@QAEIXZ			; TLevel::BlocksHigh
PUBLIC	?BlocksHigh@TMap@@QAEIXZ			; TMap::BlocksHigh
PUBLIC	?BlocksWide@TMap@@QAEIXZ			; TMap::BlocksWide
PUBLIC	?FeetPerBlock@TMap@@QAEMXZ			; TMap::FeetPerBlock
PUBLIC	?GenerateFastRandom@@YAJXZ			; GenerateFastRandom
PUBLIC	?PRANDFloatPos@@YAMXZ				; PRANDFloatPos
PUBLIC	?RemoveWeaponUsageList@@YAXXZ			; RemoveWeaponUsageList
PUBLIC	?AddCommas@@YAPADPAD@Z				; AddCommas
PUBLIC	?GetHighScores@@YAXXZ				; GetHighScores
PUBLIC	?SaveHighScores@@YAXXZ				; SaveHighScores
PUBLIC	?FindCost@@YAHH@Z				; FindCost
PUBLIC	?AddWeaponToUsageList@@YAHH@Z			; AddWeaponToUsageList
PUBLIC	?AddAircraftToKillsList@@YAHH@Z			; AddAircraftToKillsList
PUBLIC	?AddObjectToKillsList@@YAHH@Z			; AddObjectToKillsList
PUBLIC	?score_player_ejected@@YAHXZ			; score_player_ejected
PUBLIC	?RemoveBonusList@@YAXXZ				; RemoveBonusList
PUBLIC	?RemoveAircraftKillsList@@YAXXZ			; RemoveAircraftKillsList
PUBLIC	?RemoveObjectKillsList@@YAXXZ			; RemoveObjectKillsList
PUBLIC	?AddIAVehicleKill@@YAXVVU_ID@@0PAUVehicleClassDataType@@@Z ; AddIAVehicleKill
PUBLIC	?CheckEject@@YAXVVU_ID@@MM@Z			; CheckEject
PUBLIC	?CheckLanding@@YAXVVU_ID@@MM@Z			; CheckLanding
PUBLIC	?LoadInstantActionWindows@@YAXXZ		; LoadInstantActionWindows
PUBLIC	?ChangeTimeCB@@YAXJFPAVC_Base@@@Z		; ChangeTimeCB
PUBLIC	?CheckHighScore@@YAXJ@Z				; CheckHighScore
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??_7error_category@std@@6B@			; std::error_category::`vftable'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_C@_07DCLBNMLN@generic?$AA@			; `string'
PUBLIC	??_C@_0O@BFJCFAAK@unknown?5error?$AA@		; `string'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream?$AA@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	; `string'
PUBLIC	??_7_System_error_category@std@@6B@		; std::_System_error_category::`vftable'
PUBLIC	??_C@_06FHFOAHML@system?$AA@			; `string'
PUBLIC	?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
PUBLIC	?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
PUBLIC	?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
PUBLIC	?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
PUBLIC	?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
PUBLIC	?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA	; `GenerateFastRandom'::`2'::LastRandom
PUBLIC	?IAPlayerID@@3VVU_ID@@A				; IAPlayerID
PUBLIC	??_C@_0BP@KOIEKLOO@Software?2MicroProse?2Falcon?24?40?$AA@ ; `string'
PUBLIC	??_C@_08KDDNNMED@initData?$AA@			; `string'
PUBLIC	??_C@_0L@IEIHDOKC@ia_res?4lst?$AA@		; `string'
PUBLIC	??_C@_0L@MJMPJKJC@ia_art?4lst?$AA@		; `string'
PUBLIC	??_C@_0L@FEPJFIOF@ia_snd?4lst?$AA@		; `string'
PUBLIC	??_C@_0BG@BOIDIHL@art?2instant?2uidia?4scf?$AA@	; `string'
PUBLIC	??_C@_0L@HIOGJICO@ia_scf?4lst?$AA@		; `string'
PUBLIC	??_C@_07HMOCDNDG@Instant?$AA@			; `string'
PUBLIC	??_C@_04DIDHKLLF@?$CF1ld?$AA@			; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs?$AA@			; `string'
PUBLIC	??_C@_05OPOMBKKA@?$CI?$CF1d?$CJ?$AA@		; `string'
PUBLIC	??_C@_06OMDEMEG@?$CF1ld?$CF?$CF?$AA@		; `string'
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	?id@?$numpunct@_W@std@@2V0locale@2@A		; std::numpunct<wchar_t>::id
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_R4error_category@std@@6B@			; std::error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error_category@std@@6B@		; std::_System_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_System_error_category@std@@@8		; std::_System_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_System_error_category@std@@8		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error_category@std@@8		; std::_System_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error_category@std@@8	; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
PUBLIC	__real@3e051eb8
PUBLIC	__real@3f000000
PUBLIC	__real@3f3d70a4
PUBLIC	__real@3f800000
PUBLIC	__real@42480000
PUBLIC	__real@42a00000
PUBLIC	__real@42c80000
PUBLIC	__real@447a0000
PUBLIC	__real@454cffae
PUBLIC	__real@45800000
PUBLIC	__real@464cff9a
PUBLIC	__real@477fff00
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_strcpy:PROC
EXTRN	_strlen:PROC
EXTRN	_memmove:PROC
EXTRN	__imp__PostMessageA@16:PROC
EXTRN	__imp__RegCloseKey@4:PROC
EXTRN	__imp__RegOpenKeyExA@20:PROC
EXTRN	__imp__RegQueryValueExA@24:PROC
EXTRN	__imp__RegSetValueExA@24:PROC
EXTRN	_sprintf:PROC
EXTRN	_rand:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	??_Eerror_category@std@@UAEPAXI@Z:PROC		; std::error_category::`vector deleting destructor'
EXTRN	?_Syserror_map@std@@YAPBDH@Z:PROC		; std::_Syserror_map
EXTRN	?_Winerror_map@std@@YAPBDH@Z:PROC		; std::_Winerror_map
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_E_System_error_category@std@@UAEPAXI@Z:PROC	; std::_System_error_category::`vector deleting destructor'
EXTRN	__mbslen:PROC
EXTRN	__mbsnbcpy:PROC
EXTRN	?GetHeight@C_Font@@QAEHJ@Z:PROC			; C_Font::GetHeight
EXTRN	?GetSound@C_Sound@@QAEPAVSOUND_RES@@J@Z:PROC	; C_Sound::GetSound
EXTRN	?PlaySoundA@C_Sound@@QAEHPAVSOUND_RES@@@Z:PROC	; C_Sound::PlaySoundA
EXTRN	?GetString@C_String@@QAEPADJ@Z:PROC		; C_String::GetString
EXTRN	?Pick@C_SoundBite@@QAEJJ@Z:PROC			; C_SoundBite::Pick
EXTRN	?GetUserNumber@C_Base@@QAEJJ@Z:PROC		; C_Base::GetUserNumber
EXTRN	?SetText@C_EditBox@@QAEXPAD@Z:PROC		; C_EditBox::SetText
EXTRN	?SetInteger@C_EditBox@@QAEXJ@Z:PROC		; C_EditBox::SetInteger
EXTRN	?GetText@C_EditBox@@QAEPADXZ:PROC		; C_EditBox::GetText
EXTRN	??0C_Text@@QAE@XZ:PROC				; C_Text::C_Text
EXTRN	?SetFGColor@C_Text@@QAEXK@Z:PROC		; C_Text::SetFGColor
EXTRN	?SetFixedWidth@C_Text@@QAEXJ@Z:PROC		; C_Text::SetFixedWidth
EXTRN	?GetTime@C_Clock@@QAEJXZ:PROC			; C_Clock::GetTime
EXTRN	?LoadWindowList@C_Parser@@QAEHPAD@Z:PROC	; C_Parser::LoadWindowList
EXTRN	?LoadSoundList@C_Parser@@QAEHPAD@Z:PROC		; C_Parser::LoadSoundList
EXTRN	?LoadImageList@C_Parser@@QAEHPAD@Z:PROC		; C_Parser::LoadImageList
EXTRN	?ParseSoundBite@C_Parser@@QAEPAVC_SoundBite@@PAD@Z:PROC ; C_Parser::ParseSoundBite
EXTRN	?ScanClientAreas@C_Window@@QAEXXZ:PROC		; C_Window::ScanClientAreas
EXTRN	?AddControl@C_Window@@QAEXPAVC_Base@@@Z:PROC	; C_Window::AddControl
EXTRN	?SetControl@C_Window@@QAEXJ@Z:PROC		; C_Window::SetControl
EXTRN	?RefreshWindow@C_Window@@QAEXXZ:PROC		; C_Window::RefreshWindow
EXTRN	?FindControl@C_Window@@QAEPAVC_Base@@J@Z:PROC	; C_Window::FindControl
EXTRN	?EnableWindowGroup@C_Handler@@QAEXJ@Z:PROC	; C_Handler::EnableWindowGroup
EXTRN	?DisableWindowGroup@C_Handler@@QAEXJ@Z:PROC	; C_Handler::DisableWindowGroup
EXTRN	?WindowToFront@C_Handler@@QAEXPAVC_Window@@@Z:PROC ; C_Handler::WindowToFront
EXTRN	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z:PROC ; C_Handler::FindWindowA
EXTRN	?GetClassNameA@@YAPADH@Z:PROC			; GetClassNameA
EXTRN	?MapVisId@@YAKK@Z:PROC				; MapVisId
EXTRN	?LoadCampaign@CampaignClass@@QAEHW4FalconGameType@@PAD@Z:PROC ; CampaignClass::LoadCampaign
EXTRN	?EndCampaign@CampaignClass@@QAEXXZ:PROC		; CampaignClass::EndCampaign
EXTRN	?SetOnlineStatus@CampaignClass@@QAEXH@Z:PROC	; CampaignClass::SetOnlineStatus
EXTRN	?create_player_flight@instant_action@@SAXXZ:PROC ; instant_action::create_player_flight
EXTRN	?set_start_wave@instant_action@@SAXH@Z:PROC	; instant_action::set_start_wave
EXTRN	?set_start_mode@instant_action@@SAXD@Z:PROC	; instant_action::set_start_mode
EXTRN	?set_start_position@instant_action@@SAXMM@Z:PROC ; instant_action::set_start_position
EXTRN	?get_start_position@instant_action@@SAXAAM0@Z:PROC ; instant_action::get_start_position
EXTRN	?set_start_time@instant_action@@SAXJ@Z:PROC	; instant_action::set_start_time
EXTRN	?ProcessEventList@@YAXPAVC_Window@@J@Z:PROC	; ProcessEventList
EXTRN	?SetSingle_Comms_Ctrls@@YAXXZ:PROC		; SetSingle_Comms_Ctrls
EXTRN	?UI_Help_Guide_CB@@YAXJFPAVC_Base@@@Z:PROC	; UI_Help_Guide_CB
EXTRN	?EncryptBuffer@@YAXEPAEJ@Z:PROC			; EncryptBuffer
EXTRN	?DecryptBuffer@@YAXEPAEJ@Z:PROC			; DecryptBuffer
EXTRN	?CloseWindowCB@@YAXJFPAVC_Base@@@Z:PROC		; CloseWindowCB
EXTRN	?OpenMunitionsWindowCB@@YAXJFPAVC_Base@@@Z:PROC	; OpenMunitionsWindowCB
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	?FalconNullId@@3VVU_ID@@A:QWORD			; FalconNullId
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?gFontList@@3PAVC_Font@@A:DWORD			; gFontList
EXTRN	?gSoundMgr@@3PAVC_Sound@@A:DWORD		; gSoundMgr
EXTRN	?gStringMgr@@3PAVC_String@@A:DWORD		; gStringMgr
EXTRN	?_LOAD_ART_RESOURCES_@@3JA:DWORD		; _LOAD_ART_RESOURCES_
EXTRN	?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A:DWORD ; Falcon4ClassTable
EXTRN	?UI_logbk@@3VLogBookData@@A:BYTE		; UI_logbk
EXTRN	?TheCampaign@@3VCampaignClass@@A:BYTE		; TheCampaign
EXTRN	?PlayerOptions@@3VPlayerOptionsClass@@A:BYTE	; PlayerOptions
EXTRN	?TheMap@@3VTMap@@A:BYTE				; TheMap
EXTRN	?gMainHandler@@3PAVC_Handler@@A:DWORD		; gMainHandler
EXTRN	?gUI_CampaignFile@@3PADA:BYTE			; gUI_CampaignFile
EXTRN	?gMainParser@@3PAVC_Parser@@A:DWORD		; gMainParser
EXTRN	?MainLastGroup@@3HA:DWORD			; MainLastGroup
EXTRN	?IALoaded@@3HA:DWORD				; IALoaded
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
_BSS	SEGMENT
?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Generic_object
_BSS	ENDS
;	COMDAT ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
_BSS	SEGMENT
?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Iostream_object
_BSS	ENDS
;	COMDAT ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
_BSS	SEGMENT
?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_System_object
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
_BSS	ENDS
;	COMDAT ?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA
_BSS	SEGMENT
?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA DD 01H DUP (?) ; `GenerateFastRandom'::`2'::LastRandom
_BSS	ENDS
_BSS	SEGMENT
	ALIGN	8

?IAPlayerID@@3VVU_ID@@A DQ 01H DUP (?)			; IAPlayerID
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@_W@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@_W@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<wchar_t>::id
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@477fff00
CONST	SEGMENT
__real@477fff00 DD 0477fff00r			; 65535
CONST	ENDS
;	COMDAT __real@464cff9a
CONST	SEGMENT
__real@464cff9a DD 0464cff9ar			; 13119.9
CONST	ENDS
;	COMDAT __real@45800000
CONST	SEGMENT
__real@45800000 DD 045800000r			; 4096
CONST	ENDS
;	COMDAT __real@454cffae
CONST	SEGMENT
__real@454cffae DD 0454cffaer			; 3279.98
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@42a00000
CONST	SEGMENT
__real@42a00000 DD 042a00000r			; 80
CONST	ENDS
;	COMDAT __real@42480000
CONST	SEGMENT
__real@42480000 DD 042480000r			; 50
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f3d70a4
CONST	SEGMENT
__real@3f3d70a4 DD 03f3d70a4r			; 0.74
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3e051eb8
CONST	SEGMENT
__real@3e051eb8 DD 03e051eb8r			; 0.13
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error_category@std@@8 DD FLAT:??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error_category@std@@8
rdata$r	SEGMENT
??_R2_System_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error_category@std@@8
rdata$r	SEGMENT
??_R3_System_error_category@std@@8 DD 00H		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_System_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_System_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_System_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_System_error_category@std@@6B@ DD 00H		; std::_System_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error_category@std@@@8
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD FLAT:??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 00H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category@std@@@8
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
_DATA	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4error_category@std@@6B@
rdata$r	SEGMENT
??_R4error_category@std@@6B@ DD 00H			; std::error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVerror_category@std@@@8
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_06OMDEMEG@?$CF1ld?$CF?$CF?$AA@
CONST	SEGMENT
??_C@_06OMDEMEG@?$CF1ld?$CF?$CF?$AA@ DB '%1ld%%', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05OPOMBKKA@?$CI?$CF1d?$CJ?$AA@
CONST	SEGMENT
??_C@_05OPOMBKKA@?$CI?$CF1d?$CJ?$AA@ DB '(%1d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs?$AA@ DB '%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04DIDHKLLF@?$CF1ld?$AA@
CONST	SEGMENT
??_C@_04DIDHKLLF@?$CF1ld?$AA@ DB '%1ld', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07HMOCDNDG@Instant?$AA@
CONST	SEGMENT
??_C@_07HMOCDNDG@Instant?$AA@ DB 'Instant', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HIOGJICO@ia_scf?4lst?$AA@
CONST	SEGMENT
??_C@_0L@HIOGJICO@ia_scf?4lst?$AA@ DB 'ia_scf.lst', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@BOIDIHL@art?2instant?2uidia?4scf?$AA@
CONST	SEGMENT
??_C@_0BG@BOIDIHL@art?2instant?2uidia?4scf?$AA@ DB 'art\instant\uidia.scf'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FEPJFIOF@ia_snd?4lst?$AA@
CONST	SEGMENT
??_C@_0L@FEPJFIOF@ia_snd?4lst?$AA@ DB 'ia_snd.lst', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MJMPJKJC@ia_art?4lst?$AA@
CONST	SEGMENT
??_C@_0L@MJMPJKJC@ia_art?4lst?$AA@ DB 'ia_art.lst', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IEIHDOKC@ia_res?4lst?$AA@
CONST	SEGMENT
??_C@_0L@IEIHDOKC@ia_res?4lst?$AA@ DB 'ia_res.lst', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08KDDNNMED@initData?$AA@
CONST	SEGMENT
??_C@_08KDDNNMED@initData?$AA@ DB 'initData', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@KOIEKLOO@Software?2MicroProse?2Falcon?24?40?$AA@
CONST	SEGMENT
??_C@_0BP@KOIEKLOO@Software?2MicroProse?2Falcon?24?40?$AA@ DB 'Software\M'
	DB	'icroProse\Falcon\4.0', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system?$AA@
CONST	SEGMENT
??_C@_06FHFOAHML@system?$AA@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_System_error_category@std@@6B@
CONST	SEGMENT
??_7_System_error_category@std@@6B@ DD FLAT:??_R4_System_error_category@std@@6B@ ; std::_System_error_category::`vftable'
	DD	FLAT:??_E_System_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_System_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ DB 'iostream stream error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream?$AA@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream?$AA@ DB 'iostream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DD FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DD	FLAT:??_E_Iostream_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
CONST	SEGMENT
??_C@_0O@BFJCFAAK@unknown?5error?$AA@ DB 'unknown error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic?$AA@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic?$AA@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7error_category@std@@6B@
CONST	SEGMENT
??_7error_category@std@@6B@ DD FLAT:??_R4error_category@std@@6B@ ; std::error_category::`vftable'
	DD	FLAT:??_Eerror_category@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
__ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
xdata$x	SEGMENT
__unwindtable$?ProcessWeapons@@YAXPAVC_Window@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ProcessWeapons@@YAXPAVC_Window@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ProcessWeapons@@YAXPAVC_Window@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ProcessWeapons@@YAXPAVC_Window@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ProcessWeapons@@YAXPAVC_Window@@@Z$3
__ehfuncinfo$?ProcessWeapons@@YAXPAVC_Window@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?ProcessWeapons@@YAXPAVC_Window@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?ProcessKills@@YAXPAVC_Window@@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?ProcessKills@@YAXPAVC_Window@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ProcessKills@@YAXPAVC_Window@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ProcessKills@@YAXPAVC_Window@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ProcessKills@@YAXPAVC_Window@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ProcessKills@@YAXPAVC_Window@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ProcessKills@@YAXPAVC_Window@@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ProcessKills@@YAXPAVC_Window@@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ProcessKills@@YAXPAVC_Window@@@Z$5
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_IAPlayerID$initializer$ DD FLAT:??__EIAPlayerID@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Generic_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Iostream_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_System_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@D@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<char>::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@_W@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<wchar_t>::id$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 621  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();
; 624  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
_this$ = -24						; size = 4
tv73 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR __V0$[ebp]
	push	ecx
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<wchar_t>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@_W@std@@2V0locale@2@A ; std::numpunct<wchar_t>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<wchar_t>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<char>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<char>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 755  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp

; 756  : 		{	// destroy object at _Ptr
; 757  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>

; 758  : 		}

	pop	ebp
	ret	0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
	pop	ebp
	ret	0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	ebp
	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??1_System_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_System_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??0_System_error_category@std@@QAE@XZ	; std::_System_error_category::_System_error_category
	push	OFFSET ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_System_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??1_Iostream_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??0_Iostream_error_category@std@@QAE@XZ	; std::_Iostream_error_category::_Iostream_error_category
	push	OFFSET ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??1_Generic_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	push	OFFSET ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], -1
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 85   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 89   : 	}

	pop	ebp
	ret	0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 907  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
	add	esp, 8

; 910  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
	add	esp, 12					; 0000000cH
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\instant\instant.cpp
_TEXT	SEGMENT
_txt$ = -48						; size = 4
_win$ = -44						; size = 4
_i$ = -40						; size = 4
_SoundID$ = -36						; size = 4
_buffer$ = -32						; size = 25
__$ArrayPad$ = -4					; size = 4
_TotalScore$ = 8					; size = 4
?CheckHighScore@@YAXJ@Z PROC				; CheckHighScore

; 1507 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1508 : 	C_Window *win;
; 1509 : 	int i;
; 1510 : 	C_Text *txt;
; 1511 : 	long SoundID;
; 1512 : 	_TCHAR buffer[25];
; 1513 : 
; 1514 : 	i=0;

	mov	DWORD PTR _i$[ebp], 0
$LN28@CheckHighS:

; 1515 : 	while(i < MAX_SCORES && TotalScore <= Scores.Scores[i].Score && Scores.Scores[i].Name[0] != 0)

	cmp	DWORD PTR _i$[ebp], 12			; 0000000cH
	jge	SHORT $LN27@CheckHighS
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 36					; 00000024H
	mov	ecx, DWORD PTR _TotalScore$[ebp]
	cmp	ecx, DWORD PTR ?Scores@@3UHighScoreList@@A[eax+32]
	jg	SHORT $LN27@CheckHighS
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 36					; 00000024H
	mov	eax, 1
	imul	eax, 0
	movsx	ecx, BYTE PTR ?Scores@@3UHighScoreList@@A[edx+eax]
	test	ecx, ecx
	je	SHORT $LN27@CheckHighS

; 1516 : 		i++;

	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	jmp	SHORT $LN28@CheckHighS
$LN27@CheckHighS:

; 1517 : 
; 1518 : 	if(TotalScore < 0)

	cmp	DWORD PTR _TotalScore$[ebp], 0
	jge	SHORT $LN26@CheckHighS

; 1519 : 	{
; 1520 : 		SoundID=gInstantBites->Pick(IA1);

	push	450000					; 0006ddd0H
	mov	ecx, DWORD PTR ?gInstantBites@@3PAVC_SoundBite@@A ; gInstantBites
	call	?Pick@C_SoundBite@@QAEJJ@Z		; C_SoundBite::Pick
	mov	DWORD PTR _SoundID$[ebp], eax

; 1521 : 		if(SoundID)

	cmp	DWORD PTR _SoundID$[ebp], 0
	je	SHORT $LN25@CheckHighS

; 1522 : 			gSoundMgr->PlaySound(SoundID);

	mov	eax, DWORD PTR _SoundID$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?gSoundMgr@@3PAVC_Sound@@A ; gSoundMgr
	call	?PlaySoundA@C_Sound@@QAEHJ@Z		; C_Sound::PlaySoundA
$LN25@CheckHighS:

; 1523 : 	}

	jmp	$LN24@CheckHighS
$LN26@CheckHighS:

; 1524 : 	else if(TotalScore < _A_LOW_SCORE_)

	cmp	DWORD PTR _TotalScore$[ebp], 250000	; 0003d090H
	jge	SHORT $LN23@CheckHighS

; 1525 : 	{
; 1526 : 		SoundID=gInstantBites->Pick(IA2);

	push	450003					; 0006ddd3H
	mov	ecx, DWORD PTR ?gInstantBites@@3PAVC_SoundBite@@A ; gInstantBites
	call	?Pick@C_SoundBite@@QAEJJ@Z		; C_SoundBite::Pick
	mov	DWORD PTR _SoundID$[ebp], eax

; 1527 : 		if(SoundID)

	cmp	DWORD PTR _SoundID$[ebp], 0
	je	SHORT $LN22@CheckHighS

; 1528 : 			gSoundMgr->PlaySound(SoundID);

	mov	ecx, DWORD PTR _SoundID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?gSoundMgr@@3PAVC_Sound@@A ; gSoundMgr
	call	?PlaySoundA@C_Sound@@QAEHJ@Z		; C_Sound::PlaySoundA
$LN22@CheckHighS:

; 1529 : 	}

	jmp	$LN24@CheckHighS
$LN23@CheckHighS:

; 1530 : 	else if(TotalScore < _A_MEDIUM_SCORE_)

	cmp	DWORD PTR _TotalScore$[ebp], 500000	; 0007a120H
	jge	SHORT $LN20@CheckHighS

; 1531 : 	{
; 1532 : 		SoundID=gInstantBites->Pick(IA3);

	push	450005					; 0006ddd5H
	mov	ecx, DWORD PTR ?gInstantBites@@3PAVC_SoundBite@@A ; gInstantBites
	call	?Pick@C_SoundBite@@QAEJJ@Z		; C_SoundBite::Pick
	mov	DWORD PTR _SoundID$[ebp], eax

; 1533 : 		if(SoundID)

	cmp	DWORD PTR _SoundID$[ebp], 0
	je	SHORT $LN19@CheckHighS

; 1534 : 			gSoundMgr->PlaySound(SoundID);

	mov	edx, DWORD PTR _SoundID$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?gSoundMgr@@3PAVC_Sound@@A ; gSoundMgr
	call	?PlaySoundA@C_Sound@@QAEHJ@Z		; C_Sound::PlaySoundA
$LN19@CheckHighS:

; 1535 : 	}

	jmp	$LN24@CheckHighS
$LN20@CheckHighS:

; 1536 : 	else if(!i)

	cmp	DWORD PTR _i$[ebp], 0
	jne	SHORT $LN17@CheckHighS

; 1537 : 	{
; 1538 : 		SoundID=gInstantBites->Pick(IA8);

	push	450013					; 0006ddddH
	mov	ecx, DWORD PTR ?gInstantBites@@3PAVC_SoundBite@@A ; gInstantBites
	call	?Pick@C_SoundBite@@QAEJJ@Z		; C_SoundBite::Pick
	mov	DWORD PTR _SoundID$[ebp], eax

; 1539 : 		if(SoundID)

	cmp	DWORD PTR _SoundID$[ebp], 0
	je	SHORT $LN16@CheckHighS

; 1540 : 			gSoundMgr->PlaySound(SoundID);

	mov	eax, DWORD PTR _SoundID$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?gSoundMgr@@3PAVC_Sound@@A ; gSoundMgr
	call	?PlaySoundA@C_Sound@@QAEHJ@Z		; C_Sound::PlaySoundA
$LN16@CheckHighS:

; 1541 : 	}

	jmp	$LN24@CheckHighS
$LN17@CheckHighS:

; 1542 : 	else if(i == 1 )

	cmp	DWORD PTR _i$[ebp], 1
	jne	SHORT $LN14@CheckHighS

; 1543 : 	{
; 1544 : 		SoundID=gInstantBites->Pick(IA7);

	push	450012					; 0006dddcH
	mov	ecx, DWORD PTR ?gInstantBites@@3PAVC_SoundBite@@A ; gInstantBites
	call	?Pick@C_SoundBite@@QAEJJ@Z		; C_SoundBite::Pick
	mov	DWORD PTR _SoundID$[ebp], eax

; 1545 : 		if(SoundID)

	cmp	DWORD PTR _SoundID$[ebp], 0
	je	SHORT $LN13@CheckHighS

; 1546 : 			gSoundMgr->PlaySound(SoundID);

	mov	ecx, DWORD PTR _SoundID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?gSoundMgr@@3PAVC_Sound@@A ; gSoundMgr
	call	?PlaySoundA@C_Sound@@QAEHJ@Z		; C_Sound::PlaySoundA
$LN13@CheckHighS:

; 1547 : 	}

	jmp	$LN24@CheckHighS
$LN14@CheckHighS:

; 1548 : 	else if(i >= 2 && i <= 6)

	cmp	DWORD PTR _i$[ebp], 2
	jl	SHORT $LN11@CheckHighS
	cmp	DWORD PTR _i$[ebp], 6
	jg	SHORT $LN11@CheckHighS

; 1549 : 	{
; 1550 : 		SoundID=gInstantBites->Pick(IA6);

	push	450009					; 0006ddd9H
	mov	ecx, DWORD PTR ?gInstantBites@@3PAVC_SoundBite@@A ; gInstantBites
	call	?Pick@C_SoundBite@@QAEJJ@Z		; C_SoundBite::Pick
	mov	DWORD PTR _SoundID$[ebp], eax

; 1551 : 		if(SoundID)

	cmp	DWORD PTR _SoundID$[ebp], 0
	je	SHORT $LN10@CheckHighS

; 1552 : 			gSoundMgr->PlaySound(SoundID);

	mov	edx, DWORD PTR _SoundID$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?gSoundMgr@@3PAVC_Sound@@A ; gSoundMgr
	call	?PlaySoundA@C_Sound@@QAEHJ@Z		; C_Sound::PlaySoundA
$LN10@CheckHighS:

; 1553 : 	}

	jmp	SHORT $LN24@CheckHighS
$LN11@CheckHighS:

; 1554 : 	else if(i >= 7 && i <= 11)

	cmp	DWORD PTR _i$[ebp], 7
	jl	SHORT $LN8@CheckHighS
	cmp	DWORD PTR _i$[ebp], 11			; 0000000bH
	jg	SHORT $LN8@CheckHighS

; 1555 : 	{
; 1556 : 		SoundID=gInstantBites->Pick(IA5);

	push	450008					; 0006ddd8H
	mov	ecx, DWORD PTR ?gInstantBites@@3PAVC_SoundBite@@A ; gInstantBites
	call	?Pick@C_SoundBite@@QAEJJ@Z		; C_SoundBite::Pick
	mov	DWORD PTR _SoundID$[ebp], eax

; 1557 : 		if(SoundID)

	cmp	DWORD PTR _SoundID$[ebp], 0
	je	SHORT $LN7@CheckHighS

; 1558 : 			gSoundMgr->PlaySound(SoundID);

	mov	eax, DWORD PTR _SoundID$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?gSoundMgr@@3PAVC_Sound@@A ; gSoundMgr
	call	?PlaySoundA@C_Sound@@QAEHJ@Z		; C_Sound::PlaySoundA
$LN7@CheckHighS:

; 1559 : 	}
; 1560 : 	else

	jmp	SHORT $LN24@CheckHighS
$LN8@CheckHighS:

; 1561 : 	{
; 1562 : 		SoundID=gInstantBites->Pick(IA4);

	push	450007					; 0006ddd7H
	mov	ecx, DWORD PTR ?gInstantBites@@3PAVC_SoundBite@@A ; gInstantBites
	call	?Pick@C_SoundBite@@QAEJJ@Z		; C_SoundBite::Pick
	mov	DWORD PTR _SoundID$[ebp], eax

; 1563 : 		if(SoundID)

	cmp	DWORD PTR _SoundID$[ebp], 0
	je	SHORT $LN24@CheckHighS

; 1564 : 			gSoundMgr->PlaySound(SoundID);

	mov	ecx, DWORD PTR _SoundID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?gSoundMgr@@3PAVC_Sound@@A ; gSoundMgr
	call	?PlaySoundA@C_Sound@@QAEHJ@Z		; C_Sound::PlaySoundA
$LN24@CheckHighS:

; 1565 : 	}
; 1566 : 
; 1567 : 	if(i < MAX_SCORES)

	cmp	DWORD PTR _i$[ebp], 12			; 0000000cH
	jge	$LN4@CheckHighS

; 1568 : 	{
; 1569 : 		win=gMainHandler->FindWindow(IA_HS_WIN);

	push	10036					; 00002734H
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z ; C_Handler::FindWindowA
	mov	DWORD PTR _win$[ebp], eax

; 1570 : 		if(win)

	cmp	DWORD PTR _win$[ebp], 0
	je	$LN3@CheckHighS

; 1571 : 		{
; 1572 : 			gMainHandler->EnableWindowGroup(win->GetGroup());

	mov	ecx, DWORD PTR _win$[ebp]
	call	?GetGroup@C_Window@@QAEJXZ		; C_Window::GetGroup
	push	eax
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?EnableWindowGroup@C_Handler@@QAEXJ@Z	; C_Handler::EnableWindowGroup

; 1573 : 			txt=(C_Text *)win->FindControl(IA_HS_FIELD);

	push	10040					; 00002738H
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _txt$[ebp], eax

; 1574 : 			if(txt)

	cmp	DWORD PTR _txt$[ebp], 0
	je	SHORT $LN2@CheckHighS

; 1575 : 			{
; 1576 : 				_stprintf(buffer,"%1ld",TotalScore);

	mov	edx, DWORD PTR _TotalScore$[ebp]
	push	edx
	push	OFFSET ??_C@_04DIDHKLLF@?$CF1ld?$AA@
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1577 : 				AddCommas(buffer);

	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	?AddCommas@@YAPADPAD@Z			; AddCommas
	add	esp, 4

; 1578 : 				txt->SetText(buffer);

	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+256]
	call	eax
$LN2@CheckHighS:

; 1579 : 			}
; 1580 : 			gMainHandler->WindowToFront(win);

	mov	ecx, DWORD PTR _win$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?WindowToFront@C_Handler@@QAEXPAVC_Window@@@Z ; C_Handler::WindowToFront

; 1581 : 			win->RefreshWindow();

	mov	ecx, DWORD PTR _win$[ebp]
	call	?RefreshWindow@C_Window@@QAEXXZ		; C_Window::RefreshWindow

; 1582 : 			win->SetControl(IA_HS_NAME_EDIT);

	push	10042					; 0000273aH
	mov	ecx, DWORD PTR _win$[ebp]
	call	?SetControl@C_Window@@QAEXJ@Z		; C_Window::SetControl
$LN3@CheckHighS:

; 1583 : 		}
; 1584 : 	}
; 1585 : 	else

	jmp	SHORT $LN29@CheckHighS
$LN4@CheckHighS:

; 1586 : 	{
; 1587 : 		win=gMainHandler->FindWindow(IA_DBRF_WIN);

	push	10023					; 00002727H
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z ; C_Handler::FindWindowA
	mov	DWORD PTR _win$[ebp], eax

; 1588 : 		gMainHandler->EnableWindowGroup(win->GetGroup());

	mov	ecx, DWORD PTR _win$[ebp]
	call	?GetGroup@C_Window@@QAEJXZ		; C_Window::GetGroup
	push	eax
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?EnableWindowGroup@C_Handler@@QAEXJ@Z	; C_Handler::EnableWindowGroup
$LN29@CheckHighS:

; 1589 : 	}
; 1590 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?CheckHighScore@@YAXJ@Z ENDP				; CheckHighScore
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\instant\instant.cpp
_TEXT	SEGMENT
$T2 = -188						; size = 4
$T3 = -184						; size = 4
$T4 = -180						; size = 4
$T5 = -176						; size = 4
_fh$ = -172						; size = 4
_wc$ = -168						; size = 4
$T6 = -164						; size = 4
tv176 = -160						; size = 4
tv305 = -156						; size = 4
$T7 = -152						; size = 4
$T8 = -148						; size = 4
tv85 = -144						; size = 4
$T9 = -140						; size = 4
tv241 = -136						; size = 4
_UseFont$ = -132					; size = 4
_y$ = -128						; size = 4
_cur$ = -124						; size = 4
_txt$ = -120						; size = 4
_buffer$ = -116						; size = 100
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_win$ = 8						; size = 4
?ProcessWeapons@@YAXPAVC_Window@@@Z PROC		; ProcessWeapons

; 1417 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ProcessWeapons@@YAXPAVC_Window@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 176				; 000000b0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1418 : 	int y,fh;
; 1419 : 	C_Text *txt;
; 1420 : 	_TCHAR buffer[100];
; 1421 : 	WeaponClassDataType		*wc;
; 1422 : 	kill_list *cur;
; 1423 : 	long UseFont;
; 1424 : 
; 1425 : 	y=0;

	mov	DWORD PTR _y$[ebp], 0

; 1426 : 	UseFont=win->Font_;

	mov	eax, DWORD PTR _win$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	mov	DWORD PTR _UseFont$[ebp], ecx

; 1427 : 	fh=gFontList->GetHeight(UseFont);

	mov	edx, DWORD PTR _UseFont$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?gFontList@@3PAVC_Font@@A ; gFontList
	call	?GetHeight@C_Font@@QAEHJ@Z		; C_Font::GetHeight
	mov	DWORD PTR _fh$[ebp], eax

; 1428 : 
; 1429 : 	if(WeaponUsage)

	cmp	DWORD PTR ?WeaponUsage@@3PAUkill_list@@A, 0 ; WeaponUsage
	je	$LN6@ProcessWea

; 1430 : 	{
; 1431 : 		cur=WeaponUsage;

	mov	eax, DWORD PTR ?WeaponUsage@@3PAUkill_list@@A ; WeaponUsage
	mov	DWORD PTR _cur$[ebp], eax
$LN5@ProcessWea:

; 1432 : 		while(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	$LN4@ProcessWea

; 1433 : 		{
; 1434 : 			wc=(WeaponClassDataType *)Falcon4ClassTable[cur->id].dataPtr;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx]
	imul	edx, 81					; 00000051H
	mov	eax, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	ecx, DWORD PTR [eax+edx+77]
	mov	DWORD PTR _wc$[ebp], ecx

; 1435 : 			_stprintf(buffer,"%s",wc->Name);

	mov	edx, DWORD PTR _wc$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	push	OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1436 : 			txt=new C_Text;

	push	76					; 0000004cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T9[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T9[ebp], 0
	je	SHORT $LN9@ProcessWea
	mov	ecx, DWORD PTR $T9[ebp]
	call	??0C_Text@@QAE@XZ			; C_Text::C_Text
	mov	DWORD PTR tv85[ebp], eax
	jmp	SHORT $LN10@ProcessWea
$LN9@ProcessWea:
	mov	DWORD PTR tv85[ebp], 0
$LN10@ProcessWea:
	mov	ecx, DWORD PTR tv85[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR _txt$[ebp], edx

; 1437 : 			txt->Setup(C_DONT_CARE,C_TYPE_LEFT);

	push	44					; 0000002cH
	push	-2					; fffffffeH
	mov	eax, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax

; 1438 : 			txt->SetText(buffer);

	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax+256]
	call	edx

; 1439 : 			txt->SetXY(20,y);

	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	push	20					; 00000014H
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1440 : 			txt->SetFGColor(0xf0f0f0);

	push	15790320				; 00f0f0f0H
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetFGColor@C_Text@@QAEXK@Z		; C_Text::SetFGColor

; 1441 : 			txt->SetFont(UseFont);

	mov	ecx, DWORD PTR _UseFont$[ebp]
	push	ecx
	mov	edx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax+68]
	call	edx

; 1442 : 			txt->SetFlagBitOn(C_BIT_LEFT);

	push	32					; 00000020H
	mov	eax, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 1443 : 			txt->SetClient(3);

	push	3
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetClient@C_Base@@QAEXF@Z		; C_Base::SetClient

; 1444 : 			win->AddControl(txt);

	mov	ecx, DWORD PTR _txt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _win$[ebp]
	call	?AddControl@C_Window@@QAEXPAVC_Base@@@Z	; C_Window::AddControl

; 1445 : 
; 1446 : 			_stprintf(buffer,"(%1d)",cur->num);

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	push	OFFSET ??_C@_05OPOMBKKA@?$CI?$CF1d?$CJ?$AA@
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1447 : 			txt=new C_Text;

	push	76					; 0000004cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T6[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T6[ebp], 0
	je	SHORT $LN11@ProcessWea
	mov	ecx, DWORD PTR $T6[ebp]
	call	??0C_Text@@QAE@XZ			; C_Text::C_Text
	mov	DWORD PTR tv176[ebp], eax
	jmp	SHORT $LN12@ProcessWea
$LN11@ProcessWea:
	mov	DWORD PTR tv176[ebp], 0
$LN12@ProcessWea:
	mov	edx, DWORD PTR tv176[ebp]
	mov	DWORD PTR $T5[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T5[ebp]
	mov	DWORD PTR _txt$[ebp], eax

; 1448 : 			txt->Setup(C_DONT_CARE,C_TYPE_LEFT);

	push	44					; 0000002cH
	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax

; 1449 : 			txt->SetFixedWidth(_tcsclen(buffer)+1);

	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	__tcsclen
	add	esp, 4
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetFixedWidth@C_Text@@QAEXJ@Z		; C_Text::SetFixedWidth

; 1450 : 			txt->SetText(buffer);

	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+256]
	call	eax

; 1451 : 			txt->SetXY(130,y);

	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	push	130					; 00000082H
	mov	edx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 1452 : 			txt->SetFGColor(0xf0f0f0);

	push	15790320				; 00f0f0f0H
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetFGColor@C_Text@@QAEXK@Z		; C_Text::SetFGColor

; 1453 : 			txt->SetFont(UseFont);

	mov	eax, DWORD PTR _UseFont$[ebp]
	push	eax
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+68]
	call	eax

; 1454 : 			txt->SetFlagBitOn(C_BIT_LEFT);

	push	32					; 00000020H
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 1455 : 			txt->SetClient(3);

	push	3
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetClient@C_Base@@QAEXF@Z		; C_Base::SetClient

; 1456 : 			win->AddControl(txt);

	mov	ecx, DWORD PTR _txt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _win$[ebp]
	call	?AddControl@C_Window@@QAEXPAVC_Base@@@Z	; C_Window::AddControl

; 1457 : 
; 1458 : 			_stprintf(buffer,"%1ld",cur->points);

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	push	OFFSET ??_C@_04DIDHKLLF@?$CF1ld?$AA@
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1459 : 			AddCommas(buffer);

	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	?AddCommas@@YAPADPAD@Z			; AddCommas
	add	esp, 4

; 1460 : 			txt=new C_Text;

	push	76					; 0000004cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T7[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	cmp	DWORD PTR $T7[ebp], 0
	je	SHORT $LN13@ProcessWea
	mov	ecx, DWORD PTR $T7[ebp]
	call	??0C_Text@@QAE@XZ			; C_Text::C_Text
	mov	DWORD PTR tv241[ebp], eax
	jmp	SHORT $LN14@ProcessWea
$LN13@ProcessWea:
	mov	DWORD PTR tv241[ebp], 0
$LN14@ProcessWea:
	mov	eax, DWORD PTR tv241[ebp]
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR _txt$[ebp], ecx

; 1461 : 			txt->Setup(C_DONT_CARE,C_TYPE_RIGHT);

	push	46					; 0000002eH
	push	-2					; fffffffeH
	mov	edx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax+248]
	call	edx

; 1462 : 			txt->SetFixedWidth(_tcsclen(buffer)+1);

	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	__tcsclen
	add	esp, 4
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetFixedWidth@C_Text@@QAEXJ@Z		; C_Text::SetFixedWidth

; 1463 : 			txt->SetText(buffer);

	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax+256]
	call	edx

; 1464 : 			txt->SetXY(215,y);

	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	push	215					; 000000d7H
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1465 : 			txt->SetFGColor(0x00ff00);

	push	65280					; 0000ff00H
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetFGColor@C_Text@@QAEXK@Z		; C_Text::SetFGColor

; 1466 : 			txt->SetFont(UseFont);

	mov	ecx, DWORD PTR _UseFont$[ebp]
	push	ecx
	mov	edx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax+68]
	call	edx

; 1467 : 			txt->SetFlagBitOn(C_BIT_RIGHT);

	push	64					; 00000040H
	mov	eax, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 1468 : 			txt->SetClient(3);

	push	3
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetClient@C_Base@@QAEXF@Z		; C_Base::SetClient

; 1469 : 			win->AddControl(txt);

	mov	ecx, DWORD PTR _txt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _win$[ebp]
	call	?AddControl@C_Window@@QAEXPAVC_Base@@@Z	; C_Window::AddControl

; 1470 : 
; 1471 : 			TotalScore+=cur->points;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR ?TotalScore@@3JA		; TotalScore
	add	eax, DWORD PTR [edx+8]
	mov	DWORD PTR ?TotalScore@@3JA, eax		; TotalScore

; 1472 : 
; 1473 : 			y+=fh;

	mov	ecx, DWORD PTR _y$[ebp]
	add	ecx, DWORD PTR _fh$[ebp]
	mov	DWORD PTR _y$[ebp], ecx

; 1474 : 			cur=cur->next;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _cur$[ebp], eax

; 1475 : 		}

	jmp	$LN5@ProcessWea
$LN4@ProcessWea:

; 1476 : 		RemoveWeaponUsageList();

	call	?RemoveWeaponUsageList@@YAXXZ		; RemoveWeaponUsageList

; 1477 : 	}
; 1478 : 	else

	jmp	$LN3@ProcessWea
$LN6@ProcessWea:

; 1479 : 	{
; 1480 : 		txt=new C_Text;

	push	76					; 0000004cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T8[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	cmp	DWORD PTR $T8[ebp], 0
	je	SHORT $LN15@ProcessWea
	mov	ecx, DWORD PTR $T8[ebp]
	call	??0C_Text@@QAE@XZ			; C_Text::C_Text
	mov	DWORD PTR tv305[ebp], eax
	jmp	SHORT $LN16@ProcessWea
$LN15@ProcessWea:
	mov	DWORD PTR tv305[ebp], 0
$LN16@ProcessWea:
	mov	ecx, DWORD PTR tv305[ebp]
	mov	DWORD PTR $T4[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T4[ebp]
	mov	DWORD PTR _txt$[ebp], edx

; 1481 : 		txt->Setup(C_DONT_CARE,C_TYPE_LEFT);

	push	44					; 0000002cH
	push	-2					; fffffffeH
	mov	eax, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax

; 1482 : 		txt->SetText(TXT_NO_WEAPONS_USED);

	push	80					; 00000050H
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+252]
	call	eax

; 1483 : 		txt->SetXY(20,y);

	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	push	20					; 00000014H
	mov	edx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 1484 : 		txt->SetFGColor(0xf0f0f0);

	push	15790320				; 00f0f0f0H
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetFGColor@C_Text@@QAEXK@Z		; C_Text::SetFGColor

; 1485 : 		txt->SetFont(UseFont);

	mov	eax, DWORD PTR _UseFont$[ebp]
	push	eax
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+68]
	call	eax

; 1486 : 		txt->SetFlagBitOn(C_BIT_LEFT);

	push	32					; 00000020H
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 1487 : 		txt->SetClient(3);

	push	3
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetClient@C_Base@@QAEXF@Z		; C_Base::SetClient

; 1488 : 		win->AddControl(txt);

	mov	ecx, DWORD PTR _txt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _win$[ebp]
	call	?AddControl@C_Window@@QAEXPAVC_Base@@@Z	; C_Window::AddControl
$LN3@ProcessWea:

; 1489 : 	}
; 1490 : 	txt=(C_Text *)win->FindControl(IA_DBRF_BONUS_FIELD);

	push	10033					; 00002731H
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _txt$[ebp], eax

; 1491 : 	if(txt)

	cmp	DWORD PTR _txt$[ebp], 0
	je	SHORT $LN2@ProcessWea

; 1492 : 	{
; 1493 : 		sprintf(buffer,"%1ld",Bonus - Penalty + LivingBonus + LandingBonus);

	mov	edx, DWORD PTR ?Bonus@@3JA		; Bonus
	sub	edx, DWORD PTR ?Penalty@@3JA		; Penalty
	add	edx, DWORD PTR ?LivingBonus@@3JA	; LivingBonus
	add	edx, DWORD PTR ?LandingBonus@@3JA	; LandingBonus
	push	edx
	push	OFFSET ??_C@_04DIDHKLLF@?$CF1ld?$AA@
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1494 : 		AddCommas(buffer);

	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	?AddCommas@@YAPADPAD@Z			; AddCommas
	add	esp, 4

; 1495 : 		txt->SetText(buffer);

	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+256]
	call	eax
$LN2@ProcessWea:

; 1496 : 	}
; 1497 : 	txt=(C_Text *)win->FindControl(REALISM_MULTIPLIER);

	push	10053					; 00002745H
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _txt$[ebp], eax

; 1498 : 	if(txt)

	cmp	DWORD PTR _txt$[ebp], 0
	je	SHORT $LN1@ProcessWea

; 1499 : 	{
; 1500 : 		sprintf(buffer,"%1ld%%",(long)(PlayerOptions.Realism * 100.00f + 0.5f));

	movss	xmm0, DWORD PTR ?PlayerOptions@@3VPlayerOptionsClass@@A+160
	mulss	xmm0, DWORD PTR __real@42c80000
	addss	xmm0, DWORD PTR __real@3f000000
	cvttss2si ecx, xmm0
	push	ecx
	push	OFFSET ??_C@_06OMDEMEG@?$CF1ld?$CF?$CF?$AA@
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1501 : 		txt->SetText(buffer);

	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+256]
	call	eax
$LN1@ProcessWea:

; 1502 : 	}
; 1503 : 	win->RefreshWindow();

	mov	ecx, DWORD PTR _win$[ebp]
	call	?RefreshWindow@C_Window@@QAEXXZ		; C_Window::RefreshWindow

; 1504 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?ProcessWeapons@@YAXPAVC_Window@@@Z$0:
	mov	eax, DWORD PTR $T9[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?ProcessWeapons@@YAXPAVC_Window@@@Z$1:
	mov	eax, DWORD PTR $T6[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?ProcessWeapons@@YAXPAVC_Window@@@Z$2:
	mov	eax, DWORD PTR $T7[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?ProcessWeapons@@YAXPAVC_Window@@@Z$3:
	mov	eax, DWORD PTR $T8[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?ProcessWeapons@@YAXPAVC_Window@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-180]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ProcessWeapons@@YAXPAVC_Window@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ProcessWeapons@@YAXPAVC_Window@@@Z ENDP		; ProcessWeapons
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\instant\instant.cpp
_TEXT	SEGMENT
_cur$ = -4						; size = 4
?ProcessBonus@@YAXXZ PROC				; ProcessBonus

; 1401 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1402 : 	kill_list *cur;
; 1403 : 
; 1404 : 	cur = BonusList;

	mov	eax, DWORD PTR ?BonusList@@3PAUkill_list@@A ; BonusList
	mov	DWORD PTR _cur$[ebp], eax
$LN2@ProcessBon:

; 1405 : 
; 1406 : 	while (cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN1@ProcessBon

; 1407 : 	{
; 1408 : 		Bonus += cur->points;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR ?Bonus@@3JA		; Bonus
	add	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR ?Bonus@@3JA, edx		; Bonus

; 1409 : 
; 1410 : 		cur = cur->next;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _cur$[ebp], ecx

; 1411 : 	}

	jmp	SHORT $LN2@ProcessBon
$LN1@ProcessBon:

; 1412 : 
; 1413 : 	RemoveBonusList ();

	call	?RemoveBonusList@@YAXXZ			; RemoveBonusList

; 1414 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ProcessBonus@@YAXXZ ENDP				; ProcessBonus
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\instant\instant.cpp
_TEXT	SEGMENT
$T2 = -208						; size = 4
$T3 = -204						; size = 4
$T4 = -200						; size = 4
$T5 = -196						; size = 4
$T6 = -192						; size = 4
$T7 = -188						; size = 4
$T8 = -184						; size = 4
$T9 = -180						; size = 4
$T10 = -176						; size = 4
tv370 = -172						; size = 4
$T11 = -168						; size = 4
tv83 = -164						; size = 4
$T12 = -160						; size = 4
tv239 = -156						; size = 4
_fh$ = -152						; size = 4
tv174 = -148						; size = 4
tv435 = -144						; size = 4
$T13 = -140						; size = 4
tv311 = -136						; size = 4
_UseFont$ = -132					; size = 4
_y$ = -128						; size = 4
_cur$ = -124						; size = 4
_txt$ = -120						; size = 4
_buffer$ = -116						; size = 100
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_win$ = 8						; size = 4
?ProcessKills@@YAXPAVC_Window@@@Z PROC			; ProcessKills

; 1048 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ProcessKills@@YAXPAVC_Window@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 196				; 000000c4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1049 : 	int y,fh;
; 1050 : 	C_Text *txt;
; 1051 : 	_TCHAR buffer[100];
; 1052 : 	kill_list *cur;
; 1053 : 	long UseFont;
; 1054 : 
; 1055 : 	y=0;

	mov	DWORD PTR _y$[ebp], 0

; 1056 : 	UseFont=win->Font_;

	mov	eax, DWORD PTR _win$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	mov	DWORD PTR _UseFont$[ebp], ecx

; 1057 : 	fh=gFontList->GetHeight(UseFont);

	mov	edx, DWORD PTR _UseFont$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?gFontList@@3PAVC_Font@@A ; gFontList
	call	?GetHeight@C_Font@@QAEHJ@Z		; C_Font::GetHeight
	mov	DWORD PTR _fh$[ebp], eax

; 1058 : 
; 1059 : 	if(AircraftKills)

	cmp	DWORD PTR ?AircraftKills@@3PAUkill_list@@A, 0 ; AircraftKills
	je	$LN9@ProcessKil

; 1060 : 	{
; 1061 : 		cur=AircraftKills;

	mov	eax, DWORD PTR ?AircraftKills@@3PAUkill_list@@A ; AircraftKills
	mov	DWORD PTR _cur$[ebp], eax
$LN8@ProcessKil:

; 1062 : 		while(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	$LN7@ProcessKil

; 1063 : 		{
; 1064 : 			_stprintf(buffer,"%s",GetClassName (cur->id));

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?GetClassNameA@@YAPADH@Z		; GetClassNameA
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1065 : 			txt=new C_Text;

	push	76					; 0000004cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T8[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T8[ebp], 0
	je	SHORT $LN12@ProcessKil
	mov	ecx, DWORD PTR $T8[ebp]
	call	??0C_Text@@QAE@XZ			; C_Text::C_Text
	mov	DWORD PTR tv83[ebp], eax
	jmp	SHORT $LN13@ProcessKil
$LN12@ProcessKil:
	mov	DWORD PTR tv83[ebp], 0
$LN13@ProcessKil:
	mov	ecx, DWORD PTR tv83[ebp]
	mov	DWORD PTR $T7[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T7[ebp]
	mov	DWORD PTR _txt$[ebp], edx

; 1066 : 			txt->Setup(C_DONT_CARE,C_TYPE_LEFT);

	push	44					; 0000002cH
	push	-2					; fffffffeH
	mov	eax, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax

; 1067 : 			txt->SetText(buffer);

	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax+256]
	call	edx

; 1068 : 			txt->SetXY(20,y);

	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	push	20					; 00000014H
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1069 : 			txt->SetFGColor(0xf0f0f0);

	push	15790320				; 00f0f0f0H
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetFGColor@C_Text@@QAEXK@Z		; C_Text::SetFGColor

; 1070 : 			txt->SetFont(UseFont);

	mov	ecx, DWORD PTR _UseFont$[ebp]
	push	ecx
	mov	edx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax+68]
	call	edx

; 1071 : 			txt->SetFlagBitOn(C_BIT_LEFT);

	push	32					; 00000020H
	mov	eax, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 1072 : 			txt->SetClient(2);

	push	2
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetClient@C_Base@@QAEXF@Z		; C_Base::SetClient

; 1073 : 			win->AddControl(txt);

	mov	ecx, DWORD PTR _txt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _win$[ebp]
	call	?AddControl@C_Window@@QAEXPAVC_Base@@@Z	; C_Window::AddControl

; 1074 : 
; 1075 : 			_stprintf(buffer,"(%1d)",cur->num);

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	push	OFFSET ??_C@_05OPOMBKKA@?$CI?$CF1d?$CJ?$AA@
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1076 : 			txt=new C_Text;

	push	76					; 0000004cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T12[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T12[ebp], 0
	je	SHORT $LN14@ProcessKil
	mov	ecx, DWORD PTR $T12[ebp]
	call	??0C_Text@@QAE@XZ			; C_Text::C_Text
	mov	DWORD PTR tv174[ebp], eax
	jmp	SHORT $LN15@ProcessKil
$LN14@ProcessKil:
	mov	DWORD PTR tv174[ebp], 0
$LN15@ProcessKil:
	mov	edx, DWORD PTR tv174[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _txt$[ebp], eax

; 1077 : 			txt->Setup(C_DONT_CARE,C_TYPE_LEFT);

	push	44					; 0000002cH
	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax

; 1078 : 			txt->SetFixedWidth(_tcsclen(buffer)+1);

	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	__tcsclen
	add	esp, 4
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetFixedWidth@C_Text@@QAEXJ@Z		; C_Text::SetFixedWidth

; 1079 : 			txt->SetText(buffer);

	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+256]
	call	eax

; 1080 : 			txt->SetXY(130,y);

	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	push	130					; 00000082H
	mov	edx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 1081 : 			txt->SetFGColor(0xf0f0f0);

	push	15790320				; 00f0f0f0H
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetFGColor@C_Text@@QAEXK@Z		; C_Text::SetFGColor

; 1082 : 			txt->SetFont(UseFont);

	mov	eax, DWORD PTR _UseFont$[ebp]
	push	eax
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+68]
	call	eax

; 1083 : 			txt->SetFlagBitOn(C_BIT_LEFT);

	push	32					; 00000020H
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 1084 : 			txt->SetClient(2);

	push	2
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetClient@C_Base@@QAEXF@Z		; C_Base::SetClient

; 1085 : 			win->AddControl(txt);

	mov	ecx, DWORD PTR _txt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _win$[ebp]
	call	?AddControl@C_Window@@QAEXPAVC_Base@@@Z	; C_Window::AddControl

; 1086 : 
; 1087 : 			_stprintf(buffer,"%1ld",cur->points);

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	push	OFFSET ??_C@_04DIDHKLLF@?$CF1ld?$AA@
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1088 : 			AddCommas(buffer);

	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	?AddCommas@@YAPADPAD@Z			; AddCommas
	add	esp, 4

; 1089 : 			txt=new C_Text;

	push	76					; 0000004cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T11[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	cmp	DWORD PTR $T11[ebp], 0
	je	SHORT $LN16@ProcessKil
	mov	ecx, DWORD PTR $T11[ebp]
	call	??0C_Text@@QAE@XZ			; C_Text::C_Text
	mov	DWORD PTR tv239[ebp], eax
	jmp	SHORT $LN17@ProcessKil
$LN16@ProcessKil:
	mov	DWORD PTR tv239[ebp], 0
$LN17@ProcessKil:
	mov	eax, DWORD PTR tv239[ebp]
	mov	DWORD PTR $T5[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T5[ebp]
	mov	DWORD PTR _txt$[ebp], ecx

; 1090 : 			txt->Setup(C_DONT_CARE,C_TYPE_RIGHT);

	push	46					; 0000002eH
	push	-2					; fffffffeH
	mov	edx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax+248]
	call	edx

; 1091 : 			txt->SetFixedWidth(_tcsclen(buffer)+1);

	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	__tcsclen
	add	esp, 4
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetFixedWidth@C_Text@@QAEXJ@Z		; C_Text::SetFixedWidth

; 1092 : 			txt->SetText(buffer);

	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax+256]
	call	edx

; 1093 : 			txt->SetXY(215,y);

	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	push	215					; 000000d7H
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1094 : 			txt->SetFGColor(0x00ff00);

	push	65280					; 0000ff00H
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetFGColor@C_Text@@QAEXK@Z		; C_Text::SetFGColor

; 1095 : 			txt->SetFont(UseFont);

	mov	ecx, DWORD PTR _UseFont$[ebp]
	push	ecx
	mov	edx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax+68]
	call	edx

; 1096 : 			txt->SetFlagBitOn(C_BIT_RIGHT);

	push	64					; 00000040H
	mov	eax, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 1097 : 			txt->SetClient(2);

	push	2
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetClient@C_Base@@QAEXF@Z		; C_Base::SetClient

; 1098 : 			win->AddControl(txt);

	mov	ecx, DWORD PTR _txt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _win$[ebp]
	call	?AddControl@C_Window@@QAEXPAVC_Base@@@Z	; C_Window::AddControl

; 1099 : 
; 1100 : 			TotalScore+=cur->points;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR ?TotalScore@@3JA		; TotalScore
	add	eax, DWORD PTR [edx+8]
	mov	DWORD PTR ?TotalScore@@3JA, eax		; TotalScore

; 1101 : 
; 1102 : 			y+=fh;

	mov	ecx, DWORD PTR _y$[ebp]
	add	ecx, DWORD PTR _fh$[ebp]
	mov	DWORD PTR _y$[ebp], ecx

; 1103 : 			cur=cur->next;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _cur$[ebp], eax

; 1104 : 		}

	jmp	$LN8@ProcessKil
$LN7@ProcessKil:

; 1105 : 		RemoveAircraftKillsList();

	call	?RemoveAircraftKillsList@@YAXXZ		; RemoveAircraftKillsList
$LN9@ProcessKil:

; 1106 : 	}
; 1107 : 
; 1108 : 	if(ObjectKills)

	cmp	DWORD PTR ?ObjectKills@@3PAUkill_list@@A, 0 ; ObjectKills
	je	$LN6@ProcessKil

; 1109 : 	{
; 1110 : 		cur=ObjectKills;

	mov	ecx, DWORD PTR ?ObjectKills@@3PAUkill_list@@A ; ObjectKills
	mov	DWORD PTR _cur$[ebp], ecx
$LN5@ProcessKil:

; 1111 : 		while(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	$LN4@ProcessKil

; 1112 : 		{
; 1113 : 			_stprintf(buffer,"%s",GetClassName (cur->id));

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	?GetClassNameA@@YAPADH@Z		; GetClassNameA
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1114 : 			txt=new C_Text;

	push	76					; 0000004cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T10[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	cmp	DWORD PTR $T10[ebp], 0
	je	SHORT $LN18@ProcessKil
	mov	ecx, DWORD PTR $T10[ebp]
	call	??0C_Text@@QAE@XZ			; C_Text::C_Text
	mov	DWORD PTR tv311[ebp], eax
	jmp	SHORT $LN19@ProcessKil
$LN18@ProcessKil:
	mov	DWORD PTR tv311[ebp], 0
$LN19@ProcessKil:
	mov	edx, DWORD PTR tv311[ebp]
	mov	DWORD PTR $T3[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR _txt$[ebp], eax

; 1115 : 			txt->Setup(C_DONT_CARE,C_TYPE_LEFT);

	push	44					; 0000002cH
	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax

; 1116 : 			txt->SetText(buffer);

	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax+256]
	call	edx

; 1117 : 			txt->SetXY(20,y);

	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	push	20					; 00000014H
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1118 : 			txt->SetFGColor(0xf0f0f0);

	push	15790320				; 00f0f0f0H
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetFGColor@C_Text@@QAEXK@Z		; C_Text::SetFGColor

; 1119 : 			txt->SetFont(UseFont);

	mov	ecx, DWORD PTR _UseFont$[ebp]
	push	ecx
	mov	edx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax+68]
	call	edx

; 1120 : 			txt->SetFlagBitOn(C_BIT_LEFT);

	push	32					; 00000020H
	mov	eax, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 1121 : 			txt->SetClient(2);

	push	2
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetClient@C_Base@@QAEXF@Z		; C_Base::SetClient

; 1122 : 			win->AddControl(txt);

	mov	ecx, DWORD PTR _txt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _win$[ebp]
	call	?AddControl@C_Window@@QAEXPAVC_Base@@@Z	; C_Window::AddControl

; 1123 : 
; 1124 : 			_stprintf(buffer,"(%1d)",cur->num);

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	push	OFFSET ??_C@_05OPOMBKKA@?$CI?$CF1d?$CJ?$AA@
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1125 : 			txt=new C_Text;

	push	76					; 0000004cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T9[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	cmp	DWORD PTR $T9[ebp], 0
	je	SHORT $LN20@ProcessKil
	mov	ecx, DWORD PTR $T9[ebp]
	call	??0C_Text@@QAE@XZ			; C_Text::C_Text
	mov	DWORD PTR tv370[ebp], eax
	jmp	SHORT $LN21@ProcessKil
$LN20@ProcessKil:
	mov	DWORD PTR tv370[ebp], 0
$LN21@ProcessKil:
	mov	edx, DWORD PTR tv370[ebp]
	mov	DWORD PTR $T6[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T6[ebp]
	mov	DWORD PTR _txt$[ebp], eax

; 1126 : 			txt->Setup(C_DONT_CARE,C_TYPE_LEFT);

	push	44					; 0000002cH
	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax

; 1127 : 			txt->SetFixedWidth(_tcsclen(buffer)+1);

	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	__tcsclen
	add	esp, 4
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetFixedWidth@C_Text@@QAEXJ@Z		; C_Text::SetFixedWidth

; 1128 : 			txt->SetText(buffer);

	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+256]
	call	eax

; 1129 : 			txt->SetXY(130,y);

	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	push	130					; 00000082H
	mov	edx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 1130 : 			txt->SetFGColor(0xf0f0f0);

	push	15790320				; 00f0f0f0H
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetFGColor@C_Text@@QAEXK@Z		; C_Text::SetFGColor

; 1131 : 			txt->SetFont(UseFont);

	mov	eax, DWORD PTR _UseFont$[ebp]
	push	eax
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+68]
	call	eax

; 1132 : 			txt->SetFlagBitOn(C_BIT_LEFT);

	push	32					; 00000020H
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 1133 : 			txt->SetClient(2);

	push	2
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetClient@C_Base@@QAEXF@Z		; C_Base::SetClient

; 1134 : 			win->AddControl(txt);

	mov	ecx, DWORD PTR _txt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _win$[ebp]
	call	?AddControl@C_Window@@QAEXPAVC_Base@@@Z	; C_Window::AddControl

; 1135 : 
; 1136 : 			_stprintf(buffer,"%1ld",cur->points);

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	push	OFFSET ??_C@_04DIDHKLLF@?$CF1ld?$AA@
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1137 : 			AddCommas(buffer);

	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	?AddCommas@@YAPADPAD@Z			; AddCommas
	add	esp, 4

; 1138 : 			txt=new C_Text;

	push	76					; 0000004cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T13[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 5
	cmp	DWORD PTR $T13[ebp], 0
	je	SHORT $LN22@ProcessKil
	mov	ecx, DWORD PTR $T13[ebp]
	call	??0C_Text@@QAE@XZ			; C_Text::C_Text
	mov	DWORD PTR tv435[ebp], eax
	jmp	SHORT $LN23@ProcessKil
$LN22@ProcessKil:
	mov	DWORD PTR tv435[ebp], 0
$LN23@ProcessKil:
	mov	eax, DWORD PTR tv435[ebp]
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T4[ebp]
	mov	DWORD PTR _txt$[ebp], ecx

; 1139 : 			txt->Setup(C_DONT_CARE,C_TYPE_RIGHT);

	push	46					; 0000002eH
	push	-2					; fffffffeH
	mov	edx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax+248]
	call	edx

; 1140 : 			txt->SetFixedWidth(_tcsclen(buffer)+1);

	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	__tcsclen
	add	esp, 4
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetFixedWidth@C_Text@@QAEXJ@Z		; C_Text::SetFixedWidth

; 1141 : 			txt->SetText(buffer);

	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax+256]
	call	edx

; 1142 : 			txt->SetXY(215,y);

	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	push	215					; 000000d7H
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1143 : 			txt->SetFGColor(0x00ff00);

	push	65280					; 0000ff00H
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetFGColor@C_Text@@QAEXK@Z		; C_Text::SetFGColor

; 1144 : 			txt->SetFont(UseFont);

	mov	ecx, DWORD PTR _UseFont$[ebp]
	push	ecx
	mov	edx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax+68]
	call	edx

; 1145 : 			txt->SetFlagBitOn(C_BIT_RIGHT);

	push	64					; 00000040H
	mov	eax, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 1146 : 			txt->SetClient(2);

	push	2
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetClient@C_Base@@QAEXF@Z		; C_Base::SetClient

; 1147 : 			win->AddControl(txt);

	mov	ecx, DWORD PTR _txt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _win$[ebp]
	call	?AddControl@C_Window@@QAEXPAVC_Base@@@Z	; C_Window::AddControl

; 1148 : 
; 1149 : 			TotalScore+=cur->points;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR ?TotalScore@@3JA		; TotalScore
	add	eax, DWORD PTR [edx+8]
	mov	DWORD PTR ?TotalScore@@3JA, eax		; TotalScore

; 1150 : 
; 1151 : 			y+=fh;

	mov	ecx, DWORD PTR _y$[ebp]
	add	ecx, DWORD PTR _fh$[ebp]
	mov	DWORD PTR _y$[ebp], ecx

; 1152 : 			cur=cur->next;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _cur$[ebp], eax

; 1153 : 		}

	jmp	$LN5@ProcessKil
$LN4@ProcessKil:

; 1154 : 		RemoveObjectKillsList();

	call	?RemoveObjectKillsList@@YAXXZ		; RemoveObjectKillsList
$LN6@ProcessKil:

; 1155 : 	}
; 1156 : 
; 1157 : 	txt=(C_Text *)win->FindControl(IA_DBRF_BONUS_FIELD);

	push	10033					; 00002731H
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _txt$[ebp], eax

; 1158 : 	if(txt)

	cmp	DWORD PTR _txt$[ebp], 0
	je	SHORT $LN3@ProcessKil

; 1159 : 	{
; 1160 : 		sprintf(buffer,"%1ld",Bonus - Penalty + LivingBonus + LandingBonus);

	mov	ecx, DWORD PTR ?Bonus@@3JA		; Bonus
	sub	ecx, DWORD PTR ?Penalty@@3JA		; Penalty
	add	ecx, DWORD PTR ?LivingBonus@@3JA	; LivingBonus
	add	ecx, DWORD PTR ?LandingBonus@@3JA	; LandingBonus
	push	ecx
	push	OFFSET ??_C@_04DIDHKLLF@?$CF1ld?$AA@
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1161 : 		AddCommas(buffer);

	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	?AddCommas@@YAPADPAD@Z			; AddCommas
	add	esp, 4

; 1162 : 		txt->SetText(buffer);

	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax+256]
	call	edx
$LN3@ProcessKil:

; 1163 : 	}
; 1164 : 	txt=(C_Text *)win->FindControl(REALISM_MULTIPLIER);

	push	10053					; 00002745H
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _txt$[ebp], eax

; 1165 : 	if(txt)

	cmp	DWORD PTR _txt$[ebp], 0
	je	SHORT $LN2@ProcessKil

; 1166 : 	{
; 1167 : 		sprintf(buffer,"%1ld%%",(long)(PlayerOptions.Realism * 100.00f + 0.5f));

	movss	xmm0, DWORD PTR ?PlayerOptions@@3VPlayerOptionsClass@@A+160
	mulss	xmm0, DWORD PTR __real@42c80000
	addss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	push	eax
	push	OFFSET ??_C@_06OMDEMEG@?$CF1ld?$CF?$CF?$AA@
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1168 : 		txt->SetText(buffer);

	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+256]
	call	eax
$LN2@ProcessKil:

; 1169 : 	}
; 1170 : 
; 1171 : 	// JMB 010711 (total score is always zero)
; 1172 : 	// TotalScore *= static_cast<long>(PlayerOptions.Realism);
; 1173 : 	TotalScore = long(TotalScore * PlayerOptions.Realism);

	cvtsi2ss xmm0, DWORD PTR ?TotalScore@@3JA	; TotalScore
	mulss	xmm0, DWORD PTR ?PlayerOptions@@3VPlayerOptionsClass@@A+160
	cvttss2si ecx, xmm0
	mov	DWORD PTR ?TotalScore@@3JA, ecx		; TotalScore

; 1174 : 
; 1175 : 	txt=(C_Text *)win->FindControl(IA_DBRF_SCORE_FIELD);

	push	10028					; 0000272cH
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _txt$[ebp], eax

; 1176 : 	if(txt)

	cmp	DWORD PTR _txt$[ebp], 0
	je	SHORT $LN1@ProcessKil

; 1177 : 	{
; 1178 : 		sprintf(buffer,"%1ld",TotalScore);

	mov	edx, DWORD PTR ?TotalScore@@3JA		; TotalScore
	push	edx
	push	OFFSET ??_C@_04DIDHKLLF@?$CF1ld?$AA@
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1179 : 		AddCommas(buffer);

	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	?AddCommas@@YAPADPAD@Z			; AddCommas
	add	esp, 4

; 1180 : 		txt->SetText(buffer);

	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+256]
	call	eax
$LN1@ProcessKil:

; 1181 : 	}
; 1182 : 	win->RefreshWindow();

	mov	ecx, DWORD PTR _win$[ebp]
	call	?RefreshWindow@C_Window@@QAEXXZ		; C_Window::RefreshWindow

; 1183 : 
; 1184 : /*
; 1185 : 
; 1186 : 	int i,j,index;
; 1187 : 	int y,fh;
; 1188 : 	C_Text *txt;
; 1189 : 	long UseFont;
; 1190 : 	_TCHAR buffer[100];
; 1191 : 	KillList *airList,*gndList;
; 1192 : 	int aircnt,gndcnt;
; 1193 : 	VehicleClassDataType	*vc;
; 1194 : 
; 1195 : 	y=0;
; 1196 : 	UseFont=win->Font_;
; 1197 : 	fh=gFontList->GetHeight(UseFont);
; 1198 : 	aircnt=0;
; 1199 : 	gndcnt=0;
; 1200 : 
; 1201 : 	if(instant_action::get_num_aa_kills ())
; 1202 : 	{
; 1203 : 		airList=new KillList[instant_action::get_num_air_target_types () + instant_action::get_num_air_threat_types ()];
; 1204 : 		for(i=0;i<instant_action::get_num_air_target_types ();i++)
; 1205 : 		{
; 1206 : 			airList[aircnt].descriptionIndex=instant_action::get_air_target_description_index(0, i);
; 1207 : 			airList[aircnt].numKilled=0;
; 1208 : 			airList[aircnt].points=0;
; 1209 : 			for(j=0;j<=instant_action::get_num_levels();j++)
; 1210 : 			{
; 1211 : 				airList[aircnt].numKilled+=instant_action::get_air_target_num_killed(j,i);
; 1212 : 				airList[aircnt].points+=instant_action::get_air_target_points(j,i);
; 1213 : 			}
; 1214 : 			aircnt++;
; 1215 : 		}
; 1216 : 
; 1217 : 		for(i=0;i<instant_action::get_num_air_threat_types ();i++)
; 1218 : 		{
; 1219 : 			index=-1;
; 1220 : 			for(j=0;j<aircnt;j++)
; 1221 : 				if(airList[j].descriptionIndex == instant_action::get_air_threat_description_index (0, i))
; 1222 : 					index=j;
; 1223 : 
; 1224 : 			if(index >= 0)
; 1225 : 			{
; 1226 : 				for(j=0;j<=instant_action::get_num_levels();j++)
; 1227 : 				{
; 1228 : 					airList[aircnt].numKilled+=instant_action::get_air_threat_num_killed(j, i);
; 1229 : 					airList[aircnt].points+=instant_action::get_air_threat_points (j, i);
; 1230 : 				}
; 1231 : 			}
; 1232 : 			else
; 1233 : 			{
; 1234 : 				airList[aircnt].descriptionIndex=instant_action::get_air_threat_description_index (0, i);
; 1235 : 				airList[aircnt].numKilled=0;
; 1236 : 				airList[aircnt].points=0;
; 1237 : 				for(j=0;j<=instant_action::get_num_levels();j++)
; 1238 : 				{
; 1239 : 					airList[aircnt].numKilled+=instant_action::get_air_threat_num_killed (j,i);
; 1240 : 					airList[aircnt].points+=instant_action::get_air_threat_points (j,i);
; 1241 : 				}
; 1242 : 				aircnt++;
; 1243 : 			}
; 1244 : 		}
; 1245 : 
; 1246 : 		for(i=0;i<aircnt;i++)
; 1247 : 		{
; 1248 : 			if(airList[i].numKilled > 0)
; 1249 : 			{
; 1250 : 				_stprintf(buffer,"%1d",airList[i].numKilled);
; 1251 : 				txt=new C_Text;
; 1252 : 				txt->Setup(C_DONT_CARE,C_TYPE_RIGHT);
; 1253 : 				txt->SetFixedWidth(_tcsclen(buffer)+1);
; 1254 : 				txt->SetText(buffer);
; 1255 : 				txt->SetXY(35,y);
; 1256 : 				txt->SetFGColor(0xf0f0f0);
; 1257 : 				txt->SetFont(UseFont);
; 1258 : 				txt->SetFlagBitOn(C_BIT_RIGHT);
; 1259 : 				txt->SetClient(2);
; 1260 : 				win->AddControl(txt);
; 1261 : 
; 1262 : 				vc = GetVehicleClassData (airList[i].descriptionIndex);
; 1263 : 				_stprintf(buffer,"%s",vc->Name);
; 1264 : 				txt=new C_Text;
; 1265 : 				txt->Setup(C_DONT_CARE,C_TYPE_LEFT);
; 1266 : 				txt->SetText(buffer);
; 1267 : 				txt->SetXY(45,y);
; 1268 : 				txt->SetFGColor(0xf0f0f0);
; 1269 : 				txt->SetFont(UseFont);
; 1270 : 				txt->SetFlagBitOn(C_BIT_LEFT);
; 1271 : 				txt->SetClient(2);
; 1272 : 				win->AddControl(txt);
; 1273 : 
; 1274 : 				_stprintf(buffer,"%1ld",airList[i].points);
; 1275 : 				AddCommas(buffer);
; 1276 : 				txt=new C_Text;
; 1277 : 				txt->Setup(C_DONT_CARE,C_TYPE_RIGHT);
; 1278 : 				txt->SetFixedWidth(_tcsclen(buffer)+1);
; 1279 : 				txt->SetText(buffer);
; 1280 : 				txt->SetXY(215,y);
; 1281 : 				txt->SetFGColor(0x00ff00);
; 1282 : 				txt->SetFont(UseFont);
; 1283 : 				txt->SetFlagBitOn(C_BIT_RIGHT);
; 1284 : 				txt->SetClient(2);
; 1285 : 				win->AddControl(txt);
; 1286 : 
; 1287 : 				TotalScore+=airList[i].points;
; 1288 : 
; 1289 : 				y+=fh;
; 1290 : 			}
; 1291 : 		}
; 1292 : 		delete airList;
; 1293 : 	}
; 1294 : 	if(instant_action::get_num_ag_kills ())
; 1295 : 	{
; 1296 : 		gndList=new KillList[instant_action::get_num_gnd_target_types () + instant_action::get_num_gnd_threat_types ()];
; 1297 : 		for(i=0;i<instant_action::get_num_gnd_target_types ();i++)
; 1298 : 		{
; 1299 : 			gndList[gndcnt].descriptionIndex=instant_action::get_gnd_target_description_index(0,i);
; 1300 : 			gndList[gndcnt].numKilled=0;
; 1301 : 			gndList[gndcnt].points=0;
; 1302 : 			for(j=0;j<=instant_action::get_num_levels();j++)
; 1303 : 			{
; 1304 : 				gndList[gndcnt].numKilled+=instant_action::get_gnd_target_num_killed (j,i);
; 1305 : 				gndList[gndcnt].points+=instant_action::get_gnd_target_points (j,i);
; 1306 : 			}
; 1307 : 			gndcnt++;
; 1308 : 		}
; 1309 : 
; 1310 : 		for(i=0;i<instant_action::get_num_gnd_threat_types ();i++)
; 1311 : 		{
; 1312 : 			index=-1;
; 1313 : 			for(j=0;j<gndcnt;j++)
; 1314 : 				if(gndList[j].descriptionIndex == instant_action::get_gnd_threat_description_index(0,i))
; 1315 : 					index=j;
; 1316 : 
; 1317 : 			if(index >= 0)
; 1318 : 			{
; 1319 : 				for(j=0;j<=instant_action::get_num_levels();j++)
; 1320 : 				{
; 1321 : 					gndList[index].numKilled+=instant_action::get_gnd_threat_num_killed (j,i);
; 1322 : 					gndList[index].points+=instant_action::get_gnd_threat_points (j,i);
; 1323 : 				}
; 1324 : 			}
; 1325 : 			else
; 1326 : 			{
; 1327 : 				gndList[gndcnt].descriptionIndex=instant_action::get_gnd_threat_description_index (0,i);
; 1328 : 				gndList[gndcnt].numKilled=0;
; 1329 : 				gndList[gndcnt].points=0;
; 1330 : 				for(j=0;j<=instant_action::get_num_levels();j++)
; 1331 : 				{
; 1332 : 					gndList[gndcnt].numKilled+=instant_action::get_gnd_threat_num_killed (j,i);
; 1333 : 					gndList[gndcnt].points+=instant_action::get_gnd_threat_points (j,i);
; 1334 : 				}
; 1335 : 				gndcnt++;
; 1336 : 			}
; 1337 : 		}
; 1338 : 
; 1339 : 		for(i=0;i<gndcnt;i++)
; 1340 : 		{
; 1341 : 			if(gndList[i].numKilled > 0)
; 1342 : 			{
; 1343 : 				_stprintf(buffer,"%1d",gndList[i].numKilled);
; 1344 : 				txt=new C_Text;
; 1345 : 				txt->Setup(C_DONT_CARE,C_TYPE_RIGHT);
; 1346 : 				txt->SetFixedWidth(_tcsclen(buffer)+1);
; 1347 : 				txt->SetText(buffer);
; 1348 : 				txt->SetXY(35,y);
; 1349 : 				txt->SetFGColor(0xf0f0f0);
; 1350 : 				txt->SetFont(UseFont);
; 1351 : 				txt->SetFlagBitOn(C_BIT_RIGHT);
; 1352 : 				txt->SetClient(2);
; 1353 : 				win->AddControl(txt);
; 1354 : 
; 1355 : 				vc = GetVehicleClassData (gndList[i].descriptionIndex);
; 1356 : 				_stprintf(buffer,"%s",vc->Name);
; 1357 : 				txt=new C_Text;
; 1358 : 				txt->Setup(C_DONT_CARE,C_TYPE_LEFT);
; 1359 : 				txt->SetText(buffer);
; 1360 : 				txt->SetXY(45,y);
; 1361 : 				txt->SetFGColor(0xf0f0f0);
; 1362 : 				txt->SetFont(UseFont);
; 1363 : 				txt->SetFlagBitOn(C_BIT_LEFT);
; 1364 : 				txt->SetClient(2);
; 1365 : 				win->AddControl(txt);
; 1366 : 
; 1367 : 				_stprintf(buffer,"%1ld",gndList[i].points);
; 1368 : 				AddCommas(buffer);
; 1369 : 				txt=new C_Text;
; 1370 : 				txt->Setup(C_DONT_CARE,C_TYPE_RIGHT);
; 1371 : 				txt->SetFixedWidth(_tcsclen(buffer)+1);
; 1372 : 				txt->SetText(buffer);
; 1373 : 				txt->SetXY(215,y);
; 1374 : 				txt->SetFGColor(0x00ff00);
; 1375 : 				txt->SetFont(UseFont);
; 1376 : 				txt->SetFlagBitOn(C_BIT_RIGHT);
; 1377 : 				txt->SetClient(2);
; 1378 : 				win->AddControl(txt);
; 1379 : 
; 1380 : 				TotalScore+=gndList[i].points;
; 1381 : 
; 1382 : 				y+=fh;
; 1383 : 			}
; 1384 : 		}
; 1385 : 		delete gndList;
; 1386 : 	}
; 1387 : 	
; 1388 : 	TotalScore *= PlayerOptions.Realism;
; 1389 : 	txt=(C_Text *)win->FindControl(IA_DBRF_SCORE_FIELD);
; 1390 : 	if(txt)
; 1391 : 	{
; 1392 : 		sprintf(buffer,"%1ld",TotalScore);
; 1393 : 		AddCommas(buffer);
; 1394 : 		txt->SetText(buffer);
; 1395 : 	}
; 1396 : 	win->RefreshWindow();
; 1397 : */
; 1398 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?ProcessKills@@YAXPAVC_Window@@@Z$0:
	mov	eax, DWORD PTR $T8[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?ProcessKills@@YAXPAVC_Window@@@Z$1:
	mov	eax, DWORD PTR $T12[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?ProcessKills@@YAXPAVC_Window@@@Z$2:
	mov	eax, DWORD PTR $T11[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?ProcessKills@@YAXPAVC_Window@@@Z$3:
	mov	eax, DWORD PTR $T10[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?ProcessKills@@YAXPAVC_Window@@@Z$4:
	mov	eax, DWORD PTR $T9[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?ProcessKills@@YAXPAVC_Window@@@Z$5:
	mov	eax, DWORD PTR $T13[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?ProcessKills@@YAXPAVC_Window@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-200]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ProcessKills@@YAXPAVC_Window@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ProcessKills@@YAXPAVC_Window@@@Z ENDP			; ProcessKills
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\instant\instant.cpp
_TEXT	SEGMENT
_start_x$ = -36						; size = 4
_start_y$ = -32						; size = 4
tv281 = -28						; size = 4
tv279 = -24						; size = 4
tv232 = -20						; size = 4
tv228 = -16						; size = 4
_XPos$ = -12						; size = 4
_YPos$ = -8						; size = 4
_crsr$ = -4						; size = 4
_win$ = 8						; size = 4
?SetMapStartup@@YAXPAVC_Window@@@Z PROC			; SetMapStartup

; 1000 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	esi

; 1001 : 	C_Cursor *crsr;
; 1002 : 	float XPos,YPos;
; 1003 : 	float start_x, start_y; //THW 2004-02-14 Random map location
; 1004 : 
; 1005 : 	crsr=(C_Cursor *)win->FindControl(IA_MAP_CURSOR);

	push	10049					; 00002741H
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _crsr$[ebp], eax

; 1006 : 	if(crsr)

	cmp	DWORD PTR _crsr$[ebp], 0
	je	$LN5@SetMapStar

; 1007 : 	{
; 1008 : 		instant_action::get_start_position (start_x, start_y);

	lea	eax, DWORD PTR _start_y$[ebp]
	push	eax
	lea	ecx, DWORD PTR _start_x$[ebp]
	push	ecx
	call	?get_start_position@instant_action@@SAXAAM0@Z ; instant_action::get_start_position
	add	esp, 8

; 1009 : 		/*THW 2004-02-14 Random map location
; 1010 : 		XPos=start_y/(FEET_PER_KM/1000.0f*4096.0f*256.0f);
; 1011 : 		YPos=1.0f-(start_x/(FEET_PER_KM/1000.0f*4096.0f*256.0f));
; 1012 : 		*/
; 1013 : 		XPos = PRANDFloatPos()*0.74f + 0.13f;

	call	?PRANDFloatPos@@YAMXZ			; PRANDFloatPos
	fstp	DWORD PTR tv228[ebp]
	movss	xmm0, DWORD PTR tv228[ebp]
	mulss	xmm0, DWORD PTR __real@3f3d70a4
	addss	xmm0, DWORD PTR __real@3e051eb8
	movss	DWORD PTR _XPos$[ebp], xmm0

; 1014 : 		YPos = 1.0f-(PRANDFloatPos()*0.74f + 0.13f);

	call	?PRANDFloatPos@@YAMXZ			; PRANDFloatPos
	fstp	DWORD PTR tv232[ebp]
	movss	xmm0, DWORD PTR tv232[ebp]
	mulss	xmm0, DWORD PTR __real@3f3d70a4
	addss	xmm0, DWORD PTR __real@3e051eb8
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movss	DWORD PTR _YPos$[ebp], xmm1

; 1015 : 		XPos*=((float)(crsr->MaxX_-crsr->MinX_));

	mov	edx, DWORD PTR _crsr$[ebp]
	movsx	eax, WORD PTR [edx+118]
	mov	ecx, DWORD PTR _crsr$[ebp]
	movsx	edx, WORD PTR [ecx+114]
	sub	eax, edx
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR _XPos$[ebp]
	movss	DWORD PTR _XPos$[ebp], xmm0

; 1016 : 		YPos*=((float)(crsr->MaxY_-crsr->MinY_));

	mov	eax, DWORD PTR _crsr$[ebp]
	movsx	ecx, WORD PTR [eax+120]
	mov	edx, DWORD PTR _crsr$[ebp]
	movsx	eax, WORD PTR [edx+116]
	sub	ecx, eax
	cvtsi2ss xmm0, ecx
	mulss	xmm0, DWORD PTR _YPos$[ebp]
	movss	DWORD PTR _YPos$[ebp], xmm0

; 1017 : 		XPos-=crsr->GetW()/2;

	mov	ecx, DWORD PTR _crsr$[ebp]
	call	?GetW@C_Base@@QAEJXZ			; C_Base::GetW
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR _XPos$[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _XPos$[ebp], xmm1

; 1018 : 		YPos-=crsr->GetH()/2;

	mov	ecx, DWORD PTR _crsr$[ebp]
	call	?GetH@C_Base@@QAEJXZ			; C_Base::GetH
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR _YPos$[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _YPos$[ebp], xmm1

; 1019 : 		if(XPos < 0.0f)

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _XPos$[ebp]
	jbe	SHORT $LN4@SetMapStar

; 1020 : 			XPos=0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _XPos$[ebp], xmm0
$LN4@SetMapStar:

; 1021 : 		if(XPos > (float)(win->ClientArea_[0].right-crsr->GetW()))

	mov	esi, 16					; 00000010H
	imul	esi, 0
	mov	ecx, DWORD PTR _crsr$[ebp]
	call	?GetW@C_Base@@QAEJXZ			; C_Base::GetW
	mov	ecx, DWORD PTR _win$[ebp]
	mov	edx, DWORD PTR [ecx+esi+176]
	sub	edx, eax
	cvtsi2ss xmm0, edx
	movss	xmm1, DWORD PTR _XPos$[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN3@SetMapStar

; 1022 : 			XPos=(float)win->ClientArea_[0].right-crsr->GetW();

	mov	eax, 16					; 00000010H
	imul	eax, 0
	mov	ecx, DWORD PTR _win$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx+eax+176]
	mov	ecx, DWORD PTR _crsr$[ebp]
	movss	DWORD PTR tv279[ebp], xmm0
	call	?GetW@C_Base@@QAEJXZ			; C_Base::GetW
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR tv279[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _XPos$[ebp], xmm1
$LN3@SetMapStar:

; 1023 : 		if(YPos < 0.0f)

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _YPos$[ebp]
	jbe	SHORT $LN2@SetMapStar

; 1024 : 			YPos=0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _YPos$[ebp], xmm0
$LN2@SetMapStar:

; 1025 : 		if(YPos > (float)(win->ClientArea_[0].bottom-crsr->GetH()))

	mov	esi, 16					; 00000010H
	imul	esi, 0
	mov	ecx, DWORD PTR _crsr$[ebp]
	call	?GetH@C_Base@@QAEJXZ			; C_Base::GetH
	mov	edx, DWORD PTR _win$[ebp]
	mov	ecx, DWORD PTR [edx+esi+180]
	sub	ecx, eax
	cvtsi2ss xmm0, ecx
	movss	xmm1, DWORD PTR _YPos$[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN1@SetMapStar

; 1026 : 			YPos=(float)win->ClientArea_[0].bottom-crsr->GetH();

	mov	edx, 16					; 00000010H
	imul	edx, 0
	mov	eax, DWORD PTR _win$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+edx+180]
	mov	ecx, DWORD PTR _crsr$[ebp]
	movss	DWORD PTR tv281[ebp], xmm0
	call	?GetH@C_Base@@QAEJXZ			; C_Base::GetH
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR tv281[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _YPos$[ebp], xmm1
$LN1@SetMapStar:

; 1027 : 
; 1028 : 		crsr->SetXY((int)XPos+crsr->MinX_,(int)YPos+crsr->MinY_);

	cvttss2si ecx, DWORD PTR _YPos$[ebp]
	mov	edx, DWORD PTR _crsr$[ebp]
	movsx	eax, WORD PTR [edx+116]
	add	ecx, eax
	push	ecx
	cvttss2si ecx, DWORD PTR _XPos$[ebp]
	mov	edx, DWORD PTR _crsr$[ebp]
	movsx	eax, WORD PTR [edx+114]
	add	ecx, eax
	push	ecx
	mov	ecx, DWORD PTR _crsr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _crsr$[ebp]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1029 : 		win->RefreshWindow();

	mov	ecx, DWORD PTR _win$[ebp]
	call	?RefreshWindow@C_Window@@QAEXXZ		; C_Window::RefreshWindow
$LN5@SetMapStar:

; 1030 : 	}
; 1031 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?SetMapStartup@@YAXPAVC_Window@@@Z ENDP			; SetMapStartup
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\instant\instant.cpp
_TEXT	SEGMENT
_btn$ = -4						; size = 4
_win$ = 8						; size = 4
?SetIAStartup@@YAXPAVC_Window@@@Z PROC			; SetIAStartup

; 911  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 912  : 	C_Button *btn;
; 913  : 
; 914  : 	btn=(C_Button *)win->FindControl(IA_MIS_FTR_CTRL);

	push	10004					; 00002714H
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _btn$[ebp], eax

; 915  : 	if(btn)

	cmp	DWORD PTR _btn$[ebp], 0
	je	SHORT $LN27@SetIAStart

; 916  : 	{
; 917  : 		if(InstantActionSettings.MissionType == _MISSION_AIR_TO_AIR_)

	cmp	DWORD PTR ?InstantActionSettings@@3UUI_IA@@A, 0
	jne	SHORT $LN26@SetIAStart

; 918  : 			btn->SetState(1);

	push	1
	mov	eax, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 919  : 		else

	jmp	SHORT $LN25@SetIAStart
$LN26@SetIAStart:

; 920  : 			btn->SetState(0);

	push	0
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+56]
	call	eax
$LN25@SetIAStart:

; 921  : 		btn->Refresh();

	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN27@SetIAStart:

; 922  : 	}
; 923  : 	btn=(C_Button *)win->FindControl(IA_MIS_MUD_CTRL);

	push	10005					; 00002715H
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _btn$[ebp], eax

; 924  : 	if(btn)

	cmp	DWORD PTR _btn$[ebp], 0
	je	SHORT $LN24@SetIAStart

; 925  : 	{
; 926  : 		if(InstantActionSettings.MissionType == _MISSION_AIR_TO_GROUND_)

	cmp	DWORD PTR ?InstantActionSettings@@3UUI_IA@@A, 1
	jne	SHORT $LN23@SetIAStart

; 927  : 			btn->SetState(1);

	push	1
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 928  : 		else

	jmp	SHORT $LN22@SetIAStart
$LN23@SetIAStart:

; 929  : 			btn->SetState(0);

	push	0
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+56]
	call	eax
$LN22@SetIAStart:

; 930  : 		btn->Refresh();

	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN24@SetIAStart:

; 931  : 	}
; 932  : 
; 933  : 	btn=(C_Button *)win->FindControl(IA_LVL_NOVICE_CTRL);

	push	10006					; 00002716H
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _btn$[ebp], eax

; 934  : 	if(btn)

	cmp	DWORD PTR _btn$[ebp], 0
	je	SHORT $LN21@SetIAStart

; 935  : 	{
; 936  : 		if(InstantActionSettings.PilotLevel == _PILOT_LEVEL_NOVICE_)

	cmp	DWORD PTR ?InstantActionSettings@@3UUI_IA@@A+4, 0
	jne	SHORT $LN20@SetIAStart

; 937  : 			btn->SetState(1);

	push	1
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 938  : 		else

	jmp	SHORT $LN19@SetIAStart
$LN20@SetIAStart:

; 939  : 			btn->SetState(0);

	push	0
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+56]
	call	eax
$LN19@SetIAStart:

; 940  : 		btn->Refresh();

	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN21@SetIAStart:

; 941  : 	}
; 942  : 	btn=(C_Button *)win->FindControl(IA_LVL_CADET_CTRL);

	push	10007					; 00002717H
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _btn$[ebp], eax

; 943  : 	if(btn)

	cmp	DWORD PTR _btn$[ebp], 0
	je	SHORT $LN18@SetIAStart

; 944  : 	{
; 945  : 		if(InstantActionSettings.PilotLevel == _PILOT_LEVEL_CADET_)

	cmp	DWORD PTR ?InstantActionSettings@@3UUI_IA@@A+4, 1
	jne	SHORT $LN17@SetIAStart

; 946  : 			btn->SetState(1);

	push	1
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 947  : 		else

	jmp	SHORT $LN16@SetIAStart
$LN17@SetIAStart:

; 948  : 			btn->SetState(0);

	push	0
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+56]
	call	eax
$LN16@SetIAStart:

; 949  : 		btn->Refresh();

	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN18@SetIAStart:

; 950  : 	}
; 951  : 	btn=(C_Button *)win->FindControl(IA_LVL_ROOKIE_CTRL);

	push	10008					; 00002718H
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _btn$[ebp], eax

; 952  : 	if(btn)

	cmp	DWORD PTR _btn$[ebp], 0
	je	SHORT $LN15@SetIAStart

; 953  : 	{
; 954  : 		if(InstantActionSettings.PilotLevel == _PILOT_LEVEL_ROOKIE_)

	cmp	DWORD PTR ?InstantActionSettings@@3UUI_IA@@A+4, 2
	jne	SHORT $LN14@SetIAStart

; 955  : 			btn->SetState(1);

	push	1
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 956  : 		else

	jmp	SHORT $LN13@SetIAStart
$LN14@SetIAStart:

; 957  : 			btn->SetState(0);

	push	0
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+56]
	call	eax
$LN13@SetIAStart:

; 958  : 		btn->Refresh();

	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN15@SetIAStart:

; 959  : 	}
; 960  : 	btn=(C_Button *)win->FindControl(IA_LVL_VETERAN_CTRL);

	push	10009					; 00002719H
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _btn$[ebp], eax

; 961  : 	if(btn)

	cmp	DWORD PTR _btn$[ebp], 0
	je	SHORT $LN12@SetIAStart

; 962  : 	{
; 963  : 		if(InstantActionSettings.PilotLevel == _PILOT_LEVEL_VETERAN_)

	cmp	DWORD PTR ?InstantActionSettings@@3UUI_IA@@A+4, 3
	jne	SHORT $LN11@SetIAStart

; 964  : 			btn->SetState(1);

	push	1
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 965  : 		else

	jmp	SHORT $LN10@SetIAStart
$LN11@SetIAStart:

; 966  : 			btn->SetState(0);

	push	0
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+56]
	call	eax
$LN10@SetIAStart:

; 967  : 		btn->Refresh();

	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN12@SetIAStart:

; 968  : 	}
; 969  : 	btn=(C_Button *)win->FindControl(IA_LVL_ACE_CTRL);

	push	10010					; 0000271aH
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _btn$[ebp], eax

; 970  : 	if(btn)

	cmp	DWORD PTR _btn$[ebp], 0
	je	SHORT $LN9@SetIAStart

; 971  : 	{
; 972  : 		if(InstantActionSettings.PilotLevel == _PILOT_LEVEL_ACE_)

	cmp	DWORD PTR ?InstantActionSettings@@3UUI_IA@@A+4, 4
	jne	SHORT $LN8@SetIAStart

; 973  : 			btn->SetState(1);

	push	1
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 974  : 		else

	jmp	SHORT $LN7@SetIAStart
$LN8@SetIAStart:

; 975  : 			btn->SetState(0);

	push	0
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+56]
	call	eax
$LN7@SetIAStart:

; 976  : 		btn->Refresh();

	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN9@SetIAStart:

; 977  : 	}
; 978  : 
; 979  : 	btn=(C_Button *)win->FindControl(IA_AD_SAMS_CTRL);

	push	10011					; 0000271bH
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _btn$[ebp], eax

; 980  : 	if(btn)

	cmp	DWORD PTR _btn$[ebp], 0
	je	SHORT $LN6@SetIAStart

; 981  : 	{
; 982  : 		if(InstantActionSettings.SamSites == _SAM_SITES_)

	cmp	DWORD PTR ?InstantActionSettings@@3UUI_IA@@A+8, 1
	jne	SHORT $LN5@SetIAStart

; 983  : 			btn->SetState(1);

	push	1
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 984  : 		else

	jmp	SHORT $LN4@SetIAStart
$LN5@SetIAStart:

; 985  : 			btn->SetState(0);

	push	0
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+56]
	call	eax
$LN4@SetIAStart:

; 986  : 		btn->Refresh();

	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN6@SetIAStart:

; 987  : 	}
; 988  : 	btn=(C_Button *)win->FindControl(IA_AD_AAA_CTRL);

	push	10012					; 0000271cH
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _btn$[ebp], eax

; 989  : 	if(btn)

	cmp	DWORD PTR _btn$[ebp], 0
	je	SHORT $LN28@SetIAStart

; 990  : 	{
; 991  : 		if(InstantActionSettings.AAASites == _AAA_SITES_)

	cmp	DWORD PTR ?InstantActionSettings@@3UUI_IA@@A+12, 1
	jne	SHORT $LN2@SetIAStart

; 992  : 			btn->SetState(1);

	push	1
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 993  : 		else

	jmp	SHORT $LN1@SetIAStart
$LN2@SetIAStart:

; 994  : 			btn->SetState(0);

	push	0
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+56]
	call	eax
$LN1@SetIAStart:

; 995  : 		btn->Refresh();

	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN28@SetIAStart:

; 996  : 	}
; 997  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SetIAStartup@@YAXPAVC_Window@@@Z ENDP			; SetIAStartup
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\instant\instant.cpp
_TEXT	SEGMENT
_flag$ = -16						; size = 4
_value$ = -12						; size = 4
_clk$ = -8						; size = 4
_dir$ = -4						; size = 2
___formal$ = 8						; size = 4
_hittype$ = 12						; size = 2
_control$ = 16						; size = 4
?ChangeTimeCB@@YAXJFPAVC_Base@@@Z PROC			; ChangeTimeCB

; 729  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 730  : 	C_Clock *clk;
; 731  : 	short dir=0;

	xor	eax, eax
	mov	WORD PTR _dir$[ebp], ax

; 732  : 	long value,flag;
; 733  : 
; 734  : 	if(hittype != C_TYPE_LMOUSEUP && hittype != C_TYPE_REPEAT)

	movsx	ecx, WORD PTR _hittype$[ebp]
	cmp	ecx, 52					; 00000034H
	je	SHORT $LN24@ChangeTime
	movsx	edx, WORD PTR _hittype$[ebp]
	cmp	edx, 70					; 00000046H
	je	SHORT $LN24@ChangeTime

; 735  : 		return;

	jmp	$LN25@ChangeTime
$LN24@ChangeTime:

; 736  : 
; 737  : 	dir=static_cast<short>(control->GetUserNumber(1));

	push	1
	mov	ecx, DWORD PTR _control$[ebp]
	call	?GetUserNumber@C_Base@@QAEJJ@Z		; C_Base::GetUserNumber
	mov	WORD PTR _dir$[ebp], ax

; 738  : 
; 739  : 	clk=(C_Clock*)control->Parent_->FindControl(control->GetUserNumber(0));

	push	0
	mov	ecx, DWORD PTR _control$[ebp]
	call	?GetUserNumber@C_Base@@QAEJJ@Z		; C_Base::GetUserNumber
	push	eax
	mov	eax, DWORD PTR _control$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _clk$[ebp], eax

; 740  : 	if(clk)

	cmp	DWORD PTR _clk$[ebp], 0
	je	$LN25@ChangeTime

; 741  : 	{
; 742  : 		flag=0;

	mov	DWORD PTR _flag$[ebp], 0

; 743  : 		if(clk->GetCurrentCtrl())

	mov	ecx, DWORD PTR _clk$[ebp]
	call	?GetCurrentCtrl@C_Clock@@QAEPAVC_EditBox@@XZ ; C_Clock::GetCurrentCtrl
	test	eax, eax
	je	$LN22@ChangeTime

; 744  : 		{
; 745  : 			value=clk->GetLast()+dir;

	mov	ecx, DWORD PTR _clk$[ebp]
	call	?GetLast@C_Clock@@QAEJXZ		; C_Clock::GetLast
	movsx	ecx, WORD PTR _dir$[ebp]
	add	eax, ecx
	mov	DWORD PTR _value$[ebp], eax

; 746  : 			if(value < clk->GetCurrentCtrl()->GetMinInteger())

	mov	ecx, DWORD PTR _clk$[ebp]
	call	?GetCurrentCtrl@C_Clock@@QAEPAVC_EditBox@@XZ ; C_Clock::GetCurrentCtrl
	mov	ecx, eax
	call	?GetMinInteger@C_EditBox@@QAEJXZ	; C_EditBox::GetMinInteger
	cmp	DWORD PTR _value$[ebp], eax
	jge	SHORT $LN21@ChangeTime

; 747  : 			{
; 748  : 				value=clk->GetCurrentCtrl()->GetMaxInteger();

	mov	ecx, DWORD PTR _clk$[ebp]
	call	?GetCurrentCtrl@C_Clock@@QAEPAVC_EditBox@@XZ ; C_Clock::GetCurrentCtrl
	mov	ecx, eax
	call	?GetMaxInteger@C_EditBox@@QAEJXZ	; C_EditBox::GetMaxInteger
	mov	DWORD PTR _value$[ebp], eax

; 749  : 				flag=clk->GetCurrentCtrl()->GetID();

	mov	ecx, DWORD PTR _clk$[ebp]
	call	?GetCurrentCtrl@C_Clock@@QAEPAVC_EditBox@@XZ ; C_Clock::GetCurrentCtrl
	mov	ecx, eax
	call	?GetID@C_Base@@QAEJXZ			; C_Base::GetID
	mov	DWORD PTR _flag$[ebp], eax
	jmp	SHORT $LN20@ChangeTime
$LN21@ChangeTime:

; 750  : 			}
; 751  : 			else if(value > clk->GetCurrentCtrl()->GetMaxInteger())

	mov	ecx, DWORD PTR _clk$[ebp]
	call	?GetCurrentCtrl@C_Clock@@QAEPAVC_EditBox@@XZ ; C_Clock::GetCurrentCtrl
	mov	ecx, eax
	call	?GetMaxInteger@C_EditBox@@QAEJXZ	; C_EditBox::GetMaxInteger
	cmp	DWORD PTR _value$[ebp], eax
	jle	SHORT $LN20@ChangeTime

; 752  : 			{
; 753  : 				value=clk->GetCurrentCtrl()->GetMinInteger();

	mov	ecx, DWORD PTR _clk$[ebp]
	call	?GetCurrentCtrl@C_Clock@@QAEPAVC_EditBox@@XZ ; C_Clock::GetCurrentCtrl
	mov	ecx, eax
	call	?GetMinInteger@C_EditBox@@QAEJXZ	; C_EditBox::GetMinInteger
	mov	DWORD PTR _value$[ebp], eax

; 754  : 				flag=clk->GetCurrentCtrl()->GetID();

	mov	ecx, DWORD PTR _clk$[ebp]
	call	?GetCurrentCtrl@C_Clock@@QAEPAVC_EditBox@@XZ ; C_Clock::GetCurrentCtrl
	mov	ecx, eax
	call	?GetID@C_Base@@QAEJXZ			; C_Base::GetID
	mov	DWORD PTR _flag$[ebp], eax
$LN20@ChangeTime:

; 755  : 			}
; 756  : 			clk->SetLast(value);

	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	mov	ecx, DWORD PTR _clk$[ebp]
	call	?SetLast@C_Clock@@QAEXJ@Z		; C_Clock::SetLast

; 757  : 		}
; 758  : 		else

	jmp	$LN18@ChangeTime
$LN22@ChangeTime:

; 759  : 		{
; 760  : 			value=clk->GetSecond()+dir;

	mov	ecx, DWORD PTR _clk$[ebp]
	call	?GetSecond@C_Clock@@QAEJXZ		; C_Clock::GetSecond
	movsx	ecx, WORD PTR _dir$[ebp]
	add	eax, ecx
	mov	DWORD PTR _value$[ebp], eax

; 761  : 			if(value < clk->GetSecondCtrl()->GetMinInteger())

	mov	ecx, DWORD PTR _clk$[ebp]
	call	?GetSecondCtrl@C_Clock@@QAEPAVC_EditBox@@XZ ; C_Clock::GetSecondCtrl
	mov	ecx, eax
	call	?GetMinInteger@C_EditBox@@QAEJXZ	; C_EditBox::GetMinInteger
	cmp	DWORD PTR _value$[ebp], eax
	jge	SHORT $LN17@ChangeTime

; 762  : 			{
; 763  : 				value=clk->GetSecondCtrl()->GetMaxInteger();

	mov	ecx, DWORD PTR _clk$[ebp]
	call	?GetSecondCtrl@C_Clock@@QAEPAVC_EditBox@@XZ ; C_Clock::GetSecondCtrl
	mov	ecx, eax
	call	?GetMaxInteger@C_EditBox@@QAEJXZ	; C_EditBox::GetMaxInteger
	mov	DWORD PTR _value$[ebp], eax

; 764  : 				flag=clk->GetSecondCtrl()->GetID();

	mov	ecx, DWORD PTR _clk$[ebp]
	call	?GetSecondCtrl@C_Clock@@QAEPAVC_EditBox@@XZ ; C_Clock::GetSecondCtrl
	mov	ecx, eax
	call	?GetID@C_Base@@QAEJXZ			; C_Base::GetID
	mov	DWORD PTR _flag$[ebp], eax
	jmp	SHORT $LN16@ChangeTime
$LN17@ChangeTime:

; 765  : 			}
; 766  : 			else if(value > clk->GetSecondCtrl()->GetMaxInteger())

	mov	ecx, DWORD PTR _clk$[ebp]
	call	?GetSecondCtrl@C_Clock@@QAEPAVC_EditBox@@XZ ; C_Clock::GetSecondCtrl
	mov	ecx, eax
	call	?GetMaxInteger@C_EditBox@@QAEJXZ	; C_EditBox::GetMaxInteger
	cmp	DWORD PTR _value$[ebp], eax
	jle	SHORT $LN16@ChangeTime

; 767  : 			{
; 768  : 				value=clk->GetSecondCtrl()->GetMinInteger();

	mov	ecx, DWORD PTR _clk$[ebp]
	call	?GetSecondCtrl@C_Clock@@QAEPAVC_EditBox@@XZ ; C_Clock::GetSecondCtrl
	mov	ecx, eax
	call	?GetMinInteger@C_EditBox@@QAEJXZ	; C_EditBox::GetMinInteger
	mov	DWORD PTR _value$[ebp], eax

; 769  : 				flag=clk->GetSecondCtrl()->GetID();

	mov	ecx, DWORD PTR _clk$[ebp]
	call	?GetSecondCtrl@C_Clock@@QAEPAVC_EditBox@@XZ ; C_Clock::GetSecondCtrl
	mov	ecx, eax
	call	?GetID@C_Base@@QAEJXZ			; C_Base::GetID
	mov	DWORD PTR _flag$[ebp], eax
$LN16@ChangeTime:

; 770  : 			}
; 771  : 			clk->SetSecond(value);

	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	mov	ecx, DWORD PTR _clk$[ebp]
	call	?SetSecond@C_Clock@@QAEXJ@Z		; C_Clock::SetSecond
$LN18@ChangeTime:

; 772  : 		}
; 773  : 		if(flag)

	cmp	DWORD PTR _flag$[ebp], 0
	je	$LN14@ChangeTime

; 774  : 		{
; 775  : 			if(flag == 4)

	cmp	DWORD PTR _flag$[ebp], 4
	jne	$LN13@ChangeTime

; 776  : 			{
; 777  : 				flag=0;

	mov	DWORD PTR _flag$[ebp], 0

; 778  : 				value=clk->GetMinute()+dir;

	mov	ecx, DWORD PTR _clk$[ebp]
	call	?GetMinute@C_Clock@@QAEJXZ		; C_Clock::GetMinute
	movsx	ecx, WORD PTR _dir$[ebp]
	add	eax, ecx
	mov	DWORD PTR _value$[ebp], eax

; 779  : 				if(value < clk->GetMinuteCtrl()->GetMinInteger())

	mov	ecx, DWORD PTR _clk$[ebp]
	call	?GetMinuteCtrl@C_Clock@@QAEPAVC_EditBox@@XZ ; C_Clock::GetMinuteCtrl
	mov	ecx, eax
	call	?GetMinInteger@C_EditBox@@QAEJXZ	; C_EditBox::GetMinInteger
	cmp	DWORD PTR _value$[ebp], eax
	jge	SHORT $LN12@ChangeTime

; 780  : 				{
; 781  : 					value=clk->GetMinuteCtrl()->GetMaxInteger();

	mov	ecx, DWORD PTR _clk$[ebp]
	call	?GetMinuteCtrl@C_Clock@@QAEPAVC_EditBox@@XZ ; C_Clock::GetMinuteCtrl
	mov	ecx, eax
	call	?GetMaxInteger@C_EditBox@@QAEJXZ	; C_EditBox::GetMaxInteger
	mov	DWORD PTR _value$[ebp], eax

; 782  : 					flag=clk->GetMinuteCtrl()->GetID();

	mov	ecx, DWORD PTR _clk$[ebp]
	call	?GetMinuteCtrl@C_Clock@@QAEPAVC_EditBox@@XZ ; C_Clock::GetMinuteCtrl
	mov	ecx, eax
	call	?GetID@C_Base@@QAEJXZ			; C_Base::GetID
	mov	DWORD PTR _flag$[ebp], eax
	jmp	SHORT $LN11@ChangeTime
$LN12@ChangeTime:

; 783  : 				}
; 784  : 				else if(value > clk->GetMinuteCtrl()->GetMaxInteger())

	mov	ecx, DWORD PTR _clk$[ebp]
	call	?GetMinuteCtrl@C_Clock@@QAEPAVC_EditBox@@XZ ; C_Clock::GetMinuteCtrl
	mov	ecx, eax
	call	?GetMaxInteger@C_EditBox@@QAEJXZ	; C_EditBox::GetMaxInteger
	cmp	DWORD PTR _value$[ebp], eax
	jle	SHORT $LN11@ChangeTime

; 785  : 				{
; 786  : 					value=clk->GetMinuteCtrl()->GetMinInteger();

	mov	ecx, DWORD PTR _clk$[ebp]
	call	?GetMinuteCtrl@C_Clock@@QAEPAVC_EditBox@@XZ ; C_Clock::GetMinuteCtrl
	mov	ecx, eax
	call	?GetMinInteger@C_EditBox@@QAEJXZ	; C_EditBox::GetMinInteger
	mov	DWORD PTR _value$[ebp], eax

; 787  : 					flag=clk->GetMinuteCtrl()->GetID();

	mov	ecx, DWORD PTR _clk$[ebp]
	call	?GetMinuteCtrl@C_Clock@@QAEPAVC_EditBox@@XZ ; C_Clock::GetMinuteCtrl
	mov	ecx, eax
	call	?GetID@C_Base@@QAEJXZ			; C_Base::GetID
	mov	DWORD PTR _flag$[ebp], eax
$LN11@ChangeTime:

; 788  : 				}
; 789  : 				clk->SetMinute(value);

	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	mov	ecx, DWORD PTR _clk$[ebp]
	call	?SetMinute@C_Clock@@QAEXJ@Z		; C_Clock::SetMinute
$LN13@ChangeTime:

; 790  : 			}
; 791  : 			if(flag == 3)

	cmp	DWORD PTR _flag$[ebp], 3
	jne	$LN9@ChangeTime

; 792  : 			{
; 793  : 				flag=0;

	mov	DWORD PTR _flag$[ebp], 0

; 794  : 				value=clk->GetHour()+dir;

	mov	ecx, DWORD PTR _clk$[ebp]
	call	?GetHour@C_Clock@@QAEJXZ		; C_Clock::GetHour
	movsx	ecx, WORD PTR _dir$[ebp]
	add	eax, ecx
	mov	DWORD PTR _value$[ebp], eax

; 795  : 				if(value < clk->GetHourCtrl()->GetMinInteger())

	mov	ecx, DWORD PTR _clk$[ebp]
	call	?GetHourCtrl@C_Clock@@QAEPAVC_EditBox@@XZ ; C_Clock::GetHourCtrl
	mov	ecx, eax
	call	?GetMinInteger@C_EditBox@@QAEJXZ	; C_EditBox::GetMinInteger
	cmp	DWORD PTR _value$[ebp], eax
	jge	SHORT $LN8@ChangeTime

; 796  : 				{
; 797  : 					value=clk->GetHourCtrl()->GetMaxInteger();

	mov	ecx, DWORD PTR _clk$[ebp]
	call	?GetHourCtrl@C_Clock@@QAEPAVC_EditBox@@XZ ; C_Clock::GetHourCtrl
	mov	ecx, eax
	call	?GetMaxInteger@C_EditBox@@QAEJXZ	; C_EditBox::GetMaxInteger
	mov	DWORD PTR _value$[ebp], eax

; 798  : 					flag=clk->GetHourCtrl()->GetID();

	mov	ecx, DWORD PTR _clk$[ebp]
	call	?GetHourCtrl@C_Clock@@QAEPAVC_EditBox@@XZ ; C_Clock::GetHourCtrl
	mov	ecx, eax
	call	?GetID@C_Base@@QAEJXZ			; C_Base::GetID
	mov	DWORD PTR _flag$[ebp], eax
	jmp	SHORT $LN7@ChangeTime
$LN8@ChangeTime:

; 799  : 				}
; 800  : 				else if(value > clk->GetHourCtrl()->GetMaxInteger())

	mov	ecx, DWORD PTR _clk$[ebp]
	call	?GetHourCtrl@C_Clock@@QAEPAVC_EditBox@@XZ ; C_Clock::GetHourCtrl
	mov	ecx, eax
	call	?GetMaxInteger@C_EditBox@@QAEJXZ	; C_EditBox::GetMaxInteger
	cmp	DWORD PTR _value$[ebp], eax
	jle	SHORT $LN7@ChangeTime

; 801  : 				{
; 802  : 					value=clk->GetHourCtrl()->GetMinInteger();

	mov	ecx, DWORD PTR _clk$[ebp]
	call	?GetHourCtrl@C_Clock@@QAEPAVC_EditBox@@XZ ; C_Clock::GetHourCtrl
	mov	ecx, eax
	call	?GetMinInteger@C_EditBox@@QAEJXZ	; C_EditBox::GetMinInteger
	mov	DWORD PTR _value$[ebp], eax

; 803  : 					flag=clk->GetHourCtrl()->GetID();

	mov	ecx, DWORD PTR _clk$[ebp]
	call	?GetHourCtrl@C_Clock@@QAEPAVC_EditBox@@XZ ; C_Clock::GetHourCtrl
	mov	ecx, eax
	call	?GetID@C_Base@@QAEJXZ			; C_Base::GetID
	mov	DWORD PTR _flag$[ebp], eax
$LN7@ChangeTime:

; 804  : 				}
; 805  : 				clk->SetHour(value);

	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	mov	ecx, DWORD PTR _clk$[ebp]
	call	?SetHour@C_Clock@@QAEXJ@Z		; C_Clock::SetHour
$LN9@ChangeTime:

; 806  : 			}
; 807  : 			if(flag == 2)

	cmp	DWORD PTR _flag$[ebp], 2
	jne	$LN14@ChangeTime

; 808  : 			{
; 809  : 				if(clk->GetDayCtrl())

	mov	ecx, DWORD PTR _clk$[ebp]
	call	?GetDayCtrl@C_Clock@@QAEPAVC_EditBox@@XZ ; C_Clock::GetDayCtrl
	test	eax, eax
	je	$LN14@ChangeTime

; 810  : 				{
; 811  : 					flag=0;

	mov	DWORD PTR _flag$[ebp], 0

; 812  : 					value=clk->GetDay()+dir;

	mov	ecx, DWORD PTR _clk$[ebp]
	call	?GetDay@C_Clock@@QAEJXZ			; C_Clock::GetDay
	movsx	ecx, WORD PTR _dir$[ebp]
	add	eax, ecx
	mov	DWORD PTR _value$[ebp], eax

; 813  : 					if(value < clk->GetDayCtrl()->GetMinInteger()-1)

	mov	ecx, DWORD PTR _clk$[ebp]
	call	?GetDayCtrl@C_Clock@@QAEPAVC_EditBox@@XZ ; C_Clock::GetDayCtrl
	mov	ecx, eax
	call	?GetMinInteger@C_EditBox@@QAEJXZ	; C_EditBox::GetMinInteger
	sub	eax, 1
	cmp	DWORD PTR _value$[ebp], eax
	jge	SHORT $LN3@ChangeTime

; 814  : 					{
; 815  : 						value=clk->GetDayCtrl()->GetMaxInteger()-1;

	mov	ecx, DWORD PTR _clk$[ebp]
	call	?GetDayCtrl@C_Clock@@QAEPAVC_EditBox@@XZ ; C_Clock::GetDayCtrl
	mov	ecx, eax
	call	?GetMaxInteger@C_EditBox@@QAEJXZ	; C_EditBox::GetMaxInteger
	sub	eax, 1
	mov	DWORD PTR _value$[ebp], eax

; 816  : 						flag=clk->GetDayCtrl()->GetID();

	mov	ecx, DWORD PTR _clk$[ebp]
	call	?GetDayCtrl@C_Clock@@QAEPAVC_EditBox@@XZ ; C_Clock::GetDayCtrl
	mov	ecx, eax
	call	?GetID@C_Base@@QAEJXZ			; C_Base::GetID
	mov	DWORD PTR _flag$[ebp], eax
	jmp	SHORT $LN2@ChangeTime
$LN3@ChangeTime:

; 817  : 					}
; 818  : 					else if(value > clk->GetDayCtrl()->GetMaxInteger()-1)

	mov	ecx, DWORD PTR _clk$[ebp]
	call	?GetDayCtrl@C_Clock@@QAEPAVC_EditBox@@XZ ; C_Clock::GetDayCtrl
	mov	ecx, eax
	call	?GetMaxInteger@C_EditBox@@QAEJXZ	; C_EditBox::GetMaxInteger
	sub	eax, 1
	cmp	DWORD PTR _value$[ebp], eax
	jle	SHORT $LN2@ChangeTime

; 819  : 					{
; 820  : 						value=clk->GetDayCtrl()->GetMinInteger()-1;

	mov	ecx, DWORD PTR _clk$[ebp]
	call	?GetDayCtrl@C_Clock@@QAEPAVC_EditBox@@XZ ; C_Clock::GetDayCtrl
	mov	ecx, eax
	call	?GetMinInteger@C_EditBox@@QAEJXZ	; C_EditBox::GetMinInteger
	sub	eax, 1
	mov	DWORD PTR _value$[ebp], eax

; 821  : 						flag=clk->GetDayCtrl()->GetID();

	mov	ecx, DWORD PTR _clk$[ebp]
	call	?GetDayCtrl@C_Clock@@QAEPAVC_EditBox@@XZ ; C_Clock::GetDayCtrl
	mov	ecx, eax
	call	?GetID@C_Base@@QAEJXZ			; C_Base::GetID
	mov	DWORD PTR _flag$[ebp], eax
$LN2@ChangeTime:

; 822  : 					}
; 823  : 					clk->SetDay(value);

	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	mov	ecx, DWORD PTR _clk$[ebp]
	call	?SetDay@C_Clock@@QAEXJ@Z		; C_Clock::SetDay
$LN14@ChangeTime:

; 824  : 				}
; 825  : 			}
; 826  : 
; 827  : 		}
; 828  : 		clk->Refresh();

	mov	eax, DWORD PTR _clk$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _clk$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN25@ChangeTime:

; 829  : 	}
; 830  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ChangeTimeCB@@YAXJFPAVC_Base@@@Z ENDP			; ChangeTimeCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\instant\instant.cpp
_TEXT	SEGMENT
_ID$ = 8						; size = 4
_DKKey$ = 12						; size = 2
_control$ = 16						; size = 4
?HighScoreKeyboardCB@@YAXJFPAVC_Base@@@Z PROC		; HighScoreKeyboardCB

; 723  : {

	push	ebp
	mov	ebp, esp

; 724  : 	if(DKKey == DIK_RETURN)

	movsx	eax, WORD PTR _DKKey$[ebp]
	cmp	eax, 28					; 0000001cH
	jne	SHORT $LN2@HighScoreK

; 725  : 		InsertScoreCB(ID,C_TYPE_LMOUSEUP,control);

	mov	ecx, DWORD PTR _control$[ebp]
	push	ecx
	push	52					; 00000034H
	mov	edx, DWORD PTR _ID$[ebp]
	push	edx
	call	?InsertScoreCB@@YAXJFPAVC_Base@@@Z	; InsertScoreCB
	add	esp, 12					; 0000000cH
$LN2@HighScoreK:

; 726  : }

	pop	ebp
	ret	0
?HighScoreKeyboardCB@@YAXJFPAVC_Base@@@Z ENDP		; HighScoreKeyboardCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\instant\instant.cpp
_TEXT	SEGMENT
tv433 = -64						; size = 8
tv406 = -56						; size = 8
tv441 = -48						; size = 4
tv455 = -44						; size = 4
tv414 = -40						; size = 4
tv453 = -36						; size = 4
_clk$ = -32						; size = 4
tv430 = -28						; size = 4
tv403 = -24						; size = 4
_YPos$ = -20						; size = 4
_XPos$ = -16						; size = 4
_crsr$ = -12						; size = 4
_win$ = -8						; size = 4
_btn$ = -4						; size = 4
___formal$ = 8						; size = 4
_hittype$ = 12						; size = 2
___formal$ = 16						; size = 4
?InstantActionFlyCB@@YAXJFPAVC_Base@@@Z PROC		; InstantActionFlyCB

; 519  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	esi
	push	edi

; 520  : 	C_Window *win;
; 521  : 	C_Button *btn;
; 522  : 	C_Cursor *crsr;
; 523  : 	C_Clock *clk;
; 524  : 	float XPos,YPos;
; 525  : 	if(hittype != C_TYPE_LMOUSEUP)

	movsx	eax, WORD PTR _hittype$[ebp]
	cmp	eax, 52					; 00000034H
	je	SHORT $LN21@InstantAct

; 526  : 		return;

	jmp	$LN22@InstantAct
$LN21@InstantAct:

; 527  : 
; 528  : 	win=gMainHandler->FindWindow(IA_SETTINGS_WIN);

	push	10001					; 00002711H
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z ; C_Handler::FindWindowA
	mov	DWORD PTR _win$[ebp], eax

; 529  : 	if(win)

	cmp	DWORD PTR _win$[ebp], 0
	je	$LN6@InstantAct

; 530  : 	{
; 531  : 		InstantActionSettings.MissionType=_MISSION_AIR_TO_AIR_;

	mov	DWORD PTR ?InstantActionSettings@@3UUI_IA@@A, 0

; 532  : 		instant_action::set_start_mode ('f');

	push	102					; 00000066H
	call	?set_start_mode@instant_action@@SAXD@Z	; instant_action::set_start_mode
	add	esp, 4

; 533  : 
; 534  : 		btn=(C_Button *)win->FindControl(IA_MIS_MUD_CTRL);

	push	10005					; 00002715H
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _btn$[ebp], eax

; 535  : 		if(btn)

	cmp	DWORD PTR _btn$[ebp], 0
	je	SHORT $LN18@InstantAct

; 536  : 		{
; 537  : 			if(btn->GetState())

	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN18@InstantAct

; 538  : 			{
; 539  : 				InstantActionSettings.MissionType=_MISSION_AIR_TO_GROUND_;

	mov	DWORD PTR ?InstantActionSettings@@3UUI_IA@@A, 1

; 540  : 				instant_action::set_start_mode ('m');

	push	109					; 0000006dH
	call	?set_start_mode@instant_action@@SAXD@Z	; instant_action::set_start_mode
	add	esp, 4
$LN18@InstantAct:

; 541  : 			}
; 542  : 		}
; 543  : 
; 544  : 		InstantActionSettings.PilotLevel=_PILOT_LEVEL_NOVICE_;;

	mov	DWORD PTR ?InstantActionSettings@@3UUI_IA@@A+4, 0

; 545  : 		btn=(C_Button *)win->FindControl(IA_LVL_CADET_CTRL);

	push	10007					; 00002717H
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _btn$[ebp], eax

; 546  : 		if(btn)

	cmp	DWORD PTR _btn$[ebp], 0
	je	SHORT $LN16@InstantAct

; 547  : 		{
; 548  : 			if(btn->GetState())

	mov	edx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [eax+112]
	call	edx
	cwde
	test	eax, eax
	je	SHORT $LN16@InstantAct

; 549  : 				InstantActionSettings.PilotLevel=_PILOT_LEVEL_CADET_;

	mov	DWORD PTR ?InstantActionSettings@@3UUI_IA@@A+4, 1
$LN16@InstantAct:

; 550  : 		}
; 551  : 		btn=(C_Button *)win->FindControl(IA_LVL_ROOKIE_CTRL);

	push	10008					; 00002718H
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _btn$[ebp], eax

; 552  : 		if(btn)

	cmp	DWORD PTR _btn$[ebp], 0
	je	SHORT $LN14@InstantAct

; 553  : 		{
; 554  : 			if(btn->GetState())

	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN14@InstantAct

; 555  : 				InstantActionSettings.PilotLevel=_PILOT_LEVEL_ROOKIE_;

	mov	DWORD PTR ?InstantActionSettings@@3UUI_IA@@A+4, 2
$LN14@InstantAct:

; 556  : 		}
; 557  : 		btn=(C_Button *)win->FindControl(IA_LVL_VETERAN_CTRL);

	push	10009					; 00002719H
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _btn$[ebp], eax

; 558  : 		if(btn)

	cmp	DWORD PTR _btn$[ebp], 0
	je	SHORT $LN12@InstantAct

; 559  : 		{
; 560  : 			if(btn->GetState())

	mov	edx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [eax+112]
	call	edx
	cwde
	test	eax, eax
	je	SHORT $LN12@InstantAct

; 561  : 				InstantActionSettings.PilotLevel=_PILOT_LEVEL_VETERAN_;

	mov	DWORD PTR ?InstantActionSettings@@3UUI_IA@@A+4, 3
$LN12@InstantAct:

; 562  : 		}
; 563  : 		btn=(C_Button *)win->FindControl(IA_LVL_ACE_CTRL);

	push	10010					; 0000271aH
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _btn$[ebp], eax

; 564  : 		if(btn)

	cmp	DWORD PTR _btn$[ebp], 0
	je	SHORT $LN10@InstantAct

; 565  : 		{
; 566  : 			if(btn->GetState())

	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN10@InstantAct

; 567  : 				InstantActionSettings.PilotLevel=_PILOT_LEVEL_ACE_;

	mov	DWORD PTR ?InstantActionSettings@@3UUI_IA@@A+4, 4
$LN10@InstantAct:

; 568  : 		}
; 569  : 
; 570  : 		InstantActionSettings.SamSites=_NO_SAM_SITES_;

	mov	DWORD PTR ?InstantActionSettings@@3UUI_IA@@A+8, 0

; 571  : 		btn=(C_Button *)win->FindControl(IA_AD_SAMS_CTRL);

	push	10011					; 0000271bH
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _btn$[ebp], eax

; 572  : 		if(btn)

	cmp	DWORD PTR _btn$[ebp], 0
	je	SHORT $LN8@InstantAct

; 573  : 		{
; 574  : 			if(btn->GetState())

	mov	edx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [eax+112]
	call	edx
	cwde
	test	eax, eax
	je	SHORT $LN8@InstantAct

; 575  : 				InstantActionSettings.SamSites=_SAM_SITES_;

	mov	DWORD PTR ?InstantActionSettings@@3UUI_IA@@A+8, 1
$LN8@InstantAct:

; 576  : 		}
; 577  : 		InstantActionSettings.AAASites=_NO_AAA_SITES_;

	mov	DWORD PTR ?InstantActionSettings@@3UUI_IA@@A+12, 0

; 578  : 		btn=(C_Button *)win->FindControl(IA_AD_AAA_CTRL);

	push	10012					; 0000271cH
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _btn$[ebp], eax

; 579  : 		if(btn)

	cmp	DWORD PTR _btn$[ebp], 0
	je	SHORT $LN6@InstantAct

; 580  : 		{
; 581  : 			if(btn->GetState())

	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN6@InstantAct

; 582  : 				InstantActionSettings.AAASites=_AAA_SITES_;

	mov	DWORD PTR ?InstantActionSettings@@3UUI_IA@@A+12, 1
$LN6@InstantAct:

; 583  : 		}
; 584  : 	}
; 585  : 	win=gMainHandler->FindWindow(IA_MAP_WIN);

	push	10043					; 0000273bH
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z ; C_Handler::FindWindowA
	mov	DWORD PTR _win$[ebp], eax

; 586  : 	if(win)

	cmp	DWORD PTR _win$[ebp], 0
	je	$LN4@InstantAct

; 587  : 	{
; 588  : 		crsr=(C_Cursor *)win->FindControl(IA_MAP_CURSOR);

	push	10049					; 00002741H
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _crsr$[ebp], eax

; 589  : 		if(crsr)

	cmp	DWORD PTR _crsr$[ebp], 0
	je	$LN4@InstantAct

; 590  : 		{
; 591  : 			// JPO - fix for big theaters.
; 592  : 			// 13119.9 is default ft/block
; 593  : 			XPos=(float)(crsr->GetX()+crsr->GetW()/2-crsr->MinX_) / 
; 594  : 				(float)(crsr->MaxX_-crsr->MinX_);

	mov	ecx, DWORD PTR _crsr$[ebp]
	call	?GetX@C_Base@@QAEJXZ			; C_Base::GetX
	mov	esi, eax
	mov	ecx, DWORD PTR _crsr$[ebp]
	call	?GetW@C_Base@@QAEJXZ			; C_Base::GetW
	cdq
	sub	eax, edx
	sar	eax, 1
	add	esi, eax
	mov	edx, DWORD PTR _crsr$[ebp]
	movsx	eax, WORD PTR [edx+114]
	sub	esi, eax
	cvtsi2ss xmm0, esi
	mov	ecx, DWORD PTR _crsr$[ebp]
	movsx	edx, WORD PTR [ecx+118]
	mov	eax, DWORD PTR _crsr$[ebp]
	movsx	ecx, WORD PTR [eax+114]
	sub	edx, ecx
	cvtsi2ss xmm1, edx
	divss	xmm0, xmm1
	movss	DWORD PTR _XPos$[ebp], xmm0

; 595  : 			XPos *= 4096.0f * TheMap.BlocksWide() * TheMap.FeetPerBlock() / 13119.9F;

	mov	ecx, OFFSET ?TheMap@@3VTMap@@A		; TheMap
	call	?BlocksWide@TMap@@QAEIXZ		; TMap::BlocksWide
	mov	DWORD PTR tv403[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv403[ebp]
	mov	edx, DWORD PTR tv403[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv406[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv406[ebp]
	mulss	xmm0, DWORD PTR __real@45800000
	mov	ecx, OFFSET ?TheMap@@3VTMap@@A		; TheMap
	movss	DWORD PTR tv453[ebp], xmm0
	call	?FeetPerBlock@TMap@@QAEMXZ		; TMap::FeetPerBlock
	fstp	DWORD PTR tv414[ebp]
	movss	xmm0, DWORD PTR tv453[ebp]
	mulss	xmm0, DWORD PTR tv414[ebp]
	divss	xmm0, DWORD PTR __real@464cff9a
	mulss	xmm0, DWORD PTR _XPos$[ebp]
	movss	DWORD PTR _XPos$[ebp], xmm0

; 596  : 			YPos=(float)((crsr->MaxY_-crsr->MinY_) - (crsr->GetY()+crsr->GetH()/2-crsr->MinY_)) / 
; 597  : 				(float)(crsr->MaxY_-crsr->MinY_);

	mov	eax, DWORD PTR _crsr$[ebp]
	movsx	esi, WORD PTR [eax+120]
	mov	ecx, DWORD PTR _crsr$[ebp]
	movsx	edx, WORD PTR [ecx+116]
	sub	esi, edx
	mov	ecx, DWORD PTR _crsr$[ebp]
	call	?GetY@C_Base@@QAEJXZ			; C_Base::GetY
	mov	edi, eax
	mov	ecx, DWORD PTR _crsr$[ebp]
	call	?GetH@C_Base@@QAEJXZ			; C_Base::GetH
	cdq
	sub	eax, edx
	sar	eax, 1
	add	edi, eax
	mov	eax, DWORD PTR _crsr$[ebp]
	movsx	ecx, WORD PTR [eax+116]
	sub	edi, ecx
	sub	esi, edi
	cvtsi2ss xmm0, esi
	mov	edx, DWORD PTR _crsr$[ebp]
	movsx	eax, WORD PTR [edx+120]
	mov	ecx, DWORD PTR _crsr$[ebp]
	movsx	edx, WORD PTR [ecx+116]
	sub	eax, edx
	cvtsi2ss xmm1, eax
	divss	xmm0, xmm1
	movss	DWORD PTR _YPos$[ebp], xmm0

; 598  : 			YPos *=  4096.0f *TheMap.BlocksHigh() * TheMap.FeetPerBlock() / 13119.9F;

	mov	ecx, OFFSET ?TheMap@@3VTMap@@A		; TheMap
	call	?BlocksHigh@TMap@@QAEIXZ		; TMap::BlocksHigh
	mov	DWORD PTR tv430[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv430[ebp]
	mov	eax, DWORD PTR tv430[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	movsd	QWORD PTR tv433[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv433[ebp]
	mulss	xmm0, DWORD PTR __real@45800000
	mov	ecx, OFFSET ?TheMap@@3VTMap@@A		; TheMap
	movss	DWORD PTR tv455[ebp], xmm0
	call	?FeetPerBlock@TMap@@QAEMXZ		; TMap::FeetPerBlock
	fstp	DWORD PTR tv441[ebp]
	movss	xmm0, DWORD PTR tv455[ebp]
	mulss	xmm0, DWORD PTR tv441[ebp]
	divss	xmm0, DWORD PTR __real@464cff9a
	mulss	xmm0, DWORD PTR _YPos$[ebp]
	movss	DWORD PTR _YPos$[ebp], xmm0

; 599  : 
; 600  : 			instant_action::set_start_position (YPos*FEET_PER_KM/1000.0f, XPos*FEET_PER_KM/1000.0f);

	movss	xmm0, DWORD PTR _XPos$[ebp]
	mulss	xmm0, DWORD PTR __real@454cffae
	divss	xmm0, DWORD PTR __real@447a0000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _YPos$[ebp]
	mulss	xmm0, DWORD PTR __real@454cffae
	divss	xmm0, DWORD PTR __real@447a0000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?set_start_position@instant_action@@SAXMM@Z ; instant_action::set_start_position
	add	esp, 8
$LN4@InstantAct:

; 601  : 		}
; 602  : 	}
; 603  : 
; 604  : 	win=gMainHandler->FindWindow(IA_SUA);

	push	10050					; 00002742H
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z ; C_Handler::FindWindowA
	mov	DWORD PTR _win$[ebp], eax

; 605  : 	if(win)

	cmp	DWORD PTR _win$[ebp], 0
	je	SHORT $LN1@InstantAct

; 606  : 	{
; 607  : 		clk=(C_Clock*)win->FindControl(TIME_ID);

	push	5001					; 00001389H
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _clk$[ebp], eax

; 608  : 		if(clk)

	cmp	DWORD PTR _clk$[ebp], 0
	je	SHORT $LN2@InstantAct

; 609  : 			instant_action::set_start_time (clk->GetTime());

	mov	ecx, DWORD PTR _clk$[ebp]
	call	?GetTime@C_Clock@@QAEJXZ		; C_Clock::GetTime
	push	eax
	call	?set_start_time@instant_action@@SAXJ@Z	; instant_action::set_start_time
	add	esp, 4

; 610  : 		else

	jmp	SHORT $LN1@InstantAct
$LN2@InstantAct:

; 611  : 			instant_action::set_start_time (static_cast<long>(12.0F * 60.0F * 60.0F));

	push	43200					; 0000a8c0H
	call	?set_start_time@instant_action@@SAXJ@Z	; instant_action::set_start_time
	add	esp, 4
$LN1@InstantAct:

; 612  : 	}
; 613  : 
; 614  : 	ShiAssert(!TheCampaign.IsLoaded());
; 615  : 
; 616  : 	// Load a campaign here
; 617  : 	strcpy(gUI_CampaignFile,"Instant");

	push	OFFSET ??_C@_07HMOCDNDG@Instant?$AA@
	push	OFFSET ?gUI_CampaignFile@@3PADA		; gUI_CampaignFile
	call	_strcpy
	add	esp, 8

; 618  : 
; 619  : 	ShiAssert(gameCompressionRatio == 0);
; 620  : 
; 621  : 	TheCampaign.SetOnlineStatus( 0 );

	push	0
	mov	ecx, OFFSET ?TheCampaign@@3VCampaignClass@@A ; TheCampaign
	call	?SetOnlineStatus@CampaignClass@@QAEXH@Z	; CampaignClass::SetOnlineStatus

; 622  : 	
; 623  : 	TheCampaign.LoadCampaign(game_InstantAction, gUI_CampaignFile);

	push	OFFSET ?gUI_CampaignFile@@3PADA		; gUI_CampaignFile
	push	1
	mov	ecx, OFFSET ?TheCampaign@@3VCampaignClass@@A ; TheCampaign
	call	?LoadCampaign@CampaignClass@@QAEHW4FalconGameType@@PAD@Z ; CampaignClass::LoadCampaign

; 624  : 
; 625  :    instant_action::set_start_wave (InstantActionSettings.PilotLevel);

	mov	ecx, DWORD PTR ?InstantActionSettings@@3UUI_IA@@A+4
	push	ecx
	call	?set_start_wave@instant_action@@SAXH@Z	; instant_action::set_start_wave
	add	esp, 4

; 626  :    instant_action::create_player_flight ();

	call	?create_player_flight@instant_action@@SAXXZ ; instant_action::create_player_flight

; 627  : 
; 628  : 	PostMessage(gMainHandler->GetAppWnd(),FM_START_INSTANTACTION,0,0);

	push	0
	push	0
	push	1029					; 00000405H
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?GetAppWnd@C_Handler@@QAEPAUHWND__@@XZ	; C_Handler::GetAppWnd
	push	eax
	call	DWORD PTR __imp__PostMessageA@16
$LN22@InstantAct:

; 629  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?InstantActionFlyCB@@YAXJFPAVC_Base@@@Z ENDP		; InstantActionFlyCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\instant\instant.cpp
_TEXT	SEGMENT
_win$ = -12						; size = 4
_ctrl$ = -8						; size = 4
_ID$ = -4						; size = 4
?LoadInstantActionWindows@@YAXXZ PROC			; LoadInstantActionWindows

; 482  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 483  : 	long ID;
; 484  : 	C_Window *win;
; 485  : 	C_Button *ctrl;
; 486  : 
; 487  : 	if(IALoaded) return;

	cmp	DWORD PTR ?IALoaded@@3HA, 0		; IALoaded
	je	SHORT $LN8@LoadInstan
	jmp	$LN9@LoadInstan
$LN8@LoadInstan:

; 488  : 
; 489  : 	if( _LOAD_ART_RESOURCES_)

	cmp	DWORD PTR ?_LOAD_ART_RESOURCES_@@3JA, 0	; _LOAD_ART_RESOURCES_
	je	SHORT $LN7@LoadInstan

; 490  : 		gMainParser->LoadImageList("ia_res.lst");

	push	OFFSET ??_C@_0L@IEIHDOKC@ia_res?4lst?$AA@
	mov	ecx, DWORD PTR ?gMainParser@@3PAVC_Parser@@A ; gMainParser
	call	?LoadImageList@C_Parser@@QAEHPAD@Z	; C_Parser::LoadImageList

; 491  : 	else

	jmp	SHORT $LN6@LoadInstan
$LN7@LoadInstan:

; 492  : 		gMainParser->LoadImageList("ia_art.lst");

	push	OFFSET ??_C@_0L@MJMPJKJC@ia_art?4lst?$AA@
	mov	ecx, DWORD PTR ?gMainParser@@3PAVC_Parser@@A ; gMainParser
	call	?LoadImageList@C_Parser@@QAEHPAD@Z	; C_Parser::LoadImageList
$LN6@LoadInstan:

; 493  : 	gMainParser->LoadSoundList("ia_snd.lst");

	push	OFFSET ??_C@_0L@FEPJFIOF@ia_snd?4lst?$AA@
	mov	ecx, DWORD PTR ?gMainParser@@3PAVC_Parser@@A ; gMainParser
	call	?LoadSoundList@C_Parser@@QAEHPAD@Z	; C_Parser::LoadSoundList

; 494  : 	if(!gInstantBites)

	cmp	DWORD PTR ?gInstantBites@@3PAVC_SoundBite@@A, 0 ; gInstantBites
	jne	SHORT $LN5@LoadInstan

; 495  : 		gInstantBites=gMainParser->ParseSoundBite("art\\instant\\uidia.scf");

	push	OFFSET ??_C@_0BG@BOIDIHL@art?2instant?2uidia?4scf?$AA@
	mov	ecx, DWORD PTR ?gMainParser@@3PAVC_Parser@@A ; gMainParser
	call	?ParseSoundBite@C_Parser@@QAEPAVC_SoundBite@@PAD@Z ; C_Parser::ParseSoundBite
	mov	DWORD PTR ?gInstantBites@@3PAVC_SoundBite@@A, eax ; gInstantBites
$LN5@LoadInstan:

; 496  : 
; 497  : 	gMainParser->LoadWindowList("ia_scf.lst");	// Modified by M.N. - add art/art1024 by LoadWindowList

	push	OFFSET ??_C@_0L@HIOGJICO@ia_scf?4lst?$AA@
	mov	ecx, DWORD PTR ?gMainParser@@3PAVC_Parser@@A ; gMainParser
	call	?LoadWindowList@C_Parser@@QAEHPAD@Z	; C_Parser::LoadWindowList

; 498  : 
; 499  : 	ID=gMainParser->GetFirstWindowLoaded();

	mov	ecx, DWORD PTR ?gMainParser@@3PAVC_Parser@@A ; gMainParser
	call	?GetFirstWindowLoaded@C_Parser@@QAEJXZ	; C_Parser::GetFirstWindowLoaded
	mov	DWORD PTR _ID$[ebp], eax
$LN4@LoadInstan:

; 500  : 	while(ID)

	cmp	DWORD PTR _ID$[ebp], 0
	je	SHORT $LN3@LoadInstan

; 501  : 	{
; 502  : 		HookupIAControls(ID);

	mov	eax, DWORD PTR _ID$[ebp]
	push	eax
	call	?HookupIAControls@@YAXJ@Z		; HookupIAControls
	add	esp, 4

; 503  : 		ID=gMainParser->GetNextWindowLoaded();

	mov	ecx, DWORD PTR ?gMainParser@@3PAVC_Parser@@A ; gMainParser
	call	?GetNextWindowLoaded@C_Parser@@QAEJXZ	; C_Parser::GetNextWindowLoaded
	mov	DWORD PTR _ID$[ebp], eax

; 504  : 	}

	jmp	SHORT $LN4@LoadInstan
$LN3@LoadInstan:

; 505  : 
; 506  : 	SetSingle_Comms_Ctrls();

	call	?SetSingle_Comms_Ctrls@@YAXXZ		; SetSingle_Comms_Ctrls

; 507  : 	win=gMainHandler->FindWindow(IA_HS_WIN);

	push	10036					; 00002734H
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z ; C_Handler::FindWindowA
	mov	DWORD PTR _win$[ebp], eax

; 508  : 	if(win)

	cmp	DWORD PTR _win$[ebp], 0
	je	SHORT $LN2@LoadInstan

; 509  : 	{
; 510  : 		ctrl=(C_Button *)win->FindControl(CLOSE_WINDOW);

	push	80001					; 00013881H
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ctrl$[ebp], eax

; 511  : 		if(ctrl)

	cmp	DWORD PTR _ctrl$[ebp], 0
	je	SHORT $LN2@LoadInstan

; 512  : 			ctrl->SetCallback(InsertScoreCB);

	push	OFFSET ?InsertScoreCB@@YAXJFPAVC_Base@@@Z ; InsertScoreCB
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN2@LoadInstan:

; 513  : 	}
; 514  : 	SetupInstantAction();

	call	?SetupInstantAction@@YAXXZ		; SetupInstantAction

; 515  : 	IALoaded++;

	mov	ecx, DWORD PTR ?IALoaded@@3HA		; IALoaded
	add	ecx, 1
	mov	DWORD PTR ?IALoaded@@3HA, ecx		; IALoaded
$LN9@LoadInstan:

; 516  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?LoadInstantActionWindows@@YAXXZ ENDP			; LoadInstantActionWindows
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\instant\instant.cpp
_TEXT	SEGMENT
_Pilot$ = 8						; size = 8
_damage$ = 16						; size = 4
_fuel$ = 20						; size = 4
?CheckLanding@@YAXVVU_ID@@MM@Z PROC			; CheckLanding

; 472  : {

	push	ebp
	mov	ebp, esp

; 473  : 	if(Pilot == IAPlayerID)

	push	OFFSET ?IAPlayerID@@3VVU_ID@@A		; IAPlayerID
	lea	ecx, DWORD PTR _Pilot$[ebp]
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@CheckLandi

; 474  : 	{
; 475  : 		LandingBonus=50000;

	mov	DWORD PTR ?LandingBonus@@3JA, 50000	; LandingBonus, 0000c350H

; 476  : 		if(damage < 50.0f || fuel == 0.0f)

	movss	xmm0, DWORD PTR __real@42480000
	comiss	xmm0, DWORD PTR _damage$[ebp]
	ja	SHORT $LN1@CheckLandi
	movss	xmm0, DWORD PTR _fuel$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@CheckLandi
$LN1@CheckLandi:

; 477  : 			LandingBonus=150000;

	mov	DWORD PTR ?LandingBonus@@3JA, 150000	; LandingBonus, 000249f0H
$LN2@CheckLandi:

; 478  : 	}
; 479  : }

	pop	ebp
	ret	0
?CheckLanding@@YAXVVU_ID@@MM@Z ENDP			; CheckLanding
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\instant\instant.cpp
_TEXT	SEGMENT
_Pilot$ = 8						; size = 8
_damage$ = 16						; size = 4
_fuel$ = 20						; size = 4
?CheckEject@@YAXVVU_ID@@MM@Z PROC			; CheckEject

; 461  : {

	push	ebp
	mov	ebp, esp

; 462  : 	if(Pilot == IAPlayerID)

	push	OFFSET ?IAPlayerID@@3VVU_ID@@A		; IAPlayerID
	lea	ecx, DWORD PTR _Pilot$[ebp]
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@CheckEject

; 463  : 	{
; 464  : 		if(damage > 80.0f && fuel > 100.0f)

	movss	xmm0, DWORD PTR _damage$[ebp]
	comiss	xmm0, DWORD PTR __real@42a00000
	jbe	SHORT $LN2@CheckEject
	movss	xmm0, DWORD PTR _fuel$[ebp]
	comiss	xmm0, DWORD PTR __real@42c80000
	jbe	SHORT $LN2@CheckEject

; 465  : 			LivingBonus=-50000;

	mov	DWORD PTR ?LivingBonus@@3JA, -50000	; LivingBonus, ffff3cb0H

; 466  : 		else

	jmp	SHORT $LN1@CheckEject
$LN2@CheckEject:

; 467  : 			LivingBonus=50000;

	mov	DWORD PTR ?LivingBonus@@3JA, 50000	; LivingBonus, 0000c350H
$LN1@CheckEject:

; 468  : 	}
; 469  : }

	pop	ebp
	ret	0
?CheckEject@@YAXVVU_ID@@MM@Z ENDP			; CheckEject
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\instant\instant.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 8
_Victim$ = 16						; size = 8
___formal$ = 24						; size = 4
?AddIAVehicleKill@@YAXVVU_ID@@0PAUVehicleClassDataType@@@Z PROC ; AddIAVehicleKill

; 455  : { // Don't care... Leon does this

	push	ebp
	mov	ebp, esp

; 456  : 	if(Victim == IAPlayerID)

	push	OFFSET ?IAPlayerID@@3VVU_ID@@A		; IAPlayerID
	lea	ecx, DWORD PTR _Victim$[ebp]
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@AddIAVehic

; 457  : 		Penalty+=2000;

	mov	ecx, DWORD PTR ?Penalty@@3JA		; Penalty
	add	ecx, 2000				; 000007d0H
	mov	DWORD PTR ?Penalty@@3JA, ecx		; Penalty
$LN2@AddIAVehic:

; 458  : }

	pop	ebp
	ret	0
?AddIAVehicleKill@@YAXVVU_ID@@0PAUVehicleClassDataType@@@Z ENDP ; AddIAVehicleKill
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\instant\instant.cpp
_TEXT	SEGMENT
$T1 = -12						; size = 4
_prev$ = -8						; size = 4
_cur$ = -4						; size = 4
?RemoveObjectKillsList@@YAXXZ PROC			; RemoveObjectKillsList

; 441  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 442  : 	kill_list *cur,*prev;
; 443  : 
; 444  : 	cur=ObjectKills;

	mov	eax, DWORD PTR ?ObjectKills@@3PAUkill_list@@A ; ObjectKills
	mov	DWORD PTR _cur$[ebp], eax
$LN2@RemoveObje:

; 445  : 	while(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN1@RemoveObje

; 446  : 	{
; 447  : 		prev=cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _prev$[ebp], ecx

; 448  : 		cur=cur->next;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _cur$[ebp], eax

; 449  : 		delete prev;

	mov	ecx, DWORD PTR _prev$[ebp]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 450  : 	}

	jmp	SHORT $LN2@RemoveObje
$LN1@RemoveObje:

; 451  : 	ObjectKills=NULL;

	mov	DWORD PTR ?ObjectKills@@3PAUkill_list@@A, 0 ; ObjectKills

; 452  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveObjectKillsList@@YAXXZ ENDP			; RemoveObjectKillsList
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\instant\instant.cpp
_TEXT	SEGMENT
$T1 = -12						; size = 4
_prev$ = -8						; size = 4
_cur$ = -4						; size = 4
?RemoveAircraftKillsList@@YAXXZ PROC			; RemoveAircraftKillsList

; 427  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 428  : 	kill_list *cur,*prev;
; 429  : 
; 430  : 	cur=AircraftKills;

	mov	eax, DWORD PTR ?AircraftKills@@3PAUkill_list@@A ; AircraftKills
	mov	DWORD PTR _cur$[ebp], eax
$LN2@RemoveAirc:

; 431  : 	while(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN1@RemoveAirc

; 432  : 	{
; 433  : 		prev=cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _prev$[ebp], ecx

; 434  : 		cur=cur->next;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _cur$[ebp], eax

; 435  : 		delete prev;

	mov	ecx, DWORD PTR _prev$[ebp]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 436  : 	}

	jmp	SHORT $LN2@RemoveAirc
$LN1@RemoveAirc:

; 437  : 	AircraftKills=NULL;

	mov	DWORD PTR ?AircraftKills@@3PAUkill_list@@A, 0 ; AircraftKills

; 438  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAircraftKillsList@@YAXXZ ENDP			; RemoveAircraftKillsList
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\instant\instant.cpp
_TEXT	SEGMENT
$T1 = -12						; size = 4
_prev$ = -8						; size = 4
_cur$ = -4						; size = 4
?RemoveBonusList@@YAXXZ PROC				; RemoveBonusList

; 399  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 400  : 	kill_list *cur,*prev;
; 401  : 
; 402  : 	cur=BonusList;

	mov	eax, DWORD PTR ?BonusList@@3PAUkill_list@@A ; BonusList
	mov	DWORD PTR _cur$[ebp], eax
$LN2@RemoveBonu:

; 403  : 	while(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN1@RemoveBonu

; 404  : 	{
; 405  : 		prev=cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _prev$[ebp], ecx

; 406  : 		cur=cur->next;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _cur$[ebp], eax

; 407  : 		delete prev;

	mov	ecx, DWORD PTR _prev$[ebp]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 408  : 	}

	jmp	SHORT $LN2@RemoveBonu
$LN1@RemoveBonu:

; 409  : 	BonusList=NULL;

	mov	DWORD PTR ?BonusList@@3PAUkill_list@@A, 0 ; BonusList

; 410  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveBonusList@@YAXXZ ENDP				; RemoveBonusList
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\instant\instant.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 4
_newwp$ = -4						; size = 4
?score_player_ejected@@YAHXZ PROC			; score_player_ejected

; 377  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 378  : 	kill_list *newwp;
; 379  : 	
; 380  : 	newwp=new kill_list;

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR _newwp$[ebp], eax

; 381  : 	newwp->id = 0;

	mov	ecx, DWORD PTR _newwp$[ebp]
	mov	DWORD PTR [ecx], 0

; 382  : 	newwp->num = 0;

	mov	edx, DWORD PTR _newwp$[ebp]
	mov	DWORD PTR [edx+4], 0

; 383  : 	newwp->points = 0;

	mov	eax, DWORD PTR _newwp$[ebp]
	mov	DWORD PTR [eax+8], 0

; 384  : 	newwp->next = NULL;

	mov	ecx, DWORD PTR _newwp$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 385  : 
; 386  : 	if (BonusList)

	cmp	DWORD PTR ?BonusList@@3PAUkill_list@@A, 0 ; BonusList
	je	SHORT $LN2@score_play

; 387  : 	{
; 388  : 		BonusList->next = newwp;

	mov	edx, DWORD PTR ?BonusList@@3PAUkill_list@@A ; BonusList
	mov	eax, DWORD PTR _newwp$[ebp]
	mov	DWORD PTR [edx+12], eax

; 389  : 	}
; 390  : 	else

	jmp	SHORT $LN1@score_play
$LN2@score_play:

; 391  : 	{
; 392  : 		BonusList = newwp;

	mov	ecx, DWORD PTR _newwp$[ebp]
	mov	DWORD PTR ?BonusList@@3PAUkill_list@@A, ecx ; BonusList
$LN1@score_play:

; 393  : 	}
; 394  : 
; 395  : 	return 0;

	xor	eax, eax

; 396  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?score_player_ejected@@YAHXZ ENDP			; score_player_ejected
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\instant\instant.cpp
_TEXT	SEGMENT
$T1 = -20						; size = 4
_COST$ = -16						; size = 4
_newwp$ = -12						; size = 4
_cur$ = -8						; size = 4
_visID$ = -4						; size = 2
_ID$ = 8						; size = 4
?AddObjectToKillsList@@YAHH@Z PROC			; AddObjectToKillsList

; 335  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 336  : 	kill_list *cur,*newwp;
; 337  : 	int COST;
; 338  : 	short visID;
; 339  : 
; 340  : 	visID=Falcon4ClassTable[ID].visType[0];

	mov	eax, DWORD PTR _ID$[ebp]
	imul	eax, 81					; 00000051H
	add	eax, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	ecx, 2
	imul	ecx, 0
	mov	dx, WORD PTR [eax+ecx+60]
	mov	WORD PTR _visID$[ebp], dx

; 341  : 	COST=FindCost(visID);

	movsx	eax, WORD PTR _visID$[ebp]
	push	eax
	call	?FindCost@@YAHH@Z			; FindCost
	add	esp, 4
	mov	DWORD PTR _COST$[ebp], eax

; 342  : 
; 343  : 	cur=ObjectKills;

	mov	ecx, DWORD PTR ?ObjectKills@@3PAUkill_list@@A ; ObjectKills
	mov	DWORD PTR _cur$[ebp], ecx
$LN7@AddObjectT:

; 344  : 	while(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN6@AddObjectT

; 345  : 	{
; 346  : 		if(cur->id == ID)

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _ID$[ebp]
	jne	SHORT $LN5@AddObjectT

; 347  : 		{
; 348  : 			cur->num ++;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 1
	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [eax+4], edx

; 349  : 			cur->points+=COST;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, DWORD PTR _COST$[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [eax+8], edx

; 350  : 			return COST;

	mov	eax, DWORD PTR _COST$[ebp]
	jmp	$LN8@AddObjectT
$LN5@AddObjectT:

; 351  : 		}
; 352  : 		cur=cur->next;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _cur$[ebp], edx

; 353  : 	}

	jmp	SHORT $LN7@AddObjectT
$LN6@AddObjectT:

; 354  : 
; 355  : 	newwp=new kill_list;

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR _newwp$[ebp], eax

; 356  : 	newwp->id=ID;

	mov	ecx, DWORD PTR _newwp$[ebp]
	mov	edx, DWORD PTR _ID$[ebp]
	mov	DWORD PTR [ecx], edx

; 357  : 	newwp->num=1;

	mov	eax, DWORD PTR _newwp$[ebp]
	mov	DWORD PTR [eax+4], 1

; 358  : 	newwp->points=COST;

	mov	ecx, DWORD PTR _newwp$[ebp]
	mov	edx, DWORD PTR _COST$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 359  : 	newwp->next=NULL;

	mov	eax, DWORD PTR _newwp$[ebp]
	mov	DWORD PTR [eax+12], 0

; 360  : 
; 361  : 	if(ObjectKills== NULL)

	cmp	DWORD PTR ?ObjectKills@@3PAUkill_list@@A, 0 ; ObjectKills
	jne	SHORT $LN4@AddObjectT

; 362  : 	{
; 363  : 		ObjectKills=newwp;

	mov	ecx, DWORD PTR _newwp$[ebp]
	mov	DWORD PTR ?ObjectKills@@3PAUkill_list@@A, ecx ; ObjectKills

; 364  : 	}
; 365  : 	else

	jmp	SHORT $LN3@AddObjectT
$LN4@AddObjectT:

; 366  : 	{
; 367  : 		cur=ObjectKills;

	mov	edx, DWORD PTR ?ObjectKills@@3PAUkill_list@@A ; ObjectKills
	mov	DWORD PTR _cur$[ebp], edx
$LN2@AddObjectT:

; 368  : 		while(cur->next)

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@AddObjectT

; 369  : 			cur=cur->next;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _cur$[ebp], edx
	jmp	SHORT $LN2@AddObjectT
$LN1@AddObjectT:

; 370  : 		cur->next=newwp;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR _newwp$[ebp]
	mov	DWORD PTR [eax+12], ecx
$LN3@AddObjectT:

; 371  : 	}
; 372  : 
; 373  : 	return COST;

	mov	eax, DWORD PTR _COST$[ebp]
$LN8@AddObjectT:

; 374  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AddObjectToKillsList@@YAHH@Z ENDP			; AddObjectToKillsList
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\instant\instant.cpp
_TEXT	SEGMENT
$T1 = -20						; size = 4
_COST$ = -16						; size = 4
_newwp$ = -12						; size = 4
_cur$ = -8						; size = 4
_visID$ = -4						; size = 2
_ID$ = 8						; size = 4
?AddAircraftToKillsList@@YAHH@Z PROC			; AddAircraftToKillsList

; 293  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 294  : 	kill_list *cur,*newwp;
; 295  : 	int COST;
; 296  : 	short visID;
; 297  : 
; 298  : 	visID=Falcon4ClassTable[ID].visType[0];

	mov	eax, DWORD PTR _ID$[ebp]
	imul	eax, 81					; 00000051H
	add	eax, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	ecx, 2
	imul	ecx, 0
	mov	dx, WORD PTR [eax+ecx+60]
	mov	WORD PTR _visID$[ebp], dx

; 299  : 	COST=FindCost(visID);

	movsx	eax, WORD PTR _visID$[ebp]
	push	eax
	call	?FindCost@@YAHH@Z			; FindCost
	add	esp, 4
	mov	DWORD PTR _COST$[ebp], eax

; 300  : 
; 301  : 	cur=AircraftKills;

	mov	ecx, DWORD PTR ?AircraftKills@@3PAUkill_list@@A ; AircraftKills
	mov	DWORD PTR _cur$[ebp], ecx
$LN7@AddAircraf:

; 302  : 	while(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN6@AddAircraf

; 303  : 	{
; 304  : 		if(cur->id == ID)

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _ID$[ebp]
	jne	SHORT $LN5@AddAircraf

; 305  : 		{
; 306  : 			cur->num ++;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 1
	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [eax+4], edx

; 307  : 			cur->points+=COST;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, DWORD PTR _COST$[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [eax+8], edx

; 308  : 			return COST;

	mov	eax, DWORD PTR _COST$[ebp]
	jmp	$LN8@AddAircraf
$LN5@AddAircraf:

; 309  : 		}
; 310  : 		cur=cur->next;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _cur$[ebp], edx

; 311  : 	}

	jmp	SHORT $LN7@AddAircraf
$LN6@AddAircraf:

; 312  : 
; 313  : 	newwp=new kill_list;

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR _newwp$[ebp], eax

; 314  : 	newwp->id=ID;

	mov	ecx, DWORD PTR _newwp$[ebp]
	mov	edx, DWORD PTR _ID$[ebp]
	mov	DWORD PTR [ecx], edx

; 315  : 	newwp->num=1;

	mov	eax, DWORD PTR _newwp$[ebp]
	mov	DWORD PTR [eax+4], 1

; 316  : 	newwp->points=COST;

	mov	ecx, DWORD PTR _newwp$[ebp]
	mov	edx, DWORD PTR _COST$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 317  : 	newwp->next=NULL;

	mov	eax, DWORD PTR _newwp$[ebp]
	mov	DWORD PTR [eax+12], 0

; 318  : 
; 319  : 	if(AircraftKills== NULL)

	cmp	DWORD PTR ?AircraftKills@@3PAUkill_list@@A, 0 ; AircraftKills
	jne	SHORT $LN4@AddAircraf

; 320  : 	{
; 321  : 		AircraftKills=newwp;

	mov	ecx, DWORD PTR _newwp$[ebp]
	mov	DWORD PTR ?AircraftKills@@3PAUkill_list@@A, ecx ; AircraftKills

; 322  : 	}
; 323  : 	else

	jmp	SHORT $LN3@AddAircraf
$LN4@AddAircraf:

; 324  : 	{
; 325  : 		cur=AircraftKills;

	mov	edx, DWORD PTR ?AircraftKills@@3PAUkill_list@@A ; AircraftKills
	mov	DWORD PTR _cur$[ebp], edx
$LN2@AddAircraf:

; 326  : 		while(cur->next)

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@AddAircraf

; 327  : 			cur=cur->next;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _cur$[ebp], edx
	jmp	SHORT $LN2@AddAircraf
$LN1@AddAircraf:

; 328  : 		cur->next=newwp;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR _newwp$[ebp]
	mov	DWORD PTR [eax+12], ecx
$LN3@AddAircraf:

; 329  : 	}
; 330  : 
; 331  : 	return COST;

	mov	eax, DWORD PTR _COST$[ebp]
$LN8@AddAircraf:

; 332  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AddAircraftToKillsList@@YAHH@Z ENDP			; AddAircraftToKillsList
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\instant\instant.cpp
_TEXT	SEGMENT
$T1 = -20						; size = 4
_COST$ = -16						; size = 4
_newwp$ = -12						; size = 4
_cur$ = -8						; size = 4
_visID$ = -4						; size = 2
_ID$ = 8						; size = 4
?AddWeaponToUsageList@@YAHH@Z PROC			; AddWeaponToUsageList

; 250  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 251  : 	kill_list *cur,*newwp;
; 252  : 	int COST;
; 253  : 	short visID;
; 254  : 
; 255  : 	visID=Falcon4ClassTable[ID].visType[0];

	mov	eax, DWORD PTR _ID$[ebp]
	imul	eax, 81					; 00000051H
	add	eax, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	ecx, 2
	imul	ecx, 0
	mov	dx, WORD PTR [eax+ecx+60]
	mov	WORD PTR _visID$[ebp], dx

; 256  : 	COST=FindCost(visID);

	movsx	eax, WORD PTR _visID$[ebp]
	push	eax
	call	?FindCost@@YAHH@Z			; FindCost
	add	esp, 4
	mov	DWORD PTR _COST$[ebp], eax

; 257  : 	COST/=4;	// ECTS HACK

	mov	eax, DWORD PTR _COST$[ebp]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	mov	DWORD PTR _COST$[ebp], eax

; 258  : 
; 259  : 	cur=WeaponUsage;

	mov	ecx, DWORD PTR ?WeaponUsage@@3PAUkill_list@@A ; WeaponUsage
	mov	DWORD PTR _cur$[ebp], ecx
$LN7@AddWeaponT:

; 260  : 	while(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN6@AddWeaponT

; 261  : 	{
; 262  : 		if(cur->id == ID)

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _ID$[ebp]
	jne	SHORT $LN5@AddWeaponT

; 263  : 		{
; 264  : 			cur->num ++;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 1
	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [eax+4], edx

; 265  : 			cur->points-=COST;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR _COST$[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [eax+8], edx

; 266  : 			return -COST;

	mov	eax, DWORD PTR _COST$[ebp]
	neg	eax
	jmp	$LN8@AddWeaponT
$LN5@AddWeaponT:

; 267  : 		}
; 268  : 		cur=cur->next;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _cur$[ebp], edx

; 269  : 	}

	jmp	SHORT $LN7@AddWeaponT
$LN6@AddWeaponT:

; 270  : 
; 271  : 	newwp=new kill_list;

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR _newwp$[ebp], eax

; 272  : 	newwp->id=ID;

	mov	ecx, DWORD PTR _newwp$[ebp]
	mov	edx, DWORD PTR _ID$[ebp]
	mov	DWORD PTR [ecx], edx

; 273  : 	newwp->num=1;

	mov	eax, DWORD PTR _newwp$[ebp]
	mov	DWORD PTR [eax+4], 1

; 274  : 	newwp->points=-COST;

	mov	ecx, DWORD PTR _COST$[ebp]
	neg	ecx
	mov	edx, DWORD PTR _newwp$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 275  : 	newwp->next=NULL;

	mov	eax, DWORD PTR _newwp$[ebp]
	mov	DWORD PTR [eax+12], 0

; 276  : 
; 277  : 	if(WeaponUsage == NULL)

	cmp	DWORD PTR ?WeaponUsage@@3PAUkill_list@@A, 0 ; WeaponUsage
	jne	SHORT $LN4@AddWeaponT

; 278  : 	{
; 279  : 		WeaponUsage=newwp;

	mov	ecx, DWORD PTR _newwp$[ebp]
	mov	DWORD PTR ?WeaponUsage@@3PAUkill_list@@A, ecx ; WeaponUsage

; 280  : 	}
; 281  : 	else

	jmp	SHORT $LN3@AddWeaponT
$LN4@AddWeaponT:

; 282  : 	{
; 283  : 		cur=WeaponUsage;

	mov	edx, DWORD PTR ?WeaponUsage@@3PAUkill_list@@A ; WeaponUsage
	mov	DWORD PTR _cur$[ebp], edx
$LN2@AddWeaponT:

; 284  : 		while(cur->next)

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@AddWeaponT

; 285  : 			cur=cur->next;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _cur$[ebp], edx
	jmp	SHORT $LN2@AddWeaponT
$LN1@AddWeaponT:

; 286  : 		cur->next=newwp;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR _newwp$[ebp]
	mov	DWORD PTR [eax+12], ecx
$LN3@AddWeaponT:

; 287  : 	}
; 288  : 
; 289  : 	return -COST;

	mov	eax, DWORD PTR _COST$[ebp]
	neg	eax
$LN8@AddWeaponT:

; 290  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AddWeaponToUsageList@@YAHH@Z ENDP			; AddWeaponToUsageList
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\instant\instant.cpp
_TEXT	SEGMENT
_i$ = -4						; size = 4
_ID$ = 8						; size = 4
?FindCost@@YAHH@Z PROC					; FindCost

; 236  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 237  : 	int i;
; 238  : 
; 239  : 	i=0;

	mov	DWORD PTR _i$[ebp], 0
$LN3@FindCost:

; 240  : 	while(VisualIDCost[i][0] != 0)

	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR ?VisualIDCost@@3PAY01HA[eax+ecx*8], 0
	je	SHORT $LN2@FindCost

; 241  : 	{
; 242  : 		if(MapVisId(VisualIDCost[i][0]) == ID)

	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?VisualIDCost@@3PAY01HA[edx+eax*8]
	push	ecx
	call	?MapVisId@@YAKK@Z			; MapVisId
	add	esp, 4
	cmp	eax, DWORD PTR _ID$[ebp]
	jne	SHORT $LN1@FindCost

; 243  : 			return(VisualIDCost[i][1]);

	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR ?VisualIDCost@@3PAY01HA[edx+eax*8]
	jmp	SHORT $LN4@FindCost
$LN1@FindCost:

; 244  : 		i++;

	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx

; 245  : 	}

	jmp	SHORT $LN3@FindCost
$LN2@FindCost:

; 246  : 	return(500);

	mov	eax, 500				; 000001f4H
$LN4@FindCost:

; 247  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FindCost@@YAHH@Z ENDP					; FindCost
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\instant\instant.cpp
_TEXT	SEGMENT
_size$ = -12						; size = 4
_theKey$ = -8						; size = 4
_retval$ = -4						; size = 4
?SaveHighScores@@YAXXZ PROC				; SaveHighScores

; 173  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 174  : #if _USE_REGISTRY_
; 175  : 	DWORD size;
; 176  : 	HKEY theKey;
; 177  : 	long retval;
; 178  : #else
; 179  : 	HANDLE fp;
; 180  : 	DWORD br;
; 181  : #endif
; 182  : 
; 183  : 	EncryptBuffer(0x38,(uchar*)&Scores,sizeof(HighScoreList));

	push	436					; 000001b4H
	push	OFFSET ?Scores@@3UHighScoreList@@A	; Scores
	push	56					; 00000038H
	call	?EncryptBuffer@@YAXEPAEJ@Z		; EncryptBuffer
	add	esp, 12					; 0000000cH

; 184  : 
; 185  : #if _USE_REGISTRY_
; 186  : 	size = sizeof (HighScoreList);

	mov	DWORD PTR _size$[ebp], 436		; 000001b4H

; 187  : 	retval = RegOpenKeyEx(HKEY_LOCAL_MACHINE, FALCON_REGISTRY_KEY, 0, KEY_ALL_ACCESS, &theKey);

	lea	eax, DWORD PTR _theKey$[ebp]
	push	eax
	push	983103					; 000f003fH
	push	0
	push	OFFSET ??_C@_0BP@KOIEKLOO@Software?2MicroProse?2Falcon?24?40?$AA@
	push	-2147483646				; 80000002H
	call	DWORD PTR __imp__RegOpenKeyExA@20
	mov	DWORD PTR _retval$[ebp], eax

; 188  : 	if(retval == ERROR_SUCCESS)

	cmp	DWORD PTR _retval$[ebp], 0
	jne	SHORT $LN1@SaveHighSc

; 189  : 		retval = RegSetValueEx  (theKey, "initData", 0, REG_BINARY, (LPBYTE)&Scores, size);	

	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	push	OFFSET ?Scores@@3UHighScoreList@@A	; Scores
	push	3
	push	0
	push	OFFSET ??_C@_08KDDNNMED@initData?$AA@
	mov	edx, DWORD PTR _theKey$[ebp]
	push	edx
	call	DWORD PTR __imp__RegSetValueExA@24
	mov	DWORD PTR _retval$[ebp], eax
$LN1@SaveHighSc:

; 190  : 	RegCloseKey(theKey);

	mov	eax, DWORD PTR _theKey$[ebp]
	push	eax
	call	DWORD PTR __imp__RegCloseKey@4

; 191  : #else
; 192  : 
; 193  : 	fp=CreateFile("highscore.bin",GENERIC_WRITE,FILE_SHARE_WRITE,NULL,CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL);
; 194  : 	if(fp == INVALID_HANDLE_VALUE)
; 195  : 		return;
; 196  : 
; 197  : 	WriteFile(fp,&Scores,sizeof(HighScoreList),&br,NULL);
; 198  : 	CloseHandle(fp);
; 199  : #endif
; 200  : 	DecryptBuffer(0x38,(uchar*)&Scores,sizeof(HighScoreList));

	push	436					; 000001b4H
	push	OFFSET ?Scores@@3UHighScoreList@@A	; Scores
	push	56					; 00000038H
	call	?DecryptBuffer@@YAXEPAEJ@Z		; DecryptBuffer
	add	esp, 12					; 0000000cH

; 201  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SaveHighScores@@YAXXZ ENDP				; SaveHighScores
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\instant\instant.cpp
_TEXT	SEGMENT
_type$ = -16						; size = 4
_size$ = -12						; size = 4
_retval$ = -8						; size = 4
_theKey$ = -4						; size = 4
?GetHighScores@@YAXXZ PROC				; GetHighScores

; 136  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 137  : #if _USE_REGISTRY_
; 138  : 	DWORD type, size;
; 139  : 	HKEY theKey;
; 140  : 	long retval;
; 141  : #else
; 142  : 	HANDLE fp;
; 143  : 	DWORD br;
; 144  : #endif
; 145  : 
; 146  : #if _USE_REGISTRY_
; 147  : 	size = sizeof (HighScoreList);

	mov	DWORD PTR _size$[ebp], 436		; 000001b4H

; 148  : 	retval = RegOpenKeyEx(HKEY_LOCAL_MACHINE, FALCON_REGISTRY_KEY, 0, KEY_ALL_ACCESS, &theKey);

	lea	eax, DWORD PTR _theKey$[ebp]
	push	eax
	push	983103					; 000f003fH
	push	0
	push	OFFSET ??_C@_0BP@KOIEKLOO@Software?2MicroProse?2Falcon?24?40?$AA@
	push	-2147483646				; 80000002H
	call	DWORD PTR __imp__RegOpenKeyExA@20
	mov	DWORD PTR _retval$[ebp], eax

; 149  : 	retval = RegQueryValueEx(theKey, "initData", 0, &type, (LPBYTE)&Scores, &size);

	lea	ecx, DWORD PTR _size$[ebp]
	push	ecx
	push	OFFSET ?Scores@@3UHighScoreList@@A	; Scores
	lea	edx, DWORD PTR _type$[ebp]
	push	edx
	push	0
	push	OFFSET ??_C@_08KDDNNMED@initData?$AA@
	mov	eax, DWORD PTR _theKey$[ebp]
	push	eax
	call	DWORD PTR __imp__RegQueryValueExA@24
	mov	DWORD PTR _retval$[ebp], eax

; 150  : 	RegCloseKey(theKey);

	mov	ecx, DWORD PTR _theKey$[ebp]
	push	ecx
	call	DWORD PTR __imp__RegCloseKey@4

; 151  : 	if (retval != ERROR_SUCCESS)

	cmp	DWORD PTR _retval$[ebp], 0
	je	SHORT $LN2@GetHighSco

; 152  : 	{
; 153  : //		ShiAssert(strcmp("Failed Reg Load,I would Clear Here","But Not this time") == 0);
; 154  : //		memset(&Scores[0],0,size);
; 155  : 		return;

	jmp	SHORT $LN3@GetHighSco
$LN2@GetHighSco:

; 156  : 	}
; 157  : #else
; 158  : 
; 159  : 	fp=CreateFile("highscore.bin",GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);
; 160  : 	if(fp == INVALID_HANDLE_VALUE)
; 161  : 		return;
; 162  : 
; 163  : 	ReadFile(fp,&Scores,sizeof(HighScoreList),&br,NULL);
; 164  : 	CloseHandle(fp);
; 165  : 
; 166  : #endif
; 167  : 	DecryptBuffer(0x38,(uchar*)&Scores,sizeof(HighScoreList));

	push	436					; 000001b4H
	push	OFFSET ?Scores@@3UHighScoreList@@A	; Scores
	push	56					; 00000038H
	call	?DecryptBuffer@@YAXEPAEJ@Z		; DecryptBuffer
	add	esp, 12					; 0000000cH

; 168  : 	if(Scores.CheckSum) // Someone tampered with data... reset it

	cmp	DWORD PTR ?Scores@@3UHighScoreList@@A+432, 0
	je	SHORT $LN3@GetHighSco

; 169  : 		memset(&Scores,0,sizeof(HighScoreList));

	push	436					; 000001b4H
	push	0
	push	OFFSET ?Scores@@3UHighScoreList@@A	; Scores
	call	_memset
	add	esp, 12					; 0000000cH
$LN3@GetHighSco:

; 170  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetHighScores@@YAXXZ ENDP				; GetHighScores
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\instant\instant.cpp
_TEXT	SEGMENT
_comma$ = -56						; size = 4
$T1 = -52						; size = 4
_len$ = -48						; size = 4
_k$ = -44						; size = 4
_i$ = -40						; size = 4
_j$ = -36						; size = 4
_newbuf$ = -32						; size = 25
__$ArrayPad$ = -4					; size = 4
_buf$ = 8						; size = 4
?AddCommas@@YAPADPAD@Z PROC				; AddCommas

; 105  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 106  : 	int i,j,k,len;
; 107  : 	_TCHAR newbuf[25];
; 108  : 	_TCHAR *comma;
; 109  : 
; 110  : 	comma=gStringMgr->GetString(TXT_COMMA_PLACE);

	push	399					; 0000018fH
	mov	ecx, DWORD PTR ?gStringMgr@@3PAVC_String@@A ; gStringMgr
	call	?GetString@C_String@@QAEPADJ@Z		; C_String::GetString
	mov	DWORD PTR _comma$[ebp], eax

; 111  : 	if(!comma)

	cmp	DWORD PTR _comma$[ebp], 0
	jne	SHORT $LN5@AddCommas

; 112  : 		return(buf);

	mov	eax, DWORD PTR _buf$[ebp]
	jmp	$LN7@AddCommas
$LN5@AddCommas:

; 113  : 	j=0;

	mov	DWORD PTR _j$[ebp], 0

; 114  : 	k=0;

	mov	DWORD PTR _k$[ebp], 0

; 115  : 	len=_tcsclen(buf);

	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	__tcsclen
	add	esp, 4
	mov	DWORD PTR _len$[ebp], eax

; 116  : 	i=len;

	mov	ecx, DWORD PTR _len$[ebp]
	mov	DWORD PTR _i$[ebp], ecx

; 117  : 	if(buf[0] == '-')

	mov	edx, 1
	imul	edx, 0
	mov	eax, DWORD PTR _buf$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 45					; 0000002dH
	jne	SHORT $LN3@AddCommas

; 118  : 	{
; 119  : 		i--;

	mov	edx, DWORD PTR _i$[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$[ebp], edx

; 120  : 		len--;

	mov	eax, DWORD PTR _len$[ebp]
	sub	eax, 1
	mov	DWORD PTR _len$[ebp], eax

; 121  : 		newbuf[j++]=buf[k++];

	mov	ecx, DWORD PTR _buf$[ebp]
	add	ecx, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	mov	al, BYTE PTR [ecx]
	mov	BYTE PTR _newbuf$[ebp+edx], al
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
	mov	edx, DWORD PTR _k$[ebp]
	add	edx, 1
	mov	DWORD PTR _k$[ebp], edx
$LN3@AddCommas:

; 122  : 	}
; 123  : 	while(i)

	cmp	DWORD PTR _i$[ebp], 0
	je	SHORT $LN2@AddCommas

; 124  : 	{
; 125  : 		if((i % 3) == 0 && i > 1 && i < len)

	mov	eax, DWORD PTR _i$[ebp]
	cdq
	mov	ecx, 3
	idiv	ecx
	test	edx, edx
	jne	SHORT $LN1@AddCommas
	cmp	DWORD PTR _i$[ebp], 1
	jle	SHORT $LN1@AddCommas
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _len$[ebp]
	jge	SHORT $LN1@AddCommas

; 126  : 			newbuf[j++]=comma[0];

	mov	eax, 1
	imul	eax, 0
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _comma$[ebp]
	mov	al, BYTE PTR [edx+eax]
	mov	BYTE PTR _newbuf$[ebp+ecx], al
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$LN1@AddCommas:

; 127  : 		newbuf[j++]=buf[k++];

	mov	edx, DWORD PTR _buf$[ebp]
	add	edx, DWORD PTR _k$[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	mov	cl, BYTE PTR [edx]
	mov	BYTE PTR _newbuf$[ebp+eax], cl
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax

; 128  : 		i--;

	mov	ecx, DWORD PTR _i$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx

; 129  : 	}

	jmp	SHORT $LN3@AddCommas
$LN2@AddCommas:

; 130  : 	newbuf[j++]=0;

	mov	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
	cmp	DWORD PTR $T1[ebp], 25			; 00000019H
	jae	SHORT $LN8@AddCommas
	jmp	SHORT $LN9@AddCommas
$LN8@AddCommas:
	call	___report_rangecheckfailure
$LN9@AddCommas:
	mov	ecx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _newbuf$[ebp+ecx], 0

; 131  : 	_tcscpy(buf,newbuf);

	lea	edx, DWORD PTR _newbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 132  : 	return(buf);

	mov	eax, DWORD PTR _buf$[ebp]
$LN7@AddCommas:

; 133  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?AddCommas@@YAPADPAD@Z ENDP				; AddCommas
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\instant\instant.cpp
_TEXT	SEGMENT
_ID$ = 8						; size = 4
_hittype$ = 12						; size = 2
_control$ = 16						; size = 4
?OpenIAMunitionsCB@@YAXJFPAVC_Base@@@Z PROC		; OpenIAMunitionsCB

; 1673 : {

	push	ebp
	mov	ebp, esp

; 1674 : 	if(hittype != C_TYPE_LMOUSEUP)

	movsx	eax, WORD PTR _hittype$[ebp]
	cmp	eax, 52					; 00000034H
	je	SHORT $LN2@OpenIAMuni

; 1675 : 		return;

	jmp	SHORT $LN3@OpenIAMuni
$LN2@OpenIAMuni:

; 1676 : 
; 1677 : 	if (!TheCampaign.IsLoaded ())

	mov	ecx, OFFSET ?TheCampaign@@3VCampaignClass@@A ; TheCampaign
	call	?IsLoaded@CampaignClass@@QAEHXZ		; CampaignClass::IsLoaded
	test	eax, eax
	jne	SHORT $LN1@OpenIAMuni

; 1678 : 	{
; 1679 : 		// Load a campaign here
; 1680 : 		strcpy(gUI_CampaignFile,"Instant");

	push	OFFSET ??_C@_07HMOCDNDG@Instant?$AA@
	push	OFFSET ?gUI_CampaignFile@@3PADA		; gUI_CampaignFile
	call	_strcpy
	add	esp, 8

; 1681 : 
; 1682 : 		TheCampaign.SetOnlineStatus( 0 );

	push	0
	mov	ecx, OFFSET ?TheCampaign@@3VCampaignClass@@A ; TheCampaign
	call	?SetOnlineStatus@CampaignClass@@QAEXH@Z	; CampaignClass::SetOnlineStatus

; 1683 : 		TheCampaign.LoadCampaign(game_InstantAction, gUI_CampaignFile);

	push	OFFSET ?gUI_CampaignFile@@3PADA		; gUI_CampaignFile
	push	1
	mov	ecx, OFFSET ?TheCampaign@@3VCampaignClass@@A ; TheCampaign
	call	?LoadCampaign@CampaignClass@@QAEHW4FalconGameType@@PAD@Z ; CampaignClass::LoadCampaign

; 1684 : 
; 1685 : 		instant_action::create_player_flight ();

	call	?create_player_flight@instant_action@@SAXXZ ; instant_action::create_player_flight
$LN1@OpenIAMuni:

; 1686 : 	}
; 1687 : 
; 1688 : 	OpenMunitionsWindowCB (ID, hittype, control);

	mov	ecx, DWORD PTR _control$[ebp]
	push	ecx
	movzx	edx, WORD PTR _hittype$[ebp]
	push	edx
	mov	eax, DWORD PTR _ID$[ebp]
	push	eax
	call	?OpenMunitionsWindowCB@@YAXJFPAVC_Base@@@Z ; OpenMunitionsWindowCB
	add	esp, 12					; 0000000cH
$LN3@OpenIAMuni:

; 1689 : }

	pop	ebp
	ret	0
?OpenIAMunitionsCB@@YAXJFPAVC_Base@@@Z ENDP		; OpenIAMunitionsCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\instant\instant.cpp
_TEXT	SEGMENT
_ebox$ = -64						; size = 4
_idx$ = -60						; size = 4
_j$ = -56						; size = 4
_txt$ = -52						; size = 4
_win$ = -48						; size = 4
_i$ = -44						; size = 4
_buf$ = -40						; size = 33
__$ArrayPad$ = -4					; size = 4
___formal$ = 8						; size = 4
_hittype$ = 12						; size = 2
___formal$ = 16						; size = 4
?InsertScoreCB@@YAXJFPAVC_Base@@@Z PROC			; InsertScoreCB

; 632  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 633  : 	C_Window *win;
; 634  : 	int i,j,idx;
; 635  : 	C_EditBox *ebox;
; 636  : 	C_Text *txt;
; 637  : 	_TCHAR buf[MAX_NAME_LENGTH+1];
; 638  : 
; 639  : 	if(hittype != C_TYPE_LMOUSEUP)

	movsx	eax, WORD PTR _hittype$[ebp]
	cmp	eax, 52					; 00000034H
	je	SHORT $LN23@InsertScor

; 640  : 		return;

	jmp	$LN24@InsertScor
$LN23@InsertScor:

; 641  : 
; 642  : 	i=0;

	mov	DWORD PTR _i$[ebp], 0
$LN22@InsertScor:

; 643  : 	while(i < MAX_SCORES && TotalScore <= Scores.Scores[i].Score && Scores.Scores[i].Name[0] != 0)

	cmp	DWORD PTR _i$[ebp], 12			; 0000000cH
	jge	SHORT $LN21@InsertScor
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 36					; 00000024H
	mov	edx, DWORD PTR ?TotalScore@@3JA		; TotalScore
	cmp	edx, DWORD PTR ?Scores@@3UHighScoreList@@A[ecx+32]
	jg	SHORT $LN21@InsertScor
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 36					; 00000024H
	mov	ecx, 1
	imul	ecx, 0
	movsx	edx, BYTE PTR ?Scores@@3UHighScoreList@@A[eax+ecx]
	test	edx, edx
	je	SHORT $LN21@InsertScor

; 644  : 		i++;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN22@InsertScor
$LN21@InsertScor:

; 645  : 
; 646  : 	idx=MAX_SCORES;

	mov	DWORD PTR _idx$[ebp], 12		; 0000000cH

; 647  : 	if(i < MAX_SCORES)

	cmp	DWORD PTR _i$[ebp], 12			; 0000000cH
	jge	$LN20@InsertScor

; 648  : 	{
; 649  : 		for(j=MAX_SCORES-2;j>=i;j--)

	mov	DWORD PTR _j$[ebp], 10			; 0000000aH
	jmp	SHORT $LN19@InsertScor
$LN18@InsertScor:
	mov	ecx, DWORD PTR _j$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$LN19@InsertScor:
	mov	edx, DWORD PTR _j$[ebp]
	cmp	edx, DWORD PTR _i$[ebp]
	jl	SHORT $LN17@InsertScor

; 650  : 		{
; 651  : 			memset(Scores.Scores[j+1].Name,0,sizeof(_TCHAR)*MAX_NAME_LENGTH);

	push	32					; 00000020H
	push	0
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	imul	eax, 36					; 00000024H
	add	eax, OFFSET ?Scores@@3UHighScoreList@@A	; Scores
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 652  : 			_tcscpy(Scores.Scores[j+1].Name,Scores.Scores[j].Name);

	mov	ecx, DWORD PTR _j$[ebp]
	imul	ecx, 36					; 00000024H
	add	ecx, OFFSET ?Scores@@3UHighScoreList@@A	; Scores
	push	ecx
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	imul	edx, 36					; 00000024H
	add	edx, OFFSET ?Scores@@3UHighScoreList@@A	; Scores
	push	edx
	call	_strcpy
	add	esp, 8

; 653  : 			Scores.Scores[j+1].Score=Scores.Scores[j].Score;

	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, 36					; 00000024H
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	imul	ecx, 36					; 00000024H
	mov	edx, DWORD PTR ?Scores@@3UHighScoreList@@A[eax+32]
	mov	DWORD PTR ?Scores@@3UHighScoreList@@A[ecx+32], edx

; 654  : 		}

	jmp	SHORT $LN18@InsertScor
$LN17@InsertScor:

; 655  : 		idx=i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _idx$[ebp], eax

; 656  : 		memset(Scores.Scores[i].Name,0,sizeof(_TCHAR)*MAX_NAME_LENGTH);

	push	32					; 00000020H
	push	0
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 36					; 00000024H
	add	ecx, OFFSET ?Scores@@3UHighScoreList@@A	; Scores
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 657  : 		Scores.Scores[i].Name[0]=' ';

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 36					; 00000024H
	mov	eax, 1
	imul	eax, 0
	mov	BYTE PTR ?Scores@@3UHighScoreList@@A[edx+eax], 32 ; 00000020H

; 658  : 		Scores.Scores[i].Score=TotalScore;

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 36					; 00000024H
	mov	edx, DWORD PTR ?TotalScore@@3JA		; TotalScore
	mov	DWORD PTR ?Scores@@3UHighScoreList@@A[ecx+32], edx

; 659  : 
; 660  : 		ebox=NULL;

	mov	DWORD PTR _ebox$[ebp], 0

; 661  : 		win=gMainHandler->FindWindow(IA_HS_WIN);

	push	10036					; 00002734H
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z ; C_Handler::FindWindowA
	mov	DWORD PTR _win$[ebp], eax

; 662  : 		if(win)

	cmp	DWORD PTR _win$[ebp], 0
	je	SHORT $LN16@InsertScor

; 663  : 		{
; 664  : 			ebox=(C_EditBox *)win->FindControl(IA_HS_NAME_EDIT);

	push	10042					; 0000273aH
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ebox$[ebp], eax

; 665  : 			win->SetControl(0);

	push	0
	mov	ecx, DWORD PTR _win$[ebp]
	call	?SetControl@C_Window@@QAEXJ@Z		; C_Window::SetControl

; 666  : 			gMainHandler->DisableWindowGroup(win->GetGroup());

	mov	ecx, DWORD PTR _win$[ebp]
	call	?GetGroup@C_Window@@QAEJXZ		; C_Window::GetGroup
	push	eax
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?DisableWindowGroup@C_Handler@@QAEXJ@Z	; C_Handler::DisableWindowGroup
$LN16@InsertScor:

; 667  : 		}
; 668  : 		if(ebox)

	cmp	DWORD PTR _ebox$[ebp], 0
	je	SHORT $LN15@InsertScor

; 669  : 		{
; 670  : 			_tcsncpy(Scores.Scores[i].Name,ebox->GetText(),MAX_NAME_LENGTH);

	push	32					; 00000020H
	mov	ecx, DWORD PTR _ebox$[ebp]
	call	?GetText@C_EditBox@@QAEPADXZ		; C_EditBox::GetText
	push	eax
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 36					; 00000024H
	add	eax, OFFSET ?Scores@@3UHighScoreList@@A	; Scores
	push	eax
	call	__tcsncpy
	add	esp, 12					; 0000000cH

; 671  : 			if(!Scores.Scores[i].Name[0])

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 36					; 00000024H
	mov	edx, 1
	imul	edx, 0
	movsx	eax, BYTE PTR ?Scores@@3UHighScoreList@@A[ecx+edx]
	test	eax, eax
	jne	SHORT $LN14@InsertScor

; 672  : 			{
; 673  : 				Scores.Scores[i].Name[0]=' ';

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 36					; 00000024H
	mov	edx, 1
	imul	edx, 0
	mov	BYTE PTR ?Scores@@3UHighScoreList@@A[ecx+edx], 32 ; 00000020H

; 674  : 				Scores.Scores[i].Name[1]=0;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 36					; 00000024H
	mov	ecx, 1
	shl	ecx, 0
	mov	BYTE PTR ?Scores@@3UHighScoreList@@A[eax+ecx], 0
$LN14@InsertScor:

; 675  : 			}
; 676  : 		}
; 677  : 		else

	jmp	SHORT $LN13@InsertScor
$LN15@InsertScor:

; 678  : 		{
; 679  : 			Scores.Scores[i].Name[0]=' ';

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 36					; 00000024H
	mov	eax, 1
	imul	eax, 0
	mov	BYTE PTR ?Scores@@3UHighScoreList@@A[edx+eax], 32 ; 00000020H

; 680  : 			Scores.Scores[i].Name[1]=0;

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 36					; 00000024H
	mov	edx, 1
	shl	edx, 0
	mov	BYTE PTR ?Scores@@3UHighScoreList@@A[ecx+edx], 0
$LN13@InsertScor:

; 681  : 		}
; 682  : 
; 683  : 		win=gMainHandler->FindWindow(IA_SH_WIN);

	push	10002					; 00002712H
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z ; C_Handler::FindWindowA
	mov	DWORD PTR _win$[ebp], eax

; 684  : 		if(win)

	cmp	DWORD PTR _win$[ebp], 0
	je	$LN12@InsertScor

; 685  : 		{
; 686  : 			for(i=0;i<MAX_SCORES;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN11@InsertScor
$LN10@InsertScor:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN11@InsertScor:
	cmp	DWORD PTR _i$[ebp], 12			; 0000000cH
	jge	$LN12@InsertScor

; 687  : 			{
; 688  : 				if(Scores.Scores[i].Name[0] != 0)

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 36					; 00000024H
	mov	edx, 1
	imul	edx, 0
	movsx	eax, BYTE PTR ?Scores@@3UHighScoreList@@A[ecx+edx]
	test	eax, eax
	je	$LN8@InsertScor

; 689  : 				{
; 690  : 					// Set Name
; 691  : 					txt=(C_Text *)win->FindControl(TEXT_1+i*2);

	mov	ecx, DWORD PTR _i$[ebp]
	lea	edx, DWORD PTR [ecx+ecx+99800]
	push	edx
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _txt$[ebp], eax

; 692  : 					if(txt)

	cmp	DWORD PTR _txt$[ebp], 0
	je	SHORT $LN7@InsertScor

; 693  : 					{
; 694  : 						txt->SetText(Scores.Scores[i].Name);

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 36					; 00000024H
	add	eax, OFFSET ?Scores@@3UHighScoreList@@A	; Scores
	push	eax
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+256]
	call	eax

; 695  : 						if(i == idx)

	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _idx$[ebp]
	jne	SHORT $LN6@InsertScor

; 696  : 							txt->SetFGColor(0x00ff00);

	push	65280					; 0000ff00H
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetFGColor@C_Text@@QAEXK@Z		; C_Text::SetFGColor

; 697  : 						else

	jmp	SHORT $LN7@InsertScor
$LN6@InsertScor:

; 698  : 							txt->SetFGColor(0xffffff);

	push	16777215				; 00ffffffH
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetFGColor@C_Text@@QAEXK@Z		; C_Text::SetFGColor
$LN7@InsertScor:

; 699  : 					}
; 700  : 					// Set Score
; 701  : 					txt=(C_Text *)win->FindControl(TEXT_1+i*2+1);

	mov	edx, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [edx+edx+99801]
	push	eax
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _txt$[ebp], eax

; 702  : 					if(txt)

	cmp	DWORD PTR _txt$[ebp], 0
	je	SHORT $LN8@InsertScor

; 703  : 					{
; 704  : 						_stprintf(buf,"%1ld",Scores.Scores[i].Score);

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 36					; 00000024H
	mov	edx, DWORD PTR ?Scores@@3UHighScoreList@@A[ecx+32]
	push	edx
	push	OFFSET ??_C@_04DIDHKLLF@?$CF1ld?$AA@
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 705  : 						txt->SetText(AddCommas(buf));

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	?AddCommas@@YAPADPAD@Z			; AddCommas
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax+256]
	call	edx

; 706  : 						if(i == idx)

	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _idx$[ebp]
	jne	SHORT $LN3@InsertScor

; 707  : 							txt->SetFGColor(0x00ff00);

	push	65280					; 0000ff00H
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetFGColor@C_Text@@QAEXK@Z		; C_Text::SetFGColor

; 708  : 						else

	jmp	SHORT $LN8@InsertScor
$LN3@InsertScor:

; 709  : 							txt->SetFGColor(0xffffff);

	push	16777215				; 00ffffffH
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetFGColor@C_Text@@QAEXK@Z		; C_Text::SetFGColor
$LN8@InsertScor:

; 710  : 					}
; 711  : 				}
; 712  : 			}

	jmp	$LN10@InsertScor
$LN12@InsertScor:

; 713  : 		}
; 714  : 		win->RefreshWindow();

	mov	ecx, DWORD PTR _win$[ebp]
	call	?RefreshWindow@C_Window@@QAEXXZ		; C_Window::RefreshWindow

; 715  : 		SaveHighScores();

	call	?SaveHighScores@@YAXXZ			; SaveHighScores
$LN20@InsertScor:

; 716  : 	}
; 717  : 	win=gMainHandler->FindWindow(IA_DBRF_WIN);

	push	10023					; 00002727H
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z ; C_Handler::FindWindowA
	mov	DWORD PTR _win$[ebp], eax

; 718  : 	if(win)

	cmp	DWORD PTR _win$[ebp], 0
	je	SHORT $LN24@InsertScor

; 719  : 		gMainHandler->EnableWindowGroup(win->GetGroup());

	mov	ecx, DWORD PTR _win$[ebp]
	call	?GetGroup@C_Window@@QAEJXZ		; C_Window::GetGroup
	push	eax
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?EnableWindowGroup@C_Handler@@QAEXJ@Z	; C_Handler::EnableWindowGroup
$LN24@InsertScor:

; 720  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?InsertScoreCB@@YAXJFPAVC_Base@@@Z ENDP			; InsertScoreCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\instant\instant.cpp
_TEXT	SEGMENT
_txt$ = -36						; size = 4
_i$ = -32						; size = 4
_win$ = -28						; size = 4
_buf$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
?SetupInstantAction@@YAXXZ PROC				; SetupInstantAction

; 1593 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1594 : 	C_Window *win;
; 1595 : 	C_Text *txt;
; 1596 : 	_TCHAR buf[20];
; 1597 : 	int i;
; 1598 : 
; 1599 : 	win=gMainHandler->FindWindow(IA_SETTINGS_WIN);

	push	10001					; 00002711H
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z ; C_Handler::FindWindowA
	mov	DWORD PTR _win$[ebp], eax

; 1600 : 	if(win)

	cmp	DWORD PTR _win$[ebp], 0
	je	SHORT $LN12@SetupInsta

; 1601 : 	{
; 1602 : 		SetIAStartup(win);

	mov	eax, DWORD PTR _win$[ebp]
	push	eax
	call	?SetIAStartup@@YAXPAVC_Window@@@Z	; SetIAStartup
	add	esp, 4

; 1603 : 		win->RefreshWindow();

	mov	ecx, DWORD PTR _win$[ebp]
	call	?RefreshWindow@C_Window@@QAEXXZ		; C_Window::RefreshWindow
$LN12@SetupInsta:

; 1604 : 	}
; 1605 : 
; 1606 : 	GetHighScores();

	call	?GetHighScores@@YAXXZ			; GetHighScores

; 1607 : 
; 1608 : 	win=gMainHandler->FindWindow(IA_SH_WIN);

	push	10002					; 00002712H
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z ; C_Handler::FindWindowA
	mov	DWORD PTR _win$[ebp], eax

; 1609 : 	if(win)

	cmp	DWORD PTR _win$[ebp], 0
	je	$LN11@SetupInsta

; 1610 : 	{
; 1611 : 		for(i=0;i<MAX_SCORES;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN10@SetupInsta
$LN9@SetupInsta:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN10@SetupInsta:
	cmp	DWORD PTR _i$[ebp], 12			; 0000000cH
	jge	$LN8@SetupInsta

; 1612 : 		{
; 1613 : 			if(Scores.Scores[i].Name[0] != 0)

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 36					; 00000024H
	mov	eax, 1
	imul	eax, 0
	movsx	ecx, BYTE PTR ?Scores@@3UHighScoreList@@A[edx+eax]
	test	ecx, ecx
	je	$LN7@SetupInsta

; 1614 : 			{
; 1615 : 				// Set Name
; 1616 : 				txt=(C_Text *)win->FindControl(TEXT_1+i*2);

	mov	edx, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [edx+edx+99800]
	push	eax
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _txt$[ebp], eax

; 1617 : 				if(txt)

	cmp	DWORD PTR _txt$[ebp], 0
	je	SHORT $LN6@SetupInsta

; 1618 : 				{
; 1619 : 					txt->SetText(Scores.Scores[i].Name);

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 36					; 00000024H
	add	ecx, OFFSET ?Scores@@3UHighScoreList@@A	; Scores
	push	ecx
	mov	edx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax+256]
	call	edx
$LN6@SetupInsta:

; 1620 : 				}
; 1621 : 				// Set Score
; 1622 : 				txt=(C_Text *)win->FindControl(TEXT_1+i*2+1);

	mov	eax, DWORD PTR _i$[ebp]
	lea	ecx, DWORD PTR [eax+eax+99801]
	push	ecx
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _txt$[ebp], eax

; 1623 : 				if(txt)

	cmp	DWORD PTR _txt$[ebp], 0
	je	SHORT $LN7@SetupInsta

; 1624 : 				{
; 1625 : 					_stprintf(buf,"%1ld",Scores.Scores[i].Score);

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 36					; 00000024H
	mov	eax, DWORD PTR ?Scores@@3UHighScoreList@@A[edx+32]
	push	eax
	push	OFFSET ??_C@_04DIDHKLLF@?$CF1ld?$AA@
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1626 : 					txt->SetText(AddCommas(buf));

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	?AddCommas@@YAPADPAD@Z			; AddCommas
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+256]
	call	eax
$LN7@SetupInsta:

; 1627 : 				}
; 1628 : 			}
; 1629 : 		}

	jmp	$LN9@SetupInsta
$LN8@SetupInsta:

; 1630 : 		win->RefreshWindow();

	mov	ecx, DWORD PTR _win$[ebp]
	call	?RefreshWindow@C_Window@@QAEXXZ		; C_Window::RefreshWindow
$LN11@SetupInsta:

; 1631 : 	}
; 1632 : 	win=gMainHandler->FindWindow(IA_MAP_WIN);

	push	10043					; 0000273bH
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z ; C_Handler::FindWindowA
	mov	DWORD PTR _win$[ebp], eax

; 1633 : 	if(win)

	cmp	DWORD PTR _win$[ebp], 0
	je	SHORT $LN4@SetupInsta

; 1634 : 		SetMapStartup(win);

	mov	ecx, DWORD PTR _win$[ebp]
	push	ecx
	call	?SetMapStartup@@YAXPAVC_Window@@@Z	; SetMapStartup
	add	esp, 4
$LN4@SetupInsta:

; 1635 : 	
; 1636 : 	if((MainLastGroup == 1000))

	cmp	DWORD PTR ?MainLastGroup@@3HA, 1000	; MainLastGroup, 000003e8H
	jne	$LN13@SetupInsta

; 1637 : 	{// these functions (with scoring) MUST be in this order to work properly
; 1638 : 		TotalScore=0;

	mov	DWORD PTR ?TotalScore@@3JA, 0		; TotalScore

; 1639 : 		Bonus=10000;

	mov	DWORD PTR ?Bonus@@3JA, 10000		; Bonus, 00002710H

; 1640 : 		Penalty=0;

	mov	DWORD PTR ?Penalty@@3JA, 0		; Penalty

; 1641 : 		LivingBonus=0;

	mov	DWORD PTR ?LivingBonus@@3JA, 0		; LivingBonus

; 1642 : 		LandingBonus=0;

	mov	DWORD PTR ?LandingBonus@@3JA, 0		; LandingBonus

; 1643 : 
; 1644 : 		win=gMainHandler->FindWindow(IA_DBRF_WIN);

	push	10023					; 00002727H
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z ; C_Handler::FindWindowA
	mov	DWORD PTR _win$[ebp], eax

; 1645 : 		if(win)

	cmp	DWORD PTR _win$[ebp], 0
	je	SHORT $LN2@SetupInsta

; 1646 : 		{
; 1647 : 			ProcessEventList(win,1);

	push	1
	mov	edx, DWORD PTR _win$[ebp]
	push	edx
	call	?ProcessEventList@@YAXPAVC_Window@@J@Z	; ProcessEventList
	add	esp, 8
$LN2@SetupInsta:

; 1648 : 		}
; 1649 : 		//for(i=InstantAction.iaStartLevel;i<InstantAction.iaCurLevel;i++)
; 1650 : 			//Bonus+=20000*i;
; 1651 : 		win=gMainHandler->FindWindow(IA_DBRF_WIN);

	push	10023					; 00002727H
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z ; C_Handler::FindWindowA
	mov	DWORD PTR _win$[ebp], eax

; 1652 : 		if(win)

	cmp	DWORD PTR _win$[ebp], 0
	je	SHORT $LN1@SetupInsta

; 1653 : 		{
; 1654 : 			ProcessBonus();

	call	?ProcessBonus@@YAXXZ			; ProcessBonus

; 1655 : 			ProcessWeapons(win); // Bonus is part of this window

	mov	eax, DWORD PTR _win$[ebp]
	push	eax
	call	?ProcessWeapons@@YAXPAVC_Window@@@Z	; ProcessWeapons
	add	esp, 4

; 1656 : 			TotalScore+=Bonus-Penalty + LivingBonus + LandingBonus;

	mov	ecx, DWORD PTR ?Bonus@@3JA		; Bonus
	sub	ecx, DWORD PTR ?Penalty@@3JA		; Penalty
	add	ecx, DWORD PTR ?LivingBonus@@3JA	; LivingBonus
	add	ecx, DWORD PTR ?LandingBonus@@3JA	; LandingBonus
	add	ecx, DWORD PTR ?TotalScore@@3JA		; TotalScore
	mov	DWORD PTR ?TotalScore@@3JA, ecx		; TotalScore

; 1657 : 			ProcessKills(win); // TotalScore is part of this window

	mov	edx, DWORD PTR _win$[ebp]
	push	edx
	call	?ProcessKills@@YAXPAVC_Window@@@Z	; ProcessKills
	add	esp, 4

; 1658 : 			win->ScanClientAreas();

	mov	ecx, DWORD PTR _win$[ebp]
	call	?ScanClientAreas@C_Window@@QAEXXZ	; C_Window::ScanClientAreas

; 1659 : 			win->RefreshWindow();

	mov	ecx, DWORD PTR _win$[ebp]
	call	?RefreshWindow@C_Window@@QAEXXZ		; C_Window::RefreshWindow
$LN1@SetupInsta:

; 1660 : 		}
; 1661 : 
; 1662 : 		CheckHighScore(TotalScore);

	mov	eax, DWORD PTR ?TotalScore@@3JA		; TotalScore
	push	eax
	call	?CheckHighScore@@YAXJ@Z			; CheckHighScore
	add	esp, 4

; 1663 : 
; 1664 : 		TheCampaign.EndCampaign();

	mov	ecx, OFFSET ?TheCampaign@@3VCampaignClass@@A ; TheCampaign
	call	?EndCampaign@CampaignClass@@QAEXXZ	; CampaignClass::EndCampaign
$LN13@SetupInsta:

; 1665 : 	}
; 1666 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?SetupInstantAction@@YAXXZ ENDP				; SetupInstantAction
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\instant\instant.cpp
_TEXT	SEGMENT
_hour$ = -20						; size = 4
_ebox$ = -16						; size = 4
_clk$ = -12						; size = 4
_winme$ = -8						; size = 4
_ctrl$ = -4						; size = 4
_ID$ = 8						; size = 4
?HookupIAControls@@YAXJ@Z PROC				; HookupIAControls

; 833  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 834  : 	C_Window *winme;
; 835  : 	C_Button *ctrl;
; 836  : 	C_EditBox *ebox;
; 837  : 	C_Clock *clk;
; 838  : 	long hour; //THW 2004-02-18 Random daytime
; 839  : 	winme=gMainHandler->FindWindow(ID);

	mov	eax, DWORD PTR _ID$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z ; C_Handler::FindWindowA
	mov	DWORD PTR _winme$[ebp], eax

; 840  : 
; 841  : 	if(winme == NULL)

	cmp	DWORD PTR _winme$[ebp], 0
	jne	SHORT $LN14@HookupIACo

; 842  : 		return;

	jmp	$LN15@HookupIACo
$LN14@HookupIACo:

; 843  : 
; 844  : 	// Hook up IDs here
; 845  : 
; 846  : 	// Time/Date CB
; 847  : 	clk=(C_Clock *)winme->FindControl(TIME_ID);

	push	5001					; 00001389H
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _clk$[ebp], eax

; 848  : 	if(clk)

	cmp	DWORD PTR _clk$[ebp], 0
	je	$LN13@HookupIACo

; 849  : 	{
; 850  : 		//clk->SetHour(12);
; 851  : 		//THW 2004-02-18 Random daytime
; 852  : 		hour = (4 + (rand()%15));

	call	_rand
	cdq
	mov	ecx, 15					; 0000000fH
	idiv	ecx
	add	edx, 4
	mov	DWORD PTR _hour$[ebp], edx

; 853  : 		clk->SetHour(hour);

	mov	edx, DWORD PTR _hour$[ebp]
	push	edx
	mov	ecx, DWORD PTR _clk$[ebp]
	call	?SetHour@C_Clock@@QAEXJ@Z		; C_Clock::SetHour

; 854  : 		//Sunrise ~4:40h, Sunset ~19:10h
; 855  : 		if(hour==4)

	cmp	DWORD PTR _hour$[ebp], 4
	jne	SHORT $LN12@HookupIACo

; 856  : 		{
; 857  : 			clk->SetMinute(40 + (rand()%19));

	call	_rand
	cdq
	mov	ecx, 19					; 00000013H
	idiv	ecx
	add	edx, 40					; 00000028H
	push	edx
	mov	ecx, DWORD PTR _clk$[ebp]
	call	?SetMinute@C_Clock@@QAEXJ@Z		; C_Clock::SetMinute
	jmp	SHORT $LN11@HookupIACo
$LN12@HookupIACo:

; 858  : 		}
; 859  : 		else if (hour==19)

	cmp	DWORD PTR _hour$[ebp], 19		; 00000013H
	jne	SHORT $LN10@HookupIACo

; 860  : 		{
; 861  : 			clk->SetMinute(0 + (rand()%10));

	call	_rand
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	push	edx
	mov	ecx, DWORD PTR _clk$[ebp]
	call	?SetMinute@C_Clock@@QAEXJ@Z		; C_Clock::SetMinute

; 862  : 		}
; 863  : 		else

	jmp	SHORT $LN11@HookupIACo
$LN10@HookupIACo:

; 864  : 		{
; 865  : 			clk->SetMinute(0 + (rand()%59));

	call	_rand
	cdq
	mov	ecx, 59					; 0000003bH
	idiv	ecx
	push	edx
	mov	ecx, DWORD PTR _clk$[ebp]
	call	?SetMinute@C_Clock@@QAEXJ@Z		; C_Clock::SetMinute
$LN11@HookupIACo:

; 866  : 		}
; 867  : 		clk->SetSecond(0);

	push	0
	mov	ecx, DWORD PTR _clk$[ebp]
	call	?SetSecond@C_Clock@@QAEXJ@Z		; C_Clock::SetSecond

; 868  : 		clk->Refresh();

	mov	edx, DWORD PTR _clk$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _clk$[ebp]
	mov	edx, DWORD PTR [eax+160]
	call	edx
$LN13@HookupIACo:

; 869  : 	}
; 870  : 
; 871  : 	// Hook up Instant Action Buttons
; 872  : 	// Set Fly Button for IA
; 873  : 	ctrl=(C_Button *)winme->FindControl(SINGLE_FLY_CTRL);

	push	2000000					; 001e8480H
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ctrl$[ebp], eax

; 874  : 	if(ctrl)

	cmp	DWORD PTR _ctrl$[ebp], 0
	je	SHORT $LN8@HookupIACo

; 875  : 		ctrl->SetCallback(InstantActionFlyCB);

	push	OFFSET ?InstantActionFlyCB@@YAXJFPAVC_Base@@@Z ; InstantActionFlyCB
	mov	eax, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN8@HookupIACo:

; 876  : 
; 877  : 	ctrl=(C_Button *)winme->FindControl(MUNITIONS_BUTTON);

	push	6124					; 000017ecH
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ctrl$[ebp], eax

; 878  : 	if(ctrl)

	cmp	DWORD PTR _ctrl$[ebp], 0
	je	SHORT $LN7@HookupIACo

; 879  : 		ctrl->SetCallback(OpenIAMunitionsCB);

	push	OFFSET ?OpenIAMunitionsCB@@YAXJFPAVC_Base@@@Z ; OpenIAMunitionsCB
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN7@HookupIACo:

; 880  : 
; 881  : 	// editbox for high score callback
; 882  : 	ebox=(C_EditBox *)winme->FindControl(IA_HS_NAME_EDIT);

	push	10042					; 0000273aH
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ebox$[ebp], eax

; 883  : 	if(ebox)

	cmp	DWORD PTR _ebox$[ebp], 0
	je	SHORT $LN6@HookupIACo

; 884  : 	{
; 885  : 		ebox->SetCallback(HighScoreKeyboardCB);

	push	OFFSET ?HighScoreKeyboardCB@@YAXJFPAVC_Base@@@Z ; HighScoreKeyboardCB
	mov	ecx, DWORD PTR _ebox$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ebox$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax

; 886  : 		if(!*ebox->GetText())

	mov	ecx, DWORD PTR _ebox$[ebp]
	call	?GetText@C_EditBox@@QAEPADXZ		; C_EditBox::GetText
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN6@HookupIACo

; 887  : 		{
; 888  : 			ebox->SetText(UI_logbk.Name());

	mov	ecx, OFFSET ?UI_logbk@@3VLogBookData@@A	; UI_logbk
	call	?Name@LogBookData@@QAEPADXZ		; LogBookData::Name
	push	eax
	mov	ecx, DWORD PTR _ebox$[ebp]
	call	?SetText@C_EditBox@@QAEXPAD@Z		; C_EditBox::SetText
$LN6@HookupIACo:

; 889  : 		}
; 890  : 	}
; 891  : 	// Hook up Close Button
; 892  : 	ctrl=(C_Button *)winme->FindControl(CLOSE_WINDOW);

	push	80001					; 00013881H
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ctrl$[ebp], eax

; 893  : 	if(ctrl)

	cmp	DWORD PTR _ctrl$[ebp], 0
	je	SHORT $LN4@HookupIACo

; 894  : 		ctrl->SetCallback(CloseWindowCB);

	push	OFFSET ?CloseWindowCB@@YAXJFPAVC_Base@@@Z ; CloseWindowCB
	mov	edx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [eax+100]
	call	edx
$LN4@HookupIACo:

; 895  : 
; 896  : 	ctrl=(C_Button *)winme->FindControl(TIME_EARLIER);

	push	10054					; 00002746H
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ctrl$[ebp], eax

; 897  : 	if(ctrl)

	cmp	DWORD PTR _ctrl$[ebp], 0
	je	SHORT $LN3@HookupIACo

; 898  : 		ctrl->SetCallback(ChangeTimeCB);

	push	OFFSET ?ChangeTimeCB@@YAXJFPAVC_Base@@@Z ; ChangeTimeCB
	mov	eax, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN3@HookupIACo:

; 899  : 
; 900  : 	ctrl=(C_Button *)winme->FindControl(TIME_LATER);

	push	10055					; 00002747H
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ctrl$[ebp], eax

; 901  : 	if(ctrl)

	cmp	DWORD PTR _ctrl$[ebp], 0
	je	SHORT $LN2@HookupIACo

; 902  : 		ctrl->SetCallback(ChangeTimeCB);

	push	OFFSET ?ChangeTimeCB@@YAXJFPAVC_Base@@@Z ; ChangeTimeCB
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN2@HookupIACo:

; 903  : 
; 904  : // Help GUIDE thing
; 905  : 	ctrl=(C_Button*)winme->FindControl(UI_HELP_GUIDE);

	push	2501					; 000009c5H
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ctrl$[ebp], eax

; 906  : 	if(ctrl)

	cmp	DWORD PTR _ctrl$[ebp], 0
	je	SHORT $LN15@HookupIACo

; 907  : 		ctrl->SetCallback(UI_Help_Guide_CB);

	push	OFFSET ?UI_Help_Guide_CB@@YAXJFPAVC_Base@@@Z ; UI_Help_Guide_CB
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN15@HookupIACo:

; 908  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?HookupIAControls@@YAXJ@Z ENDP				; HookupIAControls
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\instant\instant.cpp
;	COMDAT ??__EIAPlayerID@@YAXXZ
text$yc	SEGMENT
??__EIAPlayerID@@YAXXZ PROC				; `dynamic initializer for 'IAPlayerID'', COMDAT

; 89   : VU_ID IAPlayerID=FalconNullId;

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR ?IAPlayerID@@3VVU_ID@@A, eax
	mov	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR ?IAPlayerID@@3VVU_ID@@A+4, ecx
	pop	ebp
	ret	0
??__EIAPlayerID@@YAXXZ ENDP				; `dynamic initializer for 'IAPlayerID''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\instant\instant.cpp
_TEXT	SEGMENT
$T1 = -12						; size = 4
_prev$ = -8						; size = 4
_cur$ = -4						; size = 4
?RemoveWeaponUsageList@@YAXXZ PROC			; RemoveWeaponUsageList

; 413  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 414  : 	kill_list *cur,*prev;
; 415  : 
; 416  : 	cur=WeaponUsage;

	mov	eax, DWORD PTR ?WeaponUsage@@3PAUkill_list@@A ; WeaponUsage
	mov	DWORD PTR _cur$[ebp], eax
$LN2@RemoveWeap:

; 417  : 	while(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN1@RemoveWeap

; 418  : 	{
; 419  : 		prev=cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _prev$[ebp], ecx

; 420  : 		cur=cur->next;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _cur$[ebp], eax

; 421  : 		delete prev;

	mov	ecx, DWORD PTR _prev$[ebp]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 422  : 	}

	jmp	SHORT $LN2@RemoveWeap
$LN1@RemoveWeap:

; 423  : 	WeaponUsage=NULL;

	mov	DWORD PTR ?WeaponUsage@@3PAUkill_list@@A, 0 ; WeaponUsage

; 424  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveWeaponUsageList@@YAXXZ ENDP			; RemoveWeaponUsageList
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\fakerand.h
;	COMDAT ?PRANDFloatPos@@YAMXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_x$ = -4						; size = 4
?PRANDFloatPos@@YAMXZ PROC				; PRANDFloatPos, COMDAT

; 150  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 151  : //	return NRANDPOS;
; 152  : 	float	x=	(float)(GenerateFastRandom()&0xffff);

	call	?GenerateFastRandom@@YAJXZ		; GenerateFastRandom
	and	eax, 65535				; 0000ffffH
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _x$[ebp], xmm0

; 153  : 	return( x / 65535.0f);

	movss	xmm0, DWORD PTR _x$[ebp]
	divss	xmm0, DWORD PTR __real@477fff00
	movss	DWORD PTR tv72[ebp], xmm0
	fld	DWORD PTR tv72[ebp]

; 154  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PRANDFloatPos@@YAMXZ ENDP				; PRANDFloatPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\fakerand.h
;	COMDAT ?GenerateFastRandom@@YAJXZ
_TEXT	SEGMENT
_FastRandom$ = -4					; size = 4
?GenerateFastRandom@@YAJXZ PROC				; GenerateFastRandom, COMDAT

; 108  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 109  : 	static long LastRandom;
; 110  : 	long	FastRandom;														// The Random Variable
; 111  : 	_asm {	
; 112  : 			push	edx

	push	edx

; 113  : 			push	eax

	push	eax

; 114  : 			RDTSC

	rdtsc

; 115  : 			add	DWORD PTR FastRandom,edx

	add	DWORD PTR _FastRandom$[ebp], edx

; 116  : 			xor	DWORD PTR FastRandom,eax

	xor	DWORD PTR _FastRandom$[ebp], eax

; 117  : 			mov	eax, DWORD PTR LastRandom

	mov	eax, DWORD PTR ?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA ; `GenerateFastRandom'::`2'::LastRandom

; 118  : 			add	DWORD PTR FastRandom,eax

	add	DWORD PTR _FastRandom$[ebp], eax

; 119  : 			add	DWORD PTR LastRandom,edx

	add	DWORD PTR ?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA, edx ; `GenerateFastRandom'::`2'::LastRandom

; 120  : 			pop	eax

	pop	eax

; 121  : 			pop	edx

	pop	edx

; 122  : 	}
; 123  : 	return(FastRandom);

	mov	eax, DWORD PTR _FastRandom$[ebp]

; 124  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GenerateFastRandom@@YAJXZ ENDP				; GenerateFastRandom
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\tmap.h
;	COMDAT ?FeetPerBlock@TMap@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?FeetPerBlock@TMap@@QAEMXZ PROC				; TMap::FeetPerBlock, COMDAT
; _this$ = ecx

; 45   :   	float	FeetPerBlock()	{ ShiAssert(IsReady()); return Levels->FTperBLOCK(); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12304]
	call	?FTperBLOCK@TLevel@@QAEMXZ		; TLevel::FTperBLOCK
	mov	esp, ebp
	pop	ebp
	ret	0
?FeetPerBlock@TMap@@QAEMXZ ENDP				; TMap::FeetPerBlock
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\tmap.h
;	COMDAT ?BlocksWide@TMap@@QAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?BlocksWide@TMap@@QAEIXZ PROC				; TMap::BlocksWide, COMDAT
; _this$ = ecx

; 44   : 	UINT	BlocksWide() { ShiAssert(IsReady());  return Levels->BlocksWide(); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12304]
	call	?BlocksWide@TLevel@@QAEIXZ		; TLevel::BlocksWide
	mov	esp, ebp
	pop	ebp
	ret	0
?BlocksWide@TMap@@QAEIXZ ENDP				; TMap::BlocksWide
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\tmap.h
;	COMDAT ?BlocksHigh@TMap@@QAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?BlocksHigh@TMap@@QAEIXZ PROC				; TMap::BlocksHigh, COMDAT
; _this$ = ecx

; 43   : 	UINT	BlocksHigh() { ShiAssert(IsReady());  return Levels->BlocksHigh(); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12304]
	call	?BlocksHigh@TLevel@@QAEIXZ		; TLevel::BlocksHigh
	mov	esp, ebp
	pop	ebp
	ret	0
?BlocksHigh@TMap@@QAEIXZ ENDP				; TMap::BlocksHigh
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\tlevel.h
;	COMDAT ?BlocksHigh@TLevel@@QAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?BlocksHigh@TLevel@@QAEIXZ PROC				; TLevel::BlocksHigh, COMDAT
; _this$ = ecx

; 54   : 	UINT	BlocksHigh( void ) { return blocks_high; };		// How many blocks high is this level

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?BlocksHigh@TLevel@@QAEIXZ ENDP				; TLevel::BlocksHigh
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\tlevel.h
;	COMDAT ?BlocksWide@TLevel@@QAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?BlocksWide@TLevel@@QAEIXZ PROC				; TLevel::BlocksWide, COMDAT
; _this$ = ecx

; 53   : 	UINT	BlocksWide( void ) { return blocks_wide; };	 	// How many blocks across is this level

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	esp, ebp
	pop	ebp
	ret	0
?BlocksWide@TLevel@@QAEIXZ ENDP				; TLevel::BlocksWide
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\tlevel.h
;	COMDAT ?FTperBLOCK@TLevel@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?FTperBLOCK@TLevel@@QAEMXZ PROC				; TLevel::FTperBLOCK, COMDAT
; _this$ = ecx

; 48   :   	float	FTperBLOCK()	{ return feet_per_block; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+16]
	mov	esp, ebp
	pop	ebp
	ret	0
?FTperBLOCK@TLevel@@QAEMXZ ENDP				; TLevel::FTperBLOCK
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\cmpclass.h
;	COMDAT ?IsLoaded@CampaignClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsLoaded@CampaignClass@@QAEHXZ PROC			; CampaignClass::IsLoaded, COMDAT
; _this$ = ecx

; 177  : 	int IsLoaded (void)										{ return Flags & CAMP_LOADED; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+64]
	and	eax, 2
	mov	esp, ebp
	pop	ebp
	ret	0
?IsLoaded@CampaignClass@@QAEHXZ ENDP			; CampaignClass::IsLoaded
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\include\logbook.h
;	COMDAT ?Name@LogBookData@@QAEPADXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Name@LogBookData@@QAEPADXZ PROC			; LogBookData::Name, COMDAT
; _this$ = ecx

; 167  : 	_TCHAR *Name(void)								{return Pilot.Name;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?Name@LogBookData@@QAEPADXZ ENDP			; LogBookData::Name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\chandler.h
;	COMDAT ?GetAppWnd@C_Handler@@QAEPAUHWND__@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAppWnd@C_Handler@@QAEPAUHWND__@@XZ PROC		; C_Handler::GetAppWnd, COMDAT
; _this$ = ecx

; 244  : 		HWND GetAppWnd() { return(AppWindow_);}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetAppWnd@C_Handler@@QAEPAUHWND__@@XZ ENDP		; C_Handler::GetAppWnd
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.h
;	COMDAT ?GetGroup@C_Window@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGroup@C_Window@@QAEJXZ PROC				; C_Window::GetGroup, COMDAT
; _this$ = ecx

; 317  : 		long GetGroup(void) { return(Group_);}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetGroup@C_Window@@QAEJXZ ENDP				; C_Window::GetGroup
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cparser.h
;	COMDAT ?GetNextWindowLoaded@C_Parser@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNextWindowLoaded@C_Parser@@QAEJXZ PROC		; C_Parser::GetNextWindowLoaded, COMDAT
; _this$ = ecx

; 99   : 		long GetNextWindowLoaded() { WinIndex_++; if(WinIndex_ < WinLoaded_) return(WindowList_[WinIndex_]); else return(0); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+960]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+960], cx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+960]
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+962]
	cmp	ecx, eax
	jge	SHORT $LN2@GetNextWin
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+960]
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+edx*4+104]
	jmp	SHORT $LN3@GetNextWin
	jmp	SHORT $LN3@GetNextWin
$LN2@GetNextWin:
	xor	eax, eax
$LN3@GetNextWin:
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNextWindowLoaded@C_Parser@@QAEJXZ ENDP		; C_Parser::GetNextWindowLoaded
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cparser.h
;	COMDAT ?GetFirstWindowLoaded@C_Parser@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFirstWindowLoaded@C_Parser@@QAEJXZ PROC		; C_Parser::GetFirstWindowLoaded, COMDAT
; _this$ = ecx

; 98   : 		long GetFirstWindowLoaded() { WinIndex_=0; if(WinIndex_ < WinLoaded_) return(WindowList_[WinIndex_]); else return(0); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+960], ax
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+960]
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+962]
	cmp	eax, edx
	jge	SHORT $LN2@GetFirstWi
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+960]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+104]
	jmp	SHORT $LN3@GetFirstWi
	jmp	SHORT $LN3@GetFirstWi
$LN2@GetFirstWi:
	xor	eax, eax
$LN3@GetFirstWi:
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFirstWindowLoaded@C_Parser@@QAEJXZ ENDP		; C_Parser::GetFirstWindowLoaded
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cclock.h
;	COMDAT ?GetSecondCtrl@C_Clock@@QAEPAVC_EditBox@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSecondCtrl@C_Clock@@QAEPAVC_EditBox@@XZ PROC	; C_Clock::GetSecondCtrl, COMDAT
; _this$ = ecx

; 80   : 		C_EditBox *GetSecondCtrl()	{ return(Second_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+132]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSecondCtrl@C_Clock@@QAEPAVC_EditBox@@XZ ENDP	; C_Clock::GetSecondCtrl
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cclock.h
;	COMDAT ?GetMinuteCtrl@C_Clock@@QAEPAVC_EditBox@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMinuteCtrl@C_Clock@@QAEPAVC_EditBox@@XZ PROC	; C_Clock::GetMinuteCtrl, COMDAT
; _this$ = ecx

; 79   : 		C_EditBox *GetMinuteCtrl()	{ return(Minute_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+128]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetMinuteCtrl@C_Clock@@QAEPAVC_EditBox@@XZ ENDP	; C_Clock::GetMinuteCtrl
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cclock.h
;	COMDAT ?GetHourCtrl@C_Clock@@QAEPAVC_EditBox@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetHourCtrl@C_Clock@@QAEPAVC_EditBox@@XZ PROC		; C_Clock::GetHourCtrl, COMDAT
; _this$ = ecx

; 78   : 		C_EditBox *GetHourCtrl()	{ return(Hour_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+124]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetHourCtrl@C_Clock@@QAEPAVC_EditBox@@XZ ENDP		; C_Clock::GetHourCtrl
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cclock.h
;	COMDAT ?GetDayCtrl@C_Clock@@QAEPAVC_EditBox@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetDayCtrl@C_Clock@@QAEPAVC_EditBox@@XZ PROC		; C_Clock::GetDayCtrl, COMDAT
; _this$ = ecx

; 77   : 		C_EditBox *GetDayCtrl()		{ return(Day_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+120]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDayCtrl@C_Clock@@QAEPAVC_EditBox@@XZ ENDP		; C_Clock::GetDayCtrl
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cclock.h
;	COMDAT ?GetCurrentCtrl@C_Clock@@QAEPAVC_EditBox@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCurrentCtrl@C_Clock@@QAEPAVC_EditBox@@XZ PROC	; C_Clock::GetCurrentCtrl, COMDAT
; _this$ = ecx

; 76   : 		C_EditBox *GetCurrentCtrl()	{ return(CurEdit_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+152]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCurrentCtrl@C_Clock@@QAEPAVC_EditBox@@XZ ENDP	; C_Clock::GetCurrentCtrl
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cclock.h
;	COMDAT ?GetLast@C_Clock@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetLast@C_Clock@@QAEJXZ PROC				; C_Clock::GetLast, COMDAT
; _this$ = ecx

; 74   : 		long GetLast()				{ if(CurEdit_) return(CurEdit_->GetInteger()); return(0); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+152], 0
	je	SHORT $LN1@GetLast
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+152]
	call	?GetInteger@C_EditBox@@QAEJXZ		; C_EditBox::GetInteger
	jmp	SHORT $LN2@GetLast
$LN1@GetLast:
	xor	eax, eax
$LN2@GetLast:
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLast@C_Clock@@QAEJXZ ENDP				; C_Clock::GetLast
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cclock.h
;	COMDAT ?GetSecond@C_Clock@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSecond@C_Clock@@QAEJXZ PROC				; C_Clock::GetSecond, COMDAT
; _this$ = ecx

; 72   : 		long GetSecond()			{ if(Second_) return(Second_->GetInteger()); return(0); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+132], 0
	je	SHORT $LN1@GetSecond
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+132]
	call	?GetInteger@C_EditBox@@QAEJXZ		; C_EditBox::GetInteger
	jmp	SHORT $LN2@GetSecond
$LN1@GetSecond:
	xor	eax, eax
$LN2@GetSecond:
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSecond@C_Clock@@QAEJXZ ENDP				; C_Clock::GetSecond
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cclock.h
;	COMDAT ?GetMinute@C_Clock@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMinute@C_Clock@@QAEJXZ PROC				; C_Clock::GetMinute, COMDAT
; _this$ = ecx

; 71   : 		long GetMinute()			{ if(Minute_) return(Minute_->GetInteger()); return(0); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+128], 0
	je	SHORT $LN1@GetMinute
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+128]
	call	?GetInteger@C_EditBox@@QAEJXZ		; C_EditBox::GetInteger
	jmp	SHORT $LN2@GetMinute
$LN1@GetMinute:
	xor	eax, eax
$LN2@GetMinute:
	mov	esp, ebp
	pop	ebp
	ret	0
?GetMinute@C_Clock@@QAEJXZ ENDP				; C_Clock::GetMinute
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cclock.h
;	COMDAT ?GetHour@C_Clock@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetHour@C_Clock@@QAEJXZ PROC				; C_Clock::GetHour, COMDAT
; _this$ = ecx

; 70   : 		long GetHour()				{ if(Hour_) return(Hour_->GetInteger()); return(0); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+124], 0
	je	SHORT $LN1@GetHour
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+124]
	call	?GetInteger@C_EditBox@@QAEJXZ		; C_EditBox::GetInteger
	jmp	SHORT $LN2@GetHour
$LN1@GetHour:
	xor	eax, eax
$LN2@GetHour:
	mov	esp, ebp
	pop	ebp
	ret	0
?GetHour@C_Clock@@QAEJXZ ENDP				; C_Clock::GetHour
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cclock.h
;	COMDAT ?GetDay@C_Clock@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetDay@C_Clock@@QAEJXZ PROC				; C_Clock::GetDay, COMDAT
; _this$ = ecx

; 69   : 		long GetDay()				{ if(Day_) return(Day_->GetInteger()-1); return(0); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+120], 0
	je	SHORT $LN1@GetDay
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+120]
	call	?GetInteger@C_EditBox@@QAEJXZ		; C_EditBox::GetInteger
	sub	eax, 1
	jmp	SHORT $LN2@GetDay
$LN1@GetDay:
	xor	eax, eax
$LN2@GetDay:
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDay@C_Clock@@QAEJXZ ENDP				; C_Clock::GetDay
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cclock.h
;	COMDAT ?SetLast@C_Clock@@QAEXJ@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_val$ = 8						; size = 4
?SetLast@C_Clock@@QAEXJ@Z PROC				; C_Clock::SetLast, COMDAT
; _this$ = ecx

; 67   : 		void SetLast(long val)		{ if(CurEdit_) CurEdit_->SetInteger(val); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+152], 0
	je	SHORT $LN2@SetLast
	mov	ecx, DWORD PTR _val$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+152]
	call	?SetInteger@C_EditBox@@QAEXJ@Z		; C_EditBox::SetInteger
$LN2@SetLast:
	mov	esp, ebp
	pop	ebp
	ret	4
?SetLast@C_Clock@@QAEXJ@Z ENDP				; C_Clock::SetLast
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cclock.h
;	COMDAT ?SetSecond@C_Clock@@QAEXJ@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_sc$ = 8						; size = 4
?SetSecond@C_Clock@@QAEXJ@Z PROC			; C_Clock::SetSecond, COMDAT
; _this$ = ecx

; 65   : 		void SetSecond(long sc)		{ if(Second_) Second_->SetInteger(sc); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+132], 0
	je	SHORT $LN2@SetSecond
	mov	ecx, DWORD PTR _sc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+132]
	call	?SetInteger@C_EditBox@@QAEXJ@Z		; C_EditBox::SetInteger
$LN2@SetSecond:
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSecond@C_Clock@@QAEXJ@Z ENDP			; C_Clock::SetSecond
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cclock.h
;	COMDAT ?SetMinute@C_Clock@@QAEXJ@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_mn$ = 8						; size = 4
?SetMinute@C_Clock@@QAEXJ@Z PROC			; C_Clock::SetMinute, COMDAT
; _this$ = ecx

; 64   : 		void SetMinute(long mn)		{ if(Minute_) Minute_->SetInteger(mn); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+128], 0
	je	SHORT $LN2@SetMinute
	mov	ecx, DWORD PTR _mn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+128]
	call	?SetInteger@C_EditBox@@QAEXJ@Z		; C_EditBox::SetInteger
$LN2@SetMinute:
	mov	esp, ebp
	pop	ebp
	ret	4
?SetMinute@C_Clock@@QAEXJ@Z ENDP			; C_Clock::SetMinute
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cclock.h
;	COMDAT ?SetHour@C_Clock@@QAEXJ@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_hr$ = 8						; size = 4
?SetHour@C_Clock@@QAEXJ@Z PROC				; C_Clock::SetHour, COMDAT
; _this$ = ecx

; 63   : 		void SetHour(long hr)		{ if(Hour_) Hour_->SetInteger(hr); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+124], 0
	je	SHORT $LN2@SetHour
	mov	ecx, DWORD PTR _hr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+124]
	call	?SetInteger@C_EditBox@@QAEXJ@Z		; C_EditBox::SetInteger
$LN2@SetHour:
	mov	esp, ebp
	pop	ebp
	ret	4
?SetHour@C_Clock@@QAEXJ@Z ENDP				; C_Clock::SetHour
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cclock.h
;	COMDAT ?SetDay@C_Clock@@QAEXJ@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_dy$ = 8						; size = 4
?SetDay@C_Clock@@QAEXJ@Z PROC				; C_Clock::SetDay, COMDAT
; _this$ = ecx

; 62   : 		void SetDay(long dy)		{ if(Day_) Day_->SetInteger(dy+1); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+120], 0
	je	SHORT $LN2@SetDay
	mov	ecx, DWORD PTR _dy$[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+120]
	call	?SetInteger@C_EditBox@@QAEXJ@Z		; C_EditBox::SetInteger
$LN2@SetDay:
	mov	esp, ebp
	pop	ebp
	ret	4
?SetDay@C_Clock@@QAEXJ@Z ENDP				; C_Clock::SetDay
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\ceditbox.h
;	COMDAT ?GetInteger@C_EditBox@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetInteger@C_EditBox@@QAEJXZ PROC			; C_EditBox::GetInteger, COMDAT
; _this$ = ecx

; 71   : 		long GetInteger() { return(Integer_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+108]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetInteger@C_EditBox@@QAEJXZ ENDP			; C_EditBox::GetInteger
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\ceditbox.h
;	COMDAT ?GetMaxInteger@C_EditBox@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMaxInteger@C_EditBox@@QAEJXZ PROC			; C_EditBox::GetMaxInteger, COMDAT
; _this$ = ecx

; 64   : 		long GetMaxInteger(void) { return(MaxInteger_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+116]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetMaxInteger@C_EditBox@@QAEJXZ ENDP			; C_EditBox::GetMaxInteger
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\ceditbox.h
;	COMDAT ?GetMinInteger@C_EditBox@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMinInteger@C_EditBox@@QAEJXZ PROC			; C_EditBox::GetMinInteger, COMDAT
; _this$ = ecx

; 61   : 		long GetMinInteger(void) { return(MinInteger_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+112]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetMinInteger@C_EditBox@@QAEJXZ ENDP			; C_EditBox::GetMinInteger
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cbase.h
;	COMDAT ?GetH@C_Base@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetH@C_Base@@QAEJXZ PROC				; C_Base::GetH, COMDAT
; _this$ = ecx

; 144  : 		long GetH()					{ return(h_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+36]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetH@C_Base@@QAEJXZ ENDP				; C_Base::GetH
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cbase.h
;	COMDAT ?GetW@C_Base@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetW@C_Base@@QAEJXZ PROC				; C_Base::GetW, COMDAT
; _this$ = ecx

; 143  : 		long GetW()					{ return(w_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+32]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetW@C_Base@@QAEJXZ ENDP				; C_Base::GetW
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cbase.h
;	COMDAT ?GetY@C_Base@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetY@C_Base@@QAEJXZ PROC				; C_Base::GetY, COMDAT
; _this$ = ecx

; 142  : 		long GetY()					{ return(y_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+28]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetY@C_Base@@QAEJXZ ENDP				; C_Base::GetY
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cbase.h
;	COMDAT ?GetX@C_Base@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetX@C_Base@@QAEJXZ PROC				; C_Base::GetX, COMDAT
; _this$ = ecx

; 141  : 		long GetX()					{ return(x_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+24]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetX@C_Base@@QAEJXZ ENDP				; C_Base::GetX
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cbase.h
;	COMDAT ?GetID@C_Base@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetID@C_Base@@QAEJXZ PROC				; C_Base::GetID, COMDAT
; _this$ = ecx

; 134  : 		long  GetID()				{ return(ID_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetID@C_Base@@QAEJXZ ENDP				; C_Base::GetID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cbase.h
;	COMDAT ?SetClient@C_Base@@QAEXF@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_client$ = 8						; size = 2
?SetClient@C_Base@@QAEXF@Z PROC				; C_Base::SetClient, COMDAT
; _this$ = ecx

; 98   : 		void SetClient(short client)							{ Client_=client; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _client$[ebp]
	mov	WORD PTR [eax+40], cx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetClient@C_Base@@QAEXF@Z ENDP				; C_Base::SetClient
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\csoundrc.h
;	COMDAT ?PlaySoundA@C_Sound@@QAEHJ@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ID$ = 8						; size = 4
?PlaySoundA@C_Sound@@QAEHJ@Z PROC			; C_Sound::PlaySoundA, COMDAT
; _this$ = ecx

; 79   : 		BOOL PlaySound(long ID) { return(PlaySound(GetSound(ID))); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _ID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSound@C_Sound@@QAEPAVSOUND_RES@@J@Z	; C_Sound::GetSound
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PlaySoundA@C_Sound@@QAEHPAVSOUND_RES@@@Z ; C_Sound::PlaySoundA
	mov	esp, ebp
	pop	ebp
	ret	4
?PlaySoundA@C_Sound@@QAEHJ@Z ENDP			; C_Sound::PlaySoundA
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tchar.h
;	COMDAT __tcsclen
_TEXT	SEGMENT
__String$ = 8						; size = 4
__tcsclen PROC						; COMDAT

; 1748 : {

	push	ebp
	mov	ebp, esp

; 1749 :     return _mbslen((const unsigned char *)_String);

	mov	eax, DWORD PTR __String$[ebp]
	push	eax
	call	__mbslen
	add	esp, 4

; 1750 : }

	pop	ebp
	ret	0
__tcsclen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tchar.h
;	COMDAT __tcsncpy
_TEXT	SEGMENT
__Dst$ = 8						; size = 4
__Source$ = 12						; size = 4
__Count$ = 16						; size = 4
__tcsncpy PROC						; COMDAT

; 1524 : {

	push	ebp
	mov	ebp, esp

; 1525 : #pragma warning(push)
; 1526 : #pragma warning(disable:4996)
; 1527 :     return (char *)_mbsnbcpy((unsigned char *)_Dst,(const unsigned char *)_Source,_Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Source$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dst$[ebp]
	push	edx
	call	__mbsnbcpy
	add	esp, 12					; 0000000cH

; 1528 : #pragma warning(pop)
; 1529 : }

	pop	ebp
	ret	0
__tcsncpy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_System_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_System_error_category@std@@UAEPAXI@Z PROC		; std::_System_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_System_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_System_error_category@std@@UAEPAXI@Z ENDP		; std::_System_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_System_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_System_error_category@std@@UAE@XZ PROC		; std::_System_error_category::~_System_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_System_error_category@std@@UAE@XZ ENDP		; std::_System_error_category::~_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::_System_error_category::default_error_condition, COMDAT
; _this$ = ecx

; 641  : 		{	// make error_condition for error code (generic if possible)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 642  : 		if (_Syserror_map(_Errval))

	mov	eax, DWORD PTR __Errval$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@default_er

; 643  : 			return (error_condition(_Errval, generic_category()));

	call	?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@default_er

; 644  : 		else

	jmp	SHORT $LN3@default_er
$LN2@default_er:

; 645  : 			return (error_condition(_Errval, system_category()));

	call	?system_category@std@@YAABVerror_category@1@XZ ; std::system_category
	push	eax
	mov	edx, DWORD PTR __Errval$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@default_er:

; 646  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::_System_error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_System_error_category::message, COMDAT
; _this$ = ecx

; 634  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 635  : 		const char *_Name = _Winerror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Winerror_map@std@@YAPBDH@Z		; std::_Winerror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 636  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 637  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_System_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_System_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_System_error_category@std@@UBEPBDXZ PROC		; std::_System_error_category::name, COMDAT
; _this$ = ecx

; 629  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 630  : 		return ("system");

	mov	eax, OFFSET ??_C@_06FHFOAHML@system?$AA@

; 631  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_System_error_category@std@@UBEPBDXZ ENDP		; std::_System_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_System_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_System_error_category@std@@QAE@XZ PROC		; std::_System_error_category::_System_error_category, COMDAT
; _this$ = ecx

; 624  : 	_System_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_System_error_category@std@@6B@

; 625  : 		{	// default constructor
; 626  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_System_error_category@std@@QAE@XZ ENDP		; std::_System_error_category::_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Iostream_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Iostream_error_category@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iostream_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Iostream_error_category@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Iostream_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Iostream_error_category@std@@UAE@XZ PROC		; std::_Iostream_error_category::~_Iostream_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Iostream_error_category@std@@UAE@XZ ENDP		; std::_Iostream_error_category::~_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT
; _this$ = ecx

; 611  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 612  : 		if (_Errcode == (int)io_errc::stream)

	cmp	DWORD PTR __Errcode$[ebp], 1
	jne	SHORT $LN2@message

; 613  : 			return ("iostream stream error");

	push	OFFSET ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@message

; 614  : 		else

	jmp	SHORT $LN3@message
$LN2@message:

; 615  : 			return (_Generic_error_category::message(_Errcode));

	mov	ecx, DWORD PTR __Errcode$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@message:

; 616  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Iostream_error_category@std@@UBEPBDXZ PROC	; std::_Iostream_error_category::name, COMDAT
; _this$ = ecx

; 606  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 607  : 		return ("iostream");

	mov	eax, OFFSET ??_C@_08LLGCOLLL@iostream?$AA@

; 608  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Iostream_error_category@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Iostream_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iostream_error_category@std@@QAE@XZ PROC		; std::_Iostream_error_category::_Iostream_error_category, COMDAT
; _this$ = ecx

; 601  : 	_Iostream_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Iostream_error_category@std@@6B@

; 602  : 		{	// default constructor
; 603  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iostream_error_category@std@@QAE@XZ ENDP		; std::_Iostream_error_category::_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Generic_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Generic_error_category@std@@UAE@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Generic_error_category@std@@UAE@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 590  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 591  : 		const char *_Name = _Syserror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 592  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 593  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 585  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		return ("generic");

	mov	eax, OFFSET ??_C@_07DCLBNMLN@generic?$AA@

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Generic_error_category@std@@QAE@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT
; _this$ = ecx

; 580  : 	_Generic_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0error_category@std@@QAE@XZ		; std::error_category::error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Generic_error_category@std@@6B@

; 581  : 		{	// default constructor
; 582  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Generic_error_category@std@@QAE@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_condition@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv78 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8error_condition@std@@QBE_NABV01@@Z PROC		; std::error_condition::operator==, COMDAT
; _this$ = ecx

; 376  : 		{	// test if *this == _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 377  : 		return (category() == _Right.category()
; 378  : 			&& value() == _Right.value());

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	mov	ecx, eax
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	cmp	esi, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv78[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv78[ebp]

; 379  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??8error_condition@std@@QBE_NABV01@@Z ENDP		; std::error_condition::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 354  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 356  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 349  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 350  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 351  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 316  : 		{	// construct from error code and category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Cat$[ebp]
	mov	DWORD PTR [edx+4], eax

; 317  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 256  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 257  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 258  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 251  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 252  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 253  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gerror_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gerror_category@std@@UAEPAXI@Z PROC			; std::error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gerror_category@std@@UAEPAXI@Z ENDP			; std::error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv65 = -4						; size = 4
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 184  : 		{	// compare categories for equality

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 185  : 		return (this == &_Right);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv65[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv65[ebp]

; 186  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -4						; size = 4
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 415  : 	{	// test if conditions same for this category

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 416  : 	return (*this == _Code.category() && _Code.value() == _Errval);

	mov	ecx, DWORD PTR __Code$[ebp]
	call	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@equivalent
	mov	ecx, DWORD PTR __Code$[ebp]
	call	?value@error_code@std@@QBEHXZ		; std::error_code::value
	cmp	eax, DWORD PTR __Errval$[ebp]
	jne	SHORT $LN3@equivalent
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN4@equivalent
$LN3@equivalent:
	mov	DWORD PTR tv74[ebp], 0
$LN4@equivalent:
	mov	al, BYTE PTR tv74[ebp]

; 417  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 408  : 	{	// test if error code same condition

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 409  : 	return (default_error_condition(_Errval) == _Cond);

	mov	eax, DWORD PTR __Cond$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	ecx, eax
	call	??8error_condition@std@@QBE_NABV01@@Z	; std::error_condition::operator==

; 410  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 401  : 	{	// make error_condition for error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 402  : 	return (error_condition(_Errval, *this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 403  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 167  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 168  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0error_category@std@@QAE@XZ PROC			; std::error_category::error_category, COMDAT
; _this$ = ecx

; 162  : 	error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 163  : 		{	// default constructor
; 164  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0error_category@std@@QAE@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?system_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?system_category@std@@YAABVerror_category@1@XZ PROC	; std::system_category, COMDAT

; 679  : 	{	// get system_category

	push	ebp
	mov	ebp, esp

; 680  : 	return (_Error_objects<int>::_System_object);

	mov	eax, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object

; 681  : 	}

	pop	ebp
	ret	0
?system_category@std@@YAABVerror_category@1@XZ ENDP	; std::system_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?generic_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?generic_category@std@@YAABVerror_category@1@XZ PROC	; std::generic_category, COMDAT

; 669  : 	{	// get generic_category

	push	ebp
	mov	ebp, esp

; 670  : 	return (_Error_objects<int>::_Generic_object);

	mov	eax, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object

; 671  : 	}

	pop	ebp
	ret	0
?generic_category@std@@YAABVerror_category@1@XZ ENDP	; std::generic_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocale
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC				; std::locale::id::id, COMDAT
; _this$ = ecx

; 74   : 			{	// construct with specified stamp value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx

; 75   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2275 : 		{	// report an out_of_range error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2276 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN2@Xran:

; 2277 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2270 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2271 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN2@Xlen:

; 2272 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Ptr$1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2253 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2254 : 		if (!_Built)

	movzx	eax, BYTE PTR __Built$[ebp]
	test	eax, eax
	jne	SHORT $LN4@Tidy
	jmp	SHORT $LN3@Tidy
$LN4@Tidy:

; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN3@Tidy

; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Ptr$1[ebp], eax

; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 2260 : 			if (0 < _Newsize)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN1@Tidy

; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$1[ebp]
	push	ecx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Tidy:

; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Ptr$1[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN3@Tidy:

; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2266 : 		_Eos(_Newsize);

	mov	edx, DWORD PTR __Newsize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2267 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2237 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	cmp	DWORD PTR __Ptr$[ebp], 0
	je	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	cmp	DWORD PTR __Ptr$[ebp], eax
	jb	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
$LN2@Inside:

; 2240 : 			return (false);	// don't ask

	xor	al, al
	jmp	SHORT $LN4@Inside

; 2241 : 		else

	jmp	SHORT $LN4@Inside
$LN3@Inside:

; 2242 : 			return (true);

	mov	al, 1
$LN4@Inside:

; 2243 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
tv136 = -12						; size = 4
tv129 = -8						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2224 : 		if (max_size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN6@Grow

; 2225 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN6@Grow:

; 2226 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN5@Grow

; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	jmp	SHORT $LN4@Grow
$LN5@Grow:

; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	movzx	edx, BYTE PTR __Trim$[ebp]
	test	edx, edx
	je	SHORT $LN3@Grow
	cmp	DWORD PTR __Newsize$[ebp], 16		; 00000010H
	jae	SHORT $LN3@Grow

; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jae	SHORT $LN9@Grow
	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv129[ebp], edx
	jmp	SHORT $LN10@Grow
$LN9@Grow:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR tv129[ebp], ecx
$LN10@Grow:
	mov	edx, DWORD PTR tv129[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
	jmp	SHORT $LN4@Grow
$LN3@Grow:

; 2231 : 		else if (_Newsize == 0)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $LN4@Grow

; 2232 : 			_Eos(0);	// new size is zero, just null terminate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN4@Grow:

; 2233 : 		return (0 < _Newsize);	// return true only if more work to do

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN11@Grow
	mov	DWORD PTR tv136[ebp], 1
	jmp	SHORT $LN12@Grow
$LN11@Grow:
	mov	DWORD PTR tv136[ebp], 0
$LN12@Grow:
	mov	al, BYTE PTR tv136[ebp]
$LN8@Grow:

; 2234 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [eax+16], ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 2219 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
tv205 = -48						; size = 4
tv204 = -44						; size = 4
tv203 = -40						; size = 4
tv202 = -36						; size = 4
__Ptr$ = -32						; size = 4
__Newres$ = -28						; size = 4
_this$ = -24						; size = 4
$T2 = -19						; size = 1
$T3 = -18						; size = 1
$T4 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Newres$[ebp], eax

; 2184 : 		if (max_size() < _Newres)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newres$[ebp]
	jae	SHORT $LN9@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx
	jmp	SHORT $LN8@Copy
$LN9@Copy:

; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)

	mov	eax, DWORD PTR __Newres$[ebp]
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	shr	ecx, 1
	cmp	ecx, eax
	ja	SHORT $LN7@Copy
	jmp	SHORT $LN8@Copy
$LN7@Copy:

; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+20]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, esi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], eax
	ja	SHORT $LN5@Copy

; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	shr	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR __Newres$[ebp], eax

; 2191 : 		else

	jmp	SHORT $LN8@Copy
$LN5@Copy:

; 2192 : 			_Newres = max_size();	// settle for max_size()

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	DWORD PTR __Newres$[ebp], eax
$LN8@Copy:

; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv202[ebp], eax
	mov	eax, DWORD PTR __Newres$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR tv202[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv203[ebp], eax
	mov	ecx, DWORD PTR tv203[ebp]
	mov	DWORD PTR __Ptr$[ebp], ecx
	jmp	SHORT $LN12@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2197 : 		_CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], edx

; 2199 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv204[ebp], eax
	mov	ecx, DWORD PTR __Newres$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR tv204[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv205[ebp], eax
	mov	edx, DWORD PTR tv205[ebp]
	mov	DWORD PTR __Ptr$[ebp], edx
	jmp	SHORT $LN14@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2203 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 2204 : 			_CATCH_END

	mov	eax, $LN17@Copy
	ret	0
$LN14@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2
$LN17@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2:

; 2205 : 		_CATCH_END

	mov	eax, $LN19@Copy
	ret	0
$LN12@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3
$LN19@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jbe	SHORT $LN1@Copy

; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements

	mov	eax, DWORD PTR __Oldlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Copy:

; 2210 : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);

	lea	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>

; 2212 : 		this->_Myres = _Newres;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newres$[ebp]
	mov	DWORD PTR [edx+20], eax

; 2213 : 		_Eos(_Oldlen);

	mov	ecx, DWORD PTR __Oldlen$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN11@Copy:

; 2214 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv75 = -12						; size = 4
__Num$ = -8						; size = 4
$T1 = -1						; size = 1
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1737 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1738 : 		size_type _Num = this->_Getal().max_size();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
	mov	DWORD PTR __Num$[ebp], eax

; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$[ebp], 1
	ja	SHORT $LN3@max_size
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	ecx, DWORD PTR __Num$[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv75[ebp], ecx
$LN4@max_size:
	mov	eax, DWORD PTR tv75[ebp]

; 1740 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1732 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1733 : 		return (this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]

; 1734 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$1 = -12					; size = 4
__Ptr$2 = -8						; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1317 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1318 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN4@erase

; 1319 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN4@erase:

; 1320 : 		if (this->_Mysize - _Off <= _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Off$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	ja	SHORT $LN3@erase

; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)

	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
	jmp	SHORT $LN2@erase
$LN3@erase:

; 1322 : 		else if (0 < _Count)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN2@erase

; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Ptr$2[ebp], eax

; 1325 : 			size_type _Newsize = this->_Mysize - _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Newsize$1[ebp], eax

; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	sub	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$2[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$2[ebp]
	push	eax
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 1327 : 			_Eos(_Newsize);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@erase:

; 1328 : 			}
; 1329 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN6@erase:

; 1330 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1309 : 		{	// erase elements [_Off, ...)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1310 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN1@erase

; 1311 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN1@erase:

; 1312 : 		_Eos(_Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1313 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@erase:

; 1314 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1142 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1145 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@assign

; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	jmp	SHORT $LN3@assign
$LN2@assign:

; 1132 : 
; 1133 : 		if (_Grow(_Count))

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@assign

; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1136 : 			_Eos(_Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@assign:

; 1137 : 			}
; 1138 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@assign:

; 1139 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1105 : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $LN5@assign

; 1106 : 			_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN5@assign:

; 1107 : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 1108 : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Num$[ebp]
	jae	SHORT $LN4@assign

; 1109 : 			_Num = _Count;	// trim _Num to size

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
$LN4@assign:

; 1110 : 
; 1111 : 		if (this == &_Right)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@assign

; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	mov	eax, DWORD PTR __Roff$[ebp]
	add	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	mov	ecx, DWORD PTR __Roff$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	jmp	SHORT $LN2@assign
$LN3@assign:

; 1113 : 		else if (_Grow(_Num))

	push	0
	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@assign

; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);

	mov	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1117 : 			_Eos(_Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@assign:

; 1118 : 			}
; 1119 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN7@assign:

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 791  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >

; 792  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 793  : 		assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 794  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 688  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 689  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 690  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 635  : 	_String_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >

; 636  : 		{	// construct allocator from _Al
; 637  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		{	// determine current pointer to buffer for nonmutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 522  : 		return (this->_BUF_SIZE <= this->_Myres
; 523  : 			? _STD addressof(*this->_Bx._Ptr)
; 524  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 525  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		{	// determine current pointer to buffer for mutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 515  : 		return (this->_BUF_SIZE <= this->_Myres
; 516  : 			? _STD addressof(*this->_Bx._Ptr)
; 517  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 518  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 496  : 	_String_val()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 497  : 		{	// initialize values
; 498  : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 499  : 		_Myres = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 500  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 913  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 914  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
	add	esp, 4

; 915  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 886  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 887  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate

; 888  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 875  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 877  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 830  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>

; 831  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 761  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp

; 762  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@D@std@@QBEIXZ	; std::allocator<char>::max_size

; 763  : 		}

	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

	or	eax, -1

; 629  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 590  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8

; 592  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 565  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 563  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 564  : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 565  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 551  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@move
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@move
$LN3@move:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@move:
	mov	eax, DWORD PTR tv69[ebp]

; 554  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 528  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@copy
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@copy
$LN3@copy:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@copy:
	mov	eax, DWORD PTR tv69[ebp]

; 531  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 521  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp
	push	ecx

; 522  : 		return (*_First == 0 ? 0
; 523  : 			: _CSTD strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@length
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN4@length
$LN3@length:
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR tv68[ebp], eax
$LN4@length:
	mov	eax, DWORD PTR tv68[ebp]

; 524  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 65   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 60   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 61   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
;	COMDAT ??8VU_ID@@QBE_NABV0@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -2						; size = 1
tv73 = -1						; size = 1
_rhs$ = 8						; size = 4
??8VU_ID@@QBE_NABV0@@Z PROC				; VU_ID::operator==, COMDAT
; _this$ = ecx

; 104  : 	bool operator == (const VU_ID &rhs) const { 

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 105  : 		return (
; 106  : 			num_ == rhs.num_ ? 
; 107  : 			(creator_ == rhs.creator_ ? true : false) : 
; 108  : 			false
; 109  : 		); 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN5@operator
	mov	eax, DWORD PTR _rhs$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??8VU_SESSION_ID@@QBEHABV0@@Z		; VU_SESSION_ID::operator==
	test	eax, eax
	je	SHORT $LN3@operator
	mov	BYTE PTR tv73[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	BYTE PTR tv73[ebp], 0
$LN4@operator:
	mov	cl, BYTE PTR tv73[ebp]
	mov	BYTE PTR tv74[ebp], cl
	jmp	SHORT $LN6@operator
$LN5@operator:
	mov	BYTE PTR tv74[ebp], 0
$LN6@operator:
	mov	al, BYTE PTR tv74[ebp]

; 110  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
??8VU_ID@@QBE_NABV0@@Z ENDP				; VU_ID::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
;	COMDAT ??8VU_SESSION_ID@@QBEHABV0@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_rhs$ = 8						; size = 4
??8VU_SESSION_ID@@QBEHABV0@@Z PROC			; VU_SESSION_ID::operator==, COMDAT
; _this$ = ecx

; 55   : 	int operator == (const VU_SESSION_ID &rhs) const{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return (value_ == rhs.value_ ? TRUE : FALSE); 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv67[ebp], 0
$LN4@operator:
	mov	eax, DWORD PTR tv67[ebp]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
??8VU_SESSION_ID@@QBEHABV0@@Z ENDP			; VU_SESSION_ID::operator==
_TEXT	ENDS
END
