; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\UI\SRC\tacref\ui_tacref.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?Reference@@3PAVTacticalReference@@A		; Reference
PUBLIC	?TAC_Viewer@@3PAVC_3dViewer@@A			; TAC_Viewer
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?CurrentModel@@3JA				; CurrentModel
PUBLIC	?CurrentWeapon@@3JA				; CurrentWeapon
PUBLIC	?CurrentEntity@@3JA				; CurrentEntity
PUBLIC	?Helicopter@@3HA				; Helicopter
PUBLIC	?BladeAngle@@3MA				; BladeAngle
PUBLIC	?LastRWRTone@@3HA				; LastRWRTone
PUBLIC	?LastLockTone@@3HA				; LastLockTone
PUBLIC	?prevtext@@3HA					; prevtext
PUBLIC	?TACREF_Object@@3UOBJECTINFO@@A			; TACREF_Object
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B ; std::ios_base::failure::_Stream_err
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
_BSS	SEGMENT
?Reference@@3PAVTacticalReference@@A DD 01H DUP (?)	; Reference
?TAC_Viewer@@3PAVC_3dViewer@@A DD 01H DUP (?)		; TAC_Viewer
?CurrentModel@@3JA DD 01H DUP (?)			; CurrentModel
?CurrentWeapon@@3JA DD 01H DUP (?)			; CurrentWeapon
?CurrentEntity@@3JA DD 01H DUP (?)			; CurrentEntity
?Helicopter@@3HA DD 01H DUP (?)				; Helicopter
?BladeAngle@@3MA DD 01H DUP (?)				; BladeAngle
?prevtext@@3HA DD 01H DUP (?)				; prevtext
?TACREF_Object@@3UOBJECTINFO@@A DB 03cH DUP (?)		; TACREF_Object
_BSS	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B
CONST	SEGMENT
?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B DD 01H ; std::ios_base::failure::_Stream_err
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
CONST	SEGMENT
_NEAR_CLIP DD	03f800000r			; 1
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
_DATA	SEGMENT
?LastRWRTone@@3HA DD 0ffffffffH				; LastRWRTone
?LastLockTone@@3HA DD 0ffffffffH			; LastLockTone
_GroupButtonID DD 02008H
	DD	0206cH
	DD	020d0H
	ORG $+4
_SubGroupButtonID DD 02711H
	DD	02718H
	DD	02719H
	DD	0271aH
	DD	02717H
	DD	02716H
	DD	02712H
	DD	02713H
	DD	0271bH
	DD	02714H
	DD	0271cH
	DD	02715H
	DD	0271dH
	DD	0271eH
	DD	02721H
	DD	02720H
	DD	02722H
	DD	0271fH
_DATA	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	??0id@locale@std@@QAE@I@Z			; std::locale::id::id
PUBLIC	?generic_category@std@@YAABVerror_category@1@XZ	; std::generic_category
PUBLIC	?system_category@std@@YAABVerror_category@1@XZ	; std::system_category
PUBLIC	??0error_category@std@@QAE@XZ			; std::error_category::error_category
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??8error_category@std@@QBE_NABV01@@Z		; std::error_category::operator==
PUBLIC	??_Gerror_category@std@@UAEPAXI@Z		; std::error_category::`scalar deleting destructor'
PUBLIC	?value@error_code@std@@QBEHXZ			; std::error_code::value
PUBLIC	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
PUBLIC	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?value@error_condition@std@@QBEHXZ		; std::error_condition::value
PUBLIC	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
PUBLIC	??8error_condition@std@@QBE_NABV01@@Z		; std::error_condition::operator==
PUBLIC	??0_Generic_error_category@std@@QAE@XZ		; std::_Generic_error_category::_Generic_error_category
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	??1_Generic_error_category@std@@UAE@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	??0_Iostream_error_category@std@@QAE@XZ		; std::_Iostream_error_category::_Iostream_error_category
PUBLIC	?name@_Iostream_error_category@std@@UBEPBDXZ	; std::_Iostream_error_category::name
PUBLIC	?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	??1_Iostream_error_category@std@@UAE@XZ		; std::_Iostream_error_category::~_Iostream_error_category
PUBLIC	??_G_Iostream_error_category@std@@UAEPAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	??0_System_error_category@std@@QAE@XZ		; std::_System_error_category::_System_error_category
PUBLIC	?name@_System_error_category@std@@UBEPBDXZ	; std::_System_error_category::name
PUBLIC	?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message
PUBLIC	?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition
PUBLIC	??1_System_error_category@std@@UAE@XZ		; std::_System_error_category::~_System_error_category
PUBLIC	??_G_System_error_category@std@@UAEPAXI@Z	; std::_System_error_category::`scalar deleting destructor'
PUBLIC	?Radius@DrawableObject@@QBEMXZ			; DrawableObject::Radius
PUBLIC	?GetNTextureSet@ObjectInstance@@QAEHXZ		; ObjectInstance::GetNTextureSet
PUBLIC	?SetTextureSet@DrawableBSP@@QAEXK@Z		; DrawableBSP::SetTextureSet
PUBLIC	?GetNTextureSet@DrawableBSP@@QAEHXZ		; DrawableBSP::GetNTextureSet
PUBLIC	?SetClient@C_Base@@QAEXF@Z			; C_Base::SetClient
PUBLIC	?SetParent@C_Base@@QAEXPAVC_Window@@@Z		; C_Base::SetParent
PUBLIC	?SetReady@C_Base@@QAEXF@Z			; C_Base::SetReady
PUBLIC	?GetID@C_Base@@QAEJXZ				; C_Base::GetID
PUBLIC	?GetFlags@C_Base@@QAEJXZ			; C_Base::GetFlags
PUBLIC	?GetClient@C_Base@@QAEFXZ			; C_Base::GetClient
PUBLIC	?GetX@C_Base@@QAEJXZ				; C_Base::GetX
PUBLIC	?GetRoot@C_ListBox@@QAEPAVLISTBOX@@XZ		; C_ListBox::GetRoot
PUBLIC	?GetTextID@C_ListBox@@QAEJXZ			; C_ListBox::GetTextID
PUBLIC	?GetRoot@C_TreeList@@QAEPAVTREELIST@@XZ		; C_TreeList::GetRoot
PUBLIC	?GetHRange@C_Panner@@QAEJXZ			; C_Panner::GetHRange
PUBLIC	?GetVRange@C_Panner@@QAEJXZ			; C_Panner::GetVRange
PUBLIC	?SetUpdateCallback@C_TimerHook@@QAEXP6AXJFPAVC_Base@@@Z@Z ; C_TimerHook::SetUpdateCallback
PUBLIC	?SetRefreshCallback@C_TimerHook@@QAEXP6AXJFPAVC_Base@@@Z@Z ; C_TimerHook::SetRefreshCallback
PUBLIC	?SetDrawCallback@C_TimerHook@@QAEXP6AXJFPAVC_Base@@@Z@Z ; C_TimerHook::SetDrawCallback
PUBLIC	?GetFirstWindowLoaded@C_Parser@@QAEJXZ		; C_Parser::GetFirstWindowLoaded
PUBLIC	?GetNextWindowLoaded@C_Parser@@QAEJXZ		; C_Parser::GetNextWindowLoaded
PUBLIC	?SetDragCallback@C_Window@@QAEXP6AXPAV1@@Z@Z	; C_Window::SetDragCallback
PUBLIC	?GetControlList@C_Window@@QAEPAUControlListStr@@XZ ; C_Window::GetControlList
PUBLIC	??0C_3dViewer@@QAE@XZ				; C_3dViewer::C_3dViewer
PUBLIC	??1C_3dViewer@@QAE@XZ				; C_3dViewer::~C_3dViewer
PUBLIC	??_GC_3dViewer@@QAEPAXI@Z			; C_3dViewer::`scalar deleting destructor'
PUBLIC	??_GTacticalReference@@QAEPAXI@Z		; TacticalReference::`scalar deleting destructor'
PUBLIC	?TacRef_Cleanup@@YAXXZ				; TacRef_Cleanup
PUBLIC	?TACMoveRendererCB@@YAXPAVC_Window@@@Z		; TACMoveRendererCB
PUBLIC	?TACREF_ViewBSPObjectCB@@YAXJFPAVC_Base@@@Z	; TACREF_ViewBSPObjectCB
PUBLIC	?StopRWRSounds@@YAXXZ				; StopRWRSounds
PUBLIC	?TACREFCloseWindowCB@@YAXJFPAVC_Base@@@Z	; TACREFCloseWindowCB
PUBLIC	?TACREF_PositionCamera@@YAXPAUOBJECTINFO@@PAVC_Window@@J@Z ; TACREF_PositionCamera
PUBLIC	?TACREF_ViewTimerAnimCB@@YAXJFPAVC_Base@@@Z	; TACREF_ViewTimerAnimCB
PUBLIC	?TACREF_ViewTimerCB@@YAXJFPAVC_Base@@@Z		; TACREF_ViewTimerCB
PUBLIC	?SelectRWR@@YAXJ@Z				; SelectRWR
PUBLIC	?ReplaceDummyControl@@YAXPAVC_Window@@@Z	; ReplaceDummyControl
PUBLIC	?TacRef_Setup@@YAHXZ				; TacRef_Setup
PUBLIC	?LoadTacticalReferenceWindows@@YAXXZ		; LoadTacticalReferenceWindows
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??_7error_category@std@@6B@			; std::error_category::`vftable'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_C@_07DCLBNMLN@generic?$AA@			; `string'
PUBLIC	??_C@_0O@BFJCFAAK@unknown?5error?$AA@		; `string'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream?$AA@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	; `string'
PUBLIC	??_7_System_error_category@std@@6B@		; std::_System_error_category::`vftable'
PUBLIC	??_C@_06FHFOAHML@system?$AA@			; `string'
PUBLIC	?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
PUBLIC	?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
PUBLIC	?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
PUBLIC	?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
PUBLIC	?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
PUBLIC	??_C@_04JCAPCJAP@?4tga?$AA@			; `string'
PUBLIC	??_C@_0N@GLKIJJIP@tacrefdb?4bin?$AA@		; `string'
PUBLIC	??_C@_05BMGBEOOC@?$CFs?2?$CFs?$AA@		; `string'
PUBLIC	??_C@_0M@LEGCNPPE@ref_res?4lst?$AA@		; `string'
PUBLIC	??_C@_0M@PJCKHLME@ref_art?4lst?$AA@		; `string'
PUBLIC	??_C@_0M@GEBMLJLD@ref_snd?4lst?$AA@		; `string'
PUBLIC	??_C@_0M@EIADHJHI@ref_scf?4lst?$AA@		; `string'
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	?id@?$numpunct@_W@std@@2V0locale@2@A		; std::numpunct<wchar_t>::id
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_R4error_category@std@@6B@			; std::error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error_category@std@@6B@		; std::_System_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_System_error_category@std@@@8		; std::_System_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_System_error_category@std@@8		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error_category@std@@8		; std::_System_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error_category@std@@8	; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
PUBLIC	__real@3f060a92
PUBLIC	__real@3f20d97c
PUBLIC	__real@3f800000
PUBLIC	__real@400599999999999a
PUBLIC	__real@40400000
PUBLIC	__real@40800000
PUBLIC	__real@40a00000
PUBLIC	__real@40c00000
PUBLIC	__real@40c90fdb
PUBLIC	__real@41200000
PUBLIC	__real@41600000
PUBLIC	__real@41a00000
PUBLIC	__real@41f00000
PUBLIC	__real@42200000
PUBLIC	__real@42480000
PUBLIC	__real@42a00000
PUBLIC	__real@42aa0000
PUBLIC	__real@42b40000
PUBLIC	__real@42c80000
PUBLIC	__real@42dc0000
PUBLIC	__real@43020000
PUBLIC	__real@43070000
PUBLIC	__real@430c0000
PUBLIC	__real@43480000
PUBLIC	__real@437a0000
PUBLIC	__real@43b40000
PUBLIC	__real@44160000
PUBLIC	__real@44480000
PUBLIC	__real@47001fcd
PUBLIC	__real@bf800000
PUBLIC	__real@c3480000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	_memcpy:PROC
EXTRN	_strcpy:PROC
EXTRN	_strcat:PROC
EXTRN	_strlen:PROC
EXTRN	_memmove:PROC
EXTRN	_sprintf:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	??_Eerror_category@std@@UAEPAXI@Z:PROC		; std::error_category::`vector deleting destructor'
EXTRN	?_Syserror_map@std@@YAPBDH@Z:PROC		; std::_Syserror_map
EXTRN	?_Winerror_map@std@@YAPBDH@Z:PROC		; std::_Winerror_map
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_E_System_error_category@std@@UAEPAXI@Z:PROC	; std::_System_error_category::`vector deleting destructor'
EXTRN	?SetTextureSet@ObjectInstance@@QAEXH@Z:PROC	; ObjectInstance::SetTextureSet
EXTRN	?Update@DrawableBSP@@QAEXPBUTpoint@@PBUTrotation@@@Z:PROC ; DrawableBSP::Update
EXTRN	?AttachChild@DrawableBSP@@QAEXPAV1@H@Z:PROC	; DrawableBSP::AttachChild
EXTRN	?DetachChild@DrawableBSP@@QAEXPAV1@H@Z:PROC	; DrawableBSP::DetachChild
EXTRN	?SetDOFangle@DrawableBSP@@QAEXHM@Z:PROC		; DrawableBSP::SetDOFangle
EXTRN	?SetSwitchMask@DrawableBSP@@QAEXHK@Z:PROC	; DrawableBSP::SetSwitchMask
EXTRN	?MapVisId@@YAKK@Z:PROC				; MapVisId
EXTRN	?GetVehicleClassData@@YAPAUVehicleClassDataType@@H@Z:PROC ; GetVehicleClassData
EXTRN	_F4LoopSound:PROC
EXTRN	_F4StopSound:PROC
EXTRN	?LoadImageA@C_Image@@QAEPAVC_Resmgr@@JPADFF@Z:PROC ; C_Image::LoadImageA
EXTRN	?RemoveImage@C_Image@@QAEHJ@Z:PROC		; C_Image::RemoveImage
EXTRN	?UI_Enter@@YAPAUF4CSECTIONHANDLE@@PAVC_Window@@@Z:PROC ; UI_Enter
EXTRN	?UI_Leave@@YAXPAUF4CSECTIONHANDLE@@@Z:PROC	; UI_Leave
EXTRN	?SetUserNumber@C_Base@@QAEXJJ@Z:PROC		; C_Base::SetUserNumber
EXTRN	?GetUserNumber@C_Base@@QAEJJ@Z:PROC		; C_Base::GetUserNumber
EXTRN	?SetImage@C_Button@@QAEXFJ@Z:PROC		; C_Button::SetImage
EXTRN	?AddItem@C_ListBox@@QAEPAV1@JFPAD@Z:PROC	; C_ListBox::AddItem
EXTRN	?AddItem@C_ListBox@@QAEPAV1@JFJ@Z:PROC		; C_ListBox::AddItem
EXTRN	?RemoveAllItems@C_ListBox@@QAEXXZ:PROC		; C_ListBox::RemoveAllItems
EXTRN	?SetItemUserData@C_ListBox@@QAEXJFJ@Z:PROC	; C_ListBox::SetItemUserData
EXTRN	?FindID@C_ListBox@@QAEPAVLISTBOX@@J@Z:PROC	; C_ListBox::FindID
EXTRN	?SetValue@C_ListBox@@QAEXJ@Z:PROC		; C_ListBox::SetValue
EXTRN	?CreateItem@C_TreeList@@QAEPAVTREELIST@@JJPAVC_Base@@@Z:PROC ; C_TreeList::CreateItem
EXTRN	?AddItem@C_TreeList@@QAEHPAVTREELIST@@0@Z:PROC	; C_TreeList::AddItem
EXTRN	?AddChildItem@C_TreeList@@QAEHPAVTREELIST@@0@Z:PROC ; C_TreeList::AddChildItem
EXTRN	?DeleteBranch@C_TreeList@@QAEXPAVTREELIST@@@Z:PROC ; C_TreeList::DeleteBranch
EXTRN	?RecalcSize@C_TreeList@@QAEXXZ:PROC		; C_TreeList::RecalcSize
EXTRN	??0C_Text@@QAE@XZ:PROC				; C_Text::C_Text
EXTRN	?SetFixedWidth@C_Text@@QAEXJ@Z:PROC		; C_Text::SetFixedWidth
EXTRN	??0C_TimerHook@@QAE@XZ:PROC			; C_TimerHook::C_TimerHook
EXTRN	?Setup@C_TimerHook@@QAEXJF@Z:PROC		; C_TimerHook::Setup
EXTRN	?LoadWindowList@C_Parser@@QAEHPAD@Z:PROC	; C_Parser::LoadWindowList
EXTRN	?LoadSoundList@C_Parser@@QAEHPAD@Z:PROC		; C_Parser::LoadSoundList
EXTRN	?LoadImageList@C_Parser@@QAEHPAD@Z:PROC		; C_Parser::LoadImageList
EXTRN	?ScanClientArea@C_Window@@QAEXJ@Z:PROC		; C_Window::ScanClientArea
EXTRN	?AddControl@C_Window@@QAEXPAVC_Base@@@Z:PROC	; C_Window::AddControl
EXTRN	?UnHideCluster@C_Window@@QAEXJ@Z:PROC		; C_Window::UnHideCluster
EXTRN	?HideCluster@C_Window@@QAEXJ@Z:PROC		; C_Window::HideCluster
EXTRN	?RefreshWindow@C_Window@@QAEXXZ:PROC		; C_Window::RefreshWindow
EXTRN	?RefreshClient@C_Window@@QAEXJ@Z:PROC		; C_Window::RefreshClient
EXTRN	?FindControl@C_Window@@QAEPAVC_Base@@J@Z:PROC	; C_Window::FindControl
EXTRN	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z:PROC ; C_Handler::FindWindowA
EXTRN	?WaitForLoader@Loader@@QAEXXZ:PROC		; Loader::WaitForLoader
EXTRN	?Setup@C_3dViewer@@QAEHXZ:PROC			; C_3dViewer::Setup
EXTRN	?Cleanup@C_3dViewer@@QAEHXZ:PROC		; C_3dViewer::Cleanup
EXTRN	?Viewport@C_3dViewer@@QAEXPAVC_Window@@J@Z:PROC	; C_3dViewer::Viewport
EXTRN	?SetCamera@C_3dViewer@@QAEXMMMMMM@Z:PROC	; C_3dViewer::SetCamera
EXTRN	?Init3d@C_3dViewer@@QAEHM@Z:PROC		; C_3dViewer::Init3d
EXTRN	?LoadBSP@C_3dViewer@@QAEPAUUI_BSPList@@JHH@Z:PROC ; C_3dViewer::LoadBSP
EXTRN	?Remove@C_3dViewer@@QAEHJ@Z:PROC		; C_3dViewer::Remove
EXTRN	?View3d@C_3dViewer@@QAEHJ@Z:PROC		; C_3dViewer::View3d
EXTRN	?Find@C_3dViewer@@QAEPAUUI_BSPList@@J@Z:PROC	; C_3dViewer::Find
EXTRN	?GetFirst@Category@@QAEPAUCatText@@PAJ@Z:PROC	; Category::GetFirst
EXTRN	?GetNext@Category@@QAEPAUCatText@@PAJ@Z:PROC	; Category::GetNext
EXTRN	?GetFirst@Statistics@@QAEPAVCategory@@PAJ@Z:PROC ; Statistics::GetFirst
EXTRN	?GetNext@Statistics@@QAEPAVCategory@@PAJ@Z:PROC	; Statistics::GetNext
EXTRN	?GetFirst@Description@@QAEPAUTextString@@PAJ@Z:PROC ; Description::GetFirst
EXTRN	?GetNext@Description@@QAEPAUTextString@@PAJ@Z:PROC ; Description::GetNext
EXTRN	?GetFirst@RWR@@QAEPAURadar@@PAJ@Z:PROC		; RWR::GetFirst
EXTRN	?GetNext@RWR@@QAEPAURadar@@PAJ@Z:PROC		; RWR::GetNext
EXTRN	?GetStats@Entity@@QAEPAVStatistics@@XZ:PROC	; Entity::GetStats
EXTRN	?GetDescription@Entity@@QAEPAVDescription@@XZ:PROC ; Entity::GetDescription
EXTRN	?GetRWR@Entity@@QAEPAVRWR@@XZ:PROC		; Entity::GetRWR
EXTRN	??0TacticalReference@@QAE@XZ:PROC		; TacticalReference::TacticalReference
EXTRN	??1TacticalReference@@QAE@XZ:PROC		; TacticalReference::~TacticalReference
EXTRN	?Load@TacticalReference@@QAEHPAD@Z:PROC		; TacticalReference::Load
EXTRN	?Cleanup@TacticalReference@@QAEXXZ:PROC		; TacticalReference::Cleanup
EXTRN	?Find@TacticalReference@@QAEPAVEntity@@J@Z:PROC	; TacticalReference::Find
EXTRN	?GetFirst@TacticalReference@@QAEPAVEntity@@PAJ@Z:PROC ; TacticalReference::GetFirst
EXTRN	?GetNext@TacticalReference@@QAEPAVEntity@@PAJ@Z:PROC ; TacticalReference::GetNext
EXTRN	?PositandOrientSetData@@YAXMMMMMMPAUTpoint@@PAUTrotation@@@Z:PROC ; PositandOrientSetData
EXTRN	?UI_Help_Guide_CB@@YAXJFPAVC_Base@@@Z:PROC	; UI_Help_Guide_CB
EXTRN	?CloseWindowCB@@YAXJFPAVC_Base@@@Z:PROC		; CloseWindowCB
EXTRN	?FindCameraDeltas@@YAXPAUOBJECTINFO@@@Z:PROC	; FindCameraDeltas
EXTRN	?UnloadObject@@YAXXZ:PROC			; UnloadObject
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?IMatrix@@3UTrotation@@B:BYTE			; IMatrix
EXTRN	?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A:DWORD ; Falcon4ClassTable
EXTRN	?gImageMgr@@3PAVC_Image@@A:DWORD		; gImageMgr
EXTRN	?_LOAD_ART_RESOURCES_@@3JA:DWORD		; _LOAD_ART_RESOURCES_
EXTRN	?TheLoader@@3VLoader@@A:BYTE			; TheLoader
EXTRN	?SFX_DEF@@3PAUSfxDef@@A:DWORD			; SFX_DEF
EXTRN	?gMainHandler@@3PAVC_Handler@@A:DWORD		; gMainHandler
EXTRN	?gMainParser@@3PAVC_Parser@@A:DWORD		; gMainParser
EXTRN	?TACREFLoaded@@3HA:DWORD			; TACREFLoaded
EXTRN	?FalconTacrefThrDirectory@@3PADA:BYTE		; FalconTacrefThrDirectory
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
_BSS	SEGMENT
?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Generic_object
_BSS	ENDS
;	COMDAT ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
_BSS	SEGMENT
?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Iostream_object
_BSS	ENDS
;	COMDAT ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
_BSS	SEGMENT
?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_System_object
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@_W@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@_W@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<wchar_t>::id
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@c3480000
CONST	SEGMENT
__real@c3480000 DD 0c3480000r			; -200
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@47001fcd
CONST	SEGMENT
__real@47001fcd DD 047001fcdr			; 32799.8
CONST	ENDS
;	COMDAT __real@44480000
CONST	SEGMENT
__real@44480000 DD 044480000r			; 800
CONST	ENDS
;	COMDAT __real@44160000
CONST	SEGMENT
__real@44160000 DD 044160000r			; 600
CONST	ENDS
;	COMDAT __real@43b40000
CONST	SEGMENT
__real@43b40000 DD 043b40000r			; 360
CONST	ENDS
;	COMDAT __real@437a0000
CONST	SEGMENT
__real@437a0000 DD 0437a0000r			; 250
CONST	ENDS
;	COMDAT __real@43480000
CONST	SEGMENT
__real@43480000 DD 043480000r			; 200
CONST	ENDS
;	COMDAT __real@430c0000
CONST	SEGMENT
__real@430c0000 DD 0430c0000r			; 140
CONST	ENDS
;	COMDAT __real@43070000
CONST	SEGMENT
__real@43070000 DD 043070000r			; 135
CONST	ENDS
;	COMDAT __real@43020000
CONST	SEGMENT
__real@43020000 DD 043020000r			; 130
CONST	ENDS
;	COMDAT __real@42dc0000
CONST	SEGMENT
__real@42dc0000 DD 042dc0000r			; 110
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@42b40000
CONST	SEGMENT
__real@42b40000 DD 042b40000r			; 90
CONST	ENDS
;	COMDAT __real@42aa0000
CONST	SEGMENT
__real@42aa0000 DD 042aa0000r			; 85
CONST	ENDS
;	COMDAT __real@42a00000
CONST	SEGMENT
__real@42a00000 DD 042a00000r			; 80
CONST	ENDS
;	COMDAT __real@42480000
CONST	SEGMENT
__real@42480000 DD 042480000r			; 50
CONST	ENDS
;	COMDAT __real@42200000
CONST	SEGMENT
__real@42200000 DD 042200000r			; 40
CONST	ENDS
;	COMDAT __real@41f00000
CONST	SEGMENT
__real@41f00000 DD 041f00000r			; 30
CONST	ENDS
;	COMDAT __real@41a00000
CONST	SEGMENT
__real@41a00000 DD 041a00000r			; 20
CONST	ENDS
;	COMDAT __real@41600000
CONST	SEGMENT
__real@41600000 DD 041600000r			; 14
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@40c90fdb
CONST	SEGMENT
__real@40c90fdb DD 040c90fdbr			; 6.28319
CONST	ENDS
;	COMDAT __real@40c00000
CONST	SEGMENT
__real@40c00000 DD 040c00000r			; 6
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@400599999999999a
CONST	SEGMENT
__real@400599999999999a DQ 0400599999999999ar	; 2.7
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f20d97c
CONST	SEGMENT
__real@3f20d97c DD 03f20d97cr			; 0.628319
CONST	ENDS
;	COMDAT __real@3f060a92
CONST	SEGMENT
__real@3f060a92 DD 03f060a92r			; 0.523599
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error_category@std@@8 DD FLAT:??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error_category@std@@8
rdata$r	SEGMENT
??_R2_System_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error_category@std@@8
rdata$r	SEGMENT
??_R3_System_error_category@std@@8 DD 00H		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_System_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_System_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_System_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_System_error_category@std@@6B@ DD 00H		; std::_System_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error_category@std@@@8
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD FLAT:??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 00H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category@std@@@8
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
_DATA	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4error_category@std@@6B@
rdata$r	SEGMENT
??_R4error_category@std@@6B@ DD 00H			; std::error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVerror_category@std@@@8
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EIADHJHI@ref_scf?4lst?$AA@
CONST	SEGMENT
??_C@_0M@EIADHJHI@ref_scf?4lst?$AA@ DB 'ref_scf.lst', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GEBMLJLD@ref_snd?4lst?$AA@
CONST	SEGMENT
??_C@_0M@GEBMLJLD@ref_snd?4lst?$AA@ DB 'ref_snd.lst', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PJCKHLME@ref_art?4lst?$AA@
CONST	SEGMENT
??_C@_0M@PJCKHLME@ref_art?4lst?$AA@ DB 'ref_art.lst', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LEGCNPPE@ref_res?4lst?$AA@
CONST	SEGMENT
??_C@_0M@LEGCNPPE@ref_res?4lst?$AA@ DB 'ref_res.lst', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05BMGBEOOC@?$CFs?2?$CFs?$AA@
CONST	SEGMENT
??_C@_05BMGBEOOC@?$CFs?2?$CFs?$AA@ DB '%s\%s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GLKIJJIP@tacrefdb?4bin?$AA@
CONST	SEGMENT
??_C@_0N@GLKIJJIP@tacrefdb?4bin?$AA@ DB 'tacrefdb.bin', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04JCAPCJAP@?4tga?$AA@
CONST	SEGMENT
??_C@_04JCAPCJAP@?4tga?$AA@ DB '.tga', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system?$AA@
CONST	SEGMENT
??_C@_06FHFOAHML@system?$AA@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_System_error_category@std@@6B@
CONST	SEGMENT
??_7_System_error_category@std@@6B@ DD FLAT:??_R4_System_error_category@std@@6B@ ; std::_System_error_category::`vftable'
	DD	FLAT:??_E_System_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_System_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ DB 'iostream stream error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream?$AA@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream?$AA@ DB 'iostream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DD FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DD	FLAT:??_E_Iostream_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
CONST	SEGMENT
??_C@_0O@BFJCFAAK@unknown?5error?$AA@ DB 'unknown error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic?$AA@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic?$AA@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7error_category@std@@6B@
CONST	SEGMENT
??_7error_category@std@@6B@ DD FLAT:??_R4error_category@std@@6B@ ; std::error_category::`vftable'
	DD	FLAT:??_Eerror_category@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
__ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
xdata$x	SEGMENT
__unwindtable$?HookupTacticalReferenceControls@@YAXJ@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?HookupTacticalReferenceControls@@YAXJ@Z$0
__unwindtable$?ReplaceDummyControl@@YAXPAVC_Window@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ReplaceDummyControl@@YAXPAVC_Window@@@Z$0
__unwindtable$?BuildDescTree@@YAXPAVDescription@@PAVC_TreeList@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?BuildDescTree@@YAXPAVDescription@@PAVC_TreeList@@@Z$0
__unwindtable$?BuildStatsTree@@YAXPAVStatistics@@PAVC_TreeList@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?BuildStatsTree@@YAXPAVStatistics@@PAVC_TreeList@@@Z$0
__unwindtable$?BuildCatTree@@YAXPAVCategory@@PAVC_TreeList@@PAVTREELIST@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?BuildCatTree@@YAXPAVCategory@@PAVC_TreeList@@PAVTREELIST@@@Z$0
__unwindtable$?TacRef_Setup@@YAHXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?TacRef_Setup@@YAHXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?TacRef_Setup@@YAHXZ$1
__ehfuncinfo$?TacRef_Setup@@YAHXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?TacRef_Setup@@YAHXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?HookupTacticalReferenceControls@@YAXJ@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?HookupTacticalReferenceControls@@YAXJ@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?ReplaceDummyControl@@YAXPAVC_Window@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ReplaceDummyControl@@YAXPAVC_Window@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?BuildDescTree@@YAXPAVDescription@@PAVC_TreeList@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?BuildDescTree@@YAXPAVDescription@@PAVC_TreeList@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?BuildStatsTree@@YAXPAVStatistics@@PAVC_TreeList@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?BuildStatsTree@@YAXPAVStatistics@@PAVC_TreeList@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?BuildCatTree@@YAXPAVCategory@@PAVC_TreeList@@PAVTREELIST@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?BuildCatTree@@YAXPAVCategory@@PAVC_TreeList@@PAVTREELIST@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Generic_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Iostream_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_System_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@D@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<char>::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@_W@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<wchar_t>::id$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 621  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();
; 624  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
_this$ = -24						; size = 4
tv73 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR __V0$[ebp]
	push	ecx
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<wchar_t>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@_W@std@@2V0locale@2@A ; std::numpunct<wchar_t>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<wchar_t>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<char>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<char>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 755  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp

; 756  : 		{	// destroy object at _Ptr
; 757  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>

; 758  : 		}

	pop	ebp
	ret	0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
	pop	ebp
	ret	0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	ebp
	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??1_System_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_System_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??0_System_error_category@std@@QAE@XZ	; std::_System_error_category::_System_error_category
	push	OFFSET ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_System_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??1_Iostream_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??0_Iostream_error_category@std@@QAE@XZ	; std::_Iostream_error_category::_Iostream_error_category
	push	OFFSET ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??1_Generic_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	push	OFFSET ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], -1
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 85   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 89   : 	}

	pop	ebp
	ret	0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 907  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
	add	esp, 8

; 910  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
	add	esp, 12					; 0000000cH
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\tacref\ui_tacref.cpp
_TEXT	SEGMENT
_ID$ = -4						; size = 4
?LoadTacticalReferenceWindows@@YAXXZ PROC		; LoadTacticalReferenceWindows

; 1283 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1284 : 	long ID;
; 1285 : 
; 1286 : 	if(TACREFLoaded) return;

	cmp	DWORD PTR ?TACREFLoaded@@3HA, 0		; TACREFLoaded
	je	SHORT $LN5@LoadTactic
	jmp	$LN6@LoadTactic
$LN5@LoadTactic:

; 1287 : 
; 1288 : 	if( _LOAD_ART_RESOURCES_)

	cmp	DWORD PTR ?_LOAD_ART_RESOURCES_@@3JA, 0	; _LOAD_ART_RESOURCES_
	je	SHORT $LN4@LoadTactic

; 1289 : 		gMainParser->LoadImageList("ref_res.lst");

	push	OFFSET ??_C@_0M@LEGCNPPE@ref_res?4lst?$AA@
	mov	ecx, DWORD PTR ?gMainParser@@3PAVC_Parser@@A ; gMainParser
	call	?LoadImageList@C_Parser@@QAEHPAD@Z	; C_Parser::LoadImageList

; 1290 : 	else

	jmp	SHORT $LN3@LoadTactic
$LN4@LoadTactic:

; 1291 : 		gMainParser->LoadImageList("ref_art.lst");

	push	OFFSET ??_C@_0M@PJCKHLME@ref_art?4lst?$AA@
	mov	ecx, DWORD PTR ?gMainParser@@3PAVC_Parser@@A ; gMainParser
	call	?LoadImageList@C_Parser@@QAEHPAD@Z	; C_Parser::LoadImageList
$LN3@LoadTactic:

; 1292 : 	gMainParser->LoadSoundList("ref_snd.lst");

	push	OFFSET ??_C@_0M@GEBMLJLD@ref_snd?4lst?$AA@
	mov	ecx, DWORD PTR ?gMainParser@@3PAVC_Parser@@A ; gMainParser
	call	?LoadSoundList@C_Parser@@QAEHPAD@Z	; C_Parser::LoadSoundList

; 1293 : 	gMainParser->LoadWindowList("ref_scf.lst");

	push	OFFSET ??_C@_0M@EIADHJHI@ref_scf?4lst?$AA@
	mov	ecx, DWORD PTR ?gMainParser@@3PAVC_Parser@@A ; gMainParser
	call	?LoadWindowList@C_Parser@@QAEHPAD@Z	; C_Parser::LoadWindowList

; 1294 : 
; 1295 : 	ID=gMainParser->GetFirstWindowLoaded();

	mov	ecx, DWORD PTR ?gMainParser@@3PAVC_Parser@@A ; gMainParser
	call	?GetFirstWindowLoaded@C_Parser@@QAEJXZ	; C_Parser::GetFirstWindowLoaded
	mov	DWORD PTR _ID$[ebp], eax
$LN2@LoadTactic:

; 1296 : 	while(ID)

	cmp	DWORD PTR _ID$[ebp], 0
	je	SHORT $LN1@LoadTactic

; 1297 : 	{
; 1298 : 		HookupTacticalReferenceControls(ID);

	mov	eax, DWORD PTR _ID$[ebp]
	push	eax
	call	?HookupTacticalReferenceControls@@YAXJ@Z ; HookupTacticalReferenceControls
	add	esp, 4

; 1299 : 		ID=gMainParser->GetNextWindowLoaded();

	mov	ecx, DWORD PTR ?gMainParser@@3PAVC_Parser@@A ; gMainParser
	call	?GetNextWindowLoaded@C_Parser@@QAEJXZ	; C_Parser::GetNextWindowLoaded
	mov	DWORD PTR _ID$[ebp], eax

; 1300 : 	}

	jmp	SHORT $LN2@LoadTactic
$LN1@LoadTactic:

; 1301 : 	TACREFLoaded++;

	mov	ecx, DWORD PTR ?TACREFLoaded@@3HA	; TACREFLoaded
	add	ecx, 1
	mov	DWORD PTR ?TACREFLoaded@@3HA, ecx	; TACREFLoaded
$LN6@LoadTactic:

; 1302 : 
; 1303 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?LoadTacticalReferenceWindows@@YAXXZ ENDP		; LoadTacticalReferenceWindows
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\tacref\ui_tacref.cpp
_TEXT	SEGMENT
tv79 = -316						; size = 4
$T2 = -312						; size = 4
$T3 = -308						; size = 4
$T4 = -304						; size = 4
tv87 = -300						; size = 4
_win$ = -296						; size = 4
$T5 = -292						; size = 4
$T6 = -288						; size = 4
$T7 = -284						; size = 4
tv133 = -280						; size = 4
_tmpPath$ = -276					; size = 260
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?TacRef_Setup@@YAHXZ PROC				; TacRef_Setup

; 1226 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?TacRef_Setup@@YAHXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 304				; 00000130H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1227 : 	C_Window *win;
; 1228 : 
; 1229 : 	// RV - Biker - Add theater switching for tacref
; 1230 : 	char tmpPath[_MAX_PATH];
; 1231 : 	sprintf(tmpPath, "%s\\%s", FalconTacrefThrDirectory, "tacrefdb.bin");

	push	OFFSET ??_C@_0N@GLKIJJIP@tacrefdb?4bin?$AA@
	push	OFFSET ?FalconTacrefThrDirectory@@3PADA	; FalconTacrefThrDirectory
	push	OFFSET ??_C@_05BMGBEOOC@?$CFs?2?$CFs?$AA@
	lea	eax, DWORD PTR _tmpPath$[ebp]
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H

; 1232 : 
; 1233 : 	win=gMainHandler->FindWindow(TAC_REF_WIN);

	push	8000					; 00001f40H
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z ; C_Handler::FindWindowA
	mov	DWORD PTR _win$[ebp], eax

; 1234 : 	if(win)

	cmp	DWORD PTR _win$[ebp], 0
	je	$LN4@TacRef_Set

; 1235 : 	{
; 1236 : 		if(TAC_Viewer == NULL)

	cmp	DWORD PTR ?TAC_Viewer@@3PAVC_3dViewer@@A, 0 ; TAC_Viewer
	jne	$LN3@TacRef_Set

; 1237 : 		{
; 1238 : 			if(TAC_Viewer != NULL)

	cmp	DWORD PTR ?TAC_Viewer@@3PAVC_3dViewer@@A, 0 ; TAC_Viewer
	je	SHORT $LN8@TacRef_Set

; 1239 : 			{
; 1240 : 				TAC_Viewer->Cleanup();

	mov	ecx, DWORD PTR ?TAC_Viewer@@3PAVC_3dViewer@@A ; TAC_Viewer
	call	?Cleanup@C_3dViewer@@QAEHXZ		; C_3dViewer::Cleanup

; 1241 : 				delete TAC_Viewer;

	mov	ecx, DWORD PTR ?TAC_Viewer@@3PAVC_3dViewer@@A ; TAC_Viewer
	mov	DWORD PTR $T4[ebp], ecx
	mov	edx, DWORD PTR $T4[ebp]
	mov	DWORD PTR $T5[ebp], edx
	cmp	DWORD PTR $T5[ebp], 0
	je	SHORT $LN7@TacRef_Set
	push	1
	mov	ecx, DWORD PTR $T5[ebp]
	call	??_GC_3dViewer@@QAEPAXI@Z
	mov	DWORD PTR tv79[ebp], eax
	jmp	SHORT $LN8@TacRef_Set
$LN7@TacRef_Set:
	mov	DWORD PTR tv79[ebp], 0
$LN8@TacRef_Set:

; 1242 : 			}
; 1243 : 			CurrentModel=0;

	mov	DWORD PTR ?CurrentModel@@3JA, 0		; CurrentModel

; 1244 : 			CurrentWeapon=0;

	mov	DWORD PTR ?CurrentWeapon@@3JA, 0	; CurrentWeapon

; 1245 : 			CurrentEntity=0;

	mov	DWORD PTR ?CurrentEntity@@3JA, 0	; CurrentEntity

; 1246 : 			TAC_Viewer=new C_3dViewer;

	push	180					; 000000b4H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T6[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T6[ebp], 0
	je	SHORT $LN9@TacRef_Set
	mov	ecx, DWORD PTR $T6[ebp]
	call	??0C_3dViewer@@QAE@XZ			; C_3dViewer::C_3dViewer
	mov	DWORD PTR tv87[ebp], eax
	jmp	SHORT $LN10@TacRef_Set
$LN9@TacRef_Set:
	mov	DWORD PTR tv87[ebp], 0
$LN10@TacRef_Set:
	mov	eax, DWORD PTR tv87[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR ?TAC_Viewer@@3PAVC_3dViewer@@A, ecx ; TAC_Viewer

; 1247 : 			TAC_Viewer->Setup();

	mov	ecx, DWORD PTR ?TAC_Viewer@@3PAVC_3dViewer@@A ; TAC_Viewer
	call	?Setup@C_3dViewer@@QAEHXZ		; C_3dViewer::Setup

; 1248 : 			TAC_Viewer->Viewport(win,0);

	push	0
	mov	edx, DWORD PTR _win$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?TAC_Viewer@@3PAVC_3dViewer@@A ; TAC_Viewer
	call	?Viewport@C_3dViewer@@QAEXPAVC_Window@@J@Z ; C_3dViewer::Viewport

; 1249 : 			TAC_Viewer->Init3d(30.0f);

	push	ecx
	movss	xmm0, DWORD PTR __real@41f00000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?TAC_Viewer@@3PAVC_3dViewer@@A ; TAC_Viewer
	call	?Init3d@C_3dViewer@@QAEHM@Z		; C_3dViewer::Init3d
$LN3@TacRef_Set:

; 1250 : 		}
; 1251 : 		if(!Reference)

	cmp	DWORD PTR ?Reference@@3PAVTacticalReference@@A, 0 ; Reference
	jne	$LN1@TacRef_Set

; 1252 : 		{
; 1253 : 			Reference=new TacticalReference;

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T7[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T7[ebp], 0
	je	SHORT $LN11@TacRef_Set
	mov	ecx, DWORD PTR $T7[ebp]
	call	??0TacticalReference@@QAE@XZ		; TacticalReference::TacticalReference
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN12@TacRef_Set
$LN11@TacRef_Set:
	mov	DWORD PTR tv133[ebp], 0
$LN12@TacRef_Set:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR ?Reference@@3PAVTacticalReference@@A, ecx ; Reference

; 1254 : 			// RV - Biker - Load theater specific tacref
; 1255 : 			//Reference->Load("tacrefdb.bin");
; 1256 : 			Reference->Load(tmpPath);

	lea	edx, DWORD PTR _tmpPath$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?Reference@@3PAVTacticalReference@@A ; Reference
	call	?Load@TacticalReference@@QAEHPAD@Z	; TacticalReference::Load

; 1257 : 			SetGroupButton(CAT_AIRCRAFT);

	push	8200					; 00002008H
	call	?SetGroupButton@@YAXJ@Z			; SetGroupButton
	add	esp, 4

; 1258 : 			LoadGroup(CAT_AIRCRAFT);

	push	8200					; 00002008H
	call	?LoadGroup@@YAXJ@Z			; LoadGroup
	add	esp, 4
$LN1@TacRef_Set:

; 1259 : 		}
; 1260 : 		return(TRUE);

	mov	eax, 1
	jmp	SHORT $LN5@TacRef_Set
$LN4@TacRef_Set:

; 1261 : 	}
; 1262 : 	return(FALSE);

	xor	eax, eax
$LN5@TacRef_Set:

; 1263 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?TacRef_Setup@@YAHXZ$0:
	mov	eax, DWORD PTR $T6[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?TacRef_Setup@@YAHXZ$1:
	mov	eax, DWORD PTR $T7[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?TacRef_Setup@@YAHXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-308]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?TacRef_Setup@@YAHXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?TacRef_Setup@@YAHXZ ENDP				; TacRef_Setup
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\tacref\ui_tacref.cpp
_TEXT	SEGMENT
$T2 = -44						; size = 4
tv576 = -40						; size = 4
$T3 = -36						; size = 4
_lbox$ = -32						; size = 4
_panner$ = -28						; size = 4
_drawTimer$ = -24					; size = 4
_winme$ = -20						; size = 4
_ctrl$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_ID$ = 8						; size = 4
?HookupTacticalReferenceControls@@YAXJ@Z PROC		; HookupTacticalReferenceControls

; 1047 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?HookupTacticalReferenceControls@@YAXJ@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1048 : 	C_Window *winme;
; 1049 : 	C_Button *ctrl;
; 1050 : 	C_Panner	*panner;
; 1051 : 	C_ListBox *lbox;
; 1052 : 	C_TimerHook *drawTimer;
; 1053 : 
; 1054 : 	winme=gMainHandler->FindWindow(ID);

	mov	eax, DWORD PTR _ID$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z ; C_Handler::FindWindowA
	mov	DWORD PTR _winme$[ebp], eax

; 1055 : 
; 1056 : 	if(winme == NULL)

	cmp	DWORD PTR _winme$[ebp], 0
	jne	SHORT $LN32@HookupTact

; 1057 : 		return;

	jmp	$LN33@HookupTact
$LN32@HookupTact:

; 1058 : 
; 1059 : 	if(ID == TAC_REF_WIN)

	cmp	DWORD PTR _ID$[ebp], 8000		; 00001f40H
	jne	SHORT $LN31@HookupTact

; 1060 : 		winme->SetDragCallback(TACMoveRendererCB);

	push	OFFSET ?TACMoveRendererCB@@YAXPAVC_Window@@@Z ; TACMoveRendererCB
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?SetDragCallback@C_Window@@QAEXP6AXPAV1@@Z@Z ; C_Window::SetDragCallback
$LN31@HookupTact:

; 1061 : 																					
; 1062 : 	// Hook up AIRCRAFT SELECT button
; 1063 : 	ctrl=(C_Button *)winme->FindControl(CAT_AIRCRAFT);

	push	8200					; 00002008H
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ctrl$[ebp], eax

; 1064 : 	if(ctrl != NULL)

	cmp	DWORD PTR _ctrl$[ebp], 0
	je	SHORT $LN30@HookupTact

; 1065 : 		ctrl->SetCallback(SelectGroupCB);

	push	OFFSET ?SelectGroupCB@@YAXJFPAVC_Base@@@Z ; SelectGroupCB
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN30@HookupTact:

; 1066 : 
; 1067 : 	// Hook up VEHICLES SELECT button
; 1068 : 	ctrl=(C_Button *)winme->FindControl(CAT_VEHICLES);

	push	8300					; 0000206cH
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ctrl$[ebp], eax

; 1069 : 	if(ctrl != NULL)

	cmp	DWORD PTR _ctrl$[ebp], 0
	je	SHORT $LN29@HookupTact

; 1070 : 		ctrl->SetCallback(SelectGroupCB);

	push	OFFSET ?SelectGroupCB@@YAXJFPAVC_Base@@@Z ; SelectGroupCB
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN29@HookupTact:

; 1071 : 												
; 1072 : 	// Hook up MUNITIONS SELECT button
; 1073 : 	ctrl=(C_Button *)winme->FindControl(CAT_MUNITIONS);

	push	8400					; 000020d0H
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ctrl$[ebp], eax

; 1074 : 	if(ctrl != NULL)

	cmp	DWORD PTR _ctrl$[ebp], 0
	je	SHORT $LN28@HookupTact

; 1075 : 		ctrl->SetCallback(SelectGroupCB);

	push	OFFSET ?SelectGroupCB@@YAXJFPAVC_Base@@@Z ; SelectGroupCB
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN28@HookupTact:

; 1076 : 
; 1077 : 	// Hook up SUB AIRCRAFT FIGHTERS button
; 1078 : 	ctrl=(C_Button *)winme->FindControl(SUB_CAT_AIRCRAFT_FIGHTERS);

	push	10001					; 00002711H
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ctrl$[ebp], eax

; 1079 : 	if(ctrl != NULL)

	cmp	DWORD PTR _ctrl$[ebp], 0
	je	SHORT $LN27@HookupTact

; 1080 : 		ctrl->SetCallback(SelectSubGroupCB);

	push	OFFSET ?SelectSubGroupCB@@YAXJFPAVC_Base@@@Z ; SelectSubGroupCB
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN27@HookupTact:

; 1081 : 							
; 1082 : 	// Hook up SUB AIRCRAFT ATTACK button
; 1083 : 	ctrl=(C_Button *)winme->FindControl(SUB_CAT_AIRCRAFT_ATTACK);

	push	10008					; 00002718H
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ctrl$[ebp], eax

; 1084 : 	if(ctrl != NULL)

	cmp	DWORD PTR _ctrl$[ebp], 0
	je	SHORT $LN26@HookupTact

; 1085 : 		ctrl->SetCallback(SelectSubGroupCB);

	push	OFFSET ?SelectSubGroupCB@@YAXJFPAVC_Base@@@Z ; SelectSubGroupCB
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN26@HookupTact:

; 1086 : 							
; 1087 : 	// Hook up SUB AIRCRAFT BOMBERS button
; 1088 : 	ctrl=(C_Button *)winme->FindControl(SUB_CAT_AIRCRAFT_BOMBERS);

	push	10009					; 00002719H
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ctrl$[ebp], eax

; 1089 : 	if(ctrl != NULL)

	cmp	DWORD PTR _ctrl$[ebp], 0
	je	SHORT $LN25@HookupTact

; 1090 : 		ctrl->SetCallback(SelectSubGroupCB);

	push	OFFSET ?SelectSubGroupCB@@YAXJFPAVC_Base@@@Z ; SelectSubGroupCB
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN25@HookupTact:

; 1091 : 									
; 1092 : 	// Hook up SUB AIRCRAFT HELICOPTERS button
; 1093 : 	ctrl=(C_Button *)winme->FindControl(SUB_CAT_AIRCRAFT_HELICOPTERS);

	push	10010					; 0000271aH
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ctrl$[ebp], eax

; 1094 : 	if(ctrl != NULL)

	cmp	DWORD PTR _ctrl$[ebp], 0
	je	SHORT $LN24@HookupTact

; 1095 : 		ctrl->SetCallback(SelectSubGroupCB);

	push	OFFSET ?SelectSubGroupCB@@YAXJFPAVC_Base@@@Z ; SelectSubGroupCB
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN24@HookupTact:

; 1096 : 							
; 1097 : 	// Hook up SUB AIRCRAFT SUPPORT button
; 1098 : 	ctrl=(C_Button *)winme->FindControl(SUB_CAT_AIRCRAFT_SUPPORT);

	push	10007					; 00002717H
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ctrl$[ebp], eax

; 1099 : 	if(ctrl != NULL)

	cmp	DWORD PTR _ctrl$[ebp], 0
	je	SHORT $LN23@HookupTact

; 1100 : 		ctrl->SetCallback(SelectSubGroupCB);

	push	OFFSET ?SelectSubGroupCB@@YAXJFPAVC_Base@@@Z ; SelectSubGroupCB
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN23@HookupTact:

; 1101 : 							
; 1102 : 	// Hook up SUB AIRCRAFT EW button
; 1103 : 	ctrl=(C_Button *)winme->FindControl(SUB_CAT_AIRCRAFT_EW);

	push	10006					; 00002716H
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ctrl$[ebp], eax

; 1104 : 	if(ctrl != NULL)

	cmp	DWORD PTR _ctrl$[ebp], 0
	je	SHORT $LN22@HookupTact

; 1105 : 		ctrl->SetCallback(SelectSubGroupCB);

	push	OFFSET ?SelectSubGroupCB@@YAXJFPAVC_Base@@@Z ; SelectSubGroupCB
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN22@HookupTact:

; 1106 : 					
; 1107 : 	// Hook up SUB VEHICLES TANKS button
; 1108 : 	ctrl=(C_Button *)winme->FindControl(SUB_CAT_VEHICLES_TANKS);

	push	10002					; 00002712H
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ctrl$[ebp], eax

; 1109 : 	if(ctrl != NULL)

	cmp	DWORD PTR _ctrl$[ebp], 0
	je	SHORT $LN21@HookupTact

; 1110 : 		ctrl->SetCallback(SelectSubGroupCB);

	push	OFFSET ?SelectSubGroupCB@@YAXJFPAVC_Base@@@Z ; SelectSubGroupCB
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN21@HookupTact:

; 1111 : 							
; 1112 : 	// Hook up SUB VEHICLES IFVS button
; 1113 : 	ctrl=(C_Button *)winme->FindControl(SUB_CAT_VEHICLES_IFVS);

	push	10003					; 00002713H
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ctrl$[ebp], eax

; 1114 : 	if(ctrl != NULL)

	cmp	DWORD PTR _ctrl$[ebp], 0
	je	SHORT $LN20@HookupTact

; 1115 : 		ctrl->SetCallback(SelectSubGroupCB);

	push	OFFSET ?SelectSubGroupCB@@YAXJFPAVC_Base@@@Z ; SelectSubGroupCB
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN20@HookupTact:

; 1116 : 								
; 1117 : 	// Hook up SUB VEHICLES ARTILLERY button
; 1118 : 	ctrl=(C_Button *)winme->FindControl(SUB_CAT_VEHICLES_ARTILLERY);

	push	10011					; 0000271bH
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ctrl$[ebp], eax

; 1119 : 	if(ctrl != NULL)

	cmp	DWORD PTR _ctrl$[ebp], 0
	je	SHORT $LN19@HookupTact

; 1120 : 		ctrl->SetCallback(SelectSubGroupCB);

	push	OFFSET ?SelectSubGroupCB@@YAXJFPAVC_Base@@@Z ; SelectSubGroupCB
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN19@HookupTact:

; 1121 : 							
; 1122 : 	// Hook up SUB VEHICLES AIRDEFENSE button
; 1123 : 	ctrl=(C_Button *)winme->FindControl(SUB_CAT_VEHICLES_AIRDEFENSE);

	push	10004					; 00002714H
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ctrl$[ebp], eax

; 1124 : 	if(ctrl != NULL)

	cmp	DWORD PTR _ctrl$[ebp], 0
	je	SHORT $LN18@HookupTact

; 1125 : 		ctrl->SetCallback(SelectSubGroupCB);

	push	OFFSET ?SelectSubGroupCB@@YAXJFPAVC_Base@@@Z ; SelectSubGroupCB
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN18@HookupTact:

; 1126 : 							
; 1127 : 	// Hook up SUB VEHICLES SUPPORT button
; 1128 : 	ctrl=(C_Button *)winme->FindControl(SUB_CAT_VEHICLES_SUPPORT);

	push	10012					; 0000271cH
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ctrl$[ebp], eax

; 1129 : 	if(ctrl != NULL)

	cmp	DWORD PTR _ctrl$[ebp], 0
	je	SHORT $LN17@HookupTact

; 1130 : 		ctrl->SetCallback(SelectSubGroupCB);

	push	OFFSET ?SelectSubGroupCB@@YAXJFPAVC_Base@@@Z ; SelectSubGroupCB
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN17@HookupTact:

; 1131 : 							
; 1132 : 	// Hook up SUB VEHICLES SHIPS button
; 1133 : 	ctrl=(C_Button *)winme->FindControl(SUB_CAT_VEHICLES_SHIPS);

	push	10005					; 00002715H
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ctrl$[ebp], eax

; 1134 : 	if(ctrl != NULL)									

	cmp	DWORD PTR _ctrl$[ebp], 0
	je	SHORT $LN16@HookupTact

; 1135 : 		ctrl->SetCallback(SelectSubGroupCB);

	push	OFFSET ?SelectSubGroupCB@@YAXJFPAVC_Base@@@Z ; SelectSubGroupCB
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN16@HookupTact:

; 1136 : 			
; 1137 : 	// Hook up SUB MUNITIONS AAM button
; 1138 : 	ctrl=(C_Button *)winme->FindControl(SUB_CAT_MUNITIONS_AAM);

	push	10013					; 0000271dH
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ctrl$[ebp], eax

; 1139 : 	if(ctrl != NULL)									

	cmp	DWORD PTR _ctrl$[ebp], 0
	je	SHORT $LN15@HookupTact

; 1140 : 		ctrl->SetCallback(SelectSubGroupCB);

	push	OFFSET ?SelectSubGroupCB@@YAXJFPAVC_Base@@@Z ; SelectSubGroupCB
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN15@HookupTact:

; 1141 : 								
; 1142 : 	// Hook up SUB MUNITIONS AGM button
; 1143 : 	ctrl=(C_Button *)winme->FindControl(SUB_CAT_MUNITIONS_AGM);

	push	10014					; 0000271eH
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ctrl$[ebp], eax

; 1144 : 	if(ctrl != NULL)																

	cmp	DWORD PTR _ctrl$[ebp], 0
	je	SHORT $LN14@HookupTact

; 1145 : 		ctrl->SetCallback(SelectSubGroupCB);

	push	OFFSET ?SelectSubGroupCB@@YAXJFPAVC_Base@@@Z ; SelectSubGroupCB
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN14@HookupTact:

; 1146 : 								
; 1147 : 	// Hook up SUB MUNITIONS ARM button
; 1148 : 	ctrl=(C_Button *)winme->FindControl(SUB_CAT_MUNITIONS_ARM);

	push	10017					; 00002721H
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ctrl$[ebp], eax

; 1149 : 	if(ctrl != NULL)																

	cmp	DWORD PTR _ctrl$[ebp], 0
	je	SHORT $LN13@HookupTact

; 1150 : 		ctrl->SetCallback(SelectSubGroupCB);

	push	OFFSET ?SelectSubGroupCB@@YAXJFPAVC_Base@@@Z ; SelectSubGroupCB
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN13@HookupTact:

; 1151 : 							
; 1152 : 	// Hook up SUB MUNITIONS BOMBS button
; 1153 : 	ctrl=(C_Button *)winme->FindControl(SUB_CAT_MUNITIONS_BOMBS);

	push	10016					; 00002720H
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ctrl$[ebp], eax

; 1154 : 	if(ctrl != NULL)																

	cmp	DWORD PTR _ctrl$[ebp], 0
	je	SHORT $LN12@HookupTact

; 1155 : 		ctrl->SetCallback(SelectSubGroupCB);

	push	OFFSET ?SelectSubGroupCB@@YAXJFPAVC_Base@@@Z ; SelectSubGroupCB
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN12@HookupTact:

; 1156 : 								
; 1157 : 	// Hook up SUB MUNITIONS STORES button
; 1158 : 	ctrl=(C_Button *)winme->FindControl(SUB_CAT_MUNITIONS_STORES);

	push	10018					; 00002722H
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ctrl$[ebp], eax

; 1159 : 	if(ctrl != NULL)																

	cmp	DWORD PTR _ctrl$[ebp], 0
	je	SHORT $LN11@HookupTact

; 1160 : 		ctrl->SetCallback(SelectSubGroupCB);

	push	OFFSET ?SelectSubGroupCB@@YAXJFPAVC_Base@@@Z ; SelectSubGroupCB
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN11@HookupTact:

; 1161 : 								
; 1162 : 	// Hook up SUB MUNITIONS GROUND button
; 1163 : 	ctrl=(C_Button *)winme->FindControl(SUB_CAT_MUNITIONS_GROUND);

	push	10015					; 0000271fH
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ctrl$[ebp], eax

; 1164 : 	if(ctrl != NULL)																						

	cmp	DWORD PTR _ctrl$[ebp], 0
	je	SHORT $LN10@HookupTact

; 1165 : 		ctrl->SetCallback(SelectSubGroupCB);

	push	OFFSET ?SelectSubGroupCB@@YAXJFPAVC_Base@@@Z ; SelectSubGroupCB
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN10@HookupTact:

; 1166 : 
; 1167 : 	// Hook up Close Button
; 1168 : 	ctrl=(C_Button *)winme->FindControl(CLOSE_WINDOW);

	push	80001					; 00013881H
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ctrl$[ebp], eax

; 1169 : 	if(ctrl != NULL)

	cmp	DWORD PTR _ctrl$[ebp], 0
	je	SHORT $LN9@HookupTact

; 1170 : 		ctrl->SetCallback(TACREFCloseWindowCB);

	push	OFFSET ?TACREFCloseWindowCB@@YAXJFPAVC_Base@@@Z ; TACREFCloseWindowCB
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN9@HookupTact:

; 1171 : 
; 1172 : 	// for ROTATION
; 1173 : 	panner = (C_Panner *)winme->FindControl(TACREF_PANNER);

	push	8013					; 00001f4dH
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _panner$[ebp], eax

; 1174 : 	if(panner != NULL)

	cmp	DWORD PTR _panner$[ebp], 0
	je	SHORT $LN8@HookupTact

; 1175 : 		panner->SetCallback( TACREF_PannerCB );

	push	OFFSET ?TACREF_PannerCB@@YAXJFPAVC_Base@@@Z ; TACREF_PannerCB
	mov	ecx, DWORD PTR _panner$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _panner$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN8@HookupTact:

; 1176 : 
; 1177 : 	// for ZOOM
; 1178 : 	panner = (C_Panner *)winme->FindControl(TACREF_ZOOMER);

	push	8014					; 00001f4eH
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _panner$[ebp], eax

; 1179 : 	if(panner != NULL)

	cmp	DWORD PTR _panner$[ebp], 0
	je	SHORT $LN7@HookupTact

; 1180 : 		panner->SetCallback( TACREF_ZoomCB);

	push	OFFSET ?TACREF_ZoomCB@@YAXJFPAVC_Base@@@Z ; TACREF_ZoomCB
	mov	ecx, DWORD PTR _panner$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _panner$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN7@HookupTact:

; 1181 : 	
; 1182 : 	lbox=(C_ListBox *)winme->FindControl(ENTITY_LIST);

	push	8015					; 00001f4fH
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _lbox$[ebp], eax

; 1183 : 	if(lbox != NULL)

	cmp	DWORD PTR _lbox$[ebp], 0
	je	SHORT $LN6@HookupTact

; 1184 : 		lbox->SetCallback(SelectEntityCB);

	push	OFFSET ?SelectEntityCB@@YAXJFPAVC_Base@@@Z ; SelectEntityCB
	mov	ecx, DWORD PTR _lbox$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _lbox$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN6@HookupTact:

; 1185 : 
; 1186 : 
; 1187 : 	// RWR LISTBOX
; 1188 : 	lbox=(C_ListBox *)winme->FindControl(RWR_LIST);

	push	8407					; 000020d7H
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _lbox$[ebp], eax

; 1189 : 	if(lbox != NULL)

	cmp	DWORD PTR _lbox$[ebp], 0
	je	SHORT $LN5@HookupTact

; 1190 : 		lbox->SetCallback(SelectRWRCB);

	push	OFFSET ?SelectRWRCB@@YAXJFPAVC_Base@@@Z	; SelectRWRCB
	mov	ecx, DWORD PTR _lbox$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _lbox$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN5@HookupTact:

; 1191 : 
; 1192 : 
; 1193 : 	// Hook up RWR Search Tone
; 1194 : 	ctrl=(C_Button *)winme->FindControl(PLAY_SEARCH_TONE);

	push	8011					; 00001f4bH
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ctrl$[ebp], eax

; 1195 : 	if(ctrl != NULL)

	cmp	DWORD PTR _ctrl$[ebp], 0
	je	SHORT $LN4@HookupTact

; 1196 : 		ctrl->SetCallback(PlaySoundCB);

	push	OFFSET ?PlaySoundCB@@YAXJFPAVC_Base@@@Z	; PlaySoundCB
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN4@HookupTact:

; 1197 : 					
; 1198 : 	// Hook up RWR Lock Tone
; 1199 : 	ctrl=(C_Button *)winme->FindControl(PLAY_LOCK_TONE);

	push	8012					; 00001f4cH
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ctrl$[ebp], eax

; 1200 : 	if(ctrl != NULL)

	cmp	DWORD PTR _ctrl$[ebp], 0
	je	SHORT $LN3@HookupTact

; 1201 : 		ctrl->SetCallback(PlaySoundCB);

	push	OFFSET ?PlaySoundCB@@YAXJFPAVC_Base@@@Z	; PlaySoundCB
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN3@HookupTact:

; 1202 : 
; 1203 : // Help GUIDE thing
; 1204 : 	ctrl=(C_Button*)winme->FindControl(UI_HELP_GUIDE);

	push	2501					; 000009c5H
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ctrl$[ebp], eax

; 1205 : 	if(ctrl)

	cmp	DWORD PTR _ctrl$[ebp], 0
	je	SHORT $LN2@HookupTact

; 1206 : 		ctrl->SetCallback(UI_Help_Guide_CB);

	push	OFFSET ?UI_Help_Guide_CB@@YAXJFPAVC_Base@@@Z ; UI_Help_Guide_CB
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN2@HookupTact:

; 1207 : 
; 1208 : 	if(ID == TAC_REF_WIN)

	cmp	DWORD PTR _ID$[ebp], 8000		; 00001f40H
	jne	$LN33@HookupTact

; 1209 : 	{
; 1210 : 		ReplaceDummyControl(winme);

	mov	ecx, DWORD PTR _winme$[ebp]
	push	ecx
	call	?ReplaceDummyControl@@YAXPAVC_Window@@@Z ; ReplaceDummyControl
	add	esp, 4

; 1211 : 
; 1212 : 		drawTimer = new C_TimerHook;

	push	68					; 00000044H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN35@HookupTact
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0C_TimerHook@@QAE@XZ			; C_TimerHook::C_TimerHook
	mov	DWORD PTR tv576[ebp], eax
	jmp	SHORT $LN36@HookupTact
$LN35@HookupTact:
	mov	DWORD PTR tv576[ebp], 0
$LN36@HookupTact:
	mov	edx, DWORD PTR tv576[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _drawTimer$[ebp], eax

; 1213 : 		drawTimer->Setup( C_DONT_CARE,C_TYPE_NORMAL );

	push	25					; 00000019H
	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _drawTimer$[ebp]
	call	?Setup@C_TimerHook@@QAEXJF@Z		; C_TimerHook::Setup

; 1214 : 		drawTimer->SetClient(0);

	push	0
	mov	ecx, DWORD PTR _drawTimer$[ebp]
	call	?SetClient@C_Base@@QAEXF@Z		; C_Base::SetClient

; 1215 : 		drawTimer->SetXY(winme->ClientArea_[0].left,winme->ClientArea_[0].top);

	mov	ecx, 16					; 00000010H
	imul	ecx, 0
	mov	edx, DWORD PTR _winme$[ebp]
	mov	eax, DWORD PTR [edx+ecx+172]
	push	eax
	mov	ecx, 16					; 00000010H
	imul	ecx, 0
	mov	edx, DWORD PTR _winme$[ebp]
	mov	eax, DWORD PTR [edx+ecx+168]
	push	eax
	mov	ecx, DWORD PTR _drawTimer$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _drawTimer$[ebp]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1216 : 		drawTimer->SetW(winme->ClientArea_[0].right - winme->ClientArea_[0].left);

	mov	ecx, 16					; 00000010H
	imul	ecx, 0
	mov	edx, 16					; 00000010H
	imul	edx, 0
	mov	eax, DWORD PTR _winme$[ebp]
	mov	esi, DWORD PTR _winme$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+176]
	sub	ecx, DWORD PTR [esi+edx+168]
	push	ecx
	mov	edx, DWORD PTR _drawTimer$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _drawTimer$[ebp]
	mov	edx, DWORD PTR [eax+24]
	call	edx

; 1217 : 		drawTimer->SetH(winme->ClientArea_[0].bottom - winme->ClientArea_[0].top);

	mov	eax, 16					; 00000010H
	imul	eax, 0
	mov	ecx, 16					; 00000010H
	imul	ecx, 0
	mov	edx, DWORD PTR _winme$[ebp]
	mov	esi, DWORD PTR _winme$[ebp]
	mov	eax, DWORD PTR [edx+eax+180]
	sub	eax, DWORD PTR [esi+ecx+172]
	push	eax
	mov	ecx, DWORD PTR _drawTimer$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _drawTimer$[ebp]
	mov	eax, DWORD PTR [edx+28]
	call	eax

; 1218 : 		drawTimer->SetUpdateCallback(TACREF_ViewTimerAnimCB );

	push	OFFSET ?TACREF_ViewTimerAnimCB@@YAXJFPAVC_Base@@@Z ; TACREF_ViewTimerAnimCB
	mov	ecx, DWORD PTR _drawTimer$[ebp]
	call	?SetUpdateCallback@C_TimerHook@@QAEXP6AXJFPAVC_Base@@@Z@Z ; C_TimerHook::SetUpdateCallback

; 1219 : 		drawTimer->SetReady( 1);

	push	1
	mov	ecx, DWORD PTR _drawTimer$[ebp]
	call	?SetReady@C_Base@@QAEXF@Z		; C_Base::SetReady

; 1220 : 		drawTimer->SetUserNumber(_UI95_TIMER_DELAY_,1);

	push	1
	push	4
	mov	ecx, DWORD PTR _drawTimer$[ebp]
	call	?SetUserNumber@C_Base@@QAEXJJ@Z		; C_Base::SetUserNumber

; 1221 : 		winme->AddControl( drawTimer );

	mov	ecx, DWORD PTR _drawTimer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?AddControl@C_Window@@QAEXPAVC_Base@@@Z	; C_Window::AddControl
$LN33@HookupTact:

; 1222 : 	}
; 1223 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?HookupTacticalReferenceControls@@YAXJ@Z$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?HookupTacticalReferenceControls@@YAXJ@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?HookupTacticalReferenceControls@@YAXJ@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?HookupTacticalReferenceControls@@YAXJ@Z ENDP		; HookupTacticalReferenceControls
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\tacref\ui_tacref.cpp
_TEXT	SEGMENT
_Leave$ = -48						; size = 4
tv210 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
tv80 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
_cur$ = -20						; size = 4
_objectviewer$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_win$ = 8						; size = 4
?ReplaceDummyControl@@YAXPAVC_Window@@@Z PROC		; ReplaceDummyControl

; 1013 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ReplaceDummyControl@@YAXPAVC_Window@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1014 : 	CONTROLLIST *cur;
; 1015 : 	C_TimerHook *objectviewer;
; 1016 : 	F4CSECTIONHANDLE *Leave;
; 1017 : 
; 1018 : 	cur=win->GetControlList();

	mov	ecx, DWORD PTR _win$[ebp]
	call	?GetControlList@C_Window@@QAEPAUControlListStr@@XZ ; C_Window::GetControlList
	mov	DWORD PTR _cur$[ebp], eax
$LN3@ReplaceDum:

; 1019 : 	while(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	$LN4@ReplaceDum

; 1020 : 	{
; 1021 : 		if(cur->Control_->GetID() == TACREF_SCAB_CTRL)

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetID@C_Base@@QAEJXZ			; C_Base::GetID
	cmp	eax, 8410				; 000020daH
	jne	$LN1@ReplaceDum

; 1022 : 		{
; 1023 : 			Leave=UI_Enter(win);

	mov	ecx, DWORD PTR _win$[ebp]
	push	ecx
	call	?UI_Enter@@YAPAUF4CSECTIONHANDLE@@PAVC_Window@@@Z ; UI_Enter
	add	esp, 4
	mov	DWORD PTR _Leave$[ebp], eax

; 1024 : 			objectviewer = new C_TimerHook;

	push	68					; 00000044H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T4[ebp], 0
	je	SHORT $LN6@ReplaceDum
	mov	ecx, DWORD PTR $T4[ebp]
	call	??0C_TimerHook@@QAE@XZ			; C_TimerHook::C_TimerHook
	mov	DWORD PTR tv80[ebp], eax
	jmp	SHORT $LN7@ReplaceDum
$LN6@ReplaceDum:
	mov	DWORD PTR tv80[ebp], 0
$LN7@ReplaceDum:
	mov	edx, DWORD PTR tv80[ebp]
	mov	DWORD PTR $T3[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR _objectviewer$[ebp], eax

; 1025 : 			objectviewer->Setup( C_DONT_CARE,C_TYPE_NORMAL );

	push	25					; 00000019H
	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _objectviewer$[ebp]
	call	?Setup@C_TimerHook@@QAEXJF@Z		; C_TimerHook::Setup

; 1026 : 			objectviewer->SetClient(0);

	push	0
	mov	ecx, DWORD PTR _objectviewer$[ebp]
	call	?SetClient@C_Base@@QAEXF@Z		; C_Base::SetClient

; 1027 : 			objectviewer->SetXY(win->ClientArea_[0].left,win->ClientArea_[0].top);

	mov	ecx, 16					; 00000010H
	imul	ecx, 0
	mov	edx, DWORD PTR _win$[ebp]
	mov	eax, DWORD PTR [edx+ecx+172]
	push	eax
	mov	ecx, 16					; 00000010H
	imul	ecx, 0
	mov	edx, DWORD PTR _win$[ebp]
	mov	eax, DWORD PTR [edx+ecx+168]
	push	eax
	mov	ecx, DWORD PTR _objectviewer$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _objectviewer$[ebp]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1028 : 			objectviewer->SetW(win->ClientArea_[0].right - win->ClientArea_[0].left);

	mov	ecx, 16					; 00000010H
	imul	ecx, 0
	mov	edx, 16					; 00000010H
	imul	edx, 0
	mov	eax, DWORD PTR _win$[ebp]
	mov	esi, DWORD PTR _win$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+176]
	sub	ecx, DWORD PTR [esi+edx+168]
	push	ecx
	mov	edx, DWORD PTR _objectviewer$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _objectviewer$[ebp]
	mov	edx, DWORD PTR [eax+24]
	call	edx

; 1029 : 			objectviewer->SetH(win->ClientArea_[0].bottom - win->ClientArea_[0].top);

	mov	eax, 16					; 00000010H
	imul	eax, 0
	mov	ecx, 16					; 00000010H
	imul	ecx, 0
	mov	edx, DWORD PTR _win$[ebp]
	mov	esi, DWORD PTR _win$[ebp]
	mov	eax, DWORD PTR [edx+eax+180]
	sub	eax, DWORD PTR [esi+ecx+172]
	push	eax
	mov	ecx, DWORD PTR _objectviewer$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _objectviewer$[ebp]
	mov	eax, DWORD PTR [edx+28]
	call	eax

; 1030 : 			objectviewer->SetRefreshCallback(TACREF_ViewTimerCB); // new

	push	OFFSET ?TACREF_ViewTimerCB@@YAXJFPAVC_Base@@@Z ; TACREF_ViewTimerCB
	mov	ecx, DWORD PTR _objectviewer$[ebp]
	call	?SetRefreshCallback@C_TimerHook@@QAEXP6AXJFPAVC_Base@@@Z@Z ; C_TimerHook::SetRefreshCallback

; 1031 : 			objectviewer->SetDrawCallback(TACREF_ViewBSPObjectCB);

	push	OFFSET ?TACREF_ViewBSPObjectCB@@YAXJFPAVC_Base@@@Z ; TACREF_ViewBSPObjectCB
	mov	ecx, DWORD PTR _objectviewer$[ebp]
	call	?SetDrawCallback@C_TimerHook@@QAEXP6AXJFPAVC_Base@@@Z@Z ; C_TimerHook::SetDrawCallback

; 1032 : 			objectviewer->SetFlagBitOff( C_BIT_TIMER );

	push	65536					; 00010000H
	mov	ecx, DWORD PTR _objectviewer$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _objectviewer$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 1033 : 			objectviewer->SetReady( 1);

	push	1
	mov	ecx, DWORD PTR _objectviewer$[ebp]
	call	?SetReady@C_Base@@QAEXF@Z		; C_Base::SetReady

; 1034 : 			objectviewer->SetParent(win);

	mov	ecx, DWORD PTR _win$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _objectviewer$[ebp]
	call	?SetParent@C_Base@@QAEXPAVC_Window@@@Z	; C_Base::SetParent

; 1035 : 
; 1036 : 			cur->Control_->Cleanup();

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+176]
	call	eax

; 1037 : 			delete cur->Control_;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T2[ebp], edx
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T5[ebp], eax
	cmp	DWORD PTR $T5[ebp], 0
	je	SHORT $LN8@ReplaceDum
	push	1
	mov	ecx, DWORD PTR $T5[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T5[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv210[ebp], eax
	jmp	SHORT $LN9@ReplaceDum
$LN8@ReplaceDum:
	mov	DWORD PTR tv210[ebp], 0
$LN9@ReplaceDum:

; 1038 : 			cur->Control_=objectviewer;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _objectviewer$[ebp]
	mov	DWORD PTR [ecx], edx

; 1039 : 			UI_Leave(Leave);

	mov	eax, DWORD PTR _Leave$[ebp]
	push	eax
	call	?UI_Leave@@YAXPAUF4CSECTIONHANDLE@@@Z	; UI_Leave
	add	esp, 4

; 1040 : 			return;

	jmp	SHORT $LN4@ReplaceDum
$LN1@ReplaceDum:

; 1041 : 		}
; 1042 : 		cur=cur->Next;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _cur$[ebp], edx

; 1043 : 	}

	jmp	$LN3@ReplaceDum
$LN4@ReplaceDum:

; 1044 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?ReplaceDummyControl@@YAXPAVC_Window@@@Z$0:
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?ReplaceDummyControl@@YAXPAVC_Window@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ReplaceDummyControl@@YAXPAVC_Window@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ReplaceDummyControl@@YAXPAVC_Window@@@Z ENDP		; ReplaceDummyControl
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\tacref\ui_tacref.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_hittype$ = 12						; size = 2
_control$ = 16						; size = 4
?PlaySoundCB@@YAXJFPAVC_Base@@@Z PROC			; PlaySoundCB

; 984  : {

	push	ebp
	mov	ebp, esp

; 985  : 	if(hittype != C_TYPE_LMOUSEUP)

	movsx	eax, WORD PTR _hittype$[ebp]
	cmp	eax, 52					; 00000034H
	je	SHORT $LN7@PlaySoundC

; 986  : 		return;

	jmp	$LN8@PlaySoundC
$LN7@PlaySoundC:

; 987  : 
; 988  : 	if(control->GetState())

	mov	ecx, DWORD PTR _control$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _control$[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN6@PlaySoundC

; 989  : 	{
; 990  : 		if (SFX_DEF) // JB 010425

	cmp	DWORD PTR ?SFX_DEF@@3PAUSfxDef@@A, 0	; SFX_DEF
	je	SHORT $LN5@PlaySoundC

; 991  : 			F4StopSound (SFX_DEF[LastLockTone].handle);

	mov	edx, DWORD PTR ?LastLockTone@@3HA	; LastLockTone
	imul	edx, 140				; 0000008cH
	mov	eax, DWORD PTR ?SFX_DEF@@3PAUSfxDef@@A	; SFX_DEF
	mov	ecx, DWORD PTR [eax+edx+72]
	push	ecx
	call	_F4StopSound
	add	esp, 4
$LN5@PlaySoundC:

; 992  : 
; 993  : 		LastLockTone=control->GetUserNumber(0);

	push	0
	mov	ecx, DWORD PTR _control$[ebp]
	call	?GetUserNumber@C_Base@@QAEJJ@Z		; C_Base::GetUserNumber
	mov	DWORD PTR ?LastLockTone@@3HA, eax	; LastLockTone

; 994  : 		
; 995  : 		if(SFX_DEF && LastLockTone != -1) // JB 010425

	cmp	DWORD PTR ?SFX_DEF@@3PAUSfxDef@@A, 0	; SFX_DEF
	je	SHORT $LN4@PlaySoundC
	cmp	DWORD PTR ?LastLockTone@@3HA, -1	; LastLockTone
	je	SHORT $LN4@PlaySoundC

; 996  : 			F4LoopSound (SFX_DEF[LastLockTone].handle);

	mov	edx, DWORD PTR ?LastLockTone@@3HA	; LastLockTone
	imul	edx, 140				; 0000008cH
	mov	eax, DWORD PTR ?SFX_DEF@@3PAUSfxDef@@A	; SFX_DEF
	mov	ecx, DWORD PTR [eax+edx+72]
	push	ecx
	call	_F4LoopSound
	add	esp, 4
$LN4@PlaySoundC:

; 997  : 	}

	jmp	SHORT $LN8@PlaySoundC
$LN6@PlaySoundC:

; 998  : 	else if(LastLockTone != -1)

	cmp	DWORD PTR ?LastLockTone@@3HA, -1	; LastLockTone
	je	SHORT $LN8@PlaySoundC

; 999  : 	{
; 1000 : 		if (SFX_DEF) // JB 010425

	cmp	DWORD PTR ?SFX_DEF@@3PAUSfxDef@@A, 0	; SFX_DEF
	je	SHORT $LN1@PlaySoundC

; 1001 : 			F4StopSound (SFX_DEF[LastLockTone].handle);

	mov	edx, DWORD PTR ?LastLockTone@@3HA	; LastLockTone
	imul	edx, 140				; 0000008cH
	mov	eax, DWORD PTR ?SFX_DEF@@3PAUSfxDef@@A	; SFX_DEF
	mov	ecx, DWORD PTR [eax+edx+72]
	push	ecx
	call	_F4StopSound
	add	esp, 4
$LN1@PlaySoundC:

; 1002 : 
; 1003 : 		LastLockTone=-1;

	mov	DWORD PTR ?LastLockTone@@3HA, -1	; LastLockTone
$LN8@PlaySoundC:

; 1004 : 	}
; 1005 : }

	pop	ebp
	ret	0
?PlaySoundCB@@YAXJFPAVC_Base@@@Z ENDP			; PlaySoundCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\tacref\ui_tacref.cpp
_TEXT	SEGMENT
_lbox$ = -4						; size = 4
_ID$ = 8						; size = 4
_hittype$ = 12						; size = 2
_control$ = 16						; size = 4
?SelectRWRCB@@YAXJFPAVC_Base@@@Z PROC			; SelectRWRCB

; 972  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 973  : 	C_ListBox *lbox=(C_ListBox*)control;

	mov	eax, DWORD PTR _control$[ebp]
	mov	DWORD PTR _lbox$[ebp], eax

; 974  : 
; 975  : 	if(hittype != C_TYPE_SELECT)

	movsx	ecx, WORD PTR _hittype$[ebp]
	cmp	ecx, 28					; 0000001cH
	je	SHORT $LN1@SelectRWRC

; 976  : 		return;

	jmp	SHORT $LN2@SelectRWRC
$LN1@SelectRWRC:

; 977  : 
; 978  : 	StopRWRSounds();

	call	?StopRWRSounds@@YAXXZ			; StopRWRSounds

; 979  : 	ID=lbox->GetTextID();

	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?GetTextID@C_ListBox@@QAEJXZ		; C_ListBox::GetTextID
	mov	DWORD PTR _ID$[ebp], eax

; 980  : 	SelectRWR(ID);

	mov	edx, DWORD PTR _ID$[ebp]
	push	edx
	call	?SelectRWR@@YAXJ@Z			; SelectRWR
	add	esp, 4
$LN2@SelectRWRC:

; 981  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SelectRWRCB@@YAXJFPAVC_Base@@@Z ENDP			; SelectRWRCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\tacref\ui_tacref.cpp
_TEXT	SEGMENT
_Leave$ = -8						; size = 4
_lbox$ = -4						; size = 4
_ID$ = 8						; size = 4
_hittype$ = 12						; size = 2
_control$ = 16						; size = 4
?SelectEntityCB@@YAXJFPAVC_Base@@@Z PROC		; SelectEntityCB

; 957  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 958  : 	F4CSECTIONHANDLE *Leave;
; 959  : 	C_ListBox *lbox=(C_ListBox*)control;

	mov	eax, DWORD PTR _control$[ebp]
	mov	DWORD PTR _lbox$[ebp], eax

; 960  : 
; 961  : 	if(hittype != C_TYPE_SELECT)

	movsx	ecx, WORD PTR _hittype$[ebp]
	cmp	ecx, 28					; 0000001cH
	je	SHORT $LN1@SelectEnti

; 962  : 		return;

	jmp	SHORT $LN2@SelectEnti
$LN1@SelectEnti:

; 963  : 
; 964  : 	StopRWRSounds();

	call	?StopRWRSounds@@YAXXZ			; StopRWRSounds

; 965  : 	Leave=UI_Enter(control->Parent_);

	mov	edx, DWORD PTR _control$[ebp]
	mov	eax, DWORD PTR [edx+48]
	push	eax
	call	?UI_Enter@@YAPAUF4CSECTIONHANDLE@@PAVC_Window@@@Z ; UI_Enter
	add	esp, 4
	mov	DWORD PTR _Leave$[ebp], eax

; 966  : 	ID=lbox->GetTextID();

	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?GetTextID@C_ListBox@@QAEJXZ		; C_ListBox::GetTextID
	mov	DWORD PTR _ID$[ebp], eax

; 967  : 	LoadEntity(ID);

	mov	ecx, DWORD PTR _ID$[ebp]
	push	ecx
	call	?LoadEntity@@YAXJ@Z			; LoadEntity
	add	esp, 4

; 968  : 	UI_Leave(Leave);

	mov	edx, DWORD PTR _Leave$[ebp]
	push	edx
	call	?UI_Leave@@YAXPAUF4CSECTIONHANDLE@@@Z	; UI_Leave
	add	esp, 4
$LN2@SelectEnti:

; 969  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SelectEntityCB@@YAXJFPAVC_Base@@@Z ENDP		; SelectEntityCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\tacref\ui_tacref.cpp
_TEXT	SEGMENT
_Leave$ = -4						; size = 4
_ID$ = 8						; size = 4
_hittype$ = 12						; size = 2
_control$ = 16						; size = 4
?SelectSubGroupCB@@YAXJFPAVC_Base@@@Z PROC		; SelectSubGroupCB

; 945  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 946  : 	F4CSECTIONHANDLE *Leave;
; 947  : 	if(hittype != C_TYPE_LMOUSEUP)

	movsx	eax, WORD PTR _hittype$[ebp]
	cmp	eax, 52					; 00000034H
	je	SHORT $LN1@SelectSubG

; 948  : 		return;

	jmp	SHORT $LN2@SelectSubG
$LN1@SelectSubG:

; 949  : 
; 950  : 	StopRWRSounds();

	call	?StopRWRSounds@@YAXXZ			; StopRWRSounds

; 951  : 	Leave=UI_Enter(control->Parent_);

	mov	ecx, DWORD PTR _control$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	push	edx
	call	?UI_Enter@@YAPAUF4CSECTIONHANDLE@@PAVC_Window@@@Z ; UI_Enter
	add	esp, 4
	mov	DWORD PTR _Leave$[ebp], eax

; 952  : 	LoadSubGroup(ID);

	mov	eax, DWORD PTR _ID$[ebp]
	push	eax
	call	?LoadSubGroup@@YAXJ@Z			; LoadSubGroup
	add	esp, 4

; 953  : 	UI_Leave(Leave);

	mov	ecx, DWORD PTR _Leave$[ebp]
	push	ecx
	call	?UI_Leave@@YAXPAUF4CSECTIONHANDLE@@@Z	; UI_Leave
	add	esp, 4
$LN2@SelectSubG:

; 954  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SelectSubGroupCB@@YAXJFPAVC_Base@@@Z ENDP		; SelectSubGroupCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\tacref\ui_tacref.cpp
_TEXT	SEGMENT
_Leave$ = -4						; size = 4
_ID$ = 8						; size = 4
_hittype$ = 12						; size = 2
_control$ = 16						; size = 4
?SelectGroupCB@@YAXJFPAVC_Base@@@Z PROC			; SelectGroupCB

; 923  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 924  : 	F4CSECTIONHANDLE *Leave;
; 925  : 	if(hittype != C_TYPE_LMOUSEUP)

	movsx	eax, WORD PTR _hittype$[ebp]
	cmp	eax, 52					; 00000034H
	je	SHORT $LN4@SelectGrou

; 926  : 		return;

	jmp	$LN5@SelectGrou
$LN4@SelectGrou:

; 927  : 
; 928  : 	StopRWRSounds();

	call	?StopRWRSounds@@YAXXZ			; StopRWRSounds

; 929  : 	Leave=UI_Enter(control->Parent_);

	mov	ecx, DWORD PTR _control$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	push	edx
	call	?UI_Enter@@YAPAUF4CSECTIONHANDLE@@PAVC_Window@@@Z ; UI_Enter
	add	esp, 4
	mov	DWORD PTR _Leave$[ebp], eax

; 930  : 
; 931  : 	// Hide/Unhide SubCat buttons
; 932  : 	if(control->GetUserNumber(1))

	push	1
	mov	ecx, DWORD PTR _control$[ebp]
	call	?GetUserNumber@C_Base@@QAEJJ@Z		; C_Base::GetUserNumber
	test	eax, eax
	je	SHORT $LN3@SelectGrou

; 933  : 		control->Parent_->HideCluster(control->GetUserNumber(1));

	push	1
	mov	ecx, DWORD PTR _control$[ebp]
	call	?GetUserNumber@C_Base@@QAEJJ@Z		; C_Base::GetUserNumber
	push	eax
	mov	eax, DWORD PTR _control$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	call	?HideCluster@C_Window@@QAEXJ@Z		; C_Window::HideCluster
$LN3@SelectGrou:

; 934  : 	if(control->GetUserNumber(2))

	push	2
	mov	ecx, DWORD PTR _control$[ebp]
	call	?GetUserNumber@C_Base@@QAEJJ@Z		; C_Base::GetUserNumber
	test	eax, eax
	je	SHORT $LN2@SelectGrou

; 935  : 		control->Parent_->HideCluster(control->GetUserNumber(2));

	push	2
	mov	ecx, DWORD PTR _control$[ebp]
	call	?GetUserNumber@C_Base@@QAEJJ@Z		; C_Base::GetUserNumber
	push	eax
	mov	ecx, DWORD PTR _control$[ebp]
	mov	ecx, DWORD PTR [ecx+48]
	call	?HideCluster@C_Window@@QAEXJ@Z		; C_Window::HideCluster
$LN2@SelectGrou:

; 936  : 	if(control->GetUserNumber(0))

	push	0
	mov	ecx, DWORD PTR _control$[ebp]
	call	?GetUserNumber@C_Base@@QAEJJ@Z		; C_Base::GetUserNumber
	test	eax, eax
	je	SHORT $LN1@SelectGrou

; 937  : 		control->Parent_->UnHideCluster(control->GetUserNumber(0));

	push	0
	mov	ecx, DWORD PTR _control$[ebp]
	call	?GetUserNumber@C_Base@@QAEJJ@Z		; C_Base::GetUserNumber
	push	eax
	mov	edx, DWORD PTR _control$[ebp]
	mov	ecx, DWORD PTR [edx+48]
	call	?UnHideCluster@C_Window@@QAEXJ@Z	; C_Window::UnHideCluster
$LN1@SelectGrou:

; 938  : 
; 939  : 	LoadGroup(ID);

	mov	eax, DWORD PTR _ID$[ebp]
	push	eax
	call	?LoadGroup@@YAXJ@Z			; LoadGroup
	add	esp, 4

; 940  : 
; 941  : 	UI_Leave(Leave);

	mov	ecx, DWORD PTR _Leave$[ebp]
	push	ecx
	call	?UI_Leave@@YAXPAUF4CSECTIONHANDLE@@@Z	; UI_Leave
	add	esp, 4
$LN5@SelectGrou:

; 942  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SelectGroupCB@@YAXJFPAVC_Base@@@Z ENDP			; SelectGroupCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\tacref\ui_tacref.cpp
_TEXT	SEGMENT
tv64 = -8						; size = 4
_SubGroupID$ = -4					; size = 4
_GroupID$ = 8						; size = 4
?LoadGroup@@YAXJ@Z PROC					; LoadGroup

; 900  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 901  : 	long SubGroupID;
; 902  : 
; 903  : 	switch(GroupID)

	mov	eax, DWORD PTR _GroupID$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 8200		; 00002008H
	je	SHORT $LN4@LoadGroup
	cmp	DWORD PTR tv64[ebp], 8300		; 0000206cH
	je	SHORT $LN3@LoadGroup
	cmp	DWORD PTR tv64[ebp], 8400		; 000020d0H
	je	SHORT $LN2@LoadGroup
	jmp	SHORT $LN1@LoadGroup
$LN4@LoadGroup:

; 904  : 	{
; 905  : 		case CAT_AIRCRAFT:
; 906  : 			SubGroupID=SUB_CAT_AIRCRAFT_FIGHTERS;

	mov	DWORD PTR _SubGroupID$[ebp], 10001	; 00002711H

; 907  : 			break;

	jmp	SHORT $LN5@LoadGroup
$LN3@LoadGroup:

; 908  : 		case CAT_VEHICLES:
; 909  : 			SubGroupID=SUB_CAT_VEHICLES_TANKS;

	mov	DWORD PTR _SubGroupID$[ebp], 10002	; 00002712H

; 910  : 			break;

	jmp	SHORT $LN5@LoadGroup
$LN2@LoadGroup:

; 911  : 		case CAT_MUNITIONS:
; 912  : 			SubGroupID=SUB_CAT_MUNITIONS_AAM;

	mov	DWORD PTR _SubGroupID$[ebp], 10013	; 0000271dH

; 913  : 			break;

	jmp	SHORT $LN5@LoadGroup
$LN1@LoadGroup:

; 914  : 		default:
; 915  : 			SubGroupID=0;

	mov	DWORD PTR _SubGroupID$[ebp], 0
$LN5@LoadGroup:

; 916  : 			break;
; 917  : 	}
; 918  : 	SetSubGroupButton(SubGroupID);

	mov	ecx, DWORD PTR _SubGroupID$[ebp]
	push	ecx
	call	?SetSubGroupButton@@YAXJ@Z		; SetSubGroupButton
	add	esp, 4

; 919  : 	LoadSubGroup(SubGroupID);

	mov	edx, DWORD PTR _SubGroupID$[ebp]
	push	edx
	call	?LoadSubGroup@@YAXJ@Z			; LoadSubGroup
	add	esp, 4

; 920  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?LoadGroup@@YAXJ@Z ENDP					; LoadGroup
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\tacref\ui_tacref.cpp
_TEXT	SEGMENT
_EntID$ = -4						; size = 4
_SubGroupID$ = 8					; size = 4
?LoadSubGroup@@YAXJ@Z PROC				; LoadSubGroup

; 892  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 893  : 	long EntID;
; 894  : 	EntID=InfoToWindow(SubGroupID);

	mov	eax, DWORD PTR _SubGroupID$[ebp]
	push	eax
	call	?InfoToWindow@@YAJJ@Z			; InfoToWindow
	add	esp, 4
	mov	DWORD PTR _EntID$[ebp], eax

; 895  : 	LoadEntity(EntID);

	mov	ecx, DWORD PTR _EntID$[ebp]
	push	ecx
	call	?LoadEntity@@YAXJ@Z			; LoadEntity
	add	esp, 4

; 896  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?LoadSubGroup@@YAXJ@Z ENDP				; LoadSubGroup
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\tacref\ui_tacref.cpp
_TEXT	SEGMENT
_ent$ = -4						; size = 4
_EntityID$ = 8						; size = 4
?LoadEntity@@YAXJ@Z PROC				; LoadEntity

; 882  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 883  : 	Entity *ent;
; 884  : 
; 885  : 	ent=Reference->Find(EntityID);

	mov	eax, DWORD PTR _EntityID$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?Reference@@3PAVTacticalReference@@A ; Reference
	call	?Find@TacticalReference@@QAEPAVEntity@@J@Z ; TacticalReference::Find
	mov	DWORD PTR _ent$[ebp], eax

; 886  : 	if(ent)

	cmp	DWORD PTR _ent$[ebp], 0
	je	SHORT $LN2@LoadEntity

; 887  : 		EntityToWindow(ent);

	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	?EntityToWindow@@YAXPAVEntity@@@Z	; EntityToWindow
	add	esp, 4
$LN2@LoadEntity:

; 888  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?LoadEntity@@YAXJ@Z ENDP				; LoadEntity
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\tacref\ui_tacref.cpp
_TEXT	SEGMENT
_win$ = -12						; size = 4
_btn$ = -8						; size = 4
_i$ = -4						; size = 2
_SubGroupID$ = 8					; size = 4
?SetSubGroupButton@@YAXJ@Z PROC				; SetSubGroupButton

; 857  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 858  : 	C_Window *win;
; 859  : 	C_Button *btn;
; 860  : 	short i;
; 861  : 
; 862  : 	win=gMainHandler->FindWindow(TAC_REF_WIN);

	push	8000					; 00001f40H
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z ; C_Handler::FindWindowA
	mov	DWORD PTR _win$[ebp], eax

; 863  : 	if(win)

	cmp	DWORD PTR _win$[ebp], 0
	je	SHORT $LN8@SetSubGrou

; 864  : 	{
; 865  : 		for(i=0;i<SUBGROUP_COUNT;i++)

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax
	jmp	SHORT $LN6@SetSubGrou
$LN5@SetSubGrou:
	mov	cx, WORD PTR _i$[ebp]
	add	cx, 1
	mov	WORD PTR _i$[ebp], cx
$LN6@SetSubGrou:
	movsx	edx, WORD PTR _i$[ebp]
	cmp	edx, 18					; 00000012H
	jge	SHORT $LN8@SetSubGrou

; 866  : 		{
; 867  : 			btn=(C_Button*)win->FindControl(SubGroupButtonID[i]);

	movsx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _SubGroupButtonID[eax*4]
	push	ecx
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _btn$[ebp], eax

; 868  : 			if(btn)

	cmp	DWORD PTR _btn$[ebp], 0
	je	SHORT $LN3@SetSubGrou

; 869  : 			{
; 870  : 				if(SubGroupButtonID[i] == SubGroupID)

	movsx	edx, WORD PTR _i$[ebp]
	mov	eax, DWORD PTR _SubGroupButtonID[edx*4]
	cmp	eax, DWORD PTR _SubGroupID$[ebp]
	jne	SHORT $LN2@SetSubGrou

; 871  : 					btn->SetState(1);

	push	1
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 872  : 				else

	jmp	SHORT $LN1@SetSubGrou
$LN2@SetSubGrou:

; 873  : 					btn->SetState(0);

	push	0
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+56]
	call	eax
$LN1@SetSubGrou:

; 874  : 				btn->Refresh();

	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN3@SetSubGrou:

; 875  : 			}
; 876  : 		}

	jmp	SHORT $LN5@SetSubGrou
$LN8@SetSubGrou:

; 877  : 	}
; 878  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SetSubGroupButton@@YAXJ@Z ENDP				; SetSubGroupButton
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\tacref\ui_tacref.cpp
_TEXT	SEGMENT
_win$ = -12						; size = 4
_btn$ = -8						; size = 4
_i$ = -4						; size = 2
_GroupID$ = 8						; size = 4
?SetGroupButton@@YAXJ@Z PROC				; SetGroupButton

; 828  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 829  : 	C_Window *win;
; 830  : 	C_Button *btn;
; 831  : 	short i;
; 832  : 
; 833  : 	win=gMainHandler->FindWindow(TAC_REF_WIN);

	push	8000					; 00001f40H
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z ; C_Handler::FindWindowA
	mov	DWORD PTR _win$[ebp], eax

; 834  : 	if(win)

	cmp	DWORD PTR _win$[ebp], 0
	je	$LN8@SetGroupBu

; 835  : 	{
; 836  : 		for(i=0;i<GROUP_COUNT;i++)

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax
	jmp	SHORT $LN6@SetGroupBu
$LN5@SetGroupBu:
	mov	cx, WORD PTR _i$[ebp]
	add	cx, 1
	mov	WORD PTR _i$[ebp], cx
$LN6@SetGroupBu:
	movsx	edx, WORD PTR _i$[ebp]
	cmp	edx, 3
	jge	$LN8@SetGroupBu

; 837  : 		{
; 838  : 			btn=(C_Button*)win->FindControl(GroupButtonID[i]);

	movsx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _GroupButtonID[eax*4]
	push	ecx
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _btn$[ebp], eax

; 839  : 			if(btn)

	cmp	DWORD PTR _btn$[ebp], 0
	je	SHORT $LN3@SetGroupBu

; 840  : 			{
; 841  : 				if(GroupButtonID[i] == GroupID)

	movsx	edx, WORD PTR _i$[ebp]
	mov	eax, DWORD PTR _GroupButtonID[edx*4]
	cmp	eax, DWORD PTR _GroupID$[ebp]
	jne	SHORT $LN2@SetGroupBu

; 842  : 				{
; 843  : 					btn->SetState(1);

	push	1
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 844  : 					win->HideCluster(btn->GetUserNumber(1));

	push	1
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?GetUserNumber@C_Base@@QAEJJ@Z		; C_Base::GetUserNumber
	push	eax
	mov	ecx, DWORD PTR _win$[ebp]
	call	?HideCluster@C_Window@@QAEXJ@Z		; C_Window::HideCluster

; 845  : 					win->HideCluster(btn->GetUserNumber(2));

	push	2
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?GetUserNumber@C_Base@@QAEJJ@Z		; C_Base::GetUserNumber
	push	eax
	mov	ecx, DWORD PTR _win$[ebp]
	call	?HideCluster@C_Window@@QAEXJ@Z		; C_Window::HideCluster

; 846  : 					win->UnHideCluster(btn->GetUserNumber(0));

	push	0
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?GetUserNumber@C_Base@@QAEJJ@Z		; C_Base::GetUserNumber
	push	eax
	mov	ecx, DWORD PTR _win$[ebp]
	call	?UnHideCluster@C_Window@@QAEXJ@Z	; C_Window::UnHideCluster

; 847  : 				}
; 848  : 				else

	jmp	SHORT $LN1@SetGroupBu
$LN2@SetGroupBu:

; 849  : 					btn->SetState(0);

	push	0
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+56]
	call	eax
$LN1@SetGroupBu:

; 850  : 				btn->Refresh();

	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN3@SetGroupBu:

; 851  : 			}
; 852  : 		}

	jmp	$LN5@SetGroupBu
$LN8@SetGroupBu:

; 853  : 	}
; 854  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SetGroupButton@@YAXJ@Z ENDP				; SetGroupButton
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\tacref\ui_tacref.cpp
_TEXT	SEGMENT
_entval$ = -16						; size = 4
_win$ = -12						; size = 4
_ent$ = -8						; size = 4
_lbox$ = -4						; size = 4
_SubGroupID$ = 8					; size = 4
?InfoToWindow@@YAJJ@Z PROC				; InfoToWindow

; 794  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 795  : 	C_Window *win;
; 796  : 	C_ListBox *lbox;
; 797  : 	Entity *ent;
; 798  : 	long entval=0;

	mov	DWORD PTR _entval$[ebp], 0

; 799  : 
; 800  : 	win=gMainHandler->FindWindow(TAC_REF_WIN);

	push	8000					; 00001f40H
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z ; C_Handler::FindWindowA
	mov	DWORD PTR _win$[ebp], eax

; 801  : 	if(win)

	cmp	DWORD PTR _win$[ebp], 0
	je	$LN6@InfoToWind

; 802  : 	{
; 803  : 		lbox=(C_ListBox*)win->FindControl(ENTITY_LIST);

	push	8015					; 00001f4fH
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _lbox$[ebp], eax

; 804  : 		if(lbox)

	cmp	DWORD PTR _lbox$[ebp], 0
	je	$LN6@InfoToWind

; 805  : 		{
; 806  : 			lbox->RemoveAllItems();

	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?RemoveAllItems@C_ListBox@@QAEXXZ	; C_ListBox::RemoveAllItems

; 807  : 
; 808  : 			ent=Reference->GetFirst(&entval);

	lea	eax, DWORD PTR _entval$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?Reference@@3PAVTacticalReference@@A ; Reference
	call	?GetFirst@TacticalReference@@QAEPAVEntity@@PAJ@Z ; TacticalReference::GetFirst
	mov	DWORD PTR _ent$[ebp], eax
$LN4@InfoToWind:

; 809  : 			while(ent)

	cmp	DWORD PTR _ent$[ebp], 0
	je	SHORT $LN3@InfoToWind

; 810  : 			{
; 811  : 				if(ent->SubGroupID == SubGroupID)

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _SubGroupID$[ebp]
	jne	SHORT $LN2@InfoToWind

; 812  : 					lbox->AddItem(ent->EntityID,C_TYPE_ITEM,ent->Name);

	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 22					; 00000016H
	push	eax
	push	50					; 00000032H
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?AddItem@C_ListBox@@QAEPAV1@JFPAD@Z	; C_ListBox::AddItem
$LN2@InfoToWind:

; 813  : 				ent=Reference->GetNext(&entval);

	lea	eax, DWORD PTR _entval$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?Reference@@3PAVTacticalReference@@A ; Reference
	call	?GetNext@TacticalReference@@QAEPAVEntity@@PAJ@Z ; TacticalReference::GetNext
	mov	DWORD PTR _ent$[ebp], eax

; 814  : 			}

	jmp	SHORT $LN4@InfoToWind
$LN3@InfoToWind:

; 815  : 
; 816  : 			if(!lbox->GetRoot())

	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?GetRoot@C_ListBox@@QAEPAVLISTBOX@@XZ	; C_ListBox::GetRoot
	test	eax, eax
	jne	SHORT $LN1@InfoToWind

; 817  : 			{
; 818  : 				lbox->AddItem(1,C_TYPE_ITEM,TXT_NONE);

	push	115					; 00000073H
	push	50					; 00000032H
	push	1
	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?AddItem@C_ListBox@@QAEPAV1@JFJ@Z	; C_ListBox::AddItem

; 819  : 				lbox->SetValue(1);

	push	1
	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?SetValue@C_ListBox@@QAEXJ@Z		; C_ListBox::SetValue
$LN1@InfoToWind:

; 820  : 			}
; 821  : 			return(lbox->GetTextID());

	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?GetTextID@C_ListBox@@QAEJXZ		; C_ListBox::GetTextID
	jmp	SHORT $LN7@InfoToWind
$LN6@InfoToWind:

; 822  : 		}
; 823  : 	}
; 824  : 	return(0);

	xor	eax, eax
$LN7@InfoToWind:

; 825  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?InfoToWindow@@YAJJ@Z ENDP				; InfoToWindow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\tacref\ui_tacref.cpp
_TEXT	SEGMENT
_btn$ = -16						; size = 4
_lbox$ = -12						; size = 4
_win$ = -8						; size = 4
_tree$ = -4						; size = 4
_ent$ = 8						; size = 4
?EntityToWindow@@YAXPAVEntity@@@Z PROC			; EntityToWindow

; 739  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 740  : 	C_Window *win;
; 741  : 	C_Button *btn;
; 742  : 	C_ListBox *lbox;
; 743  : 	C_TreeList *tree;
; 744  : 
; 745  : 	win=gMainHandler->FindWindow(TAC_REF_WIN);

	push	8000					; 00001f40H
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z ; C_Handler::FindWindowA
	mov	DWORD PTR _win$[ebp], eax

; 746  : 	if(win)

	cmp	DWORD PTR _win$[ebp], 0
	je	$LN6@EntityToWi

; 747  : 	{
; 748  : 		Unload3dModel();

	call	?Unload3dModel@@YAXXZ			; Unload3dModel

; 749  : 
; 750  : 		CurrentEntity=ent->EntityID;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR ?CurrentEntity@@3JA, ecx	; CurrentEntity

; 751  : 
; 752  : 		// Kill any sounds
; 753  : 		StopRWRSounds();

	call	?StopRWRSounds@@YAXXZ			; StopRWRSounds

; 754  : 
; 755  : 		// Make Stats Tree
; 756  : 		tree=(C_TreeList*)win->FindControl(STAT_TREE);

	push	8140					; 00001fccH
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _tree$[ebp], eax

; 757  : 		if(tree)

	cmp	DWORD PTR _tree$[ebp], 0
	je	SHORT $LN4@EntityToWi

; 758  : 		{
; 759  : 			tree->DeleteBranch(tree->GetRoot());

	mov	ecx, DWORD PTR _tree$[ebp]
	call	?GetRoot@C_TreeList@@QAEPAVTREELIST@@XZ	; C_TreeList::GetRoot
	push	eax
	mov	ecx, DWORD PTR _tree$[ebp]
	call	?DeleteBranch@C_TreeList@@QAEXPAVTREELIST@@@Z ; C_TreeList::DeleteBranch

; 760  : 			BuildStatsTree(ent->GetStats(),tree);

	mov	edx, DWORD PTR _tree$[ebp]
	push	edx
	mov	ecx, DWORD PTR _ent$[ebp]
	call	?GetStats@Entity@@QAEPAVStatistics@@XZ	; Entity::GetStats
	push	eax
	call	?BuildStatsTree@@YAXPAVStatistics@@PAVC_TreeList@@@Z ; BuildStatsTree
	add	esp, 8
$LN4@EntityToWi:

; 761  : 		}
; 762  : 
; 763  : 		// Make Description Tree
; 764  : 		tree=(C_TreeList*)win->FindControl(DESC_TREE);

	push	8150					; 00001fd6H
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _tree$[ebp], eax

; 765  : 		if(tree)

	cmp	DWORD PTR _tree$[ebp], 0
	je	SHORT $LN3@EntityToWi

; 766  : 		{
; 767  : 			tree->DeleteBranch(tree->GetRoot());

	mov	ecx, DWORD PTR _tree$[ebp]
	call	?GetRoot@C_TreeList@@QAEPAVTREELIST@@XZ	; C_TreeList::GetRoot
	push	eax
	mov	ecx, DWORD PTR _tree$[ebp]
	call	?DeleteBranch@C_TreeList@@QAEXPAVTREELIST@@@Z ; C_TreeList::DeleteBranch

; 768  : 			BuildDescTree(ent->GetDescription(),tree);

	mov	eax, DWORD PTR _tree$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	call	?GetDescription@Entity@@QAEPAVDescription@@XZ ; Entity::GetDescription
	push	eax
	call	?BuildDescTree@@YAXPAVDescription@@PAVC_TreeList@@@Z ; BuildDescTree
	add	esp, 8
$LN3@EntityToWi:

; 769  : 		}
; 770  : 
; 771  : 		// Make RWR Listbox;
; 772  : 		lbox=(C_ListBox*)win->FindControl(RWR_LIST);

	push	8407					; 000020d7H
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _lbox$[ebp], eax

; 773  : 		if(lbox)

	cmp	DWORD PTR _lbox$[ebp], 0
	je	SHORT $LN2@EntityToWi

; 774  : 		{
; 775  : 			lbox->RemoveAllItems();

	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?RemoveAllItems@C_ListBox@@QAEXXZ	; C_ListBox::RemoveAllItems

; 776  : 			BuildRWRList(ent->GetRWR(),lbox);

	mov	ecx, DWORD PTR _lbox$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _ent$[ebp]
	call	?GetRWR@Entity@@QAEPAVRWR@@XZ		; Entity::GetRWR
	push	eax
	call	?BuildRWRList@@YAXPAVRWR@@PAVC_ListBox@@@Z ; BuildRWRList
	add	esp, 8

; 777  : 
; 778  : 			SelectRWR(lbox->GetTextID());

	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?GetTextID@C_ListBox@@QAEJXZ		; C_ListBox::GetTextID
	push	eax
	call	?SelectRWR@@YAXJ@Z			; SelectRWR
	add	esp, 4
$LN2@EntityToWi:

; 779  : 		}
; 780  : 
; 781  : 		Load3dModel(ent);

	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	call	?Load3dModel@@YAXPAVEntity@@@Z		; Load3dModel
	add	esp, 4

; 782  : 
; 783  : 		btn=(C_Button*)win->FindControl(ENTITY_PIC);

	push	8008					; 00001f48H
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _btn$[ebp], eax

; 784  : 		if(btn)

	cmp	DWORD PTR _btn$[ebp], 0
	je	SHORT $LN1@EntityToWi

; 785  : 		{
; 786  : 			LoadBitmap(btn,ent->PhotoFile);

	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 54					; 00000036H
	push	eax
	mov	ecx, DWORD PTR _btn$[ebp]
	push	ecx
	call	?LoadBitmapA@@YAXPAVC_Button@@QAD@Z	; LoadBitmapA
	add	esp, 8
$LN1@EntityToWi:

; 787  : 		}
; 788  : 		win->RefreshWindow();

	mov	ecx, DWORD PTR _win$[ebp]
	call	?RefreshWindow@C_Window@@QAEXXZ		; C_Window::RefreshWindow
$LN6@EntityToWi:

; 789  : 	}
; 790  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?EntityToWindow@@YAXPAVEntity@@@Z ENDP			; EntityToWindow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\tacref\ui_tacref.cpp
_TEXT	SEGMENT
_file$ = -264						; size = 260
__$ArrayPad$ = -4					; size = 4
_btn$ = 8						; size = 4
_filename$ = 12						; size = 4
?LoadBitmapA@@YAXPAVC_Button@@QAD@Z PROC		; LoadBitmapA

; 725  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 726  : 	char file[MAX_PATH];
; 727  : 
; 728  : 	gImageMgr->RemoveImage(TACREF_BITMAP_ID);

	push	999888777				; 3b991789H
	mov	ecx, DWORD PTR ?gImageMgr@@3PAVC_Image@@A ; gImageMgr
	call	?RemoveImage@C_Image@@QAEHJ@Z		; C_Image::RemoveImage

; 729  : 	strcpy(file,filename);

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	lea	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 730  : 	strcat(file,".tga");

	push	OFFSET ??_C@_04JCAPCJAP@?4tga?$AA@
	lea	edx, DWORD PTR _file$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 731  : 	gImageMgr->LoadImage(TACREF_BITMAP_ID,file,0,0);

	push	0
	push	0
	lea	eax, DWORD PTR _file$[ebp]
	push	eax
	push	999888777				; 3b991789H
	mov	ecx, DWORD PTR ?gImageMgr@@3PAVC_Image@@A ; gImageMgr
	call	?LoadImageA@C_Image@@QAEPAVC_Resmgr@@JPADFF@Z ; C_Image::LoadImageA

; 732  : 	btn->Refresh();

	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax

; 733  : 	btn->SetImage(0,TACREF_BITMAP_ID);

	push	999888777				; 3b991789H
	push	0
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 734  : 	btn->Refresh();

	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax

; 735  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?LoadBitmapA@@YAXPAVC_Button@@QAD@Z ENDP		; LoadBitmapA
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\tacref\ui_tacref.cpp
_TEXT	SEGMENT
_ct$ = -88						; size = 4
_visFlag$ = -84						; size = 4
_Weapon$ = -80						; size = 4
_newtext$1 = -76					; size = 4
_vc$ = -72						; size = 4
_win$ = -68						; size = 4
_i$ = -64						; size = 4
_obj$ = -60						; size = 4
_modelid$ = -56						; size = 2
_objRot$ = -52						; size = 36
_objPos$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_ent$ = 8						; size = 4
?Load3dModel@@YAXPAVEntity@@@Z PROC			; Load3dModel

; 619  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 620  : 	BSPLIST *obj,*Weapon;
; 621  : 	Tpoint objPos;
; 622  : 	Trotation objRot;
; 623  : 	C_Window *win;
; 624  : 	VehicleClassDataType* vc;
; 625  : 	long i,visFlag;
; 626  : 
; 627  : // M.N. read the CT index visType[0] (= Normal model) to get the model ID instead of the tacref hardcoded one
; 628  : 	Falcon4EntityClassType* ct;
; 629  : 	short modelid;
; 630  : 
; 631  : 	ct = &Falcon4ClassTable[ent->EntityID];

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	imul	ecx, 81					; 00000051H
	add	ecx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	DWORD PTR _ct$[ebp], ecx

; 632  : 	modelid = ct->visType[0];

	mov	edx, 2
	imul	edx, 0
	mov	eax, DWORD PTR _ct$[ebp]
	mov	cx, WORD PTR [eax+edx+60]
	mov	WORD PTR _modelid$[ebp], cx

; 633  : 
; 634  : 	if (ent->EntityID == 913)

	mov	edx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [edx+8], 913			; 00000391H
	jne	SHORT $LN18@Load3dMode

; 635  : 		modelid = 1225; // LANTIRN Pod -> no CT record

	mov	eax, 1225				; 000004c9H
	mov	WORD PTR _modelid$[ebp], ax
$LN18@Load3dMode:

; 636  : 	if (ent->EntityID == 531)

	mov	ecx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [ecx+8], 531			; 00000213H
	jne	SHORT $LN17@Load3dMode

; 637  : 		modelid = 875;	// M-2A2/ADATS -> this vehicle doesn't exist in the datafiles (huh ?)

	mov	edx, 875				; 0000036bH
	mov	WORD PTR _modelid$[ebp], dx
$LN17@Load3dMode:

; 638  : //	if(ent->ModelID)
; 639  : 	if (modelid)

	movsx	eax, WORD PTR _modelid$[ebp]
	test	eax, eax
	je	$LN1@Load3dMode

; 640  : 	{
; 641  : 		Helicopter=FALSE;

	mov	DWORD PTR ?Helicopter@@3HA, 0		; Helicopter

; 642  : 		// Load Current Model
; 643  : 		if(ent->GroupID == CAT_AIRCRAFT) // Aircraft

	mov	ecx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [ecx], 8200			; 00002008H
	jne	$LN15@Load3dMode

; 644  : 		{
; 645  : //			obj=TAC_Viewer->LoadBSP(ent->ModelID,ent->ModelID,TRUE);
; 646  : 			obj=TAC_Viewer->LoadBSP(modelid,modelid,TRUE);

	push	1
	movsx	edx, WORD PTR _modelid$[ebp]
	push	edx
	movsx	eax, WORD PTR _modelid$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?TAC_Viewer@@3PAVC_3dViewer@@A ; TAC_Viewer
	call	?LoadBSP@C_3dViewer@@QAEPAUUI_BSPList@@JHH@Z ; C_3dViewer::LoadBSP
	mov	DWORD PTR _obj$[ebp], eax

; 647  : //			if (ent->ModelID == MapVisId(VIS_F16C))
; 648  : 			if (modelid == MapVisId(VIS_F16C) || ((DrawableBSP*)obj->object)->instance.ParentObject->nSwitches >= 10)

	movsx	esi, WORD PTR _modelid$[ebp]
	push	1052					; 0000041cH
	call	?MapVisId@@YAKK@Z			; MapVisId
	add	esp, 4
	cmp	esi, eax
	je	SHORT $LN13@Load3dMode
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [edx+116]
	movsx	ecx, WORD PTR [eax+52]
	cmp	ecx, 10					; 0000000aH
	jl	SHORT $LN14@Load3dMode
$LN13@Load3dMode:

; 649  : 			{
; 650  : 				((DrawableBSP*)obj->object)->SetSwitchMask(10, 1); // Afterburner

	push	1
	push	10					; 0000000aH
	mov	edx, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 651  : 				((DrawableBSP*)obj->object)->SetSwitchMask(31, 1); // Afterburner

	push	1
	push	31					; 0000001fH
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN14@Load3dMode:

; 652  : 			}
; 653  : 			if(ent->SubGroupID == SUB_CAT_AIRCRAFT_HELICOPTERS)

	mov	ecx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [ecx+4], 10010		; 0000271aH
	jne	SHORT $LN12@Load3dMode

; 654  : 			{
; 655  : 				Helicopter=TRUE;

	mov	DWORD PTR ?Helicopter@@3HA, 1		; Helicopter

; 656  : 				((DrawableBSP*)obj->object)->SetSwitchMask(0, 1); // Turn on rotors

	push	1
	push	0
	mov	edx, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN12@Load3dMode:

; 657  : 				//((DrawableBSP*)obj->object)->SetDofAngle(2, 0);
; 658  : 				//((DrawableBSP*)obj->object)->SetDofAngle(5, 0);
; 659  : 			}
; 660  : 		}
; 661  : 		else

	jmp	SHORT $LN11@Load3dMode
$LN15@Load3dMode:

; 662  : //			obj=TAC_Viewer->LoadBSP(ent->ModelID,ent->ModelID,FALSE);
; 663  : 			obj=TAC_Viewer->LoadBSP(modelid,modelid,FALSE);

	push	0
	movsx	eax, WORD PTR _modelid$[ebp]
	push	eax
	movsx	ecx, WORD PTR _modelid$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?TAC_Viewer@@3PAVC_3dViewer@@A ; TAC_Viewer
	call	?LoadBSP@C_3dViewer@@QAEPAUUI_BSPList@@JHH@Z ; C_3dViewer::LoadBSP
	mov	DWORD PTR _obj$[ebp], eax
$LN11@Load3dMode:

; 664  : 
; 665  : 		if(obj)

	cmp	DWORD PTR _obj$[ebp], 0
	je	$LN1@Load3dMode

; 666  : 		{
; 667  : 
; 668  : 			if(ent->MissileFlag > 0)

	mov	edx, DWORD PTR _ent$[ebp]
	movsx	eax, WORD PTR [edx+20]
	test	eax, eax
	jle	$LN5@Load3dMode

; 669  : 			{
; 670  : 				vc = GetVehicleClassData(ent->EntityID);

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	?GetVehicleClassData@@YAPAUVehicleClassDataType@@H@Z ; GetVehicleClassData
	add	esp, 4
	mov	DWORD PTR _vc$[ebp], eax

; 671  : 				if(vc)

	cmp	DWORD PTR _vc$[ebp], 0
	je	SHORT $LN5@Load3dMode

; 672  : 				{
; 673  : 					visFlag = vc->VisibleFlags;

	mov	eax, DWORD PTR _vc$[ebp]
	movzx	ecx, WORD PTR [eax+62]
	mov	DWORD PTR _visFlag$[ebp], ecx

; 674  : //					Weapon = TAC_Viewer->LoadBSP(ent->ModelID+1,ent->MissileFlag);
; 675  : 					Weapon = TAC_Viewer->LoadBSP(modelid+1,ent->MissileFlag);

	push	0
	mov	edx, DWORD PTR _ent$[ebp]
	movsx	eax, WORD PTR [edx+20]
	push	eax
	movsx	ecx, WORD PTR _modelid$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR ?TAC_Viewer@@3PAVC_3dViewer@@A ; TAC_Viewer
	call	?LoadBSP@C_3dViewer@@QAEPAUUI_BSPList@@JHH@Z ; C_3dViewer::LoadBSP
	mov	DWORD PTR _Weapon$[ebp], eax

; 676  : //					CurrentWeapon=ent->ModelID+1;
; 677  : 					CurrentWeapon=modelid+1;

	movsx	edx, WORD PTR _modelid$[ebp]
	add	edx, 1
	mov	DWORD PTR ?CurrentWeapon@@3JA, edx	; CurrentWeapon

; 678  : 
; 679  : 					for (i=0; i<HARDPOINT_MAX; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@Load3dMode
$LN6@Load3dMode:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@Load3dMode:
	cmp	DWORD PTR _i$[ebp], 16			; 00000010H
	jge	SHORT $LN5@Load3dMode

; 680  : 					{
; 681  : 						if (visFlag & (1 << i))

	mov	edx, 1
	mov	ecx, DWORD PTR _i$[ebp]
	shl	edx, cl
	and	edx, DWORD PTR _visFlag$[ebp]
	je	SHORT $LN4@Load3dMode

; 682  : 						{
; 683  : 							// This is a visible weapon, so attach
; 684  : 							((DrawableBSP*)obj->object)->AttachChild(((DrawableBSP*)Weapon->object),i);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Weapon$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	?AttachChild@DrawableBSP@@QAEXPAV1@H@Z	; DrawableBSP::AttachChild
$LN4@Load3dMode:

; 685  : 						}
; 686  : 					}

	jmp	SHORT $LN6@Load3dMode
$LN5@Load3dMode:

; 687  : 				}
; 688  : 			}
; 689  : 
; 690  : //			CustomPosStuff(ent->GroupID,ent->SubGroupID,ent->ModelID,obj);
; 691  : //			CurrentModel=ent->ModelID;
; 692  : 			CustomPosStuff(ent->GroupID,ent->SubGroupID,modelid,obj);

	mov	ecx, DWORD PTR _obj$[ebp]
	push	ecx
	movsx	edx, WORD PTR _modelid$[ebp]
	push	edx
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	?CustomPosStuff@@YAXJJJPAUUI_BSPList@@@Z ; CustomPosStuff
	add	esp, 16					; 00000010H

; 693  : 			CurrentModel=modelid;

	movsx	ecx, WORD PTR _modelid$[ebp]
	mov	DWORD PTR ?CurrentModel@@3JA, ecx	; CurrentModel

; 694  : 			//TJL 12/28/03 This code allows for the texture set to be cycled by reselecting the model
; 695  : 			int newtext;
; 696  : 			newtext = ((DrawableBSP*)obj->object)->GetNTextureSet()-1;

	mov	edx, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	call	?GetNTextureSet@DrawableBSP@@QAEHXZ	; DrawableBSP::GetNTextureSet
	sub	eax, 1
	mov	DWORD PTR _newtext$1[ebp], eax

; 697  : 			
; 698  : 			if (newtext >= prevtext)

	mov	eax, DWORD PTR _newtext$1[ebp]
	cmp	eax, DWORD PTR ?prevtext@@3HA		; prevtext
	jl	SHORT $LN3@Load3dMode

; 699  : 			{
; 700  : 				prevtext++;

	mov	ecx, DWORD PTR ?prevtext@@3HA		; prevtext
	add	ecx, 1
	mov	DWORD PTR ?prevtext@@3HA, ecx		; prevtext
$LN3@Load3dMode:

; 701  : 			}
; 702  : 
; 703  : 			if (prevtext > newtext)

	mov	edx, DWORD PTR ?prevtext@@3HA		; prevtext
	cmp	edx, DWORD PTR _newtext$1[ebp]
	jle	SHORT $LN2@Load3dMode

; 704  : 				prevtext = 0;

	mov	DWORD PTR ?prevtext@@3HA, 0		; prevtext
$LN2@Load3dMode:

; 705  : 
; 706  : 			((DrawableBSP*)obj->object)->SetTextureSet(prevtext);

	mov	eax, DWORD PTR ?prevtext@@3HA		; prevtext
	push	eax
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	call	?SetTextureSet@DrawableBSP@@QAEXK@Z	; DrawableBSP::SetTextureSet

; 707  : 			//end new code
; 708  : 
; 709  : 			PositandOrientSetData (TACREF_Object.PosX, TACREF_Object.PosY, TACREF_Object.PosZ, 0.0f, 0.0f, 0.0f, &objPos,&objRot);

	lea	edx, DWORD PTR _objRot$[ebp]
	push	edx
	lea	eax, DWORD PTR _objPos$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+24
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+20
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+16
	movss	DWORD PTR [esp], xmm0
	call	?PositandOrientSetData@@YAXMMMMMMPAUTpoint@@PAUTrotation@@@Z ; PositandOrientSetData
	add	esp, 32					; 00000020H

; 710  : 
; 711  : 			((DrawableBSP*)obj->object)->Update(&objPos,&objRot);

	lea	ecx, DWORD PTR _objRot$[ebp]
	push	ecx
	lea	edx, DWORD PTR _objPos$[ebp]
	push	edx
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	?Update@DrawableBSP@@QAEXPBUTpoint@@PBUTrotation@@@Z ; DrawableBSP::Update

; 712  : 
; 713  : 			
; 714  : 
; 715  : 			win=gMainHandler->FindWindow(TAC_REF_WIN);

	push	8000					; 00001f40H
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z ; C_Handler::FindWindowA
	mov	DWORD PTR _win$[ebp], eax

; 716  : 			if(win)

	cmp	DWORD PTR _win$[ebp], 0
	je	SHORT $LN1@Load3dMode

; 717  : 			{
; 718  : 				TACREF_PositionCamera(&TACREF_Object,win,0);

	push	0
	mov	ecx, DWORD PTR _win$[ebp]
	push	ecx
	push	OFFSET ?TACREF_Object@@3UOBJECTINFO@@A	; TACREF_Object
	call	?TACREF_PositionCamera@@YAXPAUOBJECTINFO@@PAVC_Window@@J@Z ; TACREF_PositionCamera
	add	esp, 12					; 0000000cH
$LN1@Load3dMode:

; 719  : 			}
; 720  : 		}
; 721  : 	}
; 722  : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?Load3dModel@@YAXPAVEntity@@@Z ENDP			; Load3dModel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\tacref\ui_tacref.cpp
_TEXT	SEGMENT
tv769 = -160						; size = 4
tv631 = -156						; size = 4
tv762 = -152						; size = 4
tv579 = -148						; size = 4
tv748 = -144						; size = 4
tv597 = -140						; size = 4
tv736 = -136						; size = 4
tv646 = -132						; size = 4
tv729 = -128						; size = 4
tv611 = -124						; size = 4
tv721 = -120						; size = 4
tv586 = -116						; size = 4
tv714 = -112						; size = 4
tv654 = -108						; size = 4
tv706 = -104						; size = 4
tv639 = -100						; size = 4
tv699 = -96						; size = 4
tv624 = -92						; size = 4
tv691 = -88						; size = 4
tv568 = -84						; size = 4
tv684 = -80						; size = 4
tv591 = -76						; size = 4
tv676 = -72						; size = 4
tv90 = -68						; size = 4
tv669 = -64						; size = 4
tv661 = -60						; size = 4
tv602 = -56						; size = 4
tv479 = -52						; size = 4
tv221 = -48						; size = 4
tv451 = -44						; size = 4
tv277 = -40						; size = 4
tv417 = -36						; size = 4
tv154 = -32						; size = 4
tv389 = -28						; size = 4
tv249 = -24						; size = 4
tv361 = -20						; size = 4
tv333 = -16						; size = 4
tv305 = -12						; size = 4
tv64 = -8						; size = 4
tv193 = -4						; size = 4
_GroupID$ = 8						; size = 4
_SubGroupID$ = 12					; size = 4
_ModelID$ = 16						; size = 4
_Vehicle$ = 20						; size = 4
?CustomPosStuff@@YAXJJJPAUUI_BSPList@@@Z PROC		; CustomPosStuff

; 465  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 160				; 000000a0H

; 466  : 	TACREF_Object.Heading=-200.0f;

	movss	xmm0, DWORD PTR __real@c3480000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A, xmm0

; 467  : 	TACREF_Object.Pitch=10.0f;

	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+4, xmm0

; 468  : 	switch(GroupID)

	mov	eax, DWORD PTR _GroupID$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 8200		; 00002008H
	je	SHORT $LN19@CustomPosS
	cmp	DWORD PTR tv64[ebp], 8300		; 0000206cH
	je	$LN18@CustomPosS
	cmp	DWORD PTR tv64[ebp], 8400		; 000020d0H
	je	$LN1@CustomPosS
	jmp	$LN20@CustomPosS
$LN19@CustomPosS:

; 469  : 	{
; 470  : 		case CAT_AIRCRAFT:
; 471  : 			//switch(SubGroupID)
; 472  : 			//{
; 473  : 				/*case SUB_CAT_AIRCRAFT_FIGHTERS: // Fighters
; 474  : 				case SUB_CAT_AIRCRAFT_ATTACK: // Attack
; 475  : 				case SUB_CAT_AIRCRAFT_HELICOPTERS: // Helicopters
; 476  : 					if(ModelID == MapVisId(VIS_AC130))
; 477  : 						TACREF_Object.Distance=350.0f;
; 478  : 					else
; 479  : 						TACREF_Object.Distance=150.0f;
; 480  : 					break;
; 481  : 				case SUB_CAT_AIRCRAFT_BOMBERS: // Bombers
; 482  : 					TACREF_Object.Distance=440.0f;
; 483  : 					break;
; 484  : 				case SUB_CAT_AIRCRAFT_EW: // EW
; 485  : 				case SUB_CAT_AIRCRAFT_SUPPORT: // Support
; 486  : 					TACREF_Object.Distance=350.0f;
; 487  : 					break;*/ //Cobra test
; 488  : 				//default:
; 489  : 					//TACREF_Object.Distance=((DrawableBSP*)Vehicle->object)->Radius()*4;
; 490  : 					//break;
; 491  : 			//}
; 492  : 		//Cobra Steve asked for all aircraft to use the same value
; 493  : 			TACREF_Object.Distance=((DrawableBSP*)Vehicle->object)->Radius()*4;

	mov	ecx, DWORD PTR _Vehicle$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	call	?Radius@DrawableObject@@QBEMXZ		; DrawableObject::Radius
	fstp	DWORD PTR tv568[ebp]
	movss	xmm0, DWORD PTR tv568[ebp]
	mulss	xmm0, DWORD PTR __real@40800000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+8, xmm0

; 494  : 			TACREF_Object.Direction=0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+12, xmm0

; 495  : 
; 496  : 			TACREF_Object.MinPitch=0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+52, xmm0

; 497  : 			TACREF_Object.MaxPitch=0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+56, xmm0

; 498  : 			TACREF_Object.CheckPitch=FALSE;

	mov	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+48, 0

; 499  : 
; 500  : 			TACREF_Object.PosX=0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+16, xmm0

; 501  : 			TACREF_Object.PosY=0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+20, xmm0

; 502  : 			TACREF_Object.PosZ=0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+24, xmm0

; 503  : 			TACREF_Object.MinDistance=((DrawableBSP*)Vehicle->object)->Radius()+30;

	mov	edx, DWORD PTR _Vehicle$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	call	?Radius@DrawableObject@@QBEMXZ		; DrawableObject::Radius
	fstp	DWORD PTR tv579[ebp]
	movss	xmm0, DWORD PTR tv579[ebp]
	addss	xmm0, DWORD PTR __real@41f00000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+40, xmm0

; 504  : 			TACREF_Object.MaxDistance=TACREF_Object.Distance + 200;

	movss	xmm0, DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+8
	addss	xmm0, DWORD PTR __real@43480000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+44, xmm0

; 505  : 			break;

	jmp	$LN20@CustomPosS
$LN18@CustomPosS:

; 506  : 		case CAT_VEHICLES:
; 507  : 			switch(SubGroupID)

	mov	eax, DWORD PTR _SubGroupID$[ebp]
	mov	DWORD PTR tv90[ebp], eax
	cmp	DWORD PTR tv90[ebp], 10005		; 00002715H
	je	SHORT $LN15@CustomPosS
	jmp	$LN14@CustomPosS
$LN15@CustomPosS:

; 508  : 			{
; 509  : 				case SUB_CAT_VEHICLES_SHIPS:
; 510  : 					TACREF_Object.Distance=static_cast<float>(max(150,(long)((float)((DrawableBSP*)Vehicle->object)->Radius()*2.7)));

	mov	ecx, DWORD PTR _Vehicle$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	call	?Radius@DrawableObject@@QBEMXZ		; DrawableObject::Radius
	fstp	DWORD PTR tv586[ebp]
	movss	xmm0, DWORD PTR tv586[ebp]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@400599999999999a
	cvttsd2si edx, xmm0
	cmp	edx, 150				; 00000096H
	jge	SHORT $LN24@CustomPosS
	mov	DWORD PTR tv154[ebp], 150		; 00000096H
	jmp	SHORT $LN25@CustomPosS
$LN24@CustomPosS:
	mov	eax, DWORD PTR _Vehicle$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	?Radius@DrawableObject@@QBEMXZ		; DrawableObject::Radius
	fstp	DWORD PTR tv591[ebp]
	movss	xmm0, DWORD PTR tv591[ebp]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@400599999999999a
	cvttsd2si ecx, xmm0
	mov	DWORD PTR tv154[ebp], ecx
$LN25@CustomPosS:
	cvtsi2ss xmm0, DWORD PTR tv154[ebp]
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+8, xmm0

; 511  : 					TACREF_Object.Direction=0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+12, xmm0

; 512  : 
; 513  : 					TACREF_Object.MinDistance=((DrawableBSP*)Vehicle->object)->Radius()+40;

	mov	edx, DWORD PTR _Vehicle$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	call	?Radius@DrawableObject@@QBEMXZ		; DrawableObject::Radius
	fstp	DWORD PTR tv597[ebp]
	movss	xmm0, DWORD PTR tv597[ebp]
	addss	xmm0, DWORD PTR __real@42200000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+40, xmm0

; 514  : 					TACREF_Object.MaxDistance=((DrawableBSP*)Vehicle->object)->Radius()*20;

	mov	eax, DWORD PTR _Vehicle$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	?Radius@DrawableObject@@QBEMXZ		; DrawableObject::Radius
	fstp	DWORD PTR tv602[ebp]
	movss	xmm0, DWORD PTR tv602[ebp]
	mulss	xmm0, DWORD PTR __real@41a00000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+44, xmm0

; 515  : 					TACREF_Object.MinPitch=5;

	movss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+52, xmm0

; 516  : 					TACREF_Object.MaxPitch=90;

	movss	xmm0, DWORD PTR __real@42b40000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+56, xmm0

; 517  : 					TACREF_Object.CheckPitch=TRUE;

	mov	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+48, 1

; 518  : 
; 519  : 					TACREF_Object.PosX=0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+16, xmm0

; 520  : 					TACREF_Object.PosY=0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+20, xmm0

; 521  : 					TACREF_Object.PosZ=((DrawableBSP*)Vehicle->object)->Radius()/20+5;

	mov	ecx, DWORD PTR _Vehicle$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	call	?Radius@DrawableObject@@QBEMXZ		; DrawableObject::Radius
	fstp	DWORD PTR tv611[ebp]
	movss	xmm0, DWORD PTR tv611[ebp]
	divss	xmm0, DWORD PTR __real@41a00000
	addss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+24, xmm0

; 522  : 					break;

	jmp	$LN16@CustomPosS
$LN14@CustomPosS:

; 523  : 				default:
; 524  : 					switch ( ModelID ) {

	mov	edx, DWORD PTR _ModelID$[ebp]
	mov	DWORD PTR tv193[ebp], edx
	cmp	DWORD PTR tv193[ebp], 834		; 00000342H
	jg	SHORT $LN46@CustomPosS
	cmp	DWORD PTR tv193[ebp], 833		; 00000341H
	jge	$LN11@CustomPosS
	mov	eax, DWORD PTR tv193[ebp]
	sub	eax, 133				; 00000085H
	mov	DWORD PTR tv193[ebp], eax
	cmp	DWORD PTR tv193[ebp], 106		; 0000006aH
	ja	$LN2@CustomPosS
	mov	ecx, DWORD PTR tv193[ebp]
	movzx	edx, BYTE PTR $LN48@CustomPosS[ecx]
	jmp	DWORD PTR $LN50@CustomPosS[edx*4]
$LN46@CustomPosS:
	cmp	DWORD PTR tv193[ebp], 978		; 000003d2H
	jg	SHORT $LN47@CustomPosS
	cmp	DWORD PTR tv193[ebp], 978		; 000003d2H
	je	$LN7@CustomPosS
	mov	eax, DWORD PTR tv193[ebp]
	sub	eax, 835				; 00000343H
	mov	DWORD PTR tv193[ebp], eax
	cmp	DWORD PTR tv193[ebp], 122		; 0000007aH
	ja	$LN2@CustomPosS
	mov	ecx, DWORD PTR tv193[ebp]
	movzx	edx, BYTE PTR $LN49@CustomPosS[ecx]
	jmp	DWORD PTR $LN51@CustomPosS[edx*4]
$LN47@CustomPosS:
	cmp	DWORD PTR tv193[ebp], 1220		; 000004c4H
	je	$LN3@CustomPosS
	cmp	DWORD PTR tv193[ebp], 1226		; 000004caH
	je	$LN4@CustomPosS
	jmp	$LN2@CustomPosS
$LN11@CustomPosS:

; 525  : 						case VIS_SA2R:	// Fan Song
; 526  : 						case VIS_SA3R:	// Low Blow
; 527  : 							TACREF_Object.Distance=130.0f;

	movss	xmm0, DWORD PTR __real@43020000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+8, xmm0

; 528  : 							TACREF_Object.MinDistance=max(90.0f,((DrawableBSP*)Vehicle->object)->Radius()+10);

	mov	eax, DWORD PTR _Vehicle$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	?Radius@DrawableObject@@QBEMXZ		; DrawableObject::Radius
	fstp	DWORD PTR tv624[ebp]
	movss	xmm0, DWORD PTR tv624[ebp]
	addss	xmm0, DWORD PTR __real@41200000
	movss	xmm1, DWORD PTR __real@42b40000
	comiss	xmm1, xmm0
	jbe	SHORT $LN26@CustomPosS
	movss	xmm0, DWORD PTR __real@42b40000
	movss	DWORD PTR tv221[ebp], xmm0
	jmp	SHORT $LN27@CustomPosS
$LN26@CustomPosS:
	mov	ecx, DWORD PTR _Vehicle$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	call	?Radius@DrawableObject@@QBEMXZ		; DrawableObject::Radius
	fstp	DWORD PTR tv631[ebp]
	movss	xmm0, DWORD PTR tv631[ebp]
	addss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR tv221[ebp], xmm0
$LN27@CustomPosS:
	movss	xmm0, DWORD PTR tv221[ebp]
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+40, xmm0

; 529  : 							TACREF_Object.PosZ=14;

	movss	xmm0, DWORD PTR __real@41600000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+24, xmm0

; 530  : 							break;

	jmp	$LN12@CustomPosS
$LN10@CustomPosS:

; 531  : 						case VIS_SA5R:	// Barlock
; 532  : 						case VIS_SA4R:	// Long Track
; 533  : 							TACREF_Object.Distance=110.0f;

	movss	xmm0, DWORD PTR __real@42dc0000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+8, xmm0

; 534  : 							TACREF_Object.MinDistance=max(80.0f,((DrawableBSP*)Vehicle->object)->Radius()+10);

	mov	edx, DWORD PTR _Vehicle$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	call	?Radius@DrawableObject@@QBEMXZ		; DrawableObject::Radius
	fstp	DWORD PTR tv639[ebp]
	movss	xmm0, DWORD PTR tv639[ebp]
	addss	xmm0, DWORD PTR __real@41200000
	movss	xmm1, DWORD PTR __real@42a00000
	comiss	xmm1, xmm0
	jbe	SHORT $LN28@CustomPosS
	movss	xmm0, DWORD PTR __real@42a00000
	movss	DWORD PTR tv249[ebp], xmm0
	jmp	SHORT $LN29@CustomPosS
$LN28@CustomPosS:
	mov	eax, DWORD PTR _Vehicle$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	?Radius@DrawableObject@@QBEMXZ		; DrawableObject::Radius
	fstp	DWORD PTR tv646[ebp]
	movss	xmm0, DWORD PTR tv646[ebp]
	addss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR tv249[ebp], xmm0
$LN29@CustomPosS:
	movss	xmm0, DWORD PTR tv249[ebp]
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+40, xmm0

; 535  : 							TACREF_Object.PosZ=10;

	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+24, xmm0

; 536  : 							break;

	jmp	$LN12@CustomPosS
$LN9@CustomPosS:

; 537  : 						case VIS_PATRIOTRAD:
; 538  : 						case VIS_SA8L:
; 539  : 						case VIS_SA13L:
; 540  : 							TACREF_Object.Distance=85.0f;

	movss	xmm0, DWORD PTR __real@42aa0000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+8, xmm0

; 541  : 							TACREF_Object.MinDistance=max(50.0f,((DrawableBSP*)Vehicle->object)->Radius()+20);

	mov	ecx, DWORD PTR _Vehicle$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	call	?Radius@DrawableObject@@QBEMXZ		; DrawableObject::Radius
	fstp	DWORD PTR tv654[ebp]
	movss	xmm0, DWORD PTR tv654[ebp]
	addss	xmm0, DWORD PTR __real@41a00000
	movss	xmm1, DWORD PTR __real@42480000
	comiss	xmm1, xmm0
	jbe	SHORT $LN30@CustomPosS
	movss	xmm0, DWORD PTR __real@42480000
	movss	DWORD PTR tv277[ebp], xmm0
	jmp	SHORT $LN31@CustomPosS
$LN30@CustomPosS:
	mov	edx, DWORD PTR _Vehicle$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	call	?Radius@DrawableObject@@QBEMXZ		; DrawableObject::Radius
	fstp	DWORD PTR tv661[ebp]
	movss	xmm0, DWORD PTR tv661[ebp]
	addss	xmm0, DWORD PTR __real@41a00000
	movss	DWORD PTR tv277[ebp], xmm0
$LN31@CustomPosS:
	movss	xmm0, DWORD PTR tv277[ebp]
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+40, xmm0

; 542  : 							TACREF_Object.PosZ=6;

	movss	xmm0, DWORD PTR __real@40c00000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+24, xmm0

; 543  : 							break;

	jmp	$LN12@CustomPosS
$LN8@CustomPosS:

; 544  : 						case VIS_SA3L:
; 545  : 							TACREF_Object.Distance=80.0f;

	movss	xmm0, DWORD PTR __real@42a00000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+8, xmm0

; 546  : 							TACREF_Object.MinDistance=max(50.0f,((DrawableBSP*)Vehicle->object)->Radius()+10);

	mov	eax, DWORD PTR _Vehicle$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	?Radius@DrawableObject@@QBEMXZ		; DrawableObject::Radius
	fstp	DWORD PTR tv669[ebp]
	movss	xmm0, DWORD PTR tv669[ebp]
	addss	xmm0, DWORD PTR __real@41200000
	movss	xmm1, DWORD PTR __real@42480000
	comiss	xmm1, xmm0
	jbe	SHORT $LN32@CustomPosS
	movss	xmm0, DWORD PTR __real@42480000
	movss	DWORD PTR tv305[ebp], xmm0
	jmp	SHORT $LN33@CustomPosS
$LN32@CustomPosS:
	mov	ecx, DWORD PTR _Vehicle$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	call	?Radius@DrawableObject@@QBEMXZ		; DrawableObject::Radius
	fstp	DWORD PTR tv676[ebp]
	movss	xmm0, DWORD PTR tv676[ebp]
	addss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR tv305[ebp], xmm0
$LN33@CustomPosS:
	movss	xmm0, DWORD PTR tv305[ebp]
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+40, xmm0

; 547  : 							TACREF_Object.PosZ=3;

	movss	xmm0, DWORD PTR __real@40400000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+24, xmm0

; 548  : 							break;

	jmp	$LN12@CustomPosS
$LN7@CustomPosS:

; 549  : 						case VIS_SA14:
; 550  : 						case VIS_STINGER:
; 551  : 							TACREF_Object.Distance=40.0f;

	movss	xmm0, DWORD PTR __real@42200000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+8, xmm0

; 552  : 							TACREF_Object.MinDistance=max(20.0f,((DrawableBSP*)Vehicle->object)->Radius()+10);

	mov	edx, DWORD PTR _Vehicle$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	call	?Radius@DrawableObject@@QBEMXZ		; DrawableObject::Radius
	fstp	DWORD PTR tv684[ebp]
	movss	xmm0, DWORD PTR tv684[ebp]
	addss	xmm0, DWORD PTR __real@41200000
	movss	xmm1, DWORD PTR __real@41a00000
	comiss	xmm1, xmm0
	jbe	SHORT $LN34@CustomPosS
	movss	xmm0, DWORD PTR __real@41a00000
	movss	DWORD PTR tv333[ebp], xmm0
	jmp	SHORT $LN35@CustomPosS
$LN34@CustomPosS:
	mov	eax, DWORD PTR _Vehicle$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	?Radius@DrawableObject@@QBEMXZ		; DrawableObject::Radius
	fstp	DWORD PTR tv691[ebp]
	movss	xmm0, DWORD PTR tv691[ebp]
	addss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR tv333[ebp], xmm0
$LN35@CustomPosS:
	movss	xmm0, DWORD PTR tv333[ebp]
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+40, xmm0

; 553  : 							TACREF_Object.PosZ=1;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+24, xmm0

; 554  : 							break;

	jmp	$LN12@CustomPosS
$LN6@CustomPosS:

; 555  : 						case VIS_SA2L:	// sorting problem, need fixing in 3D models
; 556  : 						case VIS_SA5L:
; 557  : 							TACREF_Object.Distance=110.0f;

	movss	xmm0, DWORD PTR __real@42dc0000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+8, xmm0

; 558  : 							TACREF_Object.MinDistance=max(100.0f,((DrawableBSP*)Vehicle->object)->Radius()+10);

	mov	ecx, DWORD PTR _Vehicle$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	call	?Radius@DrawableObject@@QBEMXZ		; DrawableObject::Radius
	fstp	DWORD PTR tv699[ebp]
	movss	xmm0, DWORD PTR tv699[ebp]
	addss	xmm0, DWORD PTR __real@41200000
	movss	xmm1, DWORD PTR __real@42c80000
	comiss	xmm1, xmm0
	jbe	SHORT $LN36@CustomPosS
	movss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR tv361[ebp], xmm0
	jmp	SHORT $LN37@CustomPosS
$LN36@CustomPosS:
	mov	edx, DWORD PTR _Vehicle$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	call	?Radius@DrawableObject@@QBEMXZ		; DrawableObject::Radius
	fstp	DWORD PTR tv706[ebp]
	movss	xmm0, DWORD PTR tv706[ebp]
	addss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR tv361[ebp], xmm0
$LN37@CustomPosS:
	movss	xmm0, DWORD PTR tv361[ebp]
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+40, xmm0

; 559  : 							TACREF_Object.PosZ=5;

	movss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+24, xmm0

; 560  : 							break;

	jmp	$LN12@CustomPosS
$LN5@CustomPosS:

; 561  : 						case VIS_M88:	// M-88/A2 IRV, sorting problem need fixing
; 562  : 							TACREF_Object.Distance=135.0f;

	movss	xmm0, DWORD PTR __real@43070000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+8, xmm0

; 563  : 							TACREF_Object.MinDistance=max(50.0f,((DrawableBSP*)Vehicle->object)->Radius()+10);

	mov	eax, DWORD PTR _Vehicle$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	?Radius@DrawableObject@@QBEMXZ		; DrawableObject::Radius
	fstp	DWORD PTR tv714[ebp]
	movss	xmm0, DWORD PTR tv714[ebp]
	addss	xmm0, DWORD PTR __real@41200000
	movss	xmm1, DWORD PTR __real@42480000
	comiss	xmm1, xmm0
	jbe	SHORT $LN38@CustomPosS
	movss	xmm0, DWORD PTR __real@42480000
	movss	DWORD PTR tv389[ebp], xmm0
	jmp	SHORT $LN39@CustomPosS
$LN38@CustomPosS:
	mov	ecx, DWORD PTR _Vehicle$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	call	?Radius@DrawableObject@@QBEMXZ		; DrawableObject::Radius
	fstp	DWORD PTR tv721[ebp]
	movss	xmm0, DWORD PTR tv721[ebp]
	addss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR tv389[ebp], xmm0
$LN39@CustomPosS:
	movss	xmm0, DWORD PTR tv389[ebp]
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+40, xmm0

; 564  : 							TACREF_Object.PosZ=14;

	movss	xmm0, DWORD PTR __real@41600000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+24, xmm0

; 565  : 							break;

	jmp	$LN12@CustomPosS
$LN4@CustomPosS:

; 566  : 						case VIS_NIKEL:
; 567  : 							TACREF_Object.Distance=140.0f;

	movss	xmm0, DWORD PTR __real@430c0000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+8, xmm0

; 568  : 							TACREF_Object.MinDistance=max(80.0f,((DrawableBSP*)Vehicle->object)->Radius()+5);

	mov	edx, DWORD PTR _Vehicle$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	call	?Radius@DrawableObject@@QBEMXZ		; DrawableObject::Radius
	fstp	DWORD PTR tv729[ebp]
	movss	xmm0, DWORD PTR tv729[ebp]
	addss	xmm0, DWORD PTR __real@40a00000
	movss	xmm1, DWORD PTR __real@42a00000
	comiss	xmm1, xmm0
	jbe	SHORT $LN40@CustomPosS
	movss	xmm0, DWORD PTR __real@42a00000
	movss	DWORD PTR tv417[ebp], xmm0
	jmp	SHORT $LN41@CustomPosS
$LN40@CustomPosS:
	mov	eax, DWORD PTR _Vehicle$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	?Radius@DrawableObject@@QBEMXZ		; DrawableObject::Radius
	fstp	DWORD PTR tv736[ebp]
	movss	xmm0, DWORD PTR tv736[ebp]
	addss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR tv417[ebp], xmm0
$LN41@CustomPosS:
	movss	xmm0, DWORD PTR tv417[ebp]
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+40, xmm0

; 569  : 							TACREF_Object.PosZ=14;

	movss	xmm0, DWORD PTR __real@41600000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+24, xmm0

; 570  : 							((DrawableBSP*)Vehicle->object)->SetDOFangle(1,30.0f *PI/180);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f060a92
	movss	DWORD PTR [esp], xmm0
	push	1
	mov	ecx, DWORD PTR _Vehicle$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 571  : 							break;

	jmp	$LN12@CustomPosS
$LN3@CustomPosS:

; 572  : 						case VIS_ZSU57_2:
; 573  : 							TACREF_Object.Distance=90.0f;

	movss	xmm0, DWORD PTR __real@42b40000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+8, xmm0

; 574  : 							TACREF_Object.MinDistance=max(20.0f,((DrawableBSP*)Vehicle->object)->Radius());

	mov	edx, DWORD PTR _Vehicle$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	call	?Radius@DrawableObject@@QBEMXZ		; DrawableObject::Radius
	fstp	DWORD PTR tv748[ebp]
	movss	xmm0, DWORD PTR __real@41a00000
	comiss	xmm0, DWORD PTR tv748[ebp]
	jbe	SHORT $LN42@CustomPosS
	movss	xmm0, DWORD PTR __real@41a00000
	movss	DWORD PTR tv451[ebp], xmm0
	jmp	SHORT $LN43@CustomPosS
$LN42@CustomPosS:
	mov	eax, DWORD PTR _Vehicle$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	?Radius@DrawableObject@@QBEMXZ		; DrawableObject::Radius
	fstp	DWORD PTR tv451[ebp]
$LN43@CustomPosS:
	movss	xmm0, DWORD PTR tv451[ebp]
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+40, xmm0

; 575  : 							TACREF_Object.PosZ=5;

	movss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+24, xmm0

; 576  : 							break;

	jmp	$LN12@CustomPosS
$LN2@CustomPosS:

; 577  : 						default:
; 578  : 							TACREF_Object.Distance=80.0f;

	movss	xmm0, DWORD PTR __real@42a00000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+8, xmm0

; 579  : 							TACREF_Object.MinDistance=max(40.0f,((DrawableBSP*)Vehicle->object)->Radius()+5);

	mov	ecx, DWORD PTR _Vehicle$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	call	?Radius@DrawableObject@@QBEMXZ		; DrawableObject::Radius
	fstp	DWORD PTR tv762[ebp]
	movss	xmm0, DWORD PTR tv762[ebp]
	addss	xmm0, DWORD PTR __real@40a00000
	movss	xmm1, DWORD PTR __real@42200000
	comiss	xmm1, xmm0
	jbe	SHORT $LN44@CustomPosS
	movss	xmm0, DWORD PTR __real@42200000
	movss	DWORD PTR tv479[ebp], xmm0
	jmp	SHORT $LN45@CustomPosS
$LN44@CustomPosS:
	mov	edx, DWORD PTR _Vehicle$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	call	?Radius@DrawableObject@@QBEMXZ		; DrawableObject::Radius
	fstp	DWORD PTR tv769[ebp]
	movss	xmm0, DWORD PTR tv769[ebp]
	addss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR tv479[ebp], xmm0
$LN45@CustomPosS:
	movss	xmm0, DWORD PTR tv479[ebp]
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+40, xmm0

; 580  : 							TACREF_Object.PosZ=5;

	movss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+24, xmm0
$LN12@CustomPosS:

; 581  : 							break;
; 582  : 					}
; 583  : 					TACREF_Object.Direction=0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+12, xmm0

; 584  : 
; 585  : 					TACREF_Object.MaxDistance=250.0f;

	movss	xmm0, DWORD PTR __real@437a0000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+44, xmm0

; 586  : 					TACREF_Object.MinPitch=5;

	movss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+52, xmm0

; 587  : 					TACREF_Object.MaxPitch=90;

	movss	xmm0, DWORD PTR __real@42b40000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+56, xmm0

; 588  : 					TACREF_Object.CheckPitch=TRUE;

	mov	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+48, 1

; 589  : 
; 590  : 					TACREF_Object.PosX=0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+16, xmm0

; 591  : 					TACREF_Object.PosY=0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+20, xmm0
$LN16@CustomPosS:

; 592  : 					break;
; 593  : 			}
; 594  : 			break;

	jmp	$LN20@CustomPosS
$LN1@CustomPosS:

; 595  : 		case CAT_MUNITIONS:
; 596  : 			TACREF_Object.Direction=0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+12, xmm0

; 597  : 
; 598  : 			TACREF_Object.MinPitch=0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+52, xmm0

; 599  : 			TACREF_Object.MaxPitch=0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+56, xmm0

; 600  : 			TACREF_Object.CheckPitch=FALSE;

	mov	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+48, 0

; 601  : 
; 602  : 			TACREF_Object.PosX=0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+16, xmm0

; 603  : 			TACREF_Object.PosY=0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+20, xmm0

; 604  : 			TACREF_Object.PosZ=0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+24, xmm0

; 605  : #if 0
; 606  : 			TACREF_Object.Distance=((DrawableBSP*)Vehicle->object)->Radius()*3;
; 607  : 			TACREF_Object.MinDistance=((DrawableBSP*)Vehicle->object)->Radius()+5;
; 608  : 			TACREF_Object.MaxDistance=((DrawableBSP*)Vehicle->object)->Radius()*10;
; 609  : #endif
; 610  : 			TACREF_Object.Distance=30.0f;

	movss	xmm0, DWORD PTR __real@41f00000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+8, xmm0

; 611  : 			TACREF_Object.MinDistance=20.0f;

	movss	xmm0, DWORD PTR __real@41a00000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+40, xmm0

; 612  : 			TACREF_Object.MaxDistance=50.f;

	movss	xmm0, DWORD PTR __real@42480000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+44, xmm0
$LN20@CustomPosS:

; 613  : 			break;
; 614  : 	}
; 615  : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN50@CustomPosS:
	DD	$LN9@CustomPosS
	DD	$LN5@CustomPosS
	DD	$LN6@CustomPosS
	DD	$LN8@CustomPosS
	DD	$LN2@CustomPosS
$LN48@CustomPosS:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	4
	DB	4
	DB	4
	DB	2
	DB	4
	DB	3
	DB	4
	DB	4
	DB	4
	DB	2
	DB	4
	DB	0
	npad	1
$LN51@CustomPosS:
	DD	$LN10@CustomPosS
	DD	$LN9@CustomPosS
	DD	$LN7@CustomPosS
	DD	$LN2@CustomPosS
$LN49@CustomPosS:
	DB	0
	DB	0
	DB	3
	DB	3
	DB	1
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	2
?CustomPosStuff@@YAXJJJPAUUI_BSPList@@@Z ENDP		; CustomPosStuff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\tacref\ui_tacref.cpp
_TEXT	SEGMENT
_obj$ = -20						; size = 4
_Weapon$ = -16						; size = 4
_visFlag$ = -12						; size = 4
_vc$ = -8						; size = 4
_i$ = -4						; size = 4
?Unload3dModel@@YAXXZ PROC				; Unload3dModel

; 433  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 434  : 	VehicleClassDataType* vc;
; 435  : 	long i,visFlag;
; 436  : 	BSPLIST *obj,*Weapon;
; 437  : 
; 438  : 	if (CurrentWeapon && CurrentModel)

	cmp	DWORD PTR ?CurrentWeapon@@3JA, 0	; CurrentWeapon
	je	$LN6@Unload3dMo
	cmp	DWORD PTR ?CurrentModel@@3JA, 0		; CurrentModel
	je	$LN6@Unload3dMo

; 439  : 	{
; 440  : 		obj=TAC_Viewer->Find(CurrentModel);

	mov	eax, DWORD PTR ?CurrentModel@@3JA	; CurrentModel
	push	eax
	mov	ecx, DWORD PTR ?TAC_Viewer@@3PAVC_3dViewer@@A ; TAC_Viewer
	call	?Find@C_3dViewer@@QAEPAUUI_BSPList@@J@Z	; C_3dViewer::Find
	mov	DWORD PTR _obj$[ebp], eax

; 441  : 		Weapon=TAC_Viewer->Find(CurrentWeapon);

	mov	ecx, DWORD PTR ?CurrentWeapon@@3JA	; CurrentWeapon
	push	ecx
	mov	ecx, DWORD PTR ?TAC_Viewer@@3PAVC_3dViewer@@A ; TAC_Viewer
	call	?Find@C_3dViewer@@QAEPAUUI_BSPList@@J@Z	; C_3dViewer::Find
	mov	DWORD PTR _Weapon$[ebp], eax

; 442  : 
; 443  : 		vc = GetVehicleClassData(CurrentEntity);

	mov	edx, DWORD PTR ?CurrentEntity@@3JA	; CurrentEntity
	push	edx
	call	?GetVehicleClassData@@YAPAUVehicleClassDataType@@H@Z ; GetVehicleClassData
	add	esp, 4
	mov	DWORD PTR _vc$[ebp], eax

; 444  : 		visFlag = vc->VisibleFlags;

	mov	eax, DWORD PTR _vc$[ebp]
	movzx	ecx, WORD PTR [eax+62]
	mov	DWORD PTR _visFlag$[ebp], ecx

; 445  : 
; 446  : 		for (i=0; i<HARDPOINT_MAX; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN5@Unload3dMo
$LN4@Unload3dMo:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN5@Unload3dMo:
	cmp	DWORD PTR _i$[ebp], 16			; 00000010H
	jge	SHORT $LN3@Unload3dMo

; 447  : 		{
; 448  : 			if (visFlag & (1 << i))

	mov	eax, 1
	mov	ecx, DWORD PTR _i$[ebp]
	shl	eax, cl
	and	eax, DWORD PTR _visFlag$[ebp]
	je	SHORT $LN2@Unload3dMo

; 449  : 			{
; 450  : 				// This is a visible weapon, so detach
; 451  : 				((DrawableBSP*)obj->object)->DetachChild(((DrawableBSP*)Weapon->object),i);

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Weapon$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	call	?DetachChild@DrawableBSP@@QAEXPAV1@H@Z	; DrawableBSP::DetachChild
$LN2@Unload3dMo:

; 452  : 			}
; 453  : 		}

	jmp	SHORT $LN4@Unload3dMo
$LN3@Unload3dMo:

; 454  : 		TAC_Viewer->Remove(CurrentWeapon);

	mov	edx, DWORD PTR ?CurrentWeapon@@3JA	; CurrentWeapon
	push	edx
	mov	ecx, DWORD PTR ?TAC_Viewer@@3PAVC_3dViewer@@A ; TAC_Viewer
	call	?Remove@C_3dViewer@@QAEHJ@Z		; C_3dViewer::Remove

; 455  : 		CurrentWeapon=0;

	mov	DWORD PTR ?CurrentWeapon@@3JA, 0	; CurrentWeapon
$LN6@Unload3dMo:

; 456  : 	}
; 457  : 	if(CurrentModel)

	cmp	DWORD PTR ?CurrentModel@@3JA, 0		; CurrentModel
	je	SHORT $LN7@Unload3dMo

; 458  : 	{
; 459  : 		TAC_Viewer->Remove(CurrentModel);

	mov	eax, DWORD PTR ?CurrentModel@@3JA	; CurrentModel
	push	eax
	mov	ecx, DWORD PTR ?TAC_Viewer@@3PAVC_3dViewer@@A ; TAC_Viewer
	call	?Remove@C_3dViewer@@QAEHJ@Z		; C_3dViewer::Remove

; 460  : 		CurrentModel=0;

	mov	DWORD PTR ?CurrentModel@@3JA, 0		; CurrentModel
$LN7@Unload3dMo:

; 461  : 	}
; 462  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Unload3dModel@@YAXXZ ENDP				; Unload3dModel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\tacref\ui_tacref.cpp
_TEXT	SEGMENT
_rwrval$ = -12						; size = 4
_UniqueID$ = -8						; size = 4
_radar$ = -4						; size = 4
_rwr$ = 8						; size = 4
_listbox$ = 12						; size = 4
?BuildRWRList@@YAXPAVRWR@@PAVC_ListBox@@@Z PROC		; BuildRWRList

; 399  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 400  : 	Radar *radar;
; 401  : 	long rwrval=0;

	mov	DWORD PTR _rwrval$[ebp], 0

; 402  : 	long UniqueID=1;

	mov	DWORD PTR _UniqueID$[ebp], 1

; 403  : 
; 404  : 	if(!rwr || !listbox)

	cmp	DWORD PTR _rwr$[ebp], 0
	je	SHORT $LN5@BuildRWRLi
	cmp	DWORD PTR _listbox$[ebp], 0
	jne	SHORT $LN6@BuildRWRLi
$LN5@BuildRWRLi:

; 405  : 		return;

	jmp	$LN7@BuildRWRLi
$LN6@BuildRWRLi:

; 406  : 
; 407  : 	radar=rwr->GetFirst(&rwrval);

	lea	eax, DWORD PTR _rwrval$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rwr$[ebp]
	call	?GetFirst@RWR@@QAEPAURadar@@PAJ@Z	; RWR::GetFirst
	mov	DWORD PTR _radar$[ebp], eax

; 408  : 	if(radar)

	cmp	DWORD PTR _radar$[ebp], 0
	je	$LN4@BuildRWRLi
$LN3@BuildRWRLi:

; 409  : 	{
; 410  : 		while(radar)

	cmp	DWORD PTR _radar$[ebp], 0
	je	$LN2@BuildRWRLi

; 411  : 		{
; 412  : 			listbox->AddItem(UniqueID,C_TYPE_ITEM,radar->Name);

	mov	ecx, DWORD PTR _radar$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	push	50					; 00000032H
	mov	edx, DWORD PTR _UniqueID$[ebp]
	push	edx
	mov	ecx, DWORD PTR _listbox$[ebp]
	call	?AddItem@C_ListBox@@QAEPAV1@JFPAD@Z	; C_ListBox::AddItem

; 413  : 			listbox->SetItemUserData(UniqueID,0,radar->SearchState);

	mov	eax, DWORD PTR _radar$[ebp]
	movsx	ecx, WORD PTR [eax]
	push	ecx
	push	0
	mov	edx, DWORD PTR _UniqueID$[ebp]
	push	edx
	mov	ecx, DWORD PTR _listbox$[ebp]
	call	?SetItemUserData@C_ListBox@@QAEXJFJ@Z	; C_ListBox::SetItemUserData

; 414  : 			listbox->SetItemUserData(UniqueID,1,radar->LockState);

	mov	eax, DWORD PTR _radar$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	push	ecx
	push	1
	mov	edx, DWORD PTR _UniqueID$[ebp]
	push	edx
	mov	ecx, DWORD PTR _listbox$[ebp]
	call	?SetItemUserData@C_ListBox@@QAEXJFJ@Z	; C_ListBox::SetItemUserData

; 415  : 			listbox->SetItemUserData(UniqueID,2,radar->SearchTone);

	mov	eax, DWORD PTR _radar$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	2
	mov	edx, DWORD PTR _UniqueID$[ebp]
	push	edx
	mov	ecx, DWORD PTR _listbox$[ebp]
	call	?SetItemUserData@C_ListBox@@QAEXJFJ@Z	; C_ListBox::SetItemUserData

; 416  : 			listbox->SetItemUserData(UniqueID,3,radar->LockTone);

	mov	eax, DWORD PTR _radar$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	push	3
	mov	edx, DWORD PTR _UniqueID$[ebp]
	push	edx
	mov	ecx, DWORD PTR _listbox$[ebp]
	call	?SetItemUserData@C_ListBox@@QAEXJFJ@Z	; C_ListBox::SetItemUserData

; 417  : 			UniqueID++;

	mov	eax, DWORD PTR _UniqueID$[ebp]
	add	eax, 1
	mov	DWORD PTR _UniqueID$[ebp], eax

; 418  : 			radar=rwr->GetNext(&rwrval);

	lea	ecx, DWORD PTR _rwrval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _rwr$[ebp]
	call	?GetNext@RWR@@QAEPAURadar@@PAJ@Z	; RWR::GetNext
	mov	DWORD PTR _radar$[ebp], eax

; 419  : 		}

	jmp	$LN3@BuildRWRLi
$LN2@BuildRWRLi:

; 420  : 	}
; 421  : 	else

	jmp	SHORT $LN1@BuildRWRLi
$LN4@BuildRWRLi:

; 422  : 	{
; 423  : 		listbox->AddItem(1,C_TYPE_ITEM,TXT_NO_RADAR);

	push	195					; 000000c3H
	push	50					; 00000032H
	push	1
	mov	ecx, DWORD PTR _listbox$[ebp]
	call	?AddItem@C_ListBox@@QAEPAV1@JFJ@Z	; C_ListBox::AddItem

; 424  : 		listbox->SetItemUserData(1,0,0);

	push	0
	push	0
	push	1
	mov	ecx, DWORD PTR _listbox$[ebp]
	call	?SetItemUserData@C_ListBox@@QAEXJFJ@Z	; C_ListBox::SetItemUserData

; 425  : 		listbox->SetItemUserData(1,1,0);

	push	0
	push	1
	push	1
	mov	ecx, DWORD PTR _listbox$[ebp]
	call	?SetItemUserData@C_ListBox@@QAEXJFJ@Z	; C_ListBox::SetItemUserData

; 426  : 		listbox->SetItemUserData(1,2,-1);

	push	-1
	push	2
	push	1
	mov	ecx, DWORD PTR _listbox$[ebp]
	call	?SetItemUserData@C_ListBox@@QAEXJFJ@Z	; C_ListBox::SetItemUserData

; 427  : 		listbox->SetItemUserData(1,3,-1);

	push	-1
	push	3
	push	1
	mov	ecx, DWORD PTR _listbox$[ebp]
	call	?SetItemUserData@C_ListBox@@QAEXJFJ@Z	; C_ListBox::SetItemUserData
$LN1@BuildRWRLi:

; 428  : 	}
; 429  : 	listbox->SetValue(1);

	push	1
	mov	ecx, DWORD PTR _listbox$[ebp]
	call	?SetValue@C_ListBox@@QAEXJ@Z		; C_ListBox::SetValue
$LN7@BuildRWRLi:

; 430  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?BuildRWRList@@YAXPAVRWR@@PAVC_ListBox@@@Z ENDP		; BuildRWRList
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\tacref\ui_tacref.cpp
_TEXT	SEGMENT
_lbox$ = -16						; size = 4
_item$ = -12						; size = 4
_win$ = -8						; size = 4
_btn$ = -4						; size = 4
_ID$ = 8						; size = 4
?SelectRWR@@YAXJ@Z PROC					; SelectRWR

; 353  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 354  : 	C_Window *win;
; 355  : 	C_ListBox *lbox;
; 356  : 	C_Button *btn;
; 357  : 	LISTBOX *item;
; 358  : 
; 359  : 	win=gMainHandler->FindWindow(TAC_REF_WIN);

	push	8000					; 00001f40H
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z ; C_Handler::FindWindowA
	mov	DWORD PTR _win$[ebp], eax

; 360  : 	if(win)

	cmp	DWORD PTR _win$[ebp], 0
	je	$LN9@SelectRWR

; 361  : 	{
; 362  : 		lbox=(C_ListBox*)win->FindControl(RWR_LIST);

	push	8407					; 000020d7H
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _lbox$[ebp], eax

; 363  : 		if(lbox)

	cmp	DWORD PTR _lbox$[ebp], 0
	je	$LN9@SelectRWR

; 364  : 		{
; 365  : 			item=lbox->FindID(ID);

	mov	eax, DWORD PTR _ID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?FindID@C_ListBox@@QAEPAVLISTBOX@@J@Z	; C_ListBox::FindID
	mov	DWORD PTR _item$[ebp], eax

; 366  : 			if(item)

	cmp	DWORD PTR _item$[ebp], 0
	je	SHORT $LN6@SelectRWR

; 367  : 			{
; 368  : 				btn=(C_Button*)win->FindControl(PLAY_LOCK_TONE);

	push	8012					; 00001f4cH
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _btn$[ebp], eax

; 369  : 				if(btn)

	cmp	DWORD PTR _btn$[ebp], 0
	je	SHORT $LN5@SelectRWR

; 370  : 					btn->SetUserNumber(0,item->Label_->GetUserNumber(3));

	push	3
	mov	ecx, DWORD PTR _item$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetUserNumber@C_Base@@QAEJJ@Z		; C_Base::GetUserNumber
	push	eax
	push	0
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetUserNumber@C_Base@@QAEXJJ@Z		; C_Base::SetUserNumber
$LN5@SelectRWR:

; 371  : 
; 372  : 				btn=(C_Button*)win->FindControl(LOCK_ICON);

	push	8010					; 00001f4aH
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _btn$[ebp], eax

; 373  : 				if(btn)

	cmp	DWORD PTR _btn$[ebp], 0
	je	SHORT $LN4@SelectRWR

; 374  : 				{
; 375  : 					btn->Refresh();

	mov	edx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [eax+160]
	call	edx

; 376  : 					btn->SetState(static_cast<short>(item->Label_->GetUserNumber(1)));

	push	1
	mov	eax, DWORD PTR _item$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetUserNumber@C_Base@@QAEJJ@Z		; C_Base::GetUserNumber
	push	eax
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 377  : 					btn->Refresh();

	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN4@SelectRWR:

; 378  : 				}
; 379  : 			}
; 380  : 			else

	jmp	SHORT $LN9@SelectRWR
$LN6@SelectRWR:

; 381  : 			{
; 382  : 				btn=(C_Button*)win->FindControl(PLAY_LOCK_TONE);

	push	8012					; 00001f4cH
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _btn$[ebp], eax

; 383  : 				if(btn)

	cmp	DWORD PTR _btn$[ebp], 0
	je	SHORT $LN2@SelectRWR

; 384  : 					btn->SetUserNumber(0,-1);

	push	-1
	push	0
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetUserNumber@C_Base@@QAEXJJ@Z		; C_Base::SetUserNumber
$LN2@SelectRWR:

; 385  : 
; 386  : 				btn=(C_Button*)win->FindControl(LOCK_ICON);

	push	8010					; 00001f4aH
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _btn$[ebp], eax

; 387  : 				if(btn)

	cmp	DWORD PTR _btn$[ebp], 0
	je	SHORT $LN9@SelectRWR

; 388  : 				{
; 389  : 					btn->Refresh();

	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax

; 390  : 					btn->SetState(0);

	push	0
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 391  : 					btn->Refresh();

	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN9@SelectRWR:

; 392  : 				}
; 393  : 			}
; 394  : 		}
; 395  : 	}
; 396  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SelectRWR@@YAXJ@Z ENDP					; SelectRWR
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\tacref\ui_tacref.cpp
_TEXT	SEGMENT
tv219 = -48						; size = 4
$T2 = -44						; size = 4
_textval$ = -40						; size = 4
_item$ = -36						; size = 4
tv91 = -32						; size = 4
$T3 = -28						; size = 4
_desctext$ = -24					; size = 4
_UniqueID$ = -20					; size = 4
_txt$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_desc$ = 8						; size = 4
_tree$ = 12						; size = 4
?BuildDescTree@@YAXPAVDescription@@PAVC_TreeList@@@Z PROC ; BuildDescTree

; 319  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?BuildDescTree@@YAXPAVDescription@@PAVC_TreeList@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 320  : 	C_Text *txt;
; 321  : 	TREELIST *item;
; 322  : 	TextString *desctext;
; 323  : 	long textval=0;

	mov	DWORD PTR _textval$[ebp], 0

; 324  : 	long UniqueID=1;

	mov	DWORD PTR _UniqueID$[ebp], 1

; 325  : 
; 326  : 	if(!desc || !tree)

	cmp	DWORD PTR _desc$[ebp], 0
	je	SHORT $LN4@BuildDescT
	cmp	DWORD PTR _tree$[ebp], 0
	jne	SHORT $LN5@BuildDescT
$LN4@BuildDescT:

; 327  : 		return;

	jmp	$LN6@BuildDescT
$LN5@BuildDescT:

; 328  : 
; 329  : 	tree->Parent_->ScanClientArea(tree->GetClient());

	mov	ecx, DWORD PTR _tree$[ebp]
	call	?GetClient@C_Base@@QAEFXZ		; C_Base::GetClient
	cwde
	push	eax
	mov	ecx, DWORD PTR _tree$[ebp]
	mov	ecx, DWORD PTR [ecx+48]
	call	?ScanClientArea@C_Window@@QAEXJ@Z	; C_Window::ScanClientArea

; 330  : 	desctext=desc->GetFirst(&textval);

	lea	edx, DWORD PTR _textval$[ebp]
	push	edx
	mov	ecx, DWORD PTR _desc$[ebp]
	call	?GetFirst@Description@@QAEPAUTextString@@PAJ@Z ; Description::GetFirst
	mov	DWORD PTR _desctext$[ebp], eax
$LN3@BuildDescT:

; 331  : 	while(desctext)

	cmp	DWORD PTR _desctext$[ebp], 0
	je	$LN2@BuildDescT

; 332  : 	{
; 333  : 		txt=new C_Text;

	push	76					; 0000004cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN8@BuildDescT
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0C_Text@@QAE@XZ			; C_Text::C_Text
	mov	DWORD PTR tv91[ebp], eax
	jmp	SHORT $LN9@BuildDescT
$LN8@BuildDescT:
	mov	DWORD PTR tv91[ebp], 0
$LN9@BuildDescT:
	mov	eax, DWORD PTR tv91[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR _txt$[ebp], ecx

; 334  : 		txt->Setup(UniqueID,0);

	push	0
	mov	edx, DWORD PTR _UniqueID$[ebp]
	push	edx
	mov	eax, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax

; 335  : 		txt->SetW(tree->Parent_->ClientArea_[tree->GetClient()].right-tree->Parent_->ClientArea_[tree->GetClient()].left-10 - tree->GetX());

	mov	ecx, DWORD PTR _tree$[ebp]
	mov	esi, DWORD PTR [ecx+48]
	mov	ecx, DWORD PTR _tree$[ebp]
	call	?GetClient@C_Base@@QAEFXZ		; C_Base::GetClient
	movsx	edi, ax
	shl	edi, 4
	mov	edx, DWORD PTR _tree$[ebp]
	mov	ebx, DWORD PTR [edx+48]
	mov	ecx, DWORD PTR _tree$[ebp]
	call	?GetClient@C_Base@@QAEFXZ		; C_Base::GetClient
	cwde
	shl	eax, 4
	mov	esi, DWORD PTR [esi+edi+176]
	sub	esi, DWORD PTR [ebx+eax+168]
	sub	esi, 10					; 0000000aH
	mov	ecx, DWORD PTR _tree$[ebp]
	call	?GetX@C_Base@@QAEJXZ			; C_Base::GetX
	sub	esi, eax
	push	esi
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+24]
	call	eax

; 336  : 		txt->SetFlagBitOn(C_BIT_WORDWRAP);

	push	33554432				; 02000000H
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 337  : 		txt->SetFont(tree->GetFont());

	mov	ecx, DWORD PTR _tree$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _tree$[ebp]
	mov	eax, DWORD PTR [edx+124]
	call	eax
	push	eax
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+68]
	call	eax

; 338  : 		txt->SetFixedWidth(desctext->length);

	mov	ecx, DWORD PTR _desctext$[ebp]
	movsx	edx, WORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetFixedWidth@C_Text@@QAEXJ@Z		; C_Text::SetFixedWidth

; 339  : 		txt->SetText(desctext->String);

	mov	eax, DWORD PTR _desctext$[ebp]
	add	eax, 2
	push	eax
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+256]
	call	eax

; 340  : 
; 341  : 		item=tree->CreateItem(UniqueID++,C_TYPE_ITEM,txt);

	mov	ecx, DWORD PTR _UniqueID$[ebp]
	mov	DWORD PTR tv219[ebp], ecx
	mov	edx, DWORD PTR _txt$[ebp]
	push	edx
	push	50					; 00000032H
	mov	eax, DWORD PTR tv219[ebp]
	push	eax
	mov	ecx, DWORD PTR _tree$[ebp]
	call	?CreateItem@C_TreeList@@QAEPAVTREELIST@@JJPAVC_Base@@@Z ; C_TreeList::CreateItem
	mov	DWORD PTR _item$[ebp], eax
	mov	ecx, DWORD PTR _UniqueID$[ebp]
	add	ecx, 1
	mov	DWORD PTR _UniqueID$[ebp], ecx

; 342  : 		if(item)

	cmp	DWORD PTR _item$[ebp], 0
	je	SHORT $LN1@BuildDescT

; 343  : 			tree->AddItem(tree->GetRoot(),item);

	mov	edx, DWORD PTR _item$[ebp]
	push	edx
	mov	ecx, DWORD PTR _tree$[ebp]
	call	?GetRoot@C_TreeList@@QAEPAVTREELIST@@XZ	; C_TreeList::GetRoot
	push	eax
	mov	ecx, DWORD PTR _tree$[ebp]
	call	?AddItem@C_TreeList@@QAEHPAVTREELIST@@0@Z ; C_TreeList::AddItem
$LN1@BuildDescT:

; 344  : 
; 345  : 		desctext=desc->GetNext(&textval);

	lea	eax, DWORD PTR _textval$[ebp]
	push	eax
	mov	ecx, DWORD PTR _desc$[ebp]
	call	?GetNext@Description@@QAEPAUTextString@@PAJ@Z ; Description::GetNext
	mov	DWORD PTR _desctext$[ebp], eax

; 346  : 	}

	jmp	$LN3@BuildDescT
$LN2@BuildDescT:

; 347  : 	tree->RecalcSize();

	mov	ecx, DWORD PTR _tree$[ebp]
	call	?RecalcSize@C_TreeList@@QAEXXZ		; C_TreeList::RecalcSize

; 348  : 	tree->Parent_->ScanClientArea(tree->GetClient());

	mov	ecx, DWORD PTR _tree$[ebp]
	call	?GetClient@C_Base@@QAEFXZ		; C_Base::GetClient
	movsx	ecx, ax
	push	ecx
	mov	edx, DWORD PTR _tree$[ebp]
	mov	ecx, DWORD PTR [edx+48]
	call	?ScanClientArea@C_Window@@QAEXJ@Z	; C_Window::ScanClientArea

; 349  : 	tree->Parent_->RefreshClient(tree->GetClient());

	mov	ecx, DWORD PTR _tree$[ebp]
	call	?GetClient@C_Base@@QAEFXZ		; C_Base::GetClient
	cwde
	push	eax
	mov	ecx, DWORD PTR _tree$[ebp]
	mov	ecx, DWORD PTR [ecx+48]
	call	?RefreshClient@C_Window@@QAEXJ@Z	; C_Window::RefreshClient
$LN6@BuildDescT:

; 350  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?BuildDescTree@@YAXPAVDescription@@PAVC_TreeList@@@Z$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?BuildDescTree@@YAXPAVDescription@@PAVC_TreeList@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?BuildDescTree@@YAXPAVDescription@@PAVC_TreeList@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?BuildDescTree@@YAXPAVDescription@@PAVC_TreeList@@@Z ENDP ; BuildDescTree
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\tacref\ui_tacref.cpp
_TEXT	SEGMENT
tv160 = -48						; size = 4
$T2 = -44						; size = 4
_catval$ = -40						; size = 4
tv91 = -36						; size = 4
$T3 = -32						; size = 4
_par$ = -28						; size = 4
_UniqueID$ = -24					; size = 4
_cat$ = -20						; size = 4
_txt$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_stats$ = 8						; size = 4
_tree$ = 12						; size = 4
?BuildStatsTree@@YAXPAVStatistics@@PAVC_TreeList@@@Z PROC ; BuildStatsTree

; 285  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?BuildStatsTree@@YAXPAVStatistics@@PAVC_TreeList@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 286  : 	C_Text *txt;
; 287  : 	Category *cat;
; 288  : 	TREELIST *par;
; 289  : 	long catval=0; // internal... don't use for anything

	mov	DWORD PTR _catval$[ebp], 0

; 290  : 	long UniqueID=1;

	mov	DWORD PTR _UniqueID$[ebp], 1

; 291  : 
; 292  : 	if(!stats || !tree)

	cmp	DWORD PTR _stats$[ebp], 0
	je	SHORT $LN4@BuildStats
	cmp	DWORD PTR _tree$[ebp], 0
	jne	SHORT $LN5@BuildStats
$LN4@BuildStats:

; 293  : 		return;

	jmp	$LN6@BuildStats
$LN5@BuildStats:

; 294  : 
; 295  : 	tree->Parent_->ScanClientArea(tree->GetClient());

	mov	ecx, DWORD PTR _tree$[ebp]
	call	?GetClient@C_Base@@QAEFXZ		; C_Base::GetClient
	cwde
	push	eax
	mov	ecx, DWORD PTR _tree$[ebp]
	mov	ecx, DWORD PTR [ecx+48]
	call	?ScanClientArea@C_Window@@QAEXJ@Z	; C_Window::ScanClientArea

; 296  : 	cat=stats->GetFirst(&catval);

	lea	edx, DWORD PTR _catval$[ebp]
	push	edx
	mov	ecx, DWORD PTR _stats$[ebp]
	call	?GetFirst@Statistics@@QAEPAVCategory@@PAJ@Z ; Statistics::GetFirst
	mov	DWORD PTR _cat$[ebp], eax
$LN3@BuildStats:

; 297  : 	while(cat)

	cmp	DWORD PTR _cat$[ebp], 0
	je	$LN2@BuildStats

; 298  : 	{
; 299  : 		txt=new C_Text;

	push	76					; 0000004cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN8@BuildStats
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0C_Text@@QAE@XZ			; C_Text::C_Text
	mov	DWORD PTR tv91[ebp], eax
	jmp	SHORT $LN9@BuildStats
$LN8@BuildStats:
	mov	DWORD PTR tv91[ebp], 0
$LN9@BuildStats:
	mov	eax, DWORD PTR tv91[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR _txt$[ebp], ecx

; 300  : 		txt->Setup(C_DONT_CARE,0);

	push	0
	push	-2					; fffffffeH
	mov	edx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax+248]
	call	edx

; 301  : 		txt->SetFixedWidth(40);

	push	40					; 00000028H
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetFixedWidth@C_Text@@QAEXJ@Z		; C_Text::SetFixedWidth

; 302  : 		txt->SetFont(tree->GetFont());

	mov	eax, DWORD PTR _tree$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _tree$[ebp]
	mov	eax, DWORD PTR [edx+124]
	call	eax
	push	eax
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+68]
	call	eax

; 303  : 		txt->SetText(cat->Name);

	mov	ecx, DWORD PTR _cat$[ebp]
	add	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax+256]
	call	edx

; 304  : 
; 305  : 		par=tree->CreateItem(UniqueID++,C_TYPE_MENU,txt);

	mov	eax, DWORD PTR _UniqueID$[ebp]
	mov	DWORD PTR tv160[ebp], eax
	mov	ecx, DWORD PTR _txt$[ebp]
	push	ecx
	push	49					; 00000031H
	mov	edx, DWORD PTR tv160[ebp]
	push	edx
	mov	ecx, DWORD PTR _tree$[ebp]
	call	?CreateItem@C_TreeList@@QAEPAVTREELIST@@JJPAVC_Base@@@Z ; C_TreeList::CreateItem
	mov	DWORD PTR _par$[ebp], eax
	mov	eax, DWORD PTR _UniqueID$[ebp]
	add	eax, 1
	mov	DWORD PTR _UniqueID$[ebp], eax

; 306  : 		if(par)

	cmp	DWORD PTR _par$[ebp], 0
	je	SHORT $LN1@BuildStats

; 307  : 		{
; 308  : 			tree->AddItem(tree->GetRoot(),par);

	mov	ecx, DWORD PTR _par$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _tree$[ebp]
	call	?GetRoot@C_TreeList@@QAEPAVTREELIST@@XZ	; C_TreeList::GetRoot
	push	eax
	mov	ecx, DWORD PTR _tree$[ebp]
	call	?AddItem@C_TreeList@@QAEHPAVTREELIST@@0@Z ; C_TreeList::AddItem

; 309  : 			BuildCatTree(cat,tree,par);

	mov	edx, DWORD PTR _par$[ebp]
	push	edx
	mov	eax, DWORD PTR _tree$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cat$[ebp]
	push	ecx
	call	?BuildCatTree@@YAXPAVCategory@@PAVC_TreeList@@PAVTREELIST@@@Z ; BuildCatTree
	add	esp, 12					; 0000000cH
$LN1@BuildStats:

; 310  : 		}
; 311  : 		cat=stats->GetNext(&catval);

	lea	edx, DWORD PTR _catval$[ebp]
	push	edx
	mov	ecx, DWORD PTR _stats$[ebp]
	call	?GetNext@Statistics@@QAEPAVCategory@@PAJ@Z ; Statistics::GetNext
	mov	DWORD PTR _cat$[ebp], eax

; 312  : 	}

	jmp	$LN3@BuildStats
$LN2@BuildStats:

; 313  : 	tree->RecalcSize();

	mov	ecx, DWORD PTR _tree$[ebp]
	call	?RecalcSize@C_TreeList@@QAEXXZ		; C_TreeList::RecalcSize

; 314  : 	tree->Parent_->ScanClientArea(tree->GetClient());

	mov	ecx, DWORD PTR _tree$[ebp]
	call	?GetClient@C_Base@@QAEFXZ		; C_Base::GetClient
	cwde
	push	eax
	mov	ecx, DWORD PTR _tree$[ebp]
	mov	ecx, DWORD PTR [ecx+48]
	call	?ScanClientArea@C_Window@@QAEXJ@Z	; C_Window::ScanClientArea

; 315  : 	tree->Parent_->RefreshClient(tree->GetClient());

	mov	ecx, DWORD PTR _tree$[ebp]
	call	?GetClient@C_Base@@QAEFXZ		; C_Base::GetClient
	movsx	edx, ax
	push	edx
	mov	eax, DWORD PTR _tree$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	call	?RefreshClient@C_Window@@QAEXJ@Z	; C_Window::RefreshClient
$LN6@BuildStats:

; 316  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?BuildStatsTree@@YAXPAVStatistics@@PAVC_TreeList@@@Z$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?BuildStatsTree@@YAXPAVStatistics@@PAVC_TreeList@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?BuildStatsTree@@YAXPAVStatistics@@PAVC_TreeList@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?BuildStatsTree@@YAXPAVStatistics@@PAVC_TreeList@@@Z ENDP ; BuildStatsTree
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\tacref\ui_tacref.cpp
_TEXT	SEGMENT
$T2 = -40						; size = 4
_textval$ = -36						; size = 4
_item$ = -32						; size = 4
tv75 = -28						; size = 4
$T3 = -24						; size = 4
_cattext$ = -20						; size = 4
_txt$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_cat$ = 8						; size = 4
_tree$ = 12						; size = 4
_parent$ = 16						; size = 4
?BuildCatTree@@YAXPAVCategory@@PAVC_TreeList@@PAVTREELIST@@@Z PROC ; BuildCatTree

; 261  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?BuildCatTree@@YAXPAVCategory@@PAVC_TreeList@@PAVTREELIST@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 262  : 	C_Text *txt;
; 263  : 	TREELIST *item;
; 264  : 	CatText *cattext;
; 265  : 	long textval=0;

	mov	DWORD PTR _textval$[ebp], 0

; 266  : 
; 267  : 	cattext=cat->GetFirst(&textval);

	lea	eax, DWORD PTR _textval$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cat$[ebp]
	call	?GetFirst@Category@@QAEPAUCatText@@PAJ@Z ; Category::GetFirst
	mov	DWORD PTR _cattext$[ebp], eax
$LN3@BuildCatTr:

; 268  : 	while(cattext)

	cmp	DWORD PTR _cattext$[ebp], 0
	je	$LN4@BuildCatTr

; 269  : 	{
; 270  : 		txt=new C_Text;

	push	76					; 0000004cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN6@BuildCatTr
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0C_Text@@QAE@XZ			; C_Text::C_Text
	mov	DWORD PTR tv75[ebp], eax
	jmp	SHORT $LN7@BuildCatTr
$LN6@BuildCatTr:
	mov	DWORD PTR tv75[ebp], 0
$LN7@BuildCatTr:
	mov	ecx, DWORD PTR tv75[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR _txt$[ebp], edx

; 271  : 		txt->Setup(C_DONT_CARE,0);

	push	0
	push	-2					; fffffffeH
	mov	eax, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax

; 272  : 		txt->SetFixedWidth(cattext->length);

	mov	ecx, DWORD PTR _cattext$[ebp]
	movsx	edx, WORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetFixedWidth@C_Text@@QAEXJ@Z		; C_Text::SetFixedWidth

; 273  : 		txt->SetText(cattext->String);

	mov	eax, DWORD PTR _cattext$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+256]
	call	eax

; 274  : 		txt->SetFont(tree->GetFont());

	mov	ecx, DWORD PTR _tree$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _tree$[ebp]
	mov	eax, DWORD PTR [edx+124]
	call	eax
	push	eax
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+68]
	call	eax

; 275  : 
; 276  : 		item=tree->CreateItem(C_DONT_CARE,C_TYPE_ITEM,txt);

	mov	ecx, DWORD PTR _txt$[ebp]
	push	ecx
	push	50					; 00000032H
	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _tree$[ebp]
	call	?CreateItem@C_TreeList@@QAEPAVTREELIST@@JJPAVC_Base@@@Z ; C_TreeList::CreateItem
	mov	DWORD PTR _item$[ebp], eax

; 277  : 		if(item)

	cmp	DWORD PTR _item$[ebp], 0
	je	SHORT $LN1@BuildCatTr

; 278  : 			tree->AddChildItem(parent,item);

	mov	edx, DWORD PTR _item$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tree$[ebp]
	call	?AddChildItem@C_TreeList@@QAEHPAVTREELIST@@0@Z ; C_TreeList::AddChildItem
$LN1@BuildCatTr:

; 279  : 
; 280  : 		cattext=cat->GetNext(&textval);

	lea	ecx, DWORD PTR _textval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _cat$[ebp]
	call	?GetNext@Category@@QAEPAUCatText@@PAJ@Z	; Category::GetNext
	mov	DWORD PTR _cattext$[ebp], eax

; 281  : 	}

	jmp	$LN3@BuildCatTr
$LN4@BuildCatTr:

; 282  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?BuildCatTree@@YAXPAVCategory@@PAVC_TreeList@@PAVTREELIST@@@Z$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?BuildCatTree@@YAXPAVCategory@@PAVC_TreeList@@PAVTREELIST@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?BuildCatTree@@YAXPAVCategory@@PAVC_TreeList@@PAVTREELIST@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?BuildCatTree@@YAXPAVCategory@@PAVC_TreeList@@PAVTREELIST@@@Z ENDP ; BuildCatTree
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\tacref\ui_tacref.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 2
_control$ = 16						; size = 4
?TACREF_ViewTimerCB@@YAXJFPAVC_Base@@@Z PROC		; TACREF_ViewTimerCB

; 256  : {

	push	ebp
	mov	ebp, esp

; 257  : 	control->Parent_->RefreshClient(0);

	push	0
	mov	eax, DWORD PTR _control$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	call	?RefreshClient@C_Window@@QAEXJ@Z	; C_Window::RefreshClient

; 258  : }

	pop	ebp
	ret	0
?TACREF_ViewTimerCB@@YAXJFPAVC_Base@@@Z ENDP		; TACREF_ViewTimerCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\tacref\ui_tacref.cpp
_TEXT	SEGMENT
_obj$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 2
_control$ = 16						; size = 4
?TACREF_ViewTimerAnimCB@@YAXJFPAVC_Base@@@Z PROC	; TACREF_ViewTimerAnimCB

; 226  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 227  : 	BSPLIST *obj;
; 228  : 	if(control->GetUserNumber(_UI95_TIMER_COUNTER_) < 1)

	push	5
	mov	ecx, DWORD PTR _control$[ebp]
	call	?GetUserNumber@C_Base@@QAEJJ@Z		; C_Base::GetUserNumber
	cmp	eax, 1
	jge	$LN6@TACREF_Vie

; 229  : 	{
; 230  : 		if(Helicopter)

	cmp	DWORD PTR ?Helicopter@@3HA, 0		; Helicopter
	je	$LN4@TACREF_Vie

; 231  : 		{
; 232  : 			obj=TAC_Viewer->Find(CurrentModel);

	mov	eax, DWORD PTR ?CurrentModel@@3JA	; CurrentModel
	push	eax
	mov	ecx, DWORD PTR ?TAC_Viewer@@3PAVC_3dViewer@@A ; TAC_Viewer
	call	?Find@C_3dViewer@@QAEPAUUI_BSPList@@J@Z	; C_3dViewer::Find
	mov	DWORD PTR _obj$[ebp], eax

; 233  : 			if(obj)

	cmp	DWORD PTR _obj$[ebp], 0
	je	SHORT $LN4@TACREF_Vie

; 234  : 			{
; 235  : 				BladeAngle += PI * 0.2f;

	movss	xmm0, DWORD PTR ?BladeAngle@@3MA
	addss	xmm0, DWORD PTR __real@3f20d97c
	movss	DWORD PTR ?BladeAngle@@3MA, xmm0

; 236  : 				if(BladeAngle > (PI*2.0f))

	movss	xmm0, DWORD PTR ?BladeAngle@@3MA
	comiss	xmm0, DWORD PTR __real@40c90fdb
	jbe	SHORT $LN3@TACREF_Vie

; 237  : 					BladeAngle -= PI*2.0f;

	movss	xmm0, DWORD PTR ?BladeAngle@@3MA
	subss	xmm0, DWORD PTR __real@40c90fdb
	movss	DWORD PTR ?BladeAngle@@3MA, xmm0
$LN3@TACREF_Vie:

; 238  : 
; 239  : 				((DrawableBSP*)obj->object)->SetDOFangle(2,BladeAngle);

	push	ecx
	movss	xmm0, DWORD PTR ?BladeAngle@@3MA
	movss	DWORD PTR [esp], xmm0
	push	2
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 240  : 				((DrawableBSP*)obj->object)->SetDOFangle(4,BladeAngle);

	push	ecx
	movss	xmm0, DWORD PTR ?BladeAngle@@3MA
	movss	DWORD PTR [esp], xmm0
	push	4
	mov	edx, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle
$LN4@TACREF_Vie:

; 241  : 			}
; 242  : 		}
; 243  : 
; 244  : 		if(control->GetFlags() & C_BIT_ABSOLUTE)

	mov	ecx, DWORD PTR _control$[ebp]
	call	?GetFlags@C_Base@@QAEJXZ		; C_Base::GetFlags
	and	eax, 262144				; 00040000H
	je	SHORT $LN2@TACREF_Vie

; 245  : 		{
; 246  : 			control->Parent_->RefreshWindow();

	mov	eax, DWORD PTR _control$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	call	?RefreshWindow@C_Window@@QAEXXZ		; C_Window::RefreshWindow

; 247  : 		}
; 248  : 		else

	jmp	SHORT $LN1@TACREF_Vie
$LN2@TACREF_Vie:

; 249  : 			control->Parent_->RefreshClient(control->GetClient());

	mov	ecx, DWORD PTR _control$[ebp]
	call	?GetClient@C_Base@@QAEFXZ		; C_Base::GetClient
	movsx	ecx, ax
	push	ecx
	mov	edx, DWORD PTR _control$[ebp]
	mov	ecx, DWORD PTR [edx+48]
	call	?RefreshClient@C_Window@@QAEXJ@Z	; C_Window::RefreshClient
$LN1@TACREF_Vie:

; 250  : 		control->SetUserNumber(_UI95_TIMER_COUNTER_,control->GetUserNumber(_UI95_TIMER_DELAY_));

	push	4
	mov	ecx, DWORD PTR _control$[ebp]
	call	?GetUserNumber@C_Base@@QAEJJ@Z		; C_Base::GetUserNumber
	push	eax
	push	5
	mov	ecx, DWORD PTR _control$[ebp]
	call	?SetUserNumber@C_Base@@QAEXJJ@Z		; C_Base::SetUserNumber
$LN6@TACREF_Vie:

; 251  : 	}
; 252  : 	control->SetUserNumber(_UI95_TIMER_COUNTER_,control->GetUserNumber(_UI95_TIMER_COUNTER_)-1);

	push	5
	mov	ecx, DWORD PTR _control$[ebp]
	call	?GetUserNumber@C_Base@@QAEJJ@Z		; C_Base::GetUserNumber
	sub	eax, 1
	push	eax
	push	5
	mov	ecx, DWORD PTR _control$[ebp]
	call	?SetUserNumber@C_Base@@QAEXJJ@Z		; C_Base::SetUserNumber

; 253  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?TACREF_ViewTimerAnimCB@@YAXJFPAVC_Base@@@Z ENDP	; TACREF_ViewTimerAnimCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\tacref\ui_tacref.cpp
_TEXT	SEGMENT
_dy$ = -8						; size = 4
_pnr$ = -4						; size = 4
___formal$ = 8						; size = 4
_hittype$ = 12						; size = 2
_control$ = 16						; size = 4
?TACREF_ZoomCB@@YAXJFPAVC_Base@@@Z PROC			; TACREF_ZoomCB

; 205  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 206  : 	float dy;
; 207  : 	C_Panner *pnr;
; 208  : 
; 209  : 
; 210  : 	if(hittype != C_TYPE_LMOUSEUP && hittype != C_TYPE_REPEAT)

	movsx	eax, WORD PTR _hittype$[ebp]
	cmp	eax, 52					; 00000034H
	je	SHORT $LN3@TACREF_Zoo
	movsx	ecx, WORD PTR _hittype$[ebp]
	cmp	ecx, 70					; 00000046H
	je	SHORT $LN3@TACREF_Zoo

; 211  : 		return;

	jmp	$LN4@TACREF_Zoo
$LN3@TACREF_Zoo:

; 212  : 
; 213  : 	
; 214  : 
; 215  : 	pnr=(C_Panner*)control;

	mov	edx, DWORD PTR _control$[ebp]
	mov	DWORD PTR _pnr$[ebp], edx

; 216  : 	dy=static_cast<float>(pnr->GetVRange());

	mov	ecx, DWORD PTR _pnr$[ebp]
	call	?GetVRange@C_Panner@@QAEJXZ		; C_Panner::GetVRange
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _dy$[ebp], xmm0

; 217  : 
; 218  : 	TACREF_Object.Distance+=dy;

	movss	xmm0, DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+8
	addss	xmm0, DWORD PTR _dy$[ebp]
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+8, xmm0

; 219  : 	if(TACREF_Object.Distance < TACREF_Object.MinDistance) TACREF_Object.Distance=TACREF_Object.MinDistance;

	movss	xmm0, DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+40
	comiss	xmm0, DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+8
	jbe	SHORT $LN2@TACREF_Zoo
	movss	xmm0, DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+40
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+8, xmm0
$LN2@TACREF_Zoo:

; 220  : 	if(TACREF_Object.Distance > TACREF_Object.MaxDistance) TACREF_Object.Distance=TACREF_Object.MaxDistance;

	movss	xmm0, DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+8
	comiss	xmm0, DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+44
	jbe	SHORT $LN1@TACREF_Zoo
	movss	xmm0, DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+44
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+8, xmm0
$LN1@TACREF_Zoo:

; 221  : 
; 222  : 	TACREF_PositionCamera(&TACREF_Object,control->Parent_,control->GetClient());

	mov	ecx, DWORD PTR _control$[ebp]
	call	?GetClient@C_Base@@QAEFXZ		; C_Base::GetClient
	cwde
	push	eax
	mov	ecx, DWORD PTR _control$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	push	edx
	push	OFFSET ?TACREF_Object@@3UOBJECTINFO@@A	; TACREF_Object
	call	?TACREF_PositionCamera@@YAXPAUOBJECTINFO@@PAVC_Window@@J@Z ; TACREF_PositionCamera
	add	esp, 12					; 0000000cH
$LN4@TACREF_Zoo:

; 223  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?TACREF_ZoomCB@@YAXJFPAVC_Base@@@Z ENDP			; TACREF_ZoomCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\tacref\ui_tacref.cpp
_TEXT	SEGMENT
_dy$ = -12						; size = 4
_dx$ = -8						; size = 4
_pnr$ = -4						; size = 4
___formal$ = 8						; size = 4
_hittype$ = 12						; size = 2
_control$ = 16						; size = 4
?TACREF_PannerCB@@YAXJFPAVC_Base@@@Z PROC		; TACREF_PannerCB

; 174  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 175  : 	float dx,dy;
; 176  : 	C_Panner *pnr;
; 177  : 
; 178  : 	if(hittype != C_TYPE_LMOUSEUP && hittype != C_TYPE_REPEAT)

	movsx	eax, WORD PTR _hittype$[ebp]
	cmp	eax, 52					; 00000034H
	je	SHORT $LN9@TACREF_Pan
	movsx	ecx, WORD PTR _hittype$[ebp]
	cmp	ecx, 70					; 00000046H
	je	SHORT $LN9@TACREF_Pan

; 179  : 		return;

	jmp	$LN10@TACREF_Pan
$LN9@TACREF_Pan:

; 180  : 
; 181  : 	pnr = static_cast<C_Panner *>(control);

	mov	edx, DWORD PTR _control$[ebp]
	mov	DWORD PTR _pnr$[ebp], edx

; 182  : 	dx  = static_cast<float>(pnr->GetHRange());

	mov	ecx, DWORD PTR _pnr$[ebp]
	call	?GetHRange@C_Panner@@QAEJXZ		; C_Panner::GetHRange
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _dx$[ebp], xmm0

; 183  : 	dy  = static_cast<float>(pnr->GetVRange());

	mov	ecx, DWORD PTR _pnr$[ebp]
	call	?GetVRange@C_Panner@@QAEJXZ		; C_Panner::GetVRange
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _dy$[ebp], xmm0

; 184  : 
; 185  : 	TACREF_Object.Heading+=dx;

	movss	xmm0, DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A
	addss	xmm0, DWORD PTR _dx$[ebp]
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A, xmm0

; 186  : 	TACREF_Object.Pitch+=dy;

	movss	xmm0, DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+4
	addss	xmm0, DWORD PTR _dy$[ebp]
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+4, xmm0

; 187  : 	if(TACREF_Object.Heading < 0) TACREF_Object.Heading+=360;

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A
	jbe	SHORT $LN8@TACREF_Pan
	movss	xmm0, DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A
	addss	xmm0, DWORD PTR __real@43b40000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A, xmm0
$LN8@TACREF_Pan:

; 188  : 	if(TACREF_Object.Heading > 360) TACREF_Object.Heading-=360;

	movss	xmm0, DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A
	comiss	xmm0, DWORD PTR __real@43b40000
	jbe	SHORT $LN7@TACREF_Pan
	movss	xmm0, DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A
	subss	xmm0, DWORD PTR __real@43b40000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A, xmm0
$LN7@TACREF_Pan:

; 189  : 	if(TACREF_Object.CheckPitch)

	cmp	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+48, 0
	je	SHORT $LN6@TACREF_Pan

; 190  : 	{
; 191  : 		if(TACREF_Object.Pitch < TACREF_Object.MinPitch) TACREF_Object.Pitch=TACREF_Object.MinPitch;

	movss	xmm0, DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+52
	comiss	xmm0, DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+4
	jbe	SHORT $LN5@TACREF_Pan
	movss	xmm0, DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+52
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+4, xmm0
$LN5@TACREF_Pan:

; 192  : 		if(TACREF_Object.Pitch > TACREF_Object.MaxPitch) TACREF_Object.Pitch=TACREF_Object.MaxPitch;

	movss	xmm0, DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+4
	comiss	xmm0, DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+56
	jbe	SHORT $LN4@TACREF_Pan
	movss	xmm0, DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+56
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+4, xmm0
$LN4@TACREF_Pan:

; 193  : 	}
; 194  : 	else

	jmp	SHORT $LN1@TACREF_Pan
$LN6@TACREF_Pan:

; 195  : 	{
; 196  : 		if(TACREF_Object.Pitch < 0) TACREF_Object.Pitch+=360;

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+4
	jbe	SHORT $LN2@TACREF_Pan
	movss	xmm0, DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+4
	addss	xmm0, DWORD PTR __real@43b40000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+4, xmm0
$LN2@TACREF_Pan:

; 197  : 		if(TACREF_Object.Pitch > 360) TACREF_Object.Pitch-=360;

	movss	xmm0, DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+4
	comiss	xmm0, DWORD PTR __real@43b40000
	jbe	SHORT $LN1@TACREF_Pan
	movss	xmm0, DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+4
	subss	xmm0, DWORD PTR __real@43b40000
	movss	DWORD PTR ?TACREF_Object@@3UOBJECTINFO@@A+4, xmm0
$LN1@TACREF_Pan:

; 198  : 	}
; 199  : 	TACREF_PositionCamera(&TACREF_Object,control->Parent_,control->GetClient());

	mov	ecx, DWORD PTR _control$[ebp]
	call	?GetClient@C_Base@@QAEFXZ		; C_Base::GetClient
	cwde
	push	eax
	mov	ecx, DWORD PTR _control$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	push	edx
	push	OFFSET ?TACREF_Object@@3UOBJECTINFO@@A	; TACREF_Object
	call	?TACREF_PositionCamera@@YAXPAUOBJECTINFO@@PAVC_Window@@J@Z ; TACREF_PositionCamera
	add	esp, 12					; 0000000cH
$LN10@TACREF_Pan:

; 200  : 
; 201  : 
; 202  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?TACREF_PannerCB@@YAXJFPAVC_Base@@@Z ENDP		; TACREF_PannerCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\tacref\ui_tacref.cpp
_TEXT	SEGMENT
_Info$ = 8						; size = 4
_win$ = 12						; size = 4
_client$ = 16						; size = 4
?TACREF_PositionCamera@@YAXPAUOBJECTINFO@@PAVC_Window@@J@Z PROC ; TACREF_PositionCamera

; 163  : {

	push	ebp
	mov	ebp, esp

; 164  : 	if(!TAC_Viewer || !Info || !win)

	cmp	DWORD PTR ?TAC_Viewer@@3PAVC_3dViewer@@A, 0 ; TAC_Viewer
	je	SHORT $LN1@TACREF_Pos
	cmp	DWORD PTR _Info$[ebp], 0
	je	SHORT $LN1@TACREF_Pos
	cmp	DWORD PTR _win$[ebp], 0
	jne	SHORT $LN2@TACREF_Pos
$LN1@TACREF_Pos:

; 165  : 		return;

	jmp	SHORT $LN3@TACREF_Pos
$LN2@TACREF_Pos:

; 166  : 
; 167  : 	FindCameraDeltas(Info);

	mov	eax, DWORD PTR _Info$[ebp]
	push	eax
	call	?FindCameraDeltas@@YAXPAUOBJECTINFO@@@Z	; FindCameraDeltas

; 168  : 
; 169  : 	TAC_Viewer->SetCamera(Info->DeltaX,Info->DeltaY,Info->DeltaZ,Info->Heading,-Info->Pitch,0.0f);

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _Info$[ebp]
	movss	xmm0, DWORD PTR [ecx+4]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _Info$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _Info$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+36]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _Info$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+32]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _Info$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+28]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?TAC_Viewer@@3PAVC_3dViewer@@A ; TAC_Viewer
	call	?SetCamera@C_3dViewer@@QAEXMMMMMM@Z	; C_3dViewer::SetCamera

; 170  : 	win->RefreshClient(client);

	mov	eax, DWORD PTR _client$[ebp]
	push	eax
	mov	ecx, DWORD PTR _win$[ebp]
	call	?RefreshClient@C_Window@@QAEXJ@Z	; C_Window::RefreshClient
$LN3@TACREF_Pos:

; 171  : }

	pop	ebp
	ret	0
?TACREF_PositionCamera@@YAXPAUOBJECTINFO@@PAVC_Window@@J@Z ENDP ; TACREF_PositionCamera
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\tacref\ui_tacref.cpp
_TEXT	SEGMENT
_ID$ = 8						; size = 4
_hittype$ = 12						; size = 2
_control$ = 16						; size = 4
?TACREFCloseWindowCB@@YAXJFPAVC_Base@@@Z PROC		; TACREFCloseWindowCB

; 153  : {

	push	ebp
	mov	ebp, esp

; 154  : 	if(hittype != C_TYPE_LMOUSEUP)

	movsx	eax, WORD PTR _hittype$[ebp]
	cmp	eax, 52					; 00000034H
	je	SHORT $LN1@TACREFClos

; 155  : 		return;

	jmp	SHORT $LN2@TACREFClos
$LN1@TACREFClos:

; 156  : 
; 157  : 	StopRWRSounds();

	call	?StopRWRSounds@@YAXXZ			; StopRWRSounds

; 158  : 	CloseWindowCB(ID,hittype,control);

	mov	ecx, DWORD PTR _control$[ebp]
	push	ecx
	movzx	edx, WORD PTR _hittype$[ebp]
	push	edx
	mov	eax, DWORD PTR _ID$[ebp]
	push	eax
	call	?CloseWindowCB@@YAXJFPAVC_Base@@@Z	; CloseWindowCB
	add	esp, 12					; 0000000cH

; 159  : 	TacRef_Cleanup();

	call	?TacRef_Cleanup@@YAXXZ			; TacRef_Cleanup
$LN2@TACREFClos:

; 160  : }

	pop	ebp
	ret	0
?TACREFCloseWindowCB@@YAXJFPAVC_Base@@@Z ENDP		; TACREFCloseWindowCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\tacref\ui_tacref.cpp
_TEXT	SEGMENT
_win$ = -8						; size = 4
_btn$ = -4						; size = 4
?StopRWRSounds@@YAXXZ PROC				; StopRWRSounds

; 114  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 115  : 	C_Window *win;
; 116  : 	C_Button *btn;
; 117  : 
; 118  : 	if(LastLockTone != -1)

	cmp	DWORD PTR ?LastLockTone@@3HA, -1	; LastLockTone
	je	SHORT $LN7@StopRWRSou

; 119  : 	{
; 120  : 		if (SFX_DEF) // JB 010425

	cmp	DWORD PTR ?SFX_DEF@@3PAUSfxDef@@A, 0	; SFX_DEF
	je	SHORT $LN6@StopRWRSou

; 121  : 			F4StopSound (SFX_DEF[LastLockTone].handle);

	mov	eax, DWORD PTR ?LastLockTone@@3HA	; LastLockTone
	imul	eax, 140				; 0000008cH
	mov	ecx, DWORD PTR ?SFX_DEF@@3PAUSfxDef@@A	; SFX_DEF
	mov	edx, DWORD PTR [ecx+eax+72]
	push	edx
	call	_F4StopSound
	add	esp, 4
$LN6@StopRWRSou:

; 122  : 
; 123  : 		LastLockTone=-1;

	mov	DWORD PTR ?LastLockTone@@3HA, -1	; LastLockTone
$LN7@StopRWRSou:

; 124  : 	}
; 125  : 	if(LastRWRTone != -1)

	cmp	DWORD PTR ?LastRWRTone@@3HA, -1		; LastRWRTone
	je	SHORT $LN5@StopRWRSou

; 126  : 	{
; 127  : 		if (SFX_DEF) // JB 010425

	cmp	DWORD PTR ?SFX_DEF@@3PAUSfxDef@@A, 0	; SFX_DEF
	je	SHORT $LN4@StopRWRSou

; 128  : 			F4StopSound (SFX_DEF[LastRWRTone].handle);

	mov	eax, DWORD PTR ?LastRWRTone@@3HA	; LastRWRTone
	imul	eax, 140				; 0000008cH
	mov	ecx, DWORD PTR ?SFX_DEF@@3PAUSfxDef@@A	; SFX_DEF
	mov	edx, DWORD PTR [ecx+eax+72]
	push	edx
	call	_F4StopSound
	add	esp, 4
$LN4@StopRWRSou:

; 129  : 
; 130  : 		LastLockTone=-1;

	mov	DWORD PTR ?LastLockTone@@3HA, -1	; LastLockTone
$LN5@StopRWRSou:

; 131  : 	}
; 132  : 
; 133  : 	win=gMainHandler->FindWindow(TAC_REF_WIN);

	push	8000					; 00001f40H
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z ; C_Handler::FindWindowA
	mov	DWORD PTR _win$[ebp], eax

; 134  : 	if(win)

	cmp	DWORD PTR _win$[ebp], 0
	je	SHORT $LN8@StopRWRSou

; 135  : 	{
; 136  : 		btn=(C_Button *)win->FindControl(PLAY_SEARCH_TONE);

	push	8011					; 00001f4bH
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _btn$[ebp], eax

; 137  : 		if(btn)

	cmp	DWORD PTR _btn$[ebp], 0
	je	SHORT $LN2@StopRWRSou

; 138  : 		{
; 139  : 			btn->SetState(0);

	push	0
	mov	eax, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 140  : 			btn->Refresh();

	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN2@StopRWRSou:

; 141  : 		}
; 142  : 																		
; 143  : 		btn=(C_Button *)win->FindControl(PLAY_LOCK_TONE);

	push	8012					; 00001f4cH
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _btn$[ebp], eax

; 144  : 		if(btn)

	cmp	DWORD PTR _btn$[ebp], 0
	je	SHORT $LN8@StopRWRSou

; 145  : 		{
; 146  : 			btn->SetState(0);

	push	0
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 147  : 			btn->Refresh();

	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN8@StopRWRSou:

; 148  : 		}
; 149  : 	}
; 150  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?StopRWRSounds@@YAXXZ ENDP				; StopRWRSounds
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\tacref\ui_tacref.cpp
_TEXT	SEGMENT
_Leave$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 2
_control$ = 16						; size = 4
?TACREF_ViewBSPObjectCB@@YAXJFPAVC_Base@@@Z PROC	; TACREF_ViewBSPObjectCB

; 101  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 102  : 	F4CSECTIONHANDLE *Leave;
; 103  : 
; 104  : 	if (TAC_Viewer)	

	cmp	DWORD PTR ?TAC_Viewer@@3PAVC_3dViewer@@A, 0 ; TAC_Viewer
	je	SHORT $LN2@TACREF_Vie

; 105  : 	{
; 106  : 		Leave=UI_Enter(control->Parent_);

	mov	eax, DWORD PTR _control$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	push	ecx
	call	?UI_Enter@@YAPAUF4CSECTIONHANDLE@@PAVC_Window@@@Z ; UI_Enter
	add	esp, 4
	mov	DWORD PTR _Leave$[ebp], eax

; 107  : 		TheLoader.WaitForLoader();

	mov	ecx, OFFSET ?TheLoader@@3VLoader@@A	; TheLoader
	call	?WaitForLoader@Loader@@QAEXXZ		; Loader::WaitForLoader

; 108  : 		TAC_Viewer->View3d(CurrentModel);

	mov	edx, DWORD PTR ?CurrentModel@@3JA	; CurrentModel
	push	edx
	mov	ecx, DWORD PTR ?TAC_Viewer@@3PAVC_3dViewer@@A ; TAC_Viewer
	call	?View3d@C_3dViewer@@QAEHJ@Z		; C_3dViewer::View3d

; 109  : 		UI_Leave(Leave);

	mov	eax, DWORD PTR _Leave$[ebp]
	push	eax
	call	?UI_Leave@@YAXPAUF4CSECTIONHANDLE@@@Z	; UI_Leave
	add	esp, 4
$LN2@TACREF_Vie:

; 110  : 	}
; 111  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?TACREF_ViewBSPObjectCB@@YAXJFPAVC_Base@@@Z ENDP	; TACREF_ViewBSPObjectCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\tacref\ui_tacref.cpp
_TEXT	SEGMENT
_win$ = 8						; size = 4
?TACMoveRendererCB@@YAXPAVC_Window@@@Z PROC		; TACMoveRendererCB

; 95   : {

	push	ebp
	mov	ebp, esp

; 96   : 	if(TAC_Viewer)

	cmp	DWORD PTR ?TAC_Viewer@@3PAVC_3dViewer@@A, 0 ; TAC_Viewer
	je	SHORT $LN2@TACMoveRen

; 97   : 		TAC_Viewer->Viewport(win,0);

	push	0
	mov	eax, DWORD PTR _win$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?TAC_Viewer@@3PAVC_3dViewer@@A ; TAC_Viewer
	call	?Viewport@C_3dViewer@@QAEXPAVC_Window@@J@Z ; C_3dViewer::Viewport
$LN2@TACMoveRen:

; 98   : }	

	pop	ebp
	ret	0
?TACMoveRendererCB@@YAXPAVC_Window@@@Z ENDP		; TACMoveRendererCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\tacref\ui_tacref.cpp
_TEXT	SEGMENT
tv77 = -24						; size = 4
$T1 = -20						; size = 4
tv70 = -16						; size = 4
$T2 = -12						; size = 4
$T3 = -8						; size = 4
$T4 = -4						; size = 4
?TacRef_Cleanup@@YAXXZ PROC				; TacRef_Cleanup

; 1266 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 1267 : 	if(TAC_Viewer)

	cmp	DWORD PTR ?TAC_Viewer@@3PAVC_3dViewer@@A, 0 ; TAC_Viewer
	je	SHORT $LN2@TacRef_Cle

; 1268 : 	{
; 1269 : 		UnloadObject(); // just in case :)

	call	?UnloadObject@@YAXXZ			; UnloadObject

; 1270 : 		TAC_Viewer->Cleanup();

	mov	ecx, DWORD PTR ?TAC_Viewer@@3PAVC_3dViewer@@A ; TAC_Viewer
	call	?Cleanup@C_3dViewer@@QAEHXZ		; C_3dViewer::Cleanup

; 1271 : 		delete TAC_Viewer;

	mov	eax, DWORD PTR ?TAC_Viewer@@3PAVC_3dViewer@@A ; TAC_Viewer
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T4[ebp], ecx
	cmp	DWORD PTR $T4[ebp], 0
	je	SHORT $LN5@TacRef_Cle
	push	1
	mov	ecx, DWORD PTR $T4[ebp]
	call	??_GC_3dViewer@@QAEPAXI@Z
	mov	DWORD PTR tv70[ebp], eax
	jmp	SHORT $LN6@TacRef_Cle
$LN5@TacRef_Cle:
	mov	DWORD PTR tv70[ebp], 0
$LN6@TacRef_Cle:

; 1272 : 		TAC_Viewer=NULL;

	mov	DWORD PTR ?TAC_Viewer@@3PAVC_3dViewer@@A, 0 ; TAC_Viewer
$LN2@TacRef_Cle:

; 1273 : 	}
; 1274 : 	if(Reference)

	cmp	DWORD PTR ?Reference@@3PAVTacticalReference@@A, 0 ; Reference
	je	SHORT $LN3@TacRef_Cle

; 1275 : 	{
; 1276 : 		Reference->Cleanup();

	mov	ecx, DWORD PTR ?Reference@@3PAVTacticalReference@@A ; Reference
	call	?Cleanup@TacticalReference@@QAEXXZ	; TacticalReference::Cleanup

; 1277 : 		delete Reference;

	mov	edx, DWORD PTR ?Reference@@3PAVTacticalReference@@A ; Reference
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR $T3[ebp], eax
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN7@TacRef_Cle
	push	1
	mov	ecx, DWORD PTR $T3[ebp]
	call	??_GTacticalReference@@QAEPAXI@Z
	mov	DWORD PTR tv77[ebp], eax
	jmp	SHORT $LN8@TacRef_Cle
$LN7@TacRef_Cle:
	mov	DWORD PTR tv77[ebp], 0
$LN8@TacRef_Cle:

; 1278 : 		Reference=NULL;

	mov	DWORD PTR ?Reference@@3PAVTacticalReference@@A, 0 ; Reference
$LN3@TacRef_Cle:

; 1279 : 	}
; 1280 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?TacRef_Cleanup@@YAXXZ ENDP				; TacRef_Cleanup
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GTacticalReference@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GTacticalReference@@QAEPAXI@Z PROC			; TacticalReference::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1TacticalReference@@QAE@XZ		; TacticalReference::~TacticalReference
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GTacticalReference@@QAEPAXI@Z ENDP			; TacticalReference::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GC_3dViewer@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GC_3dViewer@@QAEPAXI@Z PROC				; C_3dViewer::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1C_3dViewer@@QAE@XZ			; C_3dViewer::~C_3dViewer
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GC_3dViewer@@QAEPAXI@Z ENDP				; C_3dViewer::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\include\c3dview.h
;	COMDAT ??1C_3dViewer@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1C_3dViewer@@QAE@XZ PROC				; C_3dViewer::~C_3dViewer, COMDAT
; _this$ = ecx

; 65   : 		~C_3dViewer() { Cleanup(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Cleanup@C_3dViewer@@QAEHXZ		; C_3dViewer::Cleanup
	mov	esp, ebp
	pop	ebp
	ret	0
??1C_3dViewer@@QAE@XZ ENDP				; C_3dViewer::~C_3dViewer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\include\c3dview.h
;	COMDAT ??0C_3dViewer@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0C_3dViewer@@QAE@XZ PROC				; C_3dViewer::C_3dViewer, COMDAT
; _this$ = ecx

; 37   : 		C_3dViewer()

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 38   : 		{
; 39   : 			rend3d_=NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 40   : 			rendOTW_=NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 41   : 			viewPoint_=NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 42   : 			objects_=NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+96], 0

; 43   : 			l=-1.0f; t=1.0f;r=1.0f;b=-1.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [ecx+132], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+136], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+140], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [ecx+144], xmm0

; 44   : 			viewPos_.x=0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+24], xmm0

; 45   : 			viewPos_.y=0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+28], xmm0

; 46   : 			viewPos_.z=0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+32], xmm0

; 47   : 			zeroPos_=viewPos_;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx

; 48   : 			currentPos_=viewPos_;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 49   : 			CameraPos_=viewPos_;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 36					; 00000024H
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx

; 50   : 			currentRot_=IMatrix;

	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 60					; 0000003cH
	mov	ecx, 9
	mov	esi, OFFSET ?IMatrix@@3UTrotation@@B	; IMatrix
	rep movsd

; 51   : 			CameraHeading_=0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+104], xmm0

; 52   : 			CameraPitch_=0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+108], xmm0

; 53   : 			CameraRoll_=0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+112], xmm0

; 54   : 			ViewDistance_=10.0f * FEET_PER_KM;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@47001fcd
	movss	DWORD PTR [edx+116], xmm0

; 55   : 			Time_=12l * 60l * 60l * 1000l;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+120], 43200000		; 02932e00H

; 56   : 			MinTexture_=0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+124], 0

; 57   : 			MaxTexture_=1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+128], 1

; 58   : 			Weather_=0;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+156], xmm0

; 59   : //			TextureLevel_=2;
; 60   : //			SmoothShading_=TRUE;
; 61   : 			sw=800; sh=600;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@44480000
	movss	DWORD PTR [ecx+148], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@44160000
	movss	DWORD PTR [edx+152], xmm0

; 62   : 			LockOnView_=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+160], 0

; 63   : 			m_pImgGray = NULL;	// OW

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+100], 0

; 64   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??0C_3dViewer@@QAE@XZ ENDP				; C_3dViewer::C_3dViewer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.h
;	COMDAT ?GetControlList@C_Window@@QAEPAUControlListStr@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetControlList@C_Window@@QAEPAUControlListStr@@XZ PROC	; C_Window::GetControlList, COMDAT
; _this$ = ecx

; 285  : 		CONTROLLIST *GetControlList() { return(Controls_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4304]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetControlList@C_Window@@QAEPAUControlListStr@@XZ ENDP	; C_Window::GetControlList
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.h
;	COMDAT ?SetDragCallback@C_Window@@QAEXP6AXPAV1@@Z@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_cb$ = 8						; size = 4
?SetDragCallback@C_Window@@QAEXP6AXPAV1@@Z@Z PROC	; C_Window::SetDragCallback, COMDAT
; _this$ = ecx

; 270  : 		void SetDragCallback(void (*cb)(C_Window *)) { DragCallback_=cb; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _cb$[ebp]
	mov	DWORD PTR [eax+4316], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetDragCallback@C_Window@@QAEXP6AXPAV1@@Z@Z ENDP	; C_Window::SetDragCallback
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cparser.h
;	COMDAT ?GetNextWindowLoaded@C_Parser@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNextWindowLoaded@C_Parser@@QAEJXZ PROC		; C_Parser::GetNextWindowLoaded, COMDAT
; _this$ = ecx

; 99   : 		long GetNextWindowLoaded() { WinIndex_++; if(WinIndex_ < WinLoaded_) return(WindowList_[WinIndex_]); else return(0); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+960]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+960], cx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+960]
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+962]
	cmp	ecx, eax
	jge	SHORT $LN2@GetNextWin
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+960]
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+edx*4+104]
	jmp	SHORT $LN3@GetNextWin
	jmp	SHORT $LN3@GetNextWin
$LN2@GetNextWin:
	xor	eax, eax
$LN3@GetNextWin:
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNextWindowLoaded@C_Parser@@QAEJXZ ENDP		; C_Parser::GetNextWindowLoaded
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cparser.h
;	COMDAT ?GetFirstWindowLoaded@C_Parser@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFirstWindowLoaded@C_Parser@@QAEJXZ PROC		; C_Parser::GetFirstWindowLoaded, COMDAT
; _this$ = ecx

; 98   : 		long GetFirstWindowLoaded() { WinIndex_=0; if(WinIndex_ < WinLoaded_) return(WindowList_[WinIndex_]); else return(0); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+960], ax
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+960]
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+962]
	cmp	eax, edx
	jge	SHORT $LN2@GetFirstWi
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+960]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+104]
	jmp	SHORT $LN3@GetFirstWi
	jmp	SHORT $LN3@GetFirstWi
$LN2@GetFirstWi:
	xor	eax, eax
$LN3@GetFirstWi:
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFirstWindowLoaded@C_Parser@@QAEJXZ ENDP		; C_Parser::GetFirstWindowLoaded
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cthook.h
;	COMDAT ?SetDrawCallback@C_TimerHook@@QAEXP6AXJFPAVC_Base@@@Z@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_routine$ = 8						; size = 4
?SetDrawCallback@C_TimerHook@@QAEXP6AXJFPAVC_Base@@@Z@Z PROC ; C_TimerHook::SetDrawCallback, COMDAT
; _this$ = ecx

; 34   : 		void SetDrawCallback(void (*routine)(long ID,short hittype,C_Base *control)) { DrawCallback_=routine; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _routine$[ebp]
	mov	DWORD PTR [eax+60], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetDrawCallback@C_TimerHook@@QAEXP6AXJFPAVC_Base@@@Z@Z ENDP ; C_TimerHook::SetDrawCallback
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cthook.h
;	COMDAT ?SetRefreshCallback@C_TimerHook@@QAEXP6AXJFPAVC_Base@@@Z@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_routine$ = 8						; size = 4
?SetRefreshCallback@C_TimerHook@@QAEXP6AXJFPAVC_Base@@@Z@Z PROC ; C_TimerHook::SetRefreshCallback, COMDAT
; _this$ = ecx

; 33   : 		void SetRefreshCallback(void (*routine)(long ID,short hittype,C_Base *control)) { RefreshCallback_=routine; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _routine$[ebp]
	mov	DWORD PTR [eax+56], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetRefreshCallback@C_TimerHook@@QAEXP6AXJFPAVC_Base@@@Z@Z ENDP ; C_TimerHook::SetRefreshCallback
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cthook.h
;	COMDAT ?SetUpdateCallback@C_TimerHook@@QAEXP6AXJFPAVC_Base@@@Z@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_routine$ = 8						; size = 4
?SetUpdateCallback@C_TimerHook@@QAEXP6AXJFPAVC_Base@@@Z@Z PROC ; C_TimerHook::SetUpdateCallback, COMDAT
; _this$ = ecx

; 32   : 		void SetUpdateCallback(void (*routine)(long ID,short hittype,C_Base *control)) { UpdateCallback_=routine; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _routine$[ebp]
	mov	DWORD PTR [eax+52], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUpdateCallback@C_TimerHook@@QAEXP6AXJFPAVC_Base@@@Z@Z ENDP ; C_TimerHook::SetUpdateCallback
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cpanner.h
;	COMDAT ?GetVRange@C_Panner@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetVRange@C_Panner@@QAEJXZ PROC			; C_Panner::GetVRange, COMDAT
; _this$ = ecx

; 56   : 		long GetVRange() { return(SY_); }	  //! 

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+120]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetVRange@C_Panner@@QAEJXZ ENDP			; C_Panner::GetVRange
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cpanner.h
;	COMDAT ?GetHRange@C_Panner@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetHRange@C_Panner@@QAEJXZ PROC			; C_Panner::GetHRange, COMDAT
; _this$ = ecx

; 55   : 		long GetHRange() { return(SX_); }	  //! 

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+116]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetHRange@C_Panner@@QAEJXZ ENDP			; C_Panner::GetHRange
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\ctree.h
;	COMDAT ?GetRoot@C_TreeList@@QAEPAVTREELIST@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetRoot@C_TreeList@@QAEPAVTREELIST@@XZ PROC		; C_TreeList::GetRoot, COMDAT
; _this$ = ecx

; 118  : 		TREELIST *GetRoot() { return(Root_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+136]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetRoot@C_TreeList@@QAEPAVTREELIST@@XZ ENDP		; C_TreeList::GetRoot
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\clistbox.h
;	COMDAT ?GetTextID@C_ListBox@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTextID@C_ListBox@@QAEJXZ PROC			; C_ListBox::GetTextID, COMDAT
; _this$ = ecx

; 109  : 		long GetTextID() { return(LabelVal_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+104]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetTextID@C_ListBox@@QAEJXZ ENDP			; C_ListBox::GetTextID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\clistbox.h
;	COMDAT ?GetRoot@C_ListBox@@QAEPAVLISTBOX@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetRoot@C_ListBox@@QAEPAVLISTBOX@@XZ PROC		; C_ListBox::GetRoot, COMDAT
; _this$ = ecx

; 93   : 		LISTBOX *GetRoot() { return(Root_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+164]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetRoot@C_ListBox@@QAEPAVLISTBOX@@XZ ENDP		; C_ListBox::GetRoot
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cbase.h
;	COMDAT ?GetX@C_Base@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetX@C_Base@@QAEJXZ PROC				; C_Base::GetX, COMDAT
; _this$ = ecx

; 141  : 		long GetX()					{ return(x_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+24]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetX@C_Base@@QAEJXZ ENDP				; C_Base::GetX
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cbase.h
;	COMDAT ?GetClient@C_Base@@QAEFXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetClient@C_Base@@QAEFXZ PROC				; C_Base::GetClient, COMDAT
; _this$ = ecx

; 140  : 		short GetClient()			{ return(Client_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+40]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetClient@C_Base@@QAEFXZ ENDP				; C_Base::GetClient
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cbase.h
;	COMDAT ?GetFlags@C_Base@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFlags@C_Base@@QAEJXZ PROC				; C_Base::GetFlags, COMDAT
; _this$ = ecx

; 139  : 		long  GetFlags()			{ return(Flags_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFlags@C_Base@@QAEJXZ ENDP				; C_Base::GetFlags
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cbase.h
;	COMDAT ?GetID@C_Base@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetID@C_Base@@QAEJXZ PROC				; C_Base::GetID, COMDAT
; _this$ = ecx

; 134  : 		long  GetID()				{ return(ID_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetID@C_Base@@QAEJXZ ENDP				; C_Base::GetID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cbase.h
;	COMDAT ?SetReady@C_Base@@QAEXF@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_r$ = 8							; size = 2
?SetReady@C_Base@@QAEXF@Z PROC				; C_Base::SetReady, COMDAT
; _this$ = ecx

; 116  : 		void SetReady(short r)									{ Ready_=r; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _r$[ebp]
	mov	WORD PTR [eax+42], cx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetReady@C_Base@@QAEXF@Z ENDP				; C_Base::SetReady
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cbase.h
;	COMDAT ?SetParent@C_Base@@QAEXPAVC_Window@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_win$ = 8						; size = 4
?SetParent@C_Base@@QAEXPAVC_Window@@@Z PROC		; C_Base::SetParent, COMDAT
; _this$ = ecx

; 115  : 		void SetParent(C_Window *win)							{ Parent_=win; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _win$[ebp]
	mov	DWORD PTR [eax+48], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetParent@C_Base@@QAEXPAVC_Window@@@Z ENDP		; C_Base::SetParent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cbase.h
;	COMDAT ?SetClient@C_Base@@QAEXF@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_client$ = 8						; size = 2
?SetClient@C_Base@@QAEXF@Z PROC				; C_Base::SetClient, COMDAT
; _this$ = ecx

; 98   : 		void SetClient(short client)							{ Client_=client; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _client$[ebp]
	mov	WORD PTR [eax+40], cx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetClient@C_Base@@QAEXF@Z ENDP				; C_Base::SetClient
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\drawbsp.h
;	COMDAT ?GetNTextureSet@DrawableBSP@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNTextureSet@DrawableBSP@@QAEHXZ PROC		; DrawableBSP::GetNTextureSet, COMDAT
; _this$ = ecx

; 50   : 	int GetNTextureSet() { return instance.GetNTextureSet(); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	?GetNTextureSet@ObjectInstance@@QAEHXZ	; ObjectInstance::GetNTextureSet
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNTextureSet@DrawableBSP@@QAEHXZ ENDP		; DrawableBSP::GetNTextureSet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\drawbsp.h
;	COMDAT ?SetTextureSet@DrawableBSP@@QAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_set$ = 8						; size = 4
?SetTextureSet@DrawableBSP@@QAEXK@Z PROC		; DrawableBSP::SetTextureSet, COMDAT
; _this$ = ecx

; 49   : 	void SetTextureSet( UInt32 set )	{ instance.SetTextureSet( set ); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _set$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	?SetTextureSet@ObjectInstance@@QAEXH@Z	; ObjectInstance::SetTextureSet
	mov	esp, ebp
	pop	ebp
	ret	4
?SetTextureSet@DrawableBSP@@QAEXK@Z ENDP		; DrawableBSP::SetTextureSet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\objectinstance.h
;	COMDAT ?GetNTextureSet@ObjectInstance@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNTextureSet@ObjectInstance@@QAEHXZ PROC		; ObjectInstance::GetNTextureSet, COMDAT
; _this$ = ecx

; 39   : 	int	GetNTextureSet() { return ParentObject->nTextureSets; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	movsx	eax, WORD PTR [ecx+44]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNTextureSet@ObjectInstance@@QAEHXZ ENDP		; ObjectInstance::GetNTextureSet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\drawobj.h
;	COMDAT ?Radius@DrawableObject@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Radius@DrawableObject@@QBEMXZ PROC			; DrawableObject::Radius, COMDAT
; _this$ = ecx

; 27   : 	float Radius() const { return radius; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+16]
	mov	esp, ebp
	pop	ebp
	ret	0
?Radius@DrawableObject@@QBEMXZ ENDP			; DrawableObject::Radius
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_System_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_System_error_category@std@@UAEPAXI@Z PROC		; std::_System_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_System_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_System_error_category@std@@UAEPAXI@Z ENDP		; std::_System_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_System_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_System_error_category@std@@UAE@XZ PROC		; std::_System_error_category::~_System_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_System_error_category@std@@UAE@XZ ENDP		; std::_System_error_category::~_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::_System_error_category::default_error_condition, COMDAT
; _this$ = ecx

; 641  : 		{	// make error_condition for error code (generic if possible)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 642  : 		if (_Syserror_map(_Errval))

	mov	eax, DWORD PTR __Errval$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@default_er

; 643  : 			return (error_condition(_Errval, generic_category()));

	call	?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@default_er

; 644  : 		else

	jmp	SHORT $LN3@default_er
$LN2@default_er:

; 645  : 			return (error_condition(_Errval, system_category()));

	call	?system_category@std@@YAABVerror_category@1@XZ ; std::system_category
	push	eax
	mov	edx, DWORD PTR __Errval$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@default_er:

; 646  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::_System_error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_System_error_category::message, COMDAT
; _this$ = ecx

; 634  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 635  : 		const char *_Name = _Winerror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Winerror_map@std@@YAPBDH@Z		; std::_Winerror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 636  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 637  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_System_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_System_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_System_error_category@std@@UBEPBDXZ PROC		; std::_System_error_category::name, COMDAT
; _this$ = ecx

; 629  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 630  : 		return ("system");

	mov	eax, OFFSET ??_C@_06FHFOAHML@system?$AA@

; 631  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_System_error_category@std@@UBEPBDXZ ENDP		; std::_System_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_System_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_System_error_category@std@@QAE@XZ PROC		; std::_System_error_category::_System_error_category, COMDAT
; _this$ = ecx

; 624  : 	_System_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_System_error_category@std@@6B@

; 625  : 		{	// default constructor
; 626  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_System_error_category@std@@QAE@XZ ENDP		; std::_System_error_category::_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Iostream_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Iostream_error_category@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iostream_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Iostream_error_category@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Iostream_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Iostream_error_category@std@@UAE@XZ PROC		; std::_Iostream_error_category::~_Iostream_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Iostream_error_category@std@@UAE@XZ ENDP		; std::_Iostream_error_category::~_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT
; _this$ = ecx

; 611  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 612  : 		if (_Errcode == (int)io_errc::stream)

	cmp	DWORD PTR __Errcode$[ebp], 1
	jne	SHORT $LN2@message

; 613  : 			return ("iostream stream error");

	push	OFFSET ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@message

; 614  : 		else

	jmp	SHORT $LN3@message
$LN2@message:

; 615  : 			return (_Generic_error_category::message(_Errcode));

	mov	ecx, DWORD PTR __Errcode$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@message:

; 616  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Iostream_error_category@std@@UBEPBDXZ PROC	; std::_Iostream_error_category::name, COMDAT
; _this$ = ecx

; 606  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 607  : 		return ("iostream");

	mov	eax, OFFSET ??_C@_08LLGCOLLL@iostream?$AA@

; 608  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Iostream_error_category@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Iostream_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iostream_error_category@std@@QAE@XZ PROC		; std::_Iostream_error_category::_Iostream_error_category, COMDAT
; _this$ = ecx

; 601  : 	_Iostream_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Iostream_error_category@std@@6B@

; 602  : 		{	// default constructor
; 603  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iostream_error_category@std@@QAE@XZ ENDP		; std::_Iostream_error_category::_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Generic_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Generic_error_category@std@@UAE@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Generic_error_category@std@@UAE@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 590  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 591  : 		const char *_Name = _Syserror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 592  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 593  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 585  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		return ("generic");

	mov	eax, OFFSET ??_C@_07DCLBNMLN@generic?$AA@

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Generic_error_category@std@@QAE@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT
; _this$ = ecx

; 580  : 	_Generic_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0error_category@std@@QAE@XZ		; std::error_category::error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Generic_error_category@std@@6B@

; 581  : 		{	// default constructor
; 582  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Generic_error_category@std@@QAE@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_condition@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv78 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8error_condition@std@@QBE_NABV01@@Z PROC		; std::error_condition::operator==, COMDAT
; _this$ = ecx

; 376  : 		{	// test if *this == _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 377  : 		return (category() == _Right.category()
; 378  : 			&& value() == _Right.value());

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	mov	ecx, eax
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	cmp	esi, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv78[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv78[ebp]

; 379  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??8error_condition@std@@QBE_NABV01@@Z ENDP		; std::error_condition::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 354  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 356  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 349  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 350  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 351  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 316  : 		{	// construct from error code and category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Cat$[ebp]
	mov	DWORD PTR [edx+4], eax

; 317  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 256  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 257  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 258  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 251  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 252  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 253  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gerror_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gerror_category@std@@UAEPAXI@Z PROC			; std::error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gerror_category@std@@UAEPAXI@Z ENDP			; std::error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv65 = -4						; size = 4
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 184  : 		{	// compare categories for equality

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 185  : 		return (this == &_Right);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv65[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv65[ebp]

; 186  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -4						; size = 4
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 415  : 	{	// test if conditions same for this category

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 416  : 	return (*this == _Code.category() && _Code.value() == _Errval);

	mov	ecx, DWORD PTR __Code$[ebp]
	call	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@equivalent
	mov	ecx, DWORD PTR __Code$[ebp]
	call	?value@error_code@std@@QBEHXZ		; std::error_code::value
	cmp	eax, DWORD PTR __Errval$[ebp]
	jne	SHORT $LN3@equivalent
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN4@equivalent
$LN3@equivalent:
	mov	DWORD PTR tv74[ebp], 0
$LN4@equivalent:
	mov	al, BYTE PTR tv74[ebp]

; 417  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 408  : 	{	// test if error code same condition

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 409  : 	return (default_error_condition(_Errval) == _Cond);

	mov	eax, DWORD PTR __Cond$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	ecx, eax
	call	??8error_condition@std@@QBE_NABV01@@Z	; std::error_condition::operator==

; 410  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 401  : 	{	// make error_condition for error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 402  : 	return (error_condition(_Errval, *this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 403  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 167  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 168  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0error_category@std@@QAE@XZ PROC			; std::error_category::error_category, COMDAT
; _this$ = ecx

; 162  : 	error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 163  : 		{	// default constructor
; 164  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0error_category@std@@QAE@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?system_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?system_category@std@@YAABVerror_category@1@XZ PROC	; std::system_category, COMDAT

; 679  : 	{	// get system_category

	push	ebp
	mov	ebp, esp

; 680  : 	return (_Error_objects<int>::_System_object);

	mov	eax, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object

; 681  : 	}

	pop	ebp
	ret	0
?system_category@std@@YAABVerror_category@1@XZ ENDP	; std::system_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?generic_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?generic_category@std@@YAABVerror_category@1@XZ PROC	; std::generic_category, COMDAT

; 669  : 	{	// get generic_category

	push	ebp
	mov	ebp, esp

; 670  : 	return (_Error_objects<int>::_Generic_object);

	mov	eax, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object

; 671  : 	}

	pop	ebp
	ret	0
?generic_category@std@@YAABVerror_category@1@XZ ENDP	; std::generic_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocale
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC				; std::locale::id::id, COMDAT
; _this$ = ecx

; 74   : 			{	// construct with specified stamp value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx

; 75   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2275 : 		{	// report an out_of_range error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2276 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN2@Xran:

; 2277 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2270 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2271 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN2@Xlen:

; 2272 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Ptr$1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2253 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2254 : 		if (!_Built)

	movzx	eax, BYTE PTR __Built$[ebp]
	test	eax, eax
	jne	SHORT $LN4@Tidy
	jmp	SHORT $LN3@Tidy
$LN4@Tidy:

; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN3@Tidy

; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Ptr$1[ebp], eax

; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 2260 : 			if (0 < _Newsize)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN1@Tidy

; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$1[ebp]
	push	ecx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Tidy:

; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Ptr$1[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN3@Tidy:

; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2266 : 		_Eos(_Newsize);

	mov	edx, DWORD PTR __Newsize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2267 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2237 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	cmp	DWORD PTR __Ptr$[ebp], 0
	je	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	cmp	DWORD PTR __Ptr$[ebp], eax
	jb	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
$LN2@Inside:

; 2240 : 			return (false);	// don't ask

	xor	al, al
	jmp	SHORT $LN4@Inside

; 2241 : 		else

	jmp	SHORT $LN4@Inside
$LN3@Inside:

; 2242 : 			return (true);

	mov	al, 1
$LN4@Inside:

; 2243 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
tv136 = -12						; size = 4
tv129 = -8						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2224 : 		if (max_size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN6@Grow

; 2225 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN6@Grow:

; 2226 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN5@Grow

; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	jmp	SHORT $LN4@Grow
$LN5@Grow:

; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	movzx	edx, BYTE PTR __Trim$[ebp]
	test	edx, edx
	je	SHORT $LN3@Grow
	cmp	DWORD PTR __Newsize$[ebp], 16		; 00000010H
	jae	SHORT $LN3@Grow

; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jae	SHORT $LN9@Grow
	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv129[ebp], edx
	jmp	SHORT $LN10@Grow
$LN9@Grow:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR tv129[ebp], ecx
$LN10@Grow:
	mov	edx, DWORD PTR tv129[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
	jmp	SHORT $LN4@Grow
$LN3@Grow:

; 2231 : 		else if (_Newsize == 0)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $LN4@Grow

; 2232 : 			_Eos(0);	// new size is zero, just null terminate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN4@Grow:

; 2233 : 		return (0 < _Newsize);	// return true only if more work to do

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN11@Grow
	mov	DWORD PTR tv136[ebp], 1
	jmp	SHORT $LN12@Grow
$LN11@Grow:
	mov	DWORD PTR tv136[ebp], 0
$LN12@Grow:
	mov	al, BYTE PTR tv136[ebp]
$LN8@Grow:

; 2234 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [eax+16], ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 2219 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
tv205 = -48						; size = 4
tv204 = -44						; size = 4
tv203 = -40						; size = 4
tv202 = -36						; size = 4
__Ptr$ = -32						; size = 4
__Newres$ = -28						; size = 4
_this$ = -24						; size = 4
$T2 = -19						; size = 1
$T3 = -18						; size = 1
$T4 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Newres$[ebp], eax

; 2184 : 		if (max_size() < _Newres)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newres$[ebp]
	jae	SHORT $LN9@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx
	jmp	SHORT $LN8@Copy
$LN9@Copy:

; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)

	mov	eax, DWORD PTR __Newres$[ebp]
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	shr	ecx, 1
	cmp	ecx, eax
	ja	SHORT $LN7@Copy
	jmp	SHORT $LN8@Copy
$LN7@Copy:

; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+20]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, esi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], eax
	ja	SHORT $LN5@Copy

; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	shr	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR __Newres$[ebp], eax

; 2191 : 		else

	jmp	SHORT $LN8@Copy
$LN5@Copy:

; 2192 : 			_Newres = max_size();	// settle for max_size()

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	DWORD PTR __Newres$[ebp], eax
$LN8@Copy:

; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv202[ebp], eax
	mov	eax, DWORD PTR __Newres$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR tv202[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv203[ebp], eax
	mov	ecx, DWORD PTR tv203[ebp]
	mov	DWORD PTR __Ptr$[ebp], ecx
	jmp	SHORT $LN12@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2197 : 		_CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], edx

; 2199 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv204[ebp], eax
	mov	ecx, DWORD PTR __Newres$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR tv204[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv205[ebp], eax
	mov	edx, DWORD PTR tv205[ebp]
	mov	DWORD PTR __Ptr$[ebp], edx
	jmp	SHORT $LN14@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2203 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 2204 : 			_CATCH_END

	mov	eax, $LN17@Copy
	ret	0
$LN14@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2
$LN17@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2:

; 2205 : 		_CATCH_END

	mov	eax, $LN19@Copy
	ret	0
$LN12@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3
$LN19@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jbe	SHORT $LN1@Copy

; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements

	mov	eax, DWORD PTR __Oldlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Copy:

; 2210 : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);

	lea	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>

; 2212 : 		this->_Myres = _Newres;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newres$[ebp]
	mov	DWORD PTR [edx+20], eax

; 2213 : 		_Eos(_Oldlen);

	mov	ecx, DWORD PTR __Oldlen$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN11@Copy:

; 2214 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv75 = -12						; size = 4
__Num$ = -8						; size = 4
$T1 = -1						; size = 1
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1737 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1738 : 		size_type _Num = this->_Getal().max_size();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
	mov	DWORD PTR __Num$[ebp], eax

; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$[ebp], 1
	ja	SHORT $LN3@max_size
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	ecx, DWORD PTR __Num$[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv75[ebp], ecx
$LN4@max_size:
	mov	eax, DWORD PTR tv75[ebp]

; 1740 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1732 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1733 : 		return (this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]

; 1734 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$1 = -12					; size = 4
__Ptr$2 = -8						; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1317 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1318 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN4@erase

; 1319 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN4@erase:

; 1320 : 		if (this->_Mysize - _Off <= _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Off$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	ja	SHORT $LN3@erase

; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)

	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
	jmp	SHORT $LN2@erase
$LN3@erase:

; 1322 : 		else if (0 < _Count)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN2@erase

; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Ptr$2[ebp], eax

; 1325 : 			size_type _Newsize = this->_Mysize - _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Newsize$1[ebp], eax

; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	sub	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$2[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$2[ebp]
	push	eax
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 1327 : 			_Eos(_Newsize);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@erase:

; 1328 : 			}
; 1329 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN6@erase:

; 1330 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1309 : 		{	// erase elements [_Off, ...)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1310 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN1@erase

; 1311 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN1@erase:

; 1312 : 		_Eos(_Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1313 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@erase:

; 1314 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1142 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1145 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@assign

; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	jmp	SHORT $LN3@assign
$LN2@assign:

; 1132 : 
; 1133 : 		if (_Grow(_Count))

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@assign

; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1136 : 			_Eos(_Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@assign:

; 1137 : 			}
; 1138 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@assign:

; 1139 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1105 : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $LN5@assign

; 1106 : 			_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN5@assign:

; 1107 : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 1108 : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Num$[ebp]
	jae	SHORT $LN4@assign

; 1109 : 			_Num = _Count;	// trim _Num to size

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
$LN4@assign:

; 1110 : 
; 1111 : 		if (this == &_Right)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@assign

; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	mov	eax, DWORD PTR __Roff$[ebp]
	add	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	mov	ecx, DWORD PTR __Roff$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	jmp	SHORT $LN2@assign
$LN3@assign:

; 1113 : 		else if (_Grow(_Num))

	push	0
	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@assign

; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);

	mov	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1117 : 			_Eos(_Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@assign:

; 1118 : 			}
; 1119 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN7@assign:

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 791  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >

; 792  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 793  : 		assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 794  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 688  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 689  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 690  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 635  : 	_String_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >

; 636  : 		{	// construct allocator from _Al
; 637  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		{	// determine current pointer to buffer for nonmutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 522  : 		return (this->_BUF_SIZE <= this->_Myres
; 523  : 			? _STD addressof(*this->_Bx._Ptr)
; 524  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 525  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		{	// determine current pointer to buffer for mutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 515  : 		return (this->_BUF_SIZE <= this->_Myres
; 516  : 			? _STD addressof(*this->_Bx._Ptr)
; 517  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 518  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 496  : 	_String_val()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 497  : 		{	// initialize values
; 498  : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 499  : 		_Myres = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 500  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 913  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 914  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
	add	esp, 4

; 915  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 886  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 887  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate

; 888  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 875  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 877  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 830  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>

; 831  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 761  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp

; 762  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@D@std@@QBEIXZ	; std::allocator<char>::max_size

; 763  : 		}

	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

	or	eax, -1

; 629  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 590  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8

; 592  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 565  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 563  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 564  : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 565  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 551  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@move
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@move
$LN3@move:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@move:
	mov	eax, DWORD PTR tv69[ebp]

; 554  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 528  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@copy
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@copy
$LN3@copy:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@copy:
	mov	eax, DWORD PTR tv69[ebp]

; 531  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 521  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp
	push	ecx

; 522  : 		return (*_First == 0 ? 0
; 523  : 			: _CSTD strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@length
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN4@length
$LN3@length:
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR tv68[ebp], eax
$LN4@length:
	mov	eax, DWORD PTR tv68[ebp]

; 524  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 65   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 60   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 61   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
END
