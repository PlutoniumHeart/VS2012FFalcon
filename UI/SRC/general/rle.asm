; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\UI\SRC\general\rle.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?CompressRLE8Bit@@YAJPAE0J@Z			; CompressRLE8Bit
PUBLIC	?DecompressRLE8Bit@@YAJPAE0J@Z			; DecompressRLE8Bit
PUBLIC	?CompressRLE16Bit@@YAJPAG0J@Z			; CompressRLE16Bit
PUBLIC	?DecompressRLE16Bit@@YAJPAG0J@Z			; DecompressRLE16Bit
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\general\rle.cpp
_TEXT	SEGMENT
_OutSize$ = -8						; size = 4
_count$ = -4						; size = 2
_Src$ = 8						; size = 4
_Dest$ = 12						; size = 4
_Size$ = 16						; size = 4
?DecompressRLE16Bit@@YAJPAG0J@Z PROC			; DecompressRLE16Bit

; 258  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 259  : 	WORD count;
; 260  : 	long OutSize=0;

	mov	DWORD PTR _OutSize$[ebp], 0
$LN8@Decompress:

; 261  : 
; 262  : 	while(Size)

	cmp	DWORD PTR _Size$[ebp], 0
	je	$LN7@Decompress

; 263  : 	{
; 264  : 		count=*Src++;

	mov	eax, DWORD PTR _Src$[ebp]
	mov	cx, WORD PTR [eax]
	mov	WORD PTR _count$[ebp], cx
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, 2
	mov	DWORD PTR _Src$[ebp], edx

; 265  : 		Size -= sizeof(WORD);

	mov	eax, DWORD PTR _Size$[ebp]
	sub	eax, 2
	mov	DWORD PTR _Size$[ebp], eax

; 266  : 		if(count & 0x8000)

	movzx	ecx, WORD PTR _count$[ebp]
	and	ecx, 32768				; 00008000H
	je	SHORT $LN6@Decompress

; 267  : 		{
; 268  : 			count ^= 0xFFFF;

	movzx	edx, WORD PTR _count$[ebp]
	xor	edx, 65535				; 0000ffffH
	mov	WORD PTR _count$[ebp], dx

; 269  : 			OutSize += count*sizeof(WORD);

	movzx	eax, WORD PTR _count$[ebp]
	mov	ecx, DWORD PTR _OutSize$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _OutSize$[ebp], edx
$LN5@Decompress:

; 270  : 			while(count)

	movzx	eax, WORD PTR _count$[ebp]
	test	eax, eax
	je	SHORT $LN4@Decompress

; 271  : 			{
; 272  : 				*Dest++=*Src;

	mov	ecx, DWORD PTR _Dest$[ebp]
	mov	edx, DWORD PTR _Src$[ebp]
	mov	ax, WORD PTR [edx]
	mov	WORD PTR [ecx], ax
	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, 2
	mov	DWORD PTR _Dest$[ebp], ecx

; 273  : 				count--;

	mov	dx, WORD PTR _count$[ebp]
	sub	dx, 1
	mov	WORD PTR _count$[ebp], dx

; 274  : 			}

	jmp	SHORT $LN5@Decompress
$LN4@Decompress:

; 275  : 			Src++;

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, 2
	mov	DWORD PTR _Src$[ebp], eax

; 276  : 			Size -= sizeof(WORD);

	mov	ecx, DWORD PTR _Size$[ebp]
	sub	ecx, 2
	mov	DWORD PTR _Size$[ebp], ecx

; 277  : 		}
; 278  : 		else

	jmp	SHORT $LN3@Decompress
$LN6@Decompress:

; 279  : 		{
; 280  : 			OutSize += count*sizeof(WORD);

	movzx	edx, WORD PTR _count$[ebp]
	mov	eax, DWORD PTR _OutSize$[ebp]
	lea	ecx, DWORD PTR [eax+edx*2]
	mov	DWORD PTR _OutSize$[ebp], ecx
$LN2@Decompress:

; 281  : 			while(count && Size)

	movzx	edx, WORD PTR _count$[ebp]
	test	edx, edx
	je	SHORT $LN3@Decompress
	cmp	DWORD PTR _Size$[ebp], 0
	je	SHORT $LN3@Decompress

; 282  : 			{
; 283  : 				*Dest++=*Src++;

	mov	eax, DWORD PTR _Dest$[ebp]
	mov	ecx, DWORD PTR _Src$[ebp]
	mov	dx, WORD PTR [ecx]
	mov	WORD PTR [eax], dx
	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, 2
	mov	DWORD PTR _Dest$[ebp], eax
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, 2
	mov	DWORD PTR _Src$[ebp], ecx

; 284  : 				count--;

	mov	dx, WORD PTR _count$[ebp]
	sub	dx, 1
	mov	WORD PTR _count$[ebp], dx

; 285  : 				Size -= sizeof(WORD);

	mov	eax, DWORD PTR _Size$[ebp]
	sub	eax, 2
	mov	DWORD PTR _Size$[ebp], eax

; 286  : 			}

	jmp	SHORT $LN2@Decompress
$LN3@Decompress:

; 287  : 		}
; 288  : 	}

	jmp	$LN8@Decompress
$LN7@Decompress:

; 289  : 	return(OutSize);

	mov	eax, DWORD PTR _OutSize$[ebp]

; 290  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DecompressRLE16Bit@@YAJPAG0J@Z ENDP			; DecompressRLE16Bit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\general\rle.cpp
_TEXT	SEGMENT
_start$ = -20						; size = 4
_Size$ = -16						; size = 4
_run$ = -12						; size = 2
_data$ = -8						; size = 2
_count$ = -4						; size = 2
_Src$ = 8						; size = 4
_Dest$ = 12						; size = 4
_srcsize$ = 16						; size = 4
?CompressRLE16Bit@@YAJPAG0J@Z PROC			; CompressRLE16Bit

; 154  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 155  : 	long Size;
; 156  : 	WORD *start;
; 157  : 	WORD data;
; 158  : 	WORD count;
; 159  : 	WORD run;
; 160  : 
; 161  : 	start=Src;

	mov	eax, DWORD PTR _Src$[ebp]
	mov	DWORD PTR _start$[ebp], eax

; 162  : 	data=static_cast<unsigned short>((*Src)+1);

	mov	ecx, DWORD PTR _Src$[ebp]
	movzx	edx, WORD PTR [ecx]
	add	edx, 1
	mov	WORD PTR _data$[ebp], dx

; 163  : 	srcsize;
; 164  : 	count=0xffff;

	mov	eax, 65535				; 0000ffffH
	mov	WORD PTR _count$[ebp], ax

; 165  : 	run=0;

	xor	ecx, ecx
	mov	WORD PTR _run$[ebp], cx

; 166  : 	Size=0;

	mov	DWORD PTR _Size$[ebp], 0
$LN20@CompressRL:

; 167  : 
; 168  : 	while(srcsize)

	cmp	DWORD PTR _srcsize$[ebp], 0
	je	$LN19@CompressRL

; 169  : 	{
; 170  : 		if(*Src == data)

	mov	edx, DWORD PTR _Src$[ebp]
	movzx	eax, WORD PTR [edx]
	movzx	ecx, WORD PTR _data$[ebp]
	cmp	eax, ecx
	jne	$LN18@CompressRL

; 171  : 		{
; 172  : 			if(count)

	movzx	edx, WORD PTR _count$[ebp]
	test	edx, edx
	je	SHORT $LN17@CompressRL

; 173  : 			{
; 174  : 				*Dest++=count;

	mov	eax, DWORD PTR _Dest$[ebp]
	mov	cx, WORD PTR _count$[ebp]
	mov	WORD PTR [eax], cx
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, 2
	mov	DWORD PTR _Dest$[ebp], edx

; 175  : 				Size += sizeof(WORD);

	mov	eax, DWORD PTR _Size$[ebp]
	add	eax, 2
	mov	DWORD PTR _Size$[ebp], eax
$LN16@CompressRL:

; 176  : 				while(count)

	movzx	ecx, WORD PTR _count$[ebp]
	test	ecx, ecx
	je	SHORT $LN17@CompressRL

; 177  : 				{
; 178  : 					*Dest++=*start++;

	mov	edx, DWORD PTR _Dest$[ebp]
	mov	eax, DWORD PTR _start$[ebp]
	mov	cx, WORD PTR [eax]
	mov	WORD PTR [edx], cx
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, 2
	mov	DWORD PTR _Dest$[ebp], edx
	mov	eax, DWORD PTR _start$[ebp]
	add	eax, 2
	mov	DWORD PTR _start$[ebp], eax

; 179  : 					count--;

	mov	cx, WORD PTR _count$[ebp]
	sub	cx, 1
	mov	WORD PTR _count$[ebp], cx

; 180  : 					Size += sizeof(WORD);

	mov	edx, DWORD PTR _Size$[ebp]
	add	edx, 2
	mov	DWORD PTR _Size$[ebp], edx

; 181  : 				}

	jmp	SHORT $LN16@CompressRL
$LN17@CompressRL:

; 182  : 			}
; 183  : 			run=1;

	mov	eax, 1
	mov	WORD PTR _run$[ebp], ax

; 184  : 			count=1;

	mov	ecx, 1
	mov	WORD PTR _count$[ebp], cx
$LN14@CompressRL:

; 185  : 			while(*Src == data && count < 0xFFFF && srcsize)

	mov	edx, DWORD PTR _Src$[ebp]
	movzx	eax, WORD PTR [edx]
	movzx	ecx, WORD PTR _data$[ebp]
	cmp	eax, ecx
	jne	SHORT $LN13@CompressRL
	movzx	edx, WORD PTR _count$[ebp]
	cmp	edx, 65535				; 0000ffffH
	jge	SHORT $LN13@CompressRL
	cmp	DWORD PTR _srcsize$[ebp], 0
	je	SHORT $LN13@CompressRL

; 186  : 			{
; 187  : 				count++;

	mov	ax, WORD PTR _count$[ebp]
	add	ax, 1
	mov	WORD PTR _count$[ebp], ax

; 188  : 				Src++;

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, 2
	mov	DWORD PTR _Src$[ebp], ecx

; 189  : 				srcsize -= sizeof(WORD);

	mov	edx, DWORD PTR _srcsize$[ebp]
	sub	edx, 2
	mov	DWORD PTR _srcsize$[ebp], edx

; 190  : 			}

	jmp	SHORT $LN14@CompressRL
$LN13@CompressRL:

; 191  : 			*Dest++=static_cast<unsigned short>(count^0xFFFF);

	movzx	eax, WORD PTR _count$[ebp]
	xor	eax, 65535				; 0000ffffH
	mov	ecx, DWORD PTR _Dest$[ebp]
	mov	WORD PTR [ecx], ax
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, 2
	mov	DWORD PTR _Dest$[ebp], edx

; 192  : 			*Dest++=data;

	mov	eax, DWORD PTR _Dest$[ebp]
	mov	cx, WORD PTR _data$[ebp]
	mov	WORD PTR [eax], cx
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, 2
	mov	DWORD PTR _Dest$[ebp], edx

; 193  : 			Size += 2*sizeof(WORD);

	mov	eax, DWORD PTR _Size$[ebp]
	add	eax, 4
	mov	DWORD PTR _Size$[ebp], eax

; 194  : 			run=0;

	xor	ecx, ecx
	mov	WORD PTR _run$[ebp], cx

; 195  : 			count=0;

	xor	edx, edx
	mov	WORD PTR _count$[ebp], dx

; 196  : 			start=Src;

	mov	eax, DWORD PTR _Src$[ebp]
	mov	DWORD PTR _start$[ebp], eax

; 197  : 			if(srcsize)

	cmp	DWORD PTR _srcsize$[ebp], 0
	je	SHORT $LN12@CompressRL

; 198  : 			{
; 199  : 				data=*Src++;

	mov	ecx, DWORD PTR _Src$[ebp]
	mov	dx, WORD PTR [ecx]
	mov	WORD PTR _data$[ebp], dx
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, 2
	mov	DWORD PTR _Src$[ebp], eax

; 200  : 				srcsize -= sizeof(WORD);

	mov	ecx, DWORD PTR _srcsize$[ebp]
	sub	ecx, 2
	mov	DWORD PTR _srcsize$[ebp], ecx
$LN12@CompressRL:

; 201  : 			}
; 202  : 		}
; 203  : 		else

	jmp	SHORT $LN11@CompressRL
$LN18@CompressRL:

; 204  : 		{
; 205  : 			run=0;

	xor	edx, edx
	mov	WORD PTR _run$[ebp], dx

; 206  : 			data=*Src++;

	mov	eax, DWORD PTR _Src$[ebp]
	mov	cx, WORD PTR [eax]
	mov	WORD PTR _data$[ebp], cx
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, 2
	mov	DWORD PTR _Src$[ebp], edx

; 207  : 			count++;

	mov	ax, WORD PTR _count$[ebp]
	add	ax, 1
	mov	WORD PTR _count$[ebp], ax

; 208  : 			srcsize -= sizeof(WORD);

	mov	ecx, DWORD PTR _srcsize$[ebp]
	sub	ecx, 2
	mov	DWORD PTR _srcsize$[ebp], ecx
$LN11@CompressRL:

; 209  : 		}
; 210  : 
; 211  : 		if(count == 0x7FFF)

	movzx	edx, WORD PTR _count$[ebp]
	cmp	edx, 32767				; 00007fffH
	jne	$LN10@CompressRL

; 212  : 		{
; 213  : 			if(run)

	movzx	eax, WORD PTR _run$[ebp]
	test	eax, eax
	je	SHORT $LN9@CompressRL

; 214  : 			{
; 215  : 				*Dest++=static_cast<unsigned short>(count^0xFFFF);

	movzx	ecx, WORD PTR _count$[ebp]
	xor	ecx, 65535				; 0000ffffH
	mov	edx, DWORD PTR _Dest$[ebp]
	mov	WORD PTR [edx], cx
	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, 2
	mov	DWORD PTR _Dest$[ebp], eax

; 216  : 				*Dest++=data;

	mov	ecx, DWORD PTR _Dest$[ebp]
	mov	dx, WORD PTR _data$[ebp]
	mov	WORD PTR [ecx], dx
	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, 2
	mov	DWORD PTR _Dest$[ebp], eax

; 217  : 				Size += 2*sizeof(WORD);

	mov	ecx, DWORD PTR _Size$[ebp]
	add	ecx, 4
	mov	DWORD PTR _Size$[ebp], ecx

; 218  : 			}
; 219  : 			else

	jmp	SHORT $LN8@CompressRL
$LN9@CompressRL:

; 220  : 			{
; 221  : 				*Dest++=count;

	mov	edx, DWORD PTR _Dest$[ebp]
	mov	ax, WORD PTR _count$[ebp]
	mov	WORD PTR [edx], ax
	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, 2
	mov	DWORD PTR _Dest$[ebp], ecx

; 222  : 				Size += sizeof(WORD);

	mov	edx, DWORD PTR _Size$[ebp]
	add	edx, 2
	mov	DWORD PTR _Size$[ebp], edx
$LN7@CompressRL:

; 223  : 				while(count)

	movzx	eax, WORD PTR _count$[ebp]
	test	eax, eax
	je	SHORT $LN8@CompressRL

; 224  : 				{
; 225  : 					*Dest++=*start++;

	mov	ecx, DWORD PTR _Dest$[ebp]
	mov	edx, DWORD PTR _start$[ebp]
	mov	ax, WORD PTR [edx]
	mov	WORD PTR [ecx], ax
	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, 2
	mov	DWORD PTR _Dest$[ebp], ecx
	mov	edx, DWORD PTR _start$[ebp]
	add	edx, 2
	mov	DWORD PTR _start$[ebp], edx

; 226  : 					count--;

	mov	ax, WORD PTR _count$[ebp]
	sub	ax, 1
	mov	WORD PTR _count$[ebp], ax

; 227  : 					Size += sizeof(WORD);

	mov	ecx, DWORD PTR _Size$[ebp]
	add	ecx, 2
	mov	DWORD PTR _Size$[ebp], ecx

; 228  : 				}

	jmp	SHORT $LN7@CompressRL
$LN8@CompressRL:

; 229  : 			}
; 230  : 			count=0;

	xor	edx, edx
	mov	WORD PTR _count$[ebp], dx

; 231  : 			run=0;

	xor	eax, eax
	mov	WORD PTR _run$[ebp], ax
$LN10@CompressRL:

; 232  : 		}
; 233  : 	}

	jmp	$LN20@CompressRL
$LN19@CompressRL:

; 234  : 	if(count)

	movzx	ecx, WORD PTR _count$[ebp]
	test	ecx, ecx
	je	$LN5@CompressRL

; 235  : 	{
; 236  : 		if(run)

	movzx	edx, WORD PTR _run$[ebp]
	test	edx, edx
	je	SHORT $LN4@CompressRL

; 237  : 		{
; 238  : 			*Dest++=static_cast<unsigned short>(count^0xFFFF);

	movzx	eax, WORD PTR _count$[ebp]
	xor	eax, 65535				; 0000ffffH
	mov	ecx, DWORD PTR _Dest$[ebp]
	mov	WORD PTR [ecx], ax
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, 2
	mov	DWORD PTR _Dest$[ebp], edx

; 239  : 			*Dest++=data;

	mov	eax, DWORD PTR _Dest$[ebp]
	mov	cx, WORD PTR _data$[ebp]
	mov	WORD PTR [eax], cx
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, 2
	mov	DWORD PTR _Dest$[ebp], edx

; 240  : 			Size += 2*sizeof(WORD);

	mov	eax, DWORD PTR _Size$[ebp]
	add	eax, 4
	mov	DWORD PTR _Size$[ebp], eax

; 241  : 		}
; 242  : 		else

	jmp	SHORT $LN5@CompressRL
$LN4@CompressRL:

; 243  : 		{
; 244  : 			*Dest++=count;

	mov	ecx, DWORD PTR _Dest$[ebp]
	mov	dx, WORD PTR _count$[ebp]
	mov	WORD PTR [ecx], dx
	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, 2
	mov	DWORD PTR _Dest$[ebp], eax

; 245  : 			Size += sizeof(WORD);

	mov	ecx, DWORD PTR _Size$[ebp]
	add	ecx, 2
	mov	DWORD PTR _Size$[ebp], ecx
$LN2@CompressRL:

; 246  : 			while(count)

	movzx	edx, WORD PTR _count$[ebp]
	test	edx, edx
	je	SHORT $LN5@CompressRL

; 247  : 			{
; 248  : 				*Dest++=*start++;

	mov	eax, DWORD PTR _Dest$[ebp]
	mov	ecx, DWORD PTR _start$[ebp]
	mov	dx, WORD PTR [ecx]
	mov	WORD PTR [eax], dx
	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, 2
	mov	DWORD PTR _Dest$[ebp], eax
	mov	ecx, DWORD PTR _start$[ebp]
	add	ecx, 2
	mov	DWORD PTR _start$[ebp], ecx

; 249  : 				count--;

	mov	dx, WORD PTR _count$[ebp]
	sub	dx, 1
	mov	WORD PTR _count$[ebp], dx

; 250  : 				Size += sizeof(WORD);

	mov	eax, DWORD PTR _Size$[ebp]
	add	eax, 2
	mov	DWORD PTR _Size$[ebp], eax

; 251  : 			}

	jmp	SHORT $LN2@CompressRL
$LN5@CompressRL:

; 252  : 		}
; 253  : 	}
; 254  : 	return(Size);

	mov	eax, DWORD PTR _Size$[ebp]

; 255  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CompressRLE16Bit@@YAJPAG0J@Z ENDP			; CompressRLE16Bit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\general\rle.cpp
_TEXT	SEGMENT
_OutSize$ = -8						; size = 4
_count$ = -1						; size = 1
_Src$ = 8						; size = 4
_Dest$ = 12						; size = 4
_Size$ = 16						; size = 4
?DecompressRLE8Bit@@YAJPAE0J@Z PROC			; DecompressRLE8Bit

; 117  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 118  : 	uchar count;
; 119  : 	long OutSize;
; 120  : 	OutSize=0;

	mov	DWORD PTR _OutSize$[ebp], 0
$LN8@Decompress:

; 121  : 
; 122  : 	while(Size)

	cmp	DWORD PTR _Size$[ebp], 0
	je	$LN7@Decompress

; 123  : 	{
; 124  : 		count=*Src++;

	mov	eax, DWORD PTR _Src$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _count$[ebp], cl
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, 1
	mov	DWORD PTR _Src$[ebp], edx

; 125  : 		Size--;

	mov	eax, DWORD PTR _Size$[ebp]
	sub	eax, 1
	mov	DWORD PTR _Size$[ebp], eax

; 126  : 		if(count & 0x80)

	movzx	ecx, BYTE PTR _count$[ebp]
	and	ecx, 128				; 00000080H
	je	SHORT $LN6@Decompress

; 127  : 		{
; 128  : 			count ^= 0xff;

	movzx	edx, BYTE PTR _count$[ebp]
	xor	edx, 255				; 000000ffH
	mov	BYTE PTR _count$[ebp], dl

; 129  : 			OutSize+=count;

	movzx	eax, BYTE PTR _count$[ebp]
	add	eax, DWORD PTR _OutSize$[ebp]
	mov	DWORD PTR _OutSize$[ebp], eax
$LN5@Decompress:

; 130  : 			while(count)

	movzx	ecx, BYTE PTR _count$[ebp]
	test	ecx, ecx
	je	SHORT $LN4@Decompress

; 131  : 			{
; 132  : 				*Dest++=*Src;

	mov	edx, DWORD PTR _Dest$[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, 1
	mov	DWORD PTR _Dest$[ebp], edx

; 133  : 				count--;

	mov	al, BYTE PTR _count$[ebp]
	sub	al, 1
	mov	BYTE PTR _count$[ebp], al

; 134  : 			}

	jmp	SHORT $LN5@Decompress
$LN4@Decompress:

; 135  : 			Src++;

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, 1
	mov	DWORD PTR _Src$[ebp], ecx

; 136  : 			Size--;

	mov	edx, DWORD PTR _Size$[ebp]
	sub	edx, 1
	mov	DWORD PTR _Size$[ebp], edx

; 137  : 		}
; 138  : 		else

	jmp	SHORT $LN3@Decompress
$LN6@Decompress:

; 139  : 		{
; 140  : 			OutSize+=count;

	movzx	eax, BYTE PTR _count$[ebp]
	add	eax, DWORD PTR _OutSize$[ebp]
	mov	DWORD PTR _OutSize$[ebp], eax
$LN2@Decompress:

; 141  : 			while(count && Size)

	movzx	ecx, BYTE PTR _count$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@Decompress
	cmp	DWORD PTR _Size$[ebp], 0
	je	SHORT $LN3@Decompress

; 142  : 			{
; 143  : 				*Dest++=*Src++;

	mov	edx, DWORD PTR _Dest$[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, 1
	mov	DWORD PTR _Dest$[ebp], edx
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, 1
	mov	DWORD PTR _Src$[ebp], eax

; 144  : 				count--;

	mov	cl, BYTE PTR _count$[ebp]
	sub	cl, 1
	mov	BYTE PTR _count$[ebp], cl

; 145  : 				Size--;

	mov	edx, DWORD PTR _Size$[ebp]
	sub	edx, 1
	mov	DWORD PTR _Size$[ebp], edx

; 146  : 			}

	jmp	SHORT $LN2@Decompress
$LN3@Decompress:

; 147  : 		}
; 148  : 	}

	jmp	$LN8@Decompress
$LN7@Decompress:

; 149  : 	return(OutSize);

	mov	eax, DWORD PTR _OutSize$[ebp]

; 150  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DecompressRLE8Bit@@YAJPAE0J@Z ENDP			; DecompressRLE8Bit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\general\rle.cpp
_TEXT	SEGMENT
_start$ = -12						; size = 4
_Size$ = -8						; size = 4
_run$ = -3						; size = 1
_data$ = -2						; size = 1
_count$ = -1						; size = 1
_Src$ = 8						; size = 4
_Dest$ = 12						; size = 4
_srcsize$ = 16						; size = 4
?CompressRLE8Bit@@YAJPAE0J@Z PROC			; CompressRLE8Bit

; 13   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 14   : 	long Size;
; 15   : 	uchar *start;
; 16   : 	uchar data;
; 17   : 	uchar count;
; 18   : 	uchar run;
; 19   : 
; 20   : 	start=Src;

	mov	eax, DWORD PTR _Src$[ebp]
	mov	DWORD PTR _start$[ebp], eax

; 21   : 	data=static_cast<uchar>((*Src)+1);	// Just make data != *Src

	mov	ecx, DWORD PTR _Src$[ebp]
	movzx	edx, BYTE PTR [ecx]
	add	edx, 1
	mov	BYTE PTR _data$[ebp], dl

; 22   : 	srcsize;
; 23   : 	count=0xff;

	mov	BYTE PTR _count$[ebp], 255		; 000000ffH

; 24   : 	run=0;

	mov	BYTE PTR _run$[ebp], 0

; 25   : 	Size=0;

	mov	DWORD PTR _Size$[ebp], 0
$LN20@CompressRL:

; 26   : 
; 27   : 	while(srcsize)

	cmp	DWORD PTR _srcsize$[ebp], 0
	je	$LN19@CompressRL

; 28   : 	{
; 29   : 		if(*Src == data)

	mov	eax, DWORD PTR _Src$[ebp]
	movzx	ecx, BYTE PTR [eax]
	movzx	edx, BYTE PTR _data$[ebp]
	cmp	ecx, edx
	jne	$LN18@CompressRL

; 30   : 		{
; 31   : 			if(count)

	movzx	eax, BYTE PTR _count$[ebp]
	test	eax, eax
	je	SHORT $LN17@CompressRL

; 32   : 			{
; 33   : 				*Dest++=count;

	mov	ecx, DWORD PTR _Dest$[ebp]
	mov	dl, BYTE PTR _count$[ebp]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, 1
	mov	DWORD PTR _Dest$[ebp], eax

; 34   : 				Size++;

	mov	ecx, DWORD PTR _Size$[ebp]
	add	ecx, 1
	mov	DWORD PTR _Size$[ebp], ecx
$LN16@CompressRL:

; 35   : 				while(count)

	movzx	edx, BYTE PTR _count$[ebp]
	test	edx, edx
	je	SHORT $LN17@CompressRL

; 36   : 				{
; 37   : 					*Dest++=*start++;

	mov	eax, DWORD PTR _Dest$[ebp]
	mov	ecx, DWORD PTR _start$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, 1
	mov	DWORD PTR _Dest$[ebp], eax
	mov	ecx, DWORD PTR _start$[ebp]
	add	ecx, 1
	mov	DWORD PTR _start$[ebp], ecx

; 38   : 					count--;

	mov	dl, BYTE PTR _count$[ebp]
	sub	dl, 1
	mov	BYTE PTR _count$[ebp], dl

; 39   : 					Size++;

	mov	eax, DWORD PTR _Size$[ebp]
	add	eax, 1
	mov	DWORD PTR _Size$[ebp], eax

; 40   : 				}

	jmp	SHORT $LN16@CompressRL
$LN17@CompressRL:

; 41   : 			}
; 42   : 			run=1;

	mov	BYTE PTR _run$[ebp], 1

; 43   : 			count=1;

	mov	BYTE PTR _count$[ebp], 1
$LN14@CompressRL:

; 44   : 			while(*Src == data && count < 127 && srcsize)

	mov	ecx, DWORD PTR _Src$[ebp]
	movzx	edx, BYTE PTR [ecx]
	movzx	eax, BYTE PTR _data$[ebp]
	cmp	edx, eax
	jne	SHORT $LN13@CompressRL
	movzx	ecx, BYTE PTR _count$[ebp]
	cmp	ecx, 127				; 0000007fH
	jge	SHORT $LN13@CompressRL
	cmp	DWORD PTR _srcsize$[ebp], 0
	je	SHORT $LN13@CompressRL

; 45   : 			{
; 46   : 				count++;

	mov	dl, BYTE PTR _count$[ebp]
	add	dl, 1
	mov	BYTE PTR _count$[ebp], dl

; 47   : 				Src++;

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, 1
	mov	DWORD PTR _Src$[ebp], eax

; 48   : 				srcsize--;

	mov	ecx, DWORD PTR _srcsize$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _srcsize$[ebp], ecx

; 49   : 			}

	jmp	SHORT $LN14@CompressRL
$LN13@CompressRL:

; 50   : 			*Dest++=static_cast<uchar>(count^0xff);

	movzx	edx, BYTE PTR _count$[ebp]
	xor	edx, 255				; 000000ffH
	mov	eax, DWORD PTR _Dest$[ebp]
	mov	BYTE PTR [eax], dl
	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, 1
	mov	DWORD PTR _Dest$[ebp], ecx

; 51   : 			*Dest++=data;

	mov	edx, DWORD PTR _Dest$[ebp]
	mov	al, BYTE PTR _data$[ebp]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, 1
	mov	DWORD PTR _Dest$[ebp], ecx

; 52   : 			Size+=2;

	mov	edx, DWORD PTR _Size$[ebp]
	add	edx, 2
	mov	DWORD PTR _Size$[ebp], edx

; 53   : 			run=0;

	mov	BYTE PTR _run$[ebp], 0

; 54   : 			count=0;

	mov	BYTE PTR _count$[ebp], 0

; 55   : 			start=Src;

	mov	eax, DWORD PTR _Src$[ebp]
	mov	DWORD PTR _start$[ebp], eax

; 56   : 			if(srcsize)

	cmp	DWORD PTR _srcsize$[ebp], 0
	je	SHORT $LN12@CompressRL

; 57   : 			{
; 58   : 				data=*Src++;

	mov	ecx, DWORD PTR _Src$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _data$[ebp], dl
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, 1
	mov	DWORD PTR _Src$[ebp], eax

; 59   : 				srcsize--;

	mov	ecx, DWORD PTR _srcsize$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _srcsize$[ebp], ecx
$LN12@CompressRL:

; 60   : 			}
; 61   : 		}
; 62   : 		else

	jmp	SHORT $LN11@CompressRL
$LN18@CompressRL:

; 63   : 		{
; 64   : 			run=0;

	mov	BYTE PTR _run$[ebp], 0

; 65   : 			data=*Src++;

	mov	edx, DWORD PTR _Src$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _data$[ebp], al
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, 1
	mov	DWORD PTR _Src$[ebp], ecx

; 66   : 			count++;

	mov	dl, BYTE PTR _count$[ebp]
	add	dl, 1
	mov	BYTE PTR _count$[ebp], dl

; 67   : 			srcsize--;

	mov	eax, DWORD PTR _srcsize$[ebp]
	sub	eax, 1
	mov	DWORD PTR _srcsize$[ebp], eax
$LN11@CompressRL:

; 68   : 		}
; 69   : 
; 70   : 		if(count == 127)

	movzx	ecx, BYTE PTR _count$[ebp]
	cmp	ecx, 127				; 0000007fH
	jne	$LN10@CompressRL

; 71   : 		{
; 72   : 			if(run)

	movzx	edx, BYTE PTR _run$[ebp]
	test	edx, edx
	je	SHORT $LN9@CompressRL

; 73   : 			{
; 74   : 				*Dest++=static_cast<uchar>(count^0xff);

	movzx	eax, BYTE PTR _count$[ebp]
	xor	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR _Dest$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, 1
	mov	DWORD PTR _Dest$[ebp], edx

; 75   : 				*Dest++=data;

	mov	eax, DWORD PTR _Dest$[ebp]
	mov	cl, BYTE PTR _data$[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, 1
	mov	DWORD PTR _Dest$[ebp], edx

; 76   : 				Size+=2;

	mov	eax, DWORD PTR _Size$[ebp]
	add	eax, 2
	mov	DWORD PTR _Size$[ebp], eax

; 77   : 			}
; 78   : 			else

	jmp	SHORT $LN8@CompressRL
$LN9@CompressRL:

; 79   : 			{
; 80   : 				*Dest++=count;

	mov	ecx, DWORD PTR _Dest$[ebp]
	mov	dl, BYTE PTR _count$[ebp]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, 1
	mov	DWORD PTR _Dest$[ebp], eax

; 81   : 				Size++;

	mov	ecx, DWORD PTR _Size$[ebp]
	add	ecx, 1
	mov	DWORD PTR _Size$[ebp], ecx
$LN7@CompressRL:

; 82   : 				while(count)

	movzx	edx, BYTE PTR _count$[ebp]
	test	edx, edx
	je	SHORT $LN8@CompressRL

; 83   : 				{
; 84   : 					*Dest++=*start++;

	mov	eax, DWORD PTR _Dest$[ebp]
	mov	ecx, DWORD PTR _start$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, 1
	mov	DWORD PTR _Dest$[ebp], eax
	mov	ecx, DWORD PTR _start$[ebp]
	add	ecx, 1
	mov	DWORD PTR _start$[ebp], ecx

; 85   : 					count--;

	mov	dl, BYTE PTR _count$[ebp]
	sub	dl, 1
	mov	BYTE PTR _count$[ebp], dl

; 86   : 					Size++;

	mov	eax, DWORD PTR _Size$[ebp]
	add	eax, 1
	mov	DWORD PTR _Size$[ebp], eax

; 87   : 				}

	jmp	SHORT $LN7@CompressRL
$LN8@CompressRL:

; 88   : 			}
; 89   : 			count=0;

	mov	BYTE PTR _count$[ebp], 0

; 90   : 			run=0;

	mov	BYTE PTR _run$[ebp], 0
$LN10@CompressRL:

; 91   : 		}
; 92   : 	}

	jmp	$LN20@CompressRL
$LN19@CompressRL:

; 93   : 	if(count)

	movzx	ecx, BYTE PTR _count$[ebp]
	test	ecx, ecx
	je	$LN5@CompressRL

; 94   : 	{
; 95   : 		if(run)

	movzx	edx, BYTE PTR _run$[ebp]
	test	edx, edx
	je	SHORT $LN4@CompressRL

; 96   : 		{
; 97   : 			*Dest++=static_cast<uchar>(count^0xff);

	movzx	eax, BYTE PTR _count$[ebp]
	xor	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR _Dest$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, 1
	mov	DWORD PTR _Dest$[ebp], edx

; 98   : 			*Dest++=data;

	mov	eax, DWORD PTR _Dest$[ebp]
	mov	cl, BYTE PTR _data$[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, 1
	mov	DWORD PTR _Dest$[ebp], edx

; 99   : 			Size+=2;

	mov	eax, DWORD PTR _Size$[ebp]
	add	eax, 2
	mov	DWORD PTR _Size$[ebp], eax

; 100  : 		}
; 101  : 		else

	jmp	SHORT $LN5@CompressRL
$LN4@CompressRL:

; 102  : 		{
; 103  : 			*Dest++=count;

	mov	ecx, DWORD PTR _Dest$[ebp]
	mov	dl, BYTE PTR _count$[ebp]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, 1
	mov	DWORD PTR _Dest$[ebp], eax

; 104  : 			Size++;

	mov	ecx, DWORD PTR _Size$[ebp]
	add	ecx, 1
	mov	DWORD PTR _Size$[ebp], ecx
$LN2@CompressRL:

; 105  : 			while(count)

	movzx	edx, BYTE PTR _count$[ebp]
	test	edx, edx
	je	SHORT $LN5@CompressRL

; 106  : 			{
; 107  : 				*Dest++=*start++;

	mov	eax, DWORD PTR _Dest$[ebp]
	mov	ecx, DWORD PTR _start$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, 1
	mov	DWORD PTR _Dest$[ebp], eax
	mov	ecx, DWORD PTR _start$[ebp]
	add	ecx, 1
	mov	DWORD PTR _start$[ebp], ecx

; 108  : 				count--;

	mov	dl, BYTE PTR _count$[ebp]
	sub	dl, 1
	mov	BYTE PTR _count$[ebp], dl

; 109  : 				Size++;

	mov	eax, DWORD PTR _Size$[ebp]
	add	eax, 1
	mov	DWORD PTR _Size$[ebp], eax

; 110  : 			}

	jmp	SHORT $LN2@CompressRL
$LN5@CompressRL:

; 111  : 		}
; 112  : 	}
; 113  : 	return(Size);

	mov	eax, DWORD PTR _Size$[ebp]

; 114  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CompressRLE8Bit@@YAJPAE0J@Z ENDP			; CompressRLE8Bit
_TEXT	ENDS
END
