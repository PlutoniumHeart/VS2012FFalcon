; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\UI\SRC\general\uihash.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??0UI_Hash@@QAE@XZ				; UI_Hash::UI_Hash
PUBLIC	??1UI_Hash@@QAE@XZ				; UI_Hash::~UI_Hash
PUBLIC	?Setup@UI_Hash@@QAEXK@Z				; UI_Hash::Setup
PUBLIC	?Cleanup@UI_Hash@@QAEXXZ			; UI_Hash::Cleanup
PUBLIC	?Find@UI_Hash@@QAEPAXK@Z			; UI_Hash::Find
PUBLIC	?Add@UI_Hash@@QAEXKPAX@Z			; UI_Hash::Add
PUBLIC	?Remove@UI_Hash@@QAEXK@Z			; UI_Hash::Remove
PUBLIC	?GetFirst@UI_Hash@@QAEPAXPAPAVUI_HASHNODE@@PAK@Z ; UI_Hash::GetFirst
PUBLIC	?GetNext@UI_Hash@@QAEPAXPAPAVUI_HASHNODE@@PAK@Z	; UI_Hash::GetNext
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\general\uihash.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_cur$ = -4						; size = 4
_current$ = 8						; size = 4
_curidx$ = 12						; size = 4
?GetNext@UI_Hash@@QAEPAXPAPAVUI_HASHNODE@@PAK@Z PROC	; UI_Hash::GetNext
; _this$ = ecx

; 171  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 172  : 	UI_HASHNODE *cur;
; 173  : 
; 174  : 	if(!*current)

	mov	eax, DWORD PTR _current$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN4@GetNext

; 175  : 		return(NULL);

	xor	eax, eax
	jmp	SHORT $LN5@GetNext
$LN4@GetNext:

; 176  : 
; 177  : 	cur=(*current)->Next;

	mov	ecx, DWORD PTR _current$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _cur$[ebp], eax
$LN3@GetNext:

; 178  : 	while(!cur && *curidx < (TableSize_-1))

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN2@GetNext
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	sub	edx, 1
	mov	eax, DWORD PTR _curidx$[ebp]
	cmp	DWORD PTR [eax], edx
	jae	SHORT $LN2@GetNext

; 179  : 	{
; 180  : 		(*curidx)++;

	mov	ecx, DWORD PTR _curidx$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1
	mov	eax, DWORD PTR _curidx$[ebp]
	mov	DWORD PTR [eax], edx

; 181  : 		cur=Table_[*curidx].Root_;

	mov	ecx, DWORD PTR _curidx$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _cur$[ebp], edx

; 182  : 	}

	jmp	SHORT $LN3@GetNext
$LN2@GetNext:

; 183  : 	*current=cur;

	mov	eax, DWORD PTR _current$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [eax], ecx

; 184  : 	if(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN1@GetNext

; 185  : 		return(cur->Record);

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+4]
	jmp	SHORT $LN5@GetNext
$LN1@GetNext:

; 186  : 	return(NULL);

	xor	eax, eax
$LN5@GetNext:

; 187  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetNext@UI_Hash@@QAEPAXPAPAVUI_HASHNODE@@PAK@Z ENDP	; UI_Hash::GetNext
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\general\uihash.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_cur$ = -4						; size = 4
_current$ = 8						; size = 4
_curidx$ = 12						; size = 4
?GetFirst@UI_Hash@@QAEPAXPAPAVUI_HASHNODE@@PAK@Z PROC	; UI_Hash::GetFirst
; _this$ = ecx

; 148  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 149  : 	UI_HASHNODE *cur;
; 150  : 
; 151  : 	*curidx=0;

	mov	eax, DWORD PTR _curidx$[ebp]
	mov	DWORD PTR [eax], 0

; 152  : 	*current=NULL;

	mov	ecx, DWORD PTR _current$[ebp]
	mov	DWORD PTR [ecx], 0

; 153  : 
; 154  : 	cur=Table_[*curidx].Root_;

	mov	edx, DWORD PTR _curidx$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _cur$[ebp], eax
$LN4@GetFirst:

; 155  : 	while(!cur && *curidx < (TableSize_-1))

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN3@GetFirst
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	sub	edx, 1
	mov	eax, DWORD PTR _curidx$[ebp]
	cmp	DWORD PTR [eax], edx
	jae	SHORT $LN3@GetFirst

; 156  : 	{
; 157  : 		(*curidx)++;

	mov	ecx, DWORD PTR _curidx$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1
	mov	eax, DWORD PTR _curidx$[ebp]
	mov	DWORD PTR [eax], edx

; 158  : 		cur=Table_[*curidx].Root_;

	mov	ecx, DWORD PTR _curidx$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _cur$[ebp], edx

; 159  : 	}

	jmp	SHORT $LN4@GetFirst
$LN3@GetFirst:

; 160  : 	if(*curidx < TableSize_)

	mov	eax, DWORD PTR _curidx$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jae	SHORT $LN2@GetFirst

; 161  : 	{
; 162  : 		*current=cur;

	mov	eax, DWORD PTR _current$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [eax], ecx

; 163  : 		if(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN2@GetFirst

; 164  : 			return(cur->Record);

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+4]
	jmp	SHORT $LN5@GetFirst
$LN2@GetFirst:

; 165  : 	}
; 166  : 	*current=NULL;

	mov	eax, DWORD PTR _current$[ebp]
	mov	DWORD PTR [eax], 0

; 167  : 	return(NULL);

	xor	eax, eax
$LN5@GetFirst:

; 168  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetFirst@UI_Hash@@QAEPAXPAPAVUI_HASHNODE@@PAK@Z ENDP	; UI_Hash::GetFirst
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\general\uihash.cpp
_TEXT	SEGMENT
$T1 = -32						; size = 4
$T2 = -28						; size = 4
$T3 = -24						; size = 4
$T4 = -20						; size = 4
_idx$ = -16						; size = 4
_cur$ = -12						; size = 4
_prev$ = -8						; size = 4
_this$ = -4						; size = 4
_ID$ = 8						; size = 4
?Remove@UI_Hash@@QAEXK@Z PROC				; UI_Hash::Remove
; _this$ = ecx

; 105  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 106  : 	unsigned long idx;
; 107  : 	UI_HASHNODE *cur,*prev;
; 108  : 
; 109  : 	if(!TableSize_ || !Table_) return;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN11@Remove
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN12@Remove
$LN11@Remove:
	jmp	$LN13@Remove
$LN12@Remove:

; 110  : 
; 111  : 	idx=ID % TableSize_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _ID$[ebp]
	xor	edx, edx
	div	DWORD PTR [ecx]
	mov	DWORD PTR _idx$[ebp], edx

; 112  : 
; 113  : 	if(!Table_[idx].Root_) return;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _idx$[ebp]
	cmp	DWORD PTR [eax+ecx*4], 0
	jne	SHORT $LN10@Remove
	jmp	$LN13@Remove
$LN10@Remove:

; 114  : 
; 115  : 	Table_[idx].Root_;
; 116  : 	if(Table_[idx].Root_->ID == ID)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _idx$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _ID$[ebp]
	jne	SHORT $LN9@Remove

; 117  : 	{
; 118  : 		prev=Table_[idx].Root_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _idx$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _prev$[ebp], ecx

; 119  : 		Table_[idx].Root_=Table_[idx].Root_->Next;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _idx$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _idx$[ebp]
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+eax*4], edx

; 120  : 		if(Callback_)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN8@Remove

; 121  : 			(*Callback_)(prev->Record);

	mov	ecx, DWORD PTR _prev$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	call	ecx
	add	esp, 4

; 122  : 		else

	jmp	SHORT $LN7@Remove
$LN8@Remove:

; 123  : 			delete prev->Record;

	mov	edx, DWORD PTR _prev$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T4[ebp], eax
	mov	ecx, DWORD PTR $T4[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN7@Remove:

; 124  : 		delete prev;

	mov	edx, DWORD PTR _prev$[ebp]
	mov	DWORD PTR $T3[ebp], edx
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 125  : 	}
; 126  : 	else

	jmp	$LN13@Remove
$LN9@Remove:

; 127  : 	{
; 128  : 		cur=Table_[idx].Root_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _idx$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _cur$[ebp], ecx
$LN5@Remove:

; 129  : 		while(cur->Next)

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+8], 0
	je	SHORT $LN13@Remove

; 130  : 		{
; 131  : 			if(cur->Next->ID == ID)

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR _ID$[ebp]
	jne	SHORT $LN3@Remove

; 132  : 			{
; 133  : 				prev=cur->Next;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _prev$[ebp], ecx

; 134  : 				cur->Next=cur->Next->Next;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx

; 135  : 				if(Callback_)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN2@Remove

; 136  : 					(*Callback_)(prev->Record);

	mov	ecx, DWORD PTR _prev$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	call	ecx
	add	esp, 4

; 137  : 				else

	jmp	SHORT $LN1@Remove
$LN2@Remove:

; 138  : 					delete prev->Record;

	mov	edx, DWORD PTR _prev$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Remove:

; 139  : 				delete prev;

	mov	edx, DWORD PTR _prev$[ebp]
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 140  : 				return;

	jmp	SHORT $LN13@Remove
$LN3@Remove:

; 141  : 			}
; 142  : 			cur=cur->Next;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _cur$[ebp], edx

; 143  : 		}

	jmp	SHORT $LN5@Remove
$LN13@Remove:

; 144  : 	}
; 145  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Remove@UI_Hash@@QAEXK@Z ENDP				; UI_Hash::Remove
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\general\uihash.cpp
_TEXT	SEGMENT
$T1 = -20						; size = 4
_idx$ = -16						; size = 4
_cur$ = -12						; size = 4
_newhash$ = -8						; size = 4
_this$ = -4						; size = 4
_ID$ = 8						; size = 4
_rec$ = 12						; size = 4
?Add@UI_Hash@@QAEXKPAX@Z PROC				; UI_Hash::Add
; _this$ = ecx

; 76   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 77   : 	unsigned long idx;
; 78   : 	UI_HASHNODE *cur,*newhash;
; 79   : 
; 80   : 	if(!TableSize_ || !Table_ || !rec) return;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN6@Add
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN6@Add
	cmp	DWORD PTR _rec$[ebp], 0
	jne	SHORT $LN7@Add
$LN6@Add:
	jmp	$LN8@Add
$LN7@Add:

; 81   : 
; 82   : 	if(Find(ID)) return;

	mov	edx, DWORD PTR _ID$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Find@UI_Hash@@QAEPAXK@Z		; UI_Hash::Find
	test	eax, eax
	je	SHORT $LN5@Add
	jmp	$LN8@Add
$LN5@Add:

; 83   : 
; 84   : 	newhash=new UI_HASHNODE;

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR _newhash$[ebp], eax

; 85   : 	newhash->ID=ID;

	mov	ecx, DWORD PTR _newhash$[ebp]
	mov	edx, DWORD PTR _ID$[ebp]
	mov	DWORD PTR [ecx], edx

; 86   : 	newhash->Record=rec;

	mov	eax, DWORD PTR _newhash$[ebp]
	mov	ecx, DWORD PTR _rec$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 87   : 	newhash->Next=NULL;

	mov	edx, DWORD PTR _newhash$[ebp]
	mov	DWORD PTR [edx+8], 0

; 88   : 
; 89   : 	idx=ID % TableSize_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _ID$[ebp]
	xor	edx, edx
	div	DWORD PTR [ecx]
	mov	DWORD PTR _idx$[ebp], edx

; 90   : 
; 91   : 	if(!Table_[idx].Root_)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _idx$[ebp]
	cmp	DWORD PTR [eax+ecx*4], 0
	jne	SHORT $LN4@Add

; 92   : 	{
; 93   : 		Table_[idx].Root_=newhash;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _idx$[ebp]
	mov	edx, DWORD PTR _newhash$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 94   : 	}
; 95   : 	else

	jmp	SHORT $LN8@Add
$LN4@Add:

; 96   : 	{
; 97   : 		cur=Table_[idx].Root_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _idx$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _cur$[ebp], eax
$LN2@Add:

; 98   : 		while(cur->Next)

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN1@Add

; 99   : 			cur=cur->Next;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _cur$[ebp], eax
	jmp	SHORT $LN2@Add
$LN1@Add:

; 100  : 		cur->Next=newhash;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _newhash$[ebp]
	mov	DWORD PTR [ecx+8], edx
$LN8@Add:

; 101  : 	}
; 102  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?Add@UI_Hash@@QAEXKPAX@Z ENDP				; UI_Hash::Add
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\general\uihash.cpp
_TEXT	SEGMENT
_idx$ = -12						; size = 4
_this$ = -8						; size = 4
_cur$ = -4						; size = 4
_ID$ = 8						; size = 4
?Find@UI_Hash@@QAEPAXK@Z PROC				; UI_Hash::Find
; _this$ = ecx

; 56   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 57   : 	unsigned long idx;
; 58   : 	UI_HASHNODE *cur;
; 59   : 
; 60   : 	if(!TableSize_ || !Table_) return(NULL);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN4@Find
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN5@Find
$LN4@Find:
	xor	eax, eax
	jmp	SHORT $LN6@Find
$LN5@Find:

; 61   : 
; 62   : 	idx=ID % TableSize_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _ID$[ebp]
	xor	edx, edx
	div	DWORD PTR [ecx]
	mov	DWORD PTR _idx$[ebp], edx

; 63   : 	cur=Table_[idx].Root_;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _idx$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _cur$[ebp], edx
$LN3@Find:

; 64   : 	while(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN2@Find

; 65   : 	{
; 66   : 		if(cur->ID == ID)

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _ID$[ebp]
	jne	SHORT $LN1@Find

; 67   : 		{
; 68   : 			return(cur->Record);

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+4]
	jmp	SHORT $LN6@Find
$LN1@Find:

; 69   : 		}
; 70   : 		cur=cur->Next;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _cur$[ebp], ecx

; 71   : 	}

	jmp	SHORT $LN3@Find
$LN2@Find:

; 72   : 	return(NULL);

	xor	eax, eax
$LN6@Find:

; 73   : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Find@UI_Hash@@QAEPAXK@Z ENDP				; UI_Hash::Find
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\general\uihash.cpp
_TEXT	SEGMENT
$T1 = -28						; size = 4
$T2 = -24						; size = 4
$T3 = -20						; size = 4
_prev$ = -16						; size = 4
_cur$ = -12						; size = 4
_i$ = -8						; size = 4
_this$ = -4						; size = 4
?Cleanup@UI_Hash@@QAEXXZ PROC				; UI_Hash::Cleanup
; _this$ = ecx

; 29   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 30   : 	unsigned long i;
; 31   : 	UI_HASHNODE *cur,*prev;
; 32   : 
; 33   : 	if(TableSize_ || Table_)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN8@Cleanup
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	$LN10@Cleanup
$LN8@Cleanup:

; 34   : 	{
; 35   : 		for(i=0;i<TableSize_;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@Cleanup
$LN6@Cleanup:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN7@Cleanup:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jae	SHORT $LN5@Cleanup

; 36   : 		{
; 37   : 			cur=Table_[i].Root_;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _cur$[ebp], edx
$LN4@Cleanup:

; 38   : 			while(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN3@Cleanup

; 39   : 			{
; 40   : 				prev=cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _prev$[ebp], eax

; 41   : 				cur=cur->Next;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _cur$[ebp], edx

; 42   : 				if(Callback_)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN2@Cleanup

; 43   : 					(*Callback_)(prev->Record);

	mov	ecx, DWORD PTR _prev$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	call	ecx
	add	esp, 4

; 44   : 				else

	jmp	SHORT $LN1@Cleanup
$LN2@Cleanup:

; 45   : 					delete prev->Record;

	mov	edx, DWORD PTR _prev$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T3[ebp], eax
	mov	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Cleanup:

; 46   : 				delete prev;

	mov	edx, DWORD PTR _prev$[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 47   : 			}

	jmp	SHORT $LN4@Cleanup
$LN3@Cleanup:

; 48   : 		}

	jmp	SHORT $LN6@Cleanup
$LN5@Cleanup:

; 49   : 		delete Table_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 50   : 		Table_=NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 51   : 		TableSize_=0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], 0
$LN10@Cleanup:

; 52   : 	}
; 53   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Cleanup@UI_Hash@@QAEXXZ ENDP				; UI_Hash::Cleanup
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\general\uihash.cpp
_TEXT	SEGMENT
$T1 = -12						; size = 4
_this$ = -8						; size = 4
_i$ = -4						; size = 2
_Size$ = 8						; size = 4
?Setup@UI_Hash@@QAEXK@Z PROC				; UI_Hash::Setup
; _this$ = ecx

; 19   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 20   : 	unsigned short i;
; 21   : 	TableSize_=Size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _Size$[ebp]
	mov	DWORD PTR [eax], ecx

; 22   : 
; 23   : 	Table_=new UI_HASHROOT[TableSize_];

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [eax+4], ecx

; 24   : 	for(i=0;i<TableSize_;i++)

	xor	edx, edx
	mov	WORD PTR _i$[ebp], dx
	jmp	SHORT $LN3@Setup
$LN2@Setup:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
$LN3@Setup:
	movzx	ecx, WORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	cmp	ecx, DWORD PTR [edx]
	jae	SHORT $LN4@Setup

; 25   : 		Table_[i].Root_=NULL;

	movzx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+eax*4], 0
	jmp	SHORT $LN2@Setup
$LN4@Setup:

; 26   : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Setup@UI_Hash@@QAEXK@Z ENDP				; UI_Hash::Setup
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\general\uihash.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1UI_Hash@@QAE@XZ PROC					; UI_Hash::~UI_Hash
; _this$ = ecx

; 13   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 14   : 	if(TableSize_ || Table_)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN1@UI_Hash
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN3@UI_Hash
$LN1@UI_Hash:

; 15   : 		Cleanup();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Cleanup@UI_Hash@@QAEXXZ		; UI_Hash::Cleanup
$LN3@UI_Hash:

; 16   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??1UI_Hash@@QAE@XZ ENDP					; UI_Hash::~UI_Hash
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\general\uihash.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0UI_Hash@@QAE@XZ PROC					; UI_Hash::UI_Hash
; _this$ = ecx

; 5    : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 6    : 	TableSize_=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 7    : 	Table_=NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 8    : 
; 9    : 	Callback_=NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 10   : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0UI_Hash@@QAE@XZ ENDP					; UI_Hash::UI_Hash
_TEXT	ENDS
END
