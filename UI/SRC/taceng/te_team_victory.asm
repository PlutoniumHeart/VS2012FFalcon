; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\UI\SRC\taceng\te_team_victory.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?gVCTree@@3PAVC_TreeList@@A			; gVCTree
PUBLIC	?VCSortType@@3JA				; VCSortType
PUBLIC	?ShowGameOverWindow@@3JA			; ShowGameOverWindow
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B ; std::ios_base::failure::_Stream_err
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?team_lbox@@3PAVLISTBOX@@A			; team_lbox
PUBLIC	?action_lbox@@3PAVLISTBOX@@A			; action_lbox
PUBLIC	?percent_lbox@@3PAVLISTBOX@@A			; percent_lbox
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?intercept_lbox@@3PAVLISTBOX@@A			; intercept_lbox
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?VCFlagIDs@@3PAY03JA				; VCFlagIDs
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
_BSS	SEGMENT
?gVCTree@@3PAVC_TreeList@@A DD 01H DUP (?)		; gVCTree
?VCSortType@@3JA DD 01H DUP (?)				; VCSortType
?ShowGameOverWindow@@3JA DD 01H DUP (?)			; ShowGameOverWindow
_team_colour_box DD 08H DUP (?)
_team_name DD	08H DUP (?)
_new_vc_button DD 01H DUP (?)
_show_all_button DD 01H DUP (?)
_show_team_button DD 01H DUP (?)
_show_achieved_button DD 01H DUP (?)
_show_remaining_button DD 01H DUP (?)
_new_team_button DD 08H DUP (?)
_team_flag_box DD 08H DUP (?)
?team_lbox@@3PAVLISTBOX@@A DD 01H DUP (?)		; team_lbox
?action_lbox@@3PAVLISTBOX@@A DD 01H DUP (?)		; action_lbox
?percent_lbox@@3PAVLISTBOX@@A DD 01H DUP (?)		; percent_lbox
?intercept_lbox@@3PAVLISTBOX@@A DD 01H DUP (?)		; intercept_lbox
_BSS	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B
CONST	SEGMENT
?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B DD 01H ; std::ios_base::failure::_Stream_err
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
_DATA	SEGMENT
_team_victory_id DD 02dc6c0H
	ORG $+4
?VCFlagIDs@@3PAY03JA DD 0778cH				; VCFlagIDs
	DD	07789H
	DD	077a9H
	DD	07801H
	DD	07790H
	DD	0778dH
	DD	077aaH
	DD	07802H
	DD	07794H
	DD	07791H
	DD	077abH
	DD	07803H
	DD	07798H
	DD	07795H
	DD	077acH
	DD	07804H
	DD	0779cH
	DD	07799H
	DD	077adH
	DD	07805H
	DD	077a0H
	DD	0779dH
	DD	077aeH
	DD	07806H
	DD	077a4H
	DD	077a1H
	DD	077afH
	DD	07807H
	DD	077a8H
	DD	077a5H
	DD	077b0H
	DD	07808H
_DATA	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
PUBLIC	??0VU_SESSION_ID@@QAE@K@Z			; VU_SESSION_ID::VU_SESSION_ID
PUBLIC	??8VU_SESSION_ID@@QBEHABV0@@Z			; VU_SESSION_ID::operator==
PUBLIC	??0VU_ID@@QAE@XZ				; VU_ID::VU_ID
PUBLIC	??9VU_ID@@QBE_NABV0@@Z				; VU_ID::operator!=
PUBLIC	?Id@VuEntity@@QBE?AVVU_ID@@XZ			; VuEntity::Id
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
PUBLIC	??0id@locale@std@@QAE@I@Z			; std::locale::id::id
PUBLIC	?generic_category@std@@YAABVerror_category@1@XZ	; std::generic_category
PUBLIC	?system_category@std@@YAABVerror_category@1@XZ	; std::system_category
PUBLIC	??0error_category@std@@QAE@XZ			; std::error_category::error_category
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??8error_category@std@@QBE_NABV01@@Z		; std::error_category::operator==
PUBLIC	??_Gerror_category@std@@UAEPAXI@Z		; std::error_category::`scalar deleting destructor'
PUBLIC	?value@error_code@std@@QBEHXZ			; std::error_code::value
PUBLIC	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
PUBLIC	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?value@error_condition@std@@QBEHXZ		; std::error_condition::value
PUBLIC	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
PUBLIC	??8error_condition@std@@QBE_NABV01@@Z		; std::error_condition::operator==
PUBLIC	??0_Generic_error_category@std@@QAE@XZ		; std::_Generic_error_category::_Generic_error_category
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	??1_Generic_error_category@std@@UAE@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	??0_Iostream_error_category@std@@QAE@XZ		; std::_Iostream_error_category::_Iostream_error_category
PUBLIC	?name@_Iostream_error_category@std@@UBEPBDXZ	; std::_Iostream_error_category::name
PUBLIC	?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	??1_Iostream_error_category@std@@UAE@XZ		; std::_Iostream_error_category::~_Iostream_error_category
PUBLIC	??_G_Iostream_error_category@std@@UAEPAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	??0_System_error_category@std@@QAE@XZ		; std::_System_error_category::_System_error_category
PUBLIC	?name@_System_error_category@std@@UBEPBDXZ	; std::_System_error_category::name
PUBLIC	?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message
PUBLIC	?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition
PUBLIC	??1_System_error_category@std@@UAE@XZ		; std::_System_error_category::~_System_error_category
PUBLIC	??_G_System_error_category@std@@UAEPAXI@Z	; std::_System_error_category::`scalar deleting destructor'
PUBLIC	?SetGroup@C_Base@@QAEXJ@Z			; C_Base::SetGroup
PUBLIC	?SetClient@C_Base@@QAEXF@Z			; C_Base::SetClient
PUBLIC	?SetParent@C_Base@@QAEXPAVC_Window@@@Z		; C_Base::SetParent
PUBLIC	?SetReady@C_Base@@QAEXF@Z			; C_Base::SetReady
PUBLIC	?GetID@C_Base@@QAEJXZ				; C_Base::GetID
PUBLIC	?GetFlags@C_Base@@QAEJXZ			; C_Base::GetFlags
PUBLIC	?GetClient@C_Base@@QAEFXZ			; C_Base::GetClient
PUBLIC	?GetX@C_Base@@QAEJXZ				; C_Base::GetX
PUBLIC	?GetW@C_Base@@QAEJXZ				; C_Base::GetW
PUBLIC	?SetBgColor@C_ListBox@@QAEXK@Z			; C_ListBox::SetBgColor
PUBLIC	?GetTextID@C_ListBox@@QAEJXZ			; C_ListBox::GetTextID
PUBLIC	?SetOpenCallback@C_ListBox@@QAEXP6AXPAVC_Base@@@Z@Z ; C_ListBox::SetOpenCallback
PUBLIC	?GetRoot@C_TreeList@@QAEPAVTREELIST@@XZ		; C_TreeList::GetRoot
PUBLIC	?GetLastItem@C_TreeList@@QAEPAVTREELIST@@XZ	; C_TreeList::GetLastItem
PUBLIC	?SetMinInteger@C_EditBox@@QAEXJ@Z		; C_EditBox::SetMinInteger
PUBLIC	?SetMaxInteger@C_EditBox@@QAEXJ@Z		; C_EditBox::SetMaxInteger
PUBLIC	?GetInteger@C_EditBox@@QAEJXZ			; C_EditBox::GetInteger
PUBLIC	?GetCallingControl@C_PopupMgr@@QAEPAVC_Base@@XZ	; C_PopupMgr::GetCallingControl
PUBLIC	?GetAppWnd@C_Handler@@QAEPAUHWND__@@XZ		; C_Handler::GetAppWnd
PUBLIC	?GetVUID@C_ATO_Flight@@QAE?AVVU_ID@@XZ		; C_ATO_Flight::GetVUID
PUBLIC	?GetIconID@C_MapIcon@@QAEJXZ			; C_MapIcon::GetIconID
PUBLIC	?GetVUID@C_Squadron@@QAE?AVVU_ID@@XZ		; C_Squadron::GetVUID
PUBLIC	?SetOwner@C_Victory@@QAEXPAVTREELIST@@@Z	; C_Victory::SetOwner
PUBLIC	?SetNumberX@C_Victory@@QAEXF@Z			; C_Victory::SetNumberX
PUBLIC	?SetTeamX@C_Victory@@QAEXF@Z			; C_Victory::SetTeamX
PUBLIC	?SetActionX@C_Victory@@QAEXF@Z			; C_Victory::SetActionX
PUBLIC	?SetTargetX@C_Victory@@QAEXF@Z			; C_Victory::SetTargetX
PUBLIC	?SetArgsX@C_Victory@@QAEXF@Z			; C_Victory::SetArgsX
PUBLIC	?SetPointsX@C_Victory@@QAEXF@Z			; C_Victory::SetPointsX
PUBLIC	?SetNumber@C_Victory@@QAEXPAVC_Text@@@Z		; C_Victory::SetNumber
PUBLIC	?SetTeam@C_Victory@@QAEXPAVC_ListBox@@@Z	; C_Victory::SetTeam
PUBLIC	?SetAction@C_Victory@@QAEXPAVC_ListBox@@@Z	; C_Victory::SetAction
PUBLIC	?SetTarget@C_Victory@@QAEXPAVC_Button@@@Z	; C_Victory::SetTarget
PUBLIC	?SetArgs@C_Victory@@QAEXPAVC_ListBox@@@Z	; C_Victory::SetArgs
PUBLIC	?SetPoints@C_Victory@@QAEXPAVC_EditBox@@@Z	; C_Victory::SetPoints
PUBLIC	?GetTeam@C_Victory@@QAEPAVC_ListBox@@XZ		; C_Victory::GetTeam
PUBLIC	?GetAction@C_Victory@@QAEPAVC_ListBox@@XZ	; C_Victory::GetAction
PUBLIC	?GetTarget@C_Victory@@QAEPAVC_Button@@XZ	; C_Victory::GetTarget
PUBLIC	?GetArgs@C_Victory@@QAEPAVC_ListBox@@XZ		; C_Victory::GetArgs
PUBLIC	?GetPoints@C_Victory@@QAEPAVC_EditBox@@XZ	; C_Victory::GetPoints
PUBLIC	?SetPtr@C_Victory@@QAEXPAX@Z			; C_Victory::SetPtr
PUBLIC	?GetPtr@C_Victory@@QAEPAXXZ			; C_Victory::GetPtr
PUBLIC	?GetFlag@TeamClass@@QAEHXZ			; TeamClass::GetFlag
PUBLIC	?GetColor@TeamClass@@QAEHXZ			; TeamClass::GetColor
PUBLIC	??_Gvictory_condition@@QAEPAXI@Z		; victory_condition::`scalar deleting destructor'
PUBLIC	?set_game_over@tactical_mission@@QAEXH@Z	; tactical_mission::set_game_over
PUBLIC	?get_game_over@tactical_mission@@QAEHXZ		; tactical_mission::get_game_over
PUBLIC	?GetID@UI_Refresher@@QAE?AVVU_ID@@XZ		; UI_Refresher::GetID
PUBLIC	?hookup_team_victory_window@@YAXPAVC_Window@@@Z	; hookup_team_victory_window
PUBLIC	?update_team_victory_window@@YAXXZ		; update_team_victory_window
PUBLIC	?SetFrontTextFlags@OTWDriverClass@@QAEXJ@Z	; OTWDriverClass::SetFrontTextFlags
PUBLIC	?GetFrontTextFlags@OTWDriverClass@@QAEJXZ	; OTWDriverClass::GetFrontTextFlags
PUBLIC	?InitVCArgLists@@YAXXZ				; InitVCArgLists
PUBLIC	?hookup_team_buttons@@YAXPAVC_Window@@HJJJJ@Z	; hookup_team_buttons
PUBLIC	?RebuildTeamLists@@YAXXZ			; RebuildTeamLists
PUBLIC	?CleanupVCArgLists@@YAXXZ			; CleanupVCArgLists
PUBLIC	?SetVCSortTypeCB@@YAXJFPAVC_Base@@@Z		; SetVCSortTypeCB
PUBLIC	?VCSortCB@@YAHPAVTREELIST@@0@Z			; VCSortCB
PUBLIC	?UpdateVCOptions@@YAXPAVvictory_condition@@@Z	; UpdateVCOptions
PUBLIC	?VCChangeTeamNoCB@@YAXJFPAVC_Base@@@Z		; VCChangeTeamNoCB
PUBLIC	?VCChangeActionCB@@YAXJFPAVC_Base@@@Z		; VCChangeActionCB
PUBLIC	?VCSetTargetCB@@YAXJFPAVC_Base@@@Z		; VCSetTargetCB
PUBLIC	?VCArgsCB@@YAXJFPAVC_Base@@@Z			; VCArgsCB
PUBLIC	?VCSetPointsCB@@YAXJFPAVC_Base@@@Z		; VCSetPointsCB
PUBLIC	?VCSelectVCCB@@YAXJFPAVC_Base@@@Z		; VCSelectVCCB
PUBLIC	?AssignVCCB@@YAXJFPAVC_Base@@@Z			; AssignVCCB
PUBLIC	?SetVCTargetInfo@@YAXPAVCampBaseClass@@@Z	; SetVCTargetInfo
PUBLIC	?SelectVCTargetCB@@YAXJFPAVC_Base@@@Z		; SelectVCTargetCB
PUBLIC	?VCActionOpenCB@@YAXPAVC_Base@@@Z		; VCActionOpenCB
PUBLIC	?VCArgsOpenCB@@YAXPAVC_Base@@@Z			; VCArgsOpenCB
PUBLIC	?MakeVCControl@@YAPAVC_Victory@@PAVvictory_condition@@@Z ; MakeVCControl
PUBLIC	?advance_team@@YAHHH@Z				; advance_team
PUBLIC	?GetCurrentVCScore@@YAJJ@Z			; GetCurrentVCScore
PUBLIC	?GetPossibleVCScore@@YAJJ@Z			; GetPossibleVCScore
PUBLIC	?UpdateVCScoring@@YAXJF@Z			; UpdateVCScoring
PUBLIC	?tactical_add_victory_condition@@YAXVVU_ID@@PAVC_Base@@@Z ; tactical_add_victory_condition
PUBLIC	?get_tactical_number_of_teams@@YAHXZ		; get_tactical_number_of_teams
PUBLIC	?add_all_vcs_to_ui@@YAXXZ			; add_all_vcs_to_ui
PUBLIC	?EvaluateSituation@@YAJXZ			; EvaluateSituation
PUBLIC	?EndGameEvaluation@@YAXXZ			; EndGameEvaluation
PUBLIC	?TriggerTacEndGame@@YAXXZ			; TriggerTacEndGame
PUBLIC	?OpenTEGameOverWindow@@YAXXZ			; OpenTEGameOverWindow
PUBLIC	?TacEngGameOver@@YAXXZ				; TacEngGameOver
PUBLIC	?TacEngSetVCCompleted@@YAXJH@Z			; TacEngSetVCCompleted
PUBLIC	?CheckForVictory@@YAXXZ				; CheckForVictory
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??_7error_category@std@@6B@			; std::error_category::`vftable'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_C@_07DCLBNMLN@generic?$AA@			; `string'
PUBLIC	??_C@_0O@BFJCFAAK@unknown?5error?$AA@		; `string'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream?$AA@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	; `string'
PUBLIC	??_7_System_error_category@std@@6B@		; std::_System_error_category::`vftable'
PUBLIC	??_C@_06FHFOAHML@system?$AA@			; `string'
PUBLIC	?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
PUBLIC	?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
PUBLIC	?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
PUBLIC	?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
PUBLIC	?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
PUBLIC	??_C@_07IELFBDLE@No?5Team?$AA@			; `string'
PUBLIC	??_C@_02KEGNLNML@?0?5?$AA@			; `string'
PUBLIC	??_C@_03GNGPFOOL@?$CF1d?$AA@			; `string'
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	?id@?$numpunct@_W@std@@2V0locale@2@A		; std::numpunct<wchar_t>::id
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_R4error_category@std@@6B@			; std::error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error_category@std@@6B@		; std::_System_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_System_error_category@std@@@8		; std::_System_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_System_error_category@std@@8		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error_category@std@@8		; std::_System_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error_category@std@@8	; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	_sprintf:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_strcat:PROC
EXTRN	_strlen:PROC
EXTRN	_memmove:PROC
EXTRN	__imp__PostMessageA@16:PROC
EXTRN	__imp__SetCursor@4:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z:PROC ; VuDatabase::Find
EXTRN	??_Eerror_category@std@@UAEPAXI@Z:PROC		; std::error_category::`vector deleting destructor'
EXTRN	?_Syserror_map@std@@YAPBDH@Z:PROC		; std::_Syserror_map
EXTRN	?_Winerror_map@std@@YAPBDH@Z:PROC		; std::_Winerror_map
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_E_System_error_category@std@@UAEPAXI@Z:PROC	; std::_System_error_category::`vector deleting destructor'
EXTRN	?GetHeight@C_Font@@QAEHJ@Z:PROC			; C_Font::GetHeight
EXTRN	?UI_Enter@@YAPAUF4CSECTIONHANDLE@@PAVC_Window@@@Z:PROC ; UI_Enter
EXTRN	?UI_Leave@@YAXPAUF4CSECTIONHANDLE@@@Z:PROC	; UI_Leave
EXTRN	?SetUserNumber@C_Base@@QAEXJJ@Z:PROC		; C_Base::SetUserNumber
EXTRN	?GetUserNumber@C_Base@@QAEJJ@Z:PROC		; C_Base::GetUserNumber
EXTRN	?SetImage@C_Bitmap@@QAEXJ@Z:PROC		; C_Bitmap::SetImage
EXTRN	??0C_Button@@QAE@XZ:PROC			; C_Button::C_Button
EXTRN	?Setup@C_Button@@QAEXJFJJ@Z:PROC		; C_Button::Setup
EXTRN	?SetText@C_Button@@QAEXFPBD@Z:PROC		; C_Button::SetText
EXTRN	?SetText@C_Button@@QAEXFJ@Z:PROC		; C_Button::SetText
EXTRN	??0C_ListBox@@QAE@XZ:PROC			; C_ListBox::C_ListBox
EXTRN	?Setup@C_ListBox@@QAEXJFPAVC_Handler@@@Z:PROC	; C_ListBox::Setup
EXTRN	?SetItemFlags@C_ListBox@@QAEXJJ@Z:PROC		; C_ListBox::SetItemFlags
EXTRN	?SetRoot@C_ListBox@@QAEXPAVLISTBOX@@@Z:PROC	; C_ListBox::SetRoot
EXTRN	?SetBgFill@C_ListBox@@QAEXHHHH@Z:PROC		; C_ListBox::SetBgFill
EXTRN	?FindID@C_ListBox@@QAEPAVLISTBOX@@J@Z:PROC	; C_ListBox::FindID
EXTRN	?SetDropDown@C_ListBox@@QAEXJ@Z:PROC		; C_ListBox::SetDropDown
EXTRN	?SetValue@C_ListBox@@QAEXJ@Z:PROC		; C_ListBox::SetValue
EXTRN	?CreateItem@C_TreeList@@QAEPAVTREELIST@@JJPAVC_Base@@@Z:PROC ; C_TreeList::CreateItem
EXTRN	?AddItem@C_TreeList@@QAEHPAVTREELIST@@0@Z:PROC	; C_TreeList::AddItem
EXTRN	?DeleteItem@C_TreeList@@QAEXJ@Z:PROC		; C_TreeList::DeleteItem
EXTRN	?DeleteBranch@C_TreeList@@QAEXPAVTREELIST@@@Z:PROC ; C_TreeList::DeleteBranch
EXTRN	?SetAllControlStates@C_TreeList@@QAEXFPAVTREELIST@@@Z:PROC ; C_TreeList::SetAllControlStates
EXTRN	?RecalcSize@C_TreeList@@QAEXXZ:PROC		; C_TreeList::RecalcSize
EXTRN	?ReorderBranch@C_TreeList@@QAEXPAVTREELIST@@@Z:PROC ; C_TreeList::ReorderBranch
EXTRN	?SetCallback@C_PopupList@@QAEXJP6AXJFPAVC_Base@@@Z@Z:PROC ; C_PopupList::SetCallback
EXTRN	?CopyToText@C_EditBox@@AAEXXZ:PROC		; C_EditBox::CopyToText
EXTRN	??0C_EditBox@@QAE@XZ:PROC			; C_EditBox::C_EditBox
EXTRN	?Setup@C_EditBox@@QAEXJF@Z:PROC			; C_EditBox::Setup
EXTRN	?SetMaxLen@C_EditBox@@QAEXF@Z:PROC		; C_EditBox::SetMaxLen
EXTRN	?SetText@C_EditBox@@QAEXPAD@Z:PROC		; C_EditBox::SetText
EXTRN	?SetInteger@C_EditBox@@QAEXJ@Z:PROC		; C_EditBox::SetInteger
EXTRN	?SetBgColor@C_EditBox@@QAEXK@Z:PROC		; C_EditBox::SetBgColor
EXTRN	??0C_Text@@QAE@XZ:PROC				; C_Text::C_Text
EXTRN	?SetFixedWidth@C_Text@@QAEXJ@Z:PROC		; C_Text::SetFixedWidth
EXTRN	?SetColor@C_Box@@QAEXK@Z:PROC			; C_Box::SetColor
EXTRN	?GetMenu@C_PopupMgr@@QAEPAVC_PopupList@@J@Z:PROC ; C_PopupMgr::GetMenu
EXTRN	?CloseMenu@C_PopupMgr@@QAEXXZ:PROC		; C_PopupMgr::CloseMenu
EXTRN	?UnHideCluster@C_Window@@QAEXJ@Z:PROC		; C_Window::UnHideCluster
EXTRN	?HideCluster@C_Window@@QAEXJ@Z:PROC		; C_Window::HideCluster
EXTRN	?RefreshWindow@C_Window@@QAEXXZ:PROC		; C_Window::RefreshWindow
EXTRN	?RefreshClient@C_Window@@QAEXJ@Z:PROC		; C_Window::RefreshClient
EXTRN	?FindControl@C_Window@@QAEPAVC_Base@@J@Z:PROC	; C_Window::FindControl
EXTRN	?EnterCritical@C_Handler@@QAEXXZ:PROC		; C_Handler::EnterCritical
EXTRN	?LeaveCritical@C_Handler@@QAEXXZ:PROC		; C_Handler::LeaveCritical
EXTRN	?ShowWindow@C_Handler@@QAEHPAVC_Window@@@Z:PROC	; C_Handler::ShowWindow
EXTRN	?HideWindow@C_Handler@@QAEHPAVC_Window@@@Z:PROC	; C_Handler::HideWindow
EXTRN	?EnableWindowGroup@C_Handler@@QAEXJ@Z:PROC	; C_Handler::EnableWindowGroup
EXTRN	?WindowToFront@C_Handler@@QAEXPAVC_Window@@@Z:PROC ; C_Handler::WindowToFront
EXTRN	?GetWindowFlags@C_Handler@@QAEJJ@Z:PROC		; C_Handler::GetWindowFlags
EXTRN	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z:PROC ; C_Handler::FindWindowA
EXTRN	??0C_Victory@@QAE@XZ:PROC			; C_Victory::C_Victory
EXTRN	?Setup@C_Victory@@QAEXJF@Z:PROC			; C_Victory::Setup
EXTRN	?GetTeam@FalconSessionEntity@@QAEEXZ:PROC	; FalconSessionEntity::GetTeam
EXTRN	?Remove@CampBaseClass@@QAEHXZ:PROC		; CampBaseClass::Remove
EXTRN	?GetTotalVehicles@UnitClass@@QAEHXZ:PROC	; UnitClass::GetTotalVehicles
EXTRN	?GetName@TeamClass@@QAEPADXZ:PROC		; TeamClass::GetName
EXTRN	?RemoveTeam@@YAXH@Z:PROC			; RemoveTeam
EXTRN	?SetTimeCompression@@YAXH@Z:PROC		; SetTimeCompression
EXTRN	?GetFeatureID@ObjectiveClass@@QAEHH@Z:PROC	; ObjectiveClass::GetFeatureID
EXTRN	?FindEntity@@YAPAVCampBaseClass@@VVU_ID@@@Z:PROC ; FindEntity
EXTRN	?GetCallsign@@YAXHHPAD@Z:PROC			; GetCallsign
EXTRN	??0victory_condition@@QAE@PAVtactical_mission@@@Z:PROC ; victory_condition::victory_condition
EXTRN	??1victory_condition@@QAE@XZ:PROC		; victory_condition::~victory_condition
EXTRN	?set_team@victory_condition@@QAEXH@Z:PROC	; victory_condition::set_team
EXTRN	?get_team@victory_condition@@QAEHXZ:PROC	; victory_condition::get_team
EXTRN	?set_type@victory_condition@@QAEXW4victory_type@@@Z:PROC ; victory_condition::set_type
EXTRN	?get_type@victory_condition@@QAE?AW4victory_type@@XZ:PROC ; victory_condition::get_type
EXTRN	?set_vu_id@victory_condition@@QAEXVVU_ID@@@Z:PROC ; victory_condition::set_vu_id
EXTRN	?get_vu_id@victory_condition@@QAE?AVVU_ID@@XZ:PROC ; victory_condition::get_vu_id
EXTRN	?set_sub_objective@victory_condition@@QAEXH@Z:PROC ; victory_condition::set_sub_objective
EXTRN	?get_sub_objective@victory_condition@@QAEHXZ:PROC ; victory_condition::get_sub_objective
EXTRN	?set_tolerance@victory_condition@@QAEXH@Z:PROC	; victory_condition::set_tolerance
EXTRN	?get_tolerance@victory_condition@@QAEHXZ:PROC	; victory_condition::get_tolerance
EXTRN	?set_points@victory_condition@@QAEXH@Z:PROC	; victory_condition::set_points
EXTRN	?get_points@victory_condition@@QAEHXZ:PROC	; victory_condition::get_points
EXTRN	?get_number@victory_condition@@QAEHXZ:PROC	; victory_condition::get_number
EXTRN	?set_active@victory_condition@@QAEXH@Z:PROC	; victory_condition::set_active
EXTRN	?get_active@victory_condition@@QAEHXZ:PROC	; victory_condition::get_active
EXTRN	?set_victory_condition_filter@tactical_mission@@QAEXW4victory_condition_filter@@@Z:PROC ; tactical_mission::set_victory_condition_filter
EXTRN	?set_victory_condition_team_filter@tactical_mission@@QAEXH@Z:PROC ; tactical_mission::set_victory_condition_team_filter
EXTRN	?get_first_unfiltered_victory_condition@tactical_mission@@QAEPAVvictory_condition@@XZ:PROC ; tactical_mission::get_first_unfiltered_victory_condition
EXTRN	?get_next_unfiltered_victory_condition@tactical_mission@@QAEPAVvictory_condition@@XZ:PROC ; tactical_mission::get_next_unfiltered_victory_condition
EXTRN	?set_points_required@tactical_mission@@QAEXH@Z:PROC ; tactical_mission::set_points_required
EXTRN	?get_points_required@tactical_mission@@QAEHXZ:PROC ; tactical_mission::get_points_required
EXTRN	?AddVC@C_Map@@QAEPAVMAPICONLIST@@PAVvictory_condition@@@Z:PROC ; C_Map::AddVC
EXTRN	?UpdateVC@C_Map@@QAEXPAVvictory_condition@@@Z:PROC ; C_Map::UpdateVC
EXTRN	?RemoveVC@C_Map@@QAEXJJ@Z:PROC			; C_Map::RemoveVC
EXTRN	?GetFeatureClassData@@YAPAUFeatureClassDataType@@H@Z:PROC ; GetFeatureClassData
EXTRN	?Find@GlobalPositioningSystem@@QAEPAXJ@Z:PROC	; GlobalPositioningSystem::Find
EXTRN	?Update@GlobalPositioningSystem@@QAEXXZ:PROC	; GlobalPositioningSystem::Update
EXTRN	?BuildSpecificTargetList@@YAXVVU_ID@@@Z:PROC	; BuildSpecificTargetList
EXTRN	?delete_all_units_for_team@@YAXH@Z:PROC		; delete_all_units_for_team
EXTRN	?tactical_remove_squadron@@YAXPAVSquadronClass@@@Z:PROC ; tactical_remove_squadron
EXTRN	?SelectToolTypeCB@@YAXJFPAVC_Base@@@Z:PROC	; SelectToolTypeCB
EXTRN	?CloseReconWindowCB@@YAXJFPAVC_Base@@@Z:PROC	; CloseReconWindowCB
EXTRN	?check_victory_conditions@@YAHXZ:PROC		; check_victory_conditions
EXTRN	?CancelCampaignCompression@@YAXXZ:PROC		; CancelCampaignCompression
EXTRN	?TgtAssignCWCB@@YAXJFPAVC_Base@@@Z:PROC		; TgtAssignCWCB
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	?vuDatabase@@3PAVVuDatabase@@A:DWORD		; vuDatabase
EXTRN	?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A:DWORD ; vuLocalSessionEntity
EXTRN	?FalconNullId@@3VVU_ID@@A:QWORD			; FalconNullId
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?gFontList@@3PAVC_Font@@A:DWORD			; gFontList
EXTRN	?gPopupMgr@@3PAVC_PopupMgr@@A:DWORD		; gPopupMgr
EXTRN	?gCursors@@3PAPAUHICON__@@A:BYTE		; gCursors
EXTRN	?TheCampaign@@3VCampaignClass@@A:BYTE		; TheCampaign
EXTRN	?TeamInfo@@3PAPAVTeamClass@@A:BYTE		; TeamInfo
EXTRN	?gMainHandler@@3PAVC_Handler@@A:DWORD		; gMainHandler
EXTRN	?current_tactical_mission@@3PAVtactical_mission@@A:DWORD ; current_tactical_mission
EXTRN	?TeamColorList@@3PAKA:BYTE			; TeamColorList
EXTRN	?FlagImageID@@3PAY04JA:BYTE			; FlagImageID
EXTRN	?OTWDriver@@3VOTWDriverClass@@A:BYTE		; OTWDriver
EXTRN	?gRefreshScoresList@@3JA:DWORD			; gRefreshScoresList
EXTRN	?gMapMgr@@3PAVC_Map@@A:DWORD			; gMapMgr
EXTRN	?gSelectedTeam@@3EA:BYTE			; gSelectedTeam
EXTRN	?OldReconCWCB@@3P6AXJFPAVC_Base@@@ZA:DWORD	; OldReconCWCB
EXTRN	?FeatureID@@3VVU_ID@@A:QWORD			; FeatureID
EXTRN	?FeatureNo@@3JA:DWORD				; FeatureNo
EXTRN	?TargetTree@@3PAVC_TreeList@@A:DWORD		; TargetTree
EXTRN	?gGps@@3PAVGlobalPositioningSystem@@A:DWORD	; gGps
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
_BSS	SEGMENT
?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Generic_object
_BSS	ENDS
;	COMDAT ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
_BSS	SEGMENT
?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Iostream_object
_BSS	ENDS
;	COMDAT ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
_BSS	SEGMENT
?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_System_object
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
_BSS	ENDS
_BSS	SEGMENT
	ALIGN	4

_team_mapping DD 08H DUP (?)
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@_W@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@_W@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<wchar_t>::id
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error_category@std@@8 DD FLAT:??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error_category@std@@8
rdata$r	SEGMENT
??_R2_System_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error_category@std@@8
rdata$r	SEGMENT
??_R3_System_error_category@std@@8 DD 00H		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_System_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_System_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_System_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_System_error_category@std@@6B@ DD 00H		; std::_System_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error_category@std@@@8
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD FLAT:??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 00H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category@std@@@8
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
_DATA	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4error_category@std@@6B@
rdata$r	SEGMENT
??_R4error_category@std@@6B@ DD 00H			; std::error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVerror_category@std@@@8
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_03GNGPFOOL@?$CF1d?$AA@
CONST	SEGMENT
??_C@_03GNGPFOOL@?$CF1d?$AA@ DB '%1d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02KEGNLNML@?0?5?$AA@
CONST	SEGMENT
??_C@_02KEGNLNML@?0?5?$AA@ DB ', ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07IELFBDLE@No?5Team?$AA@
CONST	SEGMENT
??_C@_07IELFBDLE@No?5Team?$AA@ DB 'No Team', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system?$AA@
CONST	SEGMENT
??_C@_06FHFOAHML@system?$AA@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_System_error_category@std@@6B@
CONST	SEGMENT
??_7_System_error_category@std@@6B@ DD FLAT:??_R4_System_error_category@std@@6B@ ; std::_System_error_category::`vftable'
	DD	FLAT:??_E_System_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_System_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ DB 'iostream stream error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream?$AA@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream?$AA@ DB 'iostream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DD FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DD	FLAT:??_E_Iostream_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
CONST	SEGMENT
??_C@_0O@BFJCFAAK@unknown?5error?$AA@ DB 'unknown error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic?$AA@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic?$AA@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7error_category@std@@6B@
CONST	SEGMENT
??_7error_category@std@@6B@ DD FLAT:??_R4error_category@std@@6B@ ; std::error_category::`vftable'
	DD	FLAT:??_Eerror_category@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
__ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
xdata$x	SEGMENT
__unwindtable$?tactical_add_victory_condition@@YAXVVU_ID@@PAVC_Base@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?tactical_add_victory_condition@@YAXVVU_ID@@PAVC_Base@@@Z$0
__unwindtable$?mk_item@@YAPAVLISTBOX@@JPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?mk_item@@YAPAVLISTBOX@@JPAD@Z$0
__unwindtable$?mk_item@@YAPAVLISTBOX@@JJ@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?mk_item@@YAPAVLISTBOX@@JJ@Z$0
__unwindtable$?add_vc_air_unit@@YAXJFPAVC_Base@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?add_vc_air_unit@@YAXJFPAVC_Base@@@Z$0
__unwindtable$?new_victory_condition@@YAXJFPAVC_Base@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?new_victory_condition@@YAXJFPAVC_Base@@@Z$0
__ehfuncinfo$?tactical_add_victory_condition@@YAXVVU_ID@@PAVC_Base@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?tactical_add_victory_condition@@YAXVVU_ID@@PAVC_Base@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?MakeVCControl@@YAPAVC_Victory@@PAVvictory_condition@@@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?MakeVCControl@@YAPAVC_Victory@@PAVvictory_condition@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?mk_item@@YAPAVLISTBOX@@JPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?mk_item@@YAPAVLISTBOX@@JPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?mk_item@@YAPAVLISTBOX@@JJ@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?mk_item@@YAPAVLISTBOX@@JJ@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?add_vc_air_unit@@YAXJFPAVC_Base@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?add_vc_air_unit@@YAXJFPAVC_Base@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?new_victory_condition@@YAXJFPAVC_Base@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?new_victory_condition@@YAXJFPAVC_Base@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?MakeVCControl@@YAPAVC_Victory@@PAVvictory_condition@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?MakeVCControl@@YAPAVC_Victory@@PAVvictory_condition@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?MakeVCControl@@YAPAVC_Victory@@PAVvictory_condition@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?MakeVCControl@@YAPAVC_Victory@@PAVvictory_condition@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?MakeVCControl@@YAPAVC_Victory@@PAVvictory_condition@@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?MakeVCControl@@YAPAVC_Victory@@PAVvictory_condition@@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?MakeVCControl@@YAPAVC_Victory@@PAVvictory_condition@@@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?MakeVCControl@@YAPAVC_Victory@@PAVvictory_condition@@@Z$6
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Generic_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Iostream_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_System_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@D@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<char>::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@_W@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<wchar_t>::id$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 621  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();
; 624  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
_this$ = -24						; size = 4
tv73 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR __V0$[ebp]
	push	ecx
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<wchar_t>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@_W@std@@2V0locale@2@A ; std::numpunct<wchar_t>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<wchar_t>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<char>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<char>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 755  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp

; 756  : 		{	// destroy object at _Ptr
; 757  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>

; 758  : 		}

	pop	ebp
	ret	0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
	pop	ebp
	ret	0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	ebp
	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??1_System_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_System_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??0_System_error_category@std@@QAE@XZ	; std::_System_error_category::_System_error_category
	push	OFFSET ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_System_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??1_Iostream_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??0_Iostream_error_category@std@@QAE@XZ	; std::_Iostream_error_category::_Iostream_error_category
	push	OFFSET ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??1_Generic_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	push	OFFSET ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], -1
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 85   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 89   : 	}

	pop	ebp
	ret	0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 907  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
	add	esp, 8

; 910  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
	add	esp, 12					; 0000000cH
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\taceng\te_team_victory.cpp
_TEXT	SEGMENT
?CheckForVictory@@YAXXZ PROC				; CheckForVictory

; 2371 : {

	push	ebp
	mov	ebp, esp

; 2372 : 	if(current_tactical_mission)

	cmp	DWORD PTR ?current_tactical_mission@@3PAVtactical_mission@@A, 0 ; current_tactical_mission
	je	SHORT $LN3@CheckForVi

; 2373 : 	{
; 2374 : 		// Victory Condition Checks
; 2375 : 		if(!current_tactical_mission->get_game_over() && check_victory_conditions())

	mov	ecx, DWORD PTR ?current_tactical_mission@@3PAVtactical_mission@@A ; current_tactical_mission
	call	?get_game_over@tactical_mission@@QAEHXZ	; tactical_mission::get_game_over
	test	eax, eax
	jne	SHORT $LN3@CheckForVi
	call	?check_victory_conditions@@YAHXZ	; check_victory_conditions
	test	eax, eax
	je	SHORT $LN3@CheckForVi

; 2376 : 		{ // Kevin, when you transmit the EndgameResult variable... there is a duplicate section of code to this in
; 2377 : 		  // te_team_victory.cpp at the bottom
; 2378 : 			TriggerTacEndGame();	// Tell UI to open window

	call	?TriggerTacEndGame@@YAXXZ		; TriggerTacEndGame

; 2379 : 			OTWDriver.SetFrontTextFlags(OTWDriver.GetFrontTextFlags() | SHOW_TE_SCORES);

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetFrontTextFlags@OTWDriverClass@@QAEJXZ ; OTWDriverClass::GetFrontTextFlags
	or	eax, 256				; 00000100H
	push	eax
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?SetFrontTextFlags@OTWDriverClass@@QAEXJ@Z ; OTWDriverClass::SetFrontTextFlags
$LN3@CheckForVi:

; 2380 : 		}
; 2381 : 	}
; 2382 : }

	pop	ebp
	ret	0
?CheckForVictory@@YAXXZ ENDP				; CheckForVictory
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\taceng\te_team_victory.cpp
_TEXT	SEGMENT
_vc$ = -4						; size = 4
_ID$ = 8						; size = 4
_value$ = 12						; size = 4
?TacEngSetVCCompleted@@YAXJH@Z PROC			; TacEngSetVCCompleted

; 2341 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2342 : 	victory_condition *vc;
; 2343 : 
; 2344 : 	if(current_tactical_mission)

	cmp	DWORD PTR ?current_tactical_mission@@3PAVtactical_mission@@A, 0 ; current_tactical_mission
	je	SHORT $LN6@TacEngSetV

; 2345 : 	{
; 2346 : 		vc=current_tactical_mission->get_first_unfiltered_victory_condition();

	mov	ecx, DWORD PTR ?current_tactical_mission@@3PAVtactical_mission@@A ; current_tactical_mission
	call	?get_first_unfiltered_victory_condition@tactical_mission@@QAEPAVvictory_condition@@XZ ; tactical_mission::get_first_unfiltered_victory_condition
	mov	DWORD PTR _vc$[ebp], eax
$LN4@TacEngSetV:

; 2347 : 		while(vc)

	cmp	DWORD PTR _vc$[ebp], 0
	je	SHORT $LN3@TacEngSetV

; 2348 : 		{
; 2349 : 			if(vc->get_number() == ID)

	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_number@victory_condition@@QAEHXZ	; victory_condition::get_number
	cmp	eax, DWORD PTR _ID$[ebp]
	jne	SHORT $LN2@TacEngSetV

; 2350 : 			{
; 2351 : 				vc->set_active(value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?set_active@victory_condition@@QAEXH@Z	; victory_condition::set_active
$LN2@TacEngSetV:

; 2352 : 			}
; 2353 : 			vc=current_tactical_mission->get_next_unfiltered_victory_condition();

	mov	ecx, DWORD PTR ?current_tactical_mission@@3PAVtactical_mission@@A ; current_tactical_mission
	call	?get_next_unfiltered_victory_condition@tactical_mission@@QAEPAVvictory_condition@@XZ ; tactical_mission::get_next_unfiltered_victory_condition
	mov	DWORD PTR _vc$[ebp], eax

; 2354 : 		}

	jmp	SHORT $LN4@TacEngSetV
$LN3@TacEngSetV:

; 2355 : 
; 2356 : 		gRefreshScoresList=1;

	mov	DWORD PTR ?gRefreshScoresList@@3JA, 1	; gRefreshScoresList

; 2357 : 		if(!current_tactical_mission->get_game_over() && check_victory_conditions())

	mov	ecx, DWORD PTR ?current_tactical_mission@@3PAVtactical_mission@@A ; current_tactical_mission
	call	?get_game_over@tactical_mission@@QAEHXZ	; tactical_mission::get_game_over
	test	eax, eax
	jne	SHORT $LN6@TacEngSetV
	call	?check_victory_conditions@@YAHXZ	; check_victory_conditions
	test	eax, eax
	je	SHORT $LN6@TacEngSetV

; 2358 : 		{
; 2359 : 			TriggerTacEndGame();	// Tell UI to open window

	call	?TriggerTacEndGame@@YAXXZ		; TriggerTacEndGame

; 2360 : 			OTWDriver.SetFrontTextFlags(OTWDriver.GetFrontTextFlags() | SHOW_TE_SCORES);

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetFrontTextFlags@OTWDriverClass@@QAEJXZ ; OTWDriverClass::GetFrontTextFlags
	or	eax, 256				; 00000100H
	push	eax
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?SetFrontTextFlags@OTWDriverClass@@QAEXJ@Z ; OTWDriverClass::SetFrontTextFlags
$LN6@TacEngSetV:

; 2361 : 		}
; 2362 : 	}
; 2363 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?TacEngSetVCCompleted@@YAXJH@Z ENDP			; TacEngSetVCCompleted
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\taceng\te_team_victory.cpp
_TEXT	SEGMENT
?TacEngGameOver@@YAXXZ PROC				; TacEngGameOver

; 2324 : {

	push	ebp
	mov	ebp, esp

; 2325 : 	if (current_tactical_mission)

	cmp	DWORD PTR ?current_tactical_mission@@3PAVtactical_mission@@A, 0 ; current_tactical_mission
	je	SHORT $LN2@TacEngGame

; 2326 : 	{
; 2327 : 		current_tactical_mission->set_game_over (1);

	push	1
	mov	ecx, DWORD PTR ?current_tactical_mission@@3PAVtactical_mission@@A ; current_tactical_mission
	call	?set_game_over@tactical_mission@@QAEXH@Z ; tactical_mission::set_game_over

; 2328 : 		check_victory_conditions ();

	call	?check_victory_conditions@@YAHXZ	; check_victory_conditions

; 2329 : 
; 2330 : 		TriggerTacEndGame();	// Tell UI to open window

	call	?TriggerTacEndGame@@YAXXZ		; TriggerTacEndGame

; 2331 : 		OTWDriver.SetFrontTextFlags(OTWDriver.GetFrontTextFlags() | SHOW_TE_SCORES);

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetFrontTextFlags@OTWDriverClass@@QAEJXZ ; OTWDriverClass::GetFrontTextFlags
	or	eax, 256				; 00000100H
	push	eax
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?SetFrontTextFlags@OTWDriverClass@@QAEXJ@Z ; OTWDriverClass::SetFrontTextFlags
$LN2@TacEngGame:

; 2332 : 	}
; 2333 : }

	pop	ebp
	ret	0
?TacEngGameOver@@YAXXZ ENDP				; TacEngGameOver
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\taceng\te_team_victory.cpp
_TEXT	SEGMENT
?OpenTEGameOverWindow@@YAXXZ PROC			; OpenTEGameOverWindow

; 2312 : {

	push	ebp
	mov	ebp, esp

; 2313 : 	if(!gMainHandler)

	cmp	DWORD PTR ?gMainHandler@@3PAVC_Handler@@A, 0 ; gMainHandler
	jne	SHORT $LN1@OpenTEGame

; 2314 : 		return;

	jmp	SHORT $LN2@OpenTEGame
$LN1@OpenTEGame:

; 2315 : 
; 2316 : 	EndGameEvaluation();

	call	?EndGameEvaluation@@YAXXZ		; EndGameEvaluation
$LN2@OpenTEGame:

; 2317 : }

	pop	ebp
	ret	0
?OpenTEGameOverWindow@@YAXXZ ENDP			; OpenTEGameOverWindow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\taceng\te_team_victory.cpp
_TEXT	SEGMENT
_win$1 = -4						; size = 4
?TriggerTacEndGame@@YAXXZ PROC				; TriggerTacEndGame

; 2284 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2285 : 	ShowGameOverWindow=1;

	mov	DWORD PTR ?ShowGameOverWindow@@3JA, 1	; ShowGameOverWindow

; 2286 : 
; 2287 : 	if(gMainHandler && ShowGameOverWindow)

	cmp	DWORD PTR ?gMainHandler@@3PAVC_Handler@@A, 0 ; gMainHandler
	je	SHORT $LN4@TriggerTac
	cmp	DWORD PTR ?ShowGameOverWindow@@3JA, 0	; ShowGameOverWindow
	je	SHORT $LN4@TriggerTac

; 2288 : 	{
; 2289 : 		C_Window *win;
; 2290 : 
; 2291 : 		TheCampaign.EndgameResult=1;

	mov	BYTE PTR ?TheCampaign@@3VCampaignClass@@A+93, 1

; 2292 : 		SetTimeCompression(0);

	push	0
	call	?SetTimeCompression@@YAXH@Z		; SetTimeCompression
	add	esp, 4

; 2293 : 		if(gMainHandler->GetWindowFlags(CP_COUNTDOWN_WIN) & C_BIT_ENABLED)

	push	6015					; 0000177fH
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?GetWindowFlags@C_Handler@@QAEJJ@Z	; C_Handler::GetWindowFlags
	and	eax, 2048				; 00000800H
	je	SHORT $LN2@TriggerTac

; 2294 : 		{
; 2295 : 			win=gMainHandler->FindWindow(CP_COUNTDOWN_WIN);

	push	6015					; 0000177fH
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z ; C_Handler::FindWindowA
	mov	DWORD PTR _win$1[ebp], eax

; 2296 : 			if(win)

	cmp	DWORD PTR _win$1[ebp], 0
	je	SHORT $LN2@TriggerTac

; 2297 : 			{
; 2298 : 				CancelCampaignCompression();

	call	?CancelCampaignCompression@@YAXXZ	; CancelCampaignCompression

; 2299 : 				gMainHandler->HideWindow(win);

	mov	eax, DWORD PTR _win$1[ebp]
	push	eax
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?HideWindow@C_Handler@@QAEHPAVC_Window@@@Z ; C_Handler::HideWindow
$LN2@TriggerTac:

; 2300 : 			}
; 2301 : 		}
; 2302 : 
; 2303 : 		PostMessage(gMainHandler->GetAppWnd(),FM_OPEN_GAME_OVER_WIN,game_TacticalEngagement,0);

	push	0
	push	3
	push	1070					; 0000042eH
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?GetAppWnd@C_Handler@@QAEPAUHWND__@@XZ	; C_Handler::GetAppWnd
	push	eax
	call	DWORD PTR __imp__PostMessageA@16
$LN4@TriggerTac:

; 2304 : 	}
; 2305 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?TriggerTacEndGame@@YAXXZ ENDP				; TriggerTacEndGame
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\taceng\te_team_victory.cpp
_TEXT	SEGMENT
_eval$ = -16						; size = 4
_lbox$ = -12						; size = 4
_lbitem$ = -8						; size = 4
_win$ = -4						; size = 4
?EndGameEvaluation@@YAXXZ PROC				; EndGameEvaluation

; 2251 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 2252 : 	C_Window *win;
; 2253 : 	C_ListBox *lbox;
; 2254 : 	LISTBOX *lbitem;
; 2255 : 	long eval;
; 2256 : 
; 2257 : 	win=gMainHandler->FindWindow(TAC_END_WIN);

	push	40109					; 00009cadH
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z ; C_Handler::FindWindowA
	mov	DWORD PTR _win$[ebp], eax

; 2258 : 	{
; 2259 : 		UpdateVCScoring(TAC_END_WIN,0);

	push	0
	push	40109					; 00009cadH
	call	?UpdateVCScoring@@YAXJF@Z		; UpdateVCScoring
	add	esp, 8

; 2260 : 		lbox=(C_ListBox*)win->FindControl(TAC_WIN_TITLE);

	push	40108					; 00009cacH
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _lbox$[ebp], eax

; 2261 : 		if(lbox)

	cmp	DWORD PTR _lbox$[ebp], 0
	je	SHORT $LN2@EndGameEva

; 2262 : 		{
; 2263 : 			eval=EvaluateSituation();

	call	?EvaluateSituation@@YAJXZ		; EvaluateSituation
	mov	DWORD PTR _eval$[ebp], eax

; 2264 : 			lbox->SetValue(eval);

	mov	eax, DWORD PTR _eval$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?SetValue@C_ListBox@@QAEXJ@Z		; C_ListBox::SetValue

; 2265 : 			lbitem=lbox->FindID(eval);

	mov	ecx, DWORD PTR _eval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?FindID@C_ListBox@@QAEPAVLISTBOX@@J@Z	; C_ListBox::FindID
	mov	DWORD PTR _lbitem$[ebp], eax

; 2266 : 			if(lbitem && lbitem->Label_)

	cmp	DWORD PTR _lbitem$[ebp], 0
	je	SHORT $LN2@EndGameEva
	mov	edx, DWORD PTR _lbitem$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN2@EndGameEva

; 2267 : 			{
; 2268 : 				win->HideCluster(lbitem->Label_->GetUserNumber(1));

	push	1
	mov	eax, DWORD PTR _lbitem$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetUserNumber@C_Base@@QAEJJ@Z		; C_Base::GetUserNumber
	push	eax
	mov	ecx, DWORD PTR _win$[ebp]
	call	?HideCluster@C_Window@@QAEXJ@Z		; C_Window::HideCluster

; 2269 : 				win->HideCluster(lbitem->Label_->GetUserNumber(2));

	push	2
	mov	ecx, DWORD PTR _lbitem$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetUserNumber@C_Base@@QAEJJ@Z		; C_Base::GetUserNumber
	push	eax
	mov	ecx, DWORD PTR _win$[ebp]
	call	?HideCluster@C_Window@@QAEXJ@Z		; C_Window::HideCluster

; 2270 : 				win->UnHideCluster(lbitem->Label_->GetUserNumber(0));

	push	0
	mov	edx, DWORD PTR _lbitem$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetUserNumber@C_Base@@QAEJJ@Z		; C_Base::GetUserNumber
	push	eax
	mov	ecx, DWORD PTR _win$[ebp]
	call	?UnHideCluster@C_Window@@QAEXJ@Z	; C_Window::UnHideCluster
$LN2@EndGameEva:

; 2271 : 			}
; 2272 : 		}
; 2273 : 		win->RefreshWindow();

	mov	ecx, DWORD PTR _win$[ebp]
	call	?RefreshWindow@C_Window@@QAEXXZ		; C_Window::RefreshWindow

; 2274 : 		gMainHandler->ShowWindow(win);

	mov	eax, DWORD PTR _win$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?ShowWindow@C_Handler@@QAEHPAVC_Window@@@Z ; C_Handler::ShowWindow

; 2275 : 		gMainHandler->WindowToFront(win);

	mov	ecx, DWORD PTR _win$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?WindowToFront@C_Handler@@QAEXPAVC_Window@@@Z ; C_Handler::WindowToFront

; 2276 : 	}
; 2277 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?EndGameEvaluation@@YAXXZ ENDP				; EndGameEvaluation
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\taceng\te_team_victory.cpp
_TEXT	SEGMENT
_VictoryPoints$ = -64					; size = 4
_HighestPoints$ = -60					; size = 4
_myteam$ = -56						; size = 2
_teams$ = -52						; size = 2
_higuys$ = -48						; size = 2
_winners$ = -44						; size = 2
_i$ = -40						; size = 2
_TeamScores$ = -36					; size = 32
__$ArrayPad$ = -4					; size = 4
?EvaluateSituation@@YAJXZ PROC				; EvaluateSituation

; 2175 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2176 : 	short i,teams,winners,higuys,myteam;
; 2177 : 	long TeamScores[NUM_TEAMS];
; 2178 : 	long VictoryPoints,HighestPoints;
; 2179 : 
; 2180 : 	memset(TeamScores,0,sizeof(TeamScores));

	push	32					; 00000020H
	push	0
	lea	eax, DWORD PTR _TeamScores$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 2181 : 	teams=0;

	xor	ecx, ecx
	mov	WORD PTR _teams$[ebp], cx

; 2182 : 	for(i=0;i<NUM_TEAMS;i++)

	xor	edx, edx
	mov	WORD PTR _i$[ebp], dx
	jmp	SHORT $LN26@EvaluateSi
$LN25@EvaluateSi:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
$LN26@EvaluateSi:
	movsx	ecx, WORD PTR _i$[ebp]
	cmp	ecx, 8
	jge	SHORT $LN24@EvaluateSi

; 2183 : 	{
; 2184 : 		if(TeamInfo[i] && (TeamInfo[i]->flags & TEAM_ACTIVE))

	movsx	edx, WORD PTR _i$[ebp]
	cmp	DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4], 0
	je	SHORT $LN23@EvaluateSi
	movsx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	movsx	edx, WORD PTR [ecx+350]
	and	edx, 1
	je	SHORT $LN23@EvaluateSi

; 2185 : 		{
; 2186 : 			TeamScores[i]=GetCurrentVCScore(i);

	movsx	eax, WORD PTR _i$[ebp]
	push	eax
	call	?GetCurrentVCScore@@YAJJ@Z		; GetCurrentVCScore
	add	esp, 4
	movsx	ecx, WORD PTR _i$[ebp]
	mov	DWORD PTR _TeamScores$[ebp+ecx*4], eax

; 2187 : 			teams++;

	mov	dx, WORD PTR _teams$[ebp]
	add	dx, 1
	mov	WORD PTR _teams$[ebp], dx
$LN23@EvaluateSi:

; 2188 : 		}
; 2189 : 	}

	jmp	SHORT $LN25@EvaluateSi
$LN24@EvaluateSi:

; 2190 : 
; 2191 : 	winners=0;

	xor	eax, eax
	mov	WORD PTR _winners$[ebp], ax

; 2192 : 	HighestPoints=0;

	mov	DWORD PTR _HighestPoints$[ebp], 0

; 2193 : 	VictoryPoints=current_tactical_mission->get_points_required();

	mov	ecx, DWORD PTR ?current_tactical_mission@@3PAVtactical_mission@@A ; current_tactical_mission
	call	?get_points_required@tactical_mission@@QAEHXZ ; tactical_mission::get_points_required
	mov	DWORD PTR _VictoryPoints$[ebp], eax

; 2194 : 	for(i=0;i<NUM_TEAMS;i++)

	xor	ecx, ecx
	mov	WORD PTR _i$[ebp], cx
	jmp	SHORT $LN22@EvaluateSi
$LN21@EvaluateSi:
	mov	dx, WORD PTR _i$[ebp]
	add	dx, 1
	mov	WORD PTR _i$[ebp], dx
$LN22@EvaluateSi:
	movsx	eax, WORD PTR _i$[ebp]
	cmp	eax, 8
	jge	SHORT $LN20@EvaluateSi

; 2195 : 	{
; 2196 : 		if(TeamScores[i] >= VictoryPoints)

	movsx	ecx, WORD PTR _i$[ebp]
	mov	edx, DWORD PTR _TeamScores$[ebp+ecx*4]
	cmp	edx, DWORD PTR _VictoryPoints$[ebp]
	jl	SHORT $LN19@EvaluateSi

; 2197 : 			winners++;

	mov	ax, WORD PTR _winners$[ebp]
	add	ax, 1
	mov	WORD PTR _winners$[ebp], ax
$LN19@EvaluateSi:

; 2198 : 		if(TeamScores[i] > HighestPoints)

	movsx	ecx, WORD PTR _i$[ebp]
	mov	edx, DWORD PTR _TeamScores$[ebp+ecx*4]
	cmp	edx, DWORD PTR _HighestPoints$[ebp]
	jle	SHORT $LN18@EvaluateSi

; 2199 : 			HighestPoints=TeamScores[i];

	movsx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _TeamScores$[ebp+eax*4]
	mov	DWORD PTR _HighestPoints$[ebp], ecx
$LN18@EvaluateSi:

; 2200 : 	}

	jmp	SHORT $LN21@EvaluateSi
$LN20@EvaluateSi:

; 2201 : 
; 2202 : 	higuys=0;

	xor	edx, edx
	mov	WORD PTR _higuys$[ebp], dx

; 2203 : 	for(i=0;i<NUM_TEAMS;i++)

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax
	jmp	SHORT $LN17@EvaluateSi
$LN16@EvaluateSi:
	mov	cx, WORD PTR _i$[ebp]
	add	cx, 1
	mov	WORD PTR _i$[ebp], cx
$LN17@EvaluateSi:
	movsx	edx, WORD PTR _i$[ebp]
	cmp	edx, 8
	jge	SHORT $LN15@EvaluateSi

; 2204 : 	{
; 2205 : 		if(TeamScores[i] >= HighestPoints)

	movsx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _TeamScores$[ebp+eax*4]
	cmp	ecx, DWORD PTR _HighestPoints$[ebp]
	jl	SHORT $LN14@EvaluateSi

; 2206 : 			higuys++;

	mov	dx, WORD PTR _higuys$[ebp]
	add	dx, 1
	mov	WORD PTR _higuys$[ebp], dx
$LN14@EvaluateSi:

; 2207 : 	}

	jmp	SHORT $LN16@EvaluateSi
$LN15@EvaluateSi:

; 2208 : 
; 2209 : 	// Handle 1 team stuff
; 2210 : 	if(teams < 2)

	movsx	eax, WORD PTR _teams$[ebp]
	cmp	eax, 2
	jge	SHORT $LN13@EvaluateSi

; 2211 : 	{
; 2212 : 		if(winners)

	movsx	ecx, WORD PTR _winners$[ebp]
	test	ecx, ecx
	je	SHORT $LN12@EvaluateSi

; 2213 : 			return(TAC_SUCCESS);

	mov	eax, 40110				; 00009caeH
	jmp	$LN27@EvaluateSi

; 2214 : 		else

	jmp	SHORT $LN11@EvaluateSi
$LN12@EvaluateSi:

; 2215 : 			return(TAC_FAILURE);

	mov	eax, 40117				; 00009cb5H
	jmp	SHORT $LN27@EvaluateSi
$LN11@EvaluateSi:
	jmp	SHORT $LN10@EvaluateSi
$LN13@EvaluateSi:

; 2216 : 	}
; 2217 : 	else if(winners) // Handle Multiple team stuff

	movsx	edx, WORD PTR _winners$[ebp]
	test	edx, edx
	je	SHORT $LN10@EvaluateSi

; 2218 : 	{
; 2219 : 		myteam=FalconLocalSession->GetTeam();

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetTeam@FalconSessionEntity@@QAEEXZ	; FalconSessionEntity::GetTeam
	movzx	ax, al
	mov	WORD PTR _myteam$[ebp], ax

; 2220 : 		if(TeamScores[myteam] >= VictoryPoints) // We are among the winners

	movsx	ecx, WORD PTR _myteam$[ebp]
	mov	edx, DWORD PTR _TeamScores$[ebp+ecx*4]
	cmp	edx, DWORD PTR _VictoryPoints$[ebp]
	jl	SHORT $LN8@EvaluateSi

; 2221 : 		{
; 2222 : 			if(TeamScores[myteam] >= HighestPoints) // We are on top

	movsx	eax, WORD PTR _myteam$[ebp]
	mov	ecx, DWORD PTR _TeamScores$[ebp+eax*4]
	cmp	ecx, DWORD PTR _HighestPoints$[ebp]
	jl	SHORT $LN7@EvaluateSi

; 2223 : 			{
; 2224 : 				if(higuys > 1) // Draw... oh well

	movsx	edx, WORD PTR _higuys$[ebp]
	cmp	edx, 1
	jle	SHORT $LN6@EvaluateSi

; 2225 : 					return(TAC_DRAW);

	mov	eax, 40113				; 00009cb1H
	jmp	SHORT $LN27@EvaluateSi

; 2226 : 				else

	jmp	SHORT $LN5@EvaluateSi
$LN6@EvaluateSi:

; 2227 : 				{
; 2228 : 					if(winners > 1)

	movsx	eax, WORD PTR _winners$[ebp]
	cmp	eax, 1
	jle	SHORT $LN4@EvaluateSi

; 2229 : 						return(TAC_MARGINAL_WIN);

	mov	eax, 40112				; 00009cb0H
	jmp	SHORT $LN27@EvaluateSi

; 2230 : 					else

	jmp	SHORT $LN5@EvaluateSi
$LN4@EvaluateSi:

; 2231 : 						return(TAC_DECISIVE_WIN);

	mov	eax, 40111				; 00009cafH
	jmp	SHORT $LN27@EvaluateSi
$LN5@EvaluateSi:

; 2232 : 				}
; 2233 : 			}
; 2234 : 			else

	jmp	SHORT $LN2@EvaluateSi
$LN7@EvaluateSi:

; 2235 : 				return(TAC_DEFEAT);

	mov	eax, 40114				; 00009cb2H
	jmp	SHORT $LN27@EvaluateSi
$LN2@EvaluateSi:

; 2236 : 		}
; 2237 : 		else // We are a loser :)

	jmp	SHORT $LN10@EvaluateSi
$LN8@EvaluateSi:

; 2238 : 		{
; 2239 : 			return(TAC_MAJOR_DEFEAT);

	mov	eax, 40115				; 00009cb3H
	jmp	SHORT $LN27@EvaluateSi
$LN10@EvaluateSi:

; 2240 : 		}
; 2241 : 	}
; 2242 : 	return(TAC_STALEMATE);

	mov	eax, 40116				; 00009cb4H
$LN27@EvaluateSi:

; 2243 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?EvaluateSituation@@YAJXZ ENDP				; EvaluateSituation
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\taceng\te_team_victory.cpp
_TEXT	SEGMENT
_item$ = -8						; size = 4
_vc$ = -4						; size = 4
?add_all_vcs_to_ui@@YAXXZ PROC				; add_all_vcs_to_ui

; 2127 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2128 : 	TREELIST *item;
; 2129 : 	victory_condition *vc;
; 2130 : 
; 2131 : 	if(!gVCTree)

	cmp	DWORD PTR ?gVCTree@@3PAVC_TreeList@@A, 0 ; gVCTree
	jne	SHORT $LN6@add_all_vc

; 2132 : 		return;

	jmp	$LN7@add_all_vc
$LN6@add_all_vc:

; 2133 : 
; 2134 : 	gVCTree->DeleteBranch(gVCTree->GetRoot());

	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	call	?GetRoot@C_TreeList@@QAEPAVTREELIST@@XZ	; C_TreeList::GetRoot
	push	eax
	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	call	?DeleteBranch@C_TreeList@@QAEXPAVTREELIST@@@Z ; C_TreeList::DeleteBranch

; 2135 : 
; 2136 : 	if (gMapMgr)

	cmp	DWORD PTR ?gMapMgr@@3PAVC_Map@@A, 0	; gMapMgr
	je	$LN5@add_all_vc

; 2137 : 	{
; 2138 : 		vc = current_tactical_mission->get_first_unfiltered_victory_condition ();

	mov	ecx, DWORD PTR ?current_tactical_mission@@3PAVtactical_mission@@A ; current_tactical_mission
	call	?get_first_unfiltered_victory_condition@tactical_mission@@QAEPAVvictory_condition@@XZ ; tactical_mission::get_first_unfiltered_victory_condition
	mov	DWORD PTR _vc$[ebp], eax
$LN4@add_all_vc:

; 2139 : 		
; 2140 : 		while (vc)

	cmp	DWORD PTR _vc$[ebp], 0
	je	$LN5@add_all_vc

; 2141 : 		{
; 2142 : 			// Add VC Icons to Map
; 2143 : 
; 2144 : 			// Init VC control
; 2145 : 			vc->control=MakeVCControl(vc);

	mov	eax, DWORD PTR _vc$[ebp]
	push	eax
	call	?MakeVCControl@@YAPAVC_Victory@@PAVvictory_condition@@@Z ; MakeVCControl
	add	esp, 4
	mov	ecx, DWORD PTR _vc$[ebp]
	mov	DWORD PTR [ecx+52], eax

; 2146 : 
; 2147 : 			// Add VC control to VC tree
; 2148 : 			item=gVCTree->CreateItem(vc->get_number(),C_TYPE_ITEM,vc->control);

	mov	edx, DWORD PTR _vc$[ebp]
	mov	eax, DWORD PTR [edx+52]
	push	eax
	push	50					; 00000032H
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_number@victory_condition@@QAEHXZ	; victory_condition::get_number
	push	eax
	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	call	?CreateItem@C_TreeList@@QAEPAVTREELIST@@JJPAVC_Base@@@Z ; C_TreeList::CreateItem
	mov	DWORD PTR _item$[ebp], eax

; 2149 : 			if(item)

	cmp	DWORD PTR _item$[ebp], 0
	je	$LN2@add_all_vc

; 2150 : 			{
; 2151 : 				gVCTree->AddItem(gVCTree->GetRoot(),item);

	mov	ecx, DWORD PTR _item$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	call	?GetRoot@C_TreeList@@QAEPAVTREELIST@@XZ	; C_TreeList::GetRoot
	push	eax
	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	call	?AddItem@C_TreeList@@QAEHPAVTREELIST@@0@Z ; C_TreeList::AddItem

; 2152 : 				((C_Victory*)vc->control)->SetOwner(item);

	mov	edx, DWORD PTR _item$[ebp]
	push	edx
	mov	eax, DWORD PTR _vc$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	call	?SetOwner@C_Victory@@QAEXPAVTREELIST@@@Z ; C_Victory::SetOwner

; 2153 : 				vc->control->SetReady(1);

	push	1
	mov	ecx, DWORD PTR _vc$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?SetReady@C_Base@@QAEXF@Z		; C_Base::SetReady

; 2154 : 				vc->control->SetClient(gVCTree->GetClient());

	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	call	?GetClient@C_Base@@QAEFXZ		; C_Base::GetClient
	movzx	edx, ax
	push	edx
	mov	eax, DWORD PTR _vc$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	call	?SetClient@C_Base@@QAEXF@Z		; C_Base::SetClient

; 2155 : 				vc->control->SetParent(gVCTree->Parent_);

	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	mov	edx, DWORD PTR [ecx+48]
	push	edx
	mov	eax, DWORD PTR _vc$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	call	?SetParent@C_Base@@QAEXPAVC_Window@@@Z	; C_Base::SetParent

; 2156 : 				vc->control->SetSubParents(gVCTree->Parent_);

	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	mov	edx, DWORD PTR [ecx+48]
	push	edx
	mov	eax, DWORD PTR _vc$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	edx, DWORD PTR _vc$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+52]
	mov	edx, DWORD PTR [eax+172]
	call	edx
$LN2@add_all_vc:

; 2157 : 			}
; 2158 : 			gMapMgr->AddVC (vc);

	mov	eax, DWORD PTR _vc$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?gMapMgr@@3PAVC_Map@@A	; gMapMgr
	call	?AddVC@C_Map@@QAEPAVMAPICONLIST@@PAVvictory_condition@@@Z ; C_Map::AddVC

; 2159 : 			UpdateVCOptions(vc);

	mov	ecx, DWORD PTR _vc$[ebp]
	push	ecx
	call	?UpdateVCOptions@@YAXPAVvictory_condition@@@Z ; UpdateVCOptions
	add	esp, 4

; 2160 : 
; 2161 : 			vc = current_tactical_mission->get_next_unfiltered_victory_condition ();

	mov	ecx, DWORD PTR ?current_tactical_mission@@3PAVtactical_mission@@A ; current_tactical_mission
	call	?get_next_unfiltered_victory_condition@tactical_mission@@QAEPAVvictory_condition@@XZ ; tactical_mission::get_next_unfiltered_victory_condition
	mov	DWORD PTR _vc$[ebp], eax

; 2162 : 		}

	jmp	$LN4@add_all_vc
$LN5@add_all_vc:

; 2163 : 	}
; 2164 : 	gVCTree->RecalcSize();

	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	call	?RecalcSize@C_TreeList@@QAEXXZ		; C_TreeList::RecalcSize

; 2165 : 	if(gVCTree->Parent_)

	mov	edx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	cmp	DWORD PTR [edx+48], 0
	je	SHORT $LN7@add_all_vc

; 2166 : 		gVCTree->Parent_->RefreshClient(gVCTree->GetClient());

	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	call	?GetClient@C_Base@@QAEFXZ		; C_Base::GetClient
	cwde
	push	eax
	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	mov	ecx, DWORD PTR [ecx+48]
	call	?RefreshClient@C_Window@@QAEXJ@Z	; C_Window::RefreshClient
$LN7@add_all_vc:

; 2167 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?add_all_vcs_to_ui@@YAXXZ ENDP				; add_all_vcs_to_ui
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\taceng\te_team_victory.cpp
_TEXT	SEGMENT
_num$ = -8						; size = 4
_loop$ = -4						; size = 4
?get_tactical_number_of_teams@@YAHXZ PROC		; get_tactical_number_of_teams

; 2056 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2057 : 	int
; 2058 : 		num,
; 2059 : 		loop;
; 2060 : 
; 2061 : 	num = 0;

	mov	DWORD PTR _num$[ebp], 0

; 2062 : 
; 2063 : 	for (loop = 1; loop < 8; loop ++)

	mov	DWORD PTR _loop$[ebp], 1
	jmp	SHORT $LN4@get_tactic
$LN3@get_tactic:
	mov	eax, DWORD PTR _loop$[ebp]
	add	eax, 1
	mov	DWORD PTR _loop$[ebp], eax
$LN4@get_tactic:
	cmp	DWORD PTR _loop$[ebp], 8
	jge	SHORT $LN2@get_tactic

; 2064 : 	{
; 2065 : 		if (TeamInfo[loop])

	mov	ecx, DWORD PTR _loop$[ebp]
	cmp	DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4], 0
	je	SHORT $LN1@get_tactic

; 2066 : 		{
; 2067 : 			num ++;

	mov	edx, DWORD PTR _num$[ebp]
	add	edx, 1
	mov	DWORD PTR _num$[ebp], edx
$LN1@get_tactic:

; 2068 : 		}
; 2069 : 	}

	jmp	SHORT $LN3@get_tactic
$LN2@get_tactic:

; 2070 : 
; 2071 : 	return num;

	mov	eax, DWORD PTR _num$[ebp]

; 2072 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?get_tactical_number_of_teams@@YAHXZ ENDP		; get_tactical_number_of_teams
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\taceng\te_team_victory.cpp
_TEXT	SEGMENT
$T2 = -36						; size = 4
tv139 = -32						; size = 4
$T3 = -28						; size = 4
_item$ = -24						; size = 4
_ent$ = -20						; size = 4
_vc$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_id$ = 8						; size = 8
___formal$ = 16						; size = 4
?tactical_add_victory_condition@@YAXVVU_ID@@PAVC_Base@@@Z PROC ; tactical_add_victory_condition

; 1991 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?tactical_add_victory_condition@@YAXVVU_ID@@PAVC_Base@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1992 : 	CampEntity ent;
; 1993 : 	victory_condition *vc;
; 1994 : 	TREELIST *item;
; 1995 : 
; 1996 : 	ent=(CampEntity)vuDatabase->Find(id);

	mov	eax, DWORD PTR _id$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _id$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _ent$[ebp], eax

; 1997 : 	if(!ent)

	cmp	DWORD PTR _ent$[ebp], 0
	jne	SHORT $LN11@tactical_a

; 1998 : 		return;

	jmp	$LN12@tactical_a
$LN11@tactical_a:

; 1999 : 
; 2000 : 	if(ent->IsObjective() || ent->IsFlight() || ent->IsBattalion())

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax+236]
	call	edx
	test	eax, eax
	jne	SHORT $LN9@tactical_a
	mov	eax, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax
	test	eax, eax
	jne	SHORT $LN9@tactical_a
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+240]
	call	eax
	test	eax, eax
	je	$LN12@tactical_a
$LN9@tactical_a:

; 2001 : 	{
; 2002 : 		vc = new victory_condition (current_tactical_mission);

	push	56					; 00000038H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN14@tactical_a
	mov	ecx, DWORD PTR ?current_tactical_mission@@3PAVtactical_mission@@A ; current_tactical_mission
	push	ecx
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0victory_condition@@QAE@PAVtactical_mission@@@Z ; victory_condition::victory_condition
	mov	DWORD PTR tv139[ebp], eax
	jmp	SHORT $LN15@tactical_a
$LN14@tactical_a:
	mov	DWORD PTR tv139[ebp], 0
$LN15@tactical_a:
	mov	edx, DWORD PTR tv139[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _vc$[ebp], eax

; 2003 : 	
; 2004 : 		vc->set_team (gSelectedTeam);

	movzx	ecx, BYTE PTR ?gSelectedTeam@@3EA	; gSelectedTeam
	push	ecx
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?set_team@victory_condition@@QAEXH@Z	; victory_condition::set_team

; 2005 : 		vc->set_vu_id (id);

	mov	edx, DWORD PTR _id$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?set_vu_id@victory_condition@@QAEXVVU_ID@@@Z ; victory_condition::set_vu_id

; 2006 : 		if(ent->IsObjective())

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+236]
	call	eax
	test	eax, eax
	je	SHORT $LN8@tactical_a

; 2007 : 		{
; 2008 : 			vc->set_type (vt_degrade);

	push	5
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?set_type@victory_condition@@QAEXW4victory_type@@@Z ; victory_condition::set_type

; 2009 : 			vc->set_tolerance(10); // default to 100%

	push	10					; 0000000aH
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?set_tolerance@victory_condition@@QAEXH@Z ; victory_condition::set_tolerance
	jmp	SHORT $LN7@tactical_a
$LN8@tactical_a:

; 2010 : 		}
; 2011 : 		else if(ent->IsFlight())

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax
	test	eax, eax
	je	SHORT $LN6@tactical_a

; 2012 : 		{
; 2013 : 			vc->set_type (vt_intercept);

	push	4
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?set_type@victory_condition@@QAEXW4victory_type@@@Z ; victory_condition::set_type

; 2014 : 			vc->set_tolerance(((Flight)ent)->GetTotalVehicles()); // default to ALL

	mov	ecx, DWORD PTR _ent$[ebp]
	call	?GetTotalVehicles@UnitClass@@QAEHXZ	; UnitClass::GetTotalVehicles
	push	eax
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?set_tolerance@victory_condition@@QAEXH@Z ; victory_condition::set_tolerance

; 2015 : 		}
; 2016 : 		else

	jmp	SHORT $LN7@tactical_a
$LN6@tactical_a:

; 2017 : 		{
; 2018 : 			vc->set_type (vt_attrit);

	push	3
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?set_type@victory_condition@@QAEXW4victory_type@@@Z ; victory_condition::set_type

; 2019 : 			vc->set_tolerance(10); // default to 100%

	push	10					; 0000000aH
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?set_tolerance@victory_condition@@QAEXH@Z ; victory_condition::set_tolerance
$LN7@tactical_a:

; 2020 : 		}
; 2021 : 		vc->set_sub_objective(-1); // NO individual target assigned

	push	-1
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?set_sub_objective@victory_condition@@QAEXH@Z ; victory_condition::set_sub_objective

; 2022 : 
; 2023 : 		if(gVCTree)

	cmp	DWORD PTR ?gVCTree@@3PAVC_TreeList@@A, 0 ; gVCTree
	je	$LN4@tactical_a

; 2024 : 		{
; 2025 : 			vc->control=MakeVCControl(vc);

	mov	ecx, DWORD PTR _vc$[ebp]
	push	ecx
	call	?MakeVCControl@@YAPAVC_Victory@@PAVvictory_condition@@@Z ; MakeVCControl
	add	esp, 4
	mov	edx, DWORD PTR _vc$[ebp]
	mov	DWORD PTR [edx+52], eax

; 2026 : 
; 2027 : 			// Add VC control to VC tree
; 2028 : 			item=gVCTree->CreateItem(vc->get_number(),C_TYPE_ITEM,vc->control);

	mov	eax, DWORD PTR _vc$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	push	50					; 00000032H
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_number@victory_condition@@QAEHXZ	; victory_condition::get_number
	push	eax
	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	call	?CreateItem@C_TreeList@@QAEPAVTREELIST@@JJPAVC_Base@@@Z ; C_TreeList::CreateItem
	mov	DWORD PTR _item$[ebp], eax

; 2029 : 			if(item)

	cmp	DWORD PTR _item$[ebp], 0
	je	$LN4@tactical_a

; 2030 : 			{
; 2031 : 				gVCTree->AddItem(gVCTree->GetRoot(),item);

	mov	edx, DWORD PTR _item$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	call	?GetRoot@C_TreeList@@QAEPAVTREELIST@@XZ	; C_TreeList::GetRoot
	push	eax
	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	call	?AddItem@C_TreeList@@QAEHPAVTREELIST@@0@Z ; C_TreeList::AddItem

; 2032 : 				((C_Victory*)vc->control)->SetOwner(item);

	mov	eax, DWORD PTR _item$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vc$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?SetOwner@C_Victory@@QAEXPAVTREELIST@@@Z ; C_Victory::SetOwner

; 2033 : 				vc->control->SetReady(1);

	push	1
	mov	edx, DWORD PTR _vc$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	call	?SetReady@C_Base@@QAEXF@Z		; C_Base::SetReady

; 2034 : 				vc->control->SetClient(gVCTree->GetClient());

	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	call	?GetClient@C_Base@@QAEFXZ		; C_Base::GetClient
	movzx	eax, ax
	push	eax
	mov	ecx, DWORD PTR _vc$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?SetClient@C_Base@@QAEXF@Z		; C_Base::SetClient

; 2035 : 				vc->control->SetParent(gVCTree->Parent_);

	mov	edx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	mov	eax, DWORD PTR [edx+48]
	push	eax
	mov	ecx, DWORD PTR _vc$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?SetParent@C_Base@@QAEXPAVC_Window@@@Z	; C_Base::SetParent

; 2036 : 				vc->control->SetSubParents(gVCTree->Parent_);

	mov	edx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	mov	eax, DWORD PTR [edx+48]
	push	eax
	mov	ecx, DWORD PTR _vc$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	eax, DWORD PTR _vc$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+52]
	mov	eax, DWORD PTR [edx+172]
	call	eax

; 2037 : 				gVCTree->RecalcSize();

	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	call	?RecalcSize@C_TreeList@@QAEXXZ		; C_TreeList::RecalcSize

; 2038 : 				if(gVCTree->Parent_)

	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	cmp	DWORD PTR [ecx+48], 0
	je	SHORT $LN4@tactical_a

; 2039 : 					gVCTree->Parent_->RefreshClient(gVCTree->GetClient());

	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	call	?GetClient@C_Base@@QAEFXZ		; C_Base::GetClient
	movsx	edx, ax
	push	edx
	mov	eax, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	mov	ecx, DWORD PTR [eax+48]
	call	?RefreshClient@C_Window@@QAEXJ@Z	; C_Window::RefreshClient
$LN4@tactical_a:

; 2040 : 			}
; 2041 : 		}
; 2042 : 		if (gMapMgr)

	cmp	DWORD PTR ?gMapMgr@@3PAVC_Map@@A, 0	; gMapMgr
	je	SHORT $LN1@tactical_a

; 2043 : 		{
; 2044 : 			gMapMgr->AddVC (vc);

	mov	ecx, DWORD PTR _vc$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?gMapMgr@@3PAVC_Map@@A	; gMapMgr
	call	?AddVC@C_Map@@QAEPAVMAPICONLIST@@PAVvictory_condition@@@Z ; C_Map::AddVC
$LN1@tactical_a:

; 2045 : 		}
; 2046 : 		UpdateVCOptions(vc);

	mov	edx, DWORD PTR _vc$[ebp]
	push	edx
	call	?UpdateVCOptions@@YAXPAVvictory_condition@@@Z ; UpdateVCOptions
	add	esp, 4

; 2047 : 		update_team_victory_window ();

	call	?update_team_victory_window@@YAXXZ	; update_team_victory_window
$LN12@tactical_a:

; 2048 : 	}
; 2049 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?tactical_add_victory_condition@@YAXVVU_ID@@PAVC_Base@@@Z$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?tactical_add_victory_condition@@YAXVVU_ID@@PAVC_Base@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?tactical_add_victory_condition@@YAXVVU_ID@@PAVC_Base@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?tactical_add_victory_condition@@YAXVVU_ID@@PAVC_Base@@@Z ENDP ; tactical_add_victory_condition
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\taceng\te_team_victory.cpp
_TEXT	SEGMENT
_vcf$ = -4						; size = 4
?evaluate_filter@@YAXXZ PROC				; evaluate_filter

; 1473 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1474 : 	victory_condition_filter
; 1475 : 		vcf;
; 1476 : #if 0
; 1477 : 	if (show_team_button->GetState ())
; 1478 : 	{
; 1479 : 		if (show_achieved_button->GetState ())
; 1480 : 		{
; 1481 : 			vcf = vcf_team_achieved;
; 1482 : 		}
; 1483 : 		else if (show_remaining_button->GetState ())
; 1484 : 		{
; 1485 : 			vcf = vcf_team_remaining;
; 1486 : 		}
; 1487 : 		else
; 1488 : 		{
; 1489 : 			vcf = vcf_team;
; 1490 : 		}
; 1491 : 	}
; 1492 : 	else
; 1493 : 	{
; 1494 : 		if (show_achieved_button->GetState ())
; 1495 : 		{
; 1496 : 			vcf = vcf_all_achieved;
; 1497 : 		}
; 1498 : 		else if (show_remaining_button->GetState ())
; 1499 : 		{
; 1500 : 			vcf = vcf_all_remaining;
; 1501 : 		}
; 1502 : 		else
; 1503 : 		{
; 1504 : 			vcf = vcf_all;
; 1505 : 		}
; 1506 : 	}
; 1507 : #endif
; 1508 : 	vcf = vcf_all;

	mov	DWORD PTR _vcf$[ebp], 1

; 1509 : 
; 1510 : 	if (current_tactical_mission)

	cmp	DWORD PTR ?current_tactical_mission@@3PAVtactical_mission@@A, 0 ; current_tactical_mission
	je	SHORT $LN2@evaluate_f

; 1511 : 	{
; 1512 : 		current_tactical_mission->set_victory_condition_filter (vcf);

	mov	eax, DWORD PTR _vcf$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?current_tactical_mission@@3PAVtactical_mission@@A ; current_tactical_mission
	call	?set_victory_condition_filter@tactical_mission@@QAEXW4victory_condition_filter@@@Z ; tactical_mission::set_victory_condition_filter

; 1513 : 		current_tactical_mission->set_victory_condition_team_filter (1);

	push	1
	mov	ecx, DWORD PTR ?current_tactical_mission@@3PAVtactical_mission@@A ; current_tactical_mission
	call	?set_victory_condition_team_filter@tactical_mission@@QAEXH@Z ; tactical_mission::set_victory_condition_team_filter
$LN2@evaluate_f:

; 1514 : 	}
; 1515 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?evaluate_filter@@YAXXZ ENDP				; evaluate_filter
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\taceng\te_team_victory.cpp
_TEXT	SEGMENT
_tmp$ = -100						; size = 4
_bmp$ = -96						; size = 4
_box$ = -92						; size = 4
_line$ = -88						; size = 4
_win$ = -84						; size = 4
_j$ = -80						; size = 4
_ebox$ = -76						; size = 4
_i$ = -72						; size = 4
_points$ = -68						; size = 32
_sortindex$ = -36					; size = 32
__$ArrayPad$ = -4					; size = 4
_WinID$ = 8						; size = 4
_mode$ = 12						; size = 2
?UpdateVCScoring@@YAXJF@Z PROC				; UpdateVCScoring

; 1356 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1357 : 	long sortindex[NUM_TEAMS],points[NUM_TEAMS];
; 1358 : 	long i,j,line,tmp;
; 1359 : 	C_Window *win;
; 1360 : 	C_EditBox *ebox;
; 1361 : 	C_Bitmap *bmp;
; 1362 : 	C_Box *box;
; 1363 : 
; 1364 : 	memset(sortindex,0,sizeof(sortindex));

	push	32					; 00000020H
	push	0
	lea	eax, DWORD PTR _sortindex$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1365 : 	memset(points,0,sizeof(points));

	push	32					; 00000020H
	push	0
	lea	ecx, DWORD PTR _points$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 1366 : 
; 1367 : 	line=0;

	mov	DWORD PTR _line$[ebp], 0

; 1368 : 	for(i=0;i<NUM_TEAMS;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN26@UpdateVCSc
$LN25@UpdateVCSc:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN26@UpdateVCSc:
	cmp	DWORD PTR _i$[ebp], 8
	jge	SHORT $LN24@UpdateVCSc

; 1369 : 	{
; 1370 : 		if(TeamInfo[i] && (TeamInfo[i]->flags & TEAM_ACTIVE))

	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4], 0
	je	SHORT $LN23@UpdateVCSc
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	movsx	eax, WORD PTR [edx+350]
	and	eax, 1
	je	SHORT $LN23@UpdateVCSc

; 1371 : 		{
; 1372 : 			sortindex[line]=i;

	mov	ecx, DWORD PTR _line$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _sortindex$[ebp+ecx*4], edx

; 1373 : 			if(!mode) // Show current score for this team

	movsx	eax, WORD PTR _mode$[ebp]
	test	eax, eax
	jne	SHORT $LN22@UpdateVCSc

; 1374 : 			{
; 1375 : 				points[line]=GetCurrentVCScore(i);

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	call	?GetCurrentVCScore@@YAJJ@Z		; GetCurrentVCScore
	add	esp, 4
	mov	edx, DWORD PTR _line$[ebp]
	mov	DWORD PTR _points$[ebp+edx*4], eax

; 1376 : 			}
; 1377 : 			else // Show possible score for this team

	jmp	SHORT $LN21@UpdateVCSc
$LN22@UpdateVCSc:

; 1378 : 			{
; 1379 : 				points[line]=GetPossibleVCScore(i);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	call	?GetPossibleVCScore@@YAJJ@Z		; GetPossibleVCScore
	add	esp, 4
	mov	ecx, DWORD PTR _line$[ebp]
	mov	DWORD PTR _points$[ebp+ecx*4], eax
$LN21@UpdateVCSc:

; 1380 : 			}
; 1381 : 			line++;

	mov	edx, DWORD PTR _line$[ebp]
	add	edx, 1
	mov	DWORD PTR _line$[ebp], edx
$LN23@UpdateVCSc:

; 1382 : 		}
; 1383 : 	}

	jmp	SHORT $LN25@UpdateVCSc
$LN24@UpdateVCSc:

; 1384 : 	if(!mode)

	movsx	eax, WORD PTR _mode$[ebp]
	test	eax, eax
	jne	$LN20@UpdateVCSc

; 1385 : 	{
; 1386 : 		for(i=1;i<line;i++)

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN19@UpdateVCSc
$LN18@UpdateVCSc:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN19@UpdateVCSc:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _line$[ebp]
	jge	SHORT $LN20@UpdateVCSc

; 1387 : 		{
; 1388 : 			for(j=0;j<i;j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN16@UpdateVCSc
$LN15@UpdateVCSc:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN16@UpdateVCSc:
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR _i$[ebp]
	jge	SHORT $LN14@UpdateVCSc

; 1389 : 			{
; 1390 : 				if(points[sortindex[j]] > points[sortindex[i]])

	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _sortindex$[ebp+edx*4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _sortindex$[ebp+ecx*4]
	mov	eax, DWORD PTR _points$[ebp+eax*4]
	cmp	eax, DWORD PTR _points$[ebp+edx*4]
	jle	SHORT $LN13@UpdateVCSc

; 1391 : 				{
; 1392 : 					tmp=sortindex[i];

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _sortindex$[ebp+ecx*4]
	mov	DWORD PTR _tmp$[ebp], edx

; 1393 : 					sortindex[i]=sortindex[j];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _sortindex$[ebp+ecx*4]
	mov	DWORD PTR _sortindex$[ebp+eax*4], edx

; 1394 : 					sortindex[j]=tmp;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _tmp$[ebp]
	mov	DWORD PTR _sortindex$[ebp+eax*4], ecx

; 1395 : 					tmp=points[i];

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _points$[ebp+edx*4]
	mov	DWORD PTR _tmp$[ebp], eax

; 1396 : 					points[i]=points[j];

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _points$[ebp+edx*4]
	mov	DWORD PTR _points$[ebp+ecx*4], eax

; 1397 : 					points[j]=tmp;

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _tmp$[ebp]
	mov	DWORD PTR _points$[ebp+ecx*4], edx
$LN13@UpdateVCSc:

; 1398 : 				}
; 1399 : 			}

	jmp	SHORT $LN15@UpdateVCSc
$LN14@UpdateVCSc:

; 1400 : 		}

	jmp	$LN18@UpdateVCSc
$LN20@UpdateVCSc:

; 1401 : 	}
; 1402 : 
; 1403 : 	win=gMainHandler->FindWindow (WinID);

	mov	eax, DWORD PTR _WinID$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z ; C_Handler::FindWindowA
	mov	DWORD PTR _win$[ebp], eax

; 1404 : 	if(win)

	cmp	DWORD PTR _win$[ebp], 0
	je	$LN27@UpdateVCSc

; 1405 : 	{
; 1406 : 		ebox=(C_EditBox*)win->FindControl(PTS_REQ_VICTORY);

	push	30746					; 0000781aH
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ebox$[ebp], eax

; 1407 : 		if(ebox)

	cmp	DWORD PTR _ebox$[ebp], 0
	je	SHORT $LN11@UpdateVCSc

; 1408 : 		{
; 1409 : 			ebox->SetInteger(current_tactical_mission->get_points_required());

	mov	ecx, DWORD PTR ?current_tactical_mission@@3PAVtactical_mission@@A ; current_tactical_mission
	call	?get_points_required@tactical_mission@@QAEHXZ ; tactical_mission::get_points_required
	push	eax
	mov	ecx, DWORD PTR _ebox$[ebp]
	call	?SetInteger@C_EditBox@@QAEXJ@Z		; C_EditBox::SetInteger

; 1410 : 			ebox->Refresh();

	mov	ecx, DWORD PTR _ebox$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ebox$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN11@UpdateVCSc:

; 1411 : 		}
; 1412 : 		for(i=0;i<line;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN10@UpdateVCSc
$LN9@UpdateVCSc:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN10@UpdateVCSc:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _line$[ebp]
	jge	$LN2@UpdateVCSc

; 1413 : 		{
; 1414 : 			if(TeamInfo[sortindex[i]])

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _sortindex$[ebp+eax*4]
	cmp	DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4], 0
	je	$LN7@UpdateVCSc

; 1415 : 			{
; 1416 : 				box=(C_Box*)win->FindControl(VCFlagIDs[i][0]);

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR ?VCFlagIDs@@3PAY03JA[edx+eax]
	push	ecx
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _box$[ebp], eax

; 1417 : 				if(box)

	cmp	DWORD PTR _box$[ebp], 0
	je	SHORT $LN6@UpdateVCSc

; 1418 : 				{
; 1419 : 					box->SetColor(TeamColorList[TeamInfo[sortindex[i]]->GetColor()]);

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _sortindex$[ebp+edx*4]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	call	?GetColor@TeamClass@@QAEHXZ		; TeamClass::GetColor
	mov	ecx, DWORD PTR ?TeamColorList@@3PAKA[eax*4]
	push	ecx
	mov	ecx, DWORD PTR _box$[ebp]
	call	?SetColor@C_Box@@QAEXK@Z		; C_Box::SetColor

; 1420 : 					box->Refresh();

	mov	edx, DWORD PTR _box$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _box$[ebp]
	mov	edx, DWORD PTR [eax+160]
	call	edx
$LN6@UpdateVCSc:

; 1421 : 				}
; 1422 : 				bmp=(C_Bitmap*)win->FindControl(VCFlagIDs[i][1]);

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR ?VCFlagIDs@@3PAY03JA[eax+ecx]
	push	edx
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _bmp$[ebp], eax

; 1423 : 				if(bmp)

	cmp	DWORD PTR _bmp$[ebp], 0
	je	SHORT $LN5@UpdateVCSc

; 1424 : 				{
; 1425 : 					bmp->SetImage(FlagImageID[TeamInfo[sortindex[i]]->GetFlag()][BIG_HORIZ]);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _sortindex$[ebp+eax*4]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?GetFlag@TeamClass@@QAEHXZ		; TeamClass::GetFlag
	imul	eax, 20					; 00000014H
	mov	edx, 4
	imul	edx, 3
	mov	eax, DWORD PTR ?FlagImageID@@3PAY04JA[eax+edx]
	push	eax
	mov	ecx, DWORD PTR _bmp$[ebp]
	call	?SetImage@C_Bitmap@@QAEXJ@Z		; C_Bitmap::SetImage

; 1426 : 					bmp->Refresh();

	mov	ecx, DWORD PTR _bmp$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _bmp$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN5@UpdateVCSc:

; 1427 : 				}
; 1428 : 				ebox=(C_EditBox*)win->FindControl(VCFlagIDs[i][2]);

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR ?VCFlagIDs@@3PAY03JA[ecx+edx]
	push	eax
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ebox$[ebp], eax

; 1429 : 				if(ebox)

	cmp	DWORD PTR _ebox$[ebp], 0
	je	SHORT $LN4@UpdateVCSc

; 1430 : 				{
; 1431 : 					ebox->SetText(TeamInfo[sortindex[i]]->GetName());

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _sortindex$[ebp+ecx*4]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	call	?GetName@TeamClass@@QAEPADXZ		; TeamClass::GetName
	push	eax
	mov	ecx, DWORD PTR _ebox$[ebp]
	call	?SetText@C_EditBox@@QAEXPAD@Z		; C_EditBox::SetText

; 1432 : 					ebox->Refresh();

	mov	eax, DWORD PTR _ebox$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _ebox$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN4@UpdateVCSc:

; 1433 : 				}
; 1434 : 				ebox=(C_EditBox*)win->FindControl(VCFlagIDs[i][3]);

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, 4
	imul	edx, 3
	mov	eax, DWORD PTR ?VCFlagIDs@@3PAY03JA[ecx+edx]
	push	eax
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ebox$[ebp], eax

; 1435 : 				if(ebox)

	cmp	DWORD PTR _ebox$[ebp], 0
	je	SHORT $LN3@UpdateVCSc

; 1436 : 				{
; 1437 : 					ebox->SetInteger(points[i]);

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _points$[ebp+ecx*4]
	push	edx
	mov	ecx, DWORD PTR _ebox$[ebp]
	call	?SetInteger@C_EditBox@@QAEXJ@Z		; C_EditBox::SetInteger

; 1438 : 					ebox->Refresh();

	mov	eax, DWORD PTR _ebox$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _ebox$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN3@UpdateVCSc:

; 1439 : 				}
; 1440 : 
; 1441 : 				win->UnHideCluster (i+1);

	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _win$[ebp]
	call	?UnHideCluster@C_Window@@QAEXJ@Z	; C_Window::UnHideCluster
$LN7@UpdateVCSc:

; 1442 : 			}
; 1443 : 		}

	jmp	$LN9@UpdateVCSc
$LN2@UpdateVCSc:

; 1444 : 		while (i <= NUM_TEAMS)

	cmp	DWORD PTR _i$[ebp], 8
	jg	SHORT $LN27@UpdateVCSc

; 1445 : 		{
; 1446 : 			win->HideCluster (i+1);

	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	push	edx
	mov	ecx, DWORD PTR _win$[ebp]
	call	?HideCluster@C_Window@@QAEXJ@Z		; C_Window::HideCluster

; 1447 : 
; 1448 : 			i ++;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax

; 1449 : 		}

	jmp	SHORT $LN2@UpdateVCSc
$LN27@UpdateVCSc:

; 1450 : 	}
; 1451 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateVCScoring@@YAXJF@Z ENDP				; UpdateVCScoring
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\taceng\te_team_victory.cpp
_TEXT	SEGMENT
_value$ = -8						; size = 4
_vc$ = -4						; size = 4
_teamno$ = 8						; size = 4
?GetPossibleVCScore@@YAJJ@Z PROC			; GetPossibleVCScore

; 1340 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1341 : 	victory_condition *vc;
; 1342 : 	long value;
; 1343 : 
; 1344 : 	value=0;

	mov	DWORD PTR _value$[ebp], 0

; 1345 : 	vc=current_tactical_mission->get_first_unfiltered_victory_condition();

	mov	ecx, DWORD PTR ?current_tactical_mission@@3PAVtactical_mission@@A ; current_tactical_mission
	call	?get_first_unfiltered_victory_condition@tactical_mission@@QAEPAVvictory_condition@@XZ ; tactical_mission::get_first_unfiltered_victory_condition
	mov	DWORD PTR _vc$[ebp], eax
$LN3@GetPossibl:

; 1346 : 	while(vc)

	cmp	DWORD PTR _vc$[ebp], 0
	je	SHORT $LN2@GetPossibl

; 1347 : 	{
; 1348 : 		if(vc->get_team() == teamno && vc->get_points() > 0)

	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_team@victory_condition@@QAEHXZ	; victory_condition::get_team
	cmp	eax, DWORD PTR _teamno$[ebp]
	jne	SHORT $LN1@GetPossibl
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_points@victory_condition@@QAEHXZ	; victory_condition::get_points
	test	eax, eax
	jle	SHORT $LN1@GetPossibl

; 1349 : 			value+=vc->get_points();

	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_points@victory_condition@@QAEHXZ	; victory_condition::get_points
	add	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], eax
$LN1@GetPossibl:

; 1350 : 		vc=current_tactical_mission->get_next_unfiltered_victory_condition();

	mov	ecx, DWORD PTR ?current_tactical_mission@@3PAVtactical_mission@@A ; current_tactical_mission
	call	?get_next_unfiltered_victory_condition@tactical_mission@@QAEPAVvictory_condition@@XZ ; tactical_mission::get_next_unfiltered_victory_condition
	mov	DWORD PTR _vc$[ebp], eax

; 1351 : 	}

	jmp	SHORT $LN3@GetPossibl
$LN2@GetPossibl:

; 1352 : 	return(value);

	mov	eax, DWORD PTR _value$[ebp]

; 1353 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetPossibleVCScore@@YAJJ@Z ENDP			; GetPossibleVCScore
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\taceng\te_team_victory.cpp
_TEXT	SEGMENT
_value$ = -8						; size = 4
_vc$ = -4						; size = 4
_teamno$ = 8						; size = 4
?GetCurrentVCScore@@YAJJ@Z PROC				; GetCurrentVCScore

; 1324 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1325 : 	victory_condition *vc;
; 1326 : 	long value;
; 1327 : 
; 1328 : 	value=0;

	mov	DWORD PTR _value$[ebp], 0

; 1329 : 	vc=current_tactical_mission->get_first_unfiltered_victory_condition();

	mov	ecx, DWORD PTR ?current_tactical_mission@@3PAVtactical_mission@@A ; current_tactical_mission
	call	?get_first_unfiltered_victory_condition@tactical_mission@@QAEPAVvictory_condition@@XZ ; tactical_mission::get_first_unfiltered_victory_condition
	mov	DWORD PTR _vc$[ebp], eax
$LN3@GetCurrent:

; 1330 : 	while(vc)

	cmp	DWORD PTR _vc$[ebp], 0
	je	SHORT $LN2@GetCurrent

; 1331 : 	{
; 1332 : 		if(vc->get_team() == teamno && vc->get_active())

	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_team@victory_condition@@QAEHXZ	; victory_condition::get_team
	cmp	eax, DWORD PTR _teamno$[ebp]
	jne	SHORT $LN1@GetCurrent
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_active@victory_condition@@QAEHXZ	; victory_condition::get_active
	test	eax, eax
	je	SHORT $LN1@GetCurrent

; 1333 : 			value+=vc->get_points();

	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_points@victory_condition@@QAEHXZ	; victory_condition::get_points
	add	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], eax
$LN1@GetCurrent:

; 1334 : 		vc=current_tactical_mission->get_next_unfiltered_victory_condition();

	mov	ecx, DWORD PTR ?current_tactical_mission@@3PAVtactical_mission@@A ; current_tactical_mission
	call	?get_next_unfiltered_victory_condition@tactical_mission@@QAEPAVvictory_condition@@XZ ; tactical_mission::get_next_unfiltered_victory_condition
	mov	DWORD PTR _vc$[ebp], eax

; 1335 : 	}

	jmp	SHORT $LN3@GetCurrent
$LN2@GetCurrent:

; 1336 : 	return(value);

	mov	eax, DWORD PTR _value$[ebp]

; 1337 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCurrentVCScore@@YAJJ@Z ENDP				; GetCurrentVCScore
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\taceng\te_team_victory.cpp
_TEXT	SEGMENT
_ok$ = -12						; size = 4
_test$ = -8						; size = 4
_loop$ = -4						; size = 4
_team$ = 8						; size = 4
_state$ = 12						; size = 4
?advance_team@@YAHHH@Z PROC				; advance_team

; 1272 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1273 : 	int
; 1274 : 		ok,
; 1275 : 		test,
; 1276 : 		loop;
; 1277 : 
; 1278 : 	for (test = 1; test < NUM_COUNS; test ++)

	mov	DWORD PTR _test$[ebp], 1
	jmp	SHORT $LN9@advance_te
$LN8@advance_te:
	mov	eax, DWORD PTR _test$[ebp]
	add	eax, 1
	mov	DWORD PTR _test$[ebp], eax
$LN9@advance_te:
	cmp	DWORD PTR _test$[ebp], 8
	jge	SHORT $LN7@advance_te

; 1279 : 	{
; 1280 : 		state ++; if (state > 8) state = 1;

	mov	ecx, DWORD PTR _state$[ebp]
	add	ecx, 1
	mov	DWORD PTR _state$[ebp], ecx
	cmp	DWORD PTR _state$[ebp], 8
	jle	SHORT $LN6@advance_te
	mov	DWORD PTR _state$[ebp], 1
$LN6@advance_te:

; 1281 : 
; 1282 : 		ok = TRUE;

	mov	DWORD PTR _ok$[ebp], 1

; 1283 : 
; 1284 : 		for (loop = 1; loop < NUM_TEAMS; loop ++)

	mov	DWORD PTR _loop$[ebp], 1
	jmp	SHORT $LN5@advance_te
$LN4@advance_te:
	mov	edx, DWORD PTR _loop$[ebp]
	add	edx, 1
	mov	DWORD PTR _loop$[ebp], edx
$LN5@advance_te:
	cmp	DWORD PTR _loop$[ebp], 8
	jge	SHORT $LN3@advance_te

; 1285 : 		{
; 1286 : 			if
; 1287 : 			(
; 1288 : 				(loop != team) &&
; 1289 : 				(TeamInfo[loop]) &&
; 1290 : 				(TeamInfo[loop]->GetFlag () == state)
; 1291 : 			)

	mov	eax, DWORD PTR _loop$[ebp]
	cmp	eax, DWORD PTR _team$[ebp]
	je	SHORT $LN2@advance_te
	mov	ecx, DWORD PTR _loop$[ebp]
	cmp	DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4], 0
	je	SHORT $LN2@advance_te
	mov	edx, DWORD PTR _loop$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	call	?GetFlag@TeamClass@@QAEHXZ		; TeamClass::GetFlag
	cmp	eax, DWORD PTR _state$[ebp]
	jne	SHORT $LN2@advance_te

; 1292 : 			{
; 1293 : 				ok = FALSE;

	mov	DWORD PTR _ok$[ebp], 0

; 1294 : 				break;

	jmp	SHORT $LN3@advance_te
$LN2@advance_te:

; 1295 : 			}
; 1296 : 		}

	jmp	SHORT $LN4@advance_te
$LN3@advance_te:

; 1297 : 
; 1298 : 		if (ok)

	cmp	DWORD PTR _ok$[ebp], 0
	je	SHORT $LN1@advance_te

; 1299 : 		{
; 1300 : 			return state;

	mov	eax, DWORD PTR _state$[ebp]
	jmp	SHORT $LN10@advance_te
$LN1@advance_te:

; 1301 : 		}
; 1302 : 	}

	jmp	$LN8@advance_te
$LN7@advance_te:

; 1303 : 
; 1304 : 	return FALSE;

	xor	eax, eax
$LN10@advance_te:

; 1305 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?advance_team@@YAHHH@Z ENDP				; advance_team
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\taceng\te_team_victory.cpp
_TEXT	SEGMENT
$T2 = -200						; size = 8
$T3 = -192						; size = 4
$T4 = -188						; size = 4
$T5 = -184						; size = 4
$T6 = -180						; size = 4
$T7 = -176						; size = 4
$T8 = -172						; size = 4
$T9 = -168						; size = 4
tv256 = -164						; size = 4
$T10 = -160						; size = 4
$T11 = -156						; size = 4
$T12 = -152						; size = 4
$T13 = -148						; size = 4
tv388 = -144						; size = 4
$T14 = -140						; size = 4
tv94 = -136						; size = 4
tv442 = -132						; size = 4
tv181 = -128						; size = 4
tv554 = -124						; size = 4
tv153 = -120						; size = 4
$T15 = -116						; size = 4
tv515 = -112						; size = 4
$T16 = -108						; size = 4
_fh$ = -104						; size = 4
_txt$ = -100						; size = 4
_btn$ = -96						; size = 4
_ent$ = -92						; size = 4
_ebox$ = -88						; size = 4
_vcntrl$ = -84						; size = 4
_lbox$ = -80						; size = 4
_buffer$ = -76						; size = 60
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_vc$ = 8						; size = 4
?MakeVCControl@@YAPAVC_Victory@@PAVvictory_condition@@@Z PROC ; MakeVCControl

; 1128 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?MakeVCControl@@YAPAVC_Victory@@PAVvictory_condition@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 188				; 000000bcH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1129 : 	C_Victory *vcntrl;
; 1130 : 	C_ListBox *lbox;
; 1131 : 	C_Button *btn;
; 1132 : 	C_EditBox *ebox;
; 1133 : 	C_Text *txt;
; 1134 : 	CampEntity ent;
; 1135 : 	_TCHAR buffer[60];
; 1136 : 	long fh;
; 1137 : 
; 1138 : 	if(!gVCTree)

	cmp	DWORD PTR ?gVCTree@@3PAVC_TreeList@@A, 0 ; gVCTree
	jne	SHORT $LN17@MakeVCCont

; 1139 : 		return(NULL);

	xor	eax, eax
	jmp	$LN18@MakeVCCont
$LN17@MakeVCCont:

; 1140 : 
; 1141 : 	fh=gFontList->GetHeight(gVCTree->GetFont())+2;

	mov	eax, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	mov	eax, DWORD PTR [edx+124]
	call	eax
	push	eax
	mov	ecx, DWORD PTR ?gFontList@@3PAVC_Font@@A ; gFontList
	call	?GetHeight@C_Font@@QAEHJ@Z		; C_Font::GetHeight
	add	eax, 2
	mov	DWORD PTR _fh$[ebp], eax

; 1142 : 
; 1143 : 	ent=(CampEntity)vuDatabase->Find(vc->get_vu_id());

	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_vu_id@victory_condition@@QAE?AVVU_ID@@XZ ; victory_condition::get_vu_id
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _ent$[ebp], eax

; 1144 : 
; 1145 : 	vcntrl=new C_Victory;

	push	168					; 000000a8H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T12[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T12[ebp], 0
	je	SHORT $LN20@MakeVCCont
	mov	ecx, DWORD PTR $T12[ebp]
	call	??0C_Victory@@QAE@XZ			; C_Victory::C_Victory
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN21@MakeVCCont
$LN20@MakeVCCont:
	mov	DWORD PTR tv94[ebp], 0
$LN21@MakeVCCont:
	mov	ecx, DWORD PTR tv94[ebp]
	mov	DWORD PTR $T9[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T9[ebp]
	mov	DWORD PTR _vcntrl$[ebp], edx

; 1146 : 	vcntrl->Setup(vc->get_number(),0);

	push	0
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_number@victory_condition@@QAEHXZ	; victory_condition::get_number
	push	eax
	mov	ecx, DWORD PTR _vcntrl$[ebp]
	call	?Setup@C_Victory@@QAEXJF@Z		; C_Victory::Setup

; 1147 : 	vcntrl->SetPtr(vc);

	mov	eax, DWORD PTR _vc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vcntrl$[ebp]
	call	?SetPtr@C_Victory@@QAEXPAX@Z		; C_Victory::SetPtr

; 1148 : 	vcntrl->SetCallback(VCSelectVCCB);

	push	OFFSET ?VCSelectVCCB@@YAXJFPAVC_Base@@@Z ; VCSelectVCCB
	mov	ecx, DWORD PTR _vcntrl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _vcntrl$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax

; 1149 : 
; 1150 : 	// VC ID #
; 1151 : 	_stprintf(buffer,"%1d",vc->get_number());

	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_number@victory_condition@@QAEHXZ	; victory_condition::get_number
	push	eax
	push	OFFSET ??_C@_03GNGPFOOL@?$CF1d?$AA@
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1152 : 	txt=new C_Text;

	push	76					; 0000004cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T14[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T14[ebp], 0
	je	SHORT $LN22@MakeVCCont
	mov	ecx, DWORD PTR $T14[ebp]
	call	??0C_Text@@QAE@XZ			; C_Text::C_Text
	mov	DWORD PTR tv153[ebp], eax
	jmp	SHORT $LN23@MakeVCCont
$LN22@MakeVCCont:
	mov	DWORD PTR tv153[ebp], 0
$LN23@MakeVCCont:
	mov	edx, DWORD PTR tv153[ebp]
	mov	DWORD PTR $T4[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T4[ebp]
	mov	DWORD PTR _txt$[ebp], eax

; 1153 : 	txt->Setup(C_DONT_CARE,0);

	push	0
	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax

; 1154 : 	txt->SetFixedWidth(4);

	push	4
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetFixedWidth@C_Text@@QAEXJ@Z		; C_Text::SetFixedWidth

; 1155 : 	txt->SetText(buffer);

	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax+256]
	call	edx

; 1156 : 	txt->SetFlagBitOn(C_BIT_RIGHT);

	push	64					; 00000040H
	mov	eax, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 1157 : 	vcntrl->SetNumber(txt);

	mov	ecx, DWORD PTR _txt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _vcntrl$[ebp]
	call	?SetNumber@C_Victory@@QAEXPAVC_Text@@@Z	; C_Victory::SetNumber

; 1158 : 
; 1159 : 	// Team Name
; 1160 : 	lbox=new C_ListBox;

	push	216					; 000000d8H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T13[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	cmp	DWORD PTR $T13[ebp], 0
	je	SHORT $LN24@MakeVCCont
	mov	ecx, DWORD PTR $T13[ebp]
	call	??0C_ListBox@@QAE@XZ			; C_ListBox::C_ListBox
	mov	DWORD PTR tv181[ebp], eax
	jmp	SHORT $LN25@MakeVCCont
$LN24@MakeVCCont:
	mov	DWORD PTR tv181[ebp], 0
$LN25@MakeVCCont:
	mov	edx, DWORD PTR tv181[ebp]
	mov	DWORD PTR $T7[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T7[ebp]
	mov	DWORD PTR _lbox$[ebp], eax

; 1161 : 	lbox->Setup(1,0,gMainHandler);

	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	push	ecx
	push	0
	push	1
	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?Setup@C_ListBox@@QAEXJFPAVC_Handler@@@Z ; C_ListBox::Setup

; 1162 : 	lbox->SetWH(gVCTree->GetUserNumber(11),fh);

	mov	edx, DWORD PTR _fh$[ebp]
	push	edx
	push	11					; 0000000bH
	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	call	?GetUserNumber@C_Base@@QAEJJ@Z		; C_Base::GetUserNumber
	push	eax
	mov	eax, DWORD PTR _lbox$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _lbox$[ebp]
	mov	eax, DWORD PTR [edx+36]
	call	eax

; 1163 : 	lbox->SetBgFill(0,0,0,0);

	push	0
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?SetBgFill@C_ListBox@@QAEXHHHH@Z	; C_ListBox::SetBgFill

; 1164 : 	lbox->SetBgColor(11370561); // 

	push	11370561				; 00ad8041H
	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?SetBgColor@C_ListBox@@QAEXK@Z		; C_ListBox::SetBgColor

; 1165 : 	lbox->SetRoot(team_lbox);

	mov	ecx, DWORD PTR ?team_lbox@@3PAVLISTBOX@@A ; team_lbox
	push	ecx
	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?SetRoot@C_ListBox@@QAEXPAVLISTBOX@@@Z	; C_ListBox::SetRoot

; 1166 : 	lbox->SetValue(vc->get_team());

	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_team@victory_condition@@QAEHXZ	; victory_condition::get_team
	push	eax
	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?SetValue@C_ListBox@@QAEXJ@Z		; C_ListBox::SetValue

; 1167 : 	lbox->SetDropDown (BID_DROPDOWN);

	push	50300					; 0000c47cH
	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?SetDropDown@C_ListBox@@QAEXJ@Z		; C_ListBox::SetDropDown

; 1168 : 	lbox->SetCallback(VCChangeTeamNoCB);

	push	OFFSET ?VCChangeTeamNoCB@@YAXJFPAVC_Base@@@Z ; VCChangeTeamNoCB
	mov	edx, DWORD PTR _lbox$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _lbox$[ebp]
	mov	edx, DWORD PTR [eax+100]
	call	edx

; 1169 : 	lbox->SetFlagBitOff(C_BIT_ENABLED);

	push	2048					; 00000800H
	mov	eax, DWORD PTR _lbox$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _lbox$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 1170 : 	lbox->SetFlagBitOn(gVCTree->GetFlags() & C_BIT_ENABLED);

	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	call	?GetFlags@C_Base@@QAEJXZ		; C_Base::GetFlags
	and	eax, 2048				; 00000800H
	push	eax
	mov	ecx, DWORD PTR _lbox$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _lbox$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 1171 : 	vcntrl->SetTeam(lbox);

	mov	ecx, DWORD PTR _lbox$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _vcntrl$[ebp]
	call	?SetTeam@C_Victory@@QAEXPAVC_ListBox@@@Z ; C_Victory::SetTeam

; 1172 : 	
; 1173 : 	// Action
; 1174 : 	lbox=new C_ListBox;

	push	216					; 000000d8H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T11[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	cmp	DWORD PTR $T11[ebp], 0
	je	SHORT $LN26@MakeVCCont
	mov	ecx, DWORD PTR $T11[ebp]
	call	??0C_ListBox@@QAE@XZ			; C_ListBox::C_ListBox
	mov	DWORD PTR tv256[ebp], eax
	jmp	SHORT $LN27@MakeVCCont
$LN26@MakeVCCont:
	mov	DWORD PTR tv256[ebp], 0
$LN27@MakeVCCont:
	mov	edx, DWORD PTR tv256[ebp]
	mov	DWORD PTR $T3[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR _lbox$[ebp], eax

; 1175 : 	lbox->Setup(2,0,gMainHandler);

	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	push	ecx
	push	0
	push	2
	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?Setup@C_ListBox@@QAEXJFPAVC_Handler@@@Z ; C_ListBox::Setup

; 1176 : 	lbox->SetWH(gVCTree->GetUserNumber(12),fh);

	mov	edx, DWORD PTR _fh$[ebp]
	push	edx
	push	12					; 0000000cH
	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	call	?GetUserNumber@C_Base@@QAEJJ@Z		; C_Base::GetUserNumber
	push	eax
	mov	eax, DWORD PTR _lbox$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _lbox$[ebp]
	mov	eax, DWORD PTR [edx+36]
	call	eax

; 1177 : 	lbox->SetBgFill(0,0,0,0);

	push	0
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?SetBgFill@C_ListBox@@QAEXHHHH@Z	; C_ListBox::SetBgFill

; 1178 : 	lbox->SetBgColor(11370561); // 

	push	11370561				; 00ad8041H
	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?SetBgColor@C_ListBox@@QAEXK@Z		; C_ListBox::SetBgColor

; 1179 : 	lbox->SetRoot(action_lbox);

	mov	ecx, DWORD PTR ?action_lbox@@3PAVLISTBOX@@A ; action_lbox
	push	ecx
	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?SetRoot@C_ListBox@@QAEXPAVLISTBOX@@@Z	; C_ListBox::SetRoot

; 1180 : 	lbox->SetValue(vc->get_type());

	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_type@victory_condition@@QAE?AW4victory_type@@XZ ; victory_condition::get_type
	push	eax
	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?SetValue@C_ListBox@@QAEXJ@Z		; C_ListBox::SetValue

; 1181 : 	lbox->SetOpenCallback(VCActionOpenCB);

	push	OFFSET ?VCActionOpenCB@@YAXPAVC_Base@@@Z ; VCActionOpenCB
	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?SetOpenCallback@C_ListBox@@QAEXP6AXPAVC_Base@@@Z@Z ; C_ListBox::SetOpenCallback

; 1182 : 	lbox->SetCallback(VCChangeActionCB);

	push	OFFSET ?VCChangeActionCB@@YAXJFPAVC_Base@@@Z ; VCChangeActionCB
	mov	edx, DWORD PTR _lbox$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _lbox$[ebp]
	mov	edx, DWORD PTR [eax+100]
	call	edx

; 1183 : 	lbox->SetFlagBitOff(C_BIT_ENABLED);

	push	2048					; 00000800H
	mov	eax, DWORD PTR _lbox$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _lbox$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 1184 : 	lbox->SetFlagBitOn(gVCTree->GetFlags() & C_BIT_ENABLED);

	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	call	?GetFlags@C_Base@@QAEJXZ		; C_Base::GetFlags
	and	eax, 2048				; 00000800H
	push	eax
	mov	ecx, DWORD PTR _lbox$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _lbox$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 1185 : 	lbox->SetDropDown (BID_DROPDOWN);

	push	50300					; 0000c47cH
	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?SetDropDown@C_ListBox@@QAEXJ@Z		; C_ListBox::SetDropDown

; 1186 : 	if(!ent)

	cmp	DWORD PTR _ent$[ebp], 0
	jne	SHORT $LN16@MakeVCCont

; 1187 : 		lbox->SetFlagBitOn(C_BIT_INVISIBLE);

	push	8192					; 00002000H
	mov	ecx, DWORD PTR _lbox$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _lbox$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
$LN16@MakeVCCont:

; 1188 : 	vcntrl->SetAction(lbox);

	mov	ecx, DWORD PTR _lbox$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _vcntrl$[ebp]
	call	?SetAction@C_Victory@@QAEXPAVC_ListBox@@@Z ; C_Victory::SetAction

; 1189 : 
; 1190 : 	
; 1191 : 	if(ent)

	cmp	DWORD PTR _ent$[ebp], 0
	je	SHORT $LN15@MakeVCCont

; 1192 : 		{
; 1193 : 		if (ent->IsFlight())

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax+248]
	call	edx
	test	eax, eax
	je	SHORT $LN14@MakeVCCont

; 1194 : 			GetCallsign (((Flight)ent)->callsign_id, ((Flight)ent)->callsign_num, buffer);

	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	movzx	edx, BYTE PTR [ecx+426]
	push	edx
	mov	eax, DWORD PTR _ent$[ebp]
	movzx	ecx, BYTE PTR [eax+425]
	push	ecx
	call	?GetCallsign@@YAXHHPAD@Z		; GetCallsign
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN15@MakeVCCont
$LN14@MakeVCCont:

; 1195 : 		else if (ent->IsObjective())

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax+236]
	call	edx
	test	eax, eax
	je	SHORT $LN12@MakeVCCont

; 1196 : 			ent->GetName(buffer,40,TRUE);

	push	1
	push	40					; 00000028H
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+380]
	call	eax

; 1197 : 		else

	jmp	SHORT $LN15@MakeVCCont
$LN12@MakeVCCont:

; 1198 : 			ent->GetName(buffer,40,FALSE);

	push	0
	push	40					; 00000028H
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax+380]
	call	edx
$LN15@MakeVCCont:

; 1199 : 		}
; 1200 : 	// Target
; 1201 : 	btn=new C_Button;

	push	160					; 000000a0H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T16[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	cmp	DWORD PTR $T16[ebp], 0
	je	SHORT $LN28@MakeVCCont
	mov	ecx, DWORD PTR $T16[ebp]
	call	??0C_Button@@QAE@XZ			; C_Button::C_Button
	mov	DWORD PTR tv388[ebp], eax
	jmp	SHORT $LN29@MakeVCCont
$LN28@MakeVCCont:
	mov	DWORD PTR tv388[ebp], 0
$LN29@MakeVCCont:
	mov	eax, DWORD PTR tv388[ebp]
	mov	DWORD PTR $T5[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T5[ebp]
	mov	DWORD PTR _btn$[ebp], ecx

; 1202 : 	btn->Setup(TARGET_VC,C_TYPE_NORMAL,0,0);

	push	0
	push	0
	push	25					; 00000019H
	push	3
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?Setup@C_Button@@QAEXJFJJ@Z		; C_Button::Setup

; 1203 : 	if(ent)

	cmp	DWORD PTR _ent$[ebp], 0
	je	SHORT $LN10@MakeVCCont

; 1204 : 		btn->SetText(0,buffer);

	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	push	0
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetText@C_Button@@QAEXFPBD@Z		; C_Button::SetText

; 1205 : 	else

	jmp	SHORT $LN9@MakeVCCont
$LN10@MakeVCCont:

; 1206 : 		btn->SetText(0,TXT_ASSIGN);

	push	224					; 000000e0H
	push	0
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetText@C_Button@@QAEXFJ@Z		; C_Button::SetText
$LN9@MakeVCCont:

; 1207 : 	btn->SetFlagBitOn(C_BIT_USELINE);

	push	4194304					; 00400000H
	mov	eax, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 1208 : 	btn->SetCallback(VCSetTargetCB);

	push	OFFSET ?VCSetTargetCB@@YAXJFPAVC_Base@@@Z ; VCSetTargetCB
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax

; 1209 : 	btn->SetUserNumber(1,HELP_PICK_VC_TARGET);

	push	252					; 000000fcH
	push	1
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetUserNumber@C_Base@@QAEXJJ@Z		; C_Base::SetUserNumber

; 1210 : 	if(vc->get_type() == vt_destroy)

	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_type@victory_condition@@QAE?AW4victory_type@@XZ ; victory_condition::get_type
	cmp	eax, 2
	jne	SHORT $LN8@MakeVCCont

; 1211 : 		btn->SetUserNumber(10,1);

	push	1
	push	10					; 0000000aH
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetUserNumber@C_Base@@QAEXJJ@Z		; C_Base::SetUserNumber
$LN8@MakeVCCont:

; 1212 : 	vcntrl->SetTarget(btn);

	mov	ecx, DWORD PTR _btn$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _vcntrl$[ebp]
	call	?SetTarget@C_Victory@@QAEXPAVC_Button@@@Z ; C_Victory::SetTarget

; 1213 : 
; 1214 : 	// Arguments (other than target)
; 1215 : 	lbox=new C_ListBox;

	push	216					; 000000d8H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T10[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 5
	cmp	DWORD PTR $T10[ebp], 0
	je	SHORT $LN30@MakeVCCont
	mov	ecx, DWORD PTR $T10[ebp]
	call	??0C_ListBox@@QAE@XZ			; C_ListBox::C_ListBox
	mov	DWORD PTR tv442[ebp], eax
	jmp	SHORT $LN31@MakeVCCont
$LN30@MakeVCCont:
	mov	DWORD PTR tv442[ebp], 0
$LN31@MakeVCCont:
	mov	edx, DWORD PTR tv442[ebp]
	mov	DWORD PTR $T8[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T8[ebp]
	mov	DWORD PTR _lbox$[ebp], eax

; 1216 : 	lbox->Setup(4,0,gMainHandler);

	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	push	ecx
	push	0
	push	4
	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?Setup@C_ListBox@@QAEXJFPAVC_Handler@@@Z ; C_ListBox::Setup

; 1217 : 	lbox->SetWH(gVCTree->GetUserNumber(14),fh);

	mov	edx, DWORD PTR _fh$[ebp]
	push	edx
	push	14					; 0000000eH
	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	call	?GetUserNumber@C_Base@@QAEJJ@Z		; C_Base::GetUserNumber
	push	eax
	mov	eax, DWORD PTR _lbox$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _lbox$[ebp]
	mov	eax, DWORD PTR [edx+36]
	call	eax

; 1218 : 	lbox->SetBgFill(0,0,0,0);

	push	0
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?SetBgFill@C_ListBox@@QAEXHHHH@Z	; C_ListBox::SetBgFill

; 1219 : 	lbox->SetBgColor(11370561); // 

	push	11370561				; 00ad8041H
	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?SetBgColor@C_ListBox@@QAEXK@Z		; C_ListBox::SetBgColor

; 1220 : 	lbox->SetDropDown (BID_DROPDOWN);

	push	50300					; 0000c47cH
	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?SetDropDown@C_ListBox@@QAEXJ@Z		; C_ListBox::SetDropDown

; 1221 : 	lbox->SetCallback(VCArgsCB);

	push	OFFSET ?VCArgsCB@@YAXJFPAVC_Base@@@Z	; VCArgsCB
	mov	ecx, DWORD PTR _lbox$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _lbox$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax

; 1222 : 	lbox->SetOpenCallback(VCArgsOpenCB);

	push	OFFSET ?VCArgsOpenCB@@YAXPAVC_Base@@@Z	; VCArgsOpenCB
	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?SetOpenCallback@C_ListBox@@QAEXP6AXPAVC_Base@@@Z@Z ; C_ListBox::SetOpenCallback

; 1223 : 	lbox->SetFlagBitOff(C_BIT_ENABLED);

	push	2048					; 00000800H
	mov	ecx, DWORD PTR _lbox$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _lbox$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 1224 : 	lbox->SetFlagBitOn(gVCTree->GetFlags() & C_BIT_ENABLED);

	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	call	?GetFlags@C_Base@@QAEJXZ		; C_Base::GetFlags
	and	eax, 2048				; 00000800H
	push	eax
	mov	ecx, DWORD PTR _lbox$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _lbox$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 1225 : 
; 1226 : 	if(vc->get_type() == vt_intercept)

	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_type@victory_condition@@QAE?AW4victory_type@@XZ ; victory_condition::get_type
	cmp	eax, 4
	jne	SHORT $LN7@MakeVCCont

; 1227 : 		lbox->SetRoot(intercept_lbox);

	mov	ecx, DWORD PTR ?intercept_lbox@@3PAVLISTBOX@@A ; intercept_lbox
	push	ecx
	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?SetRoot@C_ListBox@@QAEXPAVLISTBOX@@@Z	; C_ListBox::SetRoot

; 1228 : 	else

	jmp	SHORT $LN6@MakeVCCont
$LN7@MakeVCCont:

; 1229 : 		lbox->SetRoot(percent_lbox);

	mov	edx, DWORD PTR ?percent_lbox@@3PAVLISTBOX@@A ; percent_lbox
	push	edx
	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?SetRoot@C_ListBox@@QAEXPAVLISTBOX@@@Z	; C_ListBox::SetRoot
$LN6@MakeVCCont:

; 1230 : 	vcntrl->SetArgs(lbox);

	mov	eax, DWORD PTR _lbox$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vcntrl$[ebp]
	call	?SetArgs@C_Victory@@QAEXPAVC_ListBox@@@Z ; C_Victory::SetArgs

; 1231 : 	switch(vc->get_type())

	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_type@victory_condition@@QAE?AW4victory_type@@XZ ; victory_condition::get_type
	mov	DWORD PTR tv515[ebp], eax
	cmp	DWORD PTR tv515[ebp], 3
	jl	SHORT $LN2@MakeVCCont
	cmp	DWORD PTR tv515[ebp], 5
	jle	SHORT $LN3@MakeVCCont
	jmp	SHORT $LN2@MakeVCCont
$LN3@MakeVCCont:

; 1232 : 	{
; 1233 : 		case vt_attrit:
; 1234 : 		case vt_intercept:
; 1235 : 		case vt_degrade:
; 1236 : 			lbox->SetFlagBitOff(C_BIT_INVISIBLE);

	push	8192					; 00002000H
	mov	ecx, DWORD PTR _lbox$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _lbox$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 1237 : 			break;

	jmp	SHORT $LN4@MakeVCCont
$LN2@MakeVCCont:

; 1238 : 		default:
; 1239 : 			lbox->SetFlagBitOn(C_BIT_INVISIBLE);

	push	8192					; 00002000H
	mov	ecx, DWORD PTR _lbox$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _lbox$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
$LN4@MakeVCCont:

; 1240 : 			break;
; 1241 : 	}
; 1242 : 	lbox->SetValue(vc->get_tolerance());

	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_tolerance@victory_condition@@QAEHXZ ; victory_condition::get_tolerance
	push	eax
	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?SetValue@C_ListBox@@QAEXJ@Z		; C_ListBox::SetValue

; 1243 : 	if(!ent)

	cmp	DWORD PTR _ent$[ebp], 0
	jne	SHORT $LN1@MakeVCCont

; 1244 : 		lbox->SetFlagBitOn(C_BIT_INVISIBLE);

	push	8192					; 00002000H
	mov	ecx, DWORD PTR _lbox$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _lbox$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
$LN1@MakeVCCont:

; 1245 : 
; 1246 : 	// Points
; 1247 : 	ebox=new C_EditBox;

	push	184					; 000000b8H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T15[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 6
	cmp	DWORD PTR $T15[ebp], 0
	je	SHORT $LN32@MakeVCCont
	mov	ecx, DWORD PTR $T15[ebp]
	call	??0C_EditBox@@QAE@XZ			; C_EditBox::C_EditBox
	mov	DWORD PTR tv554[ebp], eax
	jmp	SHORT $LN33@MakeVCCont
$LN32@MakeVCCont:
	mov	DWORD PTR tv554[ebp], 0
$LN33@MakeVCCont:
	mov	ecx, DWORD PTR tv554[ebp]
	mov	DWORD PTR $T6[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T6[ebp]
	mov	DWORD PTR _ebox$[ebp], edx

; 1248 : 	ebox->Setup(5,C_TYPE_INTEGER);

	push	41					; 00000029H
	push	5
	mov	ecx, DWORD PTR _ebox$[ebp]
	call	?Setup@C_EditBox@@QAEXJF@Z		; C_EditBox::Setup

; 1249 : 	ebox->SetMaxLen(6);

	push	6
	mov	ecx, DWORD PTR _ebox$[ebp]
	call	?SetMaxLen@C_EditBox@@QAEXF@Z		; C_EditBox::SetMaxLen

; 1250 : 	ebox->SetWH(gVCTree->GetUserNumber(15),fh);

	mov	eax, DWORD PTR _fh$[ebp]
	push	eax
	push	15					; 0000000fH
	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	call	?GetUserNumber@C_Base@@QAEJJ@Z		; C_Base::GetUserNumber
	push	eax
	mov	ecx, DWORD PTR _ebox$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ebox$[ebp]
	mov	eax, DWORD PTR [edx+36]
	call	eax

; 1251 : 	ebox->SetMinInteger(-99999);

	push	-99999					; fffe7961H
	mov	ecx, DWORD PTR _ebox$[ebp]
	call	?SetMinInteger@C_EditBox@@QAEXJ@Z	; C_EditBox::SetMinInteger

; 1252 : 	ebox->SetMaxInteger(99999);

	push	99999					; 0001869fH
	mov	ecx, DWORD PTR _ebox$[ebp]
	call	?SetMaxInteger@C_EditBox@@QAEXJ@Z	; C_EditBox::SetMaxInteger

; 1253 : 	ebox->SetInteger(vc->get_points());

	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_points@victory_condition@@QAEHXZ	; victory_condition::get_points
	push	eax
	mov	ecx, DWORD PTR _ebox$[ebp]
	call	?SetInteger@C_EditBox@@QAEXJ@Z		; C_EditBox::SetInteger

; 1254 : 	ebox->SetBgColor(11370561); // 

	push	11370561				; 00ad8041H
	mov	ecx, DWORD PTR _ebox$[ebp]
	call	?SetBgColor@C_EditBox@@QAEXK@Z		; C_EditBox::SetBgColor

; 1255 : 	ebox->SetFlagBitOn(C_BIT_USEOUTLINE|C_BIT_RIGHT);

	push	80					; 00000050H
	mov	ecx, DWORD PTR _ebox$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ebox$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 1256 : 	ebox->SetCallback(VCSetPointsCB);

	push	OFFSET ?VCSetPointsCB@@YAXJFPAVC_Base@@@Z ; VCSetPointsCB
	mov	ecx, DWORD PTR _ebox$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ebox$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax

; 1257 : 	vcntrl->SetPoints(ebox);

	mov	ecx, DWORD PTR _ebox$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _vcntrl$[ebp]
	call	?SetPoints@C_Victory@@QAEXPAVC_EditBox@@@Z ; C_Victory::SetPoints

; 1258 : 
; 1259 : 	vcntrl->SetNumberX(static_cast<short>(gVCTree->GetUserNumber(0)));

	push	0
	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	call	?GetUserNumber@C_Base@@QAEJJ@Z		; C_Base::GetUserNumber
	push	eax
	mov	ecx, DWORD PTR _vcntrl$[ebp]
	call	?SetNumberX@C_Victory@@QAEXF@Z		; C_Victory::SetNumberX

; 1260 : 	vcntrl->SetTeamX(static_cast<short>(gVCTree->GetUserNumber(1)));

	push	1
	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	call	?GetUserNumber@C_Base@@QAEJJ@Z		; C_Base::GetUserNumber
	push	eax
	mov	ecx, DWORD PTR _vcntrl$[ebp]
	call	?SetTeamX@C_Victory@@QAEXF@Z		; C_Victory::SetTeamX

; 1261 : 	vcntrl->SetActionX(static_cast<short>(gVCTree->GetUserNumber(2)));

	push	2
	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	call	?GetUserNumber@C_Base@@QAEJJ@Z		; C_Base::GetUserNumber
	push	eax
	mov	ecx, DWORD PTR _vcntrl$[ebp]
	call	?SetActionX@C_Victory@@QAEXF@Z		; C_Victory::SetActionX

; 1262 : 	vcntrl->SetTargetX(static_cast<short>(gVCTree->GetUserNumber(3)));

	push	3
	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	call	?GetUserNumber@C_Base@@QAEJJ@Z		; C_Base::GetUserNumber
	push	eax
	mov	ecx, DWORD PTR _vcntrl$[ebp]
	call	?SetTargetX@C_Victory@@QAEXF@Z		; C_Victory::SetTargetX

; 1263 : 	vcntrl->SetArgsX(static_cast<short>(gVCTree->GetUserNumber(4)));

	push	4
	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	call	?GetUserNumber@C_Base@@QAEJJ@Z		; C_Base::GetUserNumber
	push	eax
	mov	ecx, DWORD PTR _vcntrl$[ebp]
	call	?SetArgsX@C_Victory@@QAEXF@Z		; C_Victory::SetArgsX

; 1264 : 	vcntrl->SetPointsX(static_cast<short>(gVCTree->GetUserNumber(5)));

	push	5
	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	call	?GetUserNumber@C_Base@@QAEJJ@Z		; C_Base::GetUserNumber
	push	eax
	mov	ecx, DWORD PTR _vcntrl$[ebp]
	call	?SetPointsX@C_Victory@@QAEXF@Z		; C_Victory::SetPointsX

; 1265 : 	vcntrl->SetFont(gVCTree->GetFont());

	mov	edx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	mov	edx, DWORD PTR [eax+124]
	call	edx
	push	eax
	mov	eax, DWORD PTR _vcntrl$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _vcntrl$[ebp]
	mov	eax, DWORD PTR [edx+68]
	call	eax

; 1266 : 	vcntrl->SetWH(ebox->GetX()+ebox->GetW(),fh+1);

	mov	ecx, DWORD PTR _fh$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _ebox$[ebp]
	call	?GetX@C_Base@@QAEJXZ			; C_Base::GetX
	mov	esi, eax
	mov	ecx, DWORD PTR _ebox$[ebp]
	call	?GetW@C_Base@@QAEJXZ			; C_Base::GetW
	add	esi, eax
	push	esi
	mov	edx, DWORD PTR _vcntrl$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _vcntrl$[ebp]
	mov	edx, DWORD PTR [eax+36]
	call	edx

; 1267 : 	vcntrl->SetState(0);

	push	0
	mov	eax, DWORD PTR _vcntrl$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _vcntrl$[ebp]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 1268 : 	return(vcntrl);

	mov	eax, DWORD PTR _vcntrl$[ebp]
$LN18@MakeVCCont:

; 1269 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?MakeVCControl@@YAPAVC_Victory@@PAVvictory_condition@@@Z$0:
	mov	eax, DWORD PTR $T12[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?MakeVCControl@@YAPAVC_Victory@@PAVvictory_condition@@@Z$1:
	mov	eax, DWORD PTR $T14[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?MakeVCControl@@YAPAVC_Victory@@PAVvictory_condition@@@Z$2:
	mov	eax, DWORD PTR $T13[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?MakeVCControl@@YAPAVC_Victory@@PAVvictory_condition@@@Z$3:
	mov	eax, DWORD PTR $T11[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?MakeVCControl@@YAPAVC_Victory@@PAVvictory_condition@@@Z$4:
	mov	eax, DWORD PTR $T16[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?MakeVCControl@@YAPAVC_Victory@@PAVvictory_condition@@@Z$5:
	mov	eax, DWORD PTR $T10[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?MakeVCControl@@YAPAVC_Victory@@PAVvictory_condition@@@Z$6:
	mov	eax, DWORD PTR $T15[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?MakeVCControl@@YAPAVC_Victory@@PAVvictory_condition@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-196]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?MakeVCControl@@YAPAVC_Victory@@PAVvictory_condition@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?MakeVCControl@@YAPAVC_Victory@@PAVvictory_condition@@@Z ENDP ; MakeVCControl
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\taceng\te_team_victory.cpp
_TEXT	SEGMENT
$T1 = -28						; size = 8
_vctrl$ = -20						; size = 4
_item$ = -16						; size = 4
_vc$ = -12						; size = 4
_ent$ = -8						; size = 4
_i$ = -4						; size = 4
_me$ = 8						; size = 4
?VCArgsOpenCB@@YAXPAVC_Base@@@Z PROC			; VCArgsOpenCB

; 1091 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 1092 : 	TREELIST *item;
; 1093 : 	C_Victory *vctrl;
; 1094 : 	victory_condition *vc;
; 1095 : 	CampEntity ent;
; 1096 : 	long i;
; 1097 : 
; 1098 : 	if(!gVCTree)

	cmp	DWORD PTR ?gVCTree@@3PAVC_TreeList@@A, 0 ; gVCTree
	jne	SHORT $LN12@VCArgsOpen

; 1099 : 		return;

	jmp	$LN13@VCArgsOpen
$LN12@VCArgsOpen:

; 1100 : 
; 1101 : 	item=gVCTree->GetLastItem();

	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	call	?GetLastItem@C_TreeList@@QAEPAVTREELIST@@XZ ; C_TreeList::GetLastItem
	mov	DWORD PTR _item$[ebp], eax

; 1102 : 	if(!item)

	cmp	DWORD PTR _item$[ebp], 0
	jne	SHORT $LN11@VCArgsOpen

; 1103 : 		return;

	jmp	$LN13@VCArgsOpen
$LN11@VCArgsOpen:

; 1104 : 
; 1105 : 	vctrl=(C_Victory *)item->Item_;

	mov	eax, DWORD PTR _item$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _vctrl$[ebp], ecx

; 1106 : 	if(!vctrl)

	cmp	DWORD PTR _vctrl$[ebp], 0
	jne	SHORT $LN10@VCArgsOpen

; 1107 : 		return;

	jmp	$LN13@VCArgsOpen
$LN10@VCArgsOpen:

; 1108 : 
; 1109 : 	vc=(victory_condition*)vctrl->GetPtr();

	mov	ecx, DWORD PTR _vctrl$[ebp]
	call	?GetPtr@C_Victory@@QAEPAXXZ		; C_Victory::GetPtr
	mov	DWORD PTR _vc$[ebp], eax

; 1110 : 	if(!vc)

	cmp	DWORD PTR _vc$[ebp], 0
	jne	SHORT $LN9@VCArgsOpen

; 1111 : 		return;

	jmp	$LN13@VCArgsOpen
$LN9@VCArgsOpen:

; 1112 : 
; 1113 : 	if(vc->get_type() == vt_intercept)

	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_type@victory_condition@@QAE?AW4victory_type@@XZ ; victory_condition::get_type
	cmp	eax, 4
	jne	$LN13@VCArgsOpen

; 1114 : 	{
; 1115 : 		ent=(CampEntity)vuDatabase->Find(vc->get_vu_id());

	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_vu_id@victory_condition@@QAE?AVVU_ID@@XZ ; victory_condition::get_vu_id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _ent$[ebp], eax

; 1116 : 		if(ent && ent->IsFlight())

	cmp	DWORD PTR _ent$[ebp], 0
	je	SHORT $LN13@VCArgsOpen
	mov	eax, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax
	test	eax, eax
	je	SHORT $LN13@VCArgsOpen

; 1117 : 		{
; 1118 : 			for(i=1;i<=((Flight)ent)->GetTotalVehicles();i++)

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN6@VCArgsOpen
$LN5@VCArgsOpen:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN6@VCArgsOpen:
	mov	ecx, DWORD PTR _ent$[ebp]
	call	?GetTotalVehicles@UnitClass@@QAEHXZ	; UnitClass::GetTotalVehicles
	cmp	DWORD PTR _i$[ebp], eax
	jg	SHORT $LN4@VCArgsOpen

; 1119 : 				((C_ListBox*)me)->SetItemFlags(i,C_BIT_ENABLED);

	push	2048					; 00000800H
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _me$[ebp]
	call	?SetItemFlags@C_ListBox@@QAEXJJ@Z	; C_ListBox::SetItemFlags
	jmp	SHORT $LN5@VCArgsOpen
$LN4@VCArgsOpen:

; 1120 : 
; 1121 : 			for(;i<=4;i++)

	jmp	SHORT $LN3@VCArgsOpen
$LN2@VCArgsOpen:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@VCArgsOpen:
	cmp	DWORD PTR _i$[ebp], 4
	jg	SHORT $LN13@VCArgsOpen

; 1122 : 				((C_ListBox*)me)->SetItemFlags(i,C_BIT_INVISIBLE);

	push	8192					; 00002000H
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _me$[ebp]
	call	?SetItemFlags@C_ListBox@@QAEXJJ@Z	; C_ListBox::SetItemFlags
	jmp	SHORT $LN2@VCArgsOpen
$LN13@VCArgsOpen:

; 1123 : 		}
; 1124 : 	}
; 1125 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?VCArgsOpenCB@@YAXPAVC_Base@@@Z ENDP			; VCArgsOpenCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\taceng\te_team_victory.cpp
_TEXT	SEGMENT
_vc$ = -16						; size = 4
_vctrl$ = -12						; size = 4
_item$ = -8						; size = 4
tv79 = -4						; size = 4
_me$ = 8						; size = 4
?VCActionOpenCB@@YAXPAVC_Base@@@Z PROC			; VCActionOpenCB

; 1042 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 1043 : 	TREELIST *item;
; 1044 : 	C_Victory *vctrl;
; 1045 : 	victory_condition *vc;
; 1046 : 
; 1047 : 	if(!gVCTree)

	cmp	DWORD PTR ?gVCTree@@3PAVC_TreeList@@A, 0 ; gVCTree
	jne	SHORT $LN9@VCActionOp

; 1048 : 		return;

	jmp	$LN10@VCActionOp
$LN9@VCActionOp:

; 1049 : 
; 1050 : 	item=gVCTree->GetLastItem();

	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	call	?GetLastItem@C_TreeList@@QAEPAVTREELIST@@XZ ; C_TreeList::GetLastItem
	mov	DWORD PTR _item$[ebp], eax

; 1051 : 	if(!item)

	cmp	DWORD PTR _item$[ebp], 0
	jne	SHORT $LN8@VCActionOp

; 1052 : 		return;

	jmp	$LN10@VCActionOp
$LN8@VCActionOp:

; 1053 : 
; 1054 : 	vctrl=(C_Victory *)item->Item_;

	mov	eax, DWORD PTR _item$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _vctrl$[ebp], ecx

; 1055 : 	if(!vctrl)

	cmp	DWORD PTR _vctrl$[ebp], 0
	jne	SHORT $LN7@VCActionOp

; 1056 : 		return;

	jmp	$LN10@VCActionOp
$LN7@VCActionOp:

; 1057 : 
; 1058 : 	vc=(victory_condition*)vctrl->GetPtr();

	mov	ecx, DWORD PTR _vctrl$[ebp]
	call	?GetPtr@C_Victory@@QAEPAXXZ		; C_Victory::GetPtr
	mov	DWORD PTR _vc$[ebp], eax

; 1059 : 	if(!vc)

	cmp	DWORD PTR _vc$[ebp], 0
	jne	SHORT $LN6@VCActionOp

; 1060 : 		return;

	jmp	$LN10@VCActionOp
$LN6@VCActionOp:

; 1061 : 
; 1062 : 	switch(vc->get_type())

	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_type@victory_condition@@QAE?AW4victory_type@@XZ ; victory_condition::get_type
	mov	DWORD PTR tv79[ebp], eax
	mov	edx, DWORD PTR tv79[ebp]
	sub	edx, 1
	mov	DWORD PTR tv79[ebp], edx
	cmp	DWORD PTR tv79[ebp], 4
	ja	$LN10@VCActionOp
	mov	eax, DWORD PTR tv79[ebp]
	jmp	DWORD PTR $LN12@VCActionOp[eax*4]
$LN3@VCActionOp:

; 1063 : 	{
; 1064 : 		case vt_intercept:
; 1065 : 			((C_ListBox*)me)->SetItemFlags(vt_degrade,C_BIT_INVISIBLE);

	push	8192					; 00002000H
	push	5
	mov	ecx, DWORD PTR _me$[ebp]
	call	?SetItemFlags@C_ListBox@@QAEXJJ@Z	; C_ListBox::SetItemFlags

; 1066 : 			((C_ListBox*)me)->SetItemFlags(vt_occupy,C_BIT_INVISIBLE);

	push	8192					; 00002000H
	push	1
	mov	ecx, DWORD PTR _me$[ebp]
	call	?SetItemFlags@C_ListBox@@QAEXJJ@Z	; C_ListBox::SetItemFlags

; 1067 : 			((C_ListBox*)me)->SetItemFlags(vt_destroy,C_BIT_INVISIBLE);

	push	8192					; 00002000H
	push	2
	mov	ecx, DWORD PTR _me$[ebp]
	call	?SetItemFlags@C_ListBox@@QAEXJJ@Z	; C_ListBox::SetItemFlags

; 1068 : 			((C_ListBox*)me)->SetItemFlags(vt_attrit,C_BIT_INVISIBLE);

	push	8192					; 00002000H
	push	3
	mov	ecx, DWORD PTR _me$[ebp]
	call	?SetItemFlags@C_ListBox@@QAEXJJ@Z	; C_ListBox::SetItemFlags

; 1069 : 			((C_ListBox*)me)->SetItemFlags(vt_intercept,C_BIT_ENABLED);

	push	2048					; 00000800H
	push	4
	mov	ecx, DWORD PTR _me$[ebp]
	call	?SetItemFlags@C_ListBox@@QAEXJJ@Z	; C_ListBox::SetItemFlags

; 1070 : 			break;

	jmp	$LN10@VCActionOp
$LN2@VCActionOp:

; 1071 : 		case vt_attrit:
; 1072 : 			((C_ListBox*)me)->SetItemFlags(vt_degrade,C_BIT_INVISIBLE);

	push	8192					; 00002000H
	push	5
	mov	ecx, DWORD PTR _me$[ebp]
	call	?SetItemFlags@C_ListBox@@QAEXJJ@Z	; C_ListBox::SetItemFlags

; 1073 : 			((C_ListBox*)me)->SetItemFlags(vt_occupy,C_BIT_INVISIBLE);

	push	8192					; 00002000H
	push	1
	mov	ecx, DWORD PTR _me$[ebp]
	call	?SetItemFlags@C_ListBox@@QAEXJJ@Z	; C_ListBox::SetItemFlags

; 1074 : 			((C_ListBox*)me)->SetItemFlags(vt_destroy,C_BIT_INVISIBLE);

	push	8192					; 00002000H
	push	2
	mov	ecx, DWORD PTR _me$[ebp]
	call	?SetItemFlags@C_ListBox@@QAEXJJ@Z	; C_ListBox::SetItemFlags

; 1075 : 			((C_ListBox*)me)->SetItemFlags(vt_attrit,C_BIT_ENABLED);

	push	2048					; 00000800H
	push	3
	mov	ecx, DWORD PTR _me$[ebp]
	call	?SetItemFlags@C_ListBox@@QAEXJJ@Z	; C_ListBox::SetItemFlags

; 1076 : 			((C_ListBox*)me)->SetItemFlags(vt_intercept,C_BIT_INVISIBLE);

	push	8192					; 00002000H
	push	4
	mov	ecx, DWORD PTR _me$[ebp]
	call	?SetItemFlags@C_ListBox@@QAEXJJ@Z	; C_ListBox::SetItemFlags

; 1077 : 			break;

	jmp	SHORT $LN10@VCActionOp
$LN1@VCActionOp:

; 1078 : 		case vt_degrade:
; 1079 : 		case vt_occupy:
; 1080 : 		case vt_destroy:
; 1081 : 			((C_ListBox*)me)->SetItemFlags(vt_degrade,C_BIT_ENABLED);

	push	2048					; 00000800H
	push	5
	mov	ecx, DWORD PTR _me$[ebp]
	call	?SetItemFlags@C_ListBox@@QAEXJJ@Z	; C_ListBox::SetItemFlags

; 1082 : 			((C_ListBox*)me)->SetItemFlags(vt_occupy,C_BIT_ENABLED);

	push	2048					; 00000800H
	push	1
	mov	ecx, DWORD PTR _me$[ebp]
	call	?SetItemFlags@C_ListBox@@QAEXJJ@Z	; C_ListBox::SetItemFlags

; 1083 : 			((C_ListBox*)me)->SetItemFlags(vt_destroy,C_BIT_ENABLED);

	push	2048					; 00000800H
	push	2
	mov	ecx, DWORD PTR _me$[ebp]
	call	?SetItemFlags@C_ListBox@@QAEXJJ@Z	; C_ListBox::SetItemFlags

; 1084 : 			((C_ListBox*)me)->SetItemFlags(vt_attrit,C_BIT_INVISIBLE);

	push	8192					; 00002000H
	push	3
	mov	ecx, DWORD PTR _me$[ebp]
	call	?SetItemFlags@C_ListBox@@QAEXJJ@Z	; C_ListBox::SetItemFlags

; 1085 : 			((C_ListBox*)me)->SetItemFlags(vt_intercept,C_BIT_INVISIBLE);

	push	8192					; 00002000H
	push	4
	mov	ecx, DWORD PTR _me$[ebp]
	call	?SetItemFlags@C_ListBox@@QAEXJJ@Z	; C_ListBox::SetItemFlags
$LN10@VCActionOp:

; 1086 : 			break;
; 1087 : 	}
; 1088 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN12@VCActionOp:
	DD	$LN1@VCActionOp
	DD	$LN1@VCActionOp
	DD	$LN2@VCActionOp
	DD	$LN3@VCActionOp
	DD	$LN1@VCActionOp
?VCActionOpenCB@@YAXPAVC_Base@@@Z ENDP			; VCActionOpenCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\taceng\te_team_victory.cpp
_TEXT	SEGMENT
$T1 = -44						; size = 8
$T2 = -36						; size = 8
_icon$ = -28						; size = 4
tv196 = -24						; size = 4
_vctrl$ = -20						; size = 4
_item$ = -16						; size = 4
_urec$ = -12						; size = 4
_ent$ = -8						; size = 4
_vc$ = -4						; size = 4
_ID$ = 8						; size = 4
_hittype$ = 12						; size = 2
_control$ = 16						; size = 4
?SelectVCTargetCB@@YAXJFPAVC_Base@@@Z PROC		; SelectVCTargetCB

; 973  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 974  : 	C_MapIcon *icon;
; 975  : 	UI_Refresher *urec;
; 976  : 	CampEntity ent;
; 977  : 	C_Victory *vctrl;
; 978  : 	victory_condition *vc;
; 979  : 	TREELIST *item;
; 980  : 
; 981  : 	if(hittype != C_TYPE_LMOUSEUP)

	movsx	eax, WORD PTR _hittype$[ebp]
	cmp	eax, 52					; 00000034H
	je	SHORT $LN15@SelectVCTa

; 982  : 		return;

	jmp	$LN16@SelectVCTa
$LN15@SelectVCTa:

; 983  : 
; 984  : 	icon=(C_MapIcon*)control;

	mov	ecx, DWORD PTR _control$[ebp]
	mov	DWORD PTR _icon$[ebp], ecx

; 985  : 	if(control)

	cmp	DWORD PTR _control$[ebp], 0
	je	$LN16@SelectVCTa

; 986  : 	{
; 987  : 		ID=icon->GetIconID();

	mov	ecx, DWORD PTR _icon$[ebp]
	call	?GetIconID@C_MapIcon@@QAEJXZ		; C_MapIcon::GetIconID
	mov	DWORD PTR _ID$[ebp], eax

; 988  : 		urec=(UI_Refresher*)gGps->Find(ID);

	mov	edx, DWORD PTR _ID$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?gGps@@3PAVGlobalPositioningSystem@@A ; gGps
	call	?Find@GlobalPositioningSystem@@QAEPAXJ@Z ; GlobalPositioningSystem::Find
	mov	DWORD PTR _urec$[ebp], eax

; 989  : 		if(urec)

	cmp	DWORD PTR _urec$[ebp], 0
	je	$LN16@SelectVCTa

; 990  : 		{
; 991  : 			item=gVCTree->GetLastItem();

	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	call	?GetLastItem@C_TreeList@@QAEPAVTREELIST@@XZ ; C_TreeList::GetLastItem
	mov	DWORD PTR _item$[ebp], eax

; 992  : 			if(item)

	cmp	DWORD PTR _item$[ebp], 0
	je	$LN16@SelectVCTa

; 993  : 			{
; 994  : 				vctrl=(C_Victory*)item->Item_;

	mov	eax, DWORD PTR _item$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _vctrl$[ebp], ecx

; 995  : 				if(vctrl)

	cmp	DWORD PTR _vctrl$[ebp], 0
	je	$LN16@SelectVCTa

; 996  : 				{
; 997  : 					vc=(victory_condition*)vctrl->GetPtr();

	mov	ecx, DWORD PTR _vctrl$[ebp]
	call	?GetPtr@C_Victory@@QAEPAXXZ		; C_Victory::GetPtr
	mov	DWORD PTR _vc$[ebp], eax

; 998  : 					if(vc)

	cmp	DWORD PTR _vc$[ebp], 0
	je	$LN16@SelectVCTa

; 999  : 					{
; 1000 : 						ent=(CampEntity)vuDatabase->Find(urec->GetID());

	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _urec$[ebp]
	call	?GetID@UI_Refresher@@QAE?AVVU_ID@@XZ	; UI_Refresher::GetID
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _ent$[ebp], eax

; 1001 : 						if(ent)

	cmp	DWORD PTR _ent$[ebp], 0
	je	$LN16@SelectVCTa

; 1002 : 						{
; 1003 : 							vc->set_vu_id(urec->GetID());

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _urec$[ebp]
	call	?GetID@UI_Refresher@@QAE?AVVU_ID@@XZ	; UI_Refresher::GetID
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?set_vu_id@victory_condition@@QAEXVVU_ID@@@Z ; victory_condition::set_vu_id

; 1004 : 							gMapMgr->AddVC(vc);

	mov	eax, DWORD PTR _vc$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?gMapMgr@@3PAVC_Map@@A	; gMapMgr
	call	?AddVC@C_Map@@QAEPAVMAPICONLIST@@PAVvictory_condition@@@Z ; C_Map::AddVC

; 1005 : 							if(ent->IsObjective())

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+236]
	call	eax
	test	eax, eax
	je	SHORT $LN8@SelectVCTa

; 1006 : 							{
; 1007 : 								if(vc->get_type() == vt_destroy)

	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_type@victory_condition@@QAE?AW4victory_type@@XZ ; victory_condition::get_type
	cmp	eax, 2
	jne	SHORT $LN7@SelectVCTa

; 1008 : 								{
; 1009 : 									SetVCTargetInfo(ent);

	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	?SetVCTargetInfo@@YAXPAVCampBaseClass@@@Z ; SetVCTargetInfo
	add	esp, 4

; 1010 : 								}
; 1011 : 								else

	jmp	SHORT $LN6@SelectVCTa
$LN7@SelectVCTa:

; 1012 : 								{
; 1013 : 									if(vc->get_type() != vt_occupy && vc->get_type() != vt_degrade)

	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_type@victory_condition@@QAE?AW4victory_type@@XZ ; victory_condition::get_type
	cmp	eax, 1
	je	SHORT $LN5@SelectVCTa
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_type@victory_condition@@QAE?AW4victory_type@@XZ ; victory_condition::get_type
	cmp	eax, 5
	je	SHORT $LN5@SelectVCTa

; 1014 : 									{
; 1015 : 										vc->set_type(vt_degrade);

	push	5
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?set_type@victory_condition@@QAEXW4victory_type@@@Z ; victory_condition::set_type

; 1016 : 										vc->set_tolerance(10);

	push	10					; 0000000aH
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?set_tolerance@victory_condition@@QAEXH@Z ; victory_condition::set_tolerance
$LN5@SelectVCTa:

; 1017 : 									}
; 1018 : 									UpdateVCOptions(vc);

	mov	edx, DWORD PTR _vc$[ebp]
	push	edx
	call	?UpdateVCOptions@@YAXPAVvictory_condition@@@Z ; UpdateVCOptions
	add	esp, 4
$LN6@SelectVCTa:

; 1019 : 								}

	jmp	$LN16@SelectVCTa
$LN8@SelectVCTa:

; 1020 : 							}
; 1021 : 							else if(ent->IsFlight())

	mov	eax, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax
	test	eax, eax
	je	SHORT $LN3@SelectVCTa

; 1022 : 							{
; 1023 : 								vc->set_type(vt_intercept);

	push	4
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?set_type@victory_condition@@QAEXW4victory_type@@@Z ; victory_condition::set_type

; 1024 : 								vc->set_tolerance(min(4,((Flight)ent)->GetTotalVehicles()));

	mov	ecx, DWORD PTR _ent$[ebp]
	call	?GetTotalVehicles@UnitClass@@QAEHXZ	; UnitClass::GetTotalVehicles
	cmp	eax, 4
	jle	SHORT $LN18@SelectVCTa
	mov	DWORD PTR tv196[ebp], 4
	jmp	SHORT $LN19@SelectVCTa
$LN18@SelectVCTa:
	mov	ecx, DWORD PTR _ent$[ebp]
	call	?GetTotalVehicles@UnitClass@@QAEHXZ	; UnitClass::GetTotalVehicles
	mov	DWORD PTR tv196[ebp], eax
$LN19@SelectVCTa:
	mov	ecx, DWORD PTR tv196[ebp]
	push	ecx
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?set_tolerance@victory_condition@@QAEXH@Z ; victory_condition::set_tolerance

; 1025 : 								UpdateVCOptions(vc);

	mov	edx, DWORD PTR _vc$[ebp]
	push	edx
	call	?UpdateVCOptions@@YAXPAVvictory_condition@@@Z ; UpdateVCOptions
	add	esp, 4
	jmp	SHORT $LN16@SelectVCTa
$LN3@SelectVCTa:

; 1026 : 							}
; 1027 : 							else if(ent->IsBattalion())

	mov	eax, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+240]
	call	eax
	test	eax, eax
	je	SHORT $LN16@SelectVCTa

; 1028 : 							{
; 1029 : 								vc->set_type(vt_attrit);

	push	3
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?set_type@victory_condition@@QAEXW4victory_type@@@Z ; victory_condition::set_type

; 1030 : 								vc->set_tolerance(10);

	push	10					; 0000000aH
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?set_tolerance@victory_condition@@QAEXH@Z ; victory_condition::set_tolerance

; 1031 : 								UpdateVCOptions(vc);

	mov	ecx, DWORD PTR _vc$[ebp]
	push	ecx
	call	?UpdateVCOptions@@YAXPAVvictory_condition@@@Z ; UpdateVCOptions
	add	esp, 4
$LN16@SelectVCTa:

; 1032 : 							}
; 1033 : 						}
; 1034 : 					}
; 1035 : 				}
; 1036 : 			}
; 1037 : 		}
; 1038 : 	}
; 1039 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SelectVCTargetCB@@YAXJFPAVC_Base@@@Z ENDP		; SelectVCTargetCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\taceng\te_team_victory.cpp
_TEXT	SEGMENT
$T1 = -56						; size = 8
$T2 = -48						; size = 8
$T3 = -40						; size = 8
tv175 = -32						; size = 4
tv174 = -28						; size = 4
tv151 = -24						; size = 4
_win$4 = -20						; size = 4
_vctrl$ = -16						; size = 4
_item$ = -12						; size = 4
_btn$5 = -8						; size = 4
_vc$ = -4						; size = 4
_ent$ = 8						; size = 4
?SetVCTargetInfo@@YAXPAVCampBaseClass@@@Z PROC		; SetVCTargetInfo

; 893  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H

; 894  : 	TREELIST *item;
; 895  : 	C_Victory *vctrl;
; 896  : 	victory_condition *vc;
; 897  : 
; 898  : 	if(!gVCTree)

	cmp	DWORD PTR ?gVCTree@@3PAVC_TreeList@@A, 0 ; gVCTree
	jne	SHORT $LN17@SetVCTarge

; 899  : 		return;

	jmp	$LN18@SetVCTarge
$LN17@SetVCTarge:

; 900  : 
; 901  : 	if(ent->IsFlight())

	mov	eax, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax
	test	eax, eax
	je	$LN16@SetVCTarge

; 902  : 	{
; 903  : 		item=gVCTree->GetLastItem();

	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	call	?GetLastItem@C_TreeList@@QAEPAVTREELIST@@XZ ; C_TreeList::GetLastItem
	mov	DWORD PTR _item$[ebp], eax

; 904  : 		if(item)

	cmp	DWORD PTR _item$[ebp], 0
	je	$LN15@SetVCTarge

; 905  : 		{
; 906  : 			vctrl=(C_Victory*)item->Item_;

	mov	ecx, DWORD PTR _item$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _vctrl$[ebp], edx

; 907  : 			if(vctrl)

	cmp	DWORD PTR _vctrl$[ebp], 0
	je	$LN15@SetVCTarge

; 908  : 			{
; 909  : 				vc=(victory_condition*)vctrl->GetPtr();

	mov	ecx, DWORD PTR _vctrl$[ebp]
	call	?GetPtr@C_Victory@@QAEPAXXZ		; C_Victory::GetPtr
	mov	DWORD PTR _vc$[ebp], eax

; 910  : 				if(vc)

	cmp	DWORD PTR _vc$[ebp], 0
	je	$LN15@SetVCTarge

; 911  : 				{
; 912  : 					vc->set_vu_id(ent->Id());

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?set_vu_id@victory_condition@@QAEXVVU_ID@@@Z ; victory_condition::set_vu_id

; 913  : 					vc->set_type(vt_intercept);

	push	4
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?set_type@victory_condition@@QAEXW4victory_type@@@Z ; victory_condition::set_type

; 914  : 					vc->set_tolerance(max(1,min(4,((Flight)ent)->GetTotalVehicles())));

	mov	ecx, DWORD PTR _ent$[ebp]
	call	?GetTotalVehicles@UnitClass@@QAEHXZ	; UnitClass::GetTotalVehicles
	cmp	eax, 4
	jle	SHORT $LN20@SetVCTarge
	mov	DWORD PTR tv151[ebp], 4
	jmp	SHORT $LN21@SetVCTarge
$LN20@SetVCTarge:
	mov	ecx, DWORD PTR _ent$[ebp]
	call	?GetTotalVehicles@UnitClass@@QAEHXZ	; UnitClass::GetTotalVehicles
	mov	DWORD PTR tv151[ebp], eax
$LN21@SetVCTarge:
	cmp	DWORD PTR tv151[ebp], 1
	jge	SHORT $LN24@SetVCTarge
	mov	DWORD PTR tv175[ebp], 1
	jmp	SHORT $LN25@SetVCTarge
$LN24@SetVCTarge:
	mov	ecx, DWORD PTR _ent$[ebp]
	call	?GetTotalVehicles@UnitClass@@QAEHXZ	; UnitClass::GetTotalVehicles
	cmp	eax, 4
	jle	SHORT $LN22@SetVCTarge
	mov	DWORD PTR tv174[ebp], 4
	jmp	SHORT $LN23@SetVCTarge
$LN22@SetVCTarge:
	mov	ecx, DWORD PTR _ent$[ebp]
	call	?GetTotalVehicles@UnitClass@@QAEHXZ	; UnitClass::GetTotalVehicles
	mov	DWORD PTR tv174[ebp], eax
$LN23@SetVCTarge:
	mov	eax, DWORD PTR tv174[ebp]
	mov	DWORD PTR tv175[ebp], eax
$LN25@SetVCTarge:
	mov	ecx, DWORD PTR tv175[ebp]
	push	ecx
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?set_tolerance@victory_condition@@QAEXH@Z ; victory_condition::set_tolerance

; 915  : 					gMapMgr->AddVC(vc);

	mov	edx, DWORD PTR _vc$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?gMapMgr@@3PAVC_Map@@A	; gMapMgr
	call	?AddVC@C_Map@@QAEPAVMAPICONLIST@@PAVvictory_condition@@@Z ; C_Map::AddVC

; 916  : 					UpdateVCOptions(vc);

	mov	eax, DWORD PTR _vc$[ebp]
	push	eax
	call	?UpdateVCOptions@@YAXPAVvictory_condition@@@Z ; UpdateVCOptions
	add	esp, 4
$LN15@SetVCTarge:

; 917  : 				}
; 918  : 			}
; 919  : 		}
; 920  : 	}

	jmp	$LN18@SetVCTarge
$LN16@SetVCTarge:

; 921  : 	else if(ent->IsObjective())

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+236]
	call	eax
	test	eax, eax
	je	$LN11@SetVCTarge

; 922  : 	{
; 923  : 		C_Window *win;
; 924  : 		C_Base *btn;
; 925  : 
; 926  : 		SetCursor(gCursors[CRSR_WAIT]);

	mov	ecx, 4
	imul	ecx, 19					; 00000013H
	mov	edx, DWORD PTR ?gCursors@@3PAPAUHICON__@@A[ecx]
	push	edx
	call	DWORD PTR __imp__SetCursor@4

; 927  : 
; 928  : 		win=gMainHandler->FindWindow(RECON_LIST_WIN);

	push	18351					; 000047afH
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z ; C_Handler::FindWindowA
	mov	DWORD PTR _win$4[ebp], eax

; 929  : 		if(win)

	cmp	DWORD PTR _win$4[ebp], 0
	je	$LN10@SetVCTarge

; 930  : 		{
; 931  : 			if(TargetTree)

	cmp	DWORD PTR ?TargetTree@@3PAVC_TreeList@@A, 0 ; TargetTree
	je	SHORT $LN9@SetVCTarge

; 932  : 				TargetTree->DeleteBranch(TargetTree->GetRoot());

	mov	ecx, DWORD PTR ?TargetTree@@3PAVC_TreeList@@A ; TargetTree
	call	?GetRoot@C_TreeList@@QAEPAVTREELIST@@XZ	; C_TreeList::GetRoot
	push	eax
	mov	ecx, DWORD PTR ?TargetTree@@3PAVC_TreeList@@A ; TargetTree
	call	?DeleteBranch@C_TreeList@@QAEXPAVTREELIST@@@Z ; C_TreeList::DeleteBranch
$LN9@SetVCTarge:

; 933  : 
; 934  : 			if(!OldReconCWCB)

	cmp	DWORD PTR ?OldReconCWCB@@3P6AXJFPAVC_Base@@@ZA, 0 ; OldReconCWCB
	jne	SHORT $LN8@SetVCTarge

; 935  : 			{
; 936  : 				btn=win->FindControl(CLOSE_WINDOW);

	push	80001					; 00013881H
	mov	ecx, DWORD PTR _win$4[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _btn$5[ebp], eax

; 937  : 				if(btn)

	cmp	DWORD PTR _btn$5[ebp], 0
	je	SHORT $LN8@SetVCTarge

; 938  : 				{
; 939  : 					OldReconCWCB=btn->GetCallback();

	mov	eax, DWORD PTR _btn$5[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _btn$5[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	mov	DWORD PTR ?OldReconCWCB@@3P6AXJFPAVC_Base@@@ZA, eax ; OldReconCWCB

; 940  : 					btn->SetCallback(TgtAssignCWCB);

	push	OFFSET ?TgtAssignCWCB@@YAXJFPAVC_Base@@@Z ; TgtAssignCWCB
	mov	ecx, DWORD PTR _btn$5[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$5[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN8@SetVCTarge:

; 941  : 				}
; 942  : 			}
; 943  : 			btn=win->FindControl(SET_VC);

	push	18354					; 000047b2H
	mov	ecx, DWORD PTR _win$4[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _btn$5[ebp], eax

; 944  : 			if(btn)

	cmp	DWORD PTR _btn$5[ebp], 0
	je	SHORT $LN6@SetVCTarge

; 945  : 				btn->SetFlagBitOff(C_BIT_INVISIBLE);

	push	8192					; 00002000H
	mov	ecx, DWORD PTR _btn$5[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$5[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
$LN6@SetVCTarge:

; 946  : 			btn->Refresh();

	mov	ecx, DWORD PTR _btn$5[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$5[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax

; 947  : 			BuildSpecificTargetList(ent->Id());

	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _ent$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?BuildSpecificTargetList@@YAXVVU_ID@@@Z	; BuildSpecificTargetList
	add	esp, 8
$LN10@SetVCTarge:

; 948  : 		}
; 949  : 	}

	jmp	$LN18@SetVCTarge
$LN11@SetVCTarge:

; 950  : 	else if(ent->IsBattalion())

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+240]
	call	eax
	test	eax, eax
	je	SHORT $LN18@SetVCTarge

; 951  : 	{
; 952  : 		item=gVCTree->GetLastItem();

	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	call	?GetLastItem@C_TreeList@@QAEPAVTREELIST@@XZ ; C_TreeList::GetLastItem
	mov	DWORD PTR _item$[ebp], eax

; 953  : 		if(item)

	cmp	DWORD PTR _item$[ebp], 0
	je	SHORT $LN18@SetVCTarge

; 954  : 		{
; 955  : 			vctrl=(C_Victory*)item->Item_;

	mov	ecx, DWORD PTR _item$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _vctrl$[ebp], edx

; 956  : 			if(vctrl)

	cmp	DWORD PTR _vctrl$[ebp], 0
	je	SHORT $LN18@SetVCTarge

; 957  : 			{
; 958  : 				vc=(victory_condition*)vctrl->GetPtr();

	mov	ecx, DWORD PTR _vctrl$[ebp]
	call	?GetPtr@C_Victory@@QAEPAXXZ		; C_Victory::GetPtr
	mov	DWORD PTR _vc$[ebp], eax

; 959  : 				if(vc)

	cmp	DWORD PTR _vc$[ebp], 0
	je	SHORT $LN18@SetVCTarge

; 960  : 				{
; 961  : 					vc->set_vu_id(ent->Id());

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?set_vu_id@victory_condition@@QAEXVVU_ID@@@Z ; victory_condition::set_vu_id

; 962  : 					vc->set_type(vt_attrit);

	push	3
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?set_type@victory_condition@@QAEXW4victory_type@@@Z ; victory_condition::set_type

; 963  : 					vc->set_tolerance(10);

	push	10					; 0000000aH
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?set_tolerance@victory_condition@@QAEXH@Z ; victory_condition::set_tolerance

; 964  : 					gMapMgr->AddVC(vc);

	mov	eax, DWORD PTR _vc$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?gMapMgr@@3PAVC_Map@@A	; gMapMgr
	call	?AddVC@C_Map@@QAEPAVMAPICONLIST@@PAVvictory_condition@@@Z ; C_Map::AddVC

; 965  : 					UpdateVCOptions(vc);

	mov	ecx, DWORD PTR _vc$[ebp]
	push	ecx
	call	?UpdateVCOptions@@YAXPAVvictory_condition@@@Z ; UpdateVCOptions
	add	esp, 4
$LN18@SetVCTarge:

; 966  : 				}
; 967  : 			}
; 968  : 		}
; 969  : 	}
; 970  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SetVCTargetInfo@@YAXPAVCampBaseClass@@@Z ENDP		; SetVCTargetInfo
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\taceng\te_team_victory.cpp
_TEXT	SEGMENT
_vctrl$ = -12						; size = 4
_item$ = -8						; size = 4
_vc$ = -4						; size = 4
_ID$ = 8						; size = 4
_hittype$ = 12						; size = 2
_control$ = 16						; size = 4
?AssignVCCB@@YAXJFPAVC_Base@@@Z PROC			; AssignVCCB

; 857  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 858  : 	TREELIST *item;
; 859  : 	C_Victory *vctrl;
; 860  : 	victory_condition *vc;
; 861  : 	if(hittype != C_TYPE_LMOUSEUP)

	movsx	eax, WORD PTR _hittype$[ebp]
	cmp	eax, 52					; 00000034H
	je	SHORT $LN6@AssignVCCB

; 862  : 		return;

	jmp	$LN7@AssignVCCB
$LN6@AssignVCCB:

; 863  : 
; 864  : 	CloseReconWindowCB(ID,hittype,control);

	mov	ecx, DWORD PTR _control$[ebp]
	push	ecx
	movzx	edx, WORD PTR _hittype$[ebp]
	push	edx
	mov	eax, DWORD PTR _ID$[ebp]
	push	eax
	call	?CloseReconWindowCB@@YAXJFPAVC_Base@@@Z	; CloseReconWindowCB
	add	esp, 12					; 0000000cH

; 865  : 
; 866  : 	if(FeatureID != FalconNullId && FeatureNo >= 0)

	push	OFFSET ?FalconNullId@@3VVU_ID@@A	; FalconNullId
	mov	ecx, OFFSET ?FeatureID@@3VVU_ID@@A	; FeatureID
	call	??9VU_ID@@QBE_NABV0@@Z			; VU_ID::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	$LN7@AssignVCCB
	cmp	DWORD PTR ?FeatureNo@@3JA, 0		; FeatureNo
	jl	$LN7@AssignVCCB

; 867  : 	{
; 868  : 		if(gVCTree)

	cmp	DWORD PTR ?gVCTree@@3PAVC_TreeList@@A, 0 ; gVCTree
	je	$LN7@AssignVCCB

; 869  : 		{
; 870  : 			item=gVCTree->GetLastItem();

	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	call	?GetLastItem@C_TreeList@@QAEPAVTREELIST@@XZ ; C_TreeList::GetLastItem
	mov	DWORD PTR _item$[ebp], eax

; 871  : 			if(item) // MUST MAKE SURE they didn't switch Items while targetting

	cmp	DWORD PTR _item$[ebp], 0
	je	SHORT $LN7@AssignVCCB

; 872  : 			{
; 873  : 				vctrl=(C_Victory*)item->Item_;

	mov	edx, DWORD PTR _item$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR _vctrl$[ebp], eax

; 874  : 				if(vctrl)

	cmp	DWORD PTR _vctrl$[ebp], 0
	je	SHORT $LN7@AssignVCCB

; 875  : 				{
; 876  : 					vc=(victory_condition*)vctrl->GetPtr();

	mov	ecx, DWORD PTR _vctrl$[ebp]
	call	?GetPtr@C_Victory@@QAEPAXXZ		; C_Victory::GetPtr
	mov	DWORD PTR _vc$[ebp], eax

; 877  : 					if(vc)

	cmp	DWORD PTR _vc$[ebp], 0
	je	SHORT $LN7@AssignVCCB

; 878  : 					{
; 879  : 						vc->set_vu_id(FeatureID);

	mov	ecx, DWORD PTR ?FeatureID@@3VVU_ID@@A+4
	push	ecx
	mov	edx, DWORD PTR ?FeatureID@@3VVU_ID@@A
	push	edx
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?set_vu_id@victory_condition@@QAEXVVU_ID@@@Z ; victory_condition::set_vu_id

; 880  : 						vc->set_sub_objective(FeatureNo);

	mov	eax, DWORD PTR ?FeatureNo@@3JA		; FeatureNo
	push	eax
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?set_sub_objective@victory_condition@@QAEXH@Z ; victory_condition::set_sub_objective

; 881  : 						gMapMgr->AddVC(vc);

	mov	ecx, DWORD PTR _vc$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?gMapMgr@@3PAVC_Map@@A	; gMapMgr
	call	?AddVC@C_Map@@QAEPAVMAPICONLIST@@PAVvictory_condition@@@Z ; C_Map::AddVC

; 882  : 						UpdateVCOptions(vc); // sets valid list box stuff etc

	mov	edx, DWORD PTR _vc$[ebp]
	push	edx
	call	?UpdateVCOptions@@YAXPAVvictory_condition@@@Z ; UpdateVCOptions
	add	esp, 4

; 883  : 						// Clear TOOL stuff
; 884  : 						SelectToolTypeCB(0,C_TYPE_LMOUSEUP,NULL);

	push	0
	push	52					; 00000034H
	push	0
	call	?SelectToolTypeCB@@YAXJFPAVC_Base@@@Z	; SelectToolTypeCB
	add	esp, 12					; 0000000cH
$LN7@AssignVCCB:

; 885  : 					}
; 886  : 				}
; 887  : 			}
; 888  : 		}
; 889  : 	}
; 890  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AssignVCCB@@YAXJFPAVC_Base@@@Z ENDP			; AssignVCCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\taceng\te_team_victory.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_hittype$ = 12						; size = 2
___formal$ = 16						; size = 4
?VCSelectVCCB@@YAXJFPAVC_Base@@@Z PROC			; VCSelectVCCB

; 847  : {

	push	ebp
	mov	ebp, esp

; 848  : 	if(hittype != C_TYPE_LMOUSEUP)

	movsx	eax, WORD PTR _hittype$[ebp]
	cmp	eax, 52					; 00000034H
	je	SHORT $LN2@VCSelectVC

; 849  : 		return;

	jmp	SHORT $LN3@VCSelectVC
$LN2@VCSelectVC:

; 850  : 
; 851  : 	if(gVCTree)

	cmp	DWORD PTR ?gVCTree@@3PAVC_TreeList@@A, 0 ; gVCTree
	je	SHORT $LN1@VCSelectVC

; 852  : 		gVCTree->SetAllControlStates(0,gVCTree->GetRoot());

	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	call	?GetRoot@C_TreeList@@QAEPAVTREELIST@@XZ	; C_TreeList::GetRoot
	push	eax
	push	0
	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	call	?SetAllControlStates@C_TreeList@@QAEXFPAVTREELIST@@@Z ; C_TreeList::SetAllControlStates
$LN1@VCSelectVC:

; 853  : 	SelectToolTypeCB(0,C_TYPE_LMOUSEUP,NULL);

	push	0
	push	52					; 00000034H
	push	0
	call	?SelectToolTypeCB@@YAXJFPAVC_Base@@@Z	; SelectToolTypeCB
	add	esp, 12					; 0000000cH
$LN3@VCSelectVC:

; 854  : }

	pop	ebp
	ret	0
?VCSelectVCCB@@YAXJFPAVC_Base@@@Z ENDP			; VCSelectVCCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\taceng\te_team_victory.cpp
_TEXT	SEGMENT
_vctrl$ = -12						; size = 4
_vc$ = -8						; size = 4
_item$ = -4						; size = 4
___formal$ = 8						; size = 4
_hittype$ = 12						; size = 2
_control$ = 16						; size = 4
?VCSetPointsCB@@YAXJFPAVC_Base@@@Z PROC			; VCSetPointsCB

; 825  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 826  : 	victory_condition *vc;
; 827  : 	C_Victory *vctrl;
; 828  : 	TREELIST *item;
; 829  : 
; 830  : 	if(hittype && hittype != DIK_RETURN)

	movsx	eax, WORD PTR _hittype$[ebp]
	test	eax, eax
	je	SHORT $LN3@VCSetPoint
	movsx	ecx, WORD PTR _hittype$[ebp]
	cmp	ecx, 28					; 0000001cH
	je	SHORT $LN3@VCSetPoint

; 831  : 		return;

	jmp	SHORT $LN4@VCSetPoint
$LN3@VCSetPoint:

; 832  : 
; 833  : 	item=gVCTree->GetLastItem();

	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	call	?GetLastItem@C_TreeList@@QAEPAVTREELIST@@XZ ; C_TreeList::GetLastItem
	mov	DWORD PTR _item$[ebp], eax

; 834  : 	if(item && item->Item_)

	cmp	DWORD PTR _item$[ebp], 0
	je	SHORT $LN2@VCSetPoint
	mov	edx, DWORD PTR _item$[ebp]
	cmp	DWORD PTR [edx+20], 0
	je	SHORT $LN2@VCSetPoint

; 835  : 	{
; 836  : 		vctrl=(C_Victory*)item->Item_;

	mov	eax, DWORD PTR _item$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _vctrl$[ebp], ecx

; 837  : 		vc=(victory_condition*)vctrl->GetPtr();

	mov	ecx, DWORD PTR _vctrl$[ebp]
	call	?GetPtr@C_Victory@@QAEPAXXZ		; C_Victory::GetPtr
	mov	DWORD PTR _vc$[ebp], eax

; 838  : 		if(vc)

	cmp	DWORD PTR _vc$[ebp], 0
	je	SHORT $LN2@VCSetPoint

; 839  : 		{
; 840  : 			vc->set_points(((C_EditBox*)control)->GetInteger());

	mov	ecx, DWORD PTR _control$[ebp]
	call	?GetInteger@C_EditBox@@QAEJXZ		; C_EditBox::GetInteger
	push	eax
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?set_points@victory_condition@@QAEXH@Z	; victory_condition::set_points
$LN2@VCSetPoint:

; 841  : 		}
; 842  : 	}
; 843  : 	update_team_victory_window ();

	call	?update_team_victory_window@@YAXXZ	; update_team_victory_window
$LN4@VCSetPoint:

; 844  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?VCSetPointsCB@@YAXJFPAVC_Base@@@Z ENDP			; VCSetPointsCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\taceng\te_team_victory.cpp
_TEXT	SEGMENT
_vc$ = -12						; size = 4
_vctrl$ = -8						; size = 4
_item$ = -4						; size = 4
___formal$ = 8						; size = 4
_hittype$ = 12						; size = 2
___formal$ = 16						; size = 4
?VCArgsCB@@YAXJFPAVC_Base@@@Z PROC			; VCArgsCB

; 803  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 804  : 	victory_condition *vc;
; 805  : 	C_Victory *vctrl;
; 806  : 	TREELIST *item;
; 807  : 
; 808  : 	if(hittype != C_TYPE_SELECT)

	movsx	eax, WORD PTR _hittype$[ebp]
	cmp	eax, 28					; 0000001cH
	je	SHORT $LN3@VCArgsCB

; 809  : 		return;

	jmp	SHORT $LN4@VCArgsCB
$LN3@VCArgsCB:

; 810  : 
; 811  : 	item=gVCTree->GetLastItem();

	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	call	?GetLastItem@C_TreeList@@QAEPAVTREELIST@@XZ ; C_TreeList::GetLastItem
	mov	DWORD PTR _item$[ebp], eax

; 812  : 	if(item && item->Item_)

	cmp	DWORD PTR _item$[ebp], 0
	je	SHORT $LN4@VCArgsCB
	mov	ecx, DWORD PTR _item$[ebp]
	cmp	DWORD PTR [ecx+20], 0
	je	SHORT $LN4@VCArgsCB

; 813  : 	{
; 814  : 		vctrl=(C_Victory*)item->Item_;

	mov	edx, DWORD PTR _item$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR _vctrl$[ebp], eax

; 815  : 		vc=(victory_condition*)vctrl->GetPtr();

	mov	ecx, DWORD PTR _vctrl$[ebp]
	call	?GetPtr@C_Victory@@QAEPAXXZ		; C_Victory::GetPtr
	mov	DWORD PTR _vc$[ebp], eax

; 816  : 		if(vc)

	cmp	DWORD PTR _vc$[ebp], 0
	je	SHORT $LN4@VCArgsCB

; 817  : 		{
; 818  : 			vc->set_tolerance(vctrl->GetArgs()->GetTextID());

	mov	ecx, DWORD PTR _vctrl$[ebp]
	call	?GetArgs@C_Victory@@QAEPAVC_ListBox@@XZ	; C_Victory::GetArgs
	mov	ecx, eax
	call	?GetTextID@C_ListBox@@QAEJXZ		; C_ListBox::GetTextID
	push	eax
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?set_tolerance@victory_condition@@QAEXH@Z ; victory_condition::set_tolerance
$LN4@VCArgsCB:

; 819  : 		}
; 820  : 	}
; 821  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?VCArgsCB@@YAXJFPAVC_Base@@@Z ENDP			; VCArgsCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\taceng\te_team_victory.cpp
_TEXT	SEGMENT
$T1 = -28						; size = 8
_vctrl$ = -20						; size = 4
_vc$ = -16						; size = 4
_win$ = -12						; size = 4
_item$ = -8						; size = 4
_btn$ = -4						; size = 4
___formal$ = 8						; size = 4
_hittype$ = 12						; size = 2
_control$ = 16						; size = 4
?VCSetTargetCB@@YAXJFPAVC_Base@@@Z PROC			; VCSetTargetCB

; 756  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 757  : 	victory_condition *vc;
; 758  : 	C_Victory *vctrl;
; 759  : 	TREELIST *item;
; 760  : 	C_Window *win;
; 761  : 	C_Base *btn;
; 762  : 
; 763  : 	if(hittype != C_TYPE_LMOUSEUP)

	movsx	eax, WORD PTR _hittype$[ebp]
	cmp	eax, 52					; 00000034H
	je	SHORT $LN8@VCSetTarge

; 764  : 		return;

	jmp	$LN9@VCSetTarge
$LN8@VCSetTarge:

; 765  : 
; 766  : 	if(control && control->GetUserNumber(10))

	cmp	DWORD PTR _control$[ebp], 0
	je	$LN7@VCSetTarge
	push	10					; 0000000aH
	mov	ecx, DWORD PTR _control$[ebp]
	call	?GetUserNumber@C_Base@@QAEJJ@Z		; C_Base::GetUserNumber
	test	eax, eax
	je	$LN7@VCSetTarge

; 767  : 	{
; 768  : 		SetCursor(gCursors[CRSR_WAIT]);

	mov	ecx, 4
	imul	ecx, 19					; 00000013H
	mov	edx, DWORD PTR ?gCursors@@3PAPAUHICON__@@A[ecx]
	push	edx
	call	DWORD PTR __imp__SetCursor@4

; 769  : 
; 770  : 		item=gVCTree->GetLastItem();

	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	call	?GetLastItem@C_TreeList@@QAEPAVTREELIST@@XZ ; C_TreeList::GetLastItem
	mov	DWORD PTR _item$[ebp], eax

; 771  : 		if(item && item->Item_)

	cmp	DWORD PTR _item$[ebp], 0
	je	$LN7@VCSetTarge
	mov	eax, DWORD PTR _item$[ebp]
	cmp	DWORD PTR [eax+20], 0
	je	$LN7@VCSetTarge

; 772  : 		{
; 773  : 			vctrl=(C_Victory*)item->Item_;

	mov	ecx, DWORD PTR _item$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _vctrl$[ebp], edx

; 774  : 			vc=(victory_condition*)vctrl->GetPtr();

	mov	ecx, DWORD PTR _vctrl$[ebp]
	call	?GetPtr@C_Victory@@QAEPAXXZ		; C_Victory::GetPtr
	mov	DWORD PTR _vc$[ebp], eax

; 775  : 			win=gMainHandler->FindWindow(RECON_LIST_WIN);

	push	18351					; 000047afH
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z ; C_Handler::FindWindowA
	mov	DWORD PTR _win$[ebp], eax

; 776  : 			if(win && vc)

	cmp	DWORD PTR _win$[ebp], 0
	je	$LN7@VCSetTarge
	cmp	DWORD PTR _vc$[ebp], 0
	je	$LN7@VCSetTarge

; 777  : 			{
; 778  : 				if(TargetTree)

	cmp	DWORD PTR ?TargetTree@@3PAVC_TreeList@@A, 0 ; TargetTree
	je	SHORT $LN4@VCSetTarge

; 779  : 					TargetTree->DeleteBranch(TargetTree->GetRoot());

	mov	ecx, DWORD PTR ?TargetTree@@3PAVC_TreeList@@A ; TargetTree
	call	?GetRoot@C_TreeList@@QAEPAVTREELIST@@XZ	; C_TreeList::GetRoot
	push	eax
	mov	ecx, DWORD PTR ?TargetTree@@3PAVC_TreeList@@A ; TargetTree
	call	?DeleteBranch@C_TreeList@@QAEXPAVTREELIST@@@Z ; C_TreeList::DeleteBranch
$LN4@VCSetTarge:

; 780  : 
; 781  : 				if(!OldReconCWCB)

	cmp	DWORD PTR ?OldReconCWCB@@3P6AXJFPAVC_Base@@@ZA, 0 ; OldReconCWCB
	jne	SHORT $LN3@VCSetTarge

; 782  : 				{
; 783  : 					btn=win->FindControl(CLOSE_WINDOW);

	push	80001					; 00013881H
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _btn$[ebp], eax

; 784  : 					if(btn)

	cmp	DWORD PTR _btn$[ebp], 0
	je	SHORT $LN3@VCSetTarge

; 785  : 					{
; 786  : 						OldReconCWCB=btn->GetCallback();

	mov	eax, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	mov	DWORD PTR ?OldReconCWCB@@3P6AXJFPAVC_Base@@@ZA, eax ; OldReconCWCB

; 787  : 						btn->SetCallback(TgtAssignCWCB);

	push	OFFSET ?TgtAssignCWCB@@YAXJFPAVC_Base@@@Z ; TgtAssignCWCB
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN3@VCSetTarge:

; 788  : 					}
; 789  : 				}
; 790  : 				btn=win->FindControl(SET_VC);

	push	18354					; 000047b2H
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _btn$[ebp], eax

; 791  : 				if(btn)

	cmp	DWORD PTR _btn$[ebp], 0
	je	SHORT $LN1@VCSetTarge

; 792  : 					btn->SetFlagBitOff(C_BIT_INVISIBLE);

	push	8192					; 00002000H
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
$LN1@VCSetTarge:

; 793  : 				btn->Refresh();

	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax

; 794  : 				BuildSpecificTargetList(vc->get_vu_id());

	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_vu_id@victory_condition@@QAE?AVVU_ID@@XZ ; victory_condition::get_vu_id
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?BuildSpecificTargetList@@YAXVVU_ID@@@Z	; BuildSpecificTargetList
	add	esp, 8
$LN7@VCSetTarge:

; 795  : 			}
; 796  : 		}
; 797  : 	}
; 798  : 	SelectToolTypeCB(TARGET_VC,hittype,control);

	mov	ecx, DWORD PTR _control$[ebp]
	push	ecx
	movzx	edx, WORD PTR _hittype$[ebp]
	push	edx
	push	3
	call	?SelectToolTypeCB@@YAXJFPAVC_Base@@@Z	; SelectToolTypeCB
	add	esp, 12					; 0000000cH
$LN9@VCSetTarge:

; 799  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?VCSetTargetCB@@YAXJFPAVC_Base@@@Z ENDP			; VCSetTargetCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\taceng\te_team_victory.cpp
_TEXT	SEGMENT
$T1 = -28						; size = 8
_vctrl$ = -20						; size = 4
_win$2 = -16						; size = 4
_item$ = -12						; size = 4
_vc$ = -8						; size = 4
_btn$3 = -4						; size = 4
___formal$ = 8						; size = 4
_hittype$ = 12						; size = 2
_control$ = 16						; size = 4
?VCChangeActionCB@@YAXJFPAVC_Base@@@Z PROC		; VCChangeActionCB

; 700  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 701  : 	victory_condition *vc;
; 702  : 	C_Victory *vctrl;
; 703  : 	TREELIST *item;
; 704  : 
; 705  : 	if(hittype != C_TYPE_SELECT)

	movsx	eax, WORD PTR _hittype$[ebp]
	cmp	eax, 28					; 0000001cH
	je	SHORT $LN11@VCChangeAc

; 706  : 		return;

	jmp	$LN12@VCChangeAc
$LN11@VCChangeAc:

; 707  : 
; 708  : 	item=gVCTree->GetLastItem();

	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	call	?GetLastItem@C_TreeList@@QAEPAVTREELIST@@XZ ; C_TreeList::GetLastItem
	mov	DWORD PTR _item$[ebp], eax

; 709  : 	if(item && item->Item_)

	cmp	DWORD PTR _item$[ebp], 0
	je	$LN12@VCChangeAc
	mov	ecx, DWORD PTR _item$[ebp]
	cmp	DWORD PTR [ecx+20], 0
	je	$LN12@VCChangeAc

; 710  : 	{
; 711  : 		vctrl=(C_Victory*)item->Item_;

	mov	edx, DWORD PTR _item$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR _vctrl$[ebp], eax

; 712  : 		vc=(victory_condition*)vctrl->GetPtr();

	mov	ecx, DWORD PTR _vctrl$[ebp]
	call	?GetPtr@C_Victory@@QAEPAXXZ		; C_Victory::GetPtr
	mov	DWORD PTR _vc$[ebp], eax

; 713  : 		if(vc)

	cmp	DWORD PTR _vc$[ebp], 0
	je	$LN12@VCChangeAc

; 714  : 		{
; 715  : 			vc->set_type((victory_type)((C_ListBox*)control)->GetTextID());

	mov	ecx, DWORD PTR _control$[ebp]
	call	?GetTextID@C_ListBox@@QAEJXZ		; C_ListBox::GetTextID
	push	eax
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?set_type@victory_condition@@QAEXW4victory_type@@@Z ; victory_condition::set_type

; 716  : 			UpdateVCOptions(vc);

	mov	ecx, DWORD PTR _vc$[ebp]
	push	ecx
	call	?UpdateVCOptions@@YAXPAVvictory_condition@@@Z ; UpdateVCOptions
	add	esp, 4

; 717  : 			if(vc->get_type() == vt_destroy && vc->get_sub_objective() < 0)

	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_type@victory_condition@@QAE?AW4victory_type@@XZ ; victory_condition::get_type
	cmp	eax, 2
	jne	$LN8@VCChangeAc
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_sub_objective@victory_condition@@QAEHXZ ; victory_condition::get_sub_objective
	test	eax, eax
	jge	$LN8@VCChangeAc

; 718  : 			{
; 719  : 				// we need to target a building
; 720  : 				C_Window *win;
; 721  : 				C_Base *btn;
; 722  : 
; 723  : 				SetCursor(gCursors[CRSR_WAIT]);

	mov	edx, 4
	imul	edx, 19					; 00000013H
	mov	eax, DWORD PTR ?gCursors@@3PAPAUHICON__@@A[edx]
	push	eax
	call	DWORD PTR __imp__SetCursor@4

; 724  : 
; 725  : 				win=gMainHandler->FindWindow(RECON_LIST_WIN);

	push	18351					; 000047afH
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z ; C_Handler::FindWindowA
	mov	DWORD PTR _win$2[ebp], eax

; 726  : 				if(win)

	cmp	DWORD PTR _win$2[ebp], 0
	je	$LN7@VCChangeAc

; 727  : 				{
; 728  : 					if(TargetTree)

	cmp	DWORD PTR ?TargetTree@@3PAVC_TreeList@@A, 0 ; TargetTree
	je	SHORT $LN6@VCChangeAc

; 729  : 						TargetTree->DeleteBranch(TargetTree->GetRoot());

	mov	ecx, DWORD PTR ?TargetTree@@3PAVC_TreeList@@A ; TargetTree
	call	?GetRoot@C_TreeList@@QAEPAVTREELIST@@XZ	; C_TreeList::GetRoot
	push	eax
	mov	ecx, DWORD PTR ?TargetTree@@3PAVC_TreeList@@A ; TargetTree
	call	?DeleteBranch@C_TreeList@@QAEXPAVTREELIST@@@Z ; C_TreeList::DeleteBranch
$LN6@VCChangeAc:

; 730  : 
; 731  : 					if(!OldReconCWCB)

	cmp	DWORD PTR ?OldReconCWCB@@3P6AXJFPAVC_Base@@@ZA, 0 ; OldReconCWCB
	jne	SHORT $LN5@VCChangeAc

; 732  : 					{
; 733  : 						btn=win->FindControl(CLOSE_WINDOW);

	push	80001					; 00013881H
	mov	ecx, DWORD PTR _win$2[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _btn$3[ebp], eax

; 734  : 						if(btn)

	cmp	DWORD PTR _btn$3[ebp], 0
	je	SHORT $LN5@VCChangeAc

; 735  : 						{
; 736  : 							OldReconCWCB=btn->GetCallback();

	mov	ecx, DWORD PTR _btn$3[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$3[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	mov	DWORD PTR ?OldReconCWCB@@3P6AXJFPAVC_Base@@@ZA, eax ; OldReconCWCB

; 737  : 							btn->SetCallback(TgtAssignCWCB);

	push	OFFSET ?TgtAssignCWCB@@YAXJFPAVC_Base@@@Z ; TgtAssignCWCB
	mov	ecx, DWORD PTR _btn$3[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$3[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN5@VCChangeAc:

; 738  : 						}
; 739  : 					}
; 740  : 					btn=win->FindControl(SET_VC);

	push	18354					; 000047b2H
	mov	ecx, DWORD PTR _win$2[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _btn$3[ebp], eax

; 741  : 					if(btn)

	cmp	DWORD PTR _btn$3[ebp], 0
	je	SHORT $LN3@VCChangeAc

; 742  : 						btn->SetFlagBitOff(C_BIT_INVISIBLE);

	push	8192					; 00002000H
	mov	ecx, DWORD PTR _btn$3[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$3[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
$LN3@VCChangeAc:

; 743  : 					btn->Refresh();

	mov	ecx, DWORD PTR _btn$3[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$3[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN7@VCChangeAc:

; 744  : 				}
; 745  : 				SelectToolTypeCB(TARGET_VC,C_TYPE_LMOUSEUP,vctrl);

	mov	ecx, DWORD PTR _vctrl$[ebp]
	push	ecx
	push	52					; 00000034H
	push	3
	call	?SelectToolTypeCB@@YAXJFPAVC_Base@@@Z	; SelectToolTypeCB
	add	esp, 12					; 0000000cH

; 746  : 				BuildSpecificTargetList(vc->get_vu_id());

	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_vu_id@victory_condition@@QAE?AVVU_ID@@XZ ; victory_condition::get_vu_id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?BuildSpecificTargetList@@YAXVVU_ID@@@Z	; BuildSpecificTargetList
	add	esp, 8
	jmp	SHORT $LN12@VCChangeAc
$LN8@VCChangeAc:

; 747  : 			}
; 748  : 			else if(vc->get_type() != vt_destroy)

	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_type@victory_condition@@QAE?AW4victory_type@@XZ ; victory_condition::get_type
	cmp	eax, 2
	je	SHORT $LN12@VCChangeAc

; 749  : 				vc->set_sub_objective(-1);

	push	-1
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?set_sub_objective@victory_condition@@QAEXH@Z ; victory_condition::set_sub_objective
$LN12@VCChangeAc:

; 750  : 		}
; 751  : 	}
; 752  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?VCChangeActionCB@@YAXJFPAVC_Base@@@Z ENDP		; VCChangeActionCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\taceng\te_team_victory.cpp
_TEXT	SEGMENT
_vctrl$ = -12						; size = 4
_item$ = -8						; size = 4
_vc$ = -4						; size = 4
___formal$ = 8						; size = 4
_hittype$ = 12						; size = 2
___formal$ = 16						; size = 4
?VCChangeTeamNoCB@@YAXJFPAVC_Base@@@Z PROC		; VCChangeTeamNoCB

; 672  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi

; 673  : 	victory_condition *vc;
; 674  : 	C_Victory *vctrl;
; 675  : 	TREELIST *item;
; 676  : 
; 677  : 	if(hittype != C_TYPE_SELECT)

	movsx	eax, WORD PTR _hittype$[ebp]
	cmp	eax, 28					; 0000001cH
	je	SHORT $LN4@VCChangeTe

; 678  : 		return;

	jmp	$LN5@VCChangeTe
$LN4@VCChangeTe:

; 679  : 
; 680  : 	item=gVCTree->GetLastItem();

	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	call	?GetLastItem@C_TreeList@@QAEPAVTREELIST@@XZ ; C_TreeList::GetLastItem
	mov	DWORD PTR _item$[ebp], eax

; 681  : 	if(item && item->Item_)

	cmp	DWORD PTR _item$[ebp], 0
	je	$LN3@VCChangeTe
	mov	ecx, DWORD PTR _item$[ebp]
	cmp	DWORD PTR [ecx+20], 0
	je	SHORT $LN3@VCChangeTe

; 682  : 	{
; 683  : 		vctrl=(C_Victory*)item->Item_;

	mov	edx, DWORD PTR _item$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR _vctrl$[ebp], eax

; 684  : 		vc=(victory_condition*)vctrl->GetPtr();

	mov	ecx, DWORD PTR _vctrl$[ebp]
	call	?GetPtr@C_Victory@@QAEPAXXZ		; C_Victory::GetPtr
	mov	DWORD PTR _vc$[ebp], eax

; 685  : 		if(vc)

	cmp	DWORD PTR _vc$[ebp], 0
	je	SHORT $LN3@VCChangeTe

; 686  : 		{
; 687  : 			if(vctrl->GetTeam()->GetTextID() != vc->get_team())

	mov	ecx, DWORD PTR _vctrl$[ebp]
	call	?GetTeam@C_Victory@@QAEPAVC_ListBox@@XZ	; C_Victory::GetTeam
	mov	ecx, eax
	call	?GetTextID@C_ListBox@@QAEJXZ		; C_ListBox::GetTextID
	mov	esi, eax
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_team@victory_condition@@QAEHXZ	; victory_condition::get_team
	cmp	esi, eax
	je	SHORT $LN3@VCChangeTe

; 688  : 			{
; 689  : 				gMapMgr->RemoveVC(vc->get_team(),vc->get_number());

	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_number@victory_condition@@QAEHXZ	; victory_condition::get_number
	push	eax
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_team@victory_condition@@QAEHXZ	; victory_condition::get_team
	push	eax
	mov	ecx, DWORD PTR ?gMapMgr@@3PAVC_Map@@A	; gMapMgr
	call	?RemoveVC@C_Map@@QAEXJJ@Z		; C_Map::RemoveVC

; 690  : 				vc->set_team(vctrl->GetTeam()->GetTextID());

	mov	ecx, DWORD PTR _vctrl$[ebp]
	call	?GetTeam@C_Victory@@QAEPAVC_ListBox@@XZ	; C_Victory::GetTeam
	mov	ecx, eax
	call	?GetTextID@C_ListBox@@QAEJXZ		; C_ListBox::GetTextID
	push	eax
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?set_team@victory_condition@@QAEXH@Z	; victory_condition::set_team

; 691  : 				gMapMgr->AddVC(vc);

	mov	ecx, DWORD PTR _vc$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?gMapMgr@@3PAVC_Map@@A	; gMapMgr
	call	?AddVC@C_Map@@QAEPAVMAPICONLIST@@PAVvictory_condition@@@Z ; C_Map::AddVC
$LN3@VCChangeTe:

; 692  : 			}
; 693  : 		}
; 694  : 	}
; 695  : 	update_team_victory_window ();

	call	?update_team_victory_window@@YAXXZ	; update_team_victory_window
$LN5@VCChangeTe:

; 696  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?VCChangeTeamNoCB@@YAXJFPAVC_Base@@@Z ENDP		; VCChangeTeamNoCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\taceng\te_team_victory.cpp
_TEXT	SEGMENT
$T1 = -140						; size = 8
_classID$ = -132					; size = 4
tv404 = -128						; size = 4
tv429 = -124						; size = 4
tv499 = -120						; size = 4
tv430 = -116						; size = 4
tv486 = -112						; size = 4
tv422 = -108						; size = 4
tv485 = -104						; size = 4
tv411 = -100						; size = 4
tv478 = -96						; size = 4
tv412 = -92						; size = 4
_fc$ = -88						; size = 4
tv377 = -84						; size = 4
_i$ = -80						; size = 4
_vctrl$ = -76						; size = 4
_ent$ = -72						; size = 4
_lbox$ = -68						; size = 4
_buffer$ = -64						; size = 60
__$ArrayPad$ = -4					; size = 4
_vc$ = 8						; size = 4
?UpdateVCOptions@@YAXPAVvictory_condition@@@Z PROC	; UpdateVCOptions

; 528  : { // Handles changing targets etc...

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 529  : 	C_Victory *vctrl;
; 530  : 	C_ListBox *lbox;
; 531  : 	CampEntity ent;
; 532  : 	_TCHAR buffer[60];
; 533  : 	FeatureClassDataType *fc;
; 534  : 	long classID,i;
; 535  : 
; 536  : 	if(!vc)

	cmp	DWORD PTR _vc$[ebp], 0
	jne	SHORT $LN43@UpdateVCOp

; 537  : 		return;

	jmp	$LN44@UpdateVCOp
$LN43@UpdateVCOp:

; 538  : 
; 539  : 	vctrl=(C_Victory*)vc->control;

	mov	eax, DWORD PTR _vc$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	DWORD PTR _vctrl$[ebp], ecx

; 540  : 	if(!vctrl || !vctrl->Parent_)

	cmp	DWORD PTR _vctrl$[ebp], 0
	je	SHORT $LN41@UpdateVCOp
	mov	edx, DWORD PTR _vctrl$[ebp]
	cmp	DWORD PTR [edx+48], 0
	jne	SHORT $LN42@UpdateVCOp
$LN41@UpdateVCOp:

; 541  : 		return;

	jmp	$LN44@UpdateVCOp
$LN42@UpdateVCOp:

; 542  : 
; 543  : 	ent=(CampEntity)vuDatabase->Find(vc->get_vu_id());

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_vu_id@victory_condition@@QAE?AVVU_ID@@XZ ; victory_condition::get_vu_id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _ent$[ebp], eax

; 544  : 	if(ent)

	cmp	DWORD PTR _ent$[ebp], 0
	je	$LN44@UpdateVCOp

; 545  : 	{
; 546  : 		// Set location... on Map...
; 547  : 		gMapMgr->UpdateVC(vc);

	mov	eax, DWORD PTR _vc$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?gMapMgr@@3PAVC_Map@@A	; gMapMgr
	call	?UpdateVC@C_Map@@QAEXPAVvictory_condition@@@Z ; C_Map::UpdateVC

; 548  : 
; 549  : 		if (ent->IsFlight())

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax
	test	eax, eax
	je	SHORT $LN39@UpdateVCOp

; 550  : 			GetCallsign (((Flight)ent)->callsign_id, ((Flight)ent)->callsign_num, buffer);

	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	movzx	eax, BYTE PTR [edx+426]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	movzx	edx, BYTE PTR [ecx+425]
	push	edx
	call	?GetCallsign@@YAXHHPAD@Z		; GetCallsign
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN38@UpdateVCOp
$LN39@UpdateVCOp:

; 551  : 		else if (ent->IsObjective())

	mov	eax, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+236]
	call	eax
	test	eax, eax
	je	SHORT $LN37@UpdateVCOp

; 552  : 			ent->GetName(buffer,35,TRUE);

	push	1
	push	35					; 00000023H
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax+380]
	call	edx

; 553  : 		else

	jmp	SHORT $LN38@UpdateVCOp
$LN37@UpdateVCOp:

; 554  : 			ent->GetName(buffer,35,FALSE);

	push	0
	push	35					; 00000023H
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+380]
	call	eax
$LN38@UpdateVCOp:

; 555  : 		if(ent->IsObjective() && vc->get_type() == vt_destroy && vc->get_sub_objective() >= 0)

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+236]
	call	eax
	test	eax, eax
	je	$LN35@UpdateVCOp
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_type@victory_condition@@QAE?AW4victory_type@@XZ ; victory_condition::get_type
	cmp	eax, 2
	jne	SHORT $LN35@UpdateVCOp
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_sub_objective@victory_condition@@QAEHXZ ; victory_condition::get_sub_objective
	test	eax, eax
	jl	SHORT $LN35@UpdateVCOp

; 556  : 		{
; 557  : 			classID = ((Objective)ent)->GetFeatureID(vc->get_sub_objective());

	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_sub_objective@victory_condition@@QAEHXZ ; victory_condition::get_sub_objective
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	call	?GetFeatureID@ObjectiveClass@@QAEHH@Z	; ObjectiveClass::GetFeatureID
	mov	DWORD PTR _classID$[ebp], eax

; 558  : 			if (classID)

	cmp	DWORD PTR _classID$[ebp], 0
	je	SHORT $LN35@UpdateVCOp

; 559  : 			{
; 560  : 				fc = GetFeatureClassData (classID);

	mov	ecx, DWORD PTR _classID$[ebp]
	push	ecx
	call	?GetFeatureClassData@@YAPAUFeatureClassDataType@@H@Z ; GetFeatureClassData
	add	esp, 4
	mov	DWORD PTR _fc$[ebp], eax

; 561  : 				if (fc && !(fc->Flags & FEAT_VIRTUAL))

	cmp	DWORD PTR _fc$[ebp], 0
	je	SHORT $LN35@UpdateVCOp
	mov	edx, DWORD PTR _fc$[ebp]
	movzx	eax, WORD PTR [edx+6]
	and	eax, 2
	jne	SHORT $LN35@UpdateVCOp

; 562  : 				{
; 563  : 					_tcscat(buffer,", ");

	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 564  : 					_tcscat(buffer,fc->Name);

	mov	edx, DWORD PTR _fc$[ebp]
	add	edx, 8
	push	edx
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_strcat
	add	esp, 8
$LN35@UpdateVCOp:

; 565  : 				}
; 566  : 			}
; 567  : 		}
; 568  : 		vctrl->GetTarget()->SetText(0,buffer);

	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _vctrl$[ebp]
	call	?GetTarget@C_Victory@@QAEPAVC_Button@@XZ ; C_Victory::GetTarget
	mov	ecx, eax
	call	?SetText@C_Button@@QAEXFPBD@Z		; C_Button::SetText

; 569  : 		if(vc->get_type() == vt_destroy)

	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_type@victory_condition@@QAE?AW4victory_type@@XZ ; victory_condition::get_type
	cmp	eax, 2
	jne	SHORT $LN32@UpdateVCOp

; 570  : 			vctrl->GetTarget()->SetUserNumber(10,1);

	push	1
	push	10					; 0000000aH
	mov	ecx, DWORD PTR _vctrl$[ebp]
	call	?GetTarget@C_Victory@@QAEPAVC_Button@@XZ ; C_Victory::GetTarget
	mov	ecx, eax
	call	?SetUserNumber@C_Base@@QAEXJJ@Z		; C_Base::SetUserNumber

; 571  : 		else

	jmp	SHORT $LN31@UpdateVCOp
$LN32@UpdateVCOp:

; 572  : 			vctrl->GetTarget()->SetUserNumber(10,0);

	push	0
	push	10					; 0000000aH
	mov	ecx, DWORD PTR _vctrl$[ebp]
	call	?GetTarget@C_Victory@@QAEPAVC_Button@@XZ ; C_Victory::GetTarget
	mov	ecx, eax
	call	?SetUserNumber@C_Base@@QAEXJJ@Z		; C_Base::SetUserNumber
$LN31@UpdateVCOp:

; 573  : 
; 574  : 		lbox=vctrl->GetAction();

	mov	ecx, DWORD PTR _vctrl$[ebp]
	call	?GetAction@C_Victory@@QAEPAVC_ListBox@@XZ ; C_Victory::GetAction
	mov	DWORD PTR _lbox$[ebp], eax

; 575  : 		if(lbox)

	cmp	DWORD PTR _lbox$[ebp], 0
	je	$LN30@UpdateVCOp

; 576  : 		{
; 577  : 			if(ent)

	cmp	DWORD PTR _ent$[ebp], 0
	je	$LN29@UpdateVCOp

; 578  : 			{
; 579  : 				if(ent->IsObjective())

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax+236]
	call	edx
	test	eax, eax
	je	$LN28@UpdateVCOp

; 580  : 				{
; 581  : 					lbox->SetItemFlags(vt_occupy,C_BIT_ENABLED);

	push	2048					; 00000800H
	push	1
	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?SetItemFlags@C_ListBox@@QAEXJJ@Z	; C_ListBox::SetItemFlags

; 582  : 					lbox->SetItemFlags(vt_destroy,C_BIT_ENABLED);

	push	2048					; 00000800H
	push	2
	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?SetItemFlags@C_ListBox@@QAEXJJ@Z	; C_ListBox::SetItemFlags

; 583  : 					lbox->SetItemFlags(vt_degrade,C_BIT_ENABLED);

	push	2048					; 00000800H
	push	5
	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?SetItemFlags@C_ListBox@@QAEXJJ@Z	; C_ListBox::SetItemFlags

; 584  : 
; 585  : 					lbox->SetItemFlags(vt_attrit,C_BIT_INVISIBLE);

	push	8192					; 00002000H
	push	3
	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?SetItemFlags@C_ListBox@@QAEXJJ@Z	; C_ListBox::SetItemFlags

; 586  : 					lbox->SetItemFlags(vt_intercept,C_BIT_INVISIBLE);

	push	8192					; 00002000H
	push	4
	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?SetItemFlags@C_ListBox@@QAEXJJ@Z	; C_ListBox::SetItemFlags

; 587  : 
; 588  : 					lbox->SetFlagBitOff(C_BIT_INVISIBLE);

	push	8192					; 00002000H
	mov	eax, DWORD PTR _lbox$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _lbox$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 589  : 					if(vc->get_type() == vt_attrit || vc->get_type() == vt_intercept)

	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_type@victory_condition@@QAE?AW4victory_type@@XZ ; victory_condition::get_type
	cmp	eax, 3
	je	SHORT $LN26@UpdateVCOp
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_type@victory_condition@@QAE?AW4victory_type@@XZ ; victory_condition::get_type
	cmp	eax, 4
	jne	SHORT $LN27@UpdateVCOp
$LN26@UpdateVCOp:

; 590  : 						vc->set_type(vt_degrade);

	push	5
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?set_type@victory_condition@@QAEXW4victory_type@@@Z ; victory_condition::set_type
$LN27@UpdateVCOp:

; 591  : 
; 592  : 				}

	jmp	$LN25@UpdateVCOp
$LN28@UpdateVCOp:

; 593  : 				else if(ent->IsFlight())

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax
	test	eax, eax
	je	$LN24@UpdateVCOp

; 594  : 				{
; 595  : 					lbox->SetItemFlags(vt_occupy,C_BIT_INVISIBLE);

	push	8192					; 00002000H
	push	1
	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?SetItemFlags@C_ListBox@@QAEXJJ@Z	; C_ListBox::SetItemFlags

; 596  : 					lbox->SetItemFlags(vt_destroy,C_BIT_INVISIBLE);

	push	8192					; 00002000H
	push	2
	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?SetItemFlags@C_ListBox@@QAEXJJ@Z	; C_ListBox::SetItemFlags

; 597  : 					lbox->SetItemFlags(vt_degrade,C_BIT_INVISIBLE);

	push	8192					; 00002000H
	push	5
	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?SetItemFlags@C_ListBox@@QAEXJJ@Z	; C_ListBox::SetItemFlags

; 598  : 					lbox->SetItemFlags(vt_attrit,C_BIT_INVISIBLE);

	push	8192					; 00002000H
	push	3
	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?SetItemFlags@C_ListBox@@QAEXJJ@Z	; C_ListBox::SetItemFlags

; 599  : 
; 600  : 					lbox->SetItemFlags(vt_intercept,C_BIT_ENABLED);

	push	2048					; 00000800H
	push	4
	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?SetItemFlags@C_ListBox@@QAEXJJ@Z	; C_ListBox::SetItemFlags

; 601  : 					lbox->SetValue(vt_intercept);

	push	4
	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?SetValue@C_ListBox@@QAEXJ@Z		; C_ListBox::SetValue

; 602  : 					lbox->SetFlagBitOff(C_BIT_INVISIBLE);

	push	8192					; 00002000H
	mov	ecx, DWORD PTR _lbox$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _lbox$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 603  : 					if(vc->get_type() != vt_intercept)

	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_type@victory_condition@@QAE?AW4victory_type@@XZ ; victory_condition::get_type
	cmp	eax, 4
	je	SHORT $LN23@UpdateVCOp

; 604  : 						vc->set_type(vt_intercept);

	push	4
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?set_type@victory_condition@@QAEXW4victory_type@@@Z ; victory_condition::set_type
$LN23@UpdateVCOp:

; 605  : 				}

	jmp	$LN25@UpdateVCOp
$LN24@UpdateVCOp:

; 606  : 				else if(ent->IsBattalion())

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+240]
	call	eax
	test	eax, eax
	je	$LN21@UpdateVCOp

; 607  : 				{
; 608  : 					lbox->SetItemFlags(vt_occupy,C_BIT_INVISIBLE);

	push	8192					; 00002000H
	push	1
	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?SetItemFlags@C_ListBox@@QAEXJJ@Z	; C_ListBox::SetItemFlags

; 609  : 					lbox->SetItemFlags(vt_destroy,C_BIT_INVISIBLE);

	push	8192					; 00002000H
	push	2
	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?SetItemFlags@C_ListBox@@QAEXJJ@Z	; C_ListBox::SetItemFlags

; 610  : 					lbox->SetItemFlags(vt_degrade,C_BIT_INVISIBLE);

	push	8192					; 00002000H
	push	5
	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?SetItemFlags@C_ListBox@@QAEXJJ@Z	; C_ListBox::SetItemFlags

; 611  : 					lbox->SetItemFlags(vt_intercept,C_BIT_INVISIBLE);

	push	8192					; 00002000H
	push	4
	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?SetItemFlags@C_ListBox@@QAEXJJ@Z	; C_ListBox::SetItemFlags

; 612  : 
; 613  : 					lbox->SetItemFlags(vt_attrit,C_BIT_ENABLED);

	push	2048					; 00000800H
	push	3
	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?SetItemFlags@C_ListBox@@QAEXJJ@Z	; C_ListBox::SetItemFlags

; 614  : 					lbox->SetValue(vt_attrit);

	push	3
	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?SetValue@C_ListBox@@QAEXJ@Z		; C_ListBox::SetValue

; 615  : 					lbox->SetFlagBitOff(C_BIT_INVISIBLE);

	push	8192					; 00002000H
	mov	ecx, DWORD PTR _lbox$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _lbox$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 616  : 					if(vc->get_type() != vt_attrit)

	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_type@victory_condition@@QAE?AW4victory_type@@XZ ; victory_condition::get_type
	cmp	eax, 3
	je	SHORT $LN20@UpdateVCOp

; 617  : 						vc->set_type(vt_attrit);

	push	3
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?set_type@victory_condition@@QAEXW4victory_type@@@Z ; victory_condition::set_type
$LN20@UpdateVCOp:

; 618  : 				}
; 619  : 				else

	jmp	SHORT $LN25@UpdateVCOp
$LN21@UpdateVCOp:

; 620  : 					lbox->SetFlagBitOn(C_BIT_INVISIBLE);

	push	8192					; 00002000H
	mov	ecx, DWORD PTR _lbox$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _lbox$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
$LN25@UpdateVCOp:

; 621  : 				lbox->SetValue(vc->get_type());

	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_type@victory_condition@@QAE?AW4victory_type@@XZ ; victory_condition::get_type
	push	eax
	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?SetValue@C_ListBox@@QAEXJ@Z		; C_ListBox::SetValue

; 622  : 			}
; 623  : 			else

	jmp	SHORT $LN30@UpdateVCOp
$LN29@UpdateVCOp:

; 624  : 				lbox->SetFlagBitOn(C_BIT_INVISIBLE);

	push	8192					; 00002000H
	mov	ecx, DWORD PTR _lbox$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _lbox$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
$LN30@UpdateVCOp:

; 625  : 		}
; 626  : 
; 627  : 		lbox=vctrl->GetArgs();

	mov	ecx, DWORD PTR _vctrl$[ebp]
	call	?GetArgs@C_Victory@@QAEPAVC_ListBox@@XZ	; C_Victory::GetArgs
	mov	DWORD PTR _lbox$[ebp], eax

; 628  : 		if(lbox)

	cmp	DWORD PTR _lbox$[ebp], 0
	je	$LN17@UpdateVCOp

; 629  : 		{
; 630  : 			switch(vc->get_type())

	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_type@victory_condition@@QAE?AW4victory_type@@XZ ; victory_condition::get_type
	mov	DWORD PTR tv377[ebp], eax
	cmp	DWORD PTR tv377[ebp], 3
	je	$LN5@UpdateVCOp
	cmp	DWORD PTR tv377[ebp], 4
	je	SHORT $LN14@UpdateVCOp
	cmp	DWORD PTR tv377[ebp], 5
	je	$LN5@UpdateVCOp
	jmp	$LN1@UpdateVCOp
$LN14@UpdateVCOp:

; 631  : 			{
; 632  : 				case vt_intercept:
; 633  : 					lbox->SetRoot(intercept_lbox);

	mov	ecx, DWORD PTR ?intercept_lbox@@3PAVLISTBOX@@A ; intercept_lbox
	push	ecx
	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?SetRoot@C_ListBox@@QAEXPAVLISTBOX@@@Z	; C_ListBox::SetRoot

; 634  : 					lbox->SetFlagBitOff(C_BIT_INVISIBLE);

	push	8192					; 00002000H
	mov	edx, DWORD PTR _lbox$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _lbox$[ebp]
	mov	edx, DWORD PTR [eax+12]
	call	edx

; 635  : 					if(ent && ent->IsFlight())

	cmp	DWORD PTR _ent$[ebp], 0
	je	SHORT $LN13@UpdateVCOp
	mov	eax, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax
	test	eax, eax
	je	SHORT $LN13@UpdateVCOp

; 636  : 					{
; 637  : 						vc->set_tolerance(max(1,min(vc->get_tolerance (),4)));

	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_tolerance@victory_condition@@QAEHXZ ; victory_condition::get_tolerance
	cmp	eax, 4
	jge	SHORT $LN46@UpdateVCOp
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_tolerance@victory_condition@@QAEHXZ ; victory_condition::get_tolerance
	mov	DWORD PTR tv404[ebp], eax
	jmp	SHORT $LN47@UpdateVCOp
$LN46@UpdateVCOp:
	mov	DWORD PTR tv404[ebp], 4
$LN47@UpdateVCOp:
	cmp	DWORD PTR tv404[ebp], 1
	jge	SHORT $LN50@UpdateVCOp
	mov	DWORD PTR tv412[ebp], 1
	jmp	SHORT $LN51@UpdateVCOp
$LN50@UpdateVCOp:
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_tolerance@victory_condition@@QAEHXZ ; victory_condition::get_tolerance
	cmp	eax, 4
	jge	SHORT $LN48@UpdateVCOp
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_tolerance@victory_condition@@QAEHXZ ; victory_condition::get_tolerance
	mov	DWORD PTR tv411[ebp], eax
	jmp	SHORT $LN49@UpdateVCOp
$LN48@UpdateVCOp:
	mov	DWORD PTR tv411[ebp], 4
$LN49@UpdateVCOp:
	mov	ecx, DWORD PTR tv411[ebp]
	mov	DWORD PTR tv412[ebp], ecx
$LN51@UpdateVCOp:
	mov	edx, DWORD PTR tv412[ebp]
	push	edx
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?set_tolerance@victory_condition@@QAEXH@Z ; victory_condition::set_tolerance

; 638  : 					}
; 639  : 					else

	jmp	SHORT $LN12@UpdateVCOp
$LN13@UpdateVCOp:

; 640  : 					{
; 641  : 						vc->set_tolerance(1);

	push	1
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?set_tolerance@victory_condition@@QAEXH@Z ; victory_condition::set_tolerance
$LN12@UpdateVCOp:

; 642  : 					}
; 643  : 					lbox->SetValue(max(1,min(4,vc->get_tolerance())));

	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_tolerance@victory_condition@@QAEHXZ ; victory_condition::get_tolerance
	cmp	eax, 4
	jle	SHORT $LN52@UpdateVCOp
	mov	DWORD PTR tv422[ebp], 4
	jmp	SHORT $LN53@UpdateVCOp
$LN52@UpdateVCOp:
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_tolerance@victory_condition@@QAEHXZ ; victory_condition::get_tolerance
	mov	DWORD PTR tv422[ebp], eax
$LN53@UpdateVCOp:
	cmp	DWORD PTR tv422[ebp], 1
	jge	SHORT $LN56@UpdateVCOp
	mov	DWORD PTR tv430[ebp], 1
	jmp	SHORT $LN57@UpdateVCOp
$LN56@UpdateVCOp:
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_tolerance@victory_condition@@QAEHXZ ; victory_condition::get_tolerance
	cmp	eax, 4
	jle	SHORT $LN54@UpdateVCOp
	mov	DWORD PTR tv429[ebp], 4
	jmp	SHORT $LN55@UpdateVCOp
$LN54@UpdateVCOp:
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_tolerance@victory_condition@@QAEHXZ ; victory_condition::get_tolerance
	mov	DWORD PTR tv429[ebp], eax
$LN55@UpdateVCOp:
	mov	eax, DWORD PTR tv429[ebp]
	mov	DWORD PTR tv430[ebp], eax
$LN57@UpdateVCOp:
	mov	ecx, DWORD PTR tv430[ebp]
	push	ecx
	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?SetValue@C_ListBox@@QAEXJ@Z		; C_ListBox::SetValue

; 644  : 					for(i=1;i<=((Flight)ent)->GetTotalVehicles();i++)

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN11@UpdateVCOp
$LN10@UpdateVCOp:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN11@UpdateVCOp:
	mov	ecx, DWORD PTR _ent$[ebp]
	call	?GetTotalVehicles@UnitClass@@QAEHXZ	; UnitClass::GetTotalVehicles
	cmp	DWORD PTR _i$[ebp], eax
	jg	SHORT $LN9@UpdateVCOp

; 645  : 						lbox->SetItemFlags(i,C_BIT_ENABLED);

	push	2048					; 00000800H
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?SetItemFlags@C_ListBox@@QAEXJJ@Z	; C_ListBox::SetItemFlags
	jmp	SHORT $LN10@UpdateVCOp
$LN9@UpdateVCOp:

; 646  : 					for(;i <= 4;i++)

	jmp	SHORT $LN8@UpdateVCOp
$LN7@UpdateVCOp:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN8@UpdateVCOp:
	cmp	DWORD PTR _i$[ebp], 4
	jg	SHORT $LN6@UpdateVCOp

; 647  : 						lbox->SetItemFlags(i,C_BIT_INVISIBLE);

	push	8192					; 00002000H
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?SetItemFlags@C_ListBox@@QAEXJJ@Z	; C_ListBox::SetItemFlags
	jmp	SHORT $LN7@UpdateVCOp
$LN6@UpdateVCOp:

; 648  : 					break;

	jmp	$LN17@UpdateVCOp
$LN5@UpdateVCOp:

; 649  : 				case vt_attrit:
; 650  : 				case vt_degrade:
; 651  : 					lbox->SetRoot(percent_lbox);

	mov	eax, DWORD PTR ?percent_lbox@@3PAVLISTBOX@@A ; percent_lbox
	push	eax
	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?SetRoot@C_ListBox@@QAEXPAVLISTBOX@@@Z	; C_ListBox::SetRoot

; 652  : 					lbox->SetFlagBitOff(C_BIT_INVISIBLE);

	push	8192					; 00002000H
	mov	ecx, DWORD PTR _lbox$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _lbox$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 653  : 					if(vc->get_tolerance() > 10)

	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_tolerance@victory_condition@@QAEHXZ ; victory_condition::get_tolerance
	cmp	eax, 10					; 0000000aH
	jle	SHORT $LN4@UpdateVCOp

; 654  : 						vc->set_tolerance(10);

	push	10					; 0000000aH
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?set_tolerance@victory_condition@@QAEXH@Z ; victory_condition::set_tolerance
	jmp	SHORT $LN3@UpdateVCOp
$LN4@UpdateVCOp:

; 655  : 					else if(vc->get_tolerance() < 1)

	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_tolerance@victory_condition@@QAEHXZ ; victory_condition::get_tolerance
	cmp	eax, 1
	jge	SHORT $LN3@UpdateVCOp

; 656  : 						vc->set_tolerance(1);

	push	1
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?set_tolerance@victory_condition@@QAEXH@Z ; victory_condition::set_tolerance
$LN3@UpdateVCOp:

; 657  : 					lbox->SetValue(max(1,min(10,vc->get_tolerance())));

	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_tolerance@victory_condition@@QAEHXZ ; victory_condition::get_tolerance
	cmp	eax, 10					; 0000000aH
	jle	SHORT $LN58@UpdateVCOp
	mov	DWORD PTR tv478[ebp], 10		; 0000000aH
	jmp	SHORT $LN59@UpdateVCOp
$LN58@UpdateVCOp:
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_tolerance@victory_condition@@QAEHXZ ; victory_condition::get_tolerance
	mov	DWORD PTR tv478[ebp], eax
$LN59@UpdateVCOp:
	cmp	DWORD PTR tv478[ebp], 1
	jge	SHORT $LN62@UpdateVCOp
	mov	DWORD PTR tv486[ebp], 1
	jmp	SHORT $LN63@UpdateVCOp
$LN62@UpdateVCOp:
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_tolerance@victory_condition@@QAEHXZ ; victory_condition::get_tolerance
	cmp	eax, 10					; 0000000aH
	jle	SHORT $LN60@UpdateVCOp
	mov	DWORD PTR tv485[ebp], 10		; 0000000aH
	jmp	SHORT $LN61@UpdateVCOp
$LN60@UpdateVCOp:
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_tolerance@victory_condition@@QAEHXZ ; victory_condition::get_tolerance
	mov	DWORD PTR tv485[ebp], eax
$LN61@UpdateVCOp:
	mov	ecx, DWORD PTR tv485[ebp]
	mov	DWORD PTR tv486[ebp], ecx
$LN63@UpdateVCOp:
	mov	edx, DWORD PTR tv486[ebp]
	push	edx
	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?SetValue@C_ListBox@@QAEXJ@Z		; C_ListBox::SetValue

; 658  : 					break;

	jmp	SHORT $LN17@UpdateVCOp
$LN1@UpdateVCOp:

; 659  : 				default:
; 660  : 					vctrl->GetArgs()->SetRoot(percent_lbox);

	mov	eax, DWORD PTR ?percent_lbox@@3PAVLISTBOX@@A ; percent_lbox
	push	eax
	mov	ecx, DWORD PTR _vctrl$[ebp]
	call	?GetArgs@C_Victory@@QAEPAVC_ListBox@@XZ	; C_Victory::GetArgs
	mov	ecx, eax
	call	?SetRoot@C_ListBox@@QAEXPAVLISTBOX@@@Z	; C_ListBox::SetRoot

; 661  : 					vctrl->GetArgs()->SetFlagBitOn(C_BIT_INVISIBLE);

	mov	ecx, DWORD PTR _vctrl$[ebp]
	call	?GetArgs@C_Victory@@QAEPAVC_ListBox@@XZ	; C_Victory::GetArgs
	mov	DWORD PTR tv499[ebp], eax
	push	8192					; 00002000H
	mov	ecx, DWORD PTR tv499[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv499[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 662  : 					lbox->SetValue(1);

	push	1
	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?SetValue@C_ListBox@@QAEXJ@Z		; C_ListBox::SetValue
$LN17@UpdateVCOp:

; 663  : 					break;
; 664  : 			}
; 665  : 		}
; 666  : 		vctrl->Refresh();

	mov	ecx, DWORD PTR _vctrl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _vctrl$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN44@UpdateVCOp:

; 667  : 	}
; 668  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateVCOptions@@YAXPAVvictory_condition@@@Z ENDP	; UpdateVCOptions
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\taceng\te_team_victory.cpp
_TEXT	SEGMENT
tv78 = -12						; size = 4
_lvc$ = -8						; size = 4
_nvc$ = -4						; size = 4
_list$ = 8						; size = 4
_newitem$ = 12						; size = 4
?VCSortCB@@YAHPAVTREELIST@@0@Z PROC			; VCSortCB

; 483  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi

; 484  : 	C_Victory *lvc,*nvc;
; 485  : 
; 486  : 	if(!list || !newitem)

	cmp	DWORD PTR _list$[ebp], 0
	je	SHORT $LN19@VCSortCB
	cmp	DWORD PTR _newitem$[ebp], 0
	jne	SHORT $LN20@VCSortCB
$LN19@VCSortCB:

; 487  : 		return(FALSE);

	xor	eax, eax
	jmp	$LN21@VCSortCB
$LN20@VCSortCB:

; 488  : 
; 489  : 	lvc=(C_Victory*)list->Item_;

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _lvc$[ebp], ecx

; 490  : 	nvc=(C_Victory*)newitem->Item_;

	mov	edx, DWORD PTR _newitem$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR _nvc$[ebp], eax

; 491  : 	if(!lvc || !nvc)

	cmp	DWORD PTR _lvc$[ebp], 0
	je	SHORT $LN17@VCSortCB
	cmp	DWORD PTR _nvc$[ebp], 0
	jne	SHORT $LN18@VCSortCB
$LN17@VCSortCB:

; 492  : 		return(FALSE);

	xor	eax, eax
	jmp	$LN21@VCSortCB
$LN18@VCSortCB:

; 493  : 
; 494  : 	switch(VCSortType)

	mov	ecx, DWORD PTR ?VCSortType@@3JA		; VCSortType
	mov	DWORD PTR tv78[ebp], ecx
	cmp	DWORD PTR tv78[ebp], 31036		; 0000793cH
	je	SHORT $LN14@VCSortCB
	cmp	DWORD PTR tv78[ebp], 31037		; 0000793dH
	je	$LN10@VCSortCB
	cmp	DWORD PTR tv78[ebp], 31038		; 0000793eH
	je	$LN6@VCSortCB
	jmp	$LN2@VCSortCB
$LN14@VCSortCB:

; 495  : 	{
; 496  : 		case SORT_VC_TEAM: // Sort by Team
; 497  : 			if(nvc->GetTeam()->GetTextID() < lvc->GetTeam()->GetTextID())

	mov	ecx, DWORD PTR _nvc$[ebp]
	call	?GetTeam@C_Victory@@QAEPAVC_ListBox@@XZ	; C_Victory::GetTeam
	mov	ecx, eax
	call	?GetTextID@C_ListBox@@QAEJXZ		; C_ListBox::GetTextID
	mov	esi, eax
	mov	ecx, DWORD PTR _lvc$[ebp]
	call	?GetTeam@C_Victory@@QAEPAVC_ListBox@@XZ	; C_Victory::GetTeam
	mov	ecx, eax
	call	?GetTextID@C_ListBox@@QAEJXZ		; C_ListBox::GetTextID
	cmp	esi, eax
	jge	SHORT $LN13@VCSortCB

; 498  : 				return(TRUE);

	mov	eax, 1
	jmp	$LN21@VCSortCB
	jmp	SHORT $LN12@VCSortCB
$LN13@VCSortCB:

; 499  : 			else if(nvc->GetTeam()->GetTextID() == lvc->GetTeam()->GetTextID() && newitem->ID_ < list->ID_)

	mov	ecx, DWORD PTR _nvc$[ebp]
	call	?GetTeam@C_Victory@@QAEPAVC_ListBox@@XZ	; C_Victory::GetTeam
	mov	ecx, eax
	call	?GetTextID@C_ListBox@@QAEJXZ		; C_ListBox::GetTextID
	mov	esi, eax
	mov	ecx, DWORD PTR _lvc$[ebp]
	call	?GetTeam@C_Victory@@QAEPAVC_ListBox@@XZ	; C_Victory::GetTeam
	mov	ecx, eax
	call	?GetTextID@C_ListBox@@QAEJXZ		; C_ListBox::GetTextID
	cmp	esi, eax
	jne	SHORT $LN12@VCSortCB
	mov	edx, DWORD PTR _newitem$[ebp]
	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN12@VCSortCB

; 500  : 				return(TRUE);

	mov	eax, 1
	jmp	$LN21@VCSortCB
$LN12@VCSortCB:

; 501  : 			break;

	jmp	$LN15@VCSortCB
$LN10@VCSortCB:

; 502  : 		case SORT_VC_TYPE: // Sort by Action
; 503  : 			if(nvc->GetAction()->GetTextID() < lvc->GetAction()->GetTextID())

	mov	ecx, DWORD PTR _nvc$[ebp]
	call	?GetAction@C_Victory@@QAEPAVC_ListBox@@XZ ; C_Victory::GetAction
	mov	ecx, eax
	call	?GetTextID@C_ListBox@@QAEJXZ		; C_ListBox::GetTextID
	mov	esi, eax
	mov	ecx, DWORD PTR _lvc$[ebp]
	call	?GetAction@C_Victory@@QAEPAVC_ListBox@@XZ ; C_Victory::GetAction
	mov	ecx, eax
	call	?GetTextID@C_ListBox@@QAEJXZ		; C_ListBox::GetTextID
	cmp	esi, eax
	jge	SHORT $LN9@VCSortCB

; 504  : 				return(TRUE);

	mov	eax, 1
	jmp	$LN21@VCSortCB
	jmp	SHORT $LN8@VCSortCB
$LN9@VCSortCB:

; 505  : 			else if(nvc->GetAction()->GetTextID() == lvc->GetAction()->GetTextID() && newitem->ID_ < list->ID_)

	mov	ecx, DWORD PTR _nvc$[ebp]
	call	?GetAction@C_Victory@@QAEPAVC_ListBox@@XZ ; C_Victory::GetAction
	mov	ecx, eax
	call	?GetTextID@C_ListBox@@QAEJXZ		; C_ListBox::GetTextID
	mov	esi, eax
	mov	ecx, DWORD PTR _lvc$[ebp]
	call	?GetAction@C_Victory@@QAEPAVC_ListBox@@XZ ; C_Victory::GetAction
	mov	ecx, eax
	call	?GetTextID@C_ListBox@@QAEJXZ		; C_ListBox::GetTextID
	cmp	esi, eax
	jne	SHORT $LN8@VCSortCB
	mov	edx, DWORD PTR _newitem$[ebp]
	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN8@VCSortCB

; 506  : 				return(TRUE);

	mov	eax, 1
	jmp	SHORT $LN21@VCSortCB
$LN8@VCSortCB:

; 507  : 			 break;

	jmp	SHORT $LN15@VCSortCB
$LN6@VCSortCB:

; 508  : 		case SORT_VC_POINTS: // Sort by Points
; 509  : 			if(nvc->GetPoints()->GetInteger() > lvc->GetPoints()->GetInteger())

	mov	ecx, DWORD PTR _nvc$[ebp]
	call	?GetPoints@C_Victory@@QAEPAVC_EditBox@@XZ ; C_Victory::GetPoints
	mov	ecx, eax
	call	?GetInteger@C_EditBox@@QAEJXZ		; C_EditBox::GetInteger
	mov	esi, eax
	mov	ecx, DWORD PTR _lvc$[ebp]
	call	?GetPoints@C_Victory@@QAEPAVC_EditBox@@XZ ; C_Victory::GetPoints
	mov	ecx, eax
	call	?GetInteger@C_EditBox@@QAEJXZ		; C_EditBox::GetInteger
	cmp	esi, eax
	jle	SHORT $LN5@VCSortCB

; 510  : 				return(TRUE);

	mov	eax, 1
	jmp	SHORT $LN21@VCSortCB
	jmp	SHORT $LN4@VCSortCB
$LN5@VCSortCB:

; 511  : 			else if(nvc->GetPoints()->GetInteger() == lvc->GetPoints()->GetInteger() && newitem->ID_ < list->ID_)

	mov	ecx, DWORD PTR _nvc$[ebp]
	call	?GetPoints@C_Victory@@QAEPAVC_EditBox@@XZ ; C_Victory::GetPoints
	mov	ecx, eax
	call	?GetInteger@C_EditBox@@QAEJXZ		; C_EditBox::GetInteger
	mov	esi, eax
	mov	ecx, DWORD PTR _lvc$[ebp]
	call	?GetPoints@C_Victory@@QAEPAVC_EditBox@@XZ ; C_Victory::GetPoints
	mov	ecx, eax
	call	?GetInteger@C_EditBox@@QAEJXZ		; C_EditBox::GetInteger
	cmp	esi, eax
	jne	SHORT $LN4@VCSortCB
	mov	edx, DWORD PTR _newitem$[ebp]
	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN4@VCSortCB

; 512  : 				return(TRUE);

	mov	eax, 1
	jmp	SHORT $LN21@VCSortCB
$LN4@VCSortCB:

; 513  : 			break;

	jmp	SHORT $LN15@VCSortCB
$LN2@VCSortCB:

; 514  : 		case SORT_VC_NUMBER: // Sort by ID
; 515  : 		default:
; 516  : 			if(newitem->ID_ < list->ID_)

	mov	edx, DWORD PTR _newitem$[ebp]
	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN15@VCSortCB

; 517  : 				return(TRUE);

	mov	eax, 1
	jmp	SHORT $LN21@VCSortCB
$LN15@VCSortCB:

; 518  : 			break;
; 519  : 	}
; 520  : 	return(FALSE);

	xor	eax, eax
$LN21@VCSortCB:

; 521  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?VCSortCB@@YAHPAVTREELIST@@0@Z ENDP			; VCSortCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\taceng\te_team_victory.cpp
_TEXT	SEGMENT
_Leave$ = -4						; size = 4
_ID$ = 8						; size = 4
_hittype$ = 12						; size = 2
___formal$ = 16						; size = 4
?SetVCSortTypeCB@@YAXJFPAVC_Base@@@Z PROC		; SetVCSortTypeCB

; 465  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 466  : 	F4CSECTIONHANDLE *Leave;
; 467  : 	if(hittype != C_TYPE_LMOUSEUP)

	movsx	eax, WORD PTR _hittype$[ebp]
	cmp	eax, 52					; 00000034H
	je	SHORT $LN3@SetVCSortT

; 468  : 		return;

	jmp	SHORT $LN4@SetVCSortT
$LN3@SetVCSortT:

; 469  : 
; 470  : 	VCSortType=ID;

	mov	ecx, DWORD PTR _ID$[ebp]
	mov	DWORD PTR ?VCSortType@@3JA, ecx		; VCSortType

; 471  : 	if(gVCTree)

	cmp	DWORD PTR ?gVCTree@@3PAVC_TreeList@@A, 0 ; gVCTree
	je	SHORT $LN4@SetVCSortT

; 472  : 	{
; 473  : 		Leave=UI_Enter(gVCTree->Parent_);

	mov	edx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	mov	eax, DWORD PTR [edx+48]
	push	eax
	call	?UI_Enter@@YAPAUF4CSECTIONHANDLE@@PAVC_Window@@@Z ; UI_Enter
	add	esp, 4
	mov	DWORD PTR _Leave$[ebp], eax

; 474  : 		gVCTree->ReorderBranch(gVCTree->GetRoot());

	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	call	?GetRoot@C_TreeList@@QAEPAVTREELIST@@XZ	; C_TreeList::GetRoot
	push	eax
	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	call	?ReorderBranch@C_TreeList@@QAEXPAVTREELIST@@@Z ; C_TreeList::ReorderBranch

; 475  : 		gVCTree->RecalcSize();

	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	call	?RecalcSize@C_TreeList@@QAEXXZ		; C_TreeList::RecalcSize

; 476  : 		if(gVCTree->Parent_)

	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	cmp	DWORD PTR [ecx+48], 0
	je	SHORT $LN1@SetVCSortT

; 477  : 			gVCTree->Parent_->RefreshClient(gVCTree->GetClient());

	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	call	?GetClient@C_Base@@QAEFXZ		; C_Base::GetClient
	movsx	edx, ax
	push	edx
	mov	eax, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	mov	ecx, DWORD PTR [eax+48]
	call	?RefreshClient@C_Window@@QAEXJ@Z	; C_Window::RefreshClient
$LN1@SetVCSortT:

; 478  : 		UI_Leave(Leave);

	mov	ecx, DWORD PTR _Leave$[ebp]
	push	ecx
	call	?UI_Leave@@YAXPAUF4CSECTIONHANDLE@@@Z	; UI_Leave
	add	esp, 4
$LN4@SetVCSortT:

; 479  : 	}
; 480  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SetVCSortTypeCB@@YAXJFPAVC_Base@@@Z ENDP		; SetVCSortTypeCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\taceng\te_team_victory.cpp
_TEXT	SEGMENT
$T1 = -72						; size = 4
tv203 = -68						; size = 4
$T2 = -64						; size = 4
$T3 = -60						; size = 4
tv177 = -56						; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
tv151 = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
tv93 = -32						; size = 4
$T8 = -28						; size = 4
$T9 = -24						; size = 4
$T10 = -20						; size = 4
$T11 = -16						; size = 4
$T12 = -12						; size = 4
_last$ = -8						; size = 4
_cur$ = -4						; size = 4
?CleanupVCArgLists@@YAXXZ PROC				; CleanupVCArgLists

; 413  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H

; 414  : 	LISTBOX *cur,*last;
; 415  : 
; 416  : 	if(gVCTree)

	cmp	DWORD PTR ?gVCTree@@3PAVC_TreeList@@A, 0 ; gVCTree
	je	SHORT $LN9@CleanupVCA

; 417  : 		gVCTree->DeleteBranch(gVCTree->GetRoot());

	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	call	?GetRoot@C_TreeList@@QAEPAVTREELIST@@XZ	; C_TreeList::GetRoot
	push	eax
	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	call	?DeleteBranch@C_TreeList@@QAEXPAVTREELIST@@@Z ; C_TreeList::DeleteBranch
$LN9@CleanupVCA:

; 418  : 
; 419  : 	cur=team_lbox;

	mov	eax, DWORD PTR ?team_lbox@@3PAVLISTBOX@@A ; team_lbox
	mov	DWORD PTR _cur$[ebp], eax
$LN8@CleanupVCA:

; 420  : 	while(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN7@CleanupVCA

; 421  : 	{
; 422  : 		last=cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _last$[ebp], ecx

; 423  : 		cur=cur->Next;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _cur$[ebp], eax

; 424  : 		last->Label_->Cleanup();

	mov	ecx, DWORD PTR _last$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _last$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+176]
	call	eax

; 425  : 		delete last->Label_;

	mov	ecx, DWORD PTR _last$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T8[ebp], edx
	mov	eax, DWORD PTR $T8[ebp]
	mov	DWORD PTR $T12[ebp], eax
	cmp	DWORD PTR $T12[ebp], 0
	je	SHORT $LN12@CleanupVCA
	push	1
	mov	ecx, DWORD PTR $T12[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T12[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv93[ebp], eax
	jmp	SHORT $LN13@CleanupVCA
$LN12@CleanupVCA:
	mov	DWORD PTR tv93[ebp], 0
$LN13@CleanupVCA:

; 426  : 		delete last;

	mov	ecx, DWORD PTR _last$[ebp]
	mov	DWORD PTR $T7[ebp], ecx
	mov	edx, DWORD PTR $T7[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 427  : 	}

	jmp	SHORT $LN8@CleanupVCA
$LN7@CleanupVCA:

; 428  : 	team_lbox=NULL;

	mov	DWORD PTR ?team_lbox@@3PAVLISTBOX@@A, 0	; team_lbox

; 429  : 
; 430  : 	cur=action_lbox;

	mov	eax, DWORD PTR ?action_lbox@@3PAVLISTBOX@@A ; action_lbox
	mov	DWORD PTR _cur$[ebp], eax
$LN6@CleanupVCA:

; 431  : 	while(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN5@CleanupVCA

; 432  : 	{
; 433  : 		last=cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _last$[ebp], ecx

; 434  : 		cur=cur->Next;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _cur$[ebp], eax

; 435  : 		last->Label_->Cleanup();

	mov	ecx, DWORD PTR _last$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _last$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+176]
	call	eax

; 436  : 		delete last->Label_;

	mov	ecx, DWORD PTR _last$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T6[ebp], edx
	mov	eax, DWORD PTR $T6[ebp]
	mov	DWORD PTR $T11[ebp], eax
	cmp	DWORD PTR $T11[ebp], 0
	je	SHORT $LN14@CleanupVCA
	push	1
	mov	ecx, DWORD PTR $T11[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T11[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv151[ebp], eax
	jmp	SHORT $LN15@CleanupVCA
$LN14@CleanupVCA:
	mov	DWORD PTR tv151[ebp], 0
$LN15@CleanupVCA:

; 437  : 		delete last;

	mov	ecx, DWORD PTR _last$[ebp]
	mov	DWORD PTR $T5[ebp], ecx
	mov	edx, DWORD PTR $T5[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 438  : 	}

	jmp	SHORT $LN6@CleanupVCA
$LN5@CleanupVCA:

; 439  : 	action_lbox=NULL;

	mov	DWORD PTR ?action_lbox@@3PAVLISTBOX@@A, 0 ; action_lbox

; 440  : 
; 441  : 	cur=percent_lbox;

	mov	eax, DWORD PTR ?percent_lbox@@3PAVLISTBOX@@A ; percent_lbox
	mov	DWORD PTR _cur$[ebp], eax
$LN4@CleanupVCA:

; 442  : 	while(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN3@CleanupVCA

; 443  : 	{
; 444  : 		last=cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _last$[ebp], ecx

; 445  : 		cur=cur->Next;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _cur$[ebp], eax

; 446  : 		last->Label_->Cleanup();

	mov	ecx, DWORD PTR _last$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _last$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+176]
	call	eax

; 447  : 		delete last->Label_;

	mov	ecx, DWORD PTR _last$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T4[ebp], edx
	mov	eax, DWORD PTR $T4[ebp]
	mov	DWORD PTR $T10[ebp], eax
	cmp	DWORD PTR $T10[ebp], 0
	je	SHORT $LN16@CleanupVCA
	push	1
	mov	ecx, DWORD PTR $T10[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T10[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv177[ebp], eax
	jmp	SHORT $LN17@CleanupVCA
$LN16@CleanupVCA:
	mov	DWORD PTR tv177[ebp], 0
$LN17@CleanupVCA:

; 448  : 		delete last;

	mov	ecx, DWORD PTR _last$[ebp]
	mov	DWORD PTR $T3[ebp], ecx
	mov	edx, DWORD PTR $T3[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 449  : 	}

	jmp	SHORT $LN4@CleanupVCA
$LN3@CleanupVCA:

; 450  : 	percent_lbox=NULL;

	mov	DWORD PTR ?percent_lbox@@3PAVLISTBOX@@A, 0 ; percent_lbox

; 451  : 
; 452  : 	cur=intercept_lbox;

	mov	eax, DWORD PTR ?intercept_lbox@@3PAVLISTBOX@@A ; intercept_lbox
	mov	DWORD PTR _cur$[ebp], eax
$LN2@CleanupVCA:

; 453  : 	while(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN1@CleanupVCA

; 454  : 	{
; 455  : 		last=cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _last$[ebp], ecx

; 456  : 		cur=cur->Next;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _cur$[ebp], eax

; 457  : 		last->Label_->Cleanup();

	mov	ecx, DWORD PTR _last$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _last$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+176]
	call	eax

; 458  : 		delete last->Label_;

	mov	ecx, DWORD PTR _last$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T2[ebp], edx
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T9[ebp], eax
	cmp	DWORD PTR $T9[ebp], 0
	je	SHORT $LN18@CleanupVCA
	push	1
	mov	ecx, DWORD PTR $T9[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T9[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv203[ebp], eax
	jmp	SHORT $LN19@CleanupVCA
$LN18@CleanupVCA:
	mov	DWORD PTR tv203[ebp], 0
$LN19@CleanupVCA:

; 459  : 		delete last;

	mov	ecx, DWORD PTR _last$[ebp]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 460  : 	}

	jmp	SHORT $LN2@CleanupVCA
$LN1@CleanupVCA:

; 461  : 	intercept_lbox=NULL;

	mov	DWORD PTR ?intercept_lbox@@3PAVLISTBOX@@A, 0 ; intercept_lbox

; 462  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CleanupVCArgLists@@YAXXZ ENDP				; CleanupVCArgLists
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\taceng\te_team_victory.cpp
_TEXT	SEGMENT
$T1 = -40						; size = 4
tv89 = -36						; size = 4
$T2 = -32						; size = 4
_vctrl$ = -28						; size = 4
$T3 = -24						; size = 4
_vc$ = -20						; size = 4
_cur$ = -16						; size = 4
_item$ = -12						; size = 4
_last$ = -8						; size = 4
_i$ = -4						; size = 2
?RebuildTeamLists@@YAXXZ PROC				; RebuildTeamLists

; 275  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 276  : 	victory_condition *vc=NULL;

	mov	DWORD PTR _vc$[ebp], 0

; 277  : 	LISTBOX *last=NULL,*item=NULL,*cur=NULL;

	mov	DWORD PTR _last$[ebp], 0
	mov	DWORD PTR _item$[ebp], 0
	mov	DWORD PTR _cur$[ebp], 0

; 278  : 	C_Victory *vctrl=NULL;

	mov	DWORD PTR _vctrl$[ebp], 0

; 279  : 	short i=0;

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax

; 280  : 
; 281  : 	gMainHandler->EnterCritical();

	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?EnterCritical@C_Handler@@QAEXXZ	; C_Handler::EnterCritical

; 282  : 
; 283  : 	cur=team_lbox;

	mov	ecx, DWORD PTR ?team_lbox@@3PAVLISTBOX@@A ; team_lbox
	mov	DWORD PTR _cur$[ebp], ecx
$LN12@RebuildTea:

; 284  : 	while(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN11@RebuildTea

; 285  : 	{
; 286  : 		last=cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _last$[ebp], edx

; 287  : 		cur=cur->Next;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _cur$[ebp], ecx

; 288  : 		last->Label_->Cleanup();

	mov	edx, DWORD PTR _last$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _last$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+176]
	call	eax

; 289  : 		delete last->Label_;

	mov	ecx, DWORD PTR _last$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T2[ebp], edx
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T3[ebp], eax
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN15@RebuildTea
	push	1
	mov	ecx, DWORD PTR $T3[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv89[ebp], eax
	jmp	SHORT $LN16@RebuildTea
$LN15@RebuildTea:
	mov	DWORD PTR tv89[ebp], 0
$LN16@RebuildTea:

; 290  : 		delete last;

	mov	ecx, DWORD PTR _last$[ebp]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 291  : 	}

	jmp	SHORT $LN12@RebuildTea
$LN11@RebuildTea:

; 292  : 	team_lbox=NULL;

	mov	DWORD PTR ?team_lbox@@3PAVLISTBOX@@A, 0	; team_lbox

; 293  : 	last = NULL;

	mov	DWORD PTR _last$[ebp], 0

; 294  : 
; 295  : 	for(i=0;i<NUM_TEAMS;i++)

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax
	jmp	SHORT $LN10@RebuildTea
$LN9@RebuildTea:
	mov	cx, WORD PTR _i$[ebp]
	add	cx, 1
	mov	WORD PTR _i$[ebp], cx
$LN10@RebuildTea:
	movsx	edx, WORD PTR _i$[ebp]
	cmp	edx, 8
	jge	$LN8@RebuildTea

; 296  : 	{
; 297  : 		if(TeamInfo[i] && (TeamInfo[i]->flags & TEAM_ACTIVE))

	movsx	eax, WORD PTR _i$[ebp]
	cmp	DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4], 0
	je	SHORT $LN7@RebuildTea
	movsx	ecx, WORD PTR _i$[ebp]
	mov	edx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	movsx	eax, WORD PTR [edx+350]
	and	eax, 1
	je	SHORT $LN7@RebuildTea

; 298  : 			item=mk_item(i,TeamInfo[i]->GetName());

	movsx	ecx, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?GetName@TeamClass@@QAEPADXZ		; TeamClass::GetName
	push	eax
	movsx	edx, WORD PTR _i$[ebp]
	push	edx
	call	?mk_item@@YAPAVLISTBOX@@JPAD@Z		; mk_item
	add	esp, 8
	mov	DWORD PTR _item$[ebp], eax

; 299  : 		else

	jmp	SHORT $LN6@RebuildTea
$LN7@RebuildTea:

; 300  : 		{
; 301  : 			item=mk_item(i,"No Team");

	push	OFFSET ??_C@_07IELFBDLE@No?5Team?$AA@
	movsx	eax, WORD PTR _i$[ebp]
	push	eax
	call	?mk_item@@YAPAVLISTBOX@@JPAD@Z		; mk_item
	add	esp, 8
	mov	DWORD PTR _item$[ebp], eax

; 302  : 			item->Label_->SetFlagBitOn(C_BIT_INVISIBLE);

	push	8192					; 00002000H
	mov	ecx, DWORD PTR _item$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _item$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	call	eax
$LN6@RebuildTea:

; 303  : 		}
; 304  : 		if(!team_lbox)

	cmp	DWORD PTR ?team_lbox@@3PAVLISTBOX@@A, 0	; team_lbox
	jne	SHORT $LN5@RebuildTea

; 305  : 			team_lbox=item;

	mov	ecx, DWORD PTR _item$[ebp]
	mov	DWORD PTR ?team_lbox@@3PAVLISTBOX@@A, ecx ; team_lbox

; 306  : 		else

	jmp	SHORT $LN4@RebuildTea
$LN5@RebuildTea:

; 307  : 			last->Next=item;

	mov	edx, DWORD PTR _last$[ebp]
	mov	eax, DWORD PTR _item$[ebp]
	mov	DWORD PTR [edx+4], eax
$LN4@RebuildTea:

; 308  : 		last=item;

	mov	ecx, DWORD PTR _item$[ebp]
	mov	DWORD PTR _last$[ebp], ecx

; 309  : 	}

	jmp	$LN9@RebuildTea
$LN8@RebuildTea:

; 310  : 
; 311  : 	vc=current_tactical_mission->get_first_unfiltered_victory_condition();

	mov	ecx, DWORD PTR ?current_tactical_mission@@3PAVtactical_mission@@A ; current_tactical_mission
	call	?get_first_unfiltered_victory_condition@tactical_mission@@QAEPAVvictory_condition@@XZ ; tactical_mission::get_first_unfiltered_victory_condition
	mov	DWORD PTR _vc$[ebp], eax
$LN3@RebuildTea:

; 312  : 	while(vc)

	cmp	DWORD PTR _vc$[ebp], 0
	je	SHORT $LN2@RebuildTea

; 313  : 	{
; 314  : 		vctrl=(C_Victory*)vc->control;

	mov	edx, DWORD PTR _vc$[ebp]
	mov	eax, DWORD PTR [edx+52]
	mov	DWORD PTR _vctrl$[ebp], eax

; 315  : 		if(vctrl)

	cmp	DWORD PTR _vctrl$[ebp], 0
	je	SHORT $LN1@RebuildTea

; 316  : 			vctrl->GetTeam()->SetRoot(team_lbox);

	mov	ecx, DWORD PTR ?team_lbox@@3PAVLISTBOX@@A ; team_lbox
	push	ecx
	mov	ecx, DWORD PTR _vctrl$[ebp]
	call	?GetTeam@C_Victory@@QAEPAVC_ListBox@@XZ	; C_Victory::GetTeam
	mov	ecx, eax
	call	?SetRoot@C_ListBox@@QAEXPAVLISTBOX@@@Z	; C_ListBox::SetRoot
$LN1@RebuildTea:

; 317  : 		vc=current_tactical_mission->get_next_unfiltered_victory_condition();

	mov	ecx, DWORD PTR ?current_tactical_mission@@3PAVtactical_mission@@A ; current_tactical_mission
	call	?get_next_unfiltered_victory_condition@tactical_mission@@QAEPAVvictory_condition@@XZ ; tactical_mission::get_next_unfiltered_victory_condition
	mov	DWORD PTR _vc$[ebp], eax

; 318  : 	}

	jmp	SHORT $LN3@RebuildTea
$LN2@RebuildTea:

; 319  : 
; 320  : 	gMainHandler->LeaveCritical();

	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?LeaveCritical@C_Handler@@QAEXXZ	; C_Handler::LeaveCritical

; 321  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RebuildTeamLists@@YAXXZ ENDP				; RebuildTeamLists
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\taceng\te_team_victory.cpp
_TEXT	SEGMENT
$T2 = -32						; size = 4
$T3 = -28						; size = 4
tv74 = -24						; size = 4
$T4 = -20						; size = 4
_lbitem$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_ID$ = 8						; size = 4
_Text$ = 12						; size = 4
?mk_item@@YAPAVLISTBOX@@JPAD@Z PROC			; mk_item

; 260  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?mk_item@@YAPAVLISTBOX@@JPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 261  : 	LISTBOX *lbitem;
; 262  : 
; 263  : 	lbitem=new LISTBOX;

	push	8
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR _lbitem$[ebp], eax

; 264  : 	lbitem->Label_=new C_Button;

	push	160					; 000000a0H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T4[ebp], 0
	je	SHORT $LN3@mk_item
	mov	ecx, DWORD PTR $T4[ebp]
	call	??0C_Button@@QAE@XZ			; C_Button::C_Button
	mov	DWORD PTR tv74[ebp], eax
	jmp	SHORT $LN4@mk_item
$LN3@mk_item:
	mov	DWORD PTR tv74[ebp], 0
$LN4@mk_item:
	mov	ecx, DWORD PTR tv74[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _lbitem$[ebp]
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR [edx], eax

; 265  : 	lbitem->Label_->Setup(ID,C_TYPE_RADIO,0,0);

	push	0
	push	0
	push	27					; 0000001bH
	mov	ecx, DWORD PTR _ID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lbitem$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?Setup@C_Button@@QAEXJFJJ@Z		; C_Button::Setup

; 266  : 	lbitem->Label_->SetText(C_STATE_0,Text);

	mov	eax, DWORD PTR _Text$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lbitem$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?SetText@C_Button@@QAEXFPBD@Z		; C_Button::SetText

; 267  : 	lbitem->Label_->SetText(C_STATE_1,Text);

	mov	edx, DWORD PTR _Text$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _lbitem$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?SetText@C_Button@@QAEXFPBD@Z		; C_Button::SetText

; 268  : 	lbitem->Label_->SetGroup(5551212);

	push	5551212					; 0054b46cH
	mov	ecx, DWORD PTR _lbitem$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?SetGroup@C_Base@@QAEXJ@Z		; C_Base::SetGroup

; 269  : 	lbitem->Next=NULL;

	mov	edx, DWORD PTR _lbitem$[ebp]
	mov	DWORD PTR [edx+4], 0

; 270  : 
; 271  : 	return(lbitem);

	mov	eax, DWORD PTR _lbitem$[ebp]

; 272  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?mk_item@@YAPAVLISTBOX@@JPAD@Z$0:
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?mk_item@@YAPAVLISTBOX@@JPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?mk_item@@YAPAVLISTBOX@@JPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?mk_item@@YAPAVLISTBOX@@JPAD@Z ENDP			; mk_item
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\taceng\te_team_victory.cpp
_TEXT	SEGMENT
$T2 = -32						; size = 4
$T3 = -28						; size = 4
tv74 = -24						; size = 4
$T4 = -20						; size = 4
_lbitem$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_ID$ = 8						; size = 4
_TextID$ = 12						; size = 4
?mk_item@@YAPAVLISTBOX@@JJ@Z PROC			; mk_item

; 245  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?mk_item@@YAPAVLISTBOX@@JJ@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 246  : 	LISTBOX *lbitem;
; 247  : 
; 248  : 	lbitem=new LISTBOX;

	push	8
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR _lbitem$[ebp], eax

; 249  : 	lbitem->Label_=new C_Button;

	push	160					; 000000a0H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T4[ebp], 0
	je	SHORT $LN3@mk_item
	mov	ecx, DWORD PTR $T4[ebp]
	call	??0C_Button@@QAE@XZ			; C_Button::C_Button
	mov	DWORD PTR tv74[ebp], eax
	jmp	SHORT $LN4@mk_item
$LN3@mk_item:
	mov	DWORD PTR tv74[ebp], 0
$LN4@mk_item:
	mov	ecx, DWORD PTR tv74[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _lbitem$[ebp]
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR [edx], eax

; 250  : 	lbitem->Label_->Setup(ID,C_TYPE_RADIO,0,0);

	push	0
	push	0
	push	27					; 0000001bH
	mov	ecx, DWORD PTR _ID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lbitem$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?Setup@C_Button@@QAEXJFJJ@Z		; C_Button::Setup

; 251  : 	lbitem->Label_->SetText(C_STATE_0,TextID);

	mov	eax, DWORD PTR _TextID$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lbitem$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?SetText@C_Button@@QAEXFJ@Z		; C_Button::SetText

; 252  : 	lbitem->Label_->SetText(C_STATE_1,TextID);

	mov	edx, DWORD PTR _TextID$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _lbitem$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?SetText@C_Button@@QAEXFJ@Z		; C_Button::SetText

; 253  : 	lbitem->Label_->SetGroup(5551212);

	push	5551212					; 0054b46cH
	mov	ecx, DWORD PTR _lbitem$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?SetGroup@C_Base@@QAEXJ@Z		; C_Base::SetGroup

; 254  : 	lbitem->Next=NULL;

	mov	edx, DWORD PTR _lbitem$[ebp]
	mov	DWORD PTR [edx+4], 0

; 255  : 
; 256  : 	return(lbitem);

	mov	eax, DWORD PTR _lbitem$[ebp]

; 257  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?mk_item@@YAPAVLISTBOX@@JJ@Z$0:
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?mk_item@@YAPAVLISTBOX@@JJ@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?mk_item@@YAPAVLISTBOX@@JJ@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?mk_item@@YAPAVLISTBOX@@JJ@Z ENDP			; mk_item
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\taceng\te_team_victory.cpp
_TEXT	SEGMENT
_editbox$ = -16						; size = 4
_box$ = -12						; size = 4
_ctrl$ = -8						; size = 4
_popup$ = -4						; size = 4
_winme$ = 8						; size = 4
_team$ = 12						; size = 4
_colour_id$ = 16					; size = 4
_new_team_id$ = 20					; size = 4
_team_id$ = 24						; size = 4
_flag_id$ = 28						; size = 4
?hookup_team_buttons@@YAXPAVC_Window@@HJJJJ@Z PROC	; hookup_team_buttons

; 161  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 162  : 	C_Button
; 163  : 		*ctrl;
; 164  : 
; 165  : 	C_PopupList
; 166  : 		*popup;
; 167  : 
; 168  : 	C_EditBox
; 169  : 		*editbox;
; 170  : 
; 171  : 	C_Box
; 172  : 		*box;
; 173  : 
; 174  : 	box = (C_Box *) winme->FindControl (colour_id);

	mov	eax, DWORD PTR _colour_id$[ebp]
	push	eax
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _box$[ebp], eax

; 175  : 
; 176  : 	if (box)

	cmp	DWORD PTR _box$[ebp], 0
	je	SHORT $LN6@hookup_tea

; 177  : 	{
; 178  : 		team_colour_box[team] = box;

	mov	ecx, DWORD PTR _team$[ebp]
	mov	edx, DWORD PTR _box$[ebp]
	mov	DWORD PTR _team_colour_box[ecx*4], edx
$LN6@hookup_tea:

; 179  : 	}
; 180  : 
; 181  : 	ctrl = (C_Button *) winme->FindControl (new_team_id);

	mov	eax, DWORD PTR _new_team_id$[ebp]
	push	eax
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ctrl$[ebp], eax

; 182  : 
; 183  : 	if (ctrl)

	cmp	DWORD PTR _ctrl$[ebp], 0
	je	SHORT $LN5@hookup_tea

; 184  : 	{
; 185  : 		new_team_button[team] = ctrl;

	mov	ecx, DWORD PTR _team$[ebp]
	mov	edx, DWORD PTR _ctrl$[ebp]
	mov	DWORD PTR _new_team_button[ecx*4], edx
$LN5@hookup_tea:

; 186  : 	}
; 187  : 
; 188  : 	editbox = (C_EditBox *) winme->FindControl (team_id);

	mov	eax, DWORD PTR _team_id$[ebp]
	push	eax
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _editbox$[ebp], eax

; 189  : 
; 190  : 	if (editbox)

	cmp	DWORD PTR _editbox$[ebp], 0
	je	SHORT $LN4@hookup_tea

; 191  : 	{
; 192  : 		team_name[team] = editbox;

	mov	ecx, DWORD PTR _team$[ebp]
	mov	edx, DWORD PTR _editbox$[ebp]
	mov	DWORD PTR _team_name[ecx*4], edx
$LN4@hookup_tea:

; 193  : 	}
; 194  : 
; 195  : 	ctrl = (C_Button *) winme->FindControl (flag_id);

	mov	eax, DWORD PTR _flag_id$[ebp]
	push	eax
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ctrl$[ebp], eax

; 196  : 
; 197  : 	if (ctrl)

	cmp	DWORD PTR _ctrl$[ebp], 0
	je	SHORT $LN3@hookup_tea

; 198  : 	{
; 199  : 		team_flag_box[team] = ctrl;

	mov	ecx, DWORD PTR _team$[ebp]
	mov	edx, DWORD PTR _ctrl$[ebp]
	mov	DWORD PTR _team_flag_box[ecx*4], edx
$LN3@hookup_tea:

; 200  : 	}
; 201  : 
; 202  : 	popup = gPopupMgr->GetMenu (DELETE_POPUP);

	push	18706					; 00004912H
	mov	ecx, DWORD PTR ?gPopupMgr@@3PAVC_PopupMgr@@A ; gPopupMgr
	call	?GetMenu@C_PopupMgr@@QAEPAVC_PopupList@@J@Z ; C_PopupMgr::GetMenu
	mov	DWORD PTR _popup$[ebp], eax

; 203  : 
; 204  : 	if (popup)

	cmp	DWORD PTR _popup$[ebp], 0
	je	SHORT $LN2@hookup_tea

; 205  : 	{
; 206  : 		popup->SetCallback (LIST_DELETE, delete_tactical_object);

	push	OFFSET ?delete_tactical_object@@YAXJFPAVC_Base@@@Z ; delete_tactical_object
	push	18708					; 00004914H
	mov	ecx, DWORD PTR _popup$[ebp]
	call	?SetCallback@C_PopupList@@QAEXJP6AXJFPAVC_Base@@@Z@Z ; C_PopupList::SetCallback
$LN2@hookup_tea:

; 207  : 	}
; 208  : 
; 209  : 	popup = gPopupMgr->GetMenu (AIRUNIT_MENU);

	push	18710					; 00004916H
	mov	ecx, DWORD PTR ?gPopupMgr@@3PAVC_PopupMgr@@A ; gPopupMgr
	call	?GetMenu@C_PopupMgr@@QAEPAVC_PopupList@@J@Z ; C_PopupMgr::GetMenu
	mov	DWORD PTR _popup$[ebp], eax

; 210  : 
; 211  : 	if (popup)

	cmp	DWORD PTR _popup$[ebp], 0
	je	SHORT $LN7@hookup_tea

; 212  : 	{
; 213  : 		popup->SetCallback (LIST_VC, add_vc_air_unit);

	push	OFFSET ?add_vc_air_unit@@YAXJFPAVC_Base@@@Z ; add_vc_air_unit
	push	18709					; 00004915H
	mov	ecx, DWORD PTR _popup$[ebp]
	call	?SetCallback@C_PopupList@@QAEXJP6AXJFPAVC_Base@@@Z@Z ; C_PopupList::SetCallback

; 214  : 		popup->SetCallback (LIST_DELETE, delete_tactical_object);

	push	OFFSET ?delete_tactical_object@@YAXJFPAVC_Base@@@Z ; delete_tactical_object
	push	18708					; 00004914H
	mov	ecx, DWORD PTR _popup$[ebp]
	call	?SetCallback@C_PopupList@@QAEXJP6AXJFPAVC_Base@@@Z@Z ; C_PopupList::SetCallback
$LN7@hookup_tea:

; 215  : 	}
; 216  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?hookup_team_buttons@@YAXPAVC_Window@@HJJJJ@Z ENDP	; hookup_team_buttons
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\taceng\te_team_victory.cpp
_TEXT	SEGMENT
_last$ = -12						; size = 4
_item$ = -8						; size = 4
_i$ = -4						; size = 2
?InitVCArgLists@@YAXXZ PROC				; InitVCArgLists

; 324  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 325  : 	LISTBOX *last=NULL,*item=NULL;

	mov	DWORD PTR _last$[ebp], 0
	mov	DWORD PTR _item$[ebp], 0

; 326  : 	short i=0;

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax

; 327  : 
; 328  : 	if(!team_lbox)

	cmp	DWORD PTR ?team_lbox@@3PAVLISTBOX@@A, 0	; team_lbox
	jne	$LN11@InitVCArgL

; 329  : 	{
; 330  : 		for(i=0;i<NUM_TEAMS;i++)

	xor	ecx, ecx
	mov	WORD PTR _i$[ebp], cx
	jmp	SHORT $LN10@InitVCArgL
$LN9@InitVCArgL:
	mov	dx, WORD PTR _i$[ebp]
	add	dx, 1
	mov	WORD PTR _i$[ebp], dx
$LN10@InitVCArgL:
	movsx	eax, WORD PTR _i$[ebp]
	cmp	eax, 8
	jge	$LN11@InitVCArgL

; 331  : 		{
; 332  : 			if(TeamInfo[i] && (TeamInfo[i]->flags & TEAM_ACTIVE))

	movsx	ecx, WORD PTR _i$[ebp]
	cmp	DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4], 0
	je	SHORT $LN7@InitVCArgL
	movsx	edx, WORD PTR _i$[ebp]
	mov	eax, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	movsx	ecx, WORD PTR [eax+350]
	and	ecx, 1
	je	SHORT $LN7@InitVCArgL

; 333  : 				item=mk_item(i,TeamInfo[i]->GetName());

	movsx	edx, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	call	?GetName@TeamClass@@QAEPADXZ		; TeamClass::GetName
	push	eax
	movsx	eax, WORD PTR _i$[ebp]
	push	eax
	call	?mk_item@@YAPAVLISTBOX@@JPAD@Z		; mk_item
	add	esp, 8
	mov	DWORD PTR _item$[ebp], eax

; 334  : 			else

	jmp	SHORT $LN6@InitVCArgL
$LN7@InitVCArgL:

; 335  : 			{
; 336  : 				item=mk_item(i,"No Team");

	push	OFFSET ??_C@_07IELFBDLE@No?5Team?$AA@
	movsx	ecx, WORD PTR _i$[ebp]
	push	ecx
	call	?mk_item@@YAPAVLISTBOX@@JPAD@Z		; mk_item
	add	esp, 8
	mov	DWORD PTR _item$[ebp], eax

; 337  : 				item->Label_->SetFlagBitOn(C_BIT_INVISIBLE);

	push	8192					; 00002000H
	mov	edx, DWORD PTR _item$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _item$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	call	eax
$LN6@InitVCArgL:

; 338  : 			}
; 339  : 
; 340  : 			if(!team_lbox)

	cmp	DWORD PTR ?team_lbox@@3PAVLISTBOX@@A, 0	; team_lbox
	jne	SHORT $LN5@InitVCArgL

; 341  : 				team_lbox=item;

	mov	ecx, DWORD PTR _item$[ebp]
	mov	DWORD PTR ?team_lbox@@3PAVLISTBOX@@A, ecx ; team_lbox

; 342  : 			else

	jmp	SHORT $LN4@InitVCArgL
$LN5@InitVCArgL:

; 343  : 				last->Next=item;

	mov	edx, DWORD PTR _last$[ebp]
	mov	eax, DWORD PTR _item$[ebp]
	mov	DWORD PTR [edx+4], eax
$LN4@InitVCArgL:

; 344  : 			last=item;

	mov	ecx, DWORD PTR _item$[ebp]
	mov	DWORD PTR _last$[ebp], ecx

; 345  : 		}

	jmp	$LN9@InitVCArgL
$LN11@InitVCArgL:

; 346  : 	}
; 347  : 	if(!action_lbox)

	cmp	DWORD PTR ?action_lbox@@3PAVLISTBOX@@A, 0 ; action_lbox
	jne	$LN3@InitVCArgL

; 348  : 	{
; 349  : 		last=mk_item(vt_occupy,TXT_OCCUPY);

	push	219					; 000000dbH
	push	1
	call	?mk_item@@YAPAVLISTBOX@@JJ@Z		; mk_item
	add	esp, 8
	mov	DWORD PTR _last$[ebp], eax

; 350  : 		action_lbox=last;

	mov	edx, DWORD PTR _last$[ebp]
	mov	DWORD PTR ?action_lbox@@3PAVLISTBOX@@A, edx ; action_lbox

; 351  : 		item=mk_item(vt_destroy,TXT_DESTROY);

	push	220					; 000000dcH
	push	2
	call	?mk_item@@YAPAVLISTBOX@@JJ@Z		; mk_item
	add	esp, 8
	mov	DWORD PTR _item$[ebp], eax

; 352  : 		last->Next=item;

	mov	eax, DWORD PTR _last$[ebp]
	mov	ecx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 353  : 		last=item;

	mov	edx, DWORD PTR _item$[ebp]
	mov	DWORD PTR _last$[ebp], edx

; 354  : 		item=mk_item(vt_attrit,TXT_ATTRIT);

	push	221					; 000000ddH
	push	3
	call	?mk_item@@YAPAVLISTBOX@@JJ@Z		; mk_item
	add	esp, 8
	mov	DWORD PTR _item$[ebp], eax

; 355  : 		last->Next=item;

	mov	eax, DWORD PTR _last$[ebp]
	mov	ecx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 356  : 		last=item;

	mov	edx, DWORD PTR _item$[ebp]
	mov	DWORD PTR _last$[ebp], edx

; 357  : 		item=mk_item(vt_intercept,TXT_INTERCEPT);

	push	222					; 000000deH
	push	4
	call	?mk_item@@YAPAVLISTBOX@@JJ@Z		; mk_item
	add	esp, 8
	mov	DWORD PTR _item$[ebp], eax

; 358  : 		last->Next=item;

	mov	eax, DWORD PTR _last$[ebp]
	mov	ecx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 359  : 		last=item;

	mov	edx, DWORD PTR _item$[ebp]
	mov	DWORD PTR _last$[ebp], edx

; 360  : 		item=mk_item(vt_degrade,TXT_DEGRADE);

	push	223					; 000000dfH
	push	5
	call	?mk_item@@YAPAVLISTBOX@@JJ@Z		; mk_item
	add	esp, 8
	mov	DWORD PTR _item$[ebp], eax

; 361  : 		last->Next=item;

	mov	eax, DWORD PTR _last$[ebp]
	mov	ecx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [eax+4], ecx
$LN3@InitVCArgL:

; 362  : 	}
; 363  : 	// 10 -> 100 %
; 364  : 	if(!percent_lbox)

	cmp	DWORD PTR ?percent_lbox@@3PAVLISTBOX@@A, 0 ; percent_lbox
	jne	$LN2@InitVCArgL

; 365  : 	{
; 366  : 		last=mk_item(1,TXT_TEN_PERC);

	push	205					; 000000cdH
	push	1
	call	?mk_item@@YAPAVLISTBOX@@JJ@Z		; mk_item
	add	esp, 8
	mov	DWORD PTR _last$[ebp], eax

; 367  : 		percent_lbox=last;

	mov	edx, DWORD PTR _last$[ebp]
	mov	DWORD PTR ?percent_lbox@@3PAVLISTBOX@@A, edx ; percent_lbox

; 368  : 		item=mk_item(2,TXT_TWENTY_PERC);

	push	206					; 000000ceH
	push	2
	call	?mk_item@@YAPAVLISTBOX@@JJ@Z		; mk_item
	add	esp, 8
	mov	DWORD PTR _item$[ebp], eax

; 369  : 		last->Next=item;

	mov	eax, DWORD PTR _last$[ebp]
	mov	ecx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 370  : 		last=item;

	mov	edx, DWORD PTR _item$[ebp]
	mov	DWORD PTR _last$[ebp], edx

; 371  : 		item=mk_item(3,TXT_THIRTY_PERC);

	push	207					; 000000cfH
	push	3
	call	?mk_item@@YAPAVLISTBOX@@JJ@Z		; mk_item
	add	esp, 8
	mov	DWORD PTR _item$[ebp], eax

; 372  : 		last->Next=item;

	mov	eax, DWORD PTR _last$[ebp]
	mov	ecx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 373  : 		last=item;

	mov	edx, DWORD PTR _item$[ebp]
	mov	DWORD PTR _last$[ebp], edx

; 374  : 		item=mk_item(4,TXT_FORTY_PERC);

	push	208					; 000000d0H
	push	4
	call	?mk_item@@YAPAVLISTBOX@@JJ@Z		; mk_item
	add	esp, 8
	mov	DWORD PTR _item$[ebp], eax

; 375  : 		last->Next=item;

	mov	eax, DWORD PTR _last$[ebp]
	mov	ecx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 376  : 		last=item;

	mov	edx, DWORD PTR _item$[ebp]
	mov	DWORD PTR _last$[ebp], edx

; 377  : 		item=mk_item(5,TXT_FIFTY_PERC);

	push	209					; 000000d1H
	push	5
	call	?mk_item@@YAPAVLISTBOX@@JJ@Z		; mk_item
	add	esp, 8
	mov	DWORD PTR _item$[ebp], eax

; 378  : 		last->Next=item;

	mov	eax, DWORD PTR _last$[ebp]
	mov	ecx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 379  : 		last=item;

	mov	edx, DWORD PTR _item$[ebp]
	mov	DWORD PTR _last$[ebp], edx

; 380  : 		item=mk_item(6,TXT_SIXTY_PERC);

	push	210					; 000000d2H
	push	6
	call	?mk_item@@YAPAVLISTBOX@@JJ@Z		; mk_item
	add	esp, 8
	mov	DWORD PTR _item$[ebp], eax

; 381  : 		last->Next=item;

	mov	eax, DWORD PTR _last$[ebp]
	mov	ecx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 382  : 		last=item;

	mov	edx, DWORD PTR _item$[ebp]
	mov	DWORD PTR _last$[ebp], edx

; 383  : 		item=mk_item(7,TXT_SEVENTY_PERC);

	push	211					; 000000d3H
	push	7
	call	?mk_item@@YAPAVLISTBOX@@JJ@Z		; mk_item
	add	esp, 8
	mov	DWORD PTR _item$[ebp], eax

; 384  : 		last->Next=item;

	mov	eax, DWORD PTR _last$[ebp]
	mov	ecx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 385  : 		last=item;

	mov	edx, DWORD PTR _item$[ebp]
	mov	DWORD PTR _last$[ebp], edx

; 386  : 		item=mk_item(8,TXT_EIGHTY_PERC);

	push	212					; 000000d4H
	push	8
	call	?mk_item@@YAPAVLISTBOX@@JJ@Z		; mk_item
	add	esp, 8
	mov	DWORD PTR _item$[ebp], eax

; 387  : 		last->Next=item;

	mov	eax, DWORD PTR _last$[ebp]
	mov	ecx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 388  : 		last=item;

	mov	edx, DWORD PTR _item$[ebp]
	mov	DWORD PTR _last$[ebp], edx

; 389  : 		item=mk_item(9,TXT_NINETY_PERC);

	push	213					; 000000d5H
	push	9
	call	?mk_item@@YAPAVLISTBOX@@JJ@Z		; mk_item
	add	esp, 8
	mov	DWORD PTR _item$[ebp], eax

; 390  : 		last->Next=item;

	mov	eax, DWORD PTR _last$[ebp]
	mov	ecx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 391  : 		last=item;

	mov	edx, DWORD PTR _item$[ebp]
	mov	DWORD PTR _last$[ebp], edx

; 392  : 		item=mk_item(10,TXT_HUNDRED_PERC);

	push	214					; 000000d6H
	push	10					; 0000000aH
	call	?mk_item@@YAPAVLISTBOX@@JJ@Z		; mk_item
	add	esp, 8
	mov	DWORD PTR _item$[ebp], eax

; 393  : 		last->Next=item;

	mov	eax, DWORD PTR _last$[ebp]
	mov	ecx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [eax+4], ecx
$LN2@InitVCArgL:

; 394  : 	}
; 395  : 
; 396  : 	if(!intercept_lbox)

	cmp	DWORD PTR ?intercept_lbox@@3PAVLISTBOX@@A, 0 ; intercept_lbox
	jne	SHORT $LN12@InitVCArgL

; 397  : 	{
; 398  : 		last=mk_item(1,TXT_ONE);

	push	215					; 000000d7H
	push	1
	call	?mk_item@@YAPAVLISTBOX@@JJ@Z		; mk_item
	add	esp, 8
	mov	DWORD PTR _last$[ebp], eax

; 399  : 		intercept_lbox=last;

	mov	edx, DWORD PTR _last$[ebp]
	mov	DWORD PTR ?intercept_lbox@@3PAVLISTBOX@@A, edx ; intercept_lbox

; 400  : 		item=mk_item(2,TXT_TWO);

	push	216					; 000000d8H
	push	2
	call	?mk_item@@YAPAVLISTBOX@@JJ@Z		; mk_item
	add	esp, 8
	mov	DWORD PTR _item$[ebp], eax

; 401  : 		last->Next=item;

	mov	eax, DWORD PTR _last$[ebp]
	mov	ecx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 402  : 		last=item;

	mov	edx, DWORD PTR _item$[ebp]
	mov	DWORD PTR _last$[ebp], edx

; 403  : 		item=mk_item(3,TXT_THREE);

	push	217					; 000000d9H
	push	3
	call	?mk_item@@YAPAVLISTBOX@@JJ@Z		; mk_item
	add	esp, 8
	mov	DWORD PTR _item$[ebp], eax

; 404  : 		last->Next=item;

	mov	eax, DWORD PTR _last$[ebp]
	mov	ecx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 405  : 		last=item;

	mov	edx, DWORD PTR _item$[ebp]
	mov	DWORD PTR _last$[ebp], edx

; 406  : 		item=mk_item(4,TXT_FOUR);

	push	218					; 000000daH
	push	4
	call	?mk_item@@YAPAVLISTBOX@@JJ@Z		; mk_item
	add	esp, 8
	mov	DWORD PTR _item$[ebp], eax

; 407  : 		last->Next=item;

	mov	eax, DWORD PTR _last$[ebp]
	mov	ecx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [eax+4], ecx
$LN12@InitVCArgL:

; 408  : 	}
; 409  : 
; 410  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?InitVCArgLists@@YAXXZ ENDP				; InitVCArgLists
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\taceng\te_team_victory.cpp
_TEXT	SEGMENT
$T2 = -56						; size = 8
_vu_id$ = -48						; size = 8
$T3 = -40						; size = 4
_c_flight$ = -36					; size = 4
_parent$ = -32						; size = 4
tv129 = -28						; size = 4
$T4 = -24						; size = 4
_flight$ = -20						; size = 4
_vc$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 4
___formal$ = 12						; size = 2
___formal$ = 16						; size = 4
?add_vc_air_unit@@YAXJFPAVC_Base@@@Z PROC		; add_vc_air_unit

; 2079 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?add_vc_air_unit@@YAXJFPAVC_Base@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 44					; 0000002cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 2080 : 	C_Base
; 2081 : 		*parent;
; 2082 : 
; 2083 : 	victory_condition
; 2084 : 		*vc;
; 2085 : 
; 2086 : 	FlightClass
; 2087 : 		*flight;
; 2088 : 
; 2089 : 	VU_ID
; 2090 : 		vu_id;

	lea	ecx, DWORD PTR _vu_id$[ebp]
	call	??0VU_ID@@QAE@XZ			; VU_ID::VU_ID

; 2091 : 
; 2092 : 	C_ATO_Flight
; 2093 : 		*c_flight;
; 2094 : 
; 2095 : 	parent = gPopupMgr->GetCallingControl ();

	mov	ecx, DWORD PTR ?gPopupMgr@@3PAVC_PopupMgr@@A ; gPopupMgr
	call	?GetCallingControl@C_PopupMgr@@QAEPAVC_Base@@XZ ; C_PopupMgr::GetCallingControl
	mov	DWORD PTR _parent$[ebp], eax

; 2096 : 
; 2097 : 	gPopupMgr->CloseMenu ();

	mov	ecx, DWORD PTR ?gPopupMgr@@3PAVC_PopupMgr@@A ; gPopupMgr
	call	?CloseMenu@C_PopupMgr@@QAEXXZ		; C_PopupMgr::CloseMenu

; 2098 : 
; 2099 : 	c_flight = (C_ATO_Flight *) ((C_TreeList *) parent)->GetLastItem ()->Item_;

	mov	ecx, DWORD PTR _parent$[ebp]
	call	?GetLastItem@C_TreeList@@QAEPAVTREELIST@@XZ ; C_TreeList::GetLastItem
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR _c_flight$[ebp], eax

; 2100 : 
; 2101 : 	flight = (Flight) FindEntity (c_flight->GetVUID());

	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _c_flight$[ebp]
	call	?GetVUID@C_ATO_Flight@@QAE?AVVU_ID@@XZ	; C_ATO_Flight::GetVUID
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?FindEntity@@YAPAVCampBaseClass@@VVU_ID@@@Z ; FindEntity
	add	esp, 8
	mov	DWORD PTR _flight$[ebp], eax

; 2102 : 
; 2103 : 	if (flight)

	cmp	DWORD PTR _flight$[ebp], 0
	je	$LN3@add_vc_air

; 2104 : 	{
; 2105 : 		vc = new victory_condition (current_tactical_mission);

	push	56					; 00000038H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T4[ebp], 0
	je	SHORT $LN5@add_vc_air
	mov	ecx, DWORD PTR ?current_tactical_mission@@3PAVtactical_mission@@A ; current_tactical_mission
	push	ecx
	mov	ecx, DWORD PTR $T4[ebp]
	call	??0victory_condition@@QAE@PAVtactical_mission@@@Z ; victory_condition::victory_condition
	mov	DWORD PTR tv129[ebp], eax
	jmp	SHORT $LN6@add_vc_air
$LN5@add_vc_air:
	mov	DWORD PTR tv129[ebp], 0
$LN6@add_vc_air:
	mov	edx, DWORD PTR tv129[ebp]
	mov	DWORD PTR $T3[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR _vc$[ebp], eax

; 2106 : 	
; 2107 : 		vc->set_team (flight->GetTeam ());

	mov	ecx, DWORD PTR _flight$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _flight$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	push	ecx
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?set_team@victory_condition@@QAEXH@Z	; victory_condition::set_team

; 2108 : 		vc->set_type (vt_intercept);

	push	4
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?set_type@victory_condition@@QAEXW4victory_type@@@Z ; victory_condition::set_type

; 2109 : 		vc->set_vu_id (vu_id);

	mov	edx, DWORD PTR _vu_id$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _vu_id$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?set_vu_id@victory_condition@@QAEXVVU_ID@@@Z ; victory_condition::set_vu_id

; 2110 : 
; 2111 : 		if (gMapMgr)

	cmp	DWORD PTR ?gMapMgr@@3PAVC_Map@@A, 0	; gMapMgr
	je	SHORT $LN1@add_vc_air

; 2112 : 		{
; 2113 : 			gMapMgr->AddVC (vc);

	mov	ecx, DWORD PTR _vc$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?gMapMgr@@3PAVC_Map@@A	; gMapMgr
	call	?AddVC@C_Map@@QAEPAVMAPICONLIST@@PAVvictory_condition@@@Z ; C_Map::AddVC
$LN1@add_vc_air:

; 2114 : 		}
; 2115 : 
; 2116 : 		update_team_victory_window ();

	call	?update_team_victory_window@@YAXXZ	; update_team_victory_window

; 2117 : 
; 2118 : 		gMainHandler->EnableWindowGroup (3400);

	push	3400					; 00000d48H
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?EnableWindowGroup@C_Handler@@QAEXJ@Z	; C_Handler::EnableWindowGroup
$LN3@add_vc_air:

; 2119 : 	}
; 2120 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?add_vc_air_unit@@YAXJFPAVC_Base@@@Z$0:
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?add_vc_air_unit@@YAXJFPAVC_Base@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-48]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?add_vc_air_unit@@YAXJFPAVC_Base@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?add_vc_air_unit@@YAXJFPAVC_Base@@@Z ENDP		; add_vc_air_unit
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\taceng\te_team_victory.cpp
_TEXT	SEGMENT
$T1 = -108						; size = 8
$T2 = -100						; size = 8
_vu_id$ = -92						; size = 8
_next_vc$ = -84						; size = 4
tv275 = -80						; size = 4
$T3 = -76						; size = 4
_height$ = -72						; size = 4
tv174 = -68						; size = 4
$T4 = -64						; size = 4
_c_squadron$ = -60					; size = 4
_c_flight$ = -56					; size = 4
$T5 = -52						; size = 4
$T6 = -48						; size = 4
_flight$ = -44						; size = 4
_id$ = -40						; size = 4
_squadron$ = -36					; size = 4
_parent$ = -32						; size = 4
_src$ = -28						; size = 4
_width$ = -24						; size = 4
_old_team$ = -20					; size = 4
_y$ = -16						; size = 4
_vc$ = -12						; size = 4
_x$ = -8						; size = 4
_loop$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 2
___formal$ = 16						; size = 4
?delete_tactical_object@@YAXJFPAVC_Base@@@Z PROC	; delete_tactical_object

; 1823 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH

; 1824 : 	C_Base
; 1825 : 		*parent;
; 1826 : 
; 1827 : 	victory_condition
; 1828 : 		*next_vc,
; 1829 : 		*vc;
; 1830 : 
; 1831 : 	unsigned char
; 1832 : 		*src;
; 1833 : 
; 1834 : 	int
; 1835 : 		id,
; 1836 : 		x, y,
; 1837 : 		old_team,
; 1838 : 		width,
; 1839 : 		height,
; 1840 : 		loop;
; 1841 : 
; 1842 : 	C_Squadron
; 1843 : 		*c_squadron;
; 1844 : 
; 1845 : 	C_ATO_Flight
; 1846 : 		*c_flight;
; 1847 : 
; 1848 : 	SquadronClass
; 1849 : 		*squadron;
; 1850 : 
; 1851 : 	FlightClass
; 1852 : 		*flight;
; 1853 : 
; 1854 : 	VU_ID
; 1855 : 		vu_id;

	lea	ecx, DWORD PTR _vu_id$[ebp]
	call	??0VU_ID@@QAE@XZ			; VU_ID::VU_ID

; 1856 : 
; 1857 : 	parent = gPopupMgr->GetCallingControl ();

	mov	ecx, DWORD PTR ?gPopupMgr@@3PAVC_PopupMgr@@A ; gPopupMgr
	call	?GetCallingControl@C_PopupMgr@@QAEPAVC_Base@@XZ ; C_PopupMgr::GetCallingControl
	mov	DWORD PTR _parent$[ebp], eax

; 1858 : 
; 1859 : 	gPopupMgr->CloseMenu ();

	mov	ecx, DWORD PTR ?gPopupMgr@@3PAVC_PopupMgr@@A ; gPopupMgr
	call	?CloseMenu@C_PopupMgr@@QAEXXZ		; C_PopupMgr::CloseMenu

; 1860 : 
; 1861 : 	id = parent->GetID ();

	mov	ecx, DWORD PTR _parent$[ebp]
	call	?GetID@C_Base@@QAEJXZ			; C_Base::GetID
	mov	DWORD PTR _id$[ebp], eax

; 1862 : 
; 1863 : 	if (id == ATO_ALL_TREE)

	cmp	DWORD PTR _id$[ebp], 1234000		; 0012d450H
	jne	SHORT $LN30@delete_tac

; 1864 : 	{
; 1865 : 		c_flight = (C_ATO_Flight *) ((C_TreeList *) parent)->GetLastItem ()->Item_;

	mov	ecx, DWORD PTR _parent$[ebp]
	call	?GetLastItem@C_TreeList@@QAEPAVTREELIST@@XZ ; C_TreeList::GetLastItem
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR _c_flight$[ebp], eax

; 1866 : 
; 1867 : 		flight = (Flight) FindEntity (c_flight->GetVUID());

	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _c_flight$[ebp]
	call	?GetVUID@C_ATO_Flight@@QAE?AVVU_ID@@XZ	; C_ATO_Flight::GetVUID
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?FindEntity@@YAPAVCampBaseClass@@VVU_ID@@@Z ; FindEntity
	add	esp, 8
	mov	DWORD PTR _flight$[ebp], eax

; 1868 : 
; 1869 : 		if (flight)

	cmp	DWORD PTR _flight$[ebp], 0
	je	SHORT $LN29@delete_tac

; 1870 : 		{
; 1871 : 			flight->Remove ();

	mov	ecx, DWORD PTR _flight$[ebp]
	call	?Remove@CampBaseClass@@QAEHXZ		; CampBaseClass::Remove

; 1872 : 
; 1873 : 			gGps->Update ();

	mov	ecx, DWORD PTR ?gGps@@3PAVGlobalPositioningSystem@@A ; gGps
	call	?Update@GlobalPositioningSystem@@QAEXXZ	; GlobalPositioningSystem::Update
$LN29@delete_tac:

; 1874 : 		}
; 1875 : 	}

	jmp	$LN31@delete_tac
$LN30@delete_tac:

; 1876 : 	else if (id == ALL_SQUADRON_TREE)

	cmp	DWORD PTR _id$[ebp], 15202		; 00003b62H
	jne	SHORT $LN27@delete_tac

; 1877 : 	{
; 1878 : 		// Its a squadron :-)
; 1879 : 		c_squadron = (C_Squadron *) ((C_TreeList *) parent)->GetLastItem ()->Item_;

	mov	ecx, DWORD PTR _parent$[ebp]
	call	?GetLastItem@C_TreeList@@QAEPAVTREELIST@@XZ ; C_TreeList::GetLastItem
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _c_squadron$[ebp], ecx

; 1880 : 
; 1881 : 		squadron = (Squadron) FindEntity (c_squadron->GetVUID());

	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _c_squadron$[ebp]
	call	?GetVUID@C_Squadron@@QAE?AVVU_ID@@XZ	; C_Squadron::GetVUID
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?FindEntity@@YAPAVCampBaseClass@@VVU_ID@@@Z ; FindEntity
	add	esp, 8
	mov	DWORD PTR _squadron$[ebp], eax

; 1882 : 
; 1883 : 		if (squadron)

	cmp	DWORD PTR _squadron$[ebp], 0
	je	SHORT $LN26@delete_tac

; 1884 : 		{
; 1885 : 			tactical_remove_squadron (squadron);

	mov	eax, DWORD PTR _squadron$[ebp]
	push	eax
	call	?tactical_remove_squadron@@YAXPAVSquadronClass@@@Z ; tactical_remove_squadron
	add	esp, 4

; 1886 : 
; 1887 : 			squadron->Remove ();

	mov	ecx, DWORD PTR _squadron$[ebp]
	call	?Remove@CampBaseClass@@QAEHXZ		; CampBaseClass::Remove

; 1888 : 
; 1889 : 			gGps->Update ();

	mov	ecx, DWORD PTR ?gGps@@3PAVGlobalPositioningSystem@@A ; gGps
	call	?Update@GlobalPositioningSystem@@QAEXXZ	; GlobalPositioningSystem::Update
$LN26@delete_tac:

; 1890 : 		}
; 1891 : 	}

	jmp	$LN31@delete_tac
$LN27@delete_tac:

; 1892 : 	else if (id >= 3000000)

	cmp	DWORD PTR _id$[ebp], 3000000		; 002dc6c0H
	jl	SHORT $LN24@delete_tac

; 1893 : 	{
; 1894 : 		// Its a victory condition - delete it.
; 1895 : 
; 1896 : 		vc = (victory_condition *) parent->GetUserNumber (0);

	push	0
	mov	ecx, DWORD PTR _parent$[ebp]
	call	?GetUserNumber@C_Base@@QAEJJ@Z		; C_Base::GetUserNumber
	mov	DWORD PTR _vc$[ebp], eax

; 1897 : 		gMapMgr->RemoveVC(vc->get_team(),vc->get_number());

	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_number@victory_condition@@QAEHXZ	; victory_condition::get_number
	push	eax
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_team@victory_condition@@QAEHXZ	; victory_condition::get_team
	push	eax
	mov	ecx, DWORD PTR ?gMapMgr@@3PAVC_Map@@A	; gMapMgr
	call	?RemoveVC@C_Map@@QAEXJJ@Z		; C_Map::RemoveVC

; 1898 : 
; 1899 : 		delete vc;

	mov	ecx, DWORD PTR _vc$[ebp]
	mov	DWORD PTR $T4[ebp], ecx
	mov	edx, DWORD PTR $T4[ebp]
	mov	DWORD PTR $T6[ebp], edx
	cmp	DWORD PTR $T6[ebp], 0
	je	SHORT $LN33@delete_tac
	push	1
	mov	ecx, DWORD PTR $T6[ebp]
	call	??_Gvictory_condition@@QAEPAXI@Z
	mov	DWORD PTR tv174[ebp], eax
	jmp	SHORT $LN34@delete_tac
$LN33@delete_tac:
	mov	DWORD PTR tv174[ebp], 0
$LN34@delete_tac:

; 1900 : 
; 1901 : 		evaluate_filter ();

	call	?evaluate_filter@@YAXXZ			; evaluate_filter

; 1902 : 
; 1903 : 		update_team_victory_window ();

	call	?update_team_victory_window@@YAXXZ	; update_team_victory_window

; 1904 : 	}
; 1905 : 	else

	jmp	$LN31@delete_tac
$LN24@delete_tac:

; 1906 : 	{
; 1907 : 		// Its actually a team we are trying to delete - just overloaded the function a little :-)
; 1908 : 		old_team = 0;

	mov	DWORD PTR _old_team$[ebp], 0

; 1909 : 
; 1910 : 		for (loop = 1; loop < 8; loop ++)

	mov	DWORD PTR _loop$[ebp], 1
	jmp	SHORT $LN22@delete_tac
$LN21@delete_tac:
	mov	eax, DWORD PTR _loop$[ebp]
	add	eax, 1
	mov	DWORD PTR _loop$[ebp], eax
$LN22@delete_tac:
	cmp	DWORD PTR _loop$[ebp], 8
	jge	SHORT $LN20@delete_tac

; 1911 : 		{
; 1912 : 			if (TeamInfo[loop])

	mov	ecx, DWORD PTR _loop$[ebp]
	cmp	DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4], 0
	je	SHORT $LN19@delete_tac

; 1913 : 			{
; 1914 : 				old_team ++;

	mov	edx, DWORD PTR _old_team$[ebp]
	add	edx, 1
	mov	DWORD PTR _old_team$[ebp], edx
$LN19@delete_tac:

; 1915 : 			}
; 1916 : 		}

	jmp	SHORT $LN21@delete_tac
$LN20@delete_tac:

; 1917 : 
; 1918 : 		if (old_team > 1) // must have some old team if you want to delete it :-)

	cmp	DWORD PTR _old_team$[ebp], 1
	jle	$LN31@delete_tac

; 1919 : 		{
; 1920 : 			for (loop = 0; loop < 8; loop ++)

	mov	DWORD PTR _loop$[ebp], 0
	jmp	SHORT $LN17@delete_tac
$LN16@delete_tac:
	mov	eax, DWORD PTR _loop$[ebp]
	add	eax, 1
	mov	DWORD PTR _loop$[ebp], eax
$LN17@delete_tac:
	cmp	DWORD PTR _loop$[ebp], 8
	jge	$LN31@delete_tac

; 1921 : 			{
; 1922 : 				if (parent == team_name[loop])

	mov	ecx, DWORD PTR _loop$[ebp]
	mov	edx, DWORD PTR _parent$[ebp]
	cmp	edx, DWORD PTR _team_name[ecx*4]
	jne	$LN14@delete_tac

; 1923 : 				{
; 1924 : 					RemoveTeam (team_mapping[loop]);

	mov	eax, DWORD PTR _loop$[ebp]
	mov	ecx, DWORD PTR _team_mapping[eax*4]
	push	ecx
	call	?RemoveTeam@@YAXH@Z			; RemoveTeam
	add	esp, 4

; 1925 : 					
; 1926 : 					// Need to remove Team Ownership on land.
; 1927 : 					
; 1928 : 					src = TheCampaign.CampMapData;

	mov	edx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A+296
	mov	DWORD PTR _src$[ebp], edx

; 1929 : 					
; 1930 : 					width = TheCampaign.TheaterSizeX / MAP_RATIO;

	movsx	eax, WORD PTR ?TheCampaign@@3VCampaignClass@@A+86
	cdq
	mov	ecx, 6
	idiv	ecx
	mov	DWORD PTR _width$[ebp], eax

; 1931 : 					height = TheCampaign.TheaterSizeY / MAP_RATIO;

	movsx	eax, WORD PTR ?TheCampaign@@3VCampaignClass@@A+88
	cdq
	mov	ecx, 6
	idiv	ecx
	mov	DWORD PTR _height$[ebp], eax

; 1932 : 					
; 1933 : 					for (y = 0; y < height; y ++)

	mov	DWORD PTR _y$[ebp], 0
	jmp	SHORT $LN13@delete_tac
$LN12@delete_tac:
	mov	edx, DWORD PTR _y$[ebp]
	add	edx, 1
	mov	DWORD PTR _y$[ebp], edx
$LN13@delete_tac:
	mov	eax, DWORD PTR _y$[ebp]
	cmp	eax, DWORD PTR _height$[ebp]
	jge	$LN11@delete_tac

; 1934 : 					{
; 1935 : 						for (x = 0; x < width; x ++)

	mov	DWORD PTR _x$[ebp], 0
	jmp	SHORT $LN10@delete_tac
$LN9@delete_tac:
	mov	ecx, DWORD PTR _x$[ebp]
	add	ecx, 1
	mov	DWORD PTR _x$[ebp], ecx
$LN10@delete_tac:
	mov	edx, DWORD PTR _x$[ebp]
	cmp	edx, DWORD PTR _width$[ebp]
	jge	$LN8@delete_tac

; 1936 : 						{
; 1937 : 							if (x & 1)

	mov	eax, DWORD PTR _x$[ebp]
	and	eax, 1
	je	SHORT $LN7@delete_tac

; 1938 : 							{
; 1939 : 								old_team = (src[(y * width + x) / 2] & 0xf0) >> 4;

	mov	eax, DWORD PTR _y$[ebp]
	imul	eax, DWORD PTR _width$[ebp]
	add	eax, DWORD PTR _x$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _src$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	and	edx, 240				; 000000f0H
	sar	edx, 4
	mov	DWORD PTR _old_team$[ebp], edx

; 1940 : 								
; 1941 : 								if (old_team == team_mapping[loop])

	mov	eax, DWORD PTR _loop$[ebp]
	mov	ecx, DWORD PTR _old_team$[ebp]
	cmp	ecx, DWORD PTR _team_mapping[eax*4]
	jne	SHORT $LN6@delete_tac

; 1942 : 								{
; 1943 : 									src[(y * width + x) / 2] &= 0x0f;

	mov	eax, DWORD PTR _y$[ebp]
	imul	eax, DWORD PTR _width$[ebp]
	add	eax, DWORD PTR _x$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	edx, DWORD PTR _src$[ebp]
	movzx	ecx, BYTE PTR [edx+eax]
	and	ecx, 15					; 0000000fH
	mov	eax, DWORD PTR _y$[ebp]
	imul	eax, DWORD PTR _width$[ebp]
	add	eax, DWORD PTR _x$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	edx, DWORD PTR _src$[ebp]
	mov	BYTE PTR [edx+eax], cl
$LN6@delete_tac:

; 1944 : 								}
; 1945 : 							}
; 1946 : 							else

	jmp	SHORT $LN5@delete_tac
$LN7@delete_tac:

; 1947 : 							{
; 1948 : 								old_team = src[(y * width + x) / 2] & 0xf;

	mov	eax, DWORD PTR _y$[ebp]
	imul	eax, DWORD PTR _width$[ebp]
	add	eax, DWORD PTR _x$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _src$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	and	edx, 15					; 0000000fH
	mov	DWORD PTR _old_team$[ebp], edx

; 1949 : 								
; 1950 : 								if (old_team == team_mapping[loop])

	mov	eax, DWORD PTR _loop$[ebp]
	mov	ecx, DWORD PTR _old_team$[ebp]
	cmp	ecx, DWORD PTR _team_mapping[eax*4]
	jne	SHORT $LN5@delete_tac

; 1951 : 								{
; 1952 : 									src[(y * width + x) / 2] &= 0xf0;

	mov	eax, DWORD PTR _y$[ebp]
	imul	eax, DWORD PTR _width$[ebp]
	add	eax, DWORD PTR _x$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	edx, DWORD PTR _src$[ebp]
	movzx	ecx, BYTE PTR [edx+eax]
	and	ecx, 240				; 000000f0H
	mov	eax, DWORD PTR _y$[ebp]
	imul	eax, DWORD PTR _width$[ebp]
	add	eax, DWORD PTR _x$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	edx, DWORD PTR _src$[ebp]
	mov	BYTE PTR [edx+eax], cl
$LN5@delete_tac:

; 1953 : 								}
; 1954 : 							}
; 1955 : 						}

	jmp	$LN9@delete_tac
$LN8@delete_tac:

; 1956 : 					}

	jmp	$LN12@delete_tac
$LN11@delete_tac:

; 1957 : 					
; 1958 : 					// Need to Fix all Objectives / Squadrons
; 1959 : 					delete_all_units_for_team (team_mapping[loop]);

	mov	eax, DWORD PTR _loop$[ebp]
	mov	ecx, DWORD PTR _team_mapping[eax*4]
	push	ecx
	call	?delete_all_units_for_team@@YAXH@Z	; delete_all_units_for_team
	add	esp, 4

; 1960 : 					
; 1961 : 					// Remove all of this team Victory Conditions
; 1962 : 					vc = current_tactical_mission->get_first_unfiltered_victory_condition ();

	mov	ecx, DWORD PTR ?current_tactical_mission@@3PAVtactical_mission@@A ; current_tactical_mission
	call	?get_first_unfiltered_victory_condition@tactical_mission@@QAEPAVvictory_condition@@XZ ; tactical_mission::get_first_unfiltered_victory_condition
	mov	DWORD PTR _vc$[ebp], eax
$LN3@delete_tac:

; 1963 : 					
; 1964 : 					while (vc)

	cmp	DWORD PTR _vc$[ebp], 0
	je	SHORT $LN2@delete_tac

; 1965 : 					{
; 1966 : 						next_vc = current_tactical_mission->get_next_unfiltered_victory_condition ();

	mov	ecx, DWORD PTR ?current_tactical_mission@@3PAVtactical_mission@@A ; current_tactical_mission
	call	?get_next_unfiltered_victory_condition@tactical_mission@@QAEPAVvictory_condition@@XZ ; tactical_mission::get_next_unfiltered_victory_condition
	mov	DWORD PTR _next_vc$[ebp], eax

; 1967 : 						
; 1968 : 						if (vc->get_team () == team_mapping[loop])

	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_team@victory_condition@@QAEHXZ	; victory_condition::get_team
	mov	edx, DWORD PTR _loop$[ebp]
	cmp	eax, DWORD PTR _team_mapping[edx*4]
	jne	SHORT $LN1@delete_tac

; 1969 : 						{
; 1970 : 							gMapMgr->RemoveVC(vc->get_team(),vc->get_number());

	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_number@victory_condition@@QAEHXZ	; victory_condition::get_number
	push	eax
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_team@victory_condition@@QAEHXZ	; victory_condition::get_team
	push	eax
	mov	ecx, DWORD PTR ?gMapMgr@@3PAVC_Map@@A	; gMapMgr
	call	?RemoveVC@C_Map@@QAEXJJ@Z		; C_Map::RemoveVC

; 1971 : 							delete vc;

	mov	eax, DWORD PTR _vc$[ebp]
	mov	DWORD PTR $T3[ebp], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR $T5[ebp], ecx
	cmp	DWORD PTR $T5[ebp], 0
	je	SHORT $LN35@delete_tac
	push	1
	mov	ecx, DWORD PTR $T5[ebp]
	call	??_Gvictory_condition@@QAEPAXI@Z
	mov	DWORD PTR tv275[ebp], eax
	jmp	SHORT $LN1@delete_tac
$LN35@delete_tac:
	mov	DWORD PTR tv275[ebp], 0
$LN1@delete_tac:

; 1972 : 						}
; 1973 : 						
; 1974 : 						vc = next_vc;

	mov	edx, DWORD PTR _next_vc$[ebp]
	mov	DWORD PTR _vc$[ebp], edx

; 1975 : 					}

	jmp	SHORT $LN3@delete_tac
$LN2@delete_tac:

; 1976 : 					
; 1977 : 					update_team_victory_window ();

	call	?update_team_victory_window@@YAXXZ	; update_team_victory_window

; 1978 : 					
; 1979 : 					break;

	jmp	SHORT $LN31@delete_tac
$LN14@delete_tac:

; 1980 : 				}
; 1981 : 			}

	jmp	$LN16@delete_tac
$LN31@delete_tac:

; 1982 : 		}
; 1983 : 	}
; 1984 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?delete_tactical_object@@YAXJFPAVC_Base@@@Z ENDP	; delete_tactical_object
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\taceng\te_team_victory.cpp
_TEXT	SEGMENT
_editbox$ = -4						; size = 4
___formal$ = 8						; size = 4
_hittype$ = 12						; size = 2
_ctrl$ = 16						; size = 4
?set_points_required_for_victory@@YAXJFPAVC_Base@@@Z PROC ; set_points_required_for_victory

; 1806 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1807 : 	C_EditBox
; 1808 : 		*editbox;
; 1809 : 
; 1810 : 	if(hittype != DIK_RETURN)

	movsx	eax, WORD PTR _hittype$[ebp]
	cmp	eax, 28					; 0000001cH
	je	SHORT $LN1@set_points

; 1811 : 		return;

	jmp	SHORT $LN2@set_points
$LN1@set_points:

; 1812 : 
; 1813 : 	editbox = (C_EditBox *) ctrl;

	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	DWORD PTR _editbox$[ebp], ecx

; 1814 : 
; 1815 : 	current_tactical_mission->set_points_required (editbox->GetInteger ());

	mov	ecx, DWORD PTR _editbox$[ebp]
	call	?GetInteger@C_EditBox@@QAEJXZ		; C_EditBox::GetInteger
	push	eax
	mov	ecx, DWORD PTR ?current_tactical_mission@@3PAVtactical_mission@@A ; current_tactical_mission
	call	?set_points_required@tactical_mission@@QAEXH@Z ; tactical_mission::set_points_required
$LN2@set_points:

; 1816 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?set_points_required_for_victory@@YAXJFPAVC_Base@@@Z ENDP ; set_points_required_for_victory
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\taceng\te_team_victory.cpp
_TEXT	SEGMENT
tv128 = -24						; size = 4
$T1 = -20						; size = 4
$T2 = -16						; size = 4
_vctrl$ = -12						; size = 4
_item$ = -8						; size = 4
_vc$ = -4						; size = 4
___formal$ = 8						; size = 4
_hittype$ = 12						; size = 2
___formal$ = 16						; size = 4
?delete_current_vc@@YAXJFPAVC_Base@@@Z PROC		; delete_current_vc

; 1523 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 1524 : 	TREELIST *item;
; 1525 : 	C_Victory *vctrl;
; 1526 : 	victory_condition *vc;
; 1527 : 
; 1528 : 	if(hittype != C_TYPE_LMOUSEUP)

	movsx	eax, WORD PTR _hittype$[ebp]
	cmp	eax, 52					; 00000034H
	je	SHORT $LN5@delete_cur

; 1529 : 		return;

	jmp	$LN6@delete_cur
$LN5@delete_cur:

; 1530 : 
; 1531 : 	if(!gVCTree)

	cmp	DWORD PTR ?gVCTree@@3PAVC_TreeList@@A, 0 ; gVCTree
	jne	SHORT $LN4@delete_cur

; 1532 : 		return;

	jmp	$LN6@delete_cur
$LN4@delete_cur:

; 1533 : 
; 1534 : 	SelectToolTypeCB(0,C_TYPE_LMOUSEUP,NULL);

	push	0
	push	52					; 00000034H
	push	0
	call	?SelectToolTypeCB@@YAXJFPAVC_Base@@@Z	; SelectToolTypeCB
	add	esp, 12					; 0000000cH

; 1535 : 	item=gVCTree->GetLastItem();

	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	call	?GetLastItem@C_TreeList@@QAEPAVTREELIST@@XZ ; C_TreeList::GetLastItem
	mov	DWORD PTR _item$[ebp], eax

; 1536 : 	if(item)

	cmp	DWORD PTR _item$[ebp], 0
	je	$LN3@delete_cur

; 1537 : 	{
; 1538 : 		vctrl=(C_Victory*)item->Item_;

	mov	ecx, DWORD PTR _item$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _vctrl$[ebp], edx

; 1539 : 		if(vctrl)

	cmp	DWORD PTR _vctrl$[ebp], 0
	je	$LN3@delete_cur

; 1540 : 		{
; 1541 : 			vc=(victory_condition*)vctrl->GetPtr();

	mov	ecx, DWORD PTR _vctrl$[ebp]
	call	?GetPtr@C_Victory@@QAEPAXXZ		; C_Victory::GetPtr
	mov	DWORD PTR _vc$[ebp], eax

; 1542 : 			if(vc)

	cmp	DWORD PTR _vc$[ebp], 0
	je	SHORT $LN3@delete_cur

; 1543 : 			{
; 1544 : 				gMapMgr->RemoveVC(vc->get_team(),vc->get_number());

	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_number@victory_condition@@QAEHXZ	; victory_condition::get_number
	push	eax
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_team@victory_condition@@QAEHXZ	; victory_condition::get_team
	push	eax
	mov	ecx, DWORD PTR ?gMapMgr@@3PAVC_Map@@A	; gMapMgr
	call	?RemoveVC@C_Map@@QAEXJJ@Z		; C_Map::RemoveVC

; 1545 : 				gVCTree->DeleteItem(item->ID_);

	mov	eax, DWORD PTR _item$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	call	?DeleteItem@C_TreeList@@QAEXJ@Z		; C_TreeList::DeleteItem

; 1546 : 				delete vc;

	mov	edx, DWORD PTR _vc$[ebp]
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR $T2[ebp], eax
	cmp	DWORD PTR $T2[ebp], 0
	je	SHORT $LN8@delete_cur
	push	1
	mov	ecx, DWORD PTR $T2[ebp]
	call	??_Gvictory_condition@@QAEPAXI@Z
	mov	DWORD PTR tv128[ebp], eax
	jmp	SHORT $LN9@delete_cur
$LN8@delete_cur:
	mov	DWORD PTR tv128[ebp], 0
$LN9@delete_cur:

; 1547 : 				gVCTree->RecalcSize();

	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	call	?RecalcSize@C_TreeList@@QAEXXZ		; C_TreeList::RecalcSize

; 1548 : 				gVCTree->Parent_->RefreshClient(gVCTree->GetClient());

	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	call	?GetClient@C_Base@@QAEFXZ		; C_Base::GetClient
	movsx	ecx, ax
	push	ecx
	mov	edx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	mov	ecx, DWORD PTR [edx+48]
	call	?RefreshClient@C_Window@@QAEXJ@Z	; C_Window::RefreshClient
$LN3@delete_cur:

; 1549 : 			}
; 1550 : 		}
; 1551 : 	}
; 1552 : 	update_team_victory_window ();

	call	?update_team_victory_window@@YAXXZ	; update_team_victory_window
$LN6@delete_cur:

; 1553 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?delete_current_vc@@YAXJFPAVC_Base@@@Z ENDP		; delete_current_vc
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\taceng\te_team_victory.cpp
_TEXT	SEGMENT
$T2 = -32						; size = 4
tv75 = -28						; size = 4
$T3 = -24						; size = 4
_item$ = -20						; size = 4
_vc$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 4
_hittype$ = 12						; size = 2
___formal$ = 16						; size = 4
?new_victory_condition@@YAXJFPAVC_Base@@@Z PROC		; new_victory_condition

; 1556 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?new_victory_condition@@YAXJFPAVC_Base@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1557 : 	victory_condition *vc;
; 1558 : 	TREELIST *item;
; 1559 : 
; 1560 : 	if (hittype != C_TYPE_LMOUSEUP)

	movsx	eax, WORD PTR _hittype$[ebp]
	cmp	eax, 52					; 00000034H
	je	SHORT $LN5@new_victor

; 1561 : 		return;

	jmp	$LN6@new_victor
$LN5@new_victor:

; 1562 : 
; 1563 : 	//MonoPrint ("New Victory Condition\n");
; 1564 : 
; 1565 : 	if(!gVCTree)

	cmp	DWORD PTR ?gVCTree@@3PAVC_TreeList@@A, 0 ; gVCTree
	jne	SHORT $LN4@new_victor

; 1566 : 		return;

	jmp	$LN6@new_victor
$LN4@new_victor:

; 1567 : 
; 1568 : 	vc = new victory_condition (current_tactical_mission);

	push	56					; 00000038H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN8@new_victor
	mov	ecx, DWORD PTR ?current_tactical_mission@@3PAVtactical_mission@@A ; current_tactical_mission
	push	ecx
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0victory_condition@@QAE@PAVtactical_mission@@@Z ; victory_condition::victory_condition
	mov	DWORD PTR tv75[ebp], eax
	jmp	SHORT $LN9@new_victor
$LN8@new_victor:
	mov	DWORD PTR tv75[ebp], 0
$LN9@new_victor:
	mov	edx, DWORD PTR tv75[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _vc$[ebp], eax

; 1569 : 	vc->set_team (1);

	push	1
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?set_team@victory_condition@@QAEXH@Z	; victory_condition::set_team

; 1570 : 	vc->control=MakeVCControl(vc);

	mov	ecx, DWORD PTR _vc$[ebp]
	push	ecx
	call	?MakeVCControl@@YAPAVC_Victory@@PAVvictory_condition@@@Z ; MakeVCControl
	add	esp, 4
	mov	edx, DWORD PTR _vc$[ebp]
	mov	DWORD PTR [edx+52], eax

; 1571 : 	
; 1572 : 	item=gVCTree->CreateItem(vc->get_number(),C_TYPE_ITEM,vc->control);

	mov	eax, DWORD PTR _vc$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	push	50					; 00000032H
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_number@victory_condition@@QAEHXZ	; victory_condition::get_number
	push	eax
	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	call	?CreateItem@C_TreeList@@QAEPAVTREELIST@@JJPAVC_Base@@@Z ; C_TreeList::CreateItem
	mov	DWORD PTR _item$[ebp], eax

; 1573 : 	if(item)

	cmp	DWORD PTR _item$[ebp], 0
	je	$LN3@new_victor

; 1574 : 	{
; 1575 : 		gVCTree->AddItem(gVCTree->GetRoot(),item);

	mov	edx, DWORD PTR _item$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	call	?GetRoot@C_TreeList@@QAEPAVTREELIST@@XZ	; C_TreeList::GetRoot
	push	eax
	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	call	?AddItem@C_TreeList@@QAEHPAVTREELIST@@0@Z ; C_TreeList::AddItem

; 1576 : 		((C_Victory*)vc->control)->SetOwner(item);

	mov	eax, DWORD PTR _item$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vc$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?SetOwner@C_Victory@@QAEXPAVTREELIST@@@Z ; C_Victory::SetOwner

; 1577 : 		vc->control->SetReady(1);

	push	1
	mov	edx, DWORD PTR _vc$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	call	?SetReady@C_Base@@QAEXF@Z		; C_Base::SetReady

; 1578 : 		vc->control->SetClient(gVCTree->GetClient());

	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	call	?GetClient@C_Base@@QAEFXZ		; C_Base::GetClient
	movzx	eax, ax
	push	eax
	mov	ecx, DWORD PTR _vc$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?SetClient@C_Base@@QAEXF@Z		; C_Base::SetClient

; 1579 : 		vc->control->SetParent(gVCTree->Parent_);

	mov	edx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	mov	eax, DWORD PTR [edx+48]
	push	eax
	mov	ecx, DWORD PTR _vc$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?SetParent@C_Base@@QAEXPAVC_Window@@@Z	; C_Base::SetParent

; 1580 : 		vc->control->SetSubParents(gVCTree->Parent_);

	mov	edx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	mov	eax, DWORD PTR [edx+48]
	push	eax
	mov	ecx, DWORD PTR _vc$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	eax, DWORD PTR _vc$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+52]
	mov	eax, DWORD PTR [edx+172]
	call	eax

; 1581 : 		gVCTree->RecalcSize();

	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	call	?RecalcSize@C_TreeList@@QAEXXZ		; C_TreeList::RecalcSize

; 1582 : 		if(gVCTree->Parent_)

	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	cmp	DWORD PTR [ecx+48], 0
	je	SHORT $LN3@new_victor

; 1583 : 			gVCTree->Parent_->RefreshClient(gVCTree->GetClient());

	mov	ecx, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	call	?GetClient@C_Base@@QAEFXZ		; C_Base::GetClient
	movsx	edx, ax
	push	edx
	mov	eax, DWORD PTR ?gVCTree@@3PAVC_TreeList@@A ; gVCTree
	mov	ecx, DWORD PTR [eax+48]
	call	?RefreshClient@C_Window@@QAEXJ@Z	; C_Window::RefreshClient
$LN3@new_victor:

; 1584 : 	}
; 1585 : 
; 1586 : 	if (gMapMgr)

	cmp	DWORD PTR ?gMapMgr@@3PAVC_Map@@A, 0	; gMapMgr
	je	SHORT $LN1@new_victor

; 1587 : 	{
; 1588 : 		gMapMgr->AddVC (vc);

	mov	ecx, DWORD PTR _vc$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?gMapMgr@@3PAVC_Map@@A	; gMapMgr
	call	?AddVC@C_Map@@QAEPAVMAPICONLIST@@PAVvictory_condition@@@Z ; C_Map::AddVC
$LN1@new_victor:

; 1589 : 	}
; 1590 : 	UpdateVCOptions(vc);

	mov	edx, DWORD PTR _vc$[ebp]
	push	edx
	call	?UpdateVCOptions@@YAXPAVvictory_condition@@@Z ; UpdateVCOptions
	add	esp, 4

; 1591 : 
; 1592 : 	evaluate_filter ();

	call	?evaluate_filter@@YAXXZ			; evaluate_filter

; 1593 : 
; 1594 : 	update_team_victory_window ();

	call	?update_team_victory_window@@YAXXZ	; update_team_victory_window
$LN6@new_victor:

; 1595 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?new_victory_condition@@YAXJFPAVC_Base@@@Z$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?new_victory_condition@@YAXJFPAVC_Base@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?new_victory_condition@@YAXJFPAVC_Base@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?new_victory_condition@@YAXJFPAVC_Base@@@Z ENDP		; new_victory_condition
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\otwdrive.h
;	COMDAT ?GetFrontTextFlags@OTWDriverClass@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFrontTextFlags@OTWDriverClass@@QAEJXZ PROC		; OTWDriverClass::GetFrontTextFlags, COMDAT
; _this$ = ecx

; 371  : 	  long GetFrontTextFlags() { return(showFrontText); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+32352]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFrontTextFlags@OTWDriverClass@@QAEJXZ ENDP		; OTWDriverClass::GetFrontTextFlags
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\otwdrive.h
;	COMDAT ?SetFrontTextFlags@OTWDriverClass@@QAEXJ@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_flags$ = 8						; size = 4
?SetFrontTextFlags@OTWDriverClass@@QAEXJ@Z PROC		; OTWDriverClass::SetFrontTextFlags, COMDAT
; _this$ = ecx

; 370  :       void SetFrontTextFlags(long flags) { showFrontText=flags; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _flags$[ebp]
	mov	DWORD PTR [eax+32352], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetFrontTextFlags@OTWDriverClass@@QAEXJ@Z ENDP		; OTWDriverClass::SetFrontTextFlags
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\taceng\te_team_victory.cpp
_TEXT	SEGMENT
?update_team_victory_window@@YAXXZ PROC			; update_team_victory_window

; 1458 : {

	push	ebp
	mov	ebp, esp

; 1459 : 	if(gMainHandler)

	cmp	DWORD PTR ?gMainHandler@@3PAVC_Handler@@A, 0 ; gMainHandler
	je	SHORT $LN4@update_tea

; 1460 : 	{
; 1461 : 		if(TheCampaign.Flags & CAMP_TACTICAL_EDIT)

	mov	eax, DWORD PTR ?TheCampaign@@3VCampaignClass@@A+64
	and	eax, 524288				; 00080000H
	je	SHORT $LN2@update_tea

; 1462 : 			UpdateVCScoring(TAC_VC_WIN,1);

	push	1
	push	40025					; 00009c59H
	call	?UpdateVCScoring@@YAXJF@Z		; UpdateVCScoring
	add	esp, 8

; 1463 : 		else

	jmp	SHORT $LN4@update_tea
$LN2@update_tea:

; 1464 : 			UpdateVCScoring(TAC_VC_WIN,0);

	push	0
	push	40025					; 00009c59H
	call	?UpdateVCScoring@@YAXJF@Z		; UpdateVCScoring
	add	esp, 8
$LN4@update_tea:

; 1465 : 	}
; 1466 : }

	pop	ebp
	ret	0
?update_team_victory_window@@YAXXZ ENDP			; update_team_victory_window
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\taceng\te_team_victory.cpp
_TEXT	SEGMENT
_editbox$ = -8						; size = 4
_ctrl$ = -4						; size = 4
_winme$ = 8						; size = 4
?hookup_team_victory_window@@YAXPAVC_Window@@@Z PROC	; hookup_team_victory_window

; 223  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 224  : 	C_Button *ctrl;
; 225  : 	C_EditBox *editbox;
; 226  : 
; 227  : 	ctrl = (C_Button *) winme->FindControl (NEW_VC);

	push	31023					; 0000792fH
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ctrl$[ebp], eax

; 228  : 	if (ctrl)

	cmp	DWORD PTR _ctrl$[ebp], 0
	je	SHORT $LN3@hookup_tea

; 229  : 		ctrl->SetCallback (new_victory_condition);

	push	OFFSET ?new_victory_condition@@YAXJFPAVC_Base@@@Z ; new_victory_condition
	mov	eax, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN3@hookup_tea:

; 230  : 
; 231  : 	ctrl = (C_Button *) winme->FindControl (TAC_DELETE_VC);

	push	30217					; 00007609H
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _ctrl$[ebp], eax

; 232  : 	if (ctrl)

	cmp	DWORD PTR _ctrl$[ebp], 0
	je	SHORT $LN2@hookup_tea

; 233  : 		ctrl->SetCallback (delete_current_vc);

	push	OFFSET ?delete_current_vc@@YAXJFPAVC_Base@@@Z ; delete_current_vc
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN2@hookup_tea:

; 234  : 
; 235  : 	editbox = (C_EditBox *) winme->FindControl (PTS_REQ_VICTORY);

	push	30746					; 0000781aH
	mov	ecx, DWORD PTR _winme$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _editbox$[ebp], eax

; 236  : 	if (editbox)

	cmp	DWORD PTR _editbox$[ebp], 0
	je	SHORT $LN4@hookup_tea

; 237  : 		editbox->SetCallback (set_points_required_for_victory);

	push	OFFSET ?set_points_required_for_victory@@YAXJFPAVC_Base@@@Z ; set_points_required_for_victory
	mov	ecx, DWORD PTR _editbox$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _editbox$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN4@hookup_tea:

; 238  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?hookup_team_victory_window@@YAXPAVC_Window@@@Z ENDP	; hookup_team_victory_window
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\include\urefresh.h
;	COMDAT ?GetID@UI_Refresher@@QAE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetID@UI_Refresher@@QAE?AVVU_ID@@XZ PROC		; UI_Refresher::GetID, COMDAT
; _this$ = ecx

; 52   : 		VU_ID GetID() { return(ID_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [eax+12]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetID@UI_Refresher@@QAE?AVVU_ID@@XZ ENDP		; UI_Refresher::GetID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\include\tac_class.h
;	COMDAT ?get_game_over@tactical_mission@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get_game_over@tactical_mission@@QAEHXZ PROC		; tactical_mission::get_game_over, COMDAT
; _this$ = ecx

; 261  : 	int get_game_over() { return(game_over); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+204]
	mov	esp, ebp
	pop	ebp
	ret	0
?get_game_over@tactical_mission@@QAEHXZ ENDP		; tactical_mission::get_game_over
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\include\tac_class.h
;	COMDAT ?set_game_over@tactical_mission@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_val$ = 8						; size = 4
?set_game_over@tactical_mission@@QAEXH@Z PROC		; tactical_mission::set_game_over, COMDAT
; _this$ = ecx

; 260  : 	void set_game_over(int val) { game_over=val; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _val$[ebp]
	mov	DWORD PTR [eax+204], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?set_game_over@tactical_mission@@QAEXH@Z ENDP		; tactical_mission::set_game_over
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gvictory_condition@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gvictory_condition@@QAEPAXI@Z PROC			; victory_condition::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1victory_condition@@QAE@XZ		; victory_condition::~victory_condition
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gvictory_condition@@QAEPAXI@Z ENDP			; victory_condition::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\team.h
;	COMDAT ?GetColor@TeamClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetColor@TeamClass@@QAEHXZ PROC			; TeamClass::GetColor, COMDAT
; _this$ = ecx

; 329  : 	int GetColor (void)							{ return (int) teamColor; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+889]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetColor@TeamClass@@QAEHXZ ENDP			; TeamClass::GetColor
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\team.h
;	COMDAT ?GetFlag@TeamClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFlag@TeamClass@@QAEHXZ PROC				; TeamClass::GetFlag, COMDAT
; _this$ = ecx

; 327  : 	int GetFlag (void)							{ return (int) teamFlag; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+888]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFlag@TeamClass@@QAEHXZ ENDP				; TeamClass::GetFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95_ext\cvictory.h
;	COMDAT ?GetPtr@C_Victory@@QAEPAXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPtr@C_Victory@@QAEPAXXZ PROC			; C_Victory::GetPtr, COMDAT
; _this$ = ecx

; 80   : 		void *GetPtr()				{ return(ptr_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+164]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetPtr@C_Victory@@QAEPAXXZ ENDP			; C_Victory::GetPtr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95_ext\cvictory.h
;	COMDAT ?SetPtr@C_Victory@@QAEXPAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ptr$ = 8						; size = 4
?SetPtr@C_Victory@@QAEXPAX@Z PROC			; C_Victory::SetPtr, COMDAT
; _this$ = ecx

; 79   : 		void SetPtr(void *ptr)		{ ptr_=ptr; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR [eax+164], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetPtr@C_Victory@@QAEXPAX@Z ENDP			; C_Victory::SetPtr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95_ext\cvictory.h
;	COMDAT ?GetPoints@C_Victory@@QAEPAVC_EditBox@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPoints@C_Victory@@QAEPAVC_EditBox@@XZ PROC		; C_Victory::GetPoints, COMDAT
; _this$ = ecx

; 77   : 		C_EditBox *GetPoints()		{ return(Points_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+156]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetPoints@C_Victory@@QAEPAVC_EditBox@@XZ ENDP		; C_Victory::GetPoints
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95_ext\cvictory.h
;	COMDAT ?GetArgs@C_Victory@@QAEPAVC_ListBox@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetArgs@C_Victory@@QAEPAVC_ListBox@@XZ PROC		; C_Victory::GetArgs, COMDAT
; _this$ = ecx

; 76   : 		C_ListBox *GetArgs()		{ return(Args_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+152]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetArgs@C_Victory@@QAEPAVC_ListBox@@XZ ENDP		; C_Victory::GetArgs
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95_ext\cvictory.h
;	COMDAT ?GetTarget@C_Victory@@QAEPAVC_Button@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTarget@C_Victory@@QAEPAVC_Button@@XZ PROC		; C_Victory::GetTarget, COMDAT
; _this$ = ecx

; 75   : 		C_Button  *GetTarget()		{ return(Target_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+148]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetTarget@C_Victory@@QAEPAVC_Button@@XZ ENDP		; C_Victory::GetTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95_ext\cvictory.h
;	COMDAT ?GetAction@C_Victory@@QAEPAVC_ListBox@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAction@C_Victory@@QAEPAVC_ListBox@@XZ PROC		; C_Victory::GetAction, COMDAT
; _this$ = ecx

; 74   : 		C_ListBox *GetAction()		{ return(Action_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+144]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetAction@C_Victory@@QAEPAVC_ListBox@@XZ ENDP		; C_Victory::GetAction
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95_ext\cvictory.h
;	COMDAT ?GetTeam@C_Victory@@QAEPAVC_ListBox@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTeam@C_Victory@@QAEPAVC_ListBox@@XZ PROC		; C_Victory::GetTeam, COMDAT
; _this$ = ecx

; 73   : 		C_ListBox *GetTeam()		{ return(Team_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+140]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetTeam@C_Victory@@QAEPAVC_ListBox@@XZ ENDP		; C_Victory::GetTeam
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95_ext\cvictory.h
;	COMDAT ?SetPoints@C_Victory@@QAEXPAVC_EditBox@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ebox$ = 8						; size = 4
?SetPoints@C_Victory@@QAEXPAVC_EditBox@@@Z PROC		; C_Victory::SetPoints, COMDAT
; _this$ = ecx

; 70   : 		void SetPoints(C_EditBox *ebox)	{ Points_=ebox; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _ebox$[ebp]
	mov	DWORD PTR [eax+156], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetPoints@C_Victory@@QAEXPAVC_EditBox@@@Z ENDP		; C_Victory::SetPoints
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95_ext\cvictory.h
;	COMDAT ?SetArgs@C_Victory@@QAEXPAVC_ListBox@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lbox$ = 8						; size = 4
?SetArgs@C_Victory@@QAEXPAVC_ListBox@@@Z PROC		; C_Victory::SetArgs, COMDAT
; _this$ = ecx

; 69   : 		void SetArgs(C_ListBox *lbox)	{ Args_=lbox; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _lbox$[ebp]
	mov	DWORD PTR [eax+152], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetArgs@C_Victory@@QAEXPAVC_ListBox@@@Z ENDP		; C_Victory::SetArgs
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95_ext\cvictory.h
;	COMDAT ?SetTarget@C_Victory@@QAEXPAVC_Button@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_btn$ = 8						; size = 4
?SetTarget@C_Victory@@QAEXPAVC_Button@@@Z PROC		; C_Victory::SetTarget, COMDAT
; _this$ = ecx

; 68   : 		void SetTarget(C_Button *btn)	{ Target_=btn; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	DWORD PTR [eax+148], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetTarget@C_Victory@@QAEXPAVC_Button@@@Z ENDP		; C_Victory::SetTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95_ext\cvictory.h
;	COMDAT ?SetAction@C_Victory@@QAEXPAVC_ListBox@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lbox$ = 8						; size = 4
?SetAction@C_Victory@@QAEXPAVC_ListBox@@@Z PROC		; C_Victory::SetAction, COMDAT
; _this$ = ecx

; 67   : 		void SetAction(C_ListBox *lbox)	{ Action_=lbox; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _lbox$[ebp]
	mov	DWORD PTR [eax+144], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetAction@C_Victory@@QAEXPAVC_ListBox@@@Z ENDP		; C_Victory::SetAction
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95_ext\cvictory.h
;	COMDAT ?SetTeam@C_Victory@@QAEXPAVC_ListBox@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lbox$ = 8						; size = 4
?SetTeam@C_Victory@@QAEXPAVC_ListBox@@@Z PROC		; C_Victory::SetTeam, COMDAT
; _this$ = ecx

; 66   : 		void SetTeam(C_ListBox *lbox)	{ Team_=lbox; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _lbox$[ebp]
	mov	DWORD PTR [eax+140], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetTeam@C_Victory@@QAEXPAVC_ListBox@@@Z ENDP		; C_Victory::SetTeam
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95_ext\cvictory.h
;	COMDAT ?SetNumber@C_Victory@@QAEXPAVC_Text@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_txt$ = 8						; size = 4
?SetNumber@C_Victory@@QAEXPAVC_Text@@@Z PROC		; C_Victory::SetNumber, COMDAT
; _this$ = ecx

; 65   : 		void SetNumber(C_Text *txt)		{ Number_=txt; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	DWORD PTR [eax+136], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetNumber@C_Victory@@QAEXPAVC_Text@@@Z ENDP		; C_Victory::SetNumber
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95_ext\cvictory.h
;	COMDAT ?SetPointsX@C_Victory@@QAEXF@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 2
?SetPointsX@C_Victory@@QAEXF@Z PROC			; C_Victory::SetPointsX, COMDAT
; _this$ = ecx

; 63   : 		void SetPointsX(short x)	{ PointsX_=x; if(Points_) Points_->SetX(GetX()+x); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _x$[ebp]
	mov	WORD PTR [eax+122], cx
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+156], 0
	je	SHORT $LN2@SetPointsX
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetX@C_Base@@QAEJXZ			; C_Base::GetX
	movsx	ecx, WORD PTR _x$[ebp]
	add	eax, ecx
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+156]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+156]
	mov	eax, DWORD PTR [edx+16]
	call	eax
$LN2@SetPointsX:
	mov	esp, ebp
	pop	ebp
	ret	4
?SetPointsX@C_Victory@@QAEXF@Z ENDP			; C_Victory::SetPointsX
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95_ext\cvictory.h
;	COMDAT ?SetArgsX@C_Victory@@QAEXF@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 2
?SetArgsX@C_Victory@@QAEXF@Z PROC			; C_Victory::SetArgsX, COMDAT
; _this$ = ecx

; 62   : 		void SetArgsX(short x)		{ ArgsX_=x; if(Args_) Args_->SetX(GetX()+x); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _x$[ebp]
	mov	WORD PTR [eax+120], cx
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+152], 0
	je	SHORT $LN2@SetArgsX
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetX@C_Base@@QAEJXZ			; C_Base::GetX
	movsx	ecx, WORD PTR _x$[ebp]
	add	eax, ecx
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+152]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+152]
	mov	eax, DWORD PTR [edx+16]
	call	eax
$LN2@SetArgsX:
	mov	esp, ebp
	pop	ebp
	ret	4
?SetArgsX@C_Victory@@QAEXF@Z ENDP			; C_Victory::SetArgsX
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95_ext\cvictory.h
;	COMDAT ?SetTargetX@C_Victory@@QAEXF@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 2
?SetTargetX@C_Victory@@QAEXF@Z PROC			; C_Victory::SetTargetX, COMDAT
; _this$ = ecx

; 61   : 		void SetTargetX(short x)	{ TargetX_=x; if(Target_) Target_->SetX(GetX()+x); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _x$[ebp]
	mov	WORD PTR [eax+118], cx
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+148], 0
	je	SHORT $LN2@SetTargetX
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetX@C_Base@@QAEJXZ			; C_Base::GetX
	movsx	ecx, WORD PTR _x$[ebp]
	add	eax, ecx
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+148]
	mov	eax, DWORD PTR [edx+16]
	call	eax
$LN2@SetTargetX:
	mov	esp, ebp
	pop	ebp
	ret	4
?SetTargetX@C_Victory@@QAEXF@Z ENDP			; C_Victory::SetTargetX
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95_ext\cvictory.h
;	COMDAT ?SetActionX@C_Victory@@QAEXF@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 2
?SetActionX@C_Victory@@QAEXF@Z PROC			; C_Victory::SetActionX, COMDAT
; _this$ = ecx

; 60   : 		void SetActionX(short x)	{ ActionX_=x; if(Action_) Action_->SetX(GetX()+x); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _x$[ebp]
	mov	WORD PTR [eax+116], cx
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+144], 0
	je	SHORT $LN2@SetActionX
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetX@C_Base@@QAEJXZ			; C_Base::GetX
	movsx	ecx, WORD PTR _x$[ebp]
	add	eax, ecx
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+144]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+144]
	mov	eax, DWORD PTR [edx+16]
	call	eax
$LN2@SetActionX:
	mov	esp, ebp
	pop	ebp
	ret	4
?SetActionX@C_Victory@@QAEXF@Z ENDP			; C_Victory::SetActionX
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95_ext\cvictory.h
;	COMDAT ?SetTeamX@C_Victory@@QAEXF@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 2
?SetTeamX@C_Victory@@QAEXF@Z PROC			; C_Victory::SetTeamX, COMDAT
; _this$ = ecx

; 59   : 		void SetTeamX(short x)		{ TeamX_=x; if(Team_) Team_->SetX(GetX()+x); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _x$[ebp]
	mov	WORD PTR [eax+114], cx
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+140], 0
	je	SHORT $LN2@SetTeamX
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetX@C_Base@@QAEJXZ			; C_Base::GetX
	movsx	ecx, WORD PTR _x$[ebp]
	add	eax, ecx
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+140]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+140]
	mov	eax, DWORD PTR [edx+16]
	call	eax
$LN2@SetTeamX:
	mov	esp, ebp
	pop	ebp
	ret	4
?SetTeamX@C_Victory@@QAEXF@Z ENDP			; C_Victory::SetTeamX
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95_ext\cvictory.h
;	COMDAT ?SetNumberX@C_Victory@@QAEXF@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 2
?SetNumberX@C_Victory@@QAEXF@Z PROC			; C_Victory::SetNumberX, COMDAT
; _this$ = ecx

; 58   : 		void SetNumberX(short x)	{ NumberX_=x; if(Number_) Number_->SetX(GetX()+x); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _x$[ebp]
	mov	WORD PTR [eax+112], cx
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+136], 0
	je	SHORT $LN2@SetNumberX
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetX@C_Base@@QAEJXZ			; C_Base::GetX
	movsx	ecx, WORD PTR _x$[ebp]
	add	eax, ecx
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+136]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+136]
	mov	eax, DWORD PTR [edx+16]
	call	eax
$LN2@SetNumberX:
	mov	esp, ebp
	pop	ebp
	ret	4
?SetNumberX@C_Victory@@QAEXF@Z ENDP			; C_Victory::SetNumberX
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95_ext\cvictory.h
;	COMDAT ?SetOwner@C_Victory@@QAEXPAVTREELIST@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_limb$ = 8						; size = 4
?SetOwner@C_Victory@@QAEXPAVTREELIST@@@Z PROC		; C_Victory::SetOwner, COMDAT
; _this$ = ecx

; 51   : 		void SetOwner(TREELIST *limb)					{ Owner_=limb; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _limb$[ebp]
	mov	DWORD PTR [eax+160], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetOwner@C_Victory@@QAEXPAVTREELIST@@@Z ENDP		; C_Victory::SetOwner
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95_ext\csquad.h
;	COMDAT ?GetVUID@C_Squadron@@QAE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetVUID@C_Squadron@@QAE?AVVU_ID@@XZ PROC		; C_Squadron::GetVUID, COMDAT
; _this$ = ecx

; 108  : 		VU_ID GetVUID() { return(vuID); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+192]
	mov	edx, DWORD PTR [eax+196]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetVUID@C_Squadron@@QAE?AVVU_ID@@XZ ENDP		; C_Squadron::GetVUID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95_ext\cicons.h
;	COMDAT ?GetIconID@C_MapIcon@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetIconID@C_MapIcon@@QAEJXZ PROC			; C_MapIcon::GetIconID, COMDAT
; _this$ = ecx

; 132  : 		long GetIconID() { if(Last_) return(Last_->ID); return(0); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+132], 0
	je	SHORT $LN1@GetIconID
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+132]
	mov	eax, DWORD PTR [edx]
	jmp	SHORT $LN2@GetIconID
$LN1@GetIconID:
	xor	eax, eax
$LN2@GetIconID:
	mov	esp, ebp
	pop	ebp
	ret	0
?GetIconID@C_MapIcon@@QAEJXZ ENDP			; C_MapIcon::GetIconID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95_ext\cflight.h
;	COMDAT ?GetVUID@C_ATO_Flight@@QAE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetVUID@C_ATO_Flight@@QAE?AVVU_ID@@XZ PROC		; C_ATO_Flight::GetVUID, COMDAT
; _this$ = ecx

; 116  : 		VU_ID GetVUID() { return(vuID); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	mov	edx, DWORD PTR [eax+200]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetVUID@C_ATO_Flight@@QAE?AVVU_ID@@XZ ENDP		; C_ATO_Flight::GetVUID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\chandler.h
;	COMDAT ?GetAppWnd@C_Handler@@QAEPAUHWND__@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAppWnd@C_Handler@@QAEPAUHWND__@@XZ PROC		; C_Handler::GetAppWnd, COMDAT
; _this$ = ecx

; 244  : 		HWND GetAppWnd() { return(AppWindow_);}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetAppWnd@C_Handler@@QAEPAUHWND__@@XZ ENDP		; C_Handler::GetAppWnd
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cpopmgr.h
;	COMDAT ?GetCallingControl@C_PopupMgr@@QAEPAVC_Base@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCallingControl@C_PopupMgr@@QAEPAVC_Base@@XZ PROC	; C_PopupMgr::GetCallingControl, COMDAT
; _this$ = ecx

; 58   : 		C_Base *GetCallingControl() { return(Control_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+24]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCallingControl@C_PopupMgr@@QAEPAVC_Base@@XZ ENDP	; C_PopupMgr::GetCallingControl
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\ceditbox.h
;	COMDAT ?GetInteger@C_EditBox@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetInteger@C_EditBox@@QAEJXZ PROC			; C_EditBox::GetInteger, COMDAT
; _this$ = ecx

; 71   : 		long GetInteger() { return(Integer_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+108]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetInteger@C_EditBox@@QAEJXZ ENDP			; C_EditBox::GetInteger
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\ceditbox.h
;	COMDAT ?SetMaxInteger@C_EditBox@@QAEXJ@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
?SetMaxInteger@C_EditBox@@QAEXJ@Z PROC			; C_EditBox::SetMaxInteger, COMDAT
; _this$ = ecx

; 63   : 		void SetMaxInteger(long value) { MaxInteger_=value; if(Integer_ > MaxInteger_) {Integer_=MaxInteger_;CopyToText();}}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [eax+116], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+108]
	cmp	ecx, DWORD PTR [eax+116]
	jle	SHORT $LN2@SetMaxInte
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+116]
	mov	DWORD PTR [edx+108], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CopyToText@C_EditBox@@AAEXXZ		; C_EditBox::CopyToText
$LN2@SetMaxInte:
	mov	esp, ebp
	pop	ebp
	ret	4
?SetMaxInteger@C_EditBox@@QAEXJ@Z ENDP			; C_EditBox::SetMaxInteger
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\ceditbox.h
;	COMDAT ?SetMinInteger@C_EditBox@@QAEXJ@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
?SetMinInteger@C_EditBox@@QAEXJ@Z PROC			; C_EditBox::SetMinInteger, COMDAT
; _this$ = ecx

; 60   : 		void SetMinInteger(long value) { MinInteger_=value; if(Integer_ < MinInteger_) {Integer_=MinInteger_;CopyToText();}}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [eax+112], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+108]
	cmp	ecx, DWORD PTR [eax+112]
	jge	SHORT $LN2@SetMinInte
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	mov	DWORD PTR [edx+108], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CopyToText@C_EditBox@@AAEXXZ		; C_EditBox::CopyToText
$LN2@SetMinInte:
	mov	esp, ebp
	pop	ebp
	ret	4
?SetMinInteger@C_EditBox@@QAEXJ@Z ENDP			; C_EditBox::SetMinInteger
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\ctree.h
;	COMDAT ?GetLastItem@C_TreeList@@QAEPAVTREELIST@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetLastItem@C_TreeList@@QAEPAVTREELIST@@XZ PROC	; C_TreeList::GetLastItem, COMDAT
; _this$ = ecx

; 119  : 		TREELIST *GetLastItem() { return(LastFound_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+140]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLastItem@C_TreeList@@QAEPAVTREELIST@@XZ ENDP	; C_TreeList::GetLastItem
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\ctree.h
;	COMDAT ?GetRoot@C_TreeList@@QAEPAVTREELIST@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetRoot@C_TreeList@@QAEPAVTREELIST@@XZ PROC		; C_TreeList::GetRoot, COMDAT
; _this$ = ecx

; 118  : 		TREELIST *GetRoot() { return(Root_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+136]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetRoot@C_TreeList@@QAEPAVTREELIST@@XZ ENDP		; C_TreeList::GetRoot
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\clistbox.h
;	COMDAT ?SetOpenCallback@C_ListBox@@QAEXP6AXPAVC_Base@@@Z@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_cb$ = 8						; size = 4
?SetOpenCallback@C_ListBox@@QAEXP6AXPAVC_Base@@@Z@Z PROC ; C_ListBox::SetOpenCallback, COMDAT
; _this$ = ecx

; 113  : 		void SetOpenCallback(void (*cb)(C_Base*))	{ OpenCallback_=cb; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _cb$[ebp]
	mov	DWORD PTR [eax+196], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetOpenCallback@C_ListBox@@QAEXP6AXPAVC_Base@@@Z@Z ENDP ; C_ListBox::SetOpenCallback
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\clistbox.h
;	COMDAT ?GetTextID@C_ListBox@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTextID@C_ListBox@@QAEJXZ PROC			; C_ListBox::GetTextID, COMDAT
; _this$ = ecx

; 109  : 		long GetTextID() { return(LabelVal_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+104]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetTextID@C_ListBox@@QAEJXZ ENDP			; C_ListBox::GetTextID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\clistbox.h
;	COMDAT ?SetBgColor@C_ListBox@@QAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_color$ = 8						; size = 4
?SetBgColor@C_ListBox@@QAEXK@Z PROC			; C_ListBox::SetBgColor, COMDAT
; _this$ = ecx

; 87   : 		void SetBgColor(COLORREF color) { BgColor_=color; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _color$[ebp]
	mov	DWORD PTR [eax+156], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetBgColor@C_ListBox@@QAEXK@Z ENDP			; C_ListBox::SetBgColor
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cbase.h
;	COMDAT ?GetW@C_Base@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetW@C_Base@@QAEJXZ PROC				; C_Base::GetW, COMDAT
; _this$ = ecx

; 143  : 		long GetW()					{ return(w_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+32]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetW@C_Base@@QAEJXZ ENDP				; C_Base::GetW
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cbase.h
;	COMDAT ?GetX@C_Base@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetX@C_Base@@QAEJXZ PROC				; C_Base::GetX, COMDAT
; _this$ = ecx

; 141  : 		long GetX()					{ return(x_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+24]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetX@C_Base@@QAEJXZ ENDP				; C_Base::GetX
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cbase.h
;	COMDAT ?GetClient@C_Base@@QAEFXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetClient@C_Base@@QAEFXZ PROC				; C_Base::GetClient, COMDAT
; _this$ = ecx

; 140  : 		short GetClient()			{ return(Client_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+40]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetClient@C_Base@@QAEFXZ ENDP				; C_Base::GetClient
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cbase.h
;	COMDAT ?GetFlags@C_Base@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFlags@C_Base@@QAEJXZ PROC				; C_Base::GetFlags, COMDAT
; _this$ = ecx

; 139  : 		long  GetFlags()			{ return(Flags_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFlags@C_Base@@QAEJXZ ENDP				; C_Base::GetFlags
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cbase.h
;	COMDAT ?GetID@C_Base@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetID@C_Base@@QAEJXZ PROC				; C_Base::GetID, COMDAT
; _this$ = ecx

; 134  : 		long  GetID()				{ return(ID_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetID@C_Base@@QAEJXZ ENDP				; C_Base::GetID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cbase.h
;	COMDAT ?SetReady@C_Base@@QAEXF@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_r$ = 8							; size = 2
?SetReady@C_Base@@QAEXF@Z PROC				; C_Base::SetReady, COMDAT
; _this$ = ecx

; 116  : 		void SetReady(short r)									{ Ready_=r; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _r$[ebp]
	mov	WORD PTR [eax+42], cx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetReady@C_Base@@QAEXF@Z ENDP				; C_Base::SetReady
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cbase.h
;	COMDAT ?SetParent@C_Base@@QAEXPAVC_Window@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_win$ = 8						; size = 4
?SetParent@C_Base@@QAEXPAVC_Window@@@Z PROC		; C_Base::SetParent, COMDAT
; _this$ = ecx

; 115  : 		void SetParent(C_Window *win)							{ Parent_=win; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _win$[ebp]
	mov	DWORD PTR [eax+48], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetParent@C_Base@@QAEXPAVC_Window@@@Z ENDP		; C_Base::SetParent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cbase.h
;	COMDAT ?SetClient@C_Base@@QAEXF@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_client$ = 8						; size = 2
?SetClient@C_Base@@QAEXF@Z PROC				; C_Base::SetClient, COMDAT
; _this$ = ecx

; 98   : 		void SetClient(short client)							{ Client_=client; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _client$[ebp]
	mov	WORD PTR [eax+40], cx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetClient@C_Base@@QAEXF@Z ENDP				; C_Base::SetClient
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cbase.h
;	COMDAT ?SetGroup@C_Base@@QAEXJ@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_id$ = 8						; size = 4
?SetGroup@C_Base@@QAEXJ@Z PROC				; C_Base::SetGroup, COMDAT
; _this$ = ecx

; 96   : 		void SetGroup(long id)									{ Section_[_GROUP_]=id; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _id$[ebp]
	mov	DWORD PTR [ecx+eax+8], edx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetGroup@C_Base@@QAEXJ@Z ENDP				; C_Base::SetGroup
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_System_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_System_error_category@std@@UAEPAXI@Z PROC		; std::_System_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_System_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_System_error_category@std@@UAEPAXI@Z ENDP		; std::_System_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_System_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_System_error_category@std@@UAE@XZ PROC		; std::_System_error_category::~_System_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_System_error_category@std@@UAE@XZ ENDP		; std::_System_error_category::~_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::_System_error_category::default_error_condition, COMDAT
; _this$ = ecx

; 641  : 		{	// make error_condition for error code (generic if possible)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 642  : 		if (_Syserror_map(_Errval))

	mov	eax, DWORD PTR __Errval$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@default_er

; 643  : 			return (error_condition(_Errval, generic_category()));

	call	?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@default_er

; 644  : 		else

	jmp	SHORT $LN3@default_er
$LN2@default_er:

; 645  : 			return (error_condition(_Errval, system_category()));

	call	?system_category@std@@YAABVerror_category@1@XZ ; std::system_category
	push	eax
	mov	edx, DWORD PTR __Errval$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@default_er:

; 646  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::_System_error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_System_error_category::message, COMDAT
; _this$ = ecx

; 634  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 635  : 		const char *_Name = _Winerror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Winerror_map@std@@YAPBDH@Z		; std::_Winerror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 636  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 637  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_System_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_System_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_System_error_category@std@@UBEPBDXZ PROC		; std::_System_error_category::name, COMDAT
; _this$ = ecx

; 629  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 630  : 		return ("system");

	mov	eax, OFFSET ??_C@_06FHFOAHML@system?$AA@

; 631  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_System_error_category@std@@UBEPBDXZ ENDP		; std::_System_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_System_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_System_error_category@std@@QAE@XZ PROC		; std::_System_error_category::_System_error_category, COMDAT
; _this$ = ecx

; 624  : 	_System_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_System_error_category@std@@6B@

; 625  : 		{	// default constructor
; 626  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_System_error_category@std@@QAE@XZ ENDP		; std::_System_error_category::_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Iostream_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Iostream_error_category@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iostream_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Iostream_error_category@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Iostream_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Iostream_error_category@std@@UAE@XZ PROC		; std::_Iostream_error_category::~_Iostream_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Iostream_error_category@std@@UAE@XZ ENDP		; std::_Iostream_error_category::~_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT
; _this$ = ecx

; 611  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 612  : 		if (_Errcode == (int)io_errc::stream)

	cmp	DWORD PTR __Errcode$[ebp], 1
	jne	SHORT $LN2@message

; 613  : 			return ("iostream stream error");

	push	OFFSET ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@message

; 614  : 		else

	jmp	SHORT $LN3@message
$LN2@message:

; 615  : 			return (_Generic_error_category::message(_Errcode));

	mov	ecx, DWORD PTR __Errcode$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@message:

; 616  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Iostream_error_category@std@@UBEPBDXZ PROC	; std::_Iostream_error_category::name, COMDAT
; _this$ = ecx

; 606  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 607  : 		return ("iostream");

	mov	eax, OFFSET ??_C@_08LLGCOLLL@iostream?$AA@

; 608  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Iostream_error_category@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Iostream_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iostream_error_category@std@@QAE@XZ PROC		; std::_Iostream_error_category::_Iostream_error_category, COMDAT
; _this$ = ecx

; 601  : 	_Iostream_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Iostream_error_category@std@@6B@

; 602  : 		{	// default constructor
; 603  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iostream_error_category@std@@QAE@XZ ENDP		; std::_Iostream_error_category::_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Generic_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Generic_error_category@std@@UAE@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Generic_error_category@std@@UAE@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 590  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 591  : 		const char *_Name = _Syserror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 592  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 593  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 585  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		return ("generic");

	mov	eax, OFFSET ??_C@_07DCLBNMLN@generic?$AA@

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Generic_error_category@std@@QAE@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT
; _this$ = ecx

; 580  : 	_Generic_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0error_category@std@@QAE@XZ		; std::error_category::error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Generic_error_category@std@@6B@

; 581  : 		{	// default constructor
; 582  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Generic_error_category@std@@QAE@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_condition@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv78 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8error_condition@std@@QBE_NABV01@@Z PROC		; std::error_condition::operator==, COMDAT
; _this$ = ecx

; 376  : 		{	// test if *this == _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 377  : 		return (category() == _Right.category()
; 378  : 			&& value() == _Right.value());

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	mov	ecx, eax
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	cmp	esi, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv78[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv78[ebp]

; 379  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??8error_condition@std@@QBE_NABV01@@Z ENDP		; std::error_condition::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 354  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 356  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 349  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 350  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 351  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 316  : 		{	// construct from error code and category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Cat$[ebp]
	mov	DWORD PTR [edx+4], eax

; 317  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 256  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 257  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 258  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 251  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 252  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 253  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gerror_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gerror_category@std@@UAEPAXI@Z PROC			; std::error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gerror_category@std@@UAEPAXI@Z ENDP			; std::error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv65 = -4						; size = 4
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 184  : 		{	// compare categories for equality

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 185  : 		return (this == &_Right);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv65[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv65[ebp]

; 186  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -4						; size = 4
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 415  : 	{	// test if conditions same for this category

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 416  : 	return (*this == _Code.category() && _Code.value() == _Errval);

	mov	ecx, DWORD PTR __Code$[ebp]
	call	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@equivalent
	mov	ecx, DWORD PTR __Code$[ebp]
	call	?value@error_code@std@@QBEHXZ		; std::error_code::value
	cmp	eax, DWORD PTR __Errval$[ebp]
	jne	SHORT $LN3@equivalent
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN4@equivalent
$LN3@equivalent:
	mov	DWORD PTR tv74[ebp], 0
$LN4@equivalent:
	mov	al, BYTE PTR tv74[ebp]

; 417  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 408  : 	{	// test if error code same condition

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 409  : 	return (default_error_condition(_Errval) == _Cond);

	mov	eax, DWORD PTR __Cond$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	ecx, eax
	call	??8error_condition@std@@QBE_NABV01@@Z	; std::error_condition::operator==

; 410  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 401  : 	{	// make error_condition for error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 402  : 	return (error_condition(_Errval, *this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 403  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 167  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 168  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0error_category@std@@QAE@XZ PROC			; std::error_category::error_category, COMDAT
; _this$ = ecx

; 162  : 	error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 163  : 		{	// default constructor
; 164  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0error_category@std@@QAE@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?system_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?system_category@std@@YAABVerror_category@1@XZ PROC	; std::system_category, COMDAT

; 679  : 	{	// get system_category

	push	ebp
	mov	ebp, esp

; 680  : 	return (_Error_objects<int>::_System_object);

	mov	eax, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object

; 681  : 	}

	pop	ebp
	ret	0
?system_category@std@@YAABVerror_category@1@XZ ENDP	; std::system_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?generic_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?generic_category@std@@YAABVerror_category@1@XZ PROC	; std::generic_category, COMDAT

; 669  : 	{	// get generic_category

	push	ebp
	mov	ebp, esp

; 670  : 	return (_Error_objects<int>::_Generic_object);

	mov	eax, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object

; 671  : 	}

	pop	ebp
	ret	0
?generic_category@std@@YAABVerror_category@1@XZ ENDP	; std::generic_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocale
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC				; std::locale::id::id, COMDAT
; _this$ = ecx

; 74   : 			{	// construct with specified stamp value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx

; 75   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ PROC ; VuBin<VuSessionEntity>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ENDP ; VuBin<VuSessionEntity>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2275 : 		{	// report an out_of_range error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2276 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN2@Xran:

; 2277 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2270 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2271 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN2@Xlen:

; 2272 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Ptr$1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2253 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2254 : 		if (!_Built)

	movzx	eax, BYTE PTR __Built$[ebp]
	test	eax, eax
	jne	SHORT $LN4@Tidy
	jmp	SHORT $LN3@Tidy
$LN4@Tidy:

; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN3@Tidy

; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Ptr$1[ebp], eax

; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 2260 : 			if (0 < _Newsize)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN1@Tidy

; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$1[ebp]
	push	ecx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Tidy:

; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Ptr$1[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN3@Tidy:

; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2266 : 		_Eos(_Newsize);

	mov	edx, DWORD PTR __Newsize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2267 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2237 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	cmp	DWORD PTR __Ptr$[ebp], 0
	je	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	cmp	DWORD PTR __Ptr$[ebp], eax
	jb	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
$LN2@Inside:

; 2240 : 			return (false);	// don't ask

	xor	al, al
	jmp	SHORT $LN4@Inside

; 2241 : 		else

	jmp	SHORT $LN4@Inside
$LN3@Inside:

; 2242 : 			return (true);

	mov	al, 1
$LN4@Inside:

; 2243 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
tv136 = -12						; size = 4
tv129 = -8						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2224 : 		if (max_size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN6@Grow

; 2225 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN6@Grow:

; 2226 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN5@Grow

; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	jmp	SHORT $LN4@Grow
$LN5@Grow:

; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	movzx	edx, BYTE PTR __Trim$[ebp]
	test	edx, edx
	je	SHORT $LN3@Grow
	cmp	DWORD PTR __Newsize$[ebp], 16		; 00000010H
	jae	SHORT $LN3@Grow

; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jae	SHORT $LN9@Grow
	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv129[ebp], edx
	jmp	SHORT $LN10@Grow
$LN9@Grow:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR tv129[ebp], ecx
$LN10@Grow:
	mov	edx, DWORD PTR tv129[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
	jmp	SHORT $LN4@Grow
$LN3@Grow:

; 2231 : 		else if (_Newsize == 0)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $LN4@Grow

; 2232 : 			_Eos(0);	// new size is zero, just null terminate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN4@Grow:

; 2233 : 		return (0 < _Newsize);	// return true only if more work to do

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN11@Grow
	mov	DWORD PTR tv136[ebp], 1
	jmp	SHORT $LN12@Grow
$LN11@Grow:
	mov	DWORD PTR tv136[ebp], 0
$LN12@Grow:
	mov	al, BYTE PTR tv136[ebp]
$LN8@Grow:

; 2234 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [eax+16], ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 2219 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
tv205 = -48						; size = 4
tv204 = -44						; size = 4
tv203 = -40						; size = 4
tv202 = -36						; size = 4
__Ptr$ = -32						; size = 4
__Newres$ = -28						; size = 4
_this$ = -24						; size = 4
$T2 = -19						; size = 1
$T3 = -18						; size = 1
$T4 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Newres$[ebp], eax

; 2184 : 		if (max_size() < _Newres)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newres$[ebp]
	jae	SHORT $LN9@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx
	jmp	SHORT $LN8@Copy
$LN9@Copy:

; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)

	mov	eax, DWORD PTR __Newres$[ebp]
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	shr	ecx, 1
	cmp	ecx, eax
	ja	SHORT $LN7@Copy
	jmp	SHORT $LN8@Copy
$LN7@Copy:

; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+20]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, esi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], eax
	ja	SHORT $LN5@Copy

; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	shr	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR __Newres$[ebp], eax

; 2191 : 		else

	jmp	SHORT $LN8@Copy
$LN5@Copy:

; 2192 : 			_Newres = max_size();	// settle for max_size()

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	DWORD PTR __Newres$[ebp], eax
$LN8@Copy:

; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv202[ebp], eax
	mov	eax, DWORD PTR __Newres$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR tv202[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv203[ebp], eax
	mov	ecx, DWORD PTR tv203[ebp]
	mov	DWORD PTR __Ptr$[ebp], ecx
	jmp	SHORT $LN12@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2197 : 		_CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], edx

; 2199 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv204[ebp], eax
	mov	ecx, DWORD PTR __Newres$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR tv204[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv205[ebp], eax
	mov	edx, DWORD PTR tv205[ebp]
	mov	DWORD PTR __Ptr$[ebp], edx
	jmp	SHORT $LN14@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2203 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 2204 : 			_CATCH_END

	mov	eax, $LN17@Copy
	ret	0
$LN14@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2
$LN17@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2:

; 2205 : 		_CATCH_END

	mov	eax, $LN19@Copy
	ret	0
$LN12@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3
$LN19@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jbe	SHORT $LN1@Copy

; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements

	mov	eax, DWORD PTR __Oldlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Copy:

; 2210 : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);

	lea	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>

; 2212 : 		this->_Myres = _Newres;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newres$[ebp]
	mov	DWORD PTR [edx+20], eax

; 2213 : 		_Eos(_Oldlen);

	mov	ecx, DWORD PTR __Oldlen$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN11@Copy:

; 2214 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv75 = -12						; size = 4
__Num$ = -8						; size = 4
$T1 = -1						; size = 1
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1737 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1738 : 		size_type _Num = this->_Getal().max_size();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
	mov	DWORD PTR __Num$[ebp], eax

; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$[ebp], 1
	ja	SHORT $LN3@max_size
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	ecx, DWORD PTR __Num$[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv75[ebp], ecx
$LN4@max_size:
	mov	eax, DWORD PTR tv75[ebp]

; 1740 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1732 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1733 : 		return (this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]

; 1734 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$1 = -12					; size = 4
__Ptr$2 = -8						; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1317 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1318 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN4@erase

; 1319 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN4@erase:

; 1320 : 		if (this->_Mysize - _Off <= _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Off$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	ja	SHORT $LN3@erase

; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)

	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
	jmp	SHORT $LN2@erase
$LN3@erase:

; 1322 : 		else if (0 < _Count)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN2@erase

; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Ptr$2[ebp], eax

; 1325 : 			size_type _Newsize = this->_Mysize - _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Newsize$1[ebp], eax

; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	sub	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$2[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$2[ebp]
	push	eax
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 1327 : 			_Eos(_Newsize);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@erase:

; 1328 : 			}
; 1329 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN6@erase:

; 1330 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1309 : 		{	// erase elements [_Off, ...)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1310 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN1@erase

; 1311 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN1@erase:

; 1312 : 		_Eos(_Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1313 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@erase:

; 1314 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1142 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1145 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@assign

; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	jmp	SHORT $LN3@assign
$LN2@assign:

; 1132 : 
; 1133 : 		if (_Grow(_Count))

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@assign

; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1136 : 			_Eos(_Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@assign:

; 1137 : 			}
; 1138 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@assign:

; 1139 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1105 : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $LN5@assign

; 1106 : 			_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN5@assign:

; 1107 : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 1108 : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Num$[ebp]
	jae	SHORT $LN4@assign

; 1109 : 			_Num = _Count;	// trim _Num to size

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
$LN4@assign:

; 1110 : 
; 1111 : 		if (this == &_Right)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@assign

; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	mov	eax, DWORD PTR __Roff$[ebp]
	add	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	mov	ecx, DWORD PTR __Roff$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	jmp	SHORT $LN2@assign
$LN3@assign:

; 1113 : 		else if (_Grow(_Num))

	push	0
	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@assign

; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);

	mov	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1117 : 			_Eos(_Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@assign:

; 1118 : 			}
; 1119 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN7@assign:

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 791  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >

; 792  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 793  : 		assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 794  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 688  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 689  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 690  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 635  : 	_String_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >

; 636  : 		{	// construct allocator from _Al
; 637  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		{	// determine current pointer to buffer for nonmutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 522  : 		return (this->_BUF_SIZE <= this->_Myres
; 523  : 			? _STD addressof(*this->_Bx._Ptr)
; 524  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 525  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		{	// determine current pointer to buffer for mutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 515  : 		return (this->_BUF_SIZE <= this->_Myres
; 516  : 			? _STD addressof(*this->_Bx._Ptr)
; 517  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 518  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 496  : 	_String_val()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 497  : 		{	// initialize values
; 498  : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 499  : 		_Myres = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 500  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 913  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 914  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
	add	esp, 4

; 915  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 886  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 887  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate

; 888  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 875  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 877  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 830  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>

; 831  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 761  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp

; 762  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@D@std@@QBEIXZ	; std::allocator<char>::max_size

; 763  : 		}

	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

	or	eax, -1

; 629  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 590  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8

; 592  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 565  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 563  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 564  : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 565  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 551  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@move
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@move
$LN3@move:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@move:
	mov	eax, DWORD PTR tv69[ebp]

; 554  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 528  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@copy
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@copy
$LN3@copy:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@copy:
	mov	eax, DWORD PTR tv69[ebp]

; 531  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 521  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp
	push	ecx

; 522  : 		return (*_First == 0 ? 0
; 523  : 			: _CSTD strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@length
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN4@length
$LN3@length:
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR tv68[ebp], eax
$LN4@length:
	mov	eax, DWORD PTR tv68[ebp]

; 524  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 65   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 60   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 61   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Id@VuEntity@@QBE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?Id@VuEntity@@QBE?AVVU_ID@@XZ PROC			; VuEntity::Id, COMDAT
; _this$ = ecx

; 131  : 	VU_ID Id() const	{ return share_.id_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?Id@VuEntity@@QBE?AVVU_ID@@XZ ENDP			; VuEntity::Id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
;	COMDAT ??9VU_ID@@QBE_NABV0@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -2						; size = 1
tv73 = -1						; size = 1
_rhs$ = 8						; size = 4
??9VU_ID@@QBE_NABV0@@Z PROC				; VU_ID::operator!=, COMDAT
; _this$ = ecx

; 111  : 	bool operator != (const VU_ID &rhs) const { 

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 112  : 		return (
; 113  : 			num_ == rhs.num_ ? 
; 114  : 			(creator_ == rhs.creator_ ? false : true) : 
; 115  : 			true
; 116  : 		); 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN5@operator
	mov	eax, DWORD PTR _rhs$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??8VU_SESSION_ID@@QBEHABV0@@Z		; VU_SESSION_ID::operator==
	test	eax, eax
	je	SHORT $LN3@operator
	mov	BYTE PTR tv73[ebp], 0
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	BYTE PTR tv73[ebp], 1
$LN4@operator:
	mov	cl, BYTE PTR tv73[ebp]
	mov	BYTE PTR tv74[ebp], cl
	jmp	SHORT $LN6@operator
$LN5@operator:
	mov	BYTE PTR tv74[ebp], 1
$LN6@operator:
	mov	al, BYTE PTR tv74[ebp]

; 117  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
??9VU_ID@@QBE_NABV0@@Z ENDP				; VU_ID::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
;	COMDAT ??0VU_ID@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0VU_ID@@QAE@XZ PROC					; VU_ID::VU_ID, COMDAT
; _this$ = ecx

; 100  : 	VU_ID() : num_(0), creator_(0){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0VU_SESSION_ID@@QAE@K@Z		; VU_SESSION_ID::VU_SESSION_ID
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0VU_ID@@QAE@XZ ENDP					; VU_ID::VU_ID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
;	COMDAT ??8VU_SESSION_ID@@QBEHABV0@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_rhs$ = 8						; size = 4
??8VU_SESSION_ID@@QBEHABV0@@Z PROC			; VU_SESSION_ID::operator==, COMDAT
; _this$ = ecx

; 55   : 	int operator == (const VU_SESSION_ID &rhs) const{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return (value_ == rhs.value_ ? TRUE : FALSE); 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv67[ebp], 0
$LN4@operator:
	mov	eax, DWORD PTR tv67[ebp]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
??8VU_SESSION_ID@@QBEHABV0@@Z ENDP			; VU_SESSION_ID::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
;	COMDAT ??0VU_SESSION_ID@@QAE@K@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??0VU_SESSION_ID@@QAE@K@Z PROC				; VU_SESSION_ID::VU_SESSION_ID, COMDAT
; _this$ = ecx

; 53   : 	VU_SESSION_ID(unsigned long value) : value_((unsigned long)value) { }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0VU_SESSION_ID@@QAE@K@Z ENDP				; VU_SESSION_ID::VU_SESSION_ID
_TEXT	ENDS
END
