; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\UI\SRC\campaign\cmap.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B ; std::ios_base::failure::_Stream_err
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B
CONST	SEGMENT
?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B DD 01H ; std::ios_base::failure::_Stream_err
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
PUBLIC	??0VU_SESSION_ID@@QAE@K@Z			; VU_SESSION_ID::VU_SESSION_ID
PUBLIC	??8VU_SESSION_ID@@QBEHABV0@@Z			; VU_SESSION_ID::operator==
PUBLIC	??0VU_ID@@QAE@XZ				; VU_ID::VU_ID
PUBLIC	??8VU_ID@@QBE_NABV0@@Z				; VU_ID::operator==
PUBLIC	??9VU_ID@@QBE_NABV0@@Z				; VU_ID::operator!=
PUBLIC	?Id@VuEntity@@QBE?AVVU_ID@@XZ			; VuEntity::Id
PUBLIC	?XPos@VuEntity@@QBEMXZ				; VuEntity::XPos
PUBLIC	?YPos@VuEntity@@QBEMXZ				; VuEntity::YPos
PUBLIC	?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ	; VuEntity::EntityType
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	?GetWPTarget@WayPointClass@@QAEPAVCampBaseClass@@XZ ; WayPointClass::GetWPTarget
PUBLIC	?GetWPAction@WayPointClass@@QAEHXZ		; WayPointClass::GetWPAction
PUBLIC	?GetWPFlags@WayPointClass@@QAEKXZ		; WayPointClass::GetWPFlags
PUBLIC	?GetNextWP@WayPointClass@@QAEPAV1@XZ		; WayPointClass::GetNextWP
PUBLIC	?GetPrevWP@WayPointClass@@QAEPAV1@XZ		; WayPointClass::GetPrevWP
PUBLIC	?GetWPArrivalTime@WayPointClass@@QAEKXZ		; WayPointClass::GetWPArrivalTime
PUBLIC	?GetWPDepartureTime@WayPointClass@@QAEKXZ	; WayPointClass::GetWPDepartureTime
PUBLIC	?GetSType@CampBaseClass@@QBEEXZ			; CampBaseClass::GetSType
PUBLIC	?CampEnterCriticalSection@@YAXXZ		; CampEnterCriticalSection
PUBLIC	?CampLeaveCriticalSection@@YAXXZ		; CampLeaveCriticalSection
PUBLIC	?Final@UnitClass@@QBEHXZ			; UnitClass::Final
PUBLIC	?GetUnitNameID@UnitClass@@QAEHXZ		; UnitClass::GetUnitNameID
PUBLIC	?GetFirstUnitWP@UnitClass@@QAEPAVWayPointClass@@XZ ; UnitClass::GetFirstUnitWP
PUBLIC	?GetLocation@DivisionClass@@QAEXPAF0@Z		; DivisionClass::GetLocation
PUBLIC	?GetDivisionType@DivisionClass@@QAEEXZ		; DivisionClass::GetDivisionType
PUBLIC	?GetLastDirection@FlightClass@@QAEEXZ		; FlightClass::GetLastDirection
PUBLIC	??0id@locale@std@@QAE@I@Z			; std::locale::id::id
PUBLIC	?generic_category@std@@YAABVerror_category@1@XZ	; std::generic_category
PUBLIC	?system_category@std@@YAABVerror_category@1@XZ	; std::system_category
PUBLIC	??0error_category@std@@QAE@XZ			; std::error_category::error_category
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??8error_category@std@@QBE_NABV01@@Z		; std::error_category::operator==
PUBLIC	??_Gerror_category@std@@UAEPAXI@Z		; std::error_category::`scalar deleting destructor'
PUBLIC	?value@error_code@std@@QBEHXZ			; std::error_code::value
PUBLIC	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
PUBLIC	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?value@error_condition@std@@QBEHXZ		; std::error_condition::value
PUBLIC	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
PUBLIC	??8error_condition@std@@QBE_NABV01@@Z		; std::error_condition::operator==
PUBLIC	??0_Generic_error_category@std@@QAE@XZ		; std::_Generic_error_category::_Generic_error_category
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	??1_Generic_error_category@std@@UAE@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	??0_Iostream_error_category@std@@QAE@XZ		; std::_Iostream_error_category::_Iostream_error_category
PUBLIC	?name@_Iostream_error_category@std@@UBEPBDXZ	; std::_Iostream_error_category::name
PUBLIC	?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	??1_Iostream_error_category@std@@UAE@XZ		; std::_Iostream_error_category::~_Iostream_error_category
PUBLIC	??_G_Iostream_error_category@std@@UAEPAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	??0_System_error_category@std@@QAE@XZ		; std::_System_error_category::_System_error_category
PUBLIC	?name@_System_error_category@std@@UBEPBDXZ	; std::_System_error_category::name
PUBLIC	?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message
PUBLIC	?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition
PUBLIC	??1_System_error_category@std@@UAE@XZ		; std::_System_error_category::~_System_error_category
PUBLIC	??_G_System_error_category@std@@UAEPAXI@Z	; std::_System_error_category::`scalar deleting destructor'
PUBLIC	?SetSrcRect@O_Output@@QAEXPAUUI95_RECT@@@Z	; O_Output::SetSrcRect
PUBLIC	?SetDestRect@O_Output@@QAEXPAUUI95_RECT@@@Z	; O_Output::SetDestRect
PUBLIC	?SetClient@C_Base@@QAEXF@Z			; C_Base::SetClient
PUBLIC	?GetID@C_Base@@QAEJXZ				; C_Base::GetID
PUBLIC	?GetW@C_Base@@QAEJXZ				; C_Base::GetW
PUBLIC	?GetH@C_Base@@QAEJXZ				; C_Base::GetH
PUBLIC	?GetOverlay@C_ScaleBitmap@@QAEPAEXZ		; C_ScaleBitmap::GetOverlay
PUBLIC	?UseOverlay@C_ScaleBitmap@@QAEXXZ		; C_ScaleBitmap::UseOverlay
PUBLIC	?NoOverlay@C_ScaleBitmap@@QAEXXZ		; C_ScaleBitmap::NoOverlay
PUBLIC	?SetSrcRect@C_ScaleBitmap@@QAEXPAUUI95_RECT@@@Z	; C_ScaleBitmap::SetSrcRect
PUBLIC	?SetDestRect@C_ScaleBitmap@@QAEXPAUUI95_RECT@@@Z ; C_ScaleBitmap::SetDestRect
PUBLIC	?SetScaleInfo@C_ScaleBitmap@@QAEXJ@Z		; C_ScaleBitmap::SetScaleInfo
PUBLIC	?AddIconToList@C_MapIcon@@QAEPAVMAPICONLIST@@JFJMMFPADJJJJJ@Z ; C_MapIcon::AddIconToList
PUBLIC	?AddIconToList@C_MapIcon@@QAEPAVMAPICONLIST@@JFJMMFPADJJ@Z ; C_MapIcon::AddIconToList
PUBLIC	?SetTeam@C_MapIcon@@QAEXF@Z			; C_MapIcon::SetTeam
PUBLIC	?GetThreat@C_Threat@@QAEPAUTHREAT_CIRCLE@@J@Z	; C_Threat::GetThreat
PUBLIC	?SetWorldRange@C_Waypoint@@QAEXMMMM@Z		; C_Waypoint::SetWorldRange
PUBLIC	?GetRoot@C_Waypoint@@QAEPAVWAYPOINTLIST@@XZ	; C_Waypoint::GetRoot
PUBLIC	?Dragging@C_Waypoint@@QAEFXZ			; C_Waypoint::Dragging
PUBLIC	?SetColor@C_BullsEye@@QAEXK@Z			; C_BullsEye::SetColor
PUBLIC	?CalculateDrawingParams@C_Map@@AAEXXZ		; C_Map::CalculateDrawingParams
PUBLIC	?BuildWPList@C_Map@@AAEXPAVC_Waypoint@@0PAVUnitClass@@@Z ; C_Map::BuildWPList
PUBLIC	?BuildCurrentWPList@C_Map@@AAEXPAVUnitClass@@@Z	; C_Map::BuildCurrentWPList
PUBLIC	?AddListsToWindow@C_Map@@AAEXXZ			; C_Map::AddListsToWindow
PUBLIC	?RemoveListsFromWindow@C_Map@@AAEXXZ		; C_Map::RemoveListsFromWindow
PUBLIC	?SetTeamScales@C_Map@@AAEXXZ			; C_Map::SetTeamScales
PUBLIC	??0C_Map@@QAE@XZ				; C_Map::C_Map
PUBLIC	??1C_Map@@QAE@XZ				; C_Map::~C_Map
PUBLIC	?SetupOverlay@C_Map@@QAEXXZ			; C_Map::SetupOverlay
PUBLIC	?Cleanup@C_Map@@QAEXXZ				; C_Map::Cleanup
PUBLIC	?SetMapImage@C_Map@@QAEXJ@Z			; C_Map::SetMapImage
PUBLIC	?SetWindow@C_Map@@QAEXPAVC_Window@@@Z		; C_Map::SetWindow
PUBLIC	?SetWPZWindow@C_Map@@QAEXPAVC_Window@@@Z	; C_Map::SetWPZWindow
PUBLIC	?SetTeamFlags@C_Map@@QAEXJJ@Z			; C_Map::SetTeamFlags
PUBLIC	?GetTeamFlags@C_Map@@QAEJJ@Z			; C_Map::GetTeamFlags
PUBLIC	?FitFlightPlan@C_Map@@QAEXXZ			; C_Map::FitFlightPlan
PUBLIC	?SetZoomLevel@C_Map@@QAEXF@Z			; C_Map::SetZoomLevel
PUBLIC	?ZoomIn@C_Map@@QAEXXZ				; C_Map::ZoomIn
PUBLIC	?ZoomOut@C_Map@@QAEXXZ				; C_Map::ZoomOut
PUBLIC	?SetBullsEye@C_Map@@QAEXMM@Z			; C_Map::SetBullsEye
PUBLIC	?SetUnitLevel@C_Map@@QAEXJ@Z			; C_Map::SetUnitLevel
PUBLIC	?ShowObjectiveType@C_Map@@QAEXJ@Z		; C_Map::ShowObjectiveType
PUBLIC	?HideObjectiveType@C_Map@@QAEXJ@Z		; C_Map::HideObjectiveType
PUBLIC	?ShowUnitType@C_Map@@QAEXJ@Z			; C_Map::ShowUnitType
PUBLIC	?HideUnitType@C_Map@@QAEXJ@Z			; C_Map::HideUnitType
PUBLIC	?ShowAirUnitType@C_Map@@QAEXJ@Z			; C_Map::ShowAirUnitType
PUBLIC	?HideAirUnitType@C_Map@@QAEXJ@Z			; C_Map::HideAirUnitType
PUBLIC	?RefreshAllAirUnitType@C_Map@@QAEXXZ		; C_Map::RefreshAllAirUnitType
PUBLIC	?ShowNavalUnitType@C_Map@@QAEXJ@Z		; C_Map::ShowNavalUnitType
PUBLIC	?HideNavalUnitType@C_Map@@QAEXJ@Z		; C_Map::HideNavalUnitType
PUBLIC	?ShowThreatType@C_Map@@QAEXJ@Z			; C_Map::ShowThreatType
PUBLIC	?HideThreatType@C_Map@@QAEXJ@Z			; C_Map::HideThreatType
PUBLIC	?SetMapCenter@C_Map@@QAEXJJ@Z			; C_Map::SetMapCenter
PUBLIC	?MoveCenter@C_Map@@QAEXJJ@Z			; C_Map::MoveCenter
PUBLIC	?SetWaypointList@C_Map@@QAEHVVU_ID@@@Z		; C_Map::SetWaypointList
PUBLIC	?SetCurrentWaypointList@C_Map@@QAEHVVU_ID@@@Z	; C_Map::SetCurrentWaypointList
PUBLIC	?RemoveCurWPList@C_Map@@QAEXXZ			; C_Map::RemoveCurWPList
PUBLIC	?RemoveAllWaypoints@C_Map@@QAEXF@Z		; C_Map::RemoveAllWaypoints
PUBLIC	?RemoveWaypoints@C_Map@@QAEXFJ@Z		; C_Map::RemoveWaypoints
PUBLIC	?RemoveAllEntities@C_Map@@QAEXXZ		; C_Map::RemoveAllEntities
PUBLIC	?RemoveFromCurIcons@C_Map@@QAEXJ@Z		; C_Map::RemoveFromCurIcons
PUBLIC	?AddToCurIcons@C_Map@@QAEXPAVMAPICONLIST@@@Z	; C_Map::AddToCurIcons
PUBLIC	?CenterOnIcon@C_Map@@QAEXPAVMAPICONLIST@@@Z	; C_Map::CenterOnIcon
PUBLIC	?AddThreat@C_Map@@QAEPAUTHREAT_LIST@@PAVCampBaseClass@@@Z ; C_Map::AddThreat
PUBLIC	?AddObjective@C_Map@@QAEPAVMAPICONLIST@@PAVObjectiveClass@@@Z ; C_Map::AddObjective
PUBLIC	?AddDivision@C_Map@@QAEPAVMAPICONLIST@@PAVDivisionClass@@@Z ; C_Map::AddDivision
PUBLIC	?AddUnit@C_Map@@QAEPAVMAPICONLIST@@PAVUnitClass@@@Z ; C_Map::AddUnit
PUBLIC	?AddFlight@C_Map@@QAEPAVMAPICONLIST@@PAVFlightClass@@@Z ; C_Map::AddFlight
PUBLIC	?AddSquadron@C_Map@@QAEPAVMAPICONLIST@@PAVSquadronClass@@@Z ; C_Map::AddSquadron
PUBLIC	?AddPackage@C_Map@@QAEPAVMAPICONLIST@@PAVPackageClass@@@Z ; C_Map::AddPackage
PUBLIC	?AddVC@C_Map@@QAEPAVMAPICONLIST@@PAVvictory_condition@@@Z ; C_Map::AddVC
PUBLIC	?UpdateWaypoint@C_Map@@QAEXPAVFlightClass@@@Z	; C_Map::UpdateWaypoint
PUBLIC	?UpdateVC@C_Map@@QAEXPAVvictory_condition@@@Z	; C_Map::UpdateVC
PUBLIC	?RemoveVC@C_Map@@QAEXJJ@Z			; C_Map::RemoveVC
PUBLIC	?RemoveOldWaypoints@C_Map@@QAEXXZ		; C_Map::RemoveOldWaypoints
PUBLIC	?TurnOnNames@C_Map@@QAEXXZ			; C_Map::TurnOnNames
PUBLIC	?TurnOnBoundaries@C_Map@@QAEXXZ			; C_Map::TurnOnBoundaries
PUBLIC	?TurnOnArrows@C_Map@@QAEXXZ			; C_Map::TurnOnArrows
PUBLIC	?TurnOffNames@C_Map@@QAEXXZ			; C_Map::TurnOffNames
PUBLIC	?TurnOffBoundaries@C_Map@@QAEXXZ		; C_Map::TurnOffBoundaries
PUBLIC	?TurnOffArrows@C_Map@@QAEXXZ			; C_Map::TurnOffArrows
PUBLIC	?TurnOnBullseye@C_Map@@QAEXXZ			; C_Map::TurnOnBullseye
PUBLIC	?TurnOffBullseye@C_Map@@QAEXXZ			; C_Map::TurnOffBullseye
PUBLIC	?DrawMap@C_Map@@QAEXXZ				; C_Map::DrawMap
PUBLIC	?SetAllObjCallbacks@C_Map@@QAEXP6AXJFPAVC_Base@@@Z@Z ; C_Map::SetAllObjCallbacks
PUBLIC	?SetAllAirUnitCallbacks@C_Map@@QAEXP6AXJFPAVC_Base@@@Z@Z ; C_Map::SetAllAirUnitCallbacks
PUBLIC	?SetAllGroundUnitCallbacks@C_Map@@QAEXP6AXJFPAVC_Base@@@Z@Z ; C_Map::SetAllGroundUnitCallbacks
PUBLIC	?SetAllNavalUnitCallbacks@C_Map@@QAEXP6AXJFPAVC_Base@@@Z@Z ; C_Map::SetAllNavalUnitCallbacks
PUBLIC	?SetObjCallbacks@C_Map@@QAEXJP6AXJFPAVC_Base@@@Z@Z ; C_Map::SetObjCallbacks
PUBLIC	?SetAirUnitCallbacks@C_Map@@QAEXJP6AXJFPAVC_Base@@@Z@Z ; C_Map::SetAirUnitCallbacks
PUBLIC	?SetGroundUnitCallbacks@C_Map@@QAEXJJP6AXJFPAVC_Base@@@Z@Z ; C_Map::SetGroundUnitCallbacks
PUBLIC	?SetNavalUnitCallbacks@C_Map@@QAEXJP6AXJFPAVC_Base@@@Z@Z ; C_Map::SetNavalUnitCallbacks
PUBLIC	?GetObjIconList@C_Map@@QAEPAVC_MapIcon@@JJ@Z	; C_Map::GetObjIconList
PUBLIC	?RecalcWaypointZs@C_Map@@QAEXJ@Z		; C_Map::RecalcWaypointZs
PUBLIC	?RemapTeamColors@C_Map@@QAEXJ@Z			; C_Map::RemapTeamColors
PUBLIC	?GetTeamNo@GlobalPositioningSystem@@QAEJXZ	; GlobalPositioningSystem::GetTeamNo
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??_7error_category@std@@6B@			; std::error_category::`vftable'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_C@_07DCLBNMLN@generic?$AA@			; `string'
PUBLIC	??_C@_0O@BFJCFAAK@unknown?5error?$AA@		; `string'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream?$AA@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	; `string'
PUBLIC	??_7_System_error_category@std@@6B@		; std::_System_error_category::`vftable'
PUBLIC	??_C@_06FHFOAHML@system?$AA@			; `string'
PUBLIC	?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
PUBLIC	?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
PUBLIC	?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
PUBLIC	?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
PUBLIC	?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
PUBLIC	??_C@_05NCAJEJLJ@?$DMunk?$DO?$AA@		; `string'
PUBLIC	??_C@_07PAINCAHD@?$CFs?5?$CF1ld?$AA@		; `string'
PUBLIC	??_C@_05NDPOMAGE@?$CF1?41f?$AA@			; `string'
PUBLIC	??_C@_03GNGPFOOL@?$CF1d?$AA@			; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs?$AA@			; `string'
PUBLIC	??_C@_0BB@IPEEPKNC@Start?5at?5?$CF1ld?4?4?4?$AA@ ; `string'
PUBLIC	??_C@_0BB@DJFFJCHP@Total?5time?$DN?$CF1ld?6?$AA@ ; `string'
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	?id@?$numpunct@_W@std@@2V0locale@2@A		; std::numpunct<wchar_t>::id
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_R4error_category@std@@6B@			; std::error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error_category@std@@6B@		; std::_System_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_System_error_category@std@@@8		; std::_System_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_System_error_category@std@@8		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error_category@std@@8		; std::_System_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error_category@std@@8	; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@392c987a
PUBLIC	__real@399fcd90
PUBLIC	__real@3f09fbe7
PUBLIC	__real@3f800000
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@40000000
PUBLIC	__real@42c80000
PUBLIC	__real@44ccffae
PUBLIC	__real@44cd0000
PUBLIC	__real@45000000
PUBLIC	__real@454cffae
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_strcpy:PROC
EXTRN	_strlen:PROC
EXTRN	_memmove:PROC
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	__snprintf:PROC
EXTRN	_sprintf:PROC
EXTRN	_MonoPrint:PROC
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z:PROC ; VuDatabase::Find
EXTRN	?GetLocation@FalconEntity@@QBEXPAF0@Z:PROC	; FalconEntity::GetLocation
EXTRN	?GetLocation@WayPointClass@@QBEXPAM00@Z:PROC	; WayPointClass::GetLocation
EXTRN	?GetVehicleClassData@@YAPAUVehicleClassDataType@@H@Z:PROC ; GetVehicleClassData
EXTRN	_F4EnterCriticalSection:PROC
EXTRN	_F4LeaveCriticalSection:PROC
EXTRN	?GetBullseyeLocation@CampaignClass@@QAEXPAF0@Z:PROC ; CampaignClass::GetBullseyeLocation
EXTRN	?GetUnitClassData@UnitClass@@QAEPAUUnitClassDataType@@XZ:PROC ; UnitClass::GetUnitClassData
EXTRN	?GetVehicleID@UnitClass@@QAEFH@Z:PROC		; UnitClass::GetVehicleID
EXTRN	?GetTotalVehicles@UnitClass@@QAEHXZ:PROC	; UnitClass::GetTotalVehicles
EXTRN	?GetFullstrengthVehicles@UnitClass@@QAEHXZ:PROC	; UnitClass::GetFullstrengthVehicles
EXTRN	?GetCurrentUnitWP@UnitClass@@QBEPAVWayPointClass@@XZ:PROC ; UnitClass::GetCurrentUnitWP
EXTRN	?HasRadarRanges@ObjectiveClass@@QAEHXZ:PROC	; ObjectiveClass::HasRadarRanges
EXTRN	?GetObjectiveClassData@ObjectiveClass@@QAEPAUObjClassDataType@@XZ:PROC ; ObjectiveClass::GetObjectiveClassData
EXTRN	?FindUnit@@YAPAVUnitClass@@VVU_ID@@@Z:PROC	; FindUnit
EXTRN	?GetName@DivisionClass@@QAEPADPADHH@Z:PROC	; DivisionClass::GetName
EXTRN	?GetFirstUnitElement@DivisionClass@@QAEPAVUnitClass@@XZ:PROC ; DivisionClass::GetFirstUnitElement
EXTRN	?GetCallsign@@YAXPAVFlightClass@@PAD@Z:PROC	; GetCallsign
EXTRN	?GetOverrideWP@FlightClass@@QAEPAVWayPointClass@@XZ:PROC ; FlightClass::GetOverrideWP
EXTRN	??_Eerror_category@std@@UAEPAXI@Z:PROC		; std::error_category::`vector deleting destructor'
EXTRN	?_Syserror_map@std@@YAPBDH@Z:PROC		; std::_Syserror_map
EXTRN	?_Winerror_map@std@@YAPBDH@Z:PROC		; std::_Winerror_map
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_E_System_error_category@std@@UAEPAXI@Z:PROC	; std::_System_error_category::`vector deleting destructor'
EXTRN	?Find@C_Hash@@QAEPAXJ@Z:PROC			; C_Hash::Find
EXTRN	?GetString@C_String@@QAEPADJ@Z:PROC		; C_String::GetString
EXTRN	?AddText@C_String@@QAEJPBD@Z:PROC		; C_String::AddText
EXTRN	?GetText@C_String@@QAEPADJ@Z:PROC		; C_String::GetText
EXTRN	?SetScaleInfo@O_Output@@QAEXJ@Z:PROC		; O_Output::SetScaleInfo
EXTRN	?UI_Enter@@YAPAUF4CSECTIONHANDLE@@PAVC_Window@@@Z:PROC ; UI_Enter
EXTRN	?UI_Leave@@YAXPAUF4CSECTIONHANDLE@@@Z:PROC	; UI_Leave
EXTRN	?SetUserNumber@C_Base@@QAEXJJ@Z:PROC		; C_Base::SetUserNumber
EXTRN	?SetUserCleanupPtr@C_Base@@QAEXJPAX@Z:PROC	; C_Base::SetUserCleanupPtr
EXTRN	?SetText@C_Button@@QAEXFJ@Z:PROC		; C_Button::SetText
EXTRN	??0C_ScaleBitmap@@QAE@XZ:PROC			; C_ScaleBitmap::C_ScaleBitmap
EXTRN	?Setup@C_ScaleBitmap@@QAEXJFJ@Z:PROC		; C_ScaleBitmap::Setup
EXTRN	?InitOverlay@C_ScaleBitmap@@QAEXXZ:PROC		; C_ScaleBitmap::InitOverlay
EXTRN	?ClearOverlay@C_ScaleBitmap@@QAEXXZ:PROC	; C_ScaleBitmap::ClearOverlay
EXTRN	?PreparePalette@C_ScaleBitmap@@QAEXK@Z:PROC	; C_ScaleBitmap::PreparePalette
EXTRN	?SetImage@C_ScaleBitmap@@QAEXJ@Z:PROC		; C_ScaleBitmap::SetImage
EXTRN	?AddControl@C_Window@@QAEXPAVC_Base@@@Z:PROC	; C_Window::AddControl
EXTRN	?RemoveControl@C_Window@@QAEXJ@Z:PROC		; C_Window::RemoveControl
EXTRN	?RefreshWindow@C_Window@@QAEXXZ:PROC		; C_Window::RefreshWindow
EXTRN	??0C_MapIcon@@QAE@XZ:PROC			; C_MapIcon::C_MapIcon
EXTRN	?Setup@C_MapIcon@@QAEXJF@Z:PROC			; C_MapIcon::Setup
EXTRN	?SetMainImage@C_MapIcon@@QAEXFJJ@Z:PROC		; C_MapIcon::SetMainImage
EXTRN	?SetMainImage@C_MapIcon@@QAEXJJ@Z:PROC		; C_MapIcon::SetMainImage
EXTRN	?AddIconToList@C_MapIcon@@QAEPAVMAPICONLIST@@JFJMMFPADJJJJJPAUDETECTOR@@@Z:PROC ; C_MapIcon::AddIconToList
EXTRN	?RemoveIcon@C_MapIcon@@QAEXJ@Z:PROC		; C_MapIcon::RemoveIcon
EXTRN	?SetScaleFactor@C_MapIcon@@QAEXM@Z:PROC		; C_MapIcon::SetScaleFactor
EXTRN	?FindID@C_MapIcon@@QAEPAVMAPICONLIST@@J@Z:PROC	; C_MapIcon::FindID
EXTRN	?RemapIconImages@C_MapIcon@@QAEXXZ:PROC		; C_MapIcon::RemapIconImages
EXTRN	??0C_Threat@@QAE@XZ:PROC			; C_Threat::C_Threat
EXTRN	?Setup@C_Threat@@QAEXJJ@Z:PROC			; C_Threat::Setup
EXTRN	?AddCircle@C_Threat@@QAEXJJJJJ@Z:PROC		; C_Threat::AddCircle
EXTRN	?SetRadius@C_Threat@@QAEXJJJ@Z:PROC		; C_Threat::SetRadius
EXTRN	?BuildOverlay@C_Threat@@QAEXPAEJJM@Z:PROC	; C_Threat::BuildOverlay
EXTRN	??0C_Waypoint@@QAE@XZ:PROC			; C_Waypoint::C_Waypoint
EXTRN	?Setup@C_Waypoint@@QAEXJF@Z:PROC		; C_Waypoint::Setup
EXTRN	?AddWaypointToList@C_Waypoint@@QAEPAVWAYPOINTLIST@@JFJJJMMF@Z:PROC ; C_Waypoint::AddWaypointToList
EXTRN	?EraseWaypointList@C_Waypoint@@QAEXXZ:PROC	; C_Waypoint::EraseWaypointList
EXTRN	?EraseWaypointGroup@C_Waypoint@@QAEXJ@Z:PROC	; C_Waypoint::EraseWaypointGroup
EXTRN	?SetScaleFactor@C_Waypoint@@QAEXM@Z:PROC	; C_Waypoint::SetScaleFactor
EXTRN	?SetScaleType@C_Waypoint@@QAEXF@Z:PROC		; C_Waypoint::SetScaleType
EXTRN	?SetWPGroup@C_Waypoint@@QAEXJJ@Z:PROC		; C_Waypoint::SetWPGroup
EXTRN	?SetState@C_Waypoint@@QAEXJF@Z:PROC		; C_Waypoint::SetState
EXTRN	?SetGroupState@C_Waypoint@@QAEXJF@Z:PROC	; C_Waypoint::SetGroupState
EXTRN	?SetLabel@C_Waypoint@@QAEXJPAD@Z:PROC		; C_Waypoint::SetLabel
EXTRN	?SetLabelColor@C_Waypoint@@QAEXJKKK@Z:PROC	; C_Waypoint::SetLabelColor
EXTRN	?SetLineColor@C_Waypoint@@QAEXJKKK@Z:PROC	; C_Waypoint::SetLineColor
EXTRN	?SetTextOffset@C_Waypoint@@QAEXJFF@Z:PROC	; C_Waypoint::SetTextOffset
EXTRN	??0C_DrawList@@QAE@XZ:PROC			; C_DrawList::C_DrawList
EXTRN	?Setup@C_DrawList@@QAEXJF@Z:PROC		; C_DrawList::Setup
EXTRN	?Add@C_DrawList@@QAEXPAVMAPICONLIST@@@Z:PROC	; C_DrawList::Add
EXTRN	?Remove@C_DrawList@@QAEXJ@Z:PROC		; C_DrawList::Remove
EXTRN	??0C_BullsEye@@QAE@XZ:PROC			; C_BullsEye::C_BullsEye
EXTRN	?Setup@C_BullsEye@@QAEXJF@Z:PROC		; C_BullsEye::Setup
EXTRN	?SetPos@C_BullsEye@@QAEXMM@Z:PROC		; C_BullsEye::SetPos
EXTRN	?SetScale@C_BullsEye@@QAEXM@Z:PROC		; C_BullsEye::SetScale
EXTRN	?FindTypeIndex@@YAJJQAJH@Z:PROC			; FindTypeIndex
EXTRN	?GetObjectiveType@@YAJPAVCampBaseClass@@@Z:PROC	; GetObjectiveType
EXTRN	?GetAirIcon@@YAJE@Z:PROC			; GetAirIcon
EXTRN	?FindDivisionType@@YAJE@Z:PROC			; FindDivisionType
EXTRN	?FindUnitType@@YAJPAVUnitClass@@@Z:PROC		; FindUnitType
EXTRN	?get_team@victory_condition@@QAEHXZ:PROC	; victory_condition::get_team
EXTRN	?get_vu_id@victory_condition@@QAE?AVVU_ID@@XZ:PROC ; victory_condition::get_vu_id
EXTRN	?get_number@victory_condition@@QAEHXZ:PROC	; victory_condition::get_number
EXTRN	?Find@GlobalPositioningSystem@@QAEPAXJ@Z:PROC	; GlobalPositioningSystem::Find
EXTRN	?WaypointCB@@YAXJFPAVC_Base@@@Z:PROC		; WaypointCB
EXTRN	?UnitCB@@YAXJFPAVC_Base@@@Z:PROC		; UnitCB
EXTRN	?IsValidWP@@YAHPAVWayPointClass@@PAVFlightClass@@@Z:PROC ; IsValidWP
EXTRN	?Uni_Float@@YAXPAD@Z:PROC			; Uni_Float
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	?vuDatabase@@3PAVVuDatabase@@A:DWORD		; vuDatabase
EXTRN	?FalconNullId@@3VVU_ID@@A:QWORD			; FalconNullId
EXTRN	?Map_Max_Y@@3FA:WORD				; Map_Max_Y
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?campCritical@@3PAUF4CSECTIONHANDLE@@A:DWORD	; campCritical
EXTRN	?TheCampaign@@3VCampaignClass@@A:BYTE		; TheCampaign
EXTRN	?gStringMgr@@3PAVC_String@@A:DWORD		; gStringMgr
EXTRN	?AirIcons@@3PAUAIR_ICONS@@A:BYTE		; AirIcons
EXTRN	?OBJ_TypeList@@3PAJA:BYTE			; OBJ_TypeList
EXTRN	?NAV_TypeList@@3PAJA:QWORD			; NAV_TypeList
EXTRN	?AIR_TypeList@@3PAJA:BYTE			; AIR_TypeList
EXTRN	?GND_TypeList@@3PAJA:BYTE			; GND_TypeList
EXTRN	?GND_LevelList@@3PAJA:BYTE			; GND_LevelList
EXTRN	?THR_TypeList@@3PAJA:BYTE			; THR_TypeList
EXTRN	?gActiveFlightID@@3VVU_ID@@A:QWORD		; gActiveFlightID
EXTRN	?gMoveBattalion@@3HA:DWORD			; gMoveBattalion
EXTRN	?gGps@@3PAVGlobalPositioningSystem@@A:DWORD	; gGps
EXTRN	?g_bAWACSBackground@@3_NA:BYTE			; g_bAWACSBackground
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
_allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
_BSS	SEGMENT
?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Generic_object
_BSS	ENDS
;	COMDAT ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
_BSS	SEGMENT
?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Iostream_object
_BSS	ENDS
;	COMDAT ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
_BSS	SEGMENT
?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_System_object
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@_W@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@_W@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<wchar_t>::id
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __real@454cffae
CONST	SEGMENT
__real@454cffae DD 0454cffaer			; 3279.98
CONST	ENDS
;	COMDAT __real@45000000
CONST	SEGMENT
__real@45000000 DD 045000000r			; 2048
CONST	ENDS
;	COMDAT __real@44cd0000
CONST	SEGMENT
__real@44cd0000 DD 044cd0000r			; 1640
CONST	ENDS
;	COMDAT __real@44ccffae
CONST	SEGMENT
__real@44ccffae DD 044ccffaer			; 1639.99
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f09fbe7
CONST	SEGMENT
__real@3f09fbe7 DD 03f09fbe7r			; 0.539
CONST	ENDS
;	COMDAT __real@399fcd90
CONST	SEGMENT
__real@399fcd90 DD 0399fcd90r			; 0.0003048
CONST	ENDS
;	COMDAT __real@392c987a
CONST	SEGMENT
__real@392c987a DD 0392c987ar			; 0.0001646
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error_category@std@@8 DD FLAT:??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error_category@std@@8
rdata$r	SEGMENT
??_R2_System_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error_category@std@@8
rdata$r	SEGMENT
??_R3_System_error_category@std@@8 DD 00H		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_System_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_System_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_System_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_System_error_category@std@@6B@ DD 00H		; std::_System_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error_category@std@@@8
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD FLAT:??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 00H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category@std@@@8
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
_DATA	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4error_category@std@@6B@
rdata$r	SEGMENT
??_R4error_category@std@@6B@ DD 00H			; std::error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVerror_category@std@@@8
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DJFFJCHP@Total?5time?$DN?$CF1ld?6?$AA@
CONST	SEGMENT
??_C@_0BB@DJFFJCHP@Total?5time?$DN?$CF1ld?6?$AA@ DB 'Total time=%1ld', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IPEEPKNC@Start?5at?5?$CF1ld?4?4?4?$AA@
CONST	SEGMENT
??_C@_0BB@IPEEPKNC@Start?5at?5?$CF1ld?4?4?4?$AA@ DB 'Start at %1ld...', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs?$AA@ DB '%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03GNGPFOOL@?$CF1d?$AA@
CONST	SEGMENT
??_C@_03GNGPFOOL@?$CF1d?$AA@ DB '%1d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05NDPOMAGE@?$CF1?41f?$AA@
CONST	SEGMENT
??_C@_05NDPOMAGE@?$CF1?41f?$AA@ DB '%1.1f', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07PAINCAHD@?$CFs?5?$CF1ld?$AA@
CONST	SEGMENT
??_C@_07PAINCAHD@?$CFs?5?$CF1ld?$AA@ DB '%s %1ld', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05NCAJEJLJ@?$DMunk?$DO?$AA@
CONST	SEGMENT
??_C@_05NCAJEJLJ@?$DMunk?$DO?$AA@ DB '<unk>', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system?$AA@
CONST	SEGMENT
??_C@_06FHFOAHML@system?$AA@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_System_error_category@std@@6B@
CONST	SEGMENT
??_7_System_error_category@std@@6B@ DD FLAT:??_R4_System_error_category@std@@6B@ ; std::_System_error_category::`vftable'
	DD	FLAT:??_E_System_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_System_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ DB 'iostream stream error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream?$AA@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream?$AA@ DB 'iostream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DD FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DD	FLAT:??_E_Iostream_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
CONST	SEGMENT
??_C@_0O@BFJCFAAK@unknown?5error?$AA@ DB 'unknown error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic?$AA@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic?$AA@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7error_category@std@@6B@
CONST	SEGMENT
??_7error_category@std@@6B@ DD FLAT:??_R4error_category@std@@6B@ ; std::error_category::`vftable'
	DD	FLAT:??_Eerror_category@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
__ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
xdata$x	SEGMENT
__unwindtable$?SetMapImage@C_Map@@QAEXJ@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetMapImage@C_Map@@QAEXJ@Z$0
__unwindtable$?BuildWPList@C_Map@@AAEXPAVC_Waypoint@@0PAVUnitClass@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?BuildWPList@C_Map@@AAEXPAVC_Waypoint@@0PAVUnitClass@@@Z$0
__unwindtable$?BuildCurrentWPList@C_Map@@AAEXPAVUnitClass@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?BuildCurrentWPList@C_Map@@AAEXPAVUnitClass@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BuildCurrentWPList@C_Map@@AAEXPAVUnitClass@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BuildCurrentWPList@C_Map@@AAEXPAVUnitClass@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BuildCurrentWPList@C_Map@@AAEXPAVUnitClass@@@Z$3
__ehfuncinfo$?SetMapImage@C_Map@@QAEXJ@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SetMapImage@C_Map@@QAEXJ@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?AddListsToWindow@C_Map@@AAEXXZ DD 019930522H
	DD	0bH
	DD	FLAT:__unwindtable$?AddListsToWindow@C_Map@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?BuildCurrentWPList@C_Map@@AAEXPAVUnitClass@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?BuildCurrentWPList@C_Map@@AAEXPAVUnitClass@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?BuildWPList@C_Map@@AAEXPAVC_Waypoint@@0PAVUnitClass@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?BuildWPList@C_Map@@AAEXPAVC_Waypoint@@0PAVUnitClass@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?AddListsToWindow@C_Map@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddListsToWindow@C_Map@@AAEXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AddListsToWindow@C_Map@@AAEXXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AddListsToWindow@C_Map@@AAEXXZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AddListsToWindow@C_Map@@AAEXXZ$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AddListsToWindow@C_Map@@AAEXXZ$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AddListsToWindow@C_Map@@AAEXXZ$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AddListsToWindow@C_Map@@AAEXXZ$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AddListsToWindow@C_Map@@AAEXXZ$7
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AddListsToWindow@C_Map@@AAEXXZ$8
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AddListsToWindow@C_Map@@AAEXXZ$9
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AddListsToWindow@C_Map@@AAEXXZ$10
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Generic_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Iostream_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_System_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@D@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<char>::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@_W@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<wchar_t>::id$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 621  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();
; 624  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
_this$ = -24						; size = 4
tv73 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR __V0$[ebp]
	push	ecx
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<wchar_t>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@_W@std@@2V0locale@2@A ; std::numpunct<wchar_t>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<wchar_t>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<char>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<char>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 755  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp

; 756  : 		{	// destroy object at _Ptr
; 757  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>

; 758  : 		}

	pop	ebp
	ret	0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
	pop	ebp
	ret	0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	ebp
	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??1_System_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_System_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??0_System_error_category@std@@QAE@XZ	; std::_System_error_category::_System_error_category
	push	OFFSET ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_System_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??1_Iostream_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??0_Iostream_error_category@std@@QAE@XZ	; std::_Iostream_error_category::_Iostream_error_category
	push	OFFSET ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??1_Generic_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	push	OFFSET ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], -1
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 85   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 89   : 	}

	pop	ebp
	ret	0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 907  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
	add	esp, 8

; 910  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
	add	esp, 12					; 0000000cH
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\include\gps.h
;	COMDAT ?GetTeamNo@GlobalPositioningSystem@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTeamNo@GlobalPositioningSystem@@QAEJXZ PROC		; GlobalPositioningSystem::GetTeamNo, COMDAT
; _this$ = ecx

; 77   : 		long GetTeamNo()						{ return(TeamNo_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+56]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetTeamNo@GlobalPositioningSystem@@QAEJXZ ENDP		; GlobalPositioningSystem::GetTeamNo
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_this$ = -12						; size = 4
_k$ = -8						; size = 2
_j$ = -4						; size = 2
_team$ = 8						; size = 4
?RemapTeamColors@C_Map@@QAEXJ@Z PROC			; C_Map::RemapTeamColors
; _this$ = ecx

; 1635 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1636 : 	short j,k;
; 1637 : 	if(team >= NUM_TEAMS)

	cmp	DWORD PTR _team$[ebp], 8
	jl	SHORT $LN20@RemapTeamC

; 1638 : 		return;

	jmp	$LN21@RemapTeamC
$LN20@RemapTeamC:

; 1639 : 
; 1640 : 	if(Team_[team].Objectives)

	mov	eax, DWORD PTR _team$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax+876], 0
	je	$LN19@RemapTeamC

; 1641 : 	{
; 1642 : 		for(j=0;j<_MAP_NUM_OBJ_TYPES_;j++)

	xor	edx, edx
	mov	WORD PTR _j$[ebp], dx
	jmp	SHORT $LN18@RemapTeamC
$LN17@RemapTeamC:
	mov	ax, WORD PTR _j$[ebp]
	add	ax, 1
	mov	WORD PTR _j$[ebp], ax
$LN18@RemapTeamC:
	movsx	ecx, WORD PTR _j$[ebp]
	cmp	ecx, 14					; 0000000eH
	jge	SHORT $LN19@RemapTeamC

; 1643 : 		{
; 1644 : 			Team_[team].Objectives->Type[j]->SetMainImage(ObjIconIDs_[team][0],ObjIconIDs_[team][1]);

	mov	edx, DWORD PTR _team$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8+640]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR [ecx+edx]
	push	eax
	mov	ecx, DWORD PTR _team$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8+640]
	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR [eax+ecx]
	push	edx
	mov	eax, DWORD PTR _team$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+876]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+56]
	call	?SetMainImage@C_MapIcon@@QAEXJJ@Z	; C_MapIcon::SetMainImage

; 1645 : 			Team_[team].Objectives->Type[j]->RemapIconImages();

	mov	ecx, DWORD PTR _team$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+876]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4+56]
	call	?RemapIconImages@C_MapIcon@@QAEXXZ	; C_MapIcon::RemapIconImages

; 1646 : 		}

	jmp	$LN17@RemapTeamC
$LN19@RemapTeamC:

; 1647 : 	}
; 1648 : 	if(Team_[team].NavalUnits)

	mov	edx, DWORD PTR _team$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+edx+872], 0
	je	$LN15@RemapTeamC

; 1649 : 	{
; 1650 : 		for(j=0;j<_MAP_NUM_NAV_TYPES_;j++)

	xor	ecx, ecx
	mov	WORD PTR _j$[ebp], cx
	jmp	SHORT $LN14@RemapTeamC
$LN13@RemapTeamC:
	mov	dx, WORD PTR _j$[ebp]
	add	dx, 1
	mov	WORD PTR _j$[ebp], dx
$LN14@RemapTeamC:
	movsx	eax, WORD PTR _j$[ebp]
	cmp	eax, 2
	jge	SHORT $LN15@RemapTeamC

; 1651 : 		{
; 1652 : 			Team_[team].NavalUnits->Type[j]->SetMainImage(NavyIconIDs_[team][0],NavyIconIDs_[team][1]);

	mov	ecx, DWORD PTR _team$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8+576]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR [eax+ecx]
	push	edx
	mov	eax, DWORD PTR _team$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8+576]
	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR [edx+eax]
	push	ecx
	mov	edx, DWORD PTR _team$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+872]
	movsx	edx, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4+8]
	call	?SetMainImage@C_MapIcon@@QAEXJJ@Z	; C_MapIcon::SetMainImage

; 1653 : 			Team_[team].NavalUnits->Type[j]->RemapIconImages();

	mov	eax, DWORD PTR _team$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+872]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+8]
	call	?RemapIconImages@C_MapIcon@@QAEXXZ	; C_MapIcon::RemapIconImages

; 1654 : 		}

	jmp	$LN13@RemapTeamC
$LN15@RemapTeamC:

; 1655 : 	}
; 1656 : 	if(Team_[team].Units)

	mov	ecx, DWORD PTR _team$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+ecx+868], 0
	je	$LN11@RemapTeamC

; 1657 : 	{
; 1658 : 		for(j=0;j<_MAP_NUM_GND_TYPES_;j++)

	xor	eax, eax
	mov	WORD PTR _j$[ebp], ax
	jmp	SHORT $LN10@RemapTeamC
$LN9@RemapTeamC:
	mov	cx, WORD PTR _j$[ebp]
	add	cx, 1
	mov	WORD PTR _j$[ebp], cx
$LN10@RemapTeamC:
	movsx	edx, WORD PTR _j$[ebp]
	cmp	edx, 4
	jge	$LN11@RemapTeamC

; 1659 : 		{
; 1660 : 			for(k=0;k<_MAP_NUM_GND_LEVELS_;k++)

	xor	eax, eax
	mov	WORD PTR _k$[ebp], ax
	jmp	SHORT $LN7@RemapTeamC
$LN6@RemapTeamC:
	mov	cx, WORD PTR _k$[ebp]
	add	cx, 1
	mov	WORD PTR _k$[ebp], cx
$LN7@RemapTeamC:
	movsx	edx, WORD PTR _k$[ebp]
	cmp	edx, 3
	jge	$LN5@RemapTeamC

; 1661 : 			{
; 1662 : 				Team_[team].Units->Type[j]->Levels[k]->SetMainImage(ArmyIconIDs_[team][0],ArmyIconIDs_[team][1]);

	mov	eax, DWORD PTR _team$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8+512]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR [edx+eax]
	push	ecx
	mov	edx, DWORD PTR _team$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8+512]
	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR [ecx+edx]
	push	eax
	mov	ecx, DWORD PTR _team$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+868]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+16]
	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+12]
	call	?SetMainImage@C_MapIcon@@QAEXJJ@Z	; C_MapIcon::SetMainImage

; 1663 : 				Team_[team].Units->Type[j]->Levels[k]->RemapIconImages();

	mov	ecx, DWORD PTR _team$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+868]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+16]
	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+12]
	call	?RemapIconImages@C_MapIcon@@QAEXXZ	; C_MapIcon::RemapIconImages

; 1664 : 			}

	jmp	$LN6@RemapTeamC
$LN5@RemapTeamC:

; 1665 : 		}

	jmp	$LN9@RemapTeamC
$LN11@RemapTeamC:

; 1666 : 	}
; 1667 : 
; 1668 : 	if(Team_[team].AirUnits)

	mov	ecx, DWORD PTR _team$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+ecx+864], 0
	je	$LN21@RemapTeamC

; 1669 : 	{
; 1670 : 		for(j=0;j<_MAP_NUM_AIR_TYPES_;j++)

	xor	eax, eax
	mov	WORD PTR _j$[ebp], ax
	jmp	SHORT $LN3@RemapTeamC
$LN2@RemapTeamC:
	mov	cx, WORD PTR _j$[ebp]
	add	cx, 1
	mov	WORD PTR _j$[ebp], cx
$LN3@RemapTeamC:
	movsx	edx, WORD PTR _j$[ebp]
	cmp	edx, 5
	jge	$LN21@RemapTeamC

; 1671 : 		{
; 1672 : 			Team_[team].AirUnits->Type[j]->SetMainImage(C_STATE_0,AirIconIDs_[team][0][0],AirIconIDs_[team][0][1]);

	mov	eax, DWORD PTR _team$[ebp]
	shl	eax, 6
	add	eax, DWORD PTR _this$[ebp]
	mov	ecx, 8
	imul	ecx, 0
	add	eax, ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR [eax+edx]
	push	eax
	mov	ecx, DWORD PTR _team$[ebp]
	shl	ecx, 6
	add	ecx, DWORD PTR _this$[ebp]
	mov	edx, 8
	imul	edx, 0
	add	ecx, edx
	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR [ecx+eax]
	push	ecx
	push	0
	mov	edx, DWORD PTR _team$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+864]
	movsx	edx, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4+20]
	call	?SetMainImage@C_MapIcon@@QAEXFJJ@Z	; C_MapIcon::SetMainImage

; 1673 : 			Team_[team].AirUnits->Type[j]->SetMainImage(C_STATE_1,AirIconIDs_[team][1][0],AirIconIDs_[team][1][1]);

	mov	eax, DWORD PTR _team$[ebp]
	shl	eax, 6
	add	eax, DWORD PTR _this$[ebp]
	mov	ecx, 8
	shl	ecx, 0
	add	eax, ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR [eax+edx]
	push	eax
	mov	ecx, DWORD PTR _team$[ebp]
	shl	ecx, 6
	add	ecx, DWORD PTR _this$[ebp]
	mov	edx, 8
	shl	edx, 0
	add	ecx, edx
	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR [ecx+eax]
	push	ecx
	push	1
	mov	edx, DWORD PTR _team$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+864]
	movsx	edx, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4+20]
	call	?SetMainImage@C_MapIcon@@QAEXFJJ@Z	; C_MapIcon::SetMainImage

; 1674 : 			Team_[team].AirUnits->Type[j]->SetMainImage(C_STATE_2,AirIconIDs_[team][2][0],AirIconIDs_[team][2][1]);

	mov	eax, DWORD PTR _team$[ebp]
	shl	eax, 6
	add	eax, DWORD PTR _this$[ebp]
	mov	ecx, 8
	shl	ecx, 1
	add	eax, ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR [eax+edx]
	push	eax
	mov	ecx, DWORD PTR _team$[ebp]
	shl	ecx, 6
	add	ecx, DWORD PTR _this$[ebp]
	mov	edx, 8
	shl	edx, 1
	add	ecx, edx
	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR [ecx+eax]
	push	ecx
	push	2
	mov	edx, DWORD PTR _team$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+864]
	movsx	edx, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4+20]
	call	?SetMainImage@C_MapIcon@@QAEXFJJ@Z	; C_MapIcon::SetMainImage

; 1675 : 			Team_[team].AirUnits->Type[j]->SetMainImage(C_STATE_3,AirIconIDs_[team][3][0],AirIconIDs_[team][3][1]);

	mov	eax, DWORD PTR _team$[ebp]
	shl	eax, 6
	add	eax, DWORD PTR _this$[ebp]
	mov	ecx, 8
	imul	ecx, 3
	add	eax, ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR [eax+edx]
	push	eax
	mov	ecx, DWORD PTR _team$[ebp]
	shl	ecx, 6
	add	ecx, DWORD PTR _this$[ebp]
	mov	edx, 8
	imul	edx, 3
	add	ecx, edx
	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR [ecx+eax]
	push	ecx
	push	3
	mov	edx, DWORD PTR _team$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+864]
	movsx	edx, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4+20]
	call	?SetMainImage@C_MapIcon@@QAEXFJJ@Z	; C_MapIcon::SetMainImage

; 1676 : 			Team_[team].AirUnits->Type[j]->SetMainImage(C_STATE_4,AirIconIDs_[team][4][0],AirIconIDs_[team][4][1]);

	mov	eax, DWORD PTR _team$[ebp]
	shl	eax, 6
	add	eax, DWORD PTR _this$[ebp]
	mov	ecx, 8
	shl	ecx, 2
	add	eax, ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR [eax+edx]
	push	eax
	mov	ecx, DWORD PTR _team$[ebp]
	shl	ecx, 6
	add	ecx, DWORD PTR _this$[ebp]
	mov	edx, 8
	shl	edx, 2
	add	ecx, edx
	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR [ecx+eax]
	push	ecx
	push	4
	mov	edx, DWORD PTR _team$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+864]
	movsx	edx, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4+20]
	call	?SetMainImage@C_MapIcon@@QAEXFJJ@Z	; C_MapIcon::SetMainImage

; 1677 : 			Team_[team].AirUnits->Type[j]->SetMainImage(C_STATE_5,AirIconIDs_[team][5][0],AirIconIDs_[team][5][1]);

	mov	eax, DWORD PTR _team$[ebp]
	shl	eax, 6
	add	eax, DWORD PTR _this$[ebp]
	mov	ecx, 8
	imul	ecx, 5
	add	eax, ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR [eax+edx]
	push	eax
	mov	ecx, DWORD PTR _team$[ebp]
	shl	ecx, 6
	add	ecx, DWORD PTR _this$[ebp]
	mov	edx, 8
	imul	edx, 5
	add	ecx, edx
	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR [ecx+eax]
	push	ecx
	push	5
	mov	edx, DWORD PTR _team$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+864]
	movsx	edx, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4+20]
	call	?SetMainImage@C_MapIcon@@QAEXFJJ@Z	; C_MapIcon::SetMainImage

; 1678 : 			Team_[team].AirUnits->Type[j]->SetMainImage(C_STATE_6,AirIconIDs_[team][6][0],AirIconIDs_[team][6][1]);

	mov	eax, DWORD PTR _team$[ebp]
	shl	eax, 6
	add	eax, DWORD PTR _this$[ebp]
	mov	ecx, 8
	imul	ecx, 6
	add	eax, ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR [eax+edx]
	push	eax
	mov	ecx, DWORD PTR _team$[ebp]
	shl	ecx, 6
	add	ecx, DWORD PTR _this$[ebp]
	mov	edx, 8
	imul	edx, 6
	add	ecx, edx
	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR [ecx+eax]
	push	ecx
	push	6
	mov	edx, DWORD PTR _team$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+864]
	movsx	edx, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4+20]
	call	?SetMainImage@C_MapIcon@@QAEXFJJ@Z	; C_MapIcon::SetMainImage

; 1679 : 			Team_[team].AirUnits->Type[j]->SetMainImage(C_STATE_7,AirIconIDs_[team][7][0],AirIconIDs_[team][7][1]);

	mov	eax, DWORD PTR _team$[ebp]
	shl	eax, 6
	add	eax, DWORD PTR _this$[ebp]
	mov	ecx, 8
	imul	ecx, 7
	add	eax, ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR [eax+edx]
	push	eax
	mov	ecx, DWORD PTR _team$[ebp]
	shl	ecx, 6
	add	ecx, DWORD PTR _this$[ebp]
	mov	edx, 8
	imul	edx, 7
	add	ecx, edx
	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR [ecx+eax]
	push	ecx
	push	7
	mov	edx, DWORD PTR _team$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+864]
	movsx	edx, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4+20]
	call	?SetMainImage@C_MapIcon@@QAEXFJJ@Z	; C_MapIcon::SetMainImage

; 1680 : 			Team_[team].AirUnits->Type[j]->RemapIconImages();

	mov	eax, DWORD PTR _team$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+864]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+20]
	call	?RemapIconImages@C_MapIcon@@QAEXXZ	; C_MapIcon::RemapIconImages

; 1681 : 		}

	jmp	$LN2@RemapTeamC
$LN21@RemapTeamC:

; 1682 : 	}
; 1683 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?RemapTeamColors@C_Map@@QAEXJ@Z ENDP			; C_Map::RemapTeamColors
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_scaletype$ = 8						; size = 4
?RecalcWaypointZs@C_Map@@QAEXJ@Z PROC			; C_Map::RecalcWaypointZs
; _this$ = ecx

; 2700 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2701 : 	if(scaletype == 1)

	cmp	DWORD PTR _scaletype$[ebp], 1
	jne	SHORT $LN5@RecalcWayp

; 2702 : 	{
; 2703 : 		if(CurWPZ_)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1096], 0
	je	SHORT $LN4@RecalcWayp

; 2704 : 		{
; 2705 : 			CurWPZ_->SetWorldRange(LogMinX_,LogMinY_,LogMaxX_,LogMaxY_);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+764]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+760]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+756]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+752]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1096]
	call	?SetWorldRange@C_Waypoint@@QAEXMMMM@Z	; C_Waypoint::SetWorldRange

; 2706 : 			CurWPZ_->SetScaleType(static_cast<short>(scaletype));

	movzx	eax, WORD PTR _scaletype$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1096]
	call	?SetScaleType@C_Waypoint@@QAEXF@Z	; C_Waypoint::SetScaleType
$LN4@RecalcWayp:

; 2707 : 		}
; 2708 : 	}

	jmp	SHORT $LN1@RecalcWayp
$LN5@RecalcWayp:

; 2709 : 	else if(scaletype == 2)

	cmp	DWORD PTR _scaletype$[ebp], 2
	jne	SHORT $LN1@RecalcWayp

; 2710 : 	{
; 2711 : 		if(CurWPZ_)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1096], 0
	je	SHORT $LN1@RecalcWayp

; 2712 : 		{
; 2713 : 			CurWPZ_->SetWorldRange(StrtMinX_,StrtMinY_,StrtMaxX_,StrtMaxY_);

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+780]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+776]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+772]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+768]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1096]
	call	?SetWorldRange@C_Waypoint@@QAEXMMMM@Z	; C_Waypoint::SetWorldRange

; 2714 : 			CurWPZ_->SetScaleType(static_cast<short>(scaletype));

	movzx	edx, WORD PTR _scaletype$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1096]
	call	?SetScaleType@C_Waypoint@@QAEXF@Z	; C_Waypoint::SetScaleType
$LN1@RecalcWayp:

; 2715 : 		}
; 2716 : 	}
; 2717 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?RecalcWaypointZs@C_Map@@QAEXJ@Z ENDP			; C_Map::RecalcWaypointZs
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_team$ = 8						; size = 4
_type$ = 12						; size = 4
?GetObjIconList@C_Map@@QAEPAVC_MapIcon@@JJ@Z PROC	; C_Map::GetObjIconList
; _this$ = ecx

; 2358 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2359 : 	return(Team_[team].Objectives->Type[type]);

	mov	eax, DWORD PTR _team$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+876]
	mov	eax, DWORD PTR _type$[ebp]
	mov	eax, DWORD PTR [edx+eax*4+56]

; 2360 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetObjIconList@C_Map@@QAEPAVC_MapIcon@@JJ@Z ENDP	; C_Map::GetObjIconList
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$ = -4						; size = 4
_type$ = 8						; size = 4
_cb$ = 12						; size = 4
?SetNavalUnitCallbacks@C_Map@@QAEXJP6AXJFPAVC_Base@@@Z@Z PROC ; C_Map::SetNavalUnitCallbacks
; _this$ = ecx

; 2349 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 2350 : 	long i;
; 2351 : 
; 2352 : 	for(i=0;i<_MAX_TEAMS_;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SetNavalUn
$LN3@SetNavalUn:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SetNavalUn:
	cmp	DWORD PTR _i$[ebp], 8
	jge	SHORT $LN5@SetNavalUn

; 2353 : 		if(Team_[i].NavalUnits->Type[type])

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+872]
	mov	ecx, DWORD PTR _type$[ebp]
	cmp	DWORD PTR [eax+ecx*4+8], 0
	je	SHORT $LN1@SetNavalUn

; 2354 : 			Team_[i].NavalUnits->Type[type]->SetCallback(cb);

	mov	edx, DWORD PTR _cb$[ebp]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+872]
	mov	eax, DWORD PTR _type$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+8]
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+edx+872]
	mov	eax, DWORD PTR _type$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+eax*4+8]
	mov	edx, DWORD PTR [esi+100]
	call	edx
$LN1@SetNavalUn:

; 2355 : }

	jmp	SHORT $LN3@SetNavalUn
$LN5@SetNavalUn:
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?SetNavalUnitCallbacks@C_Map@@QAEXJP6AXJFPAVC_Base@@@Z@Z ENDP ; C_Map::SetNavalUnitCallbacks
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$ = -4						; size = 4
_level$ = 8						; size = 4
_type$ = 12						; size = 4
_cb$ = 16						; size = 4
?SetGroundUnitCallbacks@C_Map@@QAEXJJP6AXJFPAVC_Base@@@Z@Z PROC ; C_Map::SetGroundUnitCallbacks
; _this$ = ecx

; 2339 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2340 : 	long i;
; 2341 : 
; 2342 : 	for(i=0;i<_MAX_TEAMS_;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN5@SetGroundU
$LN4@SetGroundU:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN5@SetGroundU:
	cmp	DWORD PTR _i$[ebp], 8
	jge	$LN6@SetGroundU

; 2343 : 		if(Team_[i].Units->Type[type])

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+868]
	mov	ecx, DWORD PTR _type$[ebp]
	cmp	DWORD PTR [eax+ecx*4+16], 0
	je	SHORT $LN2@SetGroundU

; 2344 : 			if(Team_[i].Units->Type[type]->Levels[level])

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+868]
	mov	edx, DWORD PTR _type$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+16]
	mov	ecx, DWORD PTR _level$[ebp]
	cmp	DWORD PTR [eax+ecx*4+12], 0
	je	SHORT $LN2@SetGroundU

; 2345 : 				Team_[i].Units->Type[type]->Levels[level]->SetCallback(cb);

	mov	edx, DWORD PTR _cb$[ebp]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+868]
	mov	eax, DWORD PTR _type$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+16]
	mov	edx, DWORD PTR _level$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+12]
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+868]
	mov	edx, DWORD PTR _type$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4+16]
	mov	edx, DWORD PTR _level$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+edx*4+12]
	mov	edx, DWORD PTR [eax+100]
	call	edx
$LN2@SetGroundU:

; 2346 : }

	jmp	$LN4@SetGroundU
$LN6@SetGroundU:
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SetGroundUnitCallbacks@C_Map@@QAEXJJP6AXJFPAVC_Base@@@Z@Z ENDP ; C_Map::SetGroundUnitCallbacks
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$ = -4						; size = 4
_type$ = 8						; size = 4
_cb$ = 12						; size = 4
?SetAirUnitCallbacks@C_Map@@QAEXJP6AXJFPAVC_Base@@@Z@Z PROC ; C_Map::SetAirUnitCallbacks
; _this$ = ecx

; 2329 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 2330 : 	long i;
; 2331 : 
; 2332 : 	for(i=0;i<_MAX_TEAMS_;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SetAirUnit
$LN3@SetAirUnit:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SetAirUnit:
	cmp	DWORD PTR _i$[ebp], 8
	jge	SHORT $LN5@SetAirUnit

; 2333 : 		if(Team_[i].AirUnits->Type[type])

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+864]
	mov	ecx, DWORD PTR _type$[ebp]
	cmp	DWORD PTR [eax+ecx*4+20], 0
	je	SHORT $LN1@SetAirUnit

; 2334 : 			Team_[i].AirUnits->Type[type]->SetCallback(cb);

	mov	edx, DWORD PTR _cb$[ebp]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+864]
	mov	eax, DWORD PTR _type$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+20]
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+edx+864]
	mov	eax, DWORD PTR _type$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+eax*4+20]
	mov	edx, DWORD PTR [esi+100]
	call	edx
$LN1@SetAirUnit:

; 2335 : }

	jmp	SHORT $LN3@SetAirUnit
$LN5@SetAirUnit:
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?SetAirUnitCallbacks@C_Map@@QAEXJP6AXJFPAVC_Base@@@Z@Z ENDP ; C_Map::SetAirUnitCallbacks
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$ = -4						; size = 4
_type$ = 8						; size = 4
_cb$ = 12						; size = 4
?SetObjCallbacks@C_Map@@QAEXJP6AXJFPAVC_Base@@@Z@Z PROC	; C_Map::SetObjCallbacks
; _this$ = ecx

; 2275 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 2276 : 	long i;
; 2277 : 
; 2278 : 	if(type < _MAP_NUM_OBJ_TYPES_)

	cmp	DWORD PTR _type$[ebp], 14		; 0000000eH
	jge	SHORT $LN6@SetObjCall

; 2279 : 	{
; 2280 : 		for(i=0;i<_MAX_TEAMS_;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SetObjCall
$LN3@SetObjCall:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SetObjCall:
	cmp	DWORD PTR _i$[ebp], 8
	jge	SHORT $LN6@SetObjCall

; 2281 : 			if(Team_[i].Objectives->Type[type])

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+876]
	mov	ecx, DWORD PTR _type$[ebp]
	cmp	DWORD PTR [eax+ecx*4+56], 0
	je	SHORT $LN1@SetObjCall

; 2282 : 				Team_[i].Objectives->Type[type]->SetCallback(cb);

	mov	edx, DWORD PTR _cb$[ebp]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+876]
	mov	eax, DWORD PTR _type$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+56]
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+edx+876]
	mov	eax, DWORD PTR _type$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+eax*4+56]
	mov	edx, DWORD PTR [esi+100]
	call	edx
$LN1@SetObjCall:

; 2283 : 	}

	jmp	SHORT $LN3@SetObjCall
$LN6@SetObjCall:

; 2284 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?SetObjCallbacks@C_Map@@QAEXJP6AXJFPAVC_Base@@@Z@Z ENDP	; C_Map::SetObjCallbacks
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_this$ = -12						; size = 4
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_cb$ = 8						; size = 4
?SetAllNavalUnitCallbacks@C_Map@@QAEXP6AXJFPAVC_Base@@@Z@Z PROC ; C_Map::SetAllNavalUnitCallbacks
; _this$ = ecx

; 2319 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2320 : 	long i,j;
; 2321 : 
; 2322 : 	for(i=0;i<_MAX_TEAMS_;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@SetAllNava
$LN6@SetAllNava:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@SetAllNava:
	cmp	DWORD PTR _i$[ebp], 8
	jge	SHORT $LN8@SetAllNava

; 2323 : 		for(j=0;j<_MAP_NUM_NAV_TYPES_;j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN4@SetAllNava
$LN3@SetAllNava:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$LN4@SetAllNava:
	cmp	DWORD PTR _j$[ebp], 2
	jge	SHORT $LN2@SetAllNava

; 2324 : 			if(Team_[i].NavalUnits->Type[j])

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+872]
	mov	edx, DWORD PTR _j$[ebp]
	cmp	DWORD PTR [ecx+edx*4+8], 0
	je	SHORT $LN1@SetAllNava

; 2325 : 				Team_[i].NavalUnits->Type[j]->SetCallback(cb);

	mov	eax, DWORD PTR _cb$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+872]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+8]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+eax+872]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+ecx*4+8]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN1@SetAllNava:

; 2326 : }

	jmp	SHORT $LN3@SetAllNava
$LN2@SetAllNava:
	jmp	SHORT $LN6@SetAllNava
$LN8@SetAllNava:
	mov	esp, ebp
	pop	ebp
	ret	4
?SetAllNavalUnitCallbacks@C_Map@@QAEXP6AXJFPAVC_Base@@@Z@Z ENDP ; C_Map::SetAllNavalUnitCallbacks
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
_k$ = -12						; size = 4
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_cb$ = 8						; size = 4
?SetAllGroundUnitCallbacks@C_Map@@QAEXP6AXJFPAVC_Base@@@Z@Z PROC ; C_Map::SetAllGroundUnitCallbacks
; _this$ = ecx

; 2307 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 2308 : 	long i,j,k;
; 2309 : 
; 2310 : 	for(i=0;i<_MAX_TEAMS_;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN11@SetAllGrou
$LN10@SetAllGrou:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN11@SetAllGrou:
	cmp	DWORD PTR _i$[ebp], 8
	jge	$LN12@SetAllGrou

; 2311 : 		for(j=0;j<_MAP_NUM_GND_TYPES_;j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN8@SetAllGrou
$LN7@SetAllGrou:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$LN8@SetAllGrou:
	cmp	DWORD PTR _j$[ebp], 4
	jge	$LN6@SetAllGrou

; 2312 : 			for(k=0;k<_MAP_NUM_GND_LEVELS_;k++)

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN5@SetAllGrou
$LN4@SetAllGrou:
	mov	edx, DWORD PTR _k$[ebp]
	add	edx, 1
	mov	DWORD PTR _k$[ebp], edx
$LN5@SetAllGrou:
	cmp	DWORD PTR _k$[ebp], 3
	jge	$LN3@SetAllGrou

; 2313 : 				if(Team_[i].Units->Type[j])

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+868]
	mov	eax, DWORD PTR _j$[ebp]
	cmp	DWORD PTR [edx+eax*4+16], 0
	je	SHORT $LN2@SetAllGrou

; 2314 : 					if(Team_[i].Units->Type[j]->Levels[k])

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+868]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+16]
	mov	eax, DWORD PTR _k$[ebp]
	cmp	DWORD PTR [edx+eax*4+12], 0
	je	SHORT $LN2@SetAllGrou

; 2315 : 						Team_[i].Units->Type[j]->Levels[k]->SetCallback(cb);

	mov	ecx, DWORD PTR _cb$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+868]
	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+16]
	mov	ecx, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+12]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+eax+868]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4+16]
	mov	ecx, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+ecx*4+12]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN2@SetAllGrou:

; 2316 : }

	jmp	$LN4@SetAllGrou
$LN3@SetAllGrou:
	jmp	$LN7@SetAllGrou
$LN6@SetAllGrou:
	jmp	$LN10@SetAllGrou
$LN12@SetAllGrou:
	mov	esp, ebp
	pop	ebp
	ret	4
?SetAllGroundUnitCallbacks@C_Map@@QAEXP6AXJFPAVC_Base@@@Z@Z ENDP ; C_Map::SetAllGroundUnitCallbacks
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_this$ = -12						; size = 4
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_cb$ = 8						; size = 4
?SetAllAirUnitCallbacks@C_Map@@QAEXP6AXJFPAVC_Base@@@Z@Z PROC ; C_Map::SetAllAirUnitCallbacks
; _this$ = ecx

; 2297 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2298 : 	long i,j;
; 2299 : 
; 2300 : 	for(i=0;i<_MAX_TEAMS_;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@SetAllAirU
$LN6@SetAllAirU:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@SetAllAirU:
	cmp	DWORD PTR _i$[ebp], 8
	jge	SHORT $LN8@SetAllAirU

; 2301 : 		for(j=0;j<_MAP_NUM_AIR_TYPES_;j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN4@SetAllAirU
$LN3@SetAllAirU:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$LN4@SetAllAirU:
	cmp	DWORD PTR _j$[ebp], 5
	jge	SHORT $LN2@SetAllAirU

; 2302 : 			if(Team_[i].AirUnits->Type[j])

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+864]
	mov	edx, DWORD PTR _j$[ebp]
	cmp	DWORD PTR [ecx+edx*4+20], 0
	je	SHORT $LN1@SetAllAirU

; 2303 : 				Team_[i].AirUnits->Type[j]->SetCallback(cb);

	mov	eax, DWORD PTR _cb$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+864]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+20]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+eax+864]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+ecx*4+20]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN1@SetAllAirU:

; 2304 : }

	jmp	SHORT $LN3@SetAllAirU
$LN2@SetAllAirU:
	jmp	SHORT $LN6@SetAllAirU
$LN8@SetAllAirU:
	mov	esp, ebp
	pop	ebp
	ret	4
?SetAllAirUnitCallbacks@C_Map@@QAEXP6AXJFPAVC_Base@@@Z@Z ENDP ; C_Map::SetAllAirUnitCallbacks
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_this$ = -12						; size = 4
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_cb$ = 8						; size = 4
?SetAllObjCallbacks@C_Map@@QAEXP6AXJFPAVC_Base@@@Z@Z PROC ; C_Map::SetAllObjCallbacks
; _this$ = ecx

; 2287 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2288 : 	long i,j;
; 2289 : 
; 2290 : 	for(i=0;i<_MAX_TEAMS_;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@SetAllObjC
$LN6@SetAllObjC:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@SetAllObjC:
	cmp	DWORD PTR _i$[ebp], 8
	jge	SHORT $LN8@SetAllObjC

; 2291 : 		for(j=0;j<_MAP_NUM_OBJ_TYPES_;j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN4@SetAllObjC
$LN3@SetAllObjC:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$LN4@SetAllObjC:
	cmp	DWORD PTR _j$[ebp], 14			; 0000000eH
	jge	SHORT $LN2@SetAllObjC

; 2292 : 			if(Team_[i].Objectives->Type[j])

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+876]
	mov	edx, DWORD PTR _j$[ebp]
	cmp	DWORD PTR [ecx+edx*4+56], 0
	je	SHORT $LN1@SetAllObjC

; 2293 : 				Team_[i].Objectives->Type[j]->SetCallback(cb);

	mov	eax, DWORD PTR _cb$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+876]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+56]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+eax+876]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+ecx*4+56]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN1@SetAllObjC:

; 2294 : }

	jmp	SHORT $LN3@SetAllObjC
$LN2@SetAllObjC:
	jmp	SHORT $LN6@SetAllObjC
$LN8@SetAllObjC:
	mov	esp, ebp
	pop	ebp
	ret	4
?SetAllObjCallbacks@C_Map@@QAEXP6AXJFPAVC_Base@@@Z@Z ENDP ; C_Map::SetAllObjCallbacks
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_this$ = -24						; size = 4
_x$ = -20						; size = 2
_y$ = -16						; size = 2
_k$ = -12						; size = 2
_j$ = -8						; size = 2
_i$ = -4						; size = 2
?DrawMap@C_Map@@QAEXXZ PROC				; C_Map::DrawMap
; _this$ = ecx

; 2720 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2721 : 	short i,j,k;
; 2722 : 	short x,y;
; 2723 : 
; 2724 : 	if(flags_ & (I_NEED_TO_DRAW|I_NEED_TO_DRAW_MAP))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+736]
	and	ecx, 3
	je	$LN48@DrawMap

; 2725 : 	{
; 2726 : // 2002-04-16 MN update the bullseye location when it changed
; 2727 : 		TheCampaign.GetBullseyeLocation(&x,&y);

	lea	edx, DWORD PTR _y$[ebp]
	push	edx
	lea	eax, DWORD PTR _x$[ebp]
	push	eax
	mov	ecx, OFFSET ?TheCampaign@@3VCampaignClass@@A ; TheCampaign
	call	?GetBullseyeLocation@CampaignClass@@QAEXPAF0@Z ; CampaignClass::GetBullseyeLocation

; 2728 : 		if (x != BullsEyeX_ || y != BullsEyeY_)

	movsx	ecx, WORD PTR _x$[ebp]
	cvtsi2ss xmm0, ecx
	mov	edx, DWORD PTR _this$[ebp]
	ucomiss	xmm0, DWORD PTR [edx+744]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN46@DrawMap
	movsx	eax, WORD PTR _y$[ebp]
	cvtsi2ss xmm0, eax
	mov	ecx, DWORD PTR _this$[ebp]
	ucomiss	xmm0, DWORD PTR [ecx+748]
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN47@DrawMap
$LN46@DrawMap:

; 2729 : 			SetBullsEye(x * FEET_PER_KM,(TheCampaign.TheaterSizeY-y) * FEET_PER_KM);

	movsx	edx, WORD PTR ?TheCampaign@@3VCampaignClass@@A+88
	movsx	eax, WORD PTR _y$[ebp]
	sub	edx, eax
	cvtsi2ss xmm0, edx
	mulss	xmm0, DWORD PTR __real@454cffae
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movsx	ecx, WORD PTR _x$[ebp]
	cvtsi2ss xmm0, ecx
	mulss	xmm0, DWORD PTR __real@454cffae
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetBullsEye@C_Map@@QAEXMM@Z		; C_Map::SetBullsEye
$LN47@DrawMap:

; 2730 : 
; 2731 : 		if(flags_ & I_NEED_TO_DRAW_MAP)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+736]
	and	eax, 2
	je	SHORT $LN45@DrawMap

; 2732 : 		{
; 2733 : 
; 2734 : 			if (Map_)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+808], 0
	je	SHORT $LN44@DrawMap

; 2735 : 			{
; 2736 : 				Map_->Refresh();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+808]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN44@DrawMap:

; 2737 : 			}
; 2738 : 			flags_ ^= I_NEED_TO_DRAW_MAP;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+736]
	xor	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+736], edx
$LN45@DrawMap:

; 2739 : 		}
; 2740 : 
; 2741 : 		if(BullsEye_)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1148], 0
	je	SHORT $LN43@DrawMap

; 2742 : 			BullsEye_->Refresh();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1148]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+1148]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN43@DrawMap:

; 2743 : 		for(i=0;i<_MAX_TEAMS_;i++)

	xor	ecx, ecx
	mov	WORD PTR _i$[ebp], cx
	jmp	SHORT $LN42@DrawMap
$LN41@DrawMap:
	mov	dx, WORD PTR _i$[ebp]
	add	dx, 1
	mov	WORD PTR _i$[ebp], dx
$LN42@DrawMap:
	movsx	eax, WORD PTR _i$[ebp]
	cmp	eax, 8
	jge	$LN40@DrawMap

; 2744 : 			if((TeamFlags_[i] & _MAP_OBJECTIVES_) && Team_[i].Objectives)

	movsx	ecx, WORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+828]
	and	eax, 16777216				; 01000000H
	je	$LN36@DrawMap
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+ecx+876], 0
	je	SHORT $LN36@DrawMap

; 2745 : 			{
; 2746 : 				for(j=0;j<_MAP_NUM_OBJ_TYPES_;j++)

	xor	eax, eax
	mov	WORD PTR _j$[ebp], ax
	jmp	SHORT $LN38@DrawMap
$LN37@DrawMap:
	mov	cx, WORD PTR _j$[ebp]
	add	cx, 1
	mov	WORD PTR _j$[ebp], cx
$LN38@DrawMap:
	movsx	edx, WORD PTR _j$[ebp]
	cmp	edx, 14					; 0000000eH
	jge	SHORT $LN36@DrawMap

; 2747 : 				{
; 2748 : 					if(Team_[i].Objectives->Flags[j])

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+876]
	movsx	eax, WORD PTR _j$[ebp]
	cmp	DWORD PTR [edx+eax*4], 0
	je	SHORT $LN35@DrawMap

; 2749 : 						Team_[i].Objectives->Type[j]->Refresh();

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+876]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+56]
	movsx	eax, WORD PTR _j$[ebp]
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+876]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4+56]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN35@DrawMap:

; 2750 : 				}

	jmp	SHORT $LN37@DrawMap
$LN36@DrawMap:
	jmp	$LN41@DrawMap
$LN40@DrawMap:

; 2751 : 			}
; 2752 : 		for(i=0;i<_MAX_TEAMS_;i++)

	xor	ecx, ecx
	mov	WORD PTR _i$[ebp], cx
	jmp	SHORT $LN34@DrawMap
$LN33@DrawMap:
	mov	dx, WORD PTR _i$[ebp]
	add	dx, 1
	mov	WORD PTR _i$[ebp], dx
$LN34@DrawMap:
	movsx	eax, WORD PTR _i$[ebp]
	cmp	eax, 8
	jge	$LN32@DrawMap

; 2753 : 			if((TeamFlags_[i] & _MAP_NAVAL_UNITS_) && Team_[i].NavalUnits)

	movsx	ecx, WORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+828]
	and	eax, 134217728				; 08000000H
	je	$LN28@DrawMap
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+ecx+872], 0
	je	SHORT $LN28@DrawMap

; 2754 : 			{
; 2755 : 				for(j=0;j<_MAP_NUM_NAV_TYPES_;j++)

	xor	eax, eax
	mov	WORD PTR _j$[ebp], ax
	jmp	SHORT $LN30@DrawMap
$LN29@DrawMap:
	mov	cx, WORD PTR _j$[ebp]
	add	cx, 1
	mov	WORD PTR _j$[ebp], cx
$LN30@DrawMap:
	movsx	edx, WORD PTR _j$[ebp]
	cmp	edx, 2
	jge	SHORT $LN28@DrawMap

; 2756 : 				{
; 2757 : 					if(Team_[i].NavalUnits->Flags[j])

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+872]
	movsx	eax, WORD PTR _j$[ebp]
	cmp	DWORD PTR [edx+eax*4], 0
	je	SHORT $LN27@DrawMap

; 2758 : 						Team_[i].NavalUnits->Type[j]->Refresh();

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+872]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+8]
	movsx	eax, WORD PTR _j$[ebp]
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+872]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4+8]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN27@DrawMap:

; 2759 : 				}

	jmp	SHORT $LN29@DrawMap
$LN28@DrawMap:
	jmp	$LN33@DrawMap
$LN32@DrawMap:

; 2760 : 			}
; 2761 : 		for(i=0;i<_MAX_TEAMS_;i++)

	xor	ecx, ecx
	mov	WORD PTR _i$[ebp], cx
	jmp	SHORT $LN26@DrawMap
$LN25@DrawMap:
	mov	dx, WORD PTR _i$[ebp]
	add	dx, 1
	mov	WORD PTR _i$[ebp], dx
$LN26@DrawMap:
	movsx	eax, WORD PTR _i$[ebp]
	cmp	eax, 8
	jge	$LN24@DrawMap

; 2762 : 			if((TeamFlags_[i] & _MAP_UNITS_) && Team_[i].Units)

	movsx	ecx, WORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+828]
	and	eax, 33554432				; 02000000H
	je	$LN20@DrawMap
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+ecx+868], 0
	je	$LN20@DrawMap

; 2763 : 			{
; 2764 : 				for(j=0;j<_MAP_NUM_GND_TYPES_;j++)

	xor	eax, eax
	mov	WORD PTR _j$[ebp], ax
	jmp	SHORT $LN22@DrawMap
$LN21@DrawMap:
	mov	cx, WORD PTR _j$[ebp]
	add	cx, 1
	mov	WORD PTR _j$[ebp], cx
$LN22@DrawMap:
	movsx	edx, WORD PTR _j$[ebp]
	cmp	edx, 4
	jge	$LN20@DrawMap

; 2765 : 				{
; 2766 : 					if(Team_[i].Units->Flags[j])

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+868]
	movsx	eax, WORD PTR _j$[ebp]
	cmp	DWORD PTR [edx+eax*4], 0
	je	$LN16@DrawMap

; 2767 : 					{
; 2768 : 						for(k=0;k<_MAP_NUM_GND_LEVELS_;k++)

	xor	ecx, ecx
	mov	WORD PTR _k$[ebp], cx
	jmp	SHORT $LN18@DrawMap
$LN17@DrawMap:
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$LN18@DrawMap:
	movsx	eax, WORD PTR _k$[ebp]
	cmp	eax, 3
	jge	SHORT $LN16@DrawMap

; 2769 : 						{
; 2770 : 							if(Team_[i].Units->Type[j]->Flags[k])

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+868]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+16]
	movsx	eax, WORD PTR _k$[ebp]
	cmp	DWORD PTR [edx+eax*4], 0
	je	SHORT $LN15@DrawMap

; 2771 : 								Team_[i].Units->Type[j]->Levels[k]->Refresh();

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+868]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+16]
	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+12]
	movsx	edx, WORD PTR _k$[ebp]
	movsx	eax, WORD PTR _j$[ebp]
	movsx	esi, WORD PTR _i$[ebp]
	imul	esi, 24					; 00000018H
	mov	edi, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edi+esi+868]
	mov	eax, DWORD PTR [esi+eax*4+16]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4+12]
	mov	edx, DWORD PTR [esi+160]
	call	edx
$LN15@DrawMap:

; 2772 : 						}

	jmp	$LN17@DrawMap
$LN16@DrawMap:

; 2773 : 					}
; 2774 : 				}

	jmp	$LN21@DrawMap
$LN20@DrawMap:
	jmp	$LN25@DrawMap
$LN24@DrawMap:

; 2775 : 			}
; 2776 : 		for(i=0;i<_MAX_TEAMS_;i++)

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax
	jmp	SHORT $LN14@DrawMap
$LN13@DrawMap:
	mov	cx, WORD PTR _i$[ebp]
	add	cx, 1
	mov	WORD PTR _i$[ebp], cx
$LN14@DrawMap:
	movsx	edx, WORD PTR _i$[ebp]
	cmp	edx, 8
	jge	SHORT $LN12@DrawMap

; 2777 : 			if((TeamFlags_[i] & _MAP_WAYPOINTS_) && Team_[i].Waypoints)

	movsx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+828]
	and	edx, 268435456				; 10000000H
	je	SHORT $LN11@DrawMap
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax+880], 0
	je	SHORT $LN11@DrawMap

; 2778 : 				Team_[i].Waypoints->Refresh();

	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+880]
	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx+880]
	mov	edx, DWORD PTR [esi+160]
	call	edx
$LN11@DrawMap:

; 2779 : 		for(i=0;i<_MAX_TEAMS_;i++)

	jmp	SHORT $LN13@DrawMap
$LN12@DrawMap:
	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax
	jmp	SHORT $LN10@DrawMap
$LN9@DrawMap:
	mov	cx, WORD PTR _i$[ebp]
	add	cx, 1
	mov	WORD PTR _i$[ebp], cx
$LN10@DrawMap:
	movsx	edx, WORD PTR _i$[ebp]
	cmp	edx, 8
	jge	$LN8@DrawMap

; 2780 : 			if((TeamFlags_[i] & _MAP_AIR_UNITS_) && Team_[i].AirUnits)

	movsx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+828]
	and	edx, 67108864				; 04000000H
	je	$LN4@DrawMap
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax+864], 0
	je	SHORT $LN4@DrawMap

; 2781 : 			{
; 2782 : 				for(j=0;j<_MAP_NUM_AIR_TYPES_;j++)

	xor	edx, edx
	mov	WORD PTR _j$[ebp], dx
	jmp	SHORT $LN6@DrawMap
$LN5@DrawMap:
	mov	ax, WORD PTR _j$[ebp]
	add	ax, 1
	mov	WORD PTR _j$[ebp], ax
$LN6@DrawMap:
	movsx	ecx, WORD PTR _j$[ebp]
	cmp	ecx, 5
	jge	SHORT $LN4@DrawMap

; 2783 : 				{
; 2784 : 					if(Team_[i].AirUnits->Flags[j])

	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+864]
	movsx	edx, WORD PTR _j$[ebp]
	cmp	DWORD PTR [ecx+edx*4], 0
	je	SHORT $LN3@DrawMap

; 2785 : 						Team_[i].AirUnits->Type[j]->Refresh();

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+864]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+20]
	movsx	edx, WORD PTR _j$[ebp]
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [esi+eax+864]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4+20]
	mov	edx, DWORD PTR [esi+160]
	call	edx
$LN3@DrawMap:

; 2786 : 				}

	jmp	SHORT $LN5@DrawMap
$LN4@DrawMap:
	jmp	$LN9@DrawMap
$LN8@DrawMap:

; 2787 : 			}
; 2788 : 		if(CurIcons_)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1116], 0
	je	SHORT $LN2@DrawMap

; 2789 : 			CurIcons_->Refresh();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1116]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+1116]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN2@DrawMap:

; 2790 : 		if(CurWP_)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1092], 0
	je	SHORT $LN1@DrawMap

; 2791 : 			CurWP_->Refresh();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1092]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+1092]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN1@DrawMap:

; 2792 : 		flags_ ^= I_NEED_TO_DRAW;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+736]
	xor	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+736], edx
$LN48@DrawMap:

; 2793 : 	}
; 2794 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?DrawMap@C_Map@@QAEXXZ ENDP				; C_Map::DrawMap
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?TurnOffBullseye@C_Map@@QAEXXZ PROC			; C_Map::TurnOffBullseye
; _this$ = ecx

; 1625 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1626 : 	if(BullsEye_)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1148], 0
	je	SHORT $LN3@TurnOffBul

; 1627 : 	{
; 1628 : 		BullsEye_->SetFlagBitOn(C_BIT_INVISIBLE);

	push	8192					; 00002000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1148]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+1148]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 1629 : 		if(DrawWindow_)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1124], 0
	je	SHORT $LN3@TurnOffBul

; 1630 : 			DrawWindow_->RefreshWindow();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1124]
	call	?RefreshWindow@C_Window@@QAEXXZ		; C_Window::RefreshWindow
$LN3@TurnOffBul:

; 1631 : 	}
; 1632 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?TurnOffBullseye@C_Map@@QAEXXZ ENDP			; C_Map::TurnOffBullseye
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?TurnOnBullseye@C_Map@@QAEXXZ PROC			; C_Map::TurnOnBullseye
; _this$ = ecx

; 1615 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1616 : 	if(BullsEye_)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1148], 0
	je	SHORT $LN3@TurnOnBull

; 1617 : 	{
; 1618 : 		BullsEye_->SetFlagBitOff(C_BIT_INVISIBLE);

	push	8192					; 00002000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1148]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+1148]
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 1619 : 		if(DrawWindow_)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1124], 0
	je	SHORT $LN3@TurnOnBull

; 1620 : 			DrawWindow_->RefreshWindow();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1124]
	call	?RefreshWindow@C_Window@@QAEXXZ		; C_Window::RefreshWindow
$LN3@TurnOnBull:

; 1621 : 	}
; 1622 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?TurnOnBullseye@C_Map@@QAEXXZ ENDP			; C_Map::TurnOnBullseye
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?TurnOffArrows@C_Map@@QAEXXZ PROC			; C_Map::TurnOffArrows
; _this$ = ecx

; 2271 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2272 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?TurnOffArrows@C_Map@@QAEXXZ ENDP			; C_Map::TurnOffArrows
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?TurnOffBoundaries@C_Map@@QAEXXZ PROC			; C_Map::TurnOffBoundaries
; _this$ = ecx

; 2267 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2268 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?TurnOffBoundaries@C_Map@@QAEXXZ ENDP			; C_Map::TurnOffBoundaries
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
_k$ = -12						; size = 2
_i$ = -8						; size = 2
_j$ = -4						; size = 2
?TurnOffNames@C_Map@@QAEXXZ PROC			; C_Map::TurnOffNames
; _this$ = ecx

; 2248 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2249 : 	short i,j,k;
; 2250 : 
; 2251 : 	for(i=0;i<_MAX_TEAMS_;i++)

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax
	jmp	SHORT $LN18@TurnOffNam
$LN17@TurnOffNam:
	mov	cx, WORD PTR _i$[ebp]
	add	cx, 1
	mov	WORD PTR _i$[ebp], cx
$LN18@TurnOffNam:
	movsx	edx, WORD PTR _i$[ebp]
	cmp	edx, 8
	jge	$LN16@TurnOffNam

; 2252 : 	{
; 2253 : 		for(j=0;j<_MAP_NUM_OBJ_TYPES_;j++)

	xor	eax, eax
	mov	WORD PTR _j$[ebp], ax
	jmp	SHORT $LN15@TurnOffNam
$LN14@TurnOffNam:
	mov	cx, WORD PTR _j$[ebp]
	add	cx, 1
	mov	WORD PTR _j$[ebp], cx
$LN15@TurnOffNam:
	movsx	edx, WORD PTR _j$[ebp]
	cmp	edx, 14					; 0000000eH
	jge	SHORT $LN13@TurnOffNam

; 2254 : 			Team_[i].Objectives->Type[j]->SetFlagBitOn(C_BIT_NOLABEL);

	push	16777216				; 01000000H
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+876]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+56]
	movsx	edx, WORD PTR _j$[ebp]
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [esi+eax+876]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4+56]
	mov	edx, DWORD PTR [esi+8]
	call	edx
	jmp	SHORT $LN14@TurnOffNam
$LN13@TurnOffNam:

; 2255 : 		for(j=0;j<_MAP_NUM_NAV_TYPES_;j++)

	xor	eax, eax
	mov	WORD PTR _j$[ebp], ax
	jmp	SHORT $LN12@TurnOffNam
$LN11@TurnOffNam:
	mov	cx, WORD PTR _j$[ebp]
	add	cx, 1
	mov	WORD PTR _j$[ebp], cx
$LN12@TurnOffNam:
	movsx	edx, WORD PTR _j$[ebp]
	cmp	edx, 2
	jge	SHORT $LN10@TurnOffNam

; 2256 : 			Team_[i].NavalUnits->Type[j]->SetFlagBitOn(C_BIT_NOLABEL);

	push	16777216				; 01000000H
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+872]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+8]
	movsx	edx, WORD PTR _j$[ebp]
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [esi+eax+872]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4+8]
	mov	edx, DWORD PTR [esi+8]
	call	edx
	jmp	SHORT $LN11@TurnOffNam
$LN10@TurnOffNam:

; 2257 : 		for(j=0;j<_MAP_NUM_GND_TYPES_;j++)

	xor	eax, eax
	mov	WORD PTR _j$[ebp], ax
	jmp	SHORT $LN9@TurnOffNam
$LN8@TurnOffNam:
	mov	cx, WORD PTR _j$[ebp]
	add	cx, 1
	mov	WORD PTR _j$[ebp], cx
$LN9@TurnOffNam:
	movsx	edx, WORD PTR _j$[ebp]
	cmp	edx, 4
	jge	SHORT $LN7@TurnOffNam

; 2258 : 			for(k=0;k<_MAP_NUM_GND_LEVELS_;k++)

	xor	eax, eax
	mov	WORD PTR _k$[ebp], ax
	jmp	SHORT $LN6@TurnOffNam
$LN5@TurnOffNam:
	mov	cx, WORD PTR _k$[ebp]
	add	cx, 1
	mov	WORD PTR _k$[ebp], cx
$LN6@TurnOffNam:
	movsx	edx, WORD PTR _k$[ebp]
	cmp	edx, 3
	jge	SHORT $LN4@TurnOffNam

; 2259 : 				Team_[i].Units->Type[j]->Levels[k]->SetFlagBitOn(C_BIT_NOLABEL);

	push	16777216				; 01000000H
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+868]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+16]
	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+12]
	movsx	ecx, WORD PTR _k$[ebp]
	movsx	edx, WORD PTR _j$[ebp]
	movsx	esi, WORD PTR _i$[ebp]
	imul	esi, 24					; 00000018H
	mov	edi, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edi+esi+868]
	mov	edx, DWORD PTR [esi+edx*4+16]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4+12]
	mov	edx, DWORD PTR [eax+8]
	call	edx
	jmp	SHORT $LN5@TurnOffNam
$LN4@TurnOffNam:
	jmp	$LN8@TurnOffNam
$LN7@TurnOffNam:

; 2260 : 		for(j=0;j<_MAP_NUM_AIR_TYPES_;j++)

	xor	eax, eax
	mov	WORD PTR _j$[ebp], ax
	jmp	SHORT $LN3@TurnOffNam
$LN2@TurnOffNam:
	mov	cx, WORD PTR _j$[ebp]
	add	cx, 1
	mov	WORD PTR _j$[ebp], cx
$LN3@TurnOffNam:
	movsx	edx, WORD PTR _j$[ebp]
	cmp	edx, 5
	jge	SHORT $LN1@TurnOffNam

; 2261 : 			Team_[i].AirUnits->Type[j]->SetFlagBitOn(C_BIT_NOLABEL);

	push	16777216				; 01000000H
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+864]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+20]
	movsx	edx, WORD PTR _j$[ebp]
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [esi+eax+864]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4+20]
	mov	edx, DWORD PTR [esi+8]
	call	edx
	jmp	SHORT $LN2@TurnOffNam
$LN1@TurnOffNam:

; 2262 : 	}

	jmp	$LN17@TurnOffNam
$LN16@TurnOffNam:

; 2263 : 	flags_ |= I_NEED_TO_DRAW_MAP;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+736]
	or	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+736], ecx

; 2264 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?TurnOffNames@C_Map@@QAEXXZ ENDP			; C_Map::TurnOffNames
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?TurnOnArrows@C_Map@@QAEXXZ PROC			; C_Map::TurnOnArrows
; _this$ = ecx

; 2244 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2245 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?TurnOnArrows@C_Map@@QAEXXZ ENDP			; C_Map::TurnOnArrows
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?TurnOnBoundaries@C_Map@@QAEXXZ PROC			; C_Map::TurnOnBoundaries
; _this$ = ecx

; 2240 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2241 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?TurnOnBoundaries@C_Map@@QAEXXZ ENDP			; C_Map::TurnOnBoundaries
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
_k$ = -12						; size = 2
_i$ = -8						; size = 2
_j$ = -4						; size = 2
?TurnOnNames@C_Map@@QAEXXZ PROC				; C_Map::TurnOnNames
; _this$ = ecx

; 2221 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2222 : 	short i,j,k;
; 2223 : 
; 2224 : 	for(i=0;i<_MAX_TEAMS_;i++)

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax
	jmp	SHORT $LN18@TurnOnName
$LN17@TurnOnName:
	mov	cx, WORD PTR _i$[ebp]
	add	cx, 1
	mov	WORD PTR _i$[ebp], cx
$LN18@TurnOnName:
	movsx	edx, WORD PTR _i$[ebp]
	cmp	edx, 8
	jge	$LN16@TurnOnName

; 2225 : 	{
; 2226 : 		for(j=0;j<_MAP_NUM_OBJ_TYPES_;j++)

	xor	eax, eax
	mov	WORD PTR _j$[ebp], ax
	jmp	SHORT $LN15@TurnOnName
$LN14@TurnOnName:
	mov	cx, WORD PTR _j$[ebp]
	add	cx, 1
	mov	WORD PTR _j$[ebp], cx
$LN15@TurnOnName:
	movsx	edx, WORD PTR _j$[ebp]
	cmp	edx, 14					; 0000000eH
	jge	SHORT $LN13@TurnOnName

; 2227 : 			Team_[i].Objectives->Type[j]->SetFlagBitOff(C_BIT_NOLABEL);

	push	16777216				; 01000000H
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+876]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+56]
	movsx	edx, WORD PTR _j$[ebp]
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [esi+eax+876]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4+56]
	mov	edx, DWORD PTR [esi+12]
	call	edx
	jmp	SHORT $LN14@TurnOnName
$LN13@TurnOnName:

; 2228 : 		for(j=0;j<_MAP_NUM_NAV_TYPES_;j++)

	xor	eax, eax
	mov	WORD PTR _j$[ebp], ax
	jmp	SHORT $LN12@TurnOnName
$LN11@TurnOnName:
	mov	cx, WORD PTR _j$[ebp]
	add	cx, 1
	mov	WORD PTR _j$[ebp], cx
$LN12@TurnOnName:
	movsx	edx, WORD PTR _j$[ebp]
	cmp	edx, 2
	jge	SHORT $LN10@TurnOnName

; 2229 : 			Team_[i].NavalUnits->Type[j]->SetFlagBitOff(C_BIT_NOLABEL);

	push	16777216				; 01000000H
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+872]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+8]
	movsx	edx, WORD PTR _j$[ebp]
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [esi+eax+872]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4+8]
	mov	edx, DWORD PTR [esi+12]
	call	edx
	jmp	SHORT $LN11@TurnOnName
$LN10@TurnOnName:

; 2230 : 		for(j=0;j<_MAP_NUM_GND_TYPES_;j++)

	xor	eax, eax
	mov	WORD PTR _j$[ebp], ax
	jmp	SHORT $LN9@TurnOnName
$LN8@TurnOnName:
	mov	cx, WORD PTR _j$[ebp]
	add	cx, 1
	mov	WORD PTR _j$[ebp], cx
$LN9@TurnOnName:
	movsx	edx, WORD PTR _j$[ebp]
	cmp	edx, 4
	jge	SHORT $LN7@TurnOnName

; 2231 : 			for(k=0;k<_MAP_NUM_GND_LEVELS_;k++)

	xor	eax, eax
	mov	WORD PTR _k$[ebp], ax
	jmp	SHORT $LN6@TurnOnName
$LN5@TurnOnName:
	mov	cx, WORD PTR _k$[ebp]
	add	cx, 1
	mov	WORD PTR _k$[ebp], cx
$LN6@TurnOnName:
	movsx	edx, WORD PTR _k$[ebp]
	cmp	edx, 3
	jge	SHORT $LN4@TurnOnName

; 2232 : 				Team_[i].Units->Type[j]->Levels[k]->SetFlagBitOff(C_BIT_NOLABEL);

	push	16777216				; 01000000H
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+868]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+16]
	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+12]
	movsx	ecx, WORD PTR _k$[ebp]
	movsx	edx, WORD PTR _j$[ebp]
	movsx	esi, WORD PTR _i$[ebp]
	imul	esi, 24					; 00000018H
	mov	edi, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edi+esi+868]
	mov	edx, DWORD PTR [esi+edx*4+16]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4+12]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	jmp	SHORT $LN5@TurnOnName
$LN4@TurnOnName:
	jmp	$LN8@TurnOnName
$LN7@TurnOnName:

; 2233 : 		for(j=0;j<_MAP_NUM_AIR_TYPES_;j++)

	xor	eax, eax
	mov	WORD PTR _j$[ebp], ax
	jmp	SHORT $LN3@TurnOnName
$LN2@TurnOnName:
	mov	cx, WORD PTR _j$[ebp]
	add	cx, 1
	mov	WORD PTR _j$[ebp], cx
$LN3@TurnOnName:
	movsx	edx, WORD PTR _j$[ebp]
	cmp	edx, 5
	jge	SHORT $LN1@TurnOnName

; 2234 : 			Team_[i].AirUnits->Type[j]->SetFlagBitOff(C_BIT_NOLABEL);

	push	16777216				; 01000000H
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+864]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+20]
	movsx	edx, WORD PTR _j$[ebp]
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [esi+eax+864]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4+20]
	mov	edx, DWORD PTR [esi+12]
	call	edx
	jmp	SHORT $LN2@TurnOnName
$LN1@TurnOnName:

; 2235 : 	}

	jmp	$LN17@TurnOnName
$LN16@TurnOnName:

; 2236 : 	flags_ |= I_NEED_TO_DRAW_MAP;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+736]
	or	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+736], ecx

; 2237 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?TurnOnNames@C_Map@@QAEXXZ ENDP				; C_Map::TurnOnNames
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_un$ = -8						; size = 4
_this$ = -4						; size = 4
?RemoveOldWaypoints@C_Map@@QAEXXZ PROC			; C_Map::RemoveOldWaypoints
; _this$ = ecx

; 1579 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1580 : 	Unit un;
; 1581 : 
; 1582 : 	// remove current set
; 1583 : 	if(WPUnitID_ != FalconNullId)

	push	OFFSET ?FalconNullId@@3VVU_ID@@A	; FalconNullId
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1084				; 0000043cH
	call	??9VU_ID@@QBE_NABV0@@Z			; VU_ID::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@RemoveOldW

; 1584 : 	{
; 1585 : 		un=(Unit)vuDatabase->Find(WPUnitID_);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1088]
	push	edx
	mov	eax, DWORD PTR [ecx+1084]
	push	eax
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _un$[ebp], eax

; 1586 : 		if(!un)

	cmp	DWORD PTR _un$[ebp], 0
	jne	SHORT $LN3@RemoveOldW

; 1587 : 			RemoveCurWPList();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveCurWPList@C_Map@@QAEXXZ		; C_Map::RemoveCurWPList
$LN3@RemoveOldW:

; 1588 : 	}
; 1589 : 
; 1590 : 	// go through the teams and remove old WP lists
; 1591 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveOldWaypoints@C_Map@@QAEXXZ ENDP			; C_Map::RemoveOldWaypoints
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_Leave$ = -12						; size = 4
_TypeID$ = -8						; size = 4
_this$ = -4						; size = 4
_team$ = 8						; size = 4
_ID$ = 12						; size = 4
?RemoveVC@C_Map@@QAEXJJ@Z PROC				; C_Map::RemoveVC
; _this$ = ecx

; 889  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 890  : 	long TypeID;
; 891  : 	F4CSECTIONHANDLE *Leave;
; 892  : 
; 893  : 	TypeID=FindTypeIndex(_VC_CONDITION_,OBJ_TypeList,_MAP_NUM_OBJ_TYPES_);

	push	14					; 0000000eH
	push	OFFSET ?OBJ_TypeList@@3PAJA		; OBJ_TypeList
	push	8192					; 00002000H
	call	?FindTypeIndex@@YAJJQAJH@Z		; FindTypeIndex
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _TypeID$[ebp], eax

; 894  : 	if(TypeID != -1)

	cmp	DWORD PTR _TypeID$[ebp], -1
	je	SHORT $LN2@RemoveVC

; 895  : 	{
; 896  : 		Leave=UI_Enter(DrawWindow_);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1124]
	push	ecx
	call	?UI_Enter@@YAPAUF4CSECTIONHANDLE@@PAVC_Window@@@Z ; UI_Enter
	add	esp, 4
	mov	DWORD PTR _Leave$[ebp], eax

; 897  : 		Team_[team].Objectives->Type[TypeID]->RemoveIcon(ID);

	mov	edx, DWORD PTR _ID$[ebp]
	push	edx
	mov	eax, DWORD PTR _team$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+876]
	mov	eax, DWORD PTR _TypeID$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+56]
	call	?RemoveIcon@C_MapIcon@@QAEXJ@Z		; C_MapIcon::RemoveIcon

; 898  : 		UI_Leave(Leave);

	mov	ecx, DWORD PTR _Leave$[ebp]
	push	ecx
	call	?UI_Leave@@YAXPAUF4CSECTIONHANDLE@@@Z	; UI_Leave
	add	esp, 4
$LN2@RemoveVC:

; 899  : 	}
; 900  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?RemoveVC@C_Map@@QAEXJJ@Z ENDP				; C_Map::RemoveVC
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
$T1 = -28						; size = 8
tv219 = -20						; size = 4
_TypeID$ = -16						; size = 4
_this$ = -12						; size = 4
_vcicon$ = -8						; size = 4
_ent$ = -4						; size = 4
_vc$ = 8						; size = 4
?UpdateVC@C_Map@@QAEXPAVvictory_condition@@@Z PROC	; C_Map::UpdateVC
; _this$ = ecx

; 858  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 859  : 	long TypeID;
; 860  : 	CampEntity ent;
; 861  : 	MAPICONLIST *vcicon;
; 862  : 
; 863  : 	ent=(CampEntity)vuDatabase->Find(vc->get_vu_id());

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_vu_id@victory_condition@@QAE?AVVU_ID@@XZ ; victory_condition::get_vu_id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _ent$[ebp], eax

; 864  : 	if(ent)

	cmp	DWORD PTR _ent$[ebp], 0
	je	SHORT $LN5@UpdateVC

; 865  : 	{
; 866  : 		if(!ent->IsUnit() && !ent->IsObjective())

	mov	eax, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+232]
	call	eax
	test	eax, eax
	jne	SHORT $LN5@UpdateVC
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+236]
	call	eax
	test	eax, eax
	jne	SHORT $LN5@UpdateVC

; 867  : 			ent=NULL;

	mov	DWORD PTR _ent$[ebp], 0
$LN5@UpdateVC:

; 868  : 	}
; 869  : 
; 870  : 	TypeID=FindTypeIndex(_VC_CONDITION_,OBJ_TypeList,_MAP_NUM_OBJ_TYPES_);

	push	14					; 0000000eH
	push	OFFSET ?OBJ_TypeList@@3PAJA		; OBJ_TypeList
	push	8192					; 00002000H
	call	?FindTypeIndex@@YAJJQAJH@Z		; FindTypeIndex
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _TypeID$[ebp], eax

; 871  : 	if(TypeID != -1)

	cmp	DWORD PTR _TypeID$[ebp], -1
	je	$LN1@UpdateVC

; 872  : 	{
; 873  : 		vcicon=Team_[vc->get_team()].Objectives->Type[TypeID]->FindID(vc->get_number());

	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_number@victory_condition@@QAEHXZ	; victory_condition::get_number
	push	eax
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_team@victory_condition@@QAEHXZ	; victory_condition::get_team
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+876]
	mov	eax, DWORD PTR _TypeID$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+56]
	call	?FindID@C_MapIcon@@QAEPAVMAPICONLIST@@J@Z ; C_MapIcon::FindID
	mov	DWORD PTR _vcicon$[ebp], eax

; 874  : 		if(!ent)

	cmp	DWORD PTR _ent$[ebp], 0
	jne	SHORT $LN3@UpdateVC

; 875  : 		{
; 876  : 			Team_[vc->get_team()].Objectives->Type[TypeID]->RemoveIcon(vc->get_number());

	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_number@victory_condition@@QAEHXZ	; victory_condition::get_number
	push	eax
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_team@victory_condition@@QAEHXZ	; victory_condition::get_team
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+876]
	mov	eax, DWORD PTR _TypeID$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+56]
	call	?RemoveIcon@C_MapIcon@@QAEXJ@Z		; C_MapIcon::RemoveIcon
	jmp	SHORT $LN1@UpdateVC
$LN3@UpdateVC:

; 877  : 		}
; 878  : 		else if (vcicon)

	cmp	DWORD PTR _vcicon$[ebp], 0
	je	SHORT $LN1@UpdateVC

; 879  : 		{
; 880  : 			vcicon->worldx=ent->YPos();

	mov	ecx, DWORD PTR _ent$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	mov	ecx, DWORD PTR _vcicon$[ebp]
	fstp	DWORD PTR [ecx+20]

; 881  : 			vcicon->worldy=maxy-ent->XPos();

	mov	ecx, DWORD PTR _ent$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv219[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+732]
	subss	xmm0, DWORD PTR tv219[ebp]
	mov	eax, DWORD PTR _vcicon$[ebp]
	movss	DWORD PTR [eax+24], xmm0

; 882  : 			vcicon->x=static_cast<short>(vcicon->worldx*scale_);

	mov	ecx, DWORD PTR _vcicon$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+20]
	mulss	xmm0, DWORD PTR [edx+728]
	cvttss2si eax, xmm0
	mov	ecx, DWORD PTR _vcicon$[ebp]
	mov	WORD PTR [ecx+16], ax

; 883  : 			vcicon->y=static_cast<short>(vcicon->worldy*scale_);

	mov	edx, DWORD PTR _vcicon$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+24]
	mulss	xmm0, DWORD PTR [eax+728]
	cvttss2si ecx, xmm0
	mov	edx, DWORD PTR _vcicon$[ebp]
	mov	WORD PTR [edx+18], cx
$LN1@UpdateVC:

; 884  : 		}
; 885  : 	}
; 886  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?UpdateVC@C_Map@@QAEXPAVvictory_condition@@@Z ENDP	; C_Map::UpdateVC
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
$T1 = -32						; size = 8
tv494 = -24						; size = 4
_nub$ = -20						; size = 4
_wp$ = -16						; size = 4
_this$ = -12						; size = 4
_check$ = -8						; size = 2
_i$ = -4						; size = 2
_flt$ = 8						; size = 4
?UpdateWaypoint@C_Map@@QAEXPAVFlightClass@@@Z PROC	; C_Map::UpdateWaypoint
; _this$ = ecx

; 1482 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1483 : 	WayPoint wp;
; 1484 : 	WAYPOINTLIST *nub;
; 1485 : 	short i,check;
; 1486 : 
; 1487 : 	if(flt->Id() == WPUnitID_)

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1084				; 0000043cH
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _flt$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, eax
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	edx, al
	test	edx, edx
	je	$LN17@UpdateWayp

; 1488 : 	{
; 1489 : 		// We have to traverse all our waypoints to check for validity
; 1490 : 		if(flt->GetCurrentUnitWP() == flt->GetFirstUnitWP())

	mov	ecx, DWORD PTR _flt$[ebp]
	call	?GetCurrentUnitWP@UnitClass@@QBEPAVWayPointClass@@XZ ; UnitClass::GetCurrentUnitWP
	mov	esi, eax
	mov	ecx, DWORD PTR _flt$[ebp]
	call	?GetFirstUnitWP@UnitClass@@QAEPAVWayPointClass@@XZ ; UnitClass::GetFirstUnitWP
	cmp	esi, eax
	jne	SHORT $LN16@UpdateWayp

; 1491 : 			check=1;

	mov	eax, 1
	mov	WORD PTR _check$[ebp], ax

; 1492 : 		else

	jmp	SHORT $LN15@UpdateWayp
$LN16@UpdateWayp:

; 1493 : 			check=0;

	xor	ecx, ecx
	mov	WORD PTR _check$[ebp], cx
$LN15@UpdateWayp:

; 1494 : 		i=1;

	mov	edx, 1
	mov	WORD PTR _i$[ebp], dx

; 1495 : 		wp=flt->GetFirstUnitWP();

	mov	ecx, DWORD PTR _flt$[ebp]
	call	?GetFirstUnitWP@UnitClass@@QAEPAVWayPointClass@@XZ ; UnitClass::GetFirstUnitWP
	mov	DWORD PTR _wp$[ebp], eax
$LN14@UpdateWayp:

; 1496 : 		while(wp)

	cmp	DWORD PTR _wp$[ebp], 0
	je	$LN13@UpdateWayp

; 1497 : 			{
; 1498 : 			if (!IsValidWP(wp,flt) && check)

	mov	eax, DWORD PTR _flt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _wp$[ebp]
	push	ecx
	call	?IsValidWP@@YAHPAVWayPointClass@@PAVFlightClass@@@Z ; IsValidWP
	add	esp, 8
	test	eax, eax
	jne	$LN12@UpdateWayp
	movsx	edx, WORD PTR _check$[ebp]
	test	edx, edx
	je	$LN12@UpdateWayp

; 1499 : 				{
; 1500 : 				CurWP_->SetState((flt->GetCampID() << 8)+i,2);

	push	2
	mov	eax, DWORD PTR _flt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _flt$[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax
	movsx	ecx, ax
	shl	ecx, 8
	movsx	edx, WORD PTR _i$[ebp]
	add	ecx, edx
	push	ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1092]
	call	?SetState@C_Waypoint@@QAEXJF@Z		; C_Waypoint::SetState

; 1501 : 				CurWP_->SetState(0x40000000|(flt->GetCampID() << 8)+i,2);

	push	2
	mov	ecx, DWORD PTR _flt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _flt$[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax
	movsx	ecx, ax
	shl	ecx, 8
	movsx	edx, WORD PTR _i$[ebp]
	add	ecx, edx
	or	ecx, 1073741824				; 40000000H
	push	ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1092]
	call	?SetState@C_Waypoint@@QAEXJF@Z		; C_Waypoint::SetState

; 1502 : 				CurWPZ_->SetState((flt->GetCampID() << 8)+i,2);

	push	2
	mov	ecx, DWORD PTR _flt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _flt$[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax
	movsx	ecx, ax
	shl	ecx, 8
	movsx	edx, WORD PTR _i$[ebp]
	add	ecx, edx
	push	ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1096]
	call	?SetState@C_Waypoint@@QAEXJF@Z		; C_Waypoint::SetState
	jmp	$LN11@UpdateWayp
$LN12@UpdateWayp:

; 1503 : 				}
; 1504 : 			else if (wp == flt->GetCurrentUnitWP())

	mov	ecx, DWORD PTR _flt$[ebp]
	call	?GetCurrentUnitWP@UnitClass@@QBEPAVWayPointClass@@XZ ; UnitClass::GetCurrentUnitWP
	cmp	DWORD PTR _wp$[ebp], eax
	jne	$LN10@UpdateWayp

; 1505 : 				{
; 1506 : 				CurWP_->SetState((flt->GetCampID() << 8)+i,1);

	push	1
	mov	ecx, DWORD PTR _flt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _flt$[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax
	movsx	ecx, ax
	shl	ecx, 8
	movsx	edx, WORD PTR _i$[ebp]
	add	ecx, edx
	push	ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1092]
	call	?SetState@C_Waypoint@@QAEXJF@Z		; C_Waypoint::SetState

; 1507 : 				CurWP_->SetState(0x40000000|(flt->GetCampID() << 8)+i,1);

	push	1
	mov	ecx, DWORD PTR _flt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _flt$[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax
	movsx	ecx, ax
	shl	ecx, 8
	movsx	edx, WORD PTR _i$[ebp]
	add	ecx, edx
	or	ecx, 1073741824				; 40000000H
	push	ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1092]
	call	?SetState@C_Waypoint@@QAEXJF@Z		; C_Waypoint::SetState

; 1508 : 				CurWPZ_->SetState((flt->GetCampID() << 8)+i,1);

	push	1
	mov	ecx, DWORD PTR _flt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _flt$[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax
	movsx	ecx, ax
	shl	ecx, 8
	movsx	edx, WORD PTR _i$[ebp]
	add	ecx, edx
	push	ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1096]
	call	?SetState@C_Waypoint@@QAEXJF@Z		; C_Waypoint::SetState

; 1509 : 				}
; 1510 : 			else

	jmp	$LN11@UpdateWayp
$LN10@UpdateWayp:

; 1511 : 				{
; 1512 : 				CurWP_->SetState((flt->GetCampID() << 8)+i,0);

	push	0
	mov	ecx, DWORD PTR _flt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _flt$[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax
	movsx	ecx, ax
	shl	ecx, 8
	movsx	edx, WORD PTR _i$[ebp]
	add	ecx, edx
	push	ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1092]
	call	?SetState@C_Waypoint@@QAEXJF@Z		; C_Waypoint::SetState

; 1513 : 				CurWP_->SetState(0x40000000|(flt->GetCampID() << 8)+i,0);

	push	0
	mov	ecx, DWORD PTR _flt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _flt$[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax
	movsx	ecx, ax
	shl	ecx, 8
	movsx	edx, WORD PTR _i$[ebp]
	add	ecx, edx
	or	ecx, 1073741824				; 40000000H
	push	ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1092]
	call	?SetState@C_Waypoint@@QAEXJF@Z		; C_Waypoint::SetState

; 1514 : 				CurWPZ_->SetState((flt->GetCampID() << 8)+i,0);

	push	0
	mov	ecx, DWORD PTR _flt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _flt$[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax
	movsx	ecx, ax
	shl	ecx, 8
	movsx	edx, WORD PTR _i$[ebp]
	add	ecx, edx
	push	ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1096]
	call	?SetState@C_Waypoint@@QAEXJF@Z		; C_Waypoint::SetState
$LN11@UpdateWayp:

; 1515 : 				}
; 1516 : 			i++;

	mov	cx, WORD PTR _i$[ebp]
	add	cx, 1
	mov	WORD PTR _i$[ebp], cx

; 1517 : 			wp=wp->GetNextWP();

	mov	ecx, DWORD PTR _wp$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _wp$[ebp], eax

; 1518 : 			}

	jmp	$LN14@UpdateWayp
$LN13@UpdateWayp:

; 1519 : 
; 1520 : 		if(!(TheCampaign.Flags & CAMP_TACTICAL_EDIT))

	mov	edx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A+64
	and	edx, 524288				; 00080000H
	jne	$LN8@UpdateWayp

; 1521 : 		{
; 1522 : 			if(i > 1)

	movsx	eax, WORD PTR _i$[ebp]
	cmp	eax, 1
	jle	$LN8@UpdateWayp

; 1523 : 			{
; 1524 : 				nub=CurWP_->GetRoot();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1092]
	call	?GetRoot@C_Waypoint@@QAEPAVWAYPOINTLIST@@XZ ; C_Waypoint::GetRoot
	mov	DWORD PTR _nub$[ebp], eax
$LN6@UpdateWayp:

; 1525 : 				while(nub)

	cmp	DWORD PTR _nub$[ebp], 0
	je	SHORT $LN5@UpdateWayp

; 1526 : 				{
; 1527 : 					if(nub->ID & 0x40000000)

	mov	edx, DWORD PTR _nub$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, 1073741824				; 40000000H
	je	SHORT $LN4@UpdateWayp

; 1528 : 					{
; 1529 : 						nub->Icon->SetText(0,TXT_SPACE);

	push	153					; 00000099H
	push	0
	mov	ecx, DWORD PTR _nub$[ebp]
	mov	ecx, DWORD PTR [ecx+32]
	call	?SetText@C_Button@@QAEXFJ@Z		; C_Button::SetText

; 1530 : 						nub->Icon->SetText(1,TXT_SPACE);

	push	153					; 00000099H
	push	1
	mov	edx, DWORD PTR _nub$[ebp]
	mov	ecx, DWORD PTR [edx+32]
	call	?SetText@C_Button@@QAEXFJ@Z		; C_Button::SetText

; 1531 : 						nub->Icon->SetText(2,TXT_SPACE);

	push	153					; 00000099H
	push	2
	mov	eax, DWORD PTR _nub$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	call	?SetText@C_Button@@QAEXFJ@Z		; C_Button::SetText

; 1532 : 						nub->Icon->SetFlagBitOff(C_BIT_ENABLED);

	push	2048					; 00000800H
	mov	ecx, DWORD PTR _nub$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _nub$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+32]
	mov	eax, DWORD PTR [edx+12]
	call	eax
$LN4@UpdateWayp:

; 1533 : 					}
; 1534 : 					nub=nub->Next;

	mov	ecx, DWORD PTR _nub$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	DWORD PTR _nub$[ebp], edx

; 1535 : 				}

	jmp	SHORT $LN6@UpdateWayp
$LN5@UpdateWayp:

; 1536 : 				CurWP_->SetFlagBitOff(C_BIT_DRAGABLE);

	push	4096					; 00001000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1092]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+1092]
	mov	edx, DWORD PTR [eax+12]
	call	edx

; 1537 : 				CurWPZ_->SetFlagBitOff(C_BIT_DRAGABLE);

	push	4096					; 00001000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1096]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+1096]
	mov	edx, DWORD PTR [eax+12]
	call	edx
$LN8@UpdateWayp:

; 1538 : 			}
; 1539 : 		}
; 1540 : 		CurWP_->Refresh();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1092]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+1092]
	mov	edx, DWORD PTR [eax+160]
	call	edx

; 1541 : 		CurWPZ_->Refresh();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1096]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+1096]
	mov	edx, DWORD PTR [eax+160]
	call	edx

; 1542 : 	}
; 1543 : 	else

	jmp	$LN18@UpdateWayp
$LN17@UpdateWayp:

; 1544 : 	{
; 1545 : 		i=1;

	mov	eax, 1
	mov	WORD PTR _i$[ebp], ax

; 1546 : 		wp=flt->GetFirstUnitWP();

	mov	ecx, DWORD PTR _flt$[ebp]
	call	?GetFirstUnitWP@UnitClass@@QAEPAVWayPointClass@@XZ ; UnitClass::GetFirstUnitWP
	mov	DWORD PTR _wp$[ebp], eax
$LN2@UpdateWayp:

; 1547 : 		while(wp && wp != flt->GetCurrentUnitWP())

	cmp	DWORD PTR _wp$[ebp], 0
	je	SHORT $LN1@UpdateWayp
	mov	ecx, DWORD PTR _flt$[ebp]
	call	?GetCurrentUnitWP@UnitClass@@QBEPAVWayPointClass@@XZ ; UnitClass::GetCurrentUnitWP
	cmp	DWORD PTR _wp$[ebp], eax
	je	SHORT $LN1@UpdateWayp

; 1548 : 		{
; 1549 : 			i++;

	mov	cx, WORD PTR _i$[ebp]
	add	cx, 1
	mov	WORD PTR _i$[ebp], cx

; 1550 : 			wp=wp->GetNextWP();

	mov	ecx, DWORD PTR _wp$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _wp$[ebp], eax

; 1551 : 		}

	jmp	SHORT $LN2@UpdateWayp
$LN1@UpdateWayp:

; 1552 : 
; 1553 : 		Team_[flt->GetTeam()].Waypoints->SetGroupState(flt->GetCampID() << 8,0);

	push	0
	mov	edx, DWORD PTR _flt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _flt$[ebp]
	mov	edx, DWORD PTR [eax+112]
	call	edx
	cwde
	shl	eax, 8
	push	eax
	mov	ecx, DWORD PTR _flt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _flt$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+880]
	call	?SetGroupState@C_Waypoint@@QAEXJF@Z	; C_Waypoint::SetGroupState

; 1554 : 		Team_[flt->GetTeam()].Waypoints->SetState((flt->GetCampID() << 8)+i,1);

	push	1
	mov	eax, DWORD PTR _flt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _flt$[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax
	movsx	ecx, ax
	shl	ecx, 8
	movsx	edx, WORD PTR _i$[ebp]
	add	ecx, edx
	push	ecx
	mov	eax, DWORD PTR _flt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _flt$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+880]
	call	?SetState@C_Waypoint@@QAEXJF@Z		; C_Waypoint::SetState

; 1555 : 		Team_[flt->GetTeam()].Waypoints->SetState(0x40000000|(flt->GetCampID() << 8)+i,1);

	push	1
	mov	eax, DWORD PTR _flt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _flt$[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax
	movsx	ecx, ax
	shl	ecx, 8
	movsx	edx, WORD PTR _i$[ebp]
	add	ecx, edx
	or	ecx, 1073741824				; 40000000H
	push	ecx
	mov	eax, DWORD PTR _flt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _flt$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+880]
	call	?SetState@C_Waypoint@@QAEXJF@Z		; C_Waypoint::SetState

; 1556 : 		Team_[flt->GetTeam()].Waypoints->Refresh();

	mov	eax, DWORD PTR _flt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _flt$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+880]
	mov	DWORD PTR tv494[ebp], eax
	mov	ecx, DWORD PTR tv494[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv494[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN18@UpdateWayp:

; 1557 : 	}
; 1558 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?UpdateWaypoint@C_Map@@QAEXPAVFlightClass@@@Z ENDP	; C_Map::UpdateWaypoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
$T1 = -60						; size = 8
tv205 = -52						; size = 4
_this$ = -48						; size = 4
_TypeID$ = -44						; size = 4
_ent$ = -40						; size = 4
_Buffer$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_vc$ = 8						; size = 4
?AddVC@C_Map@@QAEPAVMAPICONLIST@@PAVvictory_condition@@@Z PROC ; C_Map::AddVC
; _this$ = ecx

; 826  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 827  : 	long TypeID;
; 828  : 	_TCHAR Buffer[32];
; 829  : 	CampEntity ent;
; 830  : 
; 831  : 	ent=(CampEntity)vuDatabase->Find(vc->get_vu_id());

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_vu_id@victory_condition@@QAE?AVVU_ID@@XZ ; victory_condition::get_vu_id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _ent$[ebp], eax

; 832  : 	if(ent)

	cmp	DWORD PTR _ent$[ebp], 0
	je	SHORT $LN4@AddVC

; 833  : 	{
; 834  : 		if(!ent->IsUnit() && !ent->IsObjective())

	mov	eax, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+232]
	call	eax
	test	eax, eax
	jne	SHORT $LN3@AddVC
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+236]
	call	eax
	test	eax, eax
	jne	SHORT $LN3@AddVC

; 835  : 			return(NULL);

	xor	eax, eax
	jmp	$LN5@AddVC
$LN3@AddVC:

; 836  : 	}
; 837  : 	else

	jmp	SHORT $LN2@AddVC
$LN4@AddVC:

; 838  : 		return(NULL);

	xor	eax, eax
	jmp	$LN5@AddVC
$LN2@AddVC:

; 839  : 
; 840  : 	TypeID=FindTypeIndex(_VC_CONDITION_,OBJ_TypeList,_MAP_NUM_OBJ_TYPES_);

	push	14					; 0000000eH
	push	OFFSET ?OBJ_TypeList@@3PAJA		; OBJ_TypeList
	push	8192					; 00002000H
	call	?FindTypeIndex@@YAJJQAJH@Z		; FindTypeIndex
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _TypeID$[ebp], eax

; 841  : 	if(TypeID != -1)

	cmp	DWORD PTR _TypeID$[ebp], -1
	je	$LN1@AddVC

; 842  : 	{
; 843  : 		_stprintf(Buffer,"%s %1ld",gStringMgr->GetString(TXT_VC),vc->get_number());

	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_number@victory_condition@@QAEHXZ	; victory_condition::get_number
	push	eax
	push	201					; 000000c9H
	mov	ecx, DWORD PTR ?gStringMgr@@3PAVC_String@@A ; gStringMgr
	call	?GetString@C_String@@QAEPADJ@Z		; C_String::GetString
	push	eax
	push	OFFSET ??_C@_07PAINCAHD@?$CFs?5?$CF1ld?$AA@
	lea	ecx, DWORD PTR _Buffer$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 844  : 		return(Team_[vc->get_team()].Objectives->Type[TypeID]->AddIconToList(
; 845  : 			vc->get_number(),
; 846  : 			_VC_CONDITION_,
; 847  : 			10119,
; 848  : 			ent->YPos(),
; 849  : 			maxy - ent->XPos(),
; 850  : 			FALSE,
; 851  : 			Buffer,0,0,0,0,0,NULL)
; 852  : 		);

	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	lea	edx, DWORD PTR _Buffer$[ebp]
	push	edx
	push	0
	mov	ecx, DWORD PTR _ent$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv205[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+732]
	subss	xmm0, DWORD PTR tv205[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _ent$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	push	10119					; 00002787H
	push	8192					; 00002000H
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_number@victory_condition@@QAEHXZ	; victory_condition::get_number
	push	eax
	mov	ecx, DWORD PTR _vc$[ebp]
	call	?get_team@victory_condition@@QAEHXZ	; victory_condition::get_team
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+876]
	mov	eax, DWORD PTR _TypeID$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+56]
	call	?AddIconToList@C_MapIcon@@QAEPAVMAPICONLIST@@JFJMMFPADJJJJJPAUDETECTOR@@@Z ; C_MapIcon::AddIconToList
	jmp	SHORT $LN5@AddVC
$LN1@AddVC:

; 853  : 	}
; 854  : 	return(NULL);

	xor	eax, eax
$LN5@AddVC:

; 855  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?AddVC@C_Map@@QAEPAVMAPICONLIST@@PAVvictory_condition@@@Z ENDP ; C_Map::AddVC
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
tv194 = -52						; size = 4
_this$ = -48						; size = 4
_TypeID$ = -44						; size = 4
_UnitType$ = -40					; size = 4
_Buffer$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_package$ = 8						; size = 4
?AddPackage@C_Map@@QAEPAVMAPICONLIST@@PAVPackageClass@@@Z PROC ; C_Map::AddPackage
; _this$ = ecx

; 801  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 802  : 	long UnitType,TypeID;
; 803  : 	_TCHAR Buffer[32];
; 804  : 
; 805  : 	UnitType=GetObjectiveType(package);

	mov	eax, DWORD PTR _package$[ebp]
	push	eax
	call	?GetObjectiveType@@YAJPAVCampBaseClass@@@Z ; GetObjectiveType
	add	esp, 4
	mov	DWORD PTR _UnitType$[ebp], eax

; 806  : 	TypeID=FindTypeIndex(UnitType,OBJ_TypeList,_MAP_NUM_OBJ_TYPES_);

	push	14					; 0000000eH
	push	OFFSET ?OBJ_TypeList@@3PAJA		; OBJ_TypeList
	mov	ecx, DWORD PTR _UnitType$[ebp]
	push	ecx
	call	?FindTypeIndex@@YAJJQAJH@Z		; FindTypeIndex
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _TypeID$[ebp], eax

; 807  : 	if(TypeID != -1)

	cmp	DWORD PTR _TypeID$[ebp], -1
	je	$LN1@AddPackage

; 808  : 	{
; 809  : 		if(UnitType)

	cmp	DWORD PTR _UnitType$[ebp], 0
	je	$LN1@AddPackage

; 810  : 		{
; 811  : 			_stprintf(Buffer,"%s %1ld",gStringMgr->GetString(TXT_PACKAGE),package->GetCampID());

	mov	edx, DWORD PTR _package$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _package$[ebp]
	mov	edx, DWORD PTR [eax+112]
	call	edx
	cwde
	push	eax
	push	91					; 0000005bH
	mov	ecx, DWORD PTR ?gStringMgr@@3PAVC_String@@A ; gStringMgr
	call	?GetString@C_String@@QAEPADJ@Z		; C_String::GetString
	push	eax
	push	OFFSET ??_C@_07PAINCAHD@?$CFs?5?$CF1ld?$AA@
	lea	ecx, DWORD PTR _Buffer$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 812  : 			return(Team_[package->GetTeam()].Objectives->Type[TypeID]->AddIconToList(
; 813  : 				package->GetCampID(),
; 814  : 				static_cast<short>(UnitType),
; 815  : 				10118,
; 816  : 				package->YPos(),
; 817  : 				maxy - package->XPos(),
; 818  : 				FALSE,Buffer,0,0,0,0,0,NULL)
; 819  : 			);

	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	lea	edx, DWORD PTR _Buffer$[ebp]
	push	edx
	push	0
	mov	ecx, DWORD PTR _package$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv194[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+732]
	subss	xmm0, DWORD PTR tv194[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _package$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	push	10118					; 00002786H
	movzx	ecx, WORD PTR _UnitType$[ebp]
	push	ecx
	mov	edx, DWORD PTR _package$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _package$[ebp]
	mov	edx, DWORD PTR [eax+112]
	call	edx
	cwde
	push	eax
	mov	ecx, DWORD PTR _package$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _package$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+876]
	mov	ecx, DWORD PTR _TypeID$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4+56]
	call	?AddIconToList@C_MapIcon@@QAEPAVMAPICONLIST@@JFJMMFPADJJJJJPAUDETECTOR@@@Z ; C_MapIcon::AddIconToList
	jmp	SHORT $LN3@AddPackage
$LN1@AddPackage:

; 820  : 		}
; 821  : 	}
; 822  : 	return(NULL);

	xor	eax, eax
$LN3@AddPackage:

; 823  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?AddPackage@C_Map@@QAEPAVMAPICONLIST@@PAVPackageClass@@@Z ENDP ; C_Map::AddPackage
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_UnitPtr$ = -64						; size = 4
tv194 = -60						; size = 4
_this$ = -56						; size = 4
_TypeID$ = -52						; size = 4
_UnitType$ = -48					; size = 4
_Buffer$ = -44						; size = 40
__$ArrayPad$ = -4					; size = 4
_squadron$ = 8						; size = 4
?AddSquadron@C_Map@@QAEPAVMAPICONLIST@@PAVSquadronClass@@@Z PROC ; C_Map::AddSquadron
; _this$ = ecx

; 774  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 775  : 	long UnitType,TypeID;
; 776  : 	UnitClassDataType *UnitPtr;
; 777  : 	_TCHAR Buffer[40];
; 778  : 
; 779  : 	UnitType=GetObjectiveType(squadron);

	mov	eax, DWORD PTR _squadron$[ebp]
	push	eax
	call	?GetObjectiveType@@YAJPAVCampBaseClass@@@Z ; GetObjectiveType
	add	esp, 4
	mov	DWORD PTR _UnitType$[ebp], eax

; 780  : 	TypeID=FindTypeIndex(UnitType,OBJ_TypeList,_MAP_NUM_OBJ_TYPES_);

	push	14					; 0000000eH
	push	OFFSET ?OBJ_TypeList@@3PAJA		; OBJ_TypeList
	mov	ecx, DWORD PTR _UnitType$[ebp]
	push	ecx
	call	?FindTypeIndex@@YAJJQAJH@Z		; FindTypeIndex
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _TypeID$[ebp], eax

; 781  : 	if(TypeID != -1){

	cmp	DWORD PTR _TypeID$[ebp], -1
	je	$LN1@AddSquadro

; 782  : 		if(UnitType){

	cmp	DWORD PTR _UnitType$[ebp], 0
	je	$LN1@AddSquadro

; 783  : 			UnitPtr=squadron->GetUnitClassData();

	mov	ecx, DWORD PTR _squadron$[ebp]
	call	?GetUnitClassData@UnitClass@@QAEPAUUnitClassDataType@@XZ ; UnitClass::GetUnitClassData
	mov	DWORD PTR _UnitPtr$[ebp], eax

; 784  : 			if(UnitPtr){

	cmp	DWORD PTR _UnitPtr$[ebp], 0
	je	$LN1@AddSquadro

; 785  : 				squadron->GetName(Buffer,39,FALSE);

	push	0
	push	39					; 00000027H
	lea	edx, DWORD PTR _Buffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _squadron$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _squadron$[ebp]
	mov	eax, DWORD PTR [edx+380]
	call	eax

; 786  : 				return(Team_[squadron->GetTeam()].Objectives->Type[TypeID]->AddIconToList(
; 787  : 					squadron->GetCampID(),
; 788  : 					static_cast<short>(UnitType),
; 789  : 					10117,
; 790  : 					squadron->YPos(),
; 791  : 					maxy - squadron->XPos(),
; 792  : 					FALSE,Buffer,0,0,0,0,0,NULL)
; 793  : 				);

	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	lea	ecx, DWORD PTR _Buffer$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _squadron$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv194[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+732]
	subss	xmm0, DWORD PTR tv194[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _squadron$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	push	10117					; 00002785H
	movzx	eax, WORD PTR _UnitType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _squadron$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _squadron$[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax
	movsx	ecx, ax
	push	ecx
	mov	edx, DWORD PTR _squadron$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _squadron$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	movzx	eax, al
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+876]
	mov	eax, DWORD PTR _TypeID$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+56]
	call	?AddIconToList@C_MapIcon@@QAEPAVMAPICONLIST@@JFJMMFPADJJJJJPAUDETECTOR@@@Z ; C_MapIcon::AddIconToList
	jmp	SHORT $LN4@AddSquadro
$LN1@AddSquadro:

; 794  : 			}
; 795  : 		}
; 796  : 	}
; 797  : 	return(NULL);

	xor	eax, eax
$LN4@AddSquadro:

; 798  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?AddSquadron@C_Map@@QAEPAVMAPICONLIST@@PAVSquadronClass@@@Z ENDP ; C_Map::AddSquadron
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
tv238 = -76						; size = 4
_vid$1 = -72						; size = 4
_vc$2 = -68						; size = 4
tv149 = -64						; size = 4
_idx$ = -60						; size = 4
_TypeID$ = -56						; size = 4
_this$ = -52						; size = 4
_UnitPtr$ = -48						; size = 4
_Buffer$ = -44						; size = 40
__$ArrayPad$ = -4					; size = 4
_flight$ = 8						; size = 4
?AddFlight@C_Map@@QAEPAVMAPICONLIST@@PAVFlightClass@@@Z PROC ; C_Map::AddFlight
; _this$ = ecx

; 735  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 736  : 	long idx;
; 737  : 	long TypeID;
; 738  : 	UnitClassDataType *UnitPtr;
; 739  : 	_TCHAR Buffer[40];
; 740  : 
; 741  : 	UnitPtr=flight->GetUnitClassData();

	mov	ecx, DWORD PTR _flight$[ebp]
	call	?GetUnitClassData@UnitClass@@QAEPAUUnitClassDataType@@XZ ; UnitClass::GetUnitClassData
	mov	DWORD PTR _UnitPtr$[ebp], eax

; 742  : 	if(UnitPtr){

	cmp	DWORD PTR _UnitPtr$[ebp], 0
	je	$LN3@AddFlight

; 743  : 		idx=GetAirIcon(flight->GetSType());

	mov	ecx, DWORD PTR _flight$[ebp]
	call	?GetSType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetSType
	movzx	eax, al
	push	eax
	call	?GetAirIcon@@YAJE@Z			; GetAirIcon
	add	esp, 4
	mov	DWORD PTR _idx$[ebp], eax

; 744  : 		TypeID=FindTypeIndex(AirIcons[idx].UIType,AIR_TypeList,_MAP_NUM_AIR_TYPES_);

	push	5
	push	OFFSET ?AIR_TypeList@@3PAJA		; AIR_TypeList
	mov	ecx, DWORD PTR _idx$[ebp]
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR ?AirIcons@@3PAUAIR_ICONS@@A[ecx+16]
	push	edx
	call	?FindTypeIndex@@YAJJQAJH@Z		; FindTypeIndex
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _TypeID$[ebp], eax

; 745  : 
; 746  : 		if(TypeID != -1){

	cmp	DWORD PTR _TypeID$[ebp], -1
	je	$LN3@AddFlight

; 747  : 			if(UnitPtr->IconIndex){

	mov	eax, DWORD PTR _UnitPtr$[ebp]
	movsx	ecx, WORD PTR [eax+332]
	test	ecx, ecx
	je	$LN3@AddFlight

; 748  : 				if (gGps->GetTeamNo() == flight->GetTeam()){

	mov	ecx, DWORD PTR ?gGps@@3PAVGlobalPositioningSystem@@A ; gGps
	call	?GetTeamNo@GlobalPositioningSystem@@QAEJXZ ; GlobalPositioningSystem::GetTeamNo
	mov	esi, eax
	mov	edx, DWORD PTR _flight$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _flight$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	movzx	eax, al
	cmp	esi, eax
	jne	SHORT $LN2@AddFlight

; 749  : 					GetCallsign(flight,Buffer);

	lea	ecx, DWORD PTR _Buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _flight$[ebp]
	push	edx
	call	?GetCallsign@@YAXPAVFlightClass@@PAD@Z	; GetCallsign
	add	esp, 8

; 750  : 				}
; 751  : 			    else {

	jmp	SHORT $LN1@AddFlight
$LN2@AddFlight:

; 752  : 					int vid = flight->GetVehicleID(0);

	push	0
	mov	ecx, DWORD PTR _flight$[ebp]
	call	?GetVehicleID@UnitClass@@QAEFH@Z	; UnitClass::GetVehicleID
	cwde
	mov	DWORD PTR _vid$1[ebp], eax

; 753  : 					VehicleClassDataType *vc = GetVehicleClassData(vid);

	mov	ecx, DWORD PTR _vid$1[ebp]
	push	ecx
	call	?GetVehicleClassData@@YAPAUVehicleClassDataType@@H@Z ; GetVehicleClassData
	add	esp, 4
	mov	DWORD PTR _vc$2[ebp], eax

; 754  : 					strcpy(Buffer, vc ? vc->Name : "<unk>");

	cmp	DWORD PTR _vc$2[ebp], 0
	je	SHORT $LN8@AddFlight
	mov	edx, DWORD PTR _vc$2[ebp]
	add	edx, 8
	mov	DWORD PTR tv149[ebp], edx
	jmp	SHORT $LN9@AddFlight
$LN8@AddFlight:
	mov	DWORD PTR tv149[ebp], OFFSET ??_C@_05NCAJEJLJ@?$DMunk?$DO?$AA@
$LN9@AddFlight:
	mov	eax, DWORD PTR tv149[ebp]
	push	eax
	lea	ecx, DWORD PTR _Buffer$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8
$LN1@AddFlight:

; 755  : 			    }
; 756  : 			    return (Team_[flight->GetTeam()].AirUnits->Type[TypeID]->AddIconToList(
; 757  : 					flight->GetCampID(),
; 758  : 					static_cast<short>(AirIcons[idx].UIType),
; 759  : 					UnitPtr->IconIndex,
; 760  : 					flight->YPos(),
; 761  : 					maxy - flight->XPos(),
; 762  : 					static_cast<short>(gMoveBattalion),
; 763  : 					Buffer,
; 764  : 					0,
; 765  : 					((Flight)flight)->GetLastDirection()&0x7
; 766  : 				));

	mov	ecx, DWORD PTR _flight$[ebp]
	call	?GetLastDirection@FlightClass@@QAEEXZ	; FlightClass::GetLastDirection
	movzx	edx, al
	and	edx, 7
	push	edx
	push	0
	lea	eax, DWORD PTR _Buffer$[ebp]
	push	eax
	movzx	ecx, WORD PTR ?gMoveBattalion@@3HA
	push	ecx
	mov	ecx, DWORD PTR _flight$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv238[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+732]
	subss	xmm0, DWORD PTR tv238[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _flight$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _UnitPtr$[ebp]
	movsx	ecx, WORD PTR [eax+332]
	push	ecx
	mov	edx, DWORD PTR _idx$[ebp]
	imul	edx, 20					; 00000014H
	movzx	eax, WORD PTR ?AirIcons@@3PAUAIR_ICONS@@A[edx+16]
	push	eax
	mov	ecx, DWORD PTR _flight$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _flight$[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax
	movsx	ecx, ax
	push	ecx
	mov	edx, DWORD PTR _flight$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _flight$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	movzx	eax, al
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+864]
	mov	eax, DWORD PTR _TypeID$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+20]
	call	?AddIconToList@C_MapIcon@@QAEPAVMAPICONLIST@@JFJMMFPADJJ@Z ; C_MapIcon::AddIconToList
	jmp	SHORT $LN6@AddFlight
$LN3@AddFlight:

; 767  : 			}
; 768  : 		}
; 769  : 	}
; 770  : 	return(NULL);

	xor	eax, eax
$LN6@AddFlight:

; 771  : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?AddFlight@C_Map@@QAEPAVMAPICONLIST@@PAVFlightClass@@@Z ENDP ; C_Map::AddFlight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
$T1 = -152						; size = 4
$T2 = -148						; size = 4
tv575 = -144						; size = 4
_curstr$ = -140						; size = 4
tv540 = -136						; size = 4
$T3 = -132						; size = 4
_radar_long$ = -128					; size = 4
_sam_long$ = -124					; size = 4
_upar$ = -120						; size = 4
_sam_short$ = -116					; size = 4
_radar_short$ = -112					; size = 4
_numarcs$ = -108					; size = 4
_totalstr$ = -104					; size = 4
_batid$ = -100						; size = 4
_UnitPtr$ = -96						; size = 4
_brigid$ = -92						; size = 4
_perc$ = -88						; size = 4
_this$ = -84						; size = 4
_TypeID$ = -80						; size = 4
_LevelID$ = -76						; size = 4
_UnitType$ = -72					; size = 4
_detect$ = -68						; size = 4
_Buffer$ = -64						; size = 60
__$ArrayPad$ = -4					; size = 4
_u$ = 8							; size = 4
?AddUnit@C_Map@@QAEPAVMAPICONLIST@@PAVUnitClass@@@Z PROC ; C_Map::AddUnit
; _this$ = ecx

; 597  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 152				; 00000098H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 598  : 	long UnitType,TypeID,LevelID = -1,brigid,batid,numarcs;//! 

	mov	DWORD PTR _LevelID$[ebp], -1

; 599  : 	Unit upar;
; 600  : 	UnitClassDataType *UnitPtr;
; 601  : 	float totalstr,curstr,perc;
; 602  : 	DETECTOR *detect;
; 603  : 	float sam_short;
; 604  : 	float sam_long;
; 605  : 	float radar_short;
; 606  : 	float radar_long;
; 607  : 	_TCHAR Buffer[60];
; 608  : 
; 609  : 	UnitType=FindUnitType(u);

	mov	eax, DWORD PTR _u$[ebp]
	push	eax
	call	?FindUnitType@@YAJPAVUnitClass@@@Z	; FindUnitType
	add	esp, 4
	mov	DWORD PTR _UnitType$[ebp], eax

; 610  : 	TypeID=-1;

	mov	DWORD PTR _TypeID$[ebp], -1

; 611  : 
; 612  : 	// Figure out Status
; 613  : 	curstr=(float)u->GetTotalVehicles();

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetTotalVehicles@UnitClass@@QAEHXZ	; UnitClass::GetTotalVehicles
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _curstr$[ebp], xmm0

; 614  : 	totalstr=(float)u->GetFullstrengthVehicles();

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetFullstrengthVehicles@UnitClass@@QAEHXZ ; UnitClass::GetFullstrengthVehicles
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _totalstr$[ebp], xmm0

; 615  : 	if(totalstr < 1) totalstr=1;

	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _totalstr$[ebp]
	jbe	SHORT $LN23@AddUnit
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _totalstr$[ebp], xmm0
$LN23@AddUnit:

; 616  : 	perc=(curstr/totalstr) * 100.0f;

	movss	xmm0, DWORD PTR _curstr$[ebp]
	divss	xmm0, DWORD PTR _totalstr$[ebp]
	mulss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR _perc$[ebp], xmm0

; 617  : 	if(perc > 100.0f) perc=100.0f;

	movss	xmm0, DWORD PTR _perc$[ebp]
	comiss	xmm0, DWORD PTR __real@42c80000
	jbe	SHORT $LN22@AddUnit
	movss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR _perc$[ebp], xmm0
$LN22@AddUnit:

; 618  : 
; 619  : 	if(UnitType & _UNIT_GROUND_MASK)

	mov	ecx, DWORD PTR _UnitType$[ebp]
	and	ecx, 117440512				; 07000000H
	je	SHORT $LN21@AddUnit

; 620  : 	{
; 621  : 		TypeID=FindTypeIndex(UnitType & 0x0fff,GND_TypeList,_MAP_NUM_GND_TYPES_);

	push	4
	push	OFFSET ?GND_TypeList@@3PAJA		; GND_TypeList
	mov	edx, DWORD PTR _UnitType$[ebp]
	and	edx, 4095				; 00000fffH
	push	edx
	call	?FindTypeIndex@@YAJJQAJH@Z		; FindTypeIndex
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _TypeID$[ebp], eax

; 622  : 		if(TypeID != -1)

	cmp	DWORD PTR _TypeID$[ebp], -1
	je	SHORT $LN20@AddUnit

; 623  : 			LevelID=FindTypeIndex(UnitType & _UNIT_GROUND_MASK,GND_LevelList,_MAP_NUM_GND_LEVELS_);

	push	3
	push	OFFSET ?GND_LevelList@@3PAJA		; GND_LevelList
	mov	eax, DWORD PTR _UnitType$[ebp]
	and	eax, 117440512				; 07000000H
	push	eax
	call	?FindTypeIndex@@YAJJQAJH@Z		; FindTypeIndex
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _LevelID$[ebp], eax

; 624  : 		else

	jmp	SHORT $LN19@AddUnit
$LN20@AddUnit:

; 625  : 			LevelID = -1;

	mov	DWORD PTR _LevelID$[ebp], -1
$LN19@AddUnit:
	jmp	SHORT $LN17@AddUnit
$LN21@AddUnit:

; 626  : 	}
; 627  : 	else if(UnitType & _UNIT_NAVAL_MASK)

	mov	ecx, DWORD PTR _UnitType$[ebp]
	and	ecx, 134217728				; 08000000H
	je	SHORT $LN17@AddUnit

; 628  : 	{
; 629  : 		TypeID=FindTypeIndex(UnitType & 0x0fff,NAV_TypeList,_MAP_NUM_NAV_TYPES_);

	push	2
	push	OFFSET ?NAV_TypeList@@3PAJA		; NAV_TypeList
	mov	edx, DWORD PTR _UnitType$[ebp]
	and	edx, 4095				; 00000fffH
	push	edx
	call	?FindTypeIndex@@YAJJQAJH@Z		; FindTypeIndex
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _TypeID$[ebp], eax

; 630  : 		LevelID=1;

	mov	DWORD PTR _LevelID$[ebp], 1
$LN17@AddUnit:

; 631  : 	}
; 632  : 	if(TypeID != -1 && LevelID != -1)

	cmp	DWORD PTR _TypeID$[ebp], -1
	je	$LN1@AddUnit
	cmp	DWORD PTR _LevelID$[ebp], -1
	je	$LN1@AddUnit

; 633  : 	{
; 634  : 		UnitPtr=u->GetUnitClassData();

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetUnitClassData@UnitClass@@QAEPAUUnitClassDataType@@XZ ; UnitClass::GetUnitClassData
	mov	DWORD PTR _UnitPtr$[ebp], eax

; 635  : 		if(UnitPtr)

	cmp	DWORD PTR _UnitPtr$[ebp], 0
	je	$LN1@AddUnit

; 636  : 		{
; 637  : 			if(UnitType & _UNIT_GROUND_MASK)

	mov	eax, DWORD PTR _UnitType$[ebp]
	and	eax, 117440512				; 07000000H
	je	$LN14@AddUnit

; 638  : 			{
; 639  : 				if(LevelID == 1)

	cmp	DWORD PTR _LevelID$[ebp], 1
	jne	SHORT $LN13@AddUnit

; 640  : 				{
; 641  : 					brigid=u->GetUnitNameID();

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetUnitNameID@UnitClass@@QAEHXZ	; UnitClass::GetUnitNameID
	mov	DWORD PTR _brigid$[ebp], eax

; 642  : 					batid=0;

	mov	DWORD PTR _batid$[ebp], 0
	jmp	SHORT $LN8@AddUnit
$LN13@AddUnit:

; 643  : 				}
; 644  : 				else if(LevelID == 2)

	cmp	DWORD PTR _LevelID$[ebp], 2
	jne	SHORT $LN11@AddUnit

; 645  : 				{
; 646  : 					upar=u->GetUnitParent();

	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+944]
	call	eax
	mov	DWORD PTR _upar$[ebp], eax

; 647  : 					if(upar)

	cmp	DWORD PTR _upar$[ebp], 0
	je	SHORT $LN10@AddUnit

; 648  : 						brigid=upar->GetUnitNameID();

	mov	ecx, DWORD PTR _upar$[ebp]
	call	?GetUnitNameID@UnitClass@@QAEHXZ	; UnitClass::GetUnitNameID
	mov	DWORD PTR _brigid$[ebp], eax

; 649  : 					else

	jmp	SHORT $LN9@AddUnit
$LN10@AddUnit:

; 650  : 						brigid=0;

	mov	DWORD PTR _brigid$[ebp], 0
$LN9@AddUnit:

; 651  : 					batid=u->GetUnitNameID();

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetUnitNameID@UnitClass@@QAEHXZ	; UnitClass::GetUnitNameID
	mov	DWORD PTR _batid$[ebp], eax

; 652  : 				}
; 653  : 				else

	jmp	SHORT $LN8@AddUnit
$LN11@AddUnit:

; 654  : 				{
; 655  : 					brigid=0;

	mov	DWORD PTR _brigid$[ebp], 0

; 656  : 					batid=0;

	mov	DWORD PTR _batid$[ebp], 0
$LN8@AddUnit:

; 657  : 				}
; 658  : 				detect=NULL;

	mov	DWORD PTR _detect$[ebp], 0

; 659  : 				if(u->IsBattalion())

	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+240]
	call	eax
	test	eax, eax
	je	$LN3@AddUnit

; 660  : 				{
; 661  : 					radar_short=static_cast<float>(u->GetElectronicDetectionRange(LowAir));

	push	4
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+420]
	call	eax
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _radar_short$[ebp], xmm0

; 662  : 					radar_long=static_cast<float>(u->GetElectronicDetectionRange(Air));

	push	5
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+420]
	call	eax
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _radar_long$[ebp], xmm0

; 663  : 					sam_short=static_cast<float>(u->GetAproxWeaponRange(LowAir));

	push	4
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+412]
	call	eax
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _sam_short$[ebp], xmm0

; 664  : 					sam_long=static_cast<float>(u->GetAproxWeaponRange(Air));

	push	5
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+412]
	call	eax
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _sam_long$[ebp], xmm0

; 665  : 					if(radar_short || radar_long || sam_short || sam_long)

	movss	xmm0, DWORD PTR _radar_short$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@AddUnit
	movss	xmm0, DWORD PTR _radar_long$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@AddUnit
	movss	xmm0, DWORD PTR _sam_short$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@AddUnit
	movss	xmm0, DWORD PTR _sam_long$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN3@AddUnit
$LN5@AddUnit:

; 666  : 					{
; 667  : 						#ifdef USE_SH_POOLS
; 668  : 						detect = (DETECTOR *)MemAllocPtr(UI_Pools[UI_GENERAL_POOL],sizeof(DETECTOR),FALSE);
; 669  : 						#else
; 670  : 						detect=new DETECTOR;

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR _detect$[ebp], ecx

; 671  : 						#endif
; 672  : 						detect->HighSam=sam_long * KM_TO_FT;

	movss	xmm0, DWORD PTR _sam_long$[ebp]
	mulss	xmm0, DWORD PTR __real@454cffae
	mov	edx, DWORD PTR _detect$[ebp]
	movss	DWORD PTR [edx+8], xmm0

; 673  : 						detect->HighRadar=radar_long * KM_TO_FT;

	movss	xmm0, DWORD PTR _radar_long$[ebp]
	mulss	xmm0, DWORD PTR __real@454cffae
	mov	eax, DWORD PTR _detect$[ebp]
	movss	DWORD PTR [eax+12], xmm0

; 674  : 						detect->LowSam=sam_short * KM_TO_FT;

	movss	xmm0, DWORD PTR _sam_short$[ebp]
	mulss	xmm0, DWORD PTR __real@454cffae
	mov	ecx, DWORD PTR _detect$[ebp]
	movss	DWORD PTR [ecx+4], xmm0

; 675  : 
; 676  : 						if(radar_short)

	movss	xmm0, DWORD PTR _radar_short$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN4@AddUnit

; 677  : 						{
; 678  : 							numarcs=u->GetNumberOfArcs();

	mov	edx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax+432]
	call	edx
	mov	DWORD PTR _numarcs$[ebp], eax

; 679  : 							numarcs=1; // TEMP kludge

	mov	DWORD PTR _numarcs$[ebp], 1

; 680  : 
; 681  : 							#ifdef USE_SH_POOLS
; 682  : 							detect->LowRadar = (ARC_LIST *)MemAllocPtr(UI_Pools[UI_GENERAL_POOL],sizeof(ARC_LIST),FALSE);
; 683  : 							#else
; 684  : 							detect->LowRadar=new ARC_LIST;

	push	8
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	eax, DWORD PTR _detect$[ebp]
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR [eax], ecx

; 685  : 							#endif
; 686  : 							detect->LowRadar->numarcs=static_cast<short>(numarcs);

	mov	edx, DWORD PTR _detect$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	cx, WORD PTR _numarcs$[ebp]
	mov	WORD PTR [eax], cx

; 687  : 							#ifdef USE_SH_POOLS
; 688  : 							detect->LowRadar->arcs = (ARC_REC *)MemAllocPtr(UI_Pools[UI_GENERAL_POOL],sizeof(ARC_REC)*numarcs,FALSE);
; 689  : 							#else
; 690  : 							detect->LowRadar->arcs=new ARC_REC[numarcs];

	xor	ecx, ecx
	mov	eax, DWORD PTR _numarcs$[ebp]
	mov	edx, 8
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR _detect$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR [ecx+4], edx

; 691  : 							#endif
; 692  : 
; 693  : 							// after getting rid of kludges...
; 694  : 							// figure out how to do arcs right
; 695  : 							// kludge
; 696  : 							detect->LowRadar->arcs[0].arc=0;

	mov	eax, DWORD PTR _detect$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, 8
	imul	edx, 0
	mov	eax, DWORD PTR [ecx+4]
	xor	ecx, ecx
	mov	WORD PTR [eax+edx], cx

; 697  : 							detect->LowRadar->arcs[0].range=radar_short;

	mov	edx, DWORD PTR _detect$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, 8
	imul	ecx, 0
	mov	edx, DWORD PTR [eax+4]
	movss	xmm0, DWORD PTR _radar_short$[ebp]
	movss	DWORD PTR [edx+ecx+4], xmm0

; 698  : 						}
; 699  : 						else

	jmp	SHORT $LN3@AddUnit
$LN4@AddUnit:

; 700  : 							detect->LowRadar=NULL;

	mov	eax, DWORD PTR _detect$[ebp]
	mov	DWORD PTR [eax], 0
$LN3@AddUnit:

; 701  : 					}
; 702  : 				}
; 703  : 				u->GetName(Buffer,49,FALSE);

	push	0
	push	49					; 00000031H
	lea	ecx, DWORD PTR _Buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax+380]
	call	edx

; 704  : 				return(Team_[u->GetTeam()].Units->Type[TypeID]->Levels[LevelID]->AddIconToList(
; 705  : 					u->GetCampID(),
; 706  : 					static_cast<short>(UnitType),
; 707  : 					UnitPtr->IconIndex,
; 708  : 					u->YPos(),
; 709  : 					maxy - u->XPos(),
; 710  : 					static_cast<short>(gMoveBattalion),
; 711  : 					Buffer,
; 712  : 					u->GetUnitDivision(),
; 713  : 					brigid,batid,
; 714  : 					(long)perc,0,detect)
; 715  : 				);

	mov	eax, DWORD PTR _detect$[ebp]
	push	eax
	push	0
	cvttss2si ecx, DWORD PTR _perc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _batid$[ebp]
	push	edx
	mov	eax, DWORD PTR _brigid$[ebp]
	push	eax
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+904]
	call	eax
	push	eax
	lea	ecx, DWORD PTR _Buffer$[ebp]
	push	ecx
	movzx	edx, WORD PTR ?gMoveBattalion@@3HA
	push	edx
	mov	ecx, DWORD PTR _u$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv540[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+732]
	subss	xmm0, DWORD PTR tv540[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _u$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _UnitPtr$[ebp]
	movsx	edx, WORD PTR [ecx+332]
	push	edx
	movzx	eax, WORD PTR _UnitType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax
	movsx	ecx, ax
	push	ecx
	mov	edx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	movzx	eax, al
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+868]
	mov	eax, DWORD PTR _TypeID$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+16]
	mov	edx, DWORD PTR _LevelID$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4+12]
	call	?AddIconToList@C_MapIcon@@QAEPAVMAPICONLIST@@JFJMMFPADJJJJJPAUDETECTOR@@@Z ; C_MapIcon::AddIconToList
	jmp	$LN24@AddUnit
	jmp	$LN1@AddUnit
$LN14@AddUnit:

; 716  : 			}
; 717  : 			else if(UnitType & _UNIT_NAVAL_MASK)

	mov	eax, DWORD PTR _UnitType$[ebp]
	and	eax, 134217728				; 08000000H
	je	$LN1@AddUnit

; 718  : 			{
; 719  : 				u->GetName(Buffer,49,FALSE);

	push	0
	push	49					; 00000031H
	lea	ecx, DWORD PTR _Buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax+380]
	call	edx

; 720  : 				return(Team_[u->GetTeam()].NavalUnits->Type[TypeID]->AddIconToList(
; 721  : 					u->GetCampID(),
; 722  : 					static_cast<short>(UnitType),
; 723  : 					UnitPtr->IconIndex,
; 724  : 					u->YPos(),
; 725  : 					maxy - u->XPos(),
; 726  : 					static_cast<short>(gMoveBattalion),Buffer,(long)perc,0)
; 727  : 				);

	push	0
	cvttss2si eax, DWORD PTR _perc$[ebp]
	push	eax
	lea	ecx, DWORD PTR _Buffer$[ebp]
	push	ecx
	movzx	edx, WORD PTR ?gMoveBattalion@@3HA
	push	edx
	mov	ecx, DWORD PTR _u$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv575[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+732]
	subss	xmm0, DWORD PTR tv575[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _u$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _UnitPtr$[ebp]
	movsx	edx, WORD PTR [ecx+332]
	push	edx
	movzx	eax, WORD PTR _UnitType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax
	movsx	ecx, ax
	push	ecx
	mov	edx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	movzx	eax, al
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+872]
	mov	eax, DWORD PTR _TypeID$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+8]
	call	?AddIconToList@C_MapIcon@@QAEPAVMAPICONLIST@@JFJMMFPADJJ@Z ; C_MapIcon::AddIconToList
	jmp	SHORT $LN24@AddUnit
$LN1@AddUnit:

; 728  : 			}
; 729  : 		}
; 730  : 	}
; 731  : 	return(NULL);

	xor	eax, eax
$LN24@AddUnit:

; 732  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?AddUnit@C_Map@@QAEPAVMAPICONLIST@@PAVUnitClass@@@Z ENDP ; C_Map::AddUnit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_curstr$ = -88						; size = 4
_cur$ = -84						; size = 4
_UnitPtr$ = -80						; size = 4
_UnitType$ = -76					; size = 4
_totalstr$ = -72					; size = 4
_perc$ = -68						; size = 4
_Type$ = -64						; size = 4
_x$ = -60						; size = 2
_y$ = -56						; size = 2
_this$ = -52						; size = 4
_u$ = -48						; size = 4
_Buffer$ = -44						; size = 40
__$ArrayPad$ = -4					; size = 4
_div$ = 8						; size = 4
?AddDivision@C_Map@@QAEPAVMAPICONLIST@@PAVDivisionClass@@@Z PROC ; C_Map::AddDivision
; _this$ = ecx

; 551  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 552  : 	UnitClassDataType *UnitPtr;
; 553  : 	Unit     u;
; 554  : 	MAPICONLIST *cur;
; 555  : 	GridIndex x,y;
; 556  : 	long UnitType,Type;
; 557  : 	long totalstr,curstr,perc;
; 558  : 	_TCHAR Buffer[40];
; 559  : 
; 560  : 	u=div->GetFirstUnitElement();

	mov	ecx, DWORD PTR _div$[ebp]
	call	?GetFirstUnitElement@DivisionClass@@QAEPAVUnitClass@@XZ ; DivisionClass::GetFirstUnitElement
	mov	DWORD PTR _u$[ebp], eax

; 561  : 	if(u)

	cmp	DWORD PTR _u$[ebp], 0
	je	$LN1@AddDivisio

; 562  : 	{
; 563  : 		UnitType=FindDivisionType(div->GetDivisionType()) & 0xffffff;

	mov	ecx, DWORD PTR _div$[ebp]
	call	?GetDivisionType@DivisionClass@@QAEEXZ	; DivisionClass::GetDivisionType
	movzx	eax, al
	push	eax
	call	?FindDivisionType@@YAJE@Z		; FindDivisionType
	add	esp, 4
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR _UnitType$[ebp], eax

; 564  : 		Type=FindTypeIndex(UnitType & 0x0fff,GND_TypeList,_MAP_NUM_GND_TYPES_);

	push	4
	push	OFFSET ?GND_TypeList@@3PAJA		; GND_TypeList
	mov	ecx, DWORD PTR _UnitType$[ebp]
	and	ecx, 4095				; 00000fffH
	push	ecx
	call	?FindTypeIndex@@YAJJQAJH@Z		; FindTypeIndex
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _Type$[ebp], eax

; 565  : 
; 566  : 		// Figure out Status
; 567  : 		curstr=u->GetTotalVehicles();

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetTotalVehicles@UnitClass@@QAEHXZ	; UnitClass::GetTotalVehicles
	mov	DWORD PTR _curstr$[ebp], eax

; 568  : 		totalstr=u->GetFullstrengthVehicles();

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetFullstrengthVehicles@UnitClass@@QAEHXZ ; UnitClass::GetFullstrengthVehicles
	mov	DWORD PTR _totalstr$[ebp], eax

; 569  : 		if(totalstr < 1) totalstr=1;

	cmp	DWORD PTR _totalstr$[ebp], 1
	jge	SHORT $LN3@AddDivisio
	mov	DWORD PTR _totalstr$[ebp], 1
$LN3@AddDivisio:

; 570  : 		perc=(curstr * 100)/totalstr;

	mov	eax, DWORD PTR _curstr$[ebp]
	imul	eax, 100				; 00000064H
	cdq
	idiv	DWORD PTR _totalstr$[ebp]
	mov	DWORD PTR _perc$[ebp], eax

; 571  : 		if(perc > 100) perc=100;

	cmp	DWORD PTR _perc$[ebp], 100		; 00000064H
	jle	SHORT $LN2@AddDivisio
	mov	DWORD PTR _perc$[ebp], 100		; 00000064H
$LN2@AddDivisio:

; 572  : 
; 573  : 		cur=Team_[u->GetTeam()].Units->Type[Type]->Levels[0]->FindID(UR_DIVISION | div->nid);

	mov	edx, DWORD PTR _div$[ebp]
	movsx	eax, WORD PTR [edx+4]
	or	eax, 65536				; 00010000H
	push	eax
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+868]
	mov	ecx, DWORD PTR _Type$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+16]
	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR [edx+eax+12]
	call	?FindID@C_MapIcon@@QAEPAVMAPICONLIST@@J@Z ; C_MapIcon::FindID
	mov	DWORD PTR _cur$[ebp], eax

; 574  : 		if(cur == NULL)

	cmp	DWORD PTR _cur$[ebp], 0
	jne	$LN1@AddDivisio

; 575  : 		{
; 576  : 			div->GetName(Buffer,39,FALSE);

	push	0
	push	39					; 00000027H
	lea	ecx, DWORD PTR _Buffer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _div$[ebp]
	call	?GetName@DivisionClass@@QAEPADPADHH@Z	; DivisionClass::GetName

; 577  : 			UnitPtr=u->GetUnitClassData();

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetUnitClassData@UnitClass@@QAEPAUUnitClassDataType@@XZ ; UnitClass::GetUnitClassData
	mov	DWORD PTR _UnitPtr$[ebp], eax

; 578  : 			div->GetLocation(&x,&y);

	lea	edx, DWORD PTR _y$[ebp]
	push	edx
	lea	eax, DWORD PTR _x$[ebp]
	push	eax
	mov	ecx, DWORD PTR _div$[ebp]
	call	?GetLocation@DivisionClass@@QAEXPAF0@Z	; DivisionClass::GetLocation

; 579  : 
; 580  : 			return(Team_[u->GetTeam()].Units->Type[Type]->Levels[0]->AddIconToList(
; 581  : 				UR_DIVISION | div->nid,
; 582  : 				static_cast<short>(Type | _UNIT_DIVISION),
; 583  : 				UnitPtr->IconIndex,
; 584  : 				x*FEET_PER_KM,
; 585  : 				maxy - y*FEET_PER_KM,
; 586  : 				FALSE,
; 587  : 				Buffer,
; 588  : 				div->nid,
; 589  : 				0,0,(long)perc,0)
; 590  : 			);

	push	0
	mov	ecx, DWORD PTR _perc$[ebp]
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _div$[ebp]
	movsx	eax, WORD PTR [edx+4]
	push	eax
	lea	ecx, DWORD PTR _Buffer$[ebp]
	push	ecx
	push	0
	movsx	edx, WORD PTR _y$[ebp]
	cvtsi2ss xmm0, edx
	mulss	xmm0, DWORD PTR __real@454cffae
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+732]
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	movsx	ecx, WORD PTR _x$[ebp]
	cvtsi2ss xmm0, ecx
	mulss	xmm0, DWORD PTR __real@454cffae
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _UnitPtr$[ebp]
	movsx	eax, WORD PTR [edx+332]
	push	eax
	mov	ecx, DWORD PTR _Type$[ebp]
	or	ecx, 67108864				; 04000000H
	push	ecx
	mov	edx, DWORD PTR _div$[ebp]
	movsx	eax, WORD PTR [edx+4]
	or	eax, 65536				; 00010000H
	push	eax
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+868]
	mov	ecx, DWORD PTR _Type$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+16]
	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR [edx+eax+12]
	call	?AddIconToList@C_MapIcon@@QAEPAVMAPICONLIST@@JFJMMFPADJJJJJ@Z ; C_MapIcon::AddIconToList
	jmp	SHORT $LN5@AddDivisio
$LN1@AddDivisio:

; 591  : 		}
; 592  : 	}
; 593  : 	return(NULL);

	xor	eax, eax
$LN5@AddDivisio:

; 594  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?AddDivision@C_Map@@QAEPAVMAPICONLIST@@PAVDivisionClass@@@Z ENDP ; C_Map::AddDivision
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
$T1 = -92						; size = 4
$T2 = -88						; size = 4
tv320 = -84						; size = 4
$T3 = -80						; size = 4
_radar_long$ = -76					; size = 4
_ObjPtr$ = -72						; size = 4
_TypeID$ = -68						; size = 4
_this$ = -64						; size = 4
_ObjType$ = -60						; size = 4
_radar_short$ = -56					; size = 4
_numarcs$ = -52						; size = 2
_detect$ = -48						; size = 4
_Buffer$ = -44						; size = 40
__$ArrayPad$ = -4					; size = 4
_Obj$ = 8						; size = 4
?AddObjective@C_Map@@QAEPAVMAPICONLIST@@PAVObjectiveClass@@@Z PROC ; C_Map::AddObjective
; _this$ = ecx

; 479  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 480  : 	long ObjType,TypeID;
; 481  : 	short numarcs;
; 482  : 	float radar_short,radar_long;
; 483  : 	ObjClassDataType *ObjPtr;
; 484  : 	_TCHAR Buffer[40];
; 485  : 	DETECTOR *detect;
; 486  : 
; 487  : 	ObjType=GetObjectiveType(Obj);

	mov	eax, DWORD PTR _Obj$[ebp]
	push	eax
	call	?GetObjectiveType@@YAJPAVCampBaseClass@@@Z ; GetObjectiveType
	add	esp, 4
	mov	DWORD PTR _ObjType$[ebp], eax

; 488  : 	TypeID=FindTypeIndex(ObjType,OBJ_TypeList,_MAP_NUM_OBJ_TYPES_);

	push	14					; 0000000eH
	push	OFFSET ?OBJ_TypeList@@3PAJA		; OBJ_TypeList
	mov	ecx, DWORD PTR _ObjType$[ebp]
	push	ecx
	call	?FindTypeIndex@@YAJJQAJH@Z		; FindTypeIndex
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _TypeID$[ebp], eax

; 489  : 	if(TypeID != -1)

	cmp	DWORD PTR _TypeID$[ebp], -1
	je	$LN5@AddObjecti

; 490  : 	{
; 491  : 		if(ObjType)

	cmp	DWORD PTR _ObjType$[ebp], 0
	je	$LN5@AddObjecti

; 492  : 		{
; 493  : 			ObjPtr=Obj->GetObjectiveClassData();

	mov	ecx, DWORD PTR _Obj$[ebp]
	call	?GetObjectiveClassData@ObjectiveClass@@QAEPAUObjClassDataType@@XZ ; ObjectiveClass::GetObjectiveClassData
	mov	DWORD PTR _ObjPtr$[ebp], eax

; 494  : 			if(ObjPtr)

	cmp	DWORD PTR _ObjPtr$[ebp], 0
	je	$LN5@AddObjecti

; 495  : 			{
; 496  : 				Obj->GetName(Buffer,39,TRUE);

	push	1
	push	39					; 00000027H
	lea	edx, DWORD PTR _Buffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _Obj$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _Obj$[ebp]
	mov	eax, DWORD PTR [edx+380]
	call	eax

; 497  : 				detect=NULL;

	mov	DWORD PTR _detect$[ebp], 0

; 498  : 				radar_short=static_cast<float>(Obj->GetElectronicDetectionRange(LowAir));

	push	4
	mov	ecx, DWORD PTR _Obj$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _Obj$[ebp]
	mov	eax, DWORD PTR [edx+420]
	call	eax
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _radar_short$[ebp], xmm0

; 499  : 				radar_long=static_cast<float>(Obj->GetElectronicDetectionRange(Air));

	push	5
	mov	ecx, DWORD PTR _Obj$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _Obj$[ebp]
	mov	eax, DWORD PTR [edx+420]
	call	eax
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _radar_long$[ebp], xmm0

; 500  : 				if(radar_short || radar_long)

	movss	xmm0, DWORD PTR _radar_short$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@AddObjecti
	movss	xmm0, DWORD PTR _radar_long$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN1@AddObjecti
$LN3@AddObjecti:

; 501  : 				{
; 502  : 					#ifdef USE_SH_POOLS
; 503  : 					detect = (DETECTOR *)MemAllocPtr(UI_Pools[UI_GENERAL_POOL],sizeof(DETECTOR),FALSE);
; 504  : 					#else
; 505  : 					detect=new DETECTOR;

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR _detect$[ebp], ecx

; 506  : 					#endif
; 507  : 					detect->HighSam=0.0f;

	mov	edx, DWORD PTR _detect$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+8], xmm0

; 508  : 					detect->HighRadar=radar_long * KM_TO_FT;

	movss	xmm0, DWORD PTR _radar_long$[ebp]
	mulss	xmm0, DWORD PTR __real@454cffae
	mov	eax, DWORD PTR _detect$[ebp]
	movss	DWORD PTR [eax+12], xmm0

; 509  : 					detect->LowSam=0.0f;

	mov	ecx, DWORD PTR _detect$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+4], xmm0

; 510  : 
; 511  : 					if(radar_short)

	movss	xmm0, DWORD PTR _radar_short$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN2@AddObjecti

; 512  : 					{
; 513  : 						numarcs=static_cast<short>(Obj->GetNumberOfArcs());

	mov	edx, DWORD PTR _Obj$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _Obj$[ebp]
	mov	edx, DWORD PTR [eax+432]
	call	edx
	mov	WORD PTR _numarcs$[ebp], ax

; 514  : 						numarcs=1; // TEMP kludge

	mov	eax, 1
	mov	WORD PTR _numarcs$[ebp], ax

; 515  : 						#ifdef USE_SH_POOLS
; 516  : 						detect->LowRadar = (ARC_LIST *)MemAllocPtr(UI_Pools[UI_GENERAL_POOL],sizeof(ARC_LIST),FALSE);
; 517  : 						#else
; 518  : 						detect->LowRadar=new ARC_LIST;

	push	8
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	ecx, DWORD PTR _detect$[ebp]
	mov	edx, DWORD PTR $T3[ebp]
	mov	DWORD PTR [ecx], edx

; 519  : 						#endif
; 520  : 						detect->LowRadar->numarcs=numarcs;

	mov	eax, DWORD PTR _detect$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	dx, WORD PTR _numarcs$[ebp]
	mov	WORD PTR [ecx], dx

; 521  : 						#ifdef USE_SH_POOLS
; 522  : 						detect->LowRadar->arcs = (ARC_REC *)MemAllocPtr(UI_Pools[UI_GENERAL_POOL],sizeof(ARC_REC)*numarcs,FALSE);
; 523  : 						#else
; 524  : 						detect->LowRadar->arcs=new ARC_REC[numarcs];

	movsx	eax, WORD PTR _numarcs$[ebp]
	xor	ecx, ecx
	mov	edx, 8
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR _detect$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR [ecx+4], edx

; 525  : 						#endif
; 526  : 						// after getting rid of kludges...
; 527  : 						// figure out how to do arcs right
; 528  : 						// kludge
; 529  : 						detect->LowRadar->arcs[0].arc=0;

	mov	eax, DWORD PTR _detect$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, 8
	imul	edx, 0
	mov	eax, DWORD PTR [ecx+4]
	xor	ecx, ecx
	mov	WORD PTR [eax+edx], cx

; 530  : 						detect->LowRadar->arcs[0].range=radar_short;

	mov	edx, DWORD PTR _detect$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, 8
	imul	ecx, 0
	mov	edx, DWORD PTR [eax+4]
	movss	xmm0, DWORD PTR _radar_short$[ebp]
	movss	DWORD PTR [edx+ecx+4], xmm0

; 531  : 					}
; 532  : 					else

	jmp	SHORT $LN1@AddObjecti
$LN2@AddObjecti:

; 533  : 						detect->LowRadar=NULL;

	mov	eax, DWORD PTR _detect$[ebp]
	mov	DWORD PTR [eax], 0
$LN1@AddObjecti:

; 534  : 				}
; 535  : 				return (Team_[Obj->GetTeam()].Objectives->Type[TypeID]->AddIconToList(
; 536  : 					Obj->GetCampID(),
; 537  : 					static_cast<short>(ObjType),
; 538  : 					ObjPtr->IconIndex,
; 539  : 					Obj->YPos(),
; 540  : 					maxy - Obj->XPos(),
; 541  : 					FALSE,
; 542  : 					Buffer, 0, 0, 0, 0, 0, detect)
; 543  : 				);

	mov	ecx, DWORD PTR _detect$[ebp]
	push	ecx
	push	0
	push	0
	push	0
	push	0
	push	0
	lea	edx, DWORD PTR _Buffer$[ebp]
	push	edx
	push	0
	mov	ecx, DWORD PTR _Obj$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv320[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+732]
	subss	xmm0, DWORD PTR tv320[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _Obj$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _ObjPtr$[ebp]
	movsx	edx, WORD PTR [ecx+48]
	push	edx
	movzx	eax, WORD PTR _ObjType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Obj$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _Obj$[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax
	movsx	ecx, ax
	push	ecx
	mov	edx, DWORD PTR _Obj$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _Obj$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	movzx	eax, al
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+876]
	mov	eax, DWORD PTR _TypeID$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+56]
	call	?AddIconToList@C_MapIcon@@QAEPAVMAPICONLIST@@JFJMMFPADJJJJJPAUDETECTOR@@@Z ; C_MapIcon::AddIconToList
	jmp	SHORT $LN8@AddObjecti
$LN5@AddObjecti:

; 544  : 			}
; 545  : 		}
; 546  : 	}
; 547  : 	return(NULL);

	xor	eax, eax
$LN8@AddObjecti:

; 548  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?AddObjective@C_Map@@QAEPAVMAPICONLIST@@PAVObjectiveClass@@@Z ENDP ; C_Map::AddObjective
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
$T1 = -92						; size = 4
tv1249 = -88						; size = 4
tv1243 = -84						; size = 4
tv1175 = -80						; size = 4
tv1169 = -76						; size = 4
$T2 = -72						; size = 4
$T3 = -68						; size = 4
tv1061 = -64						; size = 4
tv1055 = -60						; size = 4
$T4 = -56						; size = 4
tv856 = -52						; size = 4
tv637 = -48						; size = 4
tv334 = -44						; size = 4
tv331 = -40						; size = 4
_sam_long$ = -36					; size = 4
_sam_short$ = -32					; size = 4
_radar_long$ = -28					; size = 4
_threat$ = -24						; size = 4
_radar_short$ = -20					; size = 4
_this$ = -16						; size = 4
_x$ = -12						; size = 2
_y$ = -8						; size = 2
_i$ = -4						; size = 2
_ent$ = 8						; size = 4
?AddThreat@C_Map@@QAEPAUTHREAT_LIST@@PAVCampBaseClass@@@Z PROC ; C_Map::AddThreat
; _this$ = ecx

; 354  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 	THREAT_LIST *threat;
; 356  : 	long radar_short;
; 357  : 	long radar_long;
; 358  : 	long sam_short;
; 359  : 	long sam_long;
; 360  : 	short i;
; 361  : 	GridIndex x,y;
; 362  : 
; 363  : 	threat=NULL;

	mov	DWORD PTR _threat$[ebp], 0

; 364  : 	if(ent->IsObjective() && ent->IsEmitting())

	mov	eax, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+236]
	call	eax
	test	eax, eax
	je	$LN26@AddThreat
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+216]
	call	eax
	test	eax, eax
	je	$LN26@AddThreat

; 365  : 	{
; 366  : 		ent->GetLocation(&x,&y);

	lea	ecx, DWORD PTR _y$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	ecx, DWORD PTR _ent$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 367  : 		ShiAssert(Map_Max_Y>0);
; 368  : 		y=static_cast<short>(Map_Max_Y-y);

	movsx	eax, WORD PTR ?Map_Max_Y@@3FA		; Map_Max_Y
	movsx	ecx, WORD PTR _y$[ebp]
	sub	eax, ecx
	mov	WORD PTR _y$[ebp], ax

; 369  : 		ShiAssert(y >= 0);
; 370  : 
; 371  : 		radar_short=ent->GetElectronicDetectionRange(LowAir);

	push	4
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax+420]
	call	edx
	mov	DWORD PTR _radar_short$[ebp], eax

; 372  : 		radar_long=ent->GetElectronicDetectionRange(Air);

	push	5
	mov	eax, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+420]
	call	eax
	mov	DWORD PTR _radar_long$[ebp], eax

; 373  : 		if(radar_short || radar_long)

	cmp	DWORD PTR _radar_short$[ebp], 0
	jne	SHORT $LN25@AddThreat
	cmp	DWORD PTR _radar_long$[ebp], 0
	je	$LN26@AddThreat
$LN25@AddThreat:

; 374  : 		{
; 375  : 			#ifdef USE_SH_POOLS
; 376  : 			threat = (THREAT_LIST *)MemAllocPtr(UI_Pools[UI_GENERAL_POOL],sizeof(THREAT_LIST),FALSE);
; 377  : 			#else
; 378  : 			threat=new THREAT_LIST;

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	ecx, DWORD PTR $T4[ebp]
	mov	DWORD PTR _threat$[ebp], ecx

; 379  : 			#endif
; 380  : 			memset(threat,0,sizeof(THREAT_LIST));

	push	16					; 00000010H
	push	0
	mov	edx, DWORD PTR _threat$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 381  : 
; 382  : 			if(Team_[ent->GetTeam()].Threats)

	mov	eax, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+ecx+860], 0
	je	$LN22@AddThreat

; 383  : 			{
; 384  : 				if(Team_[ent->GetTeam()].Threats->Type[_THREAT_RADAR_HIGH_])

	mov	eax, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+860]
	mov	ecx, 4
	imul	ecx, 3
	cmp	DWORD PTR [eax+ecx+16], 0
	je	$LN23@AddThreat

; 385  : 				{
; 386  : 					Team_[ent->GetTeam()].Threats->Type[_THREAT_RADAR_HIGH_]->AddCircle(ent->GetCampID(),C_Threat::THR_CIRCLE,x,y,radar_long);

	mov	edx, DWORD PTR _radar_long$[ebp]
	push	edx
	movsx	eax, WORD PTR _y$[ebp]
	push	eax
	movsx	ecx, WORD PTR _x$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax+112]
	call	edx
	cwde
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+860]
	mov	ecx, 4
	imul	ecx, 3
	mov	ecx, DWORD PTR [eax+ecx+16]
	call	?AddCircle@C_Threat@@QAEXJJJJJ@Z	; C_Threat::AddCircle

; 387  : 					threat->RadarHigh=Team_[ent->GetTeam()].Threats->Type[_THREAT_RADAR_HIGH_]->GetThreat(ent->GetCampID());

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax+112]
	call	edx
	cwde
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+860]
	mov	ecx, 4
	imul	ecx, 3
	mov	ecx, DWORD PTR [eax+ecx+16]
	call	?GetThreat@C_Threat@@QAEPAUTHREAT_CIRCLE@@J@Z ; C_Threat::GetThreat
	mov	edx, DWORD PTR _threat$[ebp]
	mov	DWORD PTR [edx+12], eax
$LN23@AddThreat:

; 388  : 				}
; 389  : 				if(Team_[ent->GetTeam()].Threats->Type[_THREAT_RADAR_LOW_] && radar_short)

	mov	eax, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+860]
	mov	ecx, 4
	shl	ecx, 1
	cmp	DWORD PTR [eax+ecx+16], 0
	je	$LN22@AddThreat
	cmp	DWORD PTR _radar_short$[ebp], 0
	je	$LN22@AddThreat

; 390  : 				{
; 391  : 					Team_[ent->GetTeam()].Threats->Type[_THREAT_RADAR_LOW_]->AddCircle(ent->GetCampID(),C_Threat::THR_SLICE,x,y,radar_short);

	mov	edx, DWORD PTR _radar_short$[ebp]
	push	edx
	movsx	eax, WORD PTR _y$[ebp]
	push	eax
	movsx	ecx, WORD PTR _x$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax+112]
	call	edx
	cwde
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+860]
	mov	ecx, 4
	shl	ecx, 1
	mov	ecx, DWORD PTR [eax+ecx+16]
	call	?AddCircle@C_Threat@@QAEXJJJJJ@Z	; C_Threat::AddCircle

; 392  : 					for(i=0;i<8;i++)

	xor	edx, edx
	mov	WORD PTR _i$[ebp], dx
	jmp	SHORT $LN21@AddThreat
$LN20@AddThreat:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
$LN21@AddThreat:
	movsx	ecx, WORD PTR _i$[ebp]
	cmp	ecx, 8
	jge	$LN19@AddThreat

; 393  : // 2001-03-14 MODIFIED BY S.G. SO IF THERE IS NO RADAR RANGE DATA, THE radar_short VALUE IS USED INSTEAD
; 394  : //						Team_[ent->GetTeam()].Threats->Type[_THREAT_RADAR_LOW_]->SetRadius(ent->GetCampID(),i,static_cast<long>(min(ent->GetArcRange(i)*FT_TO_KM,radar_short)));
; 395  : 						Team_[ent->GetTeam()].Threats->Type[_THREAT_RADAR_LOW_]->SetRadius(ent->GetCampID(),i,static_cast<long>(((ObjectiveClass *)ent)->HasRadarRanges() ? (min(ent->GetArcRange(i)*FT_TO_KM,radar_short)) : radar_short));

	mov	ecx, DWORD PTR _ent$[ebp]
	call	?HasRadarRanges@ObjectiveClass@@QAEHXZ	; ObjectiveClass::HasRadarRanges
	test	eax, eax
	je	SHORT $LN32@AddThreat
	movsx	edx, WORD PTR _i$[ebp]
	push	edx
	mov	eax, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+440]
	call	eax
	fstp	DWORD PTR tv1055[ebp]
	movss	xmm0, DWORD PTR tv1055[ebp]
	mulss	xmm0, DWORD PTR __real@399fcd90
	cvtsi2ss xmm1, DWORD PTR _radar_short$[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN30@AddThreat
	movsx	ecx, WORD PTR _i$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax+440]
	call	edx
	fstp	DWORD PTR tv1061[ebp]
	movss	xmm0, DWORD PTR tv1061[ebp]
	mulss	xmm0, DWORD PTR __real@399fcd90
	movss	DWORD PTR tv331[ebp], xmm0
	jmp	SHORT $LN31@AddThreat
$LN30@AddThreat:
	cvtsi2ss xmm0, DWORD PTR _radar_short$[ebp]
	movss	DWORD PTR tv331[ebp], xmm0
$LN31@AddThreat:
	movss	xmm0, DWORD PTR tv331[ebp]
	movss	DWORD PTR tv334[ebp], xmm0
	jmp	SHORT $LN33@AddThreat
$LN32@AddThreat:
	cvtsi2ss xmm0, DWORD PTR _radar_short$[ebp]
	movss	DWORD PTR tv334[ebp], xmm0
$LN33@AddThreat:
	cvttss2si eax, DWORD PTR tv334[ebp]
	push	eax
	movsx	ecx, WORD PTR _i$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax+112]
	call	edx
	cwde
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+860]
	mov	ecx, 4
	shl	ecx, 1
	mov	ecx, DWORD PTR [eax+ecx+16]
	call	?SetRadius@C_Threat@@QAEXJJJ@Z		; C_Threat::SetRadius
	jmp	$LN20@AddThreat
$LN19@AddThreat:

; 396  : 					threat->RadarLow=Team_[ent->GetTeam()].Threats->Type[_THREAT_RADAR_LOW_]->GetThreat(ent->GetCampID());

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax+112]
	call	edx
	cwde
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+860]
	mov	ecx, 4
	shl	ecx, 1
	mov	ecx, DWORD PTR [eax+ecx+16]
	call	?GetThreat@C_Threat@@QAEPAUTHREAT_CIRCLE@@J@Z ; C_Threat::GetThreat
	mov	edx, DWORD PTR _threat$[ebp]
	mov	DWORD PTR [edx+8], eax
$LN22@AddThreat:

; 397  : 				}
; 398  : 			}
; 399  : 			delete threat; // JPO - no idea what this threat variable is for!!!

	mov	eax, DWORD PTR _threat$[ebp]
	mov	DWORD PTR $T3[ebp], eax
	mov	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN26@AddThreat:

; 400  : 		}
; 401  : 	}
; 402  : // 2001-05-08 MODIFIED BY S.G. UNITS CAN STILL FIRE AT YOU, EVEN IF NOT EMITING THEMSELF SO RESERVE THE 'IsEmitting' FOR THREAT_RADAR_* CODE
; 403  : //	if(ent->IsUnit() && ent->IsEmitting())
; 404  : 	if(ent->IsUnit())

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax+232]
	call	edx
	test	eax, eax
	je	$LN17@AddThreat

; 405  : // THIS IS WHAT I DO IN 1.08i2 BUT NOT REQUIRED IN 1.07 (SEE AT END OF FUNCTION FOR DETAIL)
; 406  : //	if(ent->IsUnit() && !((Unit)ent)->Inactive() && (FindUnitType(ent) & (_UNIT_AIR_DEFENSE | _UNIT_BATTALION)))
; 407  : //	UI_Refresher *gpsItem=NULL;
; 408  : //	if(ent->IsUnit() && (gpsItem=(UI_Refresher*)gGps->Find(ent->GetCampID())) && gpsItem->MapItem_ && !(gpsItem->MapItem_->Flags & C_BIT_INVISIBLE))
; 409  : 	{
; 410  : 		ent->GetLocation(&x,&y);

	lea	eax, DWORD PTR _y$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _ent$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 411  : 		ShiAssert(Map_Max_Y>0);
; 412  : 		y=static_cast<short>(Map_Max_Y-y);

	movsx	edx, WORD PTR ?Map_Max_Y@@3FA		; Map_Max_Y
	movsx	eax, WORD PTR _y$[ebp]
	sub	edx, eax
	mov	WORD PTR _y$[ebp], dx

; 413  : 		ShiAssert(y >= 0);
; 414  : 		radar_short=ent->GetElectronicDetectionRange(LowAir);

	push	4
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+420]
	call	eax
	mov	DWORD PTR _radar_short$[ebp], eax

; 415  : 		radar_long=ent->GetElectronicDetectionRange(Air);

	push	5
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+420]
	call	eax
	mov	DWORD PTR _radar_long$[ebp], eax

; 416  : 		sam_short=ent->GetAproxWeaponRange(LowAir);

	push	4
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+412]
	call	eax
	mov	DWORD PTR _sam_short$[ebp], eax

; 417  : 		sam_long=ent->GetAproxWeaponRange(Air);

	push	5
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+412]
	call	eax
	mov	DWORD PTR _sam_long$[ebp], eax

; 418  : 		if(radar_short || radar_long || sam_long || sam_short)

	cmp	DWORD PTR _radar_short$[ebp], 0
	jne	SHORT $LN16@AddThreat
	cmp	DWORD PTR _radar_long$[ebp], 0
	jne	SHORT $LN16@AddThreat
	cmp	DWORD PTR _sam_long$[ebp], 0
	jne	SHORT $LN16@AddThreat
	cmp	DWORD PTR _sam_short$[ebp], 0
	je	$LN17@AddThreat
$LN16@AddThreat:

; 419  : 		{
; 420  : // 2001-06-22 ADDED BY S.G. IF EMITTING, DISPLAY THE RADAR THREATS
; 421  : 			if (((BattalionClass *)ent)->class_data->RadarVehicle < 16) {

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+236]
	movzx	eax, BYTE PTR [edx+328]
	cmp	eax, 16					; 00000010H
	jge	SHORT $LN13@AddThreat

; 422  : 				if (!radar_short)

	cmp	DWORD PTR _radar_short$[ebp], 0
	jne	SHORT $LN14@AddThreat

; 423  : 					sam_short /= 128;

	mov	eax, DWORD PTR _sam_short$[ebp]
	cdq
	and	edx, 127				; 0000007fH
	add	eax, edx
	sar	eax, 7
	mov	DWORD PTR _sam_short$[ebp], eax
$LN14@AddThreat:

; 424  : 				if (!radar_long)

	cmp	DWORD PTR _radar_long$[ebp], 0
	jne	SHORT $LN13@AddThreat

; 425  : 					sam_long /= 128;

	mov	eax, DWORD PTR _sam_long$[ebp]
	cdq
	and	edx, 127				; 0000007fH
	add	eax, edx
	sar	eax, 7
	mov	DWORD PTR _sam_long$[ebp], eax
$LN13@AddThreat:

; 426  : 			}
; 427  : // END OF ADDED SECTION
; 428  : 
; 429  : 			#ifdef USE_SH_POOLS
; 430  : 			threat = (THREAT_LIST *)MemAllocPtr(UI_Pools[UI_GENERAL_POOL],sizeof(THREAT_LIST),FALSE);
; 431  : 			#else
; 432  : 			threat=new THREAT_LIST;

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR _threat$[ebp], ecx

; 433  : 			#endif
; 434  : 			memset(threat,0,sizeof(THREAT_LIST));

	push	16					; 00000010H
	push	0
	mov	edx, DWORD PTR _threat$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 435  : 
; 436  : 			if(Team_[ent->GetTeam()].Threats)

	mov	eax, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+ecx+860], 0
	je	$LN4@AddThreat

; 437  : 			{
; 438  : // 2001-05-08 ADDED BY S.G. IF EMITTING, DISPLAY THE RADAR THREATS
; 439  : 				if (ent->IsEmitting()) {

	mov	eax, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+216]
	call	eax
	test	eax, eax
	je	$LN4@AddThreat

; 440  : // END OF ADDED SECTION (EXCEPT FOR BLOCK INDENT)
; 441  : 					if(Team_[ent->GetTeam()].Threats->Type[_THREAT_RADAR_HIGH_] && radar_long)

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+860]
	mov	ecx, 4
	imul	ecx, 3
	cmp	DWORD PTR [eax+ecx+16], 0
	je	$LN10@AddThreat
	cmp	DWORD PTR _radar_long$[ebp], 0
	je	$LN10@AddThreat

; 442  : 					{
; 443  : 						Team_[ent->GetTeam()].Threats->Type[_THREAT_RADAR_HIGH_]->AddCircle(ent->GetCampID(),C_Threat::THR_CIRCLE,x,y,radar_long);

	mov	edx, DWORD PTR _radar_long$[ebp]
	push	edx
	movsx	eax, WORD PTR _y$[ebp]
	push	eax
	movsx	ecx, WORD PTR _x$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax+112]
	call	edx
	cwde
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+860]
	mov	ecx, 4
	imul	ecx, 3
	mov	ecx, DWORD PTR [eax+ecx+16]
	call	?AddCircle@C_Threat@@QAEXJJJJJ@Z	; C_Threat::AddCircle

; 444  : 						threat->RadarHigh=Team_[ent->GetTeam()].Threats->Type[_THREAT_RADAR_HIGH_]->GetThreat(ent->GetCampID());

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax+112]
	call	edx
	cwde
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+860]
	mov	ecx, 4
	imul	ecx, 3
	mov	ecx, DWORD PTR [eax+ecx+16]
	call	?GetThreat@C_Threat@@QAEPAUTHREAT_CIRCLE@@J@Z ; C_Threat::GetThreat
	mov	edx, DWORD PTR _threat$[ebp]
	mov	DWORD PTR [edx+12], eax
$LN10@AddThreat:

; 445  : 					}
; 446  : 					if(Team_[ent->GetTeam()].Threats->Type[_THREAT_RADAR_LOW_] && radar_short)

	mov	eax, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+860]
	mov	ecx, 4
	shl	ecx, 1
	cmp	DWORD PTR [eax+ecx+16], 0
	je	$LN9@AddThreat
	cmp	DWORD PTR _radar_short$[ebp], 0
	je	$LN9@AddThreat

; 447  : 					{
; 448  : 						Team_[ent->GetTeam()].Threats->Type[_THREAT_RADAR_LOW_]->AddCircle(ent->GetCampID(),C_Threat::THR_SLICE,x,y,radar_short);

	mov	edx, DWORD PTR _radar_short$[ebp]
	push	edx
	movsx	eax, WORD PTR _y$[ebp]
	push	eax
	movsx	ecx, WORD PTR _x$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax+112]
	call	edx
	cwde
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+860]
	mov	ecx, 4
	shl	ecx, 1
	mov	ecx, DWORD PTR [eax+ecx+16]
	call	?AddCircle@C_Threat@@QAEXJJJJJ@Z	; C_Threat::AddCircle

; 449  : 						for(i=0;i<8;i++)

	xor	edx, edx
	mov	WORD PTR _i$[ebp], dx
	jmp	SHORT $LN8@AddThreat
$LN7@AddThreat:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
$LN8@AddThreat:
	movsx	ecx, WORD PTR _i$[ebp]
	cmp	ecx, 8
	jge	$LN6@AddThreat

; 450  : 							Team_[ent->GetTeam()].Threats->Type[_THREAT_RADAR_LOW_]->SetRadius(ent->GetCampID(),i,static_cast<short>(min(ent->GetArcRange(i)*FT_TO_KM,radar_short)));

	movsx	edx, WORD PTR _i$[ebp]
	push	edx
	mov	eax, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+440]
	call	eax
	fstp	DWORD PTR tv1169[ebp]
	movss	xmm0, DWORD PTR tv1169[ebp]
	mulss	xmm0, DWORD PTR __real@399fcd90
	cvtsi2ss xmm1, DWORD PTR _radar_short$[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN34@AddThreat
	movsx	ecx, WORD PTR _i$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax+440]
	call	edx
	fstp	DWORD PTR tv1175[ebp]
	movss	xmm0, DWORD PTR tv1175[ebp]
	mulss	xmm0, DWORD PTR __real@399fcd90
	movss	DWORD PTR tv637[ebp], xmm0
	jmp	SHORT $LN35@AddThreat
$LN34@AddThreat:
	cvtsi2ss xmm0, DWORD PTR _radar_short$[ebp]
	movss	DWORD PTR tv637[ebp], xmm0
$LN35@AddThreat:
	cvttss2si eax, DWORD PTR tv637[ebp]
	movsx	ecx, ax
	push	ecx
	movsx	edx, WORD PTR _i$[ebp]
	push	edx
	mov	eax, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax
	movsx	ecx, ax
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	movzx	eax, al
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+860]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR [edx+eax+16]
	call	?SetRadius@C_Threat@@QAEXJJJ@Z		; C_Threat::SetRadius
	jmp	$LN7@AddThreat
$LN6@AddThreat:

; 451  : 						threat->RadarLow=Team_[ent->GetTeam()].Threats->Type[_THREAT_RADAR_LOW_]->GetThreat(ent->GetCampID());

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax
	movsx	ecx, ax
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	movzx	eax, al
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+860]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR [edx+eax+16]
	call	?GetThreat@C_Threat@@QAEPAUTHREAT_CIRCLE@@J@Z ; C_Threat::GetThreat
	mov	ecx, DWORD PTR _threat$[ebp]
	mov	DWORD PTR [ecx+8], eax
$LN9@AddThreat:

; 452  : 					}
; 453  : 					if(Team_[ent->GetTeam()].Threats->Type[_THREAT_SAM_HIGH_] && sam_long)

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	movzx	eax, al
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+860]
	mov	eax, 4
	shl	eax, 0
	cmp	DWORD PTR [edx+eax+16], 0
	je	$LN5@AddThreat
	cmp	DWORD PTR _sam_long$[ebp], 0
	je	$LN5@AddThreat

; 454  : 					{
; 455  : 						Team_[ent->GetTeam()].Threats->Type[_THREAT_SAM_HIGH_]->AddCircle(ent->GetCampID(),C_Threat::THR_CIRCLE,x,y, FTOL(sam_long/.539f));

	cvtsi2ss xmm0, DWORD PTR _sam_long$[ebp]
	divss	xmm0, DWORD PTR __real@3f09fbe7
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	push	eax
	movsx	ecx, WORD PTR _y$[ebp]
	push	ecx
	movsx	edx, WORD PTR _x$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax
	movsx	ecx, ax
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	movzx	eax, al
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+860]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR [edx+eax+16]
	call	?AddCircle@C_Threat@@QAEXJJJJJ@Z	; C_Threat::AddCircle

; 456  : 						threat->SamHigh=Team_[ent->GetTeam()].Threats->Type[_THREAT_SAM_HIGH_]->GetThreat(ent->GetCampID());

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax
	movsx	ecx, ax
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	movzx	eax, al
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+860]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR [edx+eax+16]
	call	?GetThreat@C_Threat@@QAEPAUTHREAT_CIRCLE@@J@Z ; C_Threat::GetThreat
	mov	ecx, DWORD PTR _threat$[ebp]
	mov	DWORD PTR [ecx+4], eax
$LN5@AddThreat:

; 457  : 					}
; 458  : 					if(Team_[ent->GetTeam()].Threats->Type[_THREAT_SAM_LOW_] && sam_short)

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	movzx	eax, al
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+860]
	mov	eax, 4
	imul	eax, 0
	cmp	DWORD PTR [edx+eax+16], 0
	je	$LN4@AddThreat
	cmp	DWORD PTR _sam_short$[ebp], 0
	je	$LN4@AddThreat

; 459  : 					{
; 460  : 						Team_[ent->GetTeam()].Threats->Type[_THREAT_SAM_LOW_]->AddCircle(ent->GetCampID(),C_Threat::THR_SLICE,x,y,sam_short);

	mov	ecx, DWORD PTR _sam_short$[ebp]
	push	ecx
	movsx	edx, WORD PTR _y$[ebp]
	push	edx
	movsx	eax, WORD PTR _x$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax
	movsx	ecx, ax
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	movzx	eax, al
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+860]
	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR [edx+eax+16]
	call	?AddCircle@C_Threat@@QAEXJJJJJ@Z	; C_Threat::AddCircle

; 461  : 						for(i=0;i<8;i++)

	xor	ecx, ecx
	mov	WORD PTR _i$[ebp], cx
	jmp	SHORT $LN3@AddThreat
$LN2@AddThreat:
	mov	dx, WORD PTR _i$[ebp]
	add	dx, 1
	mov	WORD PTR _i$[ebp], dx
$LN3@AddThreat:
	movsx	eax, WORD PTR _i$[ebp]
	cmp	eax, 8
	jge	$LN1@AddThreat

; 462  : 							Team_[ent->GetTeam()].Threats->Type[_THREAT_SAM_LOW_]->SetRadius(ent->GetCampID(),i,static_cast<short>(min(ent->GetArcRange(i)*FT_TO_KM,sam_short)));

	movsx	ecx, WORD PTR _i$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax+440]
	call	edx
	fstp	DWORD PTR tv1243[ebp]
	movss	xmm0, DWORD PTR tv1243[ebp]
	mulss	xmm0, DWORD PTR __real@399fcd90
	cvtsi2ss xmm1, DWORD PTR _sam_short$[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN36@AddThreat
	movsx	eax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+440]
	call	eax
	fstp	DWORD PTR tv1249[ebp]
	movss	xmm0, DWORD PTR tv1249[ebp]
	mulss	xmm0, DWORD PTR __real@399fcd90
	movss	DWORD PTR tv856[ebp], xmm0
	jmp	SHORT $LN37@AddThreat
$LN36@AddThreat:
	cvtsi2ss xmm0, DWORD PTR _sam_short$[ebp]
	movss	DWORD PTR tv856[ebp], xmm0
$LN37@AddThreat:
	cvttss2si ecx, DWORD PTR tv856[ebp]
	movsx	edx, cx
	push	edx
	movsx	eax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax
	movsx	ecx, ax
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	movzx	eax, al
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+860]
	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR [edx+eax+16]
	call	?SetRadius@C_Threat@@QAEXJJJ@Z		; C_Threat::SetRadius
	jmp	$LN2@AddThreat
$LN1@AddThreat:

; 463  : 						threat->SamLow=Team_[ent->GetTeam()].Threats->Type[_THREAT_SAM_LOW_]->GetThreat(ent->GetCampID());

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax
	movsx	ecx, ax
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	movzx	eax, al
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+860]
	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR [edx+eax+16]
	call	?GetThreat@C_Threat@@QAEPAUTHREAT_CIRCLE@@J@Z ; C_Threat::GetThreat
	mov	ecx, DWORD PTR _threat$[ebp]
	mov	DWORD PTR [ecx], eax
$LN4@AddThreat:

; 464  : 					}
; 465  : 				}
; 466  : 			}
; 467  : 			delete threat; // JPO - no idea what this threat variable is for!!! S.G. I DO BUT I HAVE NO TIME TO FIX IT NOW. I'LL MAKE IT RP5 COMPATIBLE FIRST

	mov	edx, DWORD PTR _threat$[ebp]
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN17@AddThreat:

; 468  : 		}
; 469  : 	}
; 470  : 
; 471  : // 2001-05-09 MODIFIED BY S.G. WHY NOT RETURNING THAT STRUCTURE WE FILLED UP? CAN WE SAY 'MEMORY LEAK' HERE? PLUS WITHOUT THIS, THREAT CIRCLES ARE APPEARING FOR ANY UNITS WITH A 'Range' AGAINST 'Air' MOVEMENT TYPE...
; 472  : 	return(NULL);

	xor	eax, eax

; 473  : // THIS IS DIFFERENT THAN WHAT I DO IN 1.08i2 AND IS THE PREFERED WAY. I CAN'T DO IT IN 1.08i2 BEFORE TOO MUCH CODE WAS OPTOMIZED OUT BY THE COMPILER :-(
; 474  : //	return (threat);
; 475  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?AddThreat@C_Map@@QAEPAUTHREAT_LIST@@PAVCampBaseClass@@@Z ENDP ; C_Map::AddThreat
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_MapItem$ = 8						; size = 4
?CenterOnIcon@C_Map@@QAEXPAVMAPICONLIST@@@Z PROC	; C_Map::CenterOnIcon
; _this$ = ecx

; 1270 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1271 : 	if(MapItem)

	cmp	DWORD PTR _MapItem$[ebp], 0
	je	SHORT $LN1@CenterOnIc

; 1272 : 	{
; 1273 : 	//cx=(CurWPArea_.top/1640 + CurWPArea_.bottom/1640)/2;
; 1274 : 	//cy=((maxy - CurWPArea_.left)/1640 + (maxy - CurWPArea_.right)/1640)/2;
; 1275 : 
; 1276 : 		SetMapCenter(static_cast<long>(MapItem->worldx/FEET_PER_PIXEL),static_cast<long>(MapItem->worldy/FEET_PER_PIXEL));

	mov	eax, DWORD PTR _MapItem$[ebp]
	movss	xmm0, DWORD PTR [eax+24]
	divss	xmm0, DWORD PTR __real@44ccffae
	cvttss2si ecx, xmm0
	push	ecx
	mov	edx, DWORD PTR _MapItem$[ebp]
	movss	xmm0, DWORD PTR [edx+20]
	divss	xmm0, DWORD PTR __real@44ccffae
	cvttss2si eax, xmm0
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMapCenter@C_Map@@QAEXJJ@Z		; C_Map::SetMapCenter

; 1277 : 		if(DrawWindow_)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1124], 0
	je	SHORT $LN1@CenterOnIc

; 1278 : 			DrawWindow_->RefreshWindow();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1124]
	call	?RefreshWindow@C_Window@@QAEXXZ		; C_Window::RefreshWindow
$LN1@CenterOnIc:

; 1279 : 	}
; 1280 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?CenterOnIcon@C_Map@@QAEXPAVMAPICONLIST@@@Z ENDP	; C_Map::CenterOnIcon
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_MapItem$ = 8						; size = 4
?AddToCurIcons@C_Map@@QAEXPAVMAPICONLIST@@@Z PROC	; C_Map::AddToCurIcons
; _this$ = ecx

; 1264 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1265 : 	if(MapItem)

	cmp	DWORD PTR _MapItem$[ebp], 0
	je	SHORT $LN2@AddToCurIc

; 1266 : 		CurIcons_->Add(MapItem);

	mov	eax, DWORD PTR _MapItem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1116]
	call	?Add@C_DrawList@@QAEXPAVMAPICONLIST@@@Z	; C_DrawList::Add
$LN2@AddToCurIc:

; 1267 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?AddToCurIcons@C_Map@@QAEXPAVMAPICONLIST@@@Z ENDP	; C_Map::AddToCurIcons
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ID$ = 8						; size = 4
?RemoveFromCurIcons@C_Map@@QAEXJ@Z PROC			; C_Map::RemoveFromCurIcons
; _this$ = ecx

; 1600 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1601 : 	if (CurIcons_)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1116], 0
	je	SHORT $LN2@RemoveFrom

; 1602 : 		CurIcons_->Remove(ID);

	mov	ecx, DWORD PTR _ID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1116]
	call	?Remove@C_DrawList@@QAEXJ@Z		; C_DrawList::Remove
$LN2@RemoveFrom:

; 1603 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?RemoveFromCurIcons@C_Map@@QAEXJ@Z ENDP			; C_Map::RemoveFromCurIcons
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
_k$ = -12						; size = 2
_i$ = -8						; size = 2
_j$ = -4						; size = 2
?RemoveAllEntities@C_Map@@QAEXXZ PROC			; C_Map::RemoveAllEntities
; _this$ = ecx

; 221  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 222  : 	short i,j,k;
; 223  : 
; 224  : 	for(i=0;i<_MAX_TEAMS_;i++)

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax
	jmp	SHORT $LN37@RemoveAllE
$LN36@RemoveAllE:
	mov	cx, WORD PTR _i$[ebp]
	add	cx, 1
	mov	WORD PTR _i$[ebp], cx
$LN37@RemoveAllE:
	movsx	edx, WORD PTR _i$[ebp]
	cmp	edx, 8
	jge	$LN35@RemoveAllE

; 225  : 	{
; 226  : 		if(Team_[i].Threats)

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax+860], 0
	je	SHORT $LN34@RemoveAllE

; 227  : 		{
; 228  : 			for(j=0;j<_MAP_NUM_THREAT_TYPES_;j++)

	xor	edx, edx
	mov	WORD PTR _j$[ebp], dx
	jmp	SHORT $LN33@RemoveAllE
$LN32@RemoveAllE:
	mov	ax, WORD PTR _j$[ebp]
	add	ax, 1
	mov	WORD PTR _j$[ebp], ax
$LN33@RemoveAllE:
	movsx	ecx, WORD PTR _j$[ebp]
	cmp	ecx, 4
	jge	SHORT $LN34@RemoveAllE

; 229  : 				if(Team_[i].Threats->Type[j])

	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+860]
	movsx	edx, WORD PTR _j$[ebp]
	cmp	DWORD PTR [ecx+edx*4+16], 0
	je	SHORT $LN30@RemoveAllE

; 230  : 				{
; 231  : 					Team_[i].Threats->Type[j]->Cleanup();

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+860]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+16]
	movsx	edx, WORD PTR _j$[ebp]
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [esi+eax+860]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4+16]
	mov	edx, DWORD PTR [esi+176]
	call	edx
$LN30@RemoveAllE:

; 232  : 				}
; 233  : 		}

	jmp	SHORT $LN32@RemoveAllE
$LN34@RemoveAllE:

; 234  : 		if(Team_[i].Objectives)

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax+876], 0
	je	SHORT $LN29@RemoveAllE

; 235  : 		{
; 236  : 			for(j=0;j<_MAP_NUM_OBJ_TYPES_;j++)

	xor	edx, edx
	mov	WORD PTR _j$[ebp], dx
	jmp	SHORT $LN28@RemoveAllE
$LN27@RemoveAllE:
	mov	ax, WORD PTR _j$[ebp]
	add	ax, 1
	mov	WORD PTR _j$[ebp], ax
$LN28@RemoveAllE:
	movsx	ecx, WORD PTR _j$[ebp]
	cmp	ecx, 14					; 0000000eH
	jge	SHORT $LN29@RemoveAllE

; 237  : 				if(Team_[i].Objectives->Type[j])

	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+876]
	movsx	edx, WORD PTR _j$[ebp]
	cmp	DWORD PTR [ecx+edx*4+56], 0
	je	SHORT $LN25@RemoveAllE

; 238  : 				{
; 239  : 					Team_[i].Objectives->Type[j]->Cleanup();

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+876]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+56]
	movsx	edx, WORD PTR _j$[ebp]
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [esi+eax+876]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4+56]
	mov	edx, DWORD PTR [esi+176]
	call	edx
$LN25@RemoveAllE:

; 240  : 				}
; 241  : 		}

	jmp	SHORT $LN27@RemoveAllE
$LN29@RemoveAllE:

; 242  : 		if(Team_[i].NavalUnits)

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax+872], 0
	je	SHORT $LN24@RemoveAllE

; 243  : 		{
; 244  : 			for(j=0;j<_MAP_NUM_NAV_TYPES_;j++)

	xor	edx, edx
	mov	WORD PTR _j$[ebp], dx
	jmp	SHORT $LN23@RemoveAllE
$LN22@RemoveAllE:
	mov	ax, WORD PTR _j$[ebp]
	add	ax, 1
	mov	WORD PTR _j$[ebp], ax
$LN23@RemoveAllE:
	movsx	ecx, WORD PTR _j$[ebp]
	cmp	ecx, 2
	jge	SHORT $LN24@RemoveAllE

; 245  : 				if(Team_[i].NavalUnits->Type[j])

	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+872]
	movsx	edx, WORD PTR _j$[ebp]
	cmp	DWORD PTR [ecx+edx*4+8], 0
	je	SHORT $LN20@RemoveAllE

; 246  : 				{
; 247  : 					Team_[i].NavalUnits->Type[j]->Cleanup();

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+872]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+8]
	movsx	edx, WORD PTR _j$[ebp]
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [esi+eax+872]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4+8]
	mov	edx, DWORD PTR [esi+176]
	call	edx
$LN20@RemoveAllE:

; 248  : 				}
; 249  : 		}

	jmp	SHORT $LN22@RemoveAllE
$LN24@RemoveAllE:

; 250  : 		if(Team_[i].Units)

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax+868], 0
	je	$LN19@RemoveAllE

; 251  : 		{
; 252  : 			for(j=0;j<_MAP_NUM_GND_TYPES_;j++)

	xor	edx, edx
	mov	WORD PTR _j$[ebp], dx
	jmp	SHORT $LN18@RemoveAllE
$LN17@RemoveAllE:
	mov	ax, WORD PTR _j$[ebp]
	add	ax, 1
	mov	WORD PTR _j$[ebp], ax
$LN18@RemoveAllE:
	movsx	ecx, WORD PTR _j$[ebp]
	cmp	ecx, 4
	jge	$LN19@RemoveAllE

; 253  : 				if(Team_[i].Units->Type[j])

	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+868]
	movsx	edx, WORD PTR _j$[ebp]
	cmp	DWORD PTR [ecx+edx*4+16], 0
	je	$LN15@RemoveAllE

; 254  : 				{
; 255  : 					if(Team_[i].Units->Type[j])

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+868]
	movsx	eax, WORD PTR _j$[ebp]
	cmp	DWORD PTR [edx+eax*4+16], 0
	je	$LN15@RemoveAllE

; 256  : 					{
; 257  : 						for(k=0;k<_MAP_NUM_GND_LEVELS_;k++)

	xor	ecx, ecx
	mov	WORD PTR _k$[ebp], cx
	jmp	SHORT $LN13@RemoveAllE
$LN12@RemoveAllE:
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$LN13@RemoveAllE:
	movsx	eax, WORD PTR _k$[ebp]
	cmp	eax, 3
	jge	SHORT $LN15@RemoveAllE

; 258  : 							if(Team_[i].Units->Type[j]->Levels[k])

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+868]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+16]
	movsx	eax, WORD PTR _k$[ebp]
	cmp	DWORD PTR [edx+eax*4+12], 0
	je	SHORT $LN10@RemoveAllE

; 259  : 							{
; 260  : 								Team_[i].Units->Type[j]->Levels[k]->Cleanup();

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+868]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+16]
	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+12]
	movsx	edx, WORD PTR _k$[ebp]
	movsx	eax, WORD PTR _j$[ebp]
	movsx	esi, WORD PTR _i$[ebp]
	imul	esi, 24					; 00000018H
	mov	edi, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edi+esi+868]
	mov	eax, DWORD PTR [esi+eax*4+16]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4+12]
	mov	edx, DWORD PTR [esi+176]
	call	edx
$LN10@RemoveAllE:

; 261  : 							}
; 262  : 					}

	jmp	$LN12@RemoveAllE
$LN15@RemoveAllE:

; 263  : 				}
; 264  : 		}

	jmp	$LN17@RemoveAllE
$LN19@RemoveAllE:

; 265  : 		if(Team_[i].AirUnits)

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax+864], 0
	je	SHORT $LN9@RemoveAllE

; 266  : 		{
; 267  : 			for(j=0;j<_MAP_NUM_AIR_TYPES_;j++)

	xor	edx, edx
	mov	WORD PTR _j$[ebp], dx
	jmp	SHORT $LN8@RemoveAllE
$LN7@RemoveAllE:
	mov	ax, WORD PTR _j$[ebp]
	add	ax, 1
	mov	WORD PTR _j$[ebp], ax
$LN8@RemoveAllE:
	movsx	ecx, WORD PTR _j$[ebp]
	cmp	ecx, 5
	jge	SHORT $LN9@RemoveAllE

; 268  : 				if(Team_[i].AirUnits->Type[j])

	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+864]
	movsx	edx, WORD PTR _j$[ebp]
	cmp	DWORD PTR [ecx+edx*4+20], 0
	je	SHORT $LN5@RemoveAllE

; 269  : 				{
; 270  : 					Team_[i].AirUnits->Type[j]->Cleanup();

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+864]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+20]
	movsx	edx, WORD PTR _j$[ebp]
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [esi+eax+864]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4+20]
	mov	edx, DWORD PTR [esi+176]
	call	edx
$LN5@RemoveAllE:

; 271  : 				}
; 272  : 		}

	jmp	SHORT $LN7@RemoveAllE
$LN9@RemoveAllE:

; 273  : 		if(Team_[i].Waypoints)

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax+880], 0
	je	SHORT $LN4@RemoveAllE

; 274  : 		{
; 275  : 			Team_[i].Waypoints->Cleanup();

	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+880]
	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx+880]
	mov	edx, DWORD PTR [esi+176]
	call	edx
$LN4@RemoveAllE:

; 276  : 		}
; 277  : 	}

	jmp	$LN36@RemoveAllE
$LN35@RemoveAllE:

; 278  : 	if(CurIcons_)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1116], 0
	je	SHORT $LN3@RemoveAllE

; 279  : 	{
; 280  : 		CurIcons_->Cleanup();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1116]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+1116]
	mov	eax, DWORD PTR [edx+176]
	call	eax
$LN3@RemoveAllE:

; 281  : 	}
; 282  : 	if(CurWP_)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1092], 0
	je	SHORT $LN2@RemoveAllE

; 283  : 	{
; 284  : 		CurWP_->Cleanup();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1092]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+1092]
	mov	eax, DWORD PTR [edx+176]
	call	eax
$LN2@RemoveAllE:

; 285  : 	}
; 286  : 	if(CurWPZ_)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1096], 0
	je	SHORT $LN38@RemoveAllE

; 287  : 	{
; 288  : 		CurWPZ_->Cleanup();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1096]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+1096]
	mov	eax, DWORD PTR [edx+176]
	call	eax
$LN38@RemoveAllE:

; 289  : 	}
; 290  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAllEntities@C_Map@@QAEXXZ ENDP			; C_Map::RemoveAllEntities
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_team$ = 8						; size = 2
_group$ = 12						; size = 4
?RemoveWaypoints@C_Map@@QAEXFJ@Z PROC			; C_Map::RemoveWaypoints
; _this$ = ecx

; 1572 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1573 : 	Team_[team].Waypoints->Refresh();

	movsx	eax, WORD PTR _team$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+880]
	movsx	eax, WORD PTR _team$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax+880]
	mov	eax, DWORD PTR [edx+160]
	call	eax

; 1574 : 	Team_[team].Waypoints->EraseWaypointGroup(group);

	mov	ecx, DWORD PTR _group$[ebp]
	push	ecx
	movsx	edx, WORD PTR _team$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+880]
	call	?EraseWaypointGroup@C_Waypoint@@QAEXJ@Z	; C_Waypoint::EraseWaypointGroup

; 1575 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?RemoveWaypoints@C_Map@@QAEXFJ@Z ENDP			; C_Map::RemoveWaypoints
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_owner$ = 8						; size = 2
?RemoveAllWaypoints@C_Map@@QAEXF@Z PROC			; C_Map::RemoveAllWaypoints
; _this$ = ecx

; 1594 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1595 : 	if ((DrawWindow_) && (Team_[owner].Waypoints))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1124], 0
	je	SHORT $LN2@RemoveAllW
	movsx	ecx, WORD PTR _owner$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+ecx+880], 0
	je	SHORT $LN2@RemoveAllW

; 1596 : 		Team_[owner].Waypoints->EraseWaypointList ();

	movsx	eax, WORD PTR _owner$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+eax+880]
	call	?EraseWaypointList@C_Waypoint@@QAEXXZ	; C_Waypoint::EraseWaypointList
$LN2@RemoveAllW:

; 1597 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?RemoveAllWaypoints@C_Map@@QAEXF@Z ENDP			; C_Map::RemoveAllWaypoints
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?RemoveCurWPList@C_Map@@QAEXXZ PROC			; C_Map::RemoveCurWPList
; _this$ = ecx

; 1561 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1562 : 	CurWP_->Refresh();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1092]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+1092]
	mov	edx, DWORD PTR [eax+160]
	call	edx

; 1563 : 	CurWP_->EraseWaypointList();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1092]
	call	?EraseWaypointList@C_Waypoint@@QAEXXZ	; C_Waypoint::EraseWaypointList

; 1564 : 	CurWPZ_->Refresh();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1096]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+1096]
	mov	eax, DWORD PTR [edx+160]
	call	eax

; 1565 : 	CurWPZ_->EraseWaypointList();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1096]
	call	?EraseWaypointList@C_Waypoint@@QAEXXZ	; C_Waypoint::EraseWaypointList

; 1566 : 	CurIcons_->Cleanup();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1116]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+1116]
	mov	eax, DWORD PTR [edx+176]
	call	eax

; 1567 : 	CurIcons_->Setup(CurIcons_->GetID(),0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1116]
	call	?GetID@C_Base@@QAEJXZ			; C_Base::GetID
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1116]
	call	?Setup@C_DrawList@@QAEXJF@Z		; C_DrawList::Setup

; 1568 : 	WPUnitID_=FalconNullId;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR [eax+1084], ecx
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR [eax+1088], edx

; 1569 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveCurWPList@C_Map@@QAEXXZ ENDP			; C_Map::RemoveCurWPList
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_unit$ = -12						; size = 4
_Leave$ = -8						; size = 4
_this$ = -4						; size = 4
_unitID$ = 8						; size = 8
?SetCurrentWaypointList@C_Map@@QAEHVVU_ID@@@Z PROC	; C_Map::SetCurrentWaypointList
; _this$ = ecx

; 1433 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1434 : 	F4CSECTIONHANDLE *Leave=NULL;

	mov	DWORD PTR _Leave$[ebp], 0

; 1435 : 	Unit unit;
; 1436 : 
; 1437 : 	if(CurWP_->Dragging()) return(FALSE);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1092]
	call	?Dragging@C_Waypoint@@QAEFXZ		; C_Waypoint::Dragging
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN5@SetCurrent
	xor	eax, eax
	jmp	$LN6@SetCurrent
$LN5@SetCurrent:

; 1438 : 	if(CurWPZ_->Dragging()) return(FALSE);

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1096]
	call	?Dragging@C_Waypoint@@QAEFXZ		; C_Waypoint::Dragging
	cwde
	test	eax, eax
	je	SHORT $LN4@SetCurrent
	xor	eax, eax
	jmp	$LN6@SetCurrent
$LN4@SetCurrent:

; 1439 : 
; 1440 : 	CampEnterCriticalSection();

	call	?CampEnterCriticalSection@@YAXXZ	; CampEnterCriticalSection

; 1441 : 
; 1442 : 	if(DrawWindow_)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1124], 0
	je	SHORT $LN3@SetCurrent

; 1443 : 		Leave=UI_Enter(DrawWindow_);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1124]
	push	eax
	call	?UI_Enter@@YAPAUF4CSECTIONHANDLE@@PAVC_Window@@@Z ; UI_Enter
	add	esp, 4
	mov	DWORD PTR _Leave$[ebp], eax
$LN3@SetCurrent:

; 1444 : 	
; 1445 : 	CurWP_->Refresh();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1092]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+1092]
	mov	eax, DWORD PTR [edx+160]
	call	eax

; 1446 : 	CurWPZ_->Refresh();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1096]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+1096]
	mov	eax, DWORD PTR [edx+160]
	call	eax

; 1447 : 
; 1448 : 	CurWP_->EraseWaypointList();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1092]
	call	?EraseWaypointList@C_Waypoint@@QAEXXZ	; C_Waypoint::EraseWaypointList

; 1449 : 	CurWPZ_->EraseWaypointList();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1096]
	call	?EraseWaypointList@C_Waypoint@@QAEXXZ	; C_Waypoint::EraseWaypointList

; 1450 : 
; 1451 : 	CurWPArea_.top=-1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1104], -1

; 1452 : 	CurWPArea_.left=-1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1100], -1

; 1453 : 	CurWPArea_.bottom=-1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1112], -1

; 1454 : 	CurWPArea_.right=-1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1108], -1

; 1455 : 
; 1456 : 	WPUnitID_=unitID;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _unitID$[ebp]
	mov	DWORD PTR [ecx+1084], edx
	mov	eax, DWORD PTR _unitID$[ebp+4]
	mov	DWORD PTR [ecx+1088], eax

; 1457 : 	gActiveFlightID=unitID;

	mov	ecx, DWORD PTR _unitID$[ebp]
	mov	DWORD PTR ?gActiveFlightID@@3VVU_ID@@A, ecx
	mov	edx, DWORD PTR _unitID$[ebp+4]
	mov	DWORD PTR ?gActiveFlightID@@3VVU_ID@@A+4, edx

; 1458 : 
; 1459 : 	if(unitID == FalconNullId)

	push	OFFSET ?FalconNullId@@3VVU_ID@@A	; FalconNullId
	lea	ecx, DWORD PTR _unitID$[ebp]
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@SetCurrent

; 1460 : 	{
; 1461 : 		UI_Leave(Leave);

	mov	ecx, DWORD PTR _Leave$[ebp]
	push	ecx
	call	?UI_Leave@@YAXPAUF4CSECTIONHANDLE@@@Z	; UI_Leave
	add	esp, 4

; 1462 : 		CampLeaveCriticalSection();

	call	?CampLeaveCriticalSection@@YAXXZ	; CampLeaveCriticalSection

; 1463 : 		return(FALSE);

	xor	eax, eax
	jmp	SHORT $LN6@SetCurrent
$LN2@SetCurrent:

; 1464 : 	}
; 1465 : 
; 1466 : 	unit=(Unit)FindUnit(unitID);

	mov	edx, DWORD PTR _unitID$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _unitID$[ebp]
	push	eax
	call	?FindUnit@@YAPAVUnitClass@@VVU_ID@@@Z	; FindUnit
	add	esp, 8
	mov	DWORD PTR _unit$[ebp], eax

; 1467 : 	if(unit == NULL)

	cmp	DWORD PTR _unit$[ebp], 0
	jne	SHORT $LN1@SetCurrent

; 1468 : 	{
; 1469 : 		UI_Leave(Leave);

	mov	ecx, DWORD PTR _Leave$[ebp]
	push	ecx
	call	?UI_Leave@@YAXPAUF4CSECTIONHANDLE@@@Z	; UI_Leave
	add	esp, 4

; 1470 : 		CampLeaveCriticalSection();

	call	?CampLeaveCriticalSection@@YAXXZ	; CampLeaveCriticalSection

; 1471 : 		return(FALSE);

	xor	eax, eax
	jmp	SHORT $LN6@SetCurrent
$LN1@SetCurrent:

; 1472 : 	}
; 1473 : 
; 1474 : 	BuildCurrentWPList(unit);

	mov	edx, DWORD PTR _unit$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuildCurrentWPList@C_Map@@AAEXPAVUnitClass@@@Z ; C_Map::BuildCurrentWPList

; 1475 : 	flags_ |= I_NEED_TO_DRAW;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+736]
	or	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+736], ecx

; 1476 : 	UI_Leave(Leave);

	mov	eax, DWORD PTR _Leave$[ebp]
	push	eax
	call	?UI_Leave@@YAXPAUF4CSECTIONHANDLE@@@Z	; UI_Leave
	add	esp, 4

; 1477 : 	CampLeaveCriticalSection();

	call	?CampLeaveCriticalSection@@YAXXZ	; CampLeaveCriticalSection

; 1478 : 	return(TRUE);

	mov	eax, 1
$LN6@SetCurrent:

; 1479 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetCurrentWaypointList@C_Map@@QAEHVVU_ID@@@Z ENDP	; C_Map::SetCurrentWaypointList
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_Leave$ = -16						; size = 4
tv170 = -12						; size = 4
_this$ = -8						; size = 4
_unit$ = -4						; size = 4
_unitID$ = 8						; size = 8
?SetWaypointList@C_Map@@QAEHVVU_ID@@@Z PROC		; C_Map::SetWaypointList
; _this$ = ecx

; 1411 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1412 : 	F4CSECTIONHANDLE *Leave=NULL;

	mov	DWORD PTR _Leave$[ebp], 0

; 1413 : 	Unit unit;
; 1414 : 
; 1415 : 	if(unitID == FalconNullId)

	push	OFFSET ?FalconNullId@@3VVU_ID@@A	; FalconNullId
	lea	ecx, DWORD PTR _unitID$[ebp]
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@SetWaypoin

; 1416 : 		return(FALSE);

	xor	eax, eax
	jmp	$LN4@SetWaypoin
$LN3@SetWaypoin:

; 1417 : 
; 1418 : 	unit=(Unit)FindUnit(unitID);

	mov	ecx, DWORD PTR _unitID$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _unitID$[ebp]
	push	edx
	call	?FindUnit@@YAPAVUnitClass@@VVU_ID@@@Z	; FindUnit
	add	esp, 8
	mov	DWORD PTR _unit$[ebp], eax

; 1419 : 	if(unit == NULL) return(FALSE);

	cmp	DWORD PTR _unit$[ebp], 0
	jne	SHORT $LN2@SetWaypoin
	xor	eax, eax
	jmp	$LN4@SetWaypoin
$LN2@SetWaypoin:

; 1420 : 
; 1421 : 	if(DrawWindow_)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1124], 0
	je	SHORT $LN1@SetWaypoin

; 1422 : 		Leave=UI_Enter(DrawWindow_);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1124]
	push	edx
	call	?UI_Enter@@YAPAUF4CSECTIONHANDLE@@PAVC_Window@@@Z ; UI_Enter
	add	esp, 4
	mov	DWORD PTR _Leave$[ebp], eax
$LN1@SetWaypoin:

; 1423 : 	Team_[unit->GetTeam()].Waypoints->EraseWaypointGroup(unit->GetCampID() << 8);

	mov	eax, DWORD PTR _unit$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _unit$[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax
	movsx	ecx, ax
	shl	ecx, 8
	push	ecx
	mov	edx, DWORD PTR _unit$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _unit$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	movzx	eax, al
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+eax+880]
	call	?EraseWaypointGroup@C_Waypoint@@QAEXJ@Z	; C_Waypoint::EraseWaypointGroup

; 1424 : 	CampEnterCriticalSection();

	call	?CampEnterCriticalSection@@YAXXZ	; CampEnterCriticalSection

; 1425 : 	BuildWPList(Team_[unit->GetTeam()].Waypoints,NULL,unit);

	mov	edx, DWORD PTR _unit$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _unit$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _unit$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+880]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuildWPList@C_Map@@AAEXPAVC_Waypoint@@0PAVUnitClass@@@Z ; C_Map::BuildWPList

; 1426 : 	CampLeaveCriticalSection();

	call	?CampLeaveCriticalSection@@YAXXZ	; CampLeaveCriticalSection

; 1427 : 	Team_[unit->GetTeam()].Waypoints->Refresh();

	mov	ecx, DWORD PTR _unit$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _unit$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+880]
	mov	DWORD PTR tv170[ebp], eax
	mov	ecx, DWORD PTR tv170[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv170[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax

; 1428 : 	UI_Leave(Leave);

	mov	ecx, DWORD PTR _Leave$[ebp]
	push	ecx
	call	?UI_Leave@@YAXPAUF4CSECTIONHANDLE@@@Z	; UI_Leave
	add	esp, 4

; 1429 : 	return(TRUE);

	mov	eax, 1
$LN4@SetWaypoin:

; 1430 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetWaypointList@C_Map@@QAEHVVU_ID@@@Z ENDP		; C_Map::SetWaypointList
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_distance$ = -8						; size = 4
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?MoveCenter@C_Map@@QAEXJJ@Z PROC			; C_Map::MoveCenter
; _this$ = ecx

; 2199 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 2200 : 	float distance;
; 2201 : 	if(Map_ == NULL || DrawWindow_ == NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+808], 0
	je	SHORT $LN6@MoveCenter
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1124], 0
	jne	SHORT $LN7@MoveCenter
$LN6@MoveCenter:

; 2202 : 		return;

	jmp	$LN8@MoveCenter
$LN7@MoveCenter:

; 2203 : 
; 2204 : 	if(!x && !y)

	cmp	DWORD PTR _x$[ebp], 0
	jne	SHORT $LN5@MoveCenter
	cmp	DWORD PTR _y$[ebp], 0
	jne	SHORT $LN5@MoveCenter

; 2205 : 		return;

	jmp	$LN8@MoveCenter
$LN5@MoveCenter:

; 2206 : 
; 2207 : 	distance=(float)(MapRect_.right-MapRect_.left)/(DrawWindow_->ClientArea_[0].right-DrawWindow_->ClientArea_[0].left);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+820]
	sub	ecx, DWORD PTR [eax+812]
	cvtsi2ss xmm0, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1124]
	mov	ecx, 16					; 00000010H
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+1124]
	mov	esi, 16					; 00000010H
	imul	esi, 0
	mov	eax, DWORD PTR [eax+ecx+176]
	sub	eax, DWORD PTR [edx+esi+168]
	cvtsi2ss xmm1, eax
	divss	xmm0, xmm1
	movss	DWORD PTR _distance$[ebp], xmm0

; 2208 : 
; 2209 : 	CenterX_+= (float)x*distance;

	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	mulss	xmm0, DWORD PTR _distance$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+704]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+704], xmm0

; 2210 : 	CenterY_+= (float)y*distance;

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	mulss	xmm0, DWORD PTR _distance$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+708]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+708], xmm0

; 2211 : 
; 2212 : 	if(CenterX_ < 0) CenterX_=0;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [edx+704]
	jbe	SHORT $LN4@MoveCenter
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+704], xmm0
$LN4@MoveCenter:

; 2213 : 	if(CenterX_ >= Map_->GetW()) CenterX_=Map_->GetW()-1.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+808]
	call	?GetW@C_Base@@QAEJXZ			; C_Base::GetW
	cvtsi2ss xmm0, eax
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+704]
	comiss	xmm1, xmm0
	jb	SHORT $LN3@MoveCenter
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	call	?GetW@C_Base@@QAEJXZ			; C_Base::GetW
	cvtsi2ss xmm0, eax
	subss	xmm0, DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+704], xmm0
$LN3@MoveCenter:

; 2214 : 	if(CenterY_ < 0) CenterY_=0;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [edx+708]
	jbe	SHORT $LN2@MoveCenter
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+708], xmm0
$LN2@MoveCenter:

; 2215 : 	if(CenterY_ >= Map_->GetH()) CenterY_=Map_->GetH()-1.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+808]
	call	?GetH@C_Base@@QAEJXZ			; C_Base::GetH
	cvtsi2ss xmm0, eax
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+708]
	comiss	xmm1, xmm0
	jb	SHORT $LN1@MoveCenter
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	call	?GetH@C_Base@@QAEJXZ			; C_Base::GetH
	cvtsi2ss xmm0, eax
	subss	xmm0, DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+708], xmm0
$LN1@MoveCenter:

; 2216 : 
; 2217 : 	CalculateDrawingParams();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateDrawingParams@C_Map@@AAEXXZ	; C_Map::CalculateDrawingParams
$LN8@MoveCenter:

; 2218 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?MoveCenter@C_Map@@QAEXJJ@Z ENDP			; C_Map::MoveCenter
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_my$ = -20						; size = 4
_mx$ = -16						; size = 4
tv89 = -12						; size = 4
tv78 = -8						; size = 4
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?SetMapCenter@C_Map@@QAEXJJ@Z PROC			; C_Map::SetMapCenter
; _this$ = ecx

; 2185 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 2186 : 	CenterX_=static_cast<float>(x);

	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+704], xmm0

; 2187 : 	CenterY_=static_cast<float>(y);

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+708], xmm0

; 2188 : 
; 2189 : 	float mx = Map_ ? Map_->GetW() : 2048.0F;

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+808], 0
	je	SHORT $LN7@SetMapCent
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	call	?GetW@C_Base@@QAEJXZ			; C_Base::GetW
	cvtsi2ss xmm0, eax
	movss	DWORD PTR tv78[ebp], xmm0
	jmp	SHORT $LN8@SetMapCent
$LN7@SetMapCent:
	movss	xmm0, DWORD PTR __real@45000000
	movss	DWORD PTR tv78[ebp], xmm0
$LN8@SetMapCent:
	movss	xmm0, DWORD PTR tv78[ebp]
	movss	DWORD PTR _mx$[ebp], xmm0

; 2190 : 	float my = Map_ ? Map_->GetH() : 2048.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+808], 0
	je	SHORT $LN9@SetMapCent
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+808]
	call	?GetH@C_Base@@QAEJXZ			; C_Base::GetH
	cvtsi2ss xmm0, eax
	movss	DWORD PTR tv89[ebp], xmm0
	jmp	SHORT $LN10@SetMapCent
$LN9@SetMapCent:
	movss	xmm0, DWORD PTR __real@45000000
	movss	DWORD PTR tv89[ebp], xmm0
$LN10@SetMapCent:
	movss	xmm0, DWORD PTR tv89[ebp]
	movss	DWORD PTR _my$[ebp], xmm0

; 2191 : 	if(CenterX_ < 0) CenterX_=0;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [eax+704]
	jbe	SHORT $LN4@SetMapCent
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+704], xmm0
$LN4@SetMapCent:

; 2192 : 	if(CenterX_ >= mx) CenterX_=mx -1;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+704]
	comiss	xmm0, DWORD PTR _mx$[ebp]
	jb	SHORT $LN3@SetMapCent
	movss	xmm0, DWORD PTR _mx$[ebp]
	subss	xmm0, DWORD PTR __real@3f800000
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+704], xmm0
$LN3@SetMapCent:

; 2193 : 	if(CenterY_ < 0) CenterY_=0;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [ecx+708]
	jbe	SHORT $LN2@SetMapCent
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+708], xmm0
$LN2@SetMapCent:

; 2194 : 	if(CenterY_ >= my) CenterY_=my - 1;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+708]
	comiss	xmm0, DWORD PTR _my$[ebp]
	jb	SHORT $LN1@SetMapCent
	movss	xmm0, DWORD PTR _my$[ebp]
	subss	xmm0, DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+708], xmm0
$LN1@SetMapCent:

; 2195 : 	CalculateDrawingParams();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateDrawingParams@C_Map@@AAEXXZ	; C_Map::CalculateDrawingParams

; 2196 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetMapCenter@C_Map@@QAEXJJ@Z ENDP			; C_Map::SetMapCenter
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_Leave$ = -20						; size = 4
_offflag$ = -16						; size = 4
_this$ = -12						; size = 4
_i$ = -8						; size = 2
_j$ = -4						; size = 2
_mask$ = 8						; size = 4
?HideThreatType@C_Map@@QAEXJ@Z PROC			; C_Map::HideThreatType
; _this$ = ecx

; 2062 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 2063 : 	short i,j;
; 2064 : 	long offflag;
; 2065 : 	F4CSECTIONHANDLE *Leave;
; 2066 : 
; 2067 : 	offflag = (1 << FindTypeIndex(mask,THR_TypeList,_MAP_NUM_THREAT_TYPES_));

	push	4
	push	OFFSET ?THR_TypeList@@3PAJA		; THR_TypeList
	mov	eax, DWORD PTR _mask$[ebp]
	push	eax
	call	?FindTypeIndex@@YAJJQAJH@Z		; FindTypeIndex
	add	esp, 12					; 0000000cH
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	mov	DWORD PTR _offflag$[ebp], edx

; 2068 : 
; 2069 : 	Leave=UI_Enter(DrawWindow_);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1124]
	push	ecx
	call	?UI_Enter@@YAPAUF4CSECTIONHANDLE@@PAVC_Window@@@Z ; UI_Enter
	add	esp, 4
	mov	DWORD PTR _Leave$[ebp], eax

; 2070 : 	for(i=0;i<_MAX_TEAMS_;i++)

	xor	edx, edx
	mov	WORD PTR _i$[ebp], dx
	jmp	SHORT $LN8@HideThreat
$LN7@HideThreat:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
$LN8@HideThreat:
	movsx	ecx, WORD PTR _i$[ebp]
	cmp	ecx, 8
	jge	$LN6@HideThreat

; 2071 : 		if(Team_[i].Threats)

	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+edx+860], 0
	je	$LN5@HideThreat

; 2072 : 		{
; 2073 : 			for(j=0;j<_MAP_NUM_THREAT_TYPES_;j++)

	xor	ecx, ecx
	mov	WORD PTR _j$[ebp], cx
	jmp	SHORT $LN4@HideThreat
$LN3@HideThreat:
	mov	dx, WORD PTR _j$[ebp]
	add	dx, 1
	mov	WORD PTR _j$[ebp], dx
$LN4@HideThreat:
	movsx	eax, WORD PTR _j$[ebp]
	cmp	eax, 4
	jge	$LN5@HideThreat

; 2074 : 				if(Team_[i].Threats->Flags[j] && (offflag & (1 << j)))

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+860]
	movsx	ecx, WORD PTR _j$[ebp]
	cmp	DWORD PTR [eax+ecx*4], 0
	je	$LN1@HideThreat
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, 1
	shl	edx, cl
	and	edx, DWORD PTR _offflag$[ebp]
	je	$LN1@HideThreat

; 2075 : 				{
; 2076 : 					Team_[i].Threats->Type[j]->Refresh();

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+860]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+16]
	movsx	edx, WORD PTR _j$[ebp]
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [esi+eax+860]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4+16]
	mov	edx, DWORD PTR [esi+160]
	call	edx

; 2077 : 					Team_[i].Threats->Flags[j]=0;

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+860]
	movsx	eax, WORD PTR _j$[ebp]
	mov	DWORD PTR [edx+eax*4], 0

; 2078 : 					Team_[i].Threats->Type[j]->SetFlagBitOn(C_BIT_INVISIBLE);

	push	8192					; 00002000H
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+860]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+16]
	movsx	eax, WORD PTR _j$[ebp]
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+860]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4+16]
	mov	eax, DWORD PTR [edx+8]
	call	eax
$LN1@HideThreat:

; 2079 : 				}
; 2080 : 		}

	jmp	$LN3@HideThreat
$LN5@HideThreat:
	jmp	$LN7@HideThreat
$LN6@HideThreat:

; 2081 : 	ThreatMask_ &= ~offflag;

	mov	ecx, DWORD PTR _offflag$[ebp]
	not	ecx
	mov	edx, DWORD PTR _this$[ebp]
	and	ecx, DWORD PTR [edx+800]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+800], ecx

; 2082 : 
; 2083 : 	Map_->NoOverlay();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+808]
	call	?NoOverlay@C_ScaleBitmap@@QAEXXZ	; C_ScaleBitmap::NoOverlay

; 2084 : #if 0
; 2085 : 	Circles_=ThreatMask_;
; 2086 : 	for(i=0;i<_MAX_TEAMS_;i++)
; 2087 : 		for(j=0;j<_MAP_NUM_GND_TYPES_;j++)
; 2088 : 			Team_[i].Units->Type[j]->Levels[2]->ShowCircles(Circles_);
; 2089 : #endif
; 2090 : 	flags_ |= I_NEED_TO_DRAW_MAP;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+736]
	or	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+736], eax

; 2091 : 	UI_Leave(Leave);

	mov	edx, DWORD PTR _Leave$[ebp]
	push	edx
	call	?UI_Leave@@YAXPAUF4CSECTIONHANDLE@@@Z	; UI_Leave
	add	esp, 4

; 2092 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?HideThreatType@C_Map@@QAEXJ@Z ENDP			; C_Map::HideThreatType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_Leave$ = -20						; size = 4
_timestamp$ = -16					; size = 4
_this$ = -12						; size = 4
_j$ = -8						; size = 2
_i$ = -4						; size = 2
_mask$ = 8						; size = 4
?ShowThreatType@C_Map@@QAEXJ@Z PROC			; C_Map::ShowThreatType
; _this$ = ecx

; 1970 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1971 : 	short i,j;
; 1972 : 	long timestamp;
; 1973 : 	F4CSECTIONHANDLE *Leave;
; 1974 : 
; 1975 : 	ThreatMask_ = (1 << FindTypeIndex(mask,THR_TypeList,_MAP_NUM_THREAT_TYPES_));

	push	4
	push	OFFSET ?THR_TypeList@@3PAJA		; THR_TypeList
	mov	eax, DWORD PTR _mask$[ebp]
	push	eax
	call	?FindTypeIndex@@YAJJQAJH@Z		; FindTypeIndex
	add	esp, 12					; 0000000cH
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+800], edx

; 1976 : 
; 1977 : 	timestamp=GetCurrentTime();

	call	DWORD PTR __imp__GetTickCount@0
	mov	DWORD PTR _timestamp$[ebp], eax

; 1978 : 	MonoPrint("Start at %1ld...",timestamp);

	mov	ecx, DWORD PTR _timestamp$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BB@IPEEPKNC@Start?5at?5?$CF1ld?4?4?4?$AA@
	call	_MonoPrint
	add	esp, 8

; 1979 : 	Leave=UI_Enter(DrawWindow_);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1124]
	push	eax
	call	?UI_Enter@@YAPAUF4CSECTIONHANDLE@@PAVC_Window@@@Z ; UI_Enter
	add	esp, 4
	mov	DWORD PTR _Leave$[ebp], eax

; 1980 : 	for(i=0;i<_MAX_TEAMS_;i++)

	xor	ecx, ecx
	mov	WORD PTR _i$[ebp], cx
	jmp	SHORT $LN35@ShowThreat
$LN34@ShowThreat:
	mov	dx, WORD PTR _i$[ebp]
	add	dx, 1
	mov	WORD PTR _i$[ebp], dx
$LN35@ShowThreat:
	movsx	eax, WORD PTR _i$[ebp]
	cmp	eax, 8
	jge	$LN33@ShowThreat

; 1981 : 		if(Team_[i].Threats)

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+ecx+860], 0
	je	$LN29@ShowThreat

; 1982 : 		{
; 1983 : 			for(j=0;j<_MAP_NUM_THREAT_TYPES_;j++)

	xor	eax, eax
	mov	WORD PTR _j$[ebp], ax
	jmp	SHORT $LN31@ShowThreat
$LN30@ShowThreat:
	mov	cx, WORD PTR _j$[ebp]
	add	cx, 1
	mov	WORD PTR _j$[ebp], cx
$LN31@ShowThreat:
	movsx	edx, WORD PTR _j$[ebp]
	cmp	edx, 4
	jge	$LN29@ShowThreat

; 1984 : 				if(!Team_[i].Threats->Flags[j] && (ThreatMask_ & (1 << j)))

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+860]
	movsx	eax, WORD PTR _j$[ebp]
	cmp	DWORD PTR [edx+eax*4], 0
	jne	$LN28@ShowThreat
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, 1
	shl	edx, cl
	mov	eax, DWORD PTR _this$[ebp]
	and	edx, DWORD PTR [eax+800]
	je	$LN28@ShowThreat

; 1985 : 				{
; 1986 : 					Team_[i].Threats->Flags[j]=1;

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+860]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	DWORD PTR [eax+ecx*4], 1

; 1987 : 					Team_[i].Threats->Type[j]->SetFlagBitOff(C_BIT_INVISIBLE);

	push	8192					; 00002000H
	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+860]
	movsx	edx, WORD PTR _j$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+16]
	movsx	ecx, WORD PTR _j$[ebp]
	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [esi+edx+860]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4+16]
	mov	edx, DWORD PTR [eax+12]
	call	edx

; 1988 : 					Team_[i].Threats->Type[j]->Refresh();

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+860]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+16]
	movsx	edx, WORD PTR _j$[ebp]
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [esi+eax+860]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4+16]
	mov	edx, DWORD PTR [esi+160]
	call	edx
$LN28@ShowThreat:

; 1989 : 				}
; 1990 : 		}

	jmp	$LN30@ShowThreat
$LN29@ShowThreat:
	jmp	$LN34@ShowThreat
$LN33@ShowThreat:

; 1991 : 
; 1992 : 	if(ThreatMask_ & _THR_SAM_LOW)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+800]
	and	ecx, 1
	je	$LN27@ShowThreat

; 1993 : 	{
; 1994 : 		Map_->PreparePalette(0x0000ff);

	push	255					; 000000ffH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+808]
	call	?PreparePalette@C_ScaleBitmap@@QAEXK@Z	; C_ScaleBitmap::PreparePalette

; 1995 : 		Map_->ClearOverlay();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	call	?ClearOverlay@C_ScaleBitmap@@QAEXXZ	; C_ScaleBitmap::ClearOverlay

; 1996 : 		for(i=0;i<_MAX_TEAMS_;i++)

	xor	ecx, ecx
	mov	WORD PTR _i$[ebp], cx
	jmp	SHORT $LN26@ShowThreat
$LN25@ShowThreat:
	mov	dx, WORD PTR _i$[ebp]
	add	dx, 1
	mov	WORD PTR _i$[ebp], dx
$LN26@ShowThreat:
	movsx	eax, WORD PTR _i$[ebp]
	cmp	eax, 8
	jge	$LN24@ShowThreat

; 1997 : 			if(Team_[i].Threats)

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+ecx+860], 0
	je	SHORT $LN22@ShowThreat

; 1998 : 			{
; 1999 : 				if(Team_[i].Threats->Flags[_THREAT_SAM_LOW_])

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+860]
	mov	eax, 4
	imul	eax, 0
	cmp	DWORD PTR [edx+eax], 0
	je	SHORT $LN22@ShowThreat

; 2000 : 				{
; 2001 : 					Team_[i].Threats->Type[_THREAT_SAM_LOW_]->BuildOverlay(Map_->GetOverlay(),Map_->GetW(),Map_->GetH(),2);

	push	ecx
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+808]
	call	?GetH@C_Base@@QAEJXZ			; C_Base::GetH
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+808]
	call	?GetW@C_Base@@QAEJXZ			; C_Base::GetW
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	call	?GetOverlay@C_ScaleBitmap@@QAEPAEXZ	; C_ScaleBitmap::GetOverlay
	push	eax
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+860]
	mov	ecx, 4
	imul	ecx, 0
	mov	ecx, DWORD PTR [eax+ecx+16]
	call	?BuildOverlay@C_Threat@@QAEXPAEJJM@Z	; C_Threat::BuildOverlay
$LN22@ShowThreat:

; 2002 : 				}
; 2003 : 			}

	jmp	$LN25@ShowThreat
$LN24@ShowThreat:

; 2004 : 		Map_->UseOverlay();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+808]
	call	?UseOverlay@C_ScaleBitmap@@QAEXXZ	; C_ScaleBitmap::UseOverlay
	jmp	$LN6@ShowThreat
$LN27@ShowThreat:

; 2005 : 	}
; 2006 : 	else if(ThreatMask_ & _THR_SAM_HIGH)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+800]
	and	ecx, 2
	je	$LN20@ShowThreat

; 2007 : 	{
; 2008 : 		Map_->PreparePalette(0x00ffff);

	push	65535					; 0000ffffH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+808]
	call	?PreparePalette@C_ScaleBitmap@@QAEXK@Z	; C_ScaleBitmap::PreparePalette

; 2009 : 		Map_->ClearOverlay();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	call	?ClearOverlay@C_ScaleBitmap@@QAEXXZ	; C_ScaleBitmap::ClearOverlay

; 2010 : 		for(i=0;i<_MAX_TEAMS_;i++)

	xor	ecx, ecx
	mov	WORD PTR _i$[ebp], cx
	jmp	SHORT $LN19@ShowThreat
$LN18@ShowThreat:
	mov	dx, WORD PTR _i$[ebp]
	add	dx, 1
	mov	WORD PTR _i$[ebp], dx
$LN19@ShowThreat:
	movsx	eax, WORD PTR _i$[ebp]
	cmp	eax, 8
	jge	$LN17@ShowThreat

; 2011 : 			if(Team_[i].Threats)

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+ecx+860], 0
	je	SHORT $LN15@ShowThreat

; 2012 : 			{
; 2013 : 				if(Team_[i].Threats->Flags[_THREAT_SAM_HIGH_])

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+860]
	mov	eax, 4
	shl	eax, 0
	cmp	DWORD PTR [edx+eax], 0
	je	SHORT $LN15@ShowThreat

; 2014 : 				{
; 2015 : 					Team_[i].Threats->Type[_THREAT_SAM_HIGH_]->BuildOverlay(Map_->GetOverlay(),Map_->GetW(),Map_->GetH(),2);

	push	ecx
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+808]
	call	?GetH@C_Base@@QAEJXZ			; C_Base::GetH
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+808]
	call	?GetW@C_Base@@QAEJXZ			; C_Base::GetW
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	call	?GetOverlay@C_ScaleBitmap@@QAEPAEXZ	; C_ScaleBitmap::GetOverlay
	push	eax
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+860]
	mov	ecx, 4
	shl	ecx, 0
	mov	ecx, DWORD PTR [eax+ecx+16]
	call	?BuildOverlay@C_Threat@@QAEXPAEJJM@Z	; C_Threat::BuildOverlay
$LN15@ShowThreat:

; 2016 : 				}
; 2017 : 			}

	jmp	$LN18@ShowThreat
$LN17@ShowThreat:

; 2018 : 		Map_->UseOverlay();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+808]
	call	?UseOverlay@C_ScaleBitmap@@QAEXXZ	; C_ScaleBitmap::UseOverlay
	jmp	$LN6@ShowThreat
$LN20@ShowThreat:

; 2019 : 	}
; 2020 : 	else if(ThreatMask_ & _THR_RADAR_LOW)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+800]
	and	ecx, 4
	je	$LN13@ShowThreat

; 2021 : 	{
; 2022 : 		Map_->PreparePalette(0xffff00);

	push	16776960				; 00ffff00H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+808]
	call	?PreparePalette@C_ScaleBitmap@@QAEXK@Z	; C_ScaleBitmap::PreparePalette

; 2023 : 		Map_->ClearOverlay();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	call	?ClearOverlay@C_ScaleBitmap@@QAEXXZ	; C_ScaleBitmap::ClearOverlay

; 2024 : 		for(i=0;i<_MAX_TEAMS_;i++)

	xor	ecx, ecx
	mov	WORD PTR _i$[ebp], cx
	jmp	SHORT $LN12@ShowThreat
$LN11@ShowThreat:
	mov	dx, WORD PTR _i$[ebp]
	add	dx, 1
	mov	WORD PTR _i$[ebp], dx
$LN12@ShowThreat:
	movsx	eax, WORD PTR _i$[ebp]
	cmp	eax, 8
	jge	$LN10@ShowThreat

; 2025 : 			if(Team_[i].Threats)

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+ecx+860], 0
	je	SHORT $LN8@ShowThreat

; 2026 : 			{
; 2027 : 				if(Team_[i].Threats->Flags[_THREAT_RADAR_LOW_])

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+860]
	mov	eax, 4
	shl	eax, 1
	cmp	DWORD PTR [edx+eax], 0
	je	SHORT $LN8@ShowThreat

; 2028 : 				{
; 2029 : 					Team_[i].Threats->Type[_THREAT_RADAR_LOW_]->BuildOverlay(Map_->GetOverlay(),Map_->GetW(),Map_->GetH(),2);

	push	ecx
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+808]
	call	?GetH@C_Base@@QAEJXZ			; C_Base::GetH
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+808]
	call	?GetW@C_Base@@QAEJXZ			; C_Base::GetW
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	call	?GetOverlay@C_ScaleBitmap@@QAEPAEXZ	; C_ScaleBitmap::GetOverlay
	push	eax
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+860]
	mov	ecx, 4
	shl	ecx, 1
	mov	ecx, DWORD PTR [eax+ecx+16]
	call	?BuildOverlay@C_Threat@@QAEXPAEJJM@Z	; C_Threat::BuildOverlay
$LN8@ShowThreat:

; 2030 : 				}
; 2031 : 			}

	jmp	$LN11@ShowThreat
$LN10@ShowThreat:

; 2032 : 		Map_->UseOverlay();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+808]
	call	?UseOverlay@C_ScaleBitmap@@QAEXXZ	; C_ScaleBitmap::UseOverlay
	jmp	$LN6@ShowThreat
$LN13@ShowThreat:

; 2033 : 	}
; 2034 : 	else if(ThreatMask_ & _THR_RADAR_HIGH)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+800]
	and	ecx, 8
	je	$LN6@ShowThreat

; 2035 : 	{
; 2036 : 		Map_->PreparePalette(0xff0000);

	push	16711680				; 00ff0000H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+808]
	call	?PreparePalette@C_ScaleBitmap@@QAEXK@Z	; C_ScaleBitmap::PreparePalette

; 2037 : 		Map_->ClearOverlay();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	call	?ClearOverlay@C_ScaleBitmap@@QAEXXZ	; C_ScaleBitmap::ClearOverlay

; 2038 : 		for(i=0;i<_MAX_TEAMS_;i++)

	xor	ecx, ecx
	mov	WORD PTR _i$[ebp], cx
	jmp	SHORT $LN5@ShowThreat
$LN4@ShowThreat:
	mov	dx, WORD PTR _i$[ebp]
	add	dx, 1
	mov	WORD PTR _i$[ebp], dx
$LN5@ShowThreat:
	movsx	eax, WORD PTR _i$[ebp]
	cmp	eax, 8
	jge	$LN3@ShowThreat

; 2039 : 			if(Team_[i].Threats)

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+ecx+860], 0
	je	SHORT $LN1@ShowThreat

; 2040 : 			{
; 2041 : 				if(Team_[i].Threats->Flags[_THREAT_RADAR_HIGH_])

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+860]
	mov	eax, 4
	imul	eax, 3
	cmp	DWORD PTR [edx+eax], 0
	je	SHORT $LN1@ShowThreat

; 2042 : 				{
; 2043 : 					Team_[i].Threats->Type[_THREAT_RADAR_HIGH_]->BuildOverlay(Map_->GetOverlay(),Map_->GetW(),Map_->GetH(),2);

	push	ecx
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+808]
	call	?GetH@C_Base@@QAEJXZ			; C_Base::GetH
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+808]
	call	?GetW@C_Base@@QAEJXZ			; C_Base::GetW
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	call	?GetOverlay@C_ScaleBitmap@@QAEPAEXZ	; C_ScaleBitmap::GetOverlay
	push	eax
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+860]
	mov	ecx, 4
	imul	ecx, 3
	mov	ecx, DWORD PTR [eax+ecx+16]
	call	?BuildOverlay@C_Threat@@QAEXPAEJJM@Z	; C_Threat::BuildOverlay
$LN1@ShowThreat:

; 2044 : 				}
; 2045 : 			}

	jmp	$LN4@ShowThreat
$LN3@ShowThreat:

; 2046 : 		Map_->UseOverlay();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+808]
	call	?UseOverlay@C_ScaleBitmap@@QAEXXZ	; C_ScaleBitmap::UseOverlay
$LN6@ShowThreat:

; 2047 : 	}
; 2048 : 
; 2049 : 	timestamp=GetCurrentTime() - timestamp;

	call	DWORD PTR __imp__GetTickCount@0
	sub	eax, DWORD PTR _timestamp$[ebp]
	mov	DWORD PTR _timestamp$[ebp], eax

; 2050 : 	MonoPrint("Total time=%1ld\n",timestamp);

	mov	eax, DWORD PTR _timestamp$[ebp]
	push	eax
	push	OFFSET ??_C@_0BB@DJFFJCHP@Total?5time?$DN?$CF1ld?6?$AA@
	call	_MonoPrint
	add	esp, 8

; 2051 : #if 0
; 2052 : 	Circles_=ThreatMask_;
; 2053 : 	for(i=0;i<_MAX_TEAMS_;i++)
; 2054 : 		for(j=0;j<_MAP_NUM_GND_TYPES_;j++)
; 2055 : 			Team_[i].Units->Type[j]->Levels[2]->ShowCircles(Circles_);
; 2056 : #endif
; 2057 : 	flags_ |= I_NEED_TO_DRAW_MAP;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+736]
	or	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+736], edx

; 2058 : 	UI_Leave(Leave);

	mov	ecx, DWORD PTR _Leave$[ebp]
	push	ecx
	call	?UI_Leave@@YAXPAUF4CSECTIONHANDLE@@@Z	; UI_Leave
	add	esp, 4

; 2059 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?ShowThreatType@C_Map@@QAEXJ@Z ENDP			; C_Map::ShowThreatType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_Leave$ = -20						; size = 4
_offflag$ = -16						; size = 4
_this$ = -12						; size = 4
_i$ = -8						; size = 2
_j$ = -4						; size = 2
_mask$ = 8						; size = 4
?HideNavalUnitType@C_Map@@QAEXJ@Z PROC			; C_Map::HideNavalUnitType
; _this$ = ecx

; 1946 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1947 : 	short i,j;
; 1948 : 	long offflag;
; 1949 : 	F4CSECTIONHANDLE *Leave;
; 1950 : 
; 1951 : 	offflag = (1 << FindTypeIndex(mask,NAV_TypeList,_MAP_NUM_NAV_TYPES_));

	push	2
	push	OFFSET ?NAV_TypeList@@3PAJA		; NAV_TypeList
	mov	eax, DWORD PTR _mask$[ebp]
	push	eax
	call	?FindTypeIndex@@YAJJQAJH@Z		; FindTypeIndex
	add	esp, 12					; 0000000cH
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	mov	DWORD PTR _offflag$[ebp], edx

; 1952 : 
; 1953 : 	Leave=UI_Enter(DrawWindow_);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1124]
	push	ecx
	call	?UI_Enter@@YAPAUF4CSECTIONHANDLE@@PAVC_Window@@@Z ; UI_Enter
	add	esp, 4
	mov	DWORD PTR _Leave$[ebp], eax

; 1954 : 	for(i=0;i<_MAX_TEAMS_;i++)

	xor	edx, edx
	mov	WORD PTR _i$[ebp], dx
	jmp	SHORT $LN8@HideNavalU
$LN7@HideNavalU:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
$LN8@HideNavalU:
	movsx	ecx, WORD PTR _i$[ebp]
	cmp	ecx, 8
	jge	$LN6@HideNavalU

; 1955 : 		if(Team_[i].NavalUnits)

	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+edx+872], 0
	je	$LN5@HideNavalU

; 1956 : 		{
; 1957 : 			for(j=0;j<_MAP_NUM_NAV_TYPES_;j++)

	xor	ecx, ecx
	mov	WORD PTR _j$[ebp], cx
	jmp	SHORT $LN4@HideNavalU
$LN3@HideNavalU:
	mov	dx, WORD PTR _j$[ebp]
	add	dx, 1
	mov	WORD PTR _j$[ebp], dx
$LN4@HideNavalU:
	movsx	eax, WORD PTR _j$[ebp]
	cmp	eax, 2
	jge	$LN5@HideNavalU

; 1958 : 				if(Team_[i].NavalUnits->Flags[j] && (offflag & (1 << j)))

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+872]
	movsx	ecx, WORD PTR _j$[ebp]
	cmp	DWORD PTR [eax+ecx*4], 0
	je	$LN1@HideNavalU
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, 1
	shl	edx, cl
	and	edx, DWORD PTR _offflag$[ebp]
	je	$LN1@HideNavalU

; 1959 : 				{
; 1960 : 					Team_[i].NavalUnits->Type[j]->Refresh();

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+872]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+8]
	movsx	edx, WORD PTR _j$[ebp]
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [esi+eax+872]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4+8]
	mov	edx, DWORD PTR [esi+160]
	call	edx

; 1961 : 					Team_[i].NavalUnits->Flags[j]=0;

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+872]
	movsx	eax, WORD PTR _j$[ebp]
	mov	DWORD PTR [edx+eax*4], 0

; 1962 : 					Team_[i].NavalUnits->Type[j]->SetFlagBitOn(C_BIT_INVISIBLE);

	push	8192					; 00002000H
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+872]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+8]
	movsx	eax, WORD PTR _j$[ebp]
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+872]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4+8]
	mov	eax, DWORD PTR [edx+8]
	call	eax
$LN1@HideNavalU:

; 1963 : 				}
; 1964 : 		}

	jmp	$LN3@HideNavalU
$LN5@HideNavalU:
	jmp	$LN7@HideNavalU
$LN6@HideNavalU:

; 1965 : 	UI_Leave(Leave);

	mov	ecx, DWORD PTR _Leave$[ebp]
	push	ecx
	call	?UI_Leave@@YAXPAUF4CSECTIONHANDLE@@@Z	; UI_Leave
	add	esp, 4

; 1966 : 	NavalUnitMask_ &= ~offflag;

	mov	edx, DWORD PTR _offflag$[ebp]
	not	edx
	mov	eax, DWORD PTR _this$[ebp]
	and	edx, DWORD PTR [eax+792]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+792], edx

; 1967 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?HideNavalUnitType@C_Map@@QAEXJ@Z ENDP			; C_Map::HideNavalUnitType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_Leave$ = -16						; size = 4
_this$ = -12						; size = 4
_i$ = -8						; size = 2
_j$ = -4						; size = 2
_mask$ = 8						; size = 4
?ShowNavalUnitType@C_Map@@QAEXJ@Z PROC			; C_Map::ShowNavalUnitType
; _this$ = ecx

; 1924 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1925 : 	short i,j;
; 1926 : 	F4CSECTIONHANDLE *Leave;
; 1927 : 
; 1928 : 	NavalUnitMask_ |= (1 << FindTypeIndex(mask,NAV_TypeList,_MAP_NUM_NAV_TYPES_));

	push	2
	push	OFFSET ?NAV_TypeList@@3PAJA		; NAV_TypeList
	mov	eax, DWORD PTR _mask$[ebp]
	push	eax
	call	?FindTypeIndex@@YAJJQAJH@Z		; FindTypeIndex
	add	esp, 12					; 0000000cH
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	mov	eax, DWORD PTR _this$[ebp]
	or	edx, DWORD PTR [eax+792]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+792], edx

; 1929 : 
; 1930 : 	Leave=UI_Enter(DrawWindow_);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1124]
	push	eax
	call	?UI_Enter@@YAPAUF4CSECTIONHANDLE@@PAVC_Window@@@Z ; UI_Enter
	add	esp, 4
	mov	DWORD PTR _Leave$[ebp], eax

; 1931 : 	for(i=0;i<_MAX_TEAMS_;i++)

	xor	ecx, ecx
	mov	WORD PTR _i$[ebp], cx
	jmp	SHORT $LN8@ShowNavalU
$LN7@ShowNavalU:
	mov	dx, WORD PTR _i$[ebp]
	add	dx, 1
	mov	WORD PTR _i$[ebp], dx
$LN8@ShowNavalU:
	movsx	eax, WORD PTR _i$[ebp]
	cmp	eax, 8
	jge	$LN6@ShowNavalU

; 1932 : 		if(Team_[i].NavalUnits)

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+ecx+872], 0
	je	$LN5@ShowNavalU

; 1933 : 		{
; 1934 : 			for(j=0;j<_MAP_NUM_NAV_TYPES_;j++)

	xor	eax, eax
	mov	WORD PTR _j$[ebp], ax
	jmp	SHORT $LN4@ShowNavalU
$LN3@ShowNavalU:
	mov	cx, WORD PTR _j$[ebp]
	add	cx, 1
	mov	WORD PTR _j$[ebp], cx
$LN4@ShowNavalU:
	movsx	edx, WORD PTR _j$[ebp]
	cmp	edx, 2
	jge	$LN5@ShowNavalU

; 1935 : 				if(!Team_[i].NavalUnits->Flags[j] && (NavalUnitMask_ & (1 << j)))

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+872]
	movsx	eax, WORD PTR _j$[ebp]
	cmp	DWORD PTR [edx+eax*4], 0
	jne	$LN1@ShowNavalU
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, 1
	shl	edx, cl
	mov	eax, DWORD PTR _this$[ebp]
	and	edx, DWORD PTR [eax+792]
	je	$LN1@ShowNavalU

; 1936 : 				{
; 1937 : 					Team_[i].NavalUnits->Flags[j]=1;

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+872]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	DWORD PTR [eax+ecx*4], 1

; 1938 : 					Team_[i].NavalUnits->Type[j]->SetFlagBitOff(C_BIT_INVISIBLE);

	push	8192					; 00002000H
	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+872]
	movsx	edx, WORD PTR _j$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+8]
	movsx	ecx, WORD PTR _j$[ebp]
	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [esi+edx+872]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4+8]
	mov	edx, DWORD PTR [eax+12]
	call	edx

; 1939 : 					Team_[i].NavalUnits->Type[j]->Refresh();

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+872]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+8]
	movsx	edx, WORD PTR _j$[ebp]
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [esi+eax+872]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4+8]
	mov	edx, DWORD PTR [esi+160]
	call	edx
$LN1@ShowNavalU:

; 1940 : 				}
; 1941 : 		}

	jmp	$LN3@ShowNavalU
$LN5@ShowNavalU:
	jmp	$LN7@ShowNavalU
$LN6@ShowNavalU:

; 1942 : 	UI_Leave(Leave);

	mov	eax, DWORD PTR _Leave$[ebp]
	push	eax
	call	?UI_Leave@@YAXPAUF4CSECTIONHANDLE@@@Z	; UI_Leave
	add	esp, 4

; 1943 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?ShowNavalUnitType@C_Map@@QAEXJ@Z ENDP			; C_Map::ShowNavalUnitType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_Leave$ = -16						; size = 4
_this$ = -12						; size = 4
_j$ = -8						; size = 2
_i$ = -4						; size = 2
?RefreshAllAirUnitType@C_Map@@QAEXXZ PROC		; C_Map::RefreshAllAirUnitType
; _this$ = ecx

; 1907 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1908 : 	short i, j;
; 1909 : 	F4CSECTIONHANDLE *Leave;
; 1910 : 
; 1911 : 	Leave=UI_Enter(DrawWindow_);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1124]
	push	ecx
	call	?UI_Enter@@YAPAUF4CSECTIONHANDLE@@PAVC_Window@@@Z ; UI_Enter
	add	esp, 4
	mov	DWORD PTR _Leave$[ebp], eax

; 1912 : 
; 1913 : 	for (i = 0; i < _MAX_TEAMS_; i++) {

	xor	edx, edx
	mov	WORD PTR _i$[ebp], dx
	jmp	SHORT $LN7@RefreshAll
$LN6@RefreshAll:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
$LN7@RefreshAll:
	movsx	ecx, WORD PTR _i$[ebp]
	cmp	ecx, 8
	jge	SHORT $LN5@RefreshAll

; 1914 : 		if (Team_[i].AirUnits) {

	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+edx+864], 0
	je	SHORT $LN4@RefreshAll

; 1915 : 			for (j = 0; j < _MAP_NUM_AIR_TYPES_; j++)

	xor	ecx, ecx
	mov	WORD PTR _j$[ebp], cx
	jmp	SHORT $LN3@RefreshAll
$LN2@RefreshAll:
	mov	dx, WORD PTR _j$[ebp]
	add	dx, 1
	mov	WORD PTR _j$[ebp], dx
$LN3@RefreshAll:
	movsx	eax, WORD PTR _j$[ebp]
	cmp	eax, 5
	jge	SHORT $LN4@RefreshAll

; 1916 : 				Team_[i].AirUnits->Type[j]->Refresh();

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+864]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+20]
	movsx	eax, WORD PTR _j$[ebp]
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+864]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4+20]
	mov	eax, DWORD PTR [edx+160]
	call	eax
	jmp	SHORT $LN2@RefreshAll
$LN4@RefreshAll:

; 1917 : 		}
; 1918 : 	}

	jmp	$LN6@RefreshAll
$LN5@RefreshAll:

; 1919 : 
; 1920 : 	UI_Leave(Leave);

	mov	ecx, DWORD PTR _Leave$[ebp]
	push	ecx
	call	?UI_Leave@@YAXPAUF4CSECTIONHANDLE@@@Z	; UI_Leave
	add	esp, 4

; 1921 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?RefreshAllAirUnitType@C_Map@@QAEXXZ ENDP		; C_Map::RefreshAllAirUnitType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_Leave$ = -20						; size = 4
_offflag$ = -16						; size = 4
_this$ = -12						; size = 4
_i$ = -8						; size = 2
_j$ = -4						; size = 2
_mask$ = 8						; size = 4
?HideAirUnitType@C_Map@@QAEXJ@Z PROC			; C_Map::HideAirUnitType
; _this$ = ecx

; 1882 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1883 : 	short i,j;
; 1884 : 	long offflag;
; 1885 : 	F4CSECTIONHANDLE *Leave;
; 1886 : 
; 1887 : 	offflag = (1 << FindTypeIndex(mask,AIR_TypeList,_MAP_NUM_AIR_TYPES_));

	push	5
	push	OFFSET ?AIR_TypeList@@3PAJA		; AIR_TypeList
	mov	eax, DWORD PTR _mask$[ebp]
	push	eax
	call	?FindTypeIndex@@YAJJQAJH@Z		; FindTypeIndex
	add	esp, 12					; 0000000cH
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	mov	DWORD PTR _offflag$[ebp], edx

; 1888 : 
; 1889 : 	Leave=UI_Enter(DrawWindow_);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1124]
	push	ecx
	call	?UI_Enter@@YAPAUF4CSECTIONHANDLE@@PAVC_Window@@@Z ; UI_Enter
	add	esp, 4
	mov	DWORD PTR _Leave$[ebp], eax

; 1890 : 	for(i=0;i<_MAX_TEAMS_;i++)

	xor	edx, edx
	mov	WORD PTR _i$[ebp], dx
	jmp	SHORT $LN8@HideAirUni
$LN7@HideAirUni:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
$LN8@HideAirUni:
	movsx	ecx, WORD PTR _i$[ebp]
	cmp	ecx, 8
	jge	$LN6@HideAirUni

; 1891 : 		if(Team_[i].AirUnits)

	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+edx+864], 0
	je	$LN5@HideAirUni

; 1892 : 		{
; 1893 : 			for(j=0;j<_MAP_NUM_AIR_TYPES_;j++)

	xor	ecx, ecx
	mov	WORD PTR _j$[ebp], cx
	jmp	SHORT $LN4@HideAirUni
$LN3@HideAirUni:
	mov	dx, WORD PTR _j$[ebp]
	add	dx, 1
	mov	WORD PTR _j$[ebp], dx
$LN4@HideAirUni:
	movsx	eax, WORD PTR _j$[ebp]
	cmp	eax, 5
	jge	$LN5@HideAirUni

; 1894 : 				if(Team_[i].AirUnits->Flags[j] && (offflag & (1 << j)))

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+864]
	movsx	ecx, WORD PTR _j$[ebp]
	cmp	DWORD PTR [eax+ecx*4], 0
	je	$LN1@HideAirUni
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, 1
	shl	edx, cl
	and	edx, DWORD PTR _offflag$[ebp]
	je	$LN1@HideAirUni

; 1895 : 				{
; 1896 : 					Team_[i].AirUnits->Type[j]->Refresh();

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+864]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+20]
	movsx	edx, WORD PTR _j$[ebp]
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [esi+eax+864]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4+20]
	mov	edx, DWORD PTR [esi+160]
	call	edx

; 1897 : 					Team_[i].AirUnits->Flags[j]=0;

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+864]
	movsx	eax, WORD PTR _j$[ebp]
	mov	DWORD PTR [edx+eax*4], 0

; 1898 : 					Team_[i].AirUnits->Type[j]->SetFlagBitOn(C_BIT_INVISIBLE);

	push	8192					; 00002000H
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+864]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+20]
	movsx	eax, WORD PTR _j$[ebp]
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+864]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4+20]
	mov	eax, DWORD PTR [edx+8]
	call	eax
$LN1@HideAirUni:

; 1899 : 				}
; 1900 : 		}

	jmp	$LN3@HideAirUni
$LN5@HideAirUni:
	jmp	$LN7@HideAirUni
$LN6@HideAirUni:

; 1901 : 	UI_Leave(Leave);

	mov	ecx, DWORD PTR _Leave$[ebp]
	push	ecx
	call	?UI_Leave@@YAXPAUF4CSECTIONHANDLE@@@Z	; UI_Leave
	add	esp, 4

; 1902 : 	AirUnitMask_ &= ~offflag;

	mov	edx, DWORD PTR _offflag$[ebp]
	not	edx
	mov	eax, DWORD PTR _this$[ebp]
	and	edx, DWORD PTR [eax+796]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+796], edx

; 1903 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?HideAirUnitType@C_Map@@QAEXJ@Z ENDP			; C_Map::HideAirUnitType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_Leave$ = -16						; size = 4
_this$ = -12						; size = 4
_i$ = -8						; size = 2
_j$ = -4						; size = 2
_mask$ = 8						; size = 4
?ShowAirUnitType@C_Map@@QAEXJ@Z PROC			; C_Map::ShowAirUnitType
; _this$ = ecx

; 1860 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1861 : 	short i,j;
; 1862 : 	F4CSECTIONHANDLE *Leave;
; 1863 : 
; 1864 : 	AirUnitMask_ |= (1 << FindTypeIndex(mask,AIR_TypeList,_MAP_NUM_AIR_TYPES_));

	push	5
	push	OFFSET ?AIR_TypeList@@3PAJA		; AIR_TypeList
	mov	eax, DWORD PTR _mask$[ebp]
	push	eax
	call	?FindTypeIndex@@YAJJQAJH@Z		; FindTypeIndex
	add	esp, 12					; 0000000cH
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	mov	eax, DWORD PTR _this$[ebp]
	or	edx, DWORD PTR [eax+796]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+796], edx

; 1865 : 
; 1866 : 	Leave=UI_Enter(DrawWindow_);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1124]
	push	eax
	call	?UI_Enter@@YAPAUF4CSECTIONHANDLE@@PAVC_Window@@@Z ; UI_Enter
	add	esp, 4
	mov	DWORD PTR _Leave$[ebp], eax

; 1867 : 	for(i=0;i<_MAX_TEAMS_;i++)

	xor	ecx, ecx
	mov	WORD PTR _i$[ebp], cx
	jmp	SHORT $LN8@ShowAirUni
$LN7@ShowAirUni:
	mov	dx, WORD PTR _i$[ebp]
	add	dx, 1
	mov	WORD PTR _i$[ebp], dx
$LN8@ShowAirUni:
	movsx	eax, WORD PTR _i$[ebp]
	cmp	eax, 8
	jge	$LN6@ShowAirUni

; 1868 : 		if(Team_[i].AirUnits)

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+ecx+864], 0
	je	$LN5@ShowAirUni

; 1869 : 		{
; 1870 : 			for(j=0;j<_MAP_NUM_AIR_TYPES_;j++)

	xor	eax, eax
	mov	WORD PTR _j$[ebp], ax
	jmp	SHORT $LN4@ShowAirUni
$LN3@ShowAirUni:
	mov	cx, WORD PTR _j$[ebp]
	add	cx, 1
	mov	WORD PTR _j$[ebp], cx
$LN4@ShowAirUni:
	movsx	edx, WORD PTR _j$[ebp]
	cmp	edx, 5
	jge	$LN5@ShowAirUni

; 1871 : 				if(!Team_[i].AirUnits->Flags[j] && (AirUnitMask_ & (1 << j)))

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+864]
	movsx	eax, WORD PTR _j$[ebp]
	cmp	DWORD PTR [edx+eax*4], 0
	jne	$LN1@ShowAirUni
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, 1
	shl	edx, cl
	mov	eax, DWORD PTR _this$[ebp]
	and	edx, DWORD PTR [eax+796]
	je	$LN1@ShowAirUni

; 1872 : 				{
; 1873 : 					Team_[i].AirUnits->Flags[j]=1;

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+864]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	DWORD PTR [eax+ecx*4], 1

; 1874 : 					Team_[i].AirUnits->Type[j]->SetFlagBitOff(C_BIT_INVISIBLE);

	push	8192					; 00002000H
	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+864]
	movsx	edx, WORD PTR _j$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+20]
	movsx	ecx, WORD PTR _j$[ebp]
	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [esi+edx+864]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4+20]
	mov	edx, DWORD PTR [eax+12]
	call	edx

; 1875 : 					Team_[i].AirUnits->Type[j]->Refresh();

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+864]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+20]
	movsx	edx, WORD PTR _j$[ebp]
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [esi+eax+864]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4+20]
	mov	edx, DWORD PTR [esi+160]
	call	edx
$LN1@ShowAirUni:

; 1876 : 				}
; 1877 : 		}

	jmp	$LN3@ShowAirUni
$LN5@ShowAirUni:
	jmp	$LN7@ShowAirUni
$LN6@ShowAirUni:

; 1878 : 	UI_Leave(Leave);

	mov	eax, DWORD PTR _Leave$[ebp]
	push	eax
	call	?UI_Leave@@YAXPAUF4CSECTIONHANDLE@@@Z	; UI_Leave
	add	esp, 4

; 1879 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?ShowAirUnitType@C_Map@@QAEXJ@Z ENDP			; C_Map::ShowAirUnitType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_Leave$ = -24						; size = 4
_offflag$ = -20						; size = 4
_this$ = -16						; size = 4
_k$ = -12						; size = 2
_i$ = -8						; size = 2
_j$ = -4						; size = 2
_mask$ = 8						; size = 4
?HideUnitType@C_Map@@QAEXJ@Z PROC			; C_Map::HideUnitType
; _this$ = ecx

; 1790 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1791 : 	short i,j,k;
; 1792 : 	long offflag;
; 1793 : 	F4CSECTIONHANDLE *Leave;
; 1794 : 
; 1795 : 	offflag = (1 << FindTypeIndex(mask,GND_TypeList,_MAP_NUM_GND_TYPES_));

	push	4
	push	OFFSET ?GND_TypeList@@3PAJA		; GND_TypeList
	mov	eax, DWORD PTR _mask$[ebp]
	push	eax
	call	?FindTypeIndex@@YAJJQAJH@Z		; FindTypeIndex
	add	esp, 12					; 0000000cH
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	mov	DWORD PTR _offflag$[ebp], edx

; 1796 : 
; 1797 : 	Leave=UI_Enter(DrawWindow_);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1124]
	push	ecx
	call	?UI_Enter@@YAPAUF4CSECTIONHANDLE@@PAVC_Window@@@Z ; UI_Enter
	add	esp, 4
	mov	DWORD PTR _Leave$[ebp], eax

; 1798 : 	for(i=0;i<_MAX_TEAMS_;i++)

	xor	edx, edx
	mov	WORD PTR _i$[ebp], dx
	jmp	SHORT $LN12@HideUnitTy
$LN11@HideUnitTy:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
$LN12@HideUnitTy:
	movsx	ecx, WORD PTR _i$[ebp]
	cmp	ecx, 8
	jge	$LN10@HideUnitTy

; 1799 : 		if(Team_[i].Units)

	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+edx+868], 0
	je	$LN9@HideUnitTy

; 1800 : 		{
; 1801 : 			for(j=0;j<_MAP_NUM_GND_TYPES_;j++)

	xor	ecx, ecx
	mov	WORD PTR _j$[ebp], cx
	jmp	SHORT $LN8@HideUnitTy
$LN7@HideUnitTy:
	mov	dx, WORD PTR _j$[ebp]
	add	dx, 1
	mov	WORD PTR _j$[ebp], dx
$LN8@HideUnitTy:
	movsx	eax, WORD PTR _j$[ebp]
	cmp	eax, 4
	jge	$LN9@HideUnitTy

; 1802 : 			{
; 1803 : 				if(Team_[i].Units->Flags[j] && (offflag & (1 << j)))

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+868]
	movsx	ecx, WORD PTR _j$[ebp]
	cmp	DWORD PTR [eax+ecx*4], 0
	je	$LN5@HideUnitTy
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, 1
	shl	edx, cl
	and	edx, DWORD PTR _offflag$[ebp]
	je	$LN5@HideUnitTy

; 1804 : 				{
; 1805 : 					Team_[i].Units->Flags[j]=0;

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+868]
	movsx	eax, WORD PTR _j$[ebp]
	mov	DWORD PTR [edx+eax*4], 0

; 1806 : 					for(k=0;k<_MAP_NUM_GND_LEVELS_;k++)

	xor	ecx, ecx
	mov	WORD PTR _k$[ebp], cx
	jmp	SHORT $LN4@HideUnitTy
$LN3@HideUnitTy:
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$LN4@HideUnitTy:
	movsx	eax, WORD PTR _k$[ebp]
	cmp	eax, 3
	jge	$LN5@HideUnitTy

; 1807 : 					{
; 1808 : 						if(Team_[i].Units->Type[j]->Flags[k] == 1)

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+868]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+16]
	movsx	eax, WORD PTR _k$[ebp]
	cmp	DWORD PTR [edx+eax*4], 1
	jne	$LN1@HideUnitTy

; 1809 : 						{
; 1810 : 							Team_[i].Units->Type[j]->Levels[k]->Refresh();

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+868]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+16]
	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+12]
	movsx	edx, WORD PTR _k$[ebp]
	movsx	eax, WORD PTR _j$[ebp]
	movsx	esi, WORD PTR _i$[ebp]
	imul	esi, 24					; 00000018H
	mov	edi, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edi+esi+868]
	mov	eax, DWORD PTR [esi+eax*4+16]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4+12]
	mov	edx, DWORD PTR [esi+160]
	call	edx

; 1811 : 							Team_[i].Units->Type[j]->Levels[k]->SetFlagBitOn(C_BIT_INVISIBLE);

	push	8192					; 00002000H
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+868]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+16]
	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+12]
	movsx	ecx, WORD PTR _k$[ebp]
	movsx	edx, WORD PTR _j$[ebp]
	movsx	esi, WORD PTR _i$[ebp]
	imul	esi, 24					; 00000018H
	mov	edi, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edi+esi+868]
	mov	edx, DWORD PTR [esi+edx*4+16]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4+12]
	mov	edx, DWORD PTR [eax+8]
	call	edx
$LN1@HideUnitTy:

; 1812 : 						}
; 1813 : 					}

	jmp	$LN3@HideUnitTy
$LN5@HideUnitTy:

; 1814 : 				}
; 1815 : 			}

	jmp	$LN7@HideUnitTy
$LN9@HideUnitTy:
	jmp	$LN11@HideUnitTy
$LN10@HideUnitTy:

; 1816 : 		}
; 1817 : 	UI_Leave(Leave);

	mov	eax, DWORD PTR _Leave$[ebp]
	push	eax
	call	?UI_Leave@@YAXPAUF4CSECTIONHANDLE@@@Z	; UI_Leave
	add	esp, 4

; 1818 : 	UnitMask_ &= ~offflag;

	mov	ecx, DWORD PTR _offflag$[ebp]
	not	ecx
	mov	edx, DWORD PTR _this$[ebp]
	and	ecx, DWORD PTR [edx+788]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+788], ecx

; 1819 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?HideUnitType@C_Map@@QAEXJ@Z ENDP			; C_Map::HideUnitType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_Leave$ = -20						; size = 4
_this$ = -16						; size = 4
_k$ = -12						; size = 2
_i$ = -8						; size = 2
_j$ = -4						; size = 2
_mask$ = 8						; size = 4
?ShowUnitType@C_Map@@QAEXJ@Z PROC			; C_Map::ShowUnitType
; _this$ = ecx

; 1760 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1761 : 	short i,j,k;
; 1762 : 	F4CSECTIONHANDLE *Leave;
; 1763 : 
; 1764 : 	UnitMask_ |= (1 << FindTypeIndex(mask,GND_TypeList,_MAP_NUM_GND_TYPES_));

	push	4
	push	OFFSET ?GND_TypeList@@3PAJA		; GND_TypeList
	mov	eax, DWORD PTR _mask$[ebp]
	push	eax
	call	?FindTypeIndex@@YAJJQAJH@Z		; FindTypeIndex
	add	esp, 12					; 0000000cH
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	mov	eax, DWORD PTR _this$[ebp]
	or	edx, DWORD PTR [eax+788]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+788], edx

; 1765 : 
; 1766 : 	Leave=UI_Enter(DrawWindow_);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1124]
	push	eax
	call	?UI_Enter@@YAPAUF4CSECTIONHANDLE@@PAVC_Window@@@Z ; UI_Enter
	add	esp, 4
	mov	DWORD PTR _Leave$[ebp], eax

; 1767 : 	for(i=0;i<_MAX_TEAMS_;i++)

	xor	ecx, ecx
	mov	WORD PTR _i$[ebp], cx
	jmp	SHORT $LN12@ShowUnitTy
$LN11@ShowUnitTy:
	mov	dx, WORD PTR _i$[ebp]
	add	dx, 1
	mov	WORD PTR _i$[ebp], dx
$LN12@ShowUnitTy:
	movsx	eax, WORD PTR _i$[ebp]
	cmp	eax, 8
	jge	$LN10@ShowUnitTy

; 1768 : 		if(Team_[i].Units)

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+ecx+868], 0
	je	$LN9@ShowUnitTy

; 1769 : 		{
; 1770 : 			for(j=0;j<_MAP_NUM_GND_TYPES_;j++)

	xor	eax, eax
	mov	WORD PTR _j$[ebp], ax
	jmp	SHORT $LN8@ShowUnitTy
$LN7@ShowUnitTy:
	mov	cx, WORD PTR _j$[ebp]
	add	cx, 1
	mov	WORD PTR _j$[ebp], cx
$LN8@ShowUnitTy:
	movsx	edx, WORD PTR _j$[ebp]
	cmp	edx, 4
	jge	$LN9@ShowUnitTy

; 1771 : 			{
; 1772 : 				if(!Team_[i].Units->Flags[j] && (UnitMask_ & (1 << j)))

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+868]
	movsx	eax, WORD PTR _j$[ebp]
	cmp	DWORD PTR [edx+eax*4], 0
	jne	$LN5@ShowUnitTy
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, 1
	shl	edx, cl
	mov	eax, DWORD PTR _this$[ebp]
	and	edx, DWORD PTR [eax+788]
	je	$LN5@ShowUnitTy

; 1773 : 				{
; 1774 : 					Team_[i].Units->Flags[j]=1;

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+868]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	DWORD PTR [eax+ecx*4], 1

; 1775 : 					for(k=0;k<_MAP_NUM_GND_LEVELS_;k++)

	xor	edx, edx
	mov	WORD PTR _k$[ebp], dx
	jmp	SHORT $LN4@ShowUnitTy
$LN3@ShowUnitTy:
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$LN4@ShowUnitTy:
	movsx	ecx, WORD PTR _k$[ebp]
	cmp	ecx, 3
	jge	$LN5@ShowUnitTy

; 1776 : 					{
; 1777 : 						if(Team_[i].Units->Type[j]->Flags[k] == 1)

	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+868]
	movsx	edx, WORD PTR _j$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+16]
	movsx	ecx, WORD PTR _k$[ebp]
	cmp	DWORD PTR [eax+ecx*4], 1
	jne	$LN1@ShowUnitTy

; 1778 : 						{
; 1779 : 							Team_[i].Units->Type[j]->Levels[k]->SetFlagBitOff(C_BIT_INVISIBLE);

	push	8192					; 00002000H
	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+868]
	movsx	edx, WORD PTR _j$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+16]
	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+12]
	movsx	eax, WORD PTR _k$[ebp]
	movsx	ecx, WORD PTR _j$[ebp]
	movsx	esi, WORD PTR _i$[ebp]
	imul	esi, 24					; 00000018H
	mov	edi, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edi+esi+868]
	mov	ecx, DWORD PTR [esi+ecx*4+16]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4+12]
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 1780 : 							Team_[i].Units->Type[j]->Levels[k]->Refresh();

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+868]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+16]
	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+12]
	movsx	edx, WORD PTR _k$[ebp]
	movsx	eax, WORD PTR _j$[ebp]
	movsx	esi, WORD PTR _i$[ebp]
	imul	esi, 24					; 00000018H
	mov	edi, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edi+esi+868]
	mov	eax, DWORD PTR [esi+eax*4+16]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4+12]
	mov	edx, DWORD PTR [esi+160]
	call	edx
$LN1@ShowUnitTy:

; 1781 : 						}
; 1782 : 					}

	jmp	$LN3@ShowUnitTy
$LN5@ShowUnitTy:

; 1783 : 				}
; 1784 : 			}

	jmp	$LN7@ShowUnitTy
$LN9@ShowUnitTy:
	jmp	$LN11@ShowUnitTy
$LN10@ShowUnitTy:

; 1785 : 		}
; 1786 : 	UI_Leave(Leave);

	mov	eax, DWORD PTR _Leave$[ebp]
	push	eax
	call	?UI_Leave@@YAXPAUF4CSECTIONHANDLE@@@Z	; UI_Leave
	add	esp, 4

; 1787 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?ShowUnitType@C_Map@@QAEXJ@Z ENDP			; C_Map::ShowUnitType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_Leave$ = -20						; size = 4
_offflag$ = -16						; size = 4
_this$ = -12						; size = 4
_i$ = -8						; size = 2
_j$ = -4						; size = 2
_mask$ = 8						; size = 4
?HideObjectiveType@C_Map@@QAEXJ@Z PROC			; C_Map::HideObjectiveType
; _this$ = ecx

; 1736 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1737 : 	short i,j;
; 1738 : 	long offflag;
; 1739 : 	F4CSECTIONHANDLE *Leave;
; 1740 : 
; 1741 : 	offflag = (1 << FindTypeIndex(mask,OBJ_TypeList,_MAP_NUM_OBJ_TYPES_));

	push	14					; 0000000eH
	push	OFFSET ?OBJ_TypeList@@3PAJA		; OBJ_TypeList
	mov	eax, DWORD PTR _mask$[ebp]
	push	eax
	call	?FindTypeIndex@@YAJJQAJH@Z		; FindTypeIndex
	add	esp, 12					; 0000000cH
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	mov	DWORD PTR _offflag$[ebp], edx

; 1742 : 
; 1743 : 	Leave=UI_Enter(DrawWindow_);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1124]
	push	ecx
	call	?UI_Enter@@YAPAUF4CSECTIONHANDLE@@PAVC_Window@@@Z ; UI_Enter
	add	esp, 4
	mov	DWORD PTR _Leave$[ebp], eax

; 1744 : 	for(i=0;i<_MAX_TEAMS_;i++)

	xor	edx, edx
	mov	WORD PTR _i$[ebp], dx
	jmp	SHORT $LN8@HideObject
$LN7@HideObject:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
$LN8@HideObject:
	movsx	ecx, WORD PTR _i$[ebp]
	cmp	ecx, 8
	jge	$LN6@HideObject

; 1745 : 		if(Team_[i].Objectives)

	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+edx+876], 0
	je	$LN5@HideObject

; 1746 : 		{
; 1747 : 			for(j=0;j<_MAP_NUM_OBJ_TYPES_;j++)

	xor	ecx, ecx
	mov	WORD PTR _j$[ebp], cx
	jmp	SHORT $LN4@HideObject
$LN3@HideObject:
	mov	dx, WORD PTR _j$[ebp]
	add	dx, 1
	mov	WORD PTR _j$[ebp], dx
$LN4@HideObject:
	movsx	eax, WORD PTR _j$[ebp]
	cmp	eax, 14					; 0000000eH
	jge	$LN5@HideObject

; 1748 : 				if(Team_[i].Objectives->Flags[j] && (offflag & (1 << j)))

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+876]
	movsx	ecx, WORD PTR _j$[ebp]
	cmp	DWORD PTR [eax+ecx*4], 0
	je	$LN1@HideObject
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, 1
	shl	edx, cl
	and	edx, DWORD PTR _offflag$[ebp]
	je	$LN1@HideObject

; 1749 : 				{
; 1750 : 					Team_[i].Objectives->Type[j]->Refresh();

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+876]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+56]
	movsx	edx, WORD PTR _j$[ebp]
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [esi+eax+876]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4+56]
	mov	edx, DWORD PTR [esi+160]
	call	edx

; 1751 : 					Team_[i].Objectives->Flags[j]=0;

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+876]
	movsx	eax, WORD PTR _j$[ebp]
	mov	DWORD PTR [edx+eax*4], 0

; 1752 : 					Team_[i].Objectives->Type[j]->SetFlagBitOn(C_BIT_INVISIBLE);

	push	8192					; 00002000H
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+876]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+56]
	movsx	eax, WORD PTR _j$[ebp]
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+876]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4+56]
	mov	eax, DWORD PTR [edx+8]
	call	eax
$LN1@HideObject:

; 1753 : 				}
; 1754 : 		}

	jmp	$LN3@HideObject
$LN5@HideObject:
	jmp	$LN7@HideObject
$LN6@HideObject:

; 1755 : 	UI_Leave(Leave);

	mov	ecx, DWORD PTR _Leave$[ebp]
	push	ecx
	call	?UI_Leave@@YAXPAUF4CSECTIONHANDLE@@@Z	; UI_Leave
	add	esp, 4

; 1756 : 	ObjectiveMask_ &= ~offflag;

	mov	edx, DWORD PTR _offflag$[ebp]
	not	edx
	mov	eax, DWORD PTR _this$[ebp]
	and	edx, DWORD PTR [eax+784]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+784], edx

; 1757 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?HideObjectiveType@C_Map@@QAEXJ@Z ENDP			; C_Map::HideObjectiveType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_Leave$ = -16						; size = 4
_this$ = -12						; size = 4
_i$ = -8						; size = 2
_j$ = -4						; size = 2
_mask$ = 8						; size = 4
?ShowObjectiveType@C_Map@@QAEXJ@Z PROC			; C_Map::ShowObjectiveType
; _this$ = ecx

; 1714 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1715 : 	short i,j;
; 1716 : 	F4CSECTIONHANDLE *Leave;
; 1717 : 
; 1718 : 	ObjectiveMask_ |= (1 << FindTypeIndex(mask,OBJ_TypeList,_MAP_NUM_OBJ_TYPES_));

	push	14					; 0000000eH
	push	OFFSET ?OBJ_TypeList@@3PAJA		; OBJ_TypeList
	mov	eax, DWORD PTR _mask$[ebp]
	push	eax
	call	?FindTypeIndex@@YAJJQAJH@Z		; FindTypeIndex
	add	esp, 12					; 0000000cH
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	mov	eax, DWORD PTR _this$[ebp]
	or	edx, DWORD PTR [eax+784]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+784], edx

; 1719 : 
; 1720 : 	Leave=UI_Enter(DrawWindow_);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1124]
	push	eax
	call	?UI_Enter@@YAPAUF4CSECTIONHANDLE@@PAVC_Window@@@Z ; UI_Enter
	add	esp, 4
	mov	DWORD PTR _Leave$[ebp], eax

; 1721 : 	for(i=0;i<_MAX_TEAMS_;i++)

	xor	ecx, ecx
	mov	WORD PTR _i$[ebp], cx
	jmp	SHORT $LN8@ShowObject
$LN7@ShowObject:
	mov	dx, WORD PTR _i$[ebp]
	add	dx, 1
	mov	WORD PTR _i$[ebp], dx
$LN8@ShowObject:
	movsx	eax, WORD PTR _i$[ebp]
	cmp	eax, 8
	jge	$LN6@ShowObject

; 1722 : 		if(Team_[i].Objectives)

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+ecx+876], 0
	je	$LN5@ShowObject

; 1723 : 		{
; 1724 : 			for(j=0;j<_MAP_NUM_OBJ_TYPES_;j++)

	xor	eax, eax
	mov	WORD PTR _j$[ebp], ax
	jmp	SHORT $LN4@ShowObject
$LN3@ShowObject:
	mov	cx, WORD PTR _j$[ebp]
	add	cx, 1
	mov	WORD PTR _j$[ebp], cx
$LN4@ShowObject:
	movsx	edx, WORD PTR _j$[ebp]
	cmp	edx, 14					; 0000000eH
	jge	$LN5@ShowObject

; 1725 : 				if(!Team_[i].Objectives->Flags[j] && (ObjectiveMask_ & (1 << j)))

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+876]
	movsx	eax, WORD PTR _j$[ebp]
	cmp	DWORD PTR [edx+eax*4], 0
	jne	$LN1@ShowObject
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, 1
	shl	edx, cl
	mov	eax, DWORD PTR _this$[ebp]
	and	edx, DWORD PTR [eax+784]
	je	$LN1@ShowObject

; 1726 : 				{
; 1727 : 					Team_[i].Objectives->Flags[j]=1;

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+876]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	DWORD PTR [eax+ecx*4], 1

; 1728 : 					Team_[i].Objectives->Type[j]->SetFlagBitOff(C_BIT_INVISIBLE);

	push	8192					; 00002000H
	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+876]
	movsx	edx, WORD PTR _j$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+56]
	movsx	ecx, WORD PTR _j$[ebp]
	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [esi+edx+876]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4+56]
	mov	edx, DWORD PTR [eax+12]
	call	edx

; 1729 : 					Team_[i].Objectives->Type[j]->Refresh();

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+876]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+56]
	movsx	edx, WORD PTR _j$[ebp]
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [esi+eax+876]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4+56]
	mov	edx, DWORD PTR [esi+160]
	call	edx
$LN1@ShowObject:

; 1730 : 				}
; 1731 : 		}

	jmp	$LN3@ShowObject
$LN5@ShowObject:
	jmp	$LN7@ShowObject
$LN6@ShowObject:

; 1732 : 	UI_Leave(Leave);

	mov	eax, DWORD PTR _Leave$[ebp]
	push	eax
	call	?UI_Leave@@YAXPAUF4CSECTIONHANDLE@@@Z	; UI_Leave
	add	esp, 4

; 1733 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?ShowObjectiveType@C_Map@@QAEXJ@Z ENDP			; C_Map::ShowObjectiveType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_Leave$ = -16						; size = 4
_this$ = -12						; size = 4
_j$ = -8						; size = 2
_i$ = -4						; size = 2
_level$ = 8						; size = 4
?SetUnitLevel@C_Map@@QAEXJ@Z PROC			; C_Map::SetUnitLevel
; _this$ = ecx

; 1822 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1823 : 	short i,j;
; 1824 : 	F4CSECTIONHANDLE *Leave;
; 1825 : 
; 1826 : 	Leave=UI_Enter(DrawWindow_);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1124]
	push	ecx
	call	?UI_Enter@@YAPAUF4CSECTIONHANDLE@@PAVC_Window@@@Z ; UI_Enter
	add	esp, 4
	mov	DWORD PTR _Leave$[ebp], eax

; 1827 : 	for(i=0;i<_MAX_TEAMS_;i++)

	xor	edx, edx
	mov	WORD PTR _i$[ebp], dx
	jmp	SHORT $LN13@SetUnitLev
$LN12@SetUnitLev:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
$LN13@SetUnitLev:
	movsx	ecx, WORD PTR _i$[ebp]
	cmp	ecx, 8
	jge	$LN11@SetUnitLev

; 1828 : 		if(Team_[i].Units)

	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+edx+868], 0
	je	$LN10@SetUnitLev

; 1829 : 		{
; 1830 : 			for(j=0;j<_MAP_NUM_GND_TYPES_;j++)

	xor	ecx, ecx
	mov	WORD PTR _j$[ebp], cx
	jmp	SHORT $LN9@SetUnitLev
$LN8@SetUnitLev:
	mov	dx, WORD PTR _j$[ebp]
	add	dx, 1
	mov	WORD PTR _j$[ebp], dx
$LN9@SetUnitLev:
	movsx	eax, WORD PTR _j$[ebp]
	cmp	eax, 4
	jge	$LN10@SetUnitLev

; 1831 : 				if(Team_[i].Units->Type[j])

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+868]
	movsx	ecx, WORD PTR _j$[ebp]
	cmp	DWORD PTR [eax+ecx*4+16], 0
	je	$LN6@SetUnitLev

; 1832 : 				{
; 1833 : 					if(level >= 0 && level < _MAP_NUM_GND_LEVELS_)

	cmp	DWORD PTR _level$[ebp], 0
	jl	$LN6@SetUnitLev
	cmp	DWORD PTR _level$[ebp], 3
	jge	$LN6@SetUnitLev

; 1834 : 					{
; 1835 : 						Team_[i].Units->Type[j]->Flags[0]=0;

	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+868]
	movsx	edx, WORD PTR _j$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+16]
	mov	ecx, 4
	imul	ecx, 0
	mov	DWORD PTR [eax+ecx], 0

; 1836 : 						if(level)

	cmp	DWORD PTR _level$[ebp], 0
	je	SHORT $LN4@SetUnitLev

; 1837 : 							Team_[i].Units->Type[j]->Levels[0]->Refresh();

	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+868]
	movsx	edx, WORD PTR _j$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+16]
	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR [eax+ecx+12]
	mov	eax, 4
	imul	eax, 0
	movsx	ecx, WORD PTR _j$[ebp]
	movsx	esi, WORD PTR _i$[ebp]
	imul	esi, 24					; 00000018H
	mov	edi, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edi+esi+868]
	mov	ecx, DWORD PTR [esi+ecx*4+16]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax+12]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN4@SetUnitLev:

; 1838 : 						Team_[i].Units->Type[j]->Levels[0]->SetFlagBitOn(C_BIT_INVISIBLE);

	push	8192					; 00002000H
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+868]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+16]
	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR [edx+eax+12]
	mov	edx, 4
	imul	edx, 0
	movsx	eax, WORD PTR _j$[ebp]
	movsx	esi, WORD PTR _i$[ebp]
	imul	esi, 24					; 00000018H
	mov	edi, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edi+esi+868]
	mov	eax, DWORD PTR [esi+eax*4+16]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx+12]
	mov	edx, DWORD PTR [esi+8]
	call	edx

; 1839 : 						Team_[i].Units->Type[j]->Flags[1]=0;

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+868]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+16]
	mov	edx, 4
	shl	edx, 0
	mov	DWORD PTR [ecx+edx], 0

; 1840 : 						if(level != 1)

	cmp	DWORD PTR _level$[ebp], 1
	je	SHORT $LN3@SetUnitLev

; 1841 : 							Team_[i].Units->Type[j]->Levels[1]->Refresh();

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+868]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+16]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR [ecx+edx+12]
	mov	ecx, 4
	shl	ecx, 0
	movsx	edx, WORD PTR _j$[ebp]
	movsx	esi, WORD PTR _i$[ebp]
	imul	esi, 24					; 00000018H
	mov	edi, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edi+esi+868]
	mov	edx, DWORD PTR [esi+edx*4+16]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx+12]
	mov	edx, DWORD PTR [eax+160]
	call	edx
$LN3@SetUnitLev:

; 1842 : 						Team_[i].Units->Type[j]->Levels[1]->SetFlagBitOn(C_BIT_INVISIBLE);

	push	8192					; 00002000H
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+868]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+16]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR [ecx+edx+12]
	mov	ecx, 4
	shl	ecx, 0
	movsx	edx, WORD PTR _j$[ebp]
	movsx	esi, WORD PTR _i$[ebp]
	imul	esi, 24					; 00000018H
	mov	edi, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edi+esi+868]
	mov	edx, DWORD PTR [esi+edx*4+16]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx+12]
	mov	edx, DWORD PTR [eax+8]
	call	edx

; 1843 : 						Team_[i].Units->Type[j]->Flags[2]=0;

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+868]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+16]
	mov	edx, 4
	shl	edx, 1
	mov	DWORD PTR [ecx+edx], 0

; 1844 : 						if(level != 2)

	cmp	DWORD PTR _level$[ebp], 2
	je	SHORT $LN2@SetUnitLev

; 1845 : 							Team_[i].Units->Type[j]->Levels[2]->Refresh();

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+868]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+16]
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR [ecx+edx+12]
	mov	ecx, 4
	shl	ecx, 1
	movsx	edx, WORD PTR _j$[ebp]
	movsx	esi, WORD PTR _i$[ebp]
	imul	esi, 24					; 00000018H
	mov	edi, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edi+esi+868]
	mov	edx, DWORD PTR [esi+edx*4+16]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx+12]
	mov	edx, DWORD PTR [eax+160]
	call	edx
$LN2@SetUnitLev:

; 1846 : 						Team_[i].Units->Type[j]->Levels[2]->SetFlagBitOn(C_BIT_INVISIBLE);

	push	8192					; 00002000H
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+868]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+16]
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR [ecx+edx+12]
	mov	ecx, 4
	shl	ecx, 1
	movsx	edx, WORD PTR _j$[ebp]
	movsx	esi, WORD PTR _i$[ebp]
	imul	esi, 24					; 00000018H
	mov	edi, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edi+esi+868]
	mov	edx, DWORD PTR [esi+edx*4+16]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx+12]
	mov	edx, DWORD PTR [eax+8]
	call	edx

; 1847 : 						Team_[i].Units->Type[j]->Flags[level]=1;

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+868]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+16]
	mov	edx, DWORD PTR _level$[ebp]
	mov	DWORD PTR [ecx+edx*4], 1

; 1848 : 						if(Team_[i].Units->Flags[j])

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+868]
	movsx	eax, WORD PTR _j$[ebp]
	cmp	DWORD PTR [edx+eax*4], 0
	je	$LN6@SetUnitLev

; 1849 : 						{
; 1850 : 							Team_[i].Units->Type[j]->Levels[level]->SetFlagBitOff(C_BIT_INVISIBLE);

	push	8192					; 00002000H
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+868]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+16]
	mov	eax, DWORD PTR _level$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+12]
	movsx	edx, WORD PTR _j$[ebp]
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [esi+eax+868]
	mov	edx, DWORD PTR [eax+edx*4+16]
	mov	eax, DWORD PTR _level$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+eax*4+12]
	mov	edx, DWORD PTR [esi+12]
	call	edx

; 1851 : 							Team_[i].Units->Type[j]->Levels[level]->Refresh();

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+868]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+16]
	mov	edx, DWORD PTR _level$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+12]
	movsx	ecx, WORD PTR _j$[ebp]
	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [esi+edx+868]
	mov	ecx, DWORD PTR [edx+ecx*4+16]
	mov	edx, DWORD PTR _level$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+edx*4+12]
	mov	edx, DWORD PTR [eax+160]
	call	edx
$LN6@SetUnitLev:

; 1852 : 						}
; 1853 : 					}
; 1854 : 				}
; 1855 : 		}

	jmp	$LN8@SetUnitLev
$LN10@SetUnitLev:
	jmp	$LN12@SetUnitLev
$LN11@SetUnitLev:

; 1856 : 	UI_Leave(Leave);

	mov	eax, DWORD PTR _Leave$[ebp]
	push	eax
	call	?UI_Leave@@YAXPAUF4CSECTIONHANDLE@@@Z	; UI_Leave
	add	esp, 4

; 1857 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitLevel@C_Map@@QAEXJ@Z ENDP			; C_Map::SetUnitLevel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?SetBullsEye@C_Map@@QAEXMM@Z PROC			; C_Map::SetBullsEye
; _this$ = ecx

; 1606 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1607 : 	BullsEyeX_=x;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [eax+744], xmm0

; 1608 : 	BullsEyeY_=y;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [ecx+748], xmm0

; 1609 : 
; 1610 : 	if(BullsEye_)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1148], 0
	je	SHORT $LN1@SetBullsEy

; 1611 : 		BullsEye_->SetPos(x,y); // Real World XY (where 0,0 is top left corner)

	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1148]
	call	?SetPos@C_BullsEye@@QAEXMM@Z		; C_BullsEye::SetPos
$LN1@SetBullsEy:

; 1612 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetBullsEye@C_Map@@QAEXMM@Z ENDP			; C_Map::SetBullsEye
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_tempzoom$ = -8						; size = 4
_this$ = -4						; size = 4
?ZoomOut@C_Map@@QAEXXZ PROC				; C_Map::ZoomOut
; _this$ = ecx

; 2169 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2170 : 	long tempzoom;
; 2171 : 
; 2172 : 	tempzoom=ZoomLevel_+(ZoomStep_ + (ZoomLevel_>>6));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+712]
	sar	ecx, 6
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+724]
	add	eax, ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+712]
	mov	DWORD PTR _tempzoom$[ebp], eax

; 2173 : 	if(tempzoom > MinZoomLevel_)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _tempzoom$[ebp]
	cmp	eax, DWORD PTR [edx+716]
	jle	SHORT $LN3@ZoomOut

; 2174 : 		tempzoom=MinZoomLevel_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+716]
	mov	DWORD PTR _tempzoom$[ebp], edx
$LN3@ZoomOut:

; 2175 : 	if(tempzoom < MaxZoomLevel_)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _tempzoom$[ebp]
	cmp	ecx, DWORD PTR [eax+720]
	jge	SHORT $LN2@ZoomOut

; 2176 : 		tempzoom=MaxZoomLevel_;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+720]
	mov	DWORD PTR _tempzoom$[ebp], eax
$LN2@ZoomOut:

; 2177 : 	if(tempzoom != ZoomLevel_)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _tempzoom$[ebp]
	cmp	edx, DWORD PTR [ecx+712]
	je	SHORT $LN4@ZoomOut

; 2178 : 	{
; 2179 : 		ZoomLevel_=tempzoom;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _tempzoom$[ebp]
	mov	DWORD PTR [eax+712], ecx

; 2180 : 		CalculateDrawingParams();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateDrawingParams@C_Map@@AAEXXZ	; C_Map::CalculateDrawingParams
$LN4@ZoomOut:

; 2181 : 	}
; 2182 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ZoomOut@C_Map@@QAEXXZ ENDP				; C_Map::ZoomOut
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_tempzoom$ = -8						; size = 4
_this$ = -4						; size = 4
?ZoomIn@C_Map@@QAEXXZ PROC				; C_Map::ZoomIn
; _this$ = ecx

; 2153 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2154 : 	long tempzoom;
; 2155 : 
; 2156 : 	tempzoom=ZoomLevel_-(ZoomStep_ + (ZoomLevel_>>6));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+712]
	sar	ecx, 6
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+724]
	add	eax, ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+712]
	sub	edx, eax
	mov	DWORD PTR _tempzoom$[ebp], edx

; 2157 : 	if(tempzoom > MinZoomLevel_)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _tempzoom$[ebp]
	cmp	ecx, DWORD PTR [eax+716]
	jle	SHORT $LN3@ZoomIn

; 2158 : 		tempzoom=MinZoomLevel_;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+716]
	mov	DWORD PTR _tempzoom$[ebp], eax
$LN3@ZoomIn:

; 2159 : 	if(tempzoom < MaxZoomLevel_)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _tempzoom$[ebp]
	cmp	edx, DWORD PTR [ecx+720]
	jge	SHORT $LN2@ZoomIn

; 2160 : 		tempzoom=MaxZoomLevel_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+720]
	mov	DWORD PTR _tempzoom$[ebp], ecx
$LN2@ZoomIn:

; 2161 : 	if(tempzoom != ZoomLevel_)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _tempzoom$[ebp]
	cmp	eax, DWORD PTR [edx+712]
	je	SHORT $LN4@ZoomIn

; 2162 : 	{
; 2163 : 		ZoomLevel_=tempzoom;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _tempzoom$[ebp]
	mov	DWORD PTR [ecx+712], edx

; 2164 : 		CalculateDrawingParams();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateDrawingParams@C_Map@@AAEXXZ	; C_Map::CalculateDrawingParams
$LN4@ZoomIn:

; 2165 : 	}
; 2166 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ZoomIn@C_Map@@QAEXXZ ENDP				; C_Map::ZoomIn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_zoom$ = 8						; size = 2
?SetZoomLevel@C_Map@@QAEXF@Z PROC			; C_Map::SetZoomLevel
; _this$ = ecx

; 2144 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2145 : 	if(zoom >= _MIN_ZOOM_LEVEL_ && zoom <= _MAX_ZOOM_LEVEL_ && zoom != ZoomLevel_ && Map_)

	movsx	eax, WORD PTR _zoom$[ebp]
	cmp	eax, 1
	jl	SHORT $LN2@SetZoomLev
	movsx	ecx, WORD PTR _zoom$[ebp]
	cmp	ecx, 32					; 00000020H
	jg	SHORT $LN2@SetZoomLev
	movsx	edx, WORD PTR _zoom$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR [eax+712]
	je	SHORT $LN2@SetZoomLev
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+808], 0
	je	SHORT $LN2@SetZoomLev

; 2146 : 	{
; 2147 : 		ZoomLevel_=Map_->GetW()/zoom;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+808]
	call	?GetW@C_Base@@QAEJXZ			; C_Base::GetW
	movsx	ecx, WORD PTR _zoom$[ebp]
	cdq
	idiv	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+712], eax

; 2148 : 		CalculateDrawingParams();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateDrawingParams@C_Map@@AAEXXZ	; C_Map::CalculateDrawingParams
$LN2@SetZoomLev:

; 2149 : 	}
; 2150 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetZoomLevel@C_Map@@QAEXF@Z ENDP			; C_Map::SetZoomLevel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_cx$ = -20						; size = 4
_cy$ = -16						; size = 4
_h$ = -12						; size = 4
_w$ = -8						; size = 4
_this$ = -4						; size = 4
?FitFlightPlan@C_Map@@QAEXXZ PROC			; C_Map::FitFlightPlan
; _this$ = ecx

; 1686 : { // Based on CurWP_'s x & y (ie: CurWPArea_)

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1687 : 	long cx,cy;
; 1688 : 	long w,h;
; 1689 : 
; 1690 : 	if(CurWPArea_.left < 0 || CurWPArea_.top < 0 || CurWPArea_.right < 0 || CurWPArea_.bottom < 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1100], 0
	jl	SHORT $LN5@FitFlightP
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1104], 0
	jl	SHORT $LN5@FitFlightP
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1108], 0
	jl	SHORT $LN5@FitFlightP
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1112], 0
	jge	SHORT $LN6@FitFlightP
$LN5@FitFlightP:

; 1691 : 		return;

	jmp	$LN7@FitFlightP
$LN6@FitFlightP:

; 1692 : 
; 1693 : 	w=(CurWPArea_.right - CurWPArea_.left) / 1000; // 1100 = ft -> 500m * 1.64 (allow for icons to fit on map also)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+1108]
	sub	eax, DWORD PTR [edx+1100]
	cdq
	mov	ecx, 1000				; 000003e8H
	idiv	ecx
	mov	DWORD PTR _w$[ebp], eax

; 1694 : 	h=(CurWPArea_.bottom - CurWPArea_.top) / 1000;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1112]
	sub	ecx, DWORD PTR [eax+1104]
	mov	eax, ecx
	cdq
	mov	ecx, 1000				; 000003e8H
	idiv	ecx
	mov	DWORD PTR _h$[ebp], eax

; 1695 : 
; 1696 : 	if(w > h)

	mov	edx, DWORD PTR _w$[ebp]
	cmp	edx, DWORD PTR _h$[ebp]
	jle	SHORT $LN4@FitFlightP

; 1697 : 		ZoomLevel_=w;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _w$[ebp]
	mov	DWORD PTR [eax+712], ecx

; 1698 : 	else

	jmp	SHORT $LN3@FitFlightP
$LN4@FitFlightP:

; 1699 : 		ZoomLevel_=h;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _h$[ebp]
	mov	DWORD PTR [edx+712], eax
$LN3@FitFlightP:

; 1700 : 
; 1701 : 	if(ZoomLevel_ < MaxZoomLevel_)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+712]
	cmp	eax, DWORD PTR [edx+720]
	jge	SHORT $LN2@FitFlightP

; 1702 : 		ZoomLevel_=MaxZoomLevel_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+720]
	mov	DWORD PTR [ecx+712], eax
$LN2@FitFlightP:

; 1703 : 	if(ZoomLevel_ > MinZoomLevel_)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+712]
	cmp	eax, DWORD PTR [edx+716]
	jle	SHORT $LN1@FitFlightP

; 1704 : 		ZoomLevel_=MinZoomLevel_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+716]
	mov	DWORD PTR [ecx+712], eax
$LN1@FitFlightP:

; 1705 : 
; 1706 : 	cx=(CurWPArea_.top/1640 + CurWPArea_.bottom/1640)/2;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+1104]
	cdq
	mov	ecx, 1640				; 00000668H
	idiv	ecx
	mov	ecx, eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1112]
	cdq
	mov	esi, 1640				; 00000668H
	idiv	esi
	add	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _cx$[ebp], eax

; 1707 : 	cy=static_cast<long>(((maxy - CurWPArea_.left)/1640 + (maxy - CurWPArea_.right)/1640)/2);

	mov	eax, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+1100]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+732]
	subss	xmm1, xmm0
	divss	xmm1, DWORD PTR __real@44cd0000
	mov	edx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [edx+1108]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm2, DWORD PTR [eax+732]
	subss	xmm2, xmm0
	divss	xmm2, DWORD PTR __real@44cd0000
	addss	xmm1, xmm2
	divss	xmm1, DWORD PTR __real@40000000
	cvttss2si ecx, xmm1
	mov	DWORD PTR _cy$[ebp], ecx

; 1708 : 
; 1709 : 	SetMapCenter(cx,cy);

	mov	edx, DWORD PTR _cy$[ebp]
	push	edx
	mov	eax, DWORD PTR _cx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMapCenter@C_Map@@QAEXJJ@Z		; C_Map::SetMapCenter
$LN7@FitFlightP:

; 1710 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?FitFlightPlan@C_Map@@QAEXXZ ENDP			; C_Map::FitFlightPlan
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\include\cmap.h
;	COMDAT ?GetTeamFlags@C_Map@@QAEJJ@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_TeamID$ = 8						; size = 4
?GetTeamFlags@C_Map@@QAEJJ@Z PROC			; C_Map::GetTeamFlags, COMDAT
; _this$ = ecx

; 174  : 		long GetTeamFlags(long TeamID) {  if(TeamID >= 0 && TeamID < _MAX_TEAMS_) return(TeamFlags_[TeamID]); return(0); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	cmp	DWORD PTR _TeamID$[ebp], 0
	jl	SHORT $LN1@GetTeamFla
	cmp	DWORD PTR _TeamID$[ebp], 8
	jge	SHORT $LN1@GetTeamFla
	mov	eax, DWORD PTR _TeamID$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4+828]
	jmp	SHORT $LN2@GetTeamFla
$LN1@GetTeamFla:
	xor	eax, eax
$LN2@GetTeamFla:
	mov	esp, ebp
	pop	ebp
	ret	4
?GetTeamFlags@C_Map@@QAEJJ@Z ENDP			; C_Map::GetTeamFlags
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\include\cmap.h
;	COMDAT ?SetTeamFlags@C_Map@@QAEXJJ@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_TeamID$ = 8						; size = 4
_flags$ = 12						; size = 4
?SetTeamFlags@C_Map@@QAEXJJ@Z PROC			; C_Map::SetTeamFlags, COMDAT
; _this$ = ecx

; 173  : 		void SetTeamFlags(long TeamID,long flags) { if(TeamID >= 0 && TeamID < _MAX_TEAMS_) TeamFlags_[TeamID]=flags; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	cmp	DWORD PTR _TeamID$[ebp], 0
	jl	SHORT $LN2@SetTeamFla
	cmp	DWORD PTR _TeamID$[ebp], 8
	jge	SHORT $LN2@SetTeamFla
	mov	eax, DWORD PTR _TeamID$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _flags$[ebp]
	mov	DWORD PTR [ecx+eax*4+828], edx
$LN2@SetTeamFla:
	mov	esp, ebp
	pop	ebp
	ret	8
?SetTeamFlags@C_Map@@QAEXJJ@Z ENDP			; C_Map::SetTeamFlags
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_win$ = 8						; size = 4
?SetWPZWindow@C_Map@@QAEXPAVC_Window@@@Z PROC		; C_Map::SetWPZWindow
; _this$ = ecx

; 2139 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2140 : 	WPZWindow_=win;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _win$[ebp]
	mov	DWORD PTR [eax+1128], ecx

; 2141 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetWPZWindow@C_Map@@QAEXPAVC_Window@@@Z ENDP		; C_Map::SetWPZWindow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_win$ = 8						; size = 4
?SetWindow@C_Map@@QAEXPAVC_Window@@@Z PROC		; C_Map::SetWindow
; _this$ = ecx

; 2115 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2116 : 	if(win)

	cmp	DWORD PTR _win$[ebp], 0
	je	SHORT $LN4@SetWindow

; 2117 : 	{
; 2118 : 		if(DrawWindow_)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1124], 0
	je	SHORT $LN2@SetWindow

; 2119 : 			RemoveListsFromWindow();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveListsFromWindow@C_Map@@AAEXXZ	; C_Map::RemoveListsFromWindow
$LN2@SetWindow:

; 2120 : 
; 2121 : 		DrawWindow_=win;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _win$[ebp]
	mov	DWORD PTR [ecx+1124], edx

; 2122 : 
; 2123 : 		if (DrawWindow_)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1124], 0
	je	SHORT $LN4@SetWindow

; 2124 : 		{
; 2125 : 			DrawRect_=DrawWindow_->ClientArea_[0];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1124]
	mov	eax, 16					; 00000010H
	imul	eax, 0
	lea	ecx, DWORD PTR [edx+eax+168]
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1132				; 0000046cH
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx

; 2126 : 			AddListsToWindow();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddListsToWindow@C_Map@@AAEXXZ		; C_Map::AddListsToWindow

; 2127 : 			CalculateDrawingParams();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateDrawingParams@C_Map@@AAEXXZ	; C_Map::CalculateDrawingParams
$LN4@SetWindow:

; 2128 : 		}
; 2129 : 	}
; 2130 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetWindow@C_Map@@QAEXPAVC_Window@@@Z ENDP		; C_Map::SetWindow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
$T2 = -28						; size = 4
tv75 = -24						; size = 4
$T3 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_ID$ = 8						; size = 4
?SetMapImage@C_Map@@QAEXJ@Z PROC			; C_Map::SetMapImage
; _this$ = ecx

; 2095 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SetMapImage@C_Map@@QAEXJ@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2096 : 	MapID=ID;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _ID$[ebp]
	mov	DWORD PTR [eax+804], ecx

; 2097 : 	if(Map_ == NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+808], 0
	jne	SHORT $LN2@SetMapImag

; 2098 : 	{
; 2099 : 		Map_=new C_ScaleBitmap;

	push	3344					; 00000d10H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN5@SetMapImag
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0C_ScaleBitmap@@QAE@XZ		; C_ScaleBitmap::C_ScaleBitmap
	mov	DWORD PTR tv75[ebp], eax
	jmp	SHORT $LN6@SetMapImag
$LN5@SetMapImag:
	mov	DWORD PTR tv75[ebp], 0
$LN6@SetMapImag:
	mov	eax, DWORD PTR tv75[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR [ecx+808], edx

; 2100 : 		Map_->Setup(5551200,0,MapID);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+804]
	push	ecx
	push	0
	push	5551200					; 0054b460H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+808]
	call	?Setup@C_ScaleBitmap@@QAEXJFJ@Z		; C_ScaleBitmap::Setup
$LN2@SetMapImag:

; 2101 : 	}
; 2102 : 	Map_->SetImage(MapID);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+804]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+808]
	call	?SetImage@C_ScaleBitmap@@QAEXJ@Z	; C_ScaleBitmap::SetImage

; 2103 : 	maxy=(float)(Map_->GetH())*FEET_PER_PIXEL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	call	?GetH@C_Base@@QAEJXZ			; C_Base::GetH
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@44ccffae
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+732], xmm0

; 2104 : 	MinZoomLevel_=Map_->GetW()/_MIN_ZOOM_LEVEL_;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+808]
	call	?GetW@C_Base@@QAEJXZ			; C_Base::GetW
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+716], eax

; 2105 : 	MaxZoomLevel_=Map_->GetW()/_MAX_ZOOM_LEVEL_;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+808]
	call	?GetW@C_Base@@QAEJXZ			; C_Base::GetW
	cdq
	and	edx, 31					; 0000001fH
	add	eax, edx
	sar	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+720], eax

; 2106 : 	ZoomStep_=(MinZoomLevel_ - MaxZoomLevel_) / 64;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+716]
	sub	ecx, DWORD PTR [eax+720]
	mov	eax, ecx
	cdq
	and	edx, 63					; 0000003fH
	add	eax, edx
	sar	eax, 6
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+724], eax

; 2107 : 	if(Map_ && DrawWindow_)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+808], 0
	je	SHORT $LN1@SetMapImag
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1124], 0
	je	SHORT $LN1@SetMapImag

; 2108 : 	{
; 2109 : 		DrawRect_=DrawWindow_->ClientArea_[0];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1124]
	mov	ecx, 16					; 00000010H
	imul	ecx, 0
	lea	edx, DWORD PTR [eax+ecx+168]
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1132				; 0000046cH
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx

; 2110 : 		CalculateDrawingParams();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateDrawingParams@C_Map@@AAEXXZ	; C_Map::CalculateDrawingParams
$LN1@SetMapImag:

; 2111 : 	}
; 2112 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SetMapImage@C_Map@@QAEXJ@Z$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?SetMapImage@C_Map@@QAEXJ@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SetMapImage@C_Map@@QAEXJ@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetMapImage@C_Map@@QAEXJ@Z ENDP			; C_Map::SetMapImage
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
tv746 = -172						; size = 4
$T1 = -168						; size = 4
$T2 = -164						; size = 4
$T3 = -160						; size = 4
tv688 = -156						; size = 4
$T4 = -152						; size = 4
$T5 = -148						; size = 4
$T6 = -144						; size = 4
tv662 = -140						; size = 4
tv300 = -136						; size = 4
$T7 = -132						; size = 4
$T8 = -128						; size = 4
tv632 = -124						; size = 4
$T9 = -120						; size = 4
$T10 = -116						; size = 4
tv377 = -112						; size = 4
$T11 = -108						; size = 4
$T12 = -104						; size = 4
tv580 = -100						; size = 4
$T13 = -96						; size = 4
$T14 = -92						; size = 4
tv223 = -88						; size = 4
$T15 = -84						; size = 4
tv153 = -80						; size = 4
$T16 = -76						; size = 4
tv95 = -72						; size = 4
tv493 = -68						; size = 4
$T17 = -64						; size = 4
$T18 = -60						; size = 4
$T19 = -56						; size = 4
$T20 = -52						; size = 4
$T21 = -48						; size = 4
$T22 = -44						; size = 4
$T23 = -40						; size = 4
$T24 = -36						; size = 4
$T25 = -32						; size = 4
$T26 = -28						; size = 4
$T27 = -24						; size = 4
$T28 = -20						; size = 4
_k$ = -16						; size = 2
_this$ = -12						; size = 4
_j$ = -8						; size = 2
_i$ = -4						; size = 2
?Cleanup@C_Map@@QAEXXZ PROC				; C_Map::Cleanup
; _this$ = ecx

; 103  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 172				; 000000acH
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 	short i,j,k;
; 105  : 
; 106  : 	if(DrawWindow_)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1124], 0
	je	SHORT $LN41@Cleanup

; 107  : 	{
; 108  : 		RemoveListsFromWindow();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveListsFromWindow@C_Map@@AAEXXZ	; C_Map::RemoveListsFromWindow

; 109  : 		DrawWindow_=NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1124], 0
$LN41@Cleanup:

; 110  : 	}
; 111  : 	if(WPZWindow_)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1128], 0
	je	SHORT $LN40@Cleanup

; 112  : 		WPZWindow_=NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1128], 0
$LN40@Cleanup:

; 113  : 	if(Map_)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+808], 0
	je	SHORT $LN39@Cleanup

; 114  : 	{
; 115  : 		Map_->Cleanup();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+808]
	mov	eax, DWORD PTR [edx+176]
	call	eax

; 116  : 		delete Map_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	mov	DWORD PTR $T4[ebp], edx
	mov	eax, DWORD PTR $T4[ebp]
	mov	DWORD PTR $T21[ebp], eax
	cmp	DWORD PTR $T21[ebp], 0
	je	SHORT $LN44@Cleanup
	push	1
	mov	ecx, DWORD PTR $T21[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T21[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv95[ebp], eax
	jmp	SHORT $LN45@Cleanup
$LN44@Cleanup:
	mov	DWORD PTR tv95[ebp], 0
$LN45@Cleanup:

; 117  : 		Map_=NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+808], 0
$LN39@Cleanup:

; 118  : 	}
; 119  : 
; 120  : 	if(BullsEye_)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1148], 0
	je	SHORT $LN38@Cleanup

; 121  : 	{
; 122  : 		BullsEye_->Cleanup();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1148]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+1148]
	mov	edx, DWORD PTR [eax+176]
	call	edx

; 123  : 		delete BullsEye_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1148]
	mov	DWORD PTR $T3[ebp], ecx
	mov	edx, DWORD PTR $T3[ebp]
	mov	DWORD PTR $T19[ebp], edx
	cmp	DWORD PTR $T19[ebp], 0
	je	SHORT $LN46@Cleanup
	push	1
	mov	eax, DWORD PTR $T19[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T19[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv153[ebp], eax
	jmp	SHORT $LN47@Cleanup
$LN46@Cleanup:
	mov	DWORD PTR tv153[ebp], 0
$LN47@Cleanup:

; 124  : 		BullsEye_=NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1148], 0
$LN38@Cleanup:

; 125  : 	}
; 126  : 
; 127  : 	for(i=0;i<_MAX_TEAMS_;i++)

	xor	edx, edx
	mov	WORD PTR _i$[ebp], dx
	jmp	SHORT $LN37@Cleanup
$LN36@Cleanup:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
$LN37@Cleanup:
	movsx	ecx, WORD PTR _i$[ebp]
	cmp	ecx, 8
	jge	$LN35@Cleanup

; 128  : 	{
; 129  : 		if(Team_[i].Threats)

	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+edx+860], 0
	je	$LN34@Cleanup

; 130  : 		{
; 131  : 			for(j=0;j<_MAP_NUM_THREAT_TYPES_;j++)

	xor	ecx, ecx
	mov	WORD PTR _j$[ebp], cx
	jmp	SHORT $LN33@Cleanup
$LN32@Cleanup:
	mov	dx, WORD PTR _j$[ebp]
	add	dx, 1
	mov	WORD PTR _j$[ebp], dx
$LN33@Cleanup:
	movsx	eax, WORD PTR _j$[ebp]
	cmp	eax, 4
	jge	$LN31@Cleanup

; 132  : 				if(Team_[i].Threats->Type[j])

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+860]
	movsx	ecx, WORD PTR _j$[ebp]
	cmp	DWORD PTR [eax+ecx*4+16], 0
	je	SHORT $LN30@Cleanup

; 133  : 				{
; 134  : 					Team_[i].Threats->Type[j]->Cleanup();

	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+860]
	movsx	edx, WORD PTR _j$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+16]
	movsx	ecx, WORD PTR _j$[ebp]
	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [esi+edx+860]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4+16]
	mov	edx, DWORD PTR [eax+176]
	call	edx

; 135  : 					delete Team_[i].Threats->Type[j];

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+860]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+16]
	mov	DWORD PTR $T8[ebp], ecx
	mov	edx, DWORD PTR $T8[ebp]
	mov	DWORD PTR $T25[ebp], edx
	cmp	DWORD PTR $T25[ebp], 0
	je	SHORT $LN48@Cleanup
	push	1
	mov	eax, DWORD PTR $T25[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T25[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv223[ebp], eax
	jmp	SHORT $LN30@Cleanup
$LN48@Cleanup:
	mov	DWORD PTR tv223[ebp], 0
$LN30@Cleanup:

; 136  : 				}

	jmp	$LN32@Cleanup
$LN31@Cleanup:

; 137  : 			delete Team_[i].Threats;

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+860]
	mov	DWORD PTR $T17[ebp], eax
	mov	ecx, DWORD PTR $T17[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 138  : 			Team_[i].Threats=NULL;

	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+860], 0
$LN34@Cleanup:

; 139  : 		}
; 140  : 		if(Team_[i].Objectives)

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+ecx+876], 0
	je	$LN29@Cleanup

; 141  : 		{
; 142  : 			for(j=0;j<_MAP_NUM_OBJ_TYPES_;j++)

	xor	eax, eax
	mov	WORD PTR _j$[ebp], ax
	jmp	SHORT $LN28@Cleanup
$LN27@Cleanup:
	mov	cx, WORD PTR _j$[ebp]
	add	cx, 1
	mov	WORD PTR _j$[ebp], cx
$LN28@Cleanup:
	movsx	edx, WORD PTR _j$[ebp]
	cmp	edx, 14					; 0000000eH
	jge	$LN26@Cleanup

; 143  : 				if(Team_[i].Objectives->Type[j])

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+876]
	movsx	eax, WORD PTR _j$[ebp]
	cmp	DWORD PTR [edx+eax*4+56], 0
	je	$LN25@Cleanup

; 144  : 				{
; 145  : 					Team_[i].Objectives->Type[j]->Cleanup();

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+876]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+56]
	movsx	eax, WORD PTR _j$[ebp]
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+876]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4+56]
	mov	eax, DWORD PTR [edx+176]
	call	eax

; 146  : 					delete Team_[i].Objectives->Type[j];

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+876]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+56]
	mov	DWORD PTR $T13[ebp], edx
	mov	eax, DWORD PTR $T13[ebp]
	mov	DWORD PTR $T28[ebp], eax
	cmp	DWORD PTR $T28[ebp], 0
	je	SHORT $LN50@Cleanup
	push	1
	mov	ecx, DWORD PTR $T28[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T28[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv300[ebp], eax
	jmp	SHORT $LN25@Cleanup
$LN50@Cleanup:
	mov	DWORD PTR tv300[ebp], 0
$LN25@Cleanup:

; 147  : 				}

	jmp	$LN27@Cleanup
$LN26@Cleanup:

; 148  : 			delete Team_[i].Objectives;

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+876]
	mov	DWORD PTR $T12[ebp], eax
	mov	ecx, DWORD PTR $T12[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 149  : 			Team_[i].Objectives=NULL;

	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+876], 0
$LN29@Cleanup:

; 150  : 		}
; 151  : 		if(Team_[i].NavalUnits)

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+ecx+872], 0
	je	$LN24@Cleanup

; 152  : 		{
; 153  : 			for(j=0;j<_MAP_NUM_NAV_TYPES_;j++)

	xor	eax, eax
	mov	WORD PTR _j$[ebp], ax
	jmp	SHORT $LN23@Cleanup
$LN22@Cleanup:
	mov	cx, WORD PTR _j$[ebp]
	add	cx, 1
	mov	WORD PTR _j$[ebp], cx
$LN23@Cleanup:
	movsx	edx, WORD PTR _j$[ebp]
	cmp	edx, 2
	jge	$LN21@Cleanup

; 154  : 				if(Team_[i].NavalUnits->Type[j])

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+872]
	movsx	eax, WORD PTR _j$[ebp]
	cmp	DWORD PTR [edx+eax*4+8], 0
	je	$LN20@Cleanup

; 155  : 				{
; 156  : 					Team_[i].NavalUnits->Type[j]->Cleanup();

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+872]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+8]
	movsx	eax, WORD PTR _j$[ebp]
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+872]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4+8]
	mov	eax, DWORD PTR [edx+176]
	call	eax

; 157  : 					delete Team_[i].NavalUnits->Type[j];

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+872]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+8]
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR $T23[ebp], eax
	cmp	DWORD PTR $T23[ebp], 0
	je	SHORT $LN52@Cleanup
	push	1
	mov	ecx, DWORD PTR $T23[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T23[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv377[ebp], eax
	jmp	SHORT $LN20@Cleanup
$LN52@Cleanup:
	mov	DWORD PTR tv377[ebp], 0
$LN20@Cleanup:

; 158  : 				}

	jmp	$LN22@Cleanup
$LN21@Cleanup:

; 159  : 			delete Team_[i].NavalUnits;

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+872]
	mov	DWORD PTR $T6[ebp], eax
	mov	ecx, DWORD PTR $T6[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 160  : 			Team_[i].NavalUnits=NULL;

	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+872], 0
$LN24@Cleanup:

; 161  : 		}
; 162  : 		if(Team_[i].Units)

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+ecx+868], 0
	je	$LN19@Cleanup

; 163  : 		{
; 164  : 			for(j=0;j<_MAP_NUM_GND_TYPES_;j++)

	xor	eax, eax
	mov	WORD PTR _j$[ebp], ax
	jmp	SHORT $LN18@Cleanup
$LN17@Cleanup:
	mov	cx, WORD PTR _j$[ebp]
	add	cx, 1
	mov	WORD PTR _j$[ebp], cx
$LN18@Cleanup:
	movsx	edx, WORD PTR _j$[ebp]
	cmp	edx, 4
	jge	$LN16@Cleanup

; 165  : 				if(Team_[i].Units->Type[j])

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+868]
	movsx	eax, WORD PTR _j$[ebp]
	cmp	DWORD PTR [edx+eax*4+16], 0
	je	$LN15@Cleanup

; 166  : 				{
; 167  : 					if(Team_[i].Units->Type[j])

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+868]
	movsx	ecx, WORD PTR _j$[ebp]
	cmp	DWORD PTR [eax+ecx*4+16], 0
	je	$LN15@Cleanup

; 168  : 					{
; 169  : 						for(k=0;k<_MAP_NUM_GND_LEVELS_;k++)

	xor	edx, edx
	mov	WORD PTR _k$[ebp], dx
	jmp	SHORT $LN13@Cleanup
$LN12@Cleanup:
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$LN13@Cleanup:
	movsx	ecx, WORD PTR _k$[ebp]
	cmp	ecx, 3
	jge	$LN11@Cleanup

; 170  : 							if(Team_[i].Units->Type[j]->Levels[k])

	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+868]
	movsx	edx, WORD PTR _j$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+16]
	movsx	ecx, WORD PTR _k$[ebp]
	cmp	DWORD PTR [eax+ecx*4+12], 0
	je	$LN10@Cleanup

; 171  : 							{
; 172  : 								Team_[i].Units->Type[j]->Levels[k]->Cleanup();

	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+868]
	movsx	edx, WORD PTR _j$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+16]
	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+12]
	movsx	eax, WORD PTR _k$[ebp]
	movsx	ecx, WORD PTR _j$[ebp]
	movsx	esi, WORD PTR _i$[ebp]
	imul	esi, 24					; 00000018H
	mov	edi, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edi+esi+868]
	mov	ecx, DWORD PTR [esi+ecx*4+16]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4+12]
	mov	eax, DWORD PTR [edx+176]
	call	eax

; 173  : 								delete Team_[i].Units->Type[j]->Levels[k];

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+868]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+16]
	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+12]
	mov	DWORD PTR $T9[ebp], ecx
	mov	edx, DWORD PTR $T9[ebp]
	mov	DWORD PTR $T27[ebp], edx
	cmp	DWORD PTR $T27[ebp], 0
	je	SHORT $LN54@Cleanup
	push	1
	mov	eax, DWORD PTR $T27[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T27[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv493[ebp], eax
	jmp	SHORT $LN10@Cleanup
$LN54@Cleanup:
	mov	DWORD PTR tv493[ebp], 0
$LN10@Cleanup:

; 174  : 							}

	jmp	$LN12@Cleanup
$LN11@Cleanup:

; 175  : 						delete Team_[i].Units->Type[j];

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+868]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+16]
	mov	DWORD PTR $T16[ebp], edx
	mov	eax, DWORD PTR $T16[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN15@Cleanup:

; 176  : 					}
; 177  : 				}

	jmp	$LN17@Cleanup
$LN16@Cleanup:

; 178  : 			delete Team_[i].Units;

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+868]
	mov	DWORD PTR $T15[ebp], eax
	mov	ecx, DWORD PTR $T15[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 179  : 			Team_[i].Units=NULL;

	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+868], 0
$LN19@Cleanup:

; 180  : 		}
; 181  : 		if(Team_[i].AirUnits)

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+ecx+864], 0
	je	$LN9@Cleanup

; 182  : 		{
; 183  : 			for(j=0;j<_MAP_NUM_AIR_TYPES_;j++)

	xor	eax, eax
	mov	WORD PTR _j$[ebp], ax
	jmp	SHORT $LN8@Cleanup
$LN7@Cleanup:
	mov	cx, WORD PTR _j$[ebp]
	add	cx, 1
	mov	WORD PTR _j$[ebp], cx
$LN8@Cleanup:
	movsx	edx, WORD PTR _j$[ebp]
	cmp	edx, 5
	jge	$LN6@Cleanup

; 184  : 				if(Team_[i].AirUnits->Type[j])

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+864]
	movsx	eax, WORD PTR _j$[ebp]
	cmp	DWORD PTR [edx+eax*4+20], 0
	je	SHORT $LN5@Cleanup

; 185  : 				{
; 186  : 					Team_[i].AirUnits->Type[j]->Cleanup();

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+864]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+20]
	movsx	eax, WORD PTR _j$[ebp]
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+864]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4+20]
	mov	eax, DWORD PTR [edx+176]
	call	eax

; 187  : 					delete Team_[i].AirUnits->Type[j];

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+864]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+20]
	mov	DWORD PTR $T14[ebp], edx
	mov	eax, DWORD PTR $T14[ebp]
	mov	DWORD PTR $T26[ebp], eax
	cmp	DWORD PTR $T26[ebp], 0
	je	SHORT $LN56@Cleanup
	push	1
	mov	ecx, DWORD PTR $T26[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T26[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv580[ebp], eax
	jmp	SHORT $LN5@Cleanup
$LN56@Cleanup:
	mov	DWORD PTR tv580[ebp], 0
$LN5@Cleanup:

; 188  : 				}

	jmp	$LN7@Cleanup
$LN6@Cleanup:

; 189  : 			delete Team_[i].AirUnits;

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+864]
	mov	DWORD PTR $T11[ebp], eax
	mov	ecx, DWORD PTR $T11[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 190  : 			Team_[i].AirUnits=NULL;

	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+864], 0
$LN9@Cleanup:

; 191  : 		}
; 192  : 		if(Team_[i].Waypoints)

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+ecx+880], 0
	je	SHORT $LN4@Cleanup

; 193  : 		{
; 194  : 			Team_[i].Waypoints->Cleanup();

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+880]
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax+880]
	mov	eax, DWORD PTR [edx+176]
	call	eax

; 195  : 			delete Team_[i].Waypoints;

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+880]
	mov	DWORD PTR $T10[ebp], eax
	mov	ecx, DWORD PTR $T10[ebp]
	mov	DWORD PTR $T24[ebp], ecx
	cmp	DWORD PTR $T24[ebp], 0
	je	SHORT $LN58@Cleanup
	push	1
	mov	edx, DWORD PTR $T24[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T24[ebp]
	mov	edx, DWORD PTR [eax]
	call	edx
	mov	DWORD PTR tv632[ebp], eax
	jmp	SHORT $LN59@Cleanup
$LN58@Cleanup:
	mov	DWORD PTR tv632[ebp], 0
$LN59@Cleanup:

; 196  : 			Team_[i].Waypoints=NULL;

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+880], 0
$LN4@Cleanup:

; 197  : 		}
; 198  : 	}

	jmp	$LN36@Cleanup
$LN35@Cleanup:

; 199  : 	if(CurIcons_)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1116], 0
	je	SHORT $LN3@Cleanup

; 200  : 	{
; 201  : 		CurIcons_->Cleanup();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1116]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+1116]
	mov	edx, DWORD PTR [eax+176]
	call	edx

; 202  : 		delete CurIcons_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1116]
	mov	DWORD PTR $T7[ebp], ecx
	mov	edx, DWORD PTR $T7[ebp]
	mov	DWORD PTR $T22[ebp], edx
	cmp	DWORD PTR $T22[ebp], 0
	je	SHORT $LN60@Cleanup
	push	1
	mov	eax, DWORD PTR $T22[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T22[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv662[ebp], eax
	jmp	SHORT $LN61@Cleanup
$LN60@Cleanup:
	mov	DWORD PTR tv662[ebp], 0
$LN61@Cleanup:

; 203  : 		CurIcons_=NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1116], 0
$LN3@Cleanup:

; 204  : 	}
; 205  : 	if(CurWP_)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1092], 0
	je	SHORT $LN2@Cleanup

; 206  : 	{
; 207  : 		CurWP_->Cleanup();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1092]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+1092]
	mov	edx, DWORD PTR [eax+176]
	call	edx

; 208  : 		delete CurWP_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1092]
	mov	DWORD PTR $T5[ebp], ecx
	mov	edx, DWORD PTR $T5[ebp]
	mov	DWORD PTR $T20[ebp], edx
	cmp	DWORD PTR $T20[ebp], 0
	je	SHORT $LN62@Cleanup
	push	1
	mov	eax, DWORD PTR $T20[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T20[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv688[ebp], eax
	jmp	SHORT $LN63@Cleanup
$LN62@Cleanup:
	mov	DWORD PTR tv688[ebp], 0
$LN63@Cleanup:

; 209  : 		CurWP_=NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1092], 0
$LN2@Cleanup:

; 210  : 	}
; 211  : 	if(CurWPZ_)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1096], 0
	je	SHORT $LN1@Cleanup

; 212  : 	{
; 213  : 		CurWPZ_->Cleanup();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1096]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+1096]
	mov	edx, DWORD PTR [eax+176]
	call	edx

; 214  : 		delete CurWPZ_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1096]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T18[ebp], edx
	cmp	DWORD PTR $T18[ebp], 0
	je	SHORT $LN64@Cleanup
	push	1
	mov	eax, DWORD PTR $T18[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T18[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv746[ebp], eax
	jmp	SHORT $LN65@Cleanup
$LN64@Cleanup:
	mov	DWORD PTR tv746[ebp], 0
$LN65@Cleanup:

; 215  : 		CurWPZ_=NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1096], 0
$LN1@Cleanup:

; 216  : 	}
; 217  : 	SmallMapCtrl_=NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1120], 0

; 218  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?Cleanup@C_Map@@QAEXXZ ENDP				; C_Map::Cleanup
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SetupOverlay@C_Map@@QAEXXZ PROC			; C_Map::SetupOverlay
; _this$ = ecx

; 2133 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2134 : 	if(Map_)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+808], 0
	je	SHORT $LN2@SetupOverl

; 2135 : 		Map_->InitOverlay();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+808]
	call	?InitOverlay@C_ScaleBitmap@@QAEXXZ	; C_ScaleBitmap::InitOverlay
$LN2@SetupOverl:

; 2136 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SetupOverlay@C_Map@@QAEXXZ ENDP			; C_Map::SetupOverlay
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1C_Map@@QAE@XZ PROC					; C_Map::~C_Map
; _this$ = ecx

; 97   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 98   : 	if(Map_ || DrawWindow_ || SmallMapCtrl_)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+808], 0
	jne	SHORT $LN1@C_Map
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1124], 0
	jne	SHORT $LN1@C_Map
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1120], 0
	je	SHORT $LN3@C_Map
$LN1@C_Map:

; 99   : 		Cleanup();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Cleanup@C_Map@@QAEXXZ			; C_Map::Cleanup
$LN3@C_Map:

; 100  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??1C_Map@@QAE@XZ ENDP					; C_Map::~C_Map
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0C_Map@@QAE@XZ PROC					; C_Map::C_Map
; _this$ = ecx

; 58   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1084				; 0000043cH
	call	??0VU_ID@@QAE@XZ			; VU_ID::VU_ID
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1152				; 00000480H
	call	??0VU_ID@@QAE@XZ			; VU_ID::VU_ID

; 59   : 	CenterX_=0;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+704], xmm0

; 60   : 	CenterY_=0;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+708], xmm0

; 61   : 	ZoomLevel_=_MAX_ZOOM_LEVEL_;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+712], 32			; 00000020H

; 62   : 	scale_=1.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+728], xmm0

; 63   : 	flags_=I_NEED_TO_DRAW|I_NEED_TO_DRAW_MAP;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+736], 3

; 64   : 
; 65   : 	MapID=0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+804], 0

; 66   : 	Map_=NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+808], 0

; 67   : 	memset(&MapRect_,0,sizeof(UI95_RECT));

	push	16					; 00000010H
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 812				; 0000032cH
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 68   : 
; 69   : 	memset(&TeamFlags_[0],0,sizeof(long)*_MAX_TEAMS_);

	push	32					; 00000020H
	push	0
	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+828]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 70   : 	memset(&Team_[0],0,sizeof(MAPICONS)*_MAX_TEAMS_);

	push	192					; 000000c0H
	push	0
	mov	edx, 24					; 00000018H
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+860]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 71   : 	memset(&TeamColor_[0],0,sizeof(COLORREF)*_MAX_TEAMS_);

	push	32					; 00000020H
	push	0
	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+1052]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 72   : 	CurWP_=NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1092], 0

; 73   : 	CurWPZ_=NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1096], 0

; 74   : 	WPUnitID_=FalconNullId;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR [ecx+1084], edx
	mov	eax, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR [ecx+1088], eax

; 75   : 	CurIcons_=NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1116], 0

; 76   : 	CurWPArea_.left=-1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1100], -1

; 77   : 	CurWPArea_.top=-1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1104], -1

; 78   : 	CurWPArea_.right=-1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1108], -1

; 79   : 	CurWPArea_.bottom=-1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1112], -1

; 80   : 
; 81   : 	BullsEye_=NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1148], 0

; 82   : 	Circles_=0;

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+740], cx

; 83   : 
; 84   : 	ObjectiveMask_=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+784], 0

; 85   : 	UnitMask_=0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+788], 0

; 86   : 	NavalUnitMask_=0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+792], 0

; 87   : 	AirUnitMask_=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+796], 0

; 88   : 	ThreatMask_=0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+800], 0

; 89   : 
; 90   : 	SmallMapCtrl_=NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1120], 0

; 91   : 	DrawWindow_=NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1124], 0

; 92   : 	WPZWindow_=NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1128], 0

; 93   : 	memset(&DrawRect_,0,sizeof(UI95_RECT));

	push	16					; 00000010H
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1132				; 0000046cH
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 94   : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0C_Map@@QAE@XZ ENDP					; C_Map::C_Map
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
_k$ = -12						; size = 2
_i$ = -8						; size = 2
_j$ = -4						; size = 2
?SetTeamScales@C_Map@@AAEXXZ PROC			; C_Map::SetTeamScales
; _this$ = ecx

; 2664 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 2665 : 	short i,j,k;
; 2666 : 
; 2667 : 	if(BullsEye_)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1148], 0
	je	SHORT $LN25@SetTeamSca

; 2668 : 		BullsEye_->SetScale(scale_);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+728]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1148]
	call	?SetScale@C_BullsEye@@QAEXM@Z		; C_BullsEye::SetScale
$LN25@SetTeamSca:

; 2669 : 	for(i=0;i<_MAX_TEAMS_;i++)

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax
	jmp	SHORT $LN24@SetTeamSca
$LN23@SetTeamSca:
	mov	cx, WORD PTR _i$[ebp]
	add	cx, 1
	mov	WORD PTR _i$[ebp], cx
$LN24@SetTeamSca:
	movsx	edx, WORD PTR _i$[ebp]
	cmp	edx, 8
	jge	$LN22@SetTeamSca

; 2670 : 	{
; 2671 : 		if(Team_[i].Objectives)

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax+876], 0
	je	SHORT $LN18@SetTeamSca

; 2672 : 		{
; 2673 : 			for(j=0;j<_MAP_NUM_OBJ_TYPES_;j++)

	xor	edx, edx
	mov	WORD PTR _j$[ebp], dx
	jmp	SHORT $LN20@SetTeamSca
$LN19@SetTeamSca:
	mov	ax, WORD PTR _j$[ebp]
	add	ax, 1
	mov	WORD PTR _j$[ebp], ax
$LN20@SetTeamSca:
	movsx	ecx, WORD PTR _j$[ebp]
	cmp	ecx, 14					; 0000000eH
	jge	SHORT $LN18@SetTeamSca

; 2674 : 				Team_[i].Objectives->Type[j]->SetScaleFactor(scale_);

	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+728]
	movss	DWORD PTR [esp], xmm0
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+876]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+56]
	call	?SetScaleFactor@C_MapIcon@@QAEXM@Z	; C_MapIcon::SetScaleFactor
	jmp	SHORT $LN19@SetTeamSca
$LN18@SetTeamSca:

; 2675 : 		}
; 2676 : 		if(Team_[i].NavalUnits)

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+ecx+872], 0
	je	SHORT $LN14@SetTeamSca

; 2677 : 		{
; 2678 : 			for(j=0;j<_MAP_NUM_NAV_TYPES_;j++)

	xor	eax, eax
	mov	WORD PTR _j$[ebp], ax
	jmp	SHORT $LN16@SetTeamSca
$LN15@SetTeamSca:
	mov	cx, WORD PTR _j$[ebp]
	add	cx, 1
	mov	WORD PTR _j$[ebp], cx
$LN16@SetTeamSca:
	movsx	edx, WORD PTR _j$[ebp]
	cmp	edx, 2
	jge	SHORT $LN14@SetTeamSca

; 2679 : 				Team_[i].NavalUnits->Type[j]->SetScaleFactor(scale_);

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+728]
	movss	DWORD PTR [esp], xmm0
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+872]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4+8]
	call	?SetScaleFactor@C_MapIcon@@QAEXM@Z	; C_MapIcon::SetScaleFactor
	jmp	SHORT $LN15@SetTeamSca
$LN14@SetTeamSca:

; 2680 : 		}
; 2681 : 		if(Team_[i].Units)

	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+edx+868], 0
	je	SHORT $LN10@SetTeamSca

; 2682 : 		{
; 2683 : 			for(j=0;j<_MAP_NUM_GND_TYPES_;j++)

	xor	ecx, ecx
	mov	WORD PTR _j$[ebp], cx
	jmp	SHORT $LN12@SetTeamSca
$LN11@SetTeamSca:
	mov	dx, WORD PTR _j$[ebp]
	add	dx, 1
	mov	WORD PTR _j$[ebp], dx
$LN12@SetTeamSca:
	movsx	eax, WORD PTR _j$[ebp]
	cmp	eax, 4
	jge	SHORT $LN10@SetTeamSca

; 2684 : 				for(k=0;k<_MAP_NUM_GND_LEVELS_;k++)

	xor	ecx, ecx
	mov	WORD PTR _k$[ebp], cx
	jmp	SHORT $LN9@SetTeamSca
$LN8@SetTeamSca:
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$LN9@SetTeamSca:
	movsx	eax, WORD PTR _k$[ebp]
	cmp	eax, 3
	jge	SHORT $LN7@SetTeamSca

; 2685 : 					Team_[i].Units->Type[j]->Levels[k]->SetScaleFactor(scale_);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+728]
	movss	DWORD PTR [esp], xmm0
	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+868]
	movsx	edx, WORD PTR _j$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+16]
	movsx	ecx, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4+12]
	call	?SetScaleFactor@C_MapIcon@@QAEXM@Z	; C_MapIcon::SetScaleFactor
	jmp	SHORT $LN8@SetTeamSca
$LN7@SetTeamSca:
	jmp	SHORT $LN11@SetTeamSca
$LN10@SetTeamSca:

; 2686 : 		}
; 2687 : 		if(Team_[i].AirUnits)

	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+edx+864], 0
	je	SHORT $LN3@SetTeamSca

; 2688 : 		{
; 2689 : 			for(j=0;j<_MAP_NUM_AIR_TYPES_;j++)

	xor	ecx, ecx
	mov	WORD PTR _j$[ebp], cx
	jmp	SHORT $LN5@SetTeamSca
$LN4@SetTeamSca:
	mov	dx, WORD PTR _j$[ebp]
	add	dx, 1
	mov	WORD PTR _j$[ebp], dx
$LN5@SetTeamSca:
	movsx	eax, WORD PTR _j$[ebp]
	cmp	eax, 5
	jge	SHORT $LN3@SetTeamSca

; 2690 : 				Team_[i].AirUnits->Type[j]->SetScaleFactor(scale_);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+728]
	movss	DWORD PTR [esp], xmm0
	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+864]
	movsx	edx, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4+20]
	call	?SetScaleFactor@C_MapIcon@@QAEXM@Z	; C_MapIcon::SetScaleFactor
	jmp	SHORT $LN4@SetTeamSca
$LN3@SetTeamSca:

; 2691 : 		}
; 2692 : 		if(Team_[i].Waypoints)

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax+880], 0
	je	SHORT $LN2@SetTeamSca

; 2693 : 			Team_[i].Waypoints->SetScaleFactor(scale_);

	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+728]
	movss	DWORD PTR [esp], xmm0
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+eax+880]
	call	?SetScaleFactor@C_Waypoint@@QAEXM@Z	; C_Waypoint::SetScaleFactor
$LN2@SetTeamSca:

; 2694 : 	}

	jmp	$LN23@SetTeamSca
$LN22@SetTeamSca:

; 2695 : 	if(CurWP_)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1092], 0
	je	SHORT $LN1@SetTeamSca

; 2696 : 		CurWP_->SetScaleFactor(scale_);

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+728]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1092]
	call	?SetScaleFactor@C_Waypoint@@QAEXM@Z	; C_Waypoint::SetScaleFactor
$LN1@SetTeamSca:

; 2697 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SetTeamScales@C_Map@@AAEXXZ ENDP			; C_Map::SetTeamScales
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
_k$ = -12						; size = 2
_i$ = -8						; size = 2
_j$ = -4						; size = 2
?RemoveListsFromWindow@C_Map@@AAEXXZ PROC		; C_Map::RemoveListsFromWindow
; _this$ = ecx

; 2624 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 2625 : 	short i,j,k;
; 2626 : 
; 2627 : 	if(DrawWindow_ == NULL) return;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1124], 0
	jne	SHORT $LN33@RemoveList
	jmp	$LN34@RemoveList
$LN33@RemoveList:

; 2628 : 
; 2629 : 	DrawWindow_->RemoveControl(Map_->GetID());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+808]
	call	?GetID@C_Base@@QAEJXZ			; C_Base::GetID
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1124]
	call	?RemoveControl@C_Window@@QAEXJ@Z	; C_Window::RemoveControl

; 2630 : 	if(BullsEye_)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1148], 0
	je	SHORT $LN32@RemoveList

; 2631 : 		DrawWindow_->RemoveControl(BullsEye_->GetID());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1148]
	call	?GetID@C_Base@@QAEJXZ			; C_Base::GetID
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1124]
	call	?RemoveControl@C_Window@@QAEXJ@Z	; C_Window::RemoveControl
$LN32@RemoveList:

; 2632 : 	for(i=0;i<_MAX_TEAMS_;i++)

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax
	jmp	SHORT $LN31@RemoveList
$LN30@RemoveList:
	mov	cx, WORD PTR _i$[ebp]
	add	cx, 1
	mov	WORD PTR _i$[ebp], cx
$LN31@RemoveList:
	movsx	edx, WORD PTR _i$[ebp]
	cmp	edx, 8
	jge	$LN29@RemoveList

; 2633 : 	{
; 2634 : 		if(Team_[i].Objectives)

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax+876], 0
	je	SHORT $LN28@RemoveList

; 2635 : 			for(j=0;j<_MAP_NUM_OBJ_TYPES_;j++)

	xor	edx, edx
	mov	WORD PTR _j$[ebp], dx
	jmp	SHORT $LN27@RemoveList
$LN26@RemoveList:
	mov	ax, WORD PTR _j$[ebp]
	add	ax, 1
	mov	WORD PTR _j$[ebp], ax
$LN27@RemoveList:
	movsx	ecx, WORD PTR _j$[ebp]
	cmp	ecx, 14					; 0000000eH
	jge	SHORT $LN28@RemoveList

; 2636 : 				if(Team_[i].Objectives->Type[j])

	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+876]
	movsx	edx, WORD PTR _j$[ebp]
	cmp	DWORD PTR [ecx+edx*4+56], 0
	je	SHORT $LN24@RemoveList

; 2637 : 					DrawWindow_->RemoveControl(Team_[i].Objectives->Type[j]->GetID());

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+876]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+56]
	call	?GetID@C_Base@@QAEJXZ			; C_Base::GetID
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1124]
	call	?RemoveControl@C_Window@@QAEXJ@Z	; C_Window::RemoveControl
$LN24@RemoveList:

; 2638 : 		if(Team_[i].NavalUnits)

	jmp	SHORT $LN26@RemoveList
$LN28@RemoveList:
	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+edx+872], 0
	je	SHORT $LN23@RemoveList

; 2639 : 			for(j=0;j<_MAP_NUM_NAV_TYPES_;j++)

	xor	ecx, ecx
	mov	WORD PTR _j$[ebp], cx
	jmp	SHORT $LN22@RemoveList
$LN21@RemoveList:
	mov	dx, WORD PTR _j$[ebp]
	add	dx, 1
	mov	WORD PTR _j$[ebp], dx
$LN22@RemoveList:
	movsx	eax, WORD PTR _j$[ebp]
	cmp	eax, 2
	jge	SHORT $LN23@RemoveList

; 2640 : 				if(Team_[i].NavalUnits->Type[j])

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+872]
	movsx	ecx, WORD PTR _j$[ebp]
	cmp	DWORD PTR [eax+ecx*4+8], 0
	je	SHORT $LN19@RemoveList

; 2641 : 					DrawWindow_->RemoveControl(Team_[i].NavalUnits->Type[j]->GetID());

	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+872]
	movsx	edx, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4+8]
	call	?GetID@C_Base@@QAEJXZ			; C_Base::GetID
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1124]
	call	?RemoveControl@C_Window@@QAEXJ@Z	; C_Window::RemoveControl
$LN19@RemoveList:

; 2642 : 		if(Team_[i].Units)

	jmp	SHORT $LN21@RemoveList
$LN23@RemoveList:
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+ecx+868], 0
	je	$LN18@RemoveList

; 2643 : 			for(j=0;j<_MAP_NUM_GND_TYPES_;j++)

	xor	eax, eax
	mov	WORD PTR _j$[ebp], ax
	jmp	SHORT $LN17@RemoveList
$LN16@RemoveList:
	mov	cx, WORD PTR _j$[ebp]
	add	cx, 1
	mov	WORD PTR _j$[ebp], cx
$LN17@RemoveList:
	movsx	edx, WORD PTR _j$[ebp]
	cmp	edx, 4
	jge	$LN18@RemoveList

; 2644 : 				if(Team_[i].Units->Type[j])

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+868]
	movsx	eax, WORD PTR _j$[ebp]
	cmp	DWORD PTR [edx+eax*4+16], 0
	je	SHORT $LN14@RemoveList

; 2645 : 					for(k=0;k<_MAP_NUM_GND_LEVELS_;k++)

	xor	ecx, ecx
	mov	WORD PTR _k$[ebp], cx
	jmp	SHORT $LN13@RemoveList
$LN12@RemoveList:
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$LN13@RemoveList:
	movsx	eax, WORD PTR _k$[ebp]
	cmp	eax, 3
	jge	SHORT $LN14@RemoveList

; 2646 : 						if(Team_[i].Units->Type[j]->Levels[k])

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+868]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+16]
	movsx	eax, WORD PTR _k$[ebp]
	cmp	DWORD PTR [edx+eax*4+12], 0
	je	SHORT $LN10@RemoveList

; 2647 : 							DrawWindow_->RemoveControl(Team_[i].Units->Type[j]->Levels[k]->GetID());

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+868]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+16]
	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+12]
	call	?GetID@C_Base@@QAEJXZ			; C_Base::GetID
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1124]
	call	?RemoveControl@C_Window@@QAEXJ@Z	; C_Window::RemoveControl
$LN10@RemoveList:

; 2648 : 		if(Team_[i].AirUnits)

	jmp	SHORT $LN12@RemoveList
$LN14@RemoveList:
	jmp	$LN16@RemoveList
$LN18@RemoveList:
	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+edx+864], 0
	je	SHORT $LN9@RemoveList

; 2649 : 			for(j=0;j<_MAP_NUM_AIR_TYPES_;j++)

	xor	ecx, ecx
	mov	WORD PTR _j$[ebp], cx
	jmp	SHORT $LN8@RemoveList
$LN7@RemoveList:
	mov	dx, WORD PTR _j$[ebp]
	add	dx, 1
	mov	WORD PTR _j$[ebp], dx
$LN8@RemoveList:
	movsx	eax, WORD PTR _j$[ebp]
	cmp	eax, 5
	jge	SHORT $LN9@RemoveList

; 2650 : 				if(Team_[i].AirUnits->Type[j])

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+864]
	movsx	ecx, WORD PTR _j$[ebp]
	cmp	DWORD PTR [eax+ecx*4+20], 0
	je	SHORT $LN5@RemoveList

; 2651 : 					DrawWindow_->RemoveControl(Team_[i].AirUnits->Type[j]->GetID());

	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+864]
	movsx	edx, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4+20]
	call	?GetID@C_Base@@QAEJXZ			; C_Base::GetID
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1124]
	call	?RemoveControl@C_Window@@QAEXJ@Z	; C_Window::RemoveControl
$LN5@RemoveList:

; 2652 : 		if(Team_[i].Waypoints)

	jmp	SHORT $LN7@RemoveList
$LN9@RemoveList:
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+ecx+880], 0
	je	SHORT $LN4@RemoveList

; 2653 : 			DrawWindow_->RemoveControl(Team_[i].Waypoints->GetID());

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+eax+880]
	call	?GetID@C_Base@@QAEJXZ			; C_Base::GetID
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1124]
	call	?RemoveControl@C_Window@@QAEXJ@Z	; C_Window::RemoveControl
$LN4@RemoveList:

; 2654 : 	}

	jmp	$LN30@RemoveList
$LN29@RemoveList:

; 2655 : 	if(CurIcons_ && DrawWindow_)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1116], 0
	je	SHORT $LN3@RemoveList
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1124], 0
	je	SHORT $LN3@RemoveList

; 2656 : 		DrawWindow_->RemoveControl(CurIcons_->GetID());

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1116]
	call	?GetID@C_Base@@QAEJXZ			; C_Base::GetID
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1124]
	call	?RemoveControl@C_Window@@QAEXJ@Z	; C_Window::RemoveControl
$LN3@RemoveList:

; 2657 : 	if(CurWP_ && DrawWindow_)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1092], 0
	je	SHORT $LN2@RemoveList
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1124], 0
	je	SHORT $LN2@RemoveList

; 2658 : 		DrawWindow_->RemoveControl(CurWP_->GetID());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1092]
	call	?GetID@C_Base@@QAEJXZ			; C_Base::GetID
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1124]
	call	?RemoveControl@C_Window@@QAEXJ@Z	; C_Window::RemoveControl
$LN2@RemoveList:

; 2659 : 	if(CurWPZ_ && WPZWindow_)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1096], 0
	je	SHORT $LN34@RemoveList
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1128], 0
	je	SHORT $LN34@RemoveList

; 2660 : 		WPZWindow_->RemoveControl(CurWPZ_->GetID());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1096]
	call	?GetID@C_Base@@QAEJXZ			; C_Base::GetID
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1128]
	call	?RemoveControl@C_Window@@QAEXJ@Z	; C_Window::RemoveControl
$LN34@RemoveList:

; 2661 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveListsFromWindow@C_Map@@AAEXXZ ENDP		; C_Map::RemoveListsFromWindow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
$T2 = -188						; size = 4
$T3 = -184						; size = 4
$T4 = -180						; size = 4
$T5 = -176						; size = 4
$T6 = -172						; size = 4
$T7 = -168						; size = 4
$T8 = -164						; size = 4
$T9 = -160						; size = 4
$T10 = -156						; size = 4
$T11 = -152						; size = 4
$T12 = -148						; size = 4
$T13 = -144						; size = 4
$T14 = -140						; size = 4
$T15 = -136						; size = 4
$T16 = -132						; size = 4
$T17 = -128						; size = 4
$T18 = -124						; size = 4
tv192 = -120						; size = 4
$T19 = -116						; size = 4
tv130 = -112						; size = 4
$T20 = -108						; size = 4
tv74 = -104						; size = 4
$T21 = -100						; size = 4
$T22 = -96						; size = 4
$T23 = -92						; size = 4
tv1764 = -88						; size = 4
tv1131 = -84						; size = 4
$T24 = -80						; size = 4
tv698 = -76						; size = 4
tv1643 = -72						; size = 4
tv324 = -68						; size = 4
$T25 = -64						; size = 4
tv1610 = -60						; size = 4
$T26 = -56						; size = 4
tv2447 = -52						; size = 4
$T27 = -48						; size = 4
$T28 = -44						; size = 4
tv1871 = -40						; size = 4
$T29 = -36						; size = 4
_Font$ = -32						; size = 4
_k$ = -28						; size = 2
_this$ = -24						; size = 4
_j$ = -20						; size = 2
_i$ = -16						; size = 2
__$EHRec$ = -12						; size = 12
?AddListsToWindow@C_Map@@AAEXXZ PROC			; C_Map::AddListsToWindow
; _this$ = ecx

; 2363 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AddListsToWindow@C_Map@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 176				; 000000b0H
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2364 : 	short i,j,k;
; 2365 : 	long Font=6;

	mov	DWORD PTR _Font$[ebp], 6

; 2366 : 
; 2367 : 	if(Map_ == NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+808], 0
	jne	SHORT $LN80@AddListsTo

; 2368 : 	{
; 2369 : 		Map_=new C_ScaleBitmap;

	push	3344					; 00000d10H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T24[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T24[ebp], 0
	je	SHORT $LN83@AddListsTo
	mov	ecx, DWORD PTR $T24[ebp]
	call	??0C_ScaleBitmap@@QAE@XZ		; C_ScaleBitmap::C_ScaleBitmap
	mov	DWORD PTR tv74[ebp], eax
	jmp	SHORT $LN84@AddListsTo
$LN83@AddListsTo:
	mov	DWORD PTR tv74[ebp], 0
$LN84@AddListsTo:
	mov	ecx, DWORD PTR tv74[ebp]
	mov	DWORD PTR $T18[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T18[ebp]
	mov	DWORD PTR [edx+808], eax

; 2370 : 		Map_->Setup(5551000,0,MapID);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+804]
	push	edx
	push	0
	push	5551000					; 0054b398H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	call	?Setup@C_ScaleBitmap@@QAEXJFJ@Z		; C_ScaleBitmap::Setup
$LN80@AddListsTo:

; 2371 : 	}
; 2372 : 	DrawWindow_->AddControl(Map_);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1124]
	call	?AddControl@C_Window@@QAEXPAVC_Base@@@Z	; C_Window::AddControl

; 2373 : 
; 2374 : 	// Although The Threats are created here... they don't actually get put into a window
; 2375 : 
; 2376 : 	if(!BullsEye_)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1148], 0
	jne	$LN79@AddListsTo

; 2377 : 	{
; 2378 : 		BullsEye_=new C_BullsEye;

	push	72					; 00000048H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T27[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T27[ebp], 0
	je	SHORT $LN85@AddListsTo
	mov	ecx, DWORD PTR $T27[ebp]
	call	??0C_BullsEye@@QAE@XZ			; C_BullsEye::C_BullsEye
	mov	DWORD PTR tv130[ebp], eax
	jmp	SHORT $LN86@AddListsTo
$LN85@AddListsTo:
	mov	DWORD PTR tv130[ebp], 0
$LN86@AddListsTo:
	mov	edx, DWORD PTR tv130[ebp]
	mov	DWORD PTR $T9[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T9[ebp]
	mov	DWORD PTR [eax+1148], ecx

; 2379 : 		BullsEye_->Setup(5550900,0);

	push	0
	push	5550900					; 0054b334H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1148]
	call	?Setup@C_BullsEye@@QAEXJF@Z		; C_BullsEye::Setup

; 2380 : 		BullsEye_->SetColor(0x005500);

	push	21760					; 00005500H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1148]
	call	?SetColor@C_BullsEye@@QAEXK@Z		; C_BullsEye::SetColor

; 2381 : 		BullsEye_->SetFlagBitOn(C_BIT_INVISIBLE);

	push	8192					; 00002000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1148]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+1148]
	mov	eax, DWORD PTR [edx+8]
	call	eax
$LN79@AddListsTo:

; 2382 : 	}
; 2383 : 	DrawWindow_->AddControl(BullsEye_);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1148]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1124]
	call	?AddControl@C_Window@@QAEXPAVC_Base@@@Z	; C_Window::AddControl

; 2384 : 
; 2385 : 	for(i=0;i<_MAX_TEAMS_;i++)

	xor	ecx, ecx
	mov	WORD PTR _i$[ebp], cx
	jmp	SHORT $LN78@AddListsTo
$LN77@AddListsTo:
	mov	dx, WORD PTR _i$[ebp]
	add	dx, 1
	mov	WORD PTR _i$[ebp], dx
$LN78@AddListsTo:
	movsx	eax, WORD PTR _i$[ebp]
	cmp	eax, 8
	jge	$LN76@AddListsTo

; 2386 : 	{
; 2387 : 		if(Team_[i].Threats == NULL)

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+ecx+860], 0
	jne	$LN75@AddListsTo

; 2388 : 		{
; 2389 : 			Team_[i].Threats=new THR_LIST;

	push	32					; 00000020H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T15[ebp], eax
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T15[ebp]
	mov	DWORD PTR [ecx+eax+860], edx

; 2390 : 
; 2391 : 			for(j=0;j<_MAP_NUM_THREAT_TYPES_;j++)

	xor	eax, eax
	mov	WORD PTR _j$[ebp], ax
	jmp	SHORT $LN74@AddListsTo
$LN73@AddListsTo:
	mov	cx, WORD PTR _j$[ebp]
	add	cx, 1
	mov	WORD PTR _j$[ebp], cx
$LN74@AddListsTo:
	movsx	edx, WORD PTR _j$[ebp]
	cmp	edx, 4
	jge	$LN72@AddListsTo

; 2392 : 			{
; 2393 : 				Team_[i].Threats->Type[j]=new C_Threat;

	push	56					; 00000038H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T26[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	cmp	DWORD PTR $T26[ebp], 0
	je	SHORT $LN87@AddListsTo
	mov	ecx, DWORD PTR $T26[ebp]
	call	??0C_Threat@@QAE@XZ			; C_Threat::C_Threat
	mov	DWORD PTR tv192[ebp], eax
	jmp	SHORT $LN88@AddListsTo
$LN87@AddListsTo:
	mov	DWORD PTR tv192[ebp], 0
$LN88@AddListsTo:
	mov	eax, DWORD PTR tv192[ebp]
	mov	DWORD PTR $T5[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+860]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR $T5[ebp]
	mov	DWORD PTR [eax+ecx*4+16], edx

; 2394 : 				Team_[i].Threats->Type[j]->Setup(0,0);

	push	0
	push	0
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+860]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+16]
	call	?Setup@C_Threat@@QAEXJJ@Z		; C_Threat::Setup

; 2395 : 				if(ThreatMask_ & (1 << j))

	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, 1
	shl	edx, cl
	mov	eax, DWORD PTR _this$[ebp]
	and	edx, DWORD PTR [eax+800]
	je	SHORT $LN71@AddListsTo

; 2396 : 				{
; 2397 : 					Team_[i].Threats->Flags[j]=1;

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+860]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	DWORD PTR [eax+ecx*4], 1

; 2398 : 					Team_[i].Threats->Type[j]->SetFlagBitOff(C_BIT_INVISIBLE);

	push	8192					; 00002000H
	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+860]
	movsx	edx, WORD PTR _j$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+16]
	movsx	ecx, WORD PTR _j$[ebp]
	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [esi+edx+860]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4+16]
	mov	edx, DWORD PTR [eax+12]
	call	edx

; 2399 : 				}
; 2400 : 				else

	jmp	SHORT $LN70@AddListsTo
$LN71@AddListsTo:

; 2401 : 				{
; 2402 : 					Team_[i].Threats->Flags[j]=0;

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+860]
	movsx	eax, WORD PTR _j$[ebp]
	mov	DWORD PTR [edx+eax*4], 0

; 2403 : 					Team_[i].Threats->Type[j]->SetFlagBitOn(C_BIT_INVISIBLE);

	push	8192					; 00002000H
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+860]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+16]
	movsx	eax, WORD PTR _j$[ebp]
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+860]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4+16]
	mov	eax, DWORD PTR [edx+8]
	call	eax
$LN70@AddListsTo:

; 2404 : 				}
; 2405 : 			}

	jmp	$LN73@AddListsTo
$LN72@AddListsTo:

; 2406 : 			SetTeamFlags(i,GetTeamFlags(i) | _MAP_THREATS_);

	movsx	ecx, WORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTeamFlags@C_Map@@QAEJJ@Z		; C_Map::GetTeamFlags
	or	eax, 536870912				; 20000000H
	push	eax
	movsx	edx, WORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTeamFlags@C_Map@@QAEXJJ@Z		; C_Map::SetTeamFlags
$LN75@AddListsTo:

; 2407 : 		}
; 2408 : 		if(Team_[i].Objectives == NULL)

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax+876], 0
	jne	$LN69@AddListsTo

; 2409 : 		{
; 2410 : 			Team_[i].Objectives=new OBJ_LIST;

	push	112					; 00000070H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T13[ebp], eax
	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T13[ebp]
	mov	DWORD PTR [eax+edx+876], ecx

; 2411 : 
; 2412 : 			for(j=0;j<_MAP_NUM_OBJ_TYPES_;j++)

	xor	edx, edx
	mov	WORD PTR _j$[ebp], dx
	jmp	SHORT $LN68@AddListsTo
$LN67@AddListsTo:
	mov	ax, WORD PTR _j$[ebp]
	add	ax, 1
	mov	WORD PTR _j$[ebp], ax
$LN68@AddListsTo:
	movsx	ecx, WORD PTR _j$[ebp]
	cmp	ecx, 14					; 0000000eH
	jge	$LN66@AddListsTo

; 2413 : 			{
; 2414 : 				Team_[i].Objectives->Type[j]=new C_MapIcon;

	push	204					; 000000ccH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T23[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	cmp	DWORD PTR $T23[ebp], 0
	je	SHORT $LN89@AddListsTo
	mov	ecx, DWORD PTR $T23[ebp]
	call	??0C_MapIcon@@QAE@XZ			; C_MapIcon::C_MapIcon
	mov	DWORD PTR tv324[ebp], eax
	jmp	SHORT $LN90@AddListsTo
$LN89@AddListsTo:
	mov	DWORD PTR tv324[ebp], 0
$LN90@AddListsTo:
	mov	edx, DWORD PTR tv324[ebp]
	mov	DWORD PTR $T7[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+876]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR $T7[ebp]
	mov	DWORD PTR [edx+eax*4+56], ecx

; 2415 : 				Team_[i].Objectives->Type[j]->Setup(5551000+i+j*10,j);

	movzx	edx, WORD PTR _j$[ebp]
	push	edx
	movsx	eax, WORD PTR _i$[ebp]
	movsx	ecx, WORD PTR _j$[ebp]
	imul	ecx, 10					; 0000000aH
	lea	edx, DWORD PTR [eax+ecx+5551000]
	push	edx
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+876]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+56]
	call	?Setup@C_MapIcon@@QAEXJF@Z		; C_MapIcon::Setup

; 2416 : 				Team_[i].Objectives->Type[j]->SetFont(Font);

	mov	ecx, DWORD PTR _Font$[ebp]
	push	ecx
	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+876]
	movsx	edx, WORD PTR _j$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+56]
	movsx	ecx, WORD PTR _j$[ebp]
	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [esi+edx+876]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4+56]
	mov	edx, DWORD PTR [eax+68]
	call	edx

; 2417 : 				Team_[i].Objectives->Type[j]->SetTeam(i);

	movzx	eax, WORD PTR _i$[ebp]
	push	eax
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+876]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4+56]
	call	?SetTeam@C_MapIcon@@QAEXF@Z		; C_MapIcon::SetTeam

; 2418 : 				Team_[i].Objectives->Type[j]->SetMainImage(ObjIconIDs_[i][0],ObjIconIDs_[i][1]);

	movsx	edx, WORD PTR _i$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8+640]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR [ecx+edx]
	push	eax
	movsx	ecx, WORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8+640]
	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR [eax+ecx]
	push	edx
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+876]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+56]
	call	?SetMainImage@C_MapIcon@@QAEXJJ@Z	; C_MapIcon::SetMainImage

; 2419 : 				if(j == FindTypeIndex(_UNIT_PACKAGE,OBJ_TypeList,_MAP_NUM_OBJ_TYPES_))

	movsx	esi, WORD PTR _j$[ebp]
	push	14					; 0000000eH
	push	OFFSET ?OBJ_TypeList@@3PAJA		; OBJ_TypeList
	push	4096					; 00001000H
	call	?FindTypeIndex@@YAJJQAJH@Z		; FindTypeIndex
	add	esp, 12					; 0000000cH
	cmp	esi, eax
	jne	SHORT $LN65@AddListsTo

; 2420 : 					Team_[i].Objectives->Type[j]->SetMenu(PACKAGE_POP);

	push	18348					; 000047acH
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+876]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+56]
	movsx	eax, WORD PTR _j$[ebp]
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+876]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4+56]
	mov	eax, DWORD PTR [edx+64]
	call	eax
	jmp	$LN62@AddListsTo
$LN65@AddListsTo:

; 2421 : 				else if(j == FindTypeIndex(_UNIT_SQUADRON,OBJ_TypeList,_MAP_NUM_OBJ_TYPES_))

	movsx	esi, WORD PTR _j$[ebp]
	push	14					; 0000000eH
	push	OFFSET ?OBJ_TypeList@@3PAJA		; OBJ_TypeList
	push	2048					; 00000800H
	call	?FindTypeIndex@@YAJJQAJH@Z		; FindTypeIndex
	add	esp, 12					; 0000000cH
	cmp	esi, eax
	jne	SHORT $LN63@AddListsTo

; 2422 : 					Team_[i].Objectives->Type[j]->SetMenu(SQUADRON_POP);

	push	18216					; 00004728H
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+876]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+56]
	movsx	eax, WORD PTR _j$[ebp]
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+876]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4+56]
	mov	eax, DWORD PTR [edx+64]
	call	eax

; 2423 : 				else

	jmp	SHORT $LN62@AddListsTo
$LN63@AddListsTo:

; 2424 : 					Team_[i].Objectives->Type[j]->SetMenu(OBJECTIVE_POP);

	push	18199					; 00004717H
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+876]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+56]
	movsx	eax, WORD PTR _j$[ebp]
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+876]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4+56]
	mov	eax, DWORD PTR [edx+64]
	call	eax
$LN62@AddListsTo:

; 2425 : 
; 2426 : 				Team_[i].Objectives->Type[j]->SetCursorID(CRSR_F16_RM);

	push	4
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+876]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+56]
	movsx	eax, WORD PTR _j$[ebp]
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+876]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4+56]
	mov	eax, DWORD PTR [edx+76]
	call	eax

; 2427 : 				Team_[i].Objectives->Type[j]->SetFlagBitOn(C_BIT_NOLABEL);

	push	16777216				; 01000000H
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+876]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+56]
	movsx	eax, WORD PTR _j$[ebp]
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+876]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4+56]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 2428 : 				if(ObjectiveMask_ & (1 << j))

	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, 1
	shl	edx, cl
	mov	eax, DWORD PTR _this$[ebp]
	and	edx, DWORD PTR [eax+784]
	je	SHORT $LN61@AddListsTo

; 2429 : 				{
; 2430 : 					Team_[i].Objectives->Flags[j]=1;

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+876]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	DWORD PTR [eax+ecx*4], 1

; 2431 : 					Team_[i].Objectives->Type[j]->SetFlagBitOff(C_BIT_INVISIBLE);

	push	8192					; 00002000H
	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+876]
	movsx	edx, WORD PTR _j$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+56]
	movsx	ecx, WORD PTR _j$[ebp]
	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [esi+edx+876]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4+56]
	mov	edx, DWORD PTR [eax+12]
	call	edx

; 2432 : 				}
; 2433 : 				else

	jmp	SHORT $LN60@AddListsTo
$LN61@AddListsTo:

; 2434 : 				{
; 2435 : 					Team_[i].Objectives->Flags[j]=0;

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+876]
	movsx	eax, WORD PTR _j$[ebp]
	mov	DWORD PTR [edx+eax*4], 0

; 2436 : 					Team_[i].Objectives->Type[j]->SetFlagBitOn(C_BIT_INVISIBLE);

	push	8192					; 00002000H
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+876]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+56]
	movsx	eax, WORD PTR _j$[ebp]
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+876]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4+56]
	mov	eax, DWORD PTR [edx+8]
	call	eax
$LN60@AddListsTo:

; 2437 : 				}
; 2438 : 			}

	jmp	$LN67@AddListsTo
$LN66@AddListsTo:

; 2439 : 			SetTeamFlags(i,GetTeamFlags(i) | _MAP_OBJECTIVES_);

	movsx	ecx, WORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTeamFlags@C_Map@@QAEJJ@Z		; C_Map::GetTeamFlags
	or	eax, 16777216				; 01000000H
	push	eax
	movsx	edx, WORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTeamFlags@C_Map@@QAEXJJ@Z		; C_Map::SetTeamFlags
$LN69@AddListsTo:

; 2440 : 		}
; 2441 : 		for(j=0;j<_MAP_NUM_OBJ_TYPES_;j++)

	xor	eax, eax
	mov	WORD PTR _j$[ebp], ax
	jmp	SHORT $LN59@AddListsTo
$LN58@AddListsTo:
	mov	cx, WORD PTR _j$[ebp]
	add	cx, 1
	mov	WORD PTR _j$[ebp], cx
$LN59@AddListsTo:
	movsx	edx, WORD PTR _j$[ebp]
	cmp	edx, 14					; 0000000eH
	jge	SHORT $LN57@AddListsTo

; 2442 : 			DrawWindow_->AddControl(Team_[i].Objectives->Type[j]);

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+876]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+56]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1124]
	call	?AddControl@C_Window@@QAEXPAVC_Base@@@Z	; C_Window::AddControl
	jmp	SHORT $LN58@AddListsTo
$LN57@AddListsTo:

; 2443 : 	}

	jmp	$LN77@AddListsTo
$LN76@AddListsTo:

; 2444 : 	for(i=0;i<_MAX_TEAMS_;i++)

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax
	jmp	SHORT $LN56@AddListsTo
$LN55@AddListsTo:
	mov	cx, WORD PTR _i$[ebp]
	add	cx, 1
	mov	WORD PTR _i$[ebp], cx
$LN56@AddListsTo:
	movsx	edx, WORD PTR _i$[ebp]
	cmp	edx, 8
	jge	$LN54@AddListsTo

; 2445 : 	{
; 2446 : 		if(Team_[i].NavalUnits == NULL)

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax+872], 0
	jne	$LN53@AddListsTo

; 2447 : 		{
; 2448 : 			Team_[i].NavalUnits=new NAV_LIST;

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T11[ebp], eax
	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T11[ebp]
	mov	DWORD PTR [eax+edx+872], ecx

; 2449 : 
; 2450 : 			for(j=0;j<_MAP_NUM_NAV_TYPES_;j++)

	xor	edx, edx
	mov	WORD PTR _j$[ebp], dx
	jmp	SHORT $LN52@AddListsTo
$LN51@AddListsTo:
	mov	ax, WORD PTR _j$[ebp]
	add	ax, 1
	mov	WORD PTR _j$[ebp], ax
$LN52@AddListsTo:
	movsx	ecx, WORD PTR _j$[ebp]
	cmp	ecx, 2
	jge	$LN50@AddListsTo

; 2451 : 			{
; 2452 : 				Team_[i].NavalUnits->Type[j]=new C_MapIcon;

	push	204					; 000000ccH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T20[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	cmp	DWORD PTR $T20[ebp], 0
	je	SHORT $LN91@AddListsTo
	mov	ecx, DWORD PTR $T20[ebp]
	call	??0C_MapIcon@@QAE@XZ			; C_MapIcon::C_MapIcon
	mov	DWORD PTR tv698[ebp], eax
	jmp	SHORT $LN92@AddListsTo
$LN91@AddListsTo:
	mov	DWORD PTR tv698[ebp], 0
$LN92@AddListsTo:
	mov	edx, DWORD PTR tv698[ebp]
	mov	DWORD PTR $T3[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+872]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR [edx+eax*4+8], ecx

; 2453 : 				Team_[i].NavalUnits->Type[j]->Setup(5551800+i+j*10,j);

	movzx	edx, WORD PTR _j$[ebp]
	push	edx
	movsx	eax, WORD PTR _i$[ebp]
	movsx	ecx, WORD PTR _j$[ebp]
	imul	ecx, 10					; 0000000aH
	lea	edx, DWORD PTR [eax+ecx+5551800]
	push	edx
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+872]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+8]
	call	?Setup@C_MapIcon@@QAEXJF@Z		; C_MapIcon::Setup

; 2454 : 				Team_[i].NavalUnits->Type[j]->SetMainImage(NavyIconIDs_[i][0],NavyIconIDs_[i][1]);

	movsx	ecx, WORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8+576]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR [eax+ecx]
	push	edx
	movsx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8+576]
	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR [edx+eax]
	push	ecx
	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+872]
	movsx	edx, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4+8]
	call	?SetMainImage@C_MapIcon@@QAEXJJ@Z	; C_MapIcon::SetMainImage

; 2455 : 				Team_[i].NavalUnits->Type[j]->SetFont(Font);

	mov	eax, DWORD PTR _Font$[ebp]
	push	eax
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+872]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+8]
	movsx	eax, WORD PTR _j$[ebp]
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+872]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4+8]
	mov	eax, DWORD PTR [edx+68]
	call	eax

; 2456 : 				Team_[i].NavalUnits->Type[j]->SetTeam(i);

	movzx	ecx, WORD PTR _i$[ebp]
	push	ecx
	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+872]
	movsx	edx, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4+8]
	call	?SetTeam@C_MapIcon@@QAEXF@Z		; C_MapIcon::SetTeam

; 2457 : 				Team_[i].NavalUnits->Type[j]->SetMenu(NAVAL_POP);

	push	18197					; 00004715H
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+872]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+8]
	movsx	edx, WORD PTR _j$[ebp]
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [esi+eax+872]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4+8]
	mov	edx, DWORD PTR [esi+64]
	call	edx

; 2458 : 				Team_[i].NavalUnits->Type[j]->SetCallback(UnitCB);

	push	OFFSET ?UnitCB@@YAXJFPAVC_Base@@@Z	; UnitCB
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+872]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+8]
	movsx	edx, WORD PTR _j$[ebp]
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [esi+eax+872]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4+8]
	mov	edx, DWORD PTR [esi+100]
	call	edx

; 2459 : 				Team_[i].NavalUnits->Type[j]->SetCursorID(CRSR_F16_RM);

	push	4
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+872]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+8]
	movsx	edx, WORD PTR _j$[ebp]
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [esi+eax+872]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4+8]
	mov	edx, DWORD PTR [esi+76]
	call	edx

; 2460 : 				Team_[i].NavalUnits->Type[j]->SetFlagBitOn(C_BIT_NOLABEL);

	push	16777216				; 01000000H
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+872]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+8]
	movsx	edx, WORD PTR _j$[ebp]
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [esi+eax+872]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4+8]
	mov	edx, DWORD PTR [esi+8]
	call	edx

; 2461 : 				if(TheCampaign.Flags & CAMP_TACTICAL_EDIT)

	mov	eax, DWORD PTR ?TheCampaign@@3VCampaignClass@@A+64
	and	eax, 524288				; 00080000H
	je	SHORT $LN49@AddListsTo

; 2462 : 					Team_[i].NavalUnits->Type[j]->SetFlagBitOn(C_BIT_DRAGABLE);

	push	4096					; 00001000H
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+872]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+8]
	movsx	eax, WORD PTR _j$[ebp]
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+872]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4+8]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 2463 : 				else

	jmp	SHORT $LN48@AddListsTo
$LN49@AddListsTo:

; 2464 : 					Team_[i].NavalUnits->Type[j]->SetFlagBitOff(C_BIT_DRAGABLE);

	push	4096					; 00001000H
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+872]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+8]
	movsx	eax, WORD PTR _j$[ebp]
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+872]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4+8]
	mov	eax, DWORD PTR [edx+12]
	call	eax
$LN48@AddListsTo:

; 2465 : 				if(NavalUnitMask_ & (1 << j))

	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, 1
	shl	edx, cl
	mov	eax, DWORD PTR _this$[ebp]
	and	edx, DWORD PTR [eax+792]
	je	SHORT $LN47@AddListsTo

; 2466 : 				{
; 2467 : 					Team_[i].NavalUnits->Flags[j]=1;

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+872]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	DWORD PTR [eax+ecx*4], 1

; 2468 : 					Team_[i].NavalUnits->Type[j]->SetFlagBitOff(C_BIT_INVISIBLE);

	push	8192					; 00002000H
	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+872]
	movsx	edx, WORD PTR _j$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+8]
	movsx	ecx, WORD PTR _j$[ebp]
	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [esi+edx+872]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4+8]
	mov	edx, DWORD PTR [eax+12]
	call	edx

; 2469 : 				}
; 2470 : 				else

	jmp	SHORT $LN46@AddListsTo
$LN47@AddListsTo:

; 2471 : 				{
; 2472 : 					Team_[i].NavalUnits->Flags[j]=0;

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+872]
	movsx	eax, WORD PTR _j$[ebp]
	mov	DWORD PTR [edx+eax*4], 0

; 2473 : 					Team_[i].NavalUnits->Type[j]->SetFlagBitOn(C_BIT_INVISIBLE);

	push	8192					; 00002000H
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+872]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+8]
	movsx	eax, WORD PTR _j$[ebp]
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+872]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4+8]
	mov	eax, DWORD PTR [edx+8]
	call	eax
$LN46@AddListsTo:

; 2474 : 				}
; 2475 : 			}

	jmp	$LN51@AddListsTo
$LN50@AddListsTo:

; 2476 : 			SetTeamFlags(i,GetTeamFlags(i) | _MAP_NAVAL_UNITS_);

	movsx	ecx, WORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTeamFlags@C_Map@@QAEJJ@Z		; C_Map::GetTeamFlags
	or	eax, 134217728				; 08000000H
	push	eax
	movsx	edx, WORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTeamFlags@C_Map@@QAEXJJ@Z		; C_Map::SetTeamFlags
$LN53@AddListsTo:

; 2477 : 		}
; 2478 : 		for(j=0;j<_MAP_NUM_NAV_TYPES_;j++)

	xor	eax, eax
	mov	WORD PTR _j$[ebp], ax
	jmp	SHORT $LN45@AddListsTo
$LN44@AddListsTo:
	mov	cx, WORD PTR _j$[ebp]
	add	cx, 1
	mov	WORD PTR _j$[ebp], cx
$LN45@AddListsTo:
	movsx	edx, WORD PTR _j$[ebp]
	cmp	edx, 2
	jge	SHORT $LN43@AddListsTo

; 2479 : 			DrawWindow_->AddControl(Team_[i].NavalUnits->Type[j]);

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+872]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1124]
	call	?AddControl@C_Window@@QAEXPAVC_Base@@@Z	; C_Window::AddControl
	jmp	SHORT $LN44@AddListsTo
$LN43@AddListsTo:

; 2480 : 	}

	jmp	$LN55@AddListsTo
$LN54@AddListsTo:

; 2481 : 	for(i=0;i<_MAX_TEAMS_;i++)

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax
	jmp	SHORT $LN42@AddListsTo
$LN41@AddListsTo:
	mov	cx, WORD PTR _i$[ebp]
	add	cx, 1
	mov	WORD PTR _i$[ebp], cx
$LN42@AddListsTo:
	movsx	edx, WORD PTR _i$[ebp]
	cmp	edx, 8
	jge	$LN40@AddListsTo

; 2482 : 	{
; 2483 : 		if(Team_[i].Units == NULL)

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax+868], 0
	jne	$LN39@AddListsTo

; 2484 : 		{
; 2485 : 			Team_[i].Units=new GND_LIST;

	push	32					; 00000020H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T17[ebp], eax
	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T17[ebp]
	mov	DWORD PTR [eax+edx+868], ecx

; 2486 : 
; 2487 : 			for(j=0;j<_MAP_NUM_GND_TYPES_;j++)

	xor	edx, edx
	mov	WORD PTR _j$[ebp], dx
	jmp	SHORT $LN38@AddListsTo
$LN37@AddListsTo:
	mov	ax, WORD PTR _j$[ebp]
	add	ax, 1
	mov	WORD PTR _j$[ebp], ax
$LN38@AddListsTo:
	movsx	ecx, WORD PTR _j$[ebp]
	cmp	ecx, 4
	jge	$LN36@AddListsTo

; 2488 : 			{
; 2489 : 				Team_[i].Units->Flags[j]=0;

	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+868]
	movsx	edx, WORD PTR _j$[ebp]
	mov	DWORD PTR [ecx+edx*4], 0

; 2490 : 				Team_[i].Units->Type[j]=new GND_SIZE;

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T16[ebp], eax
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+868]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR $T16[ebp]
	mov	DWORD PTR [edx+eax*4+16], ecx

; 2491 : 				for(k=0;k<_MAP_NUM_GND_LEVELS_;k++)

	xor	edx, edx
	mov	WORD PTR _k$[ebp], dx
	jmp	SHORT $LN35@AddListsTo
$LN34@AddListsTo:
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$LN35@AddListsTo:
	movsx	ecx, WORD PTR _k$[ebp]
	cmp	ecx, 3
	jge	$LN33@AddListsTo

; 2492 : 				{
; 2493 : 					Team_[i].Units->Type[j]->Flags[k]=0;

	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+868]
	movsx	edx, WORD PTR _j$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+16]
	movsx	ecx, WORD PTR _k$[ebp]
	mov	DWORD PTR [eax+ecx*4], 0

; 2494 : 					Team_[i].Units->Type[j]->Levels[k]=new C_MapIcon;

	push	204					; 000000ccH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T21[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 5
	cmp	DWORD PTR $T21[ebp], 0
	je	SHORT $LN93@AddListsTo
	mov	ecx, DWORD PTR $T21[ebp]
	call	??0C_MapIcon@@QAE@XZ			; C_MapIcon::C_MapIcon
	mov	DWORD PTR tv1131[ebp], eax
	jmp	SHORT $LN94@AddListsTo
$LN93@AddListsTo:
	mov	DWORD PTR tv1131[ebp], 0
$LN94@AddListsTo:
	mov	edx, DWORD PTR tv1131[ebp]
	mov	DWORD PTR $T14[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+868]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+16]
	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR $T14[ebp]
	mov	DWORD PTR [ecx+edx*4+12], eax

; 2495 : 					Team_[i].Units->Type[j]->Levels[k]->Setup(static_cast<short>(5551300+i+j*10+k*100),static_cast<short>(j + (k << 8)));

	movsx	ecx, WORD PTR _j$[ebp]
	movsx	edx, WORD PTR _k$[ebp]
	shl	edx, 8
	add	ecx, edx
	push	ecx
	movsx	eax, WORD PTR _i$[ebp]
	movsx	ecx, WORD PTR _j$[ebp]
	imul	ecx, 10					; 0000000aH
	lea	edx, DWORD PTR [eax+ecx+5551300]
	movsx	eax, WORD PTR _k$[ebp]
	imul	eax, 100				; 00000064H
	add	edx, eax
	movsx	ecx, dx
	push	ecx
	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+868]
	movsx	edx, WORD PTR _j$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+16]
	movsx	ecx, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4+12]
	call	?Setup@C_MapIcon@@QAEXJF@Z		; C_MapIcon::Setup

; 2496 : 					Team_[i].Units->Type[j]->Levels[k]->SetMainImage(ArmyIconIDs_[i][0],ArmyIconIDs_[i][1]);

	movsx	edx, WORD PTR _i$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8+512]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR [ecx+edx]
	push	eax
	movsx	ecx, WORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8+512]
	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR [eax+ecx]
	push	edx
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+868]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+16]
	movsx	edx, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4+12]
	call	?SetMainImage@C_MapIcon@@QAEXJJ@Z	; C_MapIcon::SetMainImage

; 2497 : 					Team_[i].Units->Type[j]->Levels[k]->SetFont(Font);

	mov	eax, DWORD PTR _Font$[ebp]
	push	eax
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+868]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+16]
	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+12]
	movsx	edx, WORD PTR _k$[ebp]
	movsx	eax, WORD PTR _j$[ebp]
	movsx	esi, WORD PTR _i$[ebp]
	imul	esi, 24					; 00000018H
	mov	edi, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edi+esi+868]
	mov	eax, DWORD PTR [esi+eax*4+16]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4+12]
	mov	edx, DWORD PTR [esi+68]
	call	edx

; 2498 : 					Team_[i].Units->Type[j]->Levels[k]->SetTeam(i);

	movzx	eax, WORD PTR _i$[ebp]
	push	eax
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+868]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+16]
	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+12]
	call	?SetTeam@C_MapIcon@@QAEXF@Z		; C_MapIcon::SetTeam

; 2499 : 					Team_[i].Units->Type[j]->Levels[k]->SetMenu(UNIT_POP);

	push	18200					; 00004718H
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+868]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+16]
	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+12]
	movsx	edx, WORD PTR _k$[ebp]
	movsx	eax, WORD PTR _j$[ebp]
	movsx	esi, WORD PTR _i$[ebp]
	imul	esi, 24					; 00000018H
	mov	edi, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edi+esi+868]
	mov	eax, DWORD PTR [esi+eax*4+16]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4+12]
	mov	edx, DWORD PTR [esi+64]
	call	edx

; 2500 : 					Team_[i].Units->Type[j]->Levels[k]->SetCursorID(CRSR_F16_RM);

	push	4
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+868]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+16]
	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+12]
	movsx	ecx, WORD PTR _k$[ebp]
	movsx	edx, WORD PTR _j$[ebp]
	movsx	esi, WORD PTR _i$[ebp]
	imul	esi, 24					; 00000018H
	mov	edi, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edi+esi+868]
	mov	edx, DWORD PTR [esi+edx*4+16]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4+12]
	mov	edx, DWORD PTR [eax+76]
	call	edx

; 2501 : 					Team_[i].Units->Type[j]->Levels[k]->SetFlagBitOn(C_BIT_NOLABEL);

	push	16777216				; 01000000H
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+868]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+16]
	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+12]
	movsx	ecx, WORD PTR _k$[ebp]
	movsx	edx, WORD PTR _j$[ebp]
	movsx	esi, WORD PTR _i$[ebp]
	imul	esi, 24					; 00000018H
	mov	edi, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edi+esi+868]
	mov	edx, DWORD PTR [esi+edx*4+16]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4+12]
	mov	edx, DWORD PTR [eax+8]
	call	edx

; 2502 : 					Team_[i].Units->Type[j]->Levels[k]->SetCallback (UnitCB);

	push	OFFSET ?UnitCB@@YAXJFPAVC_Base@@@Z	; UnitCB
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+868]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+16]
	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+12]
	movsx	ecx, WORD PTR _k$[ebp]
	movsx	edx, WORD PTR _j$[ebp]
	movsx	esi, WORD PTR _i$[ebp]
	imul	esi, 24					; 00000018H
	mov	edi, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edi+esi+868]
	mov	edx, DWORD PTR [esi+edx*4+16]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4+12]
	mov	edx, DWORD PTR [eax+100]
	call	edx

; 2503 : 					if(TheCampaign.Flags & CAMP_TACTICAL_EDIT)

	mov	eax, DWORD PTR ?TheCampaign@@3VCampaignClass@@A+64
	and	eax, 524288				; 00080000H
	je	SHORT $LN32@AddListsTo

; 2504 : 						Team_[i].Units->Type[j]->Levels[k]->SetFlagBitOn(C_BIT_DRAGABLE);

	push	4096					; 00001000H
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+868]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+16]
	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+12]
	movsx	edx, WORD PTR _k$[ebp]
	movsx	eax, WORD PTR _j$[ebp]
	movsx	esi, WORD PTR _i$[ebp]
	imul	esi, 24					; 00000018H
	mov	edi, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edi+esi+868]
	mov	eax, DWORD PTR [esi+eax*4+16]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4+12]
	mov	edx, DWORD PTR [esi+8]
	call	edx

; 2505 : 					else

	jmp	SHORT $LN31@AddListsTo
$LN32@AddListsTo:

; 2506 : 						Team_[i].Units->Type[j]->Levels[k]->SetFlagBitOff(C_BIT_DRAGABLE);

	push	4096					; 00001000H
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+868]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+16]
	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+12]
	movsx	ecx, WORD PTR _k$[ebp]
	movsx	edx, WORD PTR _j$[ebp]
	movsx	esi, WORD PTR _i$[ebp]
	imul	esi, 24					; 00000018H
	mov	edi, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edi+esi+868]
	mov	edx, DWORD PTR [esi+edx*4+16]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4+12]
	mov	edx, DWORD PTR [eax+12]
	call	edx
$LN31@AddListsTo:

; 2507 : 					if(UnitMask_ & (1 << j))

	movsx	ecx, WORD PTR _j$[ebp]
	mov	eax, 1
	shl	eax, cl
	mov	ecx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [ecx+788]
	je	SHORT $LN30@AddListsTo

; 2508 : 					{
; 2509 : 						Team_[i].Units->Type[j]->Flags[k]=1;

	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+868]
	movsx	edx, WORD PTR _j$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+16]
	movsx	ecx, WORD PTR _k$[ebp]
	mov	DWORD PTR [eax+ecx*4], 1

; 2510 : 						Team_[i].Units->Type[j]->Levels[k]->SetFlagBitOff(C_BIT_INVISIBLE);

	push	8192					; 00002000H
	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+868]
	movsx	edx, WORD PTR _j$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+16]
	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+12]
	movsx	eax, WORD PTR _k$[ebp]
	movsx	ecx, WORD PTR _j$[ebp]
	movsx	esi, WORD PTR _i$[ebp]
	imul	esi, 24					; 00000018H
	mov	edi, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edi+esi+868]
	mov	ecx, DWORD PTR [esi+ecx*4+16]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4+12]
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 2511 : 					}
; 2512 : 					else

	jmp	SHORT $LN29@AddListsTo
$LN30@AddListsTo:

; 2513 : 					{
; 2514 : 						Team_[i].Units->Type[j]->Flags[k]=0;

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+868]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+16]
	movsx	eax, WORD PTR _k$[ebp]
	mov	DWORD PTR [edx+eax*4], 0

; 2515 : 						Team_[i].Units->Type[j]->Levels[k]->SetFlagBitOn(C_BIT_INVISIBLE);

	push	8192					; 00002000H
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+868]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+16]
	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+12]
	movsx	edx, WORD PTR _k$[ebp]
	movsx	eax, WORD PTR _j$[ebp]
	movsx	esi, WORD PTR _i$[ebp]
	imul	esi, 24					; 00000018H
	mov	edi, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edi+esi+868]
	mov	eax, DWORD PTR [esi+eax*4+16]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4+12]
	mov	edx, DWORD PTR [esi+8]
	call	edx
$LN29@AddListsTo:

; 2516 : 					}
; 2517 : 				}

	jmp	$LN34@AddListsTo
$LN33@AddListsTo:

; 2518 : 			}

	jmp	$LN37@AddListsTo
$LN36@AddListsTo:

; 2519 : 			SetUnitLevel(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetUnitLevel@C_Map@@QAEXJ@Z		; C_Map::SetUnitLevel

; 2520 : 			SetTeamFlags(i,GetTeamFlags(i) | _MAP_UNITS_);

	movsx	eax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTeamFlags@C_Map@@QAEJJ@Z		; C_Map::GetTeamFlags
	or	eax, 33554432				; 02000000H
	push	eax
	movsx	ecx, WORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTeamFlags@C_Map@@QAEXJJ@Z		; C_Map::SetTeamFlags
$LN39@AddListsTo:

; 2521 : 		}
; 2522 : 		for(j=0;j<_MAP_NUM_GND_TYPES_;j++)

	xor	edx, edx
	mov	WORD PTR _j$[ebp], dx
	jmp	SHORT $LN28@AddListsTo
$LN27@AddListsTo:
	mov	ax, WORD PTR _j$[ebp]
	add	ax, 1
	mov	WORD PTR _j$[ebp], ax
$LN28@AddListsTo:
	movsx	ecx, WORD PTR _j$[ebp]
	cmp	ecx, 4
	jge	SHORT $LN26@AddListsTo

; 2523 : 			for(k=0;k<_MAP_NUM_GND_LEVELS_;k++)

	xor	edx, edx
	mov	WORD PTR _k$[ebp], dx
	jmp	SHORT $LN25@AddListsTo
$LN24@AddListsTo:
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$LN25@AddListsTo:
	movsx	ecx, WORD PTR _k$[ebp]
	cmp	ecx, 3
	jge	SHORT $LN23@AddListsTo

; 2524 : 				DrawWindow_->AddControl(Team_[i].Units->Type[j]->Levels[k]);

	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+868]
	movsx	edx, WORD PTR _j$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+16]
	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+12]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1124]
	call	?AddControl@C_Window@@QAEXPAVC_Base@@@Z	; C_Window::AddControl
	jmp	SHORT $LN24@AddListsTo
$LN23@AddListsTo:
	jmp	SHORT $LN27@AddListsTo
$LN26@AddListsTo:

; 2525 : 	}

	jmp	$LN41@AddListsTo
$LN40@AddListsTo:

; 2526 : 	if(CurIcons_ == NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1116], 0
	jne	SHORT $LN22@AddListsTo

; 2527 : 	{
; 2528 : 		CurIcons_=new C_DrawList;

	push	112					; 00000070H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T19[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 6
	cmp	DWORD PTR $T19[ebp], 0
	je	SHORT $LN95@AddListsTo
	mov	ecx, DWORD PTR $T19[ebp]
	call	??0C_DrawList@@QAE@XZ			; C_DrawList::C_DrawList
	mov	DWORD PTR tv1610[ebp], eax
	jmp	SHORT $LN96@AddListsTo
$LN95@AddListsTo:
	mov	DWORD PTR tv1610[ebp], 0
$LN96@AddListsTo:
	mov	edx, DWORD PTR tv1610[ebp]
	mov	DWORD PTR $T12[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T12[ebp]
	mov	DWORD PTR [eax+1116], ecx

; 2529 : 		CurIcons_->Setup(5553000,0);

	push	0
	push	5553000					; 0054bb68H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1116]
	call	?Setup@C_DrawList@@QAEXJF@Z		; C_DrawList::Setup
$LN22@AddListsTo:

; 2530 : 	}
; 2531 : 	DrawWindow_->AddControl(CurIcons_);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1116]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1124]
	call	?AddControl@C_Window@@QAEXPAVC_Base@@@Z	; C_Window::AddControl

; 2532 : 
; 2533 : 	for(i=0;i<_MAX_TEAMS_;i++)

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax
	jmp	SHORT $LN21@AddListsTo
$LN20@AddListsTo:
	mov	cx, WORD PTR _i$[ebp]
	add	cx, 1
	mov	WORD PTR _i$[ebp], cx
$LN21@AddListsTo:
	movsx	edx, WORD PTR _i$[ebp]
	cmp	edx, 8
	jge	$LN19@AddListsTo

; 2534 : 	{
; 2535 : 		if(Team_[i].Waypoints == NULL)

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax+880], 0
	jne	$LN18@AddListsTo

; 2536 : 		{
; 2537 : 			Team_[i].Waypoints=new C_Waypoint;

	push	188					; 000000bcH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T25[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 7
	cmp	DWORD PTR $T25[ebp], 0
	je	SHORT $LN97@AddListsTo
	mov	ecx, DWORD PTR $T25[ebp]
	call	??0C_Waypoint@@QAE@XZ			; C_Waypoint::C_Waypoint
	mov	DWORD PTR tv1643[ebp], eax
	jmp	SHORT $LN98@AddListsTo
$LN97@AddListsTo:
	mov	DWORD PTR tv1643[ebp], 0
$LN98@AddListsTo:
	mov	edx, DWORD PTR tv1643[ebp]
	mov	DWORD PTR $T10[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T10[ebp]
	mov	DWORD PTR [ecx+eax+880], edx

; 2538 : 			Team_[i].Waypoints->Setup(5551272+i,C_TYPE_DRAGXY);

	push	38					; 00000026H
	movsx	eax, WORD PTR _i$[ebp]
	add	eax, 5551272				; 0054b4a8H
	push	eax
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+880]
	call	?Setup@C_Waypoint@@QAEXJF@Z		; C_Waypoint::Setup

; 2539 : 			Team_[i].Waypoints->SetCallback (WaypointCB);

	push	OFFSET ?WaypointCB@@YAXJFPAVC_Base@@@Z	; WaypointCB
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+880]
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax+880]
	mov	eax, DWORD PTR [edx+100]
	call	eax

; 2540 : 			Team_[i].Waypoints->SetFont(Font);

	mov	ecx, DWORD PTR _Font$[ebp]
	push	ecx
	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+880]
	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx+880]
	mov	edx, DWORD PTR [esi+68]
	call	edx

; 2541 : 			Team_[i].Waypoints->SetFlagBitOn(C_BIT_TOP);

	push	128					; 00000080H
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+880]
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax+880]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 2542 : 			Team_[i].Waypoints->SetCursorID(CRSR_STEERPOINT);

	push	14					; 0000000eH
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+880]
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx+880]
	mov	edx, DWORD PTR [eax+76]
	call	edx

; 2543 : 			SetTeamFlags(i,GetTeamFlags(i) | _MAP_WAYPOINTS_);

	movsx	eax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTeamFlags@C_Map@@QAEJJ@Z		; C_Map::GetTeamFlags
	or	eax, 268435456				; 10000000H
	push	eax
	movsx	ecx, WORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTeamFlags@C_Map@@QAEXJJ@Z		; C_Map::SetTeamFlags
$LN18@AddListsTo:

; 2544 : 		}
; 2545 : 		DrawWindow_->AddControl(Team_[i].Waypoints);

	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+880]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1124]
	call	?AddControl@C_Window@@QAEXPAVC_Base@@@Z	; C_Window::AddControl

; 2546 : 	}

	jmp	$LN20@AddListsTo
$LN19@AddListsTo:

; 2547 : 
; 2548 : 	// Current Waypoints (After the other waypoints... so they show up infront... (behind the airplanes though))
; 2549 : 	if(!CurWP_)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1092], 0
	jne	$LN17@AddListsTo

; 2550 : 	{
; 2551 : 		CurWP_=new C_Waypoint;

	push	188					; 000000bcH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T29[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 8
	cmp	DWORD PTR $T29[ebp], 0
	je	SHORT $LN99@AddListsTo
	mov	ecx, DWORD PTR $T29[ebp]
	call	??0C_Waypoint@@QAE@XZ			; C_Waypoint::C_Waypoint
	mov	DWORD PTR tv1764[ebp], eax
	jmp	SHORT $LN100@AddListsTo
$LN99@AddListsTo:
	mov	DWORD PTR tv1764[ebp], 0
$LN100@AddListsTo:
	mov	ecx, DWORD PTR tv1764[ebp]
	mov	DWORD PTR $T8[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T8[ebp]
	mov	DWORD PTR [edx+1092], eax

; 2552 : 		CurWP_->Setup(5555000,C_TYPE_DRAGXY);

	push	38					; 00000026H
	push	5555000					; 0054c338H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1092]
	call	?Setup@C_Waypoint@@QAEXJF@Z		; C_Waypoint::Setup

; 2553 : 		CurWP_->SetFlagBitOn(C_BIT_DRAGABLE);

	push	4096					; 00001000H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1092]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+1092]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 2554 : 		CurWP_->SetCallback (WaypointCB);

	push	OFFSET ?WaypointCB@@YAXJFPAVC_Base@@@Z	; WaypointCB
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1092]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+1092]
	mov	eax, DWORD PTR [edx+100]
	call	eax

; 2555 : 		CurWP_->SetFont(Font);

	mov	ecx, DWORD PTR _Font$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1092]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+1092]
	mov	eax, DWORD PTR [edx+68]
	call	eax

; 2556 : 		CurWP_->SetFlagBitOn(C_BIT_TOP);

	push	128					; 00000080H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1092]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+1092]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 2557 : 		CurWP_->SetCursorID(CRSR_STEERPOINT);

	push	14					; 0000000eH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1092]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+1092]
	mov	eax, DWORD PTR [edx+76]
	call	eax
$LN17@AddListsTo:

; 2558 : 	}
; 2559 : 	DrawWindow_->AddControl(CurWP_);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1092]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1124]
	call	?AddControl@C_Window@@QAEXPAVC_Base@@@Z	; C_Window::AddControl

; 2560 : 
; 2561 : 	for(i=0;i<_MAX_TEAMS_;i++)

	xor	ecx, ecx
	mov	WORD PTR _i$[ebp], cx
	jmp	SHORT $LN16@AddListsTo
$LN15@AddListsTo:
	mov	dx, WORD PTR _i$[ebp]
	add	dx, 1
	mov	WORD PTR _i$[ebp], dx
$LN16@AddListsTo:
	movsx	eax, WORD PTR _i$[ebp]
	cmp	eax, 8
	jge	$LN14@AddListsTo

; 2562 : 	{
; 2563 : 		if(Team_[i].AirUnits == NULL)

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+ecx+864], 0
	jne	$LN13@AddListsTo

; 2564 : 		{
; 2565 : 			Team_[i].AirUnits=new AIR_LIST;

	push	40					; 00000028H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T6[ebp], eax
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T6[ebp]
	mov	DWORD PTR [ecx+eax+864], edx

; 2566 : 			for(j=0;j<_MAP_NUM_AIR_TYPES_;j++)

	xor	eax, eax
	mov	WORD PTR _j$[ebp], ax
	jmp	SHORT $LN12@AddListsTo
$LN11@AddListsTo:
	mov	cx, WORD PTR _j$[ebp]
	add	cx, 1
	mov	WORD PTR _j$[ebp], cx
$LN12@AddListsTo:
	movsx	edx, WORD PTR _j$[ebp]
	cmp	edx, 5
	jge	$LN10@AddListsTo

; 2567 : 			{
; 2568 : 				Team_[i].AirUnits->Type[j]=new C_MapIcon;

	push	204					; 000000ccH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T22[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 9
	cmp	DWORD PTR $T22[ebp], 0
	je	SHORT $LN101@AddListsTo
	mov	ecx, DWORD PTR $T22[ebp]
	call	??0C_MapIcon@@QAE@XZ			; C_MapIcon::C_MapIcon
	mov	DWORD PTR tv1871[ebp], eax
	jmp	SHORT $LN102@AddListsTo
$LN101@AddListsTo:
	mov	DWORD PTR tv1871[ebp], 0
$LN102@AddListsTo:
	mov	eax, DWORD PTR tv1871[ebp]
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+864]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR $T4[ebp]
	mov	DWORD PTR [eax+ecx*4+20], edx

; 2569 : 				Team_[i].AirUnits->Type[j]->Setup(5551201+i+j*10,j);

	movzx	eax, WORD PTR _j$[ebp]
	push	eax
	movsx	ecx, WORD PTR _i$[ebp]
	movsx	edx, WORD PTR _j$[ebp]
	imul	edx, 10					; 0000000aH
	lea	eax, DWORD PTR [ecx+edx+5551201]
	push	eax
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+864]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4+20]
	call	?Setup@C_MapIcon@@QAEXJF@Z		; C_MapIcon::Setup

; 2570 : 				Team_[i].AirUnits->Type[j]->SetFont(Font);

	mov	edx, DWORD PTR _Font$[ebp]
	push	edx
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+864]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+20]
	movsx	edx, WORD PTR _j$[ebp]
	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [esi+eax+864]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4+20]
	mov	edx, DWORD PTR [esi+68]
	call	edx

; 2571 : 				Team_[i].AirUnits->Type[j]->SetTeam(i);

	movzx	eax, WORD PTR _i$[ebp]
	push	eax
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+864]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4+20]
	call	?SetTeam@C_MapIcon@@QAEXF@Z		; C_MapIcon::SetTeam

; 2572 : 
; 2573 : 				Team_[i].AirUnits->Type[j]->SetMainImage(C_STATE_0,AirIconIDs_[i][0][0],AirIconIDs_[i][0][1]);

	movsx	edx, WORD PTR _i$[ebp]
	shl	edx, 6
	add	edx, DWORD PTR _this$[ebp]
	mov	eax, 8
	imul	eax, 0
	add	edx, eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR [edx+ecx]
	push	edx
	movsx	eax, WORD PTR _i$[ebp]
	shl	eax, 6
	add	eax, DWORD PTR _this$[ebp]
	mov	ecx, 8
	imul	ecx, 0
	add	eax, ecx
	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR [eax+edx]
	push	eax
	push	0
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+864]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4+20]
	call	?SetMainImage@C_MapIcon@@QAEXFJJ@Z	; C_MapIcon::SetMainImage

; 2574 : 				Team_[i].AirUnits->Type[j]->SetMainImage(C_STATE_1,AirIconIDs_[i][1][0],AirIconIDs_[i][1][1]);

	movsx	edx, WORD PTR _i$[ebp]
	shl	edx, 6
	add	edx, DWORD PTR _this$[ebp]
	mov	eax, 8
	shl	eax, 0
	add	edx, eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR [edx+ecx]
	push	edx
	movsx	eax, WORD PTR _i$[ebp]
	shl	eax, 6
	add	eax, DWORD PTR _this$[ebp]
	mov	ecx, 8
	shl	ecx, 0
	add	eax, ecx
	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR [eax+edx]
	push	eax
	push	1
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+864]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4+20]
	call	?SetMainImage@C_MapIcon@@QAEXFJJ@Z	; C_MapIcon::SetMainImage

; 2575 : 				Team_[i].AirUnits->Type[j]->SetMainImage(C_STATE_2,AirIconIDs_[i][2][0],AirIconIDs_[i][2][1]);

	movsx	edx, WORD PTR _i$[ebp]
	shl	edx, 6
	add	edx, DWORD PTR _this$[ebp]
	mov	eax, 8
	shl	eax, 1
	add	edx, eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR [edx+ecx]
	push	edx
	movsx	eax, WORD PTR _i$[ebp]
	shl	eax, 6
	add	eax, DWORD PTR _this$[ebp]
	mov	ecx, 8
	shl	ecx, 1
	add	eax, ecx
	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR [eax+edx]
	push	eax
	push	2
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+864]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4+20]
	call	?SetMainImage@C_MapIcon@@QAEXFJJ@Z	; C_MapIcon::SetMainImage

; 2576 : 				Team_[i].AirUnits->Type[j]->SetMainImage(C_STATE_3,AirIconIDs_[i][3][0],AirIconIDs_[i][3][1]);

	movsx	edx, WORD PTR _i$[ebp]
	shl	edx, 6
	add	edx, DWORD PTR _this$[ebp]
	mov	eax, 8
	imul	eax, 3
	add	edx, eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR [edx+ecx]
	push	edx
	movsx	eax, WORD PTR _i$[ebp]
	shl	eax, 6
	add	eax, DWORD PTR _this$[ebp]
	mov	ecx, 8
	imul	ecx, 3
	add	eax, ecx
	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR [eax+edx]
	push	eax
	push	3
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+864]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4+20]
	call	?SetMainImage@C_MapIcon@@QAEXFJJ@Z	; C_MapIcon::SetMainImage

; 2577 : 				Team_[i].AirUnits->Type[j]->SetMainImage(C_STATE_4,AirIconIDs_[i][4][0],AirIconIDs_[i][4][1]);

	movsx	edx, WORD PTR _i$[ebp]
	shl	edx, 6
	add	edx, DWORD PTR _this$[ebp]
	mov	eax, 8
	shl	eax, 2
	add	edx, eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR [edx+ecx]
	push	edx
	movsx	eax, WORD PTR _i$[ebp]
	shl	eax, 6
	add	eax, DWORD PTR _this$[ebp]
	mov	ecx, 8
	shl	ecx, 2
	add	eax, ecx
	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR [eax+edx]
	push	eax
	push	4
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+864]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4+20]
	call	?SetMainImage@C_MapIcon@@QAEXFJJ@Z	; C_MapIcon::SetMainImage

; 2578 : 				Team_[i].AirUnits->Type[j]->SetMainImage(C_STATE_5,AirIconIDs_[i][5][0],AirIconIDs_[i][5][1]);

	movsx	edx, WORD PTR _i$[ebp]
	shl	edx, 6
	add	edx, DWORD PTR _this$[ebp]
	mov	eax, 8
	imul	eax, 5
	add	edx, eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR [edx+ecx]
	push	edx
	movsx	eax, WORD PTR _i$[ebp]
	shl	eax, 6
	add	eax, DWORD PTR _this$[ebp]
	mov	ecx, 8
	imul	ecx, 5
	add	eax, ecx
	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR [eax+edx]
	push	eax
	push	5
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+864]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4+20]
	call	?SetMainImage@C_MapIcon@@QAEXFJJ@Z	; C_MapIcon::SetMainImage

; 2579 : 				Team_[i].AirUnits->Type[j]->SetMainImage(C_STATE_6,AirIconIDs_[i][6][0],AirIconIDs_[i][6][1]);

	movsx	edx, WORD PTR _i$[ebp]
	shl	edx, 6
	add	edx, DWORD PTR _this$[ebp]
	mov	eax, 8
	imul	eax, 6
	add	edx, eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR [edx+ecx]
	push	edx
	movsx	eax, WORD PTR _i$[ebp]
	shl	eax, 6
	add	eax, DWORD PTR _this$[ebp]
	mov	ecx, 8
	imul	ecx, 6
	add	eax, ecx
	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR [eax+edx]
	push	eax
	push	6
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+864]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4+20]
	call	?SetMainImage@C_MapIcon@@QAEXFJJ@Z	; C_MapIcon::SetMainImage

; 2580 : 				Team_[i].AirUnits->Type[j]->SetMainImage(C_STATE_7,AirIconIDs_[i][7][0],AirIconIDs_[i][7][1]);

	movsx	edx, WORD PTR _i$[ebp]
	shl	edx, 6
	add	edx, DWORD PTR _this$[ebp]
	mov	eax, 8
	imul	eax, 7
	add	edx, eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR [edx+ecx]
	push	edx
	movsx	eax, WORD PTR _i$[ebp]
	shl	eax, 6
	add	eax, DWORD PTR _this$[ebp]
	mov	ecx, 8
	imul	ecx, 7
	add	eax, ecx
	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR [eax+edx]
	push	eax
	push	7
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+864]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4+20]
	call	?SetMainImage@C_MapIcon@@QAEXFJJ@Z	; C_MapIcon::SetMainImage

; 2581 : 
; 2582 : 				Team_[i].AirUnits->Type[j]->SetFlagBitOn(C_BIT_NOLABEL);

	push	16777216				; 01000000H
	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+864]
	movsx	edx, WORD PTR _j$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+20]
	movsx	ecx, WORD PTR _j$[ebp]
	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [esi+edx+864]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4+20]
	mov	edx, DWORD PTR [eax+8]
	call	edx

; 2583 : 				if(TheCampaign.Flags & CAMP_TACTICAL_EDIT)

	mov	eax, DWORD PTR ?TheCampaign@@3VCampaignClass@@A+64
	and	eax, 524288				; 00080000H
	je	SHORT $LN9@AddListsTo

; 2584 : 					Team_[i].AirUnits->Type[j]->SetFlagBitOn(C_BIT_DRAGABLE);

	push	4096					; 00001000H
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+864]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+20]
	movsx	eax, WORD PTR _j$[ebp]
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+864]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4+20]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 2585 : 				else

	jmp	SHORT $LN8@AddListsTo
$LN9@AddListsTo:

; 2586 : 					Team_[i].AirUnits->Type[j]->SetFlagBitOff(C_BIT_DRAGABLE);

	push	4096					; 00001000H
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+864]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+20]
	movsx	eax, WORD PTR _j$[ebp]
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+864]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4+20]
	mov	eax, DWORD PTR [edx+12]
	call	eax
$LN8@AddListsTo:

; 2587 : 				Team_[i].AirUnits->Type[j]->SetCursorID(CRSR_F16_RM);

	push	4
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+864]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+20]
	movsx	eax, WORD PTR _j$[ebp]
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+864]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4+20]
	mov	eax, DWORD PTR [edx+76]
	call	eax

; 2588 : 				Team_[i].AirUnits->Type[j]->SetMenu(AIRUNIT_MENU);

	push	18710					; 00004916H
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+864]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+20]
	movsx	eax, WORD PTR _j$[ebp]
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+864]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4+20]
	mov	eax, DWORD PTR [edx+64]
	call	eax

; 2589 : 				Team_[i].AirUnits->Type[j]->SetCallback(UnitCB);

	push	OFFSET ?UnitCB@@YAXJFPAVC_Base@@@Z	; UnitCB
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+864]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+20]
	movsx	eax, WORD PTR _j$[ebp]
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+864]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4+20]
	mov	eax, DWORD PTR [edx+100]
	call	eax

; 2590 : 				if(AirUnitMask_ & (1 << j))

	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, 1
	shl	edx, cl
	mov	eax, DWORD PTR _this$[ebp]
	and	edx, DWORD PTR [eax+796]
	je	SHORT $LN7@AddListsTo

; 2591 : 				{
; 2592 : 					Team_[i].AirUnits->Flags[j]=1;

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+864]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	DWORD PTR [eax+ecx*4], 1

; 2593 : 					Team_[i].AirUnits->Type[j]->SetFlagBitOff(C_BIT_INVISIBLE);

	push	8192					; 00002000H
	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+864]
	movsx	edx, WORD PTR _j$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+20]
	movsx	ecx, WORD PTR _j$[ebp]
	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [esi+edx+864]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4+20]
	mov	edx, DWORD PTR [eax+12]
	call	edx

; 2594 : 				}
; 2595 : 				else

	jmp	SHORT $LN6@AddListsTo
$LN7@AddListsTo:

; 2596 : 				{
; 2597 : 					Team_[i].AirUnits->Flags[j]=0;

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+864]
	movsx	eax, WORD PTR _j$[ebp]
	mov	DWORD PTR [edx+eax*4], 0

; 2598 : 					Team_[i].AirUnits->Type[j]->SetFlagBitOn(C_BIT_INVISIBLE);

	push	8192					; 00002000H
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+864]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+20]
	movsx	eax, WORD PTR _j$[ebp]
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 24					; 00000018H
	mov	esi, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+864]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4+20]
	mov	eax, DWORD PTR [edx+8]
	call	eax
$LN6@AddListsTo:

; 2599 : 				}
; 2600 : 			}

	jmp	$LN11@AddListsTo
$LN10@AddListsTo:

; 2601 : 			SetTeamFlags(i,GetTeamFlags(i) | _MAP_AIR_UNITS_);

	movsx	ecx, WORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTeamFlags@C_Map@@QAEJJ@Z		; C_Map::GetTeamFlags
	or	eax, 67108864				; 04000000H
	push	eax
	movsx	edx, WORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTeamFlags@C_Map@@QAEXJJ@Z		; C_Map::SetTeamFlags
$LN13@AddListsTo:

; 2602 : 		}
; 2603 : 		for(j=0;j<_MAP_NUM_AIR_TYPES_;j++)

	xor	eax, eax
	mov	WORD PTR _j$[ebp], ax
	jmp	SHORT $LN5@AddListsTo
$LN4@AddListsTo:
	mov	cx, WORD PTR _j$[ebp]
	add	cx, 1
	mov	WORD PTR _j$[ebp], cx
$LN5@AddListsTo:
	movsx	edx, WORD PTR _j$[ebp]
	cmp	edx, 5
	jge	SHORT $LN3@AddListsTo

; 2604 : 			DrawWindow_->AddControl(Team_[i].AirUnits->Type[j]);

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+864]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+20]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1124]
	call	?AddControl@C_Window@@QAEXPAVC_Base@@@Z	; C_Window::AddControl
	jmp	SHORT $LN4@AddListsTo
$LN3@AddListsTo:

; 2605 : 	}

	jmp	$LN15@AddListsTo
$LN14@AddListsTo:

; 2606 : 	if(!CurWPZ_)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1096], 0
	jne	$LN2@AddListsTo

; 2607 : 	{
; 2608 : 		CurWPZ_=new C_Waypoint;

	push	188					; 000000bcH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T28[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 10		; 0000000aH
	cmp	DWORD PTR $T28[ebp], 0
	je	SHORT $LN103@AddListsTo
	mov	ecx, DWORD PTR $T28[ebp]
	call	??0C_Waypoint@@QAE@XZ			; C_Waypoint::C_Waypoint
	mov	DWORD PTR tv2447[ebp], eax
	jmp	SHORT $LN104@AddListsTo
$LN103@AddListsTo:
	mov	DWORD PTR tv2447[ebp], 0
$LN104@AddListsTo:
	mov	ecx, DWORD PTR tv2447[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR [edx+1096], eax

; 2609 : 		CurWPZ_->Setup(5555000,C_TYPE_DRAGY);

	push	37					; 00000025H
	push	5555000					; 0054c338H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1096]
	call	?Setup@C_Waypoint@@QAEXJF@Z		; C_Waypoint::Setup

; 2610 : 		CurWPZ_->SetScaleType(1);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1096]
	call	?SetScaleType@C_Waypoint@@QAEXF@Z	; C_Waypoint::SetScaleType

; 2611 : 		CurWPZ_->SetWorldRange(LogMinX_,LogMinY_,LogMaxX_,LogMaxY_);

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+764]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+760]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+756]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+752]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1096]
	call	?SetWorldRange@C_Waypoint@@QAEXMMMM@Z	; C_Waypoint::SetWorldRange

; 2612 : 		CurWPZ_->SetFlagBitOn(C_BIT_DRAGABLE);

	push	4096					; 00001000H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1096]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+1096]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 2613 : 		CurWPZ_->SetCallback (WaypointCB);

	push	OFFSET ?WaypointCB@@YAXJFPAVC_Base@@@Z	; WaypointCB
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1096]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+1096]
	mov	eax, DWORD PTR [edx+100]
	call	eax

; 2614 : 		CurWPZ_->SetFont(Font);

	mov	ecx, DWORD PTR _Font$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1096]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+1096]
	mov	eax, DWORD PTR [edx+68]
	call	eax

; 2615 : 		CurWPZ_->SetClient(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1096]
	call	?SetClient@C_Base@@QAEXF@Z		; C_Base::SetClient

; 2616 : 		CurWPZ_->SetFlagBitOn(C_BIT_TOP);

	push	128					; 00000080H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1096]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+1096]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 2617 : 		CurWPZ_->SetCursorID(CRSR_STEERPOINT);

	push	14					; 0000000eH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1096]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+1096]
	mov	eax, DWORD PTR [edx+76]
	call	eax
$LN2@AddListsTo:

; 2618 : 	}
; 2619 : 	if(WPZWindow_)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1128], 0
	je	SHORT $LN1@AddListsTo

; 2620 : 		WPZWindow_->AddControl(CurWPZ_);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1096]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1128]
	call	?AddControl@C_Window@@QAEXPAVC_Base@@@Z	; C_Window::AddControl
$LN1@AddListsTo:

; 2621 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?AddListsToWindow@C_Map@@AAEXXZ$0:
	mov	eax, DWORD PTR $T24[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?AddListsToWindow@C_Map@@AAEXXZ$1:
	mov	eax, DWORD PTR $T27[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?AddListsToWindow@C_Map@@AAEXXZ$2:
	mov	eax, DWORD PTR $T26[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?AddListsToWindow@C_Map@@AAEXXZ$3:
	mov	eax, DWORD PTR $T23[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?AddListsToWindow@C_Map@@AAEXXZ$4:
	mov	eax, DWORD PTR $T20[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?AddListsToWindow@C_Map@@AAEXXZ$5:
	mov	eax, DWORD PTR $T21[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?AddListsToWindow@C_Map@@AAEXXZ$6:
	mov	eax, DWORD PTR $T19[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?AddListsToWindow@C_Map@@AAEXXZ$7:
	mov	eax, DWORD PTR $T25[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?AddListsToWindow@C_Map@@AAEXXZ$8:
	mov	eax, DWORD PTR $T29[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?AddListsToWindow@C_Map@@AAEXXZ$9:
	mov	eax, DWORD PTR $T22[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?AddListsToWindow@C_Map@@AAEXXZ$10:
	mov	eax, DWORD PTR $T28[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?AddListsToWindow@C_Map@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-188]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AddListsToWindow@C_Map@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?AddListsToWindow@C_Map@@AAEXXZ ENDP			; C_Map::AddListsToWindow
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
$T2 = -304						; size = 8
$T3 = -296						; size = 8
$T4 = -288						; size = 8
$T5 = -280						; size = 8
_tempz$ = -272						; size = 4
_distance$ = -268					; size = 8
tv1668 = -260						; size = 4
$T6 = -256						; size = 4
$T7 = -252						; size = 4
_starttime$ = -248					; size = 4
$T8 = -244						; size = 4
$T9 = -240						; size = 4
tv1452 = -236						; size = 4
_ZDrag$ = -232						; size = 4
_ly$ = -228						; size = 4
tv815 = -224						; size = 4
_tempy$ = -220						; size = 4
_tempx$ = -216						; size = 4
tv918 = -212						; size = 4
$T10 = -208						; size = 4
_lz$ = -204						; size = 4
tv1069 = -200						; size = 4
_lx$ = -196						; size = 4
$T11 = -192						; size = 4
$T12 = -188						; size = 4
$T13 = -184						; size = 4
_dz$ = -180						; size = 4
$T14 = -176						; size = 4
_endtime$ = -172					; size = 4
$T15 = -168						; size = 4
tv1169 = -164						; size = 4
$T16 = -160						; size = 4
$T17 = -156						; size = 4
_xval$ = -152						; size = 4
_target$ = -148						; size = 4
_numwp$ = -144						; size = 4
_gpsItem$ = -140					; size = 4
_prevwp$ = -136						; size = 4
_lastwp$ = -132						; size = 2
_selID$ = -128						; size = 4
_othrID$ = -124						; size = 4
_normID$ = -120						; size = 4
_z$ = -116						; size = 4
_UseFlag$ = -112					; size = 4
_dy$ = -108						; size = 4
_dx$ = -104						; size = 4
_state$ = -100						; size = 2
_tmpID$ = -96						; size = 4
_firstwp$ = -92						; size = 4
_x$ = -88						; size = 4
_y$ = -84						; size = 4
_airwps$ = -80						; size = 2
_wp$ = -76						; size = 4
_wpl$ = -72						; size = 4
_campID$ = -68						; size = 4
_i$ = -64						; size = 4
_this$ = -60						; size = 4
_buf$ = -56						; size = 40
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_unit$ = 8						; size = 4
?BuildCurrentWPList@C_Map@@AAEXPAVUnitClass@@@Z PROC	; C_Map::BuildCurrentWPList
; _this$ = ecx

; 903  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?BuildCurrentWPList@C_Map@@AAEXPAVUnitClass@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 904  : 	WayPoint wp=NULL,prevwp=NULL,firstwp=NULL;

	mov	DWORD PTR _wp$[ebp], 0
	mov	DWORD PTR _prevwp$[ebp], 0
	mov	DWORD PTR _firstwp$[ebp], 0

; 905  : 	float x,y,z,tempx,tempy,tempz;
; 906  : 	long normID,selID,othrID;
; 907  : 	long i,numwp,xval;
; 908  : 	long starttime,endtime;
; 909  : 	long campID;
; 910  : 	long UseFlag,ZDrag;
; 911  : 	double distance;
; 912  : 	float lx,ly,lz,dx,dy,dz;
; 913  : 	WAYPOINTLIST *wpl=NULL;

	mov	DWORD PTR _wpl$[ebp], 0

; 914  : 	CampEntity target;
; 915  : 	short state;
; 916  : 	_TCHAR buf[40];
; 917  : 	VU_ID *tmpID=NULL;

	mov	DWORD PTR _tmpID$[ebp], 0

; 918  : 	UI_Refresher *gpsItem=NULL;

	mov	DWORD PTR _gpsItem$[ebp], 0

; 919  : 	short airwps,lastwp;
; 920  : 
; 921  : 	if(unit == NULL) return;

	cmp	DWORD PTR _unit$[ebp], 0
	jne	SHORT $LN80@BuildCurre
	jmp	$LN81@BuildCurre
$LN80@BuildCurre:

; 922  : 	if(unit->IsFlight() && !unit->Final()) return;

	mov	eax, DWORD PTR _unit$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _unit$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax
	test	eax, eax
	je	SHORT $LN79@BuildCurre
	mov	ecx, DWORD PTR _unit$[ebp]
	call	?Final@UnitClass@@QBEHXZ		; UnitClass::Final
	test	eax, eax
	jne	SHORT $LN79@BuildCurre
	jmp	$LN81@BuildCurre
$LN79@BuildCurre:

; 923  : 	if(!CurWP_ || !CurWPZ_)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1092], 0
	je	SHORT $LN77@BuildCurre
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1096], 0
	jne	SHORT $LN78@BuildCurre
$LN77@BuildCurre:

; 924  : 		return;

	jmp	$LN81@BuildCurre
$LN78@BuildCurre:

; 925  : 
; 926  : 	airwps=static_cast<short>(unit->IsFlight());

	mov	eax, DWORD PTR _unit$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _unit$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax
	mov	WORD PTR _airwps$[ebp], ax

; 927  : 
; 928  : 	if (!airwps)

	movsx	ecx, WORD PTR _airwps$[ebp]
	test	ecx, ecx
	jne	SHORT $LN75@BuildCurre

; 929  : 		{
; 930  : 		firstwp=unit->GetCurrentUnitWP();

	mov	ecx, DWORD PTR _unit$[ebp]
	call	?GetCurrentUnitWP@UnitClass@@QBEPAVWayPointClass@@XZ ; UnitClass::GetCurrentUnitWP
	mov	DWORD PTR _firstwp$[ebp], eax

; 931  : 		if (firstwp && firstwp->GetPrevWP())

	cmp	DWORD PTR _firstwp$[ebp], 0
	je	SHORT $LN75@BuildCurre
	mov	ecx, DWORD PTR _firstwp$[ebp]
	call	?GetPrevWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetPrevWP
	test	eax, eax
	je	SHORT $LN75@BuildCurre

; 932  : 			firstwp = firstwp->GetPrevWP();

	mov	ecx, DWORD PTR _firstwp$[ebp]
	call	?GetPrevWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetPrevWP
	mov	DWORD PTR _firstwp$[ebp], eax
$LN75@BuildCurre:

; 933  : 		}
; 934  : 	if (!firstwp || airwps)

	cmp	DWORD PTR _firstwp$[ebp], 0
	je	SHORT $LN73@BuildCurre
	movsx	edx, WORD PTR _airwps$[ebp]
	test	edx, edx
	je	SHORT $LN74@BuildCurre
$LN73@BuildCurre:

; 935  : 		firstwp=unit->GetFirstUnitWP();

	mov	ecx, DWORD PTR _unit$[ebp]
	call	?GetFirstUnitWP@UnitClass@@QAEPAVWayPointClass@@XZ ; UnitClass::GetFirstUnitWP
	mov	DWORD PTR _firstwp$[ebp], eax
$LN74@BuildCurre:

; 936  : 	if (!firstwp) return;

	cmp	DWORD PTR _firstwp$[ebp], 0
	jne	SHORT $LN72@BuildCurre
	jmp	$LN81@BuildCurre
$LN72@BuildCurre:

; 937  : 
; 938  : 	wp = firstwp;

	mov	eax, DWORD PTR _firstwp$[ebp]
	mov	DWORD PTR _wp$[ebp], eax

; 939  : 
; 940  : 	starttime=wp->GetWPDepartureTime();

	mov	ecx, DWORD PTR _wp$[ebp]
	call	?GetWPDepartureTime@WayPointClass@@QAEKXZ ; WayPointClass::GetWPDepartureTime
	mov	DWORD PTR _starttime$[ebp], eax

; 941  : 	endtime=wp->GetWPDepartureTime();//so endtime has a value if it doesn't get otherwise initialized

	mov	ecx, DWORD PTR _wp$[ebp]
	call	?GetWPDepartureTime@WayPointClass@@QAEKXZ ; WayPointClass::GetWPDepartureTime
	mov	DWORD PTR _endtime$[ebp], eax

; 942  : 	campID=unit->GetCampID() << 8;

	mov	ecx, DWORD PTR _unit$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _unit$[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax
	movsx	ecx, ax
	shl	ecx, 8
	mov	DWORD PTR _campID$[ebp], ecx

; 943  : 
; 944  : 	// set to 0 after Landing WP so we don't connect lines to following waypoints which are not on the agenda (Alt Land cit,Tanker etc)
; 945  : 	UseFlag=C_BIT_USELINE;

	mov	DWORD PTR _UseFlag$[ebp], 4194304	; 00400000H

; 946  : 
; 947  : 	prevwp=NULL;

	mov	DWORD PTR _prevwp$[ebp], 0

; 948  : 	numwp=0;

	mov	DWORD PTR _numwp$[ebp], 0
$LN71@BuildCurre:

; 949  : 	while(wp)

	cmp	DWORD PTR _wp$[ebp], 0
	je	SHORT $LN70@BuildCurre

; 950  : 	{
; 951  : 		numwp++;

	mov	edx, DWORD PTR _numwp$[ebp]
	add	edx, 1
	mov	DWORD PTR _numwp$[ebp], edx

; 952  : 		wp=wp->GetNextWP();

	mov	ecx, DWORD PTR _wp$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _wp$[ebp], eax

; 953  : 	}

	jmp	SHORT $LN71@BuildCurre
$LN70@BuildCurre:

; 954  : 
; 955  : 	if(airwps)

	movsx	eax, WORD PTR _airwps$[ebp]
	test	eax, eax
	je	SHORT $LN69@BuildCurre

; 956  : 	{
; 957  : 		CurWP_->SetMenu(STEERPOINT_POP);

	push	18198					; 00004716H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1092]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+1092]
	mov	eax, DWORD PTR [edx+64]
	call	eax

; 958  : 		CurWPZ_->SetMenu(STEERPOINT_POP);

	push	18198					; 00004716H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1096]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+1096]
	mov	eax, DWORD PTR [edx+64]
	call	eax

; 959  : 	}
; 960  : 	else

	jmp	SHORT $LN68@BuildCurre
$LN69@BuildCurre:

; 961  : 	{
; 962  : 		CurWP_->SetMenu(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1092]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+1092]
	mov	eax, DWORD PTR [edx+64]
	call	eax

; 963  : 		CurWPZ_->SetMenu(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1096]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+1096]
	mov	eax, DWORD PTR [edx+64]
	call	eax
$LN68@BuildCurre:

; 964  : 	}
; 965  : 	CurIcons_->Cleanup();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1116]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+1116]
	mov	eax, DWORD PTR [edx+176]
	call	eax

; 966  : 	CurIcons_->Setup(CurIcons_->GetID(),0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1116]
	call	?GetID@C_Base@@QAEJXZ			; C_Base::GetID
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1116]
	call	?Setup@C_DrawList@@QAEXJF@Z		; C_DrawList::Setup

; 967  : 
; 968  : 	if(TheCampaign.Flags & CAMP_TACTICAL_EDIT)

	mov	eax, DWORD PTR ?TheCampaign@@3VCampaignClass@@A+64
	and	eax, 524288				; 00080000H
	je	SHORT $LN67@BuildCurre

; 969  : 	{
; 970  : 		CurWP_->SetFlagBitOn(C_BIT_DRAGABLE);

	push	4096					; 00001000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1092]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+1092]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 971  : 		CurWPZ_->SetFlagBitOn(C_BIT_DRAGABLE);

	push	4096					; 00001000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1096]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+1096]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 972  : 	}
; 973  : 	else

	jmp	$LN63@BuildCurre
$LN67@BuildCurre:

; 974  : 	{
; 975  : 		if(firstwp == unit->GetCurrentUnitWP() || !airwps)

	mov	ecx, DWORD PTR _unit$[ebp]
	call	?GetCurrentUnitWP@UnitClass@@QBEPAVWayPointClass@@XZ ; UnitClass::GetCurrentUnitWP
	cmp	DWORD PTR _firstwp$[ebp], eax
	je	SHORT $LN64@BuildCurre
	movsx	ecx, WORD PTR _airwps$[ebp]
	test	ecx, ecx
	jne	SHORT $LN65@BuildCurre
$LN64@BuildCurre:

; 976  : 		{
; 977  : 			CurWP_->SetFlagBitOn(C_BIT_DRAGABLE);

	push	4096					; 00001000H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1092]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+1092]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 978  : 			CurWPZ_->SetFlagBitOn(C_BIT_DRAGABLE);

	push	4096					; 00001000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1096]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+1096]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 979  : 		}
; 980  : 		else

	jmp	SHORT $LN63@BuildCurre
$LN65@BuildCurre:

; 981  : 		{
; 982  : 			CurWP_->SetFlagBitOff(C_BIT_DRAGABLE);

	push	4096					; 00001000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1092]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+1092]
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 983  : 			CurWPZ_->SetFlagBitOff(C_BIT_DRAGABLE);

	push	4096					; 00001000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1096]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+1096]
	mov	eax, DWORD PTR [edx+12]
	call	eax
$LN63@BuildCurre:

; 984  : 		}
; 985  : 	}
; 986  : 	i=1;

	mov	DWORD PTR _i$[ebp], 1

; 987  : 	wp=firstwp;

	mov	ecx, DWORD PTR _firstwp$[ebp]
	mov	DWORD PTR _wp$[ebp], ecx
$LN62@BuildCurre:

; 988  : 	while(wp)

	cmp	DWORD PTR _wp$[ebp], 0
	je	$LN61@BuildCurre

; 989  : 	{
; 990  : 		wp->GetLocation(&x,&y,&z);

	lea	edx, DWORD PTR _z$[ebp]
	push	edx
	lea	eax, DWORD PTR _y$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _wp$[ebp]
	call	?GetLocation@WayPointClass@@QBEXPAM00@Z	; WayPointClass::GetLocation

; 991  : 		if(x < CurWPArea_.left || CurWPArea_.left < 0)

	mov	edx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [edx+1100]
	comiss	xmm0, DWORD PTR _x$[ebp]
	ja	SHORT $LN59@BuildCurre
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1100], 0
	jge	SHORT $LN60@BuildCurre
$LN59@BuildCurre:

; 992  : 			CurWPArea_.left=static_cast<long>(x);

	cvttss2si ecx, DWORD PTR _x$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1100], ecx
$LN60@BuildCurre:

; 993  : 		if(x > CurWPArea_.right || CurWPArea_.right < 0)

	mov	eax, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+1108]
	movss	xmm1, DWORD PTR _x$[ebp]
	comiss	xmm1, xmm0
	ja	SHORT $LN57@BuildCurre
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1108], 0
	jge	SHORT $LN58@BuildCurre
$LN57@BuildCurre:

; 994  : 			CurWPArea_.right=static_cast<long>(x);

	cvttss2si edx, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1108], edx
$LN58@BuildCurre:

; 995  : 		if(y < CurWPArea_.top || CurWPArea_.top < 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx+1104]
	comiss	xmm0, DWORD PTR _y$[ebp]
	ja	SHORT $LN55@BuildCurre
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1104], 0
	jge	SHORT $LN56@BuildCurre
$LN55@BuildCurre:

; 996  : 			CurWPArea_.top=static_cast<long>(y);

	cvttss2si eax, DWORD PTR _y$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1104], eax
$LN56@BuildCurre:

; 997  : 		if(y > CurWPArea_.bottom || CurWPArea_.bottom < 0)

	mov	edx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [edx+1112]
	movss	xmm1, DWORD PTR _y$[ebp]
	comiss	xmm1, xmm0
	ja	SHORT $LN53@BuildCurre
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1112], 0
	jge	SHORT $LN54@BuildCurre
$LN53@BuildCurre:

; 998  : 			CurWPArea_.bottom=static_cast<long>(y);

	cvttss2si ecx, DWORD PTR _y$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1112], ecx
$LN54@BuildCurre:

; 999  : 
; 1000 : 		if(wp->GetWPFlags() & WPF_TARGET)

	mov	ecx, DWORD PTR _wp$[ebp]
	call	?GetWPFlags@WayPointClass@@QAEKXZ	; WayPointClass::GetWPFlags
	and	eax, 1
	je	$LN52@BuildCurre

; 1001 : 		{
; 1002 : 		// Set 2d Waypoint
; 1003 : 			wpl=CurWP_->AddWaypointToList(0x20000000+campID+i,0,ASSIGNED_TGT_CUR,ASSIGNED_TGT_CUR,ASSIGNED_TGT_CUR,y,maxy-x,FALSE);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+732]
	subss	xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	10519					; 00002917H
	push	10519					; 00002917H
	push	10519					; 00002917H
	push	0
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _campID$[ebp]
	lea	eax, DWORD PTR [edx+ecx+536870912]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1092]
	call	?AddWaypointToList@C_Waypoint@@QAEPAVWAYPOINTLIST@@JFJJJMMF@Z ; C_Waypoint::AddWaypointToList
	mov	DWORD PTR _wpl$[ebp], eax

; 1004 : 			if(wpl)

	cmp	DWORD PTR _wpl$[ebp], 0
	je	SHORT $LN51@BuildCurre

; 1005 : 			{
; 1006 : 				CurWP_->SetWPGroup(campID+i,campID+i);

	mov	edx, DWORD PTR _campID$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	eax, DWORD PTR _campID$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1092]
	call	?SetWPGroup@C_Waypoint@@QAEXJJ@Z	; C_Waypoint::SetWPGroup

; 1007 : 				CurWP_->SetState(campID+i,0);

	push	0
	mov	edx, DWORD PTR _campID$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1092]
	call	?SetState@C_Waypoint@@QAEXJF@Z		; C_Waypoint::SetState

; 1008 : 				wpl->Flags &= ~C_BIT_ENABLED;

	mov	ecx, DWORD PTR _wpl$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	and	edx, -2049				; fffff7ffH
	mov	eax, DWORD PTR _wpl$[ebp]
	mov	DWORD PTR [eax+8], edx
$LN51@BuildCurre:

; 1009 : 			}
; 1010 : 		}

	jmp	$LN47@BuildCurre
$LN52@BuildCurre:

; 1011 : 		else if ((wp->GetWPAction () == WP_TAKEOFF) || (wp->GetWPAction () == WP_LAND))

	mov	ecx, DWORD PTR _wp$[ebp]
	call	?GetWPAction@WayPointClass@@QAEHXZ	; WayPointClass::GetWPAction
	cmp	eax, 1
	je	SHORT $LN48@BuildCurre
	mov	ecx, DWORD PTR _wp$[ebp]
	call	?GetWPAction@WayPointClass@@QAEHXZ	; WayPointClass::GetWPAction
	cmp	eax, 7
	jne	$LN47@BuildCurre
$LN48@BuildCurre:

; 1012 : 		{
; 1013 : 		// Set 2d Waypoint
; 1014 : 			wpl=CurWP_->AddWaypointToList(0x20000000+campID+i,0,HOME_BASE_CUR,HOME_BASE_CUR,HOME_BASE_CUR,y,maxy-x,FALSE);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+732]
	subss	xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	10520					; 00002918H
	push	10520					; 00002918H
	push	10520					; 00002918H
	push	0
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _campID$[ebp]
	lea	ecx, DWORD PTR [eax+edx+536870912]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1092]
	call	?AddWaypointToList@C_Waypoint@@QAEPAVWAYPOINTLIST@@JFJJJMMF@Z ; C_Waypoint::AddWaypointToList
	mov	DWORD PTR _wpl$[ebp], eax

; 1015 : 			if(wpl)

	cmp	DWORD PTR _wpl$[ebp], 0
	je	SHORT $LN47@BuildCurre

; 1016 : 			{
; 1017 : 				CurWP_->SetWPGroup(campID+i,campID+i);

	mov	eax, DWORD PTR _campID$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _campID$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1092]
	call	?SetWPGroup@C_Waypoint@@QAEXJJ@Z	; C_Waypoint::SetWPGroup

; 1018 : 				CurWP_->SetState(campID+i,0);

	push	0
	mov	eax, DWORD PTR _campID$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1092]
	call	?SetState@C_Waypoint@@QAEXJF@Z		; C_Waypoint::SetState

; 1019 : 				wpl->Flags &= ~C_BIT_ENABLED;

	mov	edx, DWORD PTR _wpl$[ebp]
	mov	eax, DWORD PTR [edx+8]
	and	eax, -2049				; fffff7ffH
	mov	ecx, DWORD PTR _wpl$[ebp]
	mov	DWORD PTR [ecx+8], eax
$LN47@BuildCurre:

; 1020 : 			}
; 1021 : 		}
; 1022 : 
; 1023 : 		target=wp->GetWPTarget();

	mov	ecx, DWORD PTR _wp$[ebp]
	call	?GetWPTarget@WayPointClass@@QAEPAVCampBaseClass@@XZ ; WayPointClass::GetWPTarget
	mov	DWORD PTR _target$[ebp], eax

; 1024 : 		if(target)

	cmp	DWORD PTR _target$[ebp], 0
	je	SHORT $LN45@BuildCurre

; 1025 : 		{ // use GPS to make visible
; 1026 : 			gpsItem=(UI_Refresher*)gGps->Find(target->GetCampID());

	mov	edx, DWORD PTR _target$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _target$[ebp]
	mov	edx, DWORD PTR [eax+112]
	call	edx
	cwde
	push	eax
	mov	ecx, DWORD PTR ?gGps@@3PAVGlobalPositioningSystem@@A ; gGps
	call	?Find@GlobalPositioningSystem@@QAEPAXJ@Z ; GlobalPositioningSystem::Find
	mov	DWORD PTR _gpsItem$[ebp], eax

; 1027 : 			if(gpsItem && gpsItem->MapItem_)

	cmp	DWORD PTR _gpsItem$[ebp], 0
	je	SHORT $LN45@BuildCurre
	mov	ecx, DWORD PTR _gpsItem$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	je	SHORT $LN45@BuildCurre

; 1028 : 				CurIcons_->Add(gpsItem->MapItem_);

	mov	edx, DWORD PTR _gpsItem$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1116]
	call	?Add@C_DrawList@@QAEXPAVMAPICONLIST@@@Z	; C_DrawList::Add
$LN45@BuildCurre:

; 1029 : 		}
; 1030 : 		i++;

	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx

; 1031 : 		wp=wp->GetNextWP();

	mov	ecx, DWORD PTR _wp$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _wp$[ebp], eax

; 1032 : 	}

	jmp	$LN62@BuildCurre
$LN61@BuildCurre:

; 1033 : 
; 1034 : 	distance=0.0f;

	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR _distance$[ebp], xmm0

; 1035 : 	wp=firstwp;

	mov	eax, DWORD PTR _firstwp$[ebp]
	mov	DWORD PTR _wp$[ebp], eax

; 1036 : 	wp->GetLocation(&lx,&ly,&lz);

	lea	ecx, DWORD PTR _lz$[ebp]
	push	ecx
	lea	edx, DWORD PTR _ly$[ebp]
	push	edx
	lea	eax, DWORD PTR _lx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _wp$[ebp]
	call	?GetLocation@WayPointClass@@QBEXPAM00@Z	; WayPointClass::GetLocation

; 1037 : 	i=1;

	mov	DWORD PTR _i$[ebp], 1

; 1038 : 	lastwp=0;

	xor	ecx, ecx
	mov	WORD PTR _lastwp$[ebp], cx
$LN44@BuildCurre:

; 1039 : 	while(wp)

	cmp	DWORD PTR _wp$[ebp], 0
	je	$LN43@BuildCurre

; 1040 : 	{
; 1041 : 		if(!wp->GetNextWP())

	mov	ecx, DWORD PTR _wp$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	test	eax, eax
	jne	SHORT $LN42@BuildCurre

; 1042 : 			lastwp=1;

	mov	edx, 1
	mov	WORD PTR _lastwp$[ebp], dx
$LN42@BuildCurre:

; 1043 : 
; 1044 : 		if(wp->GetWPFlags() & WPF_TARGET)

	mov	ecx, DWORD PTR _wp$[ebp]
	call	?GetWPFlags@WayPointClass@@QAEKXZ	; WayPointClass::GetWPFlags
	and	eax, 1
	je	SHORT $LN41@BuildCurre

; 1045 : 		{
; 1046 : 			normID=TGT_CUR;

	mov	DWORD PTR _normID$[ebp], 10501		; 00002905H

; 1047 : 			selID=TGT_CUR_SEL;

	mov	DWORD PTR _selID$[ebp], 10502		; 00002906H

; 1048 : 			othrID=TGT_CUR_ERROR;

	mov	DWORD PTR _othrID$[ebp], 10503		; 00002907H
	jmp	SHORT $LN38@BuildCurre
$LN41@BuildCurre:

; 1049 : 		}
; 1050 : 		else if(wp->GetWPFlags() & WPF_IP)

	mov	ecx, DWORD PTR _wp$[ebp]
	call	?GetWPFlags@WayPointClass@@QAEKXZ	; WayPointClass::GetWPFlags
	and	eax, 8
	je	SHORT $LN39@BuildCurre

; 1051 : 		{
; 1052 : 			normID=IP_CUR;

	mov	DWORD PTR _normID$[ebp], 10504		; 00002908H

; 1053 : 			selID=IP_CUR_SEL;

	mov	DWORD PTR _selID$[ebp], 10505		; 00002909H

; 1054 : 			othrID=IP_CUR_ERROR;

	mov	DWORD PTR _othrID$[ebp], 10506		; 0000290aH

; 1055 : 		}
; 1056 : 		else

	jmp	SHORT $LN38@BuildCurre
$LN39@BuildCurre:

; 1057 : 		{
; 1058 : 			normID=STPT_CUR;

	mov	DWORD PTR _normID$[ebp], 10507		; 0000290bH

; 1059 : 			selID=STPT_CUR_SEL;

	mov	DWORD PTR _selID$[ebp], 10508		; 0000290cH

; 1060 : 			othrID=STPT_CUR_ERROR;

	mov	DWORD PTR _othrID$[ebp], 10509		; 0000290dH
$LN38@BuildCurre:

; 1061 : 		}
; 1062 : 		if (unit->IsFlight() && !IsValidWP(wp,(Flight)unit))

	mov	eax, DWORD PTR _unit$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _unit$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax
	test	eax, eax
	je	SHORT $LN37@BuildCurre
	mov	ecx, DWORD PTR _unit$[ebp]
	push	ecx
	mov	edx, DWORD PTR _wp$[ebp]
	push	edx
	call	?IsValidWP@@YAHPAVWayPointClass@@PAVFlightClass@@@Z ; IsValidWP
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN37@BuildCurre

; 1063 : 			state=2;

	mov	eax, 2
	mov	WORD PTR _state$[ebp], ax
	jmp	SHORT $LN34@BuildCurre
$LN37@BuildCurre:

; 1064 : 		else if (wp == unit->GetCurrentUnitWP())

	mov	ecx, DWORD PTR _unit$[ebp]
	call	?GetCurrentUnitWP@UnitClass@@QBEPAVWayPointClass@@XZ ; UnitClass::GetCurrentUnitWP
	cmp	DWORD PTR _wp$[ebp], eax
	jne	SHORT $LN35@BuildCurre

; 1065 : 			state=1;

	mov	ecx, 1
	mov	WORD PTR _state$[ebp], cx

; 1066 : 		else

	jmp	SHORT $LN34@BuildCurre
$LN35@BuildCurre:

; 1067 : 			state=0;

	xor	edx, edx
	mov	WORD PTR _state$[ebp], dx
$LN34@BuildCurre:

; 1068 : 
; 1069 : 		wp->GetLocation(&x,&y,&z); // Note: for Sim -> UI (UI's) X = (Sim's) Y, (UI's Y) = (Sim's) [max y] - X (UI's) Z = (Sim's) -Z

	lea	eax, DWORD PTR _z$[ebp]
	push	eax
	lea	ecx, DWORD PTR _y$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	ecx, DWORD PTR _wp$[ebp]
	call	?GetLocation@WayPointClass@@QBEXPAM00@Z	; WayPointClass::GetLocation

; 1070 : 
; 1071 : 		// Add Nub to insert a waypoint
; 1072 : 		if(UseFlag && prevwp && airwps)

	cmp	DWORD PTR _UseFlag$[ebp], 0
	je	$LN32@BuildCurre
	cmp	DWORD PTR _prevwp$[ebp], 0
	je	$LN32@BuildCurre
	movsx	eax, WORD PTR _airwps$[ebp]
	test	eax, eax
	je	$LN32@BuildCurre

; 1073 : 		{
; 1074 : 			prevwp->GetLocation(&tempx,&tempy,&tempz); // Note: for Sim -> UI (UI's) X = (Sim's) Y, (UI's Y) = (Sim's) [max y] - X (UI's) Z = (Sim's) -Z

	lea	ecx, DWORD PTR _tempz$[ebp]
	push	ecx
	lea	edx, DWORD PTR _tempy$[ebp]
	push	edx
	lea	eax, DWORD PTR _tempx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _prevwp$[ebp]
	call	?GetLocation@WayPointClass@@QBEXPAM00@Z	; WayPointClass::GetLocation

; 1075 : 			dx=x-tempx;

	movss	xmm0, DWORD PTR _x$[ebp]
	subss	xmm0, DWORD PTR _tempx$[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0

; 1076 : 			dy=y-tempy;

	movss	xmm0, DWORD PTR _y$[ebp]
	subss	xmm0, DWORD PTR _tempy$[ebp]
	movss	DWORD PTR _dy$[ebp], xmm0

; 1077 : 			_stprintf(buf,"%1.1f",sqrt(dx*dx + dy*dy) * FT_TO_NM);

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR tv1452[ebp]
	movss	xmm0, DWORD PTR tv1452[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_05NDPOMAGE@?$CF1?41f?$AA@
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 1078 : 			Uni_Float(buf);

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	?Uni_Float@@YAXPAD@Z			; Uni_Float
	add	esp, 4

; 1079 : 			dx*=.5;

	cvtss2sd xmm0, DWORD PTR _dx$[ebp]
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _dx$[ebp], xmm0

; 1080 : 			dy*=.5;

	cvtss2sd xmm0, DWORD PTR _dy$[ebp]
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _dy$[ebp], xmm0

; 1081 : 			wpl=CurWP_->AddWaypointToList(0x40000000+campID+i,0,ADDLINE_CUR,ADDLINE_CUR_SEL,ADDLINE_CUR,tempy+dy,maxy-(tempx+dx),TRUE);

	push	1
	movss	xmm0, DWORD PTR _tempx$[ebp]
	addss	xmm0, DWORD PTR _dx$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+732]
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	movss	xmm0, DWORD PTR _tempy$[ebp]
	addss	xmm0, DWORD PTR _dy$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	10521					; 00002919H
	push	10522					; 0000291aH
	push	10521					; 00002919H
	push	0
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _campID$[ebp]
	lea	eax, DWORD PTR [edx+ecx+1073741824]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1092]
	call	?AddWaypointToList@C_Waypoint@@QAEPAVWAYPOINTLIST@@JFJJJMMF@Z ; C_Waypoint::AddWaypointToList
	mov	DWORD PTR _wpl$[ebp], eax

; 1082 : 			if(wpl)

	cmp	DWORD PTR _wpl$[ebp], 0
	je	$LN32@BuildCurre

; 1083 : 			{
; 1084 : 				CurWP_->SetWPGroup(0x40000000+campID+i,campID);

	mov	edx, DWORD PTR _campID$[ebp]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _campID$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1073741824]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1092]
	call	?SetWPGroup@C_Waypoint@@QAEXJJ@Z	; C_Waypoint::SetWPGroup

; 1085 : 				CurWP_->SetUserNumber(C_STATE_0, static_cast<long>(maxy));

	mov	ecx, DWORD PTR _this$[ebp]
	cvttss2si edx, DWORD PTR [ecx+732]
	push	edx
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1092]
	call	?SetUserNumber@C_Base@@QAEXJJ@Z		; C_Base::SetUserNumber

; 1086 : 				CurWP_->SetLabel(0x40000000+campID+i,gStringMgr->GetText(gStringMgr->AddText(buf)));

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?gStringMgr@@3PAVC_String@@A ; gStringMgr
	call	?AddText@C_String@@QAEJPBD@Z		; C_String::AddText
	push	eax
	mov	ecx, DWORD PTR ?gStringMgr@@3PAVC_String@@A ; gStringMgr
	call	?GetText@C_String@@QAEPADJ@Z		; C_String::GetText
	push	eax
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _campID$[ebp]
	lea	ecx, DWORD PTR [eax+edx+1073741824]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1092]
	call	?SetLabel@C_Waypoint@@QAEXJPAD@Z	; C_Waypoint::SetLabel

; 1087 : 				CurWP_->SetTextOffset(0x40000000+campID+i,0,-15);

	push	-15					; fffffff1H
	push	0
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _campID$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1073741824]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1092]
	call	?SetTextOffset@C_Waypoint@@QAEXJFF@Z	; C_Waypoint::SetTextOffset

; 1088 : 				CurWP_->SetState(0x40000000+campID+i,state);

	movzx	ecx, WORD PTR _state$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _campID$[ebp]
	lea	ecx, DWORD PTR [eax+edx+1073741824]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1092]
	call	?SetState@C_Waypoint@@QAEXJF@Z		; C_Waypoint::SetState

; 1089 : 				CurWP_->SetLabelColor(0x40000000+campID+i,0x00ffffff,0x0000ffff,0x000000ff);

	push	255					; 000000ffH
	push	65535					; 0000ffffH
	push	16777215				; 00ffffffH
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _campID$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1073741824]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1092]
	call	?SetLabelColor@C_Waypoint@@QAEXJKKK@Z	; C_Waypoint::SetLabelColor

; 1090 : 				CurWP_->SetLineColor(0x40000000+campID+i,0x00ffffff,0x0000ffff,0x000000ff);

	push	255					; 000000ffH
	push	65535					; 0000ffffH
	push	16777215				; 00ffffffH
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _campID$[ebp]
	lea	eax, DWORD PTR [edx+ecx+1073741824]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1092]
	call	?SetLineColor@C_Waypoint@@QAEXJKKK@Z	; C_Waypoint::SetLineColor

; 1091 : 				if(!(TheCampaign.Flags & CAMP_TACTICAL_EDIT))

	mov	edx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A+64
	and	edx, 524288				; 00080000H
	jne	SHORT $LN30@BuildCurre

; 1092 : 				{
; 1093 : 					if(firstwp != unit->GetCurrentUnitWP())

	mov	ecx, DWORD PTR _unit$[ebp]
	call	?GetCurrentUnitWP@UnitClass@@QBEPAVWayPointClass@@XZ ; UnitClass::GetCurrentUnitWP
	cmp	DWORD PTR _firstwp$[ebp], eax
	je	SHORT $LN30@BuildCurre

; 1094 : 					{
; 1095 : 						wpl->Icon->SetText(0,TXT_SPACE);

	push	153					; 00000099H
	push	0
	mov	eax, DWORD PTR _wpl$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	call	?SetText@C_Button@@QAEXFJ@Z		; C_Button::SetText

; 1096 : 						wpl->Icon->SetText(1,TXT_SPACE);

	push	153					; 00000099H
	push	1
	mov	ecx, DWORD PTR _wpl$[ebp]
	mov	ecx, DWORD PTR [ecx+32]
	call	?SetText@C_Button@@QAEXFJ@Z		; C_Button::SetText

; 1097 : 						wpl->Icon->SetText(2,TXT_SPACE);

	push	153					; 00000099H
	push	2
	mov	edx, DWORD PTR _wpl$[ebp]
	mov	ecx, DWORD PTR [edx+32]
	call	?SetText@C_Button@@QAEXFJ@Z		; C_Button::SetText

; 1098 : 						wpl->Icon->SetFlagBitOff(C_BIT_ENABLED);

	push	2048					; 00000800H
	mov	eax, DWORD PTR _wpl$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _wpl$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+32]
	mov	edx, DWORD PTR [eax+12]
	call	edx
$LN30@BuildCurre:

; 1099 : 					}
; 1100 : 				}
; 1101 : 				wpl->Flags |= UseFlag;

	mov	eax, DWORD PTR _wpl$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, DWORD PTR _UseFlag$[ebp]
	mov	edx, DWORD PTR _wpl$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN32@BuildCurre:

; 1102 : 			}
; 1103 : 		}
; 1104 : 	// Set 2d Waypoint
; 1105 : 		if(UseFlag)

	cmp	DWORD PTR _UseFlag$[ebp], 0
	je	SHORT $LN29@BuildCurre

; 1106 : 			_stprintf(buf,"%1d",i);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	push	OFFSET ??_C@_03GNGPFOOL@?$CF1d?$AA@
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1107 : 		else

	jmp	$LN24@BuildCurre
$LN29@BuildCurre:

; 1108 : 		{
; 1109 : 			if(wp->GetWPAction() == WP_LAND)

	mov	ecx, DWORD PTR _wp$[ebp]
	call	?GetWPAction@WayPointClass@@QAEHXZ	; WayPointClass::GetWPAction
	cmp	eax, 7
	jne	SHORT $LN27@BuildCurre

; 1110 : 			{
; 1111 : 				_sntprintf(buf,39,"%s",gStringMgr->GetString(TXT_ALTERNATE_FIELD));

	push	200					; 000000c8H
	mov	ecx, DWORD PTR ?gStringMgr@@3PAVC_String@@A ; gStringMgr
	call	?GetString@C_String@@QAEPADJ@Z		; C_String::GetString
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
	push	39					; 00000027H
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	__snprintf
	add	esp, 16					; 00000010H

; 1112 : 				buf[39] = 0;

	mov	eax, 1
	imul	eax, 39					; 00000027H
	mov	DWORD PTR $T10[ebp], eax
	cmp	DWORD PTR $T10[ebp], 40			; 00000028H
	jae	SHORT $LN83@BuildCurre
	jmp	SHORT $LN84@BuildCurre
$LN83@BuildCurre:
	call	___report_rangecheckfailure
$LN84@BuildCurre:
	mov	ecx, DWORD PTR $T10[ebp]
	mov	BYTE PTR _buf$[ebp+ecx], 0
	jmp	$LN24@BuildCurre
$LN27@BuildCurre:

; 1113 : 			}
; 1114 : 			else if(wp->GetWPAction() == WP_REFUEL)

	mov	ecx, DWORD PTR _wp$[ebp]
	call	?GetWPAction@WayPointClass@@QAEHXZ	; WayPointClass::GetWPAction
	cmp	eax, 4
	jne	SHORT $LN25@BuildCurre

; 1115 : 			{
; 1116 : 				_sntprintf(buf,39,"%s",gStringMgr->GetString(TXT_TANKER));

	push	202					; 000000caH
	mov	ecx, DWORD PTR ?gStringMgr@@3PAVC_String@@A ; gStringMgr
	call	?GetString@C_String@@QAEPADJ@Z		; C_String::GetString
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
	push	39					; 00000027H
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	__snprintf
	add	esp, 16					; 00000010H

; 1117 : 				buf[39] = 0;

	mov	eax, 1
	imul	eax, 39					; 00000027H
	mov	DWORD PTR $T15[ebp], eax
	cmp	DWORD PTR $T15[ebp], 40			; 00000028H
	jae	SHORT $LN85@BuildCurre
	jmp	SHORT $LN86@BuildCurre
$LN85@BuildCurre:
	call	___report_rangecheckfailure
$LN86@BuildCurre:
	mov	ecx, DWORD PTR $T15[ebp]
	mov	BYTE PTR _buf$[ebp+ecx], 0

; 1118 : 			}
; 1119 : 			else

	jmp	SHORT $LN24@BuildCurre
$LN25@BuildCurre:

; 1120 : 				buf[0]=0;

	mov	edx, 1
	imul	edx, 0
	mov	DWORD PTR $T17[ebp], edx
	cmp	DWORD PTR $T17[ebp], 40			; 00000028H
	jae	SHORT $LN87@BuildCurre
	jmp	SHORT $LN88@BuildCurre
$LN87@BuildCurre:
	call	___report_rangecheckfailure
$LN88@BuildCurre:
	mov	eax, DWORD PTR $T17[ebp]
	mov	BYTE PTR _buf$[ebp+eax], 0
$LN24@BuildCurre:

; 1121 : 		}
; 1122 : 		if(buf[0])

	mov	ecx, 1
	imul	ecx, 0
	movsx	edx, BYTE PTR _buf$[ebp+ecx]
	test	edx, edx
	je	$LN7@BuildCurre

; 1123 : 		{
; 1124 : 			if(airwps)

	movsx	eax, WORD PTR _airwps$[ebp]
	test	eax, eax
	je	$LN22@BuildCurre

; 1125 : 			{
; 1126 : 				if(i == 1)

	cmp	DWORD PTR _i$[ebp], 1
	jne	SHORT $LN21@BuildCurre

; 1127 : 					wpl=CurWP_->AddWaypointToList(campID+i,0,normID,selID,othrID,y,maxy-x,FALSE);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+732]
	subss	xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _othrID$[ebp]
	push	edx
	mov	eax, DWORD PTR _selID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _normID$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _campID$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1092]
	call	?AddWaypointToList@C_Waypoint@@QAEPAVWAYPOINTLIST@@JFJJJMMF@Z ; C_Waypoint::AddWaypointToList
	mov	DWORD PTR _wpl$[ebp], eax

; 1128 : 				else

	jmp	SHORT $LN20@BuildCurre
$LN21@BuildCurre:

; 1129 : 					wpl=CurWP_->AddWaypointToList(campID+i,0,normID,selID,othrID,y,maxy-x,TRUE);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+732]
	subss	xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _othrID$[ebp]
	push	edx
	mov	eax, DWORD PTR _selID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _normID$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _campID$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1092]
	call	?AddWaypointToList@C_Waypoint@@QAEPAVWAYPOINTLIST@@JFJJJMMF@Z ; C_Waypoint::AddWaypointToList
	mov	DWORD PTR _wpl$[ebp], eax
$LN20@BuildCurre:

; 1130 : 			}
; 1131 : 			else

	jmp	$LN17@BuildCurre
$LN22@BuildCurre:

; 1132 : 			{
; 1133 : 				if(lastwp)

	movsx	ecx, WORD PTR _lastwp$[ebp]
	test	ecx, ecx
	je	SHORT $LN18@BuildCurre

; 1134 : 					wpl=CurWP_->AddWaypointToList(campID+i,0,normID,selID,othrID,y,maxy-x,TRUE);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+732]
	subss	xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _othrID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _selID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _normID$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _campID$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1092]
	call	?AddWaypointToList@C_Waypoint@@QAEPAVWAYPOINTLIST@@JFJJJMMF@Z ; C_Waypoint::AddWaypointToList
	mov	DWORD PTR _wpl$[ebp], eax

; 1135 : 				else

	jmp	SHORT $LN17@BuildCurre
$LN18@BuildCurre:

; 1136 : 					wpl=CurWP_->AddWaypointToList(campID+i,0,0,0,0,y,maxy-x,FALSE);

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+732]
	subss	xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	0
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _campID$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1092]
	call	?AddWaypointToList@C_Waypoint@@QAEPAVWAYPOINTLIST@@JFJJJMMF@Z ; C_Waypoint::AddWaypointToList
	mov	DWORD PTR _wpl$[ebp], eax
$LN17@BuildCurre:

; 1137 : 			}
; 1138 : 			if(wpl)

	cmp	DWORD PTR _wpl$[ebp], 0
	je	$LN16@BuildCurre

; 1139 : 			{
; 1140 : 				CurWP_->SetWPGroup(campID+i,campID);

	mov	edx, DWORD PTR _campID$[ebp]
	push	edx
	mov	eax, DWORD PTR _campID$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1092]
	call	?SetWPGroup@C_Waypoint@@QAEXJJ@Z	; C_Waypoint::SetWPGroup

; 1141 : 				CurWP_->SetUserNumber(C_STATE_0, static_cast<long>(maxy));

	mov	edx, DWORD PTR _this$[ebp]
	cvttss2si eax, DWORD PTR [edx+732]
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1092]
	call	?SetUserNumber@C_Base@@QAEXJJ@Z		; C_Base::SetUserNumber

; 1142 : 				if(airwps)

	movsx	edx, WORD PTR _airwps$[ebp]
	test	edx, edx
	je	SHORT $LN15@BuildCurre

; 1143 : 				{
; 1144 : 					CurWP_->SetLabel(campID+i,gStringMgr->GetText(gStringMgr->AddText(buf)));

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?gStringMgr@@3PAVC_String@@A ; gStringMgr
	call	?AddText@C_String@@QAEJPBD@Z		; C_String::AddText
	push	eax
	mov	ecx, DWORD PTR ?gStringMgr@@3PAVC_String@@A ; gStringMgr
	call	?GetText@C_String@@QAEPADJ@Z		; C_String::GetText
	push	eax
	mov	ecx, DWORD PTR _campID$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1092]
	call	?SetLabel@C_Waypoint@@QAEXJPAD@Z	; C_Waypoint::SetLabel

; 1145 : 					CurWP_->SetTextOffset(campID+i,0,-15);

	push	-15					; fffffff1H
	push	0
	mov	eax, DWORD PTR _campID$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1092]
	call	?SetTextOffset@C_Waypoint@@QAEXJFF@Z	; C_Waypoint::SetTextOffset
$LN15@BuildCurre:

; 1146 : 				}
; 1147 : 				CurWP_->SetState(campID+i,state);

	movzx	edx, WORD PTR _state$[ebp]
	push	edx
	mov	eax, DWORD PTR _campID$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1092]
	call	?SetState@C_Waypoint@@QAEXJF@Z		; C_Waypoint::SetState

; 1148 : 				CurWP_->SetLabelColor(campID+i,0x00ffffff,0x0000ffff,0x000000ff);

	push	255					; 000000ffH
	push	65535					; 0000ffffH
	push	16777215				; 00ffffffH
	mov	edx, DWORD PTR _campID$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1092]
	call	?SetLabelColor@C_Waypoint@@QAEXJKKK@Z	; C_Waypoint::SetLabelColor

; 1149 : 				CurWP_->SetLineColor(campID+i,0x00ffffff,0x0000ffff,0x000000ff);

	push	255					; 000000ffH
	push	65535					; 0000ffffH
	push	16777215				; 00ffffffH
	mov	ecx, DWORD PTR _campID$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1092]
	call	?SetLineColor@C_Waypoint@@QAEXJKKK@Z	; C_Waypoint::SetLineColor

; 1150 : 				tmpID=new VU_ID;

	push	8
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T14[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T14[ebp], 0
	je	SHORT $LN89@BuildCurre
	mov	ecx, DWORD PTR $T14[ebp]
	call	??0VU_ID@@QAE@XZ			; VU_ID::VU_ID
	mov	DWORD PTR tv815[ebp], eax
	jmp	SHORT $LN90@BuildCurre
$LN89@BuildCurre:
	mov	DWORD PTR tv815[ebp], 0
$LN90@BuildCurre:
	mov	eax, DWORD PTR tv815[ebp]
	mov	DWORD PTR $T8[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T8[ebp]
	mov	DWORD PTR _tmpID$[ebp], ecx

; 1151 : 				*tmpID=unit->Id();

	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _unit$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _tmpID$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx

; 1152 : 				wpl->Flags |= UseFlag;

	mov	ecx, DWORD PTR _wpl$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	or	edx, DWORD PTR _UseFlag$[ebp]
	mov	eax, DWORD PTR _wpl$[ebp]
	mov	DWORD PTR [eax+8], edx

; 1153 : 				wpl->Icon->SetUserCleanupPtr(C_STATE_0,tmpID);

	mov	ecx, DWORD PTR _tmpID$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _wpl$[ebp]
	mov	ecx, DWORD PTR [edx+32]
	call	?SetUserCleanupPtr@C_Base@@QAEXJPAX@Z	; C_Base::SetUserCleanupPtr

; 1154 : 				wpl->Icon->SetUserNumber(C_STATE_1,i);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _wpl$[ebp]
	mov	ecx, DWORD PTR [ecx+32]
	call	?SetUserNumber@C_Base@@QAEXJJ@Z		; C_Base::SetUserNumber
$LN16@BuildCurre:

; 1155 : 			}
; 1156 : 	
; 1157 : 			// Set Z Waypoint
; 1158 : 			xval=(i-1)*(650 / numwp) + 60;

	mov	ecx, DWORD PTR _i$[ebp]
	sub	ecx, 1
	mov	eax, 650				; 0000028aH
	cdq
	idiv	DWORD PTR _numwp$[ebp]
	imul	ecx, eax
	add	ecx, 60					; 0000003cH
	mov	DWORD PTR _xval$[ebp], ecx

; 1159 : 
; 1160 : 			if (airwps)

	movsx	edx, WORD PTR _airwps$[ebp]
	test	edx, edx
	je	$LN8@BuildCurre

; 1161 : 			{
; 1162 : 				if(wp->GetWPAction() == WP_LAND || wp->GetWPAction() == WP_TAKEOFF)

	mov	ecx, DWORD PTR _wp$[ebp]
	call	?GetWPAction@WayPointClass@@QAEHXZ	; WayPointClass::GetWPAction
	cmp	eax, 7
	je	SHORT $LN12@BuildCurre
	mov	ecx, DWORD PTR _wp$[ebp]
	call	?GetWPAction@WayPointClass@@QAEHXZ	; WayPointClass::GetWPAction
	cmp	eax, 1
	jne	SHORT $LN13@BuildCurre
$LN12@BuildCurre:

; 1163 : 					ZDrag=FALSE;

	mov	DWORD PTR _ZDrag$[ebp], 0

; 1164 : 				else

	jmp	SHORT $LN11@BuildCurre
$LN13@BuildCurre:

; 1165 : 					ZDrag=TRUE;

	mov	DWORD PTR _ZDrag$[ebp], 1
$LN11@BuildCurre:

; 1166 : 				wpl=CurWPZ_->AddWaypointToList(static_cast<short>(campID+i),0,normID,selID,othrID,static_cast<float>(xval),z,static_cast<short>(ZDrag));

	movzx	eax, WORD PTR _ZDrag$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _z$[ebp]
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _xval$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _othrID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _selID$[ebp]
	push	edx
	mov	eax, DWORD PTR _normID$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _campID$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	movsx	edx, cx
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1096]
	call	?AddWaypointToList@C_Waypoint@@QAEPAVWAYPOINTLIST@@JFJJJMMF@Z ; C_Waypoint::AddWaypointToList
	mov	DWORD PTR _wpl$[ebp], eax

; 1167 : 				if(wpl)

	cmp	DWORD PTR _wpl$[ebp], 0
	je	$LN8@BuildCurre

; 1168 : 				{
; 1169 : 					CurWPZ_->SetWPGroup(campID+i,campID);

	mov	ecx, DWORD PTR _campID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _campID$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1096]
	call	?SetWPGroup@C_Waypoint@@QAEXJJ@Z	; C_Waypoint::SetWPGroup

; 1170 : 					CurWPZ_->SetLabel(campID+i,gStringMgr->GetText(gStringMgr->AddText(buf)));

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?gStringMgr@@3PAVC_String@@A ; gStringMgr
	call	?AddText@C_String@@QAEJPBD@Z		; C_String::AddText
	push	eax
	mov	ecx, DWORD PTR ?gStringMgr@@3PAVC_String@@A ; gStringMgr
	call	?GetText@C_String@@QAEPADJ@Z		; C_String::GetText
	push	eax
	mov	edx, DWORD PTR _campID$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1096]
	call	?SetLabel@C_Waypoint@@QAEXJPAD@Z	; C_Waypoint::SetLabel

; 1171 : 					CurWPZ_->SetState(campID+i,state);

	movzx	ecx, WORD PTR _state$[ebp]
	push	ecx
	mov	edx, DWORD PTR _campID$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1096]
	call	?SetState@C_Waypoint@@QAEXJF@Z		; C_Waypoint::SetState

; 1172 : 					CurWPZ_->SetLabelColor(campID+i,0x00ffffff,0x0000ffff,0x000000ff);

	push	255					; 000000ffH
	push	65535					; 0000ffffH
	push	16777215				; 00ffffffH
	mov	ecx, DWORD PTR _campID$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1096]
	call	?SetLabelColor@C_Waypoint@@QAEXJKKK@Z	; C_Waypoint::SetLabelColor

; 1173 : 					CurWPZ_->SetLineColor(campID+i,0x00ffffff,0x0000ffff,0x000000ff);

	push	255					; 000000ffH
	push	65535					; 0000ffffH
	push	16777215				; 00ffffffH
	mov	eax, DWORD PTR _campID$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1096]
	call	?SetLineColor@C_Waypoint@@QAEXJKKK@Z	; C_Waypoint::SetLineColor

; 1174 : 					CurWPZ_->SetTextOffset(campID+i,0,-15);

	push	-15					; fffffff1H
	push	0
	mov	edx, DWORD PTR _campID$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1096]
	call	?SetTextOffset@C_Waypoint@@QAEXJFF@Z	; C_Waypoint::SetTextOffset

; 1175 : 
; 1176 : 					tmpID=new VU_ID;

	push	8
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T12[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T12[ebp], 0
	je	SHORT $LN91@BuildCurre
	mov	ecx, DWORD PTR $T12[ebp]
	call	??0VU_ID@@QAE@XZ			; VU_ID::VU_ID
	mov	DWORD PTR tv918[ebp], eax
	jmp	SHORT $LN92@BuildCurre
$LN91@BuildCurre:
	mov	DWORD PTR tv918[ebp], 0
$LN92@BuildCurre:
	mov	ecx, DWORD PTR tv918[ebp]
	mov	DWORD PTR $T6[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T6[ebp]
	mov	DWORD PTR _tmpID$[ebp], edx

; 1177 : 					*tmpID=unit->Id();

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _unit$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _tmpID$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx

; 1178 : 					wpl->Flags |= UseFlag;

	mov	ecx, DWORD PTR _wpl$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	or	edx, DWORD PTR _UseFlag$[ebp]
	mov	eax, DWORD PTR _wpl$[ebp]
	mov	DWORD PTR [eax+8], edx

; 1179 : 					wpl->Icon->SetUserCleanupPtr(C_STATE_0,tmpID);

	mov	ecx, DWORD PTR _tmpID$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _wpl$[ebp]
	mov	ecx, DWORD PTR [edx+32]
	call	?SetUserCleanupPtr@C_Base@@QAEXJPAX@Z	; C_Base::SetUserCleanupPtr

; 1180 : 					wpl->Icon->SetUserNumber(C_STATE_1,i);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _wpl$[ebp]
	mov	ecx, DWORD PTR [ecx+32]
	call	?SetUserNumber@C_Base@@QAEXJJ@Z		; C_Base::SetUserNumber

; 1181 : 					if(!(TheCampaign.Flags & CAMP_TACTICAL_EDIT))

	mov	edx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A+64
	and	edx, 524288				; 00080000H
	jne	SHORT $LN8@BuildCurre

; 1182 : 						if(firstwp != unit->GetCurrentUnitWP())

	mov	ecx, DWORD PTR _unit$[ebp]
	call	?GetCurrentUnitWP@UnitClass@@QBEPAVWayPointClass@@XZ ; UnitClass::GetCurrentUnitWP
	cmp	DWORD PTR _firstwp$[ebp], eax
	je	SHORT $LN8@BuildCurre

; 1183 : 							wpl->Dragable=0;

	xor	eax, eax
	mov	ecx, DWORD PTR _wpl$[ebp]
	mov	WORD PTR [ecx+36], ax
$LN8@BuildCurre:

; 1184 : 				}
; 1185 : 			}
; 1186 : 
; 1187 : 			dx=lx-x;

	movss	xmm0, DWORD PTR _lx$[ebp]
	subss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0

; 1188 : 			dy=ly-y;

	movss	xmm0, DWORD PTR _ly$[ebp]
	subss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR _dy$[ebp], xmm0

; 1189 : 			dz=lz-z;

	movss	xmm0, DWORD PTR _lz$[ebp]
	subss	xmm0, DWORD PTR _z$[ebp]
	movss	DWORD PTR _dz$[ebp], xmm0

; 1190 : 
; 1191 : 			lx=x;

	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR _lx$[ebp], xmm0

; 1192 : 			ly=y;

	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR _ly$[ebp], xmm0

; 1193 : 			lz=z;

	movss	xmm0, DWORD PTR _z$[ebp]
	movss	DWORD PTR _lz$[ebp], xmm0

; 1194 : 
; 1195 : 			i++;

	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx

; 1196 : 			distance += sqrt(dx*dx + dy*dy + dz*dz);

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR _dz$[ebp]
	mulss	xmm1, DWORD PTR _dz$[ebp]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR tv1668[ebp]
	movss	xmm0, DWORD PTR tv1668[ebp]
	cvtss2sd xmm0, xmm0
	addsd	xmm0, QWORD PTR _distance$[ebp]
	movsd	QWORD PTR _distance$[ebp], xmm0

; 1197 : 
; 1198 : 			if(wp->GetWPAction() == WP_LAND && UseFlag)

	mov	ecx, DWORD PTR _wp$[ebp]
	call	?GetWPAction@WayPointClass@@QAEHXZ	; WayPointClass::GetWPAction
	cmp	eax, 7
	jne	SHORT $LN7@BuildCurre
	cmp	DWORD PTR _UseFlag$[ebp], 0
	je	SHORT $LN7@BuildCurre

; 1199 : 			{
; 1200 : 				endtime=wp->GetWPArrivalTime();

	mov	ecx, DWORD PTR _wp$[ebp]
	call	?GetWPArrivalTime@WayPointClass@@QAEKXZ	; WayPointClass::GetWPArrivalTime
	mov	DWORD PTR _endtime$[ebp], eax

; 1201 : 				UseFlag=0;

	mov	DWORD PTR _UseFlag$[ebp], 0
$LN7@BuildCurre:

; 1202 : 			}
; 1203 : 		}
; 1204 : 		prevwp=wp;

	mov	eax, DWORD PTR _wp$[ebp]
	mov	DWORD PTR _prevwp$[ebp], eax

; 1205 : 		wp=wp->GetNextWP();

	mov	ecx, DWORD PTR _wp$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _wp$[ebp], eax

; 1206 : 	}

	jmp	$LN44@BuildCurre
$LN43@BuildCurre:

; 1207 : 
; 1208 : 	if(airwps)

	movsx	ecx, WORD PTR _airwps$[ebp]
	test	ecx, ecx
	je	$LN1@BuildCurre

; 1209 : 	{
; 1210 : 		wp=((Flight)unit)->GetOverrideWP();

	mov	ecx, DWORD PTR _unit$[ebp]
	call	?GetOverrideWP@FlightClass@@QAEPAVWayPointClass@@XZ ; FlightClass::GetOverrideWP
	mov	DWORD PTR _wp$[ebp], eax

; 1211 : 		if(wp)

	cmp	DWORD PTR _wp$[ebp], 0
	je	$LN1@BuildCurre

; 1212 : 		{
; 1213 : 			wp->GetLocation(&x,&y,&z); // Note: for Sim -> UI (UI's) X = (Sim's) Y, (UI's Y) = (Sim's) [max y] - X (UI's) Z = (Sim's) -Z

	lea	edx, DWORD PTR _z$[ebp]
	push	edx
	lea	eax, DWORD PTR _y$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _wp$[ebp]
	call	?GetLocation@WayPointClass@@QBEXPAM00@Z	; WayPointClass::GetLocation

; 1214 : 
; 1215 : 			_sntprintf(buf,39,"%s",gStringMgr->GetString(TXT_DIVERT));

	push	203					; 000000cbH
	mov	ecx, DWORD PTR ?gStringMgr@@3PAVC_String@@A ; gStringMgr
	call	?GetString@C_String@@QAEPADJ@Z		; C_String::GetString
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
	push	39					; 00000027H
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	__snprintf
	add	esp, 16					; 00000010H

; 1216 : 			buf[39] = 0;

	mov	eax, 1
	imul	eax, 39					; 00000027H
	mov	DWORD PTR $T13[ebp], eax
	cmp	DWORD PTR $T13[ebp], 40			; 00000028H
	jae	SHORT $LN93@BuildCurre
	jmp	SHORT $LN94@BuildCurre
$LN93@BuildCurre:
	call	___report_rangecheckfailure
$LN94@BuildCurre:
	mov	ecx, DWORD PTR $T13[ebp]
	mov	BYTE PTR _buf$[ebp+ecx], 0

; 1217 : 
; 1218 : 			wpl=CurWP_->AddWaypointToList(campID+i,0,TGT_CUR,TGT_CUR_SEL,TGT_CUR_ERROR,y,maxy-x,FALSE);

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+732]
	subss	xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	10503					; 00002907H
	push	10502					; 00002906H
	push	10501					; 00002905H
	push	0
	mov	eax, DWORD PTR _campID$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1092]
	call	?AddWaypointToList@C_Waypoint@@QAEPAVWAYPOINTLIST@@JFJJJMMF@Z ; C_Waypoint::AddWaypointToList
	mov	DWORD PTR _wpl$[ebp], eax

; 1219 : 			if(wpl)

	cmp	DWORD PTR _wpl$[ebp], 0
	je	$LN4@BuildCurre

; 1220 : 			{
; 1221 : 				CurWP_->SetWPGroup(campID+i,campID);

	mov	edx, DWORD PTR _campID$[ebp]
	push	edx
	mov	eax, DWORD PTR _campID$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1092]
	call	?SetWPGroup@C_Waypoint@@QAEXJJ@Z	; C_Waypoint::SetWPGroup

; 1222 : 				CurWP_->SetUserNumber(C_STATE_0, static_cast<long>(maxy));

	mov	edx, DWORD PTR _this$[ebp]
	cvttss2si eax, DWORD PTR [edx+732]
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1092]
	call	?SetUserNumber@C_Base@@QAEXJJ@Z		; C_Base::SetUserNumber

; 1223 : 				CurWP_->SetLabel(campID+i,gStringMgr->GetText(gStringMgr->AddText(buf)));

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?gStringMgr@@3PAVC_String@@A ; gStringMgr
	call	?AddText@C_String@@QAEJPBD@Z		; C_String::AddText
	push	eax
	mov	ecx, DWORD PTR ?gStringMgr@@3PAVC_String@@A ; gStringMgr
	call	?GetText@C_String@@QAEPADJ@Z		; C_String::GetText
	push	eax
	mov	eax, DWORD PTR _campID$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1092]
	call	?SetLabel@C_Waypoint@@QAEXJPAD@Z	; C_Waypoint::SetLabel

; 1224 : 				CurWP_->SetTextOffset(campID+i,0,-15);

	push	-15					; fffffff1H
	push	0
	mov	edx, DWORD PTR _campID$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1092]
	call	?SetTextOffset@C_Waypoint@@QAEXJFF@Z	; C_Waypoint::SetTextOffset

; 1225 : 				CurWP_->SetState(campID+i,0);

	push	0
	mov	ecx, DWORD PTR _campID$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1092]
	call	?SetState@C_Waypoint@@QAEXJF@Z		; C_Waypoint::SetState

; 1226 : 				CurWP_->SetLabelColor(campID+i,0x00ffffff,0x0000ffff,0x000000ff);

	push	255					; 000000ffH
	push	65535					; 0000ffffH
	push	16777215				; 00ffffffH
	mov	eax, DWORD PTR _campID$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1092]
	call	?SetLabelColor@C_Waypoint@@QAEXJKKK@Z	; C_Waypoint::SetLabelColor

; 1227 : 				CurWP_->SetLineColor(campID+i,0x00ffffff,0x0000ffff,0x000000ff);

	push	255					; 000000ffH
	push	65535					; 0000ffffH
	push	16777215				; 00ffffffH
	mov	edx, DWORD PTR _campID$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1092]
	call	?SetLineColor@C_Waypoint@@QAEXJKKK@Z	; C_Waypoint::SetLineColor

; 1228 : 				tmpID=new VU_ID;

	push	8
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T11[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	cmp	DWORD PTR $T11[ebp], 0
	je	SHORT $LN95@BuildCurre
	mov	ecx, DWORD PTR $T11[ebp]
	call	??0VU_ID@@QAE@XZ			; VU_ID::VU_ID
	mov	DWORD PTR tv1069[ebp], eax
	jmp	SHORT $LN96@BuildCurre
$LN95@BuildCurre:
	mov	DWORD PTR tv1069[ebp], 0
$LN96@BuildCurre:
	mov	ecx, DWORD PTR tv1069[ebp]
	mov	DWORD PTR $T7[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T7[ebp]
	mov	DWORD PTR _tmpID$[ebp], edx

; 1229 : 				*tmpID=unit->Id();

	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	mov	ecx, DWORD PTR _unit$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _tmpID$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx

; 1230 : 				wpl->Icon->SetUserCleanupPtr(C_STATE_0,tmpID);

	mov	ecx, DWORD PTR _tmpID$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _wpl$[ebp]
	mov	ecx, DWORD PTR [edx+32]
	call	?SetUserCleanupPtr@C_Base@@QAEXJPAX@Z	; C_Base::SetUserCleanupPtr

; 1231 : 				wpl->Icon->SetUserNumber(C_STATE_1,-1);

	push	-1
	push	1
	mov	eax, DWORD PTR _wpl$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	call	?SetUserNumber@C_Base@@QAEXJJ@Z		; C_Base::SetUserNumber
$LN4@BuildCurre:

; 1232 : 			}
; 1233 : 
; 1234 : 		// Set Z Waypoint
; 1235 : 			xval=(i-1)*(650 / numwp) + 60;

	mov	ecx, DWORD PTR _i$[ebp]
	sub	ecx, 1
	mov	eax, 650				; 0000028aH
	cdq
	idiv	DWORD PTR _numwp$[ebp]
	imul	ecx, eax
	add	ecx, 60					; 0000003cH
	mov	DWORD PTR _xval$[ebp], ecx

; 1236 : 
; 1237 : 			wpl=CurWPZ_->AddWaypointToList(campID+i,0,TGT_CUR,TGT_CUR_SEL,TGT_CUR_ERROR,static_cast<float>(xval),z,FALSE);

	push	0
	push	ecx
	movss	xmm0, DWORD PTR _z$[ebp]
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _xval$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	10503					; 00002907H
	push	10502					; 00002906H
	push	10501					; 00002905H
	push	0
	mov	edx, DWORD PTR _campID$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1096]
	call	?AddWaypointToList@C_Waypoint@@QAEPAVWAYPOINTLIST@@JFJJJMMF@Z ; C_Waypoint::AddWaypointToList
	mov	DWORD PTR _wpl$[ebp], eax

; 1238 : 			if(wpl)

	cmp	DWORD PTR _wpl$[ebp], 0
	je	$LN1@BuildCurre

; 1239 : 			{
; 1240 : 				CurWPZ_->SetWPGroup(campID+i,campID);

	mov	ecx, DWORD PTR _campID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _campID$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1096]
	call	?SetWPGroup@C_Waypoint@@QAEXJJ@Z	; C_Waypoint::SetWPGroup

; 1241 : 				CurWPZ_->SetUserNumber(C_STATE_0, static_cast<long>(maxy));

	mov	ecx, DWORD PTR _this$[ebp]
	cvttss2si edx, DWORD PTR [ecx+732]
	push	edx
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1096]
	call	?SetUserNumber@C_Base@@QAEXJJ@Z		; C_Base::SetUserNumber

; 1242 : 				CurWPZ_->SetLabel(campID+i,gStringMgr->GetText(gStringMgr->AddText(buf)));

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?gStringMgr@@3PAVC_String@@A ; gStringMgr
	call	?AddText@C_String@@QAEJPBD@Z		; C_String::AddText
	push	eax
	mov	ecx, DWORD PTR ?gStringMgr@@3PAVC_String@@A ; gStringMgr
	call	?GetText@C_String@@QAEPADJ@Z		; C_String::GetText
	push	eax
	mov	edx, DWORD PTR _campID$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1096]
	call	?SetLabel@C_Waypoint@@QAEXJPAD@Z	; C_Waypoint::SetLabel

; 1243 : 				CurWPZ_->SetState(campID+i,0);

	push	0
	mov	ecx, DWORD PTR _campID$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1096]
	call	?SetState@C_Waypoint@@QAEXJF@Z		; C_Waypoint::SetState

; 1244 : 				CurWPZ_->SetLabelColor(campID+i,0x00ffffff,0x0000ffff,0x000000ff);

	push	255					; 000000ffH
	push	65535					; 0000ffffH
	push	16777215				; 00ffffffH
	mov	eax, DWORD PTR _campID$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1096]
	call	?SetLabelColor@C_Waypoint@@QAEXJKKK@Z	; C_Waypoint::SetLabelColor

; 1245 : 				CurWPZ_->SetLineColor(campID+i,0x00ffffff,0x0000ffff,0x000000ff);

	push	255					; 000000ffH
	push	65535					; 0000ffffH
	push	16777215				; 00ffffffH
	mov	edx, DWORD PTR _campID$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1096]
	call	?SetLineColor@C_Waypoint@@QAEXJKKK@Z	; C_Waypoint::SetLineColor

; 1246 : 				CurWPZ_->SetTextOffset(campID+i,0,-15);

	push	-15					; fffffff1H
	push	0
	mov	ecx, DWORD PTR _campID$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1096]
	call	?SetTextOffset@C_Waypoint@@QAEXJFF@Z	; C_Waypoint::SetTextOffset

; 1247 : 
; 1248 : 				tmpID=new VU_ID;

	push	8
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T16[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	cmp	DWORD PTR $T16[ebp], 0
	je	SHORT $LN97@BuildCurre
	mov	ecx, DWORD PTR $T16[ebp]
	call	??0VU_ID@@QAE@XZ			; VU_ID::VU_ID
	mov	DWORD PTR tv1169[ebp], eax
	jmp	SHORT $LN98@BuildCurre
$LN97@BuildCurre:
	mov	DWORD PTR tv1169[ebp], 0
$LN98@BuildCurre:
	mov	eax, DWORD PTR tv1169[ebp]
	mov	DWORD PTR $T9[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T9[ebp]
	mov	DWORD PTR _tmpID$[ebp], ecx

; 1249 : 				*tmpID=unit->Id();

	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _unit$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _tmpID$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx

; 1250 : 				wpl->Icon->SetUserCleanupPtr(C_STATE_0,tmpID);

	mov	ecx, DWORD PTR _tmpID$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _wpl$[ebp]
	mov	ecx, DWORD PTR [edx+32]
	call	?SetUserCleanupPtr@C_Base@@QAEXJPAX@Z	; C_Base::SetUserCleanupPtr

; 1251 : 				wpl->Icon->SetUserNumber(C_STATE_1,-1);

	push	-1
	push	1
	mov	eax, DWORD PTR _wpl$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	call	?SetUserNumber@C_Base@@QAEXJJ@Z		; C_Base::SetUserNumber

; 1252 : 				if(!(TheCampaign.Flags & CAMP_TACTICAL_EDIT))

	mov	ecx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A+64
	and	ecx, 524288				; 00080000H
	jne	SHORT $LN1@BuildCurre

; 1253 : 					if(firstwp != unit->GetCurrentUnitWP())

	mov	ecx, DWORD PTR _unit$[ebp]
	call	?GetCurrentUnitWP@UnitClass@@QBEPAVWayPointClass@@XZ ; UnitClass::GetCurrentUnitWP
	cmp	DWORD PTR _firstwp$[ebp], eax
	je	SHORT $LN1@BuildCurre

; 1254 : 						wpl->Dragable=0;

	xor	edx, edx
	mov	eax, DWORD PTR _wpl$[ebp]
	mov	WORD PTR [eax+36], dx
$LN1@BuildCurre:

; 1255 : 			}
; 1256 : 		}
; 1257 : 	}
; 1258 : 	CurWPZ_->SetUserNumber(C_STATE_1,endtime - starttime);

	mov	ecx, DWORD PTR _endtime$[ebp]
	sub	ecx, DWORD PTR _starttime$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1096]
	call	?SetUserNumber@C_Base@@QAEXJJ@Z		; C_Base::SetUserNumber

; 1259 : 	CurWPZ_->SetUserNumber(C_STATE_2,(long)distance);

	cvttsd2si eax, QWORD PTR _distance$[ebp]
	push	eax
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1096]
	call	?SetUserNumber@C_Base@@QAEXJJ@Z		; C_Base::SetUserNumber

; 1260 : 	CurWPZ_->SetUserNumber(C_STATE_3,0 /* MPG */ );

	push	0
	push	3
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1096]
	call	?SetUserNumber@C_Base@@QAEXJJ@Z		; C_Base::SetUserNumber
$LN81@BuildCurre:

; 1261 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?BuildCurrentWPList@C_Map@@AAEXPAVUnitClass@@@Z$0:
	mov	eax, DWORD PTR $T14[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?BuildCurrentWPList@C_Map@@AAEXPAVUnitClass@@@Z$1:
	mov	eax, DWORD PTR $T12[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?BuildCurrentWPList@C_Map@@AAEXPAVUnitClass@@@Z$2:
	mov	eax, DWORD PTR $T11[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?BuildCurrentWPList@C_Map@@AAEXPAVUnitClass@@@Z$3:
	mov	eax, DWORD PTR $T16[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?BuildCurrentWPList@C_Map@@AAEXPAVUnitClass@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-296]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?BuildCurrentWPList@C_Map@@AAEXPAVUnitClass@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?BuildCurrentWPList@C_Map@@AAEXPAVUnitClass@@@Z ENDP	; C_Map::BuildCurrentWPList
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
$T2 = -132						; size = 8
_z$ = -124						; size = 4
$T3 = -120						; size = 4
$T4 = -116						; size = 4
$T5 = -112						; size = 4
$T6 = -108						; size = 4
tv286 = -104						; size = 4
_UseFlag$ = -100					; size = 4
$T7 = -96						; size = 4
_state$ = -92						; size = 2
_tmpID$ = -88						; size = 4
_this$ = -84						; size = 4
_y$ = -80						; size = 4
_x$ = -76						; size = 4
_lastwp$ = -72						; size = 2
_selID$ = -68						; size = 4
_normID$ = -64						; size = 4
_othrID$ = -60						; size = 4
_airwps$ = -56						; size = 2
_wpl$ = -52						; size = 4
_campID$ = -48						; size = 4
_i$ = -44						; size = 4
_wp$ = -40						; size = 4
_buf$ = -36						; size = 20
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_wplist$ = 8						; size = 4
___formal$ = 12						; size = 4
_unit$ = 16						; size = 4
?BuildWPList@C_Map@@AAEXPAVC_Waypoint@@0PAVUnitClass@@@Z PROC ; C_Map::BuildWPList
; _this$ = ecx

; 1283 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?BuildWPList@C_Map@@AAEXPAVC_Waypoint@@0PAVUnitClass@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1284 : 	WayPoint wp=NULL;

	mov	DWORD PTR _wp$[ebp], 0

; 1285 : 	float x,y,z;
; 1286 : 	long normID,selID,othrID;
; 1287 : 	long i;
; 1288 : 	long campID;
; 1289 : 	long UseFlag;
; 1290 : 	WAYPOINTLIST *wpl=NULL;

	mov	DWORD PTR _wpl$[ebp], 0

; 1291 : 	short state;
; 1292 : 	_TCHAR buf[20];
; 1293 : 	VU_ID *tmpID=NULL;

	mov	DWORD PTR _tmpID$[ebp], 0

; 1294 : 	short airwps,lastwp;
; 1295 : 
; 1296 : 	if(unit == NULL) return;

	cmp	DWORD PTR _unit$[ebp], 0
	jne	SHORT $LN32@BuildWPLis
	jmp	$LN33@BuildWPLis
$LN32@BuildWPLis:

; 1297 : 	if(!unit->Final()) return;

	mov	ecx, DWORD PTR _unit$[ebp]
	call	?Final@UnitClass@@QBEHXZ		; UnitClass::Final
	test	eax, eax
	jne	SHORT $LN31@BuildWPLis
	jmp	$LN33@BuildWPLis
$LN31@BuildWPLis:

; 1298 : 
; 1299 : 	airwps=static_cast<short>(unit->IsFlight());

	mov	eax, DWORD PTR _unit$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _unit$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax
	mov	WORD PTR _airwps$[ebp], ax

; 1300 : 
; 1301 : 	if (!airwps)

	movsx	ecx, WORD PTR _airwps$[ebp]
	test	ecx, ecx
	jne	SHORT $LN29@BuildWPLis

; 1302 : 		{
; 1303 : 		wp=unit->GetCurrentUnitWP();

	mov	ecx, DWORD PTR _unit$[ebp]
	call	?GetCurrentUnitWP@UnitClass@@QBEPAVWayPointClass@@XZ ; UnitClass::GetCurrentUnitWP
	mov	DWORD PTR _wp$[ebp], eax

; 1304 : 		if (wp && wp->GetPrevWP())

	cmp	DWORD PTR _wp$[ebp], 0
	je	SHORT $LN29@BuildWPLis
	mov	ecx, DWORD PTR _wp$[ebp]
	call	?GetPrevWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetPrevWP
	test	eax, eax
	je	SHORT $LN29@BuildWPLis

; 1305 : 			wp = wp->GetPrevWP();

	mov	ecx, DWORD PTR _wp$[ebp]
	call	?GetPrevWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetPrevWP
	mov	DWORD PTR _wp$[ebp], eax
$LN29@BuildWPLis:

; 1306 : 		}
; 1307 : 	if (!wp || airwps)

	cmp	DWORD PTR _wp$[ebp], 0
	je	SHORT $LN27@BuildWPLis
	movsx	edx, WORD PTR _airwps$[ebp]
	test	edx, edx
	je	SHORT $LN28@BuildWPLis
$LN27@BuildWPLis:

; 1308 : 		wp=unit->GetFirstUnitWP();

	mov	ecx, DWORD PTR _unit$[ebp]
	call	?GetFirstUnitWP@UnitClass@@QAEPAVWayPointClass@@XZ ; UnitClass::GetFirstUnitWP
	mov	DWORD PTR _wp$[ebp], eax
$LN28@BuildWPLis:

; 1309 : 	if (!wp) return;

	cmp	DWORD PTR _wp$[ebp], 0
	jne	SHORT $LN26@BuildWPLis
	jmp	$LN33@BuildWPLis
$LN26@BuildWPLis:

; 1310 : 
; 1311 : 	campID=unit->GetCampID() << 8;

	mov	eax, DWORD PTR _unit$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _unit$[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax
	movsx	ecx, ax
	shl	ecx, 8
	mov	DWORD PTR _campID$[ebp], ecx

; 1312 : 
; 1313 : 	// set to 0 after Landing WP so we don't connect lines to following waypoints which are not on the agenda (Alt Land cit,Tanker etc)
; 1314 : 	UseFlag=C_BIT_USELINE;

	mov	DWORD PTR _UseFlag$[ebp], 4194304	; 00400000H

; 1315 : 
; 1316 : 	i=1;

	mov	DWORD PTR _i$[ebp], 1

; 1317 : 	lastwp=0;

	xor	edx, edx
	mov	WORD PTR _lastwp$[ebp], dx
$LN25@BuildWPLis:

; 1318 : 	while(wp)

	cmp	DWORD PTR _wp$[ebp], 0
	je	$LN24@BuildWPLis

; 1319 : 	{
; 1320 : 		if(!wp->GetNextWP())

	mov	ecx, DWORD PTR _wp$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	test	eax, eax
	jne	SHORT $LN23@BuildWPLis

; 1321 : 			lastwp=1;

	mov	eax, 1
	mov	WORD PTR _lastwp$[ebp], ax
$LN23@BuildWPLis:

; 1322 : 
; 1323 : 		if(wp->GetWPFlags() & WPF_TARGET)

	mov	ecx, DWORD PTR _wp$[ebp]
	call	?GetWPFlags@WayPointClass@@QAEKXZ	; WayPointClass::GetWPFlags
	and	eax, 1
	je	SHORT $LN22@BuildWPLis

; 1324 : 		{
; 1325 : 			normID=TGT_OTR;

	mov	DWORD PTR _normID$[ebp], 10510		; 0000290eH

; 1326 : 			selID=TGT_OTR_SEL;

	mov	DWORD PTR _selID$[ebp], 10511		; 0000290fH

; 1327 : 			othrID=TGT_OTR_OTHER;

	mov	DWORD PTR _othrID$[ebp], 10512		; 00002910H
	jmp	SHORT $LN19@BuildWPLis
$LN22@BuildWPLis:

; 1328 : 		}
; 1329 : 		else if(wp->GetWPFlags() & WPF_IP)

	mov	ecx, DWORD PTR _wp$[ebp]
	call	?GetWPFlags@WayPointClass@@QAEKXZ	; WayPointClass::GetWPFlags
	and	eax, 8
	je	SHORT $LN20@BuildWPLis

; 1330 : 		{
; 1331 : 			normID=IP_OTR;

	mov	DWORD PTR _normID$[ebp], 10513		; 00002911H

; 1332 : 			selID=IP_OTR_SEL;

	mov	DWORD PTR _selID$[ebp], 10514		; 00002912H

; 1333 : 			othrID=IP_OTR_OTHER;

	mov	DWORD PTR _othrID$[ebp], 10515		; 00002913H

; 1334 : 		}
; 1335 : 		else

	jmp	SHORT $LN19@BuildWPLis
$LN20@BuildWPLis:

; 1336 : 		{
; 1337 : 			normID=STPT_OTR;

	mov	DWORD PTR _normID$[ebp], 10516		; 00002914H

; 1338 : 			selID=STPT_OTR_SEL;

	mov	DWORD PTR _selID$[ebp], 10517		; 00002915H

; 1339 : 			othrID=STPT_OTR_OTHER;

	mov	DWORD PTR _othrID$[ebp], 10518		; 00002916H
$LN19@BuildWPLis:

; 1340 : 		}
; 1341 : 
; 1342 : 		if (wp == unit->GetCurrentUnitWP())

	mov	ecx, DWORD PTR _unit$[ebp]
	call	?GetCurrentUnitWP@UnitClass@@QBEPAVWayPointClass@@XZ ; UnitClass::GetCurrentUnitWP
	cmp	DWORD PTR _wp$[ebp], eax
	jne	SHORT $LN18@BuildWPLis

; 1343 : 			state=1;

	mov	ecx, 1
	mov	WORD PTR _state$[ebp], cx

; 1344 : 		else

	jmp	SHORT $LN17@BuildWPLis
$LN18@BuildWPLis:

; 1345 : 			state=0;

	xor	edx, edx
	mov	WORD PTR _state$[ebp], dx
$LN17@BuildWPLis:

; 1346 : 
; 1347 : 		wp->GetLocation(&x,&y,&z); // Note: for Sim -> UI (UI's) X = (Sim's) Y, (UI's Y) = (Sim's) [max y] - X (UI's) Z = (Sim's) -Z

	lea	eax, DWORD PTR _z$[ebp]
	push	eax
	lea	ecx, DWORD PTR _y$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	ecx, DWORD PTR _wp$[ebp]
	call	?GetLocation@WayPointClass@@QBEXPAM00@Z	; WayPointClass::GetLocation

; 1348 : 
; 1349 : 	// Set 2d Waypoint
; 1350 : 		if(UseFlag)

	cmp	DWORD PTR _UseFlag$[ebp], 0
	je	SHORT $LN16@BuildWPLis

; 1351 : 			_stprintf(buf,"%1d",i);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	push	OFFSET ??_C@_03GNGPFOOL@?$CF1d?$AA@
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1352 : 		else

	jmp	$LN11@BuildWPLis
$LN16@BuildWPLis:

; 1353 : 		{
; 1354 : 			if(wp->GetWPAction() == WP_LAND)

	mov	ecx, DWORD PTR _wp$[ebp]
	call	?GetWPAction@WayPointClass@@QAEHXZ	; WayPointClass::GetWPAction
	cmp	eax, 7
	jne	SHORT $LN14@BuildWPLis

; 1355 : 			{
; 1356 : 				_sntprintf(buf,39,"%s",gStringMgr->GetString(TXT_ALTERNATE_FIELD));

	push	200					; 000000c8H
	mov	ecx, DWORD PTR ?gStringMgr@@3PAVC_String@@A ; gStringMgr
	call	?GetString@C_String@@QAEPADJ@Z		; C_String::GetString
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
	push	39					; 00000027H
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	__snprintf
	add	esp, 16					; 00000010H

; 1357 : 				buf[39] = 0;

	mov	eax, 1
	imul	eax, 39					; 00000027H
	mov	DWORD PTR $T4[ebp], eax
	cmp	DWORD PTR $T4[ebp], 20			; 00000014H
	jae	SHORT $LN35@BuildWPLis
	jmp	SHORT $LN36@BuildWPLis
$LN35@BuildWPLis:
	call	___report_rangecheckfailure
$LN36@BuildWPLis:
	mov	ecx, DWORD PTR $T4[ebp]
	mov	BYTE PTR _buf$[ebp+ecx], 0
	jmp	SHORT $LN11@BuildWPLis
$LN14@BuildWPLis:

; 1358 : 			}
; 1359 : 			else if(wp->GetWPAction() == WP_REFUEL)

	mov	ecx, DWORD PTR _wp$[ebp]
	call	?GetWPAction@WayPointClass@@QAEHXZ	; WayPointClass::GetWPAction
	cmp	eax, 4
	jne	SHORT $LN12@BuildWPLis

; 1360 : 			{
; 1361 : 				_sntprintf(buf,39,_T("%s"),gStringMgr->GetString(TXT_TANKER));

	push	202					; 000000caH
	mov	ecx, DWORD PTR ?gStringMgr@@3PAVC_String@@A ; gStringMgr
	call	?GetString@C_String@@QAEPADJ@Z		; C_String::GetString
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
	push	39					; 00000027H
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	__snprintf
	add	esp, 16					; 00000010H

; 1362 : 				buf[39] = 0;

	mov	eax, 1
	imul	eax, 39					; 00000027H
	mov	DWORD PTR $T5[ebp], eax
	cmp	DWORD PTR $T5[ebp], 20			; 00000014H
	jae	SHORT $LN37@BuildWPLis
	jmp	SHORT $LN38@BuildWPLis
$LN37@BuildWPLis:
	call	___report_rangecheckfailure
$LN38@BuildWPLis:
	mov	ecx, DWORD PTR $T5[ebp]
	mov	BYTE PTR _buf$[ebp+ecx], 0

; 1363 : 			}
; 1364 : 			else

	jmp	SHORT $LN11@BuildWPLis
$LN12@BuildWPLis:

; 1365 : 				buf[0]=0;

	mov	edx, 1
	imul	edx, 0
	mov	DWORD PTR $T6[ebp], edx
	cmp	DWORD PTR $T6[ebp], 20			; 00000014H
	jae	SHORT $LN39@BuildWPLis
	jmp	SHORT $LN40@BuildWPLis
$LN39@BuildWPLis:
	call	___report_rangecheckfailure
$LN40@BuildWPLis:
	mov	eax, DWORD PTR $T6[ebp]
	mov	BYTE PTR _buf$[ebp+eax], 0
$LN11@BuildWPLis:

; 1366 : 		}
; 1367 : 		if(buf[0])

	mov	ecx, 1
	imul	ecx, 0
	movsx	edx, BYTE PTR _buf$[ebp+ecx]
	test	edx, edx
	je	$LN3@BuildWPLis

; 1368 : 		{
; 1369 : 			if(airwps)

	movsx	eax, WORD PTR _airwps$[ebp]
	test	eax, eax
	je	$LN9@BuildWPLis

; 1370 : 			{
; 1371 : 				if(i == 1)

	cmp	DWORD PTR _i$[ebp], 1
	jne	SHORT $LN8@BuildWPLis

; 1372 : 					wpl=wplist->AddWaypointToList(campID+i,0,normID,selID,othrID,y,maxy-x,FALSE);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+732]
	subss	xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _othrID$[ebp]
	push	edx
	mov	eax, DWORD PTR _selID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _normID$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _campID$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _wplist$[ebp]
	call	?AddWaypointToList@C_Waypoint@@QAEPAVWAYPOINTLIST@@JFJJJMMF@Z ; C_Waypoint::AddWaypointToList
	mov	DWORD PTR _wpl$[ebp], eax

; 1373 : 				else

	jmp	SHORT $LN7@BuildWPLis
$LN8@BuildWPLis:

; 1374 : 					wpl=wplist->AddWaypointToList(campID+i,0,normID,selID,othrID,y,maxy-x,FALSE);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+732]
	subss	xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _othrID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _selID$[ebp]
	push	edx
	mov	eax, DWORD PTR _normID$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _campID$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _wplist$[ebp]
	call	?AddWaypointToList@C_Waypoint@@QAEPAVWAYPOINTLIST@@JFJJJMMF@Z ; C_Waypoint::AddWaypointToList
	mov	DWORD PTR _wpl$[ebp], eax
$LN7@BuildWPLis:

; 1375 : 			}
; 1376 : 			else

	jmp	$LN4@BuildWPLis
$LN9@BuildWPLis:

; 1377 : 			{
; 1378 : 				if(lastwp)

	movsx	edx, WORD PTR _lastwp$[ebp]
	test	edx, edx
	je	SHORT $LN5@BuildWPLis

; 1379 : 					wpl=wplist->AddWaypointToList(campID+i,0,normID,selID,othrID,y,maxy-x,FALSE);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+732]
	subss	xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _othrID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _selID$[ebp]
	push	edx
	mov	eax, DWORD PTR _normID$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _campID$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _wplist$[ebp]
	call	?AddWaypointToList@C_Waypoint@@QAEPAVWAYPOINTLIST@@JFJJJMMF@Z ; C_Waypoint::AddWaypointToList
	mov	DWORD PTR _wpl$[ebp], eax

; 1380 : 				else

	jmp	SHORT $LN4@BuildWPLis
$LN5@BuildWPLis:

; 1381 : 					wpl=wplist->AddWaypointToList(campID+i,0,0,0,0,y,maxy-x,FALSE);

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+732]
	subss	xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	0
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _campID$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _wplist$[ebp]
	call	?AddWaypointToList@C_Waypoint@@QAEPAVWAYPOINTLIST@@JFJJJMMF@Z ; C_Waypoint::AddWaypointToList
	mov	DWORD PTR _wpl$[ebp], eax
$LN4@BuildWPLis:

; 1382 : 			}
; 1383 : 			if(wpl)

	cmp	DWORD PTR _wpl$[ebp], 0
	je	$LN3@BuildWPLis

; 1384 : 			{
; 1385 : 				wplist->SetWPGroup(campID+i,campID);

	mov	ecx, DWORD PTR _campID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _campID$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _wplist$[ebp]
	call	?SetWPGroup@C_Waypoint@@QAEXJJ@Z	; C_Waypoint::SetWPGroup

; 1386 : // 2002-03-10 MN fix for black eagle on black ground ;-)
; 1387 : 				if (g_bAWACSBackground)

	movzx	eax, BYTE PTR ?g_bAWACSBackground@@3_NA	; g_bAWACSBackground
	test	eax, eax
	je	SHORT $LN2@BuildWPLis

; 1388 : 				{
; 1389 : 					wplist->SetLabelColor(campID+i,0x00999999,0x00ffffff,0x00999999);

	push	10066329				; 00999999H
	push	16777215				; 00ffffffH
	push	10066329				; 00999999H
	mov	ecx, DWORD PTR _campID$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _wplist$[ebp]
	call	?SetLabelColor@C_Waypoint@@QAEXJKKK@Z	; C_Waypoint::SetLabelColor

; 1390 : 					wplist->SetLineColor(campID+i,0x00999999,0x00ffffff,0x00999999);

	push	10066329				; 00999999H
	push	16777215				; 00ffffffH
	push	10066329				; 00999999H
	mov	edx, DWORD PTR _campID$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _wplist$[ebp]
	call	?SetLineColor@C_Waypoint@@QAEXJKKK@Z	; C_Waypoint::SetLineColor

; 1391 : 				}
; 1392 : 				else

	jmp	SHORT $LN1@BuildWPLis
$LN2@BuildWPLis:

; 1393 : 				{
; 1394 : 					wplist->SetLabelColor(campID+i,0,0x00500000,0);

	push	0
	push	5242880					; 00500000H
	push	0
	mov	eax, DWORD PTR _campID$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _wplist$[ebp]
	call	?SetLabelColor@C_Waypoint@@QAEXJKKK@Z	; C_Waypoint::SetLabelColor

; 1395 : 					wplist->SetLineColor(campID+i,0,0x00500000,0);

	push	0
	push	5242880					; 00500000H
	push	0
	mov	ecx, DWORD PTR _campID$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _wplist$[ebp]
	call	?SetLineColor@C_Waypoint@@QAEXJKKK@Z	; C_Waypoint::SetLineColor
$LN1@BuildWPLis:

; 1396 : 				}
; 1397 : 
; 1398 : 				tmpID=new VU_ID;

	push	8
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T7[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T7[ebp], 0
	je	SHORT $LN41@BuildWPLis
	mov	ecx, DWORD PTR $T7[ebp]
	call	??0VU_ID@@QAE@XZ			; VU_ID::VU_ID
	mov	DWORD PTR tv286[ebp], eax
	jmp	SHORT $LN42@BuildWPLis
$LN41@BuildWPLis:
	mov	DWORD PTR tv286[ebp], 0
$LN42@BuildWPLis:
	mov	edx, DWORD PTR tv286[ebp]
	mov	DWORD PTR $T3[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR _tmpID$[ebp], eax

; 1399 : 				*tmpID=unit->Id();

	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _unit$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _tmpID$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax

; 1400 : 				wpl->Flags |= UseFlag;

	mov	edx, DWORD PTR _wpl$[ebp]
	mov	eax, DWORD PTR [edx+8]
	or	eax, DWORD PTR _UseFlag$[ebp]
	mov	ecx, DWORD PTR _wpl$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1401 : 				wpl->Icon->SetUserCleanupPtr(C_STATE_0,tmpID);

	mov	edx, DWORD PTR _tmpID$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _wpl$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	call	?SetUserCleanupPtr@C_Base@@QAEXJPAX@Z	; C_Base::SetUserCleanupPtr

; 1402 : 				wpl->Icon->SetUserNumber(C_STATE_1,i);

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _wpl$[ebp]
	mov	ecx, DWORD PTR [edx+32]
	call	?SetUserNumber@C_Base@@QAEXJJ@Z		; C_Base::SetUserNumber
$LN3@BuildWPLis:

; 1403 : 			}
; 1404 : 		}
; 1405 : 		i++;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax

; 1406 : 		wp=wp->GetNextWP();

	mov	ecx, DWORD PTR _wp$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _wp$[ebp], eax

; 1407 : 	}

	jmp	$LN25@BuildWPLis
$LN24@BuildWPLis:
$LN33@BuildWPLis:

; 1408 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?BuildWPList@C_Map@@AAEXPAVC_Waypoint@@0PAVUnitClass@@@Z$0:
	mov	eax, DWORD PTR $T7[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?BuildWPList@C_Map@@AAEXPAVC_Waypoint@@0PAVUnitClass@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?BuildWPList@C_Map@@AAEXPAVC_Waypoint@@0PAVUnitClass@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?BuildWPList@C_Map@@AAEXPAVC_Waypoint@@0PAVUnitClass@@@Z ENDP ; C_Map::BuildWPList
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\cmap.cpp
_TEXT	SEGMENT
_ratio$ = -20						; size = 4
_pixels$ = -16						; size = 4
_this$ = -12						; size = 4
_x$ = -8						; size = 2
_y$ = -4						; size = 2
?CalculateDrawingParams@C_Map@@AAEXXZ PROC		; C_Map::CalculateDrawingParams
; _this$ = ecx

; 294  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 295  : 	float ratio;
; 296  : 	long pixels;
; 297  : 
; 298  : 	if(Map_ == NULL || DrawWindow_ == NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+808], 0
	je	SHORT $LN7@CalculateD
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1124], 0
	jne	SHORT $LN8@CalculateD
$LN7@CalculateD:

; 299  : 		return;

	jmp	$LN9@CalculateD
$LN8@CalculateD:

; 300  : 
; 301  : 	ratio=(float)(DrawRect_.bottom-DrawRect_.top) / (float)(DrawRect_.right-DrawRect_.left);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1144]
	sub	ecx, DWORD PTR [eax+1136]
	cvtsi2ss xmm0, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1140]
	sub	ecx, DWORD PTR [eax+1132]
	cvtsi2ss xmm1, ecx
	divss	xmm0, xmm1
	movss	DWORD PTR _ratio$[ebp], xmm0

; 302  : 	pixels=ZoomLevel_;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+712]
	mov	DWORD PTR _pixels$[ebp], eax

; 303  : 
; 304  : 	MapRect_.left=FloatToInt32(CenterX_) - pixels/2;

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+704]
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	ecx, eax
	mov	eax, DWORD PTR _pixels$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	ecx, eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+812], ecx

; 305  : 	if(MapRect_.left < 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+812], 0
	jge	SHORT $LN6@CalculateD

; 306  : 	{
; 307  : 		MapRect_.left=0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+812], 0

; 308  : 		CenterX_=static_cast<float>(MapRect_.left+pixels/2);

	mov	eax, DWORD PTR _pixels$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+812]
	add	ecx, eax
	cvtsi2ss xmm0, ecx
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+704], xmm0
$LN6@CalculateD:

; 309  : 	}
; 310  : 	MapRect_.right=MapRect_.left+pixels;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+812]
	add	ecx, DWORD PTR _pixels$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+820], ecx

; 311  : 	if(MapRect_.right > Map_->GetW())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	call	?GetW@C_Base@@QAEJXZ			; C_Base::GetW
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+820], eax
	jle	SHORT $LN5@CalculateD

; 312  : 	{
; 313  : 		MapRect_.right=Map_->GetW();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+808]
	call	?GetW@C_Base@@QAEJXZ			; C_Base::GetW
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+820], eax

; 314  : 		MapRect_.left=MapRect_.right-pixels;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+820]
	sub	eax, DWORD PTR _pixels$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+812], eax

; 315  : 		CenterX_=static_cast<float>(MapRect_.right-pixels/2);

	mov	eax, DWORD PTR _pixels$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+820]
	sub	ecx, eax
	cvtsi2ss xmm0, ecx
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+704], xmm0
$LN5@CalculateD:

; 316  : 	}
; 317  : 
; 318  : 	MapRect_.top=FloatToInt32(CenterY_) - (long)((float)pixels*ratio)/2;

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+708]
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	ecx, eax
	cvtsi2ss xmm0, DWORD PTR _pixels$[ebp]
	mulss	xmm0, DWORD PTR _ratio$[ebp]
	cvttss2si eax, xmm0
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	ecx, eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+816], ecx

; 319  : 
; 320  : 	if(MapRect_.top < 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+816], 0
	jge	SHORT $LN4@CalculateD

; 321  : 	{
; 322  : 		MapRect_.top=0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+816], 0

; 323  : 		CenterY_=static_cast<float>(MapRect_.top+(long)((float)pixels*ratio)/2);

	cvtsi2ss xmm0, DWORD PTR _pixels$[ebp]
	mulss	xmm0, DWORD PTR _ratio$[ebp]
	cvttss2si eax, xmm0
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+816]
	add	ecx, eax
	cvtsi2ss xmm0, ecx
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+708], xmm0
$LN4@CalculateD:

; 324  : 	}
; 325  : 	MapRect_.bottom=MapRect_.top+(long)((float)pixels*ratio);

	cvtsi2ss xmm0, DWORD PTR _pixels$[ebp]
	mulss	xmm0, DWORD PTR _ratio$[ebp]
	cvttss2si eax, xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+816]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+824], eax

; 326  : 	if(MapRect_.bottom > Map_->GetH())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	call	?GetH@C_Base@@QAEJXZ			; C_Base::GetH
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+824], eax
	jle	SHORT $LN3@CalculateD

; 327  : 	{
; 328  : 		MapRect_.bottom=Map_->GetH();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+808]
	call	?GetH@C_Base@@QAEJXZ			; C_Base::GetH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+824], eax

; 329  : 		MapRect_.top=MapRect_.bottom-(long)((float)pixels*ratio);

	cvtsi2ss xmm0, DWORD PTR _pixels$[ebp]
	mulss	xmm0, DWORD PTR _ratio$[ebp]
	cvttss2si edx, xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+824]
	sub	ecx, edx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+816], ecx

; 330  : 		CenterY_=static_cast<float>(MapRect_.bottom-(long)((float)pixels*ratio)/2);

	cvtsi2ss xmm0, DWORD PTR _pixels$[ebp]
	mulss	xmm0, DWORD PTR _ratio$[ebp]
	cvttss2si eax, xmm0
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+824]
	sub	edx, eax
	cvtsi2ss xmm0, edx
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+708], xmm0
$LN3@CalculateD:

; 331  : 	}
; 332  : 
; 333  : 	Map_->SetSrcRect(&MapRect_);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 812				; 0000032cH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+808]
	call	?SetSrcRect@C_ScaleBitmap@@QAEXPAUUI95_RECT@@@Z ; C_ScaleBitmap::SetSrcRect

; 334  : 	Map_->SetDestRect(&DrawRect_);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1132				; 0000046cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+808]
	call	?SetDestRect@C_ScaleBitmap@@QAEXPAUUI95_RECT@@@Z ; C_ScaleBitmap::SetDestRect

; 335  : 	Map_->SetScaleInfo(((MapRect_.right-MapRect_.left)*1000)/(DrawRect_.right-DrawRect_.left));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+820]
	sub	ecx, DWORD PTR [eax+812]
	imul	ecx, 1000				; 000003e8H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+1140]
	sub	esi, DWORD PTR [eax+1132]
	mov	eax, ecx
	cdq
	idiv	esi
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+808]
	call	?SetScaleInfo@C_ScaleBitmap@@QAEXJ@Z	; C_ScaleBitmap::SetScaleInfo

; 336  : 
; 337  : 	scale_=(float)(DrawRect_.right-DrawRect_.left) / ((float)(MapRect_.right-MapRect_.left)*FEET_PER_PIXEL);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1140]
	sub	ecx, DWORD PTR [eax+1132]
	cvtsi2ss xmm0, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+820]
	sub	ecx, DWORD PTR [eax+812]
	cvtsi2ss xmm1, ecx
	mulss	xmm1, DWORD PTR __real@44ccffae
	divss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+728], xmm0

; 338  : 
; 339  : 	DrawWindow_->VX_[0]=-(short)((float)MapRect_.left*FEET_PER_PIXEL*scale_)+DrawWindow_->ClientArea_[0].left;

	mov	eax, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+812]
	mulss	xmm0, DWORD PTR __real@44ccffae
	mov	ecx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [ecx+728]
	cvttss2si edx, xmm0
	movsx	eax, dx
	neg	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1124]
	mov	ecx, 16					; 00000010H
	imul	ecx, 0
	add	eax, DWORD PTR [edx+ecx+168]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1124]
	mov	edx, 4
	imul	edx, 0
	mov	DWORD PTR [ecx+edx+480], eax

; 340  : 	DrawWindow_->VY_[0]=-(short)((float)MapRect_.top*FEET_PER_PIXEL*scale_)+DrawWindow_->ClientArea_[0].top;

	mov	eax, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+816]
	mulss	xmm0, DWORD PTR __real@44ccffae
	mov	ecx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [ecx+728]
	cvttss2si edx, xmm0
	movsx	eax, dx
	neg	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1124]
	mov	ecx, 16					; 00000010H
	imul	ecx, 0
	add	eax, DWORD PTR [edx+ecx+172]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1124]
	mov	edx, 4
	imul	edx, 0
	mov	DWORD PTR [ecx+edx+512], eax

; 341  : 	SetTeamScales();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTeamScales@C_Map@@AAEXXZ		; C_Map::SetTeamScales

; 342  : 
; 343  : 	flags_ |= I_NEED_TO_DRAW|I_NEED_TO_DRAW_MAP;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+736]
	or	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+736], ecx

; 344  : 	short x,y;
; 345  : 	TheCampaign.GetBullseyeLocation(&x,&y);

	lea	eax, DWORD PTR _y$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	ecx, OFFSET ?TheCampaign@@3VCampaignClass@@A ; TheCampaign
	call	?GetBullseyeLocation@CampaignClass@@QAEXPAF0@Z ; CampaignClass::GetBullseyeLocation

; 346  : 	if (x != BullsEyeX_ || y != BullsEyeY_)

	movsx	edx, WORD PTR _x$[ebp]
	cvtsi2ss xmm0, edx
	mov	eax, DWORD PTR _this$[ebp]
	ucomiss	xmm0, DWORD PTR [eax+744]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN1@CalculateD
	movsx	ecx, WORD PTR _y$[ebp]
	cvtsi2ss xmm0, ecx
	mov	edx, DWORD PTR _this$[ebp]
	ucomiss	xmm0, DWORD PTR [edx+748]
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2@CalculateD
$LN1@CalculateD:

; 347  : 	{
; 348  : 		SetBullsEye(x * FEET_PER_KM,(TheCampaign.TheaterSizeY-y) * FEET_PER_KM);

	movsx	eax, WORD PTR ?TheCampaign@@3VCampaignClass@@A+88
	movsx	ecx, WORD PTR _y$[ebp]
	sub	eax, ecx
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@454cffae
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movsx	edx, WORD PTR _x$[ebp]
	cvtsi2ss xmm0, edx
	mulss	xmm0, DWORD PTR __real@454cffae
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetBullsEye@C_Map@@QAEXMM@Z		; C_Map::SetBullsEye

; 349  : 		DrawMap();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawMap@C_Map@@QAEXXZ			; C_Map::DrawMap
$LN2@CalculateD:
$LN9@CalculateD:

; 350  : 	}
; 351  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?CalculateDrawingParams@C_Map@@AAEXXZ ENDP		; C_Map::CalculateDrawingParams
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95_ext\cbeye.h
;	COMDAT ?SetColor@C_BullsEye@@QAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_color$ = 8						; size = 4
?SetColor@C_BullsEye@@QAEXK@Z PROC			; C_BullsEye::SetColor, COMDAT
; _this$ = ecx

; 27   : 		void SetColor(COLORREF color) { Color_=color; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _color$[ebp]
	mov	DWORD PTR [eax+56], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetColor@C_BullsEye@@QAEXK@Z ENDP			; C_BullsEye::SetColor
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95_ext\cwaypnt.h
;	COMDAT ?Dragging@C_Waypoint@@QAEFXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Dragging@C_Waypoint@@QAEFXZ PROC			; C_Waypoint::Dragging, COMDAT
; _this$ = ecx

; 104  : 		short  Dragging() { return(Dragging_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+162]
	mov	esp, ebp
	pop	ebp
	ret	0
?Dragging@C_Waypoint@@QAEFXZ ENDP			; C_Waypoint::Dragging
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95_ext\cwaypnt.h
;	COMDAT ?GetRoot@C_Waypoint@@QAEPAVWAYPOINTLIST@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetRoot@C_Waypoint@@QAEPAVWAYPOINTLIST@@XZ PROC	; C_Waypoint::GetRoot, COMDAT
; _this$ = ecx

; 91   : 		WAYPOINTLIST *GetRoot() { return(Root_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+100]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetRoot@C_Waypoint@@QAEPAVWAYPOINTLIST@@XZ ENDP	; C_Waypoint::GetRoot
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95_ext\cwaypnt.h
;	COMDAT ?SetWorldRange@C_Waypoint@@QAEXMMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_minx$ = 8						; size = 4
_miny$ = 12						; size = 4
_maxx$ = 16						; size = 4
_maxy$ = 20						; size = 4
?SetWorldRange@C_Waypoint@@QAEXMMMM@Z PROC		; C_Waypoint::SetWorldRange, COMDAT
; _this$ = ecx

; 68   : 		void SetWorldRange(float minx,float miny,float maxx,float maxy) { MinWorldX_=minx; MinWorldY_=miny; MaxWorldX_=maxx; MaxWorldY_=maxy; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _minx$[ebp]
	movss	DWORD PTR [eax+144], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _miny$[ebp]
	movss	DWORD PTR [ecx+148], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _maxx$[ebp]
	movss	DWORD PTR [edx+152], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _maxy$[ebp]
	movss	DWORD PTR [eax+156], xmm0
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?SetWorldRange@C_Waypoint@@QAEXMMMM@Z ENDP		; C_Waypoint::SetWorldRange
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95_ext\cthreat.h
;	COMDAT ?GetThreat@C_Threat@@QAEPAUTHREAT_CIRCLE@@J@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ID$ = 8						; size = 4
?GetThreat@C_Threat@@QAEPAUTHREAT_CIRCLE@@J@Z PROC	; C_Threat::GetThreat, COMDAT
; _this$ = ecx

; 262  : 		THREAT_CIRCLE *GetThreat(long ID) { if(Root_) return((THREAT_CIRCLE*)Root_->Find(ID)); return(NULL); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+52], 0
	je	SHORT $LN1@GetThreat
	mov	ecx, DWORD PTR _ID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	call	?Find@C_Hash@@QAEPAXJ@Z			; C_Hash::Find
	jmp	SHORT $LN2@GetThreat
$LN1@GetThreat:
	xor	eax, eax
$LN2@GetThreat:
	mov	esp, ebp
	pop	ebp
	ret	4
?GetThreat@C_Threat@@QAEPAUTHREAT_CIRCLE@@J@Z ENDP	; C_Threat::GetThreat
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95_ext\cicons.h
;	COMDAT ?SetTeam@C_MapIcon@@QAEXF@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_team$ = 8						; size = 2
?SetTeam@C_MapIcon@@QAEXF@Z PROC			; C_MapIcon::SetTeam, COMDAT
; _this$ = ecx

; 140  : 		void SetTeam(short team) { Team_=team; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _team$[ebp]
	mov	WORD PTR [eax+104], cx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetTeam@C_MapIcon@@QAEXF@Z ENDP			; C_MapIcon::SetTeam
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95_ext\cicons.h
;	COMDAT ?AddIconToList@C_MapIcon@@QAEPAVMAPICONLIST@@JFJMMFPADJJ@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_CampID$ = 8						; size = 4
_type$ = 12						; size = 2
_ImageID$ = 16						; size = 4
_x$ = 20						; size = 4
_y$ = 24						; size = 4
_Dragable$ = 28						; size = 2
_str$ = 32						; size = 4
_newstatus$ = 36					; size = 4
_newstate$ = 40						; size = 4
?AddIconToList@C_MapIcon@@QAEPAVMAPICONLIST@@JFJMMFPADJJ@Z PROC ; C_MapIcon::AddIconToList, COMDAT
; _this$ = ecx

; 117  : 			{ return(AddIconToList(CampID,type,ImageID,x,y,Dragable,str,0,0,0,newstatus,newstate,NULL)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	0
	mov	eax, DWORD PTR _newstate$[ebp]
	push	eax
	mov	ecx, DWORD PTR _newstatus$[ebp]
	push	ecx
	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _str$[ebp]
	push	edx
	movzx	eax, WORD PTR _Dragable$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _ImageID$[ebp]
	push	ecx
	movzx	edx, WORD PTR _type$[ebp]
	push	edx
	mov	eax, DWORD PTR _CampID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddIconToList@C_MapIcon@@QAEPAVMAPICONLIST@@JFJMMFPADJJJJJPAUDETECTOR@@@Z ; C_MapIcon::AddIconToList
	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
?AddIconToList@C_MapIcon@@QAEPAVMAPICONLIST@@JFJMMFPADJJ@Z ENDP ; C_MapIcon::AddIconToList
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95_ext\cicons.h
;	COMDAT ?AddIconToList@C_MapIcon@@QAEPAVMAPICONLIST@@JFJMMFPADJJJJJ@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_CampID$ = 8						; size = 4
_type$ = 12						; size = 2
_ImageID$ = 16						; size = 4
_x$ = 20						; size = 4
_y$ = 24						; size = 4
_Dragable$ = 28						; size = 2
_str$ = 32						; size = 4
_DivID$ = 36						; size = 4
_BrigID$ = 40						; size = 4
_BatID$ = 44						; size = 4
_newstatus$ = 48					; size = 4
_newstate$ = 52						; size = 4
?AddIconToList@C_MapIcon@@QAEPAVMAPICONLIST@@JFJMMFPADJJJJJ@Z PROC ; C_MapIcon::AddIconToList, COMDAT
; _this$ = ecx

; 115  : 			{ return(AddIconToList(CampID,type,ImageID,x,y,Dragable,str,DivID,BrigID,BatID,newstatus,newstate,NULL)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	0
	mov	eax, DWORD PTR _newstate$[ebp]
	push	eax
	mov	ecx, DWORD PTR _newstatus$[ebp]
	push	ecx
	mov	edx, DWORD PTR _BatID$[ebp]
	push	edx
	mov	eax, DWORD PTR _BrigID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _DivID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _str$[ebp]
	push	edx
	movzx	eax, WORD PTR _Dragable$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _ImageID$[ebp]
	push	ecx
	movzx	edx, WORD PTR _type$[ebp]
	push	edx
	mov	eax, DWORD PTR _CampID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddIconToList@C_MapIcon@@QAEPAVMAPICONLIST@@JFJMMFPADJJJJJPAUDETECTOR@@@Z ; C_MapIcon::AddIconToList
	mov	esp, ebp
	pop	ebp
	ret	48					; 00000030H
?AddIconToList@C_MapIcon@@QAEPAVMAPICONLIST@@JFJMMFPADJJJJJ@Z ENDP ; C_MapIcon::AddIconToList
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\csclbmp.h
;	COMDAT ?SetScaleInfo@C_ScaleBitmap@@QAEXJ@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_scale$ = 8						; size = 4
?SetScaleInfo@C_ScaleBitmap@@QAEXJ@Z PROC		; C_ScaleBitmap::SetScaleInfo, COMDAT
; _this$ = ecx

; 50   : 		void SetScaleInfo(long scale) { if(Image_ != NULL) Image_->SetScaleInfo(scale); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3340], 0
	je	SHORT $LN2@SetScaleIn
	mov	ecx, DWORD PTR _scale$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+3340]
	call	?SetScaleInfo@O_Output@@QAEXJ@Z		; O_Output::SetScaleInfo
$LN2@SetScaleIn:
	mov	esp, ebp
	pop	ebp
	ret	4
?SetScaleInfo@C_ScaleBitmap@@QAEXJ@Z ENDP		; C_ScaleBitmap::SetScaleInfo
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\csclbmp.h
;	COMDAT ?SetDestRect@C_ScaleBitmap@@QAEXPAUUI95_RECT@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rect$ = 8						; size = 4
?SetDestRect@C_ScaleBitmap@@QAEXPAUUI95_RECT@@@Z PROC	; C_ScaleBitmap::SetDestRect, COMDAT
; _this$ = ecx

; 49   : 		void SetDestRect(UI95_RECT *rect) { if(Image_ != NULL) Image_->SetDestRect(rect); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3340], 0
	je	SHORT $LN2@SetDestRec
	mov	ecx, DWORD PTR _rect$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+3340]
	call	?SetDestRect@O_Output@@QAEXPAUUI95_RECT@@@Z ; O_Output::SetDestRect
$LN2@SetDestRec:
	mov	esp, ebp
	pop	ebp
	ret	4
?SetDestRect@C_ScaleBitmap@@QAEXPAUUI95_RECT@@@Z ENDP	; C_ScaleBitmap::SetDestRect
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\csclbmp.h
;	COMDAT ?SetSrcRect@C_ScaleBitmap@@QAEXPAUUI95_RECT@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rect$ = 8						; size = 4
?SetSrcRect@C_ScaleBitmap@@QAEXPAUUI95_RECT@@@Z PROC	; C_ScaleBitmap::SetSrcRect, COMDAT
; _this$ = ecx

; 48   : 		void SetSrcRect(UI95_RECT *rect) { if(Image_ != NULL) Image_->SetSrcRect(rect); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3340], 0
	je	SHORT $LN2@SetSrcRect
	mov	ecx, DWORD PTR _rect$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+3340]
	call	?SetSrcRect@O_Output@@QAEXPAUUI95_RECT@@@Z ; O_Output::SetSrcRect
$LN2@SetSrcRect:
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSrcRect@C_ScaleBitmap@@QAEXPAUUI95_RECT@@@Z ENDP	; C_ScaleBitmap::SetSrcRect
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\csclbmp.h
;	COMDAT ?NoOverlay@C_ScaleBitmap@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?NoOverlay@C_ScaleBitmap@@QAEXXZ PROC			; C_ScaleBitmap::NoOverlay, COMDAT
; _this$ = ecx

; 43   : 		void NoOverlay() { UseOverlay_=FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+60], 0
	mov	esp, ebp
	pop	ebp
	ret	0
?NoOverlay@C_ScaleBitmap@@QAEXXZ ENDP			; C_ScaleBitmap::NoOverlay
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\csclbmp.h
;	COMDAT ?UseOverlay@C_ScaleBitmap@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?UseOverlay@C_ScaleBitmap@@QAEXXZ PROC			; C_ScaleBitmap::UseOverlay, COMDAT
; _this$ = ecx

; 42   : 		void UseOverlay() { if(Overlay_) UseOverlay_=TRUE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3272], 0
	je	SHORT $LN2@UseOverlay
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+60], 1
$LN2@UseOverlay:
	mov	esp, ebp
	pop	ebp
	ret	0
?UseOverlay@C_ScaleBitmap@@QAEXXZ ENDP			; C_ScaleBitmap::UseOverlay
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\csclbmp.h
;	COMDAT ?GetOverlay@C_ScaleBitmap@@QAEPAEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetOverlay@C_ScaleBitmap@@QAEPAEXZ PROC		; C_ScaleBitmap::GetOverlay, COMDAT
; _this$ = ecx

; 41   : 		BYTE *GetOverlay() { return(Overlay_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+3272]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetOverlay@C_ScaleBitmap@@QAEPAEXZ ENDP		; C_ScaleBitmap::GetOverlay
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cbase.h
;	COMDAT ?GetH@C_Base@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetH@C_Base@@QAEJXZ PROC				; C_Base::GetH, COMDAT
; _this$ = ecx

; 144  : 		long GetH()					{ return(h_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+36]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetH@C_Base@@QAEJXZ ENDP				; C_Base::GetH
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cbase.h
;	COMDAT ?GetW@C_Base@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetW@C_Base@@QAEJXZ PROC				; C_Base::GetW, COMDAT
; _this$ = ecx

; 143  : 		long GetW()					{ return(w_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+32]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetW@C_Base@@QAEJXZ ENDP				; C_Base::GetW
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cbase.h
;	COMDAT ?GetID@C_Base@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetID@C_Base@@QAEJXZ PROC				; C_Base::GetID, COMDAT
; _this$ = ecx

; 134  : 		long  GetID()				{ return(ID_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetID@C_Base@@QAEJXZ ENDP				; C_Base::GetID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cbase.h
;	COMDAT ?SetClient@C_Base@@QAEXF@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_client$ = 8						; size = 2
?SetClient@C_Base@@QAEXF@Z PROC				; C_Base::SetClient, COMDAT
; _this$ = ecx

; 98   : 		void SetClient(short client)							{ Client_=client; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _client$[ebp]
	mov	WORD PTR [eax+40], cx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetClient@C_Base@@QAEXF@Z ENDP				; C_Base::SetClient
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\ooutput.h
;	COMDAT ?SetDestRect@O_Output@@QAEXPAUUI95_RECT@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rect$ = 8						; size = 4
?SetDestRect@O_Output@@QAEXPAUUI95_RECT@@@Z PROC	; O_Output::SetDestRect, COMDAT
; _this$ = ecx

; 134  : 		void SetDestRect(UI95_RECT *rect)		{ Dest_=*rect; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 36					; 00000024H
	mov	ecx, DWORD PTR _rect$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetDestRect@O_Output@@QAEXPAUUI95_RECT@@@Z ENDP	; O_Output::SetDestRect
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\ooutput.h
;	COMDAT ?SetSrcRect@O_Output@@QAEXPAUUI95_RECT@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rect$ = 8						; size = 4
?SetSrcRect@O_Output@@QAEXPAUUI95_RECT@@@Z PROC		; O_Output::SetSrcRect, COMDAT
; _this$ = ecx

; 133  : 		void SetSrcRect(UI95_RECT *rect)		{ Src_=*rect; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _rect$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSrcRect@O_Output@@QAEXPAUUI95_RECT@@@Z ENDP		; O_Output::SetSrcRect
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_System_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_System_error_category@std@@UAEPAXI@Z PROC		; std::_System_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_System_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_System_error_category@std@@UAEPAXI@Z ENDP		; std::_System_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_System_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_System_error_category@std@@UAE@XZ PROC		; std::_System_error_category::~_System_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_System_error_category@std@@UAE@XZ ENDP		; std::_System_error_category::~_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::_System_error_category::default_error_condition, COMDAT
; _this$ = ecx

; 641  : 		{	// make error_condition for error code (generic if possible)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 642  : 		if (_Syserror_map(_Errval))

	mov	eax, DWORD PTR __Errval$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@default_er

; 643  : 			return (error_condition(_Errval, generic_category()));

	call	?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@default_er

; 644  : 		else

	jmp	SHORT $LN3@default_er
$LN2@default_er:

; 645  : 			return (error_condition(_Errval, system_category()));

	call	?system_category@std@@YAABVerror_category@1@XZ ; std::system_category
	push	eax
	mov	edx, DWORD PTR __Errval$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@default_er:

; 646  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::_System_error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_System_error_category::message, COMDAT
; _this$ = ecx

; 634  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 635  : 		const char *_Name = _Winerror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Winerror_map@std@@YAPBDH@Z		; std::_Winerror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 636  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 637  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_System_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_System_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_System_error_category@std@@UBEPBDXZ PROC		; std::_System_error_category::name, COMDAT
; _this$ = ecx

; 629  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 630  : 		return ("system");

	mov	eax, OFFSET ??_C@_06FHFOAHML@system?$AA@

; 631  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_System_error_category@std@@UBEPBDXZ ENDP		; std::_System_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_System_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_System_error_category@std@@QAE@XZ PROC		; std::_System_error_category::_System_error_category, COMDAT
; _this$ = ecx

; 624  : 	_System_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_System_error_category@std@@6B@

; 625  : 		{	// default constructor
; 626  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_System_error_category@std@@QAE@XZ ENDP		; std::_System_error_category::_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Iostream_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Iostream_error_category@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iostream_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Iostream_error_category@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Iostream_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Iostream_error_category@std@@UAE@XZ PROC		; std::_Iostream_error_category::~_Iostream_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Iostream_error_category@std@@UAE@XZ ENDP		; std::_Iostream_error_category::~_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT
; _this$ = ecx

; 611  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 612  : 		if (_Errcode == (int)io_errc::stream)

	cmp	DWORD PTR __Errcode$[ebp], 1
	jne	SHORT $LN2@message

; 613  : 			return ("iostream stream error");

	push	OFFSET ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@message

; 614  : 		else

	jmp	SHORT $LN3@message
$LN2@message:

; 615  : 			return (_Generic_error_category::message(_Errcode));

	mov	ecx, DWORD PTR __Errcode$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@message:

; 616  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Iostream_error_category@std@@UBEPBDXZ PROC	; std::_Iostream_error_category::name, COMDAT
; _this$ = ecx

; 606  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 607  : 		return ("iostream");

	mov	eax, OFFSET ??_C@_08LLGCOLLL@iostream?$AA@

; 608  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Iostream_error_category@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Iostream_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iostream_error_category@std@@QAE@XZ PROC		; std::_Iostream_error_category::_Iostream_error_category, COMDAT
; _this$ = ecx

; 601  : 	_Iostream_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Iostream_error_category@std@@6B@

; 602  : 		{	// default constructor
; 603  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iostream_error_category@std@@QAE@XZ ENDP		; std::_Iostream_error_category::_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Generic_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Generic_error_category@std@@UAE@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Generic_error_category@std@@UAE@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 590  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 591  : 		const char *_Name = _Syserror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 592  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 593  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 585  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		return ("generic");

	mov	eax, OFFSET ??_C@_07DCLBNMLN@generic?$AA@

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Generic_error_category@std@@QAE@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT
; _this$ = ecx

; 580  : 	_Generic_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0error_category@std@@QAE@XZ		; std::error_category::error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Generic_error_category@std@@6B@

; 581  : 		{	// default constructor
; 582  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Generic_error_category@std@@QAE@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_condition@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv78 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8error_condition@std@@QBE_NABV01@@Z PROC		; std::error_condition::operator==, COMDAT
; _this$ = ecx

; 376  : 		{	// test if *this == _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 377  : 		return (category() == _Right.category()
; 378  : 			&& value() == _Right.value());

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	mov	ecx, eax
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	cmp	esi, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv78[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv78[ebp]

; 379  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??8error_condition@std@@QBE_NABV01@@Z ENDP		; std::error_condition::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 354  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 356  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 349  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 350  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 351  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 316  : 		{	// construct from error code and category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Cat$[ebp]
	mov	DWORD PTR [edx+4], eax

; 317  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 256  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 257  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 258  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 251  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 252  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 253  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gerror_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gerror_category@std@@UAEPAXI@Z PROC			; std::error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gerror_category@std@@UAEPAXI@Z ENDP			; std::error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv65 = -4						; size = 4
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 184  : 		{	// compare categories for equality

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 185  : 		return (this == &_Right);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv65[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv65[ebp]

; 186  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -4						; size = 4
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 415  : 	{	// test if conditions same for this category

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 416  : 	return (*this == _Code.category() && _Code.value() == _Errval);

	mov	ecx, DWORD PTR __Code$[ebp]
	call	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@equivalent
	mov	ecx, DWORD PTR __Code$[ebp]
	call	?value@error_code@std@@QBEHXZ		; std::error_code::value
	cmp	eax, DWORD PTR __Errval$[ebp]
	jne	SHORT $LN3@equivalent
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN4@equivalent
$LN3@equivalent:
	mov	DWORD PTR tv74[ebp], 0
$LN4@equivalent:
	mov	al, BYTE PTR tv74[ebp]

; 417  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 408  : 	{	// test if error code same condition

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 409  : 	return (default_error_condition(_Errval) == _Cond);

	mov	eax, DWORD PTR __Cond$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	ecx, eax
	call	??8error_condition@std@@QBE_NABV01@@Z	; std::error_condition::operator==

; 410  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 401  : 	{	// make error_condition for error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 402  : 	return (error_condition(_Errval, *this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 403  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 167  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 168  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0error_category@std@@QAE@XZ PROC			; std::error_category::error_category, COMDAT
; _this$ = ecx

; 162  : 	error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 163  : 		{	// default constructor
; 164  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0error_category@std@@QAE@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?system_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?system_category@std@@YAABVerror_category@1@XZ PROC	; std::system_category, COMDAT

; 679  : 	{	// get system_category

	push	ebp
	mov	ebp, esp

; 680  : 	return (_Error_objects<int>::_System_object);

	mov	eax, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object

; 681  : 	}

	pop	ebp
	ret	0
?system_category@std@@YAABVerror_category@1@XZ ENDP	; std::system_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?generic_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?generic_category@std@@YAABVerror_category@1@XZ PROC	; std::generic_category, COMDAT

; 669  : 	{	// get generic_category

	push	ebp
	mov	ebp, esp

; 670  : 	return (_Error_objects<int>::_Generic_object);

	mov	eax, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object

; 671  : 	}

	pop	ebp
	ret	0
?generic_category@std@@YAABVerror_category@1@XZ ENDP	; std::generic_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocale
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC				; std::locale::id::id, COMDAT
; _this$ = ecx

; 74   : 			{	// construct with specified stamp value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx

; 75   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\flight.h
;	COMDAT ?GetLastDirection@FlightClass@@QAEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetLastDirection@FlightClass@@QAEEXZ PROC		; FlightClass::GetLastDirection, COMDAT
; _this$ = ecx

; 103  : 		uchar GetLastDirection (void)				{ return last_direction; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+379]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLastDirection@FlightClass@@QAEEXZ ENDP		; FlightClass::GetLastDirection
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\division.h
;	COMDAT ?GetDivisionType@DivisionClass@@QAEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetDivisionType@DivisionClass@@QAEEXZ PROC		; DivisionClass::GetDivisionType, COMDAT
; _this$ = ecx

; 35   : 		uchar GetDivisionType (void)						{ return type; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDivisionType@DivisionClass@@QAEEXZ ENDP		; DivisionClass::GetDivisionType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\division.h
;	COMDAT ?GetLocation@DivisionClass@@QAEXPAF0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rx$ = 8						; size = 4
_ry$ = 12						; size = 4
?GetLocation@DivisionClass@@QAEXPAF0@Z PROC		; DivisionClass::GetLocation, COMDAT
; _this$ = ecx

; 34   : 		void GetLocation (GridIndex *rx, GridIndex *ry)		{ *rx = x; *ry = y; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _rx$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx]
	mov	WORD PTR [eax], dx
	mov	eax, DWORD PTR _ry$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+2]
	mov	WORD PTR [eax], dx
	mov	esp, ebp
	pop	ebp
	ret	8
?GetLocation@DivisionClass@@QAEXPAF0@Z ENDP		; DivisionClass::GetLocation
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetFirstUnitWP@UnitClass@@QAEPAVWayPointClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFirstUnitWP@UnitClass@@QAEPAVWayPointClass@@XZ PROC	; UnitClass::GetFirstUnitWP, COMDAT
; _this$ = ecx

; 431  : 	WayPoint GetFirstUnitWP()				{ return wp_list; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+244]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFirstUnitWP@UnitClass@@QAEPAVWayPointClass@@XZ ENDP	; UnitClass::GetFirstUnitWP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitNameID@UnitClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitNameID@UnitClass@@QAEHXZ PROC			; UnitClass::GetUnitNameID, COMDAT
; _this$ = ecx

; 381  : 	int GetUnitNameID (void)						{ return name_id; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [eax+226]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitNameID@UnitClass@@QAEHXZ ENDP			; UnitClass::GetUnitNameID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?Final@UnitClass@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Final@UnitClass@@QBEHXZ PROC				; UnitClass::Final, COMDAT
; _this$ = ecx

; 330  : 	int Final () const								{ return (int)unit_flags & U_FINAL; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+196]
	and	eax, 1048576				; 00100000H
	mov	esp, ebp
	pop	ebp
	ret	0
?Final@UnitClass@@QBEHXZ ENDP				; UnitClass::Final
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campaign.h
;	COMDAT ?CampLeaveCriticalSection@@YAXXZ
_TEXT	SEGMENT
?CampLeaveCriticalSection@@YAXXZ PROC			; CampLeaveCriticalSection, COMDAT

; 51   : inline void CampLeaveCriticalSection(){ F4LeaveCriticalSection(campCritical); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ?campCritical@@3PAUF4CSECTIONHANDLE@@A ; campCritical
	push	eax
	call	_F4LeaveCriticalSection
	add	esp, 4
	pop	ebp
	ret	0
?CampLeaveCriticalSection@@YAXXZ ENDP			; CampLeaveCriticalSection
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campaign.h
;	COMDAT ?CampEnterCriticalSection@@YAXXZ
_TEXT	SEGMENT
?CampEnterCriticalSection@@YAXXZ PROC			; CampEnterCriticalSection, COMDAT

; 50   : inline void CampEnterCriticalSection(){ F4EnterCriticalSection(campCritical); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ?campCritical@@3PAUF4CSECTIONHANDLE@@A ; campCritical
	push	eax
	call	_F4EnterCriticalSection
	add	esp, 4
	pop	ebp
	ret	0
?CampEnterCriticalSection@@YAXXZ ENDP			; CampEnterCriticalSection
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetSType@CampBaseClass@@QBEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSType@CampBaseClass@@QBEEXZ PROC			; CampBaseClass::GetSType, COMDAT
; _this$ = ecx

; 290  : 	uchar GetSType (void)	const						{	return (EntityType())->classInfo_[VU_STYPE]; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ ; VuEntity::EntityType
	mov	ecx, 1
	imul	ecx, 3
	mov	al, BYTE PTR [eax+ecx+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSType@CampBaseClass@@QBEEXZ ENDP			; CampBaseClass::GetSType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?GetWPDepartureTime@WayPointClass@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWPDepartureTime@WayPointClass@@QAEKXZ PROC		; WayPointClass::GetWPDepartureTime, COMDAT
; _this$ = ecx

; 203  : 	CampaignTime GetWPDepartureTime()				{ return Depart; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetWPDepartureTime@WayPointClass@@QAEKXZ ENDP		; WayPointClass::GetWPDepartureTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?GetWPArrivalTime@WayPointClass@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWPArrivalTime@WayPointClass@@QAEKXZ PROC		; WayPointClass::GetWPArrivalTime, COMDAT
; _this$ = ecx

; 202  : 	CampaignTime GetWPArrivalTime()					{ return Arrive; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetWPArrivalTime@WayPointClass@@QAEKXZ ENDP		; WayPointClass::GetWPArrivalTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?GetPrevWP@WayPointClass@@QAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPrevWP@WayPointClass@@QAEPAV1@XZ PROC		; WayPointClass::GetPrevWP, COMDAT
; _this$ = ecx

; 176  : 	WayPoint GetPrevWP (void)						{ return PrevWP; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+40]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetPrevWP@WayPointClass@@QAEPAV1@XZ ENDP		; WayPointClass::GetPrevWP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?GetNextWP@WayPointClass@@QAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNextWP@WayPointClass@@QAEPAV1@XZ PROC		; WayPointClass::GetNextWP, COMDAT
; _this$ = ecx

; 175  : 	WayPoint GetNextWP (void)						{ return NextWP; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+44]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNextWP@WayPointClass@@QAEPAV1@XZ ENDP		; WayPointClass::GetNextWP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?GetWPFlags@WayPointClass@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWPFlags@WayPointClass@@QAEKXZ PROC			; WayPointClass::GetWPFlags, COMDAT
; _this$ = ecx

; 173  : 	ulong GetWPFlags (void)							{ return (ulong)Flags; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+28]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetWPFlags@WayPointClass@@QAEKXZ ENDP			; WayPointClass::GetWPFlags
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?GetWPAction@WayPointClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWPAction@WayPointClass@@QAEHXZ PROC			; WayPointClass::GetWPAction, COMDAT
; _this$ = ecx

; 170  : 	int GetWPAction(void)							{ return (int)Action; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+24]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetWPAction@WayPointClass@@QAEHXZ ENDP			; WayPointClass::GetWPAction
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?GetWPTarget@WayPointClass@@QAEPAVCampBaseClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWPTarget@WayPointClass@@QAEPAVCampBaseClass@@XZ PROC ; WayPointClass::GetWPTarget, COMDAT
; _this$ = ecx

; 168  : 	CampEntity GetWPTarget (void)					{ return (CampEntity)vuDatabase->Find(TargetID); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	edx, DWORD PTR [eax+16]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	esp, ebp
	pop	ebp
	ret	0
?GetWPTarget@WayPointClass@@QAEPAVCampBaseClass@@XZ ENDP ; WayPointClass::GetWPTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2275 : 		{	// report an out_of_range error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2276 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN2@Xran:

; 2277 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2270 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2271 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN2@Xlen:

; 2272 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Ptr$1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2253 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2254 : 		if (!_Built)

	movzx	eax, BYTE PTR __Built$[ebp]
	test	eax, eax
	jne	SHORT $LN4@Tidy
	jmp	SHORT $LN3@Tidy
$LN4@Tidy:

; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN3@Tidy

; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Ptr$1[ebp], eax

; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 2260 : 			if (0 < _Newsize)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN1@Tidy

; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$1[ebp]
	push	ecx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Tidy:

; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Ptr$1[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN3@Tidy:

; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2266 : 		_Eos(_Newsize);

	mov	edx, DWORD PTR __Newsize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2267 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2237 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	cmp	DWORD PTR __Ptr$[ebp], 0
	je	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	cmp	DWORD PTR __Ptr$[ebp], eax
	jb	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
$LN2@Inside:

; 2240 : 			return (false);	// don't ask

	xor	al, al
	jmp	SHORT $LN4@Inside

; 2241 : 		else

	jmp	SHORT $LN4@Inside
$LN3@Inside:

; 2242 : 			return (true);

	mov	al, 1
$LN4@Inside:

; 2243 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
tv136 = -12						; size = 4
tv129 = -8						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2224 : 		if (max_size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN6@Grow

; 2225 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN6@Grow:

; 2226 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN5@Grow

; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	jmp	SHORT $LN4@Grow
$LN5@Grow:

; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	movzx	edx, BYTE PTR __Trim$[ebp]
	test	edx, edx
	je	SHORT $LN3@Grow
	cmp	DWORD PTR __Newsize$[ebp], 16		; 00000010H
	jae	SHORT $LN3@Grow

; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jae	SHORT $LN9@Grow
	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv129[ebp], edx
	jmp	SHORT $LN10@Grow
$LN9@Grow:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR tv129[ebp], ecx
$LN10@Grow:
	mov	edx, DWORD PTR tv129[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
	jmp	SHORT $LN4@Grow
$LN3@Grow:

; 2231 : 		else if (_Newsize == 0)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $LN4@Grow

; 2232 : 			_Eos(0);	// new size is zero, just null terminate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN4@Grow:

; 2233 : 		return (0 < _Newsize);	// return true only if more work to do

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN11@Grow
	mov	DWORD PTR tv136[ebp], 1
	jmp	SHORT $LN12@Grow
$LN11@Grow:
	mov	DWORD PTR tv136[ebp], 0
$LN12@Grow:
	mov	al, BYTE PTR tv136[ebp]
$LN8@Grow:

; 2234 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [eax+16], ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 2219 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
tv205 = -48						; size = 4
tv204 = -44						; size = 4
tv203 = -40						; size = 4
tv202 = -36						; size = 4
__Ptr$ = -32						; size = 4
__Newres$ = -28						; size = 4
_this$ = -24						; size = 4
$T2 = -19						; size = 1
$T3 = -18						; size = 1
$T4 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Newres$[ebp], eax

; 2184 : 		if (max_size() < _Newres)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newres$[ebp]
	jae	SHORT $LN9@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx
	jmp	SHORT $LN8@Copy
$LN9@Copy:

; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)

	mov	eax, DWORD PTR __Newres$[ebp]
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	shr	ecx, 1
	cmp	ecx, eax
	ja	SHORT $LN7@Copy
	jmp	SHORT $LN8@Copy
$LN7@Copy:

; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+20]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, esi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], eax
	ja	SHORT $LN5@Copy

; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	shr	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR __Newres$[ebp], eax

; 2191 : 		else

	jmp	SHORT $LN8@Copy
$LN5@Copy:

; 2192 : 			_Newres = max_size();	// settle for max_size()

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	DWORD PTR __Newres$[ebp], eax
$LN8@Copy:

; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv202[ebp], eax
	mov	eax, DWORD PTR __Newres$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR tv202[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv203[ebp], eax
	mov	ecx, DWORD PTR tv203[ebp]
	mov	DWORD PTR __Ptr$[ebp], ecx
	jmp	SHORT $LN12@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2197 : 		_CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], edx

; 2199 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv204[ebp], eax
	mov	ecx, DWORD PTR __Newres$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR tv204[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv205[ebp], eax
	mov	edx, DWORD PTR tv205[ebp]
	mov	DWORD PTR __Ptr$[ebp], edx
	jmp	SHORT $LN14@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2203 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 2204 : 			_CATCH_END

	mov	eax, $LN17@Copy
	ret	0
$LN14@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2
$LN17@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2:

; 2205 : 		_CATCH_END

	mov	eax, $LN19@Copy
	ret	0
$LN12@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3
$LN19@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jbe	SHORT $LN1@Copy

; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements

	mov	eax, DWORD PTR __Oldlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Copy:

; 2210 : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);

	lea	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>

; 2212 : 		this->_Myres = _Newres;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newres$[ebp]
	mov	DWORD PTR [edx+20], eax

; 2213 : 		_Eos(_Oldlen);

	mov	ecx, DWORD PTR __Oldlen$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN11@Copy:

; 2214 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv75 = -12						; size = 4
__Num$ = -8						; size = 4
$T1 = -1						; size = 1
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1737 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1738 : 		size_type _Num = this->_Getal().max_size();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
	mov	DWORD PTR __Num$[ebp], eax

; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$[ebp], 1
	ja	SHORT $LN3@max_size
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	ecx, DWORD PTR __Num$[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv75[ebp], ecx
$LN4@max_size:
	mov	eax, DWORD PTR tv75[ebp]

; 1740 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1732 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1733 : 		return (this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]

; 1734 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$1 = -12					; size = 4
__Ptr$2 = -8						; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1317 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1318 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN4@erase

; 1319 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN4@erase:

; 1320 : 		if (this->_Mysize - _Off <= _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Off$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	ja	SHORT $LN3@erase

; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)

	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
	jmp	SHORT $LN2@erase
$LN3@erase:

; 1322 : 		else if (0 < _Count)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN2@erase

; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Ptr$2[ebp], eax

; 1325 : 			size_type _Newsize = this->_Mysize - _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Newsize$1[ebp], eax

; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	sub	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$2[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$2[ebp]
	push	eax
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 1327 : 			_Eos(_Newsize);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@erase:

; 1328 : 			}
; 1329 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN6@erase:

; 1330 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1309 : 		{	// erase elements [_Off, ...)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1310 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN1@erase

; 1311 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN1@erase:

; 1312 : 		_Eos(_Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1313 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@erase:

; 1314 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1142 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1145 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@assign

; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	jmp	SHORT $LN3@assign
$LN2@assign:

; 1132 : 
; 1133 : 		if (_Grow(_Count))

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@assign

; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1136 : 			_Eos(_Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@assign:

; 1137 : 			}
; 1138 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@assign:

; 1139 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1105 : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $LN5@assign

; 1106 : 			_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN5@assign:

; 1107 : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 1108 : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Num$[ebp]
	jae	SHORT $LN4@assign

; 1109 : 			_Num = _Count;	// trim _Num to size

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
$LN4@assign:

; 1110 : 
; 1111 : 		if (this == &_Right)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@assign

; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	mov	eax, DWORD PTR __Roff$[ebp]
	add	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	mov	ecx, DWORD PTR __Roff$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	jmp	SHORT $LN2@assign
$LN3@assign:

; 1113 : 		else if (_Grow(_Num))

	push	0
	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@assign

; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);

	mov	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1117 : 			_Eos(_Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@assign:

; 1118 : 			}
; 1119 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN7@assign:

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 791  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >

; 792  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 793  : 		assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 794  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 688  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 689  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 690  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 635  : 	_String_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >

; 636  : 		{	// construct allocator from _Al
; 637  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		{	// determine current pointer to buffer for nonmutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 522  : 		return (this->_BUF_SIZE <= this->_Myres
; 523  : 			? _STD addressof(*this->_Bx._Ptr)
; 524  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 525  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		{	// determine current pointer to buffer for mutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 515  : 		return (this->_BUF_SIZE <= this->_Myres
; 516  : 			? _STD addressof(*this->_Bx._Ptr)
; 517  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 518  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 496  : 	_String_val()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 497  : 		{	// initialize values
; 498  : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 499  : 		_Myres = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 500  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 913  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 914  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
	add	esp, 4

; 915  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 886  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 887  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate

; 888  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 875  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 877  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 830  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>

; 831  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 761  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp

; 762  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@D@std@@QBEIXZ	; std::allocator<char>::max_size

; 763  : 		}

	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

	or	eax, -1

; 629  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 590  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8

; 592  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 565  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 563  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 564  : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 565  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 551  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@move
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@move
$LN3@move:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@move:
	mov	eax, DWORD PTR tv69[ebp]

; 554  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 528  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@copy
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@copy
$LN3@copy:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@copy:
	mov	eax, DWORD PTR tv69[ebp]

; 531  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 521  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp
	push	ecx

; 522  : 		return (*_First == 0 ? 0
; 523  : 			: _CSTD strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@length
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN4@length
$LN3@length:
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR tv68[ebp], eax
$LN4@length:
	mov	eax, DWORD PTR tv68[ebp]

; 524  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 65   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 60   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 61   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ PROC	; VuEntity::EntityType, COMDAT
; _this$ = ecx

; 176  : 	VuEntityType *EntityType() const { return const_cast<VuEntityType*>(entityTypePtr_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+112]
	mov	esp, ebp
	pop	ebp
	ret	0
?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ ENDP	; VuEntity::EntityType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?YPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?YPos@VuEntity@@QBEMXZ PROC				; VuEntity::YPos, COMDAT
; _this$ = ecx

; 159  : 	BIG_SCALAR YPos()	const { return pos_.y_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+40]
	mov	esp, ebp
	pop	ebp
	ret	0
?YPos@VuEntity@@QBEMXZ ENDP				; VuEntity::YPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?XPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?XPos@VuEntity@@QBEMXZ PROC				; VuEntity::XPos, COMDAT
; _this$ = ecx

; 158  : 	BIG_SCALAR XPos() const { return pos_.x_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+36]
	mov	esp, ebp
	pop	ebp
	ret	0
?XPos@VuEntity@@QBEMXZ ENDP				; VuEntity::XPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Id@VuEntity@@QBE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?Id@VuEntity@@QBE?AVVU_ID@@XZ PROC			; VuEntity::Id, COMDAT
; _this$ = ecx

; 131  : 	VU_ID Id() const	{ return share_.id_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?Id@VuEntity@@QBE?AVVU_ID@@XZ ENDP			; VuEntity::Id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
;	COMDAT ??9VU_ID@@QBE_NABV0@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -2						; size = 1
tv73 = -1						; size = 1
_rhs$ = 8						; size = 4
??9VU_ID@@QBE_NABV0@@Z PROC				; VU_ID::operator!=, COMDAT
; _this$ = ecx

; 111  : 	bool operator != (const VU_ID &rhs) const { 

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 112  : 		return (
; 113  : 			num_ == rhs.num_ ? 
; 114  : 			(creator_ == rhs.creator_ ? false : true) : 
; 115  : 			true
; 116  : 		); 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN5@operator
	mov	eax, DWORD PTR _rhs$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??8VU_SESSION_ID@@QBEHABV0@@Z		; VU_SESSION_ID::operator==
	test	eax, eax
	je	SHORT $LN3@operator
	mov	BYTE PTR tv73[ebp], 0
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	BYTE PTR tv73[ebp], 1
$LN4@operator:
	mov	cl, BYTE PTR tv73[ebp]
	mov	BYTE PTR tv74[ebp], cl
	jmp	SHORT $LN6@operator
$LN5@operator:
	mov	BYTE PTR tv74[ebp], 1
$LN6@operator:
	mov	al, BYTE PTR tv74[ebp]

; 117  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
??9VU_ID@@QBE_NABV0@@Z ENDP				; VU_ID::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
;	COMDAT ??8VU_ID@@QBE_NABV0@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -2						; size = 1
tv73 = -1						; size = 1
_rhs$ = 8						; size = 4
??8VU_ID@@QBE_NABV0@@Z PROC				; VU_ID::operator==, COMDAT
; _this$ = ecx

; 104  : 	bool operator == (const VU_ID &rhs) const { 

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 105  : 		return (
; 106  : 			num_ == rhs.num_ ? 
; 107  : 			(creator_ == rhs.creator_ ? true : false) : 
; 108  : 			false
; 109  : 		); 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN5@operator
	mov	eax, DWORD PTR _rhs$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??8VU_SESSION_ID@@QBEHABV0@@Z		; VU_SESSION_ID::operator==
	test	eax, eax
	je	SHORT $LN3@operator
	mov	BYTE PTR tv73[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	BYTE PTR tv73[ebp], 0
$LN4@operator:
	mov	cl, BYTE PTR tv73[ebp]
	mov	BYTE PTR tv74[ebp], cl
	jmp	SHORT $LN6@operator
$LN5@operator:
	mov	BYTE PTR tv74[ebp], 0
$LN6@operator:
	mov	al, BYTE PTR tv74[ebp]

; 110  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
??8VU_ID@@QBE_NABV0@@Z ENDP				; VU_ID::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
;	COMDAT ??0VU_ID@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0VU_ID@@QAE@XZ PROC					; VU_ID::VU_ID, COMDAT
; _this$ = ecx

; 100  : 	VU_ID() : num_(0), creator_(0){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0VU_SESSION_ID@@QAE@K@Z		; VU_SESSION_ID::VU_SESSION_ID
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0VU_ID@@QAE@XZ ENDP					; VU_ID::VU_ID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
;	COMDAT ??8VU_SESSION_ID@@QBEHABV0@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_rhs$ = 8						; size = 4
??8VU_SESSION_ID@@QBEHABV0@@Z PROC			; VU_SESSION_ID::operator==, COMDAT
; _this$ = ecx

; 55   : 	int operator == (const VU_SESSION_ID &rhs) const{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return (value_ == rhs.value_ ? TRUE : FALSE); 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv67[ebp], 0
$LN4@operator:
	mov	eax, DWORD PTR tv67[ebp]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
??8VU_SESSION_ID@@QBEHABV0@@Z ENDP			; VU_SESSION_ID::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
;	COMDAT ??0VU_SESSION_ID@@QAE@K@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??0VU_SESSION_ID@@QAE@K@Z PROC				; VU_SESSION_ID::VU_SESSION_ID, COMDAT
; _this$ = ecx

; 53   : 	VU_SESSION_ID(unsigned long value) : value_((unsigned long)value) { }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0VU_SESSION_ID@@QAE@K@Z ENDP				; VU_SESSION_ID::VU_SESSION_ID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
_TEXT	SEGMENT
_x$ = 8							; size = 4
?FloatToInt32@@YAHM@Z PROC				; FloatToInt32

; 179  : {

	push	ebp
	mov	ebp, esp

; 180  : #if WIN32
; 181  :   __asm {
; 182  :     fld dword ptr [x];

	fld	DWORD PTR _x$[ebp]

; 183  :     fistp dword ptr [x];

	fistp	DWORD PTR _x$[ebp]

; 184  :     mov eax,dword ptr [x];

	mov	eax, DWORD PTR _x$[ebp]

; 185  :   }
; 186  : #else 
; 187  : 	return static_cast<int>(x);	
; 188  : #endif
; 189  : }

	pop	ebp
	ret	0
?FloatToInt32@@YAHM@Z ENDP				; FloatToInt32
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
_TEXT	SEGMENT
_x$ = 8							; size = 4
?SqrtSSE@@YAMM@Z PROC					; SqrtSSE

; 91   : static inline float SqrtSSE(float x){ 

	push	ebp
	mov	ebp, esp

; 92   :     __asm 
; 93   :     { 
; 94   :         sqrtss xmm0,x 

	sqrtss	xmm0, DWORD PTR _x$[ebp]

; 95   :         movss x,xmm0 

	movss	XMMWORD PTR _x$[ebp], xmm0

; 96   :     } 
; 97   : 
; 98   :     return x; 

	fld	DWORD PTR _x$[ebp]

; 99   : } 

	pop	ebp
	ret	0
?SqrtSSE@@YAMM@Z ENDP					; SqrtSSE
_TEXT	ENDS
END
