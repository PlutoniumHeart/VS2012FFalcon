; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\UI\SRC\campaign\munition.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?HardPoints@@3JA				; HardPoints
PUBLIC	?PlaneEditList@@3PAJA				; PlaneEditList
PUBLIC	?FirstPlane@@3JA				; FirstPlane
PUBLIC	?PlaneCount@@3JA				; PlaneCount
PUBLIC	?prevtext1@@3HA					; prevtext1
PUBLIC	?gFlightOverloaded@@3JA				; gFlightOverloaded
PUBLIC	?gVCPtr@@3PAUVehicleClassDataType@@A		; gVCPtr
PUBLIC	?gVehID@@3HA					; gVehID
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?AttachBits@@3PAGA				; AttachBits
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?HeliRacks@@3PAURackData@@A			; HeliRacks
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?ACRacks@@3PAURackData@@A			; ACRacks
PUBLIC	?RocketRack@@3PAURackData@@A			; RocketRack
PUBLIC	?Hellfires@@3PAURackData@@A			; Hellfires
PUBLIC	?Maverick@@3PAURackData@@A			; Maverick
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B ; std::ios_base::failure::_Stream_err
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?gStores@@3PAVStoresList@@A			; gStores
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?g3dObjectID@@3FA				; g3dObjectID
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?Object@@3UOBJECTINFO@@A			; Object
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
_BSS	SEGMENT
?HardPoints@@3JA DD 01H DUP (?)				; HardPoints
?PlaneEditList@@3PAJA DD 04H DUP (?)			; PlaneEditList
?FirstPlane@@3JA DD 01H DUP (?)				; FirstPlane
?prevtext1@@3HA DD 01H DUP (?)				; prevtext1
?gFlightOverloaded@@3JA DD 01H DUP (?)			; gFlightOverloaded
?gVCPtr@@3PAUVehicleClassDataType@@A DD 01H DUP (?)	; gVCPtr
?gVehID@@3HA DD	01H DUP (?)				; gVehID
_Validated DW	01H DUP (?)
	ALIGN	4

?gStores@@3PAVStoresList@@A DD 01H DUP (?)		; gStores
?g3dObjectID@@3FA DW 01H DUP (?)			; g3dObjectID
	ALIGN	4

?Object@@3UOBJECTINFO@@A DB 03cH DUP (?)		; Object
_BSS	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B
CONST	SEGMENT
?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B DD 01H ; std::ios_base::failure::_Stream_err
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
CONST	SEGMENT
_NEAR_CLIP DD	03f800000r			; 1
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
_DATA	SEGMENT
?PlaneCount@@3JA DD 04H					; PlaneCount
_RackFlag DD	0ffffffffH
_VisFlag DD	0ffffffffH
?AttachBits@@3PAGA DW 00H				; AttachBits
	DW	01H
	DW	03H
	DW	07H
	DW	0fH
	DW	01fH
	DW	03fH
	DW	07fH
	DW	0ffH
	DW	01ffH
	DW	03ffH
	DW	07ffH
	DW	0fffH
	DW	01fffH
	DW	03fffH
	DW	07fffH
	DW	0ffffH
	ORG $+2
?HeliRacks@@3PAURackData@@A DW 00H			; HeliRacks
	DW	00H
	DW	00H
	DW	0518H
	DW	0518H
	DW	0518H
	DW	0516H
	DW	0516H
	DW	0516H
	DW	0517H
	DW	0517H
	DW	0517H
	DW	01e7H
	DW	01e7H
	DW	01e7H
	DW	01e6H
	DW	01e6H
	DW	01e6H
	DW	01e6H
	DW	01e6H
	DW	01e6H
	ORG $+2
?ACRacks@@3PAURackData@@A DW 00H			; ACRacks
	DW	00H
	DW	00H
	DW	08cH
	DW	08cH
	DW	08cH
	DW	08dH
	DW	0515H
	DW	0519H
	DW	08dH
	DW	08dH
	DW	0519H
	DW	01e6H
	DW	01e6H
	DW	01e6H
	DW	01e6H
	DW	01e6H
	DW	01e6H
	DW	01e6H
	DW	01e6H
	DW	01e6H
	ORG $+2
?RocketRack@@3PAURackData@@A DW 00H			; RocketRack
	DW	00H
	DW	00H
	DW	051aH
	DW	051aH
	DW	051aH
	DW	051bH
	DW	051bH
	DW	051bH
	DW	051cH
	DW	051cH
	DW	051cH
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	ORG $+2
?Hellfires@@3PAURackData@@A DW 00H			; Hellfires
	DW	00H
	DW	00H
	DW	01e7H
	DW	01e7H
	DW	01e7H
	DW	01e7H
	DW	01e7H
	DW	01e7H
	DW	01e7H
	DW	01e7H
	DW	01e7H
	DW	01e7H
	DW	01e7H
	DW	01e7H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	ORG $+2
?Maverick@@3PAURackData@@A DW 00H			; Maverick
	DW	00H
	DW	00H
	DW	0369H
	DW	0369H
	DW	0369H
	DW	0369H
	DW	0369H
	DW	0369H
	DW	0369H
	DW	0369H
	DW	0369H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	ORG $+2
_matrix33_ident DD 03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
_matrix44_ident DD 03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
_DATA	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?Radius@DrawableObject@@QBEMXZ			; DrawableObject::Radius
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	??0id@locale@std@@QAE@I@Z			; std::locale::id::id
PUBLIC	?generic_category@std@@YAABVerror_category@1@XZ	; std::generic_category
PUBLIC	?system_category@std@@YAABVerror_category@1@XZ	; std::system_category
PUBLIC	??0error_category@std@@QAE@XZ			; std::error_category::error_category
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??8error_category@std@@QBE_NABV01@@Z		; std::error_category::operator==
PUBLIC	??_Gerror_category@std@@UAEPAXI@Z		; std::error_category::`scalar deleting destructor'
PUBLIC	?value@error_code@std@@QBEHXZ			; std::error_code::value
PUBLIC	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
PUBLIC	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?value@error_condition@std@@QBEHXZ		; std::error_condition::value
PUBLIC	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
PUBLIC	??8error_condition@std@@QBE_NABV01@@Z		; std::error_condition::operator==
PUBLIC	??0_Generic_error_category@std@@QAE@XZ		; std::_Generic_error_category::_Generic_error_category
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	??1_Generic_error_category@std@@UAE@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	??0_Iostream_error_category@std@@QAE@XZ		; std::_Iostream_error_category::_Iostream_error_category
PUBLIC	?name@_Iostream_error_category@std@@UBEPBDXZ	; std::_Iostream_error_category::name
PUBLIC	?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	??1_Iostream_error_category@std@@UAE@XZ		; std::_Iostream_error_category::~_Iostream_error_category
PUBLIC	??_G_Iostream_error_category@std@@UAEPAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	??0_System_error_category@std@@QAE@XZ		; std::_System_error_category::_System_error_category
PUBLIC	?name@_System_error_category@std@@UBEPBDXZ	; std::_System_error_category::name
PUBLIC	?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message
PUBLIC	?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition
PUBLIC	??1_System_error_category@std@@UAE@XZ		; std::_System_error_category::~_System_error_category
PUBLIC	??_G_System_error_category@std@@UAEPAXI@Z	; std::_System_error_category::`scalar deleting destructor'
PUBLIC	?GetNTextureSet@ObjectInstance@@QAEHXZ		; ObjectInstance::GetNTextureSet
PUBLIC	?SetTextureSet@DrawableBSP@@QAEXK@Z		; DrawableBSP::SetTextureSet
PUBLIC	?GetNTextureSet@DrawableBSP@@QAEHXZ		; DrawableBSP::GetNTextureSet
PUBLIC	??8VU_SESSION_ID@@QBEHABV0@@Z			; VU_SESSION_ID::operator==
PUBLIC	??8VU_ID@@QBE_NABV0@@Z				; VU_ID::operator==
PUBLIC	?Id@VuEntity@@QBE?AVVU_ID@@XZ			; VuEntity::Id
PUBLIC	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
PUBLIC	__tcsclen
PUBLIC	?CampEnterCriticalSection@@YAXXZ		; CampEnterCriticalSection
PUBLIC	?CampLeaveCriticalSection@@YAXXZ		; CampLeaveCriticalSection
PUBLIC	?GetWPDepartureTime@WayPointClass@@QAEKXZ	; WayPointClass::GetWPDepartureTime
PUBLIC	??0LoadoutStruct@@QAE@XZ			; LoadoutStruct::LoadoutStruct
PUBLIC	??4LoadoutStruct@@QAEABU0@ABU0@@Z		; LoadoutStruct::operator=
PUBLIC	?GetFirstUnitWP@UnitClass@@QAEPAVWayPointClass@@XZ ; UnitClass::GetFirstUnitWP
PUBLIC	?GetLoadout@FlightClass@@QAEPAULoadoutStruct@@XZ ; FlightClass::GetLoadout
PUBLIC	?GetLoadouts@FlightClass@@QAEEXZ		; FlightClass::GetLoadouts
PUBLIC	?SetGroup@C_Base@@QAEXJ@Z			; C_Base::SetGroup
PUBLIC	?SetClient@C_Base@@QAEXF@Z			; C_Base::SetClient
PUBLIC	?GetID@C_Base@@QAEJXZ				; C_Base::GetID
PUBLIC	?GetGroup@C_Base@@QAEJXZ			; C_Base::GetGroup
PUBLIC	?GetH@C_Base@@QAEJXZ				; C_Base::GetH
PUBLIC	?GetParent@C_Base@@QAEPAVC_Window@@XZ		; C_Base::GetParent
PUBLIC	?GetTextID@C_ListBox@@QAEJXZ			; C_ListBox::GetTextID
PUBLIC	?SetTimerCallback@C_Text@@QAEXP6AHPAVC_Base@@@Z@Z ; C_Text::SetTimerCallback
PUBLIC	?GetControlList@C_Window@@QAEPAUControlListStr@@XZ ; C_Window::GetControlList
PUBLIC	?GetID@C_Window@@QAEJXZ				; C_Window::GetID
PUBLIC	?GetPlayerName@FalconSessionEntity@@QAEPADXZ	; FalconSessionEntity::GetPlayerName
PUBLIC	?GetPlayerFlightID@FalconSessionEntity@@QBE?AVVU_ID@@XZ ; FalconSessionEntity::GetPlayerFlightID
PUBLIC	?GetPilotSlot@FalconSessionEntity@@QBEEXZ	; FalconSessionEntity::GetPilotSlot
PUBLIC	??0StoresList@@QAE@XZ				; StoresList::StoresList
PUBLIC	??1StoresList@@QAE@XZ				; StoresList::~StoresList
PUBLIC	?Find@StoresList@@QAEPAUStoresStr@@J@Z		; StoresList::Find
PUBLIC	?Add@StoresList@@QAEXPAUStoresStr@@J@Z		; StoresList::Add
PUBLIC	?Sort@StoresList@@QAEXXZ			; StoresList::Sort
PUBLIC	?GetFirst@StoresList@@QAEPAUStoresStr@@J@Z	; StoresList::GetFirst
PUBLIC	?GetNext@StoresList@@QAEPAUStoresStr@@XZ	; StoresList::GetNext
PUBLIC	??_GStoresList@@QAEPAXI@Z			; StoresList::`scalar deleting destructor'
PUBLIC	??0?$VuBin@VSimWeaponClass@@@@QAE@PAVSimWeaponClass@@@Z ; VuBin<SimWeaponClass>::VuBin<SimWeaponClass>
PUBLIC	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ		; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>
PUBLIC	??4?$VuBin@VSimWeaponClass@@@@QAEABV0@ABV0@@Z	; VuBin<SimWeaponClass>::operator=
PUBLIC	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ		; VuBin<SimWeaponClass>::operator bool
PUBLIC	??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::operator->
PUBLIC	?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::get
PUBLIC	?reset@?$VuBin@VSimWeaponClass@@@@QAEXPAVSimWeaponClass@@@Z ; VuBin<SimWeaponClass>::reset
PUBLIC	?SetHPId@BasicWeaponStation@@QAEXH@Z		; BasicWeaponStation::SetHPId
PUBLIC	??0RailInfo@@QAE@XZ				; RailInfo::RailInfo
PUBLIC	??1RailInfo@@QAE@XZ				; RailInfo::~RailInfo
PUBLIC	??0RailList@@QAE@XZ				; RailList::RailList
PUBLIC	??1RailList@@QAE@XZ				; RailList::~RailList
PUBLIC	?GetNextOnRail@SimWeaponClass@@QAEPAV1@XZ	; SimWeaponClass::GetNextOnRail
PUBLIC	?SetRackSlot@SimWeaponClass@@QAEXH@Z		; SimWeaponClass::SetRackSlot
PUBLIC	?MakeStoresList@@YAXPAVC_Window@@J@Z		; MakeStoresList
PUBLIC	?SetCurrentLoadout@@YAXXZ			; SetCurrentLoadout
PUBLIC	?TallyStores@@YAXXZ				; TallyStores
PUBLIC	?UpdateInventoryCount@@YAXXZ			; UpdateInventoryCount
PUBLIC	?TotalAvailable@@YAFF@Z				; TotalAvailable
PUBLIC	?PlaceLoadedWeapons@@YAXPAULoadoutStruct@@@Z	; PlaceLoadedWeapons
PUBLIC	?GetJRackAndWeapon@@YAHPAUVehicleClassDataType@@PAUFalcon4EntityClassType@@FFFPAVRailInfo@@@Z ; GetJRackAndWeapon
PUBLIC	?FindRackIndex@@YAFF@Z				; FindRackIndex
PUBLIC	?ConvertToIndex@@YAXQAURackData@@@Z		; ConvertToIndex
PUBLIC	?ValidateRackData@@YAXXZ			; ValidateRackData
PUBLIC	?ClearHardPoint@@YAXJJJPAVRailInfo@@@Z		; ClearHardPoint
PUBLIC	?ClearAllHardPointBSPs@@YAXXZ			; ClearAllHardPointBSPs
PUBLIC	?LoadHardPoint@@YAXJJJPAVRailInfo@@@Z		; LoadHardPoint
PUBLIC	?LoadHardPoint@@YAXJJJ@Z			; LoadHardPoint
PUBLIC	?LoadFlight@@YAXVVU_ID@@@Z			; LoadFlight
PUBLIC	?ChangeSkin@@YAXXZ				; ChangeSkin
PUBLIC	?SetPlaneToArm@@YAXJH@Z				; SetPlaneToArm
PUBLIC	?MuniTimeCB@@YAHPAVC_Base@@@Z			; MuniTimeCB
PUBLIC	?DetermineWeight@@YAXVVU_ID@@@Z			; DetermineWeight
PUBLIC	?SetupMunitionsWindow@@YAXVVU_ID@@@Z		; SetupMunitionsWindow
PUBLIC	?UpdateStoresTally@@YAXPAVC_Window@@@Z		; UpdateStoresTally
PUBLIC	?InternalArmPlaneCB@@YAXJFPAVC_Base@@@Z		; InternalArmPlaneCB
PUBLIC	?ArmPlaneCB@@YAXJFPAVC_Base@@@Z			; ArmPlaneCB
PUBLIC	?SetupLoadoutDisplay@@YAXXZ			; SetupLoadoutDisplay
PUBLIC	?RestoreStores@@YAXPAVC_Window@@@Z		; RestoreStores
PUBLIC	?ClearStores@@YAXPAVC_Window@@@Z		; ClearStores
PUBLIC	?UseStores@@YAXXZ				; UseStores
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_7error_category@std@@6B@			; std::error_category::`vftable'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_C@_07DCLBNMLN@generic?$AA@			; `string'
PUBLIC	??_C@_0O@BFJCFAAK@unknown?5error?$AA@		; `string'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream?$AA@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	; `string'
PUBLIC	??_7_System_error_category@std@@6B@		; std::_System_error_category::`vftable'
PUBLIC	??_C@_06FHFOAHML@system?$AA@			; `string'
PUBLIC	?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
PUBLIC	?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
PUBLIC	?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
PUBLIC	?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
PUBLIC	?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
PUBLIC	?gLoadoutFlightID@@3VVU_ID@@A			; gLoadoutFlightID
PUBLIC	?gCurStores@@3PAULoadoutStruct@@A		; gCurStores
PUBLIC	?gOriginalStores@@3PAULoadoutStruct@@A		; gOriginalStores
PUBLIC	?gCurRails@@3PAURailList@@A			; gCurRails
PUBLIC	??_C@_01CLKCMJKC@?5?$AA@			; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs?$AA@			; `string'
PUBLIC	??_C@_03GNGPFOOL@?$CF1d?$AA@			; `string'
PUBLIC	??_C@_05CGHOGGKE@?$CF5?41f?$AA@			; `string'
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	?id@?$numpunct@_W@std@@2V0locale@2@A		; std::numpunct<wchar_t>::id
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_R4error_category@std@@6B@			; std::error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error_category@std@@6B@		; std::_System_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_System_error_category@std@@@8		; std::_System_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_System_error_category@std@@8		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error_category@std@@8		; std::_System_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error_category@std@@8	; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
PUBLIC	__real@3f800000
PUBLIC	__real@40400000
PUBLIC	__real@41200000
PUBLIC	__real@41a00000
PUBLIC	__real@43340000
PUBLIC	__real@c0a00000
PUBLIC	__real@c1200000
EXTRN	??_L@YGXPAXIHP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_strcpy:PROC
EXTRN	_strlen:PROC
EXTRN	_memmove:PROC
EXTRN	_sprintf:PROC
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	??_Eerror_category@std@@UAEPAXI@Z:PROC		; std::error_category::`vector deleting destructor'
EXTRN	?_Syserror_map@std@@YAPBDH@Z:PROC		; std::_Syserror_map
EXTRN	?_Winerror_map@std@@YAPBDH@Z:PROC		; std::_Winerror_map
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_E_System_error_category@std@@UAEPAXI@Z:PROC	; std::_System_error_category::`vector deleting destructor'
EXTRN	?SetTextureSet@ObjectInstance@@QAEXH@Z:PROC	; ObjectInstance::SetTextureSet
EXTRN	?Update@DrawableBSP@@QAEXPBUTpoint@@PBUTrotation@@@Z:PROC ; DrawableBSP::Update
EXTRN	?AttachChild@DrawableBSP@@QAEXPAV1@H@Z:PROC	; DrawableBSP::AttachChild
EXTRN	?DetachChild@DrawableBSP@@QAEXPAV1@H@Z:PROC	; DrawableBSP::DetachChild
EXTRN	?SetSwitchMask@DrawableBSP@@QAEXHK@Z:PROC	; DrawableBSP::SetSwitchMask
EXTRN	?VuReferenceEntity@@YAHPAVVuEntity@@@Z:PROC	; VuReferenceEntity
EXTRN	?VuDeReferenceEntity@@YAHPAVVuEntity@@@Z:PROC	; VuDeReferenceEntity
EXTRN	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z:PROC ; VuDatabase::Find
EXTRN	_F4EnterCriticalSection:PROC
EXTRN	_F4LeaveCriticalSection:PROC
EXTRN	__mbslen:PROC
EXTRN	?MapVisId@@YAKK@Z:PROC				; MapVisId
EXTRN	?GetVehicleClassData@@YAPAUVehicleClassDataType@@H@Z:PROC ; GetVehicleClassData
EXTRN	?GetVehicleID@UnitClass@@QAEFH@Z:PROC		; UnitClass::GetVehicleID
EXTRN	?GetTotalVehicles@UnitClass@@QAEHXZ:PROC	; UnitClass::GetTotalVehicles
EXTRN	?GetTimeString@@YAPADKQADH@Z:PROC		; GetTimeString
EXTRN	?FindUnit@@YAPAVUnitClass@@VVU_ID@@@Z:PROC	; FindUnit
EXTRN	?GetCallsign@@YAXPAVFlightClass@@PAD@Z:PROC	; GetCallsign
EXTRN	?GetAvailableStores@SquadronClass@@QAEEH@Z:PROC	; SquadronClass::GetAvailableStores
EXTRN	?UpdateSquadronStores@SquadronClass@@QAEXQAFQAEHH@Z:PROC ; SquadronClass::UpdateSquadronStores
EXTRN	?PreMissionEval@MissionEvaluationClass@@QAEHPAVFlightClass@@E@Z:PROC ; MissionEvaluationClass::PreMissionEval
EXTRN	?GetPilotName@MissionEvaluationClass@@QAEHHPAD@Z:PROC ; MissionEvaluationClass::GetPilotName
EXTRN	?GetListEntryWeapon@@YAHHH@Z:PROC		; GetListEntryWeapon
EXTRN	?GetListEntryWeapons@@YAHHH@Z:PROC		; GetListEntryWeapons
EXTRN	?GetString@C_String@@QAEPADJ@Z:PROC		; C_String::GetString
EXTRN	?UI_Enter@@YAPAUF4CSECTIONHANDLE@@PAVC_Window@@@Z:PROC ; UI_Enter
EXTRN	?UI_Leave@@YAXPAUF4CSECTIONHANDLE@@@Z:PROC	; UI_Leave
EXTRN	?SetUserNumber@C_Base@@QAEXJJ@Z:PROC		; C_Base::SetUserNumber
EXTRN	?GetUserNumber@C_Base@@QAEJJ@Z:PROC		; C_Base::GetUserNumber
EXTRN	??0C_Button@@QAE@XZ:PROC			; C_Button::C_Button
EXTRN	?Setup@C_Button@@QAEXJFJJ@Z:PROC		; C_Button::Setup
EXTRN	?SetBackImage@C_Button@@QAEXJ@Z:PROC		; C_Button::SetBackImage
EXTRN	?SetAllLabel@C_Button@@QAEXPAD@Z:PROC		; C_Button::SetAllLabel
EXTRN	?SetImage@C_Button@@QAEXFJ@Z:PROC		; C_Button::SetImage
EXTRN	??0C_Text@@QAE@XZ:PROC				; C_Text::C_Text
EXTRN	?SetFGColor@C_Text@@QAEXK@Z:PROC		; C_Text::SetFGColor
EXTRN	?SetFixedWidth@C_Text@@QAEXJ@Z:PROC		; C_Text::SetFixedWidth
EXTRN	??0C_Line@@QAE@XZ:PROC				; C_Line::C_Line
EXTRN	?Setup@C_Line@@QAEXJF@Z:PROC			; C_Line::Setup
EXTRN	?SetColor@C_Line@@QAEXK@Z:PROC			; C_Line::SetColor
EXTRN	?ScanClientArea@C_Window@@QAEXJ@Z:PROC		; C_Window::ScanClientArea
EXTRN	?ScanClientAreas@C_Window@@QAEXXZ:PROC		; C_Window::ScanClientAreas
EXTRN	?AddControl@C_Window@@QAEXPAVC_Base@@@Z:PROC	; C_Window::AddControl
EXTRN	?EnableCluster@C_Window@@QAEXJ@Z:PROC		; C_Window::EnableCluster
EXTRN	?DisableCluster@C_Window@@QAEXJ@Z:PROC		; C_Window::DisableCluster
EXTRN	?RefreshWindow@C_Window@@QAEXXZ:PROC		; C_Window::RefreshWindow
EXTRN	?RefreshClient@C_Window@@QAEXJ@Z:PROC		; C_Window::RefreshClient
EXTRN	?FindControl@C_Window@@QAEPAVC_Base@@J@Z:PROC	; C_Window::FindControl
EXTRN	?EnterCritical@C_Handler@@QAEXXZ:PROC		; C_Handler::EnterCritical
EXTRN	?LeaveCritical@C_Handler@@QAEXXZ:PROC		; C_Handler::LeaveCritical
EXTRN	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z:PROC ; C_Handler::FindWindowA
EXTRN	?FindCampaignPlayer@UIComms@@QAEPAVFalconSessionEntity@@VVU_ID@@E@Z:PROC ; UIComms::FindCampaignPlayer
EXTRN	?LoadBSP@C_3dViewer@@QAEPAUUI_BSPList@@JHH@Z:PROC ; C_3dViewer::LoadBSP
EXTRN	?Remove@C_3dViewer@@QAEHJ@Z:PROC		; C_3dViewer::Remove
EXTRN	?Find@C_3dViewer@@QAEPAUUI_BSPList@@J@Z:PROC	; C_3dViewer::Find
EXTRN	?Cleanup@StoresList@@QAEXXZ:PROC		; StoresList::Cleanup
EXTRN	?Create@StoresList@@QAEPAUStoresStr@@JPADJJJMF@Z:PROC ; StoresList::Create
EXTRN	?Add@StoresList@@QAEXPAUStoresStr@@PAPAU2@@Z:PROC ; StoresList::Add
EXTRN	?Sort@StoresList@@QAEXJ@Z:PROC			; StoresList::Sort
EXTRN	??0AdvancedWeaponStation@@QAE@XZ:PROC		; AdvancedWeaponStation::AdvancedWeaponStation
EXTRN	??1AdvancedWeaponStation@@UAE@XZ:PROC		; AdvancedWeaponStation::~AdvancedWeaponStation
EXTRN	?SetParentDrawPtr@AdvancedWeaponStation@@QAEXPAVDrawableBSP@@@Z:PROC ; AdvancedWeaponStation::SetParentDrawPtr
EXTRN	??0SimWeaponClass@@QAE@H@Z:PROC			; SimWeaponClass::SimWeaponClass
EXTRN	?DeleteGroupList@@YAXJ@Z:PROC			; DeleteGroupList
EXTRN	?GetFlightStatusID@@YAFPAVFlightClass@@@Z:PROC	; GetFlightStatusID
EXTRN	?Uni_Float@@YAXPAD@Z:PROC			; Uni_Float
EXTRN	?PositandOrientSetData@@YAXMMMMMMPAUTpoint@@PAUTrotation@@@Z:PROC ; PositandOrientSetData
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?vuDatabase@@3PAVVuDatabase@@A:DWORD		; vuDatabase
EXTRN	?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A:DWORD ; vuLocalSessionEntity
EXTRN	?vuxGameTime@@3KA:DWORD				; vuxGameTime
EXTRN	?NumEntities@@3HA:DWORD				; NumEntities
EXTRN	?FalconNullId@@3VVU_ID@@A:QWORD			; FalconNullId
EXTRN	?campCritical@@3PAUF4CSECTIONHANDLE@@A:DWORD	; campCritical
EXTRN	?TheCampaign@@3VCampaignClass@@A:BYTE		; TheCampaign
EXTRN	?WeaponDataTable@@3PAUWeaponClassDataType@@A:DWORD ; WeaponDataTable
EXTRN	?SimACDefTable@@3PAUSimACDefType@@A:DWORD	; SimACDefTable
EXTRN	?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A:DWORD ; Falcon4ClassTable
EXTRN	?gStringMgr@@3PAVC_String@@A:DWORD		; gStringMgr
EXTRN	?gCommsMgr@@3PAVUIComms@@A:DWORD		; gCommsMgr
EXTRN	?gUIViewer@@3PAVC_3dViewer@@A:DWORD		; gUIViewer
EXTRN	?aeroDataset@@3PAVAeroDataSet@@A:DWORD		; aeroDataset
EXTRN	?g_nLoadoutTimeLimit@@3HA:DWORD			; g_nLoadoutTimeLimit
EXTRN	?gMainHandler@@3PAVC_Handler@@A:DWORD		; gMainHandler
EXTRN	?set3DTexture@@3HA:DWORD			; set3DTexture
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
_BSS	SEGMENT
?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Generic_object
_BSS	ENDS
;	COMDAT ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
_BSS	SEGMENT
?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Iostream_object
_BSS	ENDS
;	COMDAT ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
_BSS	SEGMENT
?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_System_object
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
_BSS	ENDS
_BSS	SEGMENT
	ALIGN	8

?gLoadoutFlightID@@3VVU_ID@@A DQ 01H DUP (?)		; gLoadoutFlightID
?gCurStores@@3PAULoadoutStruct@@A DB 0f0H DUP (?)	; gCurStores
?gOriginalStores@@3PAULoadoutStruct@@A DB 0f0H DUP (?)	; gOriginalStores
?gCurRails@@3PAURailList@@A DB 02800H DUP (?)		; gCurRails
_Quantity DD	080H DUP (?)
_QuantityCount DD 04H DUP (?)
__MAX_WEIGHT_ DD 04H DUP (?)
__CLEAN_WEIGHT_ DD 04H DUP (?)
__DRAG_FACTOR_ DD 04H DUP (?)
__MUNITIONS_WEIGHT_ DD 04H DUP (?)
__FUEL_WEIGHT_ DD 04H DUP (?)
__CURRENT_WEIGHT_ DD 04H DUP (?)
_objPos	DB	0cH DUP (?)
_objRot	DB	024H DUP (?)
_LastCount DW	040H DUP (?)
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@_W@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@_W@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<wchar_t>::id
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __real@c1200000
CONST	SEGMENT
__real@c1200000 DD 0c1200000r			; -10
CONST	ENDS
;	COMDAT __real@c0a00000
CONST	SEGMENT
__real@c0a00000 DD 0c0a00000r			; -5
CONST	ENDS
;	COMDAT __real@43340000
CONST	SEGMENT
__real@43340000 DD 043340000r			; 180
CONST	ENDS
;	COMDAT __real@41a00000
CONST	SEGMENT
__real@41a00000 DD 041a00000r			; 20
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error_category@std@@8 DD FLAT:??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error_category@std@@8
rdata$r	SEGMENT
??_R2_System_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error_category@std@@8
rdata$r	SEGMENT
??_R3_System_error_category@std@@8 DD 00H		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_System_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_System_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_System_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_System_error_category@std@@6B@ DD 00H		; std::_System_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error_category@std@@@8
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD FLAT:??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 00H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category@std@@@8
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
_DATA	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4error_category@std@@6B@
rdata$r	SEGMENT
??_R4error_category@std@@6B@ DD 00H			; std::error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVerror_category@std@@@8
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_05CGHOGGKE@?$CF5?41f?$AA@
CONST	SEGMENT
??_C@_05CGHOGGKE@?$CF5?41f?$AA@ DB '%5.1f', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03GNGPFOOL@?$CF1d?$AA@
CONST	SEGMENT
??_C@_03GNGPFOOL@?$CF1d?$AA@ DB '%1d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs?$AA@ DB '%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5?$AA@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5?$AA@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system?$AA@
CONST	SEGMENT
??_C@_06FHFOAHML@system?$AA@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_System_error_category@std@@6B@
CONST	SEGMENT
??_7_System_error_category@std@@6B@ DD FLAT:??_R4_System_error_category@std@@6B@ ; std::_System_error_category::`vftable'
	DD	FLAT:??_E_System_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_System_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ DB 'iostream stream error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream?$AA@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream?$AA@ DB 'iostream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DD FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DD	FLAT:??_E_Iostream_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
CONST	SEGMENT
??_C@_0O@BFJCFAAK@unknown?5error?$AA@ DB 'unknown error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic?$AA@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic?$AA@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7error_category@std@@6B@
CONST	SEGMENT
??_7error_category@std@@6B@ DD FLAT:??_R4error_category@std@@6B@ ; std::error_category::`vftable'
	DD	FLAT:??_Eerror_category@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
__ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
xdata$x	SEGMENT
__unwindtable$?UseStores@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?UseStores@@YAXXZ$0
__unwindtable$?LoadFlight@@YAXVVU_ID@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LoadFlight@@YAXVVU_ID@@@Z$0
__unwindtable$?ClearHardPoint@@YAXJJJPAVRailInfo@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ClearHardPoint@@YAXJJJPAVRailInfo@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ClearHardPoint@@YAXJJJPAVRailInfo@@@Z$1
__unwindtable$?LoadHardPoint@@YAXJJJPAVRailInfo@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LoadHardPoint@@YAXJJJPAVRailInfo@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadHardPoint@@YAXJJJPAVRailInfo@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LoadHardPoint@@YAXJJJPAVRailInfo@@@Z$2
__ehfuncinfo$?UseStores@@YAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?UseStores@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?LoadFlight@@YAXVVU_ID@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?LoadFlight@@YAXVVU_ID@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?LoadHardPoint@@YAXJJJPAVRailInfo@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?LoadHardPoint@@YAXJJJPAVRailInfo@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?ClearHardPoint@@YAXJJJPAVRailInfo@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?ClearHardPoint@@YAXJJJPAVRailInfo@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?MakeStoresList@@YAXPAVC_Window@@J@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?MakeStoresList@@YAXPAVC_Window@@J@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?MakeStoresList@@YAXPAVC_Window@@J@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?MakeStoresList@@YAXPAVC_Window@@J@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?MakeStoresList@@YAXPAVC_Window@@J@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?MakeStoresList@@YAXPAVC_Window@@J@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?MakeStoresList@@YAXPAVC_Window@@J@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?MakeStoresList@@YAXPAVC_Window@@J@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?MakeStoresList@@YAXPAVC_Window@@J@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?MakeStoresList@@YAXPAVC_Window@@J@Z$6
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_gLoadoutFlightID$initializer$ DD FLAT:??__EgLoadoutFlightID@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_gCurStores$initializer$ DD FLAT:??__EgCurStores@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_gOriginalStores$initializer$ DD FLAT:??__EgOriginalStores@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_gCurRails$initializer$ DD FLAT:??__EgCurRails@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Generic_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Iostream_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_System_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@D@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<char>::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@_W@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<wchar_t>::id$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 621  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();
; 624  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
_this$ = -24						; size = 4
tv73 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR __V0$[ebp]
	push	ecx
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<wchar_t>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@_W@std@@2V0locale@2@A ; std::numpunct<wchar_t>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<wchar_t>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<char>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<char>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 755  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp

; 756  : 		{	// destroy object at _Ptr
; 757  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>

; 758  : 		}

	pop	ebp
	ret	0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
	pop	ebp
	ret	0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	ebp
	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??1_System_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_System_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??0_System_error_category@std@@QAE@XZ	; std::_System_error_category::_System_error_category
	push	OFFSET ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_System_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??1_Iostream_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??0_Iostream_error_category@std@@QAE@XZ	; std::_Iostream_error_category::_Iostream_error_category
	push	OFFSET ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??1_Generic_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	push	OFFSET ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], -1
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 85   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 89   : 	}

	pop	ebp
	ret	0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 907  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
	add	esp, 8

; 910  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
	add	esp, 12					; 0000000cH
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\munition.cpp
_TEXT	SEGMENT
$T2 = -68						; size = 8
$T3 = -60						; size = 4
tv198 = -56						; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
_loads$ = -44						; size = 4
_sq$ = -40						; size = 4
_newloadout$ = -36					; size = 4
_loadout$ = -32						; size = 4
_ac$ = -28						; size = 4
_flt$ = -24						; size = 4
_hp$ = -20						; size = 4
_i$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?UseStores@@YAXXZ PROC					; UseStores

; 2703 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?UseStores@@YAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 56					; 00000038H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 2704 : 	Flight flt;
; 2705 : 	int i,ac,hp,loads;
; 2706 : 	Squadron sq;
; 2707 : 	LoadoutStruct	*loadout,*newloadout;
; 2708 : 	
; 2709 : 	flt=(Flight)vuDatabase->Find(gLoadoutFlightID);

	mov	eax, DWORD PTR ?gLoadoutFlightID@@3VVU_ID@@A+4
	push	eax
	mov	ecx, DWORD PTR ?gLoadoutFlightID@@3VVU_ID@@A
	push	ecx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _flt$[ebp], eax

; 2710 : 	if (flt == NULL)

	cmp	DWORD PTR _flt$[ebp], 0
	jne	SHORT $LN25@UseStores

; 2711 : 		return;

	jmp	$LN26@UseStores
$LN25@UseStores:

; 2712 : 
; 2713 : 	sq = (Squadron) flt->GetUnitSquadron();

	mov	edx, DWORD PTR _flt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _flt$[ebp]
	mov	edx, DWORD PTR [eax+696]
	call	edx
	mov	DWORD PTR _sq$[ebp], eax

; 2714 : 	if (!sq)

	cmp	DWORD PTR _sq$[ebp], 0
	jne	SHORT $LN24@UseStores

; 2715 : 		return;

	jmp	$LN26@UseStores
$LN24@UseStores:

; 2716 : 
; 2717 : 	ac = flt->GetTotalVehicles();

	mov	ecx, DWORD PTR _flt$[ebp]
	call	?GetTotalVehicles@UnitClass@@QAEHXZ	; UnitClass::GetTotalVehicles
	mov	DWORD PTR _ac$[ebp], eax

; 2718 : 	loadout = flt->GetLoadout();

	mov	ecx, DWORD PTR _flt$[ebp]
	call	?GetLoadout@FlightClass@@QAEPAULoadoutStruct@@XZ ; FlightClass::GetLoadout
	mov	DWORD PTR _loadout$[ebp], eax

; 2719 : 	loads = flt->GetLoadouts();

	mov	ecx, DWORD PTR _flt$[ebp]
	call	?GetLoadouts@FlightClass@@QAEEXZ	; FlightClass::GetLoadouts
	movzx	eax, al
	mov	DWORD PTR _loads$[ebp], eax

; 2720 : 	if (loads < 1)

	cmp	DWORD PTR _loads$[ebp], 1
	jge	SHORT $LN23@UseStores

; 2721 : 		return;

	jmp	$LN26@UseStores
$LN23@UseStores:

; 2722 : 
; 2723 : 	// KCK: Need to rationalize the loadout structure
; 2724 : 	for (i=0; i<ac; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN22@UseStores
$LN21@UseStores:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN22@UseStores:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _ac$[ebp]
	jge	SHORT $LN20@UseStores

; 2725 : 		{
; 2726 : 		for (hp=0; hp<HARDPOINT_MAX; hp++)

	mov	DWORD PTR _hp$[ebp], 0
	jmp	SHORT $LN19@UseStores
$LN18@UseStores:
	mov	eax, DWORD PTR _hp$[ebp]
	add	eax, 1
	mov	DWORD PTR _hp$[ebp], eax
$LN19@UseStores:
	cmp	DWORD PTR _hp$[ebp], 16			; 00000010H
	jge	SHORT $LN17@UseStores

; 2727 : 			{
; 2728 : 			if (!gCurStores[i].WeaponCount[hp])

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _hp$[ebp]
	movzx	eax, BYTE PTR ?gCurStores@@3PAULoadoutStruct@@A[ecx+edx+32]
	test	eax, eax
	jne	SHORT $LN16@UseStores

; 2729 : 				gCurStores[i].WeaponID[hp] = 0;

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 48					; 00000030H
	xor	edx, edx
	mov	eax, DWORD PTR _hp$[ebp]
	mov	WORD PTR ?gCurStores@@3PAULoadoutStruct@@A[ecx+eax*2], dx
$LN16@UseStores:

; 2730 : 			}

	jmp	SHORT $LN18@UseStores
$LN17@UseStores:

; 2731 : 		}

	jmp	SHORT $LN21@UseStores
$LN20@UseStores:

; 2732 : 
; 2733 : 	CampEnterCriticalSection();

	call	?CampEnterCriticalSection@@YAXXZ	; CampEnterCriticalSection

; 2734 : 
; 2735 : 	// Notify the squadron that we're returning some weapons
; 2736 : 	if (loads < ac)

	mov	ecx, DWORD PTR _loads$[ebp]
	cmp	ecx, DWORD PTR _ac$[ebp]
	jge	SHORT $LN15@UseStores

; 2737 : 		sq->UpdateSquadronStores (loadout[0].WeaponID, loadout[0].WeaponCount, 0, -ac);

	mov	edx, DWORD PTR _ac$[ebp]
	neg	edx
	push	edx
	push	0
	mov	eax, 48					; 00000030H
	imul	eax, 0
	mov	ecx, DWORD PTR _loadout$[ebp]
	lea	edx, DWORD PTR [ecx+eax+32]
	push	edx
	mov	eax, 48					; 00000030H
	imul	eax, 0
	add	eax, DWORD PTR _loadout$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sq$[ebp]
	call	?UpdateSquadronStores@SquadronClass@@QAEXQAFQAEHH@Z ; SquadronClass::UpdateSquadronStores

; 2738 : 	else

	jmp	SHORT $LN14@UseStores
$LN15@UseStores:

; 2739 : 		{
; 2740 : 		for (i=0; i<loads; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN13@UseStores
$LN12@UseStores:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN13@UseStores:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _loads$[ebp]
	jge	SHORT $LN14@UseStores

; 2741 : 			sq->UpdateSquadronStores (loadout[i].WeaponID, loadout[i].WeaponCount, 0, -1);

	push	-1
	push	0
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _loadout$[ebp]
	lea	edx, DWORD PTR [ecx+eax+32]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 48					; 00000030H
	add	eax, DWORD PTR _loadout$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sq$[ebp]
	call	?UpdateSquadronStores@SquadronClass@@QAEXQAFQAEHH@Z ; SquadronClass::UpdateSquadronStores
	jmp	SHORT $LN12@UseStores
$LN14@UseStores:

; 2742 : 		}
; 2743 : 
; 2744 : 	// Notify the squadron that we've used some weapons
; 2745 : 	for (i=0; i<ac; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN10@UseStores
$LN9@UseStores:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN10@UseStores:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _ac$[ebp]
	jge	SHORT $LN8@UseStores

; 2746 : 		sq->UpdateSquadronStores (gCurStores[i].WeaponID, gCurStores[i].WeaponCount, 0, 1);

	push	1
	push	0
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 48					; 00000030H
	add	eax, OFFSET ?gCurStores@@3PAULoadoutStruct@@A+32
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 48					; 00000030H
	add	ecx, OFFSET ?gCurStores@@3PAULoadoutStruct@@A
	push	ecx
	mov	ecx, DWORD PTR _sq$[ebp]
	call	?UpdateSquadronStores@SquadronClass@@QAEXQAFQAEHH@Z ; SquadronClass::UpdateSquadronStores
	jmp	SHORT $LN9@UseStores
$LN8@UseStores:

; 2747 : 
; 2748 : 	// KCK: Gilman wanted weapons used by the player to have a larger effect.. This isn't exactly very easy to
; 2749 : 	// do, because if they then change this loadout later, they won't be put back...
; 2750 : //	i = FalconLocalSession->GetAircraftNum();
; 2751 : //	if (i < PILOTS_PER_FLIGHT)
; 2752 : //		UpdateSquadronStores (sq, gCurStores[i].WeaponID, gCurStores[i].WeaponCount, 0, 4);
; 2753 : 
; 2754 : 	// KCK: Flights optimize to use a single LoadoutStruct for all aircraft,
; 2755 : 	// After the player mucks with it, we're going to use one PER aircraft.
; 2756 : 	newloadout = new LoadoutStruct[ac];

	mov	edx, DWORD PTR _ac$[ebp]
	mov	DWORD PTR $T4[ebp], edx
	xor	ecx, ecx
	mov	eax, DWORD PTR $T4[ebp]
	mov	edx, 48					; 00000030H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T5[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T5[ebp], 0
	je	SHORT $LN28@UseStores
	push	OFFSET ??0LoadoutStruct@@QAE@XZ		; LoadoutStruct::LoadoutStruct
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	push	48					; 00000030H
	mov	ecx, DWORD PTR $T5[ebp]
	push	ecx
	call	??_H@YGXPAXIHP6EPAX0@Z@Z
	mov	edx, DWORD PTR $T5[ebp]
	mov	DWORD PTR tv198[ebp], edx
	jmp	SHORT $LN29@UseStores
$LN28@UseStores:
	mov	DWORD PTR tv198[ebp], 0
$LN29@UseStores:
	mov	eax, DWORD PTR tv198[ebp]
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR _newloadout$[ebp], ecx

; 2757 : 	for (i=0; i<ac; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@UseStores
$LN6@UseStores:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN7@UseStores:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _ac$[ebp]
	jge	$LN5@UseStores

; 2758 : 		{
; 2759 : 		// Hardpoint 0 never changes (KCK: this seems like a weird way to do this, 
; 2760 : 		// but Peter doesn't save off the gun loadout because he wants to be able to
; 2761 : 		// use the loadout for multiple aircraft -although, I have my doubts that
; 2762 : 		// that's possible).
; 2763 : 		newloadout[i].WeaponID[0] = loadout[0].WeaponID[0];

	mov	ecx, 48					; 00000030H
	imul	ecx, 0
	add	ecx, DWORD PTR _loadout$[ebp]
	mov	edx, 2
	imul	edx, 0
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 48					; 00000030H
	add	eax, DWORD PTR _newloadout$[ebp]
	mov	esi, 2
	imul	esi, 0
	mov	cx, WORD PTR [ecx+edx]
	mov	WORD PTR [eax+esi], cx

; 2764 : 		newloadout[i].WeaponCount[0] = loadout[0].WeaponCount[0];

	mov	edx, 48					; 00000030H
	imul	edx, 0
	add	edx, DWORD PTR _loadout$[ebp]
	mov	eax, 1
	imul	eax, 0
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 48					; 00000030H
	add	ecx, DWORD PTR _newloadout$[ebp]
	mov	esi, 1
	imul	esi, 0
	mov	dl, BYTE PTR [edx+eax+32]
	mov	BYTE PTR [ecx+esi+32], dl

; 2765 : 		for (hp=1; hp<HardPoints; hp++)

	mov	DWORD PTR _hp$[ebp], 1
	jmp	SHORT $LN4@UseStores
$LN3@UseStores:
	mov	eax, DWORD PTR _hp$[ebp]
	add	eax, 1
	mov	DWORD PTR _hp$[ebp], eax
$LN4@UseStores:
	mov	ecx, DWORD PTR _hp$[ebp]
	cmp	ecx, DWORD PTR ?HardPoints@@3JA		; HardPoints
	jge	SHORT $LN2@UseStores

; 2766 : 			{
; 2767 : 			newloadout[i].WeaponID[hp] = gCurStores[i].WeaponID[hp];

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 48					; 00000030H
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 48					; 00000030H
	add	eax, DWORD PTR _newloadout$[ebp]
	mov	ecx, DWORD PTR _hp$[ebp]
	mov	esi, DWORD PTR _hp$[ebp]
	mov	dx, WORD PTR ?gCurStores@@3PAULoadoutStruct@@A[edx+esi*2]
	mov	WORD PTR [eax+ecx*2], dx

; 2768 : 			newloadout[i].WeaponCount[hp] = gCurStores[i].WeaponCount[hp];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 48					; 00000030H
	add	ecx, DWORD PTR _newloadout$[ebp]
	mov	edx, DWORD PTR _hp$[ebp]
	mov	esi, DWORD PTR _hp$[ebp]
	mov	al, BYTE PTR ?gCurStores@@3PAULoadoutStruct@@A[eax+esi+32]
	mov	BYTE PTR [ecx+edx+32], al

; 2769 : 			}

	jmp	SHORT $LN3@UseStores
$LN2@UseStores:

; 2770 : 		}

	jmp	$LN6@UseStores
$LN5@UseStores:

; 2771 : 	flt->SetLoadout(newloadout,ac);

	mov	ecx, DWORD PTR _ac$[ebp]
	push	ecx
	mov	edx, DWORD PTR _newloadout$[ebp]
	push	edx
	mov	eax, DWORD PTR _flt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _flt$[ebp]
	mov	eax, DWORD PTR [edx+636]
	call	eax

; 2772 : 
; 2773 : 	CampLeaveCriticalSection();

	call	?CampLeaveCriticalSection@@YAXXZ	; CampLeaveCriticalSection

; 2774 : 
; 2775 : 	// Update the mission evaluator
; 2776 : 	if (gLoadoutFlightID == FalconLocalSession->GetPlayerFlightID())

	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetPlayerFlightID@FalconSessionEntity@@QBE?AVVU_ID@@XZ ; FalconSessionEntity::GetPlayerFlightID
	push	eax
	mov	ecx, OFFSET ?gLoadoutFlightID@@3VVU_ID@@A ; gLoadoutFlightID
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN26@UseStores

; 2777 : 		TheCampaign.MissionEvaluator->PreMissionEval(flt,FalconLocalSession->GetPilotSlot());

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetPilotSlot@FalconSessionEntity@@QBEEXZ ; FalconSessionEntity::GetPilotSlot
	movzx	eax, al
	push	eax
	mov	ecx, DWORD PTR _flt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A+324
	call	?PreMissionEval@MissionEvaluationClass@@QAEHPAVFlightClass@@E@Z ; MissionEvaluationClass::PreMissionEval
$LN26@UseStores:

; 2778 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?UseStores@@YAXXZ$0:
	mov	eax, DWORD PTR $T5[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
	ret	0
__ehhandler$?UseStores@@YAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-64]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?UseStores@@YAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?UseStores@@YAXXZ ENDP					; UseStores
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\munition.cpp
_TEXT	SEGMENT
_i$ = -8						; size = 4
_j$ = -4						; size = 4
_win$ = 8						; size = 4
?ClearStores@@YAXPAVC_Window@@@Z PROC			; ClearStores

; 2679 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2680 : 	int i,j;
; 2681 : 
; 2682 : 	for(i=0;i<4;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN8@ClearStore
$LN7@ClearStore:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN8@ClearStore:
	cmp	DWORD PTR _i$[ebp], 4
	jge	$LN6@ClearStore

; 2683 : 	{
; 2684 : 		if(PlaneEditList[i])

	mov	ecx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR ?PlaneEditList@@3PAJA[ecx*4], 0
	je	$LN5@ClearStore

; 2685 : 		{
; 2686 : 			for(j=1;j<HARDPOINT_MAX;j++)

	mov	DWORD PTR _j$[ebp], 1
	jmp	SHORT $LN4@ClearStore
$LN3@ClearStore:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$LN4@ClearStore:
	cmp	DWORD PTR _j$[ebp], 16			; 00000010H
	jge	SHORT $LN5@ClearStore

; 2687 : 			{
; 2688 : 				gCurStores[i].WeaponID[j]=0;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 48					; 00000030H
	xor	ecx, ecx
	mov	edx, DWORD PTR _j$[ebp]
	mov	WORD PTR ?gCurStores@@3PAULoadoutStruct@@A[eax+edx*2], cx

; 2689 : 				gCurStores[i].WeaponCount[j]=0;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _j$[ebp]
	mov	BYTE PTR ?gCurStores@@3PAULoadoutStruct@@A[eax+ecx+32], 0

; 2690 : 				if(j && j < HardPoints)

	cmp	DWORD PTR _j$[ebp], 0
	je	SHORT $LN1@ClearStore
	mov	edx, DWORD PTR _j$[ebp]
	cmp	edx, DWORD PTR ?HardPoints@@3JA		; HardPoints
	jge	SHORT $LN1@ClearStore

; 2691 : 				{
; 2692 : 					ClearHardPoint(i,j,HardPoints/2,&gCurRails[i].rail[j]);

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 2560				; 00000a00H
	mov	ecx, DWORD PTR _j$[ebp]
	imul	ecx, 160				; 000000a0H
	lea	edx, DWORD PTR ?gCurRails@@3PAURailList@@A[eax+ecx]
	push	edx
	mov	eax, DWORD PTR ?HardPoints@@3JA		; HardPoints
	cdq
	sub	eax, edx
	sar	eax, 1
	push	eax
	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	call	?ClearHardPoint@@YAXJJJPAVRailInfo@@@Z	; ClearHardPoint
	add	esp, 16					; 00000010H
$LN1@ClearStore:

; 2693 : 				}
; 2694 : 			}

	jmp	SHORT $LN3@ClearStore
$LN5@ClearStore:

; 2695 : 			//memset(gCurRails[i].rail,0,sizeof(RailList));
; 2696 : 		}
; 2697 : 	}

	jmp	$LN7@ClearStore
$LN6@ClearStore:

; 2698 : 	MakeStoresList(win,1);

	push	1
	mov	edx, DWORD PTR _win$[ebp]
	push	edx
	call	?MakeStoresList@@YAXPAVC_Window@@J@Z	; MakeStoresList
	add	esp, 8

; 2699 : 	win->RefreshWindow();

	mov	ecx, DWORD PTR _win$[ebp]
	call	?RefreshWindow@C_Window@@QAEXXZ		; C_Window::RefreshWindow

; 2700 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ClearStores@@YAXPAVC_Window@@@Z ENDP			; ClearStores
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\munition.cpp
_TEXT	SEGMENT
_Leave$ = -36						; size = 4
_ok$1 = -32						; size = 4
_classPtr$2 = -28					; size = 4
_loads$ = -24						; size = 4
_ac$ = -20						; size = 4
_v$ = -16						; size = 4
_flt$ = -12						; size = 4
_i$ = -8						; size = 2
_j$ = -4						; size = 2
_win$ = 8						; size = 4
?RestoreStores@@YAXPAVC_Window@@@Z PROC			; RestoreStores

; 2632 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 2633 : 	Flight flt;
; 2634 : 	int v,ac,loads;
; 2635 : 	short i,j;
; 2636 : 	F4CSECTIONHANDLE *Leave;
; 2637 : 	
; 2638 : 	Leave=UI_Enter(win);

	mov	eax, DWORD PTR _win$[ebp]
	push	eax
	call	?UI_Enter@@YAPAUF4CSECTIONHANDLE@@PAVC_Window@@@Z ; UI_Enter
	add	esp, 4
	mov	DWORD PTR _Leave$[ebp], eax

; 2639 : 	flt=(Flight)vuDatabase->Find(gLoadoutFlightID);

	mov	ecx, DWORD PTR ?gLoadoutFlightID@@3VVU_ID@@A+4
	push	ecx
	mov	edx, DWORD PTR ?gLoadoutFlightID@@3VVU_ID@@A
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _flt$[ebp], eax

; 2640 : 
; 2641 : 	ac = flt->GetTotalVehicles();

	mov	ecx, DWORD PTR _flt$[ebp]
	call	?GetTotalVehicles@UnitClass@@QAEHXZ	; UnitClass::GetTotalVehicles
	mov	DWORD PTR _ac$[ebp], eax

; 2642 : 	loads = flt->GetNumberOfLoadouts();

	mov	eax, DWORD PTR _flt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _flt$[ebp]
	mov	eax, DWORD PTR [edx+640]
	call	eax
	mov	DWORD PTR _loads$[ebp], eax

; 2643 : 	ShiAssert( ac > 0 && loads > 0 );
; 2644 : 
; 2645 : 	for (v=0; v<ac; v++)

	mov	DWORD PTR _v$[ebp], 0
	jmp	SHORT $LN13@RestoreSto
$LN12@RestoreSto:
	mov	ecx, DWORD PTR _v$[ebp]
	add	ecx, 1
	mov	DWORD PTR _v$[ebp], ecx
$LN13@RestoreSto:
	mov	edx, DWORD PTR _v$[ebp]
	cmp	edx, DWORD PTR _ac$[ebp]
	jge	SHORT $LN11@RestoreSto

; 2646 : 		{
; 2647 : 		if (v < loads)

	mov	eax, DWORD PTR _v$[ebp]
	cmp	eax, DWORD PTR _loads$[ebp]
	jge	SHORT $LN10@RestoreSto

; 2648 : 			memcpy(&gCurStores[v], flt->GetLoadout(v), sizeof(LoadoutStruct));

	push	48					; 00000030H
	mov	ecx, DWORD PTR _v$[ebp]
	push	ecx
	mov	edx, DWORD PTR _flt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _flt$[ebp]
	mov	edx, DWORD PTR [eax+996]
	call	edx
	push	eax
	mov	eax, DWORD PTR _v$[ebp]
	imul	eax, 48					; 00000030H
	add	eax, OFFSET ?gCurStores@@3PAULoadoutStruct@@A ; gCurStores
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2649 : 		else

	jmp	SHORT $LN9@RestoreSto
$LN10@RestoreSto:

; 2650 : 			memcpy(&gCurStores[v], flt->GetLoadout(0), sizeof(LoadoutStruct));

	push	48					; 00000030H
	push	0
	mov	ecx, DWORD PTR _flt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _flt$[ebp]
	mov	eax, DWORD PTR [edx+996]
	call	eax
	push	eax
	mov	ecx, DWORD PTR _v$[ebp]
	imul	ecx, 48					; 00000030H
	add	ecx, OFFSET ?gCurStores@@3PAULoadoutStruct@@A ; gCurStores
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN9@RestoreSto:

; 2651 : 		}

	jmp	SHORT $LN12@RestoreSto
$LN11@RestoreSto:

; 2652 : 	memcpy(&gCurStores[4], flt->GetLoadout(0), sizeof(LoadoutStruct));

	push	48					; 00000030H
	push	0
	mov	edx, DWORD PTR _flt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _flt$[ebp]
	mov	edx, DWORD PTR [eax+996]
	call	edx
	push	eax
	mov	eax, 48					; 00000030H
	shl	eax, 2
	add	eax, OFFSET ?gCurStores@@3PAULoadoutStruct@@A ; gCurStores
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2653 : 
; 2654 : 	for(i=0;i<4;i++)

	xor	ecx, ecx
	mov	WORD PTR _i$[ebp], cx
	jmp	SHORT $LN8@RestoreSto
$LN7@RestoreSto:
	mov	dx, WORD PTR _i$[ebp]
	add	dx, 1
	mov	WORD PTR _i$[ebp], dx
$LN8@RestoreSto:
	movsx	eax, WORD PTR _i$[ebp]
	cmp	eax, 4
	jge	$LN6@RestoreSto

; 2655 : 	{
; 2656 : 		for(j=0;j<HARDPOINT_MAX;j++)

	xor	ecx, ecx
	mov	WORD PTR _j$[ebp], cx
	jmp	SHORT $LN5@RestoreSto
$LN4@RestoreSto:
	mov	dx, WORD PTR _j$[ebp]
	add	dx, 1
	mov	WORD PTR _j$[ebp], dx
$LN5@RestoreSto:
	movsx	eax, WORD PTR _j$[ebp]
	cmp	eax, 16					; 00000010H
	jge	$LN3@RestoreSto

; 2657 : 		{
; 2658 : 			if(j && j < HardPoints)

	movsx	ecx, WORD PTR _j$[ebp]
	test	ecx, ecx
	je	$LN2@RestoreSto
	movsx	edx, WORD PTR _j$[ebp]
	cmp	edx, DWORD PTR ?HardPoints@@3JA		; HardPoints
	jge	$LN2@RestoreSto

; 2659 : 			{
; 2660 : 				int ok;
; 2661 : 				ClearHardPoint(i,j,HardPoints/2,&gCurRails[i].rail[j]);

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 2560				; 00000a00H
	movsx	ecx, WORD PTR _j$[ebp]
	imul	ecx, 160				; 000000a0H
	lea	edx, DWORD PTR ?gCurRails@@3PAURailList@@A[eax+ecx]
	push	edx
	mov	eax, DWORD PTR ?HardPoints@@3JA		; HardPoints
	cdq
	sub	eax, edx
	sar	eax, 1
	push	eax
	movsx	eax, WORD PTR _j$[ebp]
	push	eax
	movsx	ecx, WORD PTR _i$[ebp]
	push	ecx
	call	?ClearHardPoint@@YAXJJJPAVRailInfo@@@Z	; ClearHardPoint
	add	esp, 16					; 00000010H

; 2662 : 				//if (g_bNewRackData) {
; 2663 : 					Falcon4EntityClassType* classPtr = &Falcon4ClassTable[gVehID];

	mov	edx, DWORD PTR ?gVehID@@3HA		; gVehID
	imul	edx, 81					; 00000051H
	add	edx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	DWORD PTR _classPtr$2[ebp], edx

; 2664 : 					ok = GetJRackAndWeapon(gVCPtr, classPtr, gCurStores[i].WeaponID[j], gCurStores[i].WeaponCount[j], static_cast<short>(j), &gCurRails[i].rail[j]);

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 2560				; 00000a00H
	movsx	ecx, WORD PTR _j$[ebp]
	imul	ecx, 160				; 000000a0H
	lea	edx, DWORD PTR ?gCurRails@@3PAURailList@@A[eax+ecx]
	push	edx
	movzx	eax, WORD PTR _j$[ebp]
	push	eax
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 48					; 00000030H
	movsx	edx, WORD PTR _j$[ebp]
	movzx	ax, BYTE PTR ?gCurStores@@3PAULoadoutStruct@@A[ecx+edx+32]
	movzx	ecx, ax
	push	ecx
	movsx	edx, WORD PTR _i$[ebp]
	imul	edx, 48					; 00000030H
	movsx	eax, WORD PTR _j$[ebp]
	movzx	ecx, WORD PTR ?gCurStores@@3PAULoadoutStruct@@A[edx+eax*2]
	push	ecx
	mov	edx, DWORD PTR _classPtr$2[ebp]
	push	edx
	mov	eax, DWORD PTR ?gVCPtr@@3PAUVehicleClassDataType@@A ; gVCPtr
	push	eax
	call	?GetJRackAndWeapon@@YAHPAUVehicleClassDataType@@PAUFalcon4EntityClassType@@FFFPAVRailInfo@@@Z ; GetJRackAndWeapon
	add	esp, 24					; 00000018H
	mov	DWORD PTR _ok$1[ebp], eax

; 2665 : 				//}
; 2666 : 				//else
; 2667 : 				//	ok = GetRackAndWeapon(gVCPtr,static_cast<short>(gVehID), gCurStores[i].WeaponID[j],gCurStores[i].WeaponCount[j],static_cast<short>(j),static_cast<short>(HardPoints/2),&gCurRails[i].rail[j]);
; 2668 : 				if(ok)

	cmp	DWORD PTR _ok$1[ebp], 0
	je	SHORT $LN2@RestoreSto

; 2669 : 					LoadHardPoint(i,j,HardPoints/2,&gCurRails[i].rail[j]);

	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 2560				; 00000a00H
	movsx	edx, WORD PTR _j$[ebp]
	imul	edx, 160				; 000000a0H
	lea	eax, DWORD PTR ?gCurRails@@3PAURailList@@A[ecx+edx]
	push	eax
	mov	eax, DWORD PTR ?HardPoints@@3JA		; HardPoints
	cdq
	sub	eax, edx
	sar	eax, 1
	push	eax
	movsx	ecx, WORD PTR _j$[ebp]
	push	ecx
	movsx	edx, WORD PTR _i$[ebp]
	push	edx
	call	?LoadHardPoint@@YAXJJJPAVRailInfo@@@Z	; LoadHardPoint
	add	esp, 16					; 00000010H
$LN2@RestoreSto:

; 2670 : 			}
; 2671 : 		}

	jmp	$LN4@RestoreSto
$LN3@RestoreSto:

; 2672 : 	}

	jmp	$LN7@RestoreSto
$LN6@RestoreSto:

; 2673 : 	MakeStoresList(win,1);

	push	1
	mov	eax, DWORD PTR _win$[ebp]
	push	eax
	call	?MakeStoresList@@YAXPAVC_Window@@J@Z	; MakeStoresList
	add	esp, 8

; 2674 : 	win->RefreshWindow();

	mov	ecx, DWORD PTR _win$[ebp]
	call	?RefreshWindow@C_Window@@QAEXXZ		; C_Window::RefreshWindow

; 2675 : 	UI_Leave(Leave);

	mov	ecx, DWORD PTR _Leave$[ebp]
	push	ecx
	call	?UI_Leave@@YAXPAUF4CSECTIONHANDLE@@@Z	; UI_Leave
	add	esp, 4

; 2676 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RestoreStores@@YAXPAVC_Window@@@Z ENDP			; RestoreStores
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\munition.cpp
_TEXT	SEGMENT
_vid$ = -60						; size = 4
tv323 = -56						; size = 4
_sqd$ = -52						; size = 4
tv181 = -48						; size = 4
_flt$ = -44						; size = 4
_fuel$ = -40						; size = 4
_j$ = -36						; size = 4
_wpn$ = -32						; size = 4
_wtype$ = -28						; size = 4
_avail$ = -24						; size = 4
_slist$ = -20						; size = 4
_classPtr$ = -16					; size = 4
_vc$ = -12						; size = 4
_wc$ = -8						; size = 4
_i$ = -4						; size = 4
?SetupLoadoutDisplay@@YAXXZ PROC			; SetupLoadoutDisplay

; 1995 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 1996 : 	Flight flt;
; 1997 : 	Squadron sqd;
; 1998 : 	VehicleClassDataType *vc;
; 1999 : 	WeaponClassDataType  *wc;
; 2000 : 	Falcon4EntityClassType* classPtr;
; 2001 : 	int vid,i,j,slist = -1,wtype;

	mov	DWORD PTR _slist$[ebp], -1

; 2002 : 	long fuel,avail;
; 2003 : 	STORESLIST *wpn;
; 2004 : 
; 2005 : 	flt=(Flight)vuDatabase->Find(gLoadoutFlightID);

	mov	eax, DWORD PTR ?gLoadoutFlightID@@3VVU_ID@@A+4
	push	eax
	mov	ecx, DWORD PTR ?gLoadoutFlightID@@3VVU_ID@@A
	push	ecx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _flt$[ebp], eax

; 2006 : 	if(!flt)

	cmp	DWORD PTR _flt$[ebp], 0
	jne	SHORT $LN61@SetupLoado

; 2007 : 		return;

	jmp	$LN62@SetupLoado
$LN61@SetupLoado:

; 2008 : 
; 2009 : 	sqd=(Squadron)flt->GetUnitSquadron();

	mov	edx, DWORD PTR _flt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _flt$[ebp]
	mov	edx, DWORD PTR [eax+696]
	call	edx
	mov	DWORD PTR _sqd$[ebp], eax

; 2010 : 	if(!sqd)

	cmp	DWORD PTR _sqd$[ebp], 0
	jne	SHORT $LN60@SetupLoado

; 2011 : 		return;

	jmp	$LN62@SetupLoado
$LN60@SetupLoado:

; 2012 : 
; 2013 : 	vid = flt->GetVehicleID(0);

	push	0
	mov	ecx, DWORD PTR _flt$[ebp]
	call	?GetVehicleID@UnitClass@@QAEFH@Z	; UnitClass::GetVehicleID
	cwde
	mov	DWORD PTR _vid$[ebp], eax

; 2014 : 	vc = GetVehicleClassData(vid);

	mov	ecx, DWORD PTR _vid$[ebp]
	push	ecx
	call	?GetVehicleClassData@@YAPAUVehicleClassDataType@@H@Z ; GetVehicleClassData
	add	esp, 4
	mov	DWORD PTR _vc$[ebp], eax

; 2015 : 	if(!vc)

	cmp	DWORD PTR _vc$[ebp], 0
	jne	SHORT $LN59@SetupLoado

; 2016 : 		return;

	jmp	$LN62@SetupLoado
$LN59@SetupLoado:

; 2017 : 
; 2018 : 	for(i=1;i<HardPoints;i++)

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN58@SetupLoado
$LN57@SetupLoado:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN58@SetupLoado:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR ?HardPoints@@3JA		; HardPoints
	jge	$LN56@SetupLoado

; 2019 : 	{
; 2020 : 		if(vc->Weapon[i] && vc->Weapons[i])

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _vc$[ebp]
	movsx	eax, WORD PTR [edx+ecx*2+98]
	test	eax, eax
	je	$LN25@SetupLoado
	mov	ecx, DWORD PTR _vc$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	movzx	edx, BYTE PTR [ecx+130]
	test	edx, edx
	je	$LN25@SetupLoado

; 2021 : 		{
; 2022 : 			if(vc->Weapons[i] == 255)

	mov	eax, DWORD PTR _vc$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax+130]
	cmp	ecx, 255				; 000000ffH
	jne	$LN54@SetupLoado

; 2023 : 			{
; 2024 : 				for(j=0;j<MAX_WEAPONS_IN_LIST;j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN53@SetupLoado
$LN52@SetupLoado:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$LN53@SetupLoado:
	cmp	DWORD PTR _j$[ebp], 64			; 00000040H
	jge	$LN51@SetupLoado

; 2025 : 				{
; 2026 : 					ShiAssert(gStores);
; 2027 : 					if(GetListEntryWeapon(vc->Weapon[i],j) && gStores)

	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _vc$[ebp]
	movsx	eax, WORD PTR [edx+ecx*2+98]
	push	eax
	call	?GetListEntryWeapon@@YAHHH@Z		; GetListEntryWeapon
	add	esp, 8
	test	eax, eax
	je	$LN50@SetupLoado
	cmp	DWORD PTR ?gStores@@3PAVStoresList@@A, 0 ; gStores
	je	$LN50@SetupLoado

; 2028 : 					{
; 2029 : 						wpn=gStores->Find(GetListEntryWeapon(vc->Weapon[i],j));

	mov	ecx, DWORD PTR _j$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _vc$[ebp]
	movsx	ecx, WORD PTR [eax+edx*2+98]
	push	ecx
	call	?GetListEntryWeapon@@YAHHH@Z		; GetListEntryWeapon
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR ?gStores@@3PAVStoresList@@A ; gStores
	call	?Find@StoresList@@QAEPAUStoresStr@@J@Z	; StoresList::Find
	mov	DWORD PTR _wpn$[ebp], eax

; 2030 : 					
; 2031 : 						if(wpn == NULL)

	cmp	DWORD PTR _wpn$[ebp], 0
	jne	$LN49@SetupLoado

; 2032 : 						{
; 2033 : 							if(TheCampaign.Flags & CAMP_TACTICAL)

	mov	edx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A+64
	and	edx, 1024				; 00000400H
	je	SHORT $LN48@SetupLoado

; 2034 : 								avail=2000;

	mov	DWORD PTR _avail$[ebp], 2000		; 000007d0H

; 2035 : 							else

	jmp	SHORT $LN45@SetupLoado
$LN48@SetupLoado:

; 2036 : 							{
; 2037 : 								avail=sqd->GetAvailableStores(GetListEntryWeapon(vc->Weapon[i],j));

	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _vc$[ebp]
	movsx	eax, WORD PTR [edx+ecx*2+98]
	push	eax
	call	?GetListEntryWeapon@@YAHHH@Z		; GetListEntryWeapon
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _sqd$[ebp]
	call	?GetAvailableStores@SquadronClass@@QAEEH@Z ; SquadronClass::GetAvailableStores
	movzx	ecx, al
	mov	DWORD PTR _avail$[ebp], ecx

; 2038 : 								switch(avail)

	mov	edx, DWORD PTR _avail$[ebp]
	mov	DWORD PTR tv181[ebp], edx
	cmp	DWORD PTR tv181[ebp], 0
	je	SHORT $LN44@SetupLoado
	cmp	DWORD PTR tv181[ebp], 1
	je	SHORT $LN43@SetupLoado
	cmp	DWORD PTR tv181[ebp], 2
	je	SHORT $LN42@SetupLoado
	jmp	SHORT $LN41@SetupLoado
$LN44@SetupLoado:

; 2039 : 								{
; 2040 : 									case 0:
; 2041 : 										break;

	jmp	SHORT $LN45@SetupLoado
$LN43@SetupLoado:

; 2042 : 									case 1:
; 2043 : 										avail=500;

	mov	DWORD PTR _avail$[ebp], 500		; 000001f4H

; 2044 : 										break;

	jmp	SHORT $LN45@SetupLoado
$LN42@SetupLoado:

; 2045 : 									case 2:
; 2046 : 										avail=1000;

	mov	DWORD PTR _avail$[ebp], 1000		; 000003e8H

; 2047 : 										break;

	jmp	SHORT $LN45@SetupLoado
$LN41@SetupLoado:

; 2048 : 									default:
; 2049 : 										avail=2000;

	mov	DWORD PTR _avail$[ebp], 2000		; 000007d0H
$LN45@SetupLoado:

; 2050 : 										break;
; 2051 : 								}
; 2052 : 							}
; 2053 : 							fuel=0;

	mov	DWORD PTR _fuel$[ebp], 0

; 2054 : 							wc=&WeaponDataTable[GetListEntryWeapon(vc->Weapon[i],j)];

	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _vc$[ebp]
	movsx	eax, WORD PTR [edx+ecx*2+98]
	push	eax
	call	?GetListEntryWeapon@@YAHHH@Z		; GetListEntryWeapon
	add	esp, 8
	imul	eax, 60					; 0000003cH
	add	eax, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	mov	DWORD PTR _wc$[ebp], eax

; 2055 : 							classPtr = &Falcon4ClassTable[wc->Index];

	mov	ecx, DWORD PTR _wc$[ebp]
	movsx	edx, WORD PTR [ecx]
	imul	edx, 81					; 00000051H
	add	edx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	DWORD PTR _classPtr$[ebp], edx

; 2056 : 							if(classPtr)

	je	$LN40@SetupLoado

; 2057 : 							{
; 2058 : 								if(classPtr->vuClassData.classInfo_[VU_TYPE] == TYPE_MISSILE)

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _classPtr$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+8]
	cmp	edx, 6
	jne	SHORT $LN39@SetupLoado

; 2059 : 								{
; 2060 : 									if(classPtr->vuClassData.classInfo_[VU_STYPE] == STYPE_MISSILE_AIR_AIR)

	mov	eax, 1
	imul	eax, 3
	mov	ecx, DWORD PTR _classPtr$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+8]
	cmp	edx, 1
	jne	SHORT $LN38@SetupLoado

; 2061 : 									{
; 2062 : 										wtype=StoresList::_TYPE_MISSILE_;

	mov	DWORD PTR _wtype$[ebp], 100		; 00000064H

; 2063 : 										slist=StoresList::_AIR_TO_AIR_;

	mov	DWORD PTR _slist$[ebp], 0

; 2064 : 									}
; 2065 : 									else

	jmp	SHORT $LN37@SetupLoado
$LN38@SetupLoado:

; 2066 : 									{
; 2067 : 										wtype=StoresList::_TYPE_MISSILE_;

	mov	DWORD PTR _wtype$[ebp], 100		; 00000064H

; 2068 : 										slist=StoresList::_AIR_TO_GROUND_;

	mov	DWORD PTR _slist$[ebp], 1
$LN37@SetupLoado:

; 2069 : 									}
; 2070 : 								}
; 2071 : 								else if(classPtr->vuClassData.classInfo_[VU_TYPE] == TYPE_ROCKET ||

	jmp	$LN27@SetupLoado
$LN39@SetupLoado:

; 2072 : 										classPtr->vuClassData.classInfo_[VU_TYPE] == TYPE_LAUNCHER)

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _classPtr$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+8]
	cmp	edx, 8
	je	SHORT $LN34@SetupLoado
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _classPtr$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+8]
	cmp	edx, 5
	jne	SHORT $LN35@SetupLoado
$LN34@SetupLoado:

; 2073 : 								{
; 2074 : 									wtype=StoresList::_TYPE_ROCKET_;

	mov	DWORD PTR _wtype$[ebp], 101		; 00000065H

; 2075 : 									slist=StoresList::_AIR_TO_GROUND_;

	mov	DWORD PTR _slist$[ebp], 1
	jmp	$LN27@SetupLoado
$LN35@SetupLoado:

; 2076 : 								}
; 2077 : 								else if(classPtr->vuClassData.classInfo_[VU_TYPE] == TYPE_BOMB)

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _classPtr$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+8]
	cmp	edx, 2
	jne	SHORT $LN32@SetupLoado

; 2078 : 								{
; 2079 : 									wtype=StoresList::_TYPE_BOMB_;

	mov	DWORD PTR _wtype$[ebp], 102		; 00000066H

; 2080 : 									slist=StoresList::_AIR_TO_GROUND_;

	mov	DWORD PTR _slist$[ebp], 1
	jmp	SHORT $LN27@SetupLoado
$LN32@SetupLoado:

; 2081 : 								}
; 2082 : 								else if(classPtr->vuClassData.classInfo_[VU_TYPE] == TYPE_GUN)

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _classPtr$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+8]
	cmp	edx, 3
	jne	SHORT $LN30@SetupLoado

; 2083 : 								{
; 2084 : 									wtype=StoresList::_TYPE_GUN_;

	mov	DWORD PTR _wtype$[ebp], 105		; 00000069H

; 2085 : 									slist=StoresList::_AIR_TO_GROUND_;

	mov	DWORD PTR _slist$[ebp], 1
	jmp	SHORT $LN27@SetupLoado
$LN30@SetupLoado:

; 2086 : 								}
; 2087 : 								else if(classPtr->vuClassData.classInfo_[VU_TYPE] == TYPE_FUEL_TANK)

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _classPtr$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+8]
	cmp	edx, 4
	jne	SHORT $LN28@SetupLoado

; 2088 : 								{
; 2089 : 									wtype=StoresList::_TYPE_FUEL_;

	mov	DWORD PTR _wtype$[ebp], 103		; 00000067H

; 2090 : 									slist=StoresList::_OTHER_;

	mov	DWORD PTR _slist$[ebp], 2

; 2091 : 									fuel=wc->Strength;

	mov	eax, DWORD PTR _wc$[ebp]
	movzx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR _fuel$[ebp], ecx

; 2092 : 								}
; 2093 : 								else

	jmp	SHORT $LN27@SetupLoado
$LN28@SetupLoado:

; 2094 : 								{
; 2095 : 									wtype=StoresList::_TYPE_OTHER_;

	mov	DWORD PTR _wtype$[ebp], 104		; 00000068H

; 2096 : 									slist=StoresList::_OTHER_;

	mov	DWORD PTR _slist$[ebp], 2
$LN27@SetupLoado:

; 2097 : 								}
; 2098 : 								wpn=gStores->Create(GetListEntryWeapon(vc->Weapon[i],static_cast<short>(j)),wc->Name,wtype,wc->Weight,fuel,wc->DragIndex,static_cast<short>(avail)); // add stores wgt,drag factor

	movzx	edx, WORD PTR _avail$[ebp]
	push	edx
	mov	eax, DWORD PTR _wc$[ebp]
	movsx	ecx, WORD PTR [eax+50]
	cvtsi2ss xmm0, ecx
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _fuel$[ebp]
	push	edx
	mov	eax, DWORD PTR _wc$[ebp]
	movzx	ecx, WORD PTR [eax+48]
	push	ecx
	mov	edx, DWORD PTR _wtype$[ebp]
	push	edx
	mov	eax, DWORD PTR _wc$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	movsx	ecx, WORD PTR _j$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _vc$[ebp]
	movsx	ecx, WORD PTR [eax+edx*2+98]
	push	ecx
	call	?GetListEntryWeapon@@YAHHH@Z		; GetListEntryWeapon
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR ?gStores@@3PAVStoresList@@A ; gStores
	call	?Create@StoresList@@QAEPAUStoresStr@@JPADJJJMF@Z ; StoresList::Create
	mov	DWORD PTR _wpn$[ebp], eax

; 2099 : 							}
; 2100 : 							else

	jmp	SHORT $LN26@SetupLoado
$LN40@SetupLoado:

; 2101 : 							{
; 2102 : 								wpn=gStores->Create(GetListEntryWeapon(vc->Weapon[i],static_cast<short>(j)),wc->Name,StoresList::_TYPE_OTHER_,wc->Weight,fuel,wc->DragIndex,static_cast<short>(avail)); // add stores wgt,drag factor

	movzx	edx, WORD PTR _avail$[ebp]
	push	edx
	mov	eax, DWORD PTR _wc$[ebp]
	movsx	ecx, WORD PTR [eax+50]
	cvtsi2ss xmm0, ecx
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _fuel$[ebp]
	push	edx
	mov	eax, DWORD PTR _wc$[ebp]
	movzx	ecx, WORD PTR [eax+48]
	push	ecx
	push	104					; 00000068H
	mov	edx, DWORD PTR _wc$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	movsx	eax, WORD PTR _j$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _vc$[ebp]
	movsx	eax, WORD PTR [edx+ecx*2+98]
	push	eax
	call	?GetListEntryWeapon@@YAHHH@Z		; GetListEntryWeapon
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR ?gStores@@3PAVStoresList@@A ; gStores
	call	?Create@StoresList@@QAEPAUStoresStr@@JPADJJJMF@Z ; StoresList::Create
	mov	DWORD PTR _wpn$[ebp], eax
$LN26@SetupLoado:

; 2103 : 							}
; 2104 : 							gStores->Add(wpn,slist);

	mov	ecx, DWORD PTR _slist$[ebp]
	push	ecx
	mov	edx, DWORD PTR _wpn$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?gStores@@3PAVStoresList@@A ; gStores
	call	?Add@StoresList@@QAEXPAUStoresStr@@J@Z	; StoresList::Add
$LN49@SetupLoado:

; 2105 : 						}
; 2106 : 						wpn->HardPoint[i]=static_cast<short>(GetListEntryWeapons(vc->Weapon[i],j));

	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _vc$[ebp]
	movsx	eax, WORD PTR [edx+ecx*2+98]
	push	eax
	call	?GetListEntryWeapons@@YAHHH@Z		; GetListEntryWeapons
	add	esp, 8
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _wpn$[ebp]
	mov	WORD PTR [edx+ecx*2+44], ax
$LN50@SetupLoado:

; 2107 : 					}
; 2108 : 				}

	jmp	$LN52@SetupLoado
$LN51@SetupLoado:

; 2109 : 			}
; 2110 : 			else

	jmp	$LN25@SetupLoado
$LN54@SetupLoado:

; 2111 : 			{
; 2112 : 				wpn=NULL;

	mov	DWORD PTR _wpn$[ebp], 0

; 2113 : 				ShiAssert(gStores);
; 2114 : 				if (gStores)

	cmp	DWORD PTR ?gStores@@3PAVStoresList@@A, 0 ; gStores
	je	SHORT $LN24@SetupLoado

; 2115 : 					wpn = gStores->Find(vc->Weapon[i]);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _vc$[ebp]
	movsx	edx, WORD PTR [ecx+eax*2+98]
	push	edx
	mov	ecx, DWORD PTR ?gStores@@3PAVStoresList@@A ; gStores
	call	?Find@StoresList@@QAEPAUStoresStr@@J@Z	; StoresList::Find
	mov	DWORD PTR _wpn$[ebp], eax
$LN24@SetupLoado:

; 2116 : 
; 2117 : 				if(wpn == NULL)

	cmp	DWORD PTR _wpn$[ebp], 0
	jne	$LN23@SetupLoado

; 2118 : 				{
; 2119 : 					if(TheCampaign.Flags & CAMP_TACTICAL)

	mov	eax, DWORD PTR ?TheCampaign@@3VCampaignClass@@A+64
	and	eax, 1024				; 00000400H
	je	SHORT $LN22@SetupLoado

; 2120 : 						avail=2000;

	mov	DWORD PTR _avail$[ebp], 2000		; 000007d0H

; 2121 : 					else

	jmp	SHORT $LN19@SetupLoado
$LN22@SetupLoado:

; 2122 : 					{
; 2123 : 						avail=sqd->GetAvailableStores(vc->Weapon[i]);

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _vc$[ebp]
	movsx	eax, WORD PTR [edx+ecx*2+98]
	push	eax
	mov	ecx, DWORD PTR _sqd$[ebp]
	call	?GetAvailableStores@SquadronClass@@QAEEH@Z ; SquadronClass::GetAvailableStores
	movzx	ecx, al
	mov	DWORD PTR _avail$[ebp], ecx

; 2124 : 						switch(avail)

	mov	edx, DWORD PTR _avail$[ebp]
	mov	DWORD PTR tv323[ebp], edx
	cmp	DWORD PTR tv323[ebp], 0
	je	SHORT $LN18@SetupLoado
	cmp	DWORD PTR tv323[ebp], 1
	je	SHORT $LN17@SetupLoado
	cmp	DWORD PTR tv323[ebp], 2
	je	SHORT $LN16@SetupLoado
	jmp	SHORT $LN15@SetupLoado
$LN18@SetupLoado:

; 2125 : 						{
; 2126 : 							case 0:
; 2127 : 								break;

	jmp	SHORT $LN19@SetupLoado
$LN17@SetupLoado:

; 2128 : 							case 1:
; 2129 : 								avail=500;

	mov	DWORD PTR _avail$[ebp], 500		; 000001f4H

; 2130 : 								break;

	jmp	SHORT $LN19@SetupLoado
$LN16@SetupLoado:

; 2131 : 							case 2:
; 2132 : 								avail=1000;

	mov	DWORD PTR _avail$[ebp], 1000		; 000003e8H

; 2133 : 								break;

	jmp	SHORT $LN19@SetupLoado
$LN15@SetupLoado:

; 2134 : 							default:
; 2135 : 								avail=2000;

	mov	DWORD PTR _avail$[ebp], 2000		; 000007d0H
$LN19@SetupLoado:

; 2136 : 								break;
; 2137 : 						}
; 2138 : 					}
; 2139 : 					fuel=0;

	mov	DWORD PTR _fuel$[ebp], 0

; 2140 : 					wc=&WeaponDataTable[vc->Weapon[i]];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _vc$[ebp]
	movsx	edx, WORD PTR [ecx+eax*2+98]
	imul	edx, 60					; 0000003cH
	add	edx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	mov	DWORD PTR _wc$[ebp], edx

; 2141 : 					classPtr = &Falcon4ClassTable[wc->Index];

	mov	eax, DWORD PTR _wc$[ebp]
	movsx	ecx, WORD PTR [eax]
	imul	ecx, 81					; 00000051H
	add	ecx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	DWORD PTR _classPtr$[ebp], ecx

; 2142 : 					if(classPtr)

	je	$LN14@SetupLoado

; 2143 : 					{
; 2144 : 						if(classPtr->vuClassData.classInfo_[VU_TYPE] == TYPE_MISSILE)

	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _classPtr$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+8]
	cmp	ecx, 6
	jne	SHORT $LN13@SetupLoado

; 2145 : 						{
; 2146 : 							if(classPtr->vuClassData.classInfo_[VU_STYPE] == STYPE_MISSILE_AIR_AIR)

	mov	edx, 1
	imul	edx, 3
	mov	eax, DWORD PTR _classPtr$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+8]
	cmp	ecx, 1
	jne	SHORT $LN12@SetupLoado

; 2147 : 							{
; 2148 : 								wtype=StoresList::_TYPE_MISSILE_;

	mov	DWORD PTR _wtype$[ebp], 100		; 00000064H

; 2149 : 								slist=StoresList::_AIR_TO_AIR_;

	mov	DWORD PTR _slist$[ebp], 0

; 2150 : 							}
; 2151 : 							else

	jmp	SHORT $LN11@SetupLoado
$LN12@SetupLoado:

; 2152 : 							{
; 2153 : 								wtype=StoresList::_TYPE_MISSILE_;

	mov	DWORD PTR _wtype$[ebp], 100		; 00000064H

; 2154 : 								slist=StoresList::_AIR_TO_GROUND_;

	mov	DWORD PTR _slist$[ebp], 1
$LN11@SetupLoado:

; 2155 : 							}
; 2156 : 						}
; 2157 : 						else if(classPtr->vuClassData.classInfo_[VU_TYPE] == TYPE_ROCKET ||

	jmp	$LN3@SetupLoado
$LN13@SetupLoado:

; 2158 : 								classPtr->vuClassData.classInfo_[VU_TYPE] == TYPE_LAUNCHER)

	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _classPtr$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+8]
	cmp	ecx, 8
	je	SHORT $LN8@SetupLoado
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _classPtr$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+8]
	cmp	ecx, 5
	jne	SHORT $LN9@SetupLoado
$LN8@SetupLoado:

; 2159 : 						{
; 2160 : 							wtype=StoresList::_TYPE_ROCKET_;

	mov	DWORD PTR _wtype$[ebp], 101		; 00000065H

; 2161 : 							slist=StoresList::_AIR_TO_GROUND_;

	mov	DWORD PTR _slist$[ebp], 1
	jmp	SHORT $LN3@SetupLoado
$LN9@SetupLoado:

; 2162 : 						}
; 2163 : 						else if(classPtr->vuClassData.classInfo_[VU_TYPE] == TYPE_BOMB)

	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _classPtr$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+8]
	cmp	ecx, 2
	jne	SHORT $LN6@SetupLoado

; 2164 : 						{
; 2165 : 								wtype=StoresList::_TYPE_BOMB_;

	mov	DWORD PTR _wtype$[ebp], 102		; 00000066H

; 2166 : 								slist=StoresList::_AIR_TO_GROUND_;

	mov	DWORD PTR _slist$[ebp], 1
	jmp	SHORT $LN3@SetupLoado
$LN6@SetupLoado:

; 2167 : 						}
; 2168 : 						else if(classPtr->vuClassData.classInfo_[VU_TYPE] == TYPE_FUEL_TANK)

	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _classPtr$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+8]
	cmp	ecx, 4
	jne	SHORT $LN4@SetupLoado

; 2169 : 						{
; 2170 : 							wtype=StoresList::_TYPE_FUEL_;

	mov	DWORD PTR _wtype$[ebp], 103		; 00000067H

; 2171 : 							slist=StoresList::_OTHER_;

	mov	DWORD PTR _slist$[ebp], 2

; 2172 : 							fuel=wc->Strength;

	mov	edx, DWORD PTR _wc$[ebp]
	movzx	eax, WORD PTR [edx+2]
	mov	DWORD PTR _fuel$[ebp], eax

; 2173 : 						}
; 2174 : 						else

	jmp	SHORT $LN3@SetupLoado
$LN4@SetupLoado:

; 2175 : 						{
; 2176 : 							wtype=StoresList::_TYPE_OTHER_;

	mov	DWORD PTR _wtype$[ebp], 104		; 00000068H

; 2177 : 							slist=StoresList::_OTHER_;

	mov	DWORD PTR _slist$[ebp], 2
$LN3@SetupLoado:

; 2178 : 						}
; 2179 : 						wpn=gStores->Create(vc->Weapon[i],wc->Name,wtype,wc->Weight,fuel,wc->DragIndex,static_cast<short>(avail)); // add stores wgt,drag factor

	movzx	ecx, WORD PTR _avail$[ebp]
	push	ecx
	mov	edx, DWORD PTR _wc$[ebp]
	movsx	eax, WORD PTR [edx+50]
	cvtsi2ss xmm0, eax
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _fuel$[ebp]
	push	ecx
	mov	edx, DWORD PTR _wc$[ebp]
	movzx	eax, WORD PTR [edx+48]
	push	eax
	mov	ecx, DWORD PTR _wtype$[ebp]
	push	ecx
	mov	edx, DWORD PTR _wc$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _vc$[ebp]
	movsx	edx, WORD PTR [ecx+eax*2+98]
	push	edx
	mov	ecx, DWORD PTR ?gStores@@3PAVStoresList@@A ; gStores
	call	?Create@StoresList@@QAEPAUStoresStr@@JPADJJJMF@Z ; StoresList::Create
	mov	DWORD PTR _wpn$[ebp], eax

; 2180 : 					}
; 2181 : 					else

	jmp	SHORT $LN2@SetupLoado
$LN14@SetupLoado:

; 2182 : 					{
; 2183 : 						slist=StoresList::_OTHER_;

	mov	DWORD PTR _slist$[ebp], 2

; 2184 : 						wpn=gStores->Create(vc->Weapon[i],wc->Name,StoresList::_TYPE_OTHER_,wc->Weight,fuel,wc->DragIndex,static_cast<short>(avail)); // add stores wgt,drag factor

	movzx	eax, WORD PTR _avail$[ebp]
	push	eax
	mov	ecx, DWORD PTR _wc$[ebp]
	movsx	edx, WORD PTR [ecx+50]
	cvtsi2ss xmm0, edx
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _fuel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _wc$[ebp]
	movzx	edx, WORD PTR [ecx+48]
	push	edx
	push	104					; 00000068H
	mov	eax, DWORD PTR _wc$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _vc$[ebp]
	movsx	eax, WORD PTR [edx+ecx*2+98]
	push	eax
	mov	ecx, DWORD PTR ?gStores@@3PAVStoresList@@A ; gStores
	call	?Create@StoresList@@QAEPAUStoresStr@@JPADJJJMF@Z ; StoresList::Create
	mov	DWORD PTR _wpn$[ebp], eax
$LN2@SetupLoado:

; 2185 : 					}
; 2186 : 					gStores->Add(wpn,slist);

	mov	ecx, DWORD PTR _slist$[ebp]
	push	ecx
	mov	edx, DWORD PTR _wpn$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?gStores@@3PAVStoresList@@A ; gStores
	call	?Add@StoresList@@QAEXPAUStoresStr@@J@Z	; StoresList::Add
$LN23@SetupLoado:

; 2187 : 				}
; 2188 : 				wpn->HardPoint[i]=vc->Weapons[i];

	mov	eax, DWORD PTR _vc$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	cx, BYTE PTR [eax+130]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _wpn$[ebp]
	mov	WORD PTR [eax+edx*2+44], cx
$LN25@SetupLoado:

; 2189 : 			}
; 2190 : 		}
; 2191 : 	}

	jmp	$LN57@SetupLoado
$LN56@SetupLoado:

; 2192 : 
; 2193 : 	ShiAssert(gStores);
; 2194 : 	if (gStores)

	cmp	DWORD PTR ?gStores@@3PAVStoresList@@A, 0 ; gStores
	je	SHORT $LN1@SetupLoado

; 2195 : 		gStores->Sort();

	mov	ecx, DWORD PTR ?gStores@@3PAVStoresList@@A ; gStores
	call	?Sort@StoresList@@QAEXXZ		; StoresList::Sort
$LN1@SetupLoado:
$LN62@SetupLoado:

; 2196 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SetupLoadoutDisplay@@YAXXZ ENDP			; SetupLoadoutDisplay
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\munition.cpp
_TEXT	SEGMENT
_Leave$ = -44						; size = 4
_ok$1 = -40						; size = 4
_classPtr$2 = -36					; size = 4
_startcount$ = -32					; size = 4
_store$ = -28						; size = 4
_weaponID$ = -24					; size = 4
_hp$ = -20						; size = 4
_cur$ = -16						; size = 4
_i$ = -12						; size = 4
_count$ = -8						; size = 4
_state$ = -4						; size = 2
_ID$ = 8						; size = 4
_hittype$ = 12						; size = 2
_control$ = 16						; size = 4
?ArmPlaneCB@@YAXJFPAVC_Base@@@Z PROC			; ArmPlaneCB

; 1848 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 1849 : 	long hp,count,weaponID,startcount;
; 1850 : 	CONTROLLIST *cur;
; 1851 : 	STORESLIST *store;
; 1852 : 	int i;
; 1853 : 	F4CSECTIONHANDLE *Leave;
; 1854 : 
; 1855 : 	if(hittype != C_TYPE_LMOUSEUP)

	movsx	eax, WORD PTR _hittype$[ebp]
	cmp	eax, 52					; 00000034H
	je	SHORT $LN19@ArmPlaneCB

; 1856 : 		return;

	jmp	$LN20@ArmPlaneCB
$LN19@ArmPlaneCB:

; 1857 : 
; 1858 : 	hp=ID >> 16;

	mov	ecx, DWORD PTR _ID$[ebp]
	sar	ecx, 16					; 00000010H
	mov	DWORD PTR _hp$[ebp], ecx

; 1859 : 	weaponID=ID & 0x0000ffff;

	mov	edx, DWORD PTR _ID$[ebp]
	and	edx, 65535				; 0000ffffH
	mov	DWORD PTR _weaponID$[ebp], edx

; 1860 : 	store=NULL;

	mov	DWORD PTR _store$[ebp], 0

; 1861 : 	ShiAssert(gStores);
; 1862 : 	if (gStores)

	cmp	DWORD PTR ?gStores@@3PAVStoresList@@A, 0 ; gStores
	je	SHORT $LN18@ArmPlaneCB

; 1863 : 		store = gStores->Find(weaponID);

	mov	eax, DWORD PTR _weaponID$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?gStores@@3PAVStoresList@@A ; gStores
	call	?Find@StoresList@@QAEPAUStoresStr@@J@Z	; StoresList::Find
	mov	DWORD PTR _store$[ebp], eax
$LN18@ArmPlaneCB:

; 1864 : 
; 1865 : 	if(store == NULL || !control)

	cmp	DWORD PTR _store$[ebp], 0
	je	SHORT $LN16@ArmPlaneCB
	cmp	DWORD PTR _control$[ebp], 0
	jne	SHORT $LN17@ArmPlaneCB
$LN16@ArmPlaneCB:

; 1866 : 		return;

	jmp	$LN20@ArmPlaneCB
$LN17@ArmPlaneCB:

; 1867 : 
; 1868 : 	count=control->GetUserNumber(0);

	push	0
	mov	ecx, DWORD PTR _control$[ebp]
	call	?GetUserNumber@C_Base@@QAEJJ@Z		; C_Base::GetUserNumber
	mov	DWORD PTR _count$[ebp], eax

; 1869 : 	startcount=count;

	mov	ecx, DWORD PTR _count$[ebp]
	mov	DWORD PTR _startcount$[ebp], ecx

; 1870 : 	count++;

	mov	edx, DWORD PTR _count$[ebp]
	add	edx, 1
	mov	DWORD PTR _count$[ebp], edx

; 1871 : 	if(count > control->GetUserNumber(1))

	push	1
	mov	ecx, DWORD PTR _control$[ebp]
	call	?GetUserNumber@C_Base@@QAEJJ@Z		; C_Base::GetUserNumber
	cmp	DWORD PTR _count$[ebp], eax
	jle	SHORT $LN15@ArmPlaneCB

; 1872 : 		count=0;

	mov	DWORD PTR _count$[ebp], 0
$LN15@ArmPlaneCB:

; 1873 : 
; 1874 : 	if(count &&  !TotalAvailable(static_cast<short>(weaponID)))

	cmp	DWORD PTR _count$[ebp], 0
	je	SHORT $LN14@ArmPlaneCB
	movzx	eax, WORD PTR _weaponID$[ebp]
	push	eax
	call	?TotalAvailable@@YAFF@Z			; TotalAvailable
	add	esp, 4
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $LN14@ArmPlaneCB

; 1875 : 		count--;

	mov	edx, DWORD PTR _count$[ebp]
	sub	edx, 1
	mov	DWORD PTR _count$[ebp], edx
$LN14@ArmPlaneCB:

; 1876 : 
; 1877 : 	if(!count && count == startcount) //None available

	cmp	DWORD PTR _count$[ebp], 0
	jne	SHORT $LN13@ArmPlaneCB
	mov	eax, DWORD PTR _count$[ebp]
	cmp	eax, DWORD PTR _startcount$[ebp]
	jne	SHORT $LN13@ArmPlaneCB

; 1878 : 	{
; 1879 : 		return;

	jmp	$LN20@ArmPlaneCB
$LN13@ArmPlaneCB:

; 1880 : 	}
; 1881 : 
; 1882 : 	Leave=UI_Enter(control->Parent_);

	mov	ecx, DWORD PTR _control$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	push	edx
	call	?UI_Enter@@YAPAUF4CSECTIONHANDLE@@PAVC_Window@@@Z ; UI_Enter
	add	esp, 4
	mov	DWORD PTR _Leave$[ebp], eax

; 1883 : 	cur=control->Parent_->GetControlList();

	mov	eax, DWORD PTR _control$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	call	?GetControlList@C_Window@@QAEPAUControlListStr@@XZ ; C_Window::GetControlList
	mov	DWORD PTR _cur$[ebp], eax
$LN12@ArmPlaneCB:

; 1884 : 	while(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN11@ArmPlaneCB

; 1885 : 	{
; 1886 : 		if(cur->Control_->GetGroup() == hp)

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetGroup@C_Base@@QAEJXZ		; C_Base::GetGroup
	cmp	eax, DWORD PTR _hp$[ebp]
	jne	SHORT $LN10@ArmPlaneCB

; 1887 : 		{
; 1888 : 			if(count)

	cmp	DWORD PTR _count$[ebp], 0
	je	SHORT $LN9@ArmPlaneCB

; 1889 : 			{
; 1890 : 				cur->Control_->SetState(C_STATE_DISABLED);

	push	21					; 00000015H
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 1891 : 				cur->Control_->SetUserNumber(0,0);

	push	0
	push	0
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?SetUserNumber@C_Base@@QAEXJJ@Z		; C_Base::SetUserNumber

; 1892 : 			}
; 1893 : 			else

	jmp	SHORT $LN8@ArmPlaneCB
$LN9@ArmPlaneCB:

; 1894 : 			{
; 1895 : 				cur->Control_->SetState(0);

	push	0
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 1896 : 				cur->Control_->SetUserNumber(0,0);

	push	0
	push	0
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?SetUserNumber@C_Base@@QAEXJJ@Z		; C_Base::SetUserNumber
$LN8@ArmPlaneCB:

; 1897 : 			}
; 1898 : 			cur->Control_->Refresh();

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN10@ArmPlaneCB:

; 1899 : 		}
; 1900 : 		cur=cur->Next;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _cur$[ebp], edx

; 1901 : 	}

	jmp	SHORT $LN12@ArmPlaneCB
$LN11@ArmPlaneCB:

; 1902 : 
; 1903 : 	short state = count<<1;

	mov	eax, DWORD PTR _count$[ebp]
	shl	eax, 1
	mov	WORD PTR _state$[ebp], ax

; 1904 : 	if (state > C_STATE_20) // JPO - lock to max state

	movsx	ecx, WORD PTR _state$[ebp]
	cmp	ecx, 20					; 00000014H
	jle	SHORT $LN7@ArmPlaneCB

; 1905 : 		state = C_STATE_20;

	mov	edx, 20					; 00000014H
	mov	WORD PTR _state$[ebp], dx
$LN7@ArmPlaneCB:

; 1906 : 
; 1907 : 	control->SetState(state);

	movzx	eax, WORD PTR _state$[ebp]
	push	eax
	mov	ecx, DWORD PTR _control$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _control$[ebp]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 1908 : 	control->SetUserNumber(0,count);

	mov	ecx, DWORD PTR _count$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _control$[ebp]
	call	?SetUserNumber@C_Base@@QAEXJJ@Z		; C_Base::SetUserNumber

; 1909 : 
; 1910 : 	for(i=0;i<4;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@ArmPlaneCB
$LN5@ArmPlaneCB:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN6@ArmPlaneCB:
	cmp	DWORD PTR _i$[ebp], 4
	jge	$LN4@ArmPlaneCB

; 1911 : 	{
; 1912 : 		if(PlaneEditList[i])

	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR ?PlaneEditList@@3PAJA[eax*4], 0
	je	$LN3@ArmPlaneCB

; 1913 : 		{
; 1914 : 			int ok;
; 1915 : 			gCurStores[i].WeaponID[hp]=static_cast<short>(weaponID);

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _hp$[ebp]
	mov	ax, WORD PTR _weaponID$[ebp]
	mov	WORD PTR ?gCurStores@@3PAULoadoutStruct@@A[ecx+edx*2], ax

; 1916 : 			if(count && !TotalAvailable(static_cast<short>(weaponID)))

	cmp	DWORD PTR _count$[ebp], 0
	je	SHORT $LN2@ArmPlaneCB
	movzx	ecx, WORD PTR _weaponID$[ebp]
	push	ecx
	call	?TotalAvailable@@YAFF@Z			; TotalAvailable
	add	esp, 4
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $LN2@ArmPlaneCB

; 1917 : 				count--;

	mov	eax, DWORD PTR _count$[ebp]
	sub	eax, 1
	mov	DWORD PTR _count$[ebp], eax
$LN2@ArmPlaneCB:

; 1918 : 			gCurStores[i].WeaponCount[hp]=static_cast<uchar>(count);

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _hp$[ebp]
	mov	al, BYTE PTR _count$[ebp]
	mov	BYTE PTR ?gCurStores@@3PAULoadoutStruct@@A[ecx+edx+32], al

; 1919 : 			ClearHardPoint(i,hp,HardPoints/2,&gCurRails[i].rail[hp]);

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 2560				; 00000a00H
	mov	edx, DWORD PTR _hp$[ebp]
	imul	edx, 160				; 000000a0H
	lea	eax, DWORD PTR ?gCurRails@@3PAURailList@@A[ecx+edx]
	push	eax
	mov	eax, DWORD PTR ?HardPoints@@3JA		; HardPoints
	cdq
	sub	eax, edx
	sar	eax, 1
	push	eax
	mov	ecx, DWORD PTR _hp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	call	?ClearHardPoint@@YAXJJJPAVRailInfo@@@Z	; ClearHardPoint
	add	esp, 16					; 00000010H

; 1920 : 			//if (g_bNewRackData) {
; 1921 : 				Falcon4EntityClassType* classPtr = &Falcon4ClassTable[gVehID];

	mov	eax, DWORD PTR ?gVehID@@3HA		; gVehID
	imul	eax, 81					; 00000051H
	add	eax, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	DWORD PTR _classPtr$2[ebp], eax

; 1922 : 				ok = GetJRackAndWeapon(gVCPtr, classPtr, gCurStores[i].WeaponID[hp], gCurStores[i].WeaponCount[hp], static_cast<short>(hp), &gCurRails[i].rail[hp]);

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 2560				; 00000a00H
	mov	edx, DWORD PTR _hp$[ebp]
	imul	edx, 160				; 000000a0H
	lea	eax, DWORD PTR ?gCurRails@@3PAURailList@@A[ecx+edx]
	push	eax
	movzx	ecx, WORD PTR _hp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 48					; 00000030H
	mov	eax, DWORD PTR _hp$[ebp]
	movzx	cx, BYTE PTR ?gCurStores@@3PAULoadoutStruct@@A[edx+eax+32]
	movzx	edx, cx
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _hp$[ebp]
	movzx	edx, WORD PTR ?gCurStores@@3PAULoadoutStruct@@A[eax+ecx*2]
	push	edx
	mov	eax, DWORD PTR _classPtr$2[ebp]
	push	eax
	mov	ecx, DWORD PTR ?gVCPtr@@3PAUVehicleClassDataType@@A ; gVCPtr
	push	ecx
	call	?GetJRackAndWeapon@@YAHPAUVehicleClassDataType@@PAUFalcon4EntityClassType@@FFFPAVRailInfo@@@Z ; GetJRackAndWeapon
	add	esp, 24					; 00000018H
	mov	DWORD PTR _ok$1[ebp], eax

; 1923 : 			//}
; 1924 : 			//else
; 1925 : 			//	ok = GetRackAndWeapon(gVCPtr,static_cast<short>(gVehID),gCurStores[i].WeaponID[hp],gCurStores[i].WeaponCount[hp],static_cast<short>(hp),static_cast<short>(HardPoints/2),&gCurRails[i].rail[hp]);
; 1926 : 
; 1927 : 			if(ok)

	cmp	DWORD PTR _ok$1[ebp], 0
	je	SHORT $LN3@ArmPlaneCB

; 1928 : 				LoadHardPoint(i,hp,HardPoints/2,&gCurRails[i].rail[hp]);

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 2560				; 00000a00H
	mov	eax, DWORD PTR _hp$[ebp]
	imul	eax, 160				; 000000a0H
	lea	ecx, DWORD PTR ?gCurRails@@3PAURailList@@A[edx+eax]
	push	ecx
	mov	eax, DWORD PTR ?HardPoints@@3JA		; HardPoints
	cdq
	sub	eax, edx
	sar	eax, 1
	push	eax
	mov	edx, DWORD PTR _hp$[ebp]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	call	?LoadHardPoint@@YAXJJJPAVRailInfo@@@Z	; LoadHardPoint
	add	esp, 16					; 00000010H
$LN3@ArmPlaneCB:

; 1929 : 		}
; 1930 : 	}

	jmp	$LN5@ArmPlaneCB
$LN4@ArmPlaneCB:

; 1931 : 	UpdateStoresTally(control->Parent_);

	mov	ecx, DWORD PTR _control$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	push	edx
	call	?UpdateStoresTally@@YAXPAVC_Window@@@Z	; UpdateStoresTally
	add	esp, 4

; 1932 : 
; 1933 : 	control->Parent_->RefreshClient(2);

	push	2
	mov	eax, DWORD PTR _control$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	call	?RefreshClient@C_Window@@QAEXJ@Z	; C_Window::RefreshClient

; 1934 : 	UI_Leave(Leave);

	mov	ecx, DWORD PTR _Leave$[ebp]
	push	ecx
	call	?UI_Leave@@YAXPAUF4CSECTIONHANDLE@@@Z	; UI_Leave
	add	esp, 4
$LN20@ArmPlaneCB:

; 1935 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ArmPlaneCB@@YAXJFPAVC_Base@@@Z ENDP			; ArmPlaneCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\munition.cpp
_TEXT	SEGMENT
_startcount$ = -28					; size = 4
_store$ = -24						; size = 4
_hp$ = -20						; size = 4
_weaponID$ = -16					; size = 4
_i$ = -12						; size = 4
_cur$ = -8						; size = 4
_count$ = -4						; size = 4
_ID$ = 8						; size = 4
_hittype$ = 12						; size = 2
_control$ = 16						; size = 4
?InternalArmPlaneCB@@YAXJFPAVC_Base@@@Z PROC		; InternalArmPlaneCB

; 1766 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi

; 1767 : 	long hp,count,weaponID,startcount;
; 1768 : 	CONTROLLIST *cur;
; 1769 : 	STORESLIST *store;
; 1770 : 	int i;
; 1771 : 
; 1772 : 	if(hittype != C_TYPE_LMOUSEUP && hittype != C_TYPE_REPEAT)

	movsx	eax, WORD PTR _hittype$[ebp]
	cmp	eax, 52					; 00000034H
	je	SHORT $LN21@InternalAr
	movsx	ecx, WORD PTR _hittype$[ebp]
	cmp	ecx, 70					; 00000046H
	je	SHORT $LN21@InternalAr

; 1773 : 		return;

	jmp	$LN22@InternalAr
$LN21@InternalAr:

; 1774 : 
; 1775 : 	hp=ID >> 16;

	mov	edx, DWORD PTR _ID$[ebp]
	sar	edx, 16					; 00000010H
	mov	DWORD PTR _hp$[ebp], edx

; 1776 : 	weaponID=ID & 0x0000ffff;

	mov	eax, DWORD PTR _ID$[ebp]
	and	eax, 65535				; 0000ffffH
	mov	DWORD PTR _weaponID$[ebp], eax

; 1777 : 	store=NULL;

	mov	DWORD PTR _store$[ebp], 0

; 1778 : 	ShiAssert(gStores);
; 1779 : 	if (gStores)

	cmp	DWORD PTR ?gStores@@3PAVStoresList@@A, 0 ; gStores
	je	SHORT $LN20@InternalAr

; 1780 : 		store = gStores->Find(weaponID);

	mov	ecx, DWORD PTR _weaponID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?gStores@@3PAVStoresList@@A ; gStores
	call	?Find@StoresList@@QAEPAUStoresStr@@J@Z	; StoresList::Find
	mov	DWORD PTR _store$[ebp], eax
$LN20@InternalAr:

; 1781 : 
; 1782 : 	if(store == NULL)

	cmp	DWORD PTR _store$[ebp], 0
	jne	SHORT $LN19@InternalAr

; 1783 : 		return;

	jmp	$LN22@InternalAr
$LN19@InternalAr:

; 1784 : 
; 1785 : 	count=control->GetUserNumber(0);

	push	0
	mov	ecx, DWORD PTR _control$[ebp]
	call	?GetUserNumber@C_Base@@QAEJJ@Z		; C_Base::GetUserNumber
	mov	DWORD PTR _count$[ebp], eax

; 1786 : 	startcount=count;

	mov	edx, DWORD PTR _count$[ebp]
	mov	DWORD PTR _startcount$[ebp], edx

; 1787 : 	if(control->GetRelY() < control->GetH()/2)

	mov	eax, DWORD PTR _control$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _control$[ebp]
	mov	eax, DWORD PTR [edx+108]
	call	eax
	mov	esi, eax
	mov	ecx, DWORD PTR _control$[ebp]
	call	?GetH@C_Base@@QAEJXZ			; C_Base::GetH
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	esi, eax
	jge	SHORT $LN18@InternalAr

; 1788 : 		count++;

	mov	ecx, DWORD PTR _count$[ebp]
	add	ecx, 1
	mov	DWORD PTR _count$[ebp], ecx

; 1789 : 	else

	jmp	SHORT $LN17@InternalAr
$LN18@InternalAr:

; 1790 : 		count--;

	mov	edx, DWORD PTR _count$[ebp]
	sub	edx, 1
	mov	DWORD PTR _count$[ebp], edx
$LN17@InternalAr:

; 1791 : 	if(count < 0)

	cmp	DWORD PTR _count$[ebp], 0
	jge	SHORT $LN16@InternalAr

; 1792 : 		count=0;

	mov	DWORD PTR _count$[ebp], 0
$LN16@InternalAr:

; 1793 : 
; 1794 : 	if(count > control->GetUserNumber(1))

	push	1
	mov	ecx, DWORD PTR _control$[ebp]
	call	?GetUserNumber@C_Base@@QAEJJ@Z		; C_Base::GetUserNumber
	cmp	DWORD PTR _count$[ebp], eax
	jle	SHORT $LN15@InternalAr

; 1795 : 		count=control->GetUserNumber(1);

	push	1
	mov	ecx, DWORD PTR _control$[ebp]
	call	?GetUserNumber@C_Base@@QAEJJ@Z		; C_Base::GetUserNumber
	mov	DWORD PTR _count$[ebp], eax
$LN15@InternalAr:

; 1796 : 
; 1797 : 	if(count && !TotalAvailable(static_cast<short>(weaponID)))

	cmp	DWORD PTR _count$[ebp], 0
	je	SHORT $LN14@InternalAr
	movzx	eax, WORD PTR _weaponID$[ebp]
	push	eax
	call	?TotalAvailable@@YAFF@Z			; TotalAvailable
	add	esp, 4
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $LN14@InternalAr

; 1798 : 		count--;

	mov	edx, DWORD PTR _count$[ebp]
	sub	edx, 1
	mov	DWORD PTR _count$[ebp], edx
$LN14@InternalAr:

; 1799 : 
; 1800 : 	if(!count && count == startcount) //None available

	cmp	DWORD PTR _count$[ebp], 0
	jne	SHORT $LN13@InternalAr
	mov	eax, DWORD PTR _count$[ebp]
	cmp	eax, DWORD PTR _startcount$[ebp]
	jne	SHORT $LN13@InternalAr

; 1801 : 	{
; 1802 : 		return;

	jmp	$LN22@InternalAr
$LN13@InternalAr:

; 1803 : 	}
; 1804 : 
; 1805 : 	cur=control->Parent_->GetControlList();

	mov	ecx, DWORD PTR _control$[ebp]
	mov	ecx, DWORD PTR [ecx+48]
	call	?GetControlList@C_Window@@QAEPAUControlListStr@@XZ ; C_Window::GetControlList
	mov	DWORD PTR _cur$[ebp], eax
$LN12@InternalAr:

; 1806 : 	while(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN11@InternalAr

; 1807 : 	{
; 1808 : 		if(cur->Control_->GetGroup() == hp)

	mov	edx, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetGroup@C_Base@@QAEJXZ		; C_Base::GetGroup
	cmp	eax, DWORD PTR _hp$[ebp]
	jne	SHORT $LN10@InternalAr

; 1809 : 		{
; 1810 : 			if(count)

	cmp	DWORD PTR _count$[ebp], 0
	je	SHORT $LN9@InternalAr

; 1811 : 			{
; 1812 : 				cur->Control_->SetState(C_STATE_DISABLED);

	push	21					; 00000015H
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [eax+56]
	call	edx

; 1813 : 				cur->Control_->SetUserNumber(0,0);

	push	0
	push	0
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?SetUserNumber@C_Base@@QAEXJJ@Z		; C_Base::SetUserNumber

; 1814 : 			}
; 1815 : 			else

	jmp	SHORT $LN8@InternalAr
$LN9@InternalAr:

; 1816 : 			{
; 1817 : 				cur->Control_->SetState(0);

	push	0
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 1818 : 				cur->Control_->SetUserNumber(0,0);

	push	0
	push	0
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?SetUserNumber@C_Base@@QAEXJJ@Z		; C_Base::SetUserNumber
$LN8@InternalAr:

; 1819 : 			}
; 1820 : 			cur->Control_->Refresh();

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN10@InternalAr:

; 1821 : 		}
; 1822 : 		cur=cur->Next;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _cur$[ebp], edx

; 1823 : 	}

	jmp	SHORT $LN12@InternalAr
$LN11@InternalAr:

; 1824 : 
; 1825 : 	if(count)

	cmp	DWORD PTR _count$[ebp], 0
	je	SHORT $LN7@InternalAr

; 1826 : 		control->SetState(2);

	push	2
	mov	eax, DWORD PTR _control$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _control$[ebp]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 1827 : 	else

	jmp	SHORT $LN6@InternalAr
$LN7@InternalAr:

; 1828 : 		control->SetState(0);

	push	0
	mov	ecx, DWORD PTR _control$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _control$[ebp]
	mov	eax, DWORD PTR [edx+56]
	call	eax
$LN6@InternalAr:

; 1829 : 
; 1830 : 	control->SetUserNumber(0,count);

	mov	ecx, DWORD PTR _count$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _control$[ebp]
	call	?SetUserNumber@C_Base@@QAEXJJ@Z		; C_Base::SetUserNumber

; 1831 : 
; 1832 : 	for(i=0;i<4;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN5@InternalAr
$LN4@InternalAr:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN5@InternalAr:
	cmp	DWORD PTR _i$[ebp], 4
	jge	SHORT $LN3@InternalAr

; 1833 : 	{
; 1834 : 		if(PlaneEditList[i])

	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR ?PlaneEditList@@3PAJA[eax*4], 0
	je	SHORT $LN2@InternalAr

; 1835 : 		{
; 1836 : 			gCurStores[i].WeaponID[hp]=static_cast<short>(weaponID);

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _hp$[ebp]
	mov	ax, WORD PTR _weaponID$[ebp]
	mov	WORD PTR ?gCurStores@@3PAULoadoutStruct@@A[ecx+edx*2], ax

; 1837 : 			if(count && !TotalAvailable(static_cast<short>(weaponID)))

	cmp	DWORD PTR _count$[ebp], 0
	je	SHORT $LN1@InternalAr
	movzx	ecx, WORD PTR _weaponID$[ebp]
	push	ecx
	call	?TotalAvailable@@YAFF@Z			; TotalAvailable
	add	esp, 4
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $LN1@InternalAr

; 1838 : 				count--;

	mov	eax, DWORD PTR _count$[ebp]
	sub	eax, 1
	mov	DWORD PTR _count$[ebp], eax
$LN1@InternalAr:

; 1839 : 			gCurStores[i].WeaponCount[hp]=static_cast<uchar>(count);

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _hp$[ebp]
	mov	al, BYTE PTR _count$[ebp]
	mov	BYTE PTR ?gCurStores@@3PAULoadoutStruct@@A[ecx+edx+32], al
$LN2@InternalAr:

; 1840 : 		}
; 1841 : 	}

	jmp	SHORT $LN4@InternalAr
$LN3@InternalAr:

; 1842 : 	UpdateStoresTally(control->Parent_);

	mov	ecx, DWORD PTR _control$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	push	edx
	call	?UpdateStoresTally@@YAXPAVC_Window@@@Z	; UpdateStoresTally
	add	esp, 4

; 1843 : 
; 1844 : 	control->Parent_->RefreshClient(2);

	push	2
	mov	eax, DWORD PTR _control$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	call	?RefreshClient@C_Window@@QAEXJ@Z	; C_Window::RefreshClient
$LN22@InternalAr:

; 1845 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?InternalArmPlaneCB@@YAXJFPAVC_Base@@@Z ENDP		; InternalArmPlaneCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\munition.cpp
_TEXT	SEGMENT
_avail$ = -44						; size = 4
_wid$ = -40						; size = 4
_color$ = -36						; size = 4
_availID$ = -32						; size = 4
_i$ = -28						; size = 4
_cur$ = -24						; size = 4
_txt$ = -20						; size = 4
_buf$ = -16						; size = 10
__$ArrayPad$ = -4					; size = 4
_win$ = 8						; size = 4
?UpdateStoresTally@@YAXPAVC_Window@@@Z PROC		; UpdateStoresTally

; 1645 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 1646 : 	long i,wid,color,avail,availID;
; 1647 : 	CONTROLLIST *cur;
; 1648 : 	C_Text *txt;
; 1649 : 	_TCHAR buf[STRING_BUFFER_SIZE];
; 1650 : 
; 1651 : 	TallyStores();

	call	?TallyStores@@YAXXZ			; TallyStores

; 1652 : 
; 1653 : 	cur=win->GetControlList();

	mov	ecx, DWORD PTR _win$[ebp]
	call	?GetControlList@C_Window@@QAEPAUControlListStr@@XZ ; C_Window::GetControlList
	mov	DWORD PTR _cur$[ebp], eax
$LN24@UpdateStor:

; 1654 : 	while(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	$LN23@UpdateStor

; 1655 : 	{
; 1656 : 		// Update Inventory Numbers (Out -> High)
; 1657 : 		if((cur->Control_->GetID() & 0xff000000) == (1 << 25))

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetID@C_Base@@QAEJXZ			; C_Base::GetID
	and	eax, -16777216				; ff000000H
	cmp	eax, 33554432				; 02000000H
	jne	$LN22@UpdateStor

; 1658 : 		{
; 1659 : 			cur->Control_->Refresh();

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+160]
	call	eax

; 1660 : 			avail=TotalAvailable(static_cast<short>(cur->Control_->GetID() & 0x0000ffff));

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetID@C_Base@@QAEJXZ			; C_Base::GetID
	and	eax, 65535				; 0000ffffH
	push	eax
	call	?TotalAvailable@@YAFF@Z			; TotalAvailable
	add	esp, 4
	movsx	edx, ax
	mov	DWORD PTR _avail$[ebp], edx

; 1661 : 			if(!avail)

	cmp	DWORD PTR _avail$[ebp], 0
	jne	SHORT $LN21@UpdateStor

; 1662 : 			{
; 1663 : 				availID=TXT_SUPPLY_OUT;

	mov	DWORD PTR _availID$[ebp], 290		; 00000122H

; 1664 : 				color=0x0000ff;

	mov	DWORD PTR _color$[ebp], 255		; 000000ffH
	jmp	SHORT $LN16@UpdateStor
$LN21@UpdateStor:

; 1665 : 			}
; 1666 : 			else if(avail < 700)

	cmp	DWORD PTR _avail$[ebp], 700		; 000002bcH
	jge	SHORT $LN19@UpdateStor

; 1667 : 			{
; 1668 : 				availID=TXT_SUPPLY_LOW;

	mov	DWORD PTR _availID$[ebp], 291		; 00000123H

; 1669 : 				color=0x00ffff;

	mov	DWORD PTR _color$[ebp], 65535		; 0000ffffH
	jmp	SHORT $LN16@UpdateStor
$LN19@UpdateStor:

; 1670 : 			}
; 1671 : 			else if(avail < 1500)

	cmp	DWORD PTR _avail$[ebp], 1500		; 000005dcH
	jge	SHORT $LN17@UpdateStor

; 1672 : 			{
; 1673 : 				availID=TXT_SUPPLY_MEDIUM;

	mov	DWORD PTR _availID$[ebp], 292		; 00000124H

; 1674 : 				color=0xeeeeee;

	mov	DWORD PTR _color$[ebp], 15658734	; 00eeeeeeH

; 1675 : 			}
; 1676 : 			else

	jmp	SHORT $LN16@UpdateStor
$LN17@UpdateStor:

; 1677 : 			{
; 1678 : 				availID=TXT_SUPPLY_HIGH;

	mov	DWORD PTR _availID$[ebp], 293		; 00000125H

; 1679 : 				color=0x00ff00;

	mov	DWORD PTR _color$[ebp], 65280		; 0000ff00H
$LN16@UpdateStor:

; 1680 : 			}
; 1681 : 
; 1682 : 			((C_Text*)cur->Control_)->SetText(availID);

	mov	eax, DWORD PTR _availID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+252]
	call	eax

; 1683 : 			((C_Text*)cur->Control_)->SetFGColor(color);

	mov	ecx, DWORD PTR _color$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?SetFGColor@C_Text@@QAEXK@Z		; C_Text::SetFGColor

; 1684 : 			cur->Control_->Refresh();

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [eax+160]
	call	edx
$LN22@UpdateStor:

; 1685 : 		}
; 1686 : 		// Update Onboard Count
; 1687 : 		if((cur->Control_->GetID() & 0x0f000000) == (1 << 24))

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetID@C_Base@@QAEJXZ			; C_Base::GetID
	and	eax, 251658240				; 0f000000H
	cmp	eax, 16777216				; 01000000H
	jne	$LN15@UpdateStor

; 1688 : 		{
; 1689 : 			cur->Control_->Refresh();

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+160]
	call	eax

; 1690 : 			_tcscpy(buf," ");

	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 1691 : 			((C_Text*)cur->Control_)->SetText(buf);

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [eax+256]
	call	edx

; 1692 : 
; 1693 : 			wid=-1;

	mov	DWORD PTR _wid$[ebp], -1

; 1694 : 			for(i=0;i<QuantityCount[FirstPlane];i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN14@UpdateStor
$LN13@UpdateStor:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN14@UpdateStor:
	mov	ecx, DWORD PTR ?FirstPlane@@3JA		; FirstPlane
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _QuantityCount[ecx*4]
	jge	SHORT $LN12@UpdateStor

; 1695 : 			{
; 1696 : 				if(Quantity[FirstPlane][0][i] == (cur->Control_->GetID() & 0x00ffffff))

	mov	eax, DWORD PTR ?FirstPlane@@3JA		; FirstPlane
	shl	eax, 7
	mov	ecx, 64					; 00000040H
	imul	ecx, 0
	lea	esi, DWORD PTR _Quantity[eax+ecx]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetID@C_Base@@QAEJXZ			; C_Base::GetID
	and	eax, 16777215				; 00ffffffH
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR [esi+ecx*4], eax
	jne	SHORT $LN11@UpdateStor

; 1697 : 				{
; 1698 : 					wid=i;

	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _wid$[ebp], edx

; 1699 : 					break;

	jmp	SHORT $LN12@UpdateStor
$LN11@UpdateStor:

; 1700 : 				}
; 1701 : 			}

	jmp	SHORT $LN13@UpdateStor
$LN12@UpdateStor:

; 1702 : 			if(wid != -1)

	cmp	DWORD PTR _wid$[ebp], -1
	je	SHORT $LN9@UpdateStor

; 1703 : 				if(Quantity[FirstPlane][1][wid])

	mov	eax, DWORD PTR ?FirstPlane@@3JA		; FirstPlane
	shl	eax, 7
	mov	ecx, 64					; 00000040H
	shl	ecx, 0
	lea	edx, DWORD PTR _Quantity[eax+ecx]
	mov	eax, DWORD PTR _wid$[ebp]
	cmp	DWORD PTR [edx+eax*4], 0
	je	SHORT $LN9@UpdateStor

; 1704 : 				{
; 1705 : 					_stprintf(buf,"%1d",Quantity[FirstPlane][1][wid]);

	mov	ecx, DWORD PTR ?FirstPlane@@3JA		; FirstPlane
	shl	ecx, 7
	mov	edx, 64					; 00000040H
	shl	edx, 0
	lea	eax, DWORD PTR _Quantity[ecx+edx]
	mov	ecx, DWORD PTR _wid$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	push	OFFSET ??_C@_03GNGPFOOL@?$CF1d?$AA@
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1706 : 					((C_Text*)cur->Control_)->SetText(buf);

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+256]
	call	eax
$LN9@UpdateStor:

; 1707 : 				}
; 1708 : 			cur->Control_->Refresh();

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN15@UpdateStor:

; 1709 : 		}
; 1710 : 
; 1711 : 		cur=cur->Next;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _cur$[ebp], edx

; 1712 : 	}

	jmp	$LN24@UpdateStor
$LN23@UpdateStor:

; 1713 : 
; 1714 : 	DetermineWeight(gLoadoutFlightID);

	mov	eax, DWORD PTR ?gLoadoutFlightID@@3VVU_ID@@A+4
	push	eax
	mov	ecx, DWORD PTR ?gLoadoutFlightID@@3VVU_ID@@A
	push	ecx
	call	?DetermineWeight@@YAXVVU_ID@@@Z		; DetermineWeight
	add	esp, 8

; 1715 : 
; 1716 : 	txt=(C_Text*)win->FindControl(MAX_WEIGHT);

	push	16004					; 00003e84H
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _txt$[ebp], eax

; 1717 : 	if(txt)

	cmp	DWORD PTR _txt$[ebp], 0
	je	SHORT $LN8@UpdateStor

; 1718 : 	{
; 1719 : 		_stprintf(buf,"%1d",_MAX_WEIGHT_[FirstPlane]);

	mov	edx, DWORD PTR ?FirstPlane@@3JA		; FirstPlane
	mov	eax, DWORD PTR __MAX_WEIGHT_[edx*4]
	push	eax
	push	OFFSET ??_C@_03GNGPFOOL@?$CF1d?$AA@
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1720 : 		txt->SetText(buf);

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	mov	eax, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+256]
	call	eax

; 1721 : 		txt->Refresh();

	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN8@UpdateStor:

; 1722 : 	}
; 1723 : 	txt=(C_Text*)win->FindControl(CURRENT_WEIGHT);

	push	16005					; 00003e85H
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _txt$[ebp], eax

; 1724 : 	if(txt)

	cmp	DWORD PTR _txt$[ebp], 0
	je	SHORT $LN7@UpdateStor

; 1725 : 	{
; 1726 : 		if(_CURRENT_WEIGHT_[FirstPlane] > _MAX_WEIGHT_[FirstPlane])

	mov	ecx, DWORD PTR ?FirstPlane@@3JA		; FirstPlane
	mov	edx, DWORD PTR ?FirstPlane@@3JA		; FirstPlane
	mov	eax, DWORD PTR __CURRENT_WEIGHT_[ecx*4]
	cmp	eax, DWORD PTR __MAX_WEIGHT_[edx*4]
	jle	SHORT $LN6@UpdateStor

; 1727 : 			txt->SetFGColor(0x0000ff);

	push	255					; 000000ffH
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetFGColor@C_Text@@QAEXK@Z		; C_Text::SetFGColor

; 1728 : 		else

	jmp	SHORT $LN5@UpdateStor
$LN6@UpdateStor:

; 1729 : 			txt->SetFGColor(0xd9a051);

	push	14262353				; 00d9a051H
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetFGColor@C_Text@@QAEXK@Z		; C_Text::SetFGColor
$LN5@UpdateStor:

; 1730 : 		_stprintf(buf,"%1d",_CURRENT_WEIGHT_[FirstPlane]);

	mov	ecx, DWORD PTR ?FirstPlane@@3JA		; FirstPlane
	mov	edx, DWORD PTR __CURRENT_WEIGHT_[ecx*4]
	push	edx
	push	OFFSET ??_C@_03GNGPFOOL@?$CF1d?$AA@
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1731 : 		txt->SetText(buf);

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax+256]
	call	edx

; 1732 : 		txt->Refresh();

	mov	eax, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN7@UpdateStor:

; 1733 : 	}
; 1734 : 	txt=(C_Text*)win->FindControl(CLEAN_WEIGHT);

	push	18104					; 000046b8H
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _txt$[ebp], eax

; 1735 : 	if(txt)

	cmp	DWORD PTR _txt$[ebp], 0
	je	SHORT $LN4@UpdateStor

; 1736 : 	{
; 1737 : 		_stprintf(buf,"%1d",_CLEAN_WEIGHT_[FirstPlane]);

	mov	ecx, DWORD PTR ?FirstPlane@@3JA		; FirstPlane
	mov	edx, DWORD PTR __CLEAN_WEIGHT_[ecx*4]
	push	edx
	push	OFFSET ??_C@_03GNGPFOOL@?$CF1d?$AA@
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1738 : 		txt->SetText(buf);

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax+256]
	call	edx

; 1739 : 		txt->Refresh();

	mov	eax, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN4@UpdateStor:

; 1740 : 	}
; 1741 : 	txt=(C_Text*)win->FindControl(DRAG_FACTOR);

	push	16008					; 00003e88H
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _txt$[ebp], eax

; 1742 : 	if(txt)

	cmp	DWORD PTR _txt$[ebp], 0
	je	SHORT $LN3@UpdateStor

; 1743 : 	{
; 1744 : 		_stprintf(buf,"%5.1f",_DRAG_FACTOR_[FirstPlane]);

	mov	ecx, DWORD PTR ?FirstPlane@@3JA		; FirstPlane
	cvtss2sd xmm0, DWORD PTR __DRAG_FACTOR_[ecx*4]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_05CGHOGGKE@?$CF5?41f?$AA@
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 1745 : 		Uni_Float(buf);

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	?Uni_Float@@YAXPAD@Z			; Uni_Float
	add	esp, 4

; 1746 : 		txt->SetText(buf);

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax+256]
	call	edx

; 1747 : 		txt->Refresh();

	mov	eax, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN3@UpdateStor:

; 1748 : 	}
; 1749 : 	txt=(C_Text*)win->FindControl(MUNITIONS_WEIGHT);

	push	16006					; 00003e86H
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _txt$[ebp], eax

; 1750 : 	if(txt)

	cmp	DWORD PTR _txt$[ebp], 0
	je	SHORT $LN2@UpdateStor

; 1751 : 	{
; 1752 : 		_stprintf(buf,"%1d",_MUNITIONS_WEIGHT_[FirstPlane]);

	mov	ecx, DWORD PTR ?FirstPlane@@3JA		; FirstPlane
	mov	edx, DWORD PTR __MUNITIONS_WEIGHT_[ecx*4]
	push	edx
	push	OFFSET ??_C@_03GNGPFOOL@?$CF1d?$AA@
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1753 : 		txt->SetText(buf);

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax+256]
	call	edx

; 1754 : 		txt->Refresh();

	mov	eax, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN2@UpdateStor:

; 1755 : 	}
; 1756 : 	txt=(C_Text*)win->FindControl(FUEL_WEIGHT);

	push	16007					; 00003e87H
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _txt$[ebp], eax

; 1757 : 	if(txt)

	cmp	DWORD PTR _txt$[ebp], 0
	je	SHORT $LN1@UpdateStor

; 1758 : 	{
; 1759 : 		_stprintf(buf,"%1d",_FUEL_WEIGHT_[FirstPlane]);

	mov	ecx, DWORD PTR ?FirstPlane@@3JA		; FirstPlane
	mov	edx, DWORD PTR __FUEL_WEIGHT_[ecx*4]
	push	edx
	push	OFFSET ??_C@_03GNGPFOOL@?$CF1d?$AA@
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1760 : 		txt->SetText(buf);

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax+256]
	call	edx

; 1761 : 		txt->Refresh();

	mov	eax, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN1@UpdateStor:

; 1762 : 	}
; 1763 : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateStoresTally@@YAXPAVC_Window@@@Z ENDP		; UpdateStoresTally
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\munition.cpp
_TEXT	SEGMENT
$T1 = -260						; size = 8
_vc$ = -252						; size = 4
_vid$ = -248						; size = 4
tv451 = -244						; size = 4
tv536 = -240						; size = 4
_session$ = -236					; size = 4
_takeoff$ = -232					; size = 4
_status$ = -228						; size = 4
_flt$ = -224						; size = 4
_i$ = -220						; size = 4
_win$ = -216						; size = 4
_txt$ = -212						; size = 4
_btn$ = -208						; size = 4
_buf$ = -204						; size = 200
__$ArrayPad$ = -4					; size = 4
_FlightID$ = 8						; size = 8
?SetupMunitionsWindow@@YAXVVU_ID@@@Z PROC		; SetupMunitionsWindow

; 1437 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 260				; 00000104H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1438 : 	C_Window *win=NULL;

	mov	DWORD PTR _win$[ebp], 0

; 1439 : 	C_Button *btn=NULL;

	mov	DWORD PTR _btn$[ebp], 0

; 1440 : 	C_Text *txt=NULL;

	mov	DWORD PTR _txt$[ebp], 0

; 1441 : 	Flight flt;
; 1442 : 	long vid=0,status=0;

	mov	DWORD PTR _vid$[ebp], 0
	mov	DWORD PTR _status$[ebp], 0

; 1443 : 	_TCHAR buf[200];
; 1444 : 	int i=0;

	mov	DWORD PTR _i$[ebp], 0

; 1445 : 	long takeoff=0;

	mov	DWORD PTR _takeoff$[ebp], 0

; 1446 : 	VehicleClassDataType *vc=NULL;

	mov	DWORD PTR _vc$[ebp], 0

; 1447 : 	FalconSessionEntity *session=NULL;

	mov	DWORD PTR _session$[ebp], 0

; 1448 : 
; 1449 : 	win=gMainHandler->FindWindow(MUNITIONS_WIN);

	push	16000					; 00003e80H
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z ; C_Handler::FindWindowA
	mov	DWORD PTR _win$[ebp], eax

; 1450 : 	if(win == NULL)

	cmp	DWORD PTR _win$[ebp], 0
	jne	SHORT $LN51@SetupMunit

; 1451 : 		return;

	jmp	$LN52@SetupMunit
$LN51@SetupMunit:

; 1452 : 
; 1453 : 	flt=(Flight)FindUnit(FlightID);

	mov	eax, DWORD PTR _FlightID$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _FlightID$[ebp]
	push	ecx
	call	?FindUnit@@YAPAVUnitClass@@VVU_ID@@@Z	; FindUnit
	add	esp, 8
	mov	DWORD PTR _flt$[ebp], eax

; 1454 : 	if(flt == NULL)

	cmp	DWORD PTR _flt$[ebp], 0
	jne	$LN50@SetupMunit

; 1455 : 	{
; 1456 : 		txt=(C_Text*)win->FindControl(FLIGHT_CALLSIGN);

	push	13110					; 00003336H
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _txt$[ebp], eax

; 1457 : 		if(txt)

	cmp	DWORD PTR _txt$[ebp], 0
	je	SHORT $LN49@SetupMunit

; 1458 : 			txt->SetText(" ");

	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	mov	edx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax+256]
	call	edx
$LN49@SetupMunit:

; 1459 : 		txt=(C_Text*)win->FindControl(STATUS_FIELD);

	push	18002					; 00004652H
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _txt$[ebp], eax

; 1460 : 		if(txt)

	cmp	DWORD PTR _txt$[ebp], 0
	je	SHORT $LN48@SetupMunit

; 1461 : 			txt->SetText(" ");

	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	mov	eax, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+256]
	call	eax
$LN48@SetupMunit:

; 1462 : 		for(i=0;i<4;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN47@SetupMunit
$LN46@SetupMunit:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN47@SetupMunit:
	cmp	DWORD PTR _i$[ebp], 4
	jge	SHORT $LN45@SetupMunit

; 1463 : 			SetPlaneToArm(i,FALSE);

	push	0
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	call	?SetPlaneToArm@@YAXJH@Z			; SetPlaneToArm
	add	esp, 8
	jmp	SHORT $LN46@SetupMunit
$LN45@SetupMunit:

; 1464 : 		btn=(C_Button *)win->FindControl(AIR_1);

	push	16018					; 00003e92H
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _btn$[ebp], eax

; 1465 : 		if(btn)

	cmp	DWORD PTR _btn$[ebp], 0
	je	SHORT $LN44@SetupMunit

; 1466 : 		{
; 1467 : 			btn->Refresh();

	mov	eax, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax

; 1468 : 			btn->SetState(0);

	push	0
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 1469 : 			btn->SetFlagBitOff(C_BIT_ENABLED);

	push	2048					; 00000800H
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 1470 : 			btn->SetAllLabel(" ");

	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetAllLabel@C_Button@@QAEXPAD@Z	; C_Button::SetAllLabel

; 1471 : 			btn->Refresh();

	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN44@SetupMunit:

; 1472 : 		}
; 1473 : 		btn=(C_Button *)win->FindControl(AIR_2);

	push	16019					; 00003e93H
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _btn$[ebp], eax

; 1474 : 		if(btn)

	cmp	DWORD PTR _btn$[ebp], 0
	je	SHORT $LN43@SetupMunit

; 1475 : 		{
; 1476 : 			btn->Refresh();

	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax

; 1477 : 			btn->SetState(0);

	push	0
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 1478 : 			btn->SetFlagBitOff(C_BIT_ENABLED);

	push	2048					; 00000800H
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 1479 : 			btn->SetAllLabel(" ");

	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetAllLabel@C_Button@@QAEXPAD@Z	; C_Button::SetAllLabel

; 1480 : 			btn->Refresh();

	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN43@SetupMunit:

; 1481 : 		}
; 1482 : 		btn=(C_Button *)win->FindControl(AIR_3);

	push	16020					; 00003e94H
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _btn$[ebp], eax

; 1483 : 		if(btn)

	cmp	DWORD PTR _btn$[ebp], 0
	je	SHORT $LN42@SetupMunit

; 1484 : 		{
; 1485 : 			btn->Refresh();

	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax

; 1486 : 			btn->SetState(0);

	push	0
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 1487 : 			btn->SetFlagBitOff(C_BIT_ENABLED);

	push	2048					; 00000800H
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 1488 : 			btn->SetAllLabel(" ");

	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetAllLabel@C_Button@@QAEXPAD@Z	; C_Button::SetAllLabel

; 1489 : 			btn->Refresh();

	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN42@SetupMunit:

; 1490 : 		}
; 1491 : 		btn=(C_Button *)win->FindControl(AIR_4);

	push	16021					; 00003e95H
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _btn$[ebp], eax

; 1492 : 		if(btn)

	cmp	DWORD PTR _btn$[ebp], 0
	je	SHORT $LN41@SetupMunit

; 1493 : 		{
; 1494 : 			btn->Refresh();

	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax

; 1495 : 			btn->SetState(0);

	push	0
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 1496 : 			btn->SetFlagBitOff(C_BIT_ENABLED);

	push	2048					; 00000800H
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 1497 : 			btn->SetAllLabel(" ");

	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetAllLabel@C_Button@@QAEXPAD@Z	; C_Button::SetAllLabel

; 1498 : 			btn->Refresh();

	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN41@SetupMunit:

; 1499 : 		}
; 1500 : 		win->DisableCluster(-100);

	push	-100					; ffffff9cH
	mov	ecx, DWORD PTR _win$[ebp]
	call	?DisableCluster@C_Window@@QAEXJ@Z	; C_Window::DisableCluster

; 1501 : 		return;

	jmp	$LN52@SetupMunit
$LN50@SetupMunit:

; 1502 : 	}
; 1503 : 
; 1504 : 	txt=(C_Text*)win->FindControl(FLIGHT_CALLSIGN);

	push	13110					; 00003336H
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _txt$[ebp], eax

; 1505 : 	if(txt)

	cmp	DWORD PTR _txt$[ebp], 0
	je	SHORT $LN40@SetupMunit

; 1506 : 	{
; 1507 : 		GetCallsign(flt, buf);

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _flt$[ebp]
	push	edx
	call	?GetCallsign@@YAXPAVFlightClass@@PAD@Z	; GetCallsign
	add	esp, 8

; 1508 : 		txt->SetText(buf);

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+256]
	call	eax
$LN40@SetupMunit:

; 1509 : 	}
; 1510 : 	status=0;

	mov	DWORD PTR _status$[ebp], 0

; 1511 : 	txt=(C_Text*)win->FindControl(STATUS_FIELD);

	push	18002					; 00004652H
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _txt$[ebp], eax

; 1512 : 	if(txt)

	cmp	DWORD PTR _txt$[ebp], 0
	je	$LN39@SetupMunit

; 1513 : 	{
; 1514 : 		txt->SetTimerCallback(MuniTimeCB);

	push	OFFSET ?MuniTimeCB@@YAHPAVC_Base@@@Z	; MuniTimeCB
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetTimerCallback@C_Text@@QAEXP6AHPAVC_Base@@@Z@Z ; C_Text::SetTimerCallback

; 1515 : 		if ((!(TheCampaign.Flags & CAMP_TACTICAL_EDIT)) && (!(TheCampaign.Flags & CAMP_LIGHT)))

	mov	ecx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A+64
	and	ecx, 524288				; 00080000H
	jne	SHORT $LN38@SetupMunit
	mov	edx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A+64
	and	edx, 128				; 00000080H
	jne	SHORT $LN38@SetupMunit

; 1516 : 		{
; 1517 : 			status=GetFlightStatusID(flt);

	mov	eax, DWORD PTR _flt$[ebp]
	push	eax
	call	?GetFlightStatusID@@YAFPAVFlightClass@@@Z ; GetFlightStatusID
	add	esp, 4
	movsx	ecx, ax
	mov	DWORD PTR _status$[ebp], ecx

; 1518 : 			if(!status)

	cmp	DWORD PTR _status$[ebp], 0
	jne	SHORT $LN38@SetupMunit

; 1519 : 			{
; 1520 : 				takeoff=flt->GetFirstUnitWP()->GetWPDepartureTime() - vuxGameTime;

	mov	ecx, DWORD PTR _flt$[ebp]
	call	?GetFirstUnitWP@UnitClass@@QAEPAVWayPointClass@@XZ ; UnitClass::GetFirstUnitWP
	mov	ecx, eax
	call	?GetWPDepartureTime@WayPointClass@@QAEKXZ ; WayPointClass::GetWPDepartureTime
	sub	eax, DWORD PTR ?vuxGameTime@@3KA	; vuxGameTime
	mov	DWORD PTR _takeoff$[ebp], eax

; 1521 : 				//if(takeoff < 120)
; 1522 : 				if((takeoff / VU_TICS_PER_SECOND) < g_nLoadoutTimeLimit) // JB 010729

	mov	eax, DWORD PTR _takeoff$[ebp]
	cdq
	mov	ecx, 1000				; 000003e8H
	idiv	ecx
	cmp	eax, DWORD PTR ?g_nLoadoutTimeLimit@@3HA ; g_nLoadoutTimeLimit
	jge	SHORT $LN38@SetupMunit

; 1523 : 					status=1;

	mov	DWORD PTR _status$[ebp], 1
$LN38@SetupMunit:

; 1524 : 			}
; 1525 : 		}
; 1526 : 
; 1527 : 		if(status)

	cmp	DWORD PTR _status$[ebp], 0
	je	SHORT $LN35@SetupMunit

; 1528 : 		{
; 1529 : 			txt->SetText(TXT_INFLIGHT);

	push	124					; 0000007cH
	mov	edx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax+252]
	call	edx

; 1530 : 			txt->SetFGColor(0x0000ff);

	push	255					; 000000ffH
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetFGColor@C_Text@@QAEXK@Z		; C_Text::SetFGColor

; 1531 : 		}
; 1532 : 		else

	jmp	$LN39@SetupMunit
$LN35@SetupMunit:

; 1533 : 		{
; 1534 : 			if(win)

	cmp	DWORD PTR _win$[ebp], 0
	je	SHORT $LN33@SetupMunit

; 1535 : 				win->EnableCluster(-100);

	push	-100					; ffffff9cH
	mov	ecx, DWORD PTR _win$[ebp]
	call	?EnableCluster@C_Window@@QAEXJ@Z	; C_Window::EnableCluster
$LN33@SetupMunit:

; 1536 : 			txt->SetFlagBitOn(C_BIT_TIMER);

	push	65536					; 00010000H
	mov	eax, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 1537 : 			if (flt->GetFirstUnitWP ())

	mov	ecx, DWORD PTR _flt$[ebp]
	call	?GetFirstUnitWP@UnitClass@@QAEPAVWayPointClass@@XZ ; UnitClass::GetFirstUnitWP
	test	eax, eax
	je	SHORT $LN32@SetupMunit

; 1538 : 			{
; 1539 : 				GetTimeString(flt->GetFirstUnitWP()->GetWPDepartureTime(),buf);

	push	1
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _flt$[ebp]
	call	?GetFirstUnitWP@UnitClass@@QAEPAVWayPointClass@@XZ ; UnitClass::GetFirstUnitWP
	mov	ecx, eax
	call	?GetWPDepartureTime@WayPointClass@@QAEKXZ ; WayPointClass::GetWPDepartureTime
	push	eax
	call	?GetTimeString@@YAPADKQADH@Z		; GetTimeString
	add	esp, 12					; 0000000cH

; 1540 : 				txt->SetText(buf);

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	mov	eax, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+256]
	call	eax

; 1541 : 			}
; 1542 : 			else

	jmp	SHORT $LN31@SetupMunit
$LN32@SetupMunit:

; 1543 : 			{
; 1544 : 				txt->SetText ("");

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+256]
	call	eax
$LN31@SetupMunit:

; 1545 : 			}
; 1546 : 
; 1547 : // 2001-10-23 ADDED BY S.G. Set the time color according to the time until takeoff
; 1548 : 			if((takeoff / VU_TICS_PER_SECOND) > 240)

	mov	eax, DWORD PTR _takeoff$[ebp]
	cdq
	mov	ecx, 1000				; 000003e8H
	idiv	ecx
	cmp	eax, 240				; 000000f0H
	jle	SHORT $LN30@SetupMunit

; 1549 : 				txt->SetFGColor(0x00ff00);

	push	65280					; 0000ff00H
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetFGColor@C_Text@@QAEXK@Z		; C_Text::SetFGColor
	jmp	SHORT $LN29@SetupMunit
$LN30@SetupMunit:

; 1550 : 			else if((takeoff / VU_TICS_PER_SECOND) > 180)

	mov	eax, DWORD PTR _takeoff$[ebp]
	cdq
	mov	ecx, 1000				; 000003e8H
	idiv	ecx
	cmp	eax, 180				; 000000b4H
	jle	SHORT $LN28@SetupMunit

; 1551 : 				txt->SetFGColor(0x00ffff);

	push	65535					; 0000ffffH
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetFGColor@C_Text@@QAEXK@Z		; C_Text::SetFGColor

; 1552 : 			else

	jmp	SHORT $LN29@SetupMunit
$LN28@SetupMunit:

; 1553 : 				txt->SetFGColor(0x0000ff);

	push	255					; 000000ffH
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetFGColor@C_Text@@QAEXK@Z		; C_Text::SetFGColor
$LN29@SetupMunit:

; 1554 : 			txt->Refresh();

	mov	edx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax+160]
	call	edx
$LN39@SetupMunit:

; 1555 : // END OF ADDED SECTION 2001-10-23
; 1556 : 		}
; 1557 : 	}
; 1558 : 	txt=(C_Text*)win->FindControl(FLIGHT_STATUS);

	push	18341					; 000047a5H
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _txt$[ebp], eax

; 1559 : 	if(txt)

	cmp	DWORD PTR _txt$[ebp], 0
	je	SHORT $LN26@SetupMunit

; 1560 : 	{
; 1561 : 		txt->Refresh();

	mov	eax, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax

; 1562 : 		if(status)

	cmp	DWORD PTR _status$[ebp], 0
	je	SHORT $LN25@SetupMunit

; 1563 : 			txt->SetText(TXT_FLIGHT_STATUS);

	push	126					; 0000007eH
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+252]
	call	eax

; 1564 : 		else

	jmp	SHORT $LN26@SetupMunit
$LN25@SetupMunit:

; 1565 : 			txt->SetText(TXT_FLIGHT_TAKEOFF);

	push	125					; 0000007dH
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+252]
	call	eax
$LN26@SetupMunit:

; 1566 : 	}
; 1567 : 	if(status)

	cmp	DWORD PTR _status$[ebp], 0
	je	SHORT $LN23@SetupMunit

; 1568 : 		win->DisableCluster(-100);

	push	-100					; ffffff9cH
	mov	ecx, DWORD PTR _win$[ebp]
	call	?DisableCluster@C_Window@@QAEXJ@Z	; C_Window::DisableCluster

; 1569 : 	else

	jmp	SHORT $LN22@SetupMunit
$LN23@SetupMunit:

; 1570 : 		win->EnableCluster(-100);

	push	-100					; ffffff9cH
	mov	ecx, DWORD PTR _win$[ebp]
	call	?EnableCluster@C_Window@@QAEXJ@Z	; C_Window::EnableCluster
$LN22@SetupMunit:

; 1571 : 	vid = flt->GetVehicleID(0);

	push	0
	mov	ecx, DWORD PTR _flt$[ebp]
	call	?GetVehicleID@UnitClass@@QAEFH@Z	; UnitClass::GetVehicleID
	movsx	ecx, ax
	mov	DWORD PTR _vid$[ebp], ecx

; 1572 : 	PlaneCount=flt->GetTotalVehicles();

	mov	ecx, DWORD PTR _flt$[ebp]
	call	?GetTotalVehicles@UnitClass@@QAEHXZ	; UnitClass::GetTotalVehicles
	mov	DWORD PTR ?PlaneCount@@3JA, eax		; PlaneCount

; 1573 : 	vc = GetVehicleClassData(vid);

	mov	edx, DWORD PTR _vid$[ebp]
	push	edx
	call	?GetVehicleClassData@@YAPAUVehicleClassDataType@@H@Z ; GetVehicleClassData
	add	esp, 4
	mov	DWORD PTR _vc$[ebp], eax

; 1574 : 	for(i=0;i<4;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN21@SetupMunit
$LN20@SetupMunit:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN21@SetupMunit:
	cmp	DWORD PTR _i$[ebp], 4
	jge	$LN19@SetupMunit

; 1575 : 	{
; 1576 : 		if(i < PlaneCount)

	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR ?PlaneCount@@3JA		; PlaneCount
	jge	$LN18@SetupMunit

; 1577 : 		{
; 1578 : 			switch(i)

	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR tv451[ebp], edx
	cmp	DWORD PTR tv451[ebp], 3
	ja	SHORT $LN16@SetupMunit
	mov	eax, DWORD PTR tv451[ebp]
	jmp	DWORD PTR $LN54@SetupMunit[eax*4]
$LN15@SetupMunit:

; 1579 : 			{
; 1580 : 				case 0:
; 1581 : 					btn=(C_Button *)win->FindControl(AIR_1);

	push	16018					; 00003e92H
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _btn$[ebp], eax

; 1582 : 					break;

	jmp	SHORT $LN16@SetupMunit
$LN14@SetupMunit:

; 1583 : 				case 1:
; 1584 : 					btn=(C_Button *)win->FindControl(AIR_2);

	push	16019					; 00003e93H
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _btn$[ebp], eax

; 1585 : 					break;

	jmp	SHORT $LN16@SetupMunit
$LN13@SetupMunit:

; 1586 : 				case 2:
; 1587 : 					btn=(C_Button *)win->FindControl(AIR_3);

	push	16020					; 00003e94H
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _btn$[ebp], eax

; 1588 : 					break;

	jmp	SHORT $LN16@SetupMunit
$LN12@SetupMunit:

; 1589 : 				case 3:
; 1590 : 					btn=(C_Button *)win->FindControl(AIR_4);

	push	16021					; 00003e95H
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _btn$[ebp], eax
$LN16@SetupMunit:

; 1591 : 					break;
; 1592 : 			}
; 1593 : 			if(btn)

	cmp	DWORD PTR _btn$[ebp], 0
	je	$LN11@SetupMunit

; 1594 : 			{
; 1595 : 				btn->Refresh();

	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax

; 1596 : 				btn->SetState(1);

	push	1
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 1597 : 				btn->SetFlagBitOn(C_BIT_ENABLED);

	push	2048					; 00000800H
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 1598 : 				session=gCommsMgr->FindCampaignPlayer(flt->Id(),static_cast<uchar>(i));

	movzx	ecx, BYTE PTR _i$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _flt$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR ?gCommsMgr@@3PAVUIComms@@A ; gCommsMgr
	call	?FindCampaignPlayer@UIComms@@QAEPAVFalconSessionEntity@@VVU_ID@@E@Z ; UIComms::FindCampaignPlayer
	mov	DWORD PTR _session$[ebp], eax

; 1599 : 				if(session)

	cmp	DWORD PTR _session$[ebp], 0
	je	SHORT $LN10@SetupMunit

; 1600 : 				{
; 1601 : 					_stprintf(buf,"%s",session->GetPlayerName());

	mov	ecx, DWORD PTR _session$[ebp]
	call	?GetPlayerName@FalconSessionEntity@@QAEPADXZ ; FalconSessionEntity::GetPlayerName
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1602 : 				}
; 1603 : 				else

	jmp	SHORT $LN9@SetupMunit
$LN10@SetupMunit:

; 1604 : 				{
; 1605 : 					TheCampaign.MissionEvaluator->GetPilotName(i,buf);

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A+324
	call	?GetPilotName@MissionEvaluationClass@@QAEHHPAD@Z ; MissionEvaluationClass::GetPilotName
$LN9@SetupMunit:

; 1606 : 				}
; 1607 : 				btn->SetAllLabel(buf);

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetAllLabel@C_Button@@QAEXPAD@Z	; C_Button::SetAllLabel

; 1608 : 				btn->Refresh();		 //@ mark here:  Set pilots

	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN11@SetupMunit:

; 1609 : 			}
; 1610 : 			SetPlaneToArm(i,TRUE);

	push	1
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	call	?SetPlaneToArm@@YAXJH@Z			; SetPlaneToArm
	add	esp, 8

; 1611 : 		}
; 1612 : 		else

	jmp	$LN8@SetupMunit
$LN18@SetupMunit:

; 1613 : 		{
; 1614 : 			switch(i)

	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR tv536[ebp], edx
	cmp	DWORD PTR tv536[ebp], 3
	ja	SHORT $LN6@SetupMunit
	mov	eax, DWORD PTR tv536[ebp]
	jmp	DWORD PTR $LN55@SetupMunit[eax*4]
$LN5@SetupMunit:

; 1615 : 			{
; 1616 : 				case 0:
; 1617 : 					btn=(C_Button *)win->FindControl(AIR_1);

	push	16018					; 00003e92H
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _btn$[ebp], eax

; 1618 : 					break;

	jmp	SHORT $LN6@SetupMunit
$LN4@SetupMunit:

; 1619 : 				case 1:
; 1620 : 					btn=(C_Button *)win->FindControl(AIR_2);

	push	16019					; 00003e93H
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _btn$[ebp], eax

; 1621 : 					break;

	jmp	SHORT $LN6@SetupMunit
$LN3@SetupMunit:

; 1622 : 				case 2:
; 1623 : 					btn=(C_Button *)win->FindControl(AIR_3);

	push	16020					; 00003e94H
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _btn$[ebp], eax

; 1624 : 					break;

	jmp	SHORT $LN6@SetupMunit
$LN2@SetupMunit:

; 1625 : 				case 3:
; 1626 : 					btn=(C_Button *)win->FindControl(AIR_4);

	push	16021					; 00003e95H
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _btn$[ebp], eax
$LN6@SetupMunit:

; 1627 : 					break;
; 1628 : 			}
; 1629 : 			if(btn)

	cmp	DWORD PTR _btn$[ebp], 0
	je	SHORT $LN1@SetupMunit

; 1630 : 			{
; 1631 : 				btn->Refresh();

	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax

; 1632 : 				btn->SetState(0);

	push	0
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 1633 : 				btn->SetFlagBitOff(C_BIT_ENABLED);

	push	2048					; 00000800H
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 1634 : 				btn->SetAllLabel(" ");

	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetAllLabel@C_Button@@QAEXPAD@Z	; C_Button::SetAllLabel

; 1635 : 				btn->Refresh();

	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN1@SetupMunit:

; 1636 : 			}
; 1637 : 			SetPlaneToArm(i,FALSE);

	push	0
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	call	?SetPlaneToArm@@YAXJH@Z			; SetPlaneToArm
	add	esp, 8
$LN8@SetupMunit:

; 1638 : 		}
; 1639 : 	}

	jmp	$LN20@SetupMunit
$LN19@SetupMunit:

; 1640 : 	win->ScanClientAreas();

	mov	ecx, DWORD PTR _win$[ebp]
	call	?ScanClientAreas@C_Window@@QAEXXZ	; C_Window::ScanClientAreas

; 1641 : 	win->RefreshWindow();

	mov	ecx, DWORD PTR _win$[ebp]
	call	?RefreshWindow@C_Window@@QAEXXZ		; C_Window::RefreshWindow
$LN52@SetupMunit:

; 1642 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN54@SetupMunit:
	DD	$LN15@SetupMunit
	DD	$LN14@SetupMunit
	DD	$LN13@SetupMunit
	DD	$LN12@SetupMunit
$LN55@SetupMunit:
	DD	$LN5@SetupMunit
	DD	$LN4@SetupMunit
	DD	$LN3@SetupMunit
	DD	$LN2@SetupMunit
?SetupMunitionsWindow@@YAXVVU_ID@@@Z ENDP		; SetupMunitionsWindow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\munition.cpp
_TEXT	SEGMENT
_PlaneCount$ = -52					; size = 4
_vid$ = -48						; size = 4
_weapPtr$ = -44						; size = 4
_weapid$1 = -40						; size = 4
_rackid$2 = -36						; size = 4
_pylonid$3 = -32					; size = 4
_flt$ = -28						; size = 4
_store$ = -24						; size = 4
_rackPtr$ = -20						; size = 4
_vc$ = -16						; size = 4
_wc$ = -12						; size = 4
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_FlightID$ = 8						; size = 8
?DetermineWeight@@YAXVVU_ID@@@Z PROC			; DetermineWeight

; 1243 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	push	esi

; 1244 : 	VehicleClassDataType *vc;
; 1245 : 	Falcon4EntityClassType *rackPtr,*weapPtr;
; 1246 : 	WeaponClassDataType  *wc;
; 1247 : 	STORESLIST *store;
; 1248 : 	Flight flt;
; 1249 : 	long i,j,vid,PlaneCount/*,count,bitflag*/;
; 1250 : 
; 1251 : 	flt=(Flight)FindUnit(FlightID);

	mov	eax, DWORD PTR _FlightID$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _FlightID$[ebp]
	push	ecx
	call	?FindUnit@@YAPAVUnitClass@@VVU_ID@@@Z	; FindUnit
	add	esp, 8
	mov	DWORD PTR _flt$[ebp], eax

; 1252 : 	if(!flt)

	cmp	DWORD PTR _flt$[ebp], 0
	jne	$LN30@DetermineW

; 1253 : 	{
; 1254 : 		for(i=0;i<4;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN29@DetermineW
$LN28@DetermineW:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN29@DetermineW:
	cmp	DWORD PTR _i$[ebp], 4
	jge	SHORT $LN27@DetermineW

; 1255 : 		{
; 1256 : 			_MAX_WEIGHT_[i]=0;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR __MAX_WEIGHT_[eax*4], 0

; 1257 : 			_CLEAN_WEIGHT_[i]=0;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR __CLEAN_WEIGHT_[ecx*4], 0

; 1258 : 			_DRAG_FACTOR_[i]=0;

	mov	edx, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR __DRAG_FACTOR_[edx*4], xmm0

; 1259 : 			_MUNITIONS_WEIGHT_[i]=0;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR __MUNITIONS_WEIGHT_[eax*4], 0

; 1260 : 			_FUEL_WEIGHT_[i]=0;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR __FUEL_WEIGHT_[ecx*4], 0

; 1261 : 			_CURRENT_WEIGHT_[i]=0;

	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR __CURRENT_WEIGHT_[edx*4], 0

; 1262 : 		}

	jmp	SHORT $LN28@DetermineW
$LN27@DetermineW:

; 1263 : 		gFlightOverloaded=0;

	mov	DWORD PTR ?gFlightOverloaded@@3JA, 0	; gFlightOverloaded

; 1264 : 		return;

	jmp	$LN31@DetermineW
$LN30@DetermineW:

; 1265 : 	}
; 1266 : 	vid = flt->GetVehicleID(0);

	push	0
	mov	ecx, DWORD PTR _flt$[ebp]
	call	?GetVehicleID@UnitClass@@QAEFH@Z	; UnitClass::GetVehicleID
	cwde
	mov	DWORD PTR _vid$[ebp], eax

; 1267 : 	PlaneCount=flt->GetTotalVehicles();

	mov	ecx, DWORD PTR _flt$[ebp]
	call	?GetTotalVehicles@UnitClass@@QAEHXZ	; UnitClass::GetTotalVehicles
	mov	DWORD PTR _PlaneCount$[ebp], eax

; 1268 : 	vc = GetVehicleClassData(vid);

	mov	ecx, DWORD PTR _vid$[ebp]
	push	ecx
	call	?GetVehicleClassData@@YAPAUVehicleClassDataType@@H@Z ; GetVehicleClassData
	add	esp, 4
	mov	DWORD PTR _vc$[ebp], eax

; 1269 : 	gFlightOverloaded=0;

	mov	DWORD PTR ?gFlightOverloaded@@3JA, 0	; gFlightOverloaded

; 1270 : 	for(i=0;i<4;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN26@DetermineW
$LN25@DetermineW:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN26@DetermineW:
	cmp	DWORD PTR _i$[ebp], 4
	jge	$LN24@DetermineW

; 1271 : 	{
; 1272 : 		_MAX_WEIGHT_[i]=vc->MaxWt;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _vc$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR __MAX_WEIGHT_[eax*4], edx

; 1273 : 		_CLEAN_WEIGHT_[i]=vc->EmptyWt;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _vc$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR __CLEAN_WEIGHT_[eax*4], edx

; 1274 : 		_DRAG_FACTOR_[i]=1;

	mov	eax, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR __DRAG_FACTOR_[eax*4], xmm0

; 1275 : 		_MUNITIONS_WEIGHT_[i]=0;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR __MUNITIONS_WEIGHT_[ecx*4], 0

; 1276 : 		_FUEL_WEIGHT_[i]=vc->FuelWt;

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _vc$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR __FUEL_WEIGHT_[edx*4], ecx

; 1277 : 
; 1278 : 		if(i < PlaneCount)

	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _PlaneCount$[ebp]
	jge	$LN14@DetermineW

; 1279 : 		{
; 1280 : 			for(j=0;j<QuantityCount[i];j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN22@DetermineW
$LN21@DetermineW:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN22@DetermineW:
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	cmp	edx, DWORD PTR _QuantityCount[ecx*4]
	jge	$LN20@DetermineW

; 1281 : 			{
; 1282 : 				store=NULL;

	mov	DWORD PTR _store$[ebp], 0

; 1283 : 				ShiAssert(gStores);
; 1284 : 				if (gStores)

	cmp	DWORD PTR ?gStores@@3PAVStoresList@@A, 0 ; gStores
	je	SHORT $LN19@DetermineW

; 1285 : 					store = gStores->Find(Quantity[i][0][j]);

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 7
	mov	ecx, 64					; 00000040H
	imul	ecx, 0
	lea	edx, DWORD PTR _Quantity[eax+ecx]
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	mov	ecx, DWORD PTR ?gStores@@3PAVStoresList@@A ; gStores
	call	?Find@StoresList@@QAEPAUStoresStr@@J@Z	; StoresList::Find
	mov	DWORD PTR _store$[ebp], eax
$LN19@DetermineW:

; 1286 : 
; 1287 : 				if(store)

	cmp	DWORD PTR _store$[ebp], 0
	je	SHORT $LN17@DetermineW

; 1288 : 				{
; 1289 : 					if(store->Type == StoresList::_TYPE_FUEL_)

	mov	edx, DWORD PTR _store$[ebp]
	cmp	DWORD PTR [edx+24], 103			; 00000067H
	jne	SHORT $LN17@DetermineW

; 1290 : 						_FUEL_WEIGHT_[i]+=store->Fuel * Quantity[i][1][j];

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 7
	mov	ecx, 64					; 00000040H
	shl	ecx, 0
	lea	edx, DWORD PTR _Quantity[eax+ecx]
	mov	eax, DWORD PTR _store$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR [eax+32]
	imul	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _i$[ebp]
	add	eax, DWORD PTR __FUEL_WEIGHT_[ecx*4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR __FUEL_WEIGHT_[edx*4], eax
$LN17@DetermineW:

; 1291 : //					_MUNITIONS_WEIGHT_[i]+=store->Weight * Quantity[i][1][j];
; 1292 : //					_DRAG_FACTOR_[i]+=store->DragFactor * Quantity[i][1][j];
; 1293 : 				}
; 1294 : 			}

	jmp	$LN21@DetermineW
$LN20@DetermineW:

; 1295 : 
; 1296 : 			// MLR 3/1/2004 - eeheeheehee
; 1297 : 			for(j=1;j<HardPoints;j++)

	mov	DWORD PTR _j$[ebp], 1
	jmp	SHORT $LN16@DetermineW
$LN15@DetermineW:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN16@DetermineW:
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR ?HardPoints@@3JA		; HardPoints
	jge	$LN14@DetermineW

; 1298 : 			{
; 1299 : 				// Add up pylon weight & drag
; 1300 : 				int pylonid = gCurRails[i].rail[j].hardPoint.GetPylonId();

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 2560				; 00000a00H
	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, 160				; 000000a0H
	mov	ecx, DWORD PTR _j$[ebp]
	imul	ecx, 160				; 000000a0H
	mov	esi, DWORD PTR _i$[ebp]
	imul	esi, 2560				; 00000a00H
	lea	ecx, DWORD PTR ?gCurRails@@3PAURailList@@A[esi+ecx]
	mov	edx, DWORD PTR ?gCurRails@@3PAURailList@@A[edx+eax]
	mov	eax, DWORD PTR [edx+140]
	call	eax
	mov	DWORD PTR _pylonid$3[ebp], eax

; 1301 : 				if( pylonid && gCurRails[i].rail[j].weaponCount ) 

	cmp	DWORD PTR _pylonid$3[ebp], 0
	je	$LN10@DetermineW
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 2560				; 00000a00H
	mov	edx, DWORD PTR _j$[ebp]
	imul	edx, 160				; 000000a0H
	movsx	eax, WORD PTR ?gCurRails@@3PAURailList@@A[ecx+edx+156]
	test	eax, eax
	je	$LN10@DetermineW

; 1302 : 				{
; 1303 : 					rackPtr=&Falcon4ClassTable[WeaponDataTable[pylonid].Index]; // MLR 2/29/2004 - 

	mov	ecx, DWORD PTR _pylonid$3[ebp]
	imul	ecx, 60					; 0000003cH
	mov	edx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movsx	eax, WORD PTR [edx+ecx]
	imul	eax, 81					; 00000051H
	add	eax, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	DWORD PTR _rackPtr$[ebp], eax

; 1304 : 
; 1305 : 					if(rackPtr)

	je	SHORT $LN10@DetermineW

; 1306 : 					{
; 1307 : 						wc=(WeaponClassDataType *)rackPtr->dataPtr;

	mov	ecx, DWORD PTR _rackPtr$[ebp]
	mov	edx, DWORD PTR [ecx+77]
	mov	DWORD PTR _wc$[ebp], edx

; 1308 : 						if(wc)

	cmp	DWORD PTR _wc$[ebp], 0
	je	SHORT $LN10@DetermineW

; 1309 : 						{
; 1310 : 							_MUNITIONS_WEIGHT_[i]+=(wc->Weight);

	mov	eax, DWORD PTR _wc$[ebp]
	movzx	ecx, WORD PTR [eax+48]
	mov	edx, DWORD PTR _i$[ebp]
	add	ecx, DWORD PTR __MUNITIONS_WEIGHT_[edx*4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR __MUNITIONS_WEIGHT_[eax*4], ecx

; 1311 : 							if(vc->VisibleFlags & ( 1 << j)) // only do drag if it's visible

	mov	ecx, DWORD PTR _vc$[ebp]
	movzx	edx, WORD PTR [ecx+62]
	mov	eax, 1
	mov	ecx, DWORD PTR _j$[ebp]
	shl	eax, cl
	and	edx, eax
	je	SHORT $LN10@DetermineW

; 1312 : 								_DRAG_FACTOR_[i]+=wc->DragIndex;

	mov	ecx, DWORD PTR _wc$[ebp]
	movsx	edx, WORD PTR [ecx+50]
	cvtsi2ss xmm0, edx
	mov	eax, DWORD PTR _i$[ebp]
	addss	xmm0, DWORD PTR __DRAG_FACTOR_[eax*4]
	mov	ecx, DWORD PTR _i$[ebp]
	movss	DWORD PTR __DRAG_FACTOR_[ecx*4], xmm0
$LN10@DetermineW:

; 1313 : 						}
; 1314 : 					}
; 1315 : 				}
; 1316 : 
; 1317 : 				// Add rack weight & drag
; 1318 : 				int rackid = gCurRails[i].rail[j].hardPoint.GetRackId();

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 2560				; 00000a00H
	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, 160				; 000000a0H
	mov	ecx, DWORD PTR _j$[ebp]
	imul	ecx, 160				; 000000a0H
	mov	esi, DWORD PTR _i$[ebp]
	imul	esi, 2560				; 00000a00H
	lea	ecx, DWORD PTR ?gCurRails@@3PAURailList@@A[esi+ecx]
	mov	edx, DWORD PTR ?gCurRails@@3PAURailList@@A[edx+eax]
	mov	eax, DWORD PTR [edx+132]
	call	eax
	mov	DWORD PTR _rackid$2[ebp], eax

; 1319 : 				if( rackid && gCurRails[i].rail[j].weaponCount ) 

	cmp	DWORD PTR _rackid$2[ebp], 0
	je	$LN6@DetermineW
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 2560				; 00000a00H
	mov	edx, DWORD PTR _j$[ebp]
	imul	edx, 160				; 000000a0H
	movsx	eax, WORD PTR ?gCurRails@@3PAURailList@@A[ecx+edx+156]
	test	eax, eax
	je	$LN6@DetermineW

; 1320 : 				{
; 1321 : 					rackPtr=&Falcon4ClassTable[WeaponDataTable[rackid].Index]; // MLR 2/29/2004 - 

	mov	ecx, DWORD PTR _rackid$2[ebp]
	imul	ecx, 60					; 0000003cH
	mov	edx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movsx	eax, WORD PTR [edx+ecx]
	imul	eax, 81					; 00000051H
	add	eax, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	DWORD PTR _rackPtr$[ebp], eax

; 1322 : 
; 1323 : 					if(rackPtr)

	je	SHORT $LN6@DetermineW

; 1324 : 					{
; 1325 : 						wc=(WeaponClassDataType *)rackPtr->dataPtr;

	mov	ecx, DWORD PTR _rackPtr$[ebp]
	mov	edx, DWORD PTR [ecx+77]
	mov	DWORD PTR _wc$[ebp], edx

; 1326 : 						if(wc)

	cmp	DWORD PTR _wc$[ebp], 0
	je	SHORT $LN6@DetermineW

; 1327 : 						{
; 1328 : 							_MUNITIONS_WEIGHT_[i]+=(wc->Weight);

	mov	eax, DWORD PTR _wc$[ebp]
	movzx	ecx, WORD PTR [eax+48]
	mov	edx, DWORD PTR _i$[ebp]
	add	ecx, DWORD PTR __MUNITIONS_WEIGHT_[edx*4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR __MUNITIONS_WEIGHT_[eax*4], ecx

; 1329 : 							if(vc->VisibleFlags & ( 1 << j)) // only do drag if it's visible

	mov	ecx, DWORD PTR _vc$[ebp]
	movzx	edx, WORD PTR [ecx+62]
	mov	eax, 1
	mov	ecx, DWORD PTR _j$[ebp]
	shl	eax, cl
	and	edx, eax
	je	SHORT $LN6@DetermineW

; 1330 : 								_DRAG_FACTOR_[i]+=wc->DragIndex;

	mov	ecx, DWORD PTR _wc$[ebp]
	movsx	edx, WORD PTR [ecx+50]
	cvtsi2ss xmm0, edx
	mov	eax, DWORD PTR _i$[ebp]
	addss	xmm0, DWORD PTR __DRAG_FACTOR_[eax*4]
	mov	ecx, DWORD PTR _i$[ebp]
	movss	DWORD PTR __DRAG_FACTOR_[ecx*4], xmm0
$LN6@DetermineW:

; 1331 : 						}
; 1332 : 					}
; 1333 : 				}
; 1334 : 
; 1335 : 				// Add weapon(s) weight & drag
; 1336 : 				int weapid = gCurRails[i].rail[j].hardPoint.weaponId;

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 2560				; 00000a00H
	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, 160				; 000000a0H
	movsx	ecx, WORD PTR ?gCurRails@@3PAURailList@@A[edx+eax+8]
	mov	DWORD PTR _weapid$1[ebp], ecx

; 1337 : 				if( weapid && gCurRails[i].rail[j].weaponCount )

	cmp	DWORD PTR _weapid$1[ebp], 0
	je	$LN2@DetermineW
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 2560				; 00000a00H
	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, 160				; 000000a0H
	movsx	ecx, WORD PTR ?gCurRails@@3PAURailList@@A[edx+eax+156]
	test	ecx, ecx
	je	$LN2@DetermineW

; 1338 : 				{
; 1339 : 					weapPtr=&Falcon4ClassTable[WeaponDataTable[weapid].Index];

	mov	edx, DWORD PTR _weapid$1[ebp]
	imul	edx, 60					; 0000003cH
	mov	eax, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movsx	ecx, WORD PTR [eax+edx]
	imul	ecx, 81					; 00000051H
	add	ecx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	DWORD PTR _weapPtr$[ebp], ecx

; 1340 : 					if(weapPtr)

	je	$LN2@DetermineW

; 1341 : 					{
; 1342 : 						wc=(WeaponClassDataType *)weapPtr->dataPtr;

	mov	edx, DWORD PTR _weapPtr$[ebp]
	mov	eax, DWORD PTR [edx+77]
	mov	DWORD PTR _wc$[ebp], eax

; 1343 : 						if(wc)

	cmp	DWORD PTR _wc$[ebp], 0
	je	$LN2@DetermineW

; 1344 : 						{
; 1345 : 							
; 1346 : 							_MUNITIONS_WEIGHT_[i]+=wc->Weight * gCurRails[i].rail[j].weaponCount;

	mov	ecx, DWORD PTR _wc$[ebp]
	movzx	edx, WORD PTR [ecx+48]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 2560				; 00000a00H
	mov	ecx, DWORD PTR _j$[ebp]
	imul	ecx, 160				; 000000a0H
	movsx	eax, WORD PTR ?gCurRails@@3PAURailList@@A[eax+ecx+156]
	imul	edx, eax
	mov	ecx, DWORD PTR _i$[ebp]
	add	edx, DWORD PTR __MUNITIONS_WEIGHT_[ecx*4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR __MUNITIONS_WEIGHT_[eax*4], edx

; 1347 : 							if(vc->VisibleFlags & ( 1 << j)) // only do drag if it's visible

	mov	ecx, DWORD PTR _vc$[ebp]
	movzx	edx, WORD PTR [ecx+62]
	mov	eax, 1
	mov	ecx, DWORD PTR _j$[ebp]
	shl	eax, cl
	and	edx, eax
	je	SHORT $LN2@DetermineW

; 1348 : 								_DRAG_FACTOR_[i]+=wc->DragIndex * gCurRails[i].rail[j].weaponCount; 

	mov	ecx, DWORD PTR _wc$[ebp]
	movsx	edx, WORD PTR [ecx+50]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 2560				; 00000a00H
	mov	ecx, DWORD PTR _j$[ebp]
	imul	ecx, 160				; 000000a0H
	movsx	eax, WORD PTR ?gCurRails@@3PAURailList@@A[eax+ecx+156]
	imul	edx, eax
	cvtsi2ss xmm0, edx
	mov	ecx, DWORD PTR _i$[ebp]
	addss	xmm0, DWORD PTR __DRAG_FACTOR_[ecx*4]
	mov	edx, DWORD PTR _i$[ebp]
	movss	DWORD PTR __DRAG_FACTOR_[edx*4], xmm0
$LN2@DetermineW:

; 1349 : 						}
; 1350 : 					}
; 1351 : 				}
; 1352 : 			}

	jmp	$LN15@DetermineW
$LN14@DetermineW:

; 1353 : 
; 1354 : 
; 1355 : #if 0
; 1356 : 			for(j=1;j<HardPoints;j++)
; 1357 : 			{
; 1358 : 				if(gCurRails[i].rail[j].hardPoint.GetRackId() && gCurRails[i].rail[j].currentBits) // MLR 2/25/2004 - Added currentBits
; 1359 : 				{
; 1360 : 					rackPtr=&Falcon4ClassTable[gCurRails[i].rail[j].hardPoint.GetRackId()]; // MLR 2/29/2004 - 
; 1361 : 					if(rackPtr)
; 1362 : 					{
; 1363 : 						wc=(WeaponClassDataType *)rackPtr->dataPtr;
; 1364 : 						if(wc)
; 1365 : 						{
; 1366 : #if 0 // MLR 2/25/2004 - Change to weight computation.
; 1367 : 							if(gCurRails[i].rail[j].hardPoint.weaponId) // MLR 2/29/2004 - 
; 1368 : 								_MUNITIONS_WEIGHT_[i]+=(wc->Weight * 0.85);
; 1369 : 							else
; 1370 : 								_MUNITIONS_WEIGHT_[i]+=wc->Weight;
; 1371 : #else
; 1372 : 							if(gCurRails[i].rail[j].hardPoint.weaponId) // MLR 2/29/2004 - 
; 1373 : 								_MUNITIONS_WEIGHT_[i]+=(wc->Weight);
; 1374 : #endif
; 1375 : 							_DRAG_FACTOR_[i]+=wc->DragIndex;
; 1376 : 						}
; 1377 : 					}
; 1378 : 				}
; 1379 : 			}
; 1380 : 
; 1381 : 			// Add up visible stores weights
; 1382 : 			for(j=1;j<HardPoints;j++)
; 1383 : 			{
; 1384 : 				if(gCurRails[i].rail[j].hardPoint.weaponId && gCurRails[i].rail[j].currentBits)
; 1385 : 				{
; 1386 : 					bitflag=gCurRails[i].rail[j].currentBits;
; 1387 : 					count=0;
; 1388 : 					while(bitflag)
; 1389 : 					{
; 1390 : 						if(bitflag & 1)
; 1391 : 							count++;
; 1392 : 						bitflag >>= 1;
; 1393 : 					}
; 1394 : 
; 1395 : 					weapPtr=&Falcon4ClassTable[gCurRails[i].rail[j].hardPoint.weaponId];
; 1396 : 					if(weapPtr)
; 1397 : 					{
; 1398 : 						wc=(WeaponClassDataType *)weapPtr->dataPtr;
; 1399 : 						if(wc)
; 1400 : 						{
; 1401 : 							_MUNITIONS_WEIGHT_[i]+=wc->Weight * count;
; 1402 : 							_DRAG_FACTOR_[i]+=wc->DragIndex * count; // MLR 2/25/2004 - added "* count"
; 1403 : 						}
; 1404 : 					}
; 1405 : 				}
; 1406 : 			}
; 1407 : 
; 1408 : 			// Add up internal stores weights
; 1409 : 			for(j=1;j<HardPoints;j++)
; 1410 : 			{
; 1411 : 				if(!(vc->VisibleFlags & ( 1 << j)) && gCurStores[i].WeaponID[j])
; 1412 : 				{
; 1413 : 					store=NULL;
; 1414 : 					ShiAssert(gStores);
; 1415 : 					if (gStores)
; 1416 : 						store = gStores->Find(gCurStores[i].WeaponID[j]);
; 1417 : 
; 1418 : 					if(store)
; 1419 : 						_MUNITIONS_WEIGHT_[i]+=store->Weight * gCurStores[i].WeaponCount[j];
; 1420 : 				}
; 1421 : 			}
; 1422 : #endif
; 1423 : 		}
; 1424 : 		_CURRENT_WEIGHT_[i]=_CLEAN_WEIGHT_[i] + _MUNITIONS_WEIGHT_[i] + _FUEL_WEIGHT_[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR __CLEAN_WEIGHT_[eax*4]
	mov	edx, DWORD PTR _i$[ebp]
	add	ecx, DWORD PTR __MUNITIONS_WEIGHT_[edx*4]
	mov	eax, DWORD PTR _i$[ebp]
	add	ecx, DWORD PTR __FUEL_WEIGHT_[eax*4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR __CURRENT_WEIGHT_[edx*4], ecx

; 1425 : 		if(_CURRENT_WEIGHT_[i] > _MAX_WEIGHT_[i])

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR __CURRENT_WEIGHT_[eax*4]
	cmp	edx, DWORD PTR __MAX_WEIGHT_[ecx*4]
	jle	SHORT $LN1@DetermineW

; 1426 : 		{
; 1427 : 			gFlightOverloaded |= 1 << i;

	mov	eax, 1
	mov	ecx, DWORD PTR _i$[ebp]
	shl	eax, cl
	or	eax, DWORD PTR ?gFlightOverloaded@@3JA	; gFlightOverloaded
	mov	DWORD PTR ?gFlightOverloaded@@3JA, eax	; gFlightOverloaded
$LN1@DetermineW:

; 1428 : 		}
; 1429 : 	}

	jmp	$LN25@DetermineW
$LN24@DetermineW:
$LN31@DetermineW:

; 1430 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?DetermineWeight@@YAXVVU_ID@@@Z ENDP			; DetermineWeight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\munition.cpp
_TEXT	SEGMENT
_numac$1 = -288						; size = 4
_loads$2 = -284						; size = 4
_win$ = -280						; size = 4
_takeoff$ = -276					; size = 4
_flt$ = -272						; size = 4
_ref$3 = -265						; size = 1
_aci$4 = -264						; size = 4
_hpi$5 = -260						; size = 4
_txt$ = -256						; size = 4
_flightLOS$6 = -252					; size = 48
_buf$ = -204						; size = 200
__$ArrayPad$ = -4					; size = 4
_control$ = 8						; size = 4
?MuniTimeCB@@YAHPAVC_Base@@@Z PROC			; MuniTimeCB

; 1117 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 288				; 00000120H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1118 : 	C_Window *win;
; 1119 : 	Flight flt;
; 1120 : 	long takeoff;
; 1121 : 	C_Text *txt;
; 1122 : 	_TCHAR buf[200];
; 1123 : 
; 1124 : 	if((vuxGameTime - control->GetUserNumber(0)) < VU_TICS_PER_SECOND)

	push	0
	mov	ecx, DWORD PTR _control$[ebp]
	call	?GetUserNumber@C_Base@@QAEJJ@Z		; C_Base::GetUserNumber
	mov	ecx, DWORD PTR ?vuxGameTime@@3KA	; vuxGameTime
	sub	ecx, eax
	cmp	ecx, 1000				; 000003e8H
	jae	SHORT $LN26@MuniTimeCB

; 1125 : 		return(FALSE);

	xor	eax, eax
	jmp	$LN27@MuniTimeCB
$LN26@MuniTimeCB:

; 1126 : 
; 1127 : 	control->SetUserNumber(0,vuxGameTime);

	mov	edx, DWORD PTR ?vuxGameTime@@3KA	; vuxGameTime
	push	edx
	push	0
	mov	ecx, DWORD PTR _control$[ebp]
	call	?SetUserNumber@C_Base@@QAEXJJ@Z		; C_Base::SetUserNumber

; 1128 : 
; 1129 : 	txt=(C_Text*)control;

	mov	eax, DWORD PTR _control$[ebp]
	mov	DWORD PTR _txt$[ebp], eax

; 1130 : 
; 1131 : 	if(txt)

	cmp	DWORD PTR _txt$[ebp], 0
	je	$LN25@MuniTimeCB

; 1132 : 	{
; 1133 : 		flt=(Flight)vuDatabase->Find(gLoadoutFlightID);

	mov	ecx, DWORD PTR ?gLoadoutFlightID@@3VVU_ID@@A+4
	push	ecx
	mov	edx, DWORD PTR ?gLoadoutFlightID@@3VVU_ID@@A
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _flt$[ebp], eax

; 1134 : 
; 1135 : 		if (flt)

	cmp	DWORD PTR _flt$[ebp], 0
	je	$LN24@MuniTimeCB

; 1136 : 		{
; 1137 : 			// update weapon loadout if things have changed
; 1138 : 			int numac = flt->GetTotalVehicles();

	mov	ecx, DWORD PTR _flt$[ebp]
	call	?GetTotalVehicles@UnitClass@@QAEHXZ	; UnitClass::GetTotalVehicles
	mov	DWORD PTR _numac$1[ebp], eax

; 1139 : 			int loads = flt->GetNumberOfLoadouts();

	mov	eax, DWORD PTR _flt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _flt$[ebp]
	mov	eax, DWORD PTR [edx+640]
	call	eax
	mov	DWORD PTR _loads$2[ebp], eax

; 1140 : 			bool ref  = false;

	mov	BYTE PTR _ref$3[ebp], 0

; 1141 : 
; 1142 : 			for (int aci = 0; aci < numac; aci++)

	mov	DWORD PTR _aci$4[ebp], 0
	jmp	SHORT $LN23@MuniTimeCB
$LN22@MuniTimeCB:
	mov	ecx, DWORD PTR _aci$4[ebp]
	add	ecx, 1
	mov	DWORD PTR _aci$4[ebp], ecx
$LN23@MuniTimeCB:
	mov	edx, DWORD PTR _aci$4[ebp]
	cmp	edx, DWORD PTR _numac$1[ebp]
	jge	$LN21@MuniTimeCB

; 1143 : 			{
; 1144 : 				if (aci < loads)

	mov	eax, DWORD PTR _aci$4[ebp]
	cmp	eax, DWORD PTR _loads$2[ebp]
	jge	$LN20@MuniTimeCB

; 1145 : 				{
; 1146 : 					LoadoutStruct flightLOS;

	lea	ecx, DWORD PTR _flightLOS$6[ebp]
	call	??0LoadoutStruct@@QAE@XZ		; LoadoutStruct::LoadoutStruct

; 1147 : 					
; 1148 : 					memcpy(&flightLOS, flt->GetLoadout(aci), sizeof(LoadoutStruct));

	push	48					; 00000030H
	mov	ecx, DWORD PTR _aci$4[ebp]
	push	ecx
	mov	edx, DWORD PTR _flt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _flt$[ebp]
	mov	edx, DWORD PTR [eax+996]
	call	edx
	push	eax
	lea	eax, DWORD PTR _flightLOS$6[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1149 : 
; 1150 : 					for (int hpi = 0; hpi < HARDPOINT_MAX ; ++hpi)

	mov	DWORD PTR _hpi$5[ebp], 0
	jmp	SHORT $LN19@MuniTimeCB
$LN18@MuniTimeCB:
	mov	ecx, DWORD PTR _hpi$5[ebp]
	add	ecx, 1
	mov	DWORD PTR _hpi$5[ebp], ecx
$LN19@MuniTimeCB:
	cmp	DWORD PTR _hpi$5[ebp], 16		; 00000010H
	jge	$LN20@MuniTimeCB

; 1151 : 					{
; 1152 : 						if ((gOriginalStores[aci].WeaponID[hpi]		!= flightLOS.WeaponID[hpi]) || 
; 1153 : 							(gOriginalStores[aci].WeaponCount[hpi]	!= flightLOS.WeaponCount[hpi]))

	mov	edx, DWORD PTR _aci$4[ebp]
	imul	edx, 48					; 00000030H
	mov	eax, DWORD PTR _hpi$5[ebp]
	movsx	ecx, WORD PTR ?gOriginalStores@@3PAULoadoutStruct@@A[edx+eax*2]
	mov	edx, DWORD PTR _hpi$5[ebp]
	movsx	eax, WORD PTR _flightLOS$6[ebp+edx*2]
	cmp	ecx, eax
	jne	SHORT $LN15@MuniTimeCB
	mov	ecx, DWORD PTR _aci$4[ebp]
	imul	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _hpi$5[ebp]
	movzx	eax, BYTE PTR ?gOriginalStores@@3PAULoadoutStruct@@A[ecx+edx+32]
	mov	ecx, DWORD PTR _hpi$5[ebp]
	movzx	edx, BYTE PTR _flightLOS$6[ebp+ecx+32]
	cmp	eax, edx
	je	$LN16@MuniTimeCB
$LN15@MuniTimeCB:

; 1154 : 						{
; 1155 : 							// update the info for the loadout
; 1156 : 							gOriginalStores[aci].WeaponID[hpi]		= flightLOS.WeaponID[hpi]; 

	mov	eax, DWORD PTR _aci$4[ebp]
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _hpi$5[ebp]
	mov	edx, DWORD PTR _hpi$5[ebp]
	mov	dx, WORD PTR _flightLOS$6[ebp+edx*2]
	mov	WORD PTR ?gOriginalStores@@3PAULoadoutStruct@@A[eax+ecx*2], dx

; 1157 : 							gOriginalStores[aci].WeaponCount[hpi]	= flightLOS.WeaponCount[hpi];

	mov	eax, DWORD PTR _aci$4[ebp]
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _hpi$5[ebp]
	mov	edx, DWORD PTR _hpi$5[ebp]
	mov	dl, BYTE PTR _flightLOS$6[ebp+edx+32]
	mov	BYTE PTR ?gOriginalStores@@3PAULoadoutStruct@@A[eax+ecx+32], dl

; 1158 : 							gCurStores[aci].WeaponID[hpi]			= flightLOS.WeaponID[hpi]; 

	mov	eax, DWORD PTR _aci$4[ebp]
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _hpi$5[ebp]
	mov	edx, DWORD PTR _hpi$5[ebp]
	mov	dx, WORD PTR _flightLOS$6[ebp+edx*2]
	mov	WORD PTR ?gCurStores@@3PAULoadoutStruct@@A[eax+ecx*2], dx

; 1159 : 							gCurStores[aci].WeaponCount[hpi]		= flightLOS.WeaponCount[hpi];

	mov	eax, DWORD PTR _aci$4[ebp]
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _hpi$5[ebp]
	mov	edx, DWORD PTR _hpi$5[ebp]
	mov	dl, BYTE PTR _flightLOS$6[ebp+edx+32]
	mov	BYTE PTR ?gCurStores@@3PAULoadoutStruct@@A[eax+ecx+32], dl

; 1160 : 
; 1161 : 							ref = true;

	mov	BYTE PTR _ref$3[ebp], 1
$LN16@MuniTimeCB:

; 1162 : 						}
; 1163 : 					}

	jmp	$LN18@MuniTimeCB
$LN20@MuniTimeCB:

; 1164 : 				}
; 1165 : 			}

	jmp	$LN22@MuniTimeCB
$LN21@MuniTimeCB:

; 1166 : 
; 1167 : 			// check flight time till launch
; 1168 : 			if (TheCampaign.Flags & CAMP_TACTICAL_EDIT)

	mov	eax, DWORD PTR ?TheCampaign@@3VCampaignClass@@A+64
	and	eax, 524288				; 00080000H
	je	SHORT $LN14@MuniTimeCB

; 1169 : 			{
; 1170 : 				takeoff=1;

	mov	DWORD PTR _takeoff$[ebp], 1

; 1171 : 			}
; 1172 : 			else

	jmp	SHORT $LN13@MuniTimeCB
$LN14@MuniTimeCB:

; 1173 : 			{
; 1174 : 				takeoff=(flt->GetFirstUnitWP()->GetWPDepartureTime() - vuxGameTime);

	mov	ecx, DWORD PTR _flt$[ebp]
	call	?GetFirstUnitWP@UnitClass@@QAEPAVWayPointClass@@XZ ; UnitClass::GetFirstUnitWP
	mov	ecx, eax
	call	?GetWPDepartureTime@WayPointClass@@QAEKXZ ; WayPointClass::GetWPDepartureTime
	sub	eax, DWORD PTR ?vuxGameTime@@3KA	; vuxGameTime
	mov	DWORD PTR _takeoff$[ebp], eax
$LN13@MuniTimeCB:

; 1175 : 			}
; 1176 : 
; 1177 : // 2001-10-23 MODIFIED BY S.G. Now either the original code or we are in Tac edit can go in and don't use takeoff but do just like in 'SetupMunitionsWindow' to get the time
; 1178 : //			if((takeoff / VU_TICS_PER_SECOND) > g_nLoadoutTimeLimit) // JB 010729
; 1179 : //			{
; 1180 : //				GetTimeString(takeoff,buf);
; 1181 : //				txt->Refresh();
; 1182 : //				txt->SetText(buf);
; 1183 : 			if((takeoff / VU_TICS_PER_SECOND) > g_nLoadoutTimeLimit || (TheCampaign.Flags & CAMP_TACTICAL_EDIT)) // JB 010729

	mov	eax, DWORD PTR _takeoff$[ebp]
	cdq
	mov	ecx, 1000				; 000003e8H
	idiv	ecx
	cmp	eax, DWORD PTR ?g_nLoadoutTimeLimit@@3HA ; g_nLoadoutTimeLimit
	jg	SHORT $LN11@MuniTimeCB
	mov	edx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A+64
	and	edx, 524288				; 00080000H
	je	$LN12@MuniTimeCB
$LN11@MuniTimeCB:

; 1184 : 			{
; 1185 : 				txt->Refresh();

	mov	eax, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax

; 1186 : 				if (flt->GetFirstUnitWP ())

	mov	ecx, DWORD PTR _flt$[ebp]
	call	?GetFirstUnitWP@UnitClass@@QAEPAVWayPointClass@@XZ ; UnitClass::GetFirstUnitWP
	test	eax, eax
	je	SHORT $LN10@MuniTimeCB

; 1187 : 				{
; 1188 : 					GetTimeString(flt->GetFirstUnitWP()->GetWPDepartureTime(),buf);

	push	1
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _flt$[ebp]
	call	?GetFirstUnitWP@UnitClass@@QAEPAVWayPointClass@@XZ ; UnitClass::GetFirstUnitWP
	mov	ecx, eax
	call	?GetWPDepartureTime@WayPointClass@@QAEKXZ ; WayPointClass::GetWPDepartureTime
	push	eax
	call	?GetTimeString@@YAPADKQADH@Z		; GetTimeString
	add	esp, 12					; 0000000cH

; 1189 : 					txt->SetText(buf);

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	mov	eax, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+256]
	call	eax

; 1190 : 				}
; 1191 : 				else

	jmp	SHORT $LN9@MuniTimeCB
$LN10@MuniTimeCB:

; 1192 : 				{
; 1193 : 					txt->SetText ("");

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+256]
	call	eax
$LN9@MuniTimeCB:

; 1194 : 				}
; 1195 : // END OF MODIFIED SECTION  2001-10-23
; 1196 : 
; 1197 : 				if((takeoff / VU_TICS_PER_SECOND) > 240)

	mov	eax, DWORD PTR _takeoff$[ebp]
	cdq
	mov	ecx, 1000				; 000003e8H
	idiv	ecx
	cmp	eax, 240				; 000000f0H
	jle	SHORT $LN8@MuniTimeCB

; 1198 : 					txt->SetFGColor(0x00ff00);

	push	65280					; 0000ff00H
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetFGColor@C_Text@@QAEXK@Z		; C_Text::SetFGColor
	jmp	SHORT $LN7@MuniTimeCB
$LN8@MuniTimeCB:

; 1199 : 				else if((takeoff / VU_TICS_PER_SECOND) > 180)

	mov	eax, DWORD PTR _takeoff$[ebp]
	cdq
	mov	ecx, 1000				; 000003e8H
	idiv	ecx
	cmp	eax, 180				; 000000b4H
	jle	SHORT $LN6@MuniTimeCB

; 1200 : 					txt->SetFGColor(0x00ffff);

	push	65535					; 0000ffffH
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetFGColor@C_Text@@QAEXK@Z		; C_Text::SetFGColor

; 1201 : 				else

	jmp	SHORT $LN7@MuniTimeCB
$LN6@MuniTimeCB:

; 1202 : 					txt->SetFGColor(0x0000ff);

	push	255					; 000000ffH
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetFGColor@C_Text@@QAEXK@Z		; C_Text::SetFGColor
$LN7@MuniTimeCB:

; 1203 : 				txt->Refresh();

	mov	edx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax+160]
	call	edx

; 1204 : 			}
; 1205 : 			else

	jmp	$LN4@MuniTimeCB
$LN12@MuniTimeCB:

; 1206 : 			{
; 1207 : 				txt->SetFlagBitOff(C_BIT_TIMER);

	push	65536					; 00010000H
	mov	eax, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 1208 : 				txt->Refresh();

	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax

; 1209 : 				txt->SetText(TXT_INFLIGHT);

	push	124					; 0000007cH
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+252]
	call	eax

; 1210 : 				txt->SetFGColor(0x0000ff);

	push	255					; 000000ffH
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetFGColor@C_Text@@QAEXK@Z		; C_Text::SetFGColor

; 1211 : 				txt->Refresh();

	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax

; 1212 : 				win=txt->GetParent();

	mov	ecx, DWORD PTR _txt$[ebp]
	call	?GetParent@C_Base@@QAEPAVC_Window@@XZ	; C_Base::GetParent
	mov	DWORD PTR _win$[ebp], eax

; 1213 : 				if(win)

	cmp	DWORD PTR _win$[ebp], 0
	je	SHORT $LN3@MuniTimeCB

; 1214 : 					win->DisableCluster(-100);

	push	-100					; ffffff9cH
	mov	ecx, DWORD PTR _win$[ebp]
	call	?DisableCluster@C_Window@@QAEXJ@Z	; C_Window::DisableCluster
$LN3@MuniTimeCB:

; 1215 : 				win->RefreshWindow();

	mov	ecx, DWORD PTR _win$[ebp]
	call	?RefreshWindow@C_Window@@QAEXXZ		; C_Window::RefreshWindow
$LN4@MuniTimeCB:

; 1216 : 			}
; 1217 : 
; 1218 : 			if (ref)

	movzx	ecx, BYTE PTR _ref$3[ebp]
	test	ecx, ecx
	je	SHORT $LN2@MuniTimeCB

; 1219 : 			{
; 1220 : //				win=txt->GetParent();
; 1221 : 
; 1222 : //				if (win)
; 1223 : //				{
; 1224 : 					SetCurrentLoadout();

	call	?SetCurrentLoadout@@YAXXZ		; SetCurrentLoadout

; 1225 : 					control->Parent_->RefreshClient(2);

	push	2
	mov	edx, DWORD PTR _control$[ebp]
	mov	ecx, DWORD PTR [edx+48]
	call	?RefreshClient@C_Window@@QAEXJ@Z	; C_Window::RefreshClient
$LN2@MuniTimeCB:

; 1226 : //					win->ScanClientAreas();
; 1227 : //					win->RefreshWindow();
; 1228 : //				}
; 1229 : 			}
; 1230 : 		}
; 1231 : 		else

	jmp	SHORT $LN25@MuniTimeCB
$LN24@MuniTimeCB:

; 1232 : 		{
; 1233 : 			txt->SetFlagBitOff(C_BIT_TIMER);

	push	65536					; 00010000H
	mov	eax, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 1234 : 			txt->Refresh();

	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax

; 1235 : 			txt->SetText(" ");

	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+256]
	call	eax

; 1236 : 			txt->Refresh();

	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN25@MuniTimeCB:

; 1237 : 		}
; 1238 : 	}
; 1239 : 	return(TRUE);

	mov	eax, 1
$LN27@MuniTimeCB:

; 1240 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?MuniTimeCB@@YAHPAVC_Base@@@Z ENDP			; MuniTimeCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\munition.cpp
_TEXT	SEGMENT
_i$ = -4						; size = 4
_Plane$ = 8						; size = 4
_ArmIt$ = 12						; size = 4
?SetPlaneToArm@@YAXJH@Z PROC				; SetPlaneToArm

; 1103 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1104 : 	int i;
; 1105 : 	PlaneEditList[Plane]=ArmIt;

	mov	eax, DWORD PTR _Plane$[ebp]
	mov	ecx, DWORD PTR _ArmIt$[ebp]
	mov	DWORD PTR ?PlaneEditList@@3PAJA[eax*4], ecx

; 1106 : 
; 1107 : 	// JB 020219 Limit munition planecount to less than five otherwise we overwrite memory.
; 1108 : 	for(i=0;i<PlaneCount && i < 4;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SetPlaneTo
$LN3@SetPlaneTo:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@SetPlaneTo:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR ?PlaneCount@@3JA		; PlaneCount
	jge	SHORT $LN5@SetPlaneTo
	cmp	DWORD PTR _i$[ebp], 4
	jge	SHORT $LN5@SetPlaneTo

; 1109 : 		if(PlaneEditList[i])

	mov	ecx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR ?PlaneEditList@@3PAJA[ecx*4], 0
	je	SHORT $LN1@SetPlaneTo

; 1110 : 		{
; 1111 : 			FirstPlane=i;

	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR ?FirstPlane@@3JA, edx		; FirstPlane

; 1112 : 			return;

	jmp	SHORT $LN5@SetPlaneTo
$LN1@SetPlaneTo:

; 1113 : 		}
; 1114 : }

	jmp	SHORT $LN3@SetPlaneTo
$LN5@SetPlaneTo:
	mov	esp, ebp
	pop	ebp
	ret	0
?SetPlaneToArm@@YAXJH@Z ENDP				; SetPlaneToArm
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\munition.cpp
_TEXT	SEGMENT
_plane$ = -16						; size = 4
_newtext$1 = -12					; size = 4
_obj$ = -8						; size = 4
_i$ = -4						; size = 4
?ChangeSkin@@YAXXZ PROC					; ChangeSkin

; 1065 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 1066 : 	BSPLIST *obj;
; 1067 : 	long plane = 0;

	mov	DWORD PTR _plane$[ebp], 0

; 1068 : 	int i;
; 1069 : 
; 1070 : 	for (i=0;i<PlaneCount;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN9@ChangeSkin
$LN8@ChangeSkin:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN9@ChangeSkin:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR ?PlaneCount@@3JA		; PlaneCount
	jge	SHORT $LN7@ChangeSkin

; 1071 : 	{
; 1072 : 		obj=gUIViewer->Find((i << 24));

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 24					; 00000018H
	push	edx
	mov	ecx, DWORD PTR ?gUIViewer@@3PAVC_3dViewer@@A ; gUIViewer
	call	?Find@C_3dViewer@@QAEPAUUI_BSPList@@J@Z	; C_3dViewer::Find
	mov	DWORD PTR _obj$[ebp], eax

; 1073 : 	}

	jmp	SHORT $LN8@ChangeSkin
$LN7@ChangeSkin:

; 1074 : 
; 1075 : 	if (obj)

	cmp	DWORD PTR _obj$[ebp], 0
	je	SHORT $LN6@ChangeSkin

; 1076 : 	{
; 1077 : 		int newtext;
; 1078 : 		newtext = ((DrawableBSP*)obj->object)->GetNTextureSet()-1;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	?GetNTextureSet@DrawableBSP@@QAEHXZ	; DrawableBSP::GetNTextureSet
	sub	eax, 1
	mov	DWORD PTR _newtext$1[ebp], eax

; 1079 : 			
; 1080 : 		if (newtext >= prevtext1)

	mov	ecx, DWORD PTR _newtext$1[ebp]
	cmp	ecx, DWORD PTR ?prevtext1@@3HA		; prevtext1
	jl	SHORT $LN5@ChangeSkin

; 1081 : 		{
; 1082 : 			prevtext1++;

	mov	edx, DWORD PTR ?prevtext1@@3HA		; prevtext1
	add	edx, 1
	mov	DWORD PTR ?prevtext1@@3HA, edx		; prevtext1
$LN5@ChangeSkin:

; 1083 : 		}
; 1084 : 
; 1085 : 		if (prevtext1 > newtext)

	mov	eax, DWORD PTR ?prevtext1@@3HA		; prevtext1
	cmp	eax, DWORD PTR _newtext$1[ebp]
	jle	SHORT $LN6@ChangeSkin

; 1086 : 		{
; 1087 : 			prevtext1 = 0;

	mov	DWORD PTR ?prevtext1@@3HA, 0		; prevtext1
$LN6@ChangeSkin:

; 1088 : 		}
; 1089 : 	}
; 1090 : 	//TJL step through again and apply the skins
; 1091 : 	//This sets the skins on each aircraft in the flight
; 1092 : 	for (i=0;i<PlaneCount;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@ChangeSkin
$LN2@ChangeSkin:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN3@ChangeSkin:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR ?PlaneCount@@3JA		; PlaneCount
	jge	SHORT $LN10@ChangeSkin

; 1093 : 	{
; 1094 : 		obj=gUIViewer->Find((i << 24));

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 24					; 00000018H
	push	eax
	mov	ecx, DWORD PTR ?gUIViewer@@3PAVC_3dViewer@@A ; gUIViewer
	call	?Find@C_3dViewer@@QAEPAUUI_BSPList@@J@Z	; C_3dViewer::Find
	mov	DWORD PTR _obj$[ebp], eax

; 1095 : 		((DrawableBSP*)obj->object)->SetTextureSet(prevtext1);

	mov	ecx, DWORD PTR ?prevtext1@@3HA		; prevtext1
	push	ecx
	mov	edx, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	call	?SetTextureSet@DrawableBSP@@QAEXK@Z	; DrawableBSP::SetTextureSet

; 1096 : 		set3DTexture = prevtext1;

	mov	eax, DWORD PTR ?prevtext1@@3HA		; prevtext1
	mov	DWORD PTR ?set3DTexture@@3HA, eax	; set3DTexture

; 1097 : 	}

	jmp	SHORT $LN2@ChangeSkin
$LN10@ChangeSkin:

; 1098 : 
; 1099 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ChangeSkin@@YAXXZ ENDP					; ChangeSkin
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\munition.cpp
_TEXT	SEGMENT
tv567 = -88						; size = 4
tv562 = -84						; size = 4
tv556 = -80						; size = 4
_loads$ = -76						; size = 4
_ac$ = -72						; size = 4
$T2 = -68						; size = 4
tv70 = -64						; size = 4
$T3 = -60						; size = 4
tv81 = -56						; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
_vid$ = -44						; size = 4
_vc$ = -40						; size = 4
_classPtr$ = -36					; size = 4
_v$ = -32						; size = 4
_flt$ = -28						; size = 4
_obj$ = -24						; size = 4
_j$ = -20						; size = 4
_i$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_flightID$ = 8						; size = 8
?LoadFlight@@YAXVVU_ID@@@Z PROC				; LoadFlight

; 891  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LoadFlight@@YAXVVU_ID@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 76					; 0000004cH
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 892  : 	Flight flt;
; 893  : 	VehicleClassDataType*	vc;
; 894  : 	Falcon4EntityClassType* classPtr;
; 895  : 	BSPLIST *obj;
; 896  : 	int vid,v,i,j,ac,loads;
; 897  : 
; 898  : 	if(gStores)

	cmp	DWORD PTR ?gStores@@3PAVStoresList@@A, 0 ; gStores
	je	SHORT $LN42@LoadFlight

; 899  : 	{
; 900  : 		gStores->Cleanup();

	mov	ecx, DWORD PTR ?gStores@@3PAVStoresList@@A ; gStores
	call	?Cleanup@StoresList@@QAEXXZ		; StoresList::Cleanup

; 901  : 		delete gStores;

	mov	eax, DWORD PTR ?gStores@@3PAVStoresList@@A ; gStores
	mov	DWORD PTR $T3[ebp], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR $T5[ebp], ecx
	cmp	DWORD PTR $T5[ebp], 0
	je	SHORT $LN41@LoadFlight
	push	1
	mov	ecx, DWORD PTR $T5[ebp]
	call	??_GStoresList@@QAEPAXI@Z
	mov	DWORD PTR tv70[ebp], eax
	jmp	SHORT $LN42@LoadFlight
$LN41@LoadFlight:
	mov	DWORD PTR tv70[ebp], 0
$LN42@LoadFlight:

; 902  : 	}
; 903  : 
; 904  : 	memset(LastCount,0,sizeof(LastCount));

	push	128					; 00000080H
	push	0
	push	OFFSET _LastCount
	call	_memset
	add	esp, 12					; 0000000cH

; 905  : 
; 906  : 	gStores=new StoresList;

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T4[ebp], 0
	je	SHORT $LN43@LoadFlight
	mov	ecx, DWORD PTR $T4[ebp]
	call	??0StoresList@@QAE@XZ			; StoresList::StoresList
	mov	DWORD PTR tv81[ebp], eax
	jmp	SHORT $LN44@LoadFlight
$LN43@LoadFlight:
	mov	DWORD PTR tv81[ebp], 0
$LN44@LoadFlight:
	mov	edx, DWORD PTR tv81[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR ?gStores@@3PAVStoresList@@A, eax ; gStores

; 907  : 
; 908  : 	flt=(Flight)FindUnit(flightID);

	mov	ecx, DWORD PTR _flightID$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _flightID$[ebp]
	push	edx
	call	?FindUnit@@YAPAVUnitClass@@VVU_ID@@@Z	; FindUnit
	add	esp, 8
	mov	DWORD PTR _flt$[ebp], eax

; 909  : 	if(flt == NULL) return;

	cmp	DWORD PTR _flt$[ebp], 0
	jne	SHORT $LN37@LoadFlight
	jmp	$LN39@LoadFlight
$LN37@LoadFlight:

; 910  : 
; 911  : 	for(i=0;i<5;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN36@LoadFlight
$LN35@LoadFlight:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN36@LoadFlight:
	cmp	DWORD PTR _i$[ebp], 5
	jge	SHORT $LN34@LoadFlight

; 912  : 	{
; 913  : 		memset(&gCurStores[i],		0,	sizeof(LoadoutStruct));

	push	48					; 00000030H
	push	0
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 48					; 00000030H
	add	ecx, OFFSET ?gCurStores@@3PAULoadoutStruct@@A ; gCurStores
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 914  : 		memset(&gOriginalStores[i],	0,	sizeof(LoadoutStruct));

	push	48					; 00000030H
	push	0
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 48					; 00000030H
	add	edx, OFFSET ?gOriginalStores@@3PAULoadoutStruct@@A ; gOriginalStores
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 915  : 	}

	jmp	SHORT $LN35@LoadFlight
$LN34@LoadFlight:

; 916  : 
; 917  : 	vid = flt->GetVehicleID(0);

	push	0
	mov	ecx, DWORD PTR _flt$[ebp]
	call	?GetVehicleID@UnitClass@@QAEFH@Z	; UnitClass::GetVehicleID
	cwde
	mov	DWORD PTR _vid$[ebp], eax

; 918  : 	vc = GetVehicleClassData(vid);

	mov	ecx, DWORD PTR _vid$[ebp]
	push	ecx
	call	?GetVehicleClassData@@YAPAUVehicleClassDataType@@H@Z ; GetVehicleClassData
	add	esp, 4
	mov	DWORD PTR _vc$[ebp], eax

; 919  : 	classPtr = &Falcon4ClassTable[vid];

	mov	edx, DWORD PTR _vid$[ebp]
	imul	edx, 81					; 00000051H
	add	edx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	DWORD PTR _classPtr$[ebp], edx

; 920  : 
; 921  : 	gVCPtr=vc;

	mov	eax, DWORD PTR _vc$[ebp]
	mov	DWORD PTR ?gVCPtr@@3PAUVehicleClassDataType@@A, eax ; gVCPtr

; 922  : 	gVehID=vid;

	mov	ecx, DWORD PTR _vid$[ebp]
	mov	DWORD PTR ?gVehID@@3HA, ecx		; gVehID

; 923  : 
; 924  : 	RackFlag=vc->RackFlags;

	mov	edx, DWORD PTR _vc$[ebp]
	movzx	eax, WORD PTR [edx+60]
	mov	DWORD PTR _RackFlag, eax

; 925  : 	VisFlag=vc->VisibleFlags;

	mov	ecx, DWORD PTR _vc$[ebp]
	movzx	edx, WORD PTR [ecx+62]
	mov	DWORD PTR _VisFlag, edx

; 926  : 	g3dObjectID=classPtr->visType[0];

	mov	eax, 2
	imul	eax, 0
	mov	ecx, DWORD PTR _classPtr$[ebp]
	mov	dx, WORD PTR [ecx+eax+60]
	mov	WORD PTR ?g3dObjectID@@3FA, dx		; g3dObjectID

; 927  : 
; 928  : 	for (i=HARDPOINT_MAX-1; i>=0; i--)

	mov	DWORD PTR _i$[ebp], 15			; 0000000fH
	jmp	SHORT $LN33@LoadFlight
$LN32@LoadFlight:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN33@LoadFlight:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN31@LoadFlight

; 929  : 	{
; 930  : 		if (vc->Weapon[i] != 0)

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _vc$[ebp]
	movsx	eax, WORD PTR [edx+ecx*2+98]
	test	eax, eax
	je	SHORT $LN30@LoadFlight

; 931  : 			break;

	jmp	SHORT $LN31@LoadFlight
$LN30@LoadFlight:

; 932  : 	}

	jmp	SHORT $LN32@LoadFlight
$LN31@LoadFlight:

; 933  : 	if (i >= 0)

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN29@LoadFlight

; 934  : 		i ++;

	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx

; 935  : 	else

	jmp	SHORT $LN28@LoadFlight
$LN29@LoadFlight:

; 936  : 		i = 0;

	mov	DWORD PTR _i$[ebp], 0
$LN28@LoadFlight:

; 937  : 
; 938  : 	HardPoints	= i;

	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR ?HardPoints@@3JA, edx		; HardPoints

; 939  : 	ac			= flt->GetTotalVehicles();

	mov	ecx, DWORD PTR _flt$[ebp]
	call	?GetTotalVehicles@UnitClass@@QAEHXZ	; UnitClass::GetTotalVehicles
	mov	DWORD PTR _ac$[ebp], eax

; 940  : 	loads		= flt->GetNumberOfLoadouts();

	mov	eax, DWORD PTR _flt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _flt$[ebp]
	mov	eax, DWORD PTR [edx+640]
	call	eax
	mov	DWORD PTR _loads$[ebp], eax

; 941  : 
; 942  : 	// JB 020219 Limit munition planecount to less than five otherwise we overwrite memory.
; 943  : 	ShiAssert( ac > 0 && loads > 0 && ac < 4);
; 944  : 
; 945  : 	// save info from what is in the flight
; 946  : 	for (v=0; v<ac && v < 4; v++)

	mov	DWORD PTR _v$[ebp], 0
	jmp	SHORT $LN27@LoadFlight
$LN26@LoadFlight:
	mov	ecx, DWORD PTR _v$[ebp]
	add	ecx, 1
	mov	DWORD PTR _v$[ebp], ecx
$LN27@LoadFlight:
	mov	edx, DWORD PTR _v$[ebp]
	cmp	edx, DWORD PTR _ac$[ebp]
	jge	SHORT $LN25@LoadFlight
	cmp	DWORD PTR _v$[ebp], 4
	jge	SHORT $LN25@LoadFlight

; 947  : 	{
; 948  : 		if (v < loads)

	mov	eax, DWORD PTR _v$[ebp]
	cmp	eax, DWORD PTR _loads$[ebp]
	jge	SHORT $LN24@LoadFlight

; 949  : 			memcpy(&gCurStores[v], flt->GetLoadout(v), sizeof(LoadoutStruct));

	push	48					; 00000030H
	mov	ecx, DWORD PTR _v$[ebp]
	push	ecx
	mov	edx, DWORD PTR _flt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _flt$[ebp]
	mov	edx, DWORD PTR [eax+996]
	call	edx
	push	eax
	mov	eax, DWORD PTR _v$[ebp]
	imul	eax, 48					; 00000030H
	add	eax, OFFSET ?gCurStores@@3PAULoadoutStruct@@A ; gCurStores
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 950  : 		else

	jmp	SHORT $LN23@LoadFlight
$LN24@LoadFlight:

; 951  : 			memcpy(&gCurStores[v], flt->GetLoadout(0), sizeof(LoadoutStruct));

	push	48					; 00000030H
	push	0
	mov	ecx, DWORD PTR _flt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _flt$[ebp]
	mov	eax, DWORD PTR [edx+996]
	call	eax
	push	eax
	mov	ecx, DWORD PTR _v$[ebp]
	imul	ecx, 48					; 00000030H
	add	ecx, OFFSET ?gCurStores@@3PAULoadoutStruct@@A ; gCurStores
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN23@LoadFlight:

; 952  : 	}

	jmp	SHORT $LN26@LoadFlight
$LN25@LoadFlight:

; 953  : 	memcpy(&gCurStores[4], flt->GetLoadout(0), sizeof(LoadoutStruct));

	push	48					; 00000030H
	push	0
	mov	edx, DWORD PTR _flt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _flt$[ebp]
	mov	edx, DWORD PTR [eax+996]
	call	edx
	push	eax
	mov	eax, 48					; 00000030H
	shl	eax, 2
	add	eax, OFFSET ?gCurStores@@3PAULoadoutStruct@@A ; gCurStores
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 954  : 
; 955  : 	for(i = 0; i < 5; ++i) // save what we originally came into the screen with

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN22@LoadFlight
$LN21@LoadFlight:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN22@LoadFlight:
	cmp	DWORD PTR _i$[ebp], 5
	jge	SHORT $LN20@LoadFlight

; 956  : 	{
; 957  : 		gOriginalStores[i] = gCurStores[i];

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 48					; 00000030H
	add	edx, OFFSET ?gCurStores@@3PAULoadoutStruct@@A ; gCurStores
	push	edx
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 48					; 00000030H
	add	ecx, OFFSET ?gOriginalStores@@3PAULoadoutStruct@@A ; gOriginalStores
	call	??4LoadoutStruct@@QAEABU0@ABU0@@Z	; LoadoutStruct::operator=

; 958  : 	}

	jmp	SHORT $LN21@LoadFlight
$LN20@LoadFlight:

; 959  : 
; 960  : 	gMainHandler->EnterCritical();

	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?EnterCritical@C_Handler@@QAEXXZ	; C_Handler::EnterCritical

; 961  : 
; 962  : 	for(i=0;i<PlaneCount;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN19@LoadFlight
$LN18@LoadFlight:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN19@LoadFlight:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR ?PlaneCount@@3JA		; PlaneCount
	jge	$LN17@LoadFlight

; 963  : 	{
; 964  : 		obj=gUIViewer->LoadBSP((i << 24),classPtr->visType[0],TRUE);

	push	1
	mov	edx, 2
	imul	edx, 0
	mov	eax, DWORD PTR _classPtr$[ebp]
	movsx	ecx, WORD PTR [eax+edx+60]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 24					; 00000018H
	push	edx
	mov	ecx, DWORD PTR ?gUIViewer@@3PAVC_3dViewer@@A ; gUIViewer
	call	?LoadBSP@C_3dViewer@@QAEPAUUI_BSPList@@JHH@Z ; C_3dViewer::LoadBSP
	mov	DWORD PTR _obj$[ebp], eax

; 965  : 
; 966  : 		ShiAssert(obj);
; 967  : 
; 968  : 		if(!i)

	cmp	DWORD PTR _i$[ebp], 0
	jne	SHORT $LN16@LoadFlight

; 969  : 			Object.PosZ=0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR ?Object@@3UOBJECTINFO@@A+24, xmm0
$LN16@LoadFlight:

; 970  : 		if (classPtr->visType[0] == MapVisId(VIS_F16C) ||
; 971  : 			(((DrawableBSP*)obj->object)->instance.ParentObject->nSwitches >= 10 &&
; 972  : 			((DrawableBSP*)obj->object)->instance.ParentObject->nDOFs >= 24))

	mov	eax, 2
	imul	eax, 0
	mov	ecx, DWORD PTR _classPtr$[ebp]
	movsx	esi, WORD PTR [ecx+eax+60]
	push	1052					; 0000041cH
	call	?MapVisId@@YAKK@Z			; MapVisId
	add	esp, 4
	cmp	esi, eax
	je	SHORT $LN14@LoadFlight
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [eax+116]
	movsx	edx, WORD PTR [ecx+52]
	cmp	edx, 10					; 0000000aH
	jl	SHORT $LN15@LoadFlight
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [ecx+116]
	movsx	eax, WORD PTR [edx+54]
	cmp	eax, 24					; 00000018H
	jl	SHORT $LN15@LoadFlight
$LN14@LoadFlight:

; 973  : 		{ // F16 switches/DOFS
; 974  : 
; 975  : 			// MLR 12/26/2003 - fix loadout LOD - now the gear is closed up
; 976  : 			((DrawableBSP*)obj->object)->SetSwitchMask(5, 1);

	push	1
	push	5
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 977  : 			((DrawableBSP*)obj->object)->SetSwitchMask(10, 1);

	push	1
	push	10					; 0000000aH
	mov	edx, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 978  : 			((DrawableBSP*)obj->object)->SetSwitchMask(31, 1);

	push	1
	push	31					; 0000001fH
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
	jmp	SHORT $LN12@LoadFlight
$LN15@LoadFlight:

; 979  : 
; 980  : 			/* // MLR 12/26/2003 - I commented all this out.
; 981  : 			((DrawableBSP*)obj->object)->SetSwitchMask(1, 1); // Landing Gear stuff
; 982  : 			((DrawableBSP*)obj->object)->SetSwitchMask(2, 1); //
; 983  : 			((DrawableBSP*)obj->object)->SetSwitchMask(3, 1); //
; 984  : 			((DrawableBSP*)obj->object)->SetSwitchMask(4, 1); //
; 985  : 
; 986  : 			//((DrawableBSP*)obj->object)->SetSwitchMask(8, TRUE); // Lights (other than landing)
; 987  : 
; 988  : 			((DrawableBSP*)obj->object)->SetSwitchMask(10, 1); // Afterburner
; 989  : 
; 990  : 			// More landing gear stuff
; 991  : 			((DrawableBSP*)obj->object)->SetDOFangle(19,90.0f * DTR);
; 992  : 			((DrawableBSP*)obj->object)->SetDOFangle(22,90.0f * DTR);
; 993  : 			((DrawableBSP*)obj->object)->SetDOFangle(20,75.0f * DTR);
; 994  : 			((DrawableBSP*)obj->object)->SetDOFangle(21,75.0f * DTR);
; 995  : 			((DrawableBSP*)obj->object)->SetDOFangle(23,75.0f * DTR);
; 996  : 			((DrawableBSP*)obj->object)->SetDOFangle(24,75.0f * DTR);
; 997  : 			*/
; 998  : 		}
; 999  : 		else if(classPtr->vuClassData.classInfo_[VU_TYPE] == TYPE_HELICOPTER)

	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _classPtr$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+8]
	cmp	eax, 5
	jne	SHORT $LN12@LoadFlight

; 1000 : 		{
; 1001 : 			((DrawableBSP*)obj->object)->SetSwitchMask(0, 2); // Turn on rotors

	push	2
	push	0
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 1002 : 			if(!i)

	cmp	DWORD PTR _i$[ebp], 0
	jne	SHORT $LN11@LoadFlight

; 1003 : 				Object.PosZ=-5;

	movss	xmm0, DWORD PTR __real@c0a00000
	movss	DWORD PTR ?Object@@3UOBJECTINFO@@A+24, xmm0
$LN11@LoadFlight:

; 1004 : 
; 1005 : 			
; 1006 : 			// RV - Biker - Use switch 24 because we need switch 2 for gear stuff
; 1007 : 			// only do so if we have HPs to put some weapons
; 1008 : 			//if(classPtr->visType[0] == MapVisId(VIS_UH60L))
; 1009 : 				//((DrawableBSP*)obj->object)->SetSwitchMask(2, 1); // Landing Gear
; 1010 : 			if (HardPoints > 1)

	cmp	DWORD PTR ?HardPoints@@3JA, 1		; HardPoints
	jle	SHORT $LN10@LoadFlight

; 1011 : 				((DrawableBSP*)obj->object)->SetSwitchMask(24, 1);

	push	1
	push	24					; 00000018H
	mov	edx, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN10@LoadFlight:
$LN12@LoadFlight:

; 1012 : 		}
; 1013 : 		else
; 1014 : 		{ // Non F16 switches/DOFS
; 1015 : 			// MLR 12/27/2003 - disable this too
; 1016 : 			//((DrawableBSP*)obj->object)->SetSwitchMask(2, 1); // Landing Gear
; 1017 : 			//((DrawableBSP*)obj->object)->SetSwitchMask(1, 1); // Lights (other than landing)
; 1018 : 		}
; 1019 : 
; 1020 : 		//TJL 01/03/04 If player changes a skin, then always show what was last selected.
; 1021 : 		//Since set3DTexture is a global, it stays sets during the same session.
; 1022 : 		//This makes sure the same texture is displayed when returning from the 3D world as well.
; 1023 : 		if (set3DTexture != -1)

	cmp	DWORD PTR ?set3DTexture@@3HA, -1	; set3DTexture
	je	SHORT $LN8@LoadFlight

; 1024 : 			((DrawableBSP*)obj->object)->SetTextureSet(set3DTexture);

	mov	eax, DWORD PTR ?set3DTexture@@3HA	; set3DTexture
	push	eax
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	call	?SetTextureSet@DrawableBSP@@QAEXK@Z	; DrawableBSP::SetTextureSet
$LN8@LoadFlight:

; 1025 : 
; 1026 : 		// Figure out the weapons
; 1027 : 
; 1028 : 		for(j=1;j<HardPoints;j++) {

	mov	DWORD PTR _j$[ebp], 1
	jmp	SHORT $LN7@LoadFlight
$LN6@LoadFlight:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$LN7@LoadFlight:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR ?HardPoints@@3JA		; HardPoints
	jge	SHORT $LN5@LoadFlight

; 1029 : 		    //if (g_bNewRackData)
; 1030 : 			GetJRackAndWeapon(vc, classPtr, gCurStores[i].WeaponID[j], gCurStores[i].WeaponCount[j], static_cast<short>(j), &gCurRails[i].rail[j]);

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 2560				; 00000a00H
	mov	edx, DWORD PTR _j$[ebp]
	imul	edx, 160				; 000000a0H
	lea	eax, DWORD PTR ?gCurRails@@3PAURailList@@A[ecx+edx]
	push	eax
	movzx	ecx, WORD PTR _j$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 48					; 00000030H
	mov	eax, DWORD PTR _j$[ebp]
	movzx	cx, BYTE PTR ?gCurStores@@3PAULoadoutStruct@@A[edx+eax+32]
	movzx	edx, cx
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _j$[ebp]
	movzx	edx, WORD PTR ?gCurStores@@3PAULoadoutStruct@@A[eax+ecx*2]
	push	edx
	mov	eax, DWORD PTR _classPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vc$[ebp]
	push	ecx
	call	?GetJRackAndWeapon@@YAHPAUVehicleClassDataType@@PAUFalcon4EntityClassType@@FFFPAVRailInfo@@@Z ; GetJRackAndWeapon
	add	esp, 24					; 00000018H

; 1031 : 		    //else
; 1032 : 			//GetRackAndWeapon(vc,static_cast<short>(vid),gCurStores[i].WeaponID[j],gCurStores[i].WeaponCount[j],static_cast<short>(j),static_cast<short>(HardPoints/2),&gCurRails[i].rail[j]);
; 1033 : 		}

	jmp	SHORT $LN6@LoadFlight
$LN5@LoadFlight:

; 1034 : 
; 1035 : 		for(j=1;j<HardPoints;j++)

	mov	DWORD PTR _j$[ebp], 1
	jmp	SHORT $LN4@LoadFlight
$LN3@LoadFlight:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$LN4@LoadFlight:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR ?HardPoints@@3JA		; HardPoints
	jge	SHORT $LN2@LoadFlight

; 1036 : 		{
; 1037 : 			LoadHardPoint(i,j,HardPoints/2,&gCurRails[i].rail[j]);

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 2560				; 00000a00H
	mov	edx, DWORD PTR _j$[ebp]
	imul	edx, 160				; 000000a0H
	lea	eax, DWORD PTR ?gCurRails@@3PAURailList@@A[ecx+edx]
	push	eax
	mov	eax, DWORD PTR ?HardPoints@@3JA		; HardPoints
	cdq
	sub	eax, edx
	sar	eax, 1
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	call	?LoadHardPoint@@YAXJJJPAVRailInfo@@@Z	; LoadHardPoint
	add	esp, 16					; 00000010H

; 1038 : 		}

	jmp	SHORT $LN3@LoadFlight
$LN2@LoadFlight:

; 1039 : 		
; 1040 : 		if(!i)

	cmp	DWORD PTR _i$[ebp], 0
	jne	$LN1@LoadFlight

; 1041 : 		{
; 1042 : 			Object.Heading=180.0f;

	movss	xmm0, DWORD PTR __real@43340000
	movss	DWORD PTR ?Object@@3UOBJECTINFO@@A, xmm0

; 1043 : 			Object.Pitch=-10.0f;

	movss	xmm0, DWORD PTR __real@c1200000
	movss	DWORD PTR ?Object@@3UOBJECTINFO@@A+4, xmm0

; 1044 : 			Object.Distance=((DrawableBSP*)obj->object)->Radius()*3;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	?Radius@DrawableObject@@QBEMXZ		; DrawableObject::Radius
	fstp	DWORD PTR tv556[ebp]
	movss	xmm0, DWORD PTR tv556[ebp]
	mulss	xmm0, DWORD PTR __real@40400000
	movss	DWORD PTR ?Object@@3UOBJECTINFO@@A+8, xmm0

; 1045 : 			Object.Direction=0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR ?Object@@3UOBJECTINFO@@A+12, xmm0

; 1046 : 
; 1047 : 			Object.MinDistance=((DrawableBSP*)obj->object)->Radius()+20;

	mov	ecx, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	call	?Radius@DrawableObject@@QBEMXZ		; DrawableObject::Radius
	fstp	DWORD PTR tv562[ebp]
	movss	xmm0, DWORD PTR tv562[ebp]
	addss	xmm0, DWORD PTR __real@41a00000
	movss	DWORD PTR ?Object@@3UOBJECTINFO@@A+40, xmm0

; 1048 : 			Object.MaxDistance=((DrawableBSP*)obj->object)->Radius()*10;

	mov	edx, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	call	?Radius@DrawableObject@@QBEMXZ		; DrawableObject::Radius
	fstp	DWORD PTR tv567[ebp]
	movss	xmm0, DWORD PTR tv567[ebp]
	mulss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR ?Object@@3UOBJECTINFO@@A+44, xmm0

; 1049 : 			Object.MinPitch=0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR ?Object@@3UOBJECTINFO@@A+52, xmm0

; 1050 : 			Object.MaxPitch=0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR ?Object@@3UOBJECTINFO@@A+56, xmm0

; 1051 : 			Object.CheckPitch=FALSE;

	mov	DWORD PTR ?Object@@3UOBJECTINFO@@A+48, 0

; 1052 : 
; 1053 : 			Object.PosX=0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR ?Object@@3UOBJECTINFO@@A+16, xmm0

; 1054 : 			Object.PosY=0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR ?Object@@3UOBJECTINFO@@A+20, xmm0
$LN1@LoadFlight:

; 1055 : 		}
; 1056 : 		PositandOrientSetData (Object.PosX, Object.PosY, Object.PosZ, 0.0f, 0.0f, 0.0f, &objPos,&objRot);

	push	OFFSET _objRot
	push	OFFSET _objPos
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR ?Object@@3UOBJECTINFO@@A+24
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR ?Object@@3UOBJECTINFO@@A+20
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR ?Object@@3UOBJECTINFO@@A+16
	movss	DWORD PTR [esp], xmm0
	call	?PositandOrientSetData@@YAXMMMMMMPAUTpoint@@PAUTrotation@@@Z ; PositandOrientSetData
	add	esp, 32					; 00000020H

; 1057 : 		((DrawableBSP*)obj->object)->Update(&objPos,&objRot);

	push	OFFSET _objRot
	push	OFFSET _objPos
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	?Update@DrawableBSP@@QAEXPBUTpoint@@PBUTrotation@@@Z ; DrawableBSP::Update

; 1058 : 	}

	jmp	$LN18@LoadFlight
$LN17@LoadFlight:

; 1059 : 	TallyStores();

	call	?TallyStores@@YAXXZ			; TallyStores

; 1060 : 	gMainHandler->LeaveCritical();

	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?LeaveCritical@C_Handler@@QAEXXZ	; C_Handler::LeaveCritical
$LN39@LoadFlight:

; 1061 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?LoadFlight@@YAXVVU_ID@@@Z$0:
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?LoadFlight@@YAXVVU_ID@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-84]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LoadFlight@@YAXVVU_ID@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LoadFlight@@YAXVVU_ID@@@Z ENDP				; LoadFlight
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\munition.cpp
_TEXT	SEGMENT
_classPtr$ = -20					; size = 4
_Plane$ = -16						; size = 4
_Weapon$ = -12						; size = 4
_Rack$ = -8						; size = 4
_i$ = -4						; size = 4
_plane$ = 8						; size = 4
_num$ = 12						; size = 4
_center$ = 16						; size = 4
?LoadHardPoint@@YAXJJJ@Z PROC				; LoadHardPoint

; 800  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 801  : 	Falcon4EntityClassType* classPtr;
; 802  : 	BSPLIST *Plane;
; 803  : 	BSPLIST *Rack;
; 804  : 	BSPLIST *Weapon;
; 805  : 	int i;
; 806  : 
; 807  : 	Plane=gUIViewer->Find((plane << 24));

	mov	eax, DWORD PTR _plane$[ebp]
	shl	eax, 24					; 00000018H
	push	eax
	mov	ecx, DWORD PTR ?gUIViewer@@3PAVC_3dViewer@@A ; gUIViewer
	call	?Find@C_3dViewer@@QAEPAUUI_BSPList@@J@Z	; C_3dViewer::Find
	mov	DWORD PTR _Plane$[ebp], eax

; 808  : 	if(Plane == NULL) return;

	cmp	DWORD PTR _Plane$[ebp], 0
	jne	SHORT $LN33@LoadHardPo
	jmp	$LN34@LoadHardPo
$LN33@LoadHardPo:

; 809  : 	if(!(VisFlag & (1 << num))) return;

	mov	edx, 1
	mov	ecx, DWORD PTR _num$[ebp]
	shl	edx, cl
	and	edx, DWORD PTR _VisFlag
	jne	SHORT $LN32@LoadHardPo
	jmp	$LN34@LoadHardPo
$LN32@LoadHardPo:

; 810  : 
; 811  : 	Rack=gUIViewer->Find((plane << 24) + (num << 16));

	mov	eax, DWORD PTR _plane$[ebp]
	shl	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _num$[ebp]
	shl	ecx, 16					; 00000010H
	add	eax, ecx
	push	eax
	mov	ecx, DWORD PTR ?gUIViewer@@3PAVC_3dViewer@@A ; gUIViewer
	call	?Find@C_3dViewer@@QAEPAUUI_BSPList@@J@Z	; C_3dViewer::Find
	mov	DWORD PTR _Rack$[ebp], eax

; 812  : 
; 813  : 	for(i=0;i<LastCount[plane][num];i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN31@LoadHardPo
$LN30@LoadHardPo:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN31@LoadHardPo:
	mov	eax, DWORD PTR _plane$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _num$[ebp]
	movsx	edx, WORD PTR _LastCount[eax+ecx*2]
	cmp	DWORD PTR _i$[ebp], edx
	jge	$LN29@LoadHardPo

; 814  : 	{
; 815  : 		Weapon=gUIViewer->Find((plane << 24) + (num << 16) + i + 1);

	mov	eax, DWORD PTR _plane$[ebp]
	shl	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _num$[ebp]
	shl	ecx, 16					; 00000010H
	add	eax, DWORD PTR _i$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	push	edx
	mov	ecx, DWORD PTR ?gUIViewer@@3PAVC_3dViewer@@A ; gUIViewer
	call	?Find@C_3dViewer@@QAEPAUUI_BSPList@@J@Z	; C_3dViewer::Find
	mov	DWORD PTR _Weapon$[ebp], eax

; 816  : 		if(Rack && Weapon)

	cmp	DWORD PTR _Rack$[ebp], 0
	je	$LN28@LoadHardPo
	cmp	DWORD PTR _Weapon$[ebp], 0
	je	$LN28@LoadHardPo

; 817  : 		{
; 818  : 			if(LastCount[plane][num] == 2)

	mov	eax, DWORD PTR _plane$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _num$[ebp]
	movsx	edx, WORD PTR _LastCount[eax+ecx*2]
	cmp	edx, 2
	jne	SHORT $LN27@LoadHardPo

; 819  : 			{
; 820  : 				if(num > center)

	mov	eax, DWORD PTR _num$[ebp]
	cmp	eax, DWORD PTR _center$[ebp]
	jle	SHORT $LN26@LoadHardPo

; 821  : 				{
; 822  : 					if(!i)

	cmp	DWORD PTR _i$[ebp], 0
	jne	SHORT $LN25@LoadHardPo

; 823  : 						((DrawableBSP*)Rack->object)->DetachChild(((DrawableBSP*)Weapon->object),i+2);

	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _Weapon$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _Rack$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	call	?DetachChild@DrawableBSP@@QAEXPAV1@H@Z	; DrawableBSP::DetachChild

; 824  : 					else

	jmp	SHORT $LN24@LoadHardPo
$LN25@LoadHardPo:

; 825  : 						((DrawableBSP*)Rack->object)->DetachChild(((DrawableBSP*)Weapon->object),i);

	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	eax, DWORD PTR _Weapon$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _Rack$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	call	?DetachChild@DrawableBSP@@QAEXPAV1@H@Z	; DrawableBSP::DetachChild
$LN24@LoadHardPo:

; 826  : 				}
; 827  : 				else

	jmp	SHORT $LN23@LoadHardPo
$LN26@LoadHardPo:

; 828  : 					((DrawableBSP*)Rack->object)->DetachChild(((DrawableBSP*)Weapon->object),i);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Weapon$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _Rack$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	?DetachChild@DrawableBSP@@QAEXPAV1@H@Z	; DrawableBSP::DetachChild
$LN23@LoadHardPo:

; 829  : 			}
; 830  : 			else

	jmp	SHORT $LN22@LoadHardPo
$LN27@LoadHardPo:

; 831  : 				((DrawableBSP*)Rack->object)->DetachChild(((DrawableBSP*)Weapon->object),i);

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Weapon$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _Rack$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	call	?DetachChild@DrawableBSP@@QAEXPAV1@H@Z	; DrawableBSP::DetachChild
$LN22@LoadHardPo:

; 832  : 			gUIViewer->Remove((plane << 24) + (num << 16) + i + 1);

	mov	edx, DWORD PTR _plane$[ebp]
	shl	edx, 24					; 00000018H
	mov	eax, DWORD PTR _num$[ebp]
	shl	eax, 16					; 00000010H
	add	edx, DWORD PTR _i$[ebp]
	lea	ecx, DWORD PTR [eax+edx+1]
	push	ecx
	mov	ecx, DWORD PTR ?gUIViewer@@3PAVC_3dViewer@@A ; gUIViewer
	call	?Remove@C_3dViewer@@QAEHJ@Z		; C_3dViewer::Remove
	jmp	SHORT $LN21@LoadHardPo
$LN28@LoadHardPo:

; 833  : 		}
; 834  : 		else if(Weapon)

	cmp	DWORD PTR _Weapon$[ebp], 0
	je	SHORT $LN21@LoadHardPo

; 835  : 		{
; 836  : 			((DrawableBSP*)Plane->object)->DetachChild(((DrawableBSP*)Weapon->object),num-1);

	mov	edx, DWORD PTR _num$[ebp]
	sub	edx, 1
	push	edx
	mov	eax, DWORD PTR _Weapon$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _Plane$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	call	?DetachChild@DrawableBSP@@QAEXPAV1@H@Z	; DrawableBSP::DetachChild

; 837  : 			gUIViewer->Remove((plane << 24) + (num << 16) + i + 1);

	mov	eax, DWORD PTR _plane$[ebp]
	shl	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _num$[ebp]
	shl	ecx, 16					; 00000010H
	add	eax, DWORD PTR _i$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	push	edx
	mov	ecx, DWORD PTR ?gUIViewer@@3PAVC_3dViewer@@A ; gUIViewer
	call	?Remove@C_3dViewer@@QAEHJ@Z		; C_3dViewer::Remove
$LN21@LoadHardPo:

; 838  : 		}
; 839  : 		Weapon=NULL;

	mov	DWORD PTR _Weapon$[ebp], 0

; 840  : 	}

	jmp	$LN30@LoadHardPo
$LN29@LoadHardPo:

; 841  : 
; 842  : 	if(Rack)

	cmp	DWORD PTR _Rack$[ebp], 0
	je	SHORT $LN19@LoadHardPo

; 843  : 	{
; 844  : 		((DrawableBSP*)Plane->object)->DetachChild(((DrawableBSP*)Rack->object),num-1);

	mov	eax, DWORD PTR _num$[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _Rack$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _Plane$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	?DetachChild@DrawableBSP@@QAEXPAV1@H@Z	; DrawableBSP::DetachChild

; 845  : 		gUIViewer->Remove((plane << 24) + (num << 16));

	mov	ecx, DWORD PTR _plane$[ebp]
	shl	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _num$[ebp]
	shl	edx, 16					; 00000010H
	add	ecx, edx
	push	ecx
	mov	ecx, DWORD PTR ?gUIViewer@@3PAVC_3dViewer@@A ; gUIViewer
	call	?Remove@C_3dViewer@@QAEHJ@Z		; C_3dViewer::Remove

; 846  : 		Rack=NULL;

	mov	DWORD PTR _Rack$[ebp], 0
$LN19@LoadHardPo:

; 847  : 	}
; 848  : 	if(RackFlag & (1 << num))

	mov	eax, 1
	mov	ecx, DWORD PTR _num$[ebp]
	shl	eax, cl
	and	eax, DWORD PTR _RackFlag
	je	$LN18@LoadHardPo

; 849  : 	{
; 850  : 		if(gCurStores[plane].WeaponCount[num] == 1)

	mov	ecx, DWORD PTR _plane$[ebp]
	imul	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _num$[ebp]
	movzx	eax, BYTE PTR ?gCurStores@@3PAULoadoutStruct@@A[ecx+edx+32]
	cmp	eax, 1
	jne	SHORT $LN17@LoadHardPo

; 851  : 			Rack=gUIViewer->LoadBSP((plane << 24) + (num << 16),VIS_SINGLE_RACK);

	push	0
	push	140					; 0000008cH
	mov	ecx, DWORD PTR _plane$[ebp]
	shl	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _num$[ebp]
	shl	edx, 16					; 00000010H
	add	ecx, edx
	push	ecx
	mov	ecx, DWORD PTR ?gUIViewer@@3PAVC_3dViewer@@A ; gUIViewer
	call	?LoadBSP@C_3dViewer@@QAEPAUUI_BSPList@@JHH@Z ; C_3dViewer::LoadBSP
	mov	DWORD PTR _Rack$[ebp], eax
	jmp	SHORT $LN16@LoadHardPo
$LN17@LoadHardPo:

; 852  : 		else if(gCurStores[plane].WeaponCount[num] > 1)

	mov	eax, DWORD PTR _plane$[ebp]
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _num$[ebp]
	movzx	edx, BYTE PTR ?gCurStores@@3PAULoadoutStruct@@A[eax+ecx+32]
	cmp	edx, 1
	jle	SHORT $LN16@LoadHardPo

; 853  : 			Rack=gUIViewer->LoadBSP((plane << 24) + (num << 16),VIS_TRIPLE_RACK);

	push	0
	push	141					; 0000008dH
	mov	eax, DWORD PTR _plane$[ebp]
	shl	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _num$[ebp]
	shl	ecx, 16					; 00000010H
	add	eax, ecx
	push	eax
	mov	ecx, DWORD PTR ?gUIViewer@@3PAVC_3dViewer@@A ; gUIViewer
	call	?LoadBSP@C_3dViewer@@QAEPAUUI_BSPList@@JHH@Z ; C_3dViewer::LoadBSP
	mov	DWORD PTR _Rack$[ebp], eax
$LN16@LoadHardPo:

; 854  : 		if(Rack)

	cmp	DWORD PTR _Rack$[ebp], 0
	je	SHORT $LN18@LoadHardPo

; 855  : 			((DrawableBSP*)Plane->object)->AttachChild(((DrawableBSP*)Rack->object),num-1);

	mov	edx, DWORD PTR _num$[ebp]
	sub	edx, 1
	push	edx
	mov	eax, DWORD PTR _Rack$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _Plane$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	call	?AttachChild@DrawableBSP@@QAEXPAV1@H@Z	; DrawableBSP::AttachChild
$LN18@LoadHardPo:

; 856  : 	}
; 857  : 	classPtr = &Falcon4ClassTable[WeaponDataTable[gCurStores[plane].WeaponID[num]].Index];

	mov	eax, DWORD PTR _plane$[ebp]
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _num$[ebp]
	movsx	edx, WORD PTR ?gCurStores@@3PAULoadoutStruct@@A[eax+ecx*2]
	imul	edx, 60					; 0000003cH
	mov	eax, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movsx	ecx, WORD PTR [eax+edx]
	imul	ecx, 81					; 00000051H
	add	ecx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	DWORD PTR _classPtr$[ebp], ecx

; 858  : 	if(classPtr)

	je	$LN34@LoadHardPo

; 859  : 	{
; 860  : 		for(i=0;i<gCurStores[plane].WeaponCount[num] && i < _WPN_MAX_;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN12@LoadHardPo
$LN11@LoadHardPo:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN12@LoadHardPo:
	mov	eax, DWORD PTR _plane$[ebp]
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _num$[ebp]
	movzx	edx, BYTE PTR ?gCurStores@@3PAULoadoutStruct@@A[eax+ecx+32]
	cmp	DWORD PTR _i$[ebp], edx
	jge	$LN10@LoadHardPo
	cmp	DWORD PTR _i$[ebp], 6
	jge	$LN10@LoadHardPo

; 861  : 		{
; 862  : 			Weapon=gUIViewer->LoadBSP((plane << 24) + (num << 16) + i + 1,classPtr->visType[0]);

	push	0
	mov	eax, 2
	imul	eax, 0
	mov	ecx, DWORD PTR _classPtr$[ebp]
	movsx	edx, WORD PTR [ecx+eax+60]
	push	edx
	mov	eax, DWORD PTR _plane$[ebp]
	shl	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _num$[ebp]
	shl	ecx, 16					; 00000010H
	add	eax, DWORD PTR _i$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	push	edx
	mov	ecx, DWORD PTR ?gUIViewer@@3PAVC_3dViewer@@A ; gUIViewer
	call	?LoadBSP@C_3dViewer@@QAEPAUUI_BSPList@@JHH@Z ; C_3dViewer::LoadBSP
	mov	DWORD PTR _Weapon$[ebp], eax

; 863  : 			if(Weapon)

	cmp	DWORD PTR _Weapon$[ebp], 0
	je	$LN9@LoadHardPo

; 864  : 			{
; 865  : 				if(Rack)

	cmp	DWORD PTR _Rack$[ebp], 0
	je	$LN8@LoadHardPo

; 866  : 				{
; 867  : 					if(gCurStores[plane].WeaponCount[num] == 2)

	mov	eax, DWORD PTR _plane$[ebp]
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _num$[ebp]
	movzx	edx, BYTE PTR ?gCurStores@@3PAULoadoutStruct@@A[eax+ecx+32]
	cmp	edx, 2
	jne	SHORT $LN7@LoadHardPo

; 868  : 					{
; 869  : 						if(num > center)

	mov	eax, DWORD PTR _num$[ebp]
	cmp	eax, DWORD PTR _center$[ebp]
	jle	SHORT $LN6@LoadHardPo

; 870  : 						{
; 871  : 							if(!i)

	cmp	DWORD PTR _i$[ebp], 0
	jne	SHORT $LN5@LoadHardPo

; 872  : 								((DrawableBSP*)Rack->object)->AttachChild(((DrawableBSP*)Weapon->object),i+2);

	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _Weapon$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _Rack$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	call	?AttachChild@DrawableBSP@@QAEXPAV1@H@Z	; DrawableBSP::AttachChild

; 873  : 							else

	jmp	SHORT $LN4@LoadHardPo
$LN5@LoadHardPo:

; 874  : 								((DrawableBSP*)Rack->object)->AttachChild(((DrawableBSP*)Weapon->object),i);

	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	eax, DWORD PTR _Weapon$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _Rack$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	call	?AttachChild@DrawableBSP@@QAEXPAV1@H@Z	; DrawableBSP::AttachChild
$LN4@LoadHardPo:

; 875  : 						}
; 876  : 						else

	jmp	SHORT $LN3@LoadHardPo
$LN6@LoadHardPo:

; 877  : 							((DrawableBSP*)Rack->object)->AttachChild(((DrawableBSP*)Weapon->object),i);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Weapon$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _Rack$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	?AttachChild@DrawableBSP@@QAEXPAV1@H@Z	; DrawableBSP::AttachChild
$LN3@LoadHardPo:

; 878  : 					}
; 879  : 					else

	jmp	SHORT $LN2@LoadHardPo
$LN7@LoadHardPo:

; 880  : 						((DrawableBSP*)Rack->object)->AttachChild(((DrawableBSP*)Weapon->object),i);

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Weapon$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _Rack$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	call	?AttachChild@DrawableBSP@@QAEXPAV1@H@Z	; DrawableBSP::AttachChild
$LN2@LoadHardPo:

; 881  : 				}
; 882  : 				else

	jmp	SHORT $LN9@LoadHardPo
$LN8@LoadHardPo:

; 883  : 					((DrawableBSP*)Plane->object)->AttachChild(((DrawableBSP*)Weapon->object),num-1);

	mov	edx, DWORD PTR _num$[ebp]
	sub	edx, 1
	push	edx
	mov	eax, DWORD PTR _Weapon$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _Plane$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	call	?AttachChild@DrawableBSP@@QAEXPAV1@H@Z	; DrawableBSP::AttachChild
$LN9@LoadHardPo:

; 884  : 			}
; 885  : 		}

	jmp	$LN11@LoadHardPo
$LN10@LoadHardPo:

; 886  : 		LastCount[plane][num]=gCurStores[plane].WeaponCount[num];

	mov	eax, DWORD PTR _plane$[ebp]
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _num$[ebp]
	movzx	dx, BYTE PTR ?gCurStores@@3PAULoadoutStruct@@A[eax+ecx+32]
	mov	eax, DWORD PTR _plane$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _num$[ebp]
	mov	WORD PTR _LastCount[eax+ecx*2], dx
$LN34@LoadHardPo:

; 887  : 	}
; 888  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?LoadHardPoint@@YAXJJJ@Z ENDP				; LoadHardPoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\munition.cpp
_TEXT	SEGMENT
$T2 = -48						; size = 4
_PlaneBSP$ = -44					; size = 4
_lo$ = -40						; size = 4
tv168 = -36						; size = 4
$T3 = -32						; size = 4
_Plane$ = -28						; size = 4
_lastPtr$ = -24						; size = 4
_weapPtr$ = -20						; size = 4
_i$ = -16						; size = 2
__$EHRec$ = -12						; size = 12
_plane$ = 8						; size = 4
_hardpoint$ = 12					; size = 4
___formal$ = 16						; size = 4
_rail$ = 20						; size = 4
?LoadHardPoint@@YAXJJJPAVRailInfo@@@Z PROC		; LoadHardPoint

; 711  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LoadHardPoint@@YAXJJJPAVRailInfo@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 712  : 	//Falcon4EntityClassType* rackPtr,*weapPtr;
; 713  : 	BSPLIST *Plane;
; 714  : 	DrawableBSP *PlaneBSP;
; 715  : //	BSPLIST *Rack;
; 716  : //	BSPLIST *Weapon;
; 717  : 	short /*bits,*/i;
; 718  : 
; 719  : 	Plane=gUIViewer->Find((plane << 24));

	mov	eax, DWORD PTR _plane$[ebp]
	shl	eax, 24					; 00000018H
	push	eax
	mov	ecx, DWORD PTR ?gUIViewer@@3PAVC_3dViewer@@A ; gUIViewer
	call	?Find@C_3dViewer@@QAEPAUUI_BSPList@@J@Z	; C_3dViewer::Find
	mov	DWORD PTR _Plane$[ebp], eax

; 720  : 	if(Plane == NULL) return;

	cmp	DWORD PTR _Plane$[ebp], 0
	jne	SHORT $LN10@LoadHardPo
	jmp	$LN11@LoadHardPo
$LN10@LoadHardPo:

; 721  : 
; 722  : 	PlaneBSP = (DrawableBSP *)Plane->object;

	mov	ecx, DWORD PTR _Plane$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _PlaneBSP$[ebp], edx

; 723  : 
; 724  : 	rail->hardPoint.SetHPId(hardpoint);

	mov	eax, DWORD PTR _hardpoint$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rail$[ebp]
	call	?SetHPId@BasicWeaponStation@@QAEXH@Z	; BasicWeaponStation::SetHPId

; 725  : 	rail->hardPoint.SetParentDrawPtr(PlaneBSP);

	mov	ecx, DWORD PTR _PlaneBSP$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _rail$[ebp]
	call	?SetParentDrawPtr@AdvancedWeaponStation@@QAEXPAVDrawableBSP@@@Z ; AdvancedWeaponStation::SetParentDrawPtr

; 726  : 	rail->hardPoint.AttachPylonBSP();

	mov	edx, DWORD PTR _rail$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _rail$[ebp]
	mov	edx, DWORD PTR [eax+52]
	call	edx

; 727  : 	rail->hardPoint.AttachRackBSP();

	mov	eax, DWORD PTR _rail$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _rail$[ebp]
	mov	eax, DWORD PTR [edx+64]
	call	eax

; 728  : 
; 729  : 	VuBin<SimWeaponClass> weapPtr;

	push	0
	lea	ecx, DWORD PTR _weapPtr$[ebp]
	call	??0?$VuBin@VSimWeaponClass@@@@QAE@PAVSimWeaponClass@@@Z ; VuBin<SimWeaponClass>::VuBin<SimWeaponClass>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 730  : 	VuBin<SimWeaponClass> lastPtr;

	push	0
	lea	ecx, DWORD PTR _lastPtr$[ebp]
	call	??0?$VuBin@VSimWeaponClass@@@@QAE@PAVSimWeaponClass@@@Z ; VuBin<SimWeaponClass>::VuBin<SimWeaponClass>
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 731  : 
; 732  : 	for (i=0; i<rail->weaponCount; i++)

	xor	ecx, ecx
	mov	WORD PTR _i$[ebp], cx
	jmp	SHORT $LN9@LoadHardPo
$LN8@LoadHardPo:
	mov	dx, WORD PTR _i$[ebp]
	add	dx, 1
	mov	WORD PTR _i$[ebp], dx
$LN9@LoadHardPo:
	movsx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _rail$[ebp]
	movsx	edx, WORD PTR [ecx+156]
	cmp	eax, edx
	jge	$LN7@LoadHardPo

; 733  : 	{
; 734  : 		// Load from back of rack to front (ie, 2 missiles on a tri-rack will
; 735  : 		// load into slot 1 and 2, not 0 and 1)
; 736  : 		weapPtr.reset(new SimWeaponClass(WeaponDataTable[rail->hardPoint.weaponId].Index + VU_LAST_ENTITY_TYPE));

	push	692					; 000002b4H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN13@LoadHardPo
	mov	eax, DWORD PTR _rail$[ebp]
	movsx	ecx, WORD PTR [eax+8]
	imul	ecx, 60					; 0000003cH
	mov	edx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movsx	eax, WORD PTR [edx+ecx]
	add	eax, 100				; 00000064H
	push	eax
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0SimWeaponClass@@QAE@H@Z		; SimWeaponClass::SimWeaponClass
	mov	DWORD PTR tv168[ebp], eax
	jmp	SHORT $LN14@LoadHardPo
$LN13@LoadHardPo:
	mov	DWORD PTR tv168[ebp], 0
$LN14@LoadHardPo:
	mov	ecx, DWORD PTR tv168[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	lea	ecx, DWORD PTR _weapPtr$[ebp]
	call	?reset@?$VuBin@VSimWeaponClass@@@@QAEXPAVSimWeaponClass@@@Z ; VuBin<SimWeaponClass>::reset

; 737  : 		if (weapPtr){

	lea	ecx, DWORD PTR _weapPtr$[ebp]
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@LoadHardPo

; 738  : 			weapPtr->SetRackSlot(rail->hardPoint.NumPoints()-(i+1));

	mov	ecx, DWORD PTR _rail$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _rail$[ebp]
	mov	eax, DWORD PTR [edx+44]
	call	eax
	movsx	ecx, WORD PTR _i$[ebp]
	add	ecx, 1
	sub	eax, ecx
	push	eax
	lea	ecx, DWORD PTR _weapPtr$[ebp]
	call	??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::operator->
	mov	ecx, eax
	call	?SetRackSlot@SimWeaponClass@@QAEXH@Z	; SimWeaponClass::SetRackSlot

; 739  : 			if (lastPtr){

	lea	ecx, DWORD PTR _lastPtr$[ebp]
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN5@LoadHardPo

; 740  : 				weapPtr->nextOnRail = lastPtr;

	lea	eax, DWORD PTR _lastPtr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _weapPtr$[ebp]
	call	??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::operator->
	add	eax, 672				; 000002a0H
	mov	ecx, eax
	call	??4?$VuBin@VSimWeaponClass@@@@QAEABV0@ABV0@@Z ; VuBin<SimWeaponClass>::operator=
$LN5@LoadHardPo:

; 741  : 			}
; 742  : 			lastPtr = weapPtr;

	lea	ecx, DWORD PTR _weapPtr$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _lastPtr$[ebp]
	call	??4?$VuBin@VSimWeaponClass@@@@QAEABV0@ABV0@@Z ; VuBin<SimWeaponClass>::operator=
$LN6@LoadHardPo:

; 743  : 		}
; 744  : 	}

	jmp	$LN8@LoadHardPo
$LN7@LoadHardPo:

; 745  : 	rail->hardPoint.weaponPointer = weapPtr;

	lea	edx, DWORD PTR _weapPtr$[ebp]
	push	edx
	mov	ecx, DWORD PTR _rail$[ebp]
	add	ecx, 12					; 0000000cH
	call	??4?$VuBin@VSimWeaponClass@@@@QAEABV0@ABV0@@Z ; VuBin<SimWeaponClass>::operator=

; 746  : 	int *lo = rail->hardPoint.GetLoadOrder();

	mov	eax, DWORD PTR _rail$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _rail$[ebp]
	mov	eax, DWORD PTR [edx+192]
	call	eax
	mov	DWORD PTR _lo$[ebp], eax

; 747  : 	if(lo){

	cmp	DWORD PTR _lo$[ebp], 0
	je	SHORT $LN4@LoadHardPo

; 748  : 		for (i=0; i<rail->weaponCount && weapPtr; i++){

	xor	ecx, ecx
	mov	WORD PTR _i$[ebp], cx
	jmp	SHORT $LN3@LoadHardPo
$LN2@LoadHardPo:
	mov	dx, WORD PTR _i$[ebp]
	add	dx, 1
	mov	WORD PTR _i$[ebp], dx
$LN3@LoadHardPo:
	movsx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _rail$[ebp]
	movsx	edx, WORD PTR [ecx+156]
	cmp	eax, edx
	jge	SHORT $LN4@LoadHardPo
	lea	ecx, DWORD PTR _weapPtr$[ebp]
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@LoadHardPo

; 749  : 			weapPtr->SetRackSlot(lo[i]);

	movsx	ecx, WORD PTR _i$[ebp]
	mov	edx, DWORD PTR _lo$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	lea	ecx, DWORD PTR _weapPtr$[ebp]
	call	??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::operator->
	mov	ecx, eax
	call	?SetRackSlot@SimWeaponClass@@QAEXH@Z	; SimWeaponClass::SetRackSlot

; 750  : 			weapPtr = weapPtr->nextOnRail;

	lea	ecx, DWORD PTR _weapPtr$[ebp]
	call	??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::operator->
	add	eax, 672				; 000002a0H
	push	eax
	lea	ecx, DWORD PTR _weapPtr$[ebp]
	call	??4?$VuBin@VSimWeaponClass@@@@QAEABV0@ABV0@@Z ; VuBin<SimWeaponClass>::operator=

; 751  : 		}

	jmp	SHORT $LN2@LoadHardPo
$LN4@LoadHardPo:

; 752  : 	}
; 753  : 
; 754  : 	rail->hardPoint.AttachAllWeaponBSP();

	mov	ecx, DWORD PTR _rail$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _rail$[ebp]
	mov	eax, DWORD PTR [edx+76]
	call	eax

; 755  : 
; 756  : //	if(g3dObjectID == VIS_F16C)
; 757  : //		Check_HTS_Tirn((DrawableBSP*)Plane->object,&gCurStores[plane]);
; 758  : 	/*
; 759  : 
; 760  : 	if(rail->rackID)
; 761  : 	{
; 762  : 		rackPtr=&Falcon4ClassTable[rail->rackID];
; 763  : 		Rack=gUIViewer->LoadBSP((plane << 24) + (hardpoint << 16),rackPtr->visType[0]);
; 764  : 		if(Rack)
; 765  : 		{
; 766  : 			((DrawableBSP*)Plane->object)->AttachChild(((DrawableBSP*)Rack->object),hardpoint-1);
; 767  : 
; 768  : 			if(rail->weaponID && rail->startBits)
; 769  : 			{
; 770  : 				weapPtr=&Falcon4ClassTable[rail->weaponID];
; 771  : 				bits=rail->startBits;
; 772  : 				i=0;
; 773  : 				while(bits)
; 774  : 				{
; 775  : 					Weapon=gUIViewer->LoadBSP((plane << 24) + (hardpoint << 16) + (i+1),weapPtr->visType[0]);
; 776  : 					if(Weapon)
; 777  : 						// JB 020314 work from the back to the font (like the 3d code)
; 778  : 						((DrawableBSP*)Rack->object)->AttachChild(((DrawableBSP*)Weapon->object),
; 779  : 							((DrawableBSP*)Rack->object)->instance.ParentObject->nSlots - i - 1);
; 780  : 					bits >>= 1;
; 781  : 					i++;
; 782  : 				}
; 783  : 			}
; 784  : 		}
; 785  : 	}
; 786  : 	else if(rail->weaponID)
; 787  : 	{
; 788  : 		if(rail->startBits)
; 789  : 		{
; 790  : 			weapPtr=&Falcon4ClassTable[rail->weaponID];
; 791  : 			Weapon=gUIViewer->LoadBSP((plane << 24) + (hardpoint << 16) + 1,weapPtr->visType[0]);
; 792  : 			if(Weapon)
; 793  : 				((DrawableBSP*)Plane->object)->AttachChild(((DrawableBSP*)Weapon->object),hardpoint-1);
; 794  : 		}
; 795  : 	}
; 796  : 	*/
; 797  : }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _lastPtr$[ebp]
	call	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ	; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _weapPtr$[ebp]
	call	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ	; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>
$LN11@LoadHardPo:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?LoadHardPoint@@YAXJJJPAVRailInfo@@@Z$0:
	lea	ecx, DWORD PTR _weapPtr$[ebp]
	jmp	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ	; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>
__unwindfunclet$?LoadHardPoint@@YAXJJJPAVRailInfo@@@Z$1:
	lea	ecx, DWORD PTR _lastPtr$[ebp]
	jmp	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ	; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>
__unwindfunclet$?LoadHardPoint@@YAXJJJPAVRailInfo@@@Z$2:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?LoadHardPoint@@YAXJJJPAVRailInfo@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LoadHardPoint@@YAXJJJPAVRailInfo@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LoadHardPoint@@YAXJJJPAVRailInfo@@@Z ENDP		; LoadHardPoint
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\munition.cpp
_TEXT	SEGMENT
_i$ = -8						; size = 4
_j$ = -4						; size = 4
?ClearAllHardPointBSPs@@YAXXZ PROC			; ClearAllHardPointBSPs

; 670  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 671  : 	int i,j;
; 672  : 
; 673  : 	for(i=0;i<4;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@ClearAllHa
$LN6@ClearAllHa:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@ClearAllHa:
	cmp	DWORD PTR _i$[ebp], 4
	jge	SHORT $LN8@ClearAllHa

; 674  : 	{
; 675  : 		for(j=1;j<HARDPOINT_MAX;j++)

	mov	DWORD PTR _j$[ebp], 1
	jmp	SHORT $LN4@ClearAllHa
$LN3@ClearAllHa:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$LN4@ClearAllHa:
	cmp	DWORD PTR _j$[ebp], 16			; 00000010H
	jge	SHORT $LN2@ClearAllHa

; 676  : 		{
; 677  : 			if(j && j < HardPoints)

	cmp	DWORD PTR _j$[ebp], 0
	je	SHORT $LN1@ClearAllHa
	mov	edx, DWORD PTR _j$[ebp]
	cmp	edx, DWORD PTR ?HardPoints@@3JA		; HardPoints
	jge	SHORT $LN1@ClearAllHa

; 678  : 			{
; 679  : 				ClearHardPoint(i,j,HardPoints/2,&gCurRails[i].rail[j]);

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 2560				; 00000a00H
	mov	ecx, DWORD PTR _j$[ebp]
	imul	ecx, 160				; 000000a0H
	lea	edx, DWORD PTR ?gCurRails@@3PAURailList@@A[eax+ecx]
	push	edx
	mov	eax, DWORD PTR ?HardPoints@@3JA		; HardPoints
	cdq
	sub	eax, edx
	sar	eax, 1
	push	eax
	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	call	?ClearHardPoint@@YAXJJJPAVRailInfo@@@Z	; ClearHardPoint
	add	esp, 16					; 00000010H
$LN1@ClearAllHa:

; 680  : 			}
; 681  : 		}

	jmp	SHORT $LN3@ClearAllHa
$LN2@ClearAllHa:

; 682  : 	}

	jmp	SHORT $LN6@ClearAllHa
$LN8@ClearAllHa:

; 683  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ClearAllHardPointBSPs@@YAXXZ ENDP			; ClearAllHardPointBSPs
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\munition.cpp
_TEXT	SEGMENT
_nextPtr$ = -20						; size = 4
_weapPtr$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_plane$ = 8						; size = 4
_hardpoint$ = 12					; size = 4
___formal$ = 16						; size = 4
_rail$ = 20						; size = 4
?ClearHardPoint@@YAXJJJPAVRailInfo@@@Z PROC		; ClearHardPoint

; 591  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ClearHardPoint@@YAXJJJPAVRailInfo@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 592  : 	rail->hardPoint.DeleteAllWeaponBSP();

	mov	eax, DWORD PTR _rail$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _rail$[ebp]
	mov	eax, DWORD PTR [edx+96]
	call	eax

; 593  : 
; 594  : 	VuBin<SimWeaponClass> weapPtr;

	push	0
	lea	ecx, DWORD PTR _weapPtr$[ebp]
	call	??0?$VuBin@VSimWeaponClass@@@@QAE@PAVSimWeaponClass@@@Z ; VuBin<SimWeaponClass>::VuBin<SimWeaponClass>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 595  : 	VuBin<SimWeaponClass> nextPtr;

	push	0
	lea	ecx, DWORD PTR _nextPtr$[ebp]
	call	??0?$VuBin@VSimWeaponClass@@@@QAE@PAVSimWeaponClass@@@Z ; VuBin<SimWeaponClass>::VuBin<SimWeaponClass>
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 596  : 
; 597  : 	weapPtr = rail->hardPoint.weaponPointer;

	mov	ecx, DWORD PTR _rail$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	lea	ecx, DWORD PTR _weapPtr$[ebp]
	call	??4?$VuBin@VSimWeaponClass@@@@QAEABV0@ABV0@@Z ; VuBin<SimWeaponClass>::operator=
$LN2@ClearHardP:

; 598  : 	while (weapPtr){

	lea	ecx, DWORD PTR _weapPtr$[ebp]
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@ClearHardP

; 599  : 		nextPtr.reset(weapPtr->GetNextOnRail());

	lea	ecx, DWORD PTR _weapPtr$[ebp]
	call	??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::operator->
	mov	ecx, eax
	call	?GetNextOnRail@SimWeaponClass@@QAEPAV1@XZ ; SimWeaponClass::GetNextOnRail
	push	eax
	lea	ecx, DWORD PTR _nextPtr$[ebp]
	call	?reset@?$VuBin@VSimWeaponClass@@@@QAEXPAVSimWeaponClass@@@Z ; VuBin<SimWeaponClass>::reset

; 600  : 		weapPtr.reset();

	push	0
	lea	ecx, DWORD PTR _weapPtr$[ebp]
	call	?reset@?$VuBin@VSimWeaponClass@@@@QAEXPAVSimWeaponClass@@@Z ; VuBin<SimWeaponClass>::reset

; 601  : 		weapPtr = nextPtr;

	lea	eax, DWORD PTR _nextPtr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _weapPtr$[ebp]
	call	??4?$VuBin@VSimWeaponClass@@@@QAEABV0@ABV0@@Z ; VuBin<SimWeaponClass>::operator=

; 602  : 	}

	jmp	SHORT $LN2@ClearHardP
$LN1@ClearHardP:

; 603  : 
; 604  : 	rail->hardPoint.weaponPointer.reset();

	push	0
	mov	ecx, DWORD PTR _rail$[ebp]
	add	ecx, 12					; 0000000cH
	call	?reset@?$VuBin@VSimWeaponClass@@@@QAEXPAVSimWeaponClass@@@Z ; VuBin<SimWeaponClass>::reset

; 605  : 	rail->hardPoint.DeleteRackBSP();

	mov	ecx, DWORD PTR _rail$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _rail$[ebp]
	mov	eax, DWORD PTR [edx+72]
	call	eax

; 606  : 	rail->hardPoint.DeletePylonBSP();

	mov	ecx, DWORD PTR _rail$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _rail$[ebp]
	mov	eax, DWORD PTR [edx+60]
	call	eax

; 607  : 	rail->hardPoint.SetParentDrawPtr(NULL);

	push	0
	mov	ecx, DWORD PTR _rail$[ebp]
	call	?SetParentDrawPtr@AdvancedWeaponStation@@QAEXPAVDrawableBSP@@@Z ; AdvancedWeaponStation::SetParentDrawPtr

; 608  : 	rail->hardPoint.SetRackId(0);

	push	0
	mov	ecx, DWORD PTR _rail$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _rail$[ebp]
	mov	eax, DWORD PTR [edx+136]
	call	eax

; 609  : 	rail->hardPoint.SetPylonId(0);

	push	0
	mov	ecx, DWORD PTR _rail$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _rail$[ebp]
	mov	eax, DWORD PTR [edx+144]
	call	eax

; 610  : 	rail->weaponCount=0;

	xor	ecx, ecx
	mov	edx, DWORD PTR _rail$[ebp]
	mov	WORD PTR [edx+156], cx

; 611  : 
; 612  : 	/*
; 613  : 	BSPLIST *Plane;
; 614  : 	BSPLIST *Rack;
; 615  : 	BSPLIST *Weapon;
; 616  : 	short bits,i;
; 617  : 
; 618  : 	Plane=gUIViewer->Find((plane << 24));
; 619  : 	if(Plane == NULL) return;
; 620  : 
; 621  : 	if(rail->rackID)
; 622  : 	{
; 623  : 		Rack=gUIViewer->Find((plane << 24) + (hardpoint << 16));
; 624  : 		if(Rack)
; 625  : 		{
; 626  : 			if(rail->weaponID && rail->startBits)
; 627  : 			{
; 628  : 				bits=rail->startBits;
; 629  : 				i=0;
; 630  : 				while(bits)
; 631  : 				{
; 632  : 					if(bits & 1)
; 633  : 					{
; 634  : 						Weapon=gUIViewer->Find((plane << 24) + (hardpoint << 16) + (i+1));
; 635  : 						if(Weapon)
; 636  : 						{
; 637  : 							// JB 020314 work from the back to the font (like the 3d code)
; 638  : 							((DrawableBSP*)Rack->object)->DetachChild(((DrawableBSP*)Weapon->object),
; 639  : 								((DrawableBSP*)Rack->object)->instance.ParentObject->nSlots - i - 1);
; 640  : 							gUIViewer->Remove((plane << 24) + (hardpoint << 16) + (i+1));
; 641  : 						}
; 642  : 					}
; 643  : 					bits >>= 1;
; 644  : 					i++;
; 645  : 				}
; 646  : 			}
; 647  : 			((DrawableBSP*)Plane->object)->DetachChild(((DrawableBSP*)Rack->object),hardpoint-1);
; 648  : 			gUIViewer->Remove((plane << 24) + (hardpoint << 16));
; 649  : 			Rack=NULL;
; 650  : 		}
; 651  : 	}
; 652  : 	else if(rail->weaponID)
; 653  : 	{
; 654  : 		if(rail->startBits)
; 655  : 		{
; 656  : 			Weapon=gUIViewer->Find((plane << 24) + (hardpoint << 16) + 1);
; 657  : 			if(Weapon)
; 658  : 			{
; 659  : 				((DrawableBSP*)Plane->object)->DetachChild(((DrawableBSP*)Weapon->object),hardpoint-1);
; 660  : 				gUIViewer->Remove((plane << 24) + (hardpoint << 16) + 1);
; 661  : 			}
; 662  : 		}
; 663  : 	}*/
; 664  : 	//rail->rackID=0; // MLR 2/25/2004 - 
; 665  : 	//rail->weaponID=0;
; 666  : 	rail->startBits=0;

	xor	eax, eax
	mov	ecx, DWORD PTR _rail$[ebp]
	mov	WORD PTR [ecx+152], ax

; 667  : }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _nextPtr$[ebp]
	call	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ	; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _weapPtr$[ebp]
	call	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ	; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?ClearHardPoint@@YAXJJJPAVRailInfo@@@Z$0:
	lea	ecx, DWORD PTR _weapPtr$[ebp]
	jmp	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ	; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>
__unwindfunclet$?ClearHardPoint@@YAXJJJPAVRailInfo@@@Z$1:
	lea	ecx, DWORD PTR _nextPtr$[ebp]
	jmp	??1?$VuBin@VSimWeaponClass@@@@QAE@XZ	; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>
__ehhandler$?ClearHardPoint@@YAXJJJPAVRailInfo@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ClearHardPoint@@YAXJJJPAVRailInfo@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ClearHardPoint@@YAXJJJPAVRailInfo@@@Z ENDP		; ClearHardPoint
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\munition.cpp
_TEXT	SEGMENT
?ValidateRackData@@YAXXZ PROC				; ValidateRackData

; 496  : {

	push	ebp
	mov	ebp, esp

; 497  : 	if(Validated)

	movsx	eax, WORD PTR _Validated
	test	eax, eax
	je	SHORT $LN1@ValidateRa

; 498  : 		return;

	jmp	SHORT $LN2@ValidateRa
$LN1@ValidateRa:

; 499  : 
; 500  : 	ConvertToIndex(HeliRacks);

	push	OFFSET ?HeliRacks@@3PAURackData@@A	; HeliRacks
	call	?ConvertToIndex@@YAXQAURackData@@@Z	; ConvertToIndex
	add	esp, 4

; 501  : 	ConvertToIndex(ACRacks);

	push	OFFSET ?ACRacks@@3PAURackData@@A	; ACRacks
	call	?ConvertToIndex@@YAXQAURackData@@@Z	; ConvertToIndex
	add	esp, 4

; 502  : 	ConvertToIndex(RocketRack);

	push	OFFSET ?RocketRack@@3PAURackData@@A	; RocketRack
	call	?ConvertToIndex@@YAXQAURackData@@@Z	; ConvertToIndex
	add	esp, 4

; 503  : 	ConvertToIndex(Hellfires);

	push	OFFSET ?Hellfires@@3PAURackData@@A	; Hellfires
	call	?ConvertToIndex@@YAXQAURackData@@@Z	; ConvertToIndex
	add	esp, 4

; 504  : 	ConvertToIndex(Maverick);

	push	OFFSET ?Maverick@@3PAURackData@@A	; Maverick
	call	?ConvertToIndex@@YAXQAURackData@@@Z	; ConvertToIndex
	add	esp, 4

; 505  : 
; 506  : 	Validated=1;

	mov	ecx, 1
	mov	WORD PTR _Validated, cx
$LN2@ValidateRa:

; 507  : }

	pop	ebp
	ret	0
?ValidateRackData@@YAXXZ ENDP				; ValidateRackData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\munition.cpp
_TEXT	SEGMENT
_j$ = -8						; size = 2
_i$ = -4						; size = 2
_Rack$ = 8						; size = 4
?ConvertToIndex@@YAXQAURackData@@@Z PROC		; ConvertToIndex

; 482  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 483  : 	short i,j;
; 484  : 
; 485  : 	for(i=0;i<7;i++)

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax
	jmp	SHORT $LN6@ConvertToI
$LN5@ConvertToI:
	mov	cx, WORD PTR _i$[ebp]
	add	cx, 1
	mov	WORD PTR _i$[ebp], cx
$LN6@ConvertToI:
	movsx	edx, WORD PTR _i$[ebp]
	cmp	edx, 7
	jge	SHORT $LN7@ConvertToI

; 486  : 	{
; 487  : 		for(j=0;j<3;j++)

	xor	eax, eax
	mov	WORD PTR _j$[ebp], ax
	jmp	SHORT $LN3@ConvertToI
$LN2@ConvertToI:
	mov	cx, WORD PTR _j$[ebp]
	add	cx, 1
	mov	WORD PTR _j$[ebp], cx
$LN3@ConvertToI:
	movsx	edx, WORD PTR _j$[ebp]
	cmp	edx, 3
	jge	SHORT $LN1@ConvertToI

; 488  : 		{
; 489  : 			Rack[i].RackID[j]=FindRackIndex(MapVisId(Rack[i].RackID[j]));

	movsx	eax, WORD PTR _i$[ebp]
	imul	eax, 6
	add	eax, DWORD PTR _Rack$[ebp]
	movsx	ecx, WORD PTR _j$[ebp]
	movsx	edx, WORD PTR [eax+ecx*2]
	push	edx
	call	?MapVisId@@YAKK@Z			; MapVisId
	add	esp, 4
	push	eax
	call	?FindRackIndex@@YAFF@Z			; FindRackIndex
	add	esp, 4
	movsx	ecx, WORD PTR _i$[ebp]
	imul	ecx, 6
	add	ecx, DWORD PTR _Rack$[ebp]
	movsx	edx, WORD PTR _j$[ebp]
	mov	WORD PTR [ecx+edx*2], ax

; 490  : 		}

	jmp	SHORT $LN2@ConvertToI
$LN1@ConvertToI:

; 491  : 	}

	jmp	SHORT $LN5@ConvertToI
$LN7@ConvertToI:

; 492  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ConvertToIndex@@YAXQAURackData@@@Z ENDP		; ConvertToIndex
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\munition.cpp
_TEXT	SEGMENT
_classPtr$ = -8						; size = 4
_index$ = -4						; size = 4
_visID$ = 8						; size = 2
?FindRackIndex@@YAFF@Z PROC				; FindRackIndex

; 466  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 467  : 	Falcon4EntityClassType* classPtr;
; 468  : 	int index;
; 469  : 
; 470  : 	if(!visID)

	movsx	eax, WORD PTR _visID$[ebp]
	test	eax, eax
	jne	SHORT $LN5@FindRackIn

; 471  : 		return(0);

	xor	eax, eax
	jmp	SHORT $LN6@FindRackIn
$LN5@FindRackIn:

; 472  : 
; 473  : 	for(index=0;index < NumEntities;index++)

	mov	DWORD PTR _index$[ebp], 0
	jmp	SHORT $LN4@FindRackIn
$LN3@FindRackIn:
	mov	ecx, DWORD PTR _index$[ebp]
	add	ecx, 1
	mov	DWORD PTR _index$[ebp], ecx
$LN4@FindRackIn:
	mov	edx, DWORD PTR _index$[ebp]
	cmp	edx, DWORD PTR ?NumEntities@@3HA	; NumEntities
	jge	SHORT $LN2@FindRackIn

; 474  : 	{
; 475  : 		classPtr = &Falcon4ClassTable[index];

	mov	eax, DWORD PTR _index$[ebp]
	imul	eax, 81					; 00000051H
	add	eax, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	DWORD PTR _classPtr$[ebp], eax

; 476  : 		if(classPtr->visType[0] == visID)

	mov	ecx, 2
	imul	ecx, 0
	mov	edx, DWORD PTR _classPtr$[ebp]
	movsx	eax, WORD PTR [edx+ecx+60]
	movsx	ecx, WORD PTR _visID$[ebp]
	cmp	eax, ecx
	jne	SHORT $LN1@FindRackIn

; 477  : 			return(index);

	mov	ax, WORD PTR _index$[ebp]
	jmp	SHORT $LN6@FindRackIn
$LN1@FindRackIn:

; 478  : 	}

	jmp	SHORT $LN3@FindRackIn
$LN2@FindRackIn:

; 479  : 	return(0);

	xor	eax, eax
$LN6@FindRackIn:

; 480  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FindRackIndex@@YAFF@Z ENDP				; FindRackIndex
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\munition.cpp
_TEXT	SEGMENT
_weaponrg$ = -24					; size = 4
_planerg$ = -20						; size = 4
_bitflag$ = -16						; size = 4
_weapClassPtr$ = -12					; size = 4
_aux$ = -8						; size = 4
_idx$ = -4						; size = 4
_vc$ = 8						; size = 4
_classPtr$ = 12						; size = 4
_WeaponIndex$ = 16					; size = 2
_count$ = 20						; size = 2
_hardpoint$ = 24					; size = 2
_rail$ = 28						; size = 4
?GetJRackAndWeapon@@YAHPAUVehicleClassDataType@@PAUFalcon4EntityClassType@@FFFPAVRailInfo@@@Z PROC ; GetJRackAndWeapon

; 341  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 342  : 	Falcon4EntityClassType *weapClassPtr;
; 343  : 	long bitflag;
; 344  : 	//Falcon4EntityClassType* rackClassPtr;
; 345  : 
; 346  : 	//memset(rail,0,sizeof(RailInfo)); // kills the hardpoint object
; 347  : 	if(!count)

	movsx	eax, WORD PTR _count$[ebp]
	test	eax, eax
	jne	SHORT $LN4@GetJRackAn

; 348  : 		return(FALSE);

	xor	eax, eax
	jmp	$LN5@GetJRackAn
$LN4@GetJRackAn:

; 349  : 
; 350  : 	weapClassPtr = &Falcon4ClassTable[WeaponDataTable[WeaponIndex].Index];

	movsx	ecx, WORD PTR _WeaponIndex$[ebp]
	imul	ecx, 60					; 0000003cH
	mov	edx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movsx	eax, WORD PTR [edx+ecx]
	imul	eax, 81					; 00000051H
	add	eax, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	DWORD PTR _weapClassPtr$[ebp], eax

; 351  : 	int weaponrg = WeaponDataTable[WeaponIndex].SimweapIndex;

	movsx	ecx, WORD PTR _WeaponIndex$[ebp]
	imul	ecx, 60					; 0000003cH
	mov	edx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movsx	eax, WORD PTR [edx+ecx+46]
	mov	DWORD PTR _weaponrg$[ebp], eax

; 352  : 	int idx = SimACDefTable[classPtr->vehicleDataIndex].airframeIdx;

	mov	ecx, DWORD PTR _classPtr$[ebp]
	movsx	edx, WORD PTR [ecx+74]
	imul	edx, 52					; 00000034H
	mov	eax, DWORD PTR ?SimACDefTable@@3PAUSimACDefType@@A ; SimACDefTable
	mov	ecx, DWORD PTR [eax+edx+4]
	mov	DWORD PTR _idx$[ebp], ecx

; 353  : 	AuxAeroData *aux = aeroDataset[idx].auxaeroData;

	mov	edx, DWORD PTR _idx$[ebp]
	imul	edx, 220				; 000000dcH
	mov	eax, DWORD PTR ?aeroDataset@@3PAVAeroDataSet@@A ; aeroDataset
	mov	ecx, DWORD PTR [eax+edx+8]
	mov	DWORD PTR _aux$[ebp], ecx

; 354  : 	int planerg = aux->hardpointrg[hardpoint];

	movsx	edx, WORD PTR _hardpoint$[ebp]
	mov	eax, DWORD PTR _aux$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+476]
	mov	DWORD PTR _planerg$[ebp], ecx

; 355  : 
; 356  : 
; 357  : 	bitflag=1 << hardpoint;

	movsx	ecx, WORD PTR _hardpoint$[ebp]
	mov	edx, 1
	shl	edx, cl
	mov	DWORD PTR _bitflag$[ebp], edx

; 358  : 
; 359  : 	if(!vc || !classPtr || !weapClassPtr)

	cmp	DWORD PTR _vc$[ebp], 0
	je	SHORT $LN2@GetJRackAn
	cmp	DWORD PTR _classPtr$[ebp], 0
	je	SHORT $LN2@GetJRackAn
	cmp	DWORD PTR _weapClassPtr$[ebp], 0
	jne	SHORT $LN3@GetJRackAn
$LN2@GetJRackAn:

; 360  : 		return(FALSE);

	xor	eax, eax
	jmp	SHORT $LN5@GetJRackAn
$LN3@GetJRackAn:

; 361  : 
; 362  : 	if(!(vc->VisibleFlags & bitflag))

	mov	eax, DWORD PTR _vc$[ebp]
	movzx	ecx, WORD PTR [eax+62]
	and	ecx, DWORD PTR _bitflag$[ebp]
	jne	SHORT $LN1@GetJRackAn

; 363  : 		return(FALSE);

	xor	eax, eax
	jmp	SHORT $LN5@GetJRackAn
$LN1@GetJRackAn:

; 364  : 
; 365  : 	/*
; 366  : 	int rackno = FindBestRackIDByPlaneAndWeapon(planerg, weaponrg, count);
; 367  : 	if (rackno == -1) return FALSE;
; 368  : 	RackObject *rackptr = &RackObjectTable[rackno];
; 369  : 	ShiAssert(rackptr->ctind > 0 && rackptr->ctind < NumEntities);
; 370  : 	rackClassPtr = &Falcon4ClassTable[rackptr->ctind];
; 371  : 	*/
; 372  : 
; 373  : 	rail->weaponCount = count;

	mov	edx, DWORD PTR _rail$[ebp]
	mov	ax, WORD PTR _count$[ebp]
	mov	WORD PTR [edx+156], ax

; 374  : 	rail->hardPoint.DetermineRackData(planerg, WeaponIndex, count);

	movsx	ecx, WORD PTR _count$[ebp]
	push	ecx
	movsx	edx, WORD PTR _WeaponIndex$[ebp]
	push	edx
	mov	eax, DWORD PTR _planerg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rail$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _rail$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax

; 375  : 	rail->hardPoint.weaponId=WeaponIndex;

	mov	ecx, DWORD PTR _rail$[ebp]
	mov	dx, WORD PTR _WeaponIndex$[ebp]
	mov	WORD PTR [ecx+8], dx

; 376  : 
; 377  : 	// Use a rack
; 378  : 	/*
; 379  : 	if((vc->RackFlags & bitflag) || (WeaponDataTable[WeaponIndex].Flags & WEAP_ALWAYSRACK)) 
; 380  : 	{
; 381  : 	    if(rackClassPtr->visType[0])
; 382  : 	    {
; 383  : 		rail->rackID=rackptr->ctind;
; 384  : 		rail->weaponID=WeaponDataTable[WeaponIndex].Index;
; 385  : 		rail->startBits=AttachBits[count];
; 386  : 		rail->currentBits=AttachBits[count];
; 387  : 	    }
; 388  : 	}
; 389  : 	else
; 390  : 	{
; 391  : 	    if(weapClassPtr->visType[0])
; 392  : 	    {
; 393  : 		rail->weaponID=WeaponDataTable[WeaponIndex].Index;
; 394  : 		rail->startBits=AttachBits[1];
; 395  : 		rail->currentBits=AttachBits[1];
; 396  : 	    }
; 397  : 	}
; 398  : 	*/
; 399  : 	return TRUE;

	mov	eax, 1
$LN5@GetJRackAn:

; 400  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetJRackAndWeapon@@YAHPAUVehicleClassDataType@@PAUFalcon4EntityClassType@@FFFPAVRailInfo@@@Z ENDP ; GetJRackAndWeapon
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\munition.cpp
_TEXT	SEGMENT
_cur$ = -16						; size = 4
_count$ = -12						; size = 4
_i$ = -8						; size = 4
_j$ = -4						; size = 4
_loadout$ = 8						; size = 4
?PlaceLoadedWeapons@@YAXPAULoadoutStruct@@@Z PROC	; PlaceLoadedWeapons

; 271  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi

; 272  : 	STORESLIST *cur;
; 273  : 	long i,j,count;
; 274  : 
; 275  : 	for(i=0;i<4;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN15@PlaceLoade
$LN14@PlaceLoade:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN15@PlaceLoade:
	cmp	DWORD PTR _i$[ebp], 4
	jge	SHORT $LN13@PlaceLoade

; 276  : 		if(PlaneEditList[i])

	mov	ecx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR ?PlaneEditList@@3PAJA[ecx*4], 0
	je	SHORT $LN12@PlaceLoade

; 277  : 			memset(&gCurStores[i],0,sizeof(LoadoutStruct));

	push	48					; 00000030H
	push	0
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 48					; 00000030H
	add	edx, OFFSET ?gCurStores@@3PAULoadoutStruct@@A ; gCurStores
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH
$LN12@PlaceLoade:

; 278  : 
; 279  : 	TallyStores();

	jmp	SHORT $LN14@PlaceLoade
$LN13@PlaceLoade:
	call	?TallyStores@@YAXXZ			; TallyStores

; 280  : 
; 281  : 	for(i=0;i<4;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN11@PlaceLoade
$LN10@PlaceLoade:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN11@PlaceLoade:
	cmp	DWORD PTR _i$[ebp], 4
	jge	$LN9@PlaceLoade

; 282  : 		if(PlaneEditList[i])

	mov	ecx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR ?PlaneEditList@@3PAJA[ecx*4], 0
	je	$LN8@PlaceLoade

; 283  : 		{
; 284  : 			for(j=1;j<HardPoints;j++)

	mov	DWORD PTR _j$[ebp], 1
	jmp	SHORT $LN7@PlaceLoade
$LN6@PlaceLoade:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$LN7@PlaceLoade:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR ?HardPoints@@3JA		; HardPoints
	jge	$LN8@PlaceLoade

; 285  : 			{
; 286  : 				cur=NULL;

	mov	DWORD PTR _cur$[ebp], 0

; 287  : 				ShiAssert(gStores);
; 288  : 				if (gStores)

	cmp	DWORD PTR ?gStores@@3PAVStoresList@@A, 0 ; gStores
	je	SHORT $LN4@PlaceLoade

; 289  : 					cur = gStores->Find(loadout->WeaponID[j]);

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _loadout$[ebp]
	movsx	eax, WORD PTR [edx+ecx*2]
	push	eax
	mov	ecx, DWORD PTR ?gStores@@3PAVStoresList@@A ; gStores
	call	?Find@StoresList@@QAEPAUStoresStr@@J@Z	; StoresList::Find
	mov	DWORD PTR _cur$[ebp], eax
$LN4@PlaceLoade:

; 290  : 
; 291  : 				if(cur && loadout->WeaponCount[j])

	cmp	DWORD PTR _cur$[ebp], 0
	je	$LN3@PlaceLoade
	mov	ecx, DWORD PTR _loadout$[ebp]
	add	ecx, DWORD PTR _j$[ebp]
	movzx	edx, BYTE PTR [ecx+32]
	test	edx, edx
	je	$LN3@PlaceLoade

; 292  : 				{
; 293  : 					count=loadout->WeaponCount[j];

	mov	eax, DWORD PTR _loadout$[ebp]
	add	eax, DWORD PTR _j$[ebp]
	movzx	ecx, BYTE PTR [eax+32]
	mov	DWORD PTR _count$[ebp], ecx

; 294  : 
; 295  : 					if(count > cur->HardPoint[j])

	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, WORD PTR [eax+edx*2+44]
	cmp	DWORD PTR _count$[ebp], ecx
	jle	SHORT $LN2@PlaceLoade

; 296  : 						count=cur->HardPoint[j];

	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, WORD PTR [eax+edx*2+44]
	mov	DWORD PTR _count$[ebp], ecx
$LN2@PlaceLoade:

; 297  : 
; 298  : 					if(count > TotalAvailable(loadout->WeaponID[j]))

	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _loadout$[ebp]
	movzx	ecx, WORD PTR [eax+edx*2]
	push	ecx
	call	?TotalAvailable@@YAFF@Z			; TotalAvailable
	add	esp, 4
	movsx	edx, ax
	cmp	DWORD PTR _count$[ebp], edx
	jle	SHORT $LN1@PlaceLoade

; 299  : 						count=TotalAvailable(loadout->WeaponID[j]);

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _loadout$[ebp]
	movzx	edx, WORD PTR [ecx+eax*2]
	push	edx
	call	?TotalAvailable@@YAFF@Z			; TotalAvailable
	add	esp, 4
	cwde
	mov	DWORD PTR _count$[ebp], eax
$LN1@PlaceLoade:

; 300  : 
; 301  : 					gCurStores[i].WeaponID[j]=(loadout->WeaponID[j]);

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _loadout$[ebp]
	mov	ax, WORD PTR [esi+eax*2]
	mov	WORD PTR ?gCurStores@@3PAULoadoutStruct@@A[ecx+edx*2], ax

; 302  : 					gCurStores[i].WeaponCount[j]=static_cast<uchar>(count);

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _j$[ebp]
	mov	al, BYTE PTR _count$[ebp]
	mov	BYTE PTR ?gCurStores@@3PAULoadoutStruct@@A[ecx+edx+32], al
$LN3@PlaceLoade:

; 303  : 				}
; 304  : 			}

	jmp	$LN6@PlaceLoade
$LN8@PlaceLoade:
	jmp	$LN10@PlaceLoade
$LN9@PlaceLoade:

; 305  : 		}
; 306  : 	TallyStores();

	call	?TallyStores@@YAXXZ			; TallyStores

; 307  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?PlaceLoadedWeapons@@YAXPAULoadoutStruct@@@Z ENDP	; PlaceLoadedWeapons
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\munition.cpp
_TEXT	SEGMENT
tv139 = -24						; size = 4
_store$ = -20						; size = 4
_avail$ = -16						; size = 2
_onboard$ = -12						; size = 2
_j$ = -8						; size = 2
_i$ = -4						; size = 2
_weaponID$ = 8						; size = 2
?TotalAvailable@@YAFF@Z PROC				; TotalAvailable

; 244  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 245  : 	STORESLIST *store;
; 246  : 	short avail,onboard;
; 247  : 	short i,j;
; 248  : 
; 249  : 	store=NULL;

	mov	DWORD PTR _store$[ebp], 0

; 250  : 	ShiAssert(gStores);
; 251  : 	if (gStores)

	cmp	DWORD PTR ?gStores@@3PAVStoresList@@A, 0 ; gStores
	je	SHORT $LN9@TotalAvail

; 252  : 		store = gStores->Find(weaponID);

	movsx	eax, WORD PTR _weaponID$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?gStores@@3PAVStoresList@@A ; gStores
	call	?Find@StoresList@@QAEPAUStoresStr@@J@Z	; StoresList::Find
	mov	DWORD PTR _store$[ebp], eax
$LN9@TotalAvail:

; 253  : 
; 254  : 	if(store)

	cmp	DWORD PTR _store$[ebp], 0
	je	$LN8@TotalAvail

; 255  : 	{
; 256  : 		avail=store->Stock;

	mov	ecx, DWORD PTR _store$[ebp]
	mov	dx, WORD PTR [ecx+36]
	mov	WORD PTR _avail$[ebp], dx

; 257  : 		onboard=0;

	xor	eax, eax
	mov	WORD PTR _onboard$[ebp], ax

; 258  : 		// JB 020219 Limit munition planecount to less than five otherwise we overwrite memory.
; 259  : 		for(i=0;i<PlaneCount && i < 4;i++)

	xor	ecx, ecx
	mov	WORD PTR _i$[ebp], cx
	jmp	SHORT $LN7@TotalAvail
$LN6@TotalAvail:
	mov	dx, WORD PTR _i$[ebp]
	add	dx, 1
	mov	WORD PTR _i$[ebp], dx
$LN7@TotalAvail:
	movsx	eax, WORD PTR _i$[ebp]
	cmp	eax, DWORD PTR ?PlaneCount@@3JA		; PlaneCount
	jge	SHORT $LN5@TotalAvail
	movsx	ecx, WORD PTR _i$[ebp]
	cmp	ecx, 4
	jge	SHORT $LN5@TotalAvail

; 260  : 			for(j=0;j<HARDPOINT_MAX;j++)

	xor	edx, edx
	mov	WORD PTR _j$[ebp], dx
	jmp	SHORT $LN4@TotalAvail
$LN3@TotalAvail:
	mov	ax, WORD PTR _j$[ebp]
	add	ax, 1
	mov	WORD PTR _j$[ebp], ax
$LN4@TotalAvail:
	movsx	ecx, WORD PTR _j$[ebp]
	cmp	ecx, 16					; 00000010H
	jge	SHORT $LN2@TotalAvail

; 261  : 			{
; 262  : 				if(Quantity[i][0][j] == weaponID)

	movsx	edx, WORD PTR _i$[ebp]
	shl	edx, 7
	mov	eax, 64					; 00000040H
	imul	eax, 0
	lea	ecx, DWORD PTR _Quantity[edx+eax]
	movsx	edx, WORD PTR _j$[ebp]
	movsx	eax, WORD PTR _weaponID$[ebp]
	cmp	DWORD PTR [ecx+edx*4], eax
	jne	SHORT $LN1@TotalAvail

; 263  : 					onboard+=Quantity[i][1][j];

	movsx	ecx, WORD PTR _i$[ebp]
	shl	ecx, 7
	mov	edx, 64					; 00000040H
	shl	edx, 0
	lea	eax, DWORD PTR _Quantity[ecx+edx]
	movsx	ecx, WORD PTR _j$[ebp]
	movsx	edx, WORD PTR _onboard$[ebp]
	add	edx, DWORD PTR [eax+ecx*4]
	mov	WORD PTR _onboard$[ebp], dx
$LN1@TotalAvail:

; 264  : 			}

	jmp	SHORT $LN3@TotalAvail
$LN2@TotalAvail:
	jmp	$LN6@TotalAvail
$LN5@TotalAvail:

; 265  : 		return(static_cast<short>(max(avail - onboard,0)));

	movsx	eax, WORD PTR _avail$[ebp]
	movsx	ecx, WORD PTR _onboard$[ebp]
	sub	eax, ecx
	test	eax, eax
	jle	SHORT $LN12@TotalAvail
	movsx	edx, WORD PTR _avail$[ebp]
	movsx	eax, WORD PTR _onboard$[ebp]
	sub	edx, eax
	mov	DWORD PTR tv139[ebp], edx
	jmp	SHORT $LN13@TotalAvail
$LN12@TotalAvail:
	mov	DWORD PTR tv139[ebp], 0
$LN13@TotalAvail:
	mov	ax, WORD PTR tv139[ebp]
	jmp	SHORT $LN10@TotalAvail
$LN8@TotalAvail:

; 266  : 	}
; 267  : 	return(0);

	xor	eax, eax
$LN10@TotalAvail:

; 268  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?TotalAvailable@@YAFF@Z ENDP				; TotalAvailable
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\munition.cpp
_TEXT	SEGMENT
_store$ = -12						; size = 4
_j$ = -8						; size = 2
_i$ = -4						; size = 2
?UpdateInventoryCount@@YAXXZ PROC			; UpdateInventoryCount

; 222  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 223  : 	STORESLIST *store;
; 224  : 	short i,j;
; 225  : 
; 226  : 	// JB 020219 Limit munition planecount to less than five otherwise we overwrite memory.
; 227  : 	for(i=0;i<PlaneCount && i < 4;i++)

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax
	jmp	SHORT $LN9@UpdateInve
$LN8@UpdateInve:
	mov	cx, WORD PTR _i$[ebp]
	add	cx, 1
	mov	WORD PTR _i$[ebp], cx
$LN9@UpdateInve:
	movsx	edx, WORD PTR _i$[ebp]
	cmp	edx, DWORD PTR ?PlaneCount@@3JA		; PlaneCount
	jge	$LN10@UpdateInve
	movsx	eax, WORD PTR _i$[ebp]
	cmp	eax, 4
	jge	$LN10@UpdateInve

; 228  : 		for(j=0;j<HARDPOINT_MAX;j++)

	xor	ecx, ecx
	mov	WORD PTR _j$[ebp], cx
	jmp	SHORT $LN6@UpdateInve
$LN5@UpdateInve:
	mov	dx, WORD PTR _j$[ebp]
	add	dx, 1
	mov	WORD PTR _j$[ebp], dx
$LN6@UpdateInve:
	movsx	eax, WORD PTR _j$[ebp]
	cmp	eax, 16					; 00000010H
	jge	$LN4@UpdateInve

; 229  : 		{
; 230  : 			if(Quantity[i][1][j] > 0)

	movsx	ecx, WORD PTR _i$[ebp]
	shl	ecx, 7
	mov	edx, 64					; 00000040H
	shl	edx, 0
	lea	eax, DWORD PTR _Quantity[ecx+edx]
	movsx	ecx, WORD PTR _j$[ebp]
	cmp	DWORD PTR [eax+ecx*4], 0
	jle	SHORT $LN3@UpdateInve

; 231  : 			{
; 232  : 				store=NULL;

	mov	DWORD PTR _store$[ebp], 0

; 233  : 				ShiAssert(gStores);
; 234  : 				if (gStores)

	cmp	DWORD PTR ?gStores@@3PAVStoresList@@A, 0 ; gStores
	je	SHORT $LN2@UpdateInve

; 235  : 					store = gStores->Find(Quantity[i][0][j]);

	movsx	edx, WORD PTR _i$[ebp]
	shl	edx, 7
	mov	eax, 64					; 00000040H
	imul	eax, 0
	lea	ecx, DWORD PTR _Quantity[edx+eax]
	movsx	edx, WORD PTR _j$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	mov	ecx, DWORD PTR ?gStores@@3PAVStoresList@@A ; gStores
	call	?Find@StoresList@@QAEPAUStoresStr@@J@Z	; StoresList::Find
	mov	DWORD PTR _store$[ebp], eax
$LN2@UpdateInve:

; 236  : 
; 237  : 				if(store)

	cmp	DWORD PTR _store$[ebp], 0
	je	SHORT $LN3@UpdateInve

; 238  : 					store->Stock+=Quantity[i][1][j];

	movsx	ecx, WORD PTR _i$[ebp]
	shl	ecx, 7
	mov	edx, 64					; 00000040H
	shl	edx, 0
	lea	eax, DWORD PTR _Quantity[ecx+edx]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR _store$[ebp]
	movsx	edx, WORD PTR [edx+36]
	add	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _store$[ebp]
	mov	WORD PTR [eax+36], dx
$LN3@UpdateInve:

; 239  : 			}
; 240  : 		}

	jmp	$LN5@UpdateInve
$LN4@UpdateInve:
	jmp	$LN8@UpdateInve
$LN10@UpdateInve:

; 241  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateInventoryCount@@YAXXZ ENDP			; UpdateInventoryCount
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\munition.cpp
_TEXT	SEGMENT
_k$ = -16						; size = 4
_wid$ = -12						; size = 4
_j$ = -8						; size = 4
_i$ = -4						; size = 4
?TallyStores@@YAXXZ PROC				; TallyStores

; 186  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 187  : 	int i,j,k,wid;
; 188  : 
; 189  : 	// JB 020219 Limit munition planecount to less than five otherwise we overwrite memory.
; 190  : 	for(i=0;i<PlaneCount && i < 4;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN14@TallyStore
$LN13@TallyStore:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN14@TallyStore:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR ?PlaneCount@@3JA		; PlaneCount
	jge	$LN15@TallyStore
	cmp	DWORD PTR _i$[ebp], 4
	jge	$LN15@TallyStore

; 191  : 	{
; 192  : 		// Zero out all stores totals
; 193  : 		for(j=0;j<HARDPOINT_MAX;j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN11@TallyStore
$LN10@TallyStore:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$LN11@TallyStore:
	cmp	DWORD PTR _j$[ebp], 16			; 00000010H
	jge	SHORT $LN9@TallyStore

; 194  : 		{
; 195  : 			Quantity[i][0][j]=0;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 7
	mov	ecx, 64					; 00000040H
	imul	ecx, 0
	lea	edx, DWORD PTR _Quantity[eax+ecx]
	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR [edx+eax*4], 0

; 196  : 			Quantity[i][1][j]=0;

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 7
	mov	edx, 64					; 00000040H
	shl	edx, 0
	lea	eax, DWORD PTR _Quantity[ecx+edx]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [eax+ecx*4], 0

; 197  : 		}

	jmp	SHORT $LN10@TallyStore
$LN9@TallyStore:

; 198  : 		QuantityCount[i]=0;

	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _QuantityCount[edx*4], 0

; 199  : 		for(j=1;j<HardPoints;j++)

	mov	DWORD PTR _j$[ebp], 1
	jmp	SHORT $LN8@TallyStore
$LN7@TallyStore:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN8@TallyStore:
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR ?HardPoints@@3JA		; HardPoints
	jge	$LN6@TallyStore

; 200  : 		{
; 201  : 			// Tally stores Types
; 202  : 			wid=-1;

	mov	DWORD PTR _wid$[ebp], -1

; 203  : 			for(k=0;k<QuantityCount[i];k++)

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN5@TallyStore
$LN4@TallyStore:
	mov	edx, DWORD PTR _k$[ebp]
	add	edx, 1
	mov	DWORD PTR _k$[ebp], edx
$LN5@TallyStore:
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	cmp	ecx, DWORD PTR _QuantityCount[eax*4]
	jge	SHORT $LN3@TallyStore

; 204  : 				if(Quantity[i][0][k] == gCurStores[i].WeaponID[j])

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 7
	mov	eax, 64					; 00000040H
	imul	eax, 0
	lea	ecx, DWORD PTR _Quantity[edx+eax]
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 48					; 00000030H
	mov	eax, DWORD PTR _j$[ebp]
	movsx	edx, WORD PTR ?gCurStores@@3PAULoadoutStruct@@A[edx+eax*2]
	mov	eax, DWORD PTR _k$[ebp]
	cmp	DWORD PTR [ecx+eax*4], edx
	jne	SHORT $LN2@TallyStore

; 205  : 				{
; 206  : 					wid=k;

	mov	ecx, DWORD PTR _k$[ebp]
	mov	DWORD PTR _wid$[ebp], ecx

; 207  : 					break;

	jmp	SHORT $LN3@TallyStore
$LN2@TallyStore:

; 208  : 				}

	jmp	SHORT $LN4@TallyStore
$LN3@TallyStore:

; 209  : 			if(wid == -1)

	cmp	DWORD PTR _wid$[ebp], -1
	jne	SHORT $LN1@TallyStore

; 210  : 			{
; 211  : 				wid=QuantityCount[i]++;

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _QuantityCount[edx*4]
	mov	DWORD PTR _wid$[ebp], eax
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _QuantityCount[ecx*4]
	add	edx, 1
	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _QuantityCount[eax*4], edx

; 212  : 				Quantity[i][0][wid]=gCurStores[i].WeaponID[j];

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _j$[ebp]
	movsx	eax, WORD PTR ?gCurStores@@3PAULoadoutStruct@@A[ecx+edx*2]
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 7
	mov	edx, 64					; 00000040H
	imul	edx, 0
	lea	ecx, DWORD PTR _Quantity[ecx+edx]
	mov	edx, DWORD PTR _wid$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax
$LN1@TallyStore:

; 213  : 			}
; 214  : 
; 215  : 			Quantity[i][1][wid]+=gCurStores[i].WeaponCount[j];

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 7
	mov	ecx, 64					; 00000040H
	shl	ecx, 0
	lea	edx, DWORD PTR _Quantity[eax+ecx]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _j$[ebp]
	movzx	eax, BYTE PTR ?gCurStores@@3PAULoadoutStruct@@A[eax+ecx+32]
	mov	ecx, DWORD PTR _wid$[ebp]
	add	eax, DWORD PTR [edx+ecx*4]
	mov	edx, 64					; 00000040H
	shl	edx, 0
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 7
	lea	edx, DWORD PTR _Quantity[ecx+edx]
	mov	ecx, DWORD PTR _wid$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 216  : 
; 217  : 		}

	jmp	$LN7@TallyStore
$LN6@TallyStore:

; 218  : 	}

	jmp	$LN13@TallyStore
$LN15@TallyStore:

; 219  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?TallyStores@@YAXXZ ENDP				; TallyStores
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__FgCurRails@@YAXXZ
text$yd	SEGMENT
??__FgCurRails@@YAXXZ PROC				; `dynamic atexit destructor for 'gCurRails'', COMDAT
	push	ebp
	mov	ebp, esp
	push	OFFSET ??1RailList@@QAE@XZ
	push	4
	push	2560					; 00000a00H
	push	OFFSET ?gCurRails@@3PAURailList@@A	; gCurRails
	call	??_M@YGXPAXIHP6EX0@Z@Z
	pop	ebp
	ret	0
??__FgCurRails@@YAXXZ ENDP				; `dynamic atexit destructor for 'gCurRails''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\munition.cpp
;	COMDAT ??__EgCurRails@@YAXXZ
text$yc	SEGMENT
??__EgCurRails@@YAXXZ PROC				; `dynamic initializer for 'gCurRails'', COMDAT

; 155  : RailList      gCurRails[4];			// per AC... four max

	push	ebp
	mov	ebp, esp
	push	OFFSET ??1RailList@@QAE@XZ
	push	OFFSET ??0RailList@@QAE@XZ
	push	4
	push	2560					; 00000a00H
	push	OFFSET ?gCurRails@@3PAURailList@@A	; gCurRails
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	push	OFFSET ??__FgCurRails@@YAXXZ		; `dynamic atexit destructor for 'gCurRails''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__EgCurRails@@YAXXZ ENDP				; `dynamic initializer for 'gCurRails''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\munition.cpp
;	COMDAT ??__EgOriginalStores@@YAXXZ
text$yc	SEGMENT
??__EgOriginalStores@@YAXXZ PROC			; `dynamic initializer for 'gOriginalStores'', COMDAT

; 154  : LoadoutStruct gOriginalStores[5];	// Last slot is the Starting list for the flight (set by kevin)

	push	ebp
	mov	ebp, esp
	push	OFFSET ??0LoadoutStruct@@QAE@XZ		; LoadoutStruct::LoadoutStruct
	push	5
	push	48					; 00000030H
	push	OFFSET ?gOriginalStores@@3PAULoadoutStruct@@A ; gOriginalStores
	call	??_H@YGXPAXIHP6EPAX0@Z@Z
	pop	ebp
	ret	0
??__EgOriginalStores@@YAXXZ ENDP			; `dynamic initializer for 'gOriginalStores''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\munition.cpp
;	COMDAT ??__EgCurStores@@YAXXZ
text$yc	SEGMENT
??__EgCurStores@@YAXXZ PROC				; `dynamic initializer for 'gCurStores'', COMDAT

; 153  : LoadoutStruct gCurStores[5];		// Last slot is the Starting list for the flight (set by kevin)

	push	ebp
	mov	ebp, esp
	push	OFFSET ??0LoadoutStruct@@QAE@XZ		; LoadoutStruct::LoadoutStruct
	push	5
	push	48					; 00000030H
	push	OFFSET ?gCurStores@@3PAULoadoutStruct@@A ; gCurStores
	call	??_H@YGXPAXIHP6EPAX0@Z@Z
	pop	ebp
	ret	0
??__EgCurStores@@YAXXZ ENDP				; `dynamic initializer for 'gCurStores''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\munition.cpp
;	COMDAT ??__EgLoadoutFlightID@@YAXXZ
text$yc	SEGMENT
??__EgLoadoutFlightID@@YAXXZ PROC			; `dynamic initializer for 'gLoadoutFlightID'', COMDAT

; 147  : VU_ID gLoadoutFlightID=FalconNullId;

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR ?gLoadoutFlightID@@3VVU_ID@@A, eax
	mov	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR ?gLoadoutFlightID@@3VVU_ID@@A+4, ecx
	pop	ebp
	ret	0
??__EgLoadoutFlightID@@YAXXZ ENDP			; `dynamic initializer for 'gLoadoutFlightID''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\munition.cpp
_TEXT	SEGMENT
_Leave$ = -32						; size = 4
tv176 = -28						; size = 4
_win$ = -24						; size = 4
_Diff$ = -20						; size = 4
_i$ = -16						; size = 4
_j$ = -12						; size = 4
_cur$ = -8						; size = 4
_state$1 = -4						; size = 2
?SetCurrentLoadout@@YAXXZ PROC				; SetCurrentLoadout

; 1938 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi

; 1939 : 	int i,j,Diff;
; 1940 : 	CONTROLLIST *cur;
; 1941 : 	C_Window *win;
; 1942 : 	F4CSECTIONHANDLE *Leave;
; 1943 : 
; 1944 : 	win=gMainHandler->FindWindow(MUNITIONS_WIN);

	push	16000					; 00003e80H
	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?FindWindowA@C_Handler@@QAEPAVC_Window@@J@Z ; C_Handler::FindWindowA
	mov	DWORD PTR _win$[ebp], eax

; 1945 : 	if(win == NULL)

	cmp	DWORD PTR _win$[ebp], 0
	jne	SHORT $LN21@SetCurrent

; 1946 : 		return;

	jmp	$LN22@SetCurrent
$LN21@SetCurrent:

; 1947 : 
; 1948 : 	Leave=UI_Enter(win);

	mov	eax, DWORD PTR _win$[ebp]
	push	eax
	call	?UI_Enter@@YAPAUF4CSECTIONHANDLE@@PAVC_Window@@@Z ; UI_Enter
	add	esp, 4
	mov	DWORD PTR _Leave$[ebp], eax

; 1949 : 	for(j=1;j<HardPoints;j++)

	mov	DWORD PTR _j$[ebp], 1
	jmp	SHORT $LN20@SetCurrent
$LN19@SetCurrent:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$LN20@SetCurrent:
	mov	edx, DWORD PTR _j$[ebp]
	cmp	edx, DWORD PTR ?HardPoints@@3JA		; HardPoints
	jge	$LN18@SetCurrent

; 1950 : 	{
; 1951 : 		cur=win->GetControlList();

	mov	ecx, DWORD PTR _win$[ebp]
	call	?GetControlList@C_Window@@QAEPAUControlListStr@@XZ ; C_Window::GetControlList
	mov	DWORD PTR _cur$[ebp], eax
$LN17@SetCurrent:

; 1952 : 		while(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	$LN16@SetCurrent

; 1953 : 		{
; 1954 : 			if(cur->Control_->GetGroup() == j)

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetGroup@C_Base@@QAEJXZ		; C_Base::GetGroup
	cmp	eax, DWORD PTR _j$[ebp]
	jne	$LN15@SetCurrent

; 1955 : 			{
; 1956 : 				if(cur->Control_->GetID() == ((j << 16) | gCurStores[FirstPlane].WeaponID[j]))

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetID@C_Base@@QAEJXZ			; C_Base::GetID
	mov	edx, DWORD PTR _j$[ebp]
	shl	edx, 16					; 00000010H
	mov	ecx, DWORD PTR ?FirstPlane@@3JA		; FirstPlane
	imul	ecx, 48					; 00000030H
	mov	esi, DWORD PTR _j$[ebp]
	movsx	ecx, WORD PTR ?gCurStores@@3PAULoadoutStruct@@A[ecx+esi*2]
	or	edx, ecx
	cmp	eax, edx
	jne	$LN14@SetCurrent

; 1957 : 				{
; 1958 : 					Diff=0;

	mov	DWORD PTR _Diff$[ebp], 0

; 1959 : 					for(i=0;i<4;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN13@SetCurrent
$LN12@SetCurrent:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN13@SetCurrent:
	cmp	DWORD PTR _i$[ebp], 4
	jge	SHORT $LN11@SetCurrent

; 1960 : 					{
; 1961 : 						if(PlaneEditList[i] && (gCurStores[FirstPlane].WeaponID[j] != gCurStores[i].WeaponID[j] || gCurStores[FirstPlane].WeaponCount[j] != gCurStores[i].WeaponCount[j]))

	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR ?PlaneEditList@@3PAJA[eax*4], 0
	je	SHORT $LN10@SetCurrent
	mov	ecx, DWORD PTR ?FirstPlane@@3JA		; FirstPlane
	imul	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _j$[ebp]
	movsx	eax, WORD PTR ?gCurStores@@3PAULoadoutStruct@@A[ecx+edx*2]
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _j$[ebp]
	movsx	ecx, WORD PTR ?gCurStores@@3PAULoadoutStruct@@A[ecx+edx*2]
	cmp	eax, ecx
	jne	SHORT $LN9@SetCurrent
	mov	edx, DWORD PTR ?FirstPlane@@3JA		; FirstPlane
	imul	edx, 48					; 00000030H
	mov	eax, DWORD PTR _j$[ebp]
	movzx	ecx, BYTE PTR ?gCurStores@@3PAULoadoutStruct@@A[edx+eax+32]
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 48					; 00000030H
	mov	eax, DWORD PTR _j$[ebp]
	movzx	edx, BYTE PTR ?gCurStores@@3PAULoadoutStruct@@A[edx+eax+32]
	cmp	ecx, edx
	je	SHORT $LN10@SetCurrent
$LN9@SetCurrent:

; 1962 : 							Diff=1;

	mov	DWORD PTR _Diff$[ebp], 1
$LN10@SetCurrent:

; 1963 : 					}

	jmp	SHORT $LN12@SetCurrent
$LN11@SetCurrent:

; 1964 : 					cur->Control_->SetUserNumber(0,gCurStores[FirstPlane].WeaponCount[j]);

	mov	eax, DWORD PTR ?FirstPlane@@3JA		; FirstPlane
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _j$[ebp]
	movzx	edx, BYTE PTR ?gCurStores@@3PAULoadoutStruct@@A[eax+ecx+32]
	push	edx
	push	0
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?SetUserNumber@C_Base@@QAEXJJ@Z		; C_Base::SetUserNumber

; 1965 : 					short state = (gCurStores[FirstPlane].WeaponCount[j] << 1)+Diff;

	mov	ecx, DWORD PTR ?FirstPlane@@3JA		; FirstPlane
	imul	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _j$[ebp]
	movzx	eax, BYTE PTR ?gCurStores@@3PAULoadoutStruct@@A[ecx+edx+32]
	mov	ecx, DWORD PTR _Diff$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	WORD PTR _state$1[ebp], dx

; 1966 : 					if (state > C_STATE_20) {

	movsx	eax, WORD PTR _state$1[ebp]
	cmp	eax, 20					; 00000014H
	jle	SHORT $LN8@SetCurrent

; 1967 : 						state = Diff ? C_STATE_19 : C_STATE_20;

	cmp	DWORD PTR _Diff$[ebp], 0
	je	SHORT $LN24@SetCurrent
	mov	DWORD PTR tv176[ebp], 19		; 00000013H
	jmp	SHORT $LN25@SetCurrent
$LN24@SetCurrent:
	mov	DWORD PTR tv176[ebp], 20		; 00000014H
$LN25@SetCurrent:
	mov	cx, WORD PTR tv176[ebp]
	mov	WORD PTR _state$1[ebp], cx
$LN8@SetCurrent:

; 1968 : 					}
; 1969 : 					cur->Control_->SetState(state);

	movzx	edx, WORD PTR _state$1[ebp]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [eax+56]
	call	edx

; 1970 : 				}
; 1971 : 				else

	jmp	$LN7@SetCurrent
$LN14@SetCurrent:

; 1972 : 				{
; 1973 : 					Diff=0;

	mov	DWORD PTR _Diff$[ebp], 0

; 1974 : 					for(i=0;i<4;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@SetCurrent
$LN5@SetCurrent:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN6@SetCurrent:
	cmp	DWORD PTR _i$[ebp], 4
	jge	SHORT $LN4@SetCurrent

; 1975 : 					{
; 1976 : 						if(PlaneEditList[i] && (cur->Control_->GetID() == ((j << 16) | gCurStores[i].WeaponID[j]) && i != FirstPlane))

	mov	ecx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR ?PlaneEditList@@3PAJA[ecx*4], 0
	je	SHORT $LN3@SetCurrent
	mov	edx, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetID@C_Base@@QAEJXZ			; C_Base::GetID
	mov	ecx, DWORD PTR _j$[ebp]
	shl	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 48					; 00000030H
	mov	esi, DWORD PTR _j$[ebp]
	movsx	edx, WORD PTR ?gCurStores@@3PAULoadoutStruct@@A[edx+esi*2]
	or	ecx, edx
	cmp	eax, ecx
	jne	SHORT $LN3@SetCurrent
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR ?FirstPlane@@3JA		; FirstPlane
	je	SHORT $LN3@SetCurrent

; 1977 : 							Diff=1;

	mov	DWORD PTR _Diff$[ebp], 1
$LN3@SetCurrent:

; 1978 : 					}

	jmp	SHORT $LN5@SetCurrent
$LN4@SetCurrent:

; 1979 : 					cur->Control_->SetUserNumber(0,0);

	push	0
	push	0
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?SetUserNumber@C_Base@@QAEXJJ@Z		; C_Base::SetUserNumber

; 1980 : 					if(gCurStores[FirstPlane].WeaponCount[j] && !Diff)

	mov	edx, DWORD PTR ?FirstPlane@@3JA		; FirstPlane
	imul	edx, 48					; 00000030H
	mov	eax, DWORD PTR _j$[ebp]
	movzx	ecx, BYTE PTR ?gCurStores@@3PAULoadoutStruct@@A[edx+eax+32]
	test	ecx, ecx
	je	SHORT $LN2@SetCurrent
	cmp	DWORD PTR _Diff$[ebp], 0
	jne	SHORT $LN2@SetCurrent

; 1981 : 						cur->Control_->SetState(C_STATE_DISABLED);

	push	21					; 00000015H
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 1982 : 					else

	jmp	SHORT $LN7@SetCurrent
$LN2@SetCurrent:

; 1983 : 						cur->Control_->SetState(static_cast<short>(Diff));

	movzx	ecx, WORD PTR _Diff$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+56]
	call	eax
$LN7@SetCurrent:

; 1984 : 				}
; 1985 : 				cur->Control_->Refresh();

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN15@SetCurrent:

; 1986 : 			}
; 1987 : 			cur=cur->Next;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _cur$[ebp], edx

; 1988 : 		}

	jmp	$LN17@SetCurrent
$LN16@SetCurrent:

; 1989 : 	}

	jmp	$LN19@SetCurrent
$LN18@SetCurrent:

; 1990 : 	UpdateStoresTally(win);

	mov	eax, DWORD PTR _win$[ebp]
	push	eax
	call	?UpdateStoresTally@@YAXPAVC_Window@@@Z	; UpdateStoresTally
	add	esp, 4

; 1991 : 	UI_Leave(Leave);

	mov	ecx, DWORD PTR _Leave$[ebp]
	push	ecx
	call	?UI_Leave@@YAXPAUF4CSECTIONHANDLE@@@Z	; UI_Leave
	add	esp, 4
$LN22@SetCurrent:

; 1992 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?SetCurrentLoadout@@YAXXZ ENDP				; SetCurrentLoadout
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\src\campaign\munition.cpp
_TEXT	SEGMENT
$T2 = -208						; size = 4
$T3 = -204						; size = 4
_Leave$ = -200						; size = 4
$T4 = -196						; size = 4
$T5 = -192						; size = 4
$T6 = -188						; size = 4
tv785 = -184						; size = 4
$T7 = -180						; size = 4
tv677 = -176						; size = 4
$T8 = -172						; size = 4
tv640 = -168						; size = 4
tv133 = -164						; size = 4
_ShowLoadedOnly$ = -160					; size = 4
$T9 = -156						; size = 4
tv224 = -152						; size = 4
$T10 = -148						; size = 4
tv154 = -144						; size = 4
_lbox$ = -140						; size = 4
tv638 = -136						; size = 4
tv372 = -132						; size = 4
tv545 = -128						; size = 4
tv308 = -124						; size = 4
$T11 = -120						; size = 4
$T12 = -116						; size = 4
tv438 = -112						; size = 4
$T13 = -108						; size = 4
tv1086 = -104						; size = 4
$T14 = -100						; size = 4
$T15 = -96						; size = 4
$T16 = -92						; size = 4
_avail$ = -88						; size = 4
_x$ = -84						; size = 4
_hpnum$ = -80						; size = 4
tv82 = -76						; size = 4
_color$ = -72						; size = 4
_availID$ = -68						; size = 4
_Drawit$ = -64						; size = 4
_j$ = -60						; size = 4
_GetType$ = -56						; size = 4
_y$ = -52						; size = 4
_cur$ = -48						; size = 4
_line$ = -44						; size = 4
_i$ = -40						; size = 4
_txt$ = -36						; size = 4
_btn$ = -32						; size = 4
_buf$ = -28						; size = 10
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_win$ = 8						; size = 4
_client$ = 12						; size = 4
?MakeStoresList@@YAXPAVC_Window@@J@Z PROC		; MakeStoresList

; 2199 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?MakeStoresList@@YAXPAVC_Window@@J@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 196				; 000000c4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 2200 : 	C_ListBox *lbox;
; 2201 : 	C_Text *txt;
; 2202 : 	C_Button *btn;
; 2203 : 	C_Line *line;
; 2204 : 	STORESLIST *cur;
; 2205 : 	BOOL ShowLoadedOnly=FALSE,Drawit;

	mov	DWORD PTR _ShowLoadedOnly$[ebp], 0

; 2206 : 	int GetType,x,y,i,j,hpnum,availID;
; 2207 : 	long color,avail;
; 2208 : 	_TCHAR buf[STRING_BUFFER_SIZE];
; 2209 : 	F4CSECTIONHANDLE *Leave;
; 2210 : 
; 2211 : 	if(win == NULL)

	cmp	DWORD PTR _win$[ebp], 0
	jne	SHORT $LN83@MakeStores

; 2212 : 		return;

	jmp	$LN85@MakeStores
$LN83@MakeStores:

; 2213 : 
; 2214 : 	Leave=UI_Enter(win);

	mov	eax, DWORD PTR _win$[ebp]
	push	eax
	call	?UI_Enter@@YAPAUF4CSECTIONHANDLE@@PAVC_Window@@@Z ; UI_Enter
	add	esp, 4
	mov	DWORD PTR _Leave$[ebp], eax

; 2215 : 
; 2216 : 	DeleteGroupList(win->GetID());

	mov	ecx, DWORD PTR _win$[ebp]
	call	?GetID@C_Window@@QAEJXZ			; C_Window::GetID
	push	eax
	call	?DeleteGroupList@@YAXJ@Z		; DeleteGroupList
	add	esp, 4

; 2217 : 	win->ScanClientArea(client);

	mov	ecx, DWORD PTR _client$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _win$[ebp]
	call	?ScanClientArea@C_Window@@QAEXJ@Z	; C_Window::ScanClientArea

; 2218 : 
; 2219 : 	lbox=(C_ListBox*)win->FindControl(WEAPON_LIST_CTRL);

	push	16032					; 00003ea0H
	mov	ecx, DWORD PTR _win$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _lbox$[ebp], eax

; 2220 : 
; 2221 : 	if(lbox)

	cmp	DWORD PTR _lbox$[ebp], 0
	je	SHORT $LN82@MakeStores

; 2222 : 	{
; 2223 : 		switch(lbox->GetTextID())

	mov	ecx, DWORD PTR _lbox$[ebp]
	call	?GetTextID@C_ListBox@@QAEJXZ		; C_ListBox::GetTextID
	mov	DWORD PTR tv82[ebp], eax
	mov	edx, DWORD PTR tv82[ebp]
	sub	edx, 16013				; 00003e8dH
	mov	DWORD PTR tv82[ebp], edx
	cmp	DWORD PTR tv82[ebp], 3
	ja	SHORT $LN75@MakeStores
	mov	eax, DWORD PTR tv82[ebp]
	jmp	DWORD PTR $LN110@MakeStores[eax*4]
$LN79@MakeStores:

; 2224 : 		{
; 2225 : 			case SHOW_LOADOUT:
; 2226 : 				GetType=StoresList::_ALL_;

	mov	DWORD PTR _GetType$[ebp], 3

; 2227 : 				ShowLoadedOnly=TRUE;

	mov	DWORD PTR _ShowLoadedOnly$[ebp], 1

; 2228 : 				break;

	jmp	SHORT $LN80@MakeStores
$LN78@MakeStores:

; 2229 : 			case SHOW_AA:
; 2230 : 				GetType=StoresList::_AIR_TO_AIR_;

	mov	DWORD PTR _GetType$[ebp], 0

; 2231 : 				break;

	jmp	SHORT $LN80@MakeStores
$LN77@MakeStores:

; 2232 : 			case SHOW_AG:
; 2233 : 				GetType=StoresList::_AIR_TO_GROUND_;

	mov	DWORD PTR _GetType$[ebp], 1

; 2234 : 				break;

	jmp	SHORT $LN80@MakeStores
$LN76@MakeStores:

; 2235 : 			case SHOW_OTHER:
; 2236 : 				GetType=StoresList::_OTHER_;

	mov	DWORD PTR _GetType$[ebp], 2

; 2237 : 				break;

	jmp	SHORT $LN80@MakeStores
$LN75@MakeStores:

; 2238 : 			default:
; 2239 : 				GetType=StoresList::_ALL_;

	mov	DWORD PTR _GetType$[ebp], 3
$LN80@MakeStores:

; 2240 : 		}
; 2241 : 	}
; 2242 : 	else

	jmp	SHORT $LN74@MakeStores
$LN82@MakeStores:

; 2243 : 		GetType=StoresList::_ALL_;

	mov	DWORD PTR _GetType$[ebp], 3
$LN74@MakeStores:

; 2244 : 
; 2245 : 	y=1;

	mov	DWORD PTR _y$[ebp], 1

; 2246 : 	x=174+240-(HardPoints/2)*30+15*((HardPoints-1)&1);

	mov	eax, DWORD PTR ?HardPoints@@3JA		; HardPoints
	cdq
	sub	eax, edx
	sar	eax, 1
	imul	eax, 30					; 0000001eH
	mov	ecx, 414				; 0000019eH
	sub	ecx, eax
	mov	edx, DWORD PTR ?HardPoints@@3JA		; HardPoints
	sub	edx, 1
	and	edx, 1
	imul	edx, 15					; 0000000fH
	add	ecx, edx
	mov	DWORD PTR _x$[ebp], ecx

; 2247 : 
; 2248 : 	// store's column headings
; 2249 : 	hpnum=1;

	mov	DWORD PTR _hpnum$[ebp], 1

; 2250 : 	for(i=HardPoints-1;i>0;i--)

	mov	eax, DWORD PTR ?HardPoints@@3JA		; HardPoints
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN73@MakeStores
$LN72@MakeStores:
	mov	ecx, DWORD PTR _i$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN73@MakeStores:
	cmp	DWORD PTR _i$[ebp], 0
	jle	$LN71@MakeStores

; 2251 : 	{
; 2252 : 		if(VisFlag & (1 << (HardPoints - i)))

	mov	ecx, DWORD PTR ?HardPoints@@3JA		; HardPoints
	sub	ecx, DWORD PTR _i$[ebp]
	mov	edx, 1
	shl	edx, cl
	and	edx, DWORD PTR _VisFlag
	je	SHORT $LN70@MakeStores

; 2253 : 			_stprintf(buf,"%1d",hpnum++);

	mov	eax, DWORD PTR _hpnum$[ebp]
	mov	DWORD PTR tv133[ebp], eax
	mov	ecx, DWORD PTR tv133[ebp]
	push	ecx
	push	OFFSET ??_C@_03GNGPFOOL@?$CF1d?$AA@
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _hpnum$[ebp]
	add	eax, 1
	mov	DWORD PTR _hpnum$[ebp], eax

; 2254 : 		else

	jmp	SHORT $LN69@MakeStores
$LN70@MakeStores:

; 2255 : 		{
; 2256 : 			memset(buf, 0, sizeof buf);

	push	10					; 0000000aH
	push	0
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 2257 : 			_tcscpy(buf,gStringMgr->GetString(TXT_INT));

	push	191					; 000000bfH
	mov	ecx, DWORD PTR ?gStringMgr@@3PAVC_String@@A ; gStringMgr
	call	?GetString@C_String@@QAEPADJ@Z		; C_String::GetString
	push	eax
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 2258 : 			ShiAssert (buf[STRING_BUFFER_SIZE-1] == 0);
; 2259 : 			buf[STRING_BUFFER_SIZE-1] = 0;

	mov	eax, 1
	imul	eax, 9
	mov	DWORD PTR $T12[ebp], eax
	cmp	DWORD PTR $T12[ebp], 10			; 0000000aH
	jae	SHORT $LN86@MakeStores
	jmp	SHORT $LN87@MakeStores
$LN86@MakeStores:
	call	___report_rangecheckfailure
$LN87@MakeStores:
	mov	ecx, DWORD PTR $T12[ebp]
	mov	BYTE PTR _buf$[ebp+ecx], 0
$LN69@MakeStores:

; 2260 : 		}
; 2261 : 		txt=new C_Text;

	push	76					; 0000004cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T14[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T14[ebp], 0
	je	SHORT $LN88@MakeStores
	mov	ecx, DWORD PTR $T14[ebp]
	call	??0C_Text@@QAE@XZ			; C_Text::C_Text
	mov	DWORD PTR tv154[ebp], eax
	jmp	SHORT $LN89@MakeStores
$LN88@MakeStores:
	mov	DWORD PTR tv154[ebp], 0
$LN89@MakeStores:
	mov	edx, DWORD PTR tv154[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _txt$[ebp], eax

; 2262 : 		txt->Setup(C_DONT_CARE,0);

	push	0
	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax

; 2263 : 		txt->SetFixedWidth(_tcsclen(buf)+1);

	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	__tcsclen
	add	esp, 4
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetFixedWidth@C_Text@@QAEXJ@Z		; C_Text::SetFixedWidth

; 2264 : 		txt->SetText(buf);

	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	mov	eax, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+256]
	call	eax

; 2265 : 		txt->SetFont(win->Font_);

	mov	ecx, DWORD PTR _win$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	push	edx
	mov	eax, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+68]
	call	eax

; 2266 : 		txt->SetXY(x+(i-1)*30-3+15+6,278);

	push	278					; 00000116H
	mov	ecx, DWORD PTR _i$[ebp]
	sub	ecx, 1
	imul	ecx, 30					; 0000001eH
	mov	edx, DWORD PTR _x$[ebp]
	lea	eax, DWORD PTR [edx+ecx+18]
	push	eax
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2267 : 		txt->SetFGColor(0xad8041);

	push	11370561				; 00ad8041H
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetFGColor@C_Text@@QAEXK@Z		; C_Text::SetFGColor

; 2268 : 		txt->SetFlagBitOn(C_BIT_ABSOLUTE|C_BIT_HCENTER);

	push	262656					; 00040200H
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 2269 : 		txt->SetUserNumber(_UI95_DELGROUP_SLOT_,_UI95_DELGROUP_ID_);

	push	5551212					; 0054b46cH
	push	7
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetUserNumber@C_Base@@QAEXJJ@Z		; C_Base::SetUserNumber

; 2270 : 		win->AddControl(txt);

	mov	ecx, DWORD PTR _txt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _win$[ebp]
	call	?AddControl@C_Window@@QAEXPAVC_Base@@@Z	; C_Window::AddControl

; 2271 : 	}

	jmp	$LN72@MakeStores
$LN71@MakeStores:

; 2272 : 
; 2273 : 	// Vertical lines separation the stores
; 2274 : 	for(i=0;i<HardPoints;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN68@MakeStores
$LN67@MakeStores:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN68@MakeStores:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR ?HardPoints@@3JA		; HardPoints
	jge	$LN66@MakeStores

; 2275 : 	{
; 2276 : 		line=new C_Line;

	push	60					; 0000003cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T13[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T13[ebp], 0
	je	SHORT $LN90@MakeStores
	mov	ecx, DWORD PTR $T13[ebp]
	call	??0C_Line@@QAE@XZ			; C_Line::C_Line
	mov	DWORD PTR tv224[ebp], eax
	jmp	SHORT $LN91@MakeStores
$LN90@MakeStores:
	mov	DWORD PTR tv224[ebp], 0
$LN91@MakeStores:
	mov	ecx, DWORD PTR tv224[ebp]
	mov	DWORD PTR $T8[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T8[ebp]
	mov	DWORD PTR _line$[ebp], edx

; 2277 : 		line->Setup(C_DONT_CARE,C_TYPE_VERTICAL);

	push	62					; 0000003eH
	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _line$[ebp]
	call	?Setup@C_Line@@QAEXJF@Z			; C_Line::Setup

; 2278 : 		line->SetXY(x+i*30+6-3,294);

	push	294					; 00000126H
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 30					; 0000001eH
	mov	ecx, DWORD PTR _x$[ebp]
	lea	edx, DWORD PTR [ecx+eax+3]
	push	edx
	mov	eax, DWORD PTR _line$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _line$[ebp]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2279 : 		line->SetWH(1,103);

	push	103					; 00000067H
	push	1
	mov	ecx, DWORD PTR _line$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _line$[ebp]
	mov	eax, DWORD PTR [edx+36]
	call	eax

; 2280 : 		line->SetColor(0xad8041);

	push	11370561				; 00ad8041H
	mov	ecx, DWORD PTR _line$[ebp]
	call	?SetColor@C_Line@@QAEXK@Z		; C_Line::SetColor

; 2281 : 		line->SetFlagBitOn(C_BIT_ABSOLUTE);

	push	262144					; 00040000H
	mov	ecx, DWORD PTR _line$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _line$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 2282 : 		line->SetUserNumber(_UI95_DELGROUP_SLOT_,_UI95_DELGROUP_ID_);

	push	5551212					; 0054b46cH
	push	7
	mov	ecx, DWORD PTR _line$[ebp]
	call	?SetUserNumber@C_Base@@QAEXJJ@Z		; C_Base::SetUserNumber

; 2283 : 		win->AddControl(line);

	mov	ecx, DWORD PTR _line$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _win$[ebp]
	call	?AddControl@C_Window@@QAEXPAVC_Base@@@Z	; C_Window::AddControl

; 2284 : 	}

	jmp	$LN67@MakeStores
$LN66@MakeStores:

; 2285 : 
; 2286 : 	cur=NULL;

	mov	DWORD PTR _cur$[ebp], 0

; 2287 : 	ShiAssert(gStores);
; 2288 : 	if (gStores)

	cmp	DWORD PTR ?gStores@@3PAVStoresList@@A, 0 ; gStores
	je	SHORT $LN64@MakeStores

; 2289 : 		cur = gStores->GetFirst(GetType);

	mov	edx, DWORD PTR _GetType$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?gStores@@3PAVStoresList@@A ; gStores
	call	?GetFirst@StoresList@@QAEPAUStoresStr@@J@Z ; StoresList::GetFirst
	mov	DWORD PTR _cur$[ebp], eax
$LN64@MakeStores:

; 2290 : 
; 2291 : 	while(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	$LN63@MakeStores

; 2292 : 	{
; 2293 : 		if(ShowLoadedOnly)

	cmp	DWORD PTR _ShowLoadedOnly$[ebp], 0
	je	$LN62@MakeStores

; 2294 : 		{
; 2295 : 			Drawit=FALSE;

	mov	DWORD PTR _Drawit$[ebp], 0

; 2296 : 			// JB 020219 Limit munition planecount to less than five otherwise we overwrite memory.
; 2297 : 			for(i=0;i<PlaneCount && Drawit == FALSE && i < 4;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN61@MakeStores
$LN60@MakeStores:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN61@MakeStores:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR ?PlaneCount@@3JA		; PlaneCount
	jge	SHORT $LN59@MakeStores
	cmp	DWORD PTR _Drawit$[ebp], 0
	jne	SHORT $LN59@MakeStores
	cmp	DWORD PTR _i$[ebp], 4
	jge	SHORT $LN59@MakeStores

; 2298 : 				for(j=1;j<HardPoints && Drawit == FALSE;j++)

	mov	DWORD PTR _j$[ebp], 1
	jmp	SHORT $LN58@MakeStores
$LN57@MakeStores:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$LN58@MakeStores:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR ?HardPoints@@3JA		; HardPoints
	jge	SHORT $LN56@MakeStores
	cmp	DWORD PTR _Drawit$[ebp], 0
	jne	SHORT $LN56@MakeStores

; 2299 : 					if(cur->ID == gCurStores[i].WeaponID[j] && gCurStores[i].WeaponCount[j])

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _j$[ebp]
	movsx	eax, WORD PTR ?gCurStores@@3PAULoadoutStruct@@A[ecx+edx*2]
	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx], eax
	jne	SHORT $LN55@MakeStores
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 48					; 00000030H
	mov	eax, DWORD PTR _j$[ebp]
	movzx	ecx, BYTE PTR ?gCurStores@@3PAULoadoutStruct@@A[edx+eax+32]
	test	ecx, ecx
	je	SHORT $LN55@MakeStores

; 2300 : 						Drawit=TRUE;

	mov	DWORD PTR _Drawit$[ebp], 1
$LN55@MakeStores:

; 2301 : 		}

	jmp	SHORT $LN57@MakeStores
$LN56@MakeStores:
	jmp	SHORT $LN60@MakeStores
$LN59@MakeStores:

; 2302 : 		else

	jmp	SHORT $LN54@MakeStores
$LN62@MakeStores:

; 2303 : 			Drawit=TRUE;

	mov	DWORD PTR _Drawit$[ebp], 1
$LN54@MakeStores:

; 2304 : 
; 2305 : 		if(Drawit)

	cmp	DWORD PTR _Drawit$[ebp], 0
	je	$LN53@MakeStores

; 2306 : 		{
; 2307 : 			// Store's name
; 2308 : 			txt=new C_Text;

	push	76					; 0000004cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T16[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	cmp	DWORD PTR $T16[ebp], 0
	je	SHORT $LN92@MakeStores
	mov	ecx, DWORD PTR $T16[ebp]
	call	??0C_Text@@QAE@XZ			; C_Text::C_Text
	mov	DWORD PTR tv308[ebp], eax
	jmp	SHORT $LN93@MakeStores
$LN92@MakeStores:
	mov	DWORD PTR tv308[ebp], 0
$LN93@MakeStores:
	mov	edx, DWORD PTR tv308[ebp]
	mov	DWORD PTR $T3[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR _txt$[ebp], eax

; 2309 : 			txt->Setup(C_DONT_CARE,0);

	push	0
	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax

; 2310 : 			txt->SetText(cur->Name);

	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax+256]
	call	edx

; 2311 : 			txt->SetFont(win->Font_);

	mov	eax, DWORD PTR _win$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	push	ecx
	mov	edx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax+68]
	call	edx

; 2312 : 			txt->SetXY(6,y+4);

	mov	eax, DWORD PTR _y$[ebp]
	add	eax, 4
	push	eax
	push	6
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2313 : 			txt->SetClient(static_cast<short>(client));

	movzx	ecx, WORD PTR _client$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetClient@C_Base@@QAEXF@Z		; C_Base::SetClient

; 2314 : 			txt->SetFGColor(0xc0c0c0);

	push	12632256				; 00c0c0c0H
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetFGColor@C_Text@@QAEXK@Z		; C_Text::SetFGColor

; 2315 : 			txt->SetUserNumber(_UI95_DELGROUP_SLOT_,_UI95_DELGROUP_ID_);

	push	5551212					; 0054b46cH
	push	7
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetUserNumber@C_Base@@QAEXJJ@Z		; C_Base::SetUserNumber

; 2316 : 			win->AddControl(txt);

	mov	edx, DWORD PTR _txt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _win$[ebp]
	call	?AddControl@C_Window@@QAEXPAVC_Base@@@Z	; C_Window::AddControl

; 2317 : 
; 2318 : 			// # in stock
; 2319 : 			avail=TotalAvailable(static_cast<short>(cur->ID));

	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, WORD PTR [eax]
	push	ecx
	call	?TotalAvailable@@YAFF@Z			; TotalAvailable
	add	esp, 4
	movsx	edx, ax
	mov	DWORD PTR _avail$[ebp], edx

; 2320 : 			if(!avail)

	cmp	DWORD PTR _avail$[ebp], 0
	jne	SHORT $LN52@MakeStores

; 2321 : 			{
; 2322 : 				availID=TXT_SUPPLY_OUT;

	mov	DWORD PTR _availID$[ebp], 290		; 00000122H

; 2323 : 				color=0x0000ff;

	mov	DWORD PTR _color$[ebp], 255		; 000000ffH
	jmp	SHORT $LN51@MakeStores
$LN52@MakeStores:

; 2324 : 			}
; 2325 : 			else if(avail < 700)

	cmp	DWORD PTR _avail$[ebp], 700		; 000002bcH
	jge	SHORT $LN50@MakeStores

; 2326 : 			{
; 2327 : 				availID=TXT_SUPPLY_LOW;

	mov	DWORD PTR _availID$[ebp], 291		; 00000123H

; 2328 : 				color=0x00ffff;

	mov	DWORD PTR _color$[ebp], 65535		; 0000ffffH
	jmp	SHORT $LN51@MakeStores
$LN50@MakeStores:

; 2329 : 			}
; 2330 : 			else if(avail < 1500)

	cmp	DWORD PTR _avail$[ebp], 1500		; 000005dcH
	jge	SHORT $LN48@MakeStores

; 2331 : 			{
; 2332 : 				availID=TXT_SUPPLY_MEDIUM;

	mov	DWORD PTR _availID$[ebp], 292		; 00000124H

; 2333 : 				color=0xeeeeee;

	mov	DWORD PTR _color$[ebp], 15658734	; 00eeeeeeH

; 2334 : 			}
; 2335 : 			else

	jmp	SHORT $LN51@MakeStores
$LN48@MakeStores:

; 2336 : 			{
; 2337 : 				availID=TXT_SUPPLY_HIGH;

	mov	DWORD PTR _availID$[ebp], 293		; 00000125H

; 2338 : 				color=0x00ff00;

	mov	DWORD PTR _color$[ebp], 65280		; 0000ff00H
$LN51@MakeStores:

; 2339 : 			}
; 2340 : 
; 2341 : 			txt=new C_Text;

	push	76					; 0000004cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T9[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	cmp	DWORD PTR $T9[ebp], 0
	je	SHORT $LN94@MakeStores
	mov	ecx, DWORD PTR $T9[ebp]
	call	??0C_Text@@QAE@XZ			; C_Text::C_Text
	mov	DWORD PTR tv372[ebp], eax
	jmp	SHORT $LN95@MakeStores
$LN94@MakeStores:
	mov	DWORD PTR tv372[ebp], 0
$LN95@MakeStores:
	mov	eax, DWORD PTR tv372[ebp]
	mov	DWORD PTR $T7[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T7[ebp]
	mov	DWORD PTR _txt$[ebp], ecx

; 2342 : 			txt->Setup((1 << 25) | cur->ID,0);

	push	0
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx]
	or	eax, 33554432				; 02000000H
	push	eax
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax

; 2343 : 			txt->SetText(availID);

	mov	ecx, DWORD PTR _availID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax+252]
	call	edx

; 2344 : 			txt->SetFont(win->Font_);

	mov	eax, DWORD PTR _win$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	push	ecx
	mov	edx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax+68]
	call	edx

; 2345 : 			txt->SetXY(122,y+4);

	mov	eax, DWORD PTR _y$[ebp]
	add	eax, 4
	push	eax
	push	122					; 0000007aH
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2346 : 			txt->SetClient(static_cast<short>(client));

	movzx	ecx, WORD PTR _client$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetClient@C_Base@@QAEXF@Z		; C_Base::SetClient

; 2347 : 			txt->SetFGColor(color);

	mov	edx, DWORD PTR _color$[ebp]
	push	edx
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetFGColor@C_Text@@QAEXK@Z		; C_Text::SetFGColor

; 2348 : 			txt->SetFlagBitOn(C_BIT_HCENTER);

	push	512					; 00000200H
	mov	eax, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 2349 : 			txt->SetUserNumber(_UI95_DELGROUP_SLOT_,_UI95_DELGROUP_ID_);

	push	5551212					; 0054b46cH
	push	7
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetUserNumber@C_Base@@QAEXJJ@Z		; C_Base::SetUserNumber

; 2350 : 			win->AddControl(txt);

	mov	ecx, DWORD PTR _txt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _win$[ebp]
	call	?AddControl@C_Window@@QAEXPAVC_Base@@@Z	; C_Window::AddControl

; 2351 : 
; 2352 : 			// # on board
; 2353 : 			txt=new C_Text;

	push	76					; 0000004cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T10[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	cmp	DWORD PTR $T10[ebp], 0
	je	SHORT $LN96@MakeStores
	mov	ecx, DWORD PTR $T10[ebp]
	call	??0C_Text@@QAE@XZ			; C_Text::C_Text
	mov	DWORD PTR tv438[ebp], eax
	jmp	SHORT $LN97@MakeStores
$LN96@MakeStores:
	mov	DWORD PTR tv438[ebp], 0
$LN97@MakeStores:
	mov	edx, DWORD PTR tv438[ebp]
	mov	DWORD PTR $T4[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T4[ebp]
	mov	DWORD PTR _txt$[ebp], eax

; 2354 : 			txt->Setup((1 << 24) | cur->ID,0);

	push	0
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx]
	or	edx, 16777216				; 01000000H
	push	edx
	mov	eax, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax

; 2355 : 			txt->SetFixedWidth(5);

	push	5
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetFixedWidth@C_Text@@QAEXJ@Z		; C_Text::SetFixedWidth

; 2356 : 			txt->SetText(" ");

	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+256]
	call	eax

; 2357 : 			txt->SetFont(win->Font_);

	mov	ecx, DWORD PTR _win$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	push	edx
	mov	eax, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+68]
	call	eax

; 2358 : 			txt->SetXY(157,y+4);

	mov	ecx, DWORD PTR _y$[ebp]
	add	ecx, 4
	push	ecx
	push	157					; 0000009dH
	mov	edx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 2359 : 			txt->SetClient(static_cast<short>(client));

	movzx	eax, WORD PTR _client$[ebp]
	push	eax
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetClient@C_Base@@QAEXF@Z		; C_Base::SetClient

; 2360 : 			txt->SetFGColor(0xc0c0c0);

	push	12632256				; 00c0c0c0H
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetFGColor@C_Text@@QAEXK@Z		; C_Text::SetFGColor

; 2361 : 			txt->SetFlagBitOn(C_BIT_HCENTER);

	push	512					; 00000200H
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _txt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 2362 : 			txt->SetUserNumber(_UI95_DELGROUP_SLOT_,_UI95_DELGROUP_ID_);

	push	5551212					; 0054b46cH
	push	7
	mov	ecx, DWORD PTR _txt$[ebp]
	call	?SetUserNumber@C_Base@@QAEXJJ@Z		; C_Base::SetUserNumber

; 2363 : 			win->AddControl(txt);

	mov	ecx, DWORD PTR _txt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _win$[ebp]
	call	?AddControl@C_Window@@QAEXPAVC_Base@@@Z	; C_Window::AddControl

; 2364 : 
; 2365 : 			// configuration
; 2366 : 			for(i=1;i<HardPoints;i++)

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN46@MakeStores
$LN45@MakeStores:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN46@MakeStores:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR ?HardPoints@@3JA		; HardPoints
	jge	$LN44@MakeStores

; 2367 : 			{
; 2368 : 				if(cur->HardPoint[i])

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, WORD PTR [edx+ecx*2+44]
	test	eax, eax
	je	$LN43@MakeStores

; 2369 : 				{
; 2370 : 					btn=new C_Button;

	push	160					; 000000a0H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T11[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 5
	cmp	DWORD PTR $T11[ebp], 0
	je	SHORT $LN98@MakeStores
	mov	ecx, DWORD PTR $T11[ebp]
	call	??0C_Button@@QAE@XZ			; C_Button::C_Button
	mov	DWORD PTR tv545[ebp], eax
	jmp	SHORT $LN99@MakeStores
$LN98@MakeStores:
	mov	DWORD PTR tv545[ebp], 0
$LN99@MakeStores:
	mov	ecx, DWORD PTR tv545[ebp]
	mov	DWORD PTR $T6[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T6[ebp]
	mov	DWORD PTR _btn$[ebp], edx

; 2371 : 					btn->Setup(i << 16 | cur->ID,C_TYPE_CUSTOM,x+((HardPoints-i)-1)*30+1,y+4);

	mov	eax, DWORD PTR _y$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR ?HardPoints@@3JA		; HardPoints
	sub	ecx, DWORD PTR _i$[ebp]
	sub	ecx, 1
	imul	ecx, 30					; 0000001eH
	mov	edx, DWORD PTR _x$[ebp]
	lea	eax, DWORD PTR [edx+ecx+1]
	push	eax
	push	29					; 0000001dH
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _cur$[ebp]
	or	ecx, DWORD PTR [edx]
	push	ecx
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?Setup@C_Button@@QAEXJFJJ@Z		; C_Button::Setup

; 2372 : 					btn->SetUserNumber(1,cur->HardPoint[i]);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, WORD PTR [ecx+eax*2+44]
	push	edx
	push	1
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetUserNumber@C_Base@@QAEXJJ@Z		; C_Base::SetUserNumber

; 2373 : 					btn->SetUserNumber(2,1);

	push	1
	push	2
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetUserNumber@C_Base@@QAEXJJ@Z		; C_Base::SetUserNumber

; 2374 : 
; 2375 : 					if(!(VisFlag & (1 << (i)))) // Internal stores

	mov	eax, 1
	mov	ecx, DWORD PTR _i$[ebp]
	shl	eax, cl
	and	eax, DWORD PTR _VisFlag
	jne	SHORT $LN42@MakeStores

; 2376 : 					{
; 2377 : 						btn->SetBackImage(INT_EMPTY);

	push	200083					; 00030d93H
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetBackImage@C_Button@@QAEXJ@Z		; C_Button::SetBackImage

; 2378 : 						btn->SetImage(C_STATE_0,INT_EMPTY);

	push	200083					; 00030d93H
	push	0
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2379 : 						btn->SetImage(C_STATE_1,INT_DIFF); // should be diff

	push	200086					; 00030d96H
	push	1
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2380 : 						btn->SetImage(C_STATE_2,INT_FULL);

	push	200084					; 00030d94H
	push	2
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2381 : 						btn->SetImage(C_STATE_3,INT_DIFF);

	push	200086					; 00030d96H
	push	3
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2382 : 						btn->SetImage(C_STATE_DISABLED,INT_DIS);

	push	200085					; 00030d95H
	push	21					; 00000015H
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage
	jmp	$LN41@MakeStores
$LN42@MakeStores:

; 2383 : 					}
; 2384 : 					else if(cur->Type == StoresList::_TYPE_GUN_)

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+24], 105			; 00000069H
	jne	SHORT $LN40@MakeStores

; 2385 : 					{
; 2386 : 						btn->SetBackImage(SINGLE_EMPTY);

	push	200017					; 00030d51H
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetBackImage@C_Button@@QAEXJ@Z		; C_Button::SetBackImage

; 2387 : 						btn->SetImage(C_STATE_0,SINGLE_EMPTY);

	push	200017					; 00030d51H
	push	0
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2388 : 						btn->SetImage(C_STATE_1,SINGLE_EMPTY_DIFF); // should be diff

	push	200041					; 00030d69H
	push	1
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2389 : 						btn->SetImage(C_STATE_2,SINGLE_FULL);

	push	200018					; 00030d52H
	push	2
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2390 : 						btn->SetImage(C_STATE_3,SINGLE_DIFF);

	push	200020					; 00030d54H
	push	3
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2391 : 						btn->SetImage(C_STATE_DISABLED,SINGLE_DIS);

	push	200019					; 00030d53H
	push	21					; 00000015H
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2392 : 						btn->SetUserNumber(1,1);

	push	1
	push	1
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetUserNumber@C_Base@@QAEXJJ@Z		; C_Base::SetUserNumber

; 2393 : 						btn->SetUserNumber(2,cur->HardPoint[i]);

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, WORD PTR [eax+edx*2+44]
	push	ecx
	push	2
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetUserNumber@C_Base@@QAEXJJ@Z		; C_Base::SetUserNumber
	jmp	$LN41@MakeStores
$LN40@MakeStores:

; 2394 : 					}
; 2395 : 					else switch(cur->HardPoint[i])

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, WORD PTR [eax+edx*2+44]
	mov	DWORD PTR tv638[ebp], ecx
	cmp	DWORD PTR tv638[ebp], 4
	ja	$LN6@MakeStores
	mov	edx, DWORD PTR tv638[ebp]
	jmp	DWORD PTR $LN111@MakeStores[edx*4]
$LN36@MakeStores:

; 2396 : 					{
; 2397 : 						case 1:
; 2398 : 							switch(cur->Type)

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR tv640[ebp], ecx
	cmp	DWORD PTR tv640[ebp], 103		; 00000067H
	je	SHORT $LN33@MakeStores
	jmp	SHORT $LN32@MakeStores
$LN33@MakeStores:

; 2399 : 							{
; 2400 : 								case StoresList::_TYPE_FUEL_:
; 2401 : 									btn->SetBackImage(POD_EMPTY);

	push	200001					; 00030d41H
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetBackImage@C_Button@@QAEXJ@Z		; C_Button::SetBackImage

; 2402 : 									btn->SetImage(C_STATE_0,POD_EMPTY);

	push	200001					; 00030d41H
	push	0
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2403 : 									btn->SetImage(C_STATE_1,POD_EMPTY_DIFF); // should be diff

	push	200037					; 00030d65H
	push	1
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2404 : 									btn->SetImage(C_STATE_2,POD_FULL);

	push	200002					; 00030d42H
	push	2
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2405 : 									btn->SetImage(C_STATE_3,POD_DIFF);

	push	200004					; 00030d44H
	push	3
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2406 : 									btn->SetImage(C_STATE_DISABLED,POD_DIS);

	push	200003					; 00030d43H
	push	21					; 00000015H
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2407 : 									break;

	jmp	SHORT $LN34@MakeStores
$LN32@MakeStores:

; 2408 : 								default:
; 2409 : 									btn->SetBackImage(SINGLE_EMPTY);

	push	200017					; 00030d51H
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetBackImage@C_Button@@QAEXJ@Z		; C_Button::SetBackImage

; 2410 : 									btn->SetImage(C_STATE_0,SINGLE_EMPTY);

	push	200017					; 00030d51H
	push	0
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2411 : 									btn->SetImage(C_STATE_1,SINGLE_EMPTY_DIFF); // should be diff

	push	200041					; 00030d69H
	push	1
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2412 : 									btn->SetImage(C_STATE_2,SINGLE_FULL);

	push	200018					; 00030d52H
	push	2
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2413 : 									btn->SetImage(C_STATE_3,SINGLE_DIFF);

	push	200020					; 00030d54H
	push	3
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2414 : 									btn->SetImage(C_STATE_DISABLED,SINGLE_DIS);

	push	200019					; 00030d53H
	push	21					; 00000015H
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage
$LN34@MakeStores:

; 2415 : 									break;
; 2416 : 							}
; 2417 : 							break;

	jmp	$LN41@MakeStores
$LN31@MakeStores:

; 2418 : 						case 2:
; 2419 : 							switch(cur->Type)

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR tv677[ebp], eax
	cmp	DWORD PTR tv677[ebp], 100		; 00000064H
	je	SHORT $LN28@MakeStores
	jmp	$LN23@MakeStores
$LN28@MakeStores:

; 2420 : 							{
; 2421 : 								case StoresList::_TYPE_MISSILE_:
; 2422 : 									btn->SetImage(C_STATE_2,LAU1_FULL);

	push	200046					; 00030d6eH
	push	2
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2423 : 									btn->SetImage(C_STATE_3,LAU1_FULL_DIFF);

	push	200047					; 00030d6fH
	push	3
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2424 : 									if(i > (HardPoints/2))

	mov	eax, DWORD PTR ?HardPoints@@3JA		; HardPoints
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	DWORD PTR _i$[ebp], eax
	jle	SHORT $LN27@MakeStores

; 2425 : 									{
; 2426 : 										btn->SetBackImage(LAU2L_EMPTY);

	push	200013					; 00030d4dH
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetBackImage@C_Button@@QAEXJ@Z		; C_Button::SetBackImage

; 2427 : 										btn->SetImage(C_STATE_0,LAU2L_EMPTY);

	push	200013					; 00030d4dH
	push	0
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2428 : 										btn->SetImage(C_STATE_1,LAU2L_EMPTY_DIFF); // should be diff

	push	200040					; 00030d68H
	push	1
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2429 : 										btn->SetImage(C_STATE_4,LAU2L_FULL);

	push	200014					; 00030d4eH
	push	4
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2430 : 										btn->SetImage(C_STATE_5,LAU2L_DIFF);

	push	200016					; 00030d50H
	push	5
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2431 : 										btn->SetImage(C_STATE_DISABLED,LAU2L_DIS);

	push	200015					; 00030d4fH
	push	21					; 00000015H
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage
	jmp	$LN26@MakeStores
$LN27@MakeStores:

; 2432 : 									}
; 2433 : 									else if (i == (HardPoints/2) && !(HardPoints & 1))

	mov	eax, DWORD PTR ?HardPoints@@3JA		; HardPoints
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	DWORD PTR _i$[ebp], eax
	jne	SHORT $LN25@MakeStores
	mov	ecx, DWORD PTR ?HardPoints@@3JA		; HardPoints
	and	ecx, 1
	jne	SHORT $LN25@MakeStores

; 2434 : 									{
; 2435 : 										btn->SetBackImage(LAU2C_EMPTY);

	push	200021					; 00030d55H
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetBackImage@C_Button@@QAEXJ@Z		; C_Button::SetBackImage

; 2436 : 										btn->SetImage(C_STATE_0,LAU2C_EMPTY);

	push	200021					; 00030d55H
	push	0
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2437 : 										btn->SetImage(C_STATE_1,LAU2C_EMPTY_DIFF); // should be diff

	push	200042					; 00030d6aH
	push	1
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2438 : 										btn->SetImage(C_STATE_4,LAU2C_FULL);

	push	200022					; 00030d56H
	push	4
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2439 : 										btn->SetImage(C_STATE_5,LAU2C_DIFF);

	push	200024					; 00030d58H
	push	5
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2440 : 										btn->SetImage(C_STATE_DISABLED,LAU2C_DIS);

	push	200023					; 00030d57H
	push	21					; 00000015H
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2441 : 									}
; 2442 : 									else

	jmp	SHORT $LN26@MakeStores
$LN25@MakeStores:

; 2443 : 									{
; 2444 : 										btn->SetBackImage(LAU2R_EMPTY);

	push	200009					; 00030d49H
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetBackImage@C_Button@@QAEXJ@Z		; C_Button::SetBackImage

; 2445 : 										btn->SetImage(C_STATE_0,LAU2R_EMPTY);

	push	200009					; 00030d49H
	push	0
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2446 : 										btn->SetImage(C_STATE_1,LAU2R_EMPTY_DIFF); // should be diff

	push	200039					; 00030d67H
	push	1
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2447 : 										btn->SetImage(C_STATE_4,LAU2R_FULL);

	push	200010					; 00030d4aH
	push	4
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2448 : 										btn->SetImage(C_STATE_5,LAU2R_DIFF);

	push	200012					; 00030d4cH
	push	5
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2449 : 										btn->SetImage(C_STATE_DISABLED,LAU2R_DIS);

	push	200011					; 00030d4bH
	push	21					; 00000015H
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage
$LN26@MakeStores:

; 2450 : 									}
; 2451 : 									break;

	jmp	$LN29@MakeStores
$LN23@MakeStores:

; 2452 : 								default:
; 2453 : 									btn->SetImage(C_STATE_2,LAU1_FULL);

	push	200046					; 00030d6eH
	push	2
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2454 : 									btn->SetImage(C_STATE_3,LAU1_FULL_DIFF);

	push	200047					; 00030d6fH
	push	3
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2455 : 									if(i > (HardPoints/2))

	mov	eax, DWORD PTR ?HardPoints@@3JA		; HardPoints
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	DWORD PTR _i$[ebp], eax
	jle	SHORT $LN22@MakeStores

; 2456 : 									{
; 2457 : 										btn->SetBackImage(TER2L_EMPTY);

	push	200048					; 00030d70H
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetBackImage@C_Button@@QAEXJ@Z		; C_Button::SetBackImage

; 2458 : 										btn->SetImage(C_STATE_0,TER2L_EMPTY);

	push	200048					; 00030d70H
	push	0
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2459 : 										btn->SetImage(C_STATE_1,TER2L_EMPTY_DIFF); // should be diff

	push	200049					; 00030d71H
	push	1
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2460 : 										btn->SetImage(C_STATE_4,TER2L_FULL);

	push	200050					; 00030d72H
	push	4
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2461 : 										btn->SetImage(C_STATE_5,TER2L_DIFF);

	push	200052					; 00030d74H
	push	5
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2462 : 										btn->SetImage(C_STATE_DISABLED,TER2L_DIS);

	push	200051					; 00030d73H
	push	21					; 00000015H
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2463 : 									}
; 2464 : 									else

	jmp	SHORT $LN29@MakeStores
$LN22@MakeStores:

; 2465 : 									{
; 2466 : 										btn->SetBackImage(TER2R_EMPTY);

	push	200033					; 00030d61H
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetBackImage@C_Button@@QAEXJ@Z		; C_Button::SetBackImage

; 2467 : 										btn->SetImage(C_STATE_0,TER2R_EMPTY);

	push	200033					; 00030d61H
	push	0
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2468 : 										btn->SetImage(C_STATE_1,TER2R_EMPTY_DIFF); // should be diff

	push	200045					; 00030d6dH
	push	1
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2469 : 										btn->SetImage(C_STATE_4,TER2R_FULL);

	push	200034					; 00030d62H
	push	4
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2470 : 										btn->SetImage(C_STATE_5,TER2R_DIFF);

	push	200036					; 00030d64H
	push	5
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2471 : 										btn->SetImage(C_STATE_DISABLED,TER2R_DIS);

	push	200035					; 00030d63H
	push	21					; 00000015H
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage
$LN29@MakeStores:

; 2472 : 									}
; 2473 : 									break;
; 2474 : 							}
; 2475 : 							break;

	jmp	$LN41@MakeStores
$LN20@MakeStores:

; 2476 : 						case 3:
; 2477 : 							switch(cur->Type)

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR tv785[ebp], eax
	cmp	DWORD PTR tv785[ebp], 100		; 00000064H
	je	SHORT $LN17@MakeStores
	jmp	$LN12@MakeStores
$LN17@MakeStores:

; 2478 : 							{
; 2479 : 								case StoresList::_TYPE_MISSILE_:
; 2480 : 									btn->SetBackImage(LAU3_EMPTY);

	push	200005					; 00030d45H
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetBackImage@C_Button@@QAEXJ@Z		; C_Button::SetBackImage

; 2481 : 									btn->SetImage(C_STATE_0,LAU3_EMPTY);

	push	200005					; 00030d45H
	push	0
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2482 : 									btn->SetImage(C_STATE_1,LAU3_EMPTY_DIFF); // should be diff

	push	200038					; 00030d66H
	push	1
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2483 : 									btn->SetImage(C_STATE_2,LAU1_FULL);

	push	200046					; 00030d6eH
	push	2
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2484 : 									btn->SetImage(C_STATE_3,LAU1_FULL_DIFF);

	push	200047					; 00030d6fH
	push	3
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2485 : 									if(i > (HardPoints/2))

	mov	eax, DWORD PTR ?HardPoints@@3JA		; HardPoints
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	DWORD PTR _i$[ebp], eax
	jle	SHORT $LN16@MakeStores

; 2486 : 									{
; 2487 : 										btn->SetImage(C_STATE_4,LAU2L_FULL);

	push	200014					; 00030d4eH
	push	4
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2488 : 										btn->SetImage(C_STATE_5,LAU2L_DIFF);

	push	200016					; 00030d50H
	push	5
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage
	jmp	SHORT $LN15@MakeStores
$LN16@MakeStores:

; 2489 : 									}
; 2490 : 									else if (i == (HardPoints/2) && !(HardPoints & 1))

	mov	eax, DWORD PTR ?HardPoints@@3JA		; HardPoints
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	DWORD PTR _i$[ebp], eax
	jne	SHORT $LN14@MakeStores
	mov	ecx, DWORD PTR ?HardPoints@@3JA		; HardPoints
	and	ecx, 1
	jne	SHORT $LN14@MakeStores

; 2491 : 									{
; 2492 : 										btn->SetImage(C_STATE_4,LAU2C_FULL);

	push	200022					; 00030d56H
	push	4
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2493 : 										btn->SetImage(C_STATE_5,LAU2C_DIFF);

	push	200024					; 00030d58H
	push	5
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2494 : 									}
; 2495 : 									else

	jmp	SHORT $LN15@MakeStores
$LN14@MakeStores:

; 2496 : 									{
; 2497 : 										btn->SetImage(C_STATE_4,LAU2R_FULL);

	push	200010					; 00030d4aH
	push	4
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2498 : 										btn->SetImage(C_STATE_5,LAU2R_DIFF);

	push	200012					; 00030d4cH
	push	5
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage
$LN15@MakeStores:

; 2499 : 									}
; 2500 : 									btn->SetImage(C_STATE_6,LAU3_FULL);

	push	200006					; 00030d46H
	push	6
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2501 : 									btn->SetImage(C_STATE_7,LAU3_DIFF);

	push	200008					; 00030d48H
	push	7
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2502 : 									btn->SetImage(C_STATE_DISABLED,LAU3_DIS);

	push	200007					; 00030d47H
	push	21					; 00000015H
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2503 : 									break;

	jmp	$LN18@MakeStores
$LN12@MakeStores:

; 2504 : 								default:
; 2505 : 									btn->SetBackImage(TER_EMPTY);

	push	200025					; 00030d59H
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetBackImage@C_Button@@QAEXJ@Z		; C_Button::SetBackImage

; 2506 : 									btn->SetImage(C_STATE_0,TER_EMPTY);

	push	200025					; 00030d59H
	push	0
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2507 : 									btn->SetImage(C_STATE_1,TER_EMPTY_DIFF); // should be diff

	push	200043					; 00030d6bH
	push	1
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2508 : 									btn->SetImage(C_STATE_2,LAU1_FULL);

	push	200046					; 00030d6eH
	push	2
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2509 : 									btn->SetImage(C_STATE_3,LAU1_FULL_DIFF);

	push	200047					; 00030d6fH
	push	3
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2510 : 									if(i > (HardPoints/2))

	mov	eax, DWORD PTR ?HardPoints@@3JA		; HardPoints
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	DWORD PTR _i$[ebp], eax
	jle	SHORT $LN11@MakeStores

; 2511 : 									{
; 2512 : 										btn->SetImage(C_STATE_4,TER2L_FULL);

	push	200050					; 00030d72H
	push	4
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2513 : 										btn->SetImage(C_STATE_5,TER2L_DIFF);

	push	200052					; 00030d74H
	push	5
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2514 : 									}
; 2515 : 									else

	jmp	SHORT $LN10@MakeStores
$LN11@MakeStores:

; 2516 : 									{
; 2517 : 										btn->SetImage(C_STATE_4,TER2R_FULL);

	push	200034					; 00030d62H
	push	4
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2518 : 										btn->SetImage(C_STATE_5,TER2R_DIFF);

	push	200036					; 00030d64H
	push	5
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage
$LN10@MakeStores:

; 2519 : 									}
; 2520 : 									btn->SetImage(C_STATE_6,TER_FULL);

	push	200026					; 00030d5aH
	push	6
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2521 : 									btn->SetImage(C_STATE_7,TER_DIFF);

	push	200028					; 00030d5cH
	push	7
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2522 : 									btn->SetImage(C_STATE_DISABLED,TER_DIS);

	push	200027					; 00030d5bH
	push	21					; 00000015H
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage
$LN18@MakeStores:

; 2523 : 									break;
; 2524 : 							}
; 2525 : 							break;

	jmp	$LN41@MakeStores
$LN9@MakeStores:

; 2526 : 						case 4:
; 2527 : 							btn->SetBackImage(QUAD_EMPTY);

	push	200059					; 00030d7bH
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetBackImage@C_Button@@QAEXJ@Z		; C_Button::SetBackImage

; 2528 : 							btn->SetImage(C_STATE_0,QUAD_EMPTY);

	push	200059					; 00030d7bH
	push	0
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2529 : 							btn->SetImage(C_STATE_1,QUAD_EMPTY_DIFF); // should be diff

	push	200063					; 00030d7fH
	push	1
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2530 : 							if(i > (HardPoints/2))

	mov	eax, DWORD PTR ?HardPoints@@3JA		; HardPoints
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	DWORD PTR _i$[ebp], eax
	jle	SHORT $LN8@MakeStores

; 2531 : 							{
; 2532 : 								btn->SetImage(C_STATE_2,QUAD1L);

	push	200064					; 00030d80H
	push	2
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2533 : 								btn->SetImage(C_STATE_3,QUAD1L_DIFF);

	push	200066					; 00030d82H
	push	3
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2534 : 								btn->SetImage(C_STATE_4,QUAD2L);

	push	200070					; 00030d86H
	push	4
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2535 : 								btn->SetImage(C_STATE_5,QUAD2L_DIFF);

	push	200072					; 00030d88H
	push	5
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2536 : 								btn->SetImage(C_STATE_6,QUAD3L);

	push	200076					; 00030d8cH
	push	6
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2537 : 								btn->SetImage(C_STATE_7,QUAD3L_DIFF);

	push	200079					; 00030d8fH
	push	7
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2538 : 							}
; 2539 : 							else

	jmp	SHORT $LN7@MakeStores
$LN8@MakeStores:

; 2540 : 							{
; 2541 : 								btn->SetImage(C_STATE_2,QUAD1R);

	push	200067					; 00030d83H
	push	2
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2542 : 								btn->SetImage(C_STATE_3,QUAD1R_DIFF);

	push	200069					; 00030d85H
	push	3
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2543 : 								btn->SetImage(C_STATE_4,QUAD2R);

	push	200073					; 00030d89H
	push	4
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2544 : 								btn->SetImage(C_STATE_5,QUAD2R_DIFF);

	push	200075					; 00030d8bH
	push	5
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2545 : 								btn->SetImage(C_STATE_6,QUAD3R);

	push	200080					; 00030d90H
	push	6
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2546 : 								btn->SetImage(C_STATE_7,QUAD3R_DIFF);

	push	200082					; 00030d92H
	push	7
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage
$LN7@MakeStores:

; 2547 : 							}
; 2548 : 							btn->SetImage(C_STATE_8,QUAD_FULL);

	push	200060					; 00030d7cH
	push	8
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2549 : 							btn->SetImage(C_STATE_9,QUAD_DIFF);

	push	200062					; 00030d7eH
	push	9
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2550 : 							btn->SetImage(C_STATE_DISABLED,QUAD_DIS);

	push	200061					; 00030d7dH
	push	21					; 00000015H
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2551 : 							break;

	jmp	$LN41@MakeStores
$LN6@MakeStores:

; 2552 : 						case 5: case 6:
; 2553 : 						default: // JPO - best of a bad lot, for > 6, we at least get some feedback
; 2554 : 							btn->SetBackImage(DOUBLE_TER_EMPTY);

	push	200029					; 00030d5dH
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetBackImage@C_Button@@QAEXJ@Z		; C_Button::SetBackImage

; 2555 : 							btn->SetImage(C_STATE_0,DOUBLE_TER_EMPTY);

	push	200029					; 00030d5dH
	push	0
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2556 : 							btn->SetImage(C_STATE_1,DOUBLE_TER_DIFF); // should be diff

	push	200032					; 00030d60H
	push	1
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2557 : 							btn->SetImage(C_STATE_2,LAU1_FULL);

	push	200046					; 00030d6eH
	push	2
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2558 : 							btn->SetImage(C_STATE_3,LAU1_FULL_DIFF);

	push	200047					; 00030d6fH
	push	3
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2559 : 							if(i > (HardPoints/2))

	mov	eax, DWORD PTR ?HardPoints@@3JA		; HardPoints
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	DWORD PTR _i$[ebp], eax
	jle	SHORT $LN5@MakeStores

; 2560 : 							{
; 2561 : 								btn->SetImage(C_STATE_4,TER2L_FULL);

	push	200050					; 00030d72H
	push	4
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2562 : 								btn->SetImage(C_STATE_5,TER2L_DIFF);

	push	200052					; 00030d74H
	push	5
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2563 : 								btn->SetImage(C_STATE_10,DOUBLE_TER_5L);

	push	200056					; 00030d78H
	push	10					; 0000000aH
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2564 : 								btn->SetImage(C_STATE_11,DOUBLE_TER_5L_DIFF);

	push	200055					; 00030d77H
	push	11					; 0000000bH
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2565 : 							}
; 2566 : 							else

	jmp	SHORT $LN4@MakeStores
$LN5@MakeStores:

; 2567 : 							{
; 2568 : 								btn->SetImage(C_STATE_4,TER2R_FULL);

	push	200034					; 00030d62H
	push	4
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2569 : 								btn->SetImage(C_STATE_5,TER2R_DIFF);

	push	200036					; 00030d64H
	push	5
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2570 : 								btn->SetImage(C_STATE_10,DOUBLE_TER_5R);

	push	200058					; 00030d7aH
	push	10					; 0000000aH
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2571 : 								btn->SetImage(C_STATE_11,DOUBLE_TER_5R_DIFF);

	push	200057					; 00030d79H
	push	11					; 0000000bH
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage
$LN4@MakeStores:

; 2572 : 							}
; 2573 : 							btn->SetImage(C_STATE_6,TER_FULL);

	push	200026					; 00030d5aH
	push	6
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2574 : 							btn->SetImage(C_STATE_7,TER_DIFF);

	push	200028					; 00030d5cH
	push	7
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2575 : 							btn->SetImage(C_STATE_8,DOUBLE_TER_4);

	push	200054					; 00030d76H
	push	8
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2576 : 							btn->SetImage(C_STATE_9,DOUBLE_TER_4_DIFF);

	push	200053					; 00030d75H
	push	9
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2577 : 							btn->SetImage(C_STATE_12,DOUBLE_TER_FULL);

	push	200030					; 00030d5eH
	push	12					; 0000000cH
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2578 : 							btn->SetImage(C_STATE_13,DOUBLE_TER_DIFF);

	push	200032					; 00030d60H
	push	13					; 0000000dH
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2579 : 							btn->SetImage(C_STATE_14,DOUBLE_TER_FULL);

	push	200030					; 00030d5eH
	push	14					; 0000000eH
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2580 : 							btn->SetImage(C_STATE_15,DOUBLE_TER_DIFF);

	push	200032					; 00030d60H
	push	15					; 0000000fH
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2581 : 							btn->SetImage(C_STATE_16,DOUBLE_TER_FULL);

	push	200030					; 00030d5eH
	push	16					; 00000010H
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2582 : 							btn->SetImage(C_STATE_17,DOUBLE_TER_DIFF);

	push	200032					; 00030d60H
	push	17					; 00000011H
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2583 : 							btn->SetImage(C_STATE_18,DOUBLE_TER_FULL);

	push	200030					; 00030d5eH
	push	18					; 00000012H
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2584 : 							btn->SetImage(C_STATE_19,DOUBLE_TER_DIFF);

	push	200032					; 00030d60H
	push	19					; 00000013H
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2585 : 							btn->SetImage(C_STATE_20,DOUBLE_TER_FULL);

	push	200030					; 00030d5eH
	push	20					; 00000014H
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2586 : 							btn->SetImage(C_STATE_DISABLED,DOUBLE_TER_DIS);

	push	200031					; 00030d5fH
	push	21					; 00000015H
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2587 : 							break;

	jmp	SHORT $LN41@MakeStores
$LN3@MakeStores:

; 2588 : 
; 2589 : 							// JPO - from default, to 0. Move default up to 5/6 case
; 2590 : 							// this will only handle the no weapon case now I think, 
; 2591 : 							// which may not even exist.
; 2592 : 						case 0:								//!!marked
; 2593 : 							btn->SetBackImage(POD_EMPTY);

	push	200001					; 00030d41H
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetBackImage@C_Button@@QAEXJ@Z		; C_Button::SetBackImage

; 2594 : 							btn->SetImage(C_STATE_0,POD_EMPTY);

	push	200001					; 00030d41H
	push	0
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2595 : 							btn->SetImage(C_STATE_1,POD_EMPTY_DIFF); // should be diff

	push	200037					; 00030d65H
	push	1
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2596 : 							btn->SetImage(C_STATE_2,POD_FULL);

	push	200002					; 00030d42H
	push	2
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2597 : 							btn->SetImage(C_STATE_3,POD_DIFF);

	push	200004					; 00030d44H
	push	3
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage

; 2598 : 							btn->SetImage(C_STATE_DISABLED,POD_DIS);

	push	200003					; 00030d43H
	push	21					; 00000015H
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetImage@C_Button@@QAEXFJ@Z		; C_Button::SetImage
$LN41@MakeStores:

; 2599 : 							break; 
; 2600 : 					}
; 2601 : 					btn->SetClient(static_cast<short>(client));

	movzx	edx, WORD PTR _client$[ebp]
	push	edx
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetClient@C_Base@@QAEXF@Z		; C_Base::SetClient

; 2602 : 					btn->SetFont(win->Font_);

	mov	eax, DWORD PTR _win$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	push	ecx
	mov	edx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [eax+68]
	call	edx

; 2603 : 					btn->SetGroup(i);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetGroup@C_Base@@QAEXJ@Z		; C_Base::SetGroup

; 2604 : 					if(!(VisFlag & (1 << (i)))) // Internal stores

	mov	edx, 1
	mov	ecx, DWORD PTR _i$[ebp]
	shl	edx, cl
	and	edx, DWORD PTR _VisFlag
	jne	SHORT $LN2@MakeStores

; 2605 : 						btn->SetCallback(InternalArmPlaneCB);

	push	OFFSET ?InternalArmPlaneCB@@YAXJFPAVC_Base@@@Z ; InternalArmPlaneCB
	mov	eax, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax

; 2606 : 					else

	jmp	SHORT $LN1@MakeStores
$LN2@MakeStores:

; 2607 : 						btn->SetCallback(ArmPlaneCB);

	push	OFFSET ?ArmPlaneCB@@YAXJFPAVC_Base@@@Z	; ArmPlaneCB
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _btn$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN1@MakeStores:

; 2608 : 					btn->SetUserNumber(_UI95_DELGROUP_SLOT_,_UI95_DELGROUP_ID_);

	push	5551212					; 0054b46cH
	push	7
	mov	ecx, DWORD PTR _btn$[ebp]
	call	?SetUserNumber@C_Base@@QAEXJJ@Z		; C_Base::SetUserNumber

; 2609 : 					win->AddControl(btn);

	mov	ecx, DWORD PTR _btn$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _win$[ebp]
	call	?AddControl@C_Window@@QAEXPAVC_Base@@@Z	; C_Window::AddControl
$LN43@MakeStores:

; 2610 : 				}
; 2611 : 			}

	jmp	$LN45@MakeStores
$LN44@MakeStores:

; 2612 : 			line=new C_Line;

	push	60					; 0000003cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T15[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 6
	cmp	DWORD PTR $T15[ebp], 0
	je	SHORT $LN100@MakeStores
	mov	ecx, DWORD PTR $T15[ebp]
	call	??0C_Line@@QAE@XZ			; C_Line::C_Line
	mov	DWORD PTR tv1086[ebp], eax
	jmp	SHORT $LN101@MakeStores
$LN100@MakeStores:
	mov	DWORD PTR tv1086[ebp], 0
$LN101@MakeStores:
	mov	edx, DWORD PTR tv1086[ebp]
	mov	DWORD PTR $T5[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T5[ebp]
	mov	DWORD PTR _line$[ebp], eax

; 2613 : 			line->Setup(C_DONT_CARE,C_TYPE_HORIZONTAL);

	push	63					; 0000003fH
	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _line$[ebp]
	call	?Setup@C_Line@@QAEXJF@Z			; C_Line::Setup

; 2614 : 			line->SetXY(0,y+25);

	mov	ecx, DWORD PTR _y$[ebp]
	add	ecx, 25					; 00000019H
	push	ecx
	push	0
	mov	edx, DWORD PTR _line$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _line$[ebp]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 2615 : 			line->SetWH(win->ClientArea_[1].right-win->ClientArea_[1].left+1,1);

	push	1
	mov	eax, 16					; 00000010H
	shl	eax, 0
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	mov	edx, DWORD PTR _win$[ebp]
	mov	esi, DWORD PTR _win$[ebp]
	mov	eax, DWORD PTR [edx+eax+176]
	sub	eax, DWORD PTR [esi+ecx+168]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _line$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _line$[ebp]
	mov	eax, DWORD PTR [edx+36]
	call	eax

; 2616 : 			line->SetColor(0xad8041);

	push	11370561				; 00ad8041H
	mov	ecx, DWORD PTR _line$[ebp]
	call	?SetColor@C_Line@@QAEXK@Z		; C_Line::SetColor

; 2617 : 			line->SetClient(static_cast<short>(client));

	movzx	ecx, WORD PTR _client$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _line$[ebp]
	call	?SetClient@C_Base@@QAEXF@Z		; C_Base::SetClient

; 2618 : 			line->SetUserNumber(_UI95_DELGROUP_SLOT_,_UI95_DELGROUP_ID_);

	push	5551212					; 0054b46cH
	push	7
	mov	ecx, DWORD PTR _line$[ebp]
	call	?SetUserNumber@C_Base@@QAEXJJ@Z		; C_Base::SetUserNumber

; 2619 : 			win->AddControl(line);

	mov	edx, DWORD PTR _line$[ebp]
	push	edx
	mov	ecx, DWORD PTR _win$[ebp]
	call	?AddControl@C_Window@@QAEXPAVC_Base@@@Z	; C_Window::AddControl

; 2620 : 
; 2621 : 			y+=26;

	mov	eax, DWORD PTR _y$[ebp]
	add	eax, 26					; 0000001aH
	mov	DWORD PTR _y$[ebp], eax
$LN53@MakeStores:

; 2622 : 		}
; 2623 : 		cur=gStores->GetNext();

	mov	ecx, DWORD PTR ?gStores@@3PAVStoresList@@A ; gStores
	call	?GetNext@StoresList@@QAEPAUStoresStr@@XZ ; StoresList::GetNext
	mov	DWORD PTR _cur$[ebp], eax

; 2624 : 	}

	jmp	$LN64@MakeStores
$LN63@MakeStores:

; 2625 : 	SetCurrentLoadout();

	call	?SetCurrentLoadout@@YAXXZ		; SetCurrentLoadout

; 2626 : 	win->ScanClientAreas();

	mov	ecx, DWORD PTR _win$[ebp]
	call	?ScanClientAreas@C_Window@@QAEXXZ	; C_Window::ScanClientAreas

; 2627 : 	win->RefreshWindow();

	mov	ecx, DWORD PTR _win$[ebp]
	call	?RefreshWindow@C_Window@@QAEXXZ		; C_Window::RefreshWindow

; 2628 : 	UI_Leave(Leave);

	mov	ecx, DWORD PTR _Leave$[ebp]
	push	ecx
	call	?UI_Leave@@YAXPAUF4CSECTIONHANDLE@@@Z	; UI_Leave
	add	esp, 4
$LN85@MakeStores:

; 2629 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN110@MakeStores:
	DD	$LN79@MakeStores
	DD	$LN78@MakeStores
	DD	$LN77@MakeStores
	DD	$LN76@MakeStores
$LN111@MakeStores:
	DD	$LN3@MakeStores
	DD	$LN36@MakeStores
	DD	$LN31@MakeStores
	DD	$LN20@MakeStores
	DD	$LN9@MakeStores
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?MakeStoresList@@YAXPAVC_Window@@J@Z$0:
	mov	eax, DWORD PTR $T14[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?MakeStoresList@@YAXPAVC_Window@@J@Z$1:
	mov	eax, DWORD PTR $T13[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?MakeStoresList@@YAXPAVC_Window@@J@Z$2:
	mov	eax, DWORD PTR $T16[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?MakeStoresList@@YAXPAVC_Window@@J@Z$3:
	mov	eax, DWORD PTR $T9[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?MakeStoresList@@YAXPAVC_Window@@J@Z$4:
	mov	eax, DWORD PTR $T10[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?MakeStoresList@@YAXPAVC_Window@@J@Z$5:
	mov	eax, DWORD PTR $T11[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?MakeStoresList@@YAXPAVC_Window@@J@Z$6:
	mov	eax, DWORD PTR $T15[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?MakeStoresList@@YAXPAVC_Window@@J@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-204]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?MakeStoresList@@YAXPAVC_Window@@J@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?MakeStoresList@@YAXPAVC_Window@@J@Z ENDP		; MakeStoresList
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simweapn.h
;	COMDAT ?SetRackSlot@SimWeaponClass@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_slot$ = 8						; size = 4
?SetRackSlot@SimWeaponClass@@QAEXH@Z PROC		; SimWeaponClass::SetRackSlot, COMDAT
; _this$ = ecx

; 42   : 	void SetRackSlot (int slot) { rackSlot = slot; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _slot$[ebp]
	mov	DWORD PTR [eax+676], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetRackSlot@SimWeaponClass@@QAEXH@Z ENDP		; SimWeaponClass::SetRackSlot
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simweapn.h
;	COMDAT ?GetNextOnRail@SimWeaponClass@@QAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNextOnRail@SimWeaponClass@@QAEPAV1@XZ PROC		; SimWeaponClass::GetNextOnRail, COMDAT
; _this$ = ecx

; 41   : 	SimWeaponClass* GetNextOnRail(void) { return nextOnRail.get(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 672				; 000002a0H
	call	?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::get
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNextOnRail@SimWeaponClass@@QAEPAV1@XZ ENDP		; SimWeaponClass::GetNextOnRail
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1RailList@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1RailList@@QAE@XZ PROC				; RailList::~RailList, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET ??1RailInfo@@QAE@XZ
	push	16					; 00000010H
	push	160					; 000000a0H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	esp, ebp
	pop	ebp
	ret	0
??1RailList@@QAE@XZ ENDP				; RailList::~RailList
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0RailList@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0RailList@@QAE@XZ PROC				; RailList::RailList, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET ??1RailInfo@@QAE@XZ
	push	OFFSET ??0RailInfo@@QAE@XZ		; RailInfo::RailInfo
	push	16					; 00000010H
	push	160					; 000000a0H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0RailList@@QAE@XZ ENDP				; RailList::RailList
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1RailInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1RailInfo@@QAE@XZ PROC				; RailInfo::~RailInfo, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1AdvancedWeaponStation@@UAE@XZ	; AdvancedWeaponStation::~AdvancedWeaponStation
	mov	esp, ebp
	pop	ebp
	ret	0
??1RailInfo@@QAE@XZ ENDP				; RailInfo::~RailInfo
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\include\railinfo.h
;	COMDAT ??0RailInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0RailInfo@@QAE@XZ PROC				; RailInfo::RailInfo, COMDAT
; _this$ = ecx

; 9    : 	RailInfo()  // MLR 2/25/2004 - 

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0AdvancedWeaponStation@@QAE@XZ	; AdvancedWeaponStation::AdvancedWeaponStation

; 10   : 	{ 
; 11   : 		//pylonID		= 0; 
; 12   : 		//rackID		= 0; 
; 13   : 		//weaponID	= 0;
; 14   : 		startBits	= 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+152], ax

; 15   : 		currentBits	= 0;

	xor	edx, edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+154], dx

; 16   : 		weaponCount = 0;

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+156], cx

; 17   : 	};

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0RailInfo@@QAE@XZ ENDP				; RailInfo::RailInfo
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\hardpnt.h
;	COMDAT ?SetHPId@BasicWeaponStation@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_id$ = 8						; size = 4
?SetHPId@BasicWeaponStation@@QAEXH@Z PROC		; BasicWeaponStation::SetHPId, COMDAT
; _this$ = ecx

; 63   : 		void SetHPId(int id)  {hpId = id;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _id$[ebp]
	mov	DWORD PTR [eax+4], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetHPId@BasicWeaponStation@@QAEXH@Z ENDP		; BasicWeaponStation::SetHPId
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?reset@?$VuBin@VSimWeaponClass@@@@QAEXPAVSimWeaponClass@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newe$ = 8						; size = 4
?reset@?$VuBin@VSimWeaponClass@@@@QAEXPAVSimWeaponClass@@@Z PROC ; VuBin<SimWeaponClass>::reset, COMDAT
; _this$ = ecx

; 60   : 	void reset(E *newe = NULL){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 61   : 		if (newe == e){ return; }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newe$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN1@reset
	jmp	SHORT $LN2@reset
$LN1@reset:

; 62   : 		VuReferenceEntity(newe); // ref new pointer

	mov	edx, DWORD PTR _newe$[ebp]
	push	edx
	call	?VuReferenceEntity@@YAHPAVVuEntity@@@Z	; VuReferenceEntity
	add	esp, 4

; 63   : 		VuDeReferenceEntity(e);  // unref old pointer

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?VuDeReferenceEntity@@YAHPAVVuEntity@@@Z ; VuDeReferenceEntity
	add	esp, 4

; 64   : 		e = newe;                // get new pointer

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _newe$[ebp]
	mov	DWORD PTR [edx], eax
$LN2@reset:

; 65   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?reset@?$VuBin@VSimWeaponClass@@@@QAEXPAVSimWeaponClass@@@Z ENDP ; VuBin<SimWeaponClass>::reset
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ PROC ; VuBin<SimWeaponClass>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ENDP ; VuBin<SimWeaponClass>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ PROC ; VuBin<SimWeaponClass>::operator->, COMDAT
; _this$ = ecx

; 50   : 	E *operator->() const {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 51   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 52   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ENDP ; VuBin<SimWeaponClass>::operator->
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ PROC		; VuBin<SimWeaponClass>::operator bool, COMDAT
; _this$ = ecx

; 40   : 	operator bool() const{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 		return e != NULL;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@operator
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv66[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv66[ebp]

; 42   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ ENDP		; VuBin<SimWeaponClass>::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??4?$VuBin@VSimWeaponClass@@@@QAEABV0@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rhs$ = 8						; size = 4
??4?$VuBin@VSimWeaponClass@@@@QAEABV0@ABV0@@Z PROC	; VuBin<SimWeaponClass>::operator=, COMDAT
; _this$ = ecx

; 24   : 	const VuBin &operator=(const VuBin &rhs){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 25   : 		reset(rhs.e);

	mov	eax, DWORD PTR _rhs$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?reset@?$VuBin@VSimWeaponClass@@@@QAEXPAVSimWeaponClass@@@Z ; VuBin<SimWeaponClass>::reset

; 26   : 		return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 27   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
??4?$VuBin@VSimWeaponClass@@@@QAEABV0@ABV0@@Z ENDP	; VuBin<SimWeaponClass>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??1?$VuBin@VSimWeaponClass@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$VuBin@VSimWeaponClass@@@@QAE@XZ PROC		; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>, COMDAT
; _this$ = ecx

; 19   : 	~VuBin(){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 20   : 		VuDeReferenceEntity((VuEntity *)e);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?VuDeReferenceEntity@@YAHPAVVuEntity@@@Z ; VuDeReferenceEntity
	add	esp, 4

; 21   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$VuBin@VSimWeaponClass@@@@QAE@XZ ENDP		; VuBin<SimWeaponClass>::~VuBin<SimWeaponClass>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??0?$VuBin@VSimWeaponClass@@@@QAE@PAVSimWeaponClass@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_e$ = 8							; size = 4
??0?$VuBin@VSimWeaponClass@@@@QAE@PAVSimWeaponClass@@@Z PROC ; VuBin<SimWeaponClass>::VuBin<SimWeaponClass>, COMDAT
; _this$ = ecx

; 11   : 	explicit VuBin(E *e = NULL) : e(e){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	DWORD PTR [eax], ecx

; 12   : 		VuReferenceEntity(e);

	mov	edx, DWORD PTR _e$[ebp]
	push	edx
	call	?VuReferenceEntity@@YAHPAVVuEntity@@@Z	; VuReferenceEntity
	add	esp, 4

; 13   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$VuBin@VSimWeaponClass@@@@QAE@PAVSimWeaponClass@@@Z ENDP ; VuBin<SimWeaponClass>::VuBin<SimWeaponClass>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GStoresList@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GStoresList@@QAEPAXI@Z PROC				; StoresList::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1StoresList@@QAE@XZ			; StoresList::~StoresList
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GStoresList@@QAEPAXI@Z ENDP				; StoresList::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\include\cstores.h
;	COMDAT ?GetNext@StoresList@@QAEPAUStoresStr@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNext@StoresList@@QAEPAUStoresStr@@XZ PROC		; StoresList::GetNext, COMDAT
; _this$ = ecx

; 133  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 134  : 			if(current)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 0
	je	SHORT $LN3@GetNext

; 135  : 			{
; 136  : 				current=current->Next;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+76]
	mov	DWORD PTR [eax+20], ecx

; 137  : 				if(current)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+20], 0
	je	SHORT $LN3@GetNext

; 138  : 					return(current);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]
	jmp	SHORT $LN4@GetNext
$LN3@GetNext:

; 139  : 			}
; 140  : 			if(GetType_ == _ALL_ && ListID_ < _OTHER_)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+16], 3
	jne	SHORT $LN1@GetNext
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 2
	jge	SHORT $LN1@GetNext

; 141  : 			{
; 142  : 				ListID_++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 143  : 				current=Stores_[ListID_];	

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [edx+20], ecx

; 144  : 				return(current);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	jmp	SHORT $LN4@GetNext
$LN1@GetNext:

; 145  : 			}
; 146  : 			return(NULL);

	xor	eax, eax
$LN4@GetNext:

; 147  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNext@StoresList@@QAEPAUStoresStr@@XZ ENDP		; StoresList::GetNext
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\include\cstores.h
;	COMDAT ?GetFirst@StoresList@@QAEPAUStoresStr@@J@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ID$ = 8						; size = 4
?GetFirst@StoresList@@QAEPAUStoresStr@@J@Z PROC		; StoresList::GetFirst, COMDAT
; _this$ = ecx

; 111  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 112  : 			GetType_=ID;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _ID$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 113  : 			if(GetType_ == _ALL_)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+16], 3
	jne	SHORT $LN7@GetFirst

; 114  : 				ListID_=_AIR_TO_AIR_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 115  : 			else

	jmp	SHORT $LN6@GetFirst
$LN7@GetFirst:

; 116  : 				ListID_=ID;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _ID$[ebp]
	mov	DWORD PTR [ecx+12], edx
$LN6@GetFirst:

; 117  : 			if(GetType_ == _ALL_)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 3
	jne	SHORT $LN5@GetFirst

; 118  : 			{
; 119  : 				current=NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0
$LN4@GetFirst:

; 120  : 				while(!current && ListID_ < _ALL_)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+20], 0
	jne	SHORT $LN3@GetFirst
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 3
	jge	SHORT $LN3@GetFirst

; 121  : 				{
; 122  : 					current=Stores_[ListID_];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [eax+20], edx

; 123  : 					if(!current)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 0
	jne	SHORT $LN2@GetFirst

; 124  : 						ListID_++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx
$LN2@GetFirst:

; 125  : 				}

	jmp	SHORT $LN4@GetFirst
$LN3@GetFirst:

; 126  : 			}
; 127  : 			else

	jmp	SHORT $LN1@GetFirst
$LN5@GetFirst:

; 128  : 				current=Stores_[ListID_];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [eax+20], edx
$LN1@GetFirst:

; 129  : 
; 130  : 			return(current);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]

; 131  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?GetFirst@StoresList@@QAEPAUStoresStr@@J@Z ENDP		; StoresList::GetFirst
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\include\cstores.h
;	COMDAT ?Sort@StoresList@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$ = -4						; size = 4
?Sort@StoresList@@QAEXXZ PROC				; StoresList::Sort, COMDAT
; _this$ = ecx

; 104  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 105  : 			long i;
; 106  : 
; 107  : 			for(i=_AIR_TO_AIR_;i < _ALL_;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@Sort
$LN2@Sort:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@Sort:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $LN4@Sort

; 108  : 				Sort(i);

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Sort@StoresList@@QAEXJ@Z		; StoresList::Sort
	jmp	SHORT $LN2@Sort
$LN4@Sort:

; 109  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?Sort@StoresList@@QAEXXZ ENDP				; StoresList::Sort
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\include\cstores.h
;	COMDAT ?Add@StoresList@@QAEXPAUStoresStr@@J@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_store$ = 8						; size = 4
_ListID$ = 12						; size = 4
?Add@StoresList@@QAEXPAUStoresStr@@J@Z PROC		; StoresList::Add, COMDAT
; _this$ = ecx

; 97   : 		void Add(STORESLIST *store,long ListID) { if(ListID < _ALL_) Add(store,&Stores_[ListID]); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	cmp	DWORD PTR _ListID$[ebp], 3
	jge	SHORT $LN2@Add
	mov	eax, DWORD PTR _ListID$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR _store$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Add@StoresList@@QAEXPAUStoresStr@@PAPAU2@@Z ; StoresList::Add
$LN2@Add:
	mov	esp, ebp
	pop	ebp
	ret	8
?Add@StoresList@@QAEXPAUStoresStr@@J@Z ENDP		; StoresList::Add
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\include\cstores.h
;	COMDAT ?Find@StoresList@@QAEPAUStoresStr@@J@Z
_TEXT	SEGMENT
_cur$ = -8						; size = 4
_this$ = -4						; size = 4
_ID$ = 8						; size = 4
?Find@StoresList@@QAEPAUStoresStr@@J@Z PROC		; StoresList::Find, COMDAT
; _this$ = ecx

; 68   : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 69   : 			STORESLIST *cur;
; 70   : 
; 71   : 			if(current)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 0
	je	SHORT $LN5@Find

; 72   : 			{
; 73   : 				if(current->ID == ID)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _ID$[ebp]
	jne	SHORT $LN5@Find

; 74   : 					return(current);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	jmp	SHORT $LN6@Find
$LN5@Find:

; 75   : 			}
; 76   : 			cur=GetFirst(_ALL_);

	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetFirst@StoresList@@QAEPAUStoresStr@@J@Z ; StoresList::GetFirst
	mov	DWORD PTR _cur$[ebp], eax
$LN3@Find:

; 77   : 			while(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN2@Find

; 78   : 			{
; 79   : 				if(cur->ID == ID)

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _ID$[ebp]
	jne	SHORT $LN1@Find

; 80   : 					return(cur);

	mov	eax, DWORD PTR _cur$[ebp]
	jmp	SHORT $LN6@Find
$LN1@Find:

; 81   : 				cur=GetNext();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNext@StoresList@@QAEPAUStoresStr@@XZ ; StoresList::GetNext
	mov	DWORD PTR _cur$[ebp], eax

; 82   : 			}

	jmp	SHORT $LN3@Find
$LN2@Find:

; 83   : 			return(NULL);

	xor	eax, eax
$LN6@Find:

; 84   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?Find@StoresList@@QAEPAUStoresStr@@J@Z ENDP		; StoresList::Find
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\include\cstores.h
;	COMDAT ??1StoresList@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1StoresList@@QAE@XZ PROC				; StoresList::~StoresList, COMDAT
; _this$ = ecx

; 62   : 		~StoresList() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1StoresList@@QAE@XZ ENDP				; StoresList::~StoresList
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\include\cstores.h
;	COMDAT ??0StoresList@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0StoresList@@QAE@XZ PROC				; StoresList::StoresList, COMDAT
; _this$ = ecx

; 53   : 		StoresList()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 54   : 		{
; 55   : 			Stores_[_AIR_TO_AIR_]=NULL;

	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax], 0

; 56   : 			Stores_[_AIR_TO_GROUND_]=NULL;

	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx], 0

; 57   : 			Stores_[_OTHER_]=NULL;

	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx], 0

; 58   : 			current=NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 59   : 			ListID_=_ALL_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 3

; 60   : 			GetType_=_ALL_;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 3

; 61   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0StoresList@@QAE@XZ ENDP				; StoresList::StoresList
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcsess.h
;	COMDAT ?GetPilotSlot@FalconSessionEntity@@QBEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPilotSlot@FalconSessionEntity@@QBEEXZ PROC		; FalconSessionEntity::GetPilotSlot, COMDAT
; _this$ = ecx

; 146  : 	uchar GetPilotSlot (void) const               { return pilotSlot; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+512]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetPilotSlot@FalconSessionEntity@@QBEEXZ ENDP		; FalconSessionEntity::GetPilotSlot
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcsess.h
;	COMDAT ?GetPlayerFlightID@FalconSessionEntity@@QBE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetPlayerFlightID@FalconSessionEntity@@QBE?AVVU_ID@@XZ PROC ; FalconSessionEntity::GetPlayerFlightID, COMDAT
; _this$ = ecx

; 134  : 	VU_ID GetPlayerFlightID(void) const           { return playerFlight; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+460]
	mov	edx, DWORD PTR [eax+464]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetPlayerFlightID@FalconSessionEntity@@QBE?AVVU_ID@@XZ ENDP ; FalconSessionEntity::GetPlayerFlightID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcsess.h
;	COMDAT ?GetPlayerName@FalconSessionEntity@@QAEPADXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPlayerName@FalconSessionEntity@@QAEPADXZ PROC	; FalconSessionEntity::GetPlayerName, COMDAT
; _this$ = ecx

; 131  : 	_TCHAR* GetPlayerName(void)                   { return name; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 416				; 000001a0H
	mov	esp, ebp
	pop	ebp
	ret	0
?GetPlayerName@FalconSessionEntity@@QAEPADXZ ENDP	; FalconSessionEntity::GetPlayerName
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.h
;	COMDAT ?GetID@C_Window@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetID@C_Window@@QAEJXZ PROC				; C_Window::GetID, COMDAT
; _this$ = ecx

; 302  : 		long GetID() { return(ID_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetID@C_Window@@QAEJXZ ENDP				; C_Window::GetID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.h
;	COMDAT ?GetControlList@C_Window@@QAEPAUControlListStr@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetControlList@C_Window@@QAEPAUControlListStr@@XZ PROC	; C_Window::GetControlList, COMDAT
; _this$ = ecx

; 285  : 		CONTROLLIST *GetControlList() { return(Controls_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4304]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetControlList@C_Window@@QAEPAUControlListStr@@XZ ENDP	; C_Window::GetControlList
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\ctext.h
;	COMDAT ?SetTimerCallback@C_Text@@QAEXP6AHPAVC_Base@@@Z@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_Callback$ = 8						; size = 4
?SetTimerCallback@C_Text@@QAEXP6AHPAVC_Base@@@Z@Z PROC	; C_Text::SetTimerCallback, COMDAT
; _this$ = ecx

; 50   : 		void SetTimerCallback(BOOL (*Callback)(C_Base *me)) { TimerCallback_=Callback; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _Callback$[ebp]
	mov	DWORD PTR [eax+72], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetTimerCallback@C_Text@@QAEXP6AHPAVC_Base@@@Z@Z ENDP	; C_Text::SetTimerCallback
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\clistbox.h
;	COMDAT ?GetTextID@C_ListBox@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTextID@C_ListBox@@QAEJXZ PROC			; C_ListBox::GetTextID, COMDAT
; _this$ = ecx

; 109  : 		long GetTextID() { return(LabelVal_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+104]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetTextID@C_ListBox@@QAEJXZ ENDP			; C_ListBox::GetTextID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cbase.h
;	COMDAT ?GetParent@C_Base@@QAEPAVC_Window@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetParent@C_Base@@QAEPAVC_Window@@XZ PROC		; C_Base::GetParent, COMDAT
; _this$ = ecx

; 149  : 		C_Window *GetParent()		{ return(Parent_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+48]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetParent@C_Base@@QAEPAVC_Window@@XZ ENDP		; C_Base::GetParent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cbase.h
;	COMDAT ?GetH@C_Base@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetH@C_Base@@QAEJXZ PROC				; C_Base::GetH, COMDAT
; _this$ = ecx

; 144  : 		long GetH()					{ return(h_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+36]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetH@C_Base@@QAEJXZ ENDP				; C_Base::GetH
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cbase.h
;	COMDAT ?GetGroup@C_Base@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGroup@C_Base@@QAEJXZ PROC				; C_Base::GetGroup, COMDAT
; _this$ = ecx

; 137  : 		long  GetGroup()			{ return(Section_[_GROUP_]); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+eax+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetGroup@C_Base@@QAEJXZ ENDP				; C_Base::GetGroup
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cbase.h
;	COMDAT ?GetID@C_Base@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetID@C_Base@@QAEJXZ PROC				; C_Base::GetID, COMDAT
; _this$ = ecx

; 134  : 		long  GetID()				{ return(ID_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetID@C_Base@@QAEJXZ ENDP				; C_Base::GetID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cbase.h
;	COMDAT ?SetClient@C_Base@@QAEXF@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_client$ = 8						; size = 2
?SetClient@C_Base@@QAEXF@Z PROC				; C_Base::SetClient, COMDAT
; _this$ = ecx

; 98   : 		void SetClient(short client)							{ Client_=client; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _client$[ebp]
	mov	WORD PTR [eax+40], cx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetClient@C_Base@@QAEXF@Z ENDP				; C_Base::SetClient
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cbase.h
;	COMDAT ?SetGroup@C_Base@@QAEXJ@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_id$ = 8						; size = 4
?SetGroup@C_Base@@QAEXJ@Z PROC				; C_Base::SetGroup, COMDAT
; _this$ = ecx

; 96   : 		void SetGroup(long id)									{ Section_[_GROUP_]=id; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _id$[ebp]
	mov	DWORD PTR [ecx+eax+8], edx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetGroup@C_Base@@QAEXJ@Z ENDP				; C_Base::SetGroup
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\flight.h
;	COMDAT ?GetLoadouts@FlightClass@@QAEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetLoadouts@FlightClass@@QAEEXZ PROC			; FlightClass::GetLoadouts, COMDAT
; _this$ = ecx

; 101  : 		uchar GetLoadouts (void)					{ return loadouts; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+376]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLoadouts@FlightClass@@QAEEXZ ENDP			; FlightClass::GetLoadouts
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\flight.h
;	COMDAT ?GetLoadout@FlightClass@@QAEPAULoadoutStruct@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetLoadout@FlightClass@@QAEPAULoadoutStruct@@XZ PROC	; FlightClass::GetLoadout, COMDAT
; _this$ = ecx

; 100  : 		LoadoutStruct *GetLoadout (void)			{ return loadout; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+372]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLoadout@FlightClass@@QAEPAULoadoutStruct@@XZ ENDP	; FlightClass::GetLoadout
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetFirstUnitWP@UnitClass@@QAEPAVWayPointClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFirstUnitWP@UnitClass@@QAEPAVWayPointClass@@XZ PROC	; UnitClass::GetFirstUnitWP, COMDAT
; _this$ = ecx

; 431  : 	WayPoint GetFirstUnitWP()				{ return wp_list; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+244]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFirstUnitWP@UnitClass@@QAEPAVWayPointClass@@XZ ENDP	; UnitClass::GetFirstUnitWP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\loadout.h
;	COMDAT ??4LoadoutStruct@@QAEABU0@ABU0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rhs$ = 8						; size = 4
??4LoadoutStruct@@QAEABU0@ABU0@@Z PROC			; LoadoutStruct::operator=, COMDAT
; _this$ = ecx

; 39   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 40   :  			if (&rhs != this)

	mov	eax, DWORD PTR _rhs$[ebp]
	cmp	eax, DWORD PTR _this$[ebp]
	je	SHORT $LN1@operator

; 41   : 			{ 
; 42   : 				memcpy(WeaponID,	rhs.WeaponID,	 (sizeof(short) * HARDPOINT_MAX)); 

	push	32					; 00000020H
	mov	ecx, DWORD PTR _rhs$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 43   : 				memcpy(WeaponCount,	rhs.WeaponCount, (sizeof(uchar) * HARDPOINT_MAX)); 

	push	16					; 00000010H
	mov	eax, DWORD PTR _rhs$[ebp]
	add	eax, 32					; 00000020H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN1@operator:

; 44   : 			}
; 45   : 
; 46   : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 47   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4LoadoutStruct@@QAEABU0@ABU0@@Z ENDP			; LoadoutStruct::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\loadout.h
;	COMDAT ??0LoadoutStruct@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0LoadoutStruct@@QAE@XZ PROC				; LoadoutStruct::LoadoutStruct, COMDAT
; _this$ = ecx

; 32   : 		LoadoutStruct(void)		

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 33   : 		{ 
; 34   : 			memset(WeaponID,	0,	(sizeof(short) * HARDPOINT_MAX)); 

	push	32					; 00000020H
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 35   : 			memset(WeaponCount,	0,	(sizeof(uchar) * HARDPOINT_MAX)); 

	push	16					; 00000010H
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 36   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0LoadoutStruct@@QAE@XZ ENDP				; LoadoutStruct::LoadoutStruct
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?GetWPDepartureTime@WayPointClass@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWPDepartureTime@WayPointClass@@QAEKXZ PROC		; WayPointClass::GetWPDepartureTime, COMDAT
; _this$ = ecx

; 203  : 	CampaignTime GetWPDepartureTime()				{ return Depart; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetWPDepartureTime@WayPointClass@@QAEKXZ ENDP		; WayPointClass::GetWPDepartureTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campaign.h
;	COMDAT ?CampLeaveCriticalSection@@YAXXZ
_TEXT	SEGMENT
?CampLeaveCriticalSection@@YAXXZ PROC			; CampLeaveCriticalSection, COMDAT

; 51   : inline void CampLeaveCriticalSection(){ F4LeaveCriticalSection(campCritical); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ?campCritical@@3PAUF4CSECTIONHANDLE@@A ; campCritical
	push	eax
	call	_F4LeaveCriticalSection
	add	esp, 4
	pop	ebp
	ret	0
?CampLeaveCriticalSection@@YAXXZ ENDP			; CampLeaveCriticalSection
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campaign.h
;	COMDAT ?CampEnterCriticalSection@@YAXXZ
_TEXT	SEGMENT
?CampEnterCriticalSection@@YAXXZ PROC			; CampEnterCriticalSection, COMDAT

; 50   : inline void CampEnterCriticalSection(){ F4EnterCriticalSection(campCritical); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ?campCritical@@3PAUF4CSECTIONHANDLE@@A ; campCritical
	push	eax
	call	_F4EnterCriticalSection
	add	esp, 4
	pop	ebp
	ret	0
?CampEnterCriticalSection@@YAXXZ ENDP			; CampEnterCriticalSection
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tchar.h
;	COMDAT __tcsclen
_TEXT	SEGMENT
__String$ = 8						; size = 4
__tcsclen PROC						; COMDAT

; 1748 : {

	push	ebp
	mov	ebp, esp

; 1749 :     return _mbslen((const unsigned char *)_String);

	mov	eax, DWORD PTR __String$[ebp]
	push	eax
	call	__mbslen
	add	esp, 4

; 1750 : }

	pop	ebp
	ret	0
__tcsclen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ PROC ; VuBin<VuSessionEntity>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ENDP ; VuBin<VuSessionEntity>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Id@VuEntity@@QBE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?Id@VuEntity@@QBE?AVVU_ID@@XZ PROC			; VuEntity::Id, COMDAT
; _this$ = ecx

; 131  : 	VU_ID Id() const	{ return share_.id_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?Id@VuEntity@@QBE?AVVU_ID@@XZ ENDP			; VuEntity::Id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
;	COMDAT ??8VU_ID@@QBE_NABV0@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -2						; size = 1
tv73 = -1						; size = 1
_rhs$ = 8						; size = 4
??8VU_ID@@QBE_NABV0@@Z PROC				; VU_ID::operator==, COMDAT
; _this$ = ecx

; 104  : 	bool operator == (const VU_ID &rhs) const { 

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 105  : 		return (
; 106  : 			num_ == rhs.num_ ? 
; 107  : 			(creator_ == rhs.creator_ ? true : false) : 
; 108  : 			false
; 109  : 		); 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN5@operator
	mov	eax, DWORD PTR _rhs$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??8VU_SESSION_ID@@QBEHABV0@@Z		; VU_SESSION_ID::operator==
	test	eax, eax
	je	SHORT $LN3@operator
	mov	BYTE PTR tv73[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	BYTE PTR tv73[ebp], 0
$LN4@operator:
	mov	cl, BYTE PTR tv73[ebp]
	mov	BYTE PTR tv74[ebp], cl
	jmp	SHORT $LN6@operator
$LN5@operator:
	mov	BYTE PTR tv74[ebp], 0
$LN6@operator:
	mov	al, BYTE PTR tv74[ebp]

; 110  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
??8VU_ID@@QBE_NABV0@@Z ENDP				; VU_ID::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
;	COMDAT ??8VU_SESSION_ID@@QBEHABV0@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_rhs$ = 8						; size = 4
??8VU_SESSION_ID@@QBEHABV0@@Z PROC			; VU_SESSION_ID::operator==, COMDAT
; _this$ = ecx

; 55   : 	int operator == (const VU_SESSION_ID &rhs) const{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return (value_ == rhs.value_ ? TRUE : FALSE); 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv67[ebp], 0
$LN4@operator:
	mov	eax, DWORD PTR tv67[ebp]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
??8VU_SESSION_ID@@QBEHABV0@@Z ENDP			; VU_SESSION_ID::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\drawbsp.h
;	COMDAT ?GetNTextureSet@DrawableBSP@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNTextureSet@DrawableBSP@@QAEHXZ PROC		; DrawableBSP::GetNTextureSet, COMDAT
; _this$ = ecx

; 50   : 	int GetNTextureSet() { return instance.GetNTextureSet(); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	?GetNTextureSet@ObjectInstance@@QAEHXZ	; ObjectInstance::GetNTextureSet
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNTextureSet@DrawableBSP@@QAEHXZ ENDP		; DrawableBSP::GetNTextureSet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\drawbsp.h
;	COMDAT ?SetTextureSet@DrawableBSP@@QAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_set$ = 8						; size = 4
?SetTextureSet@DrawableBSP@@QAEXK@Z PROC		; DrawableBSP::SetTextureSet, COMDAT
; _this$ = ecx

; 49   : 	void SetTextureSet( UInt32 set )	{ instance.SetTextureSet( set ); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _set$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	?SetTextureSet@ObjectInstance@@QAEXH@Z	; ObjectInstance::SetTextureSet
	mov	esp, ebp
	pop	ebp
	ret	4
?SetTextureSet@DrawableBSP@@QAEXK@Z ENDP		; DrawableBSP::SetTextureSet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\objectinstance.h
;	COMDAT ?GetNTextureSet@ObjectInstance@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNTextureSet@ObjectInstance@@QAEHXZ PROC		; ObjectInstance::GetNTextureSet, COMDAT
; _this$ = ecx

; 39   : 	int	GetNTextureSet() { return ParentObject->nTextureSets; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	movsx	eax, WORD PTR [ecx+44]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNTextureSet@ObjectInstance@@QAEHXZ ENDP		; ObjectInstance::GetNTextureSet
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_System_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_System_error_category@std@@UAEPAXI@Z PROC		; std::_System_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_System_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_System_error_category@std@@UAEPAXI@Z ENDP		; std::_System_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_System_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_System_error_category@std@@UAE@XZ PROC		; std::_System_error_category::~_System_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_System_error_category@std@@UAE@XZ ENDP		; std::_System_error_category::~_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::_System_error_category::default_error_condition, COMDAT
; _this$ = ecx

; 641  : 		{	// make error_condition for error code (generic if possible)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 642  : 		if (_Syserror_map(_Errval))

	mov	eax, DWORD PTR __Errval$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@default_er

; 643  : 			return (error_condition(_Errval, generic_category()));

	call	?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@default_er

; 644  : 		else

	jmp	SHORT $LN3@default_er
$LN2@default_er:

; 645  : 			return (error_condition(_Errval, system_category()));

	call	?system_category@std@@YAABVerror_category@1@XZ ; std::system_category
	push	eax
	mov	edx, DWORD PTR __Errval$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@default_er:

; 646  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::_System_error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_System_error_category::message, COMDAT
; _this$ = ecx

; 634  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 635  : 		const char *_Name = _Winerror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Winerror_map@std@@YAPBDH@Z		; std::_Winerror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 636  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 637  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_System_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_System_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_System_error_category@std@@UBEPBDXZ PROC		; std::_System_error_category::name, COMDAT
; _this$ = ecx

; 629  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 630  : 		return ("system");

	mov	eax, OFFSET ??_C@_06FHFOAHML@system?$AA@

; 631  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_System_error_category@std@@UBEPBDXZ ENDP		; std::_System_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_System_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_System_error_category@std@@QAE@XZ PROC		; std::_System_error_category::_System_error_category, COMDAT
; _this$ = ecx

; 624  : 	_System_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_System_error_category@std@@6B@

; 625  : 		{	// default constructor
; 626  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_System_error_category@std@@QAE@XZ ENDP		; std::_System_error_category::_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Iostream_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Iostream_error_category@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iostream_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Iostream_error_category@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Iostream_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Iostream_error_category@std@@UAE@XZ PROC		; std::_Iostream_error_category::~_Iostream_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Iostream_error_category@std@@UAE@XZ ENDP		; std::_Iostream_error_category::~_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT
; _this$ = ecx

; 611  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 612  : 		if (_Errcode == (int)io_errc::stream)

	cmp	DWORD PTR __Errcode$[ebp], 1
	jne	SHORT $LN2@message

; 613  : 			return ("iostream stream error");

	push	OFFSET ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@message

; 614  : 		else

	jmp	SHORT $LN3@message
$LN2@message:

; 615  : 			return (_Generic_error_category::message(_Errcode));

	mov	ecx, DWORD PTR __Errcode$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@message:

; 616  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Iostream_error_category@std@@UBEPBDXZ PROC	; std::_Iostream_error_category::name, COMDAT
; _this$ = ecx

; 606  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 607  : 		return ("iostream");

	mov	eax, OFFSET ??_C@_08LLGCOLLL@iostream?$AA@

; 608  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Iostream_error_category@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Iostream_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iostream_error_category@std@@QAE@XZ PROC		; std::_Iostream_error_category::_Iostream_error_category, COMDAT
; _this$ = ecx

; 601  : 	_Iostream_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Iostream_error_category@std@@6B@

; 602  : 		{	// default constructor
; 603  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iostream_error_category@std@@QAE@XZ ENDP		; std::_Iostream_error_category::_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Generic_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Generic_error_category@std@@UAE@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Generic_error_category@std@@UAE@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 590  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 591  : 		const char *_Name = _Syserror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 592  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 593  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 585  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		return ("generic");

	mov	eax, OFFSET ??_C@_07DCLBNMLN@generic?$AA@

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Generic_error_category@std@@QAE@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT
; _this$ = ecx

; 580  : 	_Generic_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0error_category@std@@QAE@XZ		; std::error_category::error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Generic_error_category@std@@6B@

; 581  : 		{	// default constructor
; 582  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Generic_error_category@std@@QAE@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_condition@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv78 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8error_condition@std@@QBE_NABV01@@Z PROC		; std::error_condition::operator==, COMDAT
; _this$ = ecx

; 376  : 		{	// test if *this == _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 377  : 		return (category() == _Right.category()
; 378  : 			&& value() == _Right.value());

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	mov	ecx, eax
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	cmp	esi, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv78[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv78[ebp]

; 379  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??8error_condition@std@@QBE_NABV01@@Z ENDP		; std::error_condition::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 354  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 356  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 349  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 350  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 351  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 316  : 		{	// construct from error code and category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Cat$[ebp]
	mov	DWORD PTR [edx+4], eax

; 317  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 256  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 257  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 258  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 251  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 252  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 253  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gerror_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gerror_category@std@@UAEPAXI@Z PROC			; std::error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gerror_category@std@@UAEPAXI@Z ENDP			; std::error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv65 = -4						; size = 4
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 184  : 		{	// compare categories for equality

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 185  : 		return (this == &_Right);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv65[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv65[ebp]

; 186  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -4						; size = 4
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 415  : 	{	// test if conditions same for this category

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 416  : 	return (*this == _Code.category() && _Code.value() == _Errval);

	mov	ecx, DWORD PTR __Code$[ebp]
	call	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@equivalent
	mov	ecx, DWORD PTR __Code$[ebp]
	call	?value@error_code@std@@QBEHXZ		; std::error_code::value
	cmp	eax, DWORD PTR __Errval$[ebp]
	jne	SHORT $LN3@equivalent
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN4@equivalent
$LN3@equivalent:
	mov	DWORD PTR tv74[ebp], 0
$LN4@equivalent:
	mov	al, BYTE PTR tv74[ebp]

; 417  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 408  : 	{	// test if error code same condition

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 409  : 	return (default_error_condition(_Errval) == _Cond);

	mov	eax, DWORD PTR __Cond$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	ecx, eax
	call	??8error_condition@std@@QBE_NABV01@@Z	; std::error_condition::operator==

; 410  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 401  : 	{	// make error_condition for error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 402  : 	return (error_condition(_Errval, *this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 403  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 167  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 168  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0error_category@std@@QAE@XZ PROC			; std::error_category::error_category, COMDAT
; _this$ = ecx

; 162  : 	error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 163  : 		{	// default constructor
; 164  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0error_category@std@@QAE@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?system_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?system_category@std@@YAABVerror_category@1@XZ PROC	; std::system_category, COMDAT

; 679  : 	{	// get system_category

	push	ebp
	mov	ebp, esp

; 680  : 	return (_Error_objects<int>::_System_object);

	mov	eax, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object

; 681  : 	}

	pop	ebp
	ret	0
?system_category@std@@YAABVerror_category@1@XZ ENDP	; std::system_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?generic_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?generic_category@std@@YAABVerror_category@1@XZ PROC	; std::generic_category, COMDAT

; 669  : 	{	// get generic_category

	push	ebp
	mov	ebp, esp

; 670  : 	return (_Error_objects<int>::_Generic_object);

	mov	eax, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object

; 671  : 	}

	pop	ebp
	ret	0
?generic_category@std@@YAABVerror_category@1@XZ ENDP	; std::generic_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocale
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC				; std::locale::id::id, COMDAT
; _this$ = ecx

; 74   : 			{	// construct with specified stamp value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx

; 75   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2275 : 		{	// report an out_of_range error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2276 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN2@Xran:

; 2277 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2270 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2271 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN2@Xlen:

; 2272 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Ptr$1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2253 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2254 : 		if (!_Built)

	movzx	eax, BYTE PTR __Built$[ebp]
	test	eax, eax
	jne	SHORT $LN4@Tidy
	jmp	SHORT $LN3@Tidy
$LN4@Tidy:

; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN3@Tidy

; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Ptr$1[ebp], eax

; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 2260 : 			if (0 < _Newsize)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN1@Tidy

; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$1[ebp]
	push	ecx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Tidy:

; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Ptr$1[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN3@Tidy:

; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2266 : 		_Eos(_Newsize);

	mov	edx, DWORD PTR __Newsize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2267 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2237 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	cmp	DWORD PTR __Ptr$[ebp], 0
	je	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	cmp	DWORD PTR __Ptr$[ebp], eax
	jb	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
$LN2@Inside:

; 2240 : 			return (false);	// don't ask

	xor	al, al
	jmp	SHORT $LN4@Inside

; 2241 : 		else

	jmp	SHORT $LN4@Inside
$LN3@Inside:

; 2242 : 			return (true);

	mov	al, 1
$LN4@Inside:

; 2243 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
tv136 = -12						; size = 4
tv129 = -8						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2224 : 		if (max_size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN6@Grow

; 2225 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN6@Grow:

; 2226 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN5@Grow

; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	jmp	SHORT $LN4@Grow
$LN5@Grow:

; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	movzx	edx, BYTE PTR __Trim$[ebp]
	test	edx, edx
	je	SHORT $LN3@Grow
	cmp	DWORD PTR __Newsize$[ebp], 16		; 00000010H
	jae	SHORT $LN3@Grow

; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jae	SHORT $LN9@Grow
	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv129[ebp], edx
	jmp	SHORT $LN10@Grow
$LN9@Grow:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR tv129[ebp], ecx
$LN10@Grow:
	mov	edx, DWORD PTR tv129[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
	jmp	SHORT $LN4@Grow
$LN3@Grow:

; 2231 : 		else if (_Newsize == 0)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $LN4@Grow

; 2232 : 			_Eos(0);	// new size is zero, just null terminate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN4@Grow:

; 2233 : 		return (0 < _Newsize);	// return true only if more work to do

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN11@Grow
	mov	DWORD PTR tv136[ebp], 1
	jmp	SHORT $LN12@Grow
$LN11@Grow:
	mov	DWORD PTR tv136[ebp], 0
$LN12@Grow:
	mov	al, BYTE PTR tv136[ebp]
$LN8@Grow:

; 2234 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [eax+16], ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 2219 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
tv205 = -48						; size = 4
tv204 = -44						; size = 4
tv203 = -40						; size = 4
tv202 = -36						; size = 4
__Ptr$ = -32						; size = 4
__Newres$ = -28						; size = 4
_this$ = -24						; size = 4
$T2 = -19						; size = 1
$T3 = -18						; size = 1
$T4 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Newres$[ebp], eax

; 2184 : 		if (max_size() < _Newres)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newres$[ebp]
	jae	SHORT $LN9@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx
	jmp	SHORT $LN8@Copy
$LN9@Copy:

; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)

	mov	eax, DWORD PTR __Newres$[ebp]
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	shr	ecx, 1
	cmp	ecx, eax
	ja	SHORT $LN7@Copy
	jmp	SHORT $LN8@Copy
$LN7@Copy:

; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+20]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, esi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], eax
	ja	SHORT $LN5@Copy

; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	shr	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR __Newres$[ebp], eax

; 2191 : 		else

	jmp	SHORT $LN8@Copy
$LN5@Copy:

; 2192 : 			_Newres = max_size();	// settle for max_size()

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	DWORD PTR __Newres$[ebp], eax
$LN8@Copy:

; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv202[ebp], eax
	mov	eax, DWORD PTR __Newres$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR tv202[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv203[ebp], eax
	mov	ecx, DWORD PTR tv203[ebp]
	mov	DWORD PTR __Ptr$[ebp], ecx
	jmp	SHORT $LN12@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2197 : 		_CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], edx

; 2199 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv204[ebp], eax
	mov	ecx, DWORD PTR __Newres$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR tv204[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv205[ebp], eax
	mov	edx, DWORD PTR tv205[ebp]
	mov	DWORD PTR __Ptr$[ebp], edx
	jmp	SHORT $LN14@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2203 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 2204 : 			_CATCH_END

	mov	eax, $LN17@Copy
	ret	0
$LN14@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2
$LN17@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2:

; 2205 : 		_CATCH_END

	mov	eax, $LN19@Copy
	ret	0
$LN12@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3
$LN19@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jbe	SHORT $LN1@Copy

; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements

	mov	eax, DWORD PTR __Oldlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Copy:

; 2210 : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);

	lea	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>

; 2212 : 		this->_Myres = _Newres;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newres$[ebp]
	mov	DWORD PTR [edx+20], eax

; 2213 : 		_Eos(_Oldlen);

	mov	ecx, DWORD PTR __Oldlen$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN11@Copy:

; 2214 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv75 = -12						; size = 4
__Num$ = -8						; size = 4
$T1 = -1						; size = 1
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1737 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1738 : 		size_type _Num = this->_Getal().max_size();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
	mov	DWORD PTR __Num$[ebp], eax

; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$[ebp], 1
	ja	SHORT $LN3@max_size
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	ecx, DWORD PTR __Num$[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv75[ebp], ecx
$LN4@max_size:
	mov	eax, DWORD PTR tv75[ebp]

; 1740 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1732 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1733 : 		return (this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]

; 1734 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$1 = -12					; size = 4
__Ptr$2 = -8						; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1317 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1318 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN4@erase

; 1319 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN4@erase:

; 1320 : 		if (this->_Mysize - _Off <= _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Off$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	ja	SHORT $LN3@erase

; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)

	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
	jmp	SHORT $LN2@erase
$LN3@erase:

; 1322 : 		else if (0 < _Count)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN2@erase

; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Ptr$2[ebp], eax

; 1325 : 			size_type _Newsize = this->_Mysize - _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Newsize$1[ebp], eax

; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	sub	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$2[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$2[ebp]
	push	eax
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 1327 : 			_Eos(_Newsize);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@erase:

; 1328 : 			}
; 1329 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN6@erase:

; 1330 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1309 : 		{	// erase elements [_Off, ...)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1310 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN1@erase

; 1311 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN1@erase:

; 1312 : 		_Eos(_Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1313 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@erase:

; 1314 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1142 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1145 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@assign

; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	jmp	SHORT $LN3@assign
$LN2@assign:

; 1132 : 
; 1133 : 		if (_Grow(_Count))

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@assign

; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1136 : 			_Eos(_Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@assign:

; 1137 : 			}
; 1138 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@assign:

; 1139 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1105 : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $LN5@assign

; 1106 : 			_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN5@assign:

; 1107 : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 1108 : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Num$[ebp]
	jae	SHORT $LN4@assign

; 1109 : 			_Num = _Count;	// trim _Num to size

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
$LN4@assign:

; 1110 : 
; 1111 : 		if (this == &_Right)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@assign

; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	mov	eax, DWORD PTR __Roff$[ebp]
	add	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	mov	ecx, DWORD PTR __Roff$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	jmp	SHORT $LN2@assign
$LN3@assign:

; 1113 : 		else if (_Grow(_Num))

	push	0
	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@assign

; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);

	mov	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1117 : 			_Eos(_Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@assign:

; 1118 : 			}
; 1119 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN7@assign:

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 791  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >

; 792  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 793  : 		assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 794  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 688  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 689  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 690  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 635  : 	_String_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >

; 636  : 		{	// construct allocator from _Al
; 637  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		{	// determine current pointer to buffer for nonmutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 522  : 		return (this->_BUF_SIZE <= this->_Myres
; 523  : 			? _STD addressof(*this->_Bx._Ptr)
; 524  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 525  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		{	// determine current pointer to buffer for mutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 515  : 		return (this->_BUF_SIZE <= this->_Myres
; 516  : 			? _STD addressof(*this->_Bx._Ptr)
; 517  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 518  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 496  : 	_String_val()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 497  : 		{	// initialize values
; 498  : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 499  : 		_Myres = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 500  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 913  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 914  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
	add	esp, 4

; 915  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 886  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 887  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate

; 888  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 875  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 877  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 830  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>

; 831  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 761  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp

; 762  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@D@std@@QBEIXZ	; std::allocator<char>::max_size

; 763  : 		}

	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

	or	eax, -1

; 629  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 590  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8

; 592  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 565  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 563  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 564  : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 565  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 551  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@move
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@move
$LN3@move:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@move:
	mov	eax, DWORD PTR tv69[ebp]

; 554  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 528  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@copy
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@copy
$LN3@copy:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@copy:
	mov	eax, DWORD PTR tv69[ebp]

; 531  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 521  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp
	push	ecx

; 522  : 		return (*_First == 0 ? 0
; 523  : 			: _CSTD strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@length
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN4@length
$LN3@length:
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR tv68[ebp], eax
$LN4@length:
	mov	eax, DWORD PTR tv68[ebp]

; 524  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 65   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 60   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 61   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\drawobj.h
;	COMDAT ?Radius@DrawableObject@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Radius@DrawableObject@@QBEMXZ PROC			; DrawableObject::Radius, COMDAT
; _this$ = ecx

; 27   : 	float Radius() const { return radius; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+16]
	mov	esp, ebp
	pop	ebp
	ret	0
?Radius@DrawableObject@@QBEMXZ ENDP			; DrawableObject::Radius
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
$LN2@vector:
	mov	eax, DWORD PTR ___n$[ebp]
	sub	eax, 1
	mov	DWORD PTR ___n$[ebp], eax
	js	SHORT $LN3@vector
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	mov	ecx, DWORD PTR ___t$[ebp]
	add	ecx, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], ecx
	jmp	SHORT $LN2@vector
$LN3@vector:
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
