; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\comms\capibwcontrol.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_start_bandwidth
PUBLIC	_enter_state
PUBLIC	_player_joined
PUBLIC	_player_left
PUBLIC	_use_bandwidth
PUBLIC	_check_bandwidth
PUBLIC	_cut_bandwidth
PUBLIC	?Set@BW@@AAEXH@Z				; BW::Set
PUBLIC	?Renew@BW@@AAEXXZ				; BW::Renew
PUBLIC	?RenewIfTime@BW@@AAEXXZ				; BW::RenewIfTime
PUBLIC	??0BW@@QAE@XZ					; BW::BW
PUBLIC	?Reset@BW@@QAEXXZ				; BW::Reset
PUBLIC	?Check@BW@@QAE_NH_NW4BWTypes@1@@Z		; BW::Check
PUBLIC	?Use@BW@@QAEXH_NH@Z				; BW::Use
PUBLIC	?Cut@BW@@QAEXXZ					; BW::Cut
PUBLIC	?EnterState@BW@@QAEXW4bwstates@@@Z		; BW::EnterState
PUBLIC	?PlayerJoined@BW@@QAEXXZ			; BW::PlayerJoined
PUBLIC	?PlayerLeft@BW@@QAEXXZ				; BW::PlayerLeft
PUBLIC	??1BW@@QAE@XZ					; BW::~BW
PUBLIC	__real@00000000
PUBLIC	__real@3f800000
EXTRN	_atexit:PROC
EXTRN	_clock:PROC
EXTRN	??0BwFSM@@QAE@XZ:PROC				; BwFSM::BwFSM
EXTRN	??1BwFSM@@QAE@XZ:PROC				; BwFSM::~BwFSM
EXTRN	?Reset@BwFSM@@QAEXXZ:PROC			; BwFSM::Reset
EXTRN	?EnterState@BwFSM@@QAEXW4bwstates@@@Z:PROC	; BwFSM::EnterState
EXTRN	?PlayerJoined@BwFSM@@QAEXXZ:PROC		; BwFSM::PlayerJoined
EXTRN	?PlayerLeft@BwFSM@@QAEXXZ:PROC			; BwFSM::PlayerLeft
EXTRN	?GetBandwidth@BwFSM@@QAEHXZ:PROC		; BwFSM::GetBandwidth
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_bw_object DB	03cH DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_bw_object$initializer$ DD FLAT:??__Ebw_object@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0BW@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0BW@@QAE@XZ$0
__ehfuncinfo$??0BW@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0BW@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__Fbw_object@@YAXXZ
text$yd	SEGMENT
??__Fbw_object@@YAXXZ PROC				; `dynamic atexit destructor for 'bw_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET _bw_object
	call	??1BW@@QAE@XZ
	pop	ebp
	ret	0
??__Fbw_object@@YAXXZ ENDP				; `dynamic atexit destructor for 'bw_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\capibwcontrol.cpp
;	COMDAT ??__Ebw_object@@YAXXZ
text$yc	SEGMENT
??__Ebw_object@@YAXXZ PROC				; `dynamic initializer for 'bw_object'', COMDAT

; 210  : static BW bw_object;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET _bw_object
	call	??0BW@@QAE@XZ				; BW::BW
	push	OFFSET ??__Fbw_object@@YAXXZ		; `dynamic atexit destructor for 'bw_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__Ebw_object@@YAXXZ ENDP				; `dynamic initializer for 'bw_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1BW@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1BW@@QAE@XZ PROC					; BW::~BW, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??1BwFSM@@QAE@XZ			; BwFSM::~BwFSM
	mov	esp, ebp
	pop	ebp
	ret	0
??1BW@@QAE@XZ ENDP					; BW::~BW
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\capibwcontrol.cpp
;	COMDAT ?PlayerLeft@BW@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?PlayerLeft@BW@@QAEXXZ PROC				; BW::PlayerLeft, COMDAT
; _this$ = ecx

; 203  : 	void PlayerLeft(){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 		fsm.PlayerLeft();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	?PlayerLeft@BwFSM@@QAEXXZ		; BwFSM::PlayerLeft

; 205  : 		Set(fsm.GetBandwidth());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	?GetBandwidth@BwFSM@@QAEHXZ		; BwFSM::GetBandwidth
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Set@BW@@AAEXH@Z			; BW::Set

; 206  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?PlayerLeft@BW@@QAEXXZ ENDP				; BW::PlayerLeft
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\capibwcontrol.cpp
;	COMDAT ?PlayerJoined@BW@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?PlayerJoined@BW@@QAEXXZ PROC				; BW::PlayerJoined, COMDAT
; _this$ = ecx

; 197  : 	void PlayerJoined(){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 198  : 		fsm.PlayerJoined();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	?PlayerJoined@BwFSM@@QAEXXZ		; BwFSM::PlayerJoined

; 199  : 		Set(fsm.GetBandwidth());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	?GetBandwidth@BwFSM@@QAEHXZ		; BwFSM::GetBandwidth
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Set@BW@@AAEXH@Z			; BW::Set

; 200  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?PlayerJoined@BW@@QAEXXZ ENDP				; BW::PlayerJoined
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\capibwcontrol.cpp
;	COMDAT ?EnterState@BW@@QAEXW4bwstates@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_st$ = 8						; size = 4
?EnterState@BW@@QAEXW4bwstates@@@Z PROC			; BW::EnterState, COMDAT
; _this$ = ecx

; 191  : 	void EnterState(bwstates st){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 192  : 		fsm.EnterState(st);

	mov	eax, DWORD PTR _st$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	?EnterState@BwFSM@@QAEXW4bwstates@@@Z	; BwFSM::EnterState

; 193  : 		Set(fsm.GetBandwidth());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	?GetBandwidth@BwFSM@@QAEHXZ		; BwFSM::GetBandwidth
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Set@BW@@AAEXH@Z			; BW::Set

; 194  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?EnterState@BW@@QAEXW4bwstates@@@Z ENDP			; BW::EnterState
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\capibwcontrol.cpp
;	COMDAT ?Cut@BW@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$1 = -4						; size = 4
?Cut@BW@@QAEXXZ PROC					; BW::Cut, COMDAT
; _this$ = ecx

; 182  : 	void Cut(){

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 183  : 		for (int i=0;i<BW_NUM_TYPES;++i){

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN3@Cut
$LN2@Cut:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN3@Cut:
	cmp	DWORD PTR _i$1[ebp], 4
	jge	SHORT $LN1@Cut

; 184  : 			used_by_type[i] = bytes_by_type[i];

	mov	ecx, DWORD PTR _i$1[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$1[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [esi+eax*4+12]
	mov	DWORD PTR [edx+ecx*4+28], eax

; 185  : 		}

	jmp	SHORT $LN2@Cut
$LN1@Cut:

; 186  : 		last_renew = clock();

	call	_clock
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+44], eax

; 187  : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?Cut@BW@@QAEXXZ ENDP					; BW::Cut
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\capibwcontrol.cpp
;	COMDAT ?Use@BW@@QAEXH_NH@Z
_TEXT	SEGMENT
_common$1 = -16						; size = 4
_size$ = -12						; size = 4
tv70 = -8						; size = 4
_this$ = -4						; size = 4
_s_$ = 8						; size = 4
_isReliable$ = 12					; size = 1
_type$ = 16						; size = 4
?Use@BW@@QAEXH_NH@Z PROC				; BW::Use, COMDAT
; _this$ = ecx

; 166  : 	void Use(int s_, bool isReliable, int type){

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 167  : 		RenewIfTime();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RenewIfTime@BW@@AAEXXZ			; BW::RenewIfTime

; 168  : 		// size adjustment for reliable
; 169  : 		int size = (int)((isReliable) ? s_*RELIABLE_MOD : s_);

	movzx	eax, BYTE PTR _isReliable$[ebp]
	test	eax, eax
	je	SHORT $LN4@Use
	cvtsi2ss xmm0, DWORD PTR _s_$[ebp]
	mulss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv70[ebp], xmm0
	jmp	SHORT $LN5@Use
$LN4@Use:
	cvtsi2ss xmm0, DWORD PTR _s_$[ebp]
	movss	DWORD PTR tv70[ebp], xmm0
$LN5@Use:
	cvttss2si ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR _size$[ebp], ecx

; 170  : 		// subtract from reserve first
; 171  : 		used_by_type[type] += size;

	mov	edx, DWORD PTR _type$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+28]
	add	ecx, DWORD PTR _size$[ebp]
	mov	edx, DWORD PTR _type$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx*4+28], ecx

; 172  : 		// see if used exceed amount for that type
; 173  : 		if ((used_by_type[type] > bytes_by_type[type]) && (type != BW_COMMON)){

	mov	ecx, DWORD PTR _type$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _type$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+28]
	cmp	ecx, DWORD PTR [esi+eax*4+12]
	jle	SHORT $LN1@Use
	cmp	DWORD PTR _type$[ebp], 3
	je	SHORT $LN1@Use

; 174  : 			// consume common
; 175  : 			int common = used_by_type[type] - bytes_by_type[type];

	mov	edx, DWORD PTR _type$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _type$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+edx*4+28]
	sub	edx, DWORD PTR [esi+ecx*4+12]
	mov	DWORD PTR _common$1[ebp], edx

; 176  : 			used_by_type[type] = bytes_by_type[type];

	mov	eax, DWORD PTR _type$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _type$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+12]
	mov	DWORD PTR [ecx+eax*4+28], edx

; 177  : 			used_by_type[BW_COMMON] += common;

	mov	eax, 4
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+28]
	add	edx, DWORD PTR _common$1[ebp]
	mov	eax, 4
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+28], edx
$LN1@Use:

; 178  : 		}
; 179  : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?Use@BW@@QAEXH_NH@Z ENDP				; BW::Use
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\capibwcontrol.cpp
;	COMDAT ?Check@BW@@QAE_NH_NW4BWTypes@1@@Z
_TEXT	SEGMENT
_size$ = -12						; size = 4
tv70 = -8						; size = 4
_this$ = -4						; size = 4
_s_$ = 8						; size = 4
_isReliable$ = 12					; size = 1
_type$ = 16						; size = 4
?Check@BW@@QAE_NH_NW4BWTypes@1@@Z PROC			; BW::Check, COMDAT
; _this$ = ecx

; 146  : 	bool Check(int s_, bool isReliable, BWTypes type){

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 147  : 		RenewIfTime();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RenewIfTime@BW@@AAEXXZ			; BW::RenewIfTime

; 148  : 		// size adjustment for reliable
; 149  : 		int size = (int)((isReliable) ? s_*RELIABLE_MOD : s_);

	movzx	eax, BYTE PTR _isReliable$[ebp]
	test	eax, eax
	je	SHORT $LN6@Check
	cvtsi2ss xmm0, DWORD PTR _s_$[ebp]
	mulss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv70[ebp], xmm0
	jmp	SHORT $LN7@Check
$LN6@Check:
	cvtsi2ss xmm0, DWORD PTR _s_$[ebp]
	movss	DWORD PTR tv70[ebp], xmm0
$LN7@Check:
	cvttss2si ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR _size$[ebp], ecx

; 150  : 
; 151  : 		// we are flexible here
; 152  : 		// if we have any spare bw of that type, ok
; 153  : 		// this avoids starvation for low bw connections
; 154  : 		if (
; 155  : 			(used_by_type[type] < bytes_by_type[type]) ||
; 156  : 			(used_by_type[BW_COMMON] < bytes_by_type[BW_COMMON])
; 157  : 		){

	mov	edx, DWORD PTR _type$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _type$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+edx*4+28]
	cmp	edx, DWORD PTR [esi+ecx*4+12]
	jl	SHORT $LN2@Check
	mov	eax, 4
	imul	eax, 3
	mov	ecx, 4
	imul	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+eax+28]
	cmp	eax, DWORD PTR [esi+ecx+12]
	jge	SHORT $LN3@Check
$LN2@Check:

; 158  : 			return true;

	mov	al, 1
	jmp	SHORT $LN1@Check

; 159  : 		}
; 160  : 		else {

	jmp	SHORT $LN1@Check
$LN3@Check:

; 161  : 			return false;

	xor	al, al
$LN1@Check:

; 162  : 		}
; 163  : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?Check@BW@@QAE_NH_NW4BWTypes@1@@Z ENDP			; BW::Check
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\capibwcontrol.cpp
;	COMDAT ?Reset@BW@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Reset@BW@@QAEXXZ PROC					; BW::Reset, COMDAT
; _this$ = ecx

; 140  : 	void Reset(){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 141  : 		fsm.Reset();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	?Reset@BwFSM@@QAEXXZ			; BwFSM::Reset

; 142  : 		Set(fsm.GetBandwidth());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	?GetBandwidth@BwFSM@@QAEHXZ		; BwFSM::GetBandwidth
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Set@BW@@AAEXH@Z			; BW::Set

; 143  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?Reset@BW@@QAEXXZ ENDP					; BW::Reset
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\capibwcontrol.cpp
;	COMDAT ??0BW@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0BW@@QAE@XZ PROC					; BW::BW, COMDAT
; _this$ = ecx

; 132  : 	BW(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0BW@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??0BwFSM@@QAE@XZ			; BwFSM::BwFSM
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 133  : 		percentages_by_type[BW_POSITIONAL] = BW_POSITIONAL_RESERVED;

	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+eax], xmm0

; 134  : 		percentages_by_type[BW_DIRTY] = BW_DIRTY_RESERVED;

	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+edx], xmm0

; 135  : 		percentages_by_type[BW_OTHER] = BW_OTHER_RESERVED;

	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+ecx], xmm0

; 136  : 		Reset();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Reset@BW@@QAEXXZ			; BW::Reset

; 137  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0BW@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	jmp	??1BwFSM@@QAE@XZ			; BwFSM::~BwFSM
__ehhandler$??0BW@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0BW@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0BW@@QAE@XZ ENDP					; BW::BW
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\capibwcontrol.cpp
;	COMDAT ?RenewIfTime@BW@@AAEXXZ
_TEXT	SEGMENT
_interval_msec$ = -16					; size = 4
tv71 = -12						; size = 4
_now$ = -8						; size = 4
_this$ = -4						; size = 4
?RenewIfTime@BW@@AAEXXZ PROC				; BW::RenewIfTime, COMDAT
; _this$ = ecx

; 113  : 	void RenewIfTime(){

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 114  : 		clock_t now = clock();

	call	_clock
	mov	DWORD PTR _now$[ebp], eax

; 115  : 		// clock can wrap around, in this case renew bw immediately
; 116  : 		clock_t interval_msec = now < last_renew ? RENEW_INTERVAL_MSEC : CLOCKS_TO_MSEC(now - last_renew);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _now$[ebp]
	cmp	ecx, DWORD PTR [eax+44]
	jge	SHORT $LN4@RenewIfTim
	mov	DWORD PTR tv71[ebp], 500		; 000001f4H
	jmp	SHORT $LN5@RenewIfTim
$LN4@RenewIfTim:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	imul	eax, 1000				; 000003e8H
	cdq
	mov	ecx, 1000				; 000003e8H
	idiv	ecx
	mov	edx, DWORD PTR _now$[ebp]
	sub	edx, eax
	mov	DWORD PTR tv71[ebp], edx
$LN5@RenewIfTim:
	mov	eax, DWORD PTR tv71[ebp]
	mov	DWORD PTR _interval_msec$[ebp], eax

; 117  : 		if (interval_msec >= RENEW_INTERVAL_MSEC){

	cmp	DWORD PTR _interval_msec$[ebp], 500	; 000001f4H
	jl	SHORT $LN2@RenewIfTim

; 118  : #if INSTRUMENT_BW
; 119  : 			// percentage used
; 120  : 			unsigned int total = ComputeTotalBW();
; 121  : 			unsigned int used = ComputeTotalUsedBW(); 
; 122  : 			REPORT_VALUE("BW total (per renew)", total);
; 123  : 			REPORT_VALUE("BW percentage", (used * 100) / total);
; 124  : #endif
; 125  : 			Renew();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Renew@BW@@AAEXXZ			; BW::Renew
$LN2@RenewIfTim:

; 126  : 		}
; 127  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?RenewIfTime@BW@@AAEXXZ ENDP				; BW::RenewIfTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\capibwcontrol.cpp
;	COMDAT ?Renew@BW@@AAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$1 = -4						; size = 4
?Renew@BW@@AAEXXZ PROC					; BW::Renew, COMDAT
; _this$ = ecx

; 83   : 	void Renew(){

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 84   : 		for (int i=0;i<BW_NUM_TYPES;++i){

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN3@Renew
$LN2@Renew:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN3@Renew:
	cmp	DWORD PTR _i$1[ebp], 4
	jge	SHORT $LN1@Renew

; 85   : 			//used_by_type[i] = (used_by_type[i] > bytes_by_type[i]) ? (used_by_type[i] - bytes_by_type[i]) : 0;
; 86   : 			// lets be more flexible here...
; 87   : 			used_by_type[i] = 0;

	mov	ecx, DWORD PTR _i$1[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx*4+28], 0

; 88   : 		}

	jmp	SHORT $LN2@Renew
$LN1@Renew:

; 89   : 		last_renew = clock();

	call	_clock
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+44], eax

; 90   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?Renew@BW@@AAEXXZ ENDP					; BW::Renew
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\capibwcontrol.cpp
;	COMDAT ?Set@BW@@AAEXH@Z
_TEXT	SEGMENT
_bw$ = -16						; size = 4
_total$ = -12						; size = 4
_this$ = -8						; size = 4
_i$1 = -4						; size = 4
_bw_sec$ = 8						; size = 4
?Set@BW@@AAEXH@Z PROC					; BW::Set, COMDAT
; _this$ = ecx

; 71   : 	void Set(int bw_sec){

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 72   : 		// gets amount per interval
; 73   : 		int bw = bw_sec / RENEWS_PER_SEC;

	mov	eax, DWORD PTR _bw_sec$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _bw$[ebp], eax

; 74   : 		int total = 0;

	mov	DWORD PTR _total$[ebp], 0

; 75   : 		for (int i=0;i<BW_NUM_TYPES-1;++i){

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN3@Set
$LN2@Set:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN3@Set:
	cmp	DWORD PTR _i$1[ebp], 3
	jge	SHORT $LN1@Set

; 76   : 			bytes_by_type[i] = (int)(bw * percentages_by_type[i]);

	cvtsi2ss xmm0, DWORD PTR _bw$[ebp]
	mov	ecx, DWORD PTR _i$1[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [edx+ecx*4]
	cvttss2si eax, xmm0
	mov	ecx, DWORD PTR _i$1[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx*4+12], eax

; 77   : 			total += bytes_by_type[i];

	mov	eax, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _total$[ebp]
	add	edx, DWORD PTR [ecx+eax*4+12]
	mov	DWORD PTR _total$[ebp], edx

; 78   : 		}

	jmp	SHORT $LN2@Set
$LN1@Set:

; 79   : 		bytes_by_type[BW_COMMON] = bw - total;

	mov	eax, DWORD PTR _bw$[ebp]
	sub	eax, DWORD PTR _total$[ebp]
	mov	ecx, 4
	imul	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+12], eax

; 80   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?Set@BW@@AAEXH@Z ENDP					; BW::Set
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\capibwcontrol.cpp
_TEXT	SEGMENT
_cut_bandwidth PROC

; 240  : void cut_bandwidth(void){

	push	ebp
	mov	ebp, esp

; 241  : 	bw_object.Cut();

	mov	ecx, OFFSET _bw_object
	call	?Cut@BW@@QAEXXZ				; BW::Cut

; 242  : }

	pop	ebp
	ret	0
_cut_bandwidth ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\capibwcontrol.cpp
_TEXT	SEGMENT
tv68 = -1						; size = 1
_size$ = 8						; size = 4
_isReliable$ = 12					; size = 4
_type$ = 16						; size = 4
_check_bandwidth PROC

; 236  : int check_bandwidth(int size, int isReliable, int type){

	push	ebp
	mov	ebp, esp
	push	ecx

; 237  : 	return bw_object.Check(size, isReliable ? true : false, (BW::BWTypes)type);

	cmp	DWORD PTR _isReliable$[ebp], 0
	je	SHORT $LN3@check_band
	mov	BYTE PTR tv68[ebp], 1
	jmp	SHORT $LN4@check_band
$LN3@check_band:
	mov	BYTE PTR tv68[ebp], 0
$LN4@check_band:
	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	movzx	ecx, BYTE PTR tv68[ebp]
	push	ecx
	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	mov	ecx, OFFSET _bw_object
	call	?Check@BW@@QAE_NH_NW4BWTypes@1@@Z	; BW::Check
	movzx	eax, al

; 238  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_check_bandwidth ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\capibwcontrol.cpp
_TEXT	SEGMENT
tv67 = -1						; size = 1
_size$ = 8						; size = 4
_isReliable$ = 12					; size = 4
_type$ = 16						; size = 4
_use_bandwidth PROC

; 232  : void use_bandwidth(int size, int isReliable, int type){

	push	ebp
	mov	ebp, esp
	push	ecx

; 233  : 	bw_object.Use(size, isReliable ? true : false, type);

	cmp	DWORD PTR _isReliable$[ebp], 0
	je	SHORT $LN3@use_bandwi
	mov	BYTE PTR tv67[ebp], 1
	jmp	SHORT $LN4@use_bandwi
$LN3@use_bandwi:
	mov	BYTE PTR tv67[ebp], 0
$LN4@use_bandwi:
	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	movzx	ecx, BYTE PTR tv67[ebp]
	push	ecx
	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	mov	ecx, OFFSET _bw_object
	call	?Use@BW@@QAEXH_NH@Z			; BW::Use

; 234  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_use_bandwidth ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\capibwcontrol.cpp
_TEXT	SEGMENT
_player_left PROC

; 228  : void player_left(){

	push	ebp
	mov	ebp, esp

; 229  : 	bw_object.PlayerLeft();

	mov	ecx, OFFSET _bw_object
	call	?PlayerLeft@BW@@QAEXXZ			; BW::PlayerLeft

; 230  : }

	pop	ebp
	ret	0
_player_left ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\capibwcontrol.cpp
_TEXT	SEGMENT
_player_joined PROC

; 224  : void player_joined(){

	push	ebp
	mov	ebp, esp

; 225  : 	bw_object.PlayerJoined();

	mov	ecx, OFFSET _bw_object
	call	?PlayerJoined@BW@@QAEXXZ		; BW::PlayerJoined

; 226  : }

	pop	ebp
	ret	0
_player_joined ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\capibwcontrol.cpp
_TEXT	SEGMENT
_st$ = 8						; size = 4
_enter_state PROC

; 220  : void enter_state(bwstates st){

	push	ebp
	mov	ebp, esp

; 221  : 	bw_object.EnterState(st);

	mov	eax, DWORD PTR _st$[ebp]
	push	eax
	mov	ecx, OFFSET _bw_object
	call	?EnterState@BW@@QAEXW4bwstates@@@Z	; BW::EnterState

; 222  : }

	pop	ebp
	ret	0
_enter_state ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\capibwcontrol.cpp
_TEXT	SEGMENT
_start_bandwidth PROC

; 216  : void start_bandwidth(){

	push	ebp
	mov	ebp, esp

; 217  : 	bw_object.Reset();	

	mov	ecx, OFFSET _bw_object
	call	?Reset@BW@@QAEXXZ			; BW::Reset

; 218  : }

	pop	ebp
	ret	0
_start_bandwidth ENDP
_TEXT	ENDS
END
