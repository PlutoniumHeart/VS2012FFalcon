; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\comms\tcp.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_GlobalListHead
PUBLIC	_GlobalGroupListHead
_BSS	SEGMENT
_GlobalListHead DD 01H DUP (?)
_GlobalGroupListHead DD 01H DUP (?)
_AcceptConnectioncount DD 01H DUP (?)
_AcceptCount DD	01H DUP (?)
_BSS	ENDS
PUBLIC	_ComTCPOpenListen
PUBLIC	_ComTCPOpenConnect
PUBLIC	_ComTCPOpenAccept
PUBLIC	_ComAPICreateGroup
PUBLIC	_ComAPIAddToGroup
PUBLIC	_ComAPIDeleteFromGroup
PUBLIC	_CAPIIsInGroup
PUBLIC	_ComAPICloseOpenHandles
PUBLIC	_ComAPIGetNetHostBySocket
PUBLIC	_ComAPIGetNetHostByHandle
PUBLIC	_ComTCPClose
PUBLIC	_ComTCPSend
PUBLIC	_ComTCPSendX
PUBLIC	_ComTCPSendBufferGet
PUBLIC	_ComTCPRecvBufferGet
PUBLIC	_ComTCPGetMessage
PUBLIC	_ComTCPRecv
PUBLIC	_ComTCPGetNbytes
PUBLIC	_ComTCPQuery
PUBLIC	_ComTCPGetTimeStamp
PUBLIC	_CAPIListAppend
PUBLIC	_CAPIListRemove
PUBLIC	_CAPIListCount
PUBLIC	_CAPIListFindHandle
PUBLIC	_CAPIListDestroy
PUBLIC	_CAPIListAppendTail
PUBLIC	_ComGROUPRecvBufferGet
PUBLIC	_ComGROUPGet
PUBLIC	_ComGROUPClose
PUBLIC	_ComGROUPQuery
PUBLIC	_ComGROUPAddress
PUBLIC	_ComGROUPSendBufferGet
PUBLIC	_ComGROUPSend
PUBLIC	_ComGROUPSendX
PUBLIC	??_C@_0O@JIIAAKOM@Listen?5socket?$AA@		; `string'
PUBLIC	??_C@_0P@MIOCELLM@connect?5socket?$AA@		; `string'
PUBLIC	??_C@_0O@EDEIBAPN@accept?5socket?$AA@		; `string'
PUBLIC	??_C@_0BO@NCIPJOJG@?$CF08x?5?$DN?5CAPI?5List?5Append?5?$CF08x?6?$AA@ ; `string'
PUBLIC	??_C@_0CD@KGADPOFL@?$CF08x?5?$DN?5CAPI?5List?5Append?5Tail?5?$CF08@ ; `string'
PUBLIC	??_C@_0BH@OIOCLEPO@ComAPICreateGroup?5UDP?6?$AA@ ; `string'
PUBLIC	??_C@_0BI@FONHDAAB@ComAPICreateGroup?5RUDP?6?$AA@ ; `string'
PUBLIC	??_C@_0BK@HCBMGOHN@ComAPICreateGroup?5Serial?6?$AA@ ; `string'
PUBLIC	??_C@_0DG@KHEJLJNI@ComAPICreateGroup?5CAPIListAppend@ ; `string'
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_strcpy:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__DebugBreak@0:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__ReleaseMutex@4:PROC
EXTRN	__imp__WaitForSingleObject@8:PROC
EXTRN	__imp__CreateMutexA@12:PROC
EXTRN	__imp__Sleep@4:PROC
EXTRN	__imp__CreateThread@24:PROC
EXTRN	__imp__SetThreadPriority@8:PROC
EXTRN	__imp__FreeLibrary@4:PROC
EXTRN	__imp__IsBadCodePtr@4:PROC
EXTRN	_clock:PROC
EXTRN	_ComAPIQuery:PROC
EXTRN	_InitWS2:PROC
EXTRN	_use_bandwidth:PROC
EXTRN	_check_bandwidth:PROC
EXTRN	_F4IsBadReadPtrC:PROC
EXTRN	_F4IsBadCodePtrC:PROC
EXTRN	_MonoPrint:PROC
EXTRN	_enter_cs:PROC
EXTRN	_leave_cs:PROC
EXTRN	_ComIPHostIDGet:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_WS2Connections:DWORD
EXTRN	_hWinSockDLL:DWORD
EXTRN	_CAPI_accept:DWORD
EXTRN	_CAPI_bind:DWORD
EXTRN	_CAPI_closesocket:DWORD
EXTRN	_CAPI_connect:DWORD
EXTRN	_CAPI_ioctlsocket:DWORD
EXTRN	_CAPI_htonl:DWORD
EXTRN	_CAPI_htons:DWORD
EXTRN	_CAPI_listen:DWORD
EXTRN	_CAPI_ntohl:DWORD
EXTRN	_CAPI_recv:DWORD
EXTRN	_CAPI_send:DWORD
EXTRN	_CAPI_setsockopt:DWORD
EXTRN	_CAPI_socket:DWORD
EXTRN	_CAPI_getsockname:DWORD
EXTRN	_CAPI_WSACleanup:DWORD
EXTRN	_CAPI_WSAGetLastError:DWORD
EXTRN	_ComAPILastError:DWORD
EXTRN	_CAPI_TimeStamp:DWORD
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
_AcceptThread DD 01H DUP (?)
_ConnectThread DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0DG@KHEJLJNI@ComAPICreateGroup?5CAPIListAppend@
CONST	SEGMENT
??_C@_0DG@KHEJLJNI@ComAPICreateGroup?5CAPIListAppend@ DB 'ComAPICreateGro'
	DB	'up CAPIListAppend GlobalGroupListHead', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@HCBMGOHN@ComAPICreateGroup?5Serial?6?$AA@
CONST	SEGMENT
??_C@_0BK@HCBMGOHN@ComAPICreateGroup?5Serial?6?$AA@ DB 'ComAPICreateGroup'
	DB	' Serial', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FONHDAAB@ComAPICreateGroup?5RUDP?6?$AA@
CONST	SEGMENT
??_C@_0BI@FONHDAAB@ComAPICreateGroup?5RUDP?6?$AA@ DB 'ComAPICreateGroup R'
	DB	'UDP', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@OIOCLEPO@ComAPICreateGroup?5UDP?6?$AA@
CONST	SEGMENT
??_C@_0BH@OIOCLEPO@ComAPICreateGroup?5UDP?6?$AA@ DB 'ComAPICreateGroup UD'
	DB	'P', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@KGADPOFL@?$CF08x?5?$DN?5CAPI?5List?5Append?5Tail?5?$CF08@
CONST	SEGMENT
??_C@_0CD@KGADPOFL@?$CF08x?5?$DN?5CAPI?5List?5Append?5Tail?5?$CF08@ DB '%'
	DB	'08x = CAPI List Append Tail %08x', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@NCIPJOJG@?$CF08x?5?$DN?5CAPI?5List?5Append?5?$CF08x?6?$AA@
CONST	SEGMENT
??_C@_0BO@NCIPJOJG@?$CF08x?5?$DN?5CAPI?5List?5Append?5?$CF08x?6?$AA@ DB '%'
	DB	'08x = CAPI List Append %08x', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@EDEIBAPN@accept?5socket?$AA@
CONST	SEGMENT
??_C@_0O@EDEIBAPN@accept?5socket?$AA@ DB 'accept socket', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MIOCELLM@connect?5socket?$AA@
CONST	SEGMENT
??_C@_0P@MIOCELLM@connect?5socket?$AA@ DB 'connect socket', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JIIAAKOM@Listen?5socket?$AA@
CONST	SEGMENT
??_C@_0O@JIIAAKOM@Listen?5socket?$AA@ DB 'Listen socket', 00H ; `string'
CONST	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\tcp.c
_TEXT	SEGMENT
_bytesSent$ = -40					; size = 4
_this_group$1 = -36					; size = 4
_this_cudp$2 = -32					; size = 4
_this_ctcp$3 = -28					; size = 4
_this_cudp$4 = -24					; size = 4
_senderror$ = -20					; size = 4
_ret$5 = -16						; size = 4
_save_send_buffer$6 = -12				; size = 4
_group$7 = -8						; size = 4
_curr$8 = -4						; size = 4
_c$ = 8							; size = 4
_msgsize$ = 12						; size = 4
_oob$ = 16						; size = 4
_type$ = 20						; size = 4
_Xcom$ = 24						; size = 4
_ComGROUPSendX PROC

; 2272 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 2273 : 	int senderror=0;

	mov	DWORD PTR _senderror$[ebp], 0

; 2274 : 	int bytesSent=0;

	mov	DWORD PTR _bytesSent$[ebp], 0

; 2275 : 	
; 2276 : 	if(c)

	cmp	DWORD PTR _c$[ebp], 0
	je	$LN28@ComGROUPSe

; 2277 : 	{
; 2278 : 		ComGROUP  *group = (ComGROUP *)c;

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _group$7[ebp], eax

; 2279 : 		CAPIList * curr;
; 2280 : 		int ret = 0;

	mov	DWORD PTR _ret$5[ebp], 0

; 2281 : 		char *save_send_buffer;
; 2282 : 		enter_cs();

	call	_enter_cs

; 2283 : 		if (!CAPIListFindHandle(GlobalGroupListHead,c))

	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	mov	edx, DWORD PTR _GlobalGroupListHead
	push	edx
	call	_CAPIListFindHandle
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN27@ComGROUPSe

; 2284 : 		{
; 2285 : 		    leave_cs();

	call	_leave_cs

; 2286 : 			return COMAPI_NOTAGROUP; /* is it in  our list ? */

	mov	eax, -11				; fffffff5H
	jmp	$LN29@ComGROUPSe
$LN27@ComGROUPSe:

; 2287 : 		}
; 2288 : 		
; 2289 : 		if (group->GroupHead == NULL)

	mov	eax, DWORD PTR _group$7[ebp]
	cmp	DWORD PTR [eax+56], 0
	jne	SHORT $LN26@ComGROUPSe

; 2290 : 		{
; 2291 : 			senderror = COMAPI_EMPTYGROUP;

	mov	DWORD PTR _senderror$[ebp], -9		; fffffff7H

; 2292 : 		}
; 2293 : 		else

	jmp	SHORT $LN25@ComGROUPSe
$LN26@ComGROUPSe:

; 2294 : 		{
; 2295 : 			senderror = 0;

	mov	DWORD PTR _senderror$[ebp], 0
$LN25@ComGROUPSe:

; 2296 : 		}
; 2297 : 		
; 2298 : 		/* proceed thru list and call send_function() for each connection */      
; 2299 : 		for (curr = group->GroupHead; curr; curr = curr -> next) 

	mov	ecx, DWORD PTR _group$7[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	DWORD PTR _curr$8[ebp], edx
	jmp	SHORT $LN24@ComGROUPSe
$LN23@ComGROUPSe:
	mov	eax, DWORD PTR _curr$8[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _curr$8[ebp], ecx
$LN24@ComGROUPSe:
	cmp	DWORD PTR _curr$8[ebp], 0
	je	$LN22@ComGROUPSe

; 2300 : 		{
; 2301 : 			if (curr->com == Xcom)

	mov	edx, DWORD PTR _curr$8[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	eax, DWORD PTR _Xcom$[ebp]
	jne	SHORT $LN21@ComGROUPSe

; 2302 : 			{
; 2303 : 				continue;

	jmp	SHORT $LN23@ComGROUPSe
$LN21@ComGROUPSe:

; 2304 : 			}
; 2305 : 			
; 2306 : 			if(curr->com->protocol == CAPI_TCP_PROTOCOL)

	mov	ecx, DWORD PTR _curr$8[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx+4], 5
	jne	SHORT $LN20@ComGROUPSe

; 2307 : 			{
; 2308 : 				ComTCP *this_ctcp;
; 2309 : 				
; 2310 : 				this_ctcp = (ComTCP *)curr->com;

	mov	eax, DWORD PTR _curr$8[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _this_ctcp$3[ebp], ecx

; 2311 : 
; 2312 : 				if(this_ctcp)

	cmp	DWORD PTR _this_ctcp$3[ebp], 0
	je	SHORT $LN19@ComGROUPSe

; 2313 : 				{
; 2314 : 					save_send_buffer = this_ctcp->send_buffer.buf;

	mov	edx, DWORD PTR _this_ctcp$3[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	DWORD PTR _save_send_buffer$6[ebp], eax

; 2315 : 					this_ctcp->send_buffer.buf = group->send_buffer + group->TCP_buffer_shift;

	mov	ecx, DWORD PTR _group$7[ebp]
	movsx	edx, BYTE PTR [ecx+68]
	mov	eax, DWORD PTR _group$7[ebp]
	add	edx, DWORD PTR [eax+60]
	mov	ecx, DWORD PTR _this_ctcp$3[ebp]
	mov	DWORD PTR [ecx+56], edx

; 2316 : 					
; 2317 : 					if (curr->com->send_func){

	mov	edx, DWORD PTR _curr$8[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN18@ComGROUPSe

; 2318 : 						ret = curr->com->send_func(curr->com, msgsize, FALSE, type);

	mov	ecx, DWORD PTR _type$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _msgsize$[ebp]
	push	edx
	mov	eax, DWORD PTR _curr$8[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _curr$8[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+8]
	call	ecx
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ret$5[ebp], eax
$LN18@ComGROUPSe:

; 2319 : 					}
; 2320 : 
; 2321 : 					this_ctcp->send_buffer.buf = save_send_buffer ;

	mov	edx, DWORD PTR _this_ctcp$3[ebp]
	mov	eax, DWORD PTR _save_send_buffer$6[ebp]
	mov	DWORD PTR [edx+56], eax
$LN19@ComGROUPSe:

; 2322 : 					
; 2323 : 				}

	jmp	$LN17@ComGROUPSe
$LN20@ComGROUPSe:

; 2324 : 			}
; 2325 : 			else if (curr->com->protocol == CAPI_UDP_PROTOCOL)

	mov	ecx, DWORD PTR _curr$8[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx+4], 1
	jne	SHORT $LN16@ComGROUPSe

; 2326 : 			{
; 2327 : 				ComIP *this_cudp;
; 2328 : 				
; 2329 : 				this_cudp = (ComIP *)curr->com;

	mov	eax, DWORD PTR _curr$8[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _this_cudp$4[ebp], ecx

; 2330 : 
; 2331 : 				if(this_cudp)

	cmp	DWORD PTR _this_cudp$4[ebp], 0
	je	SHORT $LN15@ComGROUPSe

; 2332 : 				{
; 2333 : 					save_send_buffer = this_cudp->send_buffer.buf;

	mov	edx, DWORD PTR _this_cudp$4[ebp]
	mov	eax, DWORD PTR [edx+64]
	mov	DWORD PTR _save_send_buffer$6[ebp], eax

; 2334 : 					this_cudp->send_buffer.buf = group->send_buffer + group->UDP_buffer_shift;

	mov	ecx, DWORD PTR _group$7[ebp]
	movsx	edx, BYTE PTR [ecx+69]
	mov	eax, DWORD PTR _group$7[ebp]
	add	edx, DWORD PTR [eax+60]
	mov	ecx, DWORD PTR _this_cudp$4[ebp]
	mov	DWORD PTR [ecx+64], edx

; 2335 : 					memcpy(this_cudp->send_buffer.buf,save_send_buffer,sizeof(ComAPIHeader));

	push	8
	mov	edx, DWORD PTR _save_send_buffer$6[ebp]
	push	edx
	mov	eax, DWORD PTR _this_cudp$4[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2336 : 					
; 2337 : 					if (curr->com->send_func){

	mov	edx, DWORD PTR _curr$8[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN14@ComGROUPSe

; 2338 : 						ret = curr->com->send_func(curr->com, msgsize, FALSE, type);

	mov	ecx, DWORD PTR _type$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _msgsize$[ebp]
	push	edx
	mov	eax, DWORD PTR _curr$8[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _curr$8[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+8]
	call	ecx
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ret$5[ebp], eax
$LN14@ComGROUPSe:

; 2339 : 					}
; 2340 : 
; 2341 : 					this_cudp->send_buffer.buf = save_send_buffer ;

	mov	edx, DWORD PTR _this_cudp$4[ebp]
	mov	eax, DWORD PTR _save_send_buffer$6[ebp]
	mov	DWORD PTR [edx+64], eax
$LN15@ComGROUPSe:

; 2342 : 				}

	jmp	$LN17@ComGROUPSe
$LN16@ComGROUPSe:

; 2343 : 			}
; 2344 : 			else if(curr->com->protocol == CAPI_RUDP_PROTOCOL)

	mov	ecx, DWORD PTR _curr$8[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx+4], 10			; 0000000aH
	jne	SHORT $LN12@ComGROUPSe

; 2345 : 			{
; 2346 : 				ComIP *this_cudp;
; 2347 : 				
; 2348 : 				this_cudp = (ComIP *)curr->com;

	mov	eax, DWORD PTR _curr$8[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _this_cudp$2[ebp], ecx

; 2349 : 
; 2350 : 				if(this_cudp)

	cmp	DWORD PTR _this_cudp$2[ebp], 0
	je	SHORT $LN11@ComGROUPSe

; 2351 : 				{
; 2352 : 					save_send_buffer = this_cudp->send_buffer.buf;

	mov	edx, DWORD PTR _this_cudp$2[ebp]
	mov	eax, DWORD PTR [edx+64]
	mov	DWORD PTR _save_send_buffer$6[ebp], eax

; 2353 : 					this_cudp->send_buffer.buf = group->send_buffer + group->RUDP_buffer_shift;

	mov	ecx, DWORD PTR _group$7[ebp]
	movsx	edx, BYTE PTR [ecx+70]
	mov	eax, DWORD PTR _group$7[ebp]
	add	edx, DWORD PTR [eax+60]
	mov	ecx, DWORD PTR _this_cudp$2[ebp]
	mov	DWORD PTR [ecx+64], edx

; 2354 : 
; 2355 : 					if (curr->com->send_func){

	mov	edx, DWORD PTR _curr$8[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN10@ComGROUPSe

; 2356 : 						ret = curr->com->send_func(curr->com, msgsize, FALSE, type);

	mov	ecx, DWORD PTR _type$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _msgsize$[ebp]
	push	edx
	mov	eax, DWORD PTR _curr$8[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _curr$8[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+8]
	call	ecx
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ret$5[ebp], eax
$LN10@ComGROUPSe:

; 2357 : 					}
; 2358 : 
; 2359 : 					this_cudp->send_buffer.buf = save_send_buffer ;

	mov	edx, DWORD PTR _this_cudp$2[ebp]
	mov	eax, DWORD PTR _save_send_buffer$6[ebp]
	mov	DWORD PTR [edx+64], eax
$LN11@ComGROUPSe:

; 2360 : 				}

	jmp	SHORT $LN17@ComGROUPSe
$LN12@ComGROUPSe:

; 2361 : 			}
; 2362 : 			/*else if
; 2363 : 			(
; 2364 : 				curr->com->protocol == CAPI_DPLAY_TCP_PROTOCOL || 
; 2365 : 				curr->com->protocol == CAPI_DPLAY_MODEM_PROTOCOL ||
; 2366 : 				curr->com->protocol == CAPI_DPLAY_SERIAL_PROTOCOL
; 2367 : 			)
; 2368 : 			{
; 2369 : 				ret = ComDPLAYSendFromGroup(curr->com,msgsize,group->send_buffer +group->max_header);
; 2370 : 			}*/
; 2371 : 			else if(curr->com->protocol == CAPI_GROUP_PROTOCOL)  /* another group */

	mov	ecx, DWORD PTR _curr$8[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx+4], 11			; 0000000bH
	jne	SHORT $LN17@ComGROUPSe

; 2372 : 			{
; 2373 : 				ComGROUP *this_group;
; 2374 : 				this_group = (ComGROUP *) curr->com;

	mov	eax, DWORD PTR _curr$8[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _this_group$1[ebp], ecx

; 2375 : 				if(this_group)

	cmp	DWORD PTR _this_group$1[ebp], 0
	je	SHORT $LN17@ComGROUPSe

; 2376 : 				{
; 2377 : 					save_send_buffer = this_group->send_buffer;

	mov	edx, DWORD PTR _this_group$1[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	DWORD PTR _save_send_buffer$6[ebp], eax

; 2378 : 					this_group->send_buffer = group->send_buffer; 

	mov	ecx, DWORD PTR _this_group$1[ebp]
	mov	edx, DWORD PTR _group$7[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	DWORD PTR [ecx+60], eax

; 2379 : 
; 2380 : 					if (curr->com->send_func) {

	mov	ecx, DWORD PTR _curr$8[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx+8], 0
	je	SHORT $LN6@ComGROUPSe

; 2381 : 						ret = curr->com->send_func(curr->com, msgsize, FALSE, type);

	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _msgsize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _curr$8[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _curr$8[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ret$5[ebp], eax
$LN6@ComGROUPSe:

; 2382 : 					}
; 2383 : 
; 2384 : 					this_group->send_buffer = save_send_buffer ;

	mov	ecx, DWORD PTR _this_group$1[ebp]
	mov	edx, DWORD PTR _save_send_buffer$6[ebp]
	mov	DWORD PTR [ecx+60], edx
$LN17@ComGROUPSe:

; 2385 : 				}
; 2386 : 			}
; 2387 : 			
; 2388 : 			if (ret >= 0)

	cmp	DWORD PTR _ret$5[ebp], 0
	jl	SHORT $LN5@ComGROUPSe

; 2389 : 			{
; 2390 : 				bytesSent += ret;

	mov	eax, DWORD PTR _bytesSent$[ebp]
	add	eax, DWORD PTR _ret$5[ebp]
	mov	DWORD PTR _bytesSent$[ebp], eax

; 2391 : 			}
; 2392 : 			else

	jmp	SHORT $LN4@ComGROUPSe
$LN5@ComGROUPSe:

; 2393 : 			{
; 2394 : 				senderror = ret;

	mov	ecx, DWORD PTR _ret$5[ebp]
	mov	DWORD PTR _senderror$[ebp], ecx
$LN4@ComGROUPSe:

; 2395 : 			}
; 2396 : 		}

	jmp	$LN23@ComGROUPSe
$LN22@ComGROUPSe:

; 2397 : 	}
; 2398 : 	else

	jmp	SHORT $LN3@ComGROUPSe
$LN28@ComGROUPSe:

; 2399 : 	{
; 2400 : 		senderror = COMAPI_EMPTYGROUP;

	mov	DWORD PTR _senderror$[ebp], -9		; fffffff7H
$LN3@ComGROUPSe:

; 2401 : 	}
; 2402 : 	leave_cs();

	call	_leave_cs

; 2403 : 	if(senderror)

	cmp	DWORD PTR _senderror$[ebp], 0
	je	SHORT $LN2@ComGROUPSe

; 2404 : 	{
; 2405 : 		return senderror;

	mov	eax, DWORD PTR _senderror$[ebp]
	jmp	SHORT $LN29@ComGROUPSe

; 2406 : 	}
; 2407 : 	else

	jmp	SHORT $LN29@ComGROUPSe
$LN2@ComGROUPSe:

; 2408 : 	{
; 2409 : 		return bytesSent;

	mov	eax, DWORD PTR _bytesSent$[ebp]
$LN29@ComGROUPSe:

; 2410 : 	}
; 2411 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ComGROUPSendX ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\tcp.c
_TEXT	SEGMENT
_count$1 = -44						; size = 4
_bytesSent$ = -40					; size = 4
_this_group$2 = -36					; size = 4
_this_cudp$3 = -32					; size = 4
_this_ctcp$4 = -28					; size = 4
_senderror$ = -24					; size = 4
_this_cudp$5 = -20					; size = 4
_save_send_buffer$6 = -16				; size = 4
_ret$7 = -12						; size = 4
_group$8 = -8						; size = 4
_curr$9 = -4						; size = 4
_c$ = 8							; size = 4
_msgsize$ = 12						; size = 4
_oob$ = 16						; size = 4
_type$ = 20						; size = 4
_ComGROUPSend PROC

; 2116 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 2117 : 	int senderror=0;

	mov	DWORD PTR _senderror$[ebp], 0

; 2118 : 	int bytesSent=0;

	mov	DWORD PTR _bytesSent$[ebp], 0

; 2119 : 
; 2120 : 	// JPO added a bunch of asserts after crashes occured in here.
; 2121 : 	if(c){

	cmp	DWORD PTR _c$[ebp], 0
	je	$LN31@ComGROUPSe

; 2122 : 		ComGROUP  *group = (ComGROUP *)c;

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _group$8[ebp], eax

; 2123 : 		CAPIList * curr;
; 2124 : 		int ret = 0;

	mov	DWORD PTR _ret$7[ebp], 0

; 2125 : 		int count = 0;

	mov	DWORD PTR _count$1[ebp], 0

; 2126 : 		char *save_send_buffer;
; 2127 : 		enter_cs(); // JPO

	call	_enter_cs

; 2128 : 		if(!CAPIListFindHandle(GlobalGroupListHead,c)){

	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	mov	edx, DWORD PTR _GlobalGroupListHead
	push	edx
	call	_CAPIListFindHandle
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN30@ComGROUPSe

; 2129 : 		    leave_cs();

	call	_leave_cs

; 2130 : 			return COMAPI_NOTAGROUP; /* is it in  our list ? */

	mov	eax, -11				; fffffff5H
	jmp	$LN32@ComGROUPSe
$LN30@ComGROUPSe:

; 2131 : 		}
; 2132 : 		
; 2133 : 		if (group->GroupHead == NULL){

	mov	eax, DWORD PTR _group$8[ebp]
	cmp	DWORD PTR [eax+56], 0
	jne	SHORT $LN29@ComGROUPSe

; 2134 : 			senderror = COMAPI_EMPTYGROUP;

	mov	DWORD PTR _senderror$[ebp], -9		; fffffff7H

; 2135 : 		}
; 2136 : 		else {

	jmp	SHORT $LN28@ComGROUPSe
$LN29@ComGROUPSe:

; 2137 : 			senderror = 0;

	mov	DWORD PTR _senderror$[ebp], 0
$LN28@ComGROUPSe:

; 2138 : 		}
; 2139 : 	
; 2140 : 		/* proceed thru list and call send_function() for each connection */      
; 2141 : 		for (curr = group->GroupHead; curr; curr = curr->next){

	mov	ecx, DWORD PTR _group$8[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	DWORD PTR _curr$9[ebp], edx
	jmp	SHORT $LN27@ComGROUPSe
$LN26@ComGROUPSe:
	mov	eax, DWORD PTR _curr$9[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _curr$9[ebp], ecx
$LN27@ComGROUPSe:
	cmp	DWORD PTR _curr$9[ebp], 0
	je	$LN25@ComGROUPSe

; 2142 : 
; 2143 : 			// @todo sfr: remove hack
; 2144 : 			if (F4IsBadReadPtrC(curr->com, sizeof(ComAPIHandle))){

	push	4
	mov	edx, DWORD PTR _curr$9[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_F4IsBadReadPtrC
	add	esp, 8
	test	eax, eax
	je	SHORT $LN24@ComGROUPSe

; 2145 : 				// JB 010221 CTD
; 2146 : 				continue; // JB 010221 CTD

	jmp	SHORT $LN26@ComGROUPSe
$LN24@ComGROUPSe:

; 2147 : 			}
; 2148 : 
; 2149 : 			if(curr->com->protocol == CAPI_TCP_PROTOCOL){

	mov	ecx, DWORD PTR _curr$9[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx+4], 5
	jne	SHORT $LN23@ComGROUPSe

; 2150 : 				ComTCP *this_ctcp;
; 2151 : 				this_ctcp = (ComTCP *)curr->com;

	mov	eax, DWORD PTR _curr$9[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _this_ctcp$4[ebp], ecx

; 2152 : 
; 2153 : 				//if(this_ctcp)
; 2154 : 				if (this_ctcp && !IsBadCodePtr((FARPROC) (*curr->com->send_func))) // JB 010401 CTD

	cmp	DWORD PTR _this_ctcp$4[ebp], 0
	je	SHORT $LN22@ComGROUPSe
	mov	edx, DWORD PTR _curr$9[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	DWORD PTR __imp__IsBadCodePtr@4
	test	eax, eax
	jne	SHORT $LN22@ComGROUPSe

; 2155 : 				{
; 2156 : 					save_send_buffer = this_ctcp->send_buffer.buf;

	mov	edx, DWORD PTR _this_ctcp$4[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	DWORD PTR _save_send_buffer$6[ebp], eax

; 2157 : 					this_ctcp->send_buffer.buf = group->send_buffer + group->TCP_buffer_shift;

	mov	ecx, DWORD PTR _group$8[ebp]
	movsx	edx, BYTE PTR [ecx+68]
	mov	eax, DWORD PTR _group$8[ebp]
	add	edx, DWORD PTR [eax+60]
	mov	ecx, DWORD PTR _this_ctcp$4[ebp]
	mov	DWORD PTR [ecx+56], edx

; 2158 : 
; 2159 : 					if (curr->com->send_func){

	mov	edx, DWORD PTR _curr$9[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN21@ComGROUPSe

; 2160 : 						ret = curr->com->send_func(curr->com, msgsize, oob, type);

	mov	ecx, DWORD PTR _type$[ebp]
	push	ecx
	mov	edx, DWORD PTR _oob$[ebp]
	push	edx
	mov	eax, DWORD PTR _msgsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _curr$9[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _curr$9[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+8]
	call	edx
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ret$7[ebp], eax
$LN21@ComGROUPSe:

; 2161 : 					}
; 2162 : 
; 2163 : 					this_ctcp->send_buffer.buf = save_send_buffer ;

	mov	eax, DWORD PTR _this_ctcp$4[ebp]
	mov	ecx, DWORD PTR _save_send_buffer$6[ebp]
	mov	DWORD PTR [eax+56], ecx
$LN22@ComGROUPSe:

; 2164 : 				}

	jmp	$LN20@ComGROUPSe
$LN23@ComGROUPSe:

; 2165 : 			}
; 2166 : 			else if(curr->com->protocol == CAPI_UDP_PROTOCOL){

	mov	edx, DWORD PTR _curr$9[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	DWORD PTR [eax+4], 1
	jne	$LN19@ComGROUPSe

; 2167 : 				ComIP *this_cudp;
; 2168 : 				this_cudp = (ComIP*)curr->com;

	mov	ecx, DWORD PTR _curr$9[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _this_cudp$5[ebp], edx

; 2169 : 
; 2170 : 				//if(this_cudp) // JB 010222 CTD
; 2171 : 				if (
; 2172 : 					this_cudp  && (this_cudp->send_buffer.buf) && 
; 2173 : 					!F4IsBadReadPtrC(this_cudp->send_buffer.buf, sizeof(char)) && // JB 010222 CTD
; 2174 : 					!F4IsBadCodePtrC((FARPROC)(*curr->com->send_func))
; 2175 : 					 // JB 010401 CTD
; 2176 : 				){

	cmp	DWORD PTR _this_cudp$5[ebp], 0
	je	$LN18@ComGROUPSe
	mov	eax, DWORD PTR _this_cudp$5[ebp]
	cmp	DWORD PTR [eax+64], 0
	je	$LN18@ComGROUPSe
	push	1
	mov	ecx, DWORD PTR _this_cudp$5[ebp]
	mov	edx, DWORD PTR [ecx+64]
	push	edx
	call	_F4IsBadReadPtrC
	add	esp, 8
	test	eax, eax
	jne	$LN18@ComGROUPSe
	mov	eax, DWORD PTR _curr$9[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_F4IsBadCodePtrC
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN18@ComGROUPSe

; 2177 : 					save_send_buffer = this_cudp->send_buffer.buf;

	mov	eax, DWORD PTR _this_cudp$5[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	DWORD PTR _save_send_buffer$6[ebp], ecx

; 2178 : 					this_cudp->send_buffer.buf = group->send_buffer + group->UDP_buffer_shift;

	mov	edx, DWORD PTR _group$8[ebp]
	movsx	eax, BYTE PTR [edx+69]
	mov	ecx, DWORD PTR _group$8[ebp]
	add	eax, DWORD PTR [ecx+60]
	mov	edx, DWORD PTR _this_cudp$5[ebp]
	mov	DWORD PTR [edx+64], eax

; 2179 : 
; 2180 : 					memcpy(this_cudp->send_buffer.buf,save_send_buffer,sizeof(ComAPIHeader));

	push	8
	mov	eax, DWORD PTR _save_send_buffer$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _this_cudp$5[ebp]
	mov	edx, DWORD PTR [ecx+64]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2181 : 
; 2182 : 					if (curr->com->send_func){

	mov	eax, DWORD PTR _curr$9[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN17@ComGROUPSe

; 2183 : 						ret = curr->com->send_func(curr->com, msgsize, oob, type);

	mov	edx, DWORD PTR _type$[ebp]
	push	edx
	mov	eax, DWORD PTR _oob$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msgsize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _curr$9[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _curr$9[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ret$7[ebp], eax
$LN17@ComGROUPSe:

; 2184 : 
; 2185 : 						if (ret > 0){
; 2186 : //							oob = TRUE; // force other UDP packets to go OOB if the first one went
; 2187 : 						}
; 2188 : 					}
; 2189 : 
; 2190 : 					this_cudp->send_buffer.buf = save_send_buffer ;

	mov	ecx, DWORD PTR _this_cudp$5[ebp]
	mov	edx, DWORD PTR _save_send_buffer$6[ebp]
	mov	DWORD PTR [ecx+64], edx
$LN18@ComGROUPSe:

; 2191 : 				}

	jmp	$LN20@ComGROUPSe
$LN19@ComGROUPSe:

; 2192 : 			}
; 2193 : 			else if (curr->com->protocol == CAPI_RUDP_PROTOCOL){

	mov	eax, DWORD PTR _curr$9[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	DWORD PTR [ecx+4], 10			; 0000000aH
	jne	SHORT $LN14@ComGROUPSe

; 2194 : 				ComIP *this_cudp;
; 2195 : 								
; 2196 : 				this_cudp = (ComIP *)curr->com;

	mov	edx, DWORD PTR _curr$9[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _this_cudp$3[ebp], eax

; 2197 : 
; 2198 : 				//if(this_cudp)
; 2199 : 				if (this_cudp && !IsBadCodePtr((FARPROC) (*curr->com->send_func))) // JB 010401 CTD

	cmp	DWORD PTR _this_cudp$3[ebp], 0
	je	SHORT $LN13@ComGROUPSe
	mov	ecx, DWORD PTR _curr$9[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR __imp__IsBadCodePtr@4
	test	eax, eax
	jne	SHORT $LN13@ComGROUPSe

; 2200 : 				{
; 2201 : 					save_send_buffer = this_cudp->send_buffer.buf;

	mov	ecx, DWORD PTR _this_cudp$3[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	DWORD PTR _save_send_buffer$6[ebp], edx

; 2202 : 					this_cudp->send_buffer.buf = group->send_buffer + group->RUDP_buffer_shift;

	mov	eax, DWORD PTR _group$8[ebp]
	movsx	ecx, BYTE PTR [eax+70]
	mov	edx, DWORD PTR _group$8[ebp]
	add	ecx, DWORD PTR [edx+60]
	mov	eax, DWORD PTR _this_cudp$3[ebp]
	mov	DWORD PTR [eax+64], ecx

; 2203 : 	
; 2204 : 					if (curr->com->send_func)

	mov	ecx, DWORD PTR _curr$9[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx+8], 0
	je	SHORT $LN12@ComGROUPSe

; 2205 : 					{
; 2206 : 						ret = curr->com->send_func(curr->com, msgsize, oob, type);

	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _oob$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msgsize$[ebp]
	push	edx
	mov	eax, DWORD PTR _curr$9[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _curr$9[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+8]
	call	ecx
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ret$7[ebp], eax
$LN12@ComGROUPSe:

; 2207 : 					}
; 2208 : 
; 2209 : 					this_cudp->send_buffer.buf = save_send_buffer ;

	mov	edx, DWORD PTR _this_cudp$3[ebp]
	mov	eax, DWORD PTR _save_send_buffer$6[ebp]
	mov	DWORD PTR [edx+64], eax
$LN13@ComGROUPSe:

; 2210 : 				}

	jmp	$LN20@ComGROUPSe
$LN14@ComGROUPSe:

; 2211 : 			}
; 2212 : 			/*else if
; 2213 : 			(
; 2214 : 				(curr->com->protocol == CAPI_DPLAY_TCP_PROTOCOL) || 
; 2215 : 				(curr->com->protocol == CAPI_DPLAY_MODEM_PROTOCOL) ||
; 2216 : 				(curr->com->protocol == CAPI_DPLAY_SERIAL_PROTOCOL)
; 2217 : 			)
; 2218 : 			{
; 2219 : 				ret = ComDPLAYSendFromGroup(curr->com,msgsize,group->send_buffer +group->max_header);
; 2220 : 			}*/
; 2221 : 			else if(curr->com->protocol == CAPI_GROUP_PROTOCOL)  /* another group */

	mov	ecx, DWORD PTR _curr$9[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx+4], 11			; 0000000bH
	jne	SHORT $LN10@ComGROUPSe

; 2222 : 			{
; 2223 : 				ComGROUP *this_group;
; 2224 : 				this_group = (ComGROUP *) curr->com;

	mov	eax, DWORD PTR _curr$9[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _this_group$2[ebp], ecx

; 2225 : 
; 2226 : 				//if(this_group)
; 2227 : 				if(this_group && !F4IsBadCodePtrC((FARPROC) (*curr->com->send_func))) // JB 010401 CTD

	cmp	DWORD PTR _this_group$2[ebp], 0
	je	SHORT $LN9@ComGROUPSe
	mov	edx, DWORD PTR _curr$9[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_F4IsBadCodePtrC
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN9@ComGROUPSe

; 2228 : 				{
; 2229 : 					save_send_buffer = this_group->send_buffer;

	mov	edx, DWORD PTR _this_group$2[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	DWORD PTR _save_send_buffer$6[ebp], eax

; 2230 : 					this_group->send_buffer = group->send_buffer; 

	mov	ecx, DWORD PTR _this_group$2[ebp]
	mov	edx, DWORD PTR _group$8[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	DWORD PTR [ecx+60], eax

; 2231 : 
; 2232 : 					if (curr->com->send_func){

	mov	ecx, DWORD PTR _curr$9[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx+8], 0
	je	SHORT $LN8@ComGROUPSe

; 2233 : 						ret = curr->com->send_func(curr->com, msgsize, FALSE, type);

	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _msgsize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _curr$9[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _curr$9[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ret$7[ebp], eax
$LN8@ComGROUPSe:

; 2234 : 					}
; 2235 : 
; 2236 : 					this_group->send_buffer = save_send_buffer ;

	mov	ecx, DWORD PTR _this_group$2[ebp]
	mov	edx, DWORD PTR _save_send_buffer$6[ebp]
	mov	DWORD PTR [ecx+60], edx
$LN9@ComGROUPSe:

; 2237 : 				}
; 2238 : 			}
; 2239 : 			else {

	jmp	SHORT $LN20@ComGROUPSe
$LN10@ComGROUPSe:

; 2240 : 				//me123 hack hack
; 2241 : 				if (bytesSent == 0) ret = 1;

	cmp	DWORD PTR _bytesSent$[ebp], 0
	jne	SHORT $LN20@ComGROUPSe
	mov	DWORD PTR _ret$7[ebp], 1
$LN20@ComGROUPSe:

; 2242 : 			}
; 2243 : 			
; 2244 : 			if( ret >= 0)

	cmp	DWORD PTR _ret$7[ebp], 0
	jl	SHORT $LN5@ComGROUPSe

; 2245 : 			{
; 2246 : 				bytesSent += ret;

	mov	eax, DWORD PTR _bytesSent$[ebp]
	add	eax, DWORD PTR _ret$7[ebp]
	mov	DWORD PTR _bytesSent$[ebp], eax

; 2247 : 			}
; 2248 : 			else

	jmp	SHORT $LN4@ComGROUPSe
$LN5@ComGROUPSe:

; 2249 : 			{
; 2250 : 				senderror = ret;

	mov	ecx, DWORD PTR _ret$7[ebp]
	mov	DWORD PTR _senderror$[ebp], ecx
$LN4@ComGROUPSe:

; 2251 : 			}
; 2252 : 		}

	jmp	$LN26@ComGROUPSe
$LN25@ComGROUPSe:

; 2253 : 	}
; 2254 : 	else {

	jmp	SHORT $LN3@ComGROUPSe
$LN31@ComGROUPSe:

; 2255 : 		senderror = COMAPI_EMPTYGROUP;

	mov	DWORD PTR _senderror$[ebp], -9		; fffffff7H
$LN3@ComGROUPSe:

; 2256 : 	}
; 2257 : 	leave_cs();

	call	_leave_cs

; 2258 : 
; 2259 : 	if (senderror){

	cmp	DWORD PTR _senderror$[ebp], 0
	je	SHORT $LN2@ComGROUPSe

; 2260 : 		return senderror;

	mov	eax, DWORD PTR _senderror$[ebp]
	jmp	SHORT $LN32@ComGROUPSe

; 2261 : 	}
; 2262 : 	else {

	jmp	SHORT $LN32@ComGROUPSe
$LN2@ComGROUPSe:

; 2263 : 		return bytesSent;

	mov	eax, DWORD PTR _bytesSent$[ebp]
$LN32@ComGROUPSe:

; 2264 : 	}
; 2265 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ComGROUPSend ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\tcp.c
_TEXT	SEGMENT
_c$ = 8							; size = 4
_ComGROUPSendBufferGet PROC

; 2095 : {

	push	ebp
	mov	ebp, esp

; 2096 : 	if(c)

	cmp	DWORD PTR _c$[ebp], 0
	je	SHORT $LN3@ComGROUPSe

; 2097 : 	{
; 2098 : 		if(c->protocol != CAPI_GROUP_PROTOCOL)

	mov	eax, DWORD PTR _c$[ebp]
	cmp	DWORD PTR [eax+4], 11			; 0000000bH
	je	SHORT $LN2@ComGROUPSe

; 2099 : 		{
; 2100 : 			return NULL;

	xor	eax, eax
	jmp	SHORT $LN4@ComGROUPSe
$LN2@ComGROUPSe:

; 2101 : 		}
; 2102 : 
; 2103 : 		return (((ComGROUP *)c)->send_buffer + ((ComGROUP *)c)->max_header);

	mov	ecx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [ecx+60]
	mov	edx, DWORD PTR _c$[ebp]
	add	eax, DWORD PTR [edx+64]
	jmp	SHORT $LN4@ComGROUPSe

; 2104 : 	}
; 2105 : 	else

	jmp	SHORT $LN4@ComGROUPSe
$LN3@ComGROUPSe:

; 2106 : 	{
; 2107 : 		return NULL;

	xor	eax, eax
$LN4@ComGROUPSe:

; 2108 : 	}
; 2109 : }

	pop	ebp
	ret	0
_ComGROUPSendBufferGet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\tcp.c
_TEXT	SEGMENT
_ipaddr$ = -4						; size = 4
_c$ = 8							; size = 4
_buf$ = 12						; size = 4
_reset$ = 16						; size = 4
_ComGROUPAddress PROC

; 1885 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1886 : 	unsigned long ipaddr;
; 1887 : 
; 1888 : 	if(c)

	cmp	DWORD PTR _c$[ebp], 0
	je	SHORT $LN2@ComGROUPAd

; 1889 : 	{
; 1890 : 		ipaddr = ((ComGROUP *)c)->HostID;

	mov	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	DWORD PTR _ipaddr$[ebp], ecx

; 1891 : 
; 1892 : 		if (ipaddr)

	cmp	DWORD PTR _ipaddr$[ebp], 0
	je	SHORT $LN2@ComGROUPAd

; 1893 : 		{
; 1894 : 			*((int*)buf) = *((int*)(&ipaddr));

	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _ipaddr$[ebp]
	mov	DWORD PTR [edx], eax

; 1895 : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN3@ComGROUPAd
$LN2@ComGROUPAd:

; 1896 : 		}
; 1897 : 	}
; 1898 : 
; 1899 : 	return COMAPI_HOSTID_ERROR;

	mov	eax, -13				; fffffff3H
$LN3@ComGROUPAd:

; 1900 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ComGROUPAddress ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\tcp.c
_TEXT	SEGMENT
tv65 = -4						; size = 4
_c$ = 8							; size = 4
_querytype$ = 12					; size = 4
_ComGROUPQuery PROC

; 1861 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1862 : 	if(c)

	cmp	DWORD PTR _c$[ebp], 0
	je	SHORT $LN6@ComGROUPQu

; 1863 : 	{
; 1864 : 		switch(querytype)

	mov	eax, DWORD PTR _querytype$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	cmp	DWORD PTR tv65[ebp], 14			; 0000000eH
	je	SHORT $LN2@ComGROUPQu
	cmp	DWORD PTR tv65[ebp], 15			; 0000000fH
	je	SHORT $LN3@ComGROUPQu
	jmp	SHORT $LN1@ComGROUPQu
$LN3@ComGROUPQu:

; 1865 : 		{
; 1866 : 			case COMAPI_PROTOCOL:
; 1867 : 				return  c->protocol;

	mov	ecx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	jmp	SHORT $LN7@ComGROUPQu
$LN2@ComGROUPQu:

; 1868 : 			
; 1869 : 			case COMAPI_ACTUAL_BUFFER_SIZE:
; 1870 : 				return ((ComGROUP *)c)->buffer_size -  ((ComGROUP *)c)->max_header;

	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR [edx+48]
	sub	ecx, DWORD PTR [eax+64]
	mov	eax, ecx
	jmp	SHORT $LN7@ComGROUPQu
$LN1@ComGROUPQu:

; 1871 : 				
; 1872 : 			default:
; 1873 : 				return 0;

	xor	eax, eax
	jmp	SHORT $LN7@ComGROUPQu
$LN6@ComGROUPQu:

; 1874 : 		}
; 1875 : 	}
; 1876 : 
; 1877 : 	return 0;

	xor	eax, eax
$LN7@ComGROUPQu:

; 1878 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ComGROUPQuery ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\tcp.c
_TEXT	SEGMENT
_curr$ = -4						; size = 4
_c$ = 8							; size = 4
_ComGROUPClose PROC

; 1806 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1807 : 	CAPIList *curr;
; 1808 : 	
; 1809 : 	if(!c)

	cmp	DWORD PTR _c$[ebp], 0
	jne	SHORT $LN6@ComGROUPCl

; 1810 : 	{
; 1811 : 		return;

	jmp	$LN7@ComGROUPCl
$LN6@ComGROUPCl:

; 1812 : 	}
; 1813 : 	
; 1814 : 	if(!CAPIListFindHandle(GlobalGroupListHead,c))           /* in our list of groups ?*/

	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	mov	ecx, DWORD PTR _GlobalGroupListHead
	push	ecx
	call	_CAPIListFindHandle
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN5@ComGROUPCl

; 1815 : 	{
; 1816 : 		return;

	jmp	SHORT $LN7@ComGROUPCl
$LN5@ComGROUPCl:

; 1817 : 	}
; 1818 : 	
; 1819 : 	CAPIListDestroy(((ComGROUP *)c)->GroupHead,NULL);                /* destroy this group list */

	push	0
	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	call	_CAPIListDestroy
	add	esp, 8

; 1820 : 	
; 1821 : #ifdef _DEBUG
; 1822 : 	MonoPrint ("Group Close CH:\"%s\"\n", c->name);
; 1823 : #endif
; 1824 : 	GlobalGroupListHead = CAPIListRemove(GlobalGroupListHead,c);     /* remove group from list of groups */

	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	mov	edx, DWORD PTR _GlobalGroupListHead
	push	edx
	call	_CAPIListRemove
	add	esp, 8
	mov	DWORD PTR _GlobalGroupListHead, eax

; 1825 : 	
; 1826 : #ifdef _DEBUG
; 1827 : 	MonoPrint ("================================\n");
; 1828 : 	MonoPrint ("GlobalGroupListHead\n");
; 1829 : 	
; 1830 : 	curr = GlobalGroupListHead;
; 1831 : 	
; 1832 : 	while (curr){
; 1833 : 		if (!F4IsBadReadPtrC(curr->com->name, 1)) // JB 010724 CTD
; 1834 : 			MonoPrint ("  \"%s\"\n", curr->com->name);
; 1835 : 		curr = curr->next;
; 1836 : 	}
; 1837 : 	
; 1838 : 	MonoPrint ("================================\n");
; 1839 : #endif
; 1840 : 	
; 1841 : 	for( curr = GlobalGroupListHead ; curr  != NULL ; curr = curr -> next )

	mov	eax, DWORD PTR _GlobalGroupListHead
	mov	DWORD PTR _curr$[ebp], eax
	jmp	SHORT $LN4@ComGROUPCl
$LN3@ComGROUPCl:
	mov	ecx, DWORD PTR _curr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _curr$[ebp], edx
$LN4@ComGROUPCl:
	cmp	DWORD PTR _curr$[ebp], 0
	je	SHORT $LN2@ComGROUPCl

; 1842 : 	{
; 1843 : 		ComAPIDeleteFromGroup(curr->com,c);                              /* remove this group from others */

	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	mov	ecx, DWORD PTR _curr$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_ComAPIDeleteFromGroup
	add	esp, 8

; 1844 : 	}

	jmp	SHORT $LN3@ComGROUPCl
$LN2@ComGROUPCl:

; 1845 : 	
; 1846 : 	if(((ComGROUP *)c)->send_buffer)

	mov	eax, DWORD PTR _c$[ebp]
	cmp	DWORD PTR [eax+60], 0
	je	SHORT $LN1@ComGROUPCl

; 1847 : 	{
; 1848 : 		free(((ComGROUP *)c)->send_buffer);

	mov	ecx, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	push	edx
	call	_free
	add	esp, 4
$LN1@ComGROUPCl:

; 1849 : 	}
; 1850 : 	
; 1851 : 	free(c);

	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	call	_free
	add	esp, 4
$LN7@ComGROUPCl:

; 1852 : 	
; 1853 : 	return;
; 1854 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ComGROUPClose ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\tcp.c
_TEXT	SEGMENT
_c$ = 8							; size = 4
_ComGROUPGet PROC

; 1794 : {

	push	ebp
	mov	ebp, esp

; 1795 : 	c;
; 1796 : 
; 1797 : 	return 0;

	xor	eax, eax

; 1798 : }

	pop	ebp
	ret	0
_ComGROUPGet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\tcp.c
_TEXT	SEGMENT
_c$ = 8							; size = 4
_ComGROUPRecvBufferGet PROC

; 1782 : {

	push	ebp
	mov	ebp, esp

; 1783 : 	c;
; 1784 : 
; 1785 : 	return NULL;

	xor	eax, eax

; 1786 : }

	pop	ebp
	ret	0
_ComGROUPRecvBufferGet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\tcp.c
_TEXT	SEGMENT
_newnode$ = -4						; size = 4
_list$ = 8						; size = 4
_CAPIListAppendTail PROC

; 1757 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1758 : 	CAPIList * newnode;
; 1759 : 	
; 1760 : 	newnode = (CAPIList *)malloc(sizeof(CAPIList));

	push	12					; 0000000cH
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _newnode$[ebp], eax

; 1761 : 	memset(newnode,0,sizeof(CAPIList));

	push	12					; 0000000cH
	push	0
	mov	eax, DWORD PTR _newnode$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1762 : 	
; 1763 : 	/* list was null */
; 1764 : 	if ( !list ) 

	cmp	DWORD PTR _list$[ebp], 0
	jne	SHORT $LN2@CAPIListAp

; 1765 : 	{
; 1766 : 		list = newnode;

	mov	ecx, DWORD PTR _newnode$[ebp]
	mov	DWORD PTR _list$[ebp], ecx

; 1767 : 	}
; 1768 : 	else 

	jmp	SHORT $LN1@CAPIListAp
$LN2@CAPIListAp:

; 1769 : 	{
; 1770 : 		list -> next = newnode;

	mov	edx, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR _newnode$[ebp]
	mov	DWORD PTR [edx], eax
$LN1@CAPIListAp:

; 1771 : 	}
; 1772 : 
; 1773 : 	MonoPrint ("%08x = CAPI List Append Tail %08x\n", newnode, list);

	mov	ecx, DWORD PTR _list$[ebp]
	push	ecx
	mov	edx, DWORD PTR _newnode$[ebp]
	push	edx
	push	OFFSET ??_C@_0CD@KGADPOFL@?$CF08x?5?$DN?5CAPI?5List?5Append?5Tail?5?$CF08@
	call	_MonoPrint
	add	esp, 12					; 0000000cH

; 1774 : 	return newnode;

	mov	eax, DWORD PTR _newnode$[ebp]

; 1775 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CAPIListAppendTail ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\tcp.c
_TEXT	SEGMENT
_c$ = -8						; size = 4
_curr$ = -4						; size = 4
_list$ = 8						; size = 4
_CAPIListFindTCPAcceptPendingExpired PROC

; 1684 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi

; 1685 : 	CAPIList * curr;
; 1686 : 	ComTCP *c;
; 1687 : 	
; 1688 : 	for (curr = list; curr; curr = curr -> next)

	mov	eax, DWORD PTR _list$[ebp]
	mov	DWORD PTR _curr$[ebp], eax
	jmp	SHORT $LN6@CAPIListFi
$LN5@CAPIListFi:
	mov	ecx, DWORD PTR _curr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _curr$[ebp], edx
$LN6@CAPIListFi:
	cmp	DWORD PTR _curr$[ebp], 0
	je	SHORT $LN4@CAPIListFi

; 1689 : 	{
; 1690 : 		if (curr->com->protocol == CAPI_TCP_PROTOCOL)

	mov	eax, DWORD PTR _curr$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	DWORD PTR [ecx+4], 5
	jne	SHORT $LN3@CAPIListFi

; 1691 : 		{
; 1692 : 			c = (ComTCP *)curr->com;

	mov	edx, DWORD PTR _curr$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _c$[ebp], eax

; 1693 : 
; 1694 : 			if ((c->state == COMAPI_STATE_CONNECTION_PENDING) && (c->timeoutsecs))

	mov	ecx, DWORD PTR _c$[ebp]
	movsx	edx, WORD PTR [ecx+522]
	test	edx, edx
	jne	SHORT $LN3@CAPIListFi
	mov	eax, DWORD PTR _c$[ebp]
	movsx	ecx, WORD PTR [eax+518]
	test	ecx, ecx
	je	SHORT $LN3@CAPIListFi

; 1695 : 			{
; 1696 : 				if (c->timeoutsecs <= ((clock() - c->bytes_needed_for_message)/1000))

	mov	edx, DWORD PTR _c$[ebp]
	movsx	esi, WORD PTR [edx+518]
	call	_clock
	mov	ecx, DWORD PTR _c$[ebp]
	sub	eax, DWORD PTR [ecx+548]
	cdq
	mov	ecx, 1000				; 000003e8H
	idiv	ecx
	cmp	esi, eax
	jg	SHORT $LN3@CAPIListFi

; 1697 : 				{
; 1698 : 					c->timeoutsecs = 0;

	xor	edx, edx
	mov	eax, DWORD PTR _c$[ebp]
	mov	WORD PTR [eax+518], dx

; 1699 : 
; 1700 : 					return curr;

	mov	eax, DWORD PTR _curr$[ebp]
	jmp	SHORT $LN7@CAPIListFi
$LN3@CAPIListFi:

; 1701 : 				}
; 1702 : 			}
; 1703 : 		}
; 1704 : 	}

	jmp	SHORT $LN5@CAPIListFi
$LN4@CAPIListFi:

; 1705 : 	
; 1706 : 	return NULL;

	xor	eax, eax
$LN7@CAPIListFi:

; 1707 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_CAPIListFindTCPAcceptPendingExpired ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\tcp.c
_TEXT	SEGMENT
_cip$1 = -12						; size = 4
_c$ = -8						; size = 4
_curr$ = -4						; size = 4
_list$ = 8						; size = 4
_IPaddress$ = 12					; size = 4
_tcpPort$ = 16						; size = 2
_CAPIListFindTCPIPaddress PROC

; 1651 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1652 : 	CAPIList * curr;
; 1653 : 	ComTCP *c;
; 1654 : 	
; 1655 : 	if (IPaddress == 0)

	cmp	DWORD PTR _IPaddress$[ebp], 0
	jne	SHORT $LN6@CAPIListFi

; 1656 : 	{
; 1657 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN7@CAPIListFi
$LN6@CAPIListFi:

; 1658 : 	}
; 1659 : 	
; 1660 : 	for (curr = list; curr; curr = curr -> next)

	mov	eax, DWORD PTR _list$[ebp]
	mov	DWORD PTR _curr$[ebp], eax
	jmp	SHORT $LN5@CAPIListFi
$LN4@CAPIListFi:
	mov	ecx, DWORD PTR _curr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _curr$[ebp], edx
$LN5@CAPIListFi:
	cmp	DWORD PTR _curr$[ebp], 0
	je	SHORT $LN3@CAPIListFi

; 1661 : 	{
; 1662 : 		if (curr->com->protocol == CAPI_TCP_PROTOCOL)

	mov	eax, DWORD PTR _curr$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	DWORD PTR [ecx+4], 5
	jne	SHORT $LN2@CAPIListFi

; 1663 : 		{
; 1664 : 			unsigned long cip;
; 1665 : 
; 1666 : 			c = (ComTCP *)curr->com;

	mov	edx, DWORD PTR _curr$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _c$[ebp], eax

; 1667 : 			cip = c->Addr.sin_addr.s_addr;

	mov	ecx, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR [ecx+472]
	mov	DWORD PTR _cip$1[ebp], edx

; 1668 : 
; 1669 : 			if ((cip == IPaddress) && (c->Addr.sin_port == tcpPort))

	mov	eax, DWORD PTR _cip$1[ebp]
	cmp	eax, DWORD PTR _IPaddress$[ebp]
	jne	SHORT $LN2@CAPIListFi
	mov	ecx, DWORD PTR _c$[ebp]
	movzx	edx, WORD PTR [ecx+470]
	movzx	eax, WORD PTR _tcpPort$[ebp]
	cmp	edx, eax
	jne	SHORT $LN2@CAPIListFi

; 1670 : 			{
; 1671 : 				return curr;

	mov	eax, DWORD PTR _curr$[ebp]
	jmp	SHORT $LN7@CAPIListFi
$LN2@CAPIListFi:

; 1672 : 			}
; 1673 : 		}
; 1674 : 	}

	jmp	SHORT $LN4@CAPIListFi
$LN3@CAPIListFi:

; 1675 : 	
; 1676 : 	return NULL;

	xor	eax, eax
$LN7@CAPIListFi:

; 1677 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CAPIListFindTCPIPaddress ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\tcp.c
_TEXT	SEGMENT
_curr$ = -8						; size = 4
_prev$ = -4						; size = 4
_list$ = 8						; size = 4
_destructor$ = 12					; size = 4
_CAPIListDestroy PROC

; 1714 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1715 : 	CAPIList 
; 1716 : 		*prev,
; 1717 : 		*curr;
; 1718 : 	
; 1719 : 	if (!list)

	cmp	DWORD PTR _list$[ebp], 0
	jne	SHORT $LN5@CAPIListDe

; 1720 : 	{
; 1721 : 		return;

	jmp	SHORT $LN6@CAPIListDe
$LN5@CAPIListDe:

; 1722 : 	}
; 1723 : 	
; 1724 : 	prev = list;

	mov	eax, DWORD PTR _list$[ebp]
	mov	DWORD PTR _prev$[ebp], eax

; 1725 : 	curr = list -> next;

	mov	ecx, DWORD PTR _list$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _curr$[ebp], edx
$LN4@CAPIListDe:

; 1726 : 	
; 1727 : 	while (curr)

	cmp	DWORD PTR _curr$[ebp], 0
	je	SHORT $LN3@CAPIListDe

; 1728 : 	{
; 1729 : 		if (destructor)

	cmp	DWORD PTR _destructor$[ebp], 0
	je	SHORT $LN2@CAPIListDe

; 1730 : 		{
; 1731 : 			(*destructor)(prev -> com);

	mov	eax, DWORD PTR _prev$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	DWORD PTR _destructor$[ebp]
	add	esp, 4
$LN2@CAPIListDe:

; 1732 : 		}
; 1733 : 
; 1734 : 		prev -> next = NULL;

	mov	edx, DWORD PTR _prev$[ebp]
	mov	DWORD PTR [edx], 0

; 1735 : 		
; 1736 : 		free (prev);

	mov	eax, DWORD PTR _prev$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 1737 : 		
; 1738 : 		prev = curr;

	mov	ecx, DWORD PTR _curr$[ebp]
	mov	DWORD PTR _prev$[ebp], ecx

; 1739 : 		curr = curr -> next;

	mov	edx, DWORD PTR _curr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _curr$[ebp], eax

; 1740 : 	}

	jmp	SHORT $LN4@CAPIListDe
$LN3@CAPIListDe:

; 1741 : 	
; 1742 : 	if (destructor)

	cmp	DWORD PTR _destructor$[ebp], 0
	je	SHORT $LN1@CAPIListDe

; 1743 : 	{
; 1744 : 		(*destructor)(prev -> com);

	mov	ecx, DWORD PTR _prev$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	DWORD PTR _destructor$[ebp]
	add	esp, 4
$LN1@CAPIListDe:

; 1745 : 	}
; 1746 : 	
; 1747 : 	prev -> next = NULL;

	mov	eax, DWORD PTR _prev$[ebp]
	mov	DWORD PTR [eax], 0

; 1748 : 	
; 1749 : 	free( prev );

	mov	ecx, DWORD PTR _prev$[ebp]
	push	ecx
	call	_free
	add	esp, 4
$LN6@CAPIListDe:

; 1750 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CAPIListDestroy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\tcp.c
_TEXT	SEGMENT
_curr$ = -4						; size = 4
_list$ = 8						; size = 4
_port$ = 12						; size = 2
_CAPIListFindTCPListenPort PROC

; 1624 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1625 : 	CAPIList * curr;
; 1626 : 	
; 1627 : 	if(port == 0)

	movsx	eax, WORD PTR _port$[ebp]
	test	eax, eax
	jne	SHORT $LN6@CAPIListFi

; 1628 : 	{
; 1629 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN7@CAPIListFi
$LN6@CAPIListFi:

; 1630 : 	}
; 1631 : 	
; 1632 : 	for (curr = list; curr; curr = curr -> next) 

	mov	ecx, DWORD PTR _list$[ebp]
	mov	DWORD PTR _curr$[ebp], ecx
	jmp	SHORT $LN5@CAPIListFi
$LN4@CAPIListFi:
	mov	edx, DWORD PTR _curr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _curr$[ebp], eax
$LN5@CAPIListFi:
	cmp	DWORD PTR _curr$[ebp], 0
	je	SHORT $LN3@CAPIListFi

; 1633 : 	{
; 1634 : 		if (curr->com->protocol == CAPI_TCP_PROTOCOL)

	mov	ecx, DWORD PTR _curr$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx+4], 5
	jne	SHORT $LN2@CAPIListFi

; 1635 : 		{
; 1636 : 			if ((((ComTCP *)(curr -> com ))->ListenPort == port) && (((ComTCP *)(curr -> com ))->handletype == LISTENER))

	mov	eax, DWORD PTR _curr$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	movsx	edx, WORD PTR [ecx+524]
	movsx	eax, WORD PTR _port$[ebp]
	cmp	edx, eax
	jne	SHORT $LN2@CAPIListFi
	mov	ecx, DWORD PTR _curr$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	movsx	eax, WORD PTR [edx+520]
	test	eax, eax
	jne	SHORT $LN2@CAPIListFi

; 1637 : 			{
; 1638 : 				return curr;

	mov	eax, DWORD PTR _curr$[ebp]
	jmp	SHORT $LN7@CAPIListFi
$LN2@CAPIListFi:

; 1639 : 			}
; 1640 : 		}
; 1641 : 	}

	jmp	SHORT $LN4@CAPIListFi
$LN3@CAPIListFi:

; 1642 : 	
; 1643 : 	return NULL ;

	xor	eax, eax
$LN7@CAPIListFi:

; 1644 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CAPIListFindTCPListenPort ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\tcp.c
_TEXT	SEGMENT
_curr$ = -4						; size = 4
_list$ = 8						; size = 4
_com$ = 12						; size = 4
_CAPIListFindHandle PROC

; 1605 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1606 : 	CAPIList * curr;
; 1607 : 	
; 1608 : 	for( curr = list; curr; curr = curr -> next ) 

	mov	eax, DWORD PTR _list$[ebp]
	mov	DWORD PTR _curr$[ebp], eax
	jmp	SHORT $LN4@CAPIListFi
$LN3@CAPIListFi:
	mov	ecx, DWORD PTR _curr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _curr$[ebp], edx
$LN4@CAPIListFi:
	cmp	DWORD PTR _curr$[ebp], 0
	je	SHORT $LN2@CAPIListFi

; 1609 : 	{
; 1610 : 		if ( curr -> com == com )

	mov	eax, DWORD PTR _curr$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR _com$[ebp]
	jne	SHORT $LN1@CAPIListFi

; 1611 : 		{
; 1612 : 			return curr;

	mov	eax, DWORD PTR _curr$[ebp]
	jmp	SHORT $LN5@CAPIListFi
$LN1@CAPIListFi:

; 1613 : 		}
; 1614 : 	}

	jmp	SHORT $LN3@CAPIListFi
$LN2@CAPIListFi:

; 1615 : 	
; 1616 : 	return NULL;

	xor	eax, eax
$LN5@CAPIListFi:

; 1617 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CAPIListFindHandle ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\tcp.c
_TEXT	SEGMENT
_i$ = -8						; size = 4
_curr$ = -4						; size = 4
_list$ = 8						; size = 4
_CAPIListCount PROC

; 1477 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1478 : 	CAPIList *curr;
; 1479 : 	int i;
; 1480 : 	
; 1481 : 	if(!list)

	cmp	DWORD PTR _list$[ebp], 0
	jne	SHORT $LN3@CAPIListCo

; 1482 : 	{
; 1483 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN4@CAPIListCo
$LN3@CAPIListCo:

; 1484 : 	}
; 1485 : 	
; 1486 : 	i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 1487 : 	curr = list; 

	mov	eax, DWORD PTR _list$[ebp]
	mov	DWORD PTR _curr$[ebp], eax
$LN2@CAPIListCo:

; 1488 : 	while (curr)

	cmp	DWORD PTR _curr$[ebp], 0
	je	SHORT $LN1@CAPIListCo

; 1489 : 	{
; 1490 : 		i++;

	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx

; 1491 : 		curr = curr->next;

	mov	edx, DWORD PTR _curr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _curr$[ebp], eax

; 1492 : 	}

	jmp	SHORT $LN2@CAPIListCo
$LN1@CAPIListCo:

; 1493 : 	
; 1494 : 	return i;

	mov	eax, DWORD PTR _i$[ebp]
$LN4@CAPIListCo:

; 1495 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CAPIListCount ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\tcp.c
_TEXT	SEGMENT
_start$ = -12						; size = 4
_prev$ = -8						; size = 4
_curr$ = -4						; size = 4
_list$ = 8						; size = 4
_com$ = 12						; size = 4
_CAPIListRemove PROC

; 1549 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1550 : 	CAPIList
; 1551 : 		*start,
; 1552 : 		*prev,
; 1553 : 		*curr;
; 1554 : 
; 1555 : 	start = list;

	mov	eax, DWORD PTR _list$[ebp]
	mov	DWORD PTR _start$[ebp], eax

; 1556 : 
; 1557 : 	if (!list)

	cmp	DWORD PTR _list$[ebp], 0
	jne	SHORT $LN7@CAPIListRe

; 1558 : 	{
; 1559 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN9@CAPIListRe
$LN7@CAPIListRe:

; 1560 : 	}
; 1561 : 
; 1562 : 	while (1)

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN9@CAPIListRe

; 1563 : 	{
; 1564 : 		prev = NULL;

	mov	DWORD PTR _prev$[ebp], 0

; 1565 : 		curr = list;

	mov	edx, DWORD PTR _list$[ebp]
	mov	DWORD PTR _curr$[ebp], edx
$LN5@CAPIListRe:

; 1566 : 		
; 1567 : 		while ((curr) && (curr -> com != com))

	cmp	DWORD PTR _curr$[ebp], 0
	je	SHORT $LN4@CAPIListRe
	mov	eax, DWORD PTR _curr$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR _com$[ebp]
	je	SHORT $LN4@CAPIListRe

; 1568 : 		{
; 1569 : 			prev = curr;

	mov	edx, DWORD PTR _curr$[ebp]
	mov	DWORD PTR _prev$[ebp], edx

; 1570 : 			curr = curr -> next;

	mov	eax, DWORD PTR _curr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _curr$[ebp], ecx

; 1571 : 		}

	jmp	SHORT $LN5@CAPIListRe
$LN4@CAPIListRe:

; 1572 : 		
; 1573 : 		/* not found, return list unmodified */
; 1574 : 		if (!curr)

	cmp	DWORD PTR _curr$[ebp], 0
	jne	SHORT $LN3@CAPIListRe

; 1575 : 		{
; 1576 : #ifdef _DEBUG
; 1577 : //			if (list)
; 1578 : //				MonoPrint ("%08x = CAPI List Remove %08x \"%s\" %08x\n", list, start, com->name, ((ComIP*)com)->address.sin_addr.s_addr);
; 1579 : #endif
; 1580 : 
; 1581 : 			return list;

	mov	eax, DWORD PTR _list$[ebp]
	jmp	SHORT $LN9@CAPIListRe
$LN3@CAPIListRe:

; 1582 : 		}
; 1583 : 
; 1584 : 		/* found at head */
; 1585 : 		if (!prev)

	cmp	DWORD PTR _prev$[ebp], 0
	jne	SHORT $LN2@CAPIListRe

; 1586 : 		{
; 1587 : 			list = list -> next;

	mov	edx, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _list$[ebp], eax

; 1588 : 		}
; 1589 : 		else

	jmp	SHORT $LN1@CAPIListRe
$LN2@CAPIListRe:

; 1590 : 		{
; 1591 : 			prev -> next = curr -> next;

	mov	ecx, DWORD PTR _prev$[ebp]
	mov	edx, DWORD PTR _curr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
$LN1@CAPIListRe:

; 1592 : 		}
; 1593 : 		
; 1594 : 		curr -> next = NULL;

	mov	ecx, DWORD PTR _curr$[ebp]
	mov	DWORD PTR [ecx], 0

; 1595 : 		
; 1596 : 		free (curr);

	mov	edx, DWORD PTR _curr$[ebp]
	push	edx
	call	_free
	add	esp, 4

; 1597 : 	}

	jmp	SHORT $LN7@CAPIListRe
$LN9@CAPIListRe:

; 1598 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CAPIListRemove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\tcp.c
_TEXT	SEGMENT
_newnode$ = -4						; size = 4
_list$ = 8						; size = 4
_CAPIListAppend PROC

; 1532 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1533 : 	CAPIList * newnode;
; 1534 : 	
; 1535 : 	newnode = (CAPIList *)malloc(sizeof(CAPIList));

	push	12					; 0000000cH
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _newnode$[ebp], eax

; 1536 : 	memset(newnode,0,sizeof(CAPIList));

	push	12					; 0000000cH
	push	0
	mov	eax, DWORD PTR _newnode$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1537 : 	newnode -> com = NULL;

	mov	ecx, DWORD PTR _newnode$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 1538 : 	newnode -> next = list;

	mov	edx, DWORD PTR _newnode$[ebp]
	mov	eax, DWORD PTR _list$[ebp]
	mov	DWORD PTR [edx], eax

; 1539 : 	
; 1540 : 	MonoPrint ("%08x = CAPI List Append %08x\n", newnode, list);

	mov	ecx, DWORD PTR _list$[ebp]
	push	ecx
	mov	edx, DWORD PTR _newnode$[ebp]
	push	edx
	push	OFFSET ??_C@_0BO@NCIPJOJG@?$CF08x?5?$DN?5CAPI?5List?5Append?5?$CF08x?6?$AA@
	call	_MonoPrint
	add	esp, 12					; 0000000cH

; 1541 : 	return newnode;

	mov	eax, DWORD PTR _newnode$[ebp]

; 1542 : }                         

	mov	esp, ebp
	pop	ebp
	ret	0
_CAPIListAppend ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\tcp.c
_TEXT	SEGMENT
_c$ = 8							; size = 4
_ComTCPFreeData PROC

; 1448 : {

	push	ebp
	mov	ebp, esp

; 1449 : 	if(c)

	cmp	DWORD PTR _c$[ebp], 0
	je	SHORT $LN4@ComTCPFree

; 1450 : 	{
; 1451 : 		leave_cs();

	call	_leave_cs

; 1452 : 
; 1453 : 		GlobalListHead = CAPIListRemove(GlobalListHead,(ComAPIHandle)c);

	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	mov	ecx, DWORD PTR _GlobalListHead
	push	ecx
	call	_CAPIListRemove
	add	esp, 8
	mov	DWORD PTR _GlobalListHead, eax

; 1454 : 		
; 1455 : 		leave_cs();

	call	_leave_cs

; 1456 : 
; 1457 : 		/* free the data structs */
; 1458 : 		if(c->recv_buffer.buf)

	mov	edx, DWORD PTR _c$[ebp]
	cmp	DWORD PTR [edx+64], 0
	je	SHORT $LN2@ComTCPFree

; 1459 : 		{
; 1460 : 			free(c->recv_buffer.buf);

	mov	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	call	_free
	add	esp, 4
$LN2@ComTCPFree:

; 1461 : 		}
; 1462 : 
; 1463 : 		if(c->send_buffer.buf)

	mov	edx, DWORD PTR _c$[ebp]
	cmp	DWORD PTR [edx+56], 0
	je	SHORT $LN1@ComTCPFree

; 1464 : 		{
; 1465 : 			free(c->send_buffer.buf);

	mov	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	_free
	add	esp, 4
$LN1@ComTCPFree:

; 1466 : 		}
; 1467 : 
; 1468 : 		free(c);

	mov	edx, DWORD PTR _c$[ebp]
	push	edx
	call	_free
	add	esp, 4
$LN4@ComTCPFree:

; 1469 : 	}
; 1470 : }

	pop	ebp
	ret	0
_ComTCPFreeData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\tcp.c
_TEXT	SEGMENT
_header$ = -4						; size = 4
_data$ = 8						; size = 4
_size$ = 12						; size = 4
_setHeader PROC

; 1393 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1394 : 	tcpHeader *header;
; 1395 : 	
; 1396 : 	if (data)

	cmp	DWORD PTR _data$[ebp], 0
	je	SHORT $LN2@setHeader

; 1397 : 	{
; 1398 : 		header = (tcpHeader *)data;

	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR _header$[ebp], eax

; 1399 : 		header->header_base = HEADER_BASE;

	mov	ecx, 64206				; 0000faceH
	mov	edx, DWORD PTR _header$[ebp]
	mov	WORD PTR [edx], cx

; 1400 : 		header->size = (unsigned short)size;

	mov	eax, DWORD PTR _header$[ebp]
	mov	cx, WORD PTR _size$[ebp]
	mov	WORD PTR [eax+2], cx

; 1401 : 		header->inv_size = (unsigned short)(~size);

	mov	edx, DWORD PTR _size$[ebp]
	not	edx
	mov	eax, DWORD PTR _header$[ebp]
	mov	WORD PTR [eax+4], dx
$LN2@setHeader:

; 1402 : 	}
; 1403 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_setHeader ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\tcp.c
_TEXT	SEGMENT
_lptr$1 = -16						; size = 4
tv76 = -12						; size = 4
_ret$ = -8						; size = 4
_header$2 = -4						; size = 4
_data$ = 8						; size = 4
_isHeader PROC

; 1363 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 1364 : 	unsigned int ret=0;

	mov	DWORD PTR _ret$[ebp], 0

; 1365 : 	
; 1366 : 	if(data)

	cmp	DWORD PTR _data$[ebp], 0
	je	SHORT $LN3@isHeader

; 1367 : 	{
; 1368 : 		tcpHeader *header;
; 1369 : 		unsigned long *lptr;
; 1370 : 		
; 1371 : 		lptr = (unsigned long *)data;

	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR _lptr$1[ebp], eax

; 1372 : 		header = (tcpHeader *)data;

	mov	ecx, DWORD PTR _data$[ebp]
	mov	DWORD PTR _header$2[ebp], ecx

; 1373 : 		ret = 1;

	mov	DWORD PTR _ret$[ebp], 1

; 1374 : 		
; 1375 : 		if (header->header_base != HEADER_BASE)

	mov	edx, DWORD PTR _header$2[ebp]
	movzx	eax, WORD PTR [edx]
	cmp	eax, 64206				; 0000faceH
	je	SHORT $LN2@isHeader

; 1376 : 		{
; 1377 : 			ret = 0;

	mov	DWORD PTR _ret$[ebp], 0

; 1378 : 		}
; 1379 : 		else

	jmp	SHORT $LN3@isHeader
$LN2@isHeader:

; 1380 : 		{
; 1381 : 			ret =  ((header->inv_size ^ header->size) == 0xFFFF) ? header->size : 0;

	mov	ecx, DWORD PTR _header$2[ebp]
	movzx	edx, WORD PTR [ecx+4]
	mov	eax, DWORD PTR _header$2[ebp]
	movzx	ecx, WORD PTR [eax+2]
	xor	edx, ecx
	cmp	edx, 65535				; 0000ffffH
	jne	SHORT $LN6@isHeader
	mov	edx, DWORD PTR _header$2[ebp]
	movzx	eax, WORD PTR [edx+2]
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN7@isHeader
$LN6@isHeader:
	mov	DWORD PTR tv76[ebp], 0
$LN7@isHeader:
	mov	ecx, DWORD PTR tv76[ebp]
	mov	DWORD PTR _ret$[ebp], ecx
$LN3@isHeader:

; 1382 : 		}
; 1383 : 	}
; 1384 : 	
; 1385 : 	return ret;

	mov	eax, DWORD PTR _ret$[ebp]

; 1386 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_isHeader ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\tcp.c
_TEXT	SEGMENT
_w$1 = -36						; size = 4
_starttime$ = -32					; size = 4
_CliAddrLen$ = -28					; size = 4
_trueValue$ = -24					; size = 4
_endtime$ = -20						; size = 4
_FirstWouldblock$ = -16					; size = 4
_err$ = -12						; size = 4
_error$ = -8						; size = 4
_c$ = -4						; size = 4
_cvoid$ = 8						; size = 4
_RequestConnection PROC

; 652  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 653  : 	ComTCP *c = (ComTCP *)cvoid;

	mov	eax, DWORD PTR _cvoid$[ebp]
	mov	DWORD PTR _c$[ebp], eax

; 654  : 	int err;
; 655  : 	int CliAddrLen;
; 656  : 	unsigned long trueValue = 1;

	mov	DWORD PTR _trueValue$[ebp], 1

; 657  : 	int FirstWouldblock;
; 658  : 	int error;
; 659  : 	clock_t starttime,endtime;
; 660  : 	
; 661  : 	CliAddrLen = sizeof(c->Addr);

	mov	DWORD PTR _CliAddrLen$[ebp], 16		; 00000010H

; 662  : 	
; 663  : 	/* set the new socket for Non-Blocking IO */
; 664  : 	if(err=CAPI_ioctlsocket(c->recv_sock, FIONBIO, &trueValue))

	lea	ecx, DWORD PTR _trueValue$[ebp]
	push	ecx
	push	-2147195266				; 8004667eH
	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [edx+488]
	push	eax
	call	DWORD PTR _CAPI_ioctlsocket
	mov	DWORD PTR _err$[ebp], eax
	cmp	DWORD PTR _err$[ebp], 0
	je	SHORT $LN16@RequestCon

; 665  : 	{
; 666  : 		err = CAPI_WSAGetLastError();

	call	DWORD PTR _CAPI_WSAGetLastError
	mov	DWORD PTR _err$[ebp], eax
$LN16@RequestCon:

; 667  : 	}
; 668  : 	
; 669  : 	FirstWouldblock=1;

	mov	DWORD PTR _FirstWouldblock$[ebp], 1

; 670  : 	starttime = clock();

	call	_clock
	mov	DWORD PTR _starttime$[ebp], eax

; 671  : 	c->state = COMAPI_STATE_CONNECTION_PENDING;

	xor	ecx, ecx
	mov	edx, DWORD PTR _c$[ebp]
	mov	WORD PTR [edx+522], cx
$LN15@RequestCon:

; 672  : 	
; 673  : 	while(TRUE)

	mov	eax, 1
	test	eax, eax
	je	$LN14@RequestCon

; 674  : 	{
; 675  : 		Sleep(0);

	push	0
	call	DWORD PTR __imp__Sleep@4

; 676  : 		
; 677  : 		/* Look for a connection */
; 678  : 		if(CAPI_connect(c->recv_sock, (struct sockaddr*)&c->Addr, CliAddrLen))

	mov	ecx, DWORD PTR _CliAddrLen$[ebp]
	push	ecx
	mov	edx, DWORD PTR _c$[ebp]
	add	edx, 468				; 000001d4H
	push	edx
	mov	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR [eax+488]
	push	ecx
	call	DWORD PTR _CAPI_connect
	test	eax, eax
	je	$LN13@RequestCon

; 679  : 		{
; 680  : 			error = CAPI_WSAGetLastError();

	call	DWORD PTR _CAPI_WSAGetLastError
	mov	DWORD PTR _error$[ebp], eax

; 681  : 
; 682  : 			if(error == WSAEWOULDBLOCK)

	cmp	DWORD PTR _error$[ebp], 10035		; 00002733H
	jne	SHORT $LN12@RequestCon

; 683  : 			{
; 684  : 				FirstWouldblock = 0;

	mov	DWORD PTR _FirstWouldblock$[ebp], 0
$LN12@RequestCon:

; 685  : 			}
; 686  : 			
; 687  : 			/* after the first WSAEWOULDBLOCK, WASEISCONN means successfull connection */
; 688  : 			if(error == WSAEISCONN && !FirstWouldblock)  /* got a good connection */

	cmp	DWORD PTR _error$[ebp], 10056		; 00002748H
	jne	SHORT $LN11@RequestCon
	cmp	DWORD PTR _FirstWouldblock$[ebp], 0
	jne	SHORT $LN11@RequestCon

; 689  : 			{
; 690  : 				break;

	jmp	$LN14@RequestCon
$LN11@RequestCon:

; 691  : 			}
; 692  : 
; 693  : 			/* check for timeout */
; 694  : 			endtime = (clock() - starttime)/1000;

	call	_clock
	sub	eax, DWORD PTR _starttime$[ebp]
	cdq
	mov	ecx, 1000				; 000003e8H
	idiv	ecx
	mov	DWORD PTR _endtime$[ebp], eax

; 695  : 			
; 696  : 			/* keep waiting */
; 697  : 			if(error == WSAEWOULDBLOCK || error == WSAEALREADY)

	cmp	DWORD PTR _error$[ebp], 10035		; 00002733H
	je	SHORT $LN9@RequestCon
	cmp	DWORD PTR _error$[ebp], 10037		; 00002735H
	jne	SHORT $LN10@RequestCon
$LN9@RequestCon:

; 698  : 			{
; 699  : 				if(endtime  < c->timeoutsecs)

	mov	edx, DWORD PTR _c$[ebp]
	movsx	eax, WORD PTR [edx+518]
	cmp	DWORD PTR _endtime$[ebp], eax
	jge	SHORT $LN8@RequestCon

; 700  : 				{
; 701  : 					continue;

	jmp	$LN15@RequestCon

; 702  : 				}
; 703  : 				else

	jmp	SHORT $LN7@RequestCon
$LN8@RequestCon:

; 704  : 				{
; 705  : 					/* error or time out here , so inform user and then exit*/
; 706  : 					c->state = COMAPI_STATE_CONNECTED;

	mov	ecx, 1
	mov	edx, DWORD PTR _c$[ebp]
	mov	WORD PTR [edx+522], cx

; 707  : 					c->connect_callback_func((ComAPIHandle)c, -1 * error);

	mov	eax, DWORD PTR _error$[ebp]
	imul	eax, -1
	push	eax
	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [edx+560]
	call	eax
	add	esp, 8

; 708  : 
; 709  : 					return;

	jmp	$LN17@RequestCon
$LN7@RequestCon:

; 710  : 				}
; 711  : 			}
; 712  : 			else

	jmp	SHORT $LN6@RequestCon
$LN10@RequestCon:

; 713  : 			{
; 714  : 				if ((error == WSAEINVAL) && (endtime  < c->timeoutsecs))

	cmp	DWORD PTR _error$[ebp], 10022		; 00002726H
	jne	SHORT $LN5@RequestCon
	mov	ecx, DWORD PTR _c$[ebp]
	movsx	edx, WORD PTR [ecx+518]
	cmp	DWORD PTR _endtime$[ebp], edx
	jge	SHORT $LN5@RequestCon

; 715  : 				{
; 716  : 					continue;

	jmp	$LN15@RequestCon
$LN5@RequestCon:

; 717  : 				}
; 718  : 
; 719  : 				/* error or time out here , so inform user and then exit*/
; 720  : 				c->state = COMAPI_STATE_CONNECTED;

	mov	eax, 1
	mov	ecx, DWORD PTR _c$[ebp]
	mov	WORD PTR [ecx+522], ax

; 721  : 				c->connect_callback_func((ComAPIHandle)c,-1 * error);

	mov	edx, DWORD PTR _error$[ebp]
	imul	edx, -1
	push	edx
	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	mov	ecx, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR [ecx+560]
	call	edx
	add	esp, 8

; 722  : 
; 723  : 				return;

	jmp	$LN17@RequestCon
$LN6@RequestCon:

; 724  : 			}
; 725  : 		}
; 726  : 		else  /* 0 means successful connection */

	jmp	SHORT $LN4@RequestCon
$LN13@RequestCon:

; 727  : 		{
; 728  : 			break;

	jmp	SHORT $LN14@RequestCon
$LN4@RequestCon:

; 729  : 		}
; 730  : 	}

	jmp	$LN15@RequestCon
$LN14@RequestCon:

; 731  : 	
; 732  : 	/* If we get here we have a good connection */
; 733  : 	/* Set send socket to the same */
; 734  : 	c->send_sock = c->recv_sock;

	mov	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR [ecx+488]
	mov	DWORD PTR [eax+484], edx

; 735  : 		
; 736  : 	err = CAPI_setsockopt (c->recv_sock, IPPROTO_TCP,TCP_NODELAY,(char *)&trueValue,sizeof (trueValue));

	push	4
	lea	eax, DWORD PTR _trueValue$[ebp]
	push	eax
	push	1
	push	6
	mov	ecx, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR [ecx+488]
	push	edx
	call	DWORD PTR _CAPI_setsockopt
	mov	DWORD PTR _err$[ebp], eax

; 737  : 	
; 738  : 	if (err)

	cmp	DWORD PTR _err$[ebp], 0
	je	SHORT $LN3@RequestCon

; 739  : 	{
; 740  : 		err = CAPI_WSAGetLastError();

	call	DWORD PTR _CAPI_WSAGetLastError
	mov	DWORD PTR _err$[ebp], eax
$LN3@RequestCon:

; 741  : 	}
; 742  : 	
; 743  : 	/* initialize some data */
; 744  : 	initComTCP(c);

	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	call	_initComTCP
	add	esp, 4

; 745  : 	
; 746  : 	REQUEST_LOCK(c->lock);

	push	-1
	mov	ecx, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR [ecx+508]
	push	edx
	call	DWORD PTR __imp__WaitForSingleObject@8
	mov	DWORD PTR _w$1[ebp], eax
	cmp	DWORD PTR _w$1[ebp], -1
	jne	SHORT $LN2@RequestCon
	call	DWORD PTR __imp__DebugBreak@0
$LN2@RequestCon:

; 747  : 
; 748  : 	c->state = COMAPI_STATE_CONNECTED;

	mov	eax, 1
	mov	ecx, DWORD PTR _c$[ebp]
	mov	WORD PTR [ecx+522], ax

; 749  : 
; 750  : 	RELEASE_LOCK(c->lock);

	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [edx+508]
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4
	test	eax, eax
	jne	SHORT $LN1@RequestCon
	call	DWORD PTR __imp__DebugBreak@0
$LN1@RequestCon:

; 751  : 	
; 752  : 	/* Notify User that we have connected on a socket */
; 753  : 	c->connect_callback_func((ComAPIHandle)c,0);

	push	0
	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [edx+560]
	call	eax
	add	esp, 8
$LN17@RequestCon:

; 754  : 	
; 755  : 	return;
; 756  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_RequestConnection ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\tcp.c
_TEXT	SEGMENT
_w$1 = -72						; size = 4
_w$2 = -68						; size = 4
_w$3 = -64						; size = 4
_CliAddrLen$ = -60					; size = 4
_listitem$4 = -56					; size = 4
_trueValue$ = -52					; size = 4
_connecting_sock$ = -48					; size = 4
_save_send_buffer$5 = -44				; size = 4
_save_recv_buffer$6 = -40				; size = 4
_listitem$7 = -36					; size = 4
_err$ = -32						; size = 4
_ctcpListen$ = -28					; size = 4
_ctcpAccept$ = -24					; size = 4
_comCliAddr$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_cvoid$ = 8						; size = 4
_AcceptConnection PROC

; 444  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 445  : 	ComTCP *ctcpListen = (ComTCP *)cvoid;   /* This is the handle to the listening socket */

	mov	eax, DWORD PTR _cvoid$[ebp]
	mov	DWORD PTR _ctcpListen$[ebp], eax

; 446  : 	int err=0;

	mov	DWORD PTR _err$[ebp], 0

; 447  : 	struct sockaddr_in comCliAddr;
; 448  : 	int CliAddrLen;
; 449  : 	unsigned long trueValue = 1;

	mov	DWORD PTR _trueValue$[ebp], 1

; 450  : 	SOCKET connecting_sock;
; 451  : 	ComTCP *ctcpAccept;
; 452  : 	
; 453  : 	AcceptConnectioncount++;

	mov	ecx, DWORD PTR _AcceptConnectioncount
	add	ecx, 1
	mov	DWORD PTR _AcceptConnectioncount, ecx

; 454  : 	
; 455  : 	CliAddrLen = sizeof(comCliAddr);

	mov	DWORD PTR _CliAddrLen$[ebp], 16		; 00000010H
$LN34@AcceptConn:

; 456  : 	
; 457  : 	/* A call to ComTCPClose will change ->ThreadActive so we can gracefully exit this thread */
; 458  : 	while (TRUE)

	mov	edx, 1
	test	edx, edx
	je	$LN33@AcceptConn

; 459  : 	{
; 460  : 		REQUEST_LOCK(ctcpListen->lock);

	push	-1
	mov	eax, DWORD PTR _ctcpListen$[ebp]
	mov	ecx, DWORD PTR [eax+508]
	push	ecx
	call	DWORD PTR __imp__WaitForSingleObject@8
	mov	DWORD PTR _w$1[ebp], eax
	cmp	DWORD PTR _w$1[ebp], -1
	jne	SHORT $LN32@AcceptConn
	call	DWORD PTR __imp__DebugBreak@0
$LN32@AcceptConn:

; 461  : 		if(ctcpListen->ThreadActive != THREAD_ACTIVE)

	mov	edx, DWORD PTR _ctcpListen$[ebp]
	movsx	eax, WORD PTR [edx+516]
	cmp	eax, 1
	je	SHORT $LN31@AcceptConn

; 462  : 		{
; 463  : 			RELEASE_LOCK(ctcpListen->lock);

	mov	ecx, DWORD PTR _ctcpListen$[ebp]
	mov	edx, DWORD PTR [ecx+508]
	push	edx
	call	DWORD PTR __imp__ReleaseMutex@4
	test	eax, eax
	jne	SHORT $LN30@AcceptConn
	call	DWORD PTR __imp__DebugBreak@0
$LN30@AcceptConn:

; 464  : 			break;

	jmp	$LN33@AcceptConn
$LN31@AcceptConn:

; 465  : 		}
; 466  : 
; 467  : 		RELEASE_LOCK(ctcpListen->lock);

	mov	eax, DWORD PTR _ctcpListen$[ebp]
	mov	ecx, DWORD PTR [eax+508]
	push	ecx
	call	DWORD PTR __imp__ReleaseMutex@4
	test	eax, eax
	jne	SHORT $LN29@AcceptConn
	call	DWORD PTR __imp__DebugBreak@0
$LN29@AcceptConn:

; 468  : 		
; 469  : 		/*	   Sleep(SLEEP_IN_ACCEPT);    */
; 470  : 		err = 0;

	mov	DWORD PTR _err$[ebp], 0

; 471  : 		
; 472  : 		/* wait for a connection */
; 473  : 		CliAddrLen = sizeof(comCliAddr);

	mov	DWORD PTR _CliAddrLen$[ebp], 16		; 00000010H

; 474  : 		connecting_sock =  CAPI_accept (ctcpListen->recv_sock, (struct sockaddr*)&comCliAddr,&CliAddrLen);

	lea	edx, DWORD PTR _CliAddrLen$[ebp]
	push	edx
	lea	eax, DWORD PTR _comCliAddr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctcpListen$[ebp]
	mov	edx, DWORD PTR [ecx+488]
	push	edx
	call	DWORD PTR _CAPI_accept
	mov	DWORD PTR _connecting_sock$[ebp], eax

; 475  : 		
; 476  : 		AcceptCount++;

	mov	eax, DWORD PTR _AcceptCount
	add	eax, 1
	mov	DWORD PTR _AcceptCount, eax

; 477  : 		REQUEST_LOCK(ctcpListen->lock);

	push	-1
	mov	ecx, DWORD PTR _ctcpListen$[ebp]
	mov	edx, DWORD PTR [ecx+508]
	push	edx
	call	DWORD PTR __imp__WaitForSingleObject@8
	mov	DWORD PTR _w$3[ebp], eax
	cmp	DWORD PTR _w$3[ebp], -1
	jne	SHORT $LN28@AcceptConn
	call	DWORD PTR __imp__DebugBreak@0
$LN28@AcceptConn:

; 478  : 		
; 479  : 		/* if reasonable ERROR loop back and wait for another connection */
; 480  : 		if(connecting_sock == INVALID_SOCKET)

	cmp	DWORD PTR _connecting_sock$[ebp], -1
	jne	$LN27@AcceptConn

; 481  : 		{
; 482  : 			err = CAPI_WSAGetLastError(); 

	call	DWORD PTR _CAPI_WSAGetLastError
	mov	DWORD PTR _err$[ebp], eax

; 483  : 			if(err == WSAEWOULDBLOCK)

	cmp	DWORD PTR _err$[ebp], 10035		; 00002733H
	jne	SHORT $LN26@AcceptConn

; 484  : 			{
; 485  : 				CAPIList *listitem;
; 486  : 
; 487  : 				enter_cs();

	call	_enter_cs

; 488  : 
; 489  : 				listitem = CAPIListFindTCPAcceptPendingExpired(GlobalListHead);  

	mov	eax, DWORD PTR _GlobalListHead
	push	eax
	call	_CAPIListFindTCPAcceptPendingExpired
	add	esp, 4
	mov	DWORD PTR _listitem$7[ebp], eax

; 490  : 
; 491  : 				leave_cs();

	call	_leave_cs

; 492  : 
; 493  : 				if( listitem)

	cmp	DWORD PTR _listitem$7[ebp], 0
	je	SHORT $LN25@AcceptConn

; 494  : 				{
; 495  : 					listitem->com->close_func(listitem->com);

	mov	ecx, DWORD PTR _listitem$7[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _listitem$7[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+36]
	call	edx
	add	esp, 4

; 496  : 					((ComTCP *)(listitem->com))->accept_callback_func(listitem->com,COMAPI_CONNECTION_TIMEOUT);

	push	-12					; fffffff4H
	mov	eax, DWORD PTR _listitem$7[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _listitem$7[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+564]
	call	ecx
	add	esp, 8
$LN25@AcceptConn:

; 497  : 				}
; 498  : 				
; 499  : 				RELEASE_LOCK(ctcpListen->lock);

	mov	edx, DWORD PTR _ctcpListen$[ebp]
	mov	eax, DWORD PTR [edx+508]
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4
	test	eax, eax
	jne	SHORT $LN24@AcceptConn
	call	DWORD PTR __imp__DebugBreak@0
$LN24@AcceptConn:

; 500  : 				
; 501  : 				continue;

	jmp	$LN34@AcceptConn
	jmp	SHORT $LN23@AcceptConn
$LN26@AcceptConn:

; 502  : 			}
; 503  : 			else if(ctcpListen->ThreadActive != THREAD_ACTIVE && err == WSAENOTSOCK)

	mov	ecx, DWORD PTR _ctcpListen$[ebp]
	movsx	edx, WORD PTR [ecx+516]
	cmp	edx, 1
	je	SHORT $LN22@AcceptConn
	cmp	DWORD PTR _err$[ebp], 10038		; 00002736H
	jne	SHORT $LN22@AcceptConn

; 504  : 			{
; 505  : 				break;

	jmp	$LN33@AcceptConn

; 506  : 			}
; 507  : 			else

	jmp	SHORT $LN23@AcceptConn
$LN22@AcceptConn:

; 508  : 			{
; 509  : 				RELEASE_LOCK(ctcpListen->lock);

	mov	eax, DWORD PTR _ctcpListen$[ebp]
	mov	ecx, DWORD PTR [eax+508]
	push	ecx
	call	DWORD PTR __imp__ReleaseMutex@4
	test	eax, eax
	jne	SHORT $LN20@AcceptConn
	call	DWORD PTR __imp__DebugBreak@0
$LN20@AcceptConn:

; 510  : 				break;

	jmp	$LN33@AcceptConn
$LN23@AcceptConn:

; 511  : 			}
; 512  : 		}
; 513  : 		else

	jmp	$LN19@AcceptConn
$LN27@AcceptConn:

; 514  : 		{
; 515  : 			CAPIList *listitem;
; 516  : 			char *save_recv_buffer;
; 517  : 			char *save_send_buffer;
; 518  : 			
; 519  : 			save_recv_buffer  =  NULL;

	mov	DWORD PTR _save_recv_buffer$6[ebp], 0

; 520  : 			save_send_buffer  =  NULL;

	mov	DWORD PTR _save_send_buffer$5[ebp], 0

; 521  : 			
; 522  : 			enter_cs();

	call	_enter_cs

; 523  : 			listitem = CAPIListFindTCPIPaddress(GlobalListHead,comCliAddr.sin_addr.s_addr,ctcpListen->Addr.sin_port);

	mov	edx, DWORD PTR _ctcpListen$[ebp]
	movzx	eax, WORD PTR [edx+470]
	push	eax
	mov	ecx, DWORD PTR _comCliAddr$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _GlobalListHead
	push	edx
	call	_CAPIListFindTCPIPaddress
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _listitem$4[ebp], eax

; 524  : 			
; 525  : 			if (listitem)

	cmp	DWORD PTR _listitem$4[ebp], 0
	je	SHORT $LN18@AcceptConn

; 526  : 			{
; 527  : 				ctcpAccept = (ComTCP *)listitem->com;

	mov	eax, DWORD PTR _listitem$4[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _ctcpAccept$[ebp], ecx

; 528  : 				save_recv_buffer =  ctcpAccept->recv_buffer.buf;

	mov	edx, DWORD PTR _ctcpAccept$[ebp]
	mov	eax, DWORD PTR [edx+64]
	mov	DWORD PTR _save_recv_buffer$6[ebp], eax

; 529  : 				save_send_buffer  = ctcpAccept->send_buffer.buf;

	mov	ecx, DWORD PTR _ctcpAccept$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	DWORD PTR _save_send_buffer$5[ebp], edx

; 530  : 			}
; 531  : 			else

	jmp	SHORT $LN17@AcceptConn
$LN18@AcceptConn:

; 532  : 			{
; 533  : 				/*  Create a new entry in list of connections */
; 534  : 				
; 535  : 				GlobalListHead = CAPIListAppend(GlobalListHead);

	mov	eax, DWORD PTR _GlobalListHead
	push	eax
	call	_CAPIListAppend
	add	esp, 4
	mov	DWORD PTR _GlobalListHead, eax

; 536  : 
; 537  : 				if(!GlobalListHead)

	cmp	DWORD PTR _GlobalListHead, 0
	jne	SHORT $LN16@AcceptConn

; 538  : 				{
; 539  : 				    leave_cs();

	call	_leave_cs

; 540  : 					return;

	jmp	$LN35@AcceptConn
$LN16@AcceptConn:

; 541  : 				}
; 542  : 				
; 543  : 				/* allocate a new ComHandle struct */
; 544  : 				GlobalListHead->com = (ComAPIHandle)malloc(sizeof(ComTCP));

	push	572					; 0000023cH
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _GlobalListHead
	mov	DWORD PTR [ecx+8], eax

; 545  : 				ctcpAccept = (ComTCP *)(GlobalListHead->com);

	mov	edx, DWORD PTR _GlobalListHead
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _ctcpAccept$[ebp], eax

; 546  : 				memset(ctcpAccept,0,sizeof(ComTCP));

	push	572					; 0000023cH
	push	0
	mov	ecx, DWORD PTR _ctcpAccept$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
$LN17@AcceptConn:

; 547  : 			}
; 548  : 
; 549  : 			leave_cs();

	call	_leave_cs

; 550  : 			
; 551  : 			/* copy the Listen socket's ComHandle data into the Accepted socket's ComHandle*/
; 552  : 			memcpy(ctcpAccept,ctcpListen,sizeof(ComTCP));

	push	572					; 0000023cH
	mov	edx, DWORD PTR _ctcpListen$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctcpAccept$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 553  : 			
; 554  : 			/* BUT  no thread on accepted sockets  */
; 555  : 			ctcpAccept->ThreadActive = THREAD_STOP;  

	xor	ecx, ecx
	mov	edx, DWORD PTR _ctcpAccept$[ebp]
	mov	WORD PTR [edx+516], cx

; 556  : 			ctcpAccept->handletype = CONNECTION;

	mov	eax, 2
	mov	ecx, DWORD PTR _ctcpAccept$[ebp]
	mov	WORD PTR [ecx+520], ax

; 557  : 			
; 558  : 			/* copy  who we are connected to */
; 559  : 			ctcpAccept->Addr.sin_addr=comCliAddr.sin_addr;

	mov	edx, DWORD PTR _ctcpAccept$[ebp]
	mov	eax, DWORD PTR _comCliAddr$[ebp+4]
	mov	DWORD PTR [edx+472], eax

; 560  : 			
; 561  : 			/* set the socket numbers */
; 562  : 			ctcpAccept->recv_sock = ctcpAccept->send_sock = connecting_sock;

	mov	ecx, DWORD PTR _ctcpAccept$[ebp]
	mov	edx, DWORD PTR _connecting_sock$[ebp]
	mov	DWORD PTR [ecx+484], edx
	mov	eax, DWORD PTR _ctcpAccept$[ebp]
	mov	ecx, DWORD PTR _connecting_sock$[ebp]
	mov	DWORD PTR [eax+488], ecx

; 563  : 			
; 564  : 			/* allocate send and receive data buffers */
; 565  : 			if( save_send_buffer  ==  NULL)

	cmp	DWORD PTR _save_send_buffer$5[ebp], 0
	jne	SHORT $LN15@AcceptConn

; 566  : 			{
; 567  : 				ctcpAccept->send_buffer.buf = (char *)malloc(ctcpListen->buffer_size);

	mov	edx, DWORD PTR _ctcpListen$[ebp]
	mov	eax, DWORD PTR [edx+48]
	push	eax
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _ctcpAccept$[ebp]
	mov	DWORD PTR [ecx+56], eax

; 568  : 			}
; 569  : 			else 

	jmp	SHORT $LN14@AcceptConn
$LN15@AcceptConn:

; 570  : 			{
; 571  : 				ctcpAccept->send_buffer.buf = save_send_buffer;

	mov	edx, DWORD PTR _ctcpAccept$[ebp]
	mov	eax, DWORD PTR _save_send_buffer$5[ebp]
	mov	DWORD PTR [edx+56], eax
$LN14@AcceptConn:

; 572  : 			}
; 573  : 
; 574  : 			if (save_recv_buffer  ==  NULL)

	cmp	DWORD PTR _save_recv_buffer$6[ebp], 0
	jne	SHORT $LN13@AcceptConn

; 575  : 			{
; 576  : 				ctcpAccept->recv_buffer.buf = (char *)malloc( ctcpListen->buffer_size);

	mov	ecx, DWORD PTR _ctcpListen$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _ctcpAccept$[ebp]
	mov	DWORD PTR [ecx+64], eax

; 577  : 			}
; 578  : 			else

	jmp	SHORT $LN12@AcceptConn
$LN13@AcceptConn:

; 579  : 			{
; 580  : 				ctcpAccept->recv_buffer.buf = save_recv_buffer;

	mov	edx, DWORD PTR _ctcpAccept$[ebp]
	mov	eax, DWORD PTR _save_recv_buffer$6[ebp]
	mov	DWORD PTR [edx+64], eax
$LN12@AcceptConn:

; 581  : 			}
; 582  : 
; 583  : 			ctcpAccept->recv_buffer_start = ctcpAccept->recv_buffer.buf;

	mov	ecx, DWORD PTR _ctcpAccept$[ebp]
	mov	edx, DWORD PTR _ctcpAccept$[ebp]
	mov	eax, DWORD PTR [edx+64]
	mov	DWORD PTR [ecx+540], eax

; 584  : 			ctcpAccept->referencecount = 1;

	mov	ecx, DWORD PTR _ctcpAccept$[ebp]
	mov	DWORD PTR [ecx+528], 1

; 585  : 			
; 586  : 			/* Create a mutex for this connection */
; 587  : 			CREATE_LOCK(ctcpAccept->lock,"accept socket");

	push	OFFSET ??_C@_0O@EDEIBAPN@accept?5socket?$AA@
	push	0
	push	0
	call	DWORD PTR __imp__CreateMutexA@12
	mov	edx, DWORD PTR _ctcpAccept$[ebp]
	mov	DWORD PTR [edx+508], eax
	mov	eax, DWORD PTR _ctcpAccept$[ebp]
	cmp	DWORD PTR [eax+508], 0
	jne	SHORT $LN11@AcceptConn
	call	DWORD PTR __imp__DebugBreak@0
$LN11@AcceptConn:

; 588  : 			
; 589  : 			/* Now set the new socket for Non-Blocking IO */
; 590  : 			if(err=CAPI_ioctlsocket(ctcpAccept->recv_sock, FIONBIO, &trueValue))

	lea	ecx, DWORD PTR _trueValue$[ebp]
	push	ecx
	push	-2147195266				; 8004667eH
	mov	edx, DWORD PTR _ctcpAccept$[ebp]
	mov	eax, DWORD PTR [edx+488]
	push	eax
	call	DWORD PTR _CAPI_ioctlsocket
	mov	DWORD PTR _err$[ebp], eax
	cmp	DWORD PTR _err$[ebp], 0
	je	SHORT $LN10@AcceptConn

; 591  : 			{
; 592  : 				err = CAPI_WSAGetLastError();

	call	DWORD PTR _CAPI_WSAGetLastError
	mov	DWORD PTR _err$[ebp], eax
$LN10@AcceptConn:

; 593  : 			}
; 594  : 			
; 595  : 			/* turn off the Nagle alog. which buffers small messages */
; 596  : 			err = CAPI_setsockopt (ctcpAccept->recv_sock, IPPROTO_TCP,TCP_NODELAY, (char *)&trueValue, sizeof (trueValue));

	push	4
	lea	ecx, DWORD PTR _trueValue$[ebp]
	push	ecx
	push	1
	push	6
	mov	edx, DWORD PTR _ctcpAccept$[ebp]
	mov	eax, DWORD PTR [edx+488]
	push	eax
	call	DWORD PTR _CAPI_setsockopt
	mov	DWORD PTR _err$[ebp], eax

; 597  : 			
; 598  : 			if (err)

	cmp	DWORD PTR _err$[ebp], 0
	je	SHORT $LN9@AcceptConn

; 599  : 			{
; 600  : 				err = CAPI_WSAGetLastError();

	call	DWORD PTR _CAPI_WSAGetLastError
	mov	DWORD PTR _err$[ebp], eax
$LN9@AcceptConn:

; 601  : 			}
; 602  : 			
; 603  : 			/* initialize header data values */
; 604  : 			initComTCP(ctcpAccept);

	mov	ecx, DWORD PTR _ctcpAccept$[ebp]
	push	ecx
	call	_initComTCP
	add	esp, 4

; 605  : 			
; 606  : 			/* Increment reference count of openconnections */
; 607  : 			/* we have to do this here because no explicit WS2Init() was called */
; 608  : 			WS2Connections++;

	mov	edx, DWORD PTR _WS2Connections
	add	edx, 1
	mov	DWORD PTR _WS2Connections, edx

; 609  : 			
; 610  : 			/* Notify User thru his callback that we have connected on a socket */
; 611  : 			ctcpAccept->state = COMAPI_STATE_ACCEPTED;

	mov	eax, 2
	mov	ecx, DWORD PTR _ctcpAccept$[ebp]
	mov	WORD PTR [ecx+522], ax

; 612  : 			
; 613  : 			ctcpAccept->accept_callback_func((ComAPIHandle)ctcpAccept,0);

	push	0
	mov	edx, DWORD PTR _ctcpAccept$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctcpAccept$[ebp]
	mov	ecx, DWORD PTR [eax+564]
	call	ecx
	add	esp, 8

; 614  : 			
; 615  : 			/* Any errors ? */
; 616  : 			if ( err )

	cmp	DWORD PTR _err$[ebp], 0
	je	SHORT $LN8@AcceptConn

; 617  : 			{
; 618  : 				RELEASE_LOCK(ctcpListen->lock);

	mov	edx, DWORD PTR _ctcpListen$[ebp]
	mov	eax, DWORD PTR [edx+508]
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4
	test	eax, eax
	jne	SHORT $LN7@AcceptConn
	call	DWORD PTR __imp__DebugBreak@0
$LN7@AcceptConn:

; 619  : 				break;			  

	jmp	SHORT $LN33@AcceptConn
$LN8@AcceptConn:

; 620  : 			}
; 621  : 			
; 622  : 			RELEASE_LOCK(ctcpListen->lock);

	mov	ecx, DWORD PTR _ctcpListen$[ebp]
	mov	edx, DWORD PTR [ecx+508]
	push	edx
	call	DWORD PTR __imp__ReleaseMutex@4
	test	eax, eax
	jne	SHORT $LN19@AcceptConn
	call	DWORD PTR __imp__DebugBreak@0
$LN19@AcceptConn:

; 623  : 		}
; 624  : 	}

	jmp	$LN34@AcceptConn
$LN33@AcceptConn:

; 625  : 
; 626  : 	/* If we get here we need to exit to terminate the thread */
; 627  : 
; 628  : 	REQUEST_LOCK(ctcpListen->lock); 

	push	-1
	mov	eax, DWORD PTR _ctcpListen$[ebp]
	mov	ecx, DWORD PTR [eax+508]
	push	ecx
	call	DWORD PTR __imp__WaitForSingleObject@8
	mov	DWORD PTR _w$2[ebp], eax
	cmp	DWORD PTR _w$2[ebp], -1
	jne	SHORT $LN5@AcceptConn
	call	DWORD PTR __imp__DebugBreak@0
$LN5@AcceptConn:

; 629  : 
; 630  : 	if(ctcpListen->ThreadActive == THREAD_ACTIVE)  /* we got here due to a break */

	mov	edx, DWORD PTR _ctcpListen$[ebp]
	movsx	eax, WORD PTR [edx+516]
	cmp	eax, 1
	jne	SHORT $LN4@AcceptConn

; 631  : 	{
; 632  : 		/* indicate that thread is inactive, about to exit */
; 633  : 		ctcpListen->ThreadActive = THREAD_STOP;

	xor	ecx, ecx
	mov	edx, DWORD PTR _ctcpListen$[ebp]
	mov	WORD PTR [edx+516], cx

; 634  : 		RELEASE_LOCK(ctcpListen->lock);

	mov	eax, DWORD PTR _ctcpListen$[ebp]
	mov	ecx, DWORD PTR [eax+508]
	push	ecx
	call	DWORD PTR __imp__ReleaseMutex@4
	test	eax, eax
	jne	SHORT $LN3@AcceptConn
	call	DWORD PTR __imp__DebugBreak@0
$LN3@AcceptConn:

; 635  : 		
; 636  : 	}
; 637  : 	else

	jmp	SHORT $LN35@AcceptConn
$LN4@AcceptConn:

; 638  : 	{
; 639  : 		/* indicate that we are exiting to ComTCPClose which is waiting for exit of thread*/
; 640  : 		ctcpListen->ThreadActive = THREAD_TERMINATED;

	mov	edx, 2
	mov	eax, DWORD PTR _ctcpListen$[ebp]
	mov	WORD PTR [eax+516], dx

; 641  : 		RELEASE_LOCK(ctcpListen->lock);

	mov	ecx, DWORD PTR _ctcpListen$[ebp]
	mov	edx, DWORD PTR [ecx+508]
	push	edx
	call	DWORD PTR __imp__ReleaseMutex@4
	test	eax, eax
	jne	SHORT $LN35@AcceptConn
	call	DWORD PTR __imp__DebugBreak@0
$LN35@AcceptConn:

; 642  : 	}
; 643  : 
; 644  : 	return;
; 645  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_AcceptConnection ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\tcp.c
_TEXT	SEGMENT
_ctcp$1 = -4						; size = 4
_c$ = 8							; size = 4
_ComTCPGetTimeStamp PROC

; 2653 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2654 : 	if(c)

	cmp	DWORD PTR _c$[ebp], 0
	je	SHORT $LN2@ComTCPGetT

; 2655 : 	{
; 2656 : 		ComTCP *ctcp = (ComTCP *)c;

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _ctcp$1[ebp], eax

; 2657 : 		
; 2658 : 		return ctcp->timestamp;

	mov	ecx, DWORD PTR _ctcp$1[ebp]
	mov	eax, DWORD PTR [ecx+568]
	jmp	SHORT $LN3@ComTCPGetT

; 2659 : 	}
; 2660 : 	else

	jmp	SHORT $LN3@ComTCPGetT
$LN2@ComTCPGetT:

; 2661 : 	{
; 2662 : 		return 0;

	xor	eax, eax
$LN3@ComTCPGetT:

; 2663 : 	}
; 2664 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ComTCPGetTimeStamp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\tcp.c
_TEXT	SEGMENT
tv68 = -4						; size = 4
_c$ = 8							; size = 4
_querytype$ = 12					; size = 4
_ComTCPQuery PROC

; 1075 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1076 : 	if(c)

	cmp	DWORD PTR _c$[ebp], 0
	je	$LN19@ComTCPQuer

; 1077 : 	{
; 1078 : 		if (((ComTCP *)c)->handletype == GROUP)

	mov	eax, DWORD PTR _c$[ebp]
	movsx	ecx, WORD PTR [eax+520]
	cmp	ecx, 1
	jne	SHORT $LN18@ComTCPQuer

; 1079 : 		{
; 1080 : 			return 0;

	xor	eax, eax
	jmp	$LN20@ComTCPQuer
$LN18@ComTCPQuer:

; 1081 : 		}
; 1082 : 		
; 1083 : 		switch(querytype)

	mov	edx, DWORD PTR _querytype$[ebp]
	mov	DWORD PTR tv68[ebp], edx
	mov	eax, DWORD PTR tv68[ebp]
	sub	eax, 1
	mov	DWORD PTR tv68[ebp], eax
	cmp	DWORD PTR tv68[ebp], 19			; 00000013H
	ja	$LN1@ComTCPQuer
	mov	ecx, DWORD PTR tv68[ebp]
	jmp	DWORD PTR $LN22@ComTCPQuer[ecx*4]
$LN15@ComTCPQuer:

; 1084 : 		{
; 1085 : 			case COMAPI_MESSAGECOUNT:
; 1086 : 				return ((ComTCP *)c)->sendmessagecount + ((ComTCP *)c)->recvmessagecount;

	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [edx+492]
	mov	ecx, DWORD PTR _c$[ebp]
	add	eax, DWORD PTR [ecx+496]
	jmp	$LN20@ComTCPQuer

; 1087 : 				break;

	jmp	$LN19@ComTCPQuer
$LN14@ComTCPQuer:

; 1088 : 
; 1089 : 			case COMAPI_SEND_MESSAGECOUNT:
; 1090 : 				return ((ComTCP *)c)->sendmessagecount;

	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [edx+492]
	jmp	$LN20@ComTCPQuer

; 1091 : 				break;

	jmp	$LN19@ComTCPQuer
$LN13@ComTCPQuer:

; 1092 : 
; 1093 : 			case COMAPI_RECV_MESSAGECOUNT:
; 1094 : 				return ((ComTCP *)c)->recvmessagecount;

	mov	eax, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [eax+496]
	jmp	$LN20@ComTCPQuer

; 1095 : 				break;

	jmp	$LN19@ComTCPQuer
$LN12@ComTCPQuer:

; 1096 : 
; 1097 : 			case COMAPI_RECV_WOULDBLOCKCOUNT:
; 1098 : 				return ((ComTCP *)c)->recvwouldblockcount;

	mov	ecx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [ecx+504]
	jmp	$LN20@ComTCPQuer

; 1099 : 				break;

	jmp	SHORT $LN19@ComTCPQuer
$LN11@ComTCPQuer:

; 1100 : 
; 1101 : 			case COMAPI_SEND_WOULDBLOCKCOUNT:
; 1102 : 				return ((ComTCP *)c)->sendwouldblockcount;

	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [edx+500]
	jmp	SHORT $LN20@ComTCPQuer

; 1103 : 				break;

	jmp	SHORT $LN19@ComTCPQuer
$LN10@ComTCPQuer:

; 1104 : 
; 1105 : 			case COMAPI_CONNECTION_ADDRESS:
; 1106 : 			case COMAPI_SENDER:
; 1107 : 				return CAPI_ntohl(((ComTCP *)c)->Addr.sin_addr.s_addr);

	mov	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR [eax+472]
	push	ecx
	call	DWORD PTR _CAPI_ntohl
	jmp	SHORT $LN20@ComTCPQuer

; 1108 : 				break;

	jmp	SHORT $LN19@ComTCPQuer
$LN9@ComTCPQuer:

; 1109 : 
; 1110 : 			case COMAPI_RECEIVE_SOCKET:
; 1111 : 				return ((ComTCP *)c)->recv_sock;

	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [edx+488]
	jmp	SHORT $LN20@ComTCPQuer

; 1112 : 				break;

	jmp	SHORT $LN19@ComTCPQuer
$LN8@ComTCPQuer:

; 1113 : 
; 1114 : 			case COMAPI_SEND_SOCKET:
; 1115 : 				return ((ComTCP *)c)->send_sock;

	mov	eax, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [eax+484]
	jmp	SHORT $LN20@ComTCPQuer

; 1116 : 				break;

	jmp	SHORT $LN19@ComTCPQuer
$LN7@ComTCPQuer:

; 1117 : 
; 1118 : 			case COMAPI_RELIABLE:
; 1119 : 				return 1;

	mov	eax, 1
	jmp	SHORT $LN20@ComTCPQuer

; 1120 : 				break;

	jmp	SHORT $LN19@ComTCPQuer
$LN6@ComTCPQuer:

; 1121 : 
; 1122 : 			case COMAPI_MAX_BUFFER_SIZE:
; 1123 : 				return  0;

	xor	eax, eax
	jmp	SHORT $LN20@ComTCPQuer

; 1124 : 				break;

	jmp	SHORT $LN19@ComTCPQuer
$LN5@ComTCPQuer:

; 1125 : 
; 1126 : 			case COMAPI_ACTUAL_BUFFER_SIZE:
; 1127 : 				return ((ComIP *)c)->buffer_size - sizeof(tcpHeader);

	mov	ecx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [ecx+48]
	sub	eax, 6
	jmp	SHORT $LN20@ComTCPQuer

; 1128 : 				break;

	jmp	SHORT $LN19@ComTCPQuer
$LN4@ComTCPQuer:

; 1129 : 
; 1130 : 			case COMAPI_PROTOCOL:
; 1131 : 				return  c->protocol;

	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [edx+4]
	jmp	SHORT $LN20@ComTCPQuer

; 1132 : 				break;

	jmp	SHORT $LN19@ComTCPQuer
$LN3@ComTCPQuer:

; 1133 : 
; 1134 : 			case COMAPI_STATE:
; 1135 : 				return  ((ComTCP *)c)->state;

	mov	eax, DWORD PTR _c$[ebp]
	movsx	eax, WORD PTR [eax+522]
	jmp	SHORT $LN20@ComTCPQuer

; 1136 : 				break;

	jmp	SHORT $LN19@ComTCPQuer
$LN2@ComTCPQuer:

; 1137 : 
; 1138 : 			case COMAPI_TCP_HEADER_OVERHEAD:
; 1139 : 				return sizeof(tcpHeader) + 40;	// Size of underlying header.

	mov	eax, 46					; 0000002eH
	jmp	SHORT $LN20@ComTCPQuer

; 1140 : 				break;

	jmp	SHORT $LN19@ComTCPQuer
$LN1@ComTCPQuer:

; 1141 : 				
; 1142 : 			default:
; 1143 : 				return 0;

	xor	eax, eax
	jmp	SHORT $LN20@ComTCPQuer
$LN19@ComTCPQuer:

; 1144 : 		}
; 1145 : 	}
; 1146 : 
; 1147 : 	return 0;

	xor	eax, eax
$LN20@ComTCPQuer:

; 1148 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN22@ComTCPQuer:
	DD	$LN15@ComTCPQuer
	DD	$LN12@ComTCPQuer
	DD	$LN11@ComTCPQuer
	DD	$LN10@ComTCPQuer
	DD	$LN9@ComTCPQuer
	DD	$LN8@ComTCPQuer
	DD	$LN7@ComTCPQuer
	DD	$LN13@ComTCPQuer
	DD	$LN14@ComTCPQuer
	DD	$LN1@ComTCPQuer
	DD	$LN1@ComTCPQuer
	DD	$LN1@ComTCPQuer
	DD	$LN6@ComTCPQuer
	DD	$LN5@ComTCPQuer
	DD	$LN4@ComTCPQuer
	DD	$LN3@ComTCPQuer
	DD	$LN1@ComTCPQuer
	DD	$LN1@ComTCPQuer
	DD	$LN10@ComTCPQuer
	DD	$LN2@ComTCPQuer
_ComTCPQuery ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\tcp.c
_TEXT	SEGMENT
_ctcp$ = -12						; size = 4
_BytesGotten$ = -8					; size = 4
_bytesRecvd$ = -4					; size = 4
_c$ = 8							; size = 4
_BytesToGet$ = 12					; size = 4
_ComTCPGetNbytes PROC

; 1411 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1412 : 	ComTCP *ctcp = (ComTCP *)c;

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _ctcp$[ebp], eax

; 1413 : 	int bytesRecvd=1;

	mov	DWORD PTR _bytesRecvd$[ebp], 1

; 1414 : 	int BytesGotten=0;

	mov	DWORD PTR _BytesGotten$[ebp], 0

; 1415 : 	
; 1416 : 	if(c)

	cmp	DWORD PTR _c$[ebp], 0
	je	SHORT $LN6@ComTCPGetN
$LN5@ComTCPGetN:

; 1417 : 	{
; 1418 : 		//	while(BytesGotten < BytesToGet && bytesRecvd > 0)
; 1419 : 		while(BytesToGet && bytesRecvd > 0)

	cmp	DWORD PTR _BytesToGet$[ebp], 0
	je	SHORT $LN6@ComTCPGetN
	cmp	DWORD PTR _bytesRecvd$[ebp], 0
	jle	SHORT $LN6@ComTCPGetN

; 1420 : 		{
; 1421 : 			bytesRecvd = ComTCPRecv(c,BytesToGet);

	mov	ecx, DWORD PTR _BytesToGet$[ebp]
	push	ecx
	mov	edx, DWORD PTR _c$[ebp]
	push	edx
	call	_ComTCPRecv
	add	esp, 8
	mov	DWORD PTR _bytesRecvd$[ebp], eax

; 1422 : 			
; 1423 : 			/* If bytesRecvd == 0 means nothing to get .. so quit */
; 1424 : 			if (bytesRecvd > 0)

	cmp	DWORD PTR _bytesRecvd$[ebp], 0
	jle	SHORT $LN3@ComTCPGetN

; 1425 : 			{
; 1426 : 				BytesGotten += bytesRecvd;

	mov	eax, DWORD PTR _BytesGotten$[ebp]
	add	eax, DWORD PTR _bytesRecvd$[ebp]
	mov	DWORD PTR _BytesGotten$[ebp], eax

; 1427 : 				BytesToGet -= bytesRecvd;

	mov	ecx, DWORD PTR _BytesToGet$[ebp]
	sub	ecx, DWORD PTR _bytesRecvd$[ebp]
	mov	DWORD PTR _BytesToGet$[ebp], ecx

; 1428 : 				ctcp->recv_buffer.buf += bytesRecvd;  /* move the receive buffer start point along */

	mov	edx, DWORD PTR _ctcp$[ebp]
	mov	eax, DWORD PTR [edx+64]
	add	eax, DWORD PTR _bytesRecvd$[ebp]
	mov	ecx, DWORD PTR _ctcp$[ebp]
	mov	DWORD PTR [ecx+64], eax

; 1429 : 			}
; 1430 : 			else

	jmp	SHORT $LN2@ComTCPGetN
$LN3@ComTCPGetN:

; 1431 : 			{
; 1432 : 				if (bytesRecvd < 0)

	cmp	DWORD PTR _bytesRecvd$[ebp], 0
	jge	SHORT $LN2@ComTCPGetN

; 1433 : 				{
; 1434 : 					BytesGotten = bytesRecvd; /*negative error back  thru BytesGotten */

	mov	edx, DWORD PTR _bytesRecvd$[ebp]
	mov	DWORD PTR _BytesGotten$[ebp], edx
$LN2@ComTCPGetN:

; 1435 : 				}
; 1436 : 			}
; 1437 : 		}

	jmp	SHORT $LN5@ComTCPGetN
$LN6@ComTCPGetN:

; 1438 : 	}
; 1439 : 
; 1440 : 	return BytesGotten;

	mov	eax, DWORD PTR _BytesGotten$[ebp]

; 1441 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ComTCPGetNbytes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\tcp.c
_TEXT	SEGMENT
_c$ = 8							; size = 4
_initComTCP PROC

; 1350 : {

	push	ebp
	mov	ebp, esp

; 1351 : 	c->headersize = sizeof(tcpHeader);

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+536], 6

; 1352 : 	c->bytes_needed_for_header = c->headersize;

	mov	ecx, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [edx+536]
	mov	DWORD PTR [ecx+544], eax

; 1353 : 	c->bytes_needed_for_message = 0;

	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+548], 0

; 1354 : 	
; 1355 : 	return;
; 1356 : }

	pop	ebp
	ret	0
_initComTCP ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\tcp.c
_TEXT	SEGMENT
_bytesRecvd$1 = -12					; size = 4
_recverror$2 = -8					; size = 4
_ctcp$3 = -4						; size = 4
_c$ = 8							; size = 4
_BytesToRecv$ = 12					; size = 4
_ComTCPRecv PROC

; 1155 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1156 : 	if(c)

	cmp	DWORD PTR _c$[ebp], 0
	je	$LN11@ComTCPRecv

; 1157 : 	{
; 1158 : 		ComTCP *ctcp = (ComTCP *)c;

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _ctcp$3[ebp], eax

; 1159 : 		int recverror;
; 1160 : 		int bytesRecvd;
; 1161 : //		int flags = 0;
; 1162 : 		
; 1163 : 		ctcp->recv_buffer.len = BytesToRecv;

	mov	ecx, DWORD PTR _ctcp$3[ebp]
	mov	edx, DWORD PTR _BytesToRecv$[ebp]
	mov	DWORD PTR [ecx+60], edx

; 1164 : 		
; 1165 : 		/* precautionary test to protect buffers, since recv_buffer.buf is updated in ComTCPGetNBytes() */
; 1166 : 		if (ctcp->recv_buffer.buf + ctcp->recv_buffer.len > ctcp->recv_buffer_start + ctcp->buffer_size)

	mov	eax, DWORD PTR _ctcp$3[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	edx, DWORD PTR _ctcp$3[ebp]
	add	ecx, DWORD PTR [edx+60]
	mov	eax, DWORD PTR _ctcp$3[ebp]
	mov	edx, DWORD PTR [eax+540]
	mov	eax, DWORD PTR _ctcp$3[ebp]
	add	edx, DWORD PTR [eax+48]
	cmp	ecx, edx
	jbe	SHORT $LN10@ComTCPRecv

; 1167 : 		{
; 1168 : 			return COMAPI_OVERRUN_ERROR;

	mov	eax, -3					; fffffffdH
	jmp	$LN12@ComTCPRecv
$LN10@ComTCPRecv:

; 1169 : 		}
; 1170 : 		
; 1171 : 		/* now perform the the receive */
; 1172 : 		bytesRecvd = CAPI_recv(ctcp->recv_sock,ctcp->recv_buffer.buf,ctcp->recv_buffer.len,0);

	push	0
	mov	ecx, DWORD PTR _ctcp$3[ebp]
	mov	edx, DWORD PTR [ecx+60]
	push	edx
	mov	eax, DWORD PTR _ctcp$3[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	mov	edx, DWORD PTR _ctcp$3[ebp]
	mov	eax, DWORD PTR [edx+488]
	push	eax
	call	DWORD PTR _CAPI_recv
	mov	DWORD PTR _bytesRecvd$1[ebp], eax

; 1173 : 		
; 1174 : 		recverror = 0;

	mov	DWORD PTR _recverror$2[ebp], 0

; 1175 : 
; 1176 : 		if(bytesRecvd == 0 )

	cmp	DWORD PTR _bytesRecvd$1[ebp], 0
	jne	SHORT $LN9@ComTCPRecv

; 1177 : 		{
; 1178 : 			recverror = COMAPI_CONNECTION_CLOSED;      /* graceful close is indicated */

	mov	DWORD PTR _recverror$2[ebp], -5		; fffffffbH
	jmp	SHORT $LN8@ComTCPRecv
$LN9@ComTCPRecv:

; 1179 : 		}
; 1180 : 		else if(bytesRecvd == SOCKET_ERROR)

	cmp	DWORD PTR _bytesRecvd$1[ebp], -1
	jne	SHORT $LN8@ComTCPRecv

; 1181 : 		{
; 1182 : 			recverror = CAPI_WSAGetLastError();      /* error condition */

	call	DWORD PTR _CAPI_WSAGetLastError
	mov	DWORD PTR _recverror$2[ebp], eax
$LN8@ComTCPRecv:

; 1183 : 		}
; 1184 : 		
; 1185 : 		if(recverror)

	cmp	DWORD PTR _recverror$2[ebp], 0
	je	SHORT $LN6@ComTCPRecv

; 1186 : 		{
; 1187 : 			if(recverror == WSAEWOULDBLOCK )     /* nothing ready */

	cmp	DWORD PTR _recverror$2[ebp], 10035	; 00002733H
	jne	SHORT $LN5@ComTCPRecv

; 1188 : 			{
; 1189 : 				recverror = 0;

	mov	DWORD PTR _recverror$2[ebp], 0

; 1190 : 				ctcp->recvwouldblockcount++;

	mov	ecx, DWORD PTR _ctcp$3[ebp]
	mov	edx, DWORD PTR [ecx+504]
	add	edx, 1
	mov	eax, DWORD PTR _ctcp$3[ebp]
	mov	DWORD PTR [eax+504], edx
	jmp	SHORT $LN4@ComTCPRecv
$LN5@ComTCPRecv:

; 1191 : 			}
; 1192 : 			else if (recverror != COMAPI_CONNECTION_CLOSED)

	cmp	DWORD PTR _recverror$2[ebp], -5		; fffffffbH
	je	SHORT $LN4@ComTCPRecv

; 1193 : 			{
; 1194 : 				recverror *= -1;                 /* Negate Winsock error code */

	mov	ecx, DWORD PTR _recverror$2[ebp]
	imul	ecx, -1
	mov	DWORD PTR _recverror$2[ebp], ecx
$LN4@ComTCPRecv:

; 1195 : 			}
; 1196 : 
; 1197 : 			return recverror;

	mov	eax, DWORD PTR _recverror$2[ebp]
	jmp	SHORT $LN12@ComTCPRecv

; 1198 : 		}
; 1199 : 		else

	jmp	SHORT $LN2@ComTCPRecv
$LN6@ComTCPRecv:

; 1200 : 		{
; 1201 : 			return bytesRecvd;

	mov	eax, DWORD PTR _bytesRecvd$1[ebp]
	jmp	SHORT $LN12@ComTCPRecv
$LN2@ComTCPRecv:

; 1202 : 		}
; 1203 : 	}
; 1204 : 	else

	jmp	SHORT $LN12@ComTCPRecv
$LN11@ComTCPRecv:

; 1205 : 	{
; 1206 : 		return 0;

	xor	eax, eax
$LN12@ComTCPRecv:

; 1207 : 	}
; 1208 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ComTCPRecv ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\tcp.c
_TEXT	SEGMENT
_w$1 = -12						; size = 4
_bytesRecvd$2 = -8					; size = 4
_ctcp$3 = -4						; size = 4
_c$ = 8							; size = 4
_ComTCPGetMessage PROC

; 1215 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1216 : //	int retval = 0;
; 1217 : 	
; 1218 : 	if(c)

	cmp	DWORD PTR _c$[ebp], 0
	je	$LN27@ComTCPGetM

; 1219 : 	{
; 1220 : 		ComTCP *ctcp = (ComTCP *)c;

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _ctcp$3[ebp], eax

; 1221 : 		int bytesRecvd;
; 1222 : 		
; 1223 : 		if(ctcp->handletype == GROUP)

	mov	ecx, DWORD PTR _ctcp$3[ebp]
	movsx	edx, WORD PTR [ecx+520]
	cmp	edx, 1
	jne	SHORT $LN26@ComTCPGetM

; 1224 : 		{
; 1225 : 			return -1 * WSAENOTSOCK;

	mov	eax, -10038				; ffffd8caH
	jmp	$LN28@ComTCPGetM
$LN26@ComTCPGetM:

; 1226 : 		}
; 1227 : 
; 1228 : 		if(ctcp->state == COMAPI_STATE_CONNECTION_PENDING)

	mov	eax, DWORD PTR _ctcp$3[ebp]
	movsx	ecx, WORD PTR [eax+522]
	test	ecx, ecx
	jne	SHORT $LN25@ComTCPGetM

; 1229 : 		{
; 1230 : 			return COMAPI_CONNECTION_PENDING;

	mov	eax, -7					; fffffff9H
	jmp	$LN28@ComTCPGetM
$LN25@ComTCPGetM:

; 1231 : 		}
; 1232 : 
; 1233 : 		enter_cs();

	call	_enter_cs

; 1234 : 
; 1235 : 		if(!CAPIListFindHandle(GlobalListHead,c))

	mov	edx, DWORD PTR _c$[ebp]
	push	edx
	mov	eax, DWORD PTR _GlobalListHead
	push	eax
	call	_CAPIListFindHandle
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN24@ComTCPGetM

; 1236 : 		{
; 1237 : 			leave_cs();

	call	_leave_cs

; 1238 : 			return  -1 * WSAENOTSOCK; /* is it in  our list ? */

	mov	eax, -10038				; ffffd8caH
	jmp	$LN28@ComTCPGetM
$LN24@ComTCPGetM:

; 1239 : 		}
; 1240 : 
; 1241 : 		leave_cs();

	call	_leave_cs

; 1242 : 		
; 1243 : 		if(ctcp->handletype == LISTENER)

	mov	ecx, DWORD PTR _ctcp$3[ebp]
	movsx	edx, WORD PTR [ecx+520]
	test	edx, edx
	jne	SHORT $LN23@ComTCPGetM

; 1244 : 		{
; 1245 : 			return -1 * WSAENOTSOCK;

	mov	eax, -10038				; ffffd8caH
	jmp	$LN28@ComTCPGetM
$LN23@ComTCPGetM:

; 1246 : 		}
; 1247 : 		
; 1248 : 		/* Make this thread safe */
; 1249 : 		REQUEST_LOCK(ctcp->lock); 

	push	-1
	mov	eax, DWORD PTR _ctcp$3[ebp]
	mov	ecx, DWORD PTR [eax+508]
	push	ecx
	call	DWORD PTR __imp__WaitForSingleObject@8
	mov	DWORD PTR _w$1[ebp], eax
	cmp	DWORD PTR _w$1[ebp], -1
	jne	SHORT $LN22@ComTCPGetM
	call	DWORD PTR __imp__DebugBreak@0
$LN22@ComTCPGetM:

; 1250 : 		
; 1251 : 		/* need to read a header for message size */
; 1252 : 		if (ctcp->bytes_needed_for_header)  

	mov	edx, DWORD PTR _ctcp$3[ebp]
	cmp	DWORD PTR [edx+544], 0
	je	$LN21@ComTCPGetM

; 1253 : 		{
; 1254 : 			bytesRecvd = ComTCPGetNbytes(c,ctcp->bytes_needed_for_header);

	mov	eax, DWORD PTR _ctcp$3[ebp]
	mov	ecx, DWORD PTR [eax+544]
	push	ecx
	mov	edx, DWORD PTR _c$[ebp]
	push	edx
	call	_ComTCPGetNbytes
	add	esp, 8
	mov	DWORD PTR _bytesRecvd$2[ebp], eax

; 1255 : 
; 1256 : 			if (bytesRecvd <= 0 )    /* either no data (= 0) available or an error */

	cmp	DWORD PTR _bytesRecvd$2[ebp], 0
	jg	SHORT $LN20@ComTCPGetM

; 1257 : 			{
; 1258 : 				RELEASE_LOCK(ctcp->lock);

	mov	eax, DWORD PTR _ctcp$3[ebp]
	mov	ecx, DWORD PTR [eax+508]
	push	ecx
	call	DWORD PTR __imp__ReleaseMutex@4
	test	eax, eax
	jne	SHORT $LN19@ComTCPGetM
	call	DWORD PTR __imp__DebugBreak@0
$LN19@ComTCPGetM:

; 1259 : 				return bytesRecvd;

	mov	eax, DWORD PTR _bytesRecvd$2[ebp]
	jmp	$LN28@ComTCPGetM
$LN20@ComTCPGetM:

; 1260 : 			}
; 1261 : 
; 1262 : 			ctcp->bytes_needed_for_header -= bytesRecvd;

	mov	edx, DWORD PTR _ctcp$3[ebp]
	mov	eax, DWORD PTR [edx+544]
	sub	eax, DWORD PTR _bytesRecvd$2[ebp]
	mov	ecx, DWORD PTR _ctcp$3[ebp]
	mov	DWORD PTR [ecx+544], eax

; 1263 : 
; 1264 : 			if (ctcp->bytes_needed_for_header == 0 )  /* we now have a complete header */

	mov	edx, DWORD PTR _ctcp$3[ebp]
	cmp	DWORD PTR [edx+544], 0
	jne	SHORT $LN18@ComTCPGetM

; 1265 : 			{
; 1266 : 				/*should have a header here for new message .. so extract size of message*/
; 1267 : 				ctcp->messagesize = isHeader(ctcp->recv_buffer_start);   

	mov	eax, DWORD PTR _ctcp$3[ebp]
	mov	ecx, DWORD PTR [eax+540]
	push	ecx
	call	_isHeader
	add	esp, 4
	mov	edx, DWORD PTR _ctcp$3[ebp]
	mov	DWORD PTR [edx+532], eax

; 1268 : 
; 1269 : 				if (ctcp->messagesize == 0 )

	mov	eax, DWORD PTR _ctcp$3[ebp]
	cmp	DWORD PTR [eax+532], 0
	jne	SHORT $LN17@ComTCPGetM

; 1270 : 				{
; 1271 : 					RELEASE_LOCK(ctcp->lock);

	mov	ecx, DWORD PTR _ctcp$3[ebp]
	mov	edx, DWORD PTR [ecx+508]
	push	edx
	call	DWORD PTR __imp__ReleaseMutex@4
	test	eax, eax
	jne	SHORT $LN16@ComTCPGetM
	call	DWORD PTR __imp__DebugBreak@0
$LN16@ComTCPGetM:

; 1272 : 					return COMAPI_BAD_HEADER;

	or	eax, -1
	jmp	$LN28@ComTCPGetM
$LN17@ComTCPGetM:

; 1273 : 				}
; 1274 : 
; 1275 : 				/* now set these values for receiving the message data */
; 1276 : 				ctcp->bytes_needed_for_message = ctcp->messagesize; 

	mov	eax, DWORD PTR _ctcp$3[ebp]
	mov	ecx, DWORD PTR _ctcp$3[ebp]
	mov	edx, DWORD PTR [ecx+532]
	mov	DWORD PTR [eax+548], edx

; 1277 : 				ctcp->bytes_recvd_for_message = 0; 

	mov	eax, DWORD PTR _ctcp$3[ebp]
	mov	DWORD PTR [eax+552], 0

; 1278 : 			}
; 1279 : 			else  /* incomplete header .. try again later */

	jmp	SHORT $LN21@ComTCPGetM
$LN18@ComTCPGetM:

; 1280 : 			{
; 1281 : 				RELEASE_LOCK(ctcp->lock);

	mov	ecx, DWORD PTR _ctcp$3[ebp]
	mov	edx, DWORD PTR [ecx+508]
	push	edx
	call	DWORD PTR __imp__ReleaseMutex@4
	test	eax, eax
	jne	SHORT $LN14@ComTCPGetM
	call	DWORD PTR __imp__DebugBreak@0
$LN14@ComTCPGetM:

; 1282 : 				return 0;  

	xor	eax, eax
	jmp	$LN28@ComTCPGetM
$LN21@ComTCPGetM:

; 1283 : 			}
; 1284 : 		}
; 1285 : 		
; 1286 : 		/* Do we need to receive  message data ? */
; 1287 : 		if (ctcp->bytes_needed_for_message)

	mov	eax, DWORD PTR _ctcp$3[ebp]
	cmp	DWORD PTR [eax+548], 0
	je	$LN13@ComTCPGetM

; 1288 : 		{
; 1289 : 			if(ctcp->bytes_needed_for_message > ctcp->buffer_size - (int)sizeof(tcpHeader))

	mov	ecx, DWORD PTR _ctcp$3[ebp]
	mov	edx, DWORD PTR [ecx+48]
	sub	edx, 6
	mov	eax, DWORD PTR _ctcp$3[ebp]
	cmp	DWORD PTR [eax+548], edx
	jle	SHORT $LN12@ComTCPGetM

; 1290 : 			{ 
; 1291 : 				RELEASE_LOCK(ctcp->lock);

	mov	ecx, DWORD PTR _ctcp$3[ebp]
	mov	edx, DWORD PTR [ecx+508]
	push	edx
	call	DWORD PTR __imp__ReleaseMutex@4
	test	eax, eax
	jne	SHORT $LN11@ComTCPGetM
	call	DWORD PTR __imp__DebugBreak@0
$LN11@ComTCPGetM:

; 1292 : 				return COMAPI_MESSAGE_TOO_BIG;

	mov	eax, -6					; fffffffaH
	jmp	$LN28@ComTCPGetM
$LN12@ComTCPGetM:

; 1293 : 			}
; 1294 : 
; 1295 : 			bytesRecvd = ComTCPGetNbytes(c,ctcp->bytes_needed_for_message);

	mov	eax, DWORD PTR _ctcp$3[ebp]
	mov	ecx, DWORD PTR [eax+548]
	push	ecx
	mov	edx, DWORD PTR _c$[ebp]
	push	edx
	call	_ComTCPGetNbytes
	add	esp, 8
	mov	DWORD PTR _bytesRecvd$2[ebp], eax

; 1296 : 
; 1297 : 			if (bytesRecvd <= 0 )    /* either no data (= 0) available or an error */

	cmp	DWORD PTR _bytesRecvd$2[ebp], 0
	jg	SHORT $LN10@ComTCPGetM

; 1298 : 			{
; 1299 : 				RELEASE_LOCK(ctcp->lock);

	mov	eax, DWORD PTR _ctcp$3[ebp]
	mov	ecx, DWORD PTR [eax+508]
	push	ecx
	call	DWORD PTR __imp__ReleaseMutex@4
	test	eax, eax
	jne	SHORT $LN9@ComTCPGetM
	call	DWORD PTR __imp__DebugBreak@0
$LN9@ComTCPGetM:

; 1300 : 				return bytesRecvd;

	mov	eax, DWORD PTR _bytesRecvd$2[ebp]
	jmp	$LN28@ComTCPGetM
$LN10@ComTCPGetM:

; 1301 : 			}
; 1302 : 
; 1303 : 			ctcp->bytes_needed_for_message -= bytesRecvd;

	mov	edx, DWORD PTR _ctcp$3[ebp]
	mov	eax, DWORD PTR [edx+548]
	sub	eax, DWORD PTR _bytesRecvd$2[ebp]
	mov	ecx, DWORD PTR _ctcp$3[ebp]
	mov	DWORD PTR [ecx+548], eax

; 1304 : 			ctcp->bytes_recvd_for_message  += bytesRecvd;

	mov	edx, DWORD PTR _ctcp$3[ebp]
	mov	eax, DWORD PTR [edx+552]
	add	eax, DWORD PTR _bytesRecvd$2[ebp]
	mov	ecx, DWORD PTR _ctcp$3[ebp]
	mov	DWORD PTR [ecx+552], eax

; 1305 : 
; 1306 : 			if (ctcp->bytes_needed_for_message == 0 )  /* we now have a complete message */

	mov	edx, DWORD PTR _ctcp$3[ebp]
	cmp	DWORD PTR [edx+548], 0
	jne	$LN8@ComTCPGetM

; 1307 : 			{
; 1308 : 				/* a PANIC Check */
; 1309 : 				if (ctcp->messagesize != ctcp->bytes_recvd_for_message)

	mov	eax, DWORD PTR _ctcp$3[ebp]
	mov	ecx, DWORD PTR _ctcp$3[ebp]
	mov	edx, DWORD PTR [eax+532]
	cmp	edx, DWORD PTR [ecx+552]
	je	SHORT $LN7@ComTCPGetM

; 1310 : 				{
; 1311 : 					RELEASE_LOCK(ctcp->lock);

	mov	eax, DWORD PTR _ctcp$3[ebp]
	mov	ecx, DWORD PTR [eax+508]
	push	ecx
	call	DWORD PTR __imp__ReleaseMutex@4
	test	eax, eax
	jne	SHORT $LN6@ComTCPGetM
	call	DWORD PTR __imp__DebugBreak@0
$LN6@ComTCPGetM:

; 1312 : 					return COMAPI_BAD_MESSAGE_SIZE;

	mov	eax, -4					; fffffffcH
	jmp	$LN28@ComTCPGetM
$LN7@ComTCPGetM:

; 1313 : 				}
; 1314 : 				
; 1315 : 				/* Reset for next message */
; 1316 : 				ctcp->bytes_needed_for_header = ctcp->headersize;

	mov	edx, DWORD PTR _ctcp$3[ebp]
	mov	eax, DWORD PTR _ctcp$3[ebp]
	mov	ecx, DWORD PTR [eax+536]
	mov	DWORD PTR [edx+544], ecx

; 1317 : 				ctcp->bytes_needed_for_message = 0;

	mov	edx, DWORD PTR _ctcp$3[ebp]
	mov	DWORD PTR [edx+548], 0

; 1318 : 				ctcp->bytes_recvd_for_message = 0;

	mov	eax, DWORD PTR _ctcp$3[ebp]
	mov	DWORD PTR [eax+552], 0

; 1319 : 				ctcp->recv_buffer.buf = ctcp->recv_buffer_start; 

	mov	ecx, DWORD PTR _ctcp$3[ebp]
	mov	edx, DWORD PTR _ctcp$3[ebp]
	mov	eax, DWORD PTR [edx+540]
	mov	DWORD PTR [ecx+64], eax

; 1320 : 				ctcp->recvmessagecount++;    /* global message counter */

	mov	ecx, DWORD PTR _ctcp$3[ebp]
	mov	edx, DWORD PTR [ecx+496]
	add	edx, 1
	mov	eax, DWORD PTR _ctcp$3[ebp]
	mov	DWORD PTR [eax+496], edx

; 1321 : 				RELEASE_LOCK(ctcp->lock);

	mov	ecx, DWORD PTR _ctcp$3[ebp]
	mov	edx, DWORD PTR [ecx+508]
	push	edx
	call	DWORD PTR __imp__ReleaseMutex@4
	test	eax, eax
	jne	SHORT $LN5@ComTCPGetM
	call	DWORD PTR __imp__DebugBreak@0
$LN5@ComTCPGetM:

; 1322 : 
; 1323 : 				if(CAPI_TimeStamp)

	cmp	DWORD PTR _CAPI_TimeStamp, 0
	je	SHORT $LN4@ComTCPGetM

; 1324 : 				{
; 1325 : 					ctcp->timestamp = CAPI_TimeStamp();

	call	DWORD PTR _CAPI_TimeStamp
	mov	ecx, DWORD PTR _ctcp$3[ebp]
	mov	DWORD PTR [ecx+568], eax
$LN4@ComTCPGetM:

; 1326 : 				}
; 1327 : 
; 1328 : 				return ctcp->messagesize;

	mov	edx, DWORD PTR _ctcp$3[ebp]
	mov	eax, DWORD PTR [edx+532]
	jmp	SHORT $LN28@ComTCPGetM

; 1329 : 			}    
; 1330 : 			else     /* incomplete message */

	jmp	SHORT $LN13@ComTCPGetM
$LN8@ComTCPGetM:

; 1331 : 			{
; 1332 : 				RELEASE_LOCK(ctcp->lock);

	mov	eax, DWORD PTR _ctcp$3[ebp]
	mov	ecx, DWORD PTR [eax+508]
	push	ecx
	call	DWORD PTR __imp__ReleaseMutex@4
	test	eax, eax
	jne	SHORT $LN2@ComTCPGetM
	call	DWORD PTR __imp__DebugBreak@0
$LN2@ComTCPGetM:

; 1333 : 				return 0;   // complete message not avaliable yet

	xor	eax, eax
	jmp	SHORT $LN28@ComTCPGetM
$LN13@ComTCPGetM:

; 1334 : 			}
; 1335 : 		}
; 1336 : 		
; 1337 : 		RELEASE_LOCK(ctcp->lock);

	mov	edx, DWORD PTR _ctcp$3[ebp]
	mov	eax, DWORD PTR [edx+508]
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4
	test	eax, eax
	jne	SHORT $LN1@ComTCPGetM
	call	DWORD PTR __imp__DebugBreak@0
$LN1@ComTCPGetM:

; 1338 : 
; 1339 : 		return 0;   /* message not avaliable yet */

	xor	eax, eax
	jmp	SHORT $LN28@ComTCPGetM
$LN27@ComTCPGetM:

; 1340 : 	}
; 1341 : 	
; 1342 : 	return 0;

	xor	eax, eax
$LN28@ComTCPGetM:

; 1343 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ComTCPGetMessage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\tcp.c
_TEXT	SEGMENT
_c$ = 8							; size = 4
_ComTCPRecvBufferGet PROC

; 1043 : {

	push	ebp
	mov	ebp, esp

; 1044 : 	if(c)

	cmp	DWORD PTR _c$[ebp], 0
	je	SHORT $LN4@ComTCPRecv

; 1045 : 	{
; 1046 : 		enter_cs();

	call	_enter_cs

; 1047 : 
; 1048 : 		if (!CAPIListFindHandle(GlobalListHead,c))

	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	mov	ecx, DWORD PTR _GlobalListHead
	push	ecx
	call	_CAPIListFindHandle
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN3@ComTCPRecv

; 1049 : 		{
; 1050 : 			leave_cs();

	call	_leave_cs

; 1051 : 
; 1052 : 			return NULL; /* is it in  our list ? */

	xor	eax, eax
	jmp	SHORT $LN5@ComTCPRecv
$LN3@ComTCPRecv:

; 1053 : 		}
; 1054 : 
; 1055 : 		leave_cs();

	call	_leave_cs

; 1056 : 		
; 1057 : 		if (((ComTCP *)c)->handletype == GROUP)

	mov	edx, DWORD PTR _c$[ebp]
	movsx	eax, WORD PTR [edx+520]
	cmp	eax, 1
	jne	SHORT $LN2@ComTCPRecv

; 1058 : 		{
; 1059 : 			return NULL;

	xor	eax, eax
	jmp	SHORT $LN5@ComTCPRecv
$LN2@ComTCPRecv:

; 1060 : 		}
; 1061 : 		
; 1062 : 		return ((ComTCP *)c)->recv_buffer_start +sizeof(tcpHeader) ;

	mov	ecx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [ecx+540]
	add	eax, 6
	jmp	SHORT $LN5@ComTCPRecv

; 1063 : 	}
; 1064 : 	else

	jmp	SHORT $LN5@ComTCPRecv
$LN4@ComTCPRecv:

; 1065 : 	{
; 1066 : 		return NULL;

	xor	eax, eax
$LN5@ComTCPRecv:

; 1067 : 	}
; 1068 : }

	pop	ebp
	ret	0
_ComTCPRecvBufferGet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\tcp.c
_TEXT	SEGMENT
_c$ = 8							; size = 4
_ComTCPSendBufferGet PROC

; 1016 : {

	push	ebp
	mov	ebp, esp

; 1017 : 	if(c)

	cmp	DWORD PTR _c$[ebp], 0
	je	SHORT $LN3@ComTCPSend

; 1018 : 	{
; 1019 : 		enter_cs();

	call	_enter_cs

; 1020 : 
; 1021 : 		if(!CAPIListFindHandle(GlobalListHead,c))

	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	mov	ecx, DWORD PTR _GlobalListHead
	push	ecx
	call	_CAPIListFindHandle
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN2@ComTCPSend

; 1022 : 		{
; 1023 : 			leave_cs();

	call	_leave_cs

; 1024 : 
; 1025 : 			return  NULL; /* is it in  our list ? */

	xor	eax, eax
	jmp	SHORT $LN4@ComTCPSend
$LN2@ComTCPSend:

; 1026 : 		}
; 1027 : 
; 1028 : 		leave_cs();

	call	_leave_cs

; 1029 : 		
; 1030 : 		return ((ComTCP *)c)->send_buffer.buf + sizeof(tcpHeader);

	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [edx+56]
	add	eax, 6
	jmp	SHORT $LN4@ComTCPSend

; 1031 : 	}
; 1032 : 	else

	jmp	SHORT $LN4@ComTCPSend
$LN3@ComTCPSend:

; 1033 : 	{
; 1034 : 		return NULL;

	xor	eax, eax
$LN4@ComTCPSend:

; 1035 : 	}
; 1036 : }

	pop	ebp
	ret	0
_ComTCPSendBufferGet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\tcp.c
_TEXT	SEGMENT
_c$ = 8							; size = 4
_msgsize$ = 12						; size = 4
_oob$ = 16						; size = 4
_type$ = 20						; size = 4
_Xcom$ = 24						; size = 4
_ComTCPSendX PROC

; 894  : {

	push	ebp
	mov	ebp, esp

; 895  :    if (c == Xcom){

	mov	eax, DWORD PTR _c$[ebp]
	cmp	eax, DWORD PTR _Xcom$[ebp]
	jne	SHORT $LN2@ComTCPSend

; 896  : 	   return 0;

	xor	eax, eax
	jmp	SHORT $LN3@ComTCPSend

; 897  :    }
; 898  :    else {

	jmp	SHORT $LN3@ComTCPSend
$LN2@ComTCPSend:

; 899  : 	   return ComTCPSend(c, msgsize, oob, type);

	mov	ecx, DWORD PTR _type$[ebp]
	push	ecx
	mov	edx, DWORD PTR _oob$[ebp]
	push	edx
	mov	eax, DWORD PTR _msgsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	call	_ComTCPSend
	add	esp, 16					; 00000010H
$LN3@ComTCPSend:

; 900  :    }
; 901  : }

	pop	ebp
	ret	0
_ComTCPSendX ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\tcp.c
_TEXT	SEGMENT
_err$1 = -16						; size = 4
_bytesSent$2 = -12					; size = 4
_senderror$3 = -8					; size = 4
_ctcp$4 = -4						; size = 4
_c$ = 8							; size = 4
_msgsize$ = 12						; size = 4
_oob$ = 16						; size = 4
_type$ = 20						; size = 4
_ComTCPSend PROC

; 908  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 909  : 	if(c)

	cmp	DWORD PTR _c$[ebp], 0
	je	$LN12@ComTCPSend

; 910  : 	{
; 911  : 		ComTCP *ctcp = (ComTCP *)c;

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _ctcp$4[ebp], eax

; 912  : 		int senderror,err;
; 913  : 		int bytesSent;
; 914  : 		
; 915  : 		enter_cs();

	call	_enter_cs

; 916  : 
; 917  : 		if(!CAPIListFindHandle(GlobalListHead,c))

	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	mov	edx, DWORD PTR _GlobalListHead
	push	edx
	call	_CAPIListFindHandle
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN11@ComTCPSend

; 918  : 		{
; 919  : 			leave_cs();

	call	_leave_cs

; 920  : 
; 921  : 			return  -1 * WSAENOTSOCK; /* is it in  our list ? */

	mov	eax, -10038				; ffffd8caH
	jmp	$LN13@ComTCPSend
$LN11@ComTCPSend:

; 922  : 		}
; 923  : 
; 924  : 		leave_cs();

	call	_leave_cs

; 925  : 
; 926  : 		if(ctcp->handletype == LISTENER)

	mov	eax, DWORD PTR _ctcp$4[ebp]
	movsx	ecx, WORD PTR [eax+520]
	test	ecx, ecx
	jne	SHORT $LN10@ComTCPSend

; 927  : 		{
; 928  : 			return -1 * WSAENOTSOCK;

	mov	eax, -10038				; ffffd8caH
	jmp	$LN13@ComTCPSend
$LN10@ComTCPSend:

; 929  : 		}
; 930  : 		
; 931  : 		if(ctcp->state == COMAPI_STATE_CONNECTION_PENDING)

	mov	edx, DWORD PTR _ctcp$4[ebp]
	movsx	eax, WORD PTR [edx+522]
	test	eax, eax
	jne	SHORT $LN9@ComTCPSend

; 932  : 		{
; 933  : 			return COMAPI_CONNECTION_PENDING;

	mov	eax, -7					; fffffff9H
	jmp	$LN13@ComTCPSend
$LN9@ComTCPSend:

; 934  : 		}
; 935  : 		
; 936  : 		if(msgsize > ctcp->buffer_size - (int)sizeof(tcpHeader))

	mov	ecx, DWORD PTR _ctcp$4[ebp]
	mov	edx, DWORD PTR [ecx+48]
	sub	edx, 6
	cmp	DWORD PTR _msgsize$[ebp], edx
	jle	SHORT $LN8@ComTCPSend

; 937  : 		{
; 938  : 			return COMAPI_MESSAGE_TOO_BIG;

	mov	eax, -6					; fffffffaH
	jmp	$LN13@ComTCPSend
$LN8@ComTCPSend:

; 939  : 		}
; 940  : 		
; 941  : 		err = 0;

	mov	DWORD PTR _err$1[ebp], 0

; 942  : 		/* add the header size to the requested messagesize */
; 943  : 		ctcp->send_buffer.len = msgsize + ctcp->headersize;

	mov	eax, DWORD PTR _ctcp$4[ebp]
	mov	ecx, DWORD PTR _msgsize$[ebp]
	add	ecx, DWORD PTR [eax+536]
	mov	edx, DWORD PTR _ctcp$4[ebp]
	mov	DWORD PTR [edx+52], ecx

; 944  : 		/* create and store header in buffer */
; 945  : 		setHeader(ctcp->send_buffer.buf,msgsize);

	mov	eax, DWORD PTR _msgsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctcp$4[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	_setHeader
	add	esp, 8

; 946  : 
; 947  : 		if (check_bandwidth(ctcp->send_buffer.len, 1, type))

	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _ctcp$4[ebp]
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	call	_check_bandwidth
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN7@ComTCPSend

; 948  : 		{
; 949  : 			bytesSent = senderror =  CAPI_send
; 950  : 			(
; 951  : 				ctcp->send_sock,
; 952  : 				ctcp->send_buffer.buf,
; 953  : 				ctcp->send_buffer.len,
; 954  : 				0
; 955  : 			);

	push	0
	mov	eax, DWORD PTR _ctcp$4[ebp]
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	mov	edx, DWORD PTR _ctcp$4[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _ctcp$4[ebp]
	mov	edx, DWORD PTR [ecx+484]
	push	edx
	call	DWORD PTR _CAPI_send
	mov	DWORD PTR _senderror$3[ebp], eax
	mov	eax, DWORD PTR _senderror$3[ebp]
	mov	DWORD PTR _bytesSent$2[ebp], eax

; 956  : 		}
; 957  : 		else

	jmp	SHORT $LN6@ComTCPSend
$LN7@ComTCPSend:

; 958  : 		{
; 959  : 			return COMAPI_WOULDBLOCK;

	mov	eax, -8					; fffffff8H
	jmp	$LN13@ComTCPSend
$LN6@ComTCPSend:

; 960  : 		}
; 961  : 		
; 962  : 		if (senderror == SOCKET_ERROR)

	cmp	DWORD PTR _senderror$3[ebp], -1
	jne	SHORT $LN5@ComTCPSend

; 963  : 		{
; 964  : 			senderror = CAPI_WSAGetLastError();

	call	DWORD PTR _CAPI_WSAGetLastError
	mov	DWORD PTR _senderror$3[ebp], eax

; 965  : 			
; 966  : 			if(senderror == WSAEWOULDBLOCK) 

	cmp	DWORD PTR _senderror$3[ebp], 10035	; 00002733H
	jne	SHORT $LN4@ComTCPSend

; 967  : 			{
; 968  : 				/* let's keep a count of wouldblocks - might be interesting later */
; 969  : 				
; 970  : 				ctcp->sendwouldblockcount++;

	mov	ecx, DWORD PTR _ctcp$4[ebp]
	mov	edx, DWORD PTR [ecx+500]
	add	edx, 1
	mov	eax, DWORD PTR _ctcp$4[ebp]
	mov	DWORD PTR [eax+500], edx

; 971  : 				return COMAPI_WOULDBLOCK;   

	mov	eax, -8					; fffffff8H
	jmp	SHORT $LN13@ComTCPSend
$LN4@ComTCPSend:

; 972  : 			}
; 973  : 			
; 974  : 			return -1 * senderror;

	mov	eax, DWORD PTR _senderror$3[ebp]
	imul	eax, -1
	jmp	SHORT $LN13@ComTCPSend
$LN5@ComTCPSend:

; 975  : 		}
; 976  : 		
; 977  : 		use_bandwidth (bytesSent, 1, type);

	mov	ecx, DWORD PTR _type$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _bytesSent$2[ebp]
	push	edx
	call	_use_bandwidth
	add	esp, 12					; 0000000cH

; 978  : #ifdef checkbandwidth
; 979  : 
; 980  : totalbwused += bytesSent;
; 981  : if (oob) oobbwused +=bytesSent;
; 982  : if (now > laststatcound + 1000)
; 983  : {
; 984  : 	MonoPrint("TCP Bytes pr sec %d, OOB %d", 
; 985  : 		(int)(totalbwused*1000/(now-laststatcound)),
; 986  : 		(int)(oobbwused *1000/(now-laststatcound)));
; 987  : 	laststatcound = now;
; 988  : 	totalbwused = 0;
; 989  : 	oobbwused = 0;
; 990  : 	Posupdbwused = 0;
; 991  : }
; 992  : #endif		
; 993  : 		if(bytesSent != (int)ctcp->send_buffer.len )  /* Incomplete message was sent?? */

	mov	eax, DWORD PTR _ctcp$4[ebp]
	mov	ecx, DWORD PTR _bytesSent$2[ebp]
	cmp	ecx, DWORD PTR [eax+52]
	je	SHORT $LN3@ComTCPSend

; 994  : 		{
; 995  : 			ctcp->sendwouldblockcount++;

	mov	edx, DWORD PTR _ctcp$4[ebp]
	mov	eax, DWORD PTR [edx+500]
	add	eax, 1
	mov	ecx, DWORD PTR _ctcp$4[ebp]
	mov	DWORD PTR [ecx+500], eax

; 996  : 			return COMAPI_WOULDBLOCK;

	mov	eax, -8					; fffffff8H
	jmp	SHORT $LN13@ComTCPSend

; 997  : 		}
; 998  : 		else

	jmp	SHORT $LN2@ComTCPSend
$LN3@ComTCPSend:

; 999  : 		{
; 1000 : 			/* keep track of successful messages sent/received */
; 1001 : 			ctcp->sendmessagecount++;

	mov	edx, DWORD PTR _ctcp$4[ebp]
	mov	eax, DWORD PTR [edx+492]
	add	eax, 1
	mov	ecx, DWORD PTR _ctcp$4[ebp]
	mov	DWORD PTR [ecx+492], eax

; 1002 : 			return bytesSent - ctcp->headersize;

	mov	edx, DWORD PTR _ctcp$4[ebp]
	mov	eax, DWORD PTR _bytesSent$2[ebp]
	sub	eax, DWORD PTR [edx+536]
	jmp	SHORT $LN13@ComTCPSend
$LN2@ComTCPSend:

; 1003 : 		}
; 1004 : 	}
; 1005 : 	else

	jmp	SHORT $LN13@ComTCPSend
$LN12@ComTCPSend:

; 1006 : 	{
; 1007 : 		return -1 * WSAENOTSOCK;

	mov	eax, -10038				; ffffd8caH
$LN13@ComTCPSend:

; 1008 : 	}
; 1009 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ComTCPSend ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\tcp.c
_TEXT	SEGMENT
_w$1 = -16						; size = 4
_w$2 = -12						; size = 4
_sockerror$ = -8					; size = 4
_ctcp$ = -4						; size = 4
_c$ = 8							; size = 4
_ComTCPClose PROC

; 763  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 764  : 	int sockerror;
; 765  : 	ComTCP *ctcp = (ComTCP *)c;

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _ctcp$[ebp], eax

; 766  : 	
; 767  : 	if(!c)

	cmp	DWORD PTR _c$[ebp], 0
	jne	SHORT $LN24@ComTCPClos

; 768  : 	{
; 769  : 		return;

	jmp	$LN25@ComTCPClos
$LN24@ComTCPClos:

; 770  : 	}
; 771  : 	
; 772  : 	enter_cs();

	call	_enter_cs

; 773  : 	
; 774  : 	if(!CAPIListFindHandle(GlobalListHead,c))

	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	mov	edx, DWORD PTR _GlobalListHead
	push	edx
	call	_CAPIListFindHandle
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN23@ComTCPClos

; 775  : 	{
; 776  : 		leave_cs();

	call	_leave_cs

; 777  : 
; 778  : 		return ; /* is it in  our list ? */

	jmp	$LN25@ComTCPClos
$LN23@ComTCPClos:

; 779  : 	}
; 780  : 
; 781  : 	leave_cs();

	call	_leave_cs

; 782  : 	
; 783  : 	ctcp->referencecount --;

	mov	eax, DWORD PTR _ctcp$[ebp]
	mov	ecx, DWORD PTR [eax+528]
	sub	ecx, 1
	mov	edx, DWORD PTR _ctcp$[ebp]
	mov	DWORD PTR [edx+528], ecx

; 784  : 
; 785  : 	if (ctcp->referencecount)

	mov	eax, DWORD PTR _ctcp$[ebp]
	cmp	DWORD PTR [eax+528], 0
	je	SHORT $LN22@ComTCPClos

; 786  : 	{
; 787  : 		return;

	jmp	$LN25@ComTCPClos
$LN22@ComTCPClos:

; 788  : 	}
; 789  : 	
; 790  : 	if(ctcp->lock)

	mov	ecx, DWORD PTR _ctcp$[ebp]
	cmp	DWORD PTR [ecx+508], 0
	je	SHORT $LN21@ComTCPClos

; 791  : 	{
; 792  : 		REQUEST_LOCK(ctcp->lock);

	push	-1
	mov	edx, DWORD PTR _ctcp$[ebp]
	mov	eax, DWORD PTR [edx+508]
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
	mov	DWORD PTR _w$2[ebp], eax
	cmp	DWORD PTR _w$2[ebp], -1
	jne	SHORT $LN21@ComTCPClos
	call	DWORD PTR __imp__DebugBreak@0
$LN21@ComTCPClos:

; 793  : 	}
; 794  : 	
; 795  : 	if (ctcp->recv_sock > 0)

	mov	ecx, DWORD PTR _ctcp$[ebp]
	cmp	DWORD PTR [ecx+488], 0
	jbe	$LN19@ComTCPClos

; 796  : 	{
; 797  : 		/* if this is a listening socket, we have an active listening thread*/
; 798  : 		if(ctcp->ThreadActive == THREAD_ACTIVE)

	mov	edx, DWORD PTR _ctcp$[ebp]
	movsx	eax, WORD PTR [edx+516]
	cmp	eax, 1
	jne	$LN18@ComTCPClos

; 799  : 		{
; 800  : 			ctcp->ThreadActive = THREAD_STOP;   /* tell thread to stop */

	xor	ecx, ecx
	mov	edx, DWORD PTR _ctcp$[ebp]
	mov	WORD PTR [edx+516], cx

; 801  : 
; 802  : 			RELEASE_LOCK(ctcp->lock);

	mov	eax, DWORD PTR _ctcp$[ebp]
	mov	ecx, DWORD PTR [eax+508]
	push	ecx
	call	DWORD PTR __imp__ReleaseMutex@4
	test	eax, eax
	jne	SHORT $LN17@ComTCPClos
	call	DWORD PTR __imp__DebugBreak@0
$LN17@ComTCPClos:

; 803  : 			
; 804  : 			/* close the socket */
; 805  : 			if(sockerror = CAPI_closesocket(ctcp->recv_sock))

	mov	edx, DWORD PTR _ctcp$[ebp]
	mov	eax, DWORD PTR [edx+488]
	push	eax
	call	DWORD PTR _CAPI_closesocket
	mov	DWORD PTR _sockerror$[ebp], eax
	cmp	DWORD PTR _sockerror$[ebp], 0
	je	SHORT $LN16@ComTCPClos

; 806  : 			{
; 807  : 				sockerror = CAPI_WSAGetLastError();

	call	DWORD PTR _CAPI_WSAGetLastError
	mov	DWORD PTR _sockerror$[ebp], eax
$LN16@ComTCPClos:

; 808  : 			}
; 809  : 
; 810  : 			ctcp->recv_sock =0;  /* clear it */

	mov	ecx, DWORD PTR _ctcp$[ebp]
	mov	DWORD PTR [ecx+488], 0
$LN15@ComTCPClos:

; 811  : 			
; 812  : 			while(TRUE)

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN14@ComTCPClos

; 813  : 			{
; 814  : 				REQUEST_LOCK(ctcp->lock);

	push	-1
	mov	eax, DWORD PTR _ctcp$[ebp]
	mov	ecx, DWORD PTR [eax+508]
	push	ecx
	call	DWORD PTR __imp__WaitForSingleObject@8
	mov	DWORD PTR _w$1[ebp], eax
	cmp	DWORD PTR _w$1[ebp], -1
	jne	SHORT $LN13@ComTCPClos
	call	DWORD PTR __imp__DebugBreak@0
$LN13@ComTCPClos:

; 815  : 
; 816  : 				if (ctcp->ThreadActive == THREAD_TERMINATED)

	mov	edx, DWORD PTR _ctcp$[ebp]
	movsx	eax, WORD PTR [edx+516]
	cmp	eax, 2
	jne	SHORT $LN12@ComTCPClos

; 817  : 				{
; 818  : 					break;

	jmp	SHORT $LN14@ComTCPClos
$LN12@ComTCPClos:

; 819  : 				}
; 820  : 
; 821  : 				RELEASE_LOCK(ctcp->lock);

	mov	ecx, DWORD PTR _ctcp$[ebp]
	mov	edx, DWORD PTR [ecx+508]
	push	edx
	call	DWORD PTR __imp__ReleaseMutex@4
	test	eax, eax
	jne	SHORT $LN11@ComTCPClos
	call	DWORD PTR __imp__DebugBreak@0
$LN11@ComTCPClos:

; 822  : 			}

	jmp	SHORT $LN15@ComTCPClos
$LN14@ComTCPClos:

; 823  : 		}
; 824  : 		else  /* not a listening socket , a regular socket */

	jmp	SHORT $LN19@ComTCPClos
$LN18@ComTCPClos:

; 825  : 		{
; 826  : 			/* close the socket */
; 827  : 			if(sockerror = CAPI_closesocket(ctcp->recv_sock))

	mov	eax, DWORD PTR _ctcp$[ebp]
	mov	ecx, DWORD PTR [eax+488]
	push	ecx
	call	DWORD PTR _CAPI_closesocket
	mov	DWORD PTR _sockerror$[ebp], eax
	cmp	DWORD PTR _sockerror$[ebp], 0
	je	SHORT $LN9@ComTCPClos

; 828  : 			{
; 829  : 				sockerror = CAPI_WSAGetLastError();

	call	DWORD PTR _CAPI_WSAGetLastError
	mov	DWORD PTR _sockerror$[ebp], eax
$LN9@ComTCPClos:

; 830  : 			}
; 831  : 
; 832  : 			ctcp->recv_sock =0;  /* clear it */

	mov	edx, DWORD PTR _ctcp$[ebp]
	mov	DWORD PTR [edx+488], 0
$LN19@ComTCPClos:

; 833  : 		}
; 834  : 	}	
; 835  : 		
; 836  : 	/* reset this to start of receive buffer so pointer to free() is correct */
; 837  : 	ctcp->recv_buffer.buf = ctcp->recv_buffer_start;  

	mov	eax, DWORD PTR _ctcp$[ebp]
	mov	ecx, DWORD PTR _ctcp$[ebp]
	mov	edx, DWORD PTR [ecx+540]
	mov	DWORD PTR [eax+64], edx

; 838  : 	
; 839  : 	/* remove this ComHandle from the current list */
; 840  : 	enter_cs();

	call	_enter_cs

; 841  : 
; 842  : 	GlobalListHead = CAPIListRemove( GlobalListHead, c );

	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	mov	ecx, DWORD PTR _GlobalListHead
	push	ecx
	call	_CAPIListRemove
	add	esp, 8
	mov	DWORD PTR _GlobalListHead, eax

; 843  : 
; 844  : 	leave_cs();

	call	_leave_cs

; 845  : 	
; 846  : 	if(ctcp->lock)

	mov	edx, DWORD PTR _ctcp$[ebp]
	cmp	DWORD PTR [edx+508], 0
	je	SHORT $LN8@ComTCPClos

; 847  : 	{
; 848  : 		RELEASE_LOCK(ctcp->lock);

	mov	eax, DWORD PTR _ctcp$[ebp]
	mov	ecx, DWORD PTR [eax+508]
	push	ecx
	call	DWORD PTR __imp__ReleaseMutex@4
	test	eax, eax
	jne	SHORT $LN7@ComTCPClos
	call	DWORD PTR __imp__DebugBreak@0
$LN7@ComTCPClos:

; 849  : 
; 850  : 		DESTROY_LOCK(ctcp->lock);

	mov	edx, DWORD PTR _ctcp$[ebp]
	mov	eax, DWORD PTR [edx+508]
	push	eax
	call	DWORD PTR __imp__CloseHandle@4
	test	eax, eax
	jne	SHORT $LN8@ComTCPClos
	call	DWORD PTR __imp__DebugBreak@0
$LN8@ComTCPClos:

; 851  : 	}
; 852  : 
; 853  : 	ctcp->lock = 0;  /* clear it */

	mov	ecx, DWORD PTR _ctcp$[ebp]
	mov	DWORD PTR [ecx+508], 0

; 854  : 	
; 855  : 	if ((ctcp->handletype != GROUP) && (ctcp->state != COMAPI_STATE_CONNECTION_PENDING))

	mov	edx, DWORD PTR _ctcp$[ebp]
	movsx	eax, WORD PTR [edx+520]
	cmp	eax, 1
	je	SHORT $LN5@ComTCPClos
	mov	ecx, DWORD PTR _ctcp$[ebp]
	movsx	edx, WORD PTR [ecx+522]
	test	edx, edx
	je	SHORT $LN5@ComTCPClos

; 856  : 	{
; 857  : 		WS2Connections--;   /* decrement the INIT reference count */

	mov	eax, DWORD PTR _WS2Connections
	sub	eax, 1
	mov	DWORD PTR _WS2Connections, eax
$LN5@ComTCPClos:

; 858  : 	}
; 859  : 		
; 860  : 	/* free the data structs */
; 861  : 	if (ctcp->recv_buffer.buf)

	mov	ecx, DWORD PTR _ctcp$[ebp]
	cmp	DWORD PTR [ecx+64], 0
	je	SHORT $LN4@ComTCPClos

; 862  : 	{
; 863  : 		free(ctcp->recv_buffer.buf);

	mov	edx, DWORD PTR _ctcp$[ebp]
	mov	eax, DWORD PTR [edx+64]
	push	eax
	call	_free
	add	esp, 4
$LN4@ComTCPClos:

; 864  : 	}
; 865  : 
; 866  : 	if (ctcp->send_buffer.buf)

	mov	ecx, DWORD PTR _ctcp$[ebp]
	cmp	DWORD PTR [ecx+56], 0
	je	SHORT $LN3@ComTCPClos

; 867  : 	{
; 868  : 		free(ctcp->send_buffer.buf);

	mov	edx, DWORD PTR _ctcp$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	call	_free
	add	esp, 4
$LN3@ComTCPClos:

; 869  : 	}
; 870  : 
; 871  : 	free(c);

	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	call	_free
	add	esp, 4

; 872  : 	
; 873  : 	/* if No more connections then WSACleanup() */
; 874  : 	if (!WS2Connections)

	cmp	DWORD PTR _WS2Connections, 0
	jne	SHORT $LN25@ComTCPClos

; 875  : 	{
; 876  : 		if(sockerror = CAPI_WSACleanup())

	call	DWORD PTR _CAPI_WSACleanup
	mov	DWORD PTR _sockerror$[ebp], eax
	cmp	DWORD PTR _sockerror$[ebp], 0
	je	SHORT $LN1@ComTCPClos

; 877  : 		{
; 878  : 			sockerror = CAPI_WSAGetLastError();

	call	DWORD PTR _CAPI_WSAGetLastError
	mov	DWORD PTR _sockerror$[ebp], eax
$LN1@ComTCPClos:

; 879  : 		}
; 880  : 
; 881  : #ifdef LOAD_DLLS
; 882  : 		FreeLibrary(hWinSockDLL);

	mov	edx, DWORD PTR _hWinSockDLL
	push	edx
	call	DWORD PTR __imp__FreeLibrary@4

; 883  : 		hWinSockDLL = 0;

	mov	DWORD PTR _hWinSockDLL, 0
$LN25@ComTCPClos:

; 884  : #endif
; 885  : 
; 886  : 	}
; 887  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ComTCPClose ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\tcp.c
_TEXT	SEGMENT
_cudp$ = -12						; size = 4
_ctcp$ = -8						; size = 4
_ip$ = -4						; size = 4
_c$ = 8							; size = 4
_ComAPIGetNetHostByHandle PROC

; 2629 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 2630 : 	ComTCP *ctcp;
; 2631 : 	ComIP *cudp;
; 2632 : 	unsigned long ip=0;

	mov	DWORD PTR _ip$[ebp], 0

; 2633 : 	
; 2634 : 	if(c->protocol == CAPI_TCP_PROTOCOL)

	mov	eax, DWORD PTR _c$[ebp]
	cmp	DWORD PTR [eax+4], 5
	jne	SHORT $LN3@ComAPIGetN

; 2635 : 	{
; 2636 : 		ctcp = (ComTCP *)c;

	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR _ctcp$[ebp], ecx

; 2637 : 		ip = ComAPIGetNetHostBySocket(ctcp->recv_sock);

	mov	edx, DWORD PTR _ctcp$[ebp]
	mov	eax, DWORD PTR [edx+488]
	push	eax
	call	_ComAPIGetNetHostBySocket
	add	esp, 4
	mov	DWORD PTR _ip$[ebp], eax
	jmp	SHORT $LN2@ComAPIGetN
$LN3@ComAPIGetN:

; 2638 : 	}
; 2639 : 	else if(c->protocol == CAPI_TCP_PROTOCOL)

	mov	ecx, DWORD PTR _c$[ebp]
	cmp	DWORD PTR [ecx+4], 5
	jne	SHORT $LN2@ComAPIGetN

; 2640 : 	{
; 2641 : 		cudp = (ComIP *)c;

	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR _cudp$[ebp], edx

; 2642 : 		ip = ComAPIGetNetHostBySocket(cudp->recv_sock);

	mov	eax, DWORD PTR _cudp$[ebp]
	mov	ecx, DWORD PTR [eax+516]
	push	ecx
	call	_ComAPIGetNetHostBySocket
	add	esp, 4
	mov	DWORD PTR _ip$[ebp], eax
$LN2@ComAPIGetN:

; 2643 : 	}
; 2644 : 	
; 2645 : 	return ip;

	mov	eax, DWORD PTR _ip$[ebp]

; 2646 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ComAPIGetNetHostByHandle ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\tcp.c
_TEXT	SEGMENT
_i$ = -36						; size = 4
_socket$ = -32						; size = 4
_retaddress$ = -28					; size = 4
_result$ = -24						; size = 4
_Addr$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_Socket$ = 8						; size = 4
_ComAPIGetNetHostBySocket PROC

; 2596 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2597 : 	int result,i;
; 2598 : 	int retaddress=0;

	mov	DWORD PTR _retaddress$[ebp], 0

; 2599 : 	struct sockaddr_in Addr;
; 2600 : 	SOCKET socket;
; 2601 : 		
; 2602 : 	socket = (SOCKET)Socket;

	mov	eax, DWORD PTR _Socket$[ebp]
	mov	DWORD PTR _socket$[ebp], eax

; 2603 : 	
; 2604 : 	if(socket == 0)

	cmp	DWORD PTR _socket$[ebp], 0
	jne	SHORT $LN2@ComAPIGetN

; 2605 : 	{
; 2606 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN3@ComAPIGetN
$LN2@ComAPIGetN:

; 2607 : 	}
; 2608 : 	
; 2609 : 	i = sizeof(struct sockaddr);

	mov	DWORD PTR _i$[ebp], 16			; 00000010H

; 2610 : 
; 2611 : 	result = CAPI_getsockname(socket,(struct sockaddr FAR *)&Addr, &i);

	lea	ecx, DWORD PTR _i$[ebp]
	push	ecx
	lea	edx, DWORD PTR _Addr$[ebp]
	push	edx
	mov	eax, DWORD PTR _socket$[ebp]
	push	eax
	call	DWORD PTR _CAPI_getsockname
	mov	DWORD PTR _result$[ebp], eax

; 2612 : 
; 2613 : 	if(result == SOCKET_ERROR)

	cmp	DWORD PTR _result$[ebp], -1
	jne	SHORT $LN1@ComAPIGetN

; 2614 : 	{
; 2615 : 		result = CAPI_WSAGetLastError();

	call	DWORD PTR _CAPI_WSAGetLastError
	mov	DWORD PTR _result$[ebp], eax

; 2616 : 		return -1 * result;

	mov	eax, DWORD PTR _result$[ebp]
	imul	eax, -1
	jmp	SHORT $LN3@ComAPIGetN
$LN1@ComAPIGetN:

; 2617 : 	}
; 2618 : 	
; 2619 : 	retaddress = Addr.sin_addr.s_addr;

	mov	ecx, DWORD PTR _Addr$[ebp+4]
	mov	DWORD PTR _retaddress$[ebp], ecx

; 2620 : 	
; 2621 : 	return retaddress;

	mov	eax, DWORD PTR _retaddress$[ebp]
$LN3@ComAPIGetN:

; 2622 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_ComAPIGetNetHostBySocket ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\tcp.c
_TEXT	SEGMENT
_i$ = -12						; size = 4
_list$ = -8						; size = 4
_curr$ = -4						; size = 4
_ComAPICloseOpenHandles PROC

; 1502 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1503 : 	CAPIList * curr, *list;
; 1504 : 	int i;
; 1505 : 	
; 1506 : 	list = GlobalGroupListHead;

	mov	eax, DWORD PTR _GlobalGroupListHead
	mov	DWORD PTR _list$[ebp], eax

; 1507 : 	
; 1508 : 	if(list) 

	cmp	DWORD PTR _list$[ebp], 0
	je	SHORT $LN8@ComAPIClos

; 1509 : 	{
; 1510 : 		for( i = 0, curr = list; curr; i++, curr = curr  ->  next ) 

	mov	DWORD PTR _i$[ebp], 0
	mov	ecx, DWORD PTR _list$[ebp]
	mov	DWORD PTR _curr$[ebp], ecx
	jmp	SHORT $LN7@ComAPIClos
$LN6@ComAPIClos:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	mov	eax, DWORD PTR _curr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _curr$[ebp], ecx
$LN7@ComAPIClos:
	cmp	DWORD PTR _curr$[ebp], 0
	je	SHORT $LN8@ComAPIClos

; 1511 : 		{
; 1512 : 			curr->com->close_func(curr->com); 

	mov	edx, DWORD PTR _curr$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _curr$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+36]
	call	eax
	add	esp, 4

; 1513 : 		}

	jmp	SHORT $LN6@ComAPIClos
$LN8@ComAPIClos:

; 1514 : 	}  
; 1515 : 	
; 1516 : 	list = GlobalListHead;

	mov	ecx, DWORD PTR _GlobalListHead
	mov	DWORD PTR _list$[ebp], ecx

; 1517 : 
; 1518 : 	if(list) 

	cmp	DWORD PTR _list$[ebp], 0
	je	SHORT $LN9@ComAPIClos

; 1519 : 	{
; 1520 : 		for( i = 0, curr = list; curr; i++, curr = curr  ->  next ) 

	mov	DWORD PTR _i$[ebp], 0
	mov	edx, DWORD PTR _list$[ebp]
	mov	DWORD PTR _curr$[ebp], edx
	jmp	SHORT $LN3@ComAPIClos
$LN2@ComAPIClos:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _curr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _curr$[ebp], edx
$LN3@ComAPIClos:
	cmp	DWORD PTR _curr$[ebp], 0
	je	SHORT $LN9@ComAPIClos

; 1521 : 		{
; 1522 : 			curr->com->close_func(curr->com); 

	mov	eax, DWORD PTR _curr$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _curr$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+36]
	call	ecx
	add	esp, 4

; 1523 : 		}

	jmp	SHORT $LN2@ComAPIClos
$LN9@ComAPIClos:

; 1524 : 	}
; 1525 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ComAPICloseOpenHandles ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\tcp.c
_TEXT	SEGMENT
_cip$1 = -32						; size = 4
_cip$2 = -28						; size = 4
_c$3 = -24						; size = 4
_cip$4 = -20						; size = 4
_c$5 = -16						; size = 4
_c$6 = -12						; size = 4
_group$ = -8						; size = 4
_curr$ = -4						; size = 4
_grouphandle$ = 8					; size = 4
_ipAddress$ = 12					; size = 4
_CAPIIsInGroup PROC

; 1907 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 1908 : 	ComGROUP *group = (ComGROUP *)grouphandle;

	mov	eax, DWORD PTR _grouphandle$[ebp]
	mov	DWORD PTR _group$[ebp], eax

; 1909 : 	CAPIList * curr;
; 1910 : 	
; 1911 : 	if(!grouphandle)

	cmp	DWORD PTR _grouphandle$[ebp], 0
	jne	SHORT $LN18@CAPIIsInGr

; 1912 : 	{
; 1913 : 		return NULL;

	xor	eax, eax
	jmp	$LN19@CAPIIsInGr
$LN18@CAPIIsInGr:

; 1914 : 	}
; 1915 : 
; 1916 : 	if(!CAPIListFindHandle(GlobalGroupListHead,grouphandle))

	mov	ecx, DWORD PTR _grouphandle$[ebp]
	push	ecx
	mov	edx, DWORD PTR _GlobalGroupListHead
	push	edx
	call	_CAPIListFindHandle
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN17@CAPIIsInGr

; 1917 : 	{
; 1918 : 		return NULL; /* is it in  our list ? */

	xor	eax, eax
	jmp	$LN19@CAPIIsInGr
$LN17@CAPIIsInGr:

; 1919 : 	}
; 1920 : 
; 1921 : 	if (group->GroupHead == NULL)

	mov	eax, DWORD PTR _group$[ebp]
	cmp	DWORD PTR [eax+56], 0
	jne	SHORT $LN16@CAPIIsInGr

; 1922 : 	{
; 1923 : 		return NULL;

	xor	eax, eax
	jmp	$LN19@CAPIIsInGr
$LN16@CAPIIsInGr:

; 1924 : 	}
; 1925 : 	
; 1926 : 	/* proceed thru list and call send_function() for each connection */      
; 1927 : 	for( curr = group->GroupHead; curr; curr = curr -> next ) 

	mov	ecx, DWORD PTR _group$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	DWORD PTR _curr$[ebp], edx
	jmp	SHORT $LN15@CAPIIsInGr
$LN14@CAPIIsInGr:
	mov	eax, DWORD PTR _curr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _curr$[ebp], ecx
$LN15@CAPIIsInGr:
	cmp	DWORD PTR _curr$[ebp], 0
	je	$LN13@CAPIIsInGr

; 1928 : 	{
; 1929 : 		if(curr->com->protocol == CAPI_TCP_PROTOCOL)

	mov	edx, DWORD PTR _curr$[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	DWORD PTR [eax+4], 5
	jne	SHORT $LN12@CAPIIsInGr

; 1930 : 		{
; 1931 : 			ComTCP *c;
; 1932 : 			unsigned long cip;
; 1933 : 			
; 1934 : 			c = (ComTCP *)curr->com;

	mov	ecx, DWORD PTR _curr$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _c$5[ebp], edx

; 1935 : 			cip = CAPI_ntohl(c->Addr.sin_addr.s_addr);

	mov	eax, DWORD PTR _c$5[ebp]
	mov	ecx, DWORD PTR [eax+472]
	push	ecx
	call	DWORD PTR _CAPI_ntohl
	mov	DWORD PTR _cip$4[ebp], eax

; 1936 : 
; 1937 : 			if ( cip == ipAddress)

	mov	edx, DWORD PTR _cip$4[ebp]
	cmp	edx, DWORD PTR _ipAddress$[ebp]
	jne	SHORT $LN11@CAPIIsInGr

; 1938 : 			{
; 1939 : 				return curr->com;

	mov	eax, DWORD PTR _curr$[ebp]
	mov	eax, DWORD PTR [eax+8]
	jmp	$LN19@CAPIIsInGr
$LN11@CAPIIsInGr:

; 1940 : 			}

	jmp	$LN10@CAPIIsInGr
$LN12@CAPIIsInGr:

; 1941 : 		}
; 1942 : 		else if(curr->com->protocol == CAPI_UDP_PROTOCOL)

	mov	ecx, DWORD PTR _curr$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx+4], 1
	jne	SHORT $LN9@CAPIIsInGr

; 1943 : 		{
; 1944 : 			ComIP *c;
; 1945 : 			unsigned long cip;
; 1946 : 			
; 1947 : 			c = (ComIP *)curr->com;

	mov	eax, DWORD PTR _curr$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _c$3[ebp], ecx

; 1948 : 			cip = CAPI_ntohl(c->sendAddress.sin_addr.s_addr);

	mov	edx, DWORD PTR _c$3[ebp]
	mov	eax, DWORD PTR [edx+484]
	push	eax
	call	DWORD PTR _CAPI_ntohl
	mov	DWORD PTR _cip$2[ebp], eax

; 1949 : 
; 1950 : 			if ( cip == ipAddress)

	mov	ecx, DWORD PTR _cip$2[ebp]
	cmp	ecx, DWORD PTR _ipAddress$[ebp]
	jne	SHORT $LN8@CAPIIsInGr

; 1951 : 			{
; 1952 : 				return curr->com;

	mov	edx, DWORD PTR _curr$[ebp]
	mov	eax, DWORD PTR [edx+8]
	jmp	$LN19@CAPIIsInGr
$LN8@CAPIIsInGr:

; 1953 : 			}
; 1954 : 		}
; 1955 : 		else if

	jmp	SHORT $LN10@CAPIIsInGr
$LN9@CAPIIsInGr:

; 1956 : 		(
; 1957 : 			(curr->com->protocol == CAPI_DPLAY_TCP_PROTOCOL)   || 
; 1958 : 			(curr->com->protocol == CAPI_DPLAY_MODEM_PROTOCOL) ||
; 1959 : 			(curr->com->protocol == CAPI_DPLAY_SERIAL_PROTOCOL)
; 1960 : 		)

	mov	eax, DWORD PTR _curr$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	DWORD PTR [ecx+4], 8
	je	SHORT $LN5@CAPIIsInGr
	mov	edx, DWORD PTR _curr$[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	DWORD PTR [eax+4], 6
	je	SHORT $LN5@CAPIIsInGr
	mov	ecx, DWORD PTR _curr$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx+4], 7
	jne	SHORT $LN6@CAPIIsInGr
$LN5@CAPIIsInGr:

; 1961 : 		{
; 1962 : 			unsigned long cip;
; 1963 : 			cip = ComAPIQuery(curr->com,COMAPI_CONNECTION_ADDRESS);

	push	4
	mov	eax, DWORD PTR _curr$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_ComAPIQuery
	add	esp, 8
	mov	DWORD PTR _cip$1[ebp], eax

; 1964 : 
; 1965 : 			if ( cip == ipAddress)

	mov	edx, DWORD PTR _cip$1[ebp]
	cmp	edx, DWORD PTR _ipAddress$[ebp]
	jne	SHORT $LN4@CAPIIsInGr

; 1966 : 			{
; 1967 : 				return curr->com;

	mov	eax, DWORD PTR _curr$[ebp]
	mov	eax, DWORD PTR [eax+8]
	jmp	SHORT $LN19@CAPIIsInGr
$LN4@CAPIIsInGr:

; 1968 : 			}

	jmp	SHORT $LN10@CAPIIsInGr
$LN6@CAPIIsInGr:

; 1969 : 		}
; 1970 : 		else if (curr->com->protocol == CAPI_GROUP_PROTOCOL)  /* another group */

	mov	ecx, DWORD PTR _curr$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx+4], 11			; 0000000bH
	jne	SHORT $LN10@CAPIIsInGr

; 1971 : 		{
; 1972 : 			ComAPIHandle c;
; 1973 : 			c = CAPIIsInGroup(curr->com,ipAddress);

	mov	eax, DWORD PTR _ipAddress$[ebp]
	push	eax
	mov	ecx, DWORD PTR _curr$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_CAPIIsInGroup
	add	esp, 8
	mov	DWORD PTR _c$6[ebp], eax

; 1974 : 			if (c)

	cmp	DWORD PTR _c$6[ebp], 0
	je	SHORT $LN10@CAPIIsInGr

; 1975 : 			{
; 1976 : 				return c;

	mov	eax, DWORD PTR _c$6[ebp]
	jmp	SHORT $LN19@CAPIIsInGr
$LN10@CAPIIsInGr:

; 1977 : 			}
; 1978 : 		}
; 1979 : 	}

	jmp	$LN14@CAPIIsInGr
$LN13@CAPIIsInGr:

; 1980 : 
; 1981 : 	return NULL;

	xor	eax, eax
$LN19@CAPIIsInGr:

; 1982 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CAPIIsInGroup ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\tcp.c
_TEXT	SEGMENT
_curr$ = -8						; size = 4
_group$ = -4						; size = 4
_grouphandle$ = 8					; size = 4
_memberhandle$ = 12					; size = 4
_ComAPIDeleteFromGroup PROC

; 2042 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2043 : 	ComGROUP *group = (ComGROUP *)grouphandle;

	mov	eax, DWORD PTR _grouphandle$[ebp]
	mov	DWORD PTR _group$[ebp], eax

; 2044 : 	CAPIList
; 2045 : 		*curr = 0;

	mov	DWORD PTR _curr$[ebp], 0

; 2046 : 	
; 2047 : 	if(!grouphandle)

	cmp	DWORD PTR _grouphandle$[ebp], 0
	jne	SHORT $LN3@ComAPIDele

; 2048 : 	{
; 2049 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN4@ComAPIDele
$LN3@ComAPIDele:

; 2050 : 	}
; 2051 : 
; 2052 : 	if(!memberhandle)

	cmp	DWORD PTR _memberhandle$[ebp], 0
	jne	SHORT $LN2@ComAPIDele

; 2053 : 	{
; 2054 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN4@ComAPIDele
$LN2@ComAPIDele:

; 2055 : 	}
; 2056 : 
; 2057 : 	if(grouphandle->protocol != CAPI_GROUP_PROTOCOL)

	mov	ecx, DWORD PTR _grouphandle$[ebp]
	cmp	DWORD PTR [ecx+4], 11			; 0000000bH
	je	SHORT $LN1@ComAPIDele

; 2058 : 	{
; 2059 : 		return COMAPI_NOTAGROUP;

	mov	eax, -11				; fffffff5H
	jmp	SHORT $LN4@ComAPIDele
$LN1@ComAPIDele:

; 2060 : 	}
; 2061 : 
; 2062 : 	enter_cs ();

	call	_enter_cs

; 2063 : 	
; 2064 : #ifdef _DEBUG
; 2065 : 	MonoPrint ("ComAPIDeleteFromGroup GH:\"%s\" MH:\"%s\"\n", grouphandle->name, memberhandle->name);
; 2066 : #endif
; 2067 : 	group->GroupHead = CAPIListRemove(group->GroupHead,memberhandle);

	mov	edx, DWORD PTR _memberhandle$[ebp]
	push	edx
	mov	eax, DWORD PTR _group$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	_CAPIListRemove
	add	esp, 8
	mov	edx, DWORD PTR _group$[ebp]
	mov	DWORD PTR [edx+56], eax

; 2068 : 
; 2069 : #ifdef _DEBUG
; 2070 : 	MonoPrint ("================================\n");
; 2071 : 	MonoPrint ("GROUP \"%s\"\n", grouphandle->name);
; 2072 : 	curr = group->GroupHead;
; 2073 : 
; 2074 : 	while (curr){
; 2075 : 		if (!F4IsBadReadPtrC(curr->com->name, 1)) // JB 010724 CTD
; 2076 : 			MonoPrint ("  \"%s\"\n", curr->com->name);
; 2077 : 		curr = curr->next;
; 2078 : 	}
; 2079 : 	
; 2080 : 	MonoPrint ("================================\n");
; 2081 : #endif
; 2082 : 
; 2083 : 	leave_cs ();

	call	_leave_cs

; 2084 : 	
; 2085 : 	return 0;

	xor	eax, eax
$LN4@ComAPIDele:

; 2086 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ComAPIDeleteFromGroup ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\tcp.c
_TEXT	SEGMENT
_curr$ = -20						; size = 4
tv89 = -16						; size = 4
_qSize$1 = -12						; size = 4
_bufSize$2 = -8						; size = 4
_group$ = -4						; size = 4
_grouphandle$ = 8					; size = 4
_memberhandle$ = 12					; size = 4
_ComAPIAddToGroup PROC

; 1993 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 1994 : 	ComGROUP *group = (ComGROUP *)grouphandle;

	mov	eax, DWORD PTR _grouphandle$[ebp]
	mov	DWORD PTR _group$[ebp], eax

; 1995 : 	CAPIList *curr = 0;

	mov	DWORD PTR _curr$[ebp], 0

; 1996 : 	
; 1997 : 	if(!grouphandle)

	cmp	DWORD PTR _grouphandle$[ebp], 0
	jne	SHORT $LN4@ComAPIAddT

; 1998 : 	{
; 1999 : 		return COMAPI_EMPTYGROUP;

	mov	eax, -9					; fffffff7H
	jmp	$LN5@ComAPIAddT
$LN4@ComAPIAddT:

; 2000 : 	}
; 2001 : 
; 2002 : 	if(grouphandle->protocol != CAPI_GROUP_PROTOCOL)

	mov	ecx, DWORD PTR _grouphandle$[ebp]
	cmp	DWORD PTR [ecx+4], 11			; 0000000bH
	je	SHORT $LN3@ComAPIAddT

; 2003 : 	{
; 2004 : 		return COMAPI_NOTAGROUP;

	mov	eax, -11				; fffffff5H
	jmp	$LN5@ComAPIAddT
$LN3@ComAPIAddT:

; 2005 : 	}
; 2006 : 
; 2007 : 	enter_cs ();

	call	_enter_cs

; 2008 : 	
; 2009 : 	group->GroupHead = CAPIListRemove(group->GroupHead,memberhandle);

	mov	edx, DWORD PTR _memberhandle$[ebp]
	push	edx
	mov	eax, DWORD PTR _group$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	_CAPIListRemove
	add	esp, 8
	mov	edx, DWORD PTR _group$[ebp]
	mov	DWORD PTR [edx+56], eax

; 2010 : 	group->GroupHead = CAPIListAppend(group->GroupHead);

	mov	eax, DWORD PTR _group$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	_CAPIListAppend
	add	esp, 4
	mov	edx, DWORD PTR _group$[ebp]
	mov	DWORD PTR [edx+56], eax

; 2011 : 
; 2012 : 	if(! group->GroupHead)

	mov	eax, DWORD PTR _group$[ebp]
	cmp	DWORD PTR [eax+56], 0
	jne	SHORT $LN2@ComAPIAddT

; 2013 : 	{
; 2014 : 		leave_cs ();

	call	_leave_cs

; 2015 : 		return COMAPI_EMPTYGROUP;

	mov	eax, -9					; fffffff7H
	jmp	SHORT $LN5@ComAPIAddT
$LN2@ComAPIAddT:

; 2016 : 	}
; 2017 : 
; 2018 : 	group->GroupHead->com = memberhandle;

	mov	ecx, DWORD PTR _group$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _memberhandle$[ebp]
	mov	DWORD PTR [edx+8], eax

; 2019 : 
; 2020 : 	/* Reduce group send_buffer size if adding a member with smaller buffer */
; 2021 : 	{	
; 2022 : 		int bufSize = group->buffer_size;

	mov	ecx, DWORD PTR _group$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR _bufSize$2[ebp], edx

; 2023 : 		int qSize = (int)memberhandle->query_func(memberhandle,COMAPI_ACTUAL_BUFFER_SIZE)+group->max_header;

	push	14					; 0000000eH
	mov	eax, DWORD PTR _memberhandle$[ebp]
	push	eax
	mov	ecx, DWORD PTR _memberhandle$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	call	edx
	add	esp, 8
	mov	ecx, DWORD PTR _group$[ebp]
	add	eax, DWORD PTR [ecx+64]
	mov	DWORD PTR _qSize$1[ebp], eax

; 2024 : 		group->buffer_size = min(bufSize, qSize);

	mov	edx, DWORD PTR _bufSize$2[ebp]
	cmp	edx, DWORD PTR _qSize$1[ebp]
	jge	SHORT $LN7@ComAPIAddT
	mov	eax, DWORD PTR _bufSize$2[ebp]
	mov	DWORD PTR tv89[ebp], eax
	jmp	SHORT $LN8@ComAPIAddT
$LN7@ComAPIAddT:
	mov	ecx, DWORD PTR _qSize$1[ebp]
	mov	DWORD PTR tv89[ebp], ecx
$LN8@ComAPIAddT:
	mov	edx, DWORD PTR _group$[ebp]
	mov	eax, DWORD PTR tv89[ebp]
	mov	DWORD PTR [edx+48], eax

; 2025 : 	}
; 2026 : 	
; 2027 : 	/* If Group HostID is NULL, take HostID from the first added member*/
; 2028 : 	if(group->HostID == 0){

	mov	ecx, DWORD PTR _group$[ebp]
	cmp	DWORD PTR [ecx+52], 0
	jne	SHORT $LN1@ComAPIAddT

; 2029 : 		memberhandle->addr_func(memberhandle,(char *)&group->HostID, 0);

	push	0
	mov	edx, DWORD PTR _group$[ebp]
	add	edx, 52					; 00000034H
	push	edx
	mov	eax, DWORD PTR _memberhandle$[ebp]
	push	eax
	mov	ecx, DWORD PTR _memberhandle$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	call	edx
	add	esp, 12					; 0000000cH
$LN1@ComAPIAddT:

; 2030 : 	}
; 2031 : 
; 2032 : 	leave_cs ();

	call	_leave_cs

; 2033 : 
; 2034 : 	return 0;

	xor	eax, eax
$LN5@ComAPIAddT:

; 2035 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ComAPIAddToGroup ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\tcp.c
_TEXT	SEGMENT
_curr$ = -48						; size = 4
tv151 = -44						; size = 4
tv133 = -40						; size = 4
tv83 = -36						; size = 4
_count$ = -32						; size = 4
_vptr$ = -28						; size = 4
tv70 = -24						; size = 4
_HostID$ = -20						; size = 4
_marker$ = -16						; size = 4
_buffersize$ = -12					; size = 4
_CH$ = -8						; size = 4
_group$ = -4						; size = 4
_name_in$ = 8						; size = 4
_BufferSize$ = 12					; size = 4
_ComAPICreateGroup PROC

; 2418 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H

; 2419 : 	ComGROUP *group;
; 2420 : 	va_list marker;
; 2421 : 	LPVOID   vptr;
; 2422 : 	int buffersize;
; 2423 : 	int count=0;

	mov	DWORD PTR _count$[ebp], 0

; 2424 : 	ComAPIHandle CH;
; 2425 : 	unsigned int HostID=0;

	mov	DWORD PTR _HostID$[ebp], 0

; 2426 : 	CAPIList
; 2427 : 		*curr = 0;

	mov	DWORD PTR _curr$[ebp], 0

; 2428 : 
; 2429 : 	enter_cs ();

	call	_enter_cs

; 2430 : 	
; 2431 : 	buffersize = BufferSize; 

	mov	eax, DWORD PTR _BufferSize$[ebp]
	mov	DWORD PTR _buffersize$[ebp], eax

; 2432 : 	va_start( marker, BufferSize );     /* Initialize variable arguments. */

	lea	ecx, DWORD PTR _BufferSize$[ebp+4]
	mov	DWORD PTR _marker$[ebp], ecx

; 2433 : 	vptr = va_arg( marker, LPVOID);

	mov	edx, DWORD PTR _marker$[ebp]
	add	edx, 4
	mov	DWORD PTR _marker$[ebp], edx
	mov	eax, DWORD PTR _marker$[ebp]
	mov	ecx, DWORD PTR [eax-4]
	mov	DWORD PTR _vptr$[ebp], ecx
$LN20@ComAPICrea:

; 2434 : 	
; 2435 : 	while( vptr != 0 )

	cmp	DWORD PTR _vptr$[ebp], 0
	je	$LN19@ComAPICrea

; 2436 : 	{
; 2437 : 		count++;

	mov	edx, DWORD PTR _count$[ebp]
	add	edx, 1
	mov	DWORD PTR _count$[ebp], edx

; 2438 : 		
; 2439 : 		CH =  (ComAPIHandle)vptr;

	mov	eax, DWORD PTR _vptr$[ebp]
	mov	DWORD PTR _CH$[ebp], eax

; 2440 : 
; 2441 : 		switch(CH->protocol)

	mov	ecx, DWORD PTR _CH$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv70[ebp], edx
	mov	eax, DWORD PTR tv70[ebp]
	sub	eax, 1
	mov	DWORD PTR tv70[ebp], eax
	cmp	DWORD PTR tv70[ebp], 6
	ja	$LN17@ComAPICrea
	mov	ecx, DWORD PTR tv70[ebp]
	jmp	DWORD PTR $LN29@ComAPICrea[ecx*4]
$LN16@ComAPICrea:

; 2442 : 		{
; 2443 : 			case CAPI_UDP_PROTOCOL:
; 2444 : 			{
; 2445 : 				MonoPrint ("ComAPICreateGroup UDP\n");

	push	OFFSET ??_C@_0BH@OIOCLEPO@ComAPICreateGroup?5UDP?6?$AA@
	call	_MonoPrint
	add	esp, 4

; 2446 : 				if (buffersize == 0)

	cmp	DWORD PTR _buffersize$[ebp], 0
	jne	SHORT $LN15@ComAPICrea

; 2447 : 				{
; 2448 : 					buffersize = ((ComIP *)CH)->buffer_size;

	mov	edx, DWORD PTR _CH$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	DWORD PTR _buffersize$[ebp], eax

; 2449 : 				}
; 2450 : 				else

	jmp	SHORT $LN14@ComAPICrea
$LN15@ComAPICrea:

; 2451 : 				{
; 2452 : 					buffersize = min(buffersize,(int)CH->query_func(CH,COMAPI_ACTUAL_BUFFER_SIZE));

	push	14					; 0000000eH
	mov	ecx, DWORD PTR _CH$[ebp]
	push	ecx
	mov	edx, DWORD PTR _CH$[ebp]
	mov	eax, DWORD PTR [edx+40]
	call	eax
	add	esp, 8
	cmp	DWORD PTR _buffersize$[ebp], eax
	jge	SHORT $LN23@ComAPICrea
	mov	ecx, DWORD PTR _buffersize$[ebp]
	mov	DWORD PTR tv83[ebp], ecx
	jmp	SHORT $LN24@ComAPICrea
$LN23@ComAPICrea:
	push	14					; 0000000eH
	mov	edx, DWORD PTR _CH$[ebp]
	push	edx
	mov	eax, DWORD PTR _CH$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	call	ecx
	add	esp, 8
	mov	DWORD PTR tv83[ebp], eax
$LN24@ComAPICrea:
	mov	edx, DWORD PTR tv83[ebp]
	mov	DWORD PTR _buffersize$[ebp], edx
$LN14@ComAPICrea:

; 2453 : 				}
; 2454 : 
; 2455 : 				if(HostID == 0)

	cmp	DWORD PTR _HostID$[ebp], 0
	jne	SHORT $LN13@ComAPICrea

; 2456 : 				{
; 2457 : 					CH->addr_func(CH,(char *)&HostID, 0);

	push	0
	lea	eax, DWORD PTR _HostID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _CH$[ebp]
	push	ecx
	mov	edx, DWORD PTR _CH$[ebp]
	mov	eax, DWORD PTR [edx+32]
	call	eax
	add	esp, 12					; 0000000cH
$LN13@ComAPICrea:

; 2458 : 				}
; 2459 : 				
; 2460 : 				break;

	jmp	$LN17@ComAPICrea
$LN12@ComAPICrea:

; 2461 : 			}
; 2462 : 
; 2463 : 			case CAPI_TCP_PROTOCOL:
; 2464 : 			{	
; 2465 : 				MonoPrint ("ComAPICreateGroup RUDP\n");

	push	OFFSET ??_C@_0BI@FONHDAAB@ComAPICreateGroup?5RUDP?6?$AA@
	call	_MonoPrint
	add	esp, 4

; 2466 : 				if (buffersize == 0)

	cmp	DWORD PTR _buffersize$[ebp], 0
	jne	SHORT $LN11@ComAPICrea

; 2467 : 				{
; 2468 : 					buffersize = ((ComTCP *)CH)->buffer_size;

	mov	ecx, DWORD PTR _CH$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR _buffersize$[ebp], edx

; 2469 : 				}
; 2470 : 				else

	jmp	SHORT $LN10@ComAPICrea
$LN11@ComAPICrea:

; 2471 : 				{
; 2472 : 					buffersize = min(buffersize,(int)CH->query_func(CH,COMAPI_ACTUAL_BUFFER_SIZE));

	push	14					; 0000000eH
	mov	eax, DWORD PTR _CH$[ebp]
	push	eax
	mov	ecx, DWORD PTR _CH$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	call	edx
	add	esp, 8
	cmp	DWORD PTR _buffersize$[ebp], eax
	jge	SHORT $LN25@ComAPICrea
	mov	eax, DWORD PTR _buffersize$[ebp]
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN26@ComAPICrea
$LN25@ComAPICrea:
	push	14					; 0000000eH
	mov	ecx, DWORD PTR _CH$[ebp]
	push	ecx
	mov	edx, DWORD PTR _CH$[ebp]
	mov	eax, DWORD PTR [edx+40]
	call	eax
	add	esp, 8
	mov	DWORD PTR tv133[ebp], eax
$LN26@ComAPICrea:
	mov	ecx, DWORD PTR tv133[ebp]
	mov	DWORD PTR _buffersize$[ebp], ecx
$LN10@ComAPICrea:

; 2473 : 				}
; 2474 : 
; 2475 : 				if(HostID == 0)

	cmp	DWORD PTR _HostID$[ebp], 0
	jne	SHORT $LN9@ComAPICrea

; 2476 : 				{
; 2477 : 					CH->addr_func(CH,(char *)&HostID, 0);

	push	0
	lea	edx, DWORD PTR _HostID$[ebp]
	push	edx
	mov	eax, DWORD PTR _CH$[ebp]
	push	eax
	mov	ecx, DWORD PTR _CH$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	call	edx
	add	esp, 12					; 0000000cH
$LN9@ComAPICrea:

; 2478 : 				}
; 2479 : 				
; 2480 : 				break;

	jmp	SHORT $LN17@ComAPICrea
$LN8@ComAPICrea:

; 2481 : 			}
; 2482 : 				
; 2483 : 			/* a trick -- use COMIP here/below since top of ComDPLAY struct is same as ComIP */
; 2484 : 			case CAPI_DPLAY_SERIAL_PROTOCOL:
; 2485 : 			case CAPI_DPLAY_MODEM_PROTOCOL:
; 2486 : 			{
; 2487 : 				MonoPrint ("ComAPICreateGroup Serial\n");

	push	OFFSET ??_C@_0BK@HCBMGOHN@ComAPICreateGroup?5Serial?6?$AA@
	call	_MonoPrint
	add	esp, 4

; 2488 : 				if (buffersize == 0)

	cmp	DWORD PTR _buffersize$[ebp], 0
	jne	SHORT $LN7@ComAPICrea

; 2489 : 				{
; 2490 : 					buffersize = ((ComIP *)CH)->buffer_size;  

	mov	eax, DWORD PTR _CH$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR _buffersize$[ebp], ecx

; 2491 : 				}
; 2492 : 				else

	jmp	SHORT $LN6@ComAPICrea
$LN7@ComAPICrea:

; 2493 : 				{
; 2494 : 					buffersize = min(buffersize,(int)CH->query_func(CH,COMAPI_ACTUAL_BUFFER_SIZE));

	push	14					; 0000000eH
	mov	edx, DWORD PTR _CH$[ebp]
	push	edx
	mov	eax, DWORD PTR _CH$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	call	ecx
	add	esp, 8
	cmp	DWORD PTR _buffersize$[ebp], eax
	jge	SHORT $LN27@ComAPICrea
	mov	edx, DWORD PTR _buffersize$[ebp]
	mov	DWORD PTR tv151[ebp], edx
	jmp	SHORT $LN28@ComAPICrea
$LN27@ComAPICrea:
	push	14					; 0000000eH
	mov	eax, DWORD PTR _CH$[ebp]
	push	eax
	mov	ecx, DWORD PTR _CH$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	call	edx
	add	esp, 8
	mov	DWORD PTR tv151[ebp], eax
$LN28@ComAPICrea:
	mov	eax, DWORD PTR tv151[ebp]
	mov	DWORD PTR _buffersize$[ebp], eax
$LN6@ComAPICrea:

; 2495 : 				}
; 2496 : 
; 2497 : 				if (HostID == 0)

	cmp	DWORD PTR _HostID$[ebp], 0
	jne	SHORT $LN17@ComAPICrea

; 2498 : 				{
; 2499 : 					CH->addr_func(CH,(char *)&HostID, 0);

	push	0
	lea	ecx, DWORD PTR _HostID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _CH$[ebp]
	push	edx
	mov	eax, DWORD PTR _CH$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	call	ecx
	add	esp, 12					; 0000000cH
$LN17@ComAPICrea:

; 2500 : 				}
; 2501 : 				
; 2502 : 				break;
; 2503 : 			}
; 2504 : 				
; 2505 : 			default:
; 2506 : 			{
; 2507 : 				break;
; 2508 : 			}
; 2509 : 		}
; 2510 : 		
; 2511 : 		vptr = va_arg( marker, LPVOID);

	mov	edx, DWORD PTR _marker$[ebp]
	add	edx, 4
	mov	DWORD PTR _marker$[ebp], edx
	mov	eax, DWORD PTR _marker$[ebp]
	mov	ecx, DWORD PTR [eax-4]
	mov	DWORD PTR _vptr$[ebp], ecx

; 2512 : 	}

	jmp	$LN20@ComAPICrea
$LN19@ComAPICrea:

; 2513 : 	
; 2514 : 	va_end( marker );  

	mov	DWORD PTR _marker$[ebp], 0

; 2515 : 	
; 2516 : 	if (count == 0)

	cmp	DWORD PTR _count$[ebp], 0
	jne	SHORT $LN3@ComAPICrea

; 2517 : 	{
; 2518 : 		buffersize = BufferSize;

	mov	edx, DWORD PTR _BufferSize$[ebp]
	mov	DWORD PTR _buffersize$[ebp], edx
$LN3@ComAPICrea:

; 2519 : 	}
; 2520 : 	
; 2521 : 	if(buffersize == 0 )

	cmp	DWORD PTR _buffersize$[ebp], 0
	jne	SHORT $LN2@ComAPICrea

; 2522 : 	{
; 2523 : 		leave_cs ();

	call	_leave_cs

; 2524 : 
; 2525 : 		return NULL;

	xor	eax, eax
	jmp	$LN21@ComAPICrea
$LN2@ComAPICrea:

; 2526 : 	}
; 2527 : 		
; 2528 : 	MonoPrint ("ComAPICreateGroup CAPIListAppend GlobalGroupListHead\n");

	push	OFFSET ??_C@_0DG@KHEJLJNI@ComAPICreateGroup?5CAPIListAppend@
	call	_MonoPrint
	add	esp, 4

; 2529 : 	GlobalGroupListHead = CAPIListAppend(GlobalGroupListHead);

	mov	eax, DWORD PTR _GlobalGroupListHead
	push	eax
	call	_CAPIListAppend
	add	esp, 4
	mov	DWORD PTR _GlobalGroupListHead, eax

; 2530 : 
; 2531 : 	if(!GlobalGroupListHead)

	cmp	DWORD PTR _GlobalGroupListHead, 0
	jne	SHORT $LN1@ComAPICrea

; 2532 : 	{
; 2533 : 		leave_cs ();

	call	_leave_cs

; 2534 : 
; 2535 : 		return NULL;

	xor	eax, eax
	jmp	$LN21@ComAPICrea
$LN1@ComAPICrea:

; 2536 : 	}
; 2537 : 	
; 2538 : 	/* allocate a new ComHandle struct */
; 2539 : 	GlobalGroupListHead->com = (ComAPIHandle)malloc(sizeof(ComGROUP));

	push	72					; 00000048H
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _GlobalGroupListHead
	mov	DWORD PTR [ecx+8], eax

; 2540 : 	memset(GlobalGroupListHead->com,0,sizeof(ComGROUP));

	push	72					; 00000048H
	push	0
	mov	edx, DWORD PTR _GlobalGroupListHead
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 2541 : 	GlobalGroupListHead->com->name = (char*)malloc (strlen (name_in) + 1);

	mov	ecx, DWORD PTR _name_in$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	add	eax, 1
	push	eax
	call	_malloc
	add	esp, 4
	mov	edx, DWORD PTR _GlobalGroupListHead
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx], eax

; 2542 : 	strcpy (GlobalGroupListHead->com->name, name_in);

	mov	edx, DWORD PTR _name_in$[ebp]
	push	edx
	mov	eax, DWORD PTR _GlobalGroupListHead
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_strcpy
	add	esp, 8

; 2543 : 	group = (ComGROUP *)  (GlobalGroupListHead->com);

	mov	eax, DWORD PTR _GlobalGroupListHead
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _group$[ebp], ecx

; 2544 : 	group->HostID = HostID;

	mov	edx, DWORD PTR _group$[ebp]
	mov	eax, DWORD PTR _HostID$[ebp]
	mov	DWORD PTR [edx+52], eax

; 2545 : 
; 2546 : #ifdef _DEBUG
; 2547 : 	MonoPrint ("================================\n");
; 2548 : 	MonoPrint ("GlobalGroupListHead\n");
; 2549 : 	curr = GlobalGroupListHead;
; 2550 : 	while (curr)
; 2551 : 	{
; 2552 : 		if (!F4IsBadReadPtrC(curr->com->name, 1)) // JB 010724 CTD
; 2553 : 			MonoPrint ("  \"%s\"\n", curr->com->name);
; 2554 : 		curr = curr->next;
; 2555 : 	}
; 2556 : 	MonoPrint ("================================\n");
; 2557 : 
; 2558 : 	MonoPrint ("ComAPICreateGroup Created ComGroup \"%s\"\n", GlobalGroupListHead->com->name);
; 2559 : 	MonoPrint ("ComAPICreateGroup Appended GGLH%08x CH:\"%s\" IP%08x\n", GlobalGroupListHead, GlobalGroupListHead->com->name, HostID);
; 2560 : #endif
; 2561 : 	
; 2562 : 	/* initialize header data */
; 2563 : 	
; 2564 : 	group->GroupHead  = NULL;

	mov	ecx, DWORD PTR _group$[ebp]
	mov	DWORD PTR [ecx+56], 0

; 2565 : 	
; 2566 : 	group->apiheader.protocol          = CAPI_GROUP_PROTOCOL;

	mov	edx, DWORD PTR _group$[ebp]
	mov	DWORD PTR [edx+4], 11			; 0000000bH

; 2567 : 	
; 2568 : 	group->apiheader.recv_func         = ComGROUPGet;

	mov	eax, DWORD PTR _group$[ebp]
	mov	DWORD PTR [eax+20], OFFSET _ComGROUPGet

; 2569 : 	group->apiheader.recv_buf_func     = ComGROUPRecvBufferGet;

	mov	ecx, DWORD PTR _group$[ebp]
	mov	DWORD PTR [ecx+28], OFFSET _ComGROUPRecvBufferGet

; 2570 : 	group->apiheader.addr_func         = ComGROUPAddress;

	mov	edx, DWORD PTR _group$[ebp]
	mov	DWORD PTR [edx+32], OFFSET _ComGROUPAddress

; 2571 : 	group->apiheader.query_func        = ComGROUPQuery;

	mov	eax, DWORD PTR _group$[ebp]
	mov	DWORD PTR [eax+40], OFFSET _ComGROUPQuery

; 2572 : 	group->apiheader.close_func        = ComGROUPClose;

	mov	ecx, DWORD PTR _group$[ebp]
	mov	DWORD PTR [ecx+36], OFFSET _ComGROUPClose

; 2573 : 	group->apiheader.send_buf_func     = ComGROUPSendBufferGet;

	mov	edx, DWORD PTR _group$[ebp]
	mov	DWORD PTR [edx+24], OFFSET _ComGROUPSendBufferGet

; 2574 : 	group->apiheader.send_func         = ComGROUPSend;

	mov	eax, DWORD PTR _group$[ebp]
	mov	DWORD PTR [eax+8], OFFSET _ComGROUPSend

; 2575 : 	group->apiheader.sendX_func         = ComGROUPSendX;

	mov	ecx, DWORD PTR _group$[ebp]
	mov	DWORD PTR [ecx+16], OFFSET _ComGROUPSendX

; 2576 : 	group->apiheader.get_timestamp_func = ComTCPGetTimeStamp;

	mov	edx, DWORD PTR _group$[ebp]
	mov	DWORD PTR [edx+44], OFFSET _ComTCPGetTimeStamp

; 2577 : 	
; 2578 : 	group->max_header =  max(sizeof(tcpHeader),sizeof(ComAPIHeader));

	mov	eax, DWORD PTR _group$[ebp]
	mov	DWORD PTR [eax+64], 8

; 2579 : 	group->buffer_size = buffersize + group->max_header;

	mov	ecx, DWORD PTR _group$[ebp]
	mov	edx, DWORD PTR _buffersize$[ebp]
	add	edx, DWORD PTR [ecx+64]
	mov	eax, DWORD PTR _group$[ebp]
	mov	DWORD PTR [eax+48], edx

; 2580 : 	group->send_buffer = (char *)malloc(group->buffer_size);

	mov	ecx, DWORD PTR _group$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _group$[ebp]
	mov	DWORD PTR [ecx+60], eax

; 2581 : 	group->TCP_buffer_shift =  (char)(group->max_header - sizeof(tcpHeader));

	mov	edx, DWORD PTR _group$[ebp]
	mov	eax, DWORD PTR [edx+64]
	sub	eax, 6
	mov	ecx, DWORD PTR _group$[ebp]
	mov	BYTE PTR [ecx+68], al

; 2582 : 	group->UDP_buffer_shift =  (char)(group->max_header - sizeof(ComAPIHeader));

	mov	edx, DWORD PTR _group$[ebp]
	mov	eax, DWORD PTR [edx+64]
	sub	eax, 8
	mov	ecx, DWORD PTR _group$[ebp]
	mov	BYTE PTR [ecx+69], al

; 2583 : 	group->RUDP_buffer_shift = (char)group->max_header;

	mov	edx, DWORD PTR _group$[ebp]
	mov	eax, DWORD PTR _group$[ebp]
	mov	cl, BYTE PTR [eax+64]
	mov	BYTE PTR [edx+70], cl

; 2584 : 	group->DPLAY_buffer_shift = 0;

	mov	edx, DWORD PTR _group$[ebp]
	mov	BYTE PTR [edx+71], 0

; 2585 : 
; 2586 : 	leave_cs ();

	call	_leave_cs

; 2587 : 	
; 2588 : 	return (ComAPIHandle) group;

	mov	eax, DWORD PTR _group$[ebp]
$LN21@ComAPICrea:

; 2589 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN29@ComAPICrea:
	DD	$LN16@ComAPICrea
	DD	$LN17@ComAPICrea
	DD	$LN17@ComAPICrea
	DD	$LN17@ComAPICrea
	DD	$LN12@ComAPICrea
	DD	$LN8@ComAPICrea
	DD	$LN8@ComAPICrea
_ComAPICreateGroup ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\tcp.c
_TEXT	SEGMENT
_listener$ = -416					; size = 4
_listitem$ = -412					; size = 4
_c$ = -408						; size = 4
_wsaData$ = -404					; size = 400
__$ArrayPad$ = -4					; size = 4
_IPaddress$ = 8						; size = 4
_tcpPort$ = 12						; size = 4
_timeoutsecs$ = 16					; size = 4
_ComTCPOpenAccept PROC

; 367  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 416				; 000001a0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 368  : 	ComTCP *c, *listener;
; 369  : 	CAPIList *listitem;
; 370  : 	WSADATA wsaData;
; 371  : 	
; 372  : 	/* InitWS2 checks that WSASstartup is done only once and increments reference count*/
; 373  : 	if (InitWS2(&wsaData) == 0)

	lea	eax, DWORD PTR _wsaData$[ebp]
	push	eax
	call	_InitWS2
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN5@ComTCPOpen

; 374  : 	{
; 375  : 		return NULL;

	xor	eax, eax
	jmp	$LN6@ComTCPOpen
$LN5@ComTCPOpen:

; 376  : 	}
; 377  : 	
; 378  : 	if (IPaddress == 0)

	cmp	DWORD PTR _IPaddress$[ebp], 0
	jne	SHORT $LN4@ComTCPOpen

; 379  : 	{
; 380  : 		return NULL;

	xor	eax, eax
	jmp	$LN6@ComTCPOpen
$LN4@ComTCPOpen:

; 381  : 	}
; 382  : 	enter_cs();

	call	_enter_cs

; 383  : 	if(!(listitem = CAPIListFindTCPListenPort(GlobalListHead,(unsigned short)tcpPort)))

	movzx	ecx, WORD PTR _tcpPort$[ebp]
	push	ecx
	mov	edx, DWORD PTR _GlobalListHead
	push	edx
	call	_CAPIListFindTCPListenPort
	add	esp, 8
	mov	DWORD PTR _listitem$[ebp], eax
	cmp	DWORD PTR _listitem$[ebp], 0
	jne	SHORT $LN3@ComTCPOpen

; 384  : 	{
; 385  : 	    leave_cs();

	call	_leave_cs

; 386  : 		return NULL;

	xor	eax, eax
	jmp	$LN6@ComTCPOpen
$LN3@ComTCPOpen:

; 387  : 	}
; 388  : 	
; 389  : 	listener = (ComTCP *)listitem->com;

	mov	eax, DWORD PTR _listitem$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _listener$[ebp], ecx

; 390  : 	
; 391  : 	/* Is this handle already in our list */
; 392  : 	listitem = CAPIListFindTCPIPaddress(GlobalListHead,CAPI_htonl(IPaddress),CAPI_htons((unsigned short)tcpPort));

	movzx	edx, WORD PTR _tcpPort$[ebp]
	push	edx
	call	DWORD PTR _CAPI_htons
	movzx	eax, ax
	push	eax
	mov	ecx, DWORD PTR _IPaddress$[ebp]
	push	ecx
	call	DWORD PTR _CAPI_htonl
	push	eax
	mov	edx, DWORD PTR _GlobalListHead
	push	edx
	call	_CAPIListFindTCPIPaddress
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _listitem$[ebp], eax

; 393  : 	if(listitem)

	cmp	DWORD PTR _listitem$[ebp], 0
	je	SHORT $LN2@ComTCPOpen

; 394  : 	{ 
; 395  : 	    leave_cs();

	call	_leave_cs

; 396  : 		
; 397  : 		return listitem->com;

	mov	eax, DWORD PTR _listitem$[ebp]
	mov	eax, DWORD PTR [eax+8]
	jmp	$LN6@ComTCPOpen
$LN2@ComTCPOpen:

; 398  : 	}
; 399  : 	
; 400  : 	/* add connection to our local list */
; 401  : 	GlobalListHead = CAPIListAppend(GlobalListHead);

	mov	ecx, DWORD PTR _GlobalListHead
	push	ecx
	call	_CAPIListAppend
	add	esp, 4
	mov	DWORD PTR _GlobalListHead, eax

; 402  : 	if(!GlobalListHead)

	cmp	DWORD PTR _GlobalListHead, 0
	jne	SHORT $LN1@ComTCPOpen

; 403  : 	{
; 404  : 	    leave_cs();

	call	_leave_cs

; 405  : 		return NULL;

	xor	eax, eax
	jmp	$LN6@ComTCPOpen
$LN1@ComTCPOpen:

; 406  : 	}
; 407  : 	
; 408  : 	/* allocate a new ComHandle struct */
; 409  : 	GlobalListHead->com = (ComAPIHandle)malloc(sizeof(ComTCP));

	push	572					; 0000023cH
	call	_malloc
	add	esp, 4
	mov	edx, DWORD PTR _GlobalListHead
	mov	DWORD PTR [edx+8], eax

; 410  : 	c = (ComTCP*)(GlobalListHead->com);

	mov	eax, DWORD PTR _GlobalListHead
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _c$[ebp], ecx

; 411  : 	memset(c,0,sizeof(ComTCP));

	push	572					; 0000023cH
	push	0
	mov	edx, DWORD PTR _c$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 412  : 	/* copy the Listen socket's ComHandle data into the Accepted socket's ComHandle*/
; 413  : 	memcpy(c,listener,sizeof(ComTCP));

	push	572					; 0000023cH
	mov	eax, DWORD PTR _listener$[ebp]
	push	eax
	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 414  : 	c->recv_sock = c->send_sock = 0;

	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [edx+484], 0
	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+488], 0

; 415  : 	c->state = COMAPI_STATE_CONNECTION_PENDING;

	xor	ecx, ecx
	mov	edx, DWORD PTR _c$[ebp]
	mov	WORD PTR [edx+522], cx

; 416  : 	((ComAPIHandle)c)->protocol = CAPI_TCP_PROTOCOL;

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+4], 5

; 417  : 	c->lock = 0;

	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+508], 0

; 418  : 	
; 419  : 	/* Create the target address... */
; 420  : 	memset ((char*)&c->Addr, 0, sizeof(c->Addr));

	push	16					; 00000010H
	push	0
	mov	edx, DWORD PTR _c$[ebp]
	add	edx, 468				; 000001d4H
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 421  : 	c->Addr.sin_family       = AF_INET;

	mov	eax, 2
	mov	ecx, DWORD PTR _c$[ebp]
	mov	WORD PTR [ecx+468], ax

; 422  : 	c->Addr.sin_port         = CAPI_htons((unsigned short)tcpPort);

	movzx	edx, WORD PTR _tcpPort$[ebp]
	push	edx
	call	DWORD PTR _CAPI_htons
	mov	ecx, DWORD PTR _c$[ebp]
	mov	WORD PTR [ecx+470], ax

; 423  : 	c->Addr.sin_addr.s_addr  = CAPI_htonl(IPaddress);

	mov	edx, DWORD PTR _IPaddress$[ebp]
	push	edx
	call	DWORD PTR _CAPI_htonl
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+472], eax

; 424  : 	
; 425  : 	c->send_buffer.buf = (char *)malloc(c->buffer_size);

	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [edx+48]
	push	eax
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+56], eax

; 426  : 	c->recv_buffer.buf = (char *)malloc( c->buffer_size);

	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [edx+48]
	push	eax
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+64], eax

; 427  : 	c->recv_buffer_start = c->recv_buffer.buf;

	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	DWORD PTR [edx+540], ecx

; 428  : 	c->ThreadActive = THREAD_STOP;  

	xor	edx, edx
	mov	eax, DWORD PTR _c$[ebp]
	mov	WORD PTR [eax+516], dx

; 429  : 	c->handletype = CONNECTION;

	mov	ecx, 2
	mov	edx, DWORD PTR _c$[ebp]
	mov	WORD PTR [edx+520], cx

; 430  : 	
; 431  : 	c->bytes_needed_for_message = (long)clock();  /* use this variable to hold start time */

	call	_clock
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+548], eax

; 432  : 	c->timeoutsecs = (short)timeoutsecs;

	mov	edx, DWORD PTR _c$[ebp]
	mov	ax, WORD PTR _timeoutsecs$[ebp]
	mov	WORD PTR [edx+518], ax

; 433  : 	
; 434  : 	    leave_cs();

	call	_leave_cs

; 435  : 	
; 436  : 	return (ComAPIHandle)c;

	mov	eax, DWORD PTR _c$[ebp]
$LN6@ComTCPOpen:

; 437  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_ComTCPOpenAccept ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\tcp.c
_TEXT	SEGMENT
_err$ = -420						; size = 4
_listitem$ = -416					; size = 4
_w$1 = -412						; size = 4
_c$ = -408						; size = 4
_wsaData$ = -404					; size = 400
__$ArrayPad$ = -4					; size = 4
_buffersize$ = 8					; size = 4
_gamename$ = 12						; size = 4
_tcpPort$ = 16						; size = 4
_IPaddress$ = 20					; size = 4
_ConnectCallback$ = 24					; size = 4
_timeoutsecs$ = 28					; size = 4
_ComTCPOpenConnect PROC

; 258  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 420				; 000001a4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 259  : 	ComTCP *c;
; 260  : 	int err;
; 261  : //	int trueValue=1;
; 262  : //	int falseValue=0;
; 263  : 	WSADATA wsaData;
; 264  : 	CAPIList *listitem;
; 265  : 	
; 266  : 	gamename;
; 267  : 
; 268  : 	/* InitWS2 checks that WSASstartup is done only once and increments reference count*/
; 269  : 	if (InitWS2(&wsaData) == 0)

	lea	eax, DWORD PTR _wsaData$[ebp]
	push	eax
	call	_InitWS2
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN9@ComTCPOpen

; 270  : 	{
; 271  : 		return NULL;

	xor	eax, eax
	jmp	$LN10@ComTCPOpen
$LN9@ComTCPOpen:

; 272  : 	}
; 273  : 	enter_cs();	

	call	_enter_cs

; 274  : 	/* GFG */
; 275  : 	listitem = CAPIListFindTCPIPaddress(GlobalListHead,CAPI_htonl(IPaddress),CAPI_htons((unsigned short)tcpPort));

	movzx	ecx, WORD PTR _tcpPort$[ebp]
	push	ecx
	call	DWORD PTR _CAPI_htons
	movzx	edx, ax
	push	edx
	mov	eax, DWORD PTR _IPaddress$[ebp]
	push	eax
	call	DWORD PTR _CAPI_htonl
	push	eax
	mov	ecx, DWORD PTR _GlobalListHead
	push	ecx
	call	_CAPIListFindTCPIPaddress
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _listitem$[ebp], eax

; 276  : 	if(listitem)

	cmp	DWORD PTR _listitem$[ebp], 0
	je	SHORT $LN8@ComTCPOpen

; 277  : 	{ 
; 278  : 		leave_cs();

	call	_leave_cs

; 279  : 		return NULL;

	xor	eax, eax
	jmp	$LN10@ComTCPOpen
$LN8@ComTCPOpen:

; 280  : 	}
; 281  : 	
; 282  : 	GlobalListHead = CAPIListAppend(GlobalListHead);

	mov	edx, DWORD PTR _GlobalListHead
	push	edx
	call	_CAPIListAppend
	add	esp, 4
	mov	DWORD PTR _GlobalListHead, eax

; 283  : 	if(!GlobalListHead)

	cmp	DWORD PTR _GlobalListHead, 0
	jne	SHORT $LN7@ComTCPOpen

; 284  : 	{
; 285  : 		leave_cs();

	call	_leave_cs

; 286  : 		return NULL;

	xor	eax, eax
	jmp	$LN10@ComTCPOpen
$LN7@ComTCPOpen:

; 287  : 	}
; 288  : 	
; 289  : 	/* allocate a new ComHandle struct */
; 290  : 	GlobalListHead->com = (ComAPIHandle)malloc(sizeof(ComTCP));

	push	572					; 0000023cH
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _GlobalListHead
	mov	DWORD PTR [ecx+8], eax

; 291  : 	c = (ComTCP*)(GlobalListHead->com);

	mov	edx, DWORD PTR _GlobalListHead
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _c$[ebp], eax

; 292  : 	memset(c,0,sizeof(ComTCP));

	push	572					; 0000023cH
	push	0
	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 293  : 	
; 294  : 	/* InitWS2 checks that WSASstartup is done only once and increments reference count*/
; 295  : 	if (InitWS2(&c->wsaData) == 0)

	mov	edx, DWORD PTR _c$[ebp]
	add	edx, 68					; 00000044H
	push	edx
	call	_InitWS2
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN6@ComTCPOpen

; 296  : 	{
; 297  : 		GlobalListHead = CAPIListRemove(GlobalListHead,(ComAPIHandle)c);

	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	mov	ecx, DWORD PTR _GlobalListHead
	push	ecx
	call	_CAPIListRemove
	add	esp, 8
	mov	DWORD PTR _GlobalListHead, eax

; 298  : 		leave_cs();

	call	_leave_cs

; 299  : 		free(c);

	mov	edx, DWORD PTR _c$[ebp]
	push	edx
	call	_free
	add	esp, 4

; 300  : 
; 301  : 		return NULL;

	xor	eax, eax
	jmp	$LN10@ComTCPOpen
$LN6@ComTCPOpen:

; 302  : 	}
; 303  : 	
; 304  : 	leave_cs();

	call	_leave_cs

; 305  : 	
; 306  : 	/* initialize header data */
; 307  : 	c->connect_callback_func   = ConnectCallback;

	mov	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR _ConnectCallback$[ebp]
	mov	DWORD PTR [eax+560], ecx

; 308  : 	c->apiheader.protocol      = CAPI_TCP_PROTOCOL;

	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [edx+4], 5

; 309  : 	c->apiheader.send_func     = ComTCPSend;

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+8], OFFSET _ComTCPSend

; 310  : 	c->apiheader.sendX_func     = ComTCPSendX;

	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+16], OFFSET _ComTCPSendX

; 311  : 	c->apiheader.recv_func     = ComTCPGetMessage;

	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [edx+20], OFFSET _ComTCPGetMessage

; 312  : 	c->apiheader.send_buf_func = ComTCPSendBufferGet;

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+24], OFFSET _ComTCPSendBufferGet

; 313  : 	c->apiheader.recv_buf_func = ComTCPRecvBufferGet;

	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+28], OFFSET _ComTCPRecvBufferGet

; 314  : 	c->apiheader.query_func    = ComTCPQuery;

	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [edx+40], OFFSET _ComTCPQuery

; 315  : 	c->apiheader.addr_func     = ComIPHostIDGet;

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+32], OFFSET _ComIPHostIDGet

; 316  : 	c->apiheader.close_func    = ComTCPClose;

	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+36], OFFSET _ComTCPClose

; 317  : 	c->apiheader.get_timestamp_func = ComTCPGetTimeStamp;

	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [edx+44], OFFSET _ComTCPGetTimeStamp

; 318  : 	
; 319  : 	c->buffer_size             = buffersize + sizeof(tcpHeader);

	mov	eax, DWORD PTR _buffersize$[ebp]
	add	eax, 6
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+48], eax

; 320  : 	c->send_buffer.buf         = (char *)malloc(c->buffer_size);

	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [edx+48]
	push	eax
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+56], eax

; 321  : 	c->recv_buffer.buf         = (char *)malloc( c->buffer_size);

	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [edx+48]
	push	eax
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+64], eax

; 322  : 	c->recv_buffer_start       = c->recv_buffer.buf;

	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	DWORD PTR [edx+540], ecx

; 323  : 	c->timeoutsecs             = (short)timeoutsecs;

	mov	edx, DWORD PTR _c$[ebp]
	mov	ax, WORD PTR _timeoutsecs$[ebp]
	mov	WORD PTR [edx+518], ax

; 324  : 	c->handletype              = CONNECTION;

	mov	ecx, 2
	mov	edx, DWORD PTR _c$[ebp]
	mov	WORD PTR [edx+520], cx

; 325  : 	c->referencecount          = 1; 

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+528], 1

; 326  : 	
; 327  : 	/* create socket */
; 328  : 	c->recv_sock = CAPI_socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

	push	6
	push	1
	push	2
	call	DWORD PTR _CAPI_socket
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+488], eax

; 329  : 	
; 330  : 	if(c->recv_sock == INVALID_SOCKET)

	mov	edx, DWORD PTR _c$[ebp]
	cmp	DWORD PTR [edx+488], -1
	jne	SHORT $LN5@ComTCPOpen

; 331  : 	{
; 332  : 		err = CAPI_WSAGetLastError();

	call	DWORD PTR _CAPI_WSAGetLastError
	mov	DWORD PTR _err$[ebp], eax

; 333  : 		ComTCPFreeData(c);

	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	call	_ComTCPFreeData
	add	esp, 4

; 334  : 		return NULL;

	xor	eax, eax
	jmp	$LN10@ComTCPOpen
$LN5@ComTCPOpen:

; 335  : 	}
; 336  : 	
; 337  : 	/* Server Address... */
; 338  : 	memset ((char*)&c->Addr, 0, sizeof(c->Addr));

	push	16					; 00000010H
	push	0
	mov	ecx, DWORD PTR _c$[ebp]
	add	ecx, 468				; 000001d4H
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 339  : 	c->Addr.sin_family       = AF_INET;

	mov	edx, 2
	mov	eax, DWORD PTR _c$[ebp]
	mov	WORD PTR [eax+468], dx

; 340  : 	c->Addr.sin_port         = CAPI_htons((unsigned short)tcpPort);

	movzx	ecx, WORD PTR _tcpPort$[ebp]
	push	ecx
	call	DWORD PTR _CAPI_htons
	mov	edx, DWORD PTR _c$[ebp]
	mov	WORD PTR [edx+470], ax

; 341  : 	c->Addr.sin_addr.s_addr  = CAPI_htonl(IPaddress);

	mov	eax, DWORD PTR _IPaddress$[ebp]
	push	eax
	call	DWORD PTR _CAPI_htonl
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+472], eax

; 342  : 		
; 343  : 	/* create a mutex */
; 344  : 	CREATE_LOCK(c->lock,"connect socket");

	push	OFFSET ??_C@_0P@MIOCELLM@connect?5socket?$AA@
	push	0
	push	0
	call	DWORD PTR __imp__CreateMutexA@12
	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [edx+508], eax
	mov	eax, DWORD PTR _c$[ebp]
	cmp	DWORD PTR [eax+508], 0
	jne	SHORT $LN4@ComTCPOpen
	call	DWORD PTR __imp__DebugBreak@0
$LN4@ComTCPOpen:

; 345  : 	REQUEST_LOCK(c->lock);

	push	-1
	mov	ecx, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR [ecx+508]
	push	edx
	call	DWORD PTR __imp__WaitForSingleObject@8
	mov	DWORD PTR _w$1[ebp], eax
	cmp	DWORD PTR _w$1[ebp], -1
	jne	SHORT $LN3@ComTCPOpen
	call	DWORD PTR __imp__DebugBreak@0
$LN3@ComTCPOpen:

; 346  : 	c->state = COMAPI_STATE_CONNECTION_PENDING;

	xor	eax, eax
	mov	ecx, DWORD PTR _c$[ebp]
	mov	WORD PTR [ecx+522], ax

; 347  : 	RELEASE_LOCK(c->lock);

	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [edx+508]
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4
	test	eax, eax
	jne	SHORT $LN2@ComTCPOpen
	call	DWORD PTR __imp__DebugBreak@0
$LN2@ComTCPOpen:

; 348  : 		
; 349  : 	/* Create thread which attempt to make connection */
; 350  : 	c->ThreadHandle = CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)RequestConnection,(LPVOID)c,0,&ConnectThread);

	push	OFFSET _ConnectThread
	push	0
	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	push	OFFSET _RequestConnection
	push	0
	push	0
	call	DWORD PTR __imp__CreateThread@24
	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [edx+512], eax

; 351  : 
; 352  : 	if (c->ThreadHandle == NULL)

	mov	eax, DWORD PTR _c$[ebp]
	cmp	DWORD PTR [eax+512], 0
	jne	SHORT $LN1@ComTCPOpen

; 353  : 	{
; 354  : //		DWORD error = GetLastError();	   
; 355  : 		ComTCPFreeData(c);

	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	call	_ComTCPFreeData
	add	esp, 4

; 356  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN10@ComTCPOpen
$LN1@ComTCPOpen:

; 357  : 	}
; 358  : 	
; 359  : 	return (ComAPIHandle)c;

	mov	eax, DWORD PTR _c$[ebp]
$LN10@ComTCPOpen:

; 360  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_ComTCPOpenConnect ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\tcp.c
_TEXT	SEGMENT
_w$1 = -428						; size = 4
tv145 = -424						; size = 4
_listitem$ = -420					; size = 4
_listen_sock$ = -416					; size = 4
_err$ = -412						; size = 4
_c$ = -408						; size = 4
_wsaData$ = -404					; size = 400
__$ArrayPad$ = -4					; size = 4
_buffersize$ = 8					; size = 4
_gamename$ = 12						; size = 4
_tcpPort$ = 16						; size = 4
_AcceptCallback$ = 20					; size = 4
_ComTCPOpenListen PROC

; 139  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 428				; 000001acH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 140  : 	ComTCP *c;
; 141  : 	int err;
; 142  : //	int trueValue=1;
; 143  : //	int falseValue=0;
; 144  : 	SOCKET listen_sock;
; 145  : 	CAPIList  *listitem;
; 146  : 	WSADATA  wsaData;
; 147  : 
; 148  : 	gamename;
; 149  : 	
; 150  : 	/* InitWS2 checks that WSASstartup is done only once and increments reference count*/
; 151  : 	if (InitWS2(&wsaData) == 0)

	lea	eax, DWORD PTR _wsaData$[ebp]
	push	eax
	call	_InitWS2
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN10@ComTCPOpen

; 152  : 	{
; 153  : 		return NULL;

	xor	eax, eax
	jmp	$LN11@ComTCPOpen
$LN10@ComTCPOpen:

; 154  : 	}
; 155  : 	
; 156  : 	enter_cs();	

	call	_enter_cs

; 157  : 	/* Is this port already being listened to?*/
; 158  : 	listitem = CAPIListFindTCPListenPort(GlobalListHead,(short)tcpPort);

	movzx	ecx, WORD PTR _tcpPort$[ebp]
	push	ecx
	mov	edx, DWORD PTR _GlobalListHead
	push	edx
	call	_CAPIListFindTCPListenPort
	add	esp, 8
	mov	DWORD PTR _listitem$[ebp], eax

; 159  : 	if (listitem)

	cmp	DWORD PTR _listitem$[ebp], 0
	je	$LN9@ComTCPOpen

; 160  : 	{
; 161  : 		c = (ComTCP *)listitem->com;

	mov	eax, DWORD PTR _listitem$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _c$[ebp], ecx

; 162  : 		REQUEST_LOCK(c->lock);

	push	-1
	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [edx+508]
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
	mov	DWORD PTR _w$1[ebp], eax
	cmp	DWORD PTR _w$1[ebp], -1
	jne	SHORT $LN8@ComTCPOpen
	call	DWORD PTR __imp__DebugBreak@0
$LN8@ComTCPOpen:

; 163  : 		c->referencecount++;

	mov	ecx, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR [ecx+528]
	add	edx, 1
	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+528], edx

; 164  : 		RELEASE_LOCK(c->lock);

	mov	ecx, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR [ecx+508]
	push	edx
	call	DWORD PTR __imp__ReleaseMutex@4
	test	eax, eax
	jne	SHORT $LN7@ComTCPOpen
	call	DWORD PTR __imp__DebugBreak@0
$LN7@ComTCPOpen:

; 165  : 
; 166  : 		leave_cs();

	call	_leave_cs

; 167  : 		return (ComAPIHandle)c;

	mov	eax, DWORD PTR _c$[ebp]
	jmp	$LN11@ComTCPOpen
$LN9@ComTCPOpen:

; 168  : 	}
; 169  : 	
; 170  : 	/* CREATE NEW LISTENER */
; 171  : 	/* add new socket connection to list */
; 172  : 	/* although this is only a listener socket */
; 173  : 	GlobalListHead = CAPIListAppend(GlobalListHead);

	mov	eax, DWORD PTR _GlobalListHead
	push	eax
	call	_CAPIListAppend
	add	esp, 4
	mov	DWORD PTR _GlobalListHead, eax

; 174  : 	if(!GlobalListHead)

	cmp	DWORD PTR _GlobalListHead, 0
	jne	SHORT $LN6@ComTCPOpen

; 175  : 	{
; 176  : 	    leave_cs();

	call	_leave_cs

; 177  : 		return NULL;

	xor	eax, eax
	jmp	$LN11@ComTCPOpen
$LN6@ComTCPOpen:

; 178  : 	}
; 179  : 	
; 180  : 	/* allocate a new ComHandle struct */
; 181  : 	GlobalListHead->com = (ComAPIHandle)malloc(sizeof(ComTCP));

	push	572					; 0000023cH
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _GlobalListHead
	mov	DWORD PTR [ecx+8], eax

; 182  : 	c =(ComTCP*) (GlobalListHead->com);

	mov	edx, DWORD PTR _GlobalListHead
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _c$[ebp], eax

; 183  : 	//GlobalListHead->ListenPort = tcpPort;
; 184  : 	memset(c,0,sizeof(ComTCP));

	push	572					; 0000023cH
	push	0
	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 185  : 	
; 186  : 	/* initialize header data */
; 187  : 	c->accept_callback_func         = AcceptCallback;

	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR _AcceptCallback$[ebp]
	mov	DWORD PTR [edx+564], eax

; 188  : 	c->apiheader.protocol           = CAPI_TCP_PROTOCOL;

	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+4], 5

; 189  : 	c->apiheader.send_func          = ComTCPSend;

	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [edx+8], OFFSET _ComTCPSend

; 190  : 	c->apiheader.sendX_func         = ComTCPSendX;

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+16], OFFSET _ComTCPSendX

; 191  : 	c->apiheader.recv_func          = ComTCPGetMessage;

	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+20], OFFSET _ComTCPGetMessage

; 192  : 	c->apiheader.send_buf_func      = ComTCPSendBufferGet;

	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [edx+24], OFFSET _ComTCPSendBufferGet

; 193  : 	c->apiheader.recv_buf_func      = ComTCPRecvBufferGet;

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+28], OFFSET _ComTCPRecvBufferGet

; 194  : 	c->apiheader.addr_func          = ComIPHostIDGet;

	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+32], OFFSET _ComIPHostIDGet

; 195  : 	c->apiheader.close_func         = ComTCPClose;

	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [edx+36], OFFSET _ComTCPClose

; 196  : 	c->apiheader.query_func         = ComTCPQuery;

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+40], OFFSET _ComTCPQuery

; 197  : 	c->apiheader.get_timestamp_func = ComTCPGetTimeStamp;

	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+44], OFFSET _ComTCPGetTimeStamp

; 198  : 	c->handletype                   = LISTENER;

	xor	edx, edx
	mov	eax, DWORD PTR _c$[ebp]
	mov	WORD PTR [eax+520], dx

; 199  : 	c->referencecount               = 1;  

	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+528], 1

; 200  : 	c->buffer_size                  = sizeof(tcpHeader) + buffersize;

	mov	edx, DWORD PTR _buffersize$[ebp]
	add	edx, 6
	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+48], edx

; 201  : 	c->ListenPort                   = (short)tcpPort;

	mov	ecx, DWORD PTR _c$[ebp]
	mov	dx, WORD PTR _tcpPort$[ebp]
	mov	WORD PTR [ecx+524], dx

; 202  : 	c->state                        = COMAPI_STATE_CONNECTED;

	mov	eax, 1
	mov	ecx, DWORD PTR _c$[ebp]
	mov	WORD PTR [ecx+522], ax

; 203  : 	
; 204  : 	/* create socket */
; 205  : 	listen_sock = c->recv_sock = CAPI_socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

	push	6
	push	1
	push	2
	call	DWORD PTR _CAPI_socket
	mov	DWORD PTR tv145[ebp], eax
	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR tv145[ebp]
	mov	DWORD PTR [edx+488], eax
	mov	ecx, DWORD PTR tv145[ebp]
	mov	DWORD PTR _listen_sock$[ebp], ecx

; 206  : 	
; 207  : 	if(listen_sock == INVALID_SOCKET)

	cmp	DWORD PTR _listen_sock$[ebp], -1
	jne	SHORT $LN5@ComTCPOpen

; 208  : 	{
; 209  : 		ComAPILastError = err = CAPI_WSAGetLastError();

	call	DWORD PTR _CAPI_WSAGetLastError
	mov	DWORD PTR _err$[ebp], eax
	mov	edx, DWORD PTR _err$[ebp]
	mov	DWORD PTR _ComAPILastError, edx
$LN5@ComTCPOpen:

; 210  : 	}
; 211  : 	
; 212  : 	/* Set Server Address... */
; 213  : 	memset ((char*)&c->Addr, 0, sizeof(c->Addr));

	push	16					; 00000010H
	push	0
	mov	eax, DWORD PTR _c$[ebp]
	add	eax, 468				; 000001d4H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 214  : 	
; 215  : 	c->Addr.sin_family       = AF_INET;

	mov	ecx, 2
	mov	edx, DWORD PTR _c$[ebp]
	mov	WORD PTR [edx+468], cx

; 216  : 	c->Addr.sin_addr.s_addr  = CAPI_htonl(INADDR_ANY);

	push	0
	call	DWORD PTR _CAPI_htonl
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+472], eax

; 217  : 	c->Addr.sin_port         = CAPI_htons((unsigned short)tcpPort);

	movzx	edx, WORD PTR _tcpPort$[ebp]
	push	edx
	call	DWORD PTR _CAPI_htons
	mov	ecx, DWORD PTR _c$[ebp]
	mov	WORD PTR [ecx+470], ax

; 218  : 	
; 219  : 	/* Bind to local address -- don't really need this but Hey ... */
; 220  : 	if(err=CAPI_bind(listen_sock, (struct sockaddr*)&c->Addr,sizeof(c->Addr)))

	push	16					; 00000010H
	mov	edx, DWORD PTR _c$[ebp]
	add	edx, 468				; 000001d4H
	push	edx
	mov	eax, DWORD PTR _listen_sock$[ebp]
	push	eax
	call	DWORD PTR _CAPI_bind
	mov	DWORD PTR _err$[ebp], eax
	cmp	DWORD PTR _err$[ebp], 0
	je	SHORT $LN4@ComTCPOpen

; 221  : 	{
; 222  : //		int error = CAPI_WSAGetLastError();
; 223  : 	    leave_cs();

	call	_leave_cs

; 224  : 		return NULL;

	xor	eax, eax
	jmp	$LN11@ComTCPOpen
$LN4@ComTCPOpen:

; 225  : 	}
; 226  : 	
; 227  : 	/* now listen on this socket */
; 228  : 	if(err=CAPI_listen(listen_sock, MAXBACKLOG))

	push	5
	mov	ecx, DWORD PTR _listen_sock$[ebp]
	push	ecx
	call	DWORD PTR _CAPI_listen
	mov	DWORD PTR _err$[ebp], eax
	cmp	DWORD PTR _err$[ebp], 0
	je	SHORT $LN3@ComTCPOpen

; 229  : 	{
; 230  : //		int error = CAPI_WSAGetLastError();
; 231  : 	    leave_cs();

	call	_leave_cs

; 232  : 		return 0;

	xor	eax, eax
	jmp	$LN11@ComTCPOpen
$LN3@ComTCPOpen:

; 233  : 	}
; 234  : 	
; 235  : 	/* Create a mutex for this connection */
; 236  : 	CREATE_LOCK(c->lock,"Listen socket");

	push	OFFSET ??_C@_0O@JIIAAKOM@Listen?5socket?$AA@
	push	0
	push	0
	call	DWORD PTR __imp__CreateMutexA@12
	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [edx+508], eax
	mov	eax, DWORD PTR _c$[ebp]
	cmp	DWORD PTR [eax+508], 0
	jne	SHORT $LN2@ComTCPOpen
	call	DWORD PTR __imp__DebugBreak@0
$LN2@ComTCPOpen:

; 237  : 	
; 238  : 	/* Mark this thread ACCEPT() active in the data struct */
; 239  : 	c->ThreadActive = THREAD_ACTIVE;

	mov	ecx, 1
	mov	edx, DWORD PTR _c$[ebp]
	mov	WORD PTR [edx+516], cx

; 240  : 	
; 241  : 	/* Start the thread which waits for socket connectiosn with accept() */	
; 242  : 	c->ThreadHandle = CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)AcceptConnection,(LPVOID)c,0,&AcceptThread);

	push	OFFSET _AcceptThread
	push	0
	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	push	OFFSET _AcceptConnection
	push	0
	push	0
	call	DWORD PTR __imp__CreateThread@24
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+512], eax

; 243  : 	if (c->ThreadHandle == NULL)
; 244  : 	{
; 245  : //		DWORD error = GetLastError();	   
; 246  : 	}
; 247  : 	
; 248  : 	SetThreadPriority(c->ThreadHandle,THREAD_PRIORITY_IDLE);

	push	-15					; fffffff1H
	mov	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR [eax+512]
	push	ecx
	call	DWORD PTR __imp__SetThreadPriority@8

; 249  : 	leave_cs();

	call	_leave_cs

; 250  : 	return (ComAPIHandle)c;

	mov	eax, DWORD PTR _c$[ebp]
$LN11@ComTCPOpen:

; 251  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_ComTCPOpenListen ENDP
_TEXT	ENDS
END
