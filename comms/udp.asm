; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\comms\udp.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_ComIPGetHostIDIndex
PUBLIC	_force_ip_address
_BSS	SEGMENT
_ComIPGetHostIDIndex DD 01H DUP (?)
_force_ip_address DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
?internalId@?1??ComIPHostIDGet@@9@9 DD 0ffffffffH	; `ComIPHostIDGet'::`2'::internalId
_DATA	ENDS
PUBLIC	_ComAPISetReceiveThreadPriority
PUBLIC	_ComUDPOpen
PUBLIC	_ComUDPClose
PUBLIC	_ComUDPSend
PUBLIC	_ComUDPSendDummy
PUBLIC	_ComUDPSendX
PUBLIC	_ComUDPGet
PUBLIC	_ComIPHostIDGet
PUBLIC	_ComIPSendBufferGet
PUBLIC	_ComIPRecvBufferGet
PUBLIC	_ComUDPQuery
PUBLIC	_ComUDPGetTimeStamp
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_strcpy:PROC
EXTRN	_strlen:PROC
EXTRN	_strncmp:PROC
EXTRN	_strncpy:PROC
EXTRN	_strdup:PROC
EXTRN	__imp__SetThreadPriority@8:PROC
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	__imp__FreeLibrary@4:PROC
EXTRN	_clock:PROC
EXTRN	_InitWS2:PROC
EXTRN	_comListAdd:PROC
EXTRN	_comListRemove:PROC
EXTRN	_comListFindProtocolRport:PROC
EXTRN	_use_bandwidth:PROC
EXTRN	_check_bandwidth:PROC
EXTRN	_cut_bandwidth:PROC
EXTRN	_F4IsBadReadPtrC:PROC
EXTRN	_comms_compress:PROC
EXTRN	_comms_decompress:PROC
EXTRN	_enter_cs:PROC
EXTRN	_leave_cs:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_WS2Connections:DWORD
EXTRN	_hWinSockDLL:DWORD
EXTRN	_CAPI_bind:DWORD
EXTRN	_CAPI_closesocket:DWORD
EXTRN	_CAPI_ioctlsocket:DWORD
EXTRN	_CAPI_htonl:DWORD
EXTRN	_CAPI_htons:DWORD
EXTRN	_CAPI_ntohl:DWORD
EXTRN	_CAPI_ntohs:DWORD
EXTRN	_CAPI_recvfrom:DWORD
EXTRN	_CAPI_sendto:DWORD
EXTRN	_CAPI_setsockopt:DWORD
EXTRN	_CAPI_socket:DWORD
EXTRN	_CAPI_WSACleanup:DWORD
EXTRN	_CAPI_WSAGetLastError:DWORD
EXTRN	_CAPI_TimeStamp:DWORD
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
_comRecvAddr DB	010H DUP (?)
_BSS	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\udp.c
_TEXT	SEGMENT
_curr$ = -12						; size = 4
tv93 = -8						; size = 4
_c$ = -4						; size = 4
_name_in$ = 8						; size = 4
_parentCom$ = 12					; size = 4
_buffersize$ = 16					; size = 4
_gamename$ = 20						; size = 4
_udpPort$ = 24						; size = 4
_IPaddress$ = 28					; size = 4
_id$ = 32						; size = 4
_ComUDPOpenSendClone PROC

; 267  : ){

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 268  : 	ComIP *c;
; 269  : 	CAPIList *curr = 0;

	mov	DWORD PTR _curr$[ebp], 0

; 270  : 
; 271  : 
; 272  : 	/* add new socket connection to list */
; 273  : 
; 274  : 	c = (ComIP*)malloc(sizeof(ComIP));

	push	716					; 000002ccH
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _c$[ebp], eax

; 275  : 	memset(c,0,sizeof(ComIP));

	push	716					; 000002ccH
	push	0
	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 276  : 
; 277  : 	memcpy(c,parentCom,sizeof(ComIP));

	push	716					; 000002ccH
	mov	ecx, DWORD PTR _parentCom$[ebp]
	push	ecx
	mov	edx, DWORD PTR _c$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 278  : 
; 279  : 	((ComAPIHandle)c)->name = (char*)malloc (strlen (name_in) + 1);

	mov	eax, DWORD PTR _name_in$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 1
	push	eax
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx], eax

; 280  : 	strcpy (((ComAPIHandle)c)->name, name_in);

	mov	edx, DWORD PTR _name_in$[ebp]
	push	edx
	mov	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_strcpy
	add	esp, 8

; 281  : 
; 282  : 	/* initialize header data */
; 283  : 
; 284  : 	c->parent = parentCom;

	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR _parentCom$[ebp]
	mov	DWORD PTR [edx+564], eax

; 285  : 	parentCom->referencecount++;

	mov	ecx, DWORD PTR _parentCom$[ebp]
	mov	edx, DWORD PTR [ecx+568]
	add	edx, 1
	mov	eax, DWORD PTR _parentCom$[ebp]
	mov	DWORD PTR [eax+568], edx

; 286  : 	c->referencecount = 1;

	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+568], 1

; 287  : 
; 288  : 
; 289  : 	c->buffer_size =   max(parentCom->buffer_size, (int)(sizeof(ComAPIHeader) + buffersize));

	mov	edx, DWORD PTR _buffersize$[ebp]
	add	edx, 8
	mov	eax, DWORD PTR _parentCom$[ebp]
	cmp	DWORD PTR [eax+48], edx
	jle	SHORT $LN9@ComUDPOpen
	mov	ecx, DWORD PTR _parentCom$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR tv93[ebp], edx
	jmp	SHORT $LN10@ComUDPOpen
$LN9@ComUDPOpen:
	mov	eax, DWORD PTR _buffersize$[ebp]
	add	eax, 8
	mov	DWORD PTR tv93[ebp], eax
$LN10@ComUDPOpen:
	mov	ecx, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR tv93[ebp]
	mov	DWORD PTR [ecx+48], edx

; 290  : 
; 291  : 	if ((c->max_buffer_size > 0) && (c->buffer_size  > c->max_buffer_size)){

	mov	eax, DWORD PTR _c$[ebp]
	cmp	DWORD PTR [eax+52], 0
	jle	SHORT $LN6@ComUDPOpen
	mov	ecx, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [ecx+48]
	cmp	eax, DWORD PTR [edx+52]
	jle	SHORT $LN6@ComUDPOpen

; 292  : 		c->buffer_size = c->max_buffer_size;

	mov	ecx, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [edx+52]
	mov	DWORD PTR [ecx+48], eax
$LN6@ComUDPOpen:

; 293  : 	}
; 294  : 
; 295  : 	c->send_buffer.buf = (char *)malloc(c->buffer_size);

	mov	ecx, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+64], eax

; 296  : 
; 297  : 	if (IPaddress == -1){

	cmp	DWORD PTR _IPaddress$[ebp], -1
	jne	SHORT $LN5@ComUDPOpen

; 298  : 		ComIPHostIDGet(&c->apiheader, (char*)&IPaddress, 0);

	push	0
	lea	edx, DWORD PTR _IPaddress$[ebp]
	push	edx
	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	call	_ComIPHostIDGet
	add	esp, 12					; 0000000cH

; 299  : 		IPaddress = CAPI_htonl (IPaddress);

	mov	ecx, DWORD PTR _IPaddress$[ebp]
	push	ecx
	call	DWORD PTR _CAPI_htonl
	mov	DWORD PTR _IPaddress$[ebp], eax
$LN5@ComUDPOpen:

; 300  : 	}
; 301  : 
; 302  : 	// header 
; 303  : 	strncpy(((ComAPIHeader *)c->send_buffer.buf)->gamename, gamename, GAME_NAME_LENGTH);

	push	4
	mov	edx, DWORD PTR _gamename$[ebp]
	push	edx
	mov	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	call	_strncpy
	add	esp, 12					; 0000000cH

; 304  : 	// sfr: id in network order
; 305  : 	((ComAPIHeader *)c->send_buffer.buf)->id = c->whoami;

	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [edx+64]
	mov	ecx, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR [ecx+580]
	mov	DWORD PTR [eax+4], edx

; 306  : 
; 307  : 	/* Outgoing... */
; 308  : 	memset ((char*)&c->sendAddress, 0, sizeof(c->sendAddress));

	push	16					; 00000010H
	push	0
	mov	eax, DWORD PTR _c$[ebp]
	add	eax, 480				; 000001e0H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 309  : 	c->sendAddress.sin_family       = AF_INET;

	mov	ecx, 2
	mov	edx, DWORD PTR _c$[ebp]
	mov	WORD PTR [edx+480], cx

; 310  : 
; 311  : 	if(IPaddress == 0){

	cmp	DWORD PTR _IPaddress$[ebp], 0
	jne	SHORT $LN4@ComUDPOpen

; 312  : 		c->sendAddress.sin_addr.s_addr  = CAPI_htonl(INADDR_BROADCAST);

	push	-1
	call	DWORD PTR _CAPI_htonl
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+484], eax

; 313  : 	}
; 314  : 	else{

	jmp	SHORT $LN3@ComUDPOpen
$LN4@ComUDPOpen:

; 315  : 		c->sendAddress.sin_addr.s_addr  = CAPI_htonl(IPaddress);

	mov	edx, DWORD PTR _IPaddress$[ebp]
	push	edx
	call	DWORD PTR _CAPI_htonl
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+484], eax
$LN3@ComUDPOpen:

; 316  : 	}
; 317  : 
; 318  : 	c->sendAddress.sin_port         = CAPI_htons((unsigned short)udpPort);

	movzx	edx, WORD PTR _udpPort$[ebp]
	push	edx
	call	DWORD PTR _CAPI_htons
	mov	ecx, DWORD PTR _c$[ebp]
	mov	WORD PTR [ecx+482], ax

; 319  : 
; 320  : 
; 321  : 	if(IPaddress == 0){

	cmp	DWORD PTR _IPaddress$[ebp], 0
	jne	SHORT $LN2@ComUDPOpen

; 322  : 		c->NeedBroadcastMode = 1;

	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [edx+576], 1

; 323  : 	}
; 324  : 	else {

	jmp	SHORT $LN1@ComUDPOpen
$LN2@ComUDPOpen:

; 325  : 		c->NeedBroadcastMode = 0;

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+576], 0
$LN1@ComUDPOpen:

; 326  : 	}
; 327  : 	//sfr id (network order)
; 328  : 	c->id = CAPI_htonl(id);

	mov	ecx, DWORD PTR _id$[ebp]
	push	ecx
	call	DWORD PTR _CAPI_htonl
	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [edx+584], eax

; 329  : 
; 330  : 	comListAdd(c);

	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	call	_comListAdd
	add	esp, 4

; 331  : 	return (ComAPIHandle)c;

	mov	eax, DWORD PTR _c$[ebp]

; 332  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ComUDPOpenSendClone ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\udp.c
_TEXT	SEGMENT
_cudp$1 = -4						; size = 4
_c$ = 8							; size = 4
_ComUDPGetTimeStamp PROC

; 1034 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1035 : 	if(c){

	cmp	DWORD PTR _c$[ebp], 0
	je	SHORT $LN2@ComUDPGetT

; 1036 : 		ComIP *cudp= (ComIP *)c;

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _cudp$1[ebp], eax

; 1037 : 		return cudp->timestamp;

	mov	ecx, DWORD PTR _cudp$1[ebp]
	mov	eax, DWORD PTR [ecx+600]
	jmp	SHORT $LN3@ComUDPGetT

; 1038 : 	}
; 1039 : 	else {

	jmp	SHORT $LN3@ComUDPGetT
$LN2@ComUDPGetT:

; 1040 : 		return 0;

	xor	eax, eax
$LN3@ComUDPGetT:

; 1041 : 	}
; 1042 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ComUDPGetTimeStamp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\udp.c
_TEXT	SEGMENT
tv68 = -12						; size = 4
tv69 = -8						; size = 4
_cudp$1 = -4						; size = 4
_c$ = 8							; size = 4
_querytype$ = 12					; size = 4
_ComUDPQuery PROC

; 917  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 918  : 	if(c)

	cmp	DWORD PTR _c$[ebp], 0
	je	$LN22@ComUDPQuer

; 919  : 	{
; 920  : 		ComIP * cudp;
; 921  : 
; 922  : 		cudp = GETActiveCOMHandle(c);  

	mov	eax, DWORD PTR _c$[ebp]
	cmp	DWORD PTR [eax+564], 0
	jne	SHORT $LN25@ComUDPQuer
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR tv68[ebp], ecx
	jmp	SHORT $LN26@ComUDPQuer
$LN25@ComUDPQuer:
	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [edx+564]
	mov	DWORD PTR tv68[ebp], eax
$LN26@ComUDPQuer:
	mov	ecx, DWORD PTR tv68[ebp]
	mov	DWORD PTR _cudp$1[ebp], ecx

; 923  : 
; 924  : 		switch(querytype)

	mov	edx, DWORD PTR _querytype$[ebp]
	mov	DWORD PTR tv69[ebp], edx
	mov	eax, DWORD PTR tv69[ebp]
	sub	eax, 1
	mov	DWORD PTR tv69[ebp], eax
	cmp	DWORD PTR tv69[ebp], 25			; 00000019H
	ja	$LN1@ComUDPQuer
	mov	ecx, DWORD PTR tv69[ebp]
	jmp	DWORD PTR $LN27@ComUDPQuer[ecx*4]
$LN19@ComUDPQuer:

; 925  : 		{
; 926  : 			case COMAPI_MESSAGECOUNT:
; 927  : 				{
; 928  : 					return cudp->sendmessagecount + ((ComIP *)c)->recvmessagecount;

	mov	edx, DWORD PTR _cudp$1[ebp]
	mov	eax, DWORD PTR [edx+524]
	mov	ecx, DWORD PTR _c$[ebp]
	add	eax, DWORD PTR [ecx+520]
	jmp	$LN23@ComUDPQuer
$LN18@ComUDPQuer:

; 929  : 				}
; 930  : 
; 931  : 			case COMAPI_RECV_MESSAGECOUNT:
; 932  : 				{
; 933  : 					return ((ComIP *)c)->recvmessagecount;

	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [edx+520]
	jmp	$LN23@ComUDPQuer
$LN17@ComUDPQuer:

; 934  : 				}
; 935  : 
; 936  : 			case COMAPI_SEND_MESSAGECOUNT:
; 937  : 				{
; 938  : 					return cudp->sendmessagecount;

	mov	eax, DWORD PTR _cudp$1[ebp]
	mov	eax, DWORD PTR [eax+524]
	jmp	$LN23@ComUDPQuer
$LN16@ComUDPQuer:

; 939  : 				}
; 940  : 
; 941  : 			case COMAPI_RECV_WOULDBLOCKCOUNT:
; 942  : 				{
; 943  : 					return ((ComIP *)c)->recvwouldblockcount;

	mov	ecx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [ecx+528]
	jmp	$LN23@ComUDPQuer
$LN15@ComUDPQuer:

; 944  : 				}
; 945  : 
; 946  : 			case COMAPI_SEND_WOULDBLOCKCOUNT:
; 947  : 				{
; 948  : 					return cudp->sendwouldblockcount;

	mov	edx, DWORD PTR _cudp$1[ebp]
	mov	eax, DWORD PTR [edx+532]
	jmp	$LN23@ComUDPQuer
$LN14@ComUDPQuer:

; 949  : 				}
; 950  : 
; 951  : 			case COMAPI_RECEIVE_SOCKET:
; 952  : 				{
; 953  : 					return ((ComIP *)c)->recv_sock;

	mov	eax, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [eax+516]
	jmp	$LN23@ComUDPQuer
$LN13@ComUDPQuer:

; 954  : 				}
; 955  : 
; 956  : 			case COMAPI_SEND_SOCKET:
; 957  : 				{
; 958  : 					return ((ComIP *)c)->send_sock;

	mov	ecx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [ecx+512]
	jmp	SHORT $LN23@ComUDPQuer
$LN12@ComUDPQuer:

; 959  : 				}
; 960  : 
; 961  : 			case COMAPI_RELIABLE:
; 962  : 				{
; 963  : 					return 0;

	xor	eax, eax
	jmp	SHORT $LN23@ComUDPQuer
$LN11@ComUDPQuer:

; 964  : 				}
; 965  : 
; 966  : 			case COMAPI_UDP_CACHE_SIZE:
; 967  : 				{
; 968  : 					return 0;

	xor	eax, eax
	jmp	SHORT $LN23@ComUDPQuer
$LN10@ComUDPQuer:

; 969  : 				}
; 970  : 
; 971  : 			case COMAPI_SENDER:
; 972  : 				{
; 973  : 					return CAPI_ntohl(cudp->lastsender);

	mov	edx, DWORD PTR _cudp$1[ebp]
	mov	eax, DWORD PTR [edx+588]
	push	eax
	call	DWORD PTR _CAPI_ntohl
	jmp	SHORT $LN23@ComUDPQuer
$LN9@ComUDPQuer:

; 974  : 				}
; 975  : 			// sfr: converts
; 976  : 			// port info
; 977  : 			case COMAPI_SENDER_PORT:
; 978  : 				{
; 979  : 					return (long)(CAPI_ntohs((short)cudp->lastsenderport));

	mov	ecx, DWORD PTR _cudp$1[ebp]
	movzx	edx, WORD PTR [ecx+592]
	push	edx
	call	DWORD PTR _CAPI_ntohs
	movzx	eax, ax
	jmp	SHORT $LN23@ComUDPQuer
$LN8@ComUDPQuer:

; 980  : 				}
; 981  : 			//sfr: id
; 982  : 			case COMAPI_ID:
; 983  : 				{
; 984  : 					return (CAPI_ntohl(cudp->lastsenderid));

	mov	eax, DWORD PTR _cudp$1[ebp]
	mov	ecx, DWORD PTR [eax+596]
	push	ecx
	call	DWORD PTR _CAPI_ntohl
	jmp	SHORT $LN23@ComUDPQuer
$LN7@ComUDPQuer:

; 985  : 				}
; 986  : 
; 987  : 
; 988  : 			case COMAPI_CONNECTION_ADDRESS:
; 989  : 				{
; 990  : 					return CAPI_ntohl(((ComIP *)c)->sendAddress.sin_addr.s_addr);

	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [edx+484]
	push	eax
	call	DWORD PTR _CAPI_ntohl
	jmp	SHORT $LN23@ComUDPQuer
$LN6@ComUDPQuer:

; 991  : 				}
; 992  : 
; 993  : 			case COMAPI_MAX_BUFFER_SIZE:
; 994  : 				{
; 995  : 					return 0;

	xor	eax, eax
	jmp	SHORT $LN23@ComUDPQuer
$LN5@ComUDPQuer:

; 996  : 				}
; 997  : 
; 998  : 			case COMAPI_ACTUAL_BUFFER_SIZE:
; 999  : 				{
; 1000 : 					return ((ComIP *)c)->buffer_size - sizeof(ComAPIHeader);

	mov	ecx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [ecx+48]
	sub	eax, 8
	jmp	SHORT $LN23@ComUDPQuer
$LN4@ComUDPQuer:

; 1001 : 				}
; 1002 : 
; 1003 : 
; 1004 : 			case COMAPI_PROTOCOL:
; 1005 : 				{
; 1006 : 					return  c->protocol;

	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [edx+4]
	jmp	SHORT $LN23@ComUDPQuer
$LN3@ComUDPQuer:

; 1007 : 				}
; 1008 : 
; 1009 : 			case COMAPI_STATE:
; 1010 : 				{
; 1011 : 					return  COMAPI_STATE_CONNECTED;

	mov	eax, 1
	jmp	SHORT $LN23@ComUDPQuer
$LN2@ComUDPQuer:

; 1012 : 				}
; 1013 : 
; 1014 : 			case COMAPI_UDP_HEADER_OVERHEAD:
; 1015 : 				{
; 1016 : 					return sizeof(ComAPIHeader);

	mov	eax, 8
	jmp	SHORT $LN23@ComUDPQuer
$LN1@ComUDPQuer:

; 1017 : 				}
; 1018 : 
; 1019 : 			default:
; 1020 : 				{
; 1021 : 					return 0;

	xor	eax, eax
	jmp	SHORT $LN23@ComUDPQuer
$LN22@ComUDPQuer:

; 1022 : 				}
; 1023 : 		}
; 1024 : 	}
; 1025 : 
; 1026 : 	return 0;

	xor	eax, eax
$LN23@ComUDPQuer:

; 1027 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN27@ComUDPQuer:
	DD	$LN19@ComUDPQuer
	DD	$LN16@ComUDPQuer
	DD	$LN15@ComUDPQuer
	DD	$LN7@ComUDPQuer
	DD	$LN14@ComUDPQuer
	DD	$LN13@ComUDPQuer
	DD	$LN12@ComUDPQuer
	DD	$LN18@ComUDPQuer
	DD	$LN17@ComUDPQuer
	DD	$LN11@ComUDPQuer
	DD	$LN1@ComUDPQuer
	DD	$LN1@ComUDPQuer
	DD	$LN6@ComUDPQuer
	DD	$LN5@ComUDPQuer
	DD	$LN4@ComUDPQuer
	DD	$LN3@ComUDPQuer
	DD	$LN1@ComUDPQuer
	DD	$LN1@ComUDPQuer
	DD	$LN10@ComUDPQuer
	DD	$LN1@ComUDPQuer
	DD	$LN2@ComUDPQuer
	DD	$LN1@ComUDPQuer
	DD	$LN1@ComUDPQuer
	DD	$LN1@ComUDPQuer
	DD	$LN9@ComUDPQuer
	DD	$LN8@ComUDPQuer
_ComUDPQuery ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\udp.c
_TEXT	SEGMENT
_cudp$ = -8						; size = 4
tv67 = -4						; size = 4
_c$ = 8							; size = 4
_ComIPRecvBufferGet PROC

; 904  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 905  : 	ComIP *cudp = (ComIP *)c;

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _cudp$[ebp], eax

; 906  : 	//	char *recvbuf=NULL;
; 907  : 
; 908  : 	cudp = GETActiveCOMHandle(c) ;

	mov	ecx, DWORD PTR _c$[ebp]
	cmp	DWORD PTR [ecx+564], 0
	jne	SHORT $LN3@ComIPRecvB
	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR tv67[ebp], edx
	jmp	SHORT $LN4@ComIPRecvB
$LN3@ComIPRecvB:
	mov	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR [eax+564]
	mov	DWORD PTR tv67[ebp], ecx
$LN4@ComIPRecvB:
	mov	edx, DWORD PTR tv67[ebp]
	mov	DWORD PTR _cudp$[ebp], edx

; 909  : 	return cudp->recv_buffer.buf + sizeof(ComAPIHeader);

	mov	eax, DWORD PTR _cudp$[ebp]
	mov	eax, DWORD PTR [eax+72]
	add	eax, 8

; 910  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ComIPRecvBufferGet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\udp.c
_TEXT	SEGMENT
_c$ = 8							; size = 4
_ComIPSendBufferGet PROC

; 895  : {

	push	ebp
	mov	ebp, esp

; 896  : 	return ((ComIP *)c)->send_buffer.buf + sizeof(ComAPIHeader);

	mov	eax, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [eax+64]
	add	eax, 8

; 897  : }

	pop	ebp
	ret	0
_ComIPSendBufferGet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\udp.c
_TEXT	SEGMENT
_c$ = 8							; size = 4
_buf$ = 12						; size = 4
_reset$ = 16						; size = 4
_ComIPHostIDGet PROC

; 813  : int ComIPHostIDGet(ComAPIHandle c, char *buf, int reset) {

	push	ebp
	mov	ebp, esp

; 814  : 	static long internalId = -1;
; 815  : 
; 816  : 	// reset the ID, choose a new one
; 817  : 	if (reset){

	cmp	DWORD PTR _reset$[ebp], 0
	je	SHORT $LN3@ComIPHostI

; 818  : 		internalId = -1;

	mov	DWORD PTR ?internalId@?1??ComIPHostIDGet@@9@9, -1
$LN3@ComIPHostI:

; 819  : 	}
; 820  : 
; 821  : 	// -1 is never a valid ID
; 822  : 	while (internalId == -1){

	cmp	DWORD PTR ?internalId@?1??ComIPHostIDGet@@9@9, -1
	jne	SHORT $LN2@ComIPHostI

; 823  : 		internalId = ((long)(clock()));

	call	_clock
	mov	DWORD PTR ?internalId@?1??ComIPHostIDGet@@9@9, eax

; 824  : 	}

	jmp	SHORT $LN3@ComIPHostI
$LN2@ComIPHostI:

; 825  : 
; 826  : 	if (force_ip_address){

	cmp	DWORD PTR _force_ip_address, 0
	je	SHORT $LN1@ComIPHostI

; 827  : 		internalId = ((long)force_ip_address);

	mov	eax, DWORD PTR _force_ip_address
	mov	DWORD PTR ?internalId@?1??ComIPHostIDGet@@9@9, eax
$LN1@ComIPHostI:

; 828  : 	}
; 829  : 
; 830  : 	// writes Id to buffer, host order
; 831  : 	memcpy(buf, &internalId, sizeof(long));

	push	4
	push	OFFSET ?internalId@?1??ComIPHostIDGet@@9@9
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 832  : 
; 833  : 	return 0;

	xor	eax, eax

; 834  : 
; 835  : #if 0
; 836  : 	// our hostname
; 837  : 	char name[1024];
; 838  : 	// our hostent struct, with our IP
; 839  : 	struct hostent *hentry;
; 840  : 	int i;
; 841  : 
; 842  : 	// we need a valid handle
; 843  : 	if(c == NULL)	{
; 844  : 		return COMAPI_HOSTID_ERROR;
; 845  : 	}
; 846  : 
; 847  : 
; 848  : 	// get our hostname
; 849  : 	if(CAPI_gethostname(name,1024) == SOCKET_ERROR)	{
; 850  : 		return COMAPI_HOSTID_ERROR;
; 851  : 	}
; 852  : 
; 853  : 	// from hostname, get IP
; 854  : 	if ((hentry = CAPI_gethostbyname(name)) == NULL){
; 855  : 		return COMAPI_HOSTID_ERROR;
; 856  : 	}
; 857  : 
; 858  : 
; 859  : 	if (force_ip_address)	{
; 860  : 		buf[3] = (char)(force_ip_address & 0xff);
; 861  : 		buf[2] = (char)((force_ip_address >> 8)  & 0xff);
; 862  : 		buf[1] = (char)((force_ip_address >> 16) & 0xff);
; 863  : 		buf[0] = (char)((force_ip_address >> 24) & 0xff);
; 864  : 		return 0;
; 865  : 	}
; 866  : 
; 867  : 	// sfr: build IP from hentry struct. 
; 868  : 	// shouldnt we use inet_ntoa?
; 869  : 	// wow this is dark magic... dont wanna get in here
; 870  : 	// hentry->h_addr_list[i] is an array of char
; 871  : 	// run all available IPs for host
; 872  : 	for (i=0;hentry->h_addr_list[i] != NULL; i++) {
; 873  : 		// we return either first IP or hostIdx IP
; 874  : 		// first IP
; 875  : 		if (i == 0) {
; 876  : 			*((int*)buf) = *((int*)(hentry->h_addr_list[i]));
; 877  : 		}
; 878  : 		// hostIdx IP
; 879  : 		if (i == ComIPGetHostIDIndex)	{
; 880  : 			*((int*)buf) = *((int*)(hentry->h_addr_list[i]));
; 881  : 			return 0;
; 882  : 		}
; 883  : 	}
; 884  : 	return 0;
; 885  : #endif
; 886  : }

	pop	ebp
	ret	0
_ComIPHostIDGet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\udp.c
_TEXT	SEGMENT
_recverror$1 = -1048					; size = 4
_size$2 = -1044						; size = 4
tv68 = -1040						; size = 4
tv82 = -1036						; size = 4
_bytesRecvd$3 = -1032					; size = 4
_decomp_size$4 = -1028					; size = 2
_cudp$5 = -1024						; size = 4
_in_addr$6 = -1020					; size = 16
_buffer$ = -1004					; size = 1000
__$ArrayPad$ = -4					; size = 4
_c$ = 8							; size = 4
_ComUDPGet PROC

; 651  : int ComUDPGet(ComAPIHandle c)	{

	push	ebp
	mov	ebp, esp
	sub	esp, 1048				; 00000418H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
$LN14@ComUDPGet:

; 652  : 
; 653  : 	char buffer[1000];
; 654  : 
; 655  : 	while(c) {

	cmp	DWORD PTR _c$[ebp], 0
	je	$LN13@ComUDPGet

; 656  : 
; 657  : 		ComIP *cudp = (ComIP *)c;

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _cudp$5[ebp], eax

; 658  : 
; 659  : 		int recverror;
; 660  : 		int bytesRecvd;
; 661  : 		int size=0;

	mov	DWORD PTR _size$2[ebp], 0

; 662  : 		struct sockaddr in_addr;
; 663  : 
; 664  : 		cudp = GETActiveCOMHandle(c);

	mov	ecx, DWORD PTR _c$[ebp]
	cmp	DWORD PTR [ecx+564], 0
	jne	SHORT $LN17@ComUDPGet
	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR tv68[ebp], edx
	jmp	SHORT $LN18@ComUDPGet
$LN17@ComUDPGet:
	mov	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR [eax+564]
	mov	DWORD PTR tv68[ebp], ecx
$LN18@ComUDPGet:
	mov	edx, DWORD PTR tv68[ebp]
	mov	DWORD PTR _cudp$5[ebp], edx

; 665  : 		cudp->recv_buffer.len = cudp->buffer_size;

	mov	eax, DWORD PTR _cudp$5[ebp]
	mov	ecx, DWORD PTR _cudp$5[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR [eax+68], edx

; 666  : 
; 667  : 		size =  sizeof(in_addr);

	mov	DWORD PTR _size$2[ebp], 16		; 00000010H

; 668  : 		bytesRecvd = CAPI_recvfrom(
; 669  : 			cudp->recv_sock,
; 670  : 			buffer,
; 671  : 			cudp->recv_buffer.len,
; 672  : 			0,
; 673  : 			&in_addr,
; 674  : 			&size
; 675  : 		);

	lea	eax, DWORD PTR _size$2[ebp]
	push	eax
	lea	ecx, DWORD PTR _in_addr$6[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _cudp$5[ebp]
	mov	eax, DWORD PTR [edx+68]
	push	eax
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cudp$5[ebp]
	mov	eax, DWORD PTR [edx+516]
	push	eax
	call	DWORD PTR _CAPI_recvfrom
	mov	DWORD PTR _bytesRecvd$3[ebp], eax

; 676  : 
; 677  : 		if (bytesRecvd == SOCKET_ERROR){

	cmp	DWORD PTR _bytesRecvd$3[ebp], -1
	jne	SHORT $LN12@ComUDPGet

; 678  : 			recverror = CAPI_WSAGetLastError();

	call	DWORD PTR _CAPI_WSAGetLastError
	mov	DWORD PTR _recverror$1[ebp], eax

; 679  : 
; 680  : #ifdef DEBUG_COMMS
; 681  : 			if(recverror != WSAEWOULDBLOCK )
; 682  : 			{
; 683  : 			}
; 684  : #endif
; 685  : 
; 686  : 			switch(recverror)

	mov	ecx, DWORD PTR _recverror$1[ebp]
	mov	DWORD PTR tv82[ebp], ecx
	mov	edx, DWORD PTR tv82[ebp]
	sub	edx, 10004				; 00002714H
	mov	DWORD PTR tv82[ebp], edx
	cmp	DWORD PTR tv82[ebp], 89			; 00000059H
	ja	SHORT $LN8@ComUDPGet
	mov	eax, DWORD PTR tv82[ebp]
	movzx	ecx, BYTE PTR $LN19@ComUDPGet[eax]
	jmp	DWORD PTR $LN20@ComUDPGet[ecx*4]
$LN9@ComUDPGet:

; 687  : 			{
; 688  : 				case WSANOTINITIALISED:
; 689  : 					/* A successful WSAStartup must occur before using this API.*/
; 690  : 				case WSAENETDOWN:
; 691  : 					/* The network subsystem has failed. */
; 692  : 				case WSAEFAULT:
; 693  : 					/* The buf argument is not totally contained in a valid part
; 694  : 						 of the user address space. */
; 695  : 				case WSAENOTCONN:
; 696  : 					/* The socket is not connected. */
; 697  : 				case WSAEINTR:
; 698  : 					/* The (blocking) call was canceled via WSACancelBlockingCall. */
; 699  : 				case WSAEINPROGRESS:
; 700  : 					/* A blocking Windows Sockets 1.1 call is in progress, or
; 701  : 						 the service provider is still processing a callback
; 702  : 						 function. */
; 703  : 				case WSAENETRESET:
; 704  : 					/* The connection has been broken due to the remote host
; 705  : 						 resetting. */
; 706  : 				case WSAENOTSOCK:
; 707  : 					/* The descriptor is not a socket. */
; 708  : 				case WSAEOPNOTSUPP:
; 709  : 					/* MSG_OOB was specified, but the socket is not stream style
; 710  : 						 such as type SOCK_STREAM, out-of-band data is not supported
; 711  : 						 in the communication domain associated with this socket,
; 712  : 						 or the socket is unidirectional and supports only send
; 713  : 						 operations. */
; 714  : 				case WSAESHUTDOWN:
; 715  : 					/* The socket has been shutdown; it is not possible to recv
; 716  : 						 on a socket after shutdown has been invoked with how set
; 717  : 						 to SD_RECEIVE or SD_BOTH. */
; 718  : 
; 719  : 				case WSAEWOULDBLOCK:
; 720  : 					/* The socket is marked as non-blocking and the receive
; 721  : 						 operation would block. */
; 722  : 					cudp->recvwouldblockcount++;

	mov	edx, DWORD PTR _cudp$5[ebp]
	mov	eax, DWORD PTR [edx+528]
	add	eax, 1
	mov	ecx, DWORD PTR _cudp$5[ebp]
	mov	DWORD PTR [ecx+528], eax

; 723  : 					return 0;

	xor	eax, eax
	jmp	$LN15@ComUDPGet
$LN8@ComUDPGet:

; 724  : 
; 725  : 				case WSAEMSGSIZE:
; 726  : 					/* The message was too large to fit into the specified buffer
; 727  : 						 and was truncated. */
; 728  : 				case WSAEINVAL:
; 729  : 					/* The socket has not been bound with bind, or an unknown flag
; 730  : 						 was specified, or MSG_OOB was specified for a socket with
; 731  : 						 SO_OOBINLINE enabled or (for byte stream sockets only) len
; 732  : 						 was 0 or negative. */
; 733  : 				case WSAECONNABORTED:
; 734  : 					/* The virtual circuit was aborted due to timeout or other
; 735  : 						 failure. The application should close the socket as it
; 736  : 						 is no longer useable. */
; 737  : 				case WSAETIMEDOUT:
; 738  : 					/* The connection has been dropped because of a network
; 739  : 						 failure or because the peer system failed to respond. */
; 740  : 				case WSAECONNRESET:
; 741  : 					/* The virtual circuit was reset by the remote side executing
; 742  : 						 a "hard" or "abortive" close. The application should close
; 743  : 						 the socket as it is no longer useable. On a UDP datagram
; 744  : 						 socket this error would indicate that a previous send
; 745  : 						 operation resulted in an ICMP "Port Unreachable" message. */
; 746  : 				default :
; 747  : 					return 0;

	xor	eax, eax
	jmp	$LN15@ComUDPGet
$LN12@ComUDPGet:

; 748  : 			}
; 749  : 		}
; 750  : 
; 751  : 		if (bytesRecvd > 0)

	cmp	DWORD PTR _bytesRecvd$3[ebp], 0
	jle	$LN7@ComUDPGet

; 752  : 		{
; 753  : 
; 754  : 			if (*(u_short*)buffer <= 700)

	movzx	edx, WORD PTR _buffer$[ebp]
	cmp	edx, 700				; 000002bcH
	jg	SHORT $LN6@ComUDPGet

; 755  : 			{
; 756  : 				u_short decomp_size;
; 757  : 
; 758  : 				memcpy(&decomp_size, buffer, sizeof(u_short));

	push	2
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	lea	ecx, DWORD PTR _decomp_size$4[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 759  : 				comms_decompress (buffer + sizeof(u_short), cudp->recv_buffer.buf, decomp_size);

	movzx	edx, WORD PTR _decomp_size$4[ebp]
	push	edx
	mov	eax, DWORD PTR _cudp$5[ebp]
	mov	ecx, DWORD PTR [eax+72]
	push	ecx
	lea	edx, DWORD PTR _buffer$[ebp+2]
	push	edx
	call	_comms_decompress
	add	esp, 12					; 0000000cH

; 760  : 				cudp->recv_buffer.len = decomp_size;

	movzx	eax, WORD PTR _decomp_size$4[ebp]
	mov	ecx, DWORD PTR _cudp$5[ebp]
	mov	DWORD PTR [ecx+68], eax

; 761  : 				bytesRecvd = decomp_size;

	movzx	edx, WORD PTR _decomp_size$4[ebp]
	mov	DWORD PTR _bytesRecvd$3[ebp], edx

; 762  : 			}
; 763  : 			else

	jmp	SHORT $LN5@ComUDPGet
$LN6@ComUDPGet:

; 764  : 			{
; 765  : 				memcpy (cudp->recv_buffer.buf, buffer, bytesRecvd);

	mov	eax, DWORD PTR _bytesRecvd$3[ebp]
	push	eax
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cudp$5[ebp]
	mov	eax, DWORD PTR [edx+72]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 766  : 				cudp->recv_buffer.len = bytesRecvd;

	mov	ecx, DWORD PTR _cudp$5[ebp]
	mov	edx, DWORD PTR _bytesRecvd$3[ebp]
	mov	DWORD PTR [ecx+68], edx
$LN5@ComUDPGet:

; 767  : 			}
; 768  : 
; 769  : 			// ignore messages from me
; 770  : 			//sfr: added port info
; 771  : /*			if (!(
; 772  : 				(((struct sockaddr_in *)(&in_addr))->sin_addr.s_addr == cudp->whoami) &&
; 773  : 				(((struct sockaddr_in *)(&in_addr))->sin_port == CAPI_htons(ComAPIGetMySendPort()))
; 774  : 			)){*/
; 775  : 			if (((ComAPIHeader *)cudp->recv_buffer.buf)->id != cudp->whoami){

	mov	eax, DWORD PTR _cudp$5[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR _cudp$5[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+580]
	je	$LN4@ComUDPGet

; 776  : 				// sets lastsender
; 777  : 				cudp->lastsender = ((struct sockaddr_in *) (&in_addr))->sin_addr.s_addr;

	mov	ecx, DWORD PTR _cudp$5[ebp]
	mov	edx, DWORD PTR _in_addr$6[ebp+4]
	mov	DWORD PTR [ecx+588], edx

; 778  : 				cudp->lastsenderport = ((struct sockaddr_in *) (&in_addr))->sin_port;

	movzx	eax, WORD PTR _in_addr$6[ebp+2]
	mov	ecx, DWORD PTR _cudp$5[ebp]
	mov	DWORD PTR [ecx+592], eax

; 779  : 				cudp->lastsenderid = ((ComAPIHeader *)cudp->recv_buffer.buf)->id;

	mov	edx, DWORD PTR _cudp$5[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	ecx, DWORD PTR _cudp$5[ebp]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+596], edx

; 780  : 
; 781  : 
; 782  : 				// check gamename
; 783  : 				if (strncmp(((ComAPIHeader *)cudp->recv_buffer.buf)->gamename, ((ComAPIHeader *)cudp->send_buffer.buf)->gamename, GAME_NAME_LENGTH) == 0)

	push	4
	mov	eax, DWORD PTR _cudp$5[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	mov	edx, DWORD PTR _cudp$5[ebp]
	mov	eax, DWORD PTR [edx+72]
	push	eax
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN4@ComUDPGet

; 784  : 				{
; 785  : 					cudp->recvmessagecount++;

	mov	ecx, DWORD PTR _cudp$5[ebp]
	mov	edx, DWORD PTR [ecx+520]
	add	edx, 1
	mov	eax, DWORD PTR _cudp$5[ebp]
	mov	DWORD PTR [eax+520], edx

; 786  : 
; 787  : 					// refresh timestamp
; 788  : 					if (CAPI_TimeStamp) {

	cmp	DWORD PTR _CAPI_TimeStamp, 0
	je	SHORT $LN2@ComUDPGet

; 789  : 						cudp->timestamp = CAPI_TimeStamp();

	call	DWORD PTR _CAPI_TimeStamp
	mov	ecx, DWORD PTR _cudp$5[ebp]
	mov	DWORD PTR [ecx+600], eax
$LN2@ComUDPGet:

; 790  : 					}
; 791  : 					cudp->rudp_data.last_ping_recv_time = GetTickCount ();

	call	DWORD PTR __imp__GetTickCount@0
	mov	edx, DWORD PTR _cudp$5[ebp]
	mov	DWORD PTR [edx+708], eax

; 792  : 					//take header out
; 793  : 					return bytesRecvd - sizeof(ComAPIHeader);

	mov	eax, DWORD PTR _bytesRecvd$3[ebp]
	sub	eax, 8
	jmp	SHORT $LN15@ComUDPGet
$LN4@ComUDPGet:

; 794  : 				}
; 795  : 			}
; 796  : 		}
; 797  : 		else

	jmp	SHORT $LN1@ComUDPGet
$LN7@ComUDPGet:

; 798  : 		{
; 799  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN15@ComUDPGet
$LN1@ComUDPGet:

; 800  : 		}
; 801  : 	}

	jmp	$LN14@ComUDPGet
$LN13@ComUDPGet:

; 802  : 
; 803  : 	return 0;

	xor	eax, eax
$LN15@ComUDPGet:

; 804  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN20@ComUDPGet:
	DD	$LN9@ComUDPGet
	DD	$LN8@ComUDPGet
$LN19@ComUDPGet:
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	0
	DB	1
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	1
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
_ComUDPGet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\udp.c
_TEXT	SEGMENT
_c$ = 8							; size = 4
_msgsize$ = 12						; size = 4
_oob$ = 16						; size = 4
_type$ = 20						; size = 4
_Xcom$ = 24						; size = 4
_ComUDPSendX PROC

; 476  : int ComUDPSendX(ComAPIHandle c, int msgsize, int oob, int type, ComAPIHandle Xcom){

	push	ebp
	mov	ebp, esp

; 477  : 	if(c == Xcom){

	mov	eax, DWORD PTR _c$[ebp]
	cmp	eax, DWORD PTR _Xcom$[ebp]
	jne	SHORT $LN2@ComUDPSend

; 478  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN3@ComUDPSend

; 479  : 	}
; 480  : 	else {

	jmp	SHORT $LN3@ComUDPSend
$LN2@ComUDPSend:

; 481  : 		return ComUDPSend(c, msgsize, oob, type);

	mov	ecx, DWORD PTR _type$[ebp]
	push	ecx
	mov	edx, DWORD PTR _oob$[ebp]
	push	edx
	mov	eax, DWORD PTR _msgsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	call	_ComUDPSend
	add	esp, 16					; 00000010H
$LN3@ComUDPSend:

; 482  : 	}
; 483  : }

	pop	ebp
	ret	0
_ComUDPSendX ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\udp.c
_TEXT	SEGMENT
_dummyBlk$ = -28					; size = 4
_com$ = -24						; size = 4
_to$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_c$ = 8							; size = 4
_ip$ = 12						; size = 4
_port$ = 16						; size = 2
_ComUDPSendDummy PROC

; 638  : int ComUDPSendDummy(ComAPIHandle c, unsigned long ip, unsigned short port){

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 639  : 	int dummyBlk = 0;

	mov	DWORD PTR _dummyBlk$[ebp], 0

; 640  : 	ComIP *com = (ComIP*)c;

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _com$[ebp], eax

; 641  : 	struct sockaddr_in to;
; 642  : 	memset(&to, 0, sizeof(to));

	push	16					; 00000010H
	push	0
	lea	ecx, DWORD PTR _to$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 643  : 	to.sin_family = AF_INET;

	mov	edx, 2
	mov	WORD PTR _to$[ebp], dx

; 644  : 	to.sin_addr.S_un.S_addr = CAPI_htonl(ip);

	mov	eax, DWORD PTR _ip$[ebp]
	push	eax
	call	DWORD PTR _CAPI_htonl
	mov	DWORD PTR _to$[ebp+4], eax

; 645  : 	to.sin_port = CAPI_htons(port);

	movzx	ecx, WORD PTR _port$[ebp]
	push	ecx
	call	DWORD PTR _CAPI_htons
	mov	WORD PTR _to$[ebp+2], ax

; 646  : 	return CAPI_sendto(
; 647  : 		com->send_sock, (const void*)&dummyBlk, sizeof(int), 0, (struct sockaddr*)&to, sizeof(to)
; 648  : 	);

	push	16					; 00000010H
	lea	edx, DWORD PTR _to$[ebp]
	push	edx
	push	0
	push	4
	lea	eax, DWORD PTR _dummyBlk$[ebp]
	push	eax
	mov	ecx, DWORD PTR _com$[ebp]
	mov	edx, DWORD PTR [ecx+512]
	push	edx
	call	DWORD PTR _CAPI_sendto

; 649  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_ComUDPSendDummy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\udp.c
_TEXT	SEGMENT
tv184 = -1032						; size = 4
_senderror$ = -1028					; size = 4
_bytesSent$ = -1024					; size = 4
_actual$ = -1020					; size = 4
_newsize$ = -1016					; size = 2
_size$ = -1012						; size = 2
_cudp$ = -1008						; size = 4
_buffer$ = -1004					; size = 1000
__$ArrayPad$ = -4					; size = 4
_c$ = 8							; size = 4
_msgsize$ = 12						; size = 4
_oob$ = 16						; size = 4
_type$ = 20						; size = 4
_ComUDPSend PROC

; 492  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1032				; 00000408H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 493  : 	ComIP *cudp;
; 494  : 	ComIP *actual;
; 495  : 
; 496  : 	int senderror;
; 497  : 	int bytesSent;
; 498  : 
; 499  : 	u_short size;
; 500  : 	u_short newsize;
; 501  : 
; 502  : 	char buffer[1000];
; 503  : 
; 504  : 	if(c == NULL){

	cmp	DWORD PTR _c$[ebp], 0
	jne	SHORT $LN17@ComUDPSend

; 505  : 		return 0;

	xor	eax, eax
	jmp	$LN18@ComUDPSend
$LN17@ComUDPSend:

; 506  : 	}
; 507  : 
; 508  : 	cudp = (ComIP *)c;

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _cudp$[ebp], eax

; 509  : 
; 510  : 	if(msgsize > cudp->buffer_size - (int)sizeof(ComAPIHeader)){

	mov	ecx, DWORD PTR _cudp$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	sub	edx, 8
	cmp	DWORD PTR _msgsize$[ebp], edx
	jle	SHORT $LN16@ComUDPSend

; 511  : 		return COMAPI_MESSAGE_TOO_BIG;

	mov	eax, -6					; fffffffaH
	jmp	$LN18@ComUDPSend
$LN16@ComUDPSend:

; 512  : 	}
; 513  : 
; 514  : 	cudp->send_buffer.len = msgsize + sizeof(ComAPIHeader);

	mov	eax, DWORD PTR _msgsize$[ebp]
	add	eax, 8
	mov	ecx, DWORD PTR _cudp$[ebp]
	mov	DWORD PTR [ecx+60], eax

; 515  : 
; 516  : 	/* Do we need to toggle the SO_BROADCAST state ?*/
; 517  : 	actual = cudp;

	mov	edx, DWORD PTR _cudp$[ebp]
	mov	DWORD PTR _actual$[ebp], edx

; 518  : 
; 519  : 	if (cudp->parent != NULL){

	mov	eax, DWORD PTR _cudp$[ebp]
	cmp	DWORD PTR [eax+564], 0
	je	SHORT $LN15@ComUDPSend

; 520  : 		/* am I a SendClone ?? */
; 521  : 		actual   = cudp->parent;

	mov	ecx, DWORD PTR _cudp$[ebp]
	mov	edx, DWORD PTR [ecx+564]
	mov	DWORD PTR _actual$[ebp], edx
$LN15@ComUDPSend:

; 522  : 	}
; 523  : 
; 524  : 	if (F4IsBadReadPtrC(cudp, sizeof(ComIP)) || F4IsBadReadPtrC(actual, sizeof(ComIP))) // JB 010220 CTD

	push	716					; 000002ccH
	mov	eax, DWORD PTR _cudp$[ebp]
	push	eax
	call	_F4IsBadReadPtrC
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN13@ComUDPSend
	push	716					; 000002ccH
	mov	ecx, DWORD PTR _actual$[ebp]
	push	ecx
	call	_F4IsBadReadPtrC
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@ComUDPSend
$LN13@ComUDPSend:

; 525  : 		return COMAPI_OUT_OF_SYNC; // JB 010220 CTD

	mov	eax, -2					; fffffffeH
	jmp	$LN18@ComUDPSend
$LN14@ComUDPSend:

; 526  : 
; 527  : 	if(actual->BroadcastModeOn != cudp->NeedBroadcastMode)

	mov	edx, DWORD PTR _actual$[ebp]
	mov	eax, DWORD PTR _cudp$[ebp]
	mov	ecx, DWORD PTR [edx+572]
	cmp	ecx, DWORD PTR [eax+576]
	je	SHORT $LN12@ComUDPSend

; 528  : 	{
; 529  : 		CAPI_setsockopt(cudp->send_sock, SOL_SOCKET, SO_BROADCAST, (char *)&(cudp->NeedBroadcastMode), sizeof(int) );  

	push	4
	mov	edx, DWORD PTR _cudp$[ebp]
	add	edx, 576				; 00000240H
	push	edx
	push	32					; 00000020H
	push	65535					; 0000ffffH
	mov	eax, DWORD PTR _cudp$[ebp]
	mov	ecx, DWORD PTR [eax+512]
	push	ecx
	call	DWORD PTR _CAPI_setsockopt

; 530  : 		actual->BroadcastModeOn = cudp->NeedBroadcastMode;     

	mov	edx, DWORD PTR _actual$[ebp]
	mov	eax, DWORD PTR _cudp$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	mov	DWORD PTR [edx+572], ecx
$LN12@ComUDPSend:

; 531  : 	}
; 532  : 
; 533  : 	size = (u_short)cudp->send_buffer.len;

	mov	edx, DWORD PTR _cudp$[ebp]
	mov	ax, WORD PTR [edx+60]
	mov	WORD PTR _size$[ebp], ax

; 534  : 
; 535  : 	if (size < 32){

	movzx	ecx, WORD PTR _size$[ebp]
	cmp	ecx, 32					; 00000020H
	jge	SHORT $LN11@ComUDPSend

; 536  : 		newsize = size;

	mov	dx, WORD PTR _size$[ebp]
	mov	WORD PTR _newsize$[ebp], dx

; 537  : 	}
; 538  : 	else {

	jmp	SHORT $LN10@ComUDPSend
$LN11@ComUDPSend:

; 539  : 		memcpy(buffer, &size, sizeof(u_short));

	push	2
	lea	eax, DWORD PTR _size$[ebp]
	push	eax
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 540  : 		memset (cudp->send_buffer.buf + size, 0, cudp->buffer_size - size);

	movzx	edx, WORD PTR _size$[ebp]
	mov	eax, DWORD PTR _cudp$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	sub	ecx, edx
	push	ecx
	push	0
	movzx	edx, WORD PTR _size$[ebp]
	mov	eax, DWORD PTR _cudp$[ebp]
	add	edx, DWORD PTR [eax+64]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 541  : 		newsize = (unsigned short)(comms_compress (cudp->send_buffer.buf, buffer+sizeof(u_short), size));

	movzx	ecx, WORD PTR _size$[ebp]
	push	ecx
	lea	edx, DWORD PTR _buffer$[ebp+2]
	push	edx
	mov	eax, DWORD PTR _cudp$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	call	_comms_compress
	add	esp, 12					; 0000000cH
	mov	WORD PTR _newsize$[ebp], ax
$LN10@ComUDPSend:

; 542  : 	}
; 543  : 
; 544  : 	//cudp->send_buffer.len = newsize+sizeof(u_short);
; 545  : 
; 546  : 	// if not OOB, check if enough bw is available
; 547  : 	if (!oob){

	cmp	DWORD PTR _oob$[ebp], 0
	jne	SHORT $LN9@ComUDPSend

; 548  : 		if (check_bandwidth(newsize + sizeof (u_short), 0, type) == 0){

	mov	edx, DWORD PTR _type$[ebp]
	push	edx
	push	0
	movzx	eax, WORD PTR _newsize$[ebp]
	add	eax, 2
	push	eax
	call	_check_bandwidth
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN9@ComUDPSend

; 549  : 			return COMAPI_WOULDBLOCK;

	mov	eax, -8					; fffffff8H
	jmp	$LN18@ComUDPSend
$LN9@ComUDPSend:

; 550  : 		}
; 551  : 	}
; 552  : 
; 553  : 	bytesSent = 0;

	mov	DWORD PTR _bytesSent$[ebp], 0

; 554  : 	//if (docomms){
; 555  : 	if ((int)(newsize + sizeof (u_short)) < (int) (size))

	movzx	ecx, WORD PTR _newsize$[ebp]
	add	ecx, 2
	movzx	edx, WORD PTR _size$[ebp]
	cmp	ecx, edx
	jge	SHORT $LN7@ComUDPSend

; 556  : 	{
; 557  : 		bytesSent = CAPI_sendto
; 558  : 			(
; 559  : 				cudp->send_sock,
; 560  : 				buffer,
; 561  : 				newsize + sizeof (u_short),
; 562  : 				0,
; 563  : 				(struct sockaddr *)&cudp->sendAddress,   
; 564  : 				sizeof(cudp->sendAddress)
; 565  : 			);

	push	16					; 00000010H
	mov	eax, DWORD PTR _cudp$[ebp]
	add	eax, 480				; 000001e0H
	push	eax
	push	0
	movzx	ecx, WORD PTR _newsize$[ebp]
	add	ecx, 2
	push	ecx
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _cudp$[ebp]
	mov	ecx, DWORD PTR [eax+512]
	push	ecx
	call	DWORD PTR _CAPI_sendto
	mov	DWORD PTR _bytesSent$[ebp], eax

; 566  : 	}
; 567  : 	else

	jmp	SHORT $LN6@ComUDPSend
$LN7@ComUDPSend:

; 568  : 	{
; 569  : 		bytesSent = CAPI_sendto
; 570  : 			(
; 571  : 				cudp->send_sock,
; 572  : 				cudp->send_buffer.buf,
; 573  : 				cudp->send_buffer.len,
; 574  : 				0,
; 575  : 				(struct sockaddr *)&cudp->sendAddress,   
; 576  : 				sizeof(cudp->sendAddress)
; 577  : 			);

	push	16					; 00000010H
	mov	edx, DWORD PTR _cudp$[ebp]
	add	edx, 480				; 000001e0H
	push	edx
	push	0
	mov	eax, DWORD PTR _cudp$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	push	ecx
	mov	edx, DWORD PTR _cudp$[ebp]
	mov	eax, DWORD PTR [edx+64]
	push	eax
	mov	ecx, DWORD PTR _cudp$[ebp]
	mov	edx, DWORD PTR [ecx+512]
	push	edx
	call	DWORD PTR _CAPI_sendto
	mov	DWORD PTR _bytesSent$[ebp], eax
$LN6@ComUDPSend:

; 578  : 	}
; 579  : 	//}
; 580  : 
; 581  : 	senderror = bytesSent;

	mov	eax, DWORD PTR _bytesSent$[ebp]
	mov	DWORD PTR _senderror$[ebp], eax

; 582  : 
; 583  : 	if (senderror == SOCKET_ERROR)

	cmp	DWORD PTR _senderror$[ebp], -1
	jne	SHORT $LN5@ComUDPSend

; 584  : 	{
; 585  : 		senderror = CAPI_WSAGetLastError();

	call	DWORD PTR _CAPI_WSAGetLastError
	mov	DWORD PTR _senderror$[ebp], eax

; 586  : 		switch(senderror)

	mov	ecx, DWORD PTR _senderror$[ebp]
	mov	DWORD PTR tv184[ebp], ecx
	cmp	DWORD PTR tv184[ebp], 10035		; 00002733H
	je	SHORT $LN2@ComUDPSend
	jmp	SHORT $LN1@ComUDPSend
$LN2@ComUDPSend:

; 587  : 		{
; 588  : 			case WSAEWOULDBLOCK:
; 589  : 				{
; 590  : 					//				MonoPrint ("WouldBlock %d %d\n", cudp->send_buffer.len, get_bandwidth_available ());
; 591  : 					cudp->sendwouldblockcount++;

	mov	edx, DWORD PTR _cudp$[ebp]
	mov	eax, DWORD PTR [edx+532]
	add	eax, 1
	mov	ecx, DWORD PTR _cudp$[ebp]
	mov	DWORD PTR [ecx+532], eax

; 592  : 					cut_bandwidth ();

	call	_cut_bandwidth

; 593  : 					/* The socket is marked as non-blocking and the send
; 594  : 							operation would block. */
; 595  : 					return COMAPI_WOULDBLOCK;

	mov	eax, -8					; fffffff8H
	jmp	SHORT $LN18@ComUDPSend
$LN1@ComUDPSend:

; 596  : 				}
; 597  : 
; 598  : 			default :
; 599  : 				{
; 600  : 					return 0;

	xor	eax, eax
	jmp	SHORT $LN18@ComUDPSend
$LN5@ComUDPSend:

; 601  : 				}
; 602  : 		}
; 603  : 	}
; 604  : 
; 605  : 
; 606  : 
; 607  : #ifdef checkbandwidth
; 608  : 
; 609  : 	if (test < 20 && oob == 2) 
; 610  : 	{
; 611  : 		MonoPrint("posupd size %d",bytesSent);
; 612  : 		test ++;
; 613  : 	}
; 614  : 
; 615  : 	totalbwused += bytesSent;
; 616  : 	if (oob) oobbwused +=bytesSent;
; 617  : 	if (oob == 2) Posupdbwused +=bytesSent;
; 618  : 	if (now > laststatcound + 1000)
; 619  : 	{
; 620  : 		/*	MonoPrint("UDP Bytes pr sec %d, OOB %d, Posupds %d", 
; 621  : 				(int)(totalbwused*1000/(now-laststatcound)),
; 622  : 				(int)(oobbwused *1000/(now-laststatcound)),
; 623  : 				(int)(Posupdbwused*1000/(now-laststatcound)));*/
; 624  : 		laststatcound = now;
; 625  : 		totalbwused = 0;
; 626  : 		oobbwused = 0;
; 627  : 		Posupdbwused = 0;
; 628  : 	}
; 629  : 
; 630  : #endif		
; 631  : 	use_bandwidth(bytesSent, 0, type);

	mov	edx, DWORD PTR _type$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _bytesSent$[ebp]
	push	eax
	call	_use_bandwidth
	add	esp, 12					; 0000000cH

; 632  : 	cudp->rudp_data.last_ping_send_time = GetTickCount ();

	call	DWORD PTR __imp__GetTickCount@0
	mov	ecx, DWORD PTR _cudp$[ebp]
	mov	DWORD PTR [ecx+704], eax

; 633  : 	cudp->sendmessagecount++;

	mov	edx, DWORD PTR _cudp$[ebp]
	mov	eax, DWORD PTR [edx+524]
	add	eax, 1
	mov	ecx, DWORD PTR _cudp$[ebp]
	mov	DWORD PTR [ecx+524], eax

; 634  : 
; 635  : 	return msgsize;

	mov	eax, DWORD PTR _msgsize$[ebp]
$LN18@ComUDPSend:

; 636  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_ComUDPSend ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\udp.c
_TEXT	SEGMENT
tv128 = -24						; size = 4
tv90 = -20						; size = 4
_curr$ = -16						; size = 4
_parent$1 = -12						; size = 4
_sockerror$ = -8					; size = 4
_cudp$2 = -4						; size = 4
_c$ = 8							; size = 4
_ComUDPClose PROC

; 341  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 342  : 	int sockerror;
; 343  : 	CAPIList
; 344  : 		*curr = 0;

	mov	DWORD PTR _curr$[ebp], 0

; 345  : 
; 346  : 	if(c)

	cmp	DWORD PTR _c$[ebp], 0
	je	$LN32@ComUDPClos

; 347  : 	{
; 348  : 		ComIP *cudp = (ComIP *)c;

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _cudp$2[ebp], eax

; 349  : 		//		int trueValue = 1;
; 350  : 		//		int falseValue = 0;
; 351  : 
; 352  : 		if (cudp->parent != NULL)

	mov	ecx, DWORD PTR _cudp$2[ebp]
	cmp	DWORD PTR [ecx+564], 0
	je	SHORT $LN30@ComUDPClos

; 353  : 		{
; 354  : 			ComIP *parent;
; 355  : 			parent = cudp->parent;

	mov	edx, DWORD PTR _cudp$2[ebp]
	mov	eax, DWORD PTR [edx+564]
	mov	DWORD PTR _parent$1[ebp], eax

; 356  : 			/* remove this ComHandle from the current list */
; 357  : 			//GlobalListHead = CAPIListRemove(GlobalListHead,c);
; 358  : 			comListRemove(cudp);

	mov	ecx, DWORD PTR _cudp$2[ebp]
	push	ecx
	call	_comListRemove
	add	esp, 4

; 359  : 
; 360  : 			if (cudp->send_buffer.buf) 

	mov	edx, DWORD PTR _cudp$2[ebp]
	cmp	DWORD PTR [edx+64], 0
	je	SHORT $LN29@ComUDPClos

; 361  : 			{
; 362  : 				free ( cudp->send_buffer.buf);

	mov	eax, DWORD PTR _cudp$2[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	call	_free
	add	esp, 4
$LN29@ComUDPClos:

; 363  : 			}
; 364  : 
; 365  : 			free(cudp);

	mov	edx, DWORD PTR _cudp$2[ebp]
	push	edx
	call	_free
	add	esp, 4

; 366  : 			parent->referencecount--;

	mov	eax, DWORD PTR _parent$1[ebp]
	mov	ecx, DWORD PTR [eax+568]
	sub	ecx, 1
	mov	edx, DWORD PTR _parent$1[ebp]
	mov	DWORD PTR [edx+568], ecx

; 367  : 			cudp = parent;

	mov	eax, DWORD PTR _parent$1[ebp]
	mov	DWORD PTR _cudp$2[ebp], eax

; 368  : 		}
; 369  : 		else

	jmp	SHORT $LN28@ComUDPClos
$LN30@ComUDPClos:

; 370  : 		{
; 371  : 			cudp->referencecount--;

	mov	ecx, DWORD PTR _cudp$2[ebp]
	mov	edx, DWORD PTR [ecx+568]
	sub	edx, 1
	mov	eax, DWORD PTR _cudp$2[ebp]
	mov	DWORD PTR [eax+568], edx
$LN28@ComUDPClos:

; 372  : 		}
; 373  : 
; 374  : 
; 375  : 		if(cudp->referencecount)

	mov	ecx, DWORD PTR _cudp$2[ebp]
	cmp	DWORD PTR [ecx+568], 0
	je	SHORT $LN27@ComUDPClos

; 376  : 		{
; 377  : 			return;

	jmp	$LN32@ComUDPClos
$LN27@ComUDPClos:

; 378  : 		}
; 379  : 
; 380  : #ifdef _DEBUG
; 381  : 		MonoPrint ("ComUDPClose Parent CH:\"%s\"\n", ((ComAPIHandle)cudp)->name);
; 382  : #endif
; 383  : 
; 384  : //		GlobalListHead = CAPIListRemove(GlobalListHead,(ComAPIHandle)cudp);
; 385  : 		comListRemove(cudp);

	mov	edx, DWORD PTR _cudp$2[ebp]
	push	edx
	call	_comListRemove
	add	esp, 4

; 386  : 
; 387  : 		if(sockerror = CAPI_closesocket(cudp->recv_sock))

	mov	eax, DWORD PTR _cudp$2[ebp]
	mov	ecx, DWORD PTR [eax+516]
	push	ecx
	call	DWORD PTR _CAPI_closesocket
	mov	DWORD PTR _sockerror$[ebp], eax
	cmp	DWORD PTR _sockerror$[ebp], 0
	je	SHORT $LN26@ComUDPClos

; 388  : 		{
; 389  : 			sockerror = CAPI_WSAGetLastError();

	call	DWORD PTR _CAPI_WSAGetLastError
	mov	DWORD PTR _sockerror$[ebp], eax

; 390  : 
; 391  : 			switch(sockerror)

	mov	edx, DWORD PTR _sockerror$[ebp]
	mov	DWORD PTR tv90[ebp], edx
$LN26@ComUDPClos:

; 392  : 			{
; 393  : 				case WSANOTINITIALISED:
; 394  : 					break;
; 395  : 				case WSAENETDOWN:
; 396  : 					break;
; 397  : 				case WSAENOTSOCK:
; 398  : 					break;
; 399  : 				case WSAEINPROGRESS:
; 400  : 					break;
; 401  : 				case WSAEINTR:
; 402  : 					break;
; 403  : 				case WSAEWOULDBLOCK:
; 404  : 					break;
; 405  : 				default :
; 406  : 					break;
; 407  : 			}
; 408  : 		}
; 409  : 
; 410  : 
; 411  : 		if(sockerror = CAPI_closesocket(cudp->send_sock))

	mov	eax, DWORD PTR _cudp$2[ebp]
	mov	ecx, DWORD PTR [eax+512]
	push	ecx
	call	DWORD PTR _CAPI_closesocket
	mov	DWORD PTR _sockerror$[ebp], eax
	cmp	DWORD PTR _sockerror$[ebp], 0
	je	SHORT $LN16@ComUDPClos

; 412  : 		{
; 413  : 			sockerror = CAPI_WSAGetLastError();

	call	DWORD PTR _CAPI_WSAGetLastError
	mov	DWORD PTR _sockerror$[ebp], eax

; 414  : 
; 415  : 			switch(sockerror)

	mov	edx, DWORD PTR _sockerror$[ebp]
	mov	DWORD PTR tv128[ebp], edx
$LN16@ComUDPClos:

; 416  : 			{
; 417  : 				case WSANOTINITIALISED:
; 418  : 					break;
; 419  : 				case WSAENETDOWN:
; 420  : 					break;
; 421  : 				case WSAENOTSOCK:
; 422  : 					break;
; 423  : 				case WSAEINPROGRESS:
; 424  : 					break;
; 425  : 				case WSAEINTR:
; 426  : 					break;
; 427  : 				case WSAEWOULDBLOCK:
; 428  : 					break;
; 429  : 				default :
; 430  : 					break;
; 431  : 			}
; 432  : 		}
; 433  : 
; 434  : 		WS2Connections--;

	mov	eax, DWORD PTR _WS2Connections
	sub	eax, 1
	mov	DWORD PTR _WS2Connections, eax

; 435  : 
; 436  : 		/* if No more connections then WSACleanup() */
; 437  : 		if (!WS2Connections)

	jne	SHORT $LN6@ComUDPClos

; 438  : 		{
; 439  : 			if(sockerror = CAPI_WSACleanup())

	call	DWORD PTR _CAPI_WSACleanup
	mov	DWORD PTR _sockerror$[ebp], eax
	cmp	DWORD PTR _sockerror$[ebp], 0
	je	SHORT $LN4@ComUDPClos

; 440  : 			{
; 441  : 				sockerror = CAPI_WSAGetLastError();

	call	DWORD PTR _CAPI_WSAGetLastError
	mov	DWORD PTR _sockerror$[ebp], eax
$LN4@ComUDPClos:

; 442  : 			}
; 443  : 			else
; 444  : 			{
; 445  : 			}
; 446  : 
; 447  : #ifdef LOAD_DLLS
; 448  : 			FreeLibrary(hWinSockDLL);

	mov	ecx, DWORD PTR _hWinSockDLL
	push	ecx
	call	DWORD PTR __imp__FreeLibrary@4

; 449  : 			hWinSockDLL = 0;

	mov	DWORD PTR _hWinSockDLL, 0
$LN6@ComUDPClos:

; 450  : #endif
; 451  : 		}
; 452  : 
; 453  : 		if(cudp->recv_buffer.buf)

	mov	edx, DWORD PTR _cudp$2[ebp]
	cmp	DWORD PTR [edx+72], 0
	je	SHORT $LN3@ComUDPClos

; 454  : 		{
; 455  : 			free(cudp->recv_buffer.buf);

	mov	eax, DWORD PTR _cudp$2[ebp]
	mov	ecx, DWORD PTR [eax+72]
	push	ecx
	call	_free
	add	esp, 4
$LN3@ComUDPClos:

; 456  : 		}
; 457  : 
; 458  : 		if(cudp->send_buffer.buf){

	mov	edx, DWORD PTR _cudp$2[ebp]
	cmp	DWORD PTR [edx+64], 0
	je	SHORT $LN2@ComUDPClos

; 459  : 			free(cudp->send_buffer.buf);

	mov	eax, DWORD PTR _cudp$2[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	call	_free
	add	esp, 4
$LN2@ComUDPClos:

; 460  : 		}
; 461  : 
; 462  : 		if(cudp->compression_buffer){

	mov	edx, DWORD PTR _cudp$2[ebp]
	cmp	DWORD PTR [edx+476], 0
	je	SHORT $LN1@ComUDPClos

; 463  : 			free(cudp->compression_buffer);

	mov	eax, DWORD PTR _cudp$2[ebp]
	mov	ecx, DWORD PTR [eax+476]
	push	ecx
	call	_free
	add	esp, 4
$LN1@ComUDPClos:

; 464  : 		}
; 465  : 
; 466  : 		// sfr: removed JB check
; 467  : 		//if (!F4IsBadReadPtrC(cudp, sizeof(ComIP))) // JB 010615 CTD
; 468  : 		free(cudp);

	mov	edx, DWORD PTR _cudp$2[ebp]
	push	edx
	call	_free
	add	esp, 4
$LN32@ComUDPClos:

; 469  : 	}
; 470  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ComUDPClose ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\udp.c
_TEXT	SEGMENT
_ret_val$1 = -424					; size = 4
_err$ = -420						; size = 4
_trueValue$ = -416					; size = 4
_size$ = -412						; size = 4
_c$ = -408						; size = 4
_wsaData$ = -404					; size = 400
__$ArrayPad$ = -4					; size = 4
_name_in$ = 8						; size = 4
_buffersize$ = 12					; size = 4
_gamename$ = 16						; size = 4
_localUdpPort$ = 20					; size = 2
_remoteUdpPort$ = 24					; size = 2
_IPaddress$ = 28					; size = 4
_id$ = 32						; size = 4
_ComUDPOpen PROC

; 98   : ){

	push	ebp
	mov	ebp, esp
	sub	esp, 424				; 000001a8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 99   : 	ComIP *c;
; 100  : 	int err, size;
; 101  : 	WSADATA wsaData;
; 102  : 	unsigned long trueValue=1;

	mov	DWORD PTR _trueValue$[ebp], 1

; 103  : 	enter_cs();

	call	_enter_cs

; 104  : 
; 105  : 	if (InitWS2(&wsaData) == 0){

	lea	eax, DWORD PTR _wsaData$[ebp]
	push	eax
	call	_InitWS2
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN10@ComUDPOpen

; 106  : 		leave_cs ();

	call	_leave_cs

; 107  : 		return 0;

	xor	eax, eax
	jmp	$LN11@ComUDPOpen
$LN10@ComUDPOpen:

; 108  : 	}
; 109  : 
; 110  : 	//sfr: if we already have comms setup, use a clone to send data to new client
; 111  : 	c = comListFindProtocolRport(CAPI_UDP_PROTOCOL, localUdpPort);

	movzx	ecx, WORD PTR _localUdpPort$[ebp]
	push	ecx
	push	1
	call	_comListFindProtocolRport
	add	esp, 8
	mov	DWORD PTR _c$[ebp], eax

; 112  : 	//if (listitem){
; 113  : 	if (c != NULL){

	cmp	DWORD PTR _c$[ebp], 0
	je	SHORT $LN9@ComUDPOpen

; 114  : 		ComAPIHandle ret_val;
; 115  : 		ret_val = ComUDPOpenSendClone(name_in, c, buffersize, gamename,  remoteUdpPort, IPaddress, id);

	mov	edx, DWORD PTR _id$[ebp]
	push	edx
	mov	eax, DWORD PTR _IPaddress$[ebp]
	push	eax
	movzx	ecx, WORD PTR _remoteUdpPort$[ebp]
	push	ecx
	mov	edx, DWORD PTR _gamename$[ebp]
	push	edx
	mov	eax, DWORD PTR _buffersize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	mov	edx, DWORD PTR _name_in$[ebp]
	push	edx
	call	_ComUDPOpenSendClone
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _ret_val$1[ebp], eax

; 116  : 		leave_cs ();

	call	_leave_cs

; 117  : 
; 118  : 		return ret_val;

	mov	eax, DWORD PTR _ret_val$1[ebp]
	jmp	$LN11@ComUDPOpen
$LN9@ComUDPOpen:

; 119  : 	}
; 120  : 
; 121  : 	/* add new socket connection to list */
; 122  : 
; 123  : 	c = (ComIP*)malloc(sizeof(ComIP));

	push	716					; 000002ccH
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _c$[ebp], eax

; 124  : 	memset(c,0,sizeof(ComIP));

	push	716					; 000002ccH
	push	0
	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 125  : 	((ComAPIHandle)c)->name = strdup(name_in);

	mov	ecx, DWORD PTR _name_in$[ebp]
	push	ecx
	call	_strdup
	add	esp, 4
	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [edx], eax

; 126  : 
; 127  : 	/* initialize header data */
; 128  : 	c->apiheader.protocol = CAPI_UDP_PROTOCOL;

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+4], 1

; 129  : 	c->apiheader.send_func = ComUDPSend;

	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+8], OFFSET _ComUDPSend

; 130  : 	c->apiheader.send_dummy_func = ComUDPSendDummy;

	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [edx+12], OFFSET _ComUDPSendDummy

; 131  : 	c->apiheader.sendX_func = ComUDPSendX;

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+16], OFFSET _ComUDPSendX

; 132  : 	c->apiheader.recv_func = ComUDPGet;

	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+20], OFFSET _ComUDPGet

; 133  : 	c->apiheader.send_buf_func = ComIPSendBufferGet;

	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [edx+24], OFFSET _ComIPSendBufferGet

; 134  : 	c->apiheader.recv_buf_func = ComIPRecvBufferGet;

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+28], OFFSET _ComIPRecvBufferGet

; 135  : 	c->apiheader.addr_func = ComIPHostIDGet;

	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+32], OFFSET _ComIPHostIDGet

; 136  : 	c->apiheader.close_func = ComUDPClose;

	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [edx+36], OFFSET _ComUDPClose

; 137  : 	c->apiheader.query_func = ComUDPQuery;

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+40], OFFSET _ComUDPQuery

; 138  : 	c->apiheader.get_timestamp_func = ComUDPGetTimeStamp;

	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+44], OFFSET _ComUDPGetTimeStamp

; 139  : 	c->sendmessagecount = 0;

	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [edx+524], 0

; 140  : 	c->recvmessagecount = 0;

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+520], 0

; 141  : 	c->recvwouldblockcount = 0;

	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+528], 0

; 142  : 	c->sendwouldblockcount = 0;

	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [edx+532], 0

; 143  : 	c->referencecount = 1;

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+568], 1

; 144  : 	c->timestamp = 0;

	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+600], 0

; 145  : 	c->max_buffer_size = 0;

	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [edx+52], 0

; 146  : 	c->ideal_packet_size = 0;

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+56], 0

; 147  : 
; 148  : 	c->recv_sock = CAPI_socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

	push	17					; 00000011H
	push	2
	push	2
	call	DWORD PTR _CAPI_socket
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+516], eax

; 149  : 
; 150  : 	size = CAPI_SENDBUFSIZE;

	mov	DWORD PTR _size$[ebp], 1024		; 00000400H

; 151  : 	CAPI_setsockopt (c->recv_sock, SOL_SOCKET, SO_SNDBUF, (char*) &size, 4);

	push	4
	lea	edx, DWORD PTR _size$[ebp]
	push	edx
	push	4097					; 00001001H
	push	65535					; 0000ffffH
	mov	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR [eax+516]
	push	ecx
	call	DWORD PTR _CAPI_setsockopt

; 152  : 	size = CAPI_RECVBUFSIZE;

	mov	DWORD PTR _size$[ebp], 65536		; 00010000H

; 153  : 	CAPI_setsockopt (c->recv_sock, SOL_SOCKET, SO_RCVBUF, (char*) &size, 4);

	push	4
	lea	edx, DWORD PTR _size$[ebp]
	push	edx
	push	4098					; 00001002H
	push	65535					; 0000ffffH
	mov	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR [eax+516]
	push	ecx
	call	DWORD PTR _CAPI_setsockopt

; 154  : 
; 155  : 	CAPI_ioctlsocket(c->recv_sock, FIONBIO, &trueValue);

	lea	edx, DWORD PTR _trueValue$[ebp]
	push	edx
	push	-2147195266				; 8004667eH
	mov	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR [eax+516]
	push	ecx
	call	DWORD PTR _CAPI_ioctlsocket

; 156  : 
; 157  : 	c->buffer_size = sizeof(ComAPIHeader) + buffersize;

	mov	edx, DWORD PTR _buffersize$[ebp]
	add	edx, 8
	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+48], edx

; 158  : 
; 159  : 	if ((c->max_buffer_size > 0) && (c->buffer_size  > c->max_buffer_size))

	mov	ecx, DWORD PTR _c$[ebp]
	cmp	DWORD PTR [ecx+52], 0
	jle	SHORT $LN8@ComUDPOpen
	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR [edx+48]
	cmp	ecx, DWORD PTR [eax+52]
	jle	SHORT $LN8@ComUDPOpen

; 160  : 	{
; 161  : 		c->buffer_size = c->max_buffer_size;

	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	DWORD PTR [edx+48], ecx
$LN8@ComUDPOpen:

; 162  : 	}
; 163  : 
; 164  : 	c->recv_buffer.buf = (char *)malloc(c->buffer_size);

	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [edx+48]
	push	eax
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+72], eax

; 165  : 	c->recv_buffer.len = c->buffer_size;

	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR [edx+68], ecx

; 166  : 
; 167  : 	c->send_buffer.buf = (char *)malloc(c->buffer_size);

	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [edx+48]
	push	eax
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+64], eax

; 168  : 
; 169  : 	c->compression_buffer = (char *)malloc(c->buffer_size);

	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [edx+48]
	push	eax
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+476], eax

; 170  : 
; 171  : 	// sfr: store as network, but functions all use host order...
; 172  : 	// so reverse here
; 173  : 	ComIPHostIDGet(&c->apiheader, (char *)&c->whoami, 0);

	push	0
	mov	edx, DWORD PTR _c$[ebp]
	add	edx, 580				; 00000244H
	push	edx
	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	call	_ComIPHostIDGet
	add	esp, 12					; 0000000cH

; 174  : 	c->whoami = CAPI_htonl(c->whoami);

	mov	ecx, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR [ecx+580]
	push	edx
	call	DWORD PTR _CAPI_htonl
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+580], eax

; 175  : 
; 176  : 	if (IPaddress == CAPI_DANGLING_IP)

	cmp	DWORD PTR _IPaddress$[ebp], -1
	jne	SHORT $LN7@ComUDPOpen

; 177  : 	{
; 178  : 		ComIPHostIDGet(&c->apiheader, (char*)&IPaddress, 0);

	push	0
	lea	edx, DWORD PTR _IPaddress$[ebp]
	push	edx
	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	call	_ComIPHostIDGet
	add	esp, 12					; 0000000cH

; 179  : 		IPaddress = CAPI_htonl (IPaddress);

	mov	ecx, DWORD PTR _IPaddress$[ebp]
	push	ecx
	call	DWORD PTR _CAPI_htonl
	mov	DWORD PTR _IPaddress$[ebp], eax
$LN7@ComUDPOpen:

; 180  : 		//IPaddress = CAPI_htonl (c->whoami);
; 181  : 	}
; 182  : 
; 183  : 	strncpy(((ComAPIHeader *)c->send_buffer.buf)->gamename, gamename, GAME_NAME_LENGTH);

	push	4
	mov	edx, DWORD PTR _gamename$[ebp]
	push	edx
	mov	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	call	_strncpy
	add	esp, 12					; 0000000cH

; 184  : 	// sfr: send id in network order
; 185  : 	((ComAPIHeader *)c->send_buffer.buf)->id = c->whoami;

	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [edx+64]
	mov	ecx, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR [ecx+580]
	mov	DWORD PTR [eax+4], edx

; 186  : 
; 187  : 	CAPI_ioctlsocket(c->recv_sock, FIONBIO, &trueValue);

	lea	eax, DWORD PTR _trueValue$[ebp]
	push	eax
	push	-2147195266				; 8004667eH
	mov	ecx, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR [ecx+516]
	push	edx
	call	DWORD PTR _CAPI_ioctlsocket

; 188  : 	if(c->recv_sock == INVALID_SOCKET)

	mov	eax, DWORD PTR _c$[ebp]
	cmp	DWORD PTR [eax+516], -1
	jne	SHORT $LN6@ComUDPOpen

; 189  : 	{
; 190  : 		//		int error = CAPI_WSAGetLastError();
; 191  : 		leave_cs ();

	call	_leave_cs

; 192  : 		return 0;

	xor	eax, eax
	jmp	$LN11@ComUDPOpen
$LN6@ComUDPOpen:

; 193  : 	}
; 194  : 
; 195  : 	/* Incoming... */
; 196  : 	memset ((char*)&comRecvAddr, 0, sizeof(comRecvAddr));

	push	16					; 00000010H
	push	0
	push	OFFSET _comRecvAddr
	call	_memset
	add	esp, 12					; 0000000cH

; 197  : 	comRecvAddr.sin_family       = AF_INET;

	mov	ecx, 2
	mov	WORD PTR _comRecvAddr, cx

; 198  : 	comRecvAddr.sin_addr.s_addr  = CAPI_htonl(INADDR_ANY);

	push	0
	call	DWORD PTR _CAPI_htonl
	mov	DWORD PTR _comRecvAddr+4, eax

; 199  : 	// receive port
; 200  : 	comRecvAddr.sin_port         = CAPI_htons(localUdpPort);

	movzx	edx, WORD PTR _localUdpPort$[ebp]
	push	edx
	call	DWORD PTR _CAPI_htons
	mov	WORD PTR _comRecvAddr+2, ax

; 201  : 	memcpy(&c->recAddress, &comRecvAddr, sizeof(struct sockaddr_in));

	push	16					; 00000010H
	push	OFFSET _comRecvAddr
	mov	eax, DWORD PTR _c$[ebp]
	add	eax, 496				; 000001f0H
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 202  : 
; 203  : 	if(err=CAPI_bind(c->recv_sock, (struct sockaddr*)&comRecvAddr,sizeof(comRecvAddr)))

	push	16					; 00000010H
	push	OFFSET _comRecvAddr
	mov	ecx, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR [ecx+516]
	push	edx
	call	DWORD PTR _CAPI_bind
	mov	DWORD PTR _err$[ebp], eax
	cmp	DWORD PTR _err$[ebp], 0
	je	SHORT $LN5@ComUDPOpen

; 204  : 	{
; 205  : 		leave_cs ();

	call	_leave_cs

; 206  : 		return 0;

	xor	eax, eax
	jmp	$LN11@ComUDPOpen
$LN5@ComUDPOpen:

; 207  : 	}
; 208  : 
; 209  : 	//c->send_sock = CAPI_socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
; 210  : 	c->send_sock = c->recv_sock;

	mov	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR [ecx+516]
	mov	DWORD PTR [eax+512], edx

; 211  : 
; 212  : 	if(c->send_sock == INVALID_SOCKET){

	mov	eax, DWORD PTR _c$[ebp]
	cmp	DWORD PTR [eax+512], -1
	jne	SHORT $LN4@ComUDPOpen

; 213  : 		leave_cs ();

	call	_leave_cs

; 214  : 		return 0;

	xor	eax, eax
	jmp	$LN11@ComUDPOpen
$LN4@ComUDPOpen:

; 215  : 	}
; 216  : 
; 217  : 	size = CAPI_SENDBUFSIZE;

	mov	DWORD PTR _size$[ebp], 1024		; 00000400H

; 218  : 	CAPI_setsockopt (c->send_sock, SOL_SOCKET, SO_SNDBUF, (char*) &size, 4);

	push	4
	lea	ecx, DWORD PTR _size$[ebp]
	push	ecx
	push	4097					; 00001001H
	push	65535					; 0000ffffH
	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [edx+512]
	push	eax
	call	DWORD PTR _CAPI_setsockopt

; 219  : 	size = CAPI_RECVBUFSIZE;

	mov	DWORD PTR _size$[ebp], 65536		; 00010000H

; 220  : 	CAPI_setsockopt (c->send_sock, SOL_SOCKET, SO_RCVBUF, (char*) &size, 4);

	push	4
	lea	ecx, DWORD PTR _size$[ebp]
	push	ecx
	push	4098					; 00001002H
	push	65535					; 0000ffffH
	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [edx+512]
	push	eax
	call	DWORD PTR _CAPI_setsockopt

; 221  : 
; 222  : 	/**  .. on ISPs modem maybe better to set to Non-Blocking on send **/
; 223  : 	CAPI_ioctlsocket(c->send_sock, FIONBIO, &trueValue);

	lea	ecx, DWORD PTR _trueValue$[ebp]
	push	ecx
	push	-2147195266				; 8004667eH
	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [edx+512]
	push	eax
	call	DWORD PTR _CAPI_ioctlsocket

; 224  : 
; 225  : 	/* Outgoing... */
; 226  : 	memset ((char*)&c->sendAddress, 0, sizeof(c->sendAddress));

	push	16					; 00000010H
	push	0
	mov	ecx, DWORD PTR _c$[ebp]
	add	ecx, 480				; 000001e0H
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 227  : 	c->sendAddress.sin_family       = AF_INET;

	mov	edx, 2
	mov	eax, DWORD PTR _c$[ebp]
	mov	WORD PTR [eax+480], dx

; 228  : 
; 229  : 	if(IPaddress == 0){

	cmp	DWORD PTR _IPaddress$[ebp], 0
	jne	SHORT $LN3@ComUDPOpen

; 230  : 		c->sendAddress.sin_addr.s_addr  = CAPI_htonl(INADDR_BROADCAST);

	push	-1
	call	DWORD PTR _CAPI_htonl
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+484], eax

; 231  : 	}
; 232  : 	else {

	jmp	SHORT $LN2@ComUDPOpen
$LN3@ComUDPOpen:

; 233  : 		c->sendAddress.sin_addr.s_addr  = CAPI_htonl(IPaddress);

	mov	edx, DWORD PTR _IPaddress$[ebp]
	push	edx
	call	DWORD PTR _CAPI_htonl
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+484], eax
$LN2@ComUDPOpen:

; 234  : 	}
; 235  : 
; 236  : 	// send port
; 237  : 	c->sendAddress.sin_port         = CAPI_htons((unsigned short)remoteUdpPort);

	movzx	edx, WORD PTR _remoteUdpPort$[ebp]
	push	edx
	call	DWORD PTR _CAPI_htons
	mov	ecx, DWORD PTR _c$[ebp]
	mov	WORD PTR [ecx+482], ax

; 238  : 
; 239  : 	if(IPaddress == 0){

	cmp	DWORD PTR _IPaddress$[ebp], 0
	jne	SHORT $LN1@ComUDPOpen

; 240  : 		c->NeedBroadcastMode = 1;

	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [edx+576], 1

; 241  : 		c->BroadcastModeOn = 1;

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+572], 1

; 242  : 		CAPI_setsockopt(c->send_sock, SOL_SOCKET, SO_BROADCAST, (char *)&trueValue, sizeof(int) );  

	push	4
	lea	ecx, DWORD PTR _trueValue$[ebp]
	push	ecx
	push	32					; 00000020H
	push	65535					; 0000ffffH
	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [edx+512]
	push	eax
	call	DWORD PTR _CAPI_setsockopt
$LN1@ComUDPOpen:

; 243  : 	}
; 244  : 
; 245  : 	// sfr handle id
; 246  : 	c->id = CAPI_htonl(id);

	mov	ecx, DWORD PTR _id$[ebp]
	push	ecx
	call	DWORD PTR _CAPI_htonl
	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [edx+584], eax

; 247  : 
; 248  : 	// sfr: add c to list
; 249  : 	comListAdd(c);

	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	call	_comListAdd
	add	esp, 4

; 250  : 	leave_cs ();

	call	_leave_cs

; 251  : 
; 252  : 	return (ComAPIHandle)c;

	mov	eax, DWORD PTR _c$[ebp]
$LN11@ComUDPOpen:

; 253  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_ComUDPOpen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\udp.c
_TEXT	SEGMENT
_cudp$1 = -20						; size = 4
tv66 = -16						; size = 4
_threadhandle$ = -12					; size = 4
tv69 = -8						; size = 4
_SetPriority$ = -4					; size = 4
_c$ = 8							; size = 4
_priority$ = 12						; size = 4
_ComAPISetReceiveThreadPriority PROC

; 1049 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 1050 : 	HANDLE  threadhandle = 0;

	mov	DWORD PTR _threadhandle$[ebp], 0

; 1051 : 	int     SetPriority  = 0xffffffff;

	mov	DWORD PTR _SetPriority$[ebp], -1

; 1052 : 
; 1053 : 	if(c)

	cmp	DWORD PTR _c$[ebp], 0
	je	$LN17@ComAPISetR

; 1054 : 	{
; 1055 : 		switch (c->protocol)

	mov	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR tv66[ebp], ecx
	cmp	DWORD PTR tv66[ebp], 1
	je	SHORT $LN13@ComAPISetR
	jmp	SHORT $LN14@ComAPISetR
$LN13@ComAPISetR:

; 1056 : 		{
; 1057 : 			case CAPI_UDP_PROTOCOL:
; 1058 : 				{
; 1059 : 					ComIP *cudp= (ComIP *)c;

	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR _cudp$1[ebp], edx

; 1060 : 					threadhandle = cudp->ThreadHandle;

	mov	eax, DWORD PTR _cudp$1[ebp]
	mov	ecx, DWORD PTR [eax+540]
	mov	DWORD PTR _threadhandle$[ebp], ecx
$LN14@ComAPISetR:

; 1061 : 					break;
; 1062 : 				}
; 1063 : 
; 1064 : 			default:
; 1065 : 				{
; 1066 : 					break;
; 1067 : 				}
; 1068 : 		}
; 1069 : 
; 1070 : 		switch (priority)

	mov	edx, DWORD PTR _priority$[ebp]
	mov	DWORD PTR tv69[ebp], edx
	mov	eax, DWORD PTR tv69[ebp]
	sub	eax, 1
	mov	DWORD PTR tv69[ebp], eax
	cmp	DWORD PTR tv69[ebp], 6
	ja	SHORT $LN10@ComAPISetR
	mov	ecx, DWORD PTR tv69[ebp]
	jmp	DWORD PTR $LN19@ComAPISetR[ecx*4]
$LN9@ComAPISetR:

; 1071 : 		{
; 1072 : 			case CAPI_THREAD_PRIORITY_ABOVE_NORMAL:
; 1073 : 				{
; 1074 : 					SetPriority = THREAD_PRIORITY_ABOVE_NORMAL;

	mov	DWORD PTR _SetPriority$[ebp], 1

; 1075 : 					break;

	jmp	SHORT $LN10@ComAPISetR
$LN8@ComAPISetR:

; 1076 : 				}
; 1077 : 
; 1078 : 			case CAPI_THREAD_PRIORITY_BELOW_NORMAL:
; 1079 : 				{
; 1080 : 					SetPriority = THREAD_PRIORITY_BELOW_NORMAL;

	mov	DWORD PTR _SetPriority$[ebp], -1

; 1081 : 					break;

	jmp	SHORT $LN10@ComAPISetR
$LN7@ComAPISetR:

; 1082 : 				}
; 1083 : 
; 1084 : 			case CAPI_THREAD_PRIORITY_HIGHEST: 
; 1085 : 				{
; 1086 : 					SetPriority = THREAD_PRIORITY_HIGHEST;

	mov	DWORD PTR _SetPriority$[ebp], 2

; 1087 : 					break;

	jmp	SHORT $LN10@ComAPISetR
$LN6@ComAPISetR:

; 1088 : 				}
; 1089 : 
; 1090 : 			case CAPI_THREAD_PRIORITY_IDLE: 
; 1091 : 				{
; 1092 : 					SetPriority = THREAD_PRIORITY_IDLE;

	mov	DWORD PTR _SetPriority$[ebp], -15	; fffffff1H

; 1093 : 					break; 

	jmp	SHORT $LN10@ComAPISetR
$LN5@ComAPISetR:

; 1094 : 				}
; 1095 : 
; 1096 : 			case CAPI_THREAD_PRIORITY_LOWEST:
; 1097 : 				{
; 1098 : 					SetPriority = THREAD_PRIORITY_LOWEST;

	mov	DWORD PTR _SetPriority$[ebp], -2	; fffffffeH

; 1099 : 					break;

	jmp	SHORT $LN10@ComAPISetR
$LN4@ComAPISetR:

; 1100 : 				}
; 1101 : 
; 1102 : 			case CAPI_THREAD_PRIORITY_NORMAL: 
; 1103 : 				{
; 1104 : 					SetPriority = THREAD_PRIORITY_NORMAL;

	mov	DWORD PTR _SetPriority$[ebp], 0

; 1105 : 					break;

	jmp	SHORT $LN10@ComAPISetR
$LN3@ComAPISetR:

; 1106 : 				}
; 1107 : 
; 1108 : 			case CAPI_THREAD_PRIORITY_TIME_CRITICAL:
; 1109 : 				{
; 1110 : 					SetPriority = THREAD_PRIORITY_TIME_CRITICAL;

	mov	DWORD PTR _SetPriority$[ebp], 15	; 0000000fH
$LN10@ComAPISetR:

; 1111 : 					break;
; 1112 : 				}
; 1113 : 
; 1114 : 			default:
; 1115 : 				{
; 1116 : 					break;
; 1117 : 				}	
; 1118 : 		}
; 1119 : 
; 1120 : 		if (threadhandle && SetPriority != 0xFFFFFFFF)

	cmp	DWORD PTR _threadhandle$[ebp], 0
	je	SHORT $LN17@ComAPISetR
	cmp	DWORD PTR _SetPriority$[ebp], -1
	je	SHORT $LN17@ComAPISetR

; 1121 : 		{
; 1122 : 			SetThreadPriority(threadhandle,SetPriority);

	mov	edx, DWORD PTR _SetPriority$[ebp]
	push	edx
	mov	eax, DWORD PTR _threadhandle$[ebp]
	push	eax
	call	DWORD PTR __imp__SetThreadPriority@8
$LN17@ComAPISetR:

; 1123 : 		}
; 1124 : 	}
; 1125 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN19@ComAPISetR:
	DD	$LN9@ComAPISetR
	DD	$LN8@ComAPISetR
	DD	$LN7@ComAPISetR
	DD	$LN6@ComAPISetR
	DD	$LN5@ComAPISetR
	DD	$LN4@ComAPISetR
	DD	$LN3@ComAPISetR
_ComAPISetReceiveThreadPriority ENDP
_TEXT	ENDS
END
