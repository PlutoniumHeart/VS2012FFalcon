; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\comms\rudp.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_ComRUDPOpen
PUBLIC	_ComRUDPClose
PUBLIC	_ComRUDPSend
PUBLIC	_ComRUDPSendX
PUBLIC	_ComRUDPGet
PUBLIC	_comms_compress
PUBLIC	_comms_decompress
PUBLIC	_ComRUDPSendBufferGet
PUBLIC	_ComRUDPRecvBufferGet
PUBLIC	_ComRUDPQuery
PUBLIC	_ComRUDPGetTimeStamp
PUBLIC	_get_rudp_max_queue_length
PUBLIC	_ComRUDPOpenSendClone
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_strcpy:PROC
EXTRN	_strlen:PROC
EXTRN	_strncmp:PROC
EXTRN	_strncpy:PROC
EXTRN	_strdup:PROC
EXTRN	__imp__Sleep@4:PROC
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	__imp__FreeLibrary@4:PROC
EXTRN	__imp__IsBadWritePtr@8:PROC
EXTRN	_InitWS2:PROC
EXTRN	_comListAdd:PROC
EXTRN	_comListRemove:PROC
EXTRN	_comListGetFirstP:PROC
EXTRN	_comListGetNextP:PROC
EXTRN	_comListFindProtocolRport:PROC
EXTRN	_comListFindProtocolId:PROC
EXTRN	_use_bandwidth:PROC
EXTRN	_check_bandwidth:PROC
EXTRN	_cut_bandwidth:PROC
EXTRN	_F4IsBadReadPtrC:PROC
EXTRN	_enter_cs:PROC
EXTRN	_leave_cs:PROC
EXTRN	_ComIPHostIDGet:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_WS2Connections:DWORD
EXTRN	_hWinSockDLL:DWORD
EXTRN	_CAPI_bind:DWORD
EXTRN	_CAPI_closesocket:DWORD
EXTRN	_CAPI_ioctlsocket:DWORD
EXTRN	_CAPI_htonl:DWORD
EXTRN	_CAPI_htons:DWORD
EXTRN	_CAPI_ntohl:DWORD
EXTRN	_CAPI_ntohs:DWORD
EXTRN	_CAPI_recvfrom:DWORD
EXTRN	_CAPI_sendto:DWORD
EXTRN	_CAPI_setsockopt:DWORD
EXTRN	_CAPI_socket:DWORD
EXTRN	_CAPI_WSACleanup:DWORD
EXTRN	_CAPI_WSAGetLastError:DWORD
EXTRN	_CAPI_TimeStamp:DWORD
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
_comRecvAddr DB	010H DUP (?)
_BSS	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\rudp.c
_TEXT	SEGMENT
_addr$ = -60						; size = 4
_recverror$ = -56					; size = 4
_ch$1 = -52						; size = 4
_got_packets$ = -48					; size = 4
_id$ = -44						; size = 4
tv79 = -40						; size = 4
_ptr$ = -36						; size = 4
_curr$ = -32						; size = 4
_bytesRecvd$ = -28					; size = 4
_size$ = -24						; size = 4
_in_addr$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_cudp$ = 8						; size = 4
_get_rudp_packets PROC

; 1259 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1260 : 	int
; 1261 : 		size,
; 1262 : 		got_packets=0,

	mov	DWORD PTR _got_packets$[ebp], 0

; 1263 : 		bytesRecvd=-1,

	mov	DWORD PTR _bytesRecvd$[ebp], -1
$LN15@get_rudp_p:

; 1264 : 		recverror;
; 1265 : 	
; 1266 : 	struct sockaddr
; 1267 : 		in_addr;
; 1268 : 	
; 1269 : 	struct in_addr
; 1270 : 		addr;
; 1271 : 	
; 1272 : 	unsigned char
; 1273 : 		*ptr;
; 1274 : 
; 1275 : 	unsigned long id; // id of message owner
; 1276 : 	
; 1277 : 	ComIP *curr;
; 1278 : 	//CAPIList 
; 1279 : 	//	*curr;
; 1280 : 	
; 1281 : 	// Loop until we're out of stuff to read
; 1282 : 	while (bytesRecvd)

	cmp	DWORD PTR _bytesRecvd$[ebp], 0
	je	$LN14@get_rudp_p

; 1283 : 	{
; 1284 : 		cudp->recv_buffer.len = cudp->buffer_size;

	mov	eax, DWORD PTR _cudp$[ebp]
	mov	ecx, DWORD PTR _cudp$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR [eax+68], edx

; 1285 : 		
; 1286 : 		size =  sizeof(in_addr);	  

	mov	DWORD PTR _size$[ebp], 16		; 00000010H

; 1287 : 		
; 1288 : 		bytesRecvd = CAPI_recvfrom
; 1289 : 		(
; 1290 : 			cudp->recv_sock,
; 1291 : 			cudp->compression_buffer,
; 1292 : 			cudp->recv_buffer.len,
; 1293 : 			0,
; 1294 : 			&in_addr,
; 1295 : 			&size
; 1296 : 		);

	lea	eax, DWORD PTR _size$[ebp]
	push	eax
	lea	ecx, DWORD PTR _in_addr$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _cudp$[ebp]
	mov	eax, DWORD PTR [edx+68]
	push	eax
	mov	ecx, DWORD PTR _cudp$[ebp]
	mov	edx, DWORD PTR [ecx+476]
	push	edx
	mov	eax, DWORD PTR _cudp$[ebp]
	mov	ecx, DWORD PTR [eax+516]
	push	ecx
	call	DWORD PTR _CAPI_recvfrom
	mov	DWORD PTR _bytesRecvd$[ebp], eax

; 1297 : 
; 1298 : 		if (bytesRecvd == SOCKET_ERROR)

	cmp	DWORD PTR _bytesRecvd$[ebp], -1
	jne	SHORT $LN13@get_rudp_p

; 1299 : 		{
; 1300 : 			recverror = CAPI_WSAGetLastError();

	call	DWORD PTR _CAPI_WSAGetLastError
	mov	DWORD PTR _recverror$[ebp], eax

; 1301 : 			
; 1302 : 			switch(recverror)

	mov	edx, DWORD PTR _recverror$[ebp]
	mov	DWORD PTR tv79[ebp], edx
	mov	eax, DWORD PTR tv79[ebp]
	sub	eax, 10004				; 00002714H
	mov	DWORD PTR tv79[ebp], eax
	cmp	DWORD PTR tv79[ebp], 89			; 00000059H
	ja	SHORT $LN8@get_rudp_p
	mov	ecx, DWORD PTR tv79[ebp]
	movzx	edx, BYTE PTR $LN20@get_rudp_p[ecx]
	jmp	DWORD PTR $LN21@get_rudp_p[edx*4]
$LN10@get_rudp_p:

; 1303 : 			{
; 1304 : 				case WSANOTINITIALISED:
; 1305 : 				case WSAENETDOWN:
; 1306 : 				case WSAEFAULT:
; 1307 : 				case WSAENOTCONN:
; 1308 : 				case WSAEINTR:
; 1309 : 				case WSAEINPROGRESS:
; 1310 : 				case WSAENETRESET:
; 1311 : 				case WSAENOTSOCK:
; 1312 : 				case WSAEOPNOTSUPP:
; 1313 : 				case WSAESHUTDOWN:
; 1314 : 					return 0;

	xor	eax, eax
	jmp	$LN16@get_rudp_p
$LN9@get_rudp_p:

; 1315 : 
; 1316 : 				case WSAEWOULDBLOCK:
; 1317 : 					cudp->recvwouldblockcount++;

	mov	eax, DWORD PTR _cudp$[ebp]
	mov	ecx, DWORD PTR [eax+528]
	add	ecx, 1
	mov	edx, DWORD PTR _cudp$[ebp]
	mov	DWORD PTR [edx+528], ecx

; 1318 : 					return 0;

	xor	eax, eax
	jmp	$LN16@get_rudp_p
$LN8@get_rudp_p:

; 1319 : 
; 1320 : 				case WSAEMSGSIZE:
; 1321 : 				case WSAEINVAL:
; 1322 : 				case WSAECONNABORTED:
; 1323 : 				case WSAETIMEDOUT:
; 1324 : 				case WSAECONNRESET:
; 1325 : 				default :
; 1326 : 					return 0;

	xor	eax, eax
	jmp	$LN16@get_rudp_p
$LN13@get_rudp_p:

; 1327 : 			}
; 1328 : 		}
; 1329 : 		
; 1330 : 		if (bytesRecvd == 0)

	cmp	DWORD PTR _bytesRecvd$[ebp], 0
	jne	SHORT $LN7@get_rudp_p

; 1331 : 		{
; 1332 : 			return 0;

	xor	eax, eax
	jmp	$LN16@get_rudp_p
$LN7@get_rudp_p:

; 1333 : 		}
; 1334 : 
; 1335 : 		if (*(u_short*)cudp->compression_buffer <= 700)

	mov	eax, DWORD PTR _cudp$[ebp]
	mov	ecx, DWORD PTR [eax+476]
	movzx	edx, WORD PTR [ecx]
	cmp	edx, 700				; 000002bcH
	jg	SHORT $LN6@get_rudp_p

; 1336 : 		{
; 1337 : 			memcpy(&size, cudp->compression_buffer, sizeof(u_short));

	push	2
	mov	eax, DWORD PTR _cudp$[ebp]
	mov	ecx, DWORD PTR [eax+476]
	push	ecx
	lea	edx, DWORD PTR _size$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1338 : 			comms_decompress (cudp->compression_buffer + sizeof(u_short), cudp->recv_buffer.buf, size);

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cudp$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	push	edx
	mov	eax, DWORD PTR _cudp$[ebp]
	mov	ecx, DWORD PTR [eax+476]
	add	ecx, 2
	push	ecx
	call	_comms_decompress
	add	esp, 12					; 0000000cH

; 1339 : 			cudp->recv_buffer.len = size;

	mov	edx, DWORD PTR _cudp$[ebp]
	mov	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR [edx+68], eax

; 1340 : 			bytesRecvd = size;

	mov	ecx, DWORD PTR _size$[ebp]
	mov	DWORD PTR _bytesRecvd$[ebp], ecx

; 1341 : 		}
; 1342 : 		else

	jmp	SHORT $LN5@get_rudp_p
$LN6@get_rudp_p:

; 1343 : 		{
; 1344 : 			memcpy (cudp->recv_buffer.buf, cudp->compression_buffer, bytesRecvd);

	mov	edx, DWORD PTR _bytesRecvd$[ebp]
	push	edx
	mov	eax, DWORD PTR _cudp$[ebp]
	mov	ecx, DWORD PTR [eax+476]
	push	ecx
	mov	edx, DWORD PTR _cudp$[ebp]
	mov	eax, DWORD PTR [edx+72]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1345 : 			cudp->recv_buffer.len = bytesRecvd;

	mov	ecx, DWORD PTR _cudp$[ebp]
	mov	edx, DWORD PTR _bytesRecvd$[ebp]
	mov	DWORD PTR [ecx+68], edx
$LN5@get_rudp_p:

; 1346 : 		}
; 1347 : 
; 1348 : 		/*// sfr: added port info
; 1349 : 		if (
; 1350 : 			(((struct sockaddr_in *)(&in_addr))->sin_addr.s_addr == cudp->whoami) &&
; 1351 : 			((struct sockaddr_in *)(&in_addr))->sin_port == CAPI_htons(ComAPIGetMySendPort())
; 1352 : 		){*/
; 1353 : 		id = ((ComAPIHeader *)cudp->recv_buffer.buf)->id;

	mov	eax, DWORD PTR _cudp$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _id$[ebp], edx

; 1354 : 		if (id == cudp->whoami){

	mov	eax, DWORD PTR _cudp$[ebp]
	mov	ecx, DWORD PTR _id$[ebp]
	cmp	ecx, DWORD PTR [eax+580]
	jne	SHORT $LN4@get_rudp_p

; 1355 : 			/* From ourself */
; 1356 : 			continue;

	jmp	$LN15@get_rudp_p
$LN4@get_rudp_p:

; 1357 : 		}
; 1358 : 		//sfr: query stuff
; 1359 : 		// moved below
; 1360 : 		//cudp->lastsender = ((struct sockaddr_in*)&in_addr)->sin_addr.s_addr;
; 1361 : 		//cudp->lastsenderport = ((struct sockaddr_in*)&in_addr)->sin_port;
; 1362 : 
; 1363 : 		size = bytesRecvd;

	mov	edx, DWORD PTR _bytesRecvd$[ebp]
	mov	DWORD PTR _size$[ebp], edx

; 1364 : 		ptr = (unsigned char *)cudp->recv_buffer.buf;

	mov	eax, DWORD PTR _cudp$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	DWORD PTR _ptr$[ebp], ecx

; 1365 : 		{
; 1366 : 			ComAPIHeader *ch = (ComAPIHeader *)ptr;		

	mov	edx, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR _ch$1[ebp], edx

; 1367 : 			// Trim off ComAPIHeader
; 1368 : 			if (strncmp(ch->gamename, ((ComAPIHeader *)cudp->rudp_data.real_send_buffer)->gamename, GAME_NAME_LENGTH))

	push	4
	mov	eax, DWORD PTR _cudp$[ebp]
	mov	ecx, DWORD PTR [eax+712]
	push	ecx
	mov	edx, DWORD PTR _ch$1[ebp]
	push	edx
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN3@get_rudp_p

; 1369 : 			{
; 1370 : 				/* Not a good header */
; 1371 : 				continue;

	jmp	$LN15@get_rudp_p
$LN3@get_rudp_p:

; 1372 : 			}
; 1373 : 		}		
; 1374 : 		ptr += sizeof(ComAPIHeader);

	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, 8
	mov	DWORD PTR _ptr$[ebp], eax

; 1375 : 		size -= sizeof(ComAPIHeader);

	mov	ecx, DWORD PTR _size$[ebp]
	sub	ecx, 8
	mov	DWORD PTR _size$[ebp], ecx

; 1376 : 		
; 1377 : 		// Find who sent it and add to their queue
; 1378 : 		addr = ((struct sockaddr_in*)(&in_addr))->sin_addr;

	mov	edx, DWORD PTR _in_addr$[ebp+4]
	mov	DWORD PTR _addr$[ebp], edx

; 1379 : 		enter_cs(); // JPO

	call	_enter_cs

; 1380 : 		// sfr: chicken egg prob
; 1381 : 		// try to match a given IP or a session with no rudp port set yet
; 1382 : 		if (
; 1383 : 			(curr = comListFindProtocolId(CAPI_RUDP_PROTOCOL, CAPI_ntohl(id)))
; 1384 : 		){

	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	call	DWORD PTR _CAPI_ntohl
	push	eax
	push	10					; 0000000aH
	call	_comListFindProtocolId
	add	esp, 8
	mov	DWORD PTR _curr$[ebp], eax
	cmp	DWORD PTR _curr$[ebp], 0
	je	SHORT $LN2@get_rudp_p

; 1385 : 			// query stuff
; 1386 : 			curr->lastsenderid = id;

	mov	ecx, DWORD PTR _curr$[ebp]
	mov	edx, DWORD PTR _id$[ebp]
	mov	DWORD PTR [ecx+596], edx

; 1387 : 			curr->lastsender = ((struct sockaddr_in*)&in_addr)->sin_addr.s_addr;

	mov	eax, DWORD PTR _curr$[ebp]
	mov	ecx, DWORD PTR _in_addr$[ebp+4]
	mov	DWORD PTR [eax+588], ecx

; 1388 : 			curr->lastsenderport = ((struct sockaddr_in*)&in_addr)->sin_port;

	movzx	edx, WORD PTR _in_addr$[ebp+2]
	mov	eax, DWORD PTR _curr$[ebp]
	mov	DWORD PTR [eax+592], edx

; 1389 : 			if (add_to_receive_queue(curr, ptr, size)){

	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _curr$[ebp]
	push	eax
	call	_add_to_receive_queue
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN2@get_rudp_p

; 1390 : 				got_packets++;

	mov	ecx, DWORD PTR _got_packets$[ebp]
	add	ecx, 1
	mov	DWORD PTR _got_packets$[ebp], ecx
$LN2@get_rudp_p:

; 1391 : 			}
; 1392 : 		}
; 1393 : 
; 1394 : 		leave_cs();

	call	_leave_cs

; 1395 : 		// check if we were able to dispatch it.
; 1396 : 		// assert (curr);
; 1397 : 	}

	jmp	$LN15@get_rudp_p
$LN14@get_rudp_p:

; 1398 : 	
; 1399 : 	return got_packets;

	mov	eax, DWORD PTR _got_packets$[ebp]
$LN16@get_rudp_p:

; 1400 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN21@get_rudp_p:
	DD	$LN10@get_rudp_p
	DD	$LN9@get_rudp_p
	DD	$LN8@get_rudp_p
$LN20@get_rudp_p:
	DB	0
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	0
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	1
	DB	0
	DB	2
	DB	0
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	0
	DB	2
	DB	2
	DB	2
	DB	2
	DB	0
	DB	2
	DB	0
	DB	2
	DB	2
	DB	2
	DB	2
	DB	0
	DB	0
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	0
_get_rudp_packets ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\rudp.c
_TEXT	SEGMENT
_np$ = -28						; size = 4
tv73 = -24						; size = 4
_lp$ = -20						; size = 4
_count$ = -16						; size = 4
_cp$ = -12						; size = 4
_rp$ = -8						; size = 4
_flags$ = -1						; size = 1
_cudp$ = 8						; size = 4
_ptr$ = 12						; size = 4
_size$ = 16						; size = 4
_add_to_receive_queue PROC

; 900  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 901  : 	int count;
; 902  : //		bytesRecvd=-1;
; 903  : 	
; 904  : //	unsigned short
; 905  : //		ack;
; 906  : 	
; 907  : 	unsigned char flags;
; 908  : 	
; 909  : 	Reliable_Packet *cp, *lp, *np, *rp;
; 910  : 	
; 911  : 	// Trim off the flags
; 912  : 	flags = *ptr;

	mov	eax, DWORD PTR _ptr$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _flags$[ebp], cl

; 913  : 	ptr ++;

	mov	edx, DWORD PTR _ptr$[ebp]
	add	edx, 1
	mov	DWORD PTR _ptr$[ebp], edx

; 914  : 	size --;

	mov	eax, DWORD PTR _size$[ebp]
	sub	eax, 1
	mov	DWORD PTR _size$[ebp], eax

; 915  : 	
; 916  : 	cudp->rudp_data.last_ping_recv_time = GetTickCount ();

	call	DWORD PTR __imp__GetTickCount@0
	mov	ecx, DWORD PTR _cudp$[ebp]
	mov	DWORD PTR [ecx+708], eax

; 917  : 
; 918  : 	if (flags & RUDPF_RESET)

	movzx	edx, BYTE PTR _flags$[ebp]
	and	edx, 128				; 00000080H
	je	$LN52@add_to_rec

; 919  : 	{
; 920  : //		MonoPrint ("Recv %d\n", flags & RUDPF_MASK);
; 921  : 
; 922  : 		switch (flags & 0x0f)

	movzx	eax, BYTE PTR _flags$[ebp]
	and	eax, 15					; 0000000fH
	mov	DWORD PTR tv73[ebp], eax
	cmp	DWORD PTR tv73[ebp], 7
	ja	$LN50@add_to_rec
	mov	ecx, DWORD PTR tv73[ebp]
	jmp	DWORD PTR $LN55@add_to_rec[ecx*4]
$LN49@add_to_rec:

; 923  : 		{
; 924  : 			case RUDP_RESET_REQ:
; 925  : 			{
; 926  : 				if (cudp->rudp_data.reset_send == RUDP_WORKING)

	mov	edx, DWORD PTR _cudp$[ebp]
	cmp	DWORD PTR [edx+628], 5
	jne	SHORT $LN48@add_to_rec

; 927  : 				{
; 928  : 					cudp->rudp_data.reset_send = RUDP_EXIT;

	mov	eax, DWORD PTR _cudp$[ebp]
	mov	DWORD PTR [eax+628], 6
$LN48@add_to_rec:

; 929  : 				}
; 930  : 				
; 931  : 				cudp->rudp_data.reset_send = RUDP_RESET_ACK;

	mov	ecx, DWORD PTR _cudp$[ebp]
	mov	DWORD PTR [ecx+628], 1

; 932  : 				cudp->rudp_data.last_send_time = 0;

	mov	edx, DWORD PTR _cudp$[ebp]
	mov	DWORD PTR [edx+660], 0

; 933  : 				cudp->rudp_data.last_oob_send_time = 0;

	mov	eax, DWORD PTR _cudp$[ebp]
	mov	DWORD PTR [eax+700], 0

; 934  : 				send_rudp_packet (cudp, NULL, 0);

	push	0
	push	0
	mov	ecx, DWORD PTR _cudp$[ebp]
	push	ecx
	call	_send_rudp_packet
	add	esp, 12					; 0000000cH

; 935  : 				send_rudp_packet (cudp, NULL, 0);

	push	0
	push	0
	mov	edx, DWORD PTR _cudp$[ebp]
	push	edx
	call	_send_rudp_packet
	add	esp, 12					; 0000000cH

; 936  : 				send_rudp_packet (cudp, NULL, 0);

	push	0
	push	0
	mov	eax, DWORD PTR _cudp$[ebp]
	push	eax
	call	_send_rudp_packet
	add	esp, 12					; 0000000cH

; 937  : 				break;

	jmp	$LN50@add_to_rec
$LN47@add_to_rec:

; 938  : 			}
; 939  : 
; 940  : 			case RUDP_RESET_ACK:
; 941  : 			{
; 942  : 				cudp->rudp_data.reset_send = RUDP_RESET_OK;

	mov	ecx, DWORD PTR _cudp$[ebp]
	mov	DWORD PTR [ecx+628], 2

; 943  : 				cudp->rudp_data.last_send_time = 0;

	mov	edx, DWORD PTR _cudp$[ebp]
	mov	DWORD PTR [edx+660], 0

; 944  : 				cudp->rudp_data.last_oob_send_time = 0;

	mov	eax, DWORD PTR _cudp$[ebp]
	mov	DWORD PTR [eax+700], 0

; 945  : 				send_rudp_packet (cudp, NULL, 0);

	push	0
	push	0
	mov	ecx, DWORD PTR _cudp$[ebp]
	push	ecx
	call	_send_rudp_packet
	add	esp, 12					; 0000000cH

; 946  : 				send_rudp_packet (cudp, NULL, 0);

	push	0
	push	0
	mov	edx, DWORD PTR _cudp$[ebp]
	push	edx
	call	_send_rudp_packet
	add	esp, 12					; 0000000cH

; 947  : 				send_rudp_packet (cudp, NULL, 0);

	push	0
	push	0
	mov	eax, DWORD PTR _cudp$[ebp]
	push	eax
	call	_send_rudp_packet
	add	esp, 12					; 0000000cH

; 948  : 				cudp->rudp_data.reset_send = RUDP_WORKING;

	mov	ecx, DWORD PTR _cudp$[ebp]
	mov	DWORD PTR [ecx+628], 5

; 949  : 				break;

	jmp	SHORT $LN50@add_to_rec
$LN46@add_to_rec:

; 950  : 			}
; 951  : 
; 952  : 			case RUDP_RESET_OK:
; 953  : 			{
; 954  : 				cudp->rudp_data.reset_send = RUDP_WORKING;

	mov	edx, DWORD PTR _cudp$[ebp]
	mov	DWORD PTR [edx+628], 5

; 955  : 				break;

	jmp	SHORT $LN50@add_to_rec

; 956  : 			}
; 957  : 
; 958  : 			case RUDP_PING:
; 959  : 			{
; 960  : 				// This is just sent to fill up some bandwidth
; 961  : 				// the code below is done for all received packets
; 962  : 
; 963  : 				//cudp->rudp_data.last_ping_recv_time = GetTickCount ();
; 964  : 
; 965  : 				break;

	jmp	SHORT $LN50@add_to_rec
$LN44@add_to_rec:

; 966  : 			}
; 967  : 
; 968  : 			case RUDP_EXIT:
; 969  : 			{
; 970  : 				cudp->rudp_data.reset_send = RUDP_EXIT;

	mov	eax, DWORD PTR _cudp$[ebp]
	mov	DWORD PTR [eax+628], 6

; 971  : 				cudp->rudp_data.last_send_time = 0;

	mov	ecx, DWORD PTR _cudp$[ebp]
	mov	DWORD PTR [ecx+660], 0

; 972  : 				cudp->rudp_data.last_oob_send_time = 0;

	mov	edx, DWORD PTR _cudp$[ebp]
	mov	DWORD PTR [edx+700], 0

; 973  : 				send_rudp_packet (cudp, NULL, 0);

	push	0
	push	0
	mov	eax, DWORD PTR _cudp$[ebp]
	push	eax
	call	_send_rudp_packet
	add	esp, 12					; 0000000cH

; 974  : 				break;

	jmp	SHORT $LN50@add_to_rec
$LN43@add_to_rec:

; 975  : 			}
; 976  : 
; 977  : 			case RUDP_DROP:
; 978  : 			{
; 979  : 				if (cudp->rudp_data.reset_send == RUDP_WORKING)

	mov	ecx, DWORD PTR _cudp$[ebp]
	cmp	DWORD PTR [ecx+628], 5
	jne	SHORT $LN50@add_to_rec

; 980  : 				{
; 981  : 					cudp->rudp_data.reset_send = RUDP_DROP;

	mov	edx, DWORD PTR _cudp$[ebp]
	mov	DWORD PTR [edx+628], 7
$LN50@add_to_rec:

; 982  : 				}
; 983  : 				break;
; 984  : 			}
; 985  : 		}
; 986  : 
; 987  : 		return 0;

	xor	eax, eax
	jmp	$LN53@add_to_rec
$LN52@add_to_rec:

; 988  : 	}
; 989  : 
; 990  : 	if (cudp->rudp_data.reset_send != RUDP_WORKING)

	mov	eax, DWORD PTR _cudp$[ebp]
	cmp	DWORD PTR [eax+628], 5
	je	SHORT $LN41@add_to_rec

; 991  : 	{
; 992  : 		return 0;

	xor	eax, eax
	jmp	$LN53@add_to_rec
$LN41@add_to_rec:

; 993  : 	}
; 994  : 
; 995  : 	count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 996  : 	if (flags & RUDPF_LAST)

	movzx	ecx, BYTE PTR _flags$[ebp]
	and	ecx, 16					; 00000010H
	je	SHORT $LN40@add_to_rec

; 997  : 	{
; 998  : 		count += 2;

	mov	edx, DWORD PTR _count$[ebp]
	add	edx, 2
	mov	DWORD PTR _count$[ebp], edx
$LN40@add_to_rec:

; 999  : 	}
; 1000 : 
; 1001 : 	if (flags & RUDPF_LOOB)

	movzx	eax, BYTE PTR _flags$[ebp]
	and	eax, 8
	je	SHORT $LN39@add_to_rec

; 1002 : 	{
; 1003 : 		count += 2;

	mov	ecx, DWORD PTR _count$[ebp]
	add	ecx, 2
	mov	DWORD PTR _count$[ebp], ecx
$LN39@add_to_rec:

; 1004 : 	}
; 1005 : 
; 1006 : //	if (flags & RUDPF_MASK)
; 1007 : //	{
; 1008 : //		count += 2 * (flags & RUDPF_MASK);
; 1009 : //	}
; 1010 : 	// 2003-09-27 Fix by Will Mulvihill - RUDPF_SEQ is a 2 byte message - see above line 694 - size = short = 2...
; 1011 : 	if (flags & RUDPF_SEQ)

	movzx	edx, BYTE PTR _flags$[ebp]
	and	edx, 32					; 00000020H
	je	SHORT $LN38@add_to_rec

; 1012 : 	{
; 1013 : 		//count += 4;
; 1014 : 		count += 2;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 2
	mov	DWORD PTR _count$[ebp], eax
$LN38@add_to_rec:

; 1015 : 	}
; 1016 : 
; 1017 : 	if (flags & RUDPF_MSG)

	movzx	ecx, BYTE PTR _flags$[ebp]
	and	ecx, 4
	je	SHORT $LN37@add_to_rec

; 1018 : 	{
; 1019 : 		count += 4;

	mov	edx, DWORD PTR _count$[ebp]
	add	edx, 4
	mov	DWORD PTR _count$[ebp], edx
$LN37@add_to_rec:

; 1020 : 	}
; 1021 : 
; 1022 : 	if (count > size)

	mov	eax, DWORD PTR _count$[ebp]
	cmp	eax, DWORD PTR _size$[ebp]
	jle	SHORT $LN36@add_to_rec

; 1023 : 	{
; 1024 : 		return 0;

	xor	eax, eax
	jmp	$LN53@add_to_rec
$LN36@add_to_rec:

; 1025 : 	}
; 1026 : 
; 1027 : 	// Trim off last_sequence number received by remote
; 1028 : 	if (flags & RUDPF_LAST)

	movzx	ecx, BYTE PTR _flags$[ebp]
	and	ecx, 16					; 00000010H
	je	SHORT $LN35@add_to_rec

; 1029 : 	{
; 1030 : 		cudp->rudp_data.last_sequence = (*(unsigned short *) ptr) & 0xffff;

	mov	edx, DWORD PTR _ptr$[ebp]
	movzx	eax, WORD PTR [edx]
	and	eax, 65535				; 0000ffffH
	mov	ecx, DWORD PTR _cudp$[ebp]
	mov	DWORD PTR [ecx+632], eax

; 1031 : 		ptr += sizeof(short);

	mov	edx, DWORD PTR _ptr$[ebp]
	add	edx, 2
	mov	DWORD PTR _ptr$[ebp], edx

; 1032 : 		size -= sizeof(short);

	mov	eax, DWORD PTR _size$[ebp]
	sub	eax, 2
	mov	DWORD PTR _size$[ebp], eax
$LN35@add_to_rec:

; 1033 : 	}
; 1034 : 	
; 1035 : 	if (flags & RUDPF_LOOB)

	movzx	ecx, BYTE PTR _flags$[ebp]
	and	ecx, 8
	je	SHORT $LN34@add_to_rec

; 1036 : 	{
; 1037 : 		cudp->rudp_data.last_oob_sequence = (*(unsigned short *) ptr) & 0xffff;

	mov	edx, DWORD PTR _ptr$[ebp]
	movzx	eax, WORD PTR [edx]
	and	eax, 65535				; 0000ffffH
	mov	ecx, DWORD PTR _cudp$[ebp]
	mov	DWORD PTR [ecx+672], eax

; 1038 : 		ptr += sizeof(short);

	mov	edx, DWORD PTR _ptr$[ebp]
	add	edx, 2
	mov	DWORD PTR _ptr$[ebp], edx

; 1039 : 		size -= sizeof(short);

	mov	eax, DWORD PTR _size$[ebp]
	sub	eax, 2
	mov	DWORD PTR _size$[ebp], eax
$LN34@add_to_rec:

; 1040 : 	}
; 1041 : 	
; 1042 : //	if (flags & RUDPF_MASK)
; 1043 : //	{
; 1044 : //		count = flags & RUDPF_MASK;
; 1045 : //		
; 1046 : //		while (count)
; 1047 : //		{
; 1048 : //			ack = *(short *) ptr;
; 1049 : //			
; 1050 : //			cp = cudp->rudp_data.sending;
; 1051 : //			
; 1052 : //			while (cp)
; 1053 : //			{
; 1054 : //				if (cp->sequence_number == ack)
; 1055 : //				{
; 1056 : //					cp->acknowledged = TRUE;
; 1057 : //					break;
; 1058 : //				}
; 1059 : //				
; 1060 : //				cp = cp->next;
; 1061 : //			}
; 1062 : //			
; 1063 : //			ptr += sizeof (short);
; 1064 : //			size -= sizeof (short);
; 1065 : //			
; 1066 : //			count --;
; 1067 : //		}
; 1068 : //	}
; 1069 : 	
; 1070 : 	// Trim off the sequence number
; 1071 : 	if (flags & RUDPF_SEQ)

	movzx	ecx, BYTE PTR _flags$[ebp]
	and	ecx, 32					; 00000020H
	je	$LN33@add_to_rec

; 1072 : 	{
; 1073 : 		// Fail early if we've seen this packet before
; 1074 : 		if (flags & RUDPF_OOB)

	movzx	edx, BYTE PTR _flags$[ebp]
	and	edx, 64					; 00000040H
	je	SHORT $LN32@add_to_rec

; 1075 : 		{
; 1076 : 			if ((*(unsigned short*)ptr - ((cudp->rudp_data.last_oob_received + 1) & 0xffff)) & 0x8000)

	mov	eax, DWORD PTR _ptr$[ebp]
	movzx	ecx, WORD PTR [eax]
	mov	edx, DWORD PTR _cudp$[ebp]
	mov	eax, DWORD PTR [edx+676]
	add	eax, 1
	and	eax, 65535				; 0000ffffH
	sub	ecx, eax
	and	ecx, 32768				; 00008000H
	je	SHORT $LN31@add_to_rec

; 1077 : 			{
; 1078 : 				cudp->rudp_data.last_oob_sent_received = -1;

	mov	ecx, DWORD PTR _cudp$[ebp]
	mov	DWORD PTR [ecx+680], -1

; 1079 : 				return size;

	mov	eax, DWORD PTR _size$[ebp]
	jmp	$LN53@add_to_rec
$LN31@add_to_rec:

; 1080 : 			}
; 1081 : 
; 1082 : 			cudp->rudp_data.send_oob_ack = TRUE;

	mov	edx, DWORD PTR _cudp$[ebp]
	mov	DWORD PTR [edx+684], 1

; 1083 : 		}
; 1084 : 		else

	jmp	SHORT $LN30@add_to_rec
$LN32@add_to_rec:

; 1085 : 		{
; 1086 : 			if ((*(unsigned short*)ptr - ((cudp->rudp_data.last_received + 1) & 0xffff)) & 0x8000)

	mov	eax, DWORD PTR _ptr$[ebp]
	movzx	ecx, WORD PTR [eax]
	mov	edx, DWORD PTR _cudp$[ebp]
	mov	eax, DWORD PTR [edx+636]
	add	eax, 1
	and	eax, 65535				; 0000ffffH
	sub	ecx, eax
	and	ecx, 32768				; 00008000H
	je	SHORT $LN29@add_to_rec

; 1087 : 			{
; 1088 : 				cudp->rudp_data.last_sent_received = -1;

	mov	ecx, DWORD PTR _cudp$[ebp]
	mov	DWORD PTR [ecx+640], -1

; 1089 : 				return size;

	mov	eax, DWORD PTR _size$[ebp]
	jmp	$LN53@add_to_rec
$LN29@add_to_rec:

; 1090 : 			}
; 1091 : 
; 1092 : 			cudp->rudp_data.send_ack = TRUE;

	mov	edx, DWORD PTR _cudp$[ebp]
	mov	DWORD PTR [edx+644], 1
$LN30@add_to_rec:

; 1093 : 		}
; 1094 : 
; 1095 : 		rp = malloc(sizeof(Reliable_Packet));

	push	24					; 00000018H
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _rp$[ebp], eax

; 1096 : 		rp->sequence_number = *(unsigned short*)ptr;

	mov	eax, DWORD PTR _rp$[ebp]
	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	dx, WORD PTR [ecx]
	mov	WORD PTR [eax+4], dx

; 1097 : 		rp->dispatched = FALSE;

	mov	eax, DWORD PTR _rp$[ebp]
	mov	BYTE PTR [eax+14], 0

; 1098 : 		rp->acknowledged = FALSE;

	mov	ecx, DWORD PTR _rp$[ebp]
	mov	BYTE PTR [ecx+15], 0

; 1099 : 		rp->send_count = 0;

	mov	edx, DWORD PTR _rp$[ebp]
	mov	BYTE PTR [edx+10], 0

; 1100 : 		rp->data = NULL;

	mov	eax, DWORD PTR _rp$[ebp]
	mov	DWORD PTR [eax+16], 0

; 1101 : 		rp->next = NULL;

	mov	ecx, DWORD PTR _rp$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 1102 : 
; 1103 : 		if (flags & RUDPF_OOB)

	movzx	edx, BYTE PTR _flags$[ebp]
	and	edx, 64					; 00000040H
	je	SHORT $LN28@add_to_rec

; 1104 : 		{
; 1105 : 			rp->oob = TRUE;

	mov	eax, DWORD PTR _rp$[ebp]
	mov	BYTE PTR [eax+11], 1

; 1106 : 		}
; 1107 : 		else

	jmp	SHORT $LN27@add_to_rec
$LN28@add_to_rec:

; 1108 : 		{
; 1109 : 			rp->oob = FALSE;

	mov	ecx, DWORD PTR _rp$[ebp]
	mov	BYTE PTR [ecx+11], 0
$LN27@add_to_rec:

; 1110 : 		}
; 1111 : 
; 1112 : 		ptr += sizeof(short);

	mov	edx, DWORD PTR _ptr$[ebp]
	add	edx, 2
	mov	DWORD PTR _ptr$[ebp], edx

; 1113 : 		size -= sizeof(short);

	mov	eax, DWORD PTR _size$[ebp]
	sub	eax, 2
	mov	DWORD PTR _size$[ebp], eax

; 1114 : 	}
; 1115 : 	else

	jmp	SHORT $LN26@add_to_rec
$LN33@add_to_rec:

; 1116 : 	{
; 1117 : 		rp = NULL;

	mov	DWORD PTR _rp$[ebp], 0
$LN26@add_to_rec:

; 1118 : 	}
; 1119 : 	
; 1120 : 	// Trim off the message data, if any
; 1121 : 	if (flags & RUDPF_MSG)

	movzx	ecx, BYTE PTR _flags$[ebp]
	and	ecx, 4
	je	SHORT $LN25@add_to_rec

; 1122 : 	{
; 1123 : 		assert (rp);
; 1124 : 		rp->message_number = *(unsigned short *)ptr;

	mov	edx, DWORD PTR _rp$[ebp]
	mov	eax, DWORD PTR _ptr$[ebp]
	mov	cx, WORD PTR [eax]
	mov	WORD PTR [edx+6], cx

; 1125 : 		ptr += sizeof(unsigned short);

	mov	edx, DWORD PTR _ptr$[ebp]
	add	edx, 2
	mov	DWORD PTR _ptr$[ebp], edx

; 1126 : 		size -= sizeof(unsigned short);

	mov	eax, DWORD PTR _size$[ebp]
	sub	eax, 2
	mov	DWORD PTR _size$[ebp], eax

; 1127 : 		rp->message_slot = *ptr;

	mov	ecx, DWORD PTR _rp$[ebp]
	mov	edx, DWORD PTR _ptr$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx+12], al

; 1128 : 		ptr ++;

	mov	ecx, DWORD PTR _ptr$[ebp]
	add	ecx, 1
	mov	DWORD PTR _ptr$[ebp], ecx

; 1129 : 		size --;

	mov	edx, DWORD PTR _size$[ebp]
	sub	edx, 1
	mov	DWORD PTR _size$[ebp], edx

; 1130 : 		rp->message_parts = *ptr;

	mov	eax, DWORD PTR _rp$[ebp]
	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax+13], dl

; 1131 : 		ptr ++;

	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, 1
	mov	DWORD PTR _ptr$[ebp], eax

; 1132 : 		size --;

	mov	ecx, DWORD PTR _size$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _size$[ebp], ecx
	jmp	SHORT $LN24@add_to_rec
$LN25@add_to_rec:

; 1133 : 	}
; 1134 : 	else if (rp)

	cmp	DWORD PTR _rp$[ebp], 0
	je	SHORT $LN24@add_to_rec

; 1135 : 	{
; 1136 : 		rp->message_number = 0;

	xor	edx, edx
	mov	eax, DWORD PTR _rp$[ebp]
	mov	WORD PTR [eax+6], dx

; 1137 : 		rp->message_slot = 0;

	mov	ecx, DWORD PTR _rp$[ebp]
	mov	BYTE PTR [ecx+12], 0

; 1138 : 		rp->message_parts = 1;

	mov	edx, DWORD PTR _rp$[ebp]
	mov	BYTE PTR [edx+13], 1
$LN24@add_to_rec:

; 1139 : 	}
; 1140 : 	
; 1141 : 	// Trim off the data
; 1142 : 	if (flags & RUDPF_SEQ)

	movzx	eax, BYTE PTR _flags$[ebp]
	and	eax, 32					; 00000020H
	je	SHORT $LN22@add_to_rec

; 1143 : 	{
; 1144 : 		assert (rp);
; 1145 : 		rp->size = (unsigned short)size;

	mov	ecx, DWORD PTR _rp$[ebp]
	mov	dx, WORD PTR _size$[ebp]
	mov	WORD PTR [ecx+8], dx

; 1146 : 		rp->data = (char*)malloc(size);

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _rp$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1147 : 		memcpy(rp->data, ptr, size);

	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	mov	eax, DWORD PTR _ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rp$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1148 : 		
; 1149 : 		if (CAPI_TimeStamp)

	cmp	DWORD PTR _CAPI_TimeStamp, 0
	je	SHORT $LN21@add_to_rec

; 1150 : 		{
; 1151 : 			cudp->timestamp = CAPI_TimeStamp();

	call	DWORD PTR _CAPI_TimeStamp
	mov	ecx, DWORD PTR _cudp$[ebp]
	mov	DWORD PTR [ecx+600], eax
$LN21@add_to_rec:

; 1152 : 		}
; 1153 : 	}
; 1154 : 	else

	jmp	SHORT $LN20@add_to_rec
$LN22@add_to_rec:

; 1155 : 	{
; 1156 : 		assert (size == 0);
; 1157 : 		return 0;

	xor	eax, eax
	jmp	$LN53@add_to_rec
$LN20@add_to_rec:

; 1158 : 	}
; 1159 : 	
; 1160 : 	if (!size || !rp)

	cmp	DWORD PTR _size$[ebp], 0
	je	SHORT $LN18@add_to_rec
	cmp	DWORD PTR _rp$[ebp], 0
	jne	SHORT $LN19@add_to_rec
$LN18@add_to_rec:

; 1161 : 	{
; 1162 : 		return 0;

	xor	eax, eax
	jmp	$LN53@add_to_rec
$LN19@add_to_rec:

; 1163 : 	}
; 1164 : 	
; 1165 : 	// Add the new packet to the receiving queue at the right place
; 1166 : 	lp = np = NULL;

	mov	DWORD PTR _np$[ebp], 0
	mov	edx, DWORD PTR _np$[ebp]
	mov	DWORD PTR _lp$[ebp], edx

; 1167 : 	if (rp->oob)

	mov	eax, DWORD PTR _rp$[ebp]
	movzx	ecx, BYTE PTR [eax+11]
	test	ecx, ecx
	je	SHORT $LN17@add_to_rec

; 1168 : 	{
; 1169 : 		cp = cudp->rudp_data.oob_receiving;

	mov	edx, DWORD PTR _cudp$[ebp]
	mov	eax, DWORD PTR [edx+692]
	mov	DWORD PTR _cp$[ebp], eax

; 1170 : 	}
; 1171 : 	else

	jmp	SHORT $LN15@add_to_rec
$LN17@add_to_rec:

; 1172 : 	{
; 1173 : 		cp = cudp->rudp_data.receiving;

	mov	ecx, DWORD PTR _cudp$[ebp]
	mov	edx, DWORD PTR [ecx+652]
	mov	DWORD PTR _cp$[ebp], edx
$LN15@add_to_rec:

; 1174 : 	}
; 1175 : 
; 1176 : 	while (cp)

	cmp	DWORD PTR _cp$[ebp], 0
	je	$LN14@add_to_rec

; 1177 : 	{
; 1178 : 		// Don't store the packet if we have already seen it, or its before
; 1179 : 		// first known good packet
; 1180 : 		if (cp->sequence_number == rp->sequence_number)

	mov	eax, DWORD PTR _cp$[ebp]
	movzx	ecx, WORD PTR [eax+4]
	mov	edx, DWORD PTR _rp$[ebp]
	movzx	eax, WORD PTR [edx+4]
	cmp	ecx, eax
	jne	SHORT $LN13@add_to_rec

; 1181 : 		{
; 1182 : 			// since we have seen it before, make sure we resend the last received numbers
; 1183 : 			// or acknowledge this packet
; 1184 : 			cp->acknowledged = FALSE;

	mov	ecx, DWORD PTR _cp$[ebp]
	mov	BYTE PTR [ecx+15], 0

; 1185 : 
; 1186 : 			if (rp->oob)

	mov	edx, DWORD PTR _rp$[ebp]
	movzx	eax, BYTE PTR [edx+11]
	test	eax, eax
	je	SHORT $LN12@add_to_rec

; 1187 : 			{
; 1188 : 				cudp->rudp_data.last_oob_sent_received = -1;

	mov	ecx, DWORD PTR _cudp$[ebp]
	mov	DWORD PTR [ecx+680], -1

; 1189 : 			}
; 1190 : 			else

	jmp	SHORT $LN11@add_to_rec
$LN12@add_to_rec:

; 1191 : 			{
; 1192 : 				cudp->rudp_data.last_sent_received = -1;

	mov	edx, DWORD PTR _cudp$[ebp]
	mov	DWORD PTR [edx+640], -1
$LN11@add_to_rec:

; 1193 : 			}
; 1194 : 
; 1195 : 			free(rp);

	mov	eax, DWORD PTR _rp$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 1196 : 			rp = NULL;

	mov	DWORD PTR _rp$[ebp], 0

; 1197 : 			return size;

	mov	eax, DWORD PTR _size$[ebp]
	jmp	$LN53@add_to_rec
$LN13@add_to_rec:

; 1198 : 		}
; 1199 : 		
; 1200 : 		// otherwise insert it into the receiving queue.
; 1201 : 		if ((rp->sequence_number - cp->sequence_number) & 0x8000)

	mov	ecx, DWORD PTR _rp$[ebp]
	movzx	edx, WORD PTR [ecx+4]
	mov	eax, DWORD PTR _cp$[ebp]
	movzx	ecx, WORD PTR [eax+4]
	sub	edx, ecx
	and	edx, 32768				; 00008000H
	je	SHORT $LN10@add_to_rec

; 1202 : 		{
; 1203 : 			if (lp)

	cmp	DWORD PTR _lp$[ebp], 0
	je	SHORT $LN9@add_to_rec

; 1204 : 			{
; 1205 : 				lp->next = rp;

	mov	edx, DWORD PTR _lp$[ebp]
	mov	eax, DWORD PTR _rp$[ebp]
	mov	DWORD PTR [edx+20], eax

; 1206 : 			}
; 1207 : 			else

	jmp	SHORT $LN8@add_to_rec
$LN9@add_to_rec:

; 1208 : 			{
; 1209 : 				if (rp->oob)

	mov	ecx, DWORD PTR _rp$[ebp]
	movzx	edx, BYTE PTR [ecx+11]
	test	edx, edx
	je	SHORT $LN7@add_to_rec

; 1210 : 				{
; 1211 : 					cudp->rudp_data.oob_receiving = rp;

	mov	eax, DWORD PTR _cudp$[ebp]
	mov	ecx, DWORD PTR _rp$[ebp]
	mov	DWORD PTR [eax+692], ecx

; 1212 : 				}
; 1213 : 				else

	jmp	SHORT $LN8@add_to_rec
$LN7@add_to_rec:

; 1214 : 				{
; 1215 : 					cudp->rudp_data.receiving = rp;

	mov	edx, DWORD PTR _cudp$[ebp]
	mov	eax, DWORD PTR _rp$[ebp]
	mov	DWORD PTR [edx+652], eax
$LN8@add_to_rec:

; 1216 : 				}
; 1217 : 			}
; 1218 : 
; 1219 : 			rp->next = cp;

	mov	ecx, DWORD PTR _rp$[ebp]
	mov	edx, DWORD PTR _cp$[ebp]
	mov	DWORD PTR [ecx+20], edx

; 1220 : 			break;

	jmp	SHORT $LN14@add_to_rec
$LN10@add_to_rec:

; 1221 : 		}
; 1222 : 		
; 1223 : 		lp = cp;

	mov	eax, DWORD PTR _cp$[ebp]
	mov	DWORD PTR _lp$[ebp], eax

; 1224 : 		cp = cp->next;

	mov	ecx, DWORD PTR _cp$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _cp$[ebp], edx

; 1225 : 	}

	jmp	$LN15@add_to_rec
$LN14@add_to_rec:

; 1226 : 	
; 1227 : 	// if the queue is empty or we're at the end of the list, insert it
; 1228 : 	if (!cp)

	cmp	DWORD PTR _cp$[ebp], 0
	jne	SHORT $LN5@add_to_rec

; 1229 : 	{
; 1230 : 		if (lp)

	cmp	DWORD PTR _lp$[ebp], 0
	je	SHORT $LN4@add_to_rec

; 1231 : 		{
; 1232 : 			lp->next = rp;

	mov	eax, DWORD PTR _lp$[ebp]
	mov	ecx, DWORD PTR _rp$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 1233 : 		}
; 1234 : 		else

	jmp	SHORT $LN3@add_to_rec
$LN4@add_to_rec:

; 1235 : 		{
; 1236 : 			if (rp->oob)

	mov	edx, DWORD PTR _rp$[ebp]
	movzx	eax, BYTE PTR [edx+11]
	test	eax, eax
	je	SHORT $LN2@add_to_rec

; 1237 : 			{
; 1238 : 				cudp->rudp_data.oob_receiving = rp;

	mov	ecx, DWORD PTR _cudp$[ebp]
	mov	edx, DWORD PTR _rp$[ebp]
	mov	DWORD PTR [ecx+692], edx

; 1239 : 			}
; 1240 : 			else

	jmp	SHORT $LN3@add_to_rec
$LN2@add_to_rec:

; 1241 : 			{
; 1242 : 				cudp->rudp_data.receiving = rp;

	mov	eax, DWORD PTR _cudp$[ebp]
	mov	ecx, DWORD PTR _rp$[ebp]
	mov	DWORD PTR [eax+652], ecx
$LN3@add_to_rec:

; 1243 : 			}
; 1244 : 		}
; 1245 : 
; 1246 : 		rp->next = NULL;

	mov	edx, DWORD PTR _rp$[ebp]
	mov	DWORD PTR [edx+20], 0
$LN5@add_to_rec:

; 1247 : 	}
; 1248 : 	
; 1249 : 	cudp->recvmessagecount++;

	mov	eax, DWORD PTR _cudp$[ebp]
	mov	ecx, DWORD PTR [eax+520]
	add	ecx, 1
	mov	edx, DWORD PTR _cudp$[ebp]
	mov	DWORD PTR [edx+520], ecx

; 1250 : 	
; 1251 : 	return size;

	mov	eax, DWORD PTR _size$[ebp]
$LN53@add_to_rec:

; 1252 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN55@add_to_rec:
	DD	$LN49@add_to_rec
	DD	$LN47@add_to_rec
	DD	$LN46@add_to_rec
	DD	$LN50@add_to_rec
	DD	$LN50@add_to_rec
	DD	$LN50@add_to_rec
	DD	$LN44@add_to_rec
	DD	$LN43@add_to_rec
_add_to_receive_queue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\rudp.c
_TEXT	SEGMENT
tv251 = -32						; size = 4
_senderror$1 = -28					; size = 4
_newsize$ = -24						; size = 4
_sent$ = -20						; size = 4
_now$ = -16						; size = 4
_flags$ = -12						; size = 4
_ptr$ = -8						; size = 4
_size$ = -4						; size = 4
_cudp$ = 8						; size = 4
_rp$ = 12						; size = 4
_type$ = 16						; size = 4
_send_rudp_packet PROC

; 452  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 453  : 	unsigned char *ptr, *flags; 
; 454  : 	
; 455  : 	int newsize, size, sent = 0;

	mov	DWORD PTR _sent$[ebp], 0

; 456  : 
; 457  : 	long now = GetTickCount();

	call	DWORD PTR __imp__GetTickCount@0
	mov	DWORD PTR _now$[ebp], eax

; 458  : 	// We're copying all our data into the temp_buffer
; 459  : 	ptr = (unsigned char *)cudp->rudp_data.real_send_buffer;

	mov	eax, DWORD PTR _cudp$[ebp]
	mov	ecx, DWORD PTR [eax+712]
	mov	DWORD PTR _ptr$[ebp], ecx

; 460  : 	
; 461  : 	// Every message needs a ComAPIHeader (it never gets written over for rudp)
; 462  : 	ptr += sizeof(ComAPIHeader);

	mov	edx, DWORD PTR _ptr$[ebp]
	add	edx, 8
	mov	DWORD PTR _ptr$[ebp], edx

; 463  : 	size = sizeof(ComAPIHeader);

	mov	DWORD PTR _size$[ebp], 8

; 464  : 	
; 465  : 	// Every message needs a flags field
; 466  : 	flags = ptr;

	mov	eax, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR _flags$[ebp], eax

; 467  : 	*flags = 0;

	mov	ecx, DWORD PTR _flags$[ebp]
	mov	BYTE PTR [ecx], 0

; 468  : 	ptr++;

	mov	edx, DWORD PTR _ptr$[ebp]
	add	edx, 1
	mov	DWORD PTR _ptr$[ebp], edx

; 469  : 	size++;

	mov	eax, DWORD PTR _size$[ebp]
	add	eax, 1
	mov	DWORD PTR _size$[ebp], eax

; 470  : 
; 471  : 	if (cudp->rudp_data.reset_send <= RUDP_RESET_OK){

	mov	ecx, DWORD PTR _cudp$[ebp]
	cmp	DWORD PTR [ecx+628], 2
	jg	SHORT $LN36@send_rudp_

; 472  : 		if (now - cudp->rudp_data.last_send_time > RUDP_OOB_RESEND_TIME){

	mov	edx, DWORD PTR _cudp$[ebp]
	mov	eax, DWORD PTR _now$[ebp]
	sub	eax, DWORD PTR [edx+660]
	cmp	eax, 750				; 000002eeH
	jbe	SHORT $LN35@send_rudp_

; 473  : 			*flags = RUDPF_RESET;

	mov	ecx, DWORD PTR _flags$[ebp]
	mov	BYTE PTR [ecx], 128			; 00000080H

; 474  : 			*flags |= cudp->rudp_data.reset_send;

	mov	edx, DWORD PTR _flags$[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _cudp$[ebp]
	or	eax, DWORD PTR [ecx+628]
	mov	edx, DWORD PTR _flags$[ebp]
	mov	BYTE PTR [edx], al

; 475  : 			cudp->rudp_data.last_send_time = now;

	mov	eax, DWORD PTR _cudp$[ebp]
	mov	ecx, DWORD PTR _now$[ebp]
	mov	DWORD PTR [eax+660], ecx
$LN35@send_rudp_:

; 476  : 		}

	jmp	$LN34@send_rudp_
$LN36@send_rudp_:

; 477  : 	}
; 478  : 	else if (cudp->rudp_data.reset_send == RUDP_RESET_OK){

	mov	edx, DWORD PTR _cudp$[ebp]
	cmp	DWORD PTR [edx+628], 2
	jne	SHORT $LN33@send_rudp_

; 479  : 		*flags = RUDPF_RESET;

	mov	eax, DWORD PTR _flags$[ebp]
	mov	BYTE PTR [eax], 128			; 00000080H

; 480  : 		*flags |= cudp->rudp_data.reset_send;

	mov	ecx, DWORD PTR _flags$[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _cudp$[ebp]
	or	edx, DWORD PTR [eax+628]
	mov	ecx, DWORD PTR _flags$[ebp]
	mov	BYTE PTR [ecx], dl

; 481  : 		cudp->rudp_data.last_send_time = now;

	mov	edx, DWORD PTR _cudp$[ebp]
	mov	eax, DWORD PTR _now$[ebp]
	mov	DWORD PTR [edx+660], eax
	jmp	$LN34@send_rudp_
$LN33@send_rudp_:

; 482  : 	}
; 483  : 	else if (cudp->rudp_data.reset_send == RUDP_PING){

	mov	ecx, DWORD PTR _cudp$[ebp]
	cmp	DWORD PTR [ecx+628], 3
	jne	SHORT $LN31@send_rudp_

; 484  : 		*flags = RUDPF_RESET | RUDP_PING;

	mov	edx, DWORD PTR _flags$[ebp]
	mov	BYTE PTR [edx], 131			; 00000083H

; 485  : 		*(long *)ptr = now;

	mov	eax, DWORD PTR _ptr$[ebp]
	mov	ecx, DWORD PTR _now$[ebp]
	mov	DWORD PTR [eax], ecx

; 486  : 		ptr += sizeof (long);

	mov	edx, DWORD PTR _ptr$[ebp]
	add	edx, 4
	mov	DWORD PTR _ptr$[ebp], edx

; 487  : 		size += sizeof (long);

	mov	eax, DWORD PTR _size$[ebp]
	add	eax, 4
	mov	DWORD PTR _size$[ebp], eax
	jmp	$LN34@send_rudp_
$LN31@send_rudp_:

; 488  : 	}
; 489  : 	else if (cudp->rudp_data.reset_send == RUDP_EXIT){

	mov	ecx, DWORD PTR _cudp$[ebp]
	cmp	DWORD PTR [ecx+628], 6
	jne	SHORT $LN29@send_rudp_

; 490  : 		*flags = RUDPF_RESET | RUDP_EXIT;

	mov	edx, DWORD PTR _flags$[ebp]
	mov	BYTE PTR [edx], 134			; 00000086H
	jmp	$LN34@send_rudp_
$LN29@send_rudp_:

; 491  : 	}
; 492  : 	else if (cudp->rudp_data.reset_send == RUDP_DROP){

	mov	eax, DWORD PTR _cudp$[ebp]
	cmp	DWORD PTR [eax+628], 7
	jne	SHORT $LN27@send_rudp_

; 493  : 		*flags = RUDPF_RESET | RUDP_DROP;

	mov	ecx, DWORD PTR _flags$[ebp]
	mov	BYTE PTR [ecx], 135			; 00000087H

; 494  : 	}
; 495  : 	else {

	jmp	$LN34@send_rudp_
$LN27@send_rudp_:

; 496  : 		// If our last_sent_received is out of date, we need to send it
; 497  : 		if (cudp->rudp_data.last_sent_received != cudp->rudp_data.last_received){

	mov	edx, DWORD PTR _cudp$[ebp]
	mov	eax, DWORD PTR _cudp$[ebp]
	mov	ecx, DWORD PTR [edx+640]
	cmp	ecx, DWORD PTR [eax+636]
	je	SHORT $LN25@send_rudp_

; 498  : 			cudp->rudp_data.send_ack = FALSE;

	mov	edx, DWORD PTR _cudp$[ebp]
	mov	DWORD PTR [edx+644], 0

; 499  : 			*flags |= RUDPF_LAST;

	mov	eax, DWORD PTR _flags$[ebp]
	movzx	ecx, BYTE PTR [eax]
	or	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _flags$[ebp]
	mov	BYTE PTR [edx], cl

; 500  : 			*(unsigned short*)ptr = (unsigned short)cudp->rudp_data.last_received;

	mov	eax, DWORD PTR _ptr$[ebp]
	mov	ecx, DWORD PTR _cudp$[ebp]
	mov	dx, WORD PTR [ecx+636]
	mov	WORD PTR [eax], dx

; 501  : 
; 502  : 			cudp->rudp_data.last_sent_received = cudp->rudp_data.last_received;

	mov	eax, DWORD PTR _cudp$[ebp]
	mov	ecx, DWORD PTR _cudp$[ebp]
	mov	edx, DWORD PTR [ecx+636]
	mov	DWORD PTR [eax+640], edx

; 503  : 			ptr += sizeof(short);

	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, 2
	mov	DWORD PTR _ptr$[ebp], eax

; 504  : 			size += sizeof(short);

	mov	ecx, DWORD PTR _size$[ebp]
	add	ecx, 2
	mov	DWORD PTR _size$[ebp], ecx
$LN25@send_rudp_:

; 505  : 		}
; 506  : 		
; 507  : 		// If our last_sent_received is out of date, we need to send it
; 508  : 		if (cudp->rudp_data.last_oob_sent_received != cudp->rudp_data.last_oob_received){

	mov	edx, DWORD PTR _cudp$[ebp]
	mov	eax, DWORD PTR _cudp$[ebp]
	mov	ecx, DWORD PTR [edx+680]
	cmp	ecx, DWORD PTR [eax+676]
	je	SHORT $LN24@send_rudp_

; 509  : 			cudp->rudp_data.send_oob_ack = FALSE;

	mov	edx, DWORD PTR _cudp$[ebp]
	mov	DWORD PTR [edx+684], 0

; 510  : 			*flags |= RUDPF_LOOB;

	mov	eax, DWORD PTR _flags$[ebp]
	movzx	ecx, BYTE PTR [eax]
	or	ecx, 8
	mov	edx, DWORD PTR _flags$[ebp]
	mov	BYTE PTR [edx], cl

; 511  : 			*(unsigned short*)ptr = (unsigned short)cudp->rudp_data.last_oob_received;

	mov	eax, DWORD PTR _ptr$[ebp]
	mov	ecx, DWORD PTR _cudp$[ebp]
	mov	dx, WORD PTR [ecx+676]
	mov	WORD PTR [eax], dx

; 512  : 
; 513  : 			cudp->rudp_data.last_oob_sent_received = cudp->rudp_data.last_oob_received;

	mov	eax, DWORD PTR _cudp$[ebp]
	mov	ecx, DWORD PTR _cudp$[ebp]
	mov	edx, DWORD PTR [ecx+676]
	mov	DWORD PTR [eax+680], edx

; 514  : 			ptr += sizeof(short);

	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, 2
	mov	DWORD PTR _ptr$[ebp], eax

; 515  : 			size += sizeof(short);

	mov	ecx, DWORD PTR _size$[ebp]
	add	ecx, 2
	mov	DWORD PTR _size$[ebp], ecx
$LN24@send_rudp_:

; 516  : 		}
; 517  : 		
; 518  : //		cp = cudp->rudp_data.receiving;
; 519  : //		count = 0;
; 520  : //		
; 521  : //		while (cp)
; 522  : //		{
; 523  : //			if ((!cp->acknowledged) && ((cudp->rudp_data.last_received - cp->sequence_number + 1) & 0x8000))
; 524  : //			{
; 525  : //				cudp->rudp_data.send_ack = FALSE;
; 526  : //
; 527  : //				count ++;
; 528  : //				cp->acknowledged = TRUE;
; 529  : //				// *flags |= RUDPF_ACK;
; 530  : //				*(unsigned short*)ptr = cp->sequence_number;
; 531  : //				ptr += sizeof (short);
; 532  : //				size += sizeof (short);
; 533  : //			}
; 534  : //			
; 535  : //			if (count >= 7)
; 536  : ///			{
; 537  : //				break;
; 538  : //			}
; 539  : //
; 540  : //			cp = cp->next;
; 541  : //		}
; 542  : //		
; 543  : //		if (count)
; 544  : //		{
; 545  : //			*flags |= (count);
; 546  : //		}
; 547  : 		
; 548  : 		// If we're sending a packet, we have a sequence number & data
; 549  : 		if (rp)

	cmp	DWORD PTR _rp$[ebp], 0
	je	$LN34@send_rudp_

; 550  : 		{
; 551  : 			*flags |= RUDPF_SEQ;

	mov	edx, DWORD PTR _flags$[ebp]
	movzx	eax, BYTE PTR [edx]
	or	eax, 32					; 00000020H
	mov	ecx, DWORD PTR _flags$[ebp]
	mov	BYTE PTR [ecx], al

; 552  : 			*(unsigned short*)ptr = rp->sequence_number;

	mov	edx, DWORD PTR _ptr$[ebp]
	mov	eax, DWORD PTR _rp$[ebp]
	mov	cx, WORD PTR [eax+4]
	mov	WORD PTR [edx], cx

; 553  : 			ptr += sizeof(short);

	mov	edx, DWORD PTR _ptr$[ebp]
	add	edx, 2
	mov	DWORD PTR _ptr$[ebp], edx

; 554  : 			size += sizeof(short);

	mov	eax, DWORD PTR _size$[ebp]
	add	eax, 2
	mov	DWORD PTR _size$[ebp], eax

; 555  : 
; 556  : 			if (rp->oob)

	mov	ecx, DWORD PTR _rp$[ebp]
	movzx	edx, BYTE PTR [ecx+11]
	test	edx, edx
	je	SHORT $LN22@send_rudp_

; 557  : 			{
; 558  : 				*flags |= RUDPF_OOB;

	mov	eax, DWORD PTR _flags$[ebp]
	movzx	ecx, BYTE PTR [eax]
	or	ecx, 64					; 00000040H
	mov	edx, DWORD PTR _flags$[ebp]
	mov	BYTE PTR [edx], cl
$LN22@send_rudp_:

; 559  : 			}
; 560  : 			
; 561  : 			// If we're a packetized message, send a message id, slot, etc.
; 562  : 			if (rp->message_parts > 1)

	mov	eax, DWORD PTR _rp$[ebp]
	movzx	ecx, BYTE PTR [eax+13]
	cmp	ecx, 1
	jle	SHORT $LN21@send_rudp_

; 563  : 			{
; 564  : 				*flags |= RUDPF_MSG;

	mov	edx, DWORD PTR _flags$[ebp]
	movzx	eax, BYTE PTR [edx]
	or	eax, 4
	mov	ecx, DWORD PTR _flags$[ebp]
	mov	BYTE PTR [ecx], al

; 565  : 				*(unsigned short*)ptr = rp->message_number;

	mov	edx, DWORD PTR _ptr$[ebp]
	mov	eax, DWORD PTR _rp$[ebp]
	mov	cx, WORD PTR [eax+6]
	mov	WORD PTR [edx], cx

; 566  : 				ptr += sizeof(unsigned short);

	mov	edx, DWORD PTR _ptr$[ebp]
	add	edx, 2
	mov	DWORD PTR _ptr$[ebp], edx

; 567  : 				size += sizeof(unsigned short);

	mov	eax, DWORD PTR _size$[ebp]
	add	eax, 2
	mov	DWORD PTR _size$[ebp], eax

; 568  : 				*ptr = rp->message_slot;

	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	edx, DWORD PTR _rp$[ebp]
	mov	al, BYTE PTR [edx+12]
	mov	BYTE PTR [ecx], al

; 569  : 				ptr ++;

	mov	ecx, DWORD PTR _ptr$[ebp]
	add	ecx, 1
	mov	DWORD PTR _ptr$[ebp], ecx

; 570  : 				size ++;

	mov	edx, DWORD PTR _size$[ebp]
	add	edx, 1
	mov	DWORD PTR _size$[ebp], edx

; 571  : 				*ptr = rp->message_parts;

	mov	eax, DWORD PTR _ptr$[ebp]
	mov	ecx, DWORD PTR _rp$[ebp]
	mov	dl, BYTE PTR [ecx+13]
	mov	BYTE PTR [eax], dl

; 572  : 				ptr ++;

	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, 1
	mov	DWORD PTR _ptr$[ebp], eax

; 573  : 				size ++;

	mov	ecx, DWORD PTR _size$[ebp]
	add	ecx, 1
	mov	DWORD PTR _size$[ebp], ecx
$LN21@send_rudp_:

; 574  : 			}
; 575  : 
; 576  : 			assert(FALSE == IsBadWritePtr(ptr, rp->size));
; 577  : 			//if (!IsBadWritePtr(ptr, sizeof(unsigned char))) // JB 010223 CTD
; 578  : 			if (!IsBadWritePtr(ptr, rp->size)) // JB 010401 CTD

	mov	edx, DWORD PTR _rp$[ebp]
	movzx	eax, WORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	call	DWORD PTR __imp__IsBadWritePtr@8
	test	eax, eax
	jne	SHORT $LN20@send_rudp_

; 579  : 				memcpy (ptr, rp->data, rp->size);

	mov	edx, DWORD PTR _rp$[ebp]
	movzx	eax, WORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _rp$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _ptr$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN20@send_rudp_:

; 580  : 			size += rp->size;

	mov	ecx, DWORD PTR _rp$[ebp]
	movzx	edx, WORD PTR [ecx+8]
	add	edx, DWORD PTR _size$[ebp]
	mov	DWORD PTR _size$[ebp], edx
$LN34@send_rudp_:

; 581  : 			assert(size < cudp->buffer_size);
; 582  : 
; 583  : //			MonoPrint ("Send RUDP Packet %08x %08x\n", cudp->address.sin_addr.s_addr, size);
; 584  : 		}
; 585  : 	}
; 586  : 	
; 587  : 	// If we have something worth sending
; 588  : 	if (*flags){

	mov	eax, DWORD PTR _flags$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN19@send_rudp_

; 589  : 		if (size < 32){

	cmp	DWORD PTR _size$[ebp], 32		; 00000020H
	jge	SHORT $LN18@send_rudp_

; 590  : 			newsize = size;

	mov	edx, DWORD PTR _size$[ebp]
	mov	DWORD PTR _newsize$[ebp], edx

; 591  : 		}
; 592  : 		else{

	jmp	SHORT $LN17@send_rudp_
$LN18@send_rudp_:

; 593  : 			memcpy(cudp->compression_buffer, &size, sizeof(u_short));

	push	2
	lea	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cudp$[ebp]
	mov	edx, DWORD PTR [ecx+476]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 594  : 			memset (cudp->rudp_data.real_send_buffer + size, 0, cudp->buffer_size - size);

	mov	eax, DWORD PTR _cudp$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	sub	ecx, DWORD PTR _size$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _cudp$[ebp]
	mov	eax, DWORD PTR [edx+712]
	add	eax, DWORD PTR _size$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 595  : 			newsize = comms_compress (cudp->rudp_data.real_send_buffer, cudp->compression_buffer+sizeof(u_short), size);

	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cudp$[ebp]
	mov	eax, DWORD PTR [edx+476]
	add	eax, 2
	push	eax
	mov	ecx, DWORD PTR _cudp$[ebp]
	mov	edx, DWORD PTR [ecx+712]
	push	edx
	call	_comms_compress
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _newsize$[ebp], eax
$LN17@send_rudp_:

; 596  : 		}
; 597  : 
; 598  : 		// sfr: test comms drop
; 599  : 		sent = 0;

	mov	DWORD PTR _sent$[ebp], 0

; 600  : 		//if (docomms){
; 601  : 		if ((int)(newsize + sizeof (u_short)) < (int) (size))

	mov	eax, DWORD PTR _newsize$[ebp]
	add	eax, 2
	cmp	eax, DWORD PTR _size$[ebp]
	jge	SHORT $LN16@send_rudp_

; 602  : 		{
; 603  : 			sent = CAPI_sendto
; 604  : 			(
; 605  : 				cudp->send_sock,
; 606  : 				cudp->compression_buffer,
; 607  : 				newsize + sizeof (u_short),
; 608  : 				0,
; 609  : 				(struct sockaddr *)&cudp->sendAddress,   
; 610  : 				sizeof(cudp->sendAddress)
; 611  : 			);

	push	16					; 00000010H
	mov	ecx, DWORD PTR _cudp$[ebp]
	add	ecx, 480				; 000001e0H
	push	ecx
	push	0
	mov	edx, DWORD PTR _newsize$[ebp]
	add	edx, 2
	push	edx
	mov	eax, DWORD PTR _cudp$[ebp]
	mov	ecx, DWORD PTR [eax+476]
	push	ecx
	mov	edx, DWORD PTR _cudp$[ebp]
	mov	eax, DWORD PTR [edx+512]
	push	eax
	call	DWORD PTR _CAPI_sendto
	mov	DWORD PTR _sent$[ebp], eax

; 612  : 		}
; 613  : 		else

	jmp	SHORT $LN15@send_rudp_
$LN16@send_rudp_:

; 614  : 		{
; 615  : 			sent = CAPI_sendto
; 616  : 			(
; 617  : 				cudp->send_sock,
; 618  : 				cudp->rudp_data.real_send_buffer,
; 619  : 				size,
; 620  : 				0,
; 621  : 				(struct sockaddr *)&cudp->sendAddress,   
; 622  : 				sizeof(cudp->sendAddress)
; 623  : 			);

	push	16					; 00000010H
	mov	ecx, DWORD PTR _cudp$[ebp]
	add	ecx, 480				; 000001e0H
	push	ecx
	push	0
	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	mov	eax, DWORD PTR _cudp$[ebp]
	mov	ecx, DWORD PTR [eax+712]
	push	ecx
	mov	edx, DWORD PTR _cudp$[ebp]
	mov	eax, DWORD PTR [edx+512]
	push	eax
	call	DWORD PTR _CAPI_sendto
	mov	DWORD PTR _sent$[ebp], eax
$LN15@send_rudp_:

; 624  : 		}
; 625  : 		//}
; 626  : 		
; 627  : 		if (sent > 0){

	cmp	DWORD PTR _sent$[ebp], 0
	jle	SHORT $LN14@send_rudp_

; 628  : 			cudp->rudp_data.last_ping_send_time = now;

	mov	ecx, DWORD PTR _cudp$[ebp]
	mov	edx, DWORD PTR _now$[ebp]
	mov	DWORD PTR [ecx+704], edx

; 629  : 
; 630  : 			if (rp){

	cmp	DWORD PTR _rp$[ebp], 0
	je	SHORT $LN13@send_rudp_

; 631  : 				if (rp->oob){

	mov	eax, DWORD PTR _rp$[ebp]
	movzx	ecx, BYTE PTR [eax+11]
	test	ecx, ecx
	je	SHORT $LN12@send_rudp_

; 632  : 					cudp->rudp_data.last_oob_send_time = now;

	mov	edx, DWORD PTR _cudp$[ebp]
	mov	eax, DWORD PTR _now$[ebp]
	mov	DWORD PTR [edx+700], eax

; 633  : 				}
; 634  : 				else{

	jmp	SHORT $LN11@send_rudp_
$LN12@send_rudp_:

; 635  : 					cudp->rudp_data.last_send_time = now;

	mov	ecx, DWORD PTR _cudp$[ebp]
	mov	edx, DWORD PTR _now$[ebp]
	mov	DWORD PTR [ecx+660], edx
$LN11@send_rudp_:

; 636  : 				}
; 637  : 				rp->last_sent_at = now;

	mov	eax, DWORD PTR _rp$[ebp]
	mov	ecx, DWORD PTR _now$[ebp]
	mov	DWORD PTR [eax], ecx
$LN13@send_rudp_:

; 638  : 			}
; 639  : 			use_bandwidth (sent, 1, type);

	mov	edx, DWORD PTR _type$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _sent$[ebp]
	push	eax
	call	_use_bandwidth
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN10@send_rudp_
$LN14@send_rudp_:

; 640  : 		}
; 641  :         else if (size == SOCKET_ERROR)

	cmp	DWORD PTR _size$[ebp], -1
	jne	SHORT $LN10@send_rudp_

; 642  : 		{
; 643  : 			int senderror;
; 644  : 			senderror = CAPI_WSAGetLastError();

	call	DWORD PTR _CAPI_WSAGetLastError
	mov	DWORD PTR _senderror$1[ebp], eax

; 645  : 			switch(senderror)

	mov	ecx, DWORD PTR _senderror$1[ebp]
	mov	DWORD PTR tv251[ebp], ecx
	cmp	DWORD PTR tv251[ebp], 10035		; 00002733H
	je	SHORT $LN6@send_rudp_
	jmp	SHORT $LN5@send_rudp_
$LN6@send_rudp_:

; 646  : 			{
; 647  : 				case WSAEWOULDBLOCK:
; 648  : 				{
; 649  : 					// if (rp)
; 650  : 					// {
; 651  : 					//	MonoPrint ("WouldBlock %d %d %d\n", size, get_bandwidth_available (), rp->sequence_number);
; 652  : 					// }
; 653  : 					// else
; 654  : 					// {
; 655  : 					// 	MonoPrint ("WouldBlock %d %d\n", size, get_bandwidth_available ());
; 656  : 					// }
; 657  : 					cut_bandwidth ();

	call	_cut_bandwidth

; 658  : 					cudp->sendwouldblockcount++;

	mov	edx, DWORD PTR _cudp$[ebp]
	mov	eax, DWORD PTR [edx+532]
	add	eax, 1
	mov	ecx, DWORD PTR _cudp$[ebp]
	mov	DWORD PTR [ecx+532], eax

; 659  : 					/* The socket is marked as non-blocking and the send
; 660  : 					operation would block. */
; 661  : 					return COMAPI_WOULDBLOCK;

	mov	eax, -8					; fffffff8H
	jmp	SHORT $LN37@send_rudp_
$LN5@send_rudp_:

; 662  : 				}
; 663  : 
; 664  : 				default :
; 665  : 				{
; 666  : 					return 0;

	xor	eax, eax
	jmp	SHORT $LN37@send_rudp_
$LN10@send_rudp_:

; 667  : 				}
; 668  : 			}
; 669  : 		}
; 670  : 		
; 671  : 		if (*flags & RUDPF_RESET)

	mov	edx, DWORD PTR _flags$[ebp]
	movzx	eax, BYTE PTR [edx]
	and	eax, 128				; 00000080H
	je	SHORT $LN4@send_rudp_

; 672  : 		{
; 673  : 			if (size)

	cmp	DWORD PTR _size$[ebp], 0
	je	SHORT $LN3@send_rudp_

; 674  : 			{
; 675  : 				return -2;

	mov	eax, -2					; fffffffeH
	jmp	SHORT $LN37@send_rudp_

; 676  : 			}
; 677  : 			else

	jmp	SHORT $LN4@send_rudp_
$LN3@send_rudp_:

; 678  : 			{
; 679  : 				return 0;

	xor	eax, eax
	jmp	SHORT $LN37@send_rudp_
$LN4@send_rudp_:

; 680  : 			}
; 681  : 		}
; 682  : 		
; 683  : 		return size;

	mov	eax, DWORD PTR _size$[ebp]
	jmp	SHORT $LN37@send_rudp_

; 684  : 	}
; 685  : 	else

	jmp	SHORT $LN37@send_rudp_
$LN19@send_rudp_:

; 686  : 	{
; 687  : 		return 0;

	xor	eax, eax
$LN37@send_rudp_:

; 688  : 	}
; 689  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_send_rudp_packet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\rudp.c
_TEXT	SEGMENT
tv95 = -8						; size = 4
_c$ = -4						; size = 4
_name_in$ = 8						; size = 4
_parentCom$ = 12					; size = 4
_buffersize$ = 16					; size = 4
_gamename$ = 20						; size = 4
_rudpPort$ = 24						; size = 4
_IPaddress$ = 28					; size = 4
_id$ = 32						; size = 4
_ComRUDPOpenSendClone PROC

; 138  : ){

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 139  : 	ComIP *c;
; 140  : 	
; 141  : 	c = (ComIP*)malloc(sizeof(ComIP));

	push	716					; 000002ccH
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _c$[ebp], eax

; 142  : 	//GlobalListHead->com = (ComAPIHandle)c;
; 143  : 	memset(c,0,sizeof(ComIP));

	push	716					; 000002ccH
	push	0
	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 144  : 	
; 145  : 	memcpy(c,parentCom,sizeof(ComIP));

	push	716					; 000002ccH
	mov	ecx, DWORD PTR _parentCom$[ebp]
	push	ecx
	mov	edx, DWORD PTR _c$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 146  : 	
; 147  : 	((ComAPIHandle)c)->name = (char*)malloc (strlen (name_in) + 1);

	mov	eax, DWORD PTR _name_in$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 1
	push	eax
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx], eax

; 148  : 	strcpy (((ComAPIHandle)c)->name, name_in);

	mov	edx, DWORD PTR _name_in$[ebp]
	push	edx
	mov	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_strcpy
	add	esp, 8

; 149  : 	
; 150  : 	/* initialize header data */
; 151  : 	
; 152  : 	c->parent = parentCom;

	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR _parentCom$[ebp]
	mov	DWORD PTR [edx+564], eax

; 153  : 	parentCom->referencecount++;

	mov	ecx, DWORD PTR _parentCom$[ebp]
	mov	edx, DWORD PTR [ecx+568]
	add	edx, 1
	mov	eax, DWORD PTR _parentCom$[ebp]
	mov	DWORD PTR [eax+568], edx

; 154  : 	c->referencecount = 1;

	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+568], 1

; 155  : 	
; 156  : 	c->buffer_size = max(parentCom->buffer_size, (int)(sizeof(ComAPIHeader) + buffersize + 16));

	mov	edx, DWORD PTR _buffersize$[ebp]
	add	edx, 24					; 00000018H
	mov	eax, DWORD PTR _parentCom$[ebp]
	cmp	DWORD PTR [eax+48], edx
	jle	SHORT $LN5@ComRUDPOpe
	mov	ecx, DWORD PTR _parentCom$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR tv95[ebp], edx
	jmp	SHORT $LN6@ComRUDPOpe
$LN5@ComRUDPOpe:
	mov	eax, DWORD PTR _buffersize$[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR tv95[ebp], eax
$LN6@ComRUDPOpe:
	mov	ecx, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR tv95[ebp]
	mov	DWORD PTR [ecx+48], edx

; 157  : 	
; 158  : 	if ((c->max_buffer_size > 0) && (c->buffer_size > c->max_buffer_size))

	mov	eax, DWORD PTR _c$[ebp]
	cmp	DWORD PTR [eax+52], 0
	jle	SHORT $LN2@ComRUDPOpe
	mov	ecx, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [ecx+48]
	cmp	eax, DWORD PTR [edx+52]
	jle	SHORT $LN2@ComRUDPOpe

; 159  : 	{
; 160  : 		c->buffer_size = c->max_buffer_size;

	mov	ecx, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [edx+52]
	mov	DWORD PTR [ecx+48], eax
$LN2@ComRUDPOpe:

; 161  : 	}
; 162  : 	
; 163  : 	c->send_buffer.buf = (char *)malloc(c->buffer_size);

	mov	ecx, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+64], eax

; 164  : 	c->rudp_data.real_send_buffer = (char *)malloc(c->buffer_size);

	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [edx+48]
	push	eax
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+712], eax

; 165  : 
; 166  : 	c->rudp_data.sequence_number = 0;		/* sequence number for sending */

	xor	edx, edx
	mov	eax, DWORD PTR _c$[ebp]
	mov	WORD PTR [eax+612], dx

; 167  : 	c->rudp_data.oob_sequence_number = 0;		/* sequence number for sending */

	xor	ecx, ecx
	mov	edx, DWORD PTR _c$[ebp]
	mov	WORD PTR [edx+614], cx

; 168  : 	c->rudp_data.message_number = 0;		/* message number for sending */

	xor	eax, eax
	mov	ecx, DWORD PTR _c$[ebp]
	mov	WORD PTR [ecx+616], ax

; 169  : 	c->rudp_data.sending = 0;				/* list of sent packets */

	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [edx+620], 0

; 170  : 	c->rudp_data.oob_sending = 0;				/* list of sent packets */

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+664], 0

; 171  : 	c->rudp_data.last_sent = 0;				/* list of sent packets */

	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+624], 0

; 172  : 	c->rudp_data.oob_last_sent = 0;				/* list of sent packets */

	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [edx+668], 0

; 173  : 
; 174  : 	c->rudp_data.reset_send = 0;			/* What reset stage are we in */

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+628], 0

; 175  : 
; 176  : 	c->rudp_data.send_ack = 0;

	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+644], 0

; 177  : 	c->rudp_data.send_oob_ack = 0;

	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [edx+684], 0

; 178  : 	c->rudp_data.last_sequence = 0;			/* other's last seen sequence number */

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+632], 0

; 179  : 	c->rudp_data.last_oob_sequence = 0;			/* other's last seen sequence number */

	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+672], 0

; 180  : 	c->rudp_data.last_received = 0;			/* my last received sequential sequence number for ack.*/

	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [edx+636], 0

; 181  : 	c->rudp_data.last_oob_received = 0;			/* my last received sequential sequence number for ack.*/

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+676], 0

; 182  : 	c->rudp_data.last_sent_received = 0;	/* the last last_received that I acknowledged */

	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+640], 0

; 183  : 	c->rudp_data.last_oob_sent_received = 0;	/* the last last_received that I acknowledged */

	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [edx+680], 0

; 184  : 
; 185  : 	c->rudp_data.last_dispatched = 0;		/* the last dispatched message */

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+648], 0

; 186  : 	c->rudp_data.last_oob_dispatched = 0;		/* the last dispatched message */

	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+688], 0

; 187  : 
; 188  : 	c->rudp_data.receiving = 0;				/* list of received packets */

	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [edx+652], 0

; 189  : 	c->rudp_data.oob_receiving = 0;				/* list of received packets */

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+692], 0

; 190  : 
; 191  : 	c->rudp_data.sent_received = 0;			/* what the last received I sent */

	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+656], 0

; 192  : 	c->rudp_data.sent_oob_received = 0;			/* what the last received I sent */

	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [edx+696], 0

; 193  : 	c->rudp_data.last_send_time = 0;		/* last time we checked for ack */

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+660], 0

; 194  : 	c->rudp_data.last_oob_send_time = 0;		/* last time we checked for ack */

	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+700], 0

; 195  : 
; 196  : 	c->rudp_data.last_ping_send_time = 0;

	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [edx+704], 0

; 197  : 	c->rudp_data.last_ping_recv_time = GetTickCount ();

	call	DWORD PTR __imp__GetTickCount@0
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+708], eax

; 198  : 	
; 199  : 	c->compression_buffer = (char *)malloc(c->buffer_size);

	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [edx+48]
	push	eax
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+476], eax

; 200  : 	
; 201  : 	ComIPHostIDGet(&c->apiheader, c->send_buffer.buf, 0);

	push	0
	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [edx+64]
	push	eax
	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	call	_ComIPHostIDGet
	add	esp, 12					; 0000000cH

; 202  : 	
; 203  : 	strncpy(((ComAPIHeader *)c->rudp_data.real_send_buffer)->gamename, gamename, GAME_NAME_LENGTH);

	push	4
	mov	edx, DWORD PTR _gamename$[ebp]
	push	edx
	mov	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR [eax+712]
	push	ecx
	call	_strncpy
	add	esp, 12					; 0000000cH

; 204  : 	//sfr: id network order
; 205  : 	((ComAPIHeader *)c->rudp_data.real_send_buffer)->id = c->whoami;

	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [edx+712]
	mov	ecx, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR [ecx+580]
	mov	DWORD PTR [eax+4], edx

; 206  : 
; 207  : 	// sfr: get ID instead of IP if IP is flag
; 208  : 	if (IPaddress == CAPI_DANGLING_IP){

	cmp	DWORD PTR _IPaddress$[ebp], -1
	jne	SHORT $LN1@ComRUDPOpe

; 209  : 		ComIPHostIDGet(&c->apiheader, (char*)&IPaddress, 0);

	push	0
	lea	eax, DWORD PTR _IPaddress$[ebp]
	push	eax
	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	call	_ComIPHostIDGet
	add	esp, 12					; 0000000cH

; 210  : 		IPaddress = CAPI_htonl (IPaddress);

	mov	edx, DWORD PTR _IPaddress$[ebp]
	push	edx
	call	DWORD PTR _CAPI_htonl
	mov	DWORD PTR _IPaddress$[ebp], eax
$LN1@ComRUDPOpe:

; 211  : 	}
; 212  : 
; 213  : 	/* Outgoing... */
; 214  : 	memset ((char*)&c->sendAddress, 0, sizeof(c->sendAddress));

	push	16					; 00000010H
	push	0
	mov	eax, DWORD PTR _c$[ebp]
	add	eax, 480				; 000001e0H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 215  : 	c->sendAddress.sin_family       = AF_INET;

	mov	ecx, 2
	mov	edx, DWORD PTR _c$[ebp]
	mov	WORD PTR [edx+480], cx

; 216  : 	c->sendAddress.sin_addr.s_addr  = CAPI_htonl(IPaddress);

	mov	eax, DWORD PTR _IPaddress$[ebp]
	push	eax
	call	DWORD PTR _CAPI_htonl
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+484], eax

; 217  : 	c->sendAddress.sin_port         = CAPI_htons((unsigned short)rudpPort);

	movzx	edx, WORD PTR _rudpPort$[ebp]
	push	edx
	call	DWORD PTR _CAPI_htons
	mov	ecx, DWORD PTR _c$[ebp]
	mov	WORD PTR [ecx+482], ax

; 218  : 
; 219  : 	// sfr: id (store network order)
; 220  : 	c->id = CAPI_htonl(id);

	mov	edx, DWORD PTR _id$[ebp]
	push	edx
	call	DWORD PTR _CAPI_htonl
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+584], eax

; 221  : 
; 222  : 	comListAdd(c);

	mov	edx, DWORD PTR _c$[ebp]
	push	edx
	call	_comListAdd
	add	esp, 4

; 223  : 	return (ComAPIHandle)c;

	mov	eax, DWORD PTR _c$[ebp]

; 224  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ComRUDPOpenSendClone ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\rudp.c
_TEXT	SEGMENT
_max$ = -16						; size = 4
_rp$ = -12						; size = 4
_curr$ = -8						; size = 4
_count$ = -4						; size = 4
_get_rudp_max_queue_length PROC

; 103  : int get_rudp_max_queue_length (void){

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 104  : 	int max, count;
; 105  : 
; 106  : 	Reliable_Packet *rp;
; 107  : 
; 108  : 	ComIP *curr;
; 109  : 
; 110  : 	max = 0;

	mov	DWORD PTR _max$[ebp], 0

; 111  : 
; 112  : 	enter_cs(); // JPO

	call	_enter_cs

; 113  : 	//sfr new list
; 114  : 	for (curr = comListGetFirstP(CAPI_RUDP_PROTOCOL); curr != NULL; curr = comListGetNextP(CAPI_RUDP_PROTOCOL)){

	push	10					; 0000000aH
	call	_comListGetFirstP
	add	esp, 4
	mov	DWORD PTR _curr$[ebp], eax
	jmp	SHORT $LN6@get_rudp_m
$LN5@get_rudp_m:
	push	10					; 0000000aH
	call	_comListGetNextP
	add	esp, 4
	mov	DWORD PTR _curr$[ebp], eax
$LN6@get_rudp_m:
	cmp	DWORD PTR _curr$[ebp], 0
	je	SHORT $LN4@get_rudp_m

; 115  : 		count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 116  : 		rp = curr->rudp_data.sending;

	mov	eax, DWORD PTR _curr$[ebp]
	mov	ecx, DWORD PTR [eax+620]
	mov	DWORD PTR _rp$[ebp], ecx
$LN3@get_rudp_m:

; 117  : 		while (rp) {

	cmp	DWORD PTR _rp$[ebp], 0
	je	SHORT $LN2@get_rudp_m

; 118  : 			count ++;

	mov	edx, DWORD PTR _count$[ebp]
	add	edx, 1
	mov	DWORD PTR _count$[ebp], edx

; 119  : 			rp = rp->next;

	mov	eax, DWORD PTR _rp$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _rp$[ebp], ecx

; 120  : 		}

	jmp	SHORT $LN3@get_rudp_m
$LN2@get_rudp_m:

; 121  : 		if (count > max){

	mov	edx, DWORD PTR _count$[ebp]
	cmp	edx, DWORD PTR _max$[ebp]
	jle	SHORT $LN1@get_rudp_m

; 122  : 			max = count;

	mov	eax, DWORD PTR _count$[ebp]
	mov	DWORD PTR _max$[ebp], eax
$LN1@get_rudp_m:

; 123  : 		}
; 124  : 	}

	jmp	SHORT $LN5@get_rudp_m
$LN4@get_rudp_m:

; 125  : 
; 126  : 	leave_cs();

	call	_leave_cs

; 127  : 	return max;

	mov	eax, DWORD PTR _max$[ebp]

; 128  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_get_rudp_max_queue_length ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\rudp.c
_TEXT	SEGMENT
_cudp$1 = -4						; size = 4
_c$ = 8							; size = 4
_ComRUDPGetTimeStamp PROC

; 1962 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1963 : 	if(c)

	cmp	DWORD PTR _c$[ebp], 0
	je	SHORT $LN2@ComRUDPGet

; 1964 : 	{
; 1965 : 		ComIP *cudp= (ComIP *)c;

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _cudp$1[ebp], eax

; 1966 : 		
; 1967 : 		return cudp->timestamp;

	mov	ecx, DWORD PTR _cudp$1[ebp]
	mov	eax, DWORD PTR [ecx+600]
	jmp	SHORT $LN3@ComRUDPGet

; 1968 : 	}
; 1969 : 	else

	jmp	SHORT $LN3@ComRUDPGet
$LN2@ComRUDPGet:

; 1970 : 	{
; 1971 : 		return 0;

	xor	eax, eax
$LN3@ComRUDPGet:

; 1972 : 	}
; 1973 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ComRUDPGetTimeStamp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\rudp.c
_TEXT	SEGMENT
_diff$1 = -32						; size = 4
tv68 = -28						; size = 4
_time$2 = -24						; size = 4
_now$3 = -20						; size = 4
tv69 = -16						; size = 4
_size$4 = -12						; size = 4
_cudp$5 = -8						; size = 4
_rp$6 = -4						; size = 4
_c$ = 8							; size = 4
_querytype$ = 12					; size = 4
_ComRUDPQuery PROC

; 1816 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 1817 : 	if(c)

	cmp	DWORD PTR _c$[ebp], 0
	je	$LN35@ComRUDPQue

; 1818 : 	{
; 1819 : 		ComIP
; 1820 : 			*cudp;
; 1821 : 
; 1822 : 		cudp = GETActiveCOMHandle(c);  

	mov	eax, DWORD PTR _c$[ebp]
	cmp	DWORD PTR [eax+564], 0
	jne	SHORT $LN38@ComRUDPQue
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR tv68[ebp], ecx
	jmp	SHORT $LN39@ComRUDPQue
$LN38@ComRUDPQue:
	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [edx+564]
	mov	DWORD PTR tv68[ebp], eax
$LN39@ComRUDPQue:
	mov	ecx, DWORD PTR tv68[ebp]
	mov	DWORD PTR _cudp$5[ebp], ecx

; 1823 : 
; 1824 : 		switch(querytype)

	mov	edx, DWORD PTR _querytype$[ebp]
	mov	DWORD PTR tv69[ebp], edx
	mov	eax, DWORD PTR tv69[ebp]
	sub	eax, 1
	mov	DWORD PTR tv69[ebp], eax
	cmp	DWORD PTR tv69[ebp], 25			; 00000019H
	ja	$LN1@ComRUDPQue
	mov	ecx, DWORD PTR tv69[ebp]
	jmp	DWORD PTR $LN40@ComRUDPQue[ecx*4]
$LN32@ComRUDPQue:

; 1825 : 		{
; 1826 : 			case COMAPI_MESSAGECOUNT:
; 1827 : 				return cudp->sendmessagecount + ((ComIP *)c)->recvmessagecount;

	mov	edx, DWORD PTR _cudp$5[ebp]
	mov	eax, DWORD PTR [edx+524]
	mov	ecx, DWORD PTR _c$[ebp]
	add	eax, DWORD PTR [ecx+520]
	jmp	$LN36@ComRUDPQue

; 1828 : 				break;

	jmp	$LN35@ComRUDPQue
$LN31@ComRUDPQue:

; 1829 : 			case COMAPI_RECV_MESSAGECOUNT:
; 1830 : 				return ((ComIP *)c)->recvmessagecount;

	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [edx+520]
	jmp	$LN36@ComRUDPQue

; 1831 : 				break;

	jmp	$LN35@ComRUDPQue
$LN30@ComRUDPQue:

; 1832 : 			case COMAPI_SEND_MESSAGECOUNT:
; 1833 : 				return cudp->sendmessagecount;

	mov	eax, DWORD PTR _cudp$5[ebp]
	mov	eax, DWORD PTR [eax+524]
	jmp	$LN36@ComRUDPQue

; 1834 : 				break;

	jmp	$LN35@ComRUDPQue
$LN29@ComRUDPQue:

; 1835 : 			case COMAPI_RECV_WOULDBLOCKCOUNT:
; 1836 : 				return ((ComIP *)c)->recvwouldblockcount;

	mov	ecx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [ecx+528]
	jmp	$LN36@ComRUDPQue

; 1837 : 				break;

	jmp	$LN35@ComRUDPQue
$LN28@ComRUDPQue:

; 1838 : 			case COMAPI_SEND_WOULDBLOCKCOUNT:
; 1839 : 				return cudp->sendwouldblockcount;

	mov	edx, DWORD PTR _cudp$5[ebp]
	mov	eax, DWORD PTR [edx+532]
	jmp	$LN36@ComRUDPQue

; 1840 : 				break;

	jmp	$LN35@ComRUDPQue
$LN27@ComRUDPQue:

; 1841 : 			case COMAPI_RECEIVE_SOCKET:
; 1842 : 				return ((ComIP *)c)->recv_sock;

	mov	eax, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [eax+516]
	jmp	$LN36@ComRUDPQue

; 1843 : 				break;

	jmp	$LN35@ComRUDPQue
$LN26@ComRUDPQue:

; 1844 : 			case COMAPI_SEND_SOCKET:
; 1845 : 				return ((ComIP *)c)->send_sock;

	mov	ecx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [ecx+512]
	jmp	$LN36@ComRUDPQue

; 1846 : 				break;

	jmp	$LN35@ComRUDPQue
$LN25@ComRUDPQue:

; 1847 : 			case COMAPI_RELIABLE:
; 1848 : 				return 0;

	xor	eax, eax
	jmp	$LN36@ComRUDPQue

; 1849 : 				break;

	jmp	$LN35@ComRUDPQue
$LN24@ComRUDPQue:

; 1850 : 			case COMAPI_RUDP_CACHE_SIZE:
; 1851 : 				return get_rudp_max_queue_length ();

	call	_get_rudp_max_queue_length
	jmp	$LN36@ComRUDPQue

; 1852 : 				break;

	jmp	$LN35@ComRUDPQue
$LN23@ComRUDPQue:

; 1853 : 			case COMAPI_SENDER:
; 1854 : 				// We always return from the correct IP address - given packet queues.
; 1855 : 				//return CAPI_ntohl(((ComIP *)c)->address.sin_addr.s_addr);
; 1856 : 				//sfr: using lastsender like udp
; 1857 : 				return CAPI_ntohl(((ComIP *)c)->lastsender);

	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [edx+588]
	push	eax
	call	DWORD PTR _CAPI_ntohl
	jmp	$LN36@ComRUDPQue

; 1858 : 				break;

	jmp	$LN35@ComRUDPQue
$LN22@ComRUDPQue:

; 1859 : 			// sfr: converts
; 1860 : 			// port info
; 1861 : 			case COMAPI_SENDER_PORT:
; 1862 : 				return (long)(CAPI_ntohs((short)((ComIP*)c)->lastsenderport));

	mov	ecx, DWORD PTR _c$[ebp]
	movzx	edx, WORD PTR [ecx+592]
	push	edx
	call	DWORD PTR _CAPI_ntohs
	movzx	eax, ax
	jmp	$LN36@ComRUDPQue

; 1863 : 				break;

	jmp	$LN35@ComRUDPQue
$LN21@ComRUDPQue:

; 1864 : 			// sfr: id of sender
; 1865 : 			case COMAPI_ID:
; 1866 : 				return (CAPI_ntohl(((ComIP*)c)->lastsenderid));

	mov	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR [eax+596]
	push	ecx
	call	DWORD PTR _CAPI_ntohl
	jmp	$LN36@ComRUDPQue

; 1867 : 				break;

	jmp	$LN35@ComRUDPQue
$LN20@ComRUDPQue:

; 1868 : 			case COMAPI_CONNECTION_ADDRESS:
; 1869 : 				return CAPI_ntohl(((ComIP *)c)->sendAddress.sin_addr.s_addr);

	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [edx+484]
	push	eax
	call	DWORD PTR _CAPI_ntohl
	jmp	$LN36@ComRUDPQue

; 1870 : 				break;

	jmp	$LN35@ComRUDPQue
$LN19@ComRUDPQue:

; 1871 : 			case COMAPI_MAX_BUFFER_SIZE:
; 1872 : 				//          return ((ComIP *)c)->max_buffer_size - sizeof(ComAPIHeader);
; 1873 : 				return 0;

	xor	eax, eax
	jmp	$LN36@ComRUDPQue

; 1874 : 				break;

	jmp	$LN35@ComRUDPQue
$LN18@ComRUDPQue:

; 1875 : 			case COMAPI_ACTUAL_BUFFER_SIZE:
; 1876 : 				return ((ComIP *)c)->buffer_size - sizeof(ComAPIHeader);

	mov	ecx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [ecx+48]
	sub	eax, 8
	jmp	$LN36@ComRUDPQue

; 1877 : 				break;

	jmp	$LN35@ComRUDPQue
$LN17@ComRUDPQue:

; 1878 : 				
; 1879 : 			case COMAPI_PROTOCOL:
; 1880 : 				return  c->protocol;

	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [edx+4]
	jmp	$LN36@ComRUDPQue

; 1881 : 				break;

	jmp	$LN35@ComRUDPQue
$LN16@ComRUDPQue:

; 1882 : 			case COMAPI_STATE:
; 1883 : 				return  COMAPI_STATE_CONNECTED;

	mov	eax, 1
	jmp	$LN36@ComRUDPQue

; 1884 : 				break;

	jmp	$LN35@ComRUDPQue
$LN15@ComRUDPQue:

; 1885 : 			case COMAPI_RUDP_HEADER_OVERHEAD:
; 1886 : 				return MAX_RUDP_HEADER_SIZE;

	mov	eax, 17					; 00000011H
	jmp	$LN36@ComRUDPQue

; 1887 : 				break;

	jmp	$LN35@ComRUDPQue
$LN14@ComRUDPQue:

; 1888 : 
; 1889 : 			case COMAPI_PING_TIME:
; 1890 : 			{
; 1891 : 				if (((ComIP *)c)->rudp_data.reset_send == RUDP_EXIT){

	mov	eax, DWORD PTR _c$[ebp]
	cmp	DWORD PTR [eax+628], 6
	jne	SHORT $LN13@ComRUDPQue

; 1892 : 					return (unsigned long) -1;

	or	eax, -1
	jmp	$LN36@ComRUDPQue
	jmp	SHORT $LN9@ComRUDPQue
$LN13@ComRUDPQue:

; 1893 : 				}
; 1894 : 				else if (((ComIP *)c)->rudp_data.reset_send == RUDP_DROP){

	mov	ecx, DWORD PTR _c$[ebp]
	cmp	DWORD PTR [ecx+628], 7
	jne	SHORT $LN11@ComRUDPQue

; 1895 : 					return (unsigned long) -2;

	mov	eax, -2					; fffffffeH
	jmp	$LN36@ComRUDPQue

; 1896 : 				}
; 1897 : 				else {

	jmp	SHORT $LN9@ComRUDPQue
$LN11@ComRUDPQue:

; 1898 : 					int diff;
; 1899 : 					diff = GetTickCount () - ((ComIP *)c)->rudp_data.last_ping_recv_time;

	call	DWORD PTR __imp__GetTickCount@0
	mov	edx, DWORD PTR _c$[ebp]
	sub	eax, DWORD PTR [edx+708]
	mov	DWORD PTR _diff$1[ebp], eax

; 1900 : 					return diff;

	mov	eax, DWORD PTR _diff$1[ebp]
	jmp	$LN36@ComRUDPQue
$LN9@ComRUDPQue:

; 1901 : 				}
; 1902 : 			}
; 1903 : 			case COMAPI_BYTES_PENDING:
; 1904 : 			{
; 1905 : 				Reliable_Packet
; 1906 : 					*rp;	// reliable packet
; 1907 : 
; 1908 : 				int
; 1909 : 					now,
; 1910 : 					time,
; 1911 : 					size;
; 1912 : 
; 1913 : 				size = 0;

	mov	DWORD PTR _size$4[ebp], 0

; 1914 : 				now = GetTickCount ();

	call	DWORD PTR __imp__GetTickCount@0
	mov	DWORD PTR _now$3[ebp], eax

; 1915 : 
; 1916 : 				if (cudp->rudp_data.last_ping_recv_time - now > 4 * RUDP_PING_TIME){

	mov	eax, DWORD PTR _cudp$5[ebp]
	mov	ecx, DWORD PTR [eax+708]
	sub	ecx, DWORD PTR _now$3[ebp]
	cmp	ecx, 10000				; 00002710H
	jle	SHORT $LN8@ComRUDPQue

; 1917 : 					return 0;

	xor	eax, eax
	jmp	$LN36@ComRUDPQue
$LN8@ComRUDPQue:

; 1918 : 				}
; 1919 : 
; 1920 : 				rp = cudp->rudp_data.sending;

	mov	edx, DWORD PTR _cudp$5[ebp]
	mov	eax, DWORD PTR [edx+620]
	mov	DWORD PTR _rp$6[ebp], eax
$LN7@ComRUDPQue:

; 1921 : 				while (rp && !F4IsBadReadPtrC(rp, sizeof(Reliable_Packet))) // JB 010619 CTD

	cmp	DWORD PTR _rp$6[ebp], 0
	je	SHORT $LN6@ComRUDPQue
	push	24					; 00000018H
	mov	ecx, DWORD PTR _rp$6[ebp]
	push	ecx
	call	_F4IsBadReadPtrC
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN6@ComRUDPQue

; 1922 : 				{
; 1923 : 					time = RUDP_RESEND_TIME * 2;

	mov	DWORD PTR _time$2[ebp], 3000		; 00000bb8H

; 1924 : 
; 1925 : 					if ((!rp->acknowledged) && ((int)(now - rp->last_sent_at) > time)){

	mov	edx, DWORD PTR _rp$6[ebp]
	movzx	eax, BYTE PTR [edx+15]
	test	eax, eax
	jne	SHORT $LN5@ComRUDPQue
	mov	ecx, DWORD PTR _rp$6[ebp]
	mov	edx, DWORD PTR _now$3[ebp]
	sub	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR _time$2[ebp]
	jle	SHORT $LN5@ComRUDPQue

; 1926 : 						size += rp->size;

	mov	eax, DWORD PTR _rp$6[ebp]
	movzx	ecx, WORD PTR [eax+8]
	add	ecx, DWORD PTR _size$4[ebp]
	mov	DWORD PTR _size$4[ebp], ecx
$LN5@ComRUDPQue:

; 1927 : 					}
; 1928 : 
; 1929 : 					rp = rp->next;

	mov	edx, DWORD PTR _rp$6[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR _rp$6[ebp], eax

; 1930 : 				}

	jmp	SHORT $LN7@ComRUDPQue
$LN6@ComRUDPQue:

; 1931 : 
; 1932 : 				rp = cudp->rudp_data.oob_sending;

	mov	ecx, DWORD PTR _cudp$5[ebp]
	mov	edx, DWORD PTR [ecx+664]
	mov	DWORD PTR _rp$6[ebp], edx
$LN4@ComRUDPQue:

; 1933 : 				while (rp && !F4IsBadReadPtrC(rp, sizeof(Reliable_Packet))) // JB 010619 CTD

	cmp	DWORD PTR _rp$6[ebp], 0
	je	SHORT $LN3@ComRUDPQue
	push	24					; 00000018H
	mov	eax, DWORD PTR _rp$6[ebp]
	push	eax
	call	_F4IsBadReadPtrC
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN3@ComRUDPQue

; 1934 : 				{
; 1935 : 					time = RUDP_RESEND_TIME * 2;

	mov	DWORD PTR _time$2[ebp], 3000		; 00000bb8H

; 1936 : 
; 1937 : 					if ((!rp->acknowledged) && ((int)(now - rp->last_sent_at) > time)){

	mov	ecx, DWORD PTR _rp$6[ebp]
	movzx	edx, BYTE PTR [ecx+15]
	test	edx, edx
	jne	SHORT $LN2@ComRUDPQue
	mov	eax, DWORD PTR _rp$6[ebp]
	mov	ecx, DWORD PTR _now$3[ebp]
	sub	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _time$2[ebp]
	jle	SHORT $LN2@ComRUDPQue

; 1938 : 						size += rp->size;

	mov	edx, DWORD PTR _rp$6[ebp]
	movzx	eax, WORD PTR [edx+8]
	add	eax, DWORD PTR _size$4[ebp]
	mov	DWORD PTR _size$4[ebp], eax
$LN2@ComRUDPQue:

; 1939 : 					}
; 1940 : 
; 1941 : 					rp = rp->next;

	mov	ecx, DWORD PTR _rp$6[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _rp$6[ebp], edx

; 1942 : 				}

	jmp	SHORT $LN4@ComRUDPQue
$LN3@ComRUDPQue:

; 1943 : 
; 1944 : 				return size;

	mov	eax, DWORD PTR _size$4[ebp]
	jmp	SHORT $LN36@ComRUDPQue
$LN1@ComRUDPQue:

; 1945 : 			}
; 1946 : 				
; 1947 : 			default:
; 1948 : 				return 0;

	xor	eax, eax
	jmp	SHORT $LN36@ComRUDPQue
$LN35@ComRUDPQue:

; 1949 : 				
; 1950 : 		}
; 1951 : 	}
; 1952 : 	return 0;

	xor	eax, eax
$LN36@ComRUDPQue:

; 1953 : 	
; 1954 : 	
; 1955 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN40@ComRUDPQue:
	DD	$LN32@ComRUDPQue
	DD	$LN29@ComRUDPQue
	DD	$LN28@ComRUDPQue
	DD	$LN20@ComRUDPQue
	DD	$LN27@ComRUDPQue
	DD	$LN26@ComRUDPQue
	DD	$LN25@ComRUDPQue
	DD	$LN31@ComRUDPQue
	DD	$LN30@ComRUDPQue
	DD	$LN1@ComRUDPQue
	DD	$LN1@ComRUDPQue
	DD	$LN24@ComRUDPQue
	DD	$LN19@ComRUDPQue
	DD	$LN18@ComRUDPQue
	DD	$LN17@ComRUDPQue
	DD	$LN16@ComRUDPQue
	DD	$LN1@ComRUDPQue
	DD	$LN1@ComRUDPQue
	DD	$LN23@ComRUDPQue
	DD	$LN1@ComRUDPQue
	DD	$LN1@ComRUDPQue
	DD	$LN15@ComRUDPQue
	DD	$LN14@ComRUDPQue
	DD	$LN9@ComRUDPQue
	DD	$LN22@ComRUDPQue
	DD	$LN21@ComRUDPQue
_ComRUDPQuery ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\rudp.c
_TEXT	SEGMENT
_c$ = 8							; size = 4
_ComRUDPRecvBufferGet PROC

; 429  : {

	push	ebp
	mov	ebp, esp

; 430  : 	return ((ComIP *)c)->recv_buffer.buf;

	mov	eax, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [eax+72]

; 431  : }

	pop	ebp
	ret	0
_ComRUDPRecvBufferGet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\rudp.c
_TEXT	SEGMENT
_c$ = 8							; size = 4
_ComRUDPSendBufferGet PROC

; 420  : {

	push	ebp
	mov	ebp, esp

; 421  : 	return ((ComIP *)c)->send_buffer.buf;

	mov	eax, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [eax+64]

; 422  : }

	pop	ebp
	ret	0
_ComRUDPSendBufferGet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\rudp.c
_TEXT	SEGMENT
_index$ = -16						; size = 4
_offset$ = -12						; size = 4
_newsize$ = -8						; size = 4
_len$ = -4						; size = 4
_in$ = 8						; size = 4
_out$ = 12						; size = 4
_size$ = 16						; size = 4
_comms_decompress PROC

; 2242 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 2243 : 	char
; 2244 : 		*offset;
; 2245 : 	int
; 2246 : 		len,
; 2247 : 		index,
; 2248 : 		newsize;
; 2249 : 
; 2250 : 	newsize = 0;

	mov	DWORD PTR _newsize$[ebp], 0
$LN8@comms_deco:

; 2251 : 
; 2252 : 	while (newsize < size)

	mov	eax, DWORD PTR _newsize$[ebp]
	cmp	eax, DWORD PTR _size$[ebp]
	jge	$LN7@comms_deco

; 2253 : 	{
; 2254 : 		len = *in;

	mov	ecx, DWORD PTR _in$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	DWORD PTR _len$[ebp], edx

; 2255 : 		in ++;

	mov	eax, DWORD PTR _in$[ebp]
	add	eax, 1
	mov	DWORD PTR _in$[ebp], eax

; 2256 : 
; 2257 : 		if (len & 0x80)

	mov	ecx, DWORD PTR _len$[ebp]
	and	ecx, 128				; 00000080H
	je	SHORT $LN6@comms_deco

; 2258 : 		{
; 2259 : 			len = len & 0x7f;

	mov	edx, DWORD PTR _len$[ebp]
	and	edx, 127				; 0000007fH
	mov	DWORD PTR _len$[ebp], edx

; 2260 : 			index = *(unsigned char*) in;

	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _index$[ebp], ecx

; 2261 : 			in ++;

	mov	edx, DWORD PTR _in$[ebp]
	add	edx, 1
	mov	DWORD PTR _in$[ebp], edx

; 2262 : 			offset = &out[-index];

	mov	eax, DWORD PTR _index$[ebp]
	neg	eax
	add	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR _offset$[ebp], eax

; 2263 : 
; 2264 : 			newsize += len;

	mov	ecx, DWORD PTR _newsize$[ebp]
	add	ecx, DWORD PTR _len$[ebp]
	mov	DWORD PTR _newsize$[ebp], ecx
$LN5@comms_deco:

; 2265 : 
; 2266 : 			while (len)

	cmp	DWORD PTR _len$[ebp], 0
	je	SHORT $LN4@comms_deco

; 2267 : 			{
; 2268 : 				len --;

	mov	edx, DWORD PTR _len$[ebp]
	sub	edx, 1
	mov	DWORD PTR _len$[ebp], edx

; 2269 : 				*out = *offset;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _offset$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 2270 : 				out ++;

	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax

; 2271 : 				offset ++;

	mov	ecx, DWORD PTR _offset$[ebp]
	add	ecx, 1
	mov	DWORD PTR _offset$[ebp], ecx

; 2272 : 			}

	jmp	SHORT $LN5@comms_deco
$LN4@comms_deco:

; 2273 : 		}
; 2274 : 		else

	jmp	SHORT $LN3@comms_deco
$LN6@comms_deco:

; 2275 : 		{
; 2276 : 			newsize += len;

	mov	edx, DWORD PTR _newsize$[ebp]
	add	edx, DWORD PTR _len$[ebp]
	mov	DWORD PTR _newsize$[ebp], edx
$LN2@comms_deco:

; 2277 : 
; 2278 : 			while (len)

	cmp	DWORD PTR _len$[ebp], 0
	je	SHORT $LN3@comms_deco

; 2279 : 			{
; 2280 : 				len --;

	mov	eax, DWORD PTR _len$[ebp]
	sub	eax, 1
	mov	DWORD PTR _len$[ebp], eax

; 2281 : 				*out = *in;

	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR _in$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al

; 2282 : 				out ++;

	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx

; 2283 : 				in ++;

	mov	edx, DWORD PTR _in$[ebp]
	add	edx, 1
	mov	DWORD PTR _in$[ebp], edx

; 2284 : 			}

	jmp	SHORT $LN2@comms_deco
$LN3@comms_deco:

; 2285 : 		}
; 2286 : 	}

	jmp	$LN8@comms_deco
$LN7@comms_deco:

; 2287 : 
; 2288 : 	return newsize;

	mov	eax, DWORD PTR _newsize$[ebp]

; 2289 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_comms_decompress ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\rudp.c
_TEXT	SEGMENT
_best$ = -36						; size = 4
tv69 = -32						; size = 4
_best_size$ = -28					; size = 4
_ptr$ = -24						; size = 4
_loop$ = -20						; size = 4
_run$ = -16						; size = 4
_current$ = -12						; size = 4
_index$ = -8						; size = 4
_newsize$ = -4						; size = 4
_in$ = 8						; size = 4
_out$ = 12						; size = 4
_size$ = 16						; size = 4
_comms_compress PROC

; 2138 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 2139 : 	char
; 2140 : 		*current,
; 2141 : 		*ptr;
; 2142 : 
; 2143 : 	int
; 2144 : 		best,
; 2145 : 		best_size,
; 2146 : 		run,
; 2147 : 		loop,
; 2148 : 		index,
; 2149 : 		newsize;
; 2150 : 
; 2151 : 	current = out;

	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR _current$[ebp], eax

; 2152 : 	*current = 0x00;

	mov	ecx, DWORD PTR _current$[ebp]
	mov	BYTE PTR [ecx], 0

; 2153 : 	out ++;

	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx

; 2154 : 	newsize = 1;

	mov	DWORD PTR _newsize$[ebp], 1

; 2155 : 
; 2156 : 	index = 0;

	mov	DWORD PTR _index$[ebp], 0

; 2157 : 
; 2158 : 	ptr = in;

	mov	eax, DWORD PTR _in$[ebp]
	mov	DWORD PTR _ptr$[ebp], eax
$LN17@comms_comp:

; 2159 : 
; 2160 : 	while (index < size)

	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR _size$[ebp]
	jge	$LN16@comms_comp

; 2161 : 	{
; 2162 : 		best = 0;

	mov	DWORD PTR _best$[ebp], 0

; 2163 : 		best_size = 0;

	mov	DWORD PTR _best_size$[ebp], 0

; 2164 : 
; 2165 : 		for (loop = max (0, index - 127); loop < index; loop ++)

	mov	edx, DWORD PTR _index$[ebp]
	sub	edx, 127				; 0000007fH
	jns	SHORT $LN20@comms_comp
	mov	DWORD PTR tv69[ebp], 0
	jmp	SHORT $LN21@comms_comp
$LN20@comms_comp:
	mov	eax, DWORD PTR _index$[ebp]
	sub	eax, 127				; 0000007fH
	mov	DWORD PTR tv69[ebp], eax
$LN21@comms_comp:
	mov	ecx, DWORD PTR tv69[ebp]
	mov	DWORD PTR _loop$[ebp], ecx
	jmp	SHORT $LN15@comms_comp
$LN14@comms_comp:
	mov	edx, DWORD PTR _loop$[ebp]
	add	edx, 1
	mov	DWORD PTR _loop$[ebp], edx
$LN15@comms_comp:
	mov	eax, DWORD PTR _loop$[ebp]
	cmp	eax, DWORD PTR _index$[ebp]
	jge	$LN13@comms_comp

; 2166 : 		{
; 2167 : 			if (in[loop] == *ptr)

	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, DWORD PTR _loop$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _ptr$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	jne	SHORT $LN12@comms_comp

; 2168 : 			{
; 2169 : 				for (run = 1; (run < 127) && (loop + run < index) && (index + run < size); run ++)

	mov	DWORD PTR _run$[ebp], 1
	jmp	SHORT $LN11@comms_comp
$LN10@comms_comp:
	mov	edx, DWORD PTR _run$[ebp]
	add	edx, 1
	mov	DWORD PTR _run$[ebp], edx
$LN11@comms_comp:
	cmp	DWORD PTR _run$[ebp], 127		; 0000007fH
	jge	SHORT $LN12@comms_comp
	mov	eax, DWORD PTR _loop$[ebp]
	add	eax, DWORD PTR _run$[ebp]
	cmp	eax, DWORD PTR _index$[ebp]
	jge	SHORT $LN12@comms_comp
	mov	ecx, DWORD PTR _index$[ebp]
	add	ecx, DWORD PTR _run$[ebp]
	cmp	ecx, DWORD PTR _size$[ebp]
	jge	SHORT $LN12@comms_comp

; 2170 : 				{
; 2171 : 					if (in[loop + run] == ptr[run])

	mov	edx, DWORD PTR _loop$[ebp]
	add	edx, DWORD PTR _run$[ebp]
	mov	eax, DWORD PTR _in$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	mov	edx, DWORD PTR _ptr$[ebp]
	add	edx, DWORD PTR _run$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN8@comms_comp

; 2172 : 					{
; 2173 : 						if (run + 1 > best_size)

	mov	ecx, DWORD PTR _run$[ebp]
	add	ecx, 1
	cmp	ecx, DWORD PTR _best_size$[ebp]
	jle	SHORT $LN7@comms_comp

; 2174 : 						{
; 2175 : 							best_size = run + 1;

	mov	edx, DWORD PTR _run$[ebp]
	add	edx, 1
	mov	DWORD PTR _best_size$[ebp], edx

; 2176 : 							best = loop;

	mov	eax, DWORD PTR _loop$[ebp]
	mov	DWORD PTR _best$[ebp], eax
$LN7@comms_comp:

; 2177 : 						}
; 2178 : 					}
; 2179 : 					else

	jmp	SHORT $LN6@comms_comp
$LN8@comms_comp:

; 2180 : 					{
; 2181 : 						break;

	jmp	SHORT $LN12@comms_comp
$LN6@comms_comp:

; 2182 : 					}
; 2183 : 				}

	jmp	SHORT $LN10@comms_comp
$LN12@comms_comp:

; 2184 : 			}
; 2185 : 		}

	jmp	$LN14@comms_comp
$LN13@comms_comp:

; 2186 : 
; 2187 : 		if (best_size <= 2)

	cmp	DWORD PTR _best_size$[ebp], 2
	jg	SHORT $LN5@comms_comp

; 2188 : 		{
; 2189 : 			*out = *ptr;

	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR _ptr$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al

; 2190 : 			out ++;

	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx

; 2191 : 			ptr ++;

	mov	edx, DWORD PTR _ptr$[ebp]
	add	edx, 1
	mov	DWORD PTR _ptr$[ebp], edx

; 2192 : 			(*current) ++;

	mov	eax, DWORD PTR _current$[ebp]
	mov	cl, BYTE PTR [eax]
	add	cl, 1
	mov	edx, DWORD PTR _current$[ebp]
	mov	BYTE PTR [edx], cl

; 2193 : 			newsize ++;

	mov	eax, DWORD PTR _newsize$[ebp]
	add	eax, 1
	mov	DWORD PTR _newsize$[ebp], eax

; 2194 : 
; 2195 : 			if (*current == 0x78)

	mov	ecx, DWORD PTR _current$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 120				; 00000078H
	jne	SHORT $LN4@comms_comp

; 2196 : 			{
; 2197 : 				current = out;

	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR _current$[ebp], eax

; 2198 : 				*current = 0x00;

	mov	ecx, DWORD PTR _current$[ebp]
	mov	BYTE PTR [ecx], 0

; 2199 : 				out ++;

	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx

; 2200 : 				newsize ++;

	mov	eax, DWORD PTR _newsize$[ebp]
	add	eax, 1
	mov	DWORD PTR _newsize$[ebp], eax
$LN4@comms_comp:

; 2201 : 			}
; 2202 : 
; 2203 : 			index ++;

	mov	ecx, DWORD PTR _index$[ebp]
	add	ecx, 1
	mov	DWORD PTR _index$[ebp], ecx

; 2204 : 		}
; 2205 : 		else

	jmp	SHORT $LN3@comms_comp
$LN5@comms_comp:

; 2206 : 		{
; 2207 : 			if (*current == 0x00)

	mov	edx, DWORD PTR _current$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN2@comms_comp

; 2208 : 			{
; 2209 : 				out --;

	mov	ecx, DWORD PTR _out$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx

; 2210 : 				newsize --;

	mov	edx, DWORD PTR _newsize$[ebp]
	sub	edx, 1
	mov	DWORD PTR _newsize$[ebp], edx
$LN2@comms_comp:

; 2211 : 			}
; 2212 : 
; 2213 : 			*out = (char)(0x80 | best_size);

	mov	eax, DWORD PTR _best_size$[ebp]
	or	eax, 128				; 00000080H
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx], al

; 2214 : 			out ++;

	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx

; 2215 : 			*out = (char)(index - best);

	mov	eax, DWORD PTR _index$[ebp]
	sub	eax, DWORD PTR _best$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx], al

; 2216 : 			out ++;

	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx

; 2217 : 			newsize += 2;

	mov	eax, DWORD PTR _newsize$[ebp]
	add	eax, 2
	mov	DWORD PTR _newsize$[ebp], eax

; 2218 : 
; 2219 : 			current = out;

	mov	ecx, DWORD PTR _out$[ebp]
	mov	DWORD PTR _current$[ebp], ecx

; 2220 : 			*current = 0x00;

	mov	edx, DWORD PTR _current$[ebp]
	mov	BYTE PTR [edx], 0

; 2221 : 			out ++;

	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax

; 2222 : 			newsize ++;

	mov	ecx, DWORD PTR _newsize$[ebp]
	add	ecx, 1
	mov	DWORD PTR _newsize$[ebp], ecx

; 2223 : 
; 2224 : 			index += best_size;

	mov	edx, DWORD PTR _index$[ebp]
	add	edx, DWORD PTR _best_size$[ebp]
	mov	DWORD PTR _index$[ebp], edx

; 2225 : 			ptr += best_size;

	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, DWORD PTR _best_size$[ebp]
	mov	DWORD PTR _ptr$[ebp], eax
$LN3@comms_comp:

; 2226 : 		}
; 2227 : 	}

	jmp	$LN17@comms_comp
$LN16@comms_comp:

; 2228 : 
; 2229 : 	if (*current == 0x00)

	mov	ecx, DWORD PTR _current$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN1@comms_comp

; 2230 : 	{
; 2231 : 		newsize --;

	mov	eax, DWORD PTR _newsize$[ebp]
	sub	eax, 1
	mov	DWORD PTR _newsize$[ebp], eax
$LN1@comms_comp:

; 2232 : 	}
; 2233 : 
; 2234 : 	return newsize;

	mov	eax, DWORD PTR _newsize$[ebp]

; 2235 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_comms_compress ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\rudp.c
_TEXT	SEGMENT
_offset$1 = -40						; size = 4
_offset$2 = -36						; size = 4
_did_send$3 = -32					; size = 4
_now$4 = -28						; size = 4
_msg_size$5 = -24					; size = 4
_needed$6 = -20						; size = 4
_lp$7 = -16						; size = 4
_np$8 = -12						; size = 4
_cudp$9 = -8						; size = 4
_cp$10 = -4						; size = 4
_c$ = 8							; size = 4
_ComRUDPGet PROC

; 1408 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 1409 : 	if(c)

	cmp	DWORD PTR _c$[ebp], 0
	je	$LN75@ComRUDPGet

; 1410 : 	{
; 1411 : 		ComIP
; 1412 : 			*cudp;
; 1413 : 		
; 1414 : 		int
; 1415 : 			did_send = 0,

	mov	DWORD PTR _did_send$3[ebp], 0

; 1416 : 			needed,
; 1417 : 			msg_size=0;

	mov	DWORD PTR _msg_size$5[ebp], 0

; 1418 : 		
; 1419 : 		long
; 1420 : 			now;
; 1421 : 		
; 1422 : 		Reliable_Packet
; 1423 : 			*lp,	// last packet
; 1424 : 			*cp,	// current packet
; 1425 : 			*np;	// next packet
; 1426 : 		
; 1427 : 		cudp = (ComIP *)c;

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _cudp$9[ebp], eax

; 1428 : 		
; 1429 : 		now = GetTickCount();

	call	DWORD PTR __imp__GetTickCount@0
	mov	DWORD PTR _now$4[ebp], eax

; 1430 : 
; 1431 : 		// Check if we should send the reset stuff
; 1432 : 
; 1433 : 		if ((cudp->rudp_data.reset_send != RUDP_WORKING) && (now - cudp->rudp_data.last_send_time > RUDP_RESEND_TIME))

	mov	ecx, DWORD PTR _cudp$9[ebp]
	cmp	DWORD PTR [ecx+628], 5
	je	SHORT $LN74@ComRUDPGet
	mov	edx, DWORD PTR _cudp$9[ebp]
	mov	eax, DWORD PTR _now$4[ebp]
	sub	eax, DWORD PTR [edx+660]
	cmp	eax, 1500				; 000005dcH
	jbe	SHORT $LN74@ComRUDPGet

; 1434 : 		{
; 1435 : 			if (send_rudp_packet (cudp, NULL, 0)){

	push	0
	push	0
	mov	ecx, DWORD PTR _cudp$9[ebp]
	push	ecx
	call	_send_rudp_packet
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN74@ComRUDPGet

; 1436 : 				did_send = 1;

	mov	DWORD PTR _did_send$3[ebp], 1
$LN74@ComRUDPGet:

; 1437 : 			}
; 1438 : 		}
; 1439 : 
; 1440 : 		// Get all packets from this handle.
; 1441 : 		// This will copy the packets into our receive queue
; 1442 : 		get_rudp_packets (cudp);

	mov	edx, DWORD PTR _cudp$9[ebp]
	push	edx
	call	_get_rudp_packets
	add	esp, 4

; 1443 : 		
; 1444 : 		if (cudp->rudp_data.reset_send != RUDP_WORKING)

	mov	eax, DWORD PTR _cudp$9[ebp]
	cmp	DWORD PTR [eax+628], 5
	je	SHORT $LN72@ComRUDPGet

; 1445 : 		{
; 1446 : 			if (did_send)

	cmp	DWORD PTR _did_send$3[ebp], 0
	je	SHORT $LN71@ComRUDPGet

; 1447 : 			{
; 1448 : 				return -2;

	mov	eax, -2					; fffffffeH
	jmp	$LN76@ComRUDPGet

; 1449 : 			}
; 1450 : 			else

	jmp	SHORT $LN72@ComRUDPGet
$LN71@ComRUDPGet:

; 1451 : 			{
; 1452 : 				return 0;

	xor	eax, eax
	jmp	$LN76@ComRUDPGet
$LN72@ComRUDPGet:

; 1453 : 			}
; 1454 : 		}
; 1455 : 
; 1456 : 		// Ping is important
; 1457 : 		if (now - cudp->rudp_data.last_ping_send_time > RUDP_PING_TIME)

	mov	ecx, DWORD PTR _cudp$9[ebp]
	mov	edx, DWORD PTR _now$4[ebp]
	sub	edx, DWORD PTR [ecx+704]
	cmp	edx, 2500				; 000009c4H
	jle	SHORT $LN69@ComRUDPGet

; 1458 : 		{
; 1459 : 			cudp->rudp_data.reset_send = RUDP_PING;

	mov	eax, DWORD PTR _cudp$9[ebp]
	mov	DWORD PTR [eax+628], 3

; 1460 : 			send_rudp_packet (cudp, NULL, 0);

	push	0
	push	0
	mov	ecx, DWORD PTR _cudp$9[ebp]
	push	ecx
	call	_send_rudp_packet
	add	esp, 12					; 0000000cH

; 1461 : 			cudp->rudp_data.reset_send = RUDP_WORKING;

	mov	edx, DWORD PTR _cudp$9[ebp]
	mov	DWORD PTR [edx+628], 5
$LN69@ComRUDPGet:

; 1462 : 		}
; 1463 : 
; 1464 : 		// Check for completed messages
; 1465 : 		cp = cudp->rudp_data.receiving;

	mov	eax, DWORD PTR _cudp$9[ebp]
	mov	ecx, DWORD PTR [eax+652]
	mov	DWORD PTR _cp$10[ebp], ecx

; 1466 : 		lp = NULL;

	mov	DWORD PTR _lp$7[ebp], 0
$LN68@ComRUDPGet:

; 1467 : 		while (cp)

	cmp	DWORD PTR _cp$10[ebp], 0
	je	$LN67@ComRUDPGet

; 1468 : 		{
; 1469 : 			// Find the last received packet that is sequential, so 
; 1470 : 			// we can do the ack back to the other side
; 1471 : 			if ((cp) && ((cp->sequence_number & 0xffff) == ((cudp->rudp_data.last_received + 1) & 0xffff)))

	cmp	DWORD PTR _cp$10[ebp], 0
	je	SHORT $LN66@ComRUDPGet
	mov	edx, DWORD PTR _cp$10[ebp]
	movzx	eax, WORD PTR [edx+4]
	and	eax, 65535				; 0000ffffH
	mov	ecx, DWORD PTR _cudp$9[ebp]
	mov	edx, DWORD PTR [ecx+636]
	add	edx, 1
	and	edx, 65535				; 0000ffffH
	cmp	eax, edx
	jne	SHORT $LN66@ComRUDPGet

; 1472 : 			{
; 1473 : 				cudp->rudp_data.last_received = cp->sequence_number;

	mov	eax, DWORD PTR _cp$10[ebp]
	movzx	ecx, WORD PTR [eax+4]
	mov	edx, DWORD PTR _cudp$9[ebp]
	mov	DWORD PTR [edx+636], ecx
$LN66@ComRUDPGet:

; 1474 : 			}
; 1475 : 
; 1476 : 			if ((cp->sequence_number & 0xffff) == ((cudp->rudp_data.last_dispatched + 1) & 0xffff))

	mov	eax, DWORD PTR _cp$10[ebp]
	movzx	ecx, WORD PTR [eax+4]
	and	ecx, 65535				; 0000ffffH
	mov	edx, DWORD PTR _cudp$9[ebp]
	mov	eax, DWORD PTR [edx+648]
	add	eax, 1
	and	eax, 65535				; 0000ffffH
	cmp	ecx, eax
	jne	$LN65@ComRUDPGet

; 1477 : 			{
; 1478 : 				// If it's the first part of a packetized message, try to build
; 1479 : 				// the message and copy into the receive buffer
; 1480 : 				if ((!msg_size) && (cp->message_slot == 0) && (!cp->dispatched))

	cmp	DWORD PTR _msg_size$5[ebp], 0
	jne	$LN65@ComRUDPGet
	mov	ecx, DWORD PTR _cp$10[ebp]
	movzx	edx, BYTE PTR [ecx+12]
	test	edx, edx
	jne	$LN65@ComRUDPGet
	mov	eax, DWORD PTR _cp$10[ebp]
	movzx	ecx, BYTE PTR [eax+14]
	test	ecx, ecx
	jne	$LN65@ComRUDPGet

; 1481 : 				{
; 1482 : 					needed = cp->message_parts - 1;

	mov	edx, DWORD PTR _cp$10[ebp]
	movzx	eax, BYTE PTR [edx+13]
	sub	eax, 1
	mov	DWORD PTR _needed$6[ebp], eax

; 1483 : 					np = cp->next;

	mov	ecx, DWORD PTR _cp$10[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _np$8[ebp], edx
$LN63@ComRUDPGet:

; 1484 : 
; 1485 : 					//while (np && needed) // JB 010223 CTD
; 1486 : 					while (np && needed && !F4IsBadReadPtrC(np, sizeof(Reliable_Packet))) // JB 010223 CTD

	cmp	DWORD PTR _np$8[ebp], 0
	je	SHORT $LN62@ComRUDPGet
	cmp	DWORD PTR _needed$6[ebp], 0
	je	SHORT $LN62@ComRUDPGet
	push	24					; 00000018H
	mov	eax, DWORD PTR _np$8[ebp]
	push	eax
	call	_F4IsBadReadPtrC
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN62@ComRUDPGet

; 1487 : 					{
; 1488 : 						if (np->message_number == cp->message_number){

	mov	ecx, DWORD PTR _np$8[ebp]
	movzx	edx, WORD PTR [ecx+6]
	mov	eax, DWORD PTR _cp$10[ebp]
	movzx	ecx, WORD PTR [eax+6]
	cmp	edx, ecx
	jne	SHORT $LN61@ComRUDPGet

; 1489 : 							needed--;

	mov	edx, DWORD PTR _needed$6[ebp]
	sub	edx, 1
	mov	DWORD PTR _needed$6[ebp], edx
$LN61@ComRUDPGet:

; 1490 : 						}
; 1491 : 
; 1492 : 						np = np->next;

	mov	eax, DWORD PTR _np$8[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _np$8[ebp], ecx

; 1493 : 					}

	jmp	SHORT $LN63@ComRUDPGet
$LN62@ComRUDPGet:

; 1494 : 
; 1495 : 					if (!needed){

	cmp	DWORD PTR _needed$6[ebp], 0
	jne	$LN65@ComRUDPGet

; 1496 : 						// We've got the entire message, copy it into the receive buffer
; 1497 : 						np = cp;

	mov	edx, DWORD PTR _cp$10[ebp]
	mov	DWORD PTR _np$8[ebp], edx

; 1498 : 						needed = cp->message_parts;

	mov	eax, DWORD PTR _cp$10[ebp]
	movzx	ecx, BYTE PTR [eax+13]
	mov	DWORD PTR _needed$6[ebp], ecx
$LN59@ComRUDPGet:

; 1499 : 
; 1500 : 						while (np && needed){

	cmp	DWORD PTR _np$8[ebp], 0
	je	$LN65@ComRUDPGet
	cmp	DWORD PTR _needed$6[ebp], 0
	je	$LN65@ComRUDPGet

; 1501 : 							if (np->message_number == cp->message_number){

	mov	edx, DWORD PTR _np$8[ebp]
	movzx	eax, WORD PTR [edx+6]
	mov	ecx, DWORD PTR _cp$10[ebp]
	movzx	edx, WORD PTR [ecx+6]
	cmp	eax, edx
	jne	SHORT $LN57@ComRUDPGet

; 1502 : 								int offset = np->message_slot * (cudp->ideal_packet_size - MAX_RUDP_HEADER_SIZE);

	mov	eax, DWORD PTR _np$8[ebp]
	movzx	ecx, BYTE PTR [eax+12]
	mov	edx, DWORD PTR _cudp$9[ebp]
	mov	eax, DWORD PTR [edx+56]
	sub	eax, 17					; 00000011H
	imul	ecx, eax
	mov	DWORD PTR _offset$2[ebp], ecx

; 1503 : 								memcpy(cudp->recv_buffer.buf+offset, np->data, np->size);

	mov	ecx, DWORD PTR _np$8[ebp]
	movzx	edx, WORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _np$8[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _cudp$9[ebp]
	mov	eax, DWORD PTR [edx+72]
	add	eax, DWORD PTR _offset$2[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1504 : 								np->dispatched = 1;

	mov	ecx, DWORD PTR _np$8[ebp]
	mov	BYTE PTR [ecx+14], 1

; 1505 : 								free(np->data);

	mov	edx, DWORD PTR _np$8[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_free
	add	esp, 4

; 1506 : 								np->data = NULL;

	mov	ecx, DWORD PTR _np$8[ebp]
	mov	DWORD PTR [ecx+16], 0

; 1507 : 								msg_size += np->size;

	mov	edx, DWORD PTR _np$8[ebp]
	movzx	eax, WORD PTR [edx+8]
	add	eax, DWORD PTR _msg_size$5[ebp]
	mov	DWORD PTR _msg_size$5[ebp], eax

; 1508 : 								needed--;

	mov	ecx, DWORD PTR _needed$6[ebp]
	sub	ecx, 1
	mov	DWORD PTR _needed$6[ebp], ecx

; 1509 : 
; 1510 : //								MonoPrint ("Dispatching %d\n", np->sequence_number); 
; 1511 : 
; 1512 : 								cudp->rudp_data.last_dispatched = np->sequence_number;

	mov	edx, DWORD PTR _np$8[ebp]
	movzx	eax, WORD PTR [edx+4]
	mov	ecx, DWORD PTR _cudp$9[ebp]
	mov	DWORD PTR [ecx+648], eax
$LN57@ComRUDPGet:

; 1513 : 							}
; 1514 : 
; 1515 : 							np = np->next;

	mov	edx, DWORD PTR _np$8[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR _np$8[ebp], eax

; 1516 : 						}

	jmp	$LN59@ComRUDPGet
$LN65@ComRUDPGet:

; 1517 : 					}
; 1518 : 				}
; 1519 : 			}
; 1520 : 			
; 1521 : 			// if it's been dispatched, and it's less that our sequence number, 
; 1522 : 			// then remove this entry from the receive queue, we no longer 
; 1523 : 			// care about it.
; 1524 : 			if ((cp->dispatched) && ((cp->sequence_number - (cudp->rudp_data.last_received + 1)) & 0x8000))

	mov	ecx, DWORD PTR _cp$10[ebp]
	movzx	edx, BYTE PTR [ecx+14]
	test	edx, edx
	je	$LN56@ComRUDPGet
	mov	eax, DWORD PTR _cp$10[ebp]
	movzx	ecx, WORD PTR [eax+4]
	mov	edx, DWORD PTR _cudp$9[ebp]
	mov	eax, DWORD PTR [edx+636]
	add	eax, 1
	sub	ecx, eax
	and	ecx, 32768				; 00008000H
	je	SHORT $LN56@ComRUDPGet

; 1525 : 			{
; 1526 : 				if (lp)

	cmp	DWORD PTR _lp$7[ebp], 0
	je	SHORT $LN55@ComRUDPGet

; 1527 : 				{
; 1528 : 					lp->next = cp->next;

	mov	ecx, DWORD PTR _lp$7[ebp]
	mov	edx, DWORD PTR _cp$10[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx+20], eax

; 1529 : 				}
; 1530 : 				else

	jmp	SHORT $LN54@ComRUDPGet
$LN55@ComRUDPGet:

; 1531 : 				{
; 1532 : 					cudp->rudp_data.receiving = cp->next;

	mov	ecx, DWORD PTR _cudp$9[ebp]
	mov	edx, DWORD PTR _cp$10[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx+652], eax
$LN54@ComRUDPGet:

; 1533 : 				}
; 1534 : 
; 1535 : 				if (cp->data)

	mov	ecx, DWORD PTR _cp$10[ebp]
	cmp	DWORD PTR [ecx+16], 0
	je	SHORT $LN53@ComRUDPGet

; 1536 : 				{
; 1537 : 					free(cp->data);

	mov	edx, DWORD PTR _cp$10[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_free
	add	esp, 4
$LN53@ComRUDPGet:

; 1538 : 				}
; 1539 : 
; 1540 : 				free(cp);

	mov	ecx, DWORD PTR _cp$10[ebp]
	push	ecx
	call	_free
	add	esp, 4

; 1541 : 
; 1542 : 				if (lp)

	cmp	DWORD PTR _lp$7[ebp], 0
	je	SHORT $LN52@ComRUDPGet

; 1543 : 				{
; 1544 : 					cp = lp->next;

	mov	edx, DWORD PTR _lp$7[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR _cp$10[ebp], eax

; 1545 : 				}
; 1546 : 				else

	jmp	SHORT $LN51@ComRUDPGet
$LN52@ComRUDPGet:

; 1547 : 				{
; 1548 : 					cp = cudp->rudp_data.receiving;

	mov	ecx, DWORD PTR _cudp$9[ebp]
	mov	edx, DWORD PTR [ecx+652]
	mov	DWORD PTR _cp$10[ebp], edx
$LN51@ComRUDPGet:

; 1549 : 				}
; 1550 : 			}
; 1551 : 			else

	jmp	SHORT $LN50@ComRUDPGet
$LN56@ComRUDPGet:

; 1552 : 			{
; 1553 : 				lp = cp;

	mov	eax, DWORD PTR _cp$10[ebp]
	mov	DWORD PTR _lp$7[ebp], eax

; 1554 : 				cp = cp->next;

	mov	ecx, DWORD PTR _cp$10[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _cp$10[ebp], edx
$LN50@ComRUDPGet:

; 1555 : 			}
; 1556 : 		}

	jmp	$LN68@ComRUDPGet
$LN67@ComRUDPGet:

; 1557 : 		
; 1558 : 		// Check for completed oob messages
; 1559 : 		cp = cudp->rudp_data.oob_receiving;

	mov	eax, DWORD PTR _cudp$9[ebp]
	mov	ecx, DWORD PTR [eax+692]
	mov	DWORD PTR _cp$10[ebp], ecx

; 1560 : 		lp = NULL;

	mov	DWORD PTR _lp$7[ebp], 0
$LN49@ComRUDPGet:

; 1561 : 		while (cp)

	cmp	DWORD PTR _cp$10[ebp], 0
	je	$LN48@ComRUDPGet

; 1562 : 		{
; 1563 : 			// Find the last received packet that is sequential, so 
; 1564 : 			// we can do the ack back to the other side
; 1565 : 			if ((cp) && ((cp->sequence_number & 0xffff) == ((cudp->rudp_data.last_oob_received + 1) & 0xffff)))

	cmp	DWORD PTR _cp$10[ebp], 0
	je	SHORT $LN47@ComRUDPGet
	mov	edx, DWORD PTR _cp$10[ebp]
	movzx	eax, WORD PTR [edx+4]
	and	eax, 65535				; 0000ffffH
	mov	ecx, DWORD PTR _cudp$9[ebp]
	mov	edx, DWORD PTR [ecx+676]
	add	edx, 1
	and	edx, 65535				; 0000ffffH
	cmp	eax, edx
	jne	SHORT $LN47@ComRUDPGet

; 1566 : 			{
; 1567 : 				cudp->rudp_data.last_oob_received = cp->sequence_number;

	mov	eax, DWORD PTR _cp$10[ebp]
	movzx	ecx, WORD PTR [eax+4]
	mov	edx, DWORD PTR _cudp$9[ebp]
	mov	DWORD PTR [edx+676], ecx
$LN47@ComRUDPGet:

; 1568 : 			}
; 1569 : 
; 1570 : 			if ((cp->sequence_number & 0xffff) == ((cudp->rudp_data.last_oob_dispatched + 1) & 0xffff))

	mov	eax, DWORD PTR _cp$10[ebp]
	movzx	ecx, WORD PTR [eax+4]
	and	ecx, 65535				; 0000ffffH
	mov	edx, DWORD PTR _cudp$9[ebp]
	mov	eax, DWORD PTR [edx+688]
	add	eax, 1
	and	eax, 65535				; 0000ffffH
	cmp	ecx, eax
	jne	$LN46@ComRUDPGet

; 1571 : 			{
; 1572 : 				// If it's the first part of a packetized message, try to build
; 1573 : 				// the message and copy into the receive buffer
; 1574 : 				if ((!msg_size) && (cp->message_slot == 0) && (!cp->dispatched))

	cmp	DWORD PTR _msg_size$5[ebp], 0
	jne	$LN46@ComRUDPGet
	mov	ecx, DWORD PTR _cp$10[ebp]
	movzx	edx, BYTE PTR [ecx+12]
	test	edx, edx
	jne	$LN46@ComRUDPGet
	mov	eax, DWORD PTR _cp$10[ebp]
	movzx	ecx, BYTE PTR [eax+14]
	test	ecx, ecx
	jne	$LN46@ComRUDPGet

; 1575 : 				{
; 1576 : 					needed = cp->message_parts - 1;

	mov	edx, DWORD PTR _cp$10[ebp]
	movzx	eax, BYTE PTR [edx+13]
	sub	eax, 1
	mov	DWORD PTR _needed$6[ebp], eax

; 1577 : 					np = cp->next;

	mov	ecx, DWORD PTR _cp$10[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _np$8[ebp], edx
$LN44@ComRUDPGet:

; 1578 : 
; 1579 : 					while (np && needed)

	cmp	DWORD PTR _np$8[ebp], 0
	je	SHORT $LN43@ComRUDPGet
	cmp	DWORD PTR _needed$6[ebp], 0
	je	SHORT $LN43@ComRUDPGet

; 1580 : 					{
; 1581 : 						if (np->message_number == cp->message_number)

	mov	eax, DWORD PTR _np$8[ebp]
	movzx	ecx, WORD PTR [eax+6]
	mov	edx, DWORD PTR _cp$10[ebp]
	movzx	eax, WORD PTR [edx+6]
	cmp	ecx, eax
	jne	SHORT $LN42@ComRUDPGet

; 1582 : 						{
; 1583 : 							needed--;

	mov	ecx, DWORD PTR _needed$6[ebp]
	sub	ecx, 1
	mov	DWORD PTR _needed$6[ebp], ecx
$LN42@ComRUDPGet:

; 1584 : 						}
; 1585 : 
; 1586 : 						np = np->next;

	mov	edx, DWORD PTR _np$8[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR _np$8[ebp], eax

; 1587 : 					}

	jmp	SHORT $LN44@ComRUDPGet
$LN43@ComRUDPGet:

; 1588 : 
; 1589 : 					if (!needed)

	cmp	DWORD PTR _needed$6[ebp], 0
	jne	$LN46@ComRUDPGet

; 1590 : 					{
; 1591 : 						// We've got the entire message, copy it into the receive buffer
; 1592 : 						np = cp;

	mov	ecx, DWORD PTR _cp$10[ebp]
	mov	DWORD PTR _np$8[ebp], ecx

; 1593 : 						needed = cp->message_parts;

	mov	edx, DWORD PTR _cp$10[ebp]
	movzx	eax, BYTE PTR [edx+13]
	mov	DWORD PTR _needed$6[ebp], eax
$LN40@ComRUDPGet:

; 1594 : 
; 1595 : 						while (np && needed)

	cmp	DWORD PTR _np$8[ebp], 0
	je	$LN46@ComRUDPGet
	cmp	DWORD PTR _needed$6[ebp], 0
	je	$LN46@ComRUDPGet

; 1596 : 						{
; 1597 : 							if (np->message_number == cp->message_number)

	mov	ecx, DWORD PTR _np$8[ebp]
	movzx	edx, WORD PTR [ecx+6]
	mov	eax, DWORD PTR _cp$10[ebp]
	movzx	ecx, WORD PTR [eax+6]
	cmp	edx, ecx
	jne	SHORT $LN38@ComRUDPGet

; 1598 : 							{
; 1599 : 								int offset = np->message_slot * (cudp->ideal_packet_size - MAX_RUDP_HEADER_SIZE);

	mov	edx, DWORD PTR _np$8[ebp]
	movzx	eax, BYTE PTR [edx+12]
	mov	ecx, DWORD PTR _cudp$9[ebp]
	mov	edx, DWORD PTR [ecx+56]
	sub	edx, 17					; 00000011H
	imul	eax, edx
	mov	DWORD PTR _offset$1[ebp], eax

; 1600 : 								memcpy(cudp->recv_buffer.buf+offset, np->data, np->size);

	mov	eax, DWORD PTR _np$8[ebp]
	movzx	ecx, WORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _np$8[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _cudp$9[ebp]
	mov	edx, DWORD PTR [ecx+72]
	add	edx, DWORD PTR _offset$1[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1601 : 								np->dispatched = 1;

	mov	eax, DWORD PTR _np$8[ebp]
	mov	BYTE PTR [eax+14], 1

; 1602 : 								free(np->data);

	mov	ecx, DWORD PTR _np$8[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_free
	add	esp, 4

; 1603 : 								np->data = NULL;

	mov	eax, DWORD PTR _np$8[ebp]
	mov	DWORD PTR [eax+16], 0

; 1604 : 								msg_size += np->size;

	mov	ecx, DWORD PTR _np$8[ebp]
	movzx	edx, WORD PTR [ecx+8]
	add	edx, DWORD PTR _msg_size$5[ebp]
	mov	DWORD PTR _msg_size$5[ebp], edx

; 1605 : 								needed--;

	mov	eax, DWORD PTR _needed$6[ebp]
	sub	eax, 1
	mov	DWORD PTR _needed$6[ebp], eax

; 1606 : 
; 1607 : //								MonoPrint ("Dispatching OOB %d\n", np->sequence_number); 
; 1608 : 
; 1609 : 								cudp->rudp_data.last_oob_dispatched = np->sequence_number;

	mov	ecx, DWORD PTR _np$8[ebp]
	movzx	edx, WORD PTR [ecx+4]
	mov	eax, DWORD PTR _cudp$9[ebp]
	mov	DWORD PTR [eax+688], edx
$LN38@ComRUDPGet:

; 1610 : 							}
; 1611 : 
; 1612 : 							np = np->next;

	mov	ecx, DWORD PTR _np$8[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _np$8[ebp], edx

; 1613 : 						}

	jmp	$LN40@ComRUDPGet
$LN46@ComRUDPGet:

; 1614 : 					}
; 1615 : 				}
; 1616 : 			}
; 1617 : 			
; 1618 : 			// if it's been dispatched, and it's less that our sequence number, 
; 1619 : 			// then remove this entry from the receive queue, we no longer 
; 1620 : 			// care about it.
; 1621 : 			if ((cp->dispatched) && ((cp->sequence_number - (cudp->rudp_data.last_oob_received + 1)) & 0x8000))

	mov	eax, DWORD PTR _cp$10[ebp]
	movzx	ecx, BYTE PTR [eax+14]
	test	ecx, ecx
	je	$LN37@ComRUDPGet
	mov	edx, DWORD PTR _cp$10[ebp]
	movzx	eax, WORD PTR [edx+4]
	mov	ecx, DWORD PTR _cudp$9[ebp]
	mov	edx, DWORD PTR [ecx+676]
	add	edx, 1
	sub	eax, edx
	and	eax, 32768				; 00008000H
	je	SHORT $LN37@ComRUDPGet

; 1622 : 			{
; 1623 : 				if (lp)

	cmp	DWORD PTR _lp$7[ebp], 0
	je	SHORT $LN36@ComRUDPGet

; 1624 : 				{
; 1625 : 					lp->next = cp->next;

	mov	eax, DWORD PTR _lp$7[ebp]
	mov	ecx, DWORD PTR _cp$10[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx

; 1626 : 				}
; 1627 : 				else

	jmp	SHORT $LN35@ComRUDPGet
$LN36@ComRUDPGet:

; 1628 : 				{
; 1629 : 					cudp->rudp_data.oob_receiving = cp->next;

	mov	eax, DWORD PTR _cudp$9[ebp]
	mov	ecx, DWORD PTR _cp$10[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+692], edx
$LN35@ComRUDPGet:

; 1630 : 				}
; 1631 : 
; 1632 : 				if (cp->data)

	mov	eax, DWORD PTR _cp$10[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN34@ComRUDPGet

; 1633 : 				{
; 1634 : 					free(cp->data);

	mov	ecx, DWORD PTR _cp$10[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_free
	add	esp, 4
$LN34@ComRUDPGet:

; 1635 : 				}
; 1636 : 
; 1637 : 				free(cp);

	mov	eax, DWORD PTR _cp$10[ebp]
	push	eax
	call	_free
	add	esp, 4

; 1638 : 
; 1639 : 				if (lp)

	cmp	DWORD PTR _lp$7[ebp], 0
	je	SHORT $LN33@ComRUDPGet

; 1640 : 				{
; 1641 : 					cp = lp->next;

	mov	ecx, DWORD PTR _lp$7[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _cp$10[ebp], edx

; 1642 : 				}
; 1643 : 				else

	jmp	SHORT $LN32@ComRUDPGet
$LN33@ComRUDPGet:

; 1644 : 				{
; 1645 : 					cp = cudp->rudp_data.oob_receiving;

	mov	eax, DWORD PTR _cudp$9[ebp]
	mov	ecx, DWORD PTR [eax+692]
	mov	DWORD PTR _cp$10[ebp], ecx
$LN32@ComRUDPGet:

; 1646 : 				}
; 1647 : 			}
; 1648 : 			else

	jmp	SHORT $LN31@ComRUDPGet
$LN37@ComRUDPGet:

; 1649 : 			{
; 1650 : 				lp = cp;

	mov	edx, DWORD PTR _cp$10[ebp]
	mov	DWORD PTR _lp$7[ebp], edx

; 1651 : 				cp = cp->next;

	mov	eax, DWORD PTR _cp$10[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _cp$10[ebp], ecx
$LN31@ComRUDPGet:

; 1652 : 			}
; 1653 : 		}

	jmp	$LN49@ComRUDPGet
$LN48@ComRUDPGet:

; 1654 : 		
; 1655 : 		// Clean up all packets that we know got through from the sending queue..
; 1656 : 		cp = cudp->rudp_data.sending;

	mov	edx, DWORD PTR _cudp$9[ebp]
	mov	eax, DWORD PTR [edx+620]
	mov	DWORD PTR _cp$10[ebp], eax

; 1657 : 		lp = NULL;

	mov	DWORD PTR _lp$7[ebp], 0
$LN30@ComRUDPGet:

; 1658 : 
; 1659 : 		while (cp)

	cmp	DWORD PTR _cp$10[ebp], 0
	je	$LN29@ComRUDPGet

; 1660 : 		{
; 1661 : 			if ((cp->sequence_number - (cudp->rudp_data.last_sequence + 1)) & 0x8000)

	mov	ecx, DWORD PTR _cp$10[ebp]
	movzx	edx, WORD PTR [ecx+4]
	mov	eax, DWORD PTR _cudp$9[ebp]
	mov	ecx, DWORD PTR [eax+632]
	add	ecx, 1
	sub	edx, ecx
	and	edx, 32768				; 00008000H
	je	SHORT $LN28@ComRUDPGet

; 1662 : 			{
; 1663 : 				// this packet got through
; 1664 : 				// since its sequence number is less than last_sequence number
; 1665 : 				// the other guy has received
; 1666 : 
; 1667 : 				// we now accept out of sequence packets in sending queue
; 1668 : 
; 1669 : 				// assert(cudp->rudp_data.sending == cp);
; 1670 : 				
; 1671 : 				if (lp)

	cmp	DWORD PTR _lp$7[ebp], 0
	je	SHORT $LN27@ComRUDPGet

; 1672 : 				{
; 1673 : 					lp->next = cp->next;

	mov	edx, DWORD PTR _lp$7[ebp]
	mov	eax, DWORD PTR _cp$10[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [edx+20], ecx

; 1674 : 				}
; 1675 : 				else

	jmp	SHORT $LN26@ComRUDPGet
$LN27@ComRUDPGet:

; 1676 : 				{
; 1677 : 					cudp->rudp_data.sending = cp->next;

	mov	edx, DWORD PTR _cudp$9[ebp]
	mov	eax, DWORD PTR _cp$10[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [edx+620], ecx
$LN26@ComRUDPGet:

; 1678 : 				}
; 1679 : 
; 1680 : 				if (cp == cudp->rudp_data.last_sent)

	mov	edx, DWORD PTR _cudp$9[ebp]
	mov	eax, DWORD PTR _cp$10[ebp]
	cmp	eax, DWORD PTR [edx+624]
	jne	SHORT $LN25@ComRUDPGet

; 1681 : 				{
; 1682 : 					cudp->rudp_data.last_sent = lp;

	mov	ecx, DWORD PTR _cudp$9[ebp]
	mov	edx, DWORD PTR _lp$7[ebp]
	mov	DWORD PTR [ecx+624], edx
$LN25@ComRUDPGet:

; 1683 : 				}
; 1684 : 				
; 1685 : 				if (cp->data)

	mov	eax, DWORD PTR _cp$10[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN24@ComRUDPGet

; 1686 : 				{
; 1687 : 					free(cp->data);

	mov	ecx, DWORD PTR _cp$10[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_free
	add	esp, 4
$LN24@ComRUDPGet:

; 1688 : 				}
; 1689 : 
; 1690 : 				lp = NULL;

	mov	DWORD PTR _lp$7[ebp], 0

; 1691 : 				cp = cudp->rudp_data.sending;

	mov	eax, DWORD PTR _cudp$9[ebp]
	mov	ecx, DWORD PTR [eax+620]
	mov	DWORD PTR _cp$10[ebp], ecx

; 1692 : 			}
; 1693 : 			else

	jmp	SHORT $LN23@ComRUDPGet
$LN28@ComRUDPGet:

; 1694 : 			{
; 1695 : 				lp = cp;

	mov	edx, DWORD PTR _cp$10[ebp]
	mov	DWORD PTR _lp$7[ebp], edx

; 1696 : 				cp = cp->next;

	mov	eax, DWORD PTR _cp$10[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _cp$10[ebp], ecx
$LN23@ComRUDPGet:

; 1697 : 			}
; 1698 : 		}

	jmp	$LN30@ComRUDPGet
$LN29@ComRUDPGet:

; 1699 : 		
; 1700 : 		// Clean up all packets that we know got through from the oob sending queue..
; 1701 : 		cp = cudp->rudp_data.oob_sending;

	mov	edx, DWORD PTR _cudp$9[ebp]
	mov	eax, DWORD PTR [edx+664]
	mov	DWORD PTR _cp$10[ebp], eax

; 1702 : 		lp = NULL;

	mov	DWORD PTR _lp$7[ebp], 0
$LN22@ComRUDPGet:

; 1703 : 
; 1704 : 		while (cp)

	cmp	DWORD PTR _cp$10[ebp], 0
	je	$LN21@ComRUDPGet

; 1705 : 		{
; 1706 : 			if ((cp->sequence_number - (cudp->rudp_data.last_oob_sequence + 1)) & 0x8000)

	mov	ecx, DWORD PTR _cp$10[ebp]
	movzx	edx, WORD PTR [ecx+4]
	mov	eax, DWORD PTR _cudp$9[ebp]
	mov	ecx, DWORD PTR [eax+672]
	add	ecx, 1
	sub	edx, ecx
	and	edx, 32768				; 00008000H
	je	SHORT $LN20@ComRUDPGet

; 1707 : 			{
; 1708 : 				// this packet got through
; 1709 : 				// since its sequence number is less than last_sequence number
; 1710 : 				// the other guy has received
; 1711 : 
; 1712 : 				// we now accept out of sequence packets in sending queue
; 1713 : 
; 1714 : 				// assert(cudp->rudp_data.sending == cp);
; 1715 : 				
; 1716 : 				if (lp)

	cmp	DWORD PTR _lp$7[ebp], 0
	je	SHORT $LN19@ComRUDPGet

; 1717 : 				{
; 1718 : 					lp->next = cp->next;

	mov	edx, DWORD PTR _lp$7[ebp]
	mov	eax, DWORD PTR _cp$10[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [edx+20], ecx

; 1719 : 				}
; 1720 : 				else

	jmp	SHORT $LN18@ComRUDPGet
$LN19@ComRUDPGet:

; 1721 : 				{
; 1722 : 					cudp->rudp_data.oob_sending = cp->next;

	mov	edx, DWORD PTR _cudp$9[ebp]
	mov	eax, DWORD PTR _cp$10[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [edx+664], ecx
$LN18@ComRUDPGet:

; 1723 : 				}
; 1724 : 
; 1725 : 				if (cp == cudp->rudp_data.oob_last_sent)

	mov	edx, DWORD PTR _cudp$9[ebp]
	mov	eax, DWORD PTR _cp$10[ebp]
	cmp	eax, DWORD PTR [edx+668]
	jne	SHORT $LN17@ComRUDPGet

; 1726 : 				{
; 1727 : 					cudp->rudp_data.oob_last_sent = lp;

	mov	ecx, DWORD PTR _cudp$9[ebp]
	mov	edx, DWORD PTR _lp$7[ebp]
	mov	DWORD PTR [ecx+668], edx
$LN17@ComRUDPGet:

; 1728 : 				}
; 1729 : 				
; 1730 : 				if (cp->data)

	mov	eax, DWORD PTR _cp$10[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN16@ComRUDPGet

; 1731 : 				{
; 1732 : 					free(cp->data);

	mov	ecx, DWORD PTR _cp$10[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_free
	add	esp, 4
$LN16@ComRUDPGet:

; 1733 : 				}
; 1734 : 
; 1735 : 				lp = NULL;

	mov	DWORD PTR _lp$7[ebp], 0

; 1736 : 				cp = cudp->rudp_data.oob_sending;

	mov	eax, DWORD PTR _cudp$9[ebp]
	mov	ecx, DWORD PTR [eax+664]
	mov	DWORD PTR _cp$10[ebp], ecx

; 1737 : 			}
; 1738 : 			else

	jmp	SHORT $LN15@ComRUDPGet
$LN20@ComRUDPGet:

; 1739 : 			{
; 1740 : 				lp = cp;

	mov	edx, DWORD PTR _cp$10[ebp]
	mov	DWORD PTR _lp$7[ebp], edx

; 1741 : 				cp = cp->next;

	mov	eax, DWORD PTR _cp$10[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _cp$10[ebp], ecx
$LN15@ComRUDPGet:

; 1742 : 			}
; 1743 : 		}

	jmp	$LN22@ComRUDPGet
$LN21@ComRUDPGet:

; 1744 : 		
; 1745 : 		// Check if we should send an ack
; 1746 : 		// If we've not send them our last_received, or one second timeout for ack
; 1747 : 		if
; 1748 : 		(
; 1749 : 			(cudp->rudp_data.last_sent_received != cudp->rudp_data.last_received) &&
; 1750 : 			(now - cudp->rudp_data.last_send_time > RUDP_ACK_WAIT_TIME)
; 1751 : 		)

	mov	edx, DWORD PTR _cudp$9[ebp]
	mov	eax, DWORD PTR _cudp$9[ebp]
	mov	ecx, DWORD PTR [edx+640]
	cmp	ecx, DWORD PTR [eax+636]
	je	SHORT $LN14@ComRUDPGet
	mov	edx, DWORD PTR _cudp$9[ebp]
	mov	eax, DWORD PTR _now$4[ebp]
	sub	eax, DWORD PTR [edx+660]
	cmp	eax, 500				; 000001f4H
	jbe	SHORT $LN14@ComRUDPGet

; 1752 : 		{
; 1753 : 			cudp->rudp_data.last_sent_received = -1;

	mov	ecx, DWORD PTR _cudp$9[ebp]
	mov	DWORD PTR [ecx+640], -1
$LN14@ComRUDPGet:

; 1754 : 		}
; 1755 : 
; 1756 : 		if
; 1757 : 		(
; 1758 : 			(cudp->rudp_data.last_oob_sent_received != cudp->rudp_data.last_oob_received) &&
; 1759 : 			(now - cudp->rudp_data.last_oob_send_time > RUDP_OOB_ACK_WAIT_TIME)
; 1760 : 		)

	mov	edx, DWORD PTR _cudp$9[ebp]
	mov	eax, DWORD PTR _cudp$9[ebp]
	mov	ecx, DWORD PTR [edx+680]
	cmp	ecx, DWORD PTR [eax+676]
	je	SHORT $LN13@ComRUDPGet
	mov	edx, DWORD PTR _cudp$9[ebp]
	mov	eax, DWORD PTR _now$4[ebp]
	sub	eax, DWORD PTR [edx+700]
	cmp	eax, 50					; 00000032H
	jbe	SHORT $LN13@ComRUDPGet

; 1761 : 		{
; 1762 : 			cudp->rudp_data.last_oob_sent_received = -1;

	mov	ecx, DWORD PTR _cudp$9[ebp]
	mov	DWORD PTR [ecx+680], -1
$LN13@ComRUDPGet:

; 1763 : 		}
; 1764 : 
; 1765 : 		if ((cudp->rudp_data.last_sent_received == -1) || (cudp->rudp_data.last_oob_sent_received == -1))

	mov	edx, DWORD PTR _cudp$9[ebp]
	cmp	DWORD PTR [edx+640], -1
	je	SHORT $LN11@ComRUDPGet
	mov	eax, DWORD PTR _cudp$9[ebp]
	cmp	DWORD PTR [eax+680], -1
	jne	SHORT $LN12@ComRUDPGet
$LN11@ComRUDPGet:

; 1766 : 		{
; 1767 : 			if (send_rudp_packet (cudp, NULL, 0))

	push	0
	push	0
	mov	ecx, DWORD PTR _cudp$9[ebp]
	push	ecx
	call	_send_rudp_packet
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN12@ComRUDPGet

; 1768 : 			{
; 1769 : 				did_send = 1;

	mov	DWORD PTR _did_send$3[ebp], 1
$LN12@ComRUDPGet:

; 1770 : 			}
; 1771 : 		}
; 1772 : 
; 1773 : 		if ((cudp->rudp_data.send_ack) && (now - cudp->rudp_data.last_send_time > RUDP_ACK_WAIT_TIME))

	mov	edx, DWORD PTR _cudp$9[ebp]
	cmp	DWORD PTR [edx+644], 0
	je	SHORT $LN9@ComRUDPGet
	mov	eax, DWORD PTR _cudp$9[ebp]
	mov	ecx, DWORD PTR _now$4[ebp]
	sub	ecx, DWORD PTR [eax+660]
	cmp	ecx, 500				; 000001f4H
	jbe	SHORT $LN9@ComRUDPGet

; 1774 : 		{
; 1775 : 			cudp->rudp_data.send_ack = FALSE;

	mov	edx, DWORD PTR _cudp$9[ebp]
	mov	DWORD PTR [edx+644], 0

; 1776 : 			if (send_rudp_packet (cudp, NULL, 0))

	push	0
	push	0
	mov	eax, DWORD PTR _cudp$9[ebp]
	push	eax
	call	_send_rudp_packet
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN9@ComRUDPGet

; 1777 : 			{
; 1778 : 				did_send = 1;

	mov	DWORD PTR _did_send$3[ebp], 1
$LN9@ComRUDPGet:

; 1779 : 			}
; 1780 : 		}
; 1781 : 		
; 1782 : 		if ((cudp->rudp_data.send_oob_ack) && (now - cudp->rudp_data.last_oob_send_time > RUDP_ACK_WAIT_TIME))

	mov	ecx, DWORD PTR _cudp$9[ebp]
	cmp	DWORD PTR [ecx+684], 0
	je	SHORT $LN7@ComRUDPGet
	mov	edx, DWORD PTR _cudp$9[ebp]
	mov	eax, DWORD PTR _now$4[ebp]
	sub	eax, DWORD PTR [edx+700]
	cmp	eax, 500				; 000001f4H
	jbe	SHORT $LN7@ComRUDPGet

; 1783 : 		{
; 1784 : 			cudp->rudp_data.send_oob_ack = FALSE;

	mov	ecx, DWORD PTR _cudp$9[ebp]
	mov	DWORD PTR [ecx+684], 0

; 1785 : 			if (send_rudp_packet (cudp, NULL, 0))

	push	0
	push	0
	mov	edx, DWORD PTR _cudp$9[ebp]
	push	edx
	call	_send_rudp_packet
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN7@ComRUDPGet

; 1786 : 			{
; 1787 : 				did_send = 1;

	mov	DWORD PTR _did_send$3[ebp], 1
$LN7@ComRUDPGet:

; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 		// Return the size of the message we got (if any)
; 1792 : 		if (msg_size)

	cmp	DWORD PTR _msg_size$5[ebp], 0
	je	SHORT $LN5@ComRUDPGet

; 1793 : 		{
; 1794 : 			return msg_size;

	mov	eax, DWORD PTR _msg_size$5[ebp]
	jmp	SHORT $LN76@ComRUDPGet
	jmp	SHORT $LN4@ComRUDPGet
$LN5@ComRUDPGet:

; 1795 : 		}
; 1796 : 		else if (did_send)

	cmp	DWORD PTR _did_send$3[ebp], 0
	je	SHORT $LN3@ComRUDPGet

; 1797 : 		{
; 1798 : 			return -1;

	or	eax, -1
	jmp	SHORT $LN76@ComRUDPGet

; 1799 : 		}
; 1800 : 		else

	jmp	SHORT $LN4@ComRUDPGet
$LN3@ComRUDPGet:

; 1801 : 		{
; 1802 : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN76@ComRUDPGet
$LN4@ComRUDPGet:

; 1803 : 		}
; 1804 : 	}
; 1805 : 	else

	jmp	SHORT $LN76@ComRUDPGet
$LN75@ComRUDPGet:

; 1806 : 	{
; 1807 : 		return 0;

	xor	eax, eax
$LN76@ComRUDPGet:

; 1808 : 	}
; 1809 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ComRUDPGet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\rudp.c
_TEXT	SEGMENT
_c$ = 8							; size = 4
_msgsize$ = 12						; size = 4
_oob$ = 16						; size = 4
_type$ = 20						; size = 4
_Xcom$ = 24						; size = 4
_ComRUDPSendX PROC

; 438  : {

	push	ebp
	mov	ebp, esp

; 439  : 	if(c == Xcom){

	mov	eax, DWORD PTR _c$[ebp]
	cmp	eax, DWORD PTR _Xcom$[ebp]
	jne	SHORT $LN2@ComRUDPSen

; 440  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN3@ComRUDPSen

; 441  : 	}
; 442  : 	else {

	jmp	SHORT $LN3@ComRUDPSen
$LN2@ComRUDPSen:

; 443  : 		return ComRUDPSend(c, msgsize, oob, type);

	mov	ecx, DWORD PTR _type$[ebp]
	push	ecx
	mov	edx, DWORD PTR _oob$[ebp]
	push	edx
	mov	eax, DWORD PTR _msgsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	call	_ComRUDPSend
	add	esp, 16					; 00000010H
$LN3@ComRUDPSen:

; 444  : 	}
; 445  : }

	pop	ebp
	ret	0
_ComRUDPSendX ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\rudp.c
_TEXT	SEGMENT
_pp$ = -44						; size = 4
_time$ = -40						; size = 4
_now$ = -36						; size = 4
_slot$ = -32						; size = 4
_offset$ = -28						; size = 4
_parts$ = -24						; size = 4
_left$ = -20						; size = 4
_count$ = -16						; size = 4
_rp$ = -12						; size = 4
_lp$ = -8						; size = 4
_cudp$1 = -4						; size = 4
_c$ = 8							; size = 4
_msgsize$ = 12						; size = 4
_oob$ = 16						; size = 4
_type$ = 20						; size = 4
_ComRUDPSend PROC

; 696  : int ComRUDPSend(ComAPIHandle c, int msgsize, int oob, int type){

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 697  : 	Reliable_Packet *pp, *lp, *rp;
; 698  : 	
; 699  : 	int time, count, left, parts, slot=0, offset=0;

	mov	DWORD PTR _slot$[ebp], 0
	mov	DWORD PTR _offset$[ebp], 0

; 700  : 	long now;
; 701  : 
; 702  : 	if (c){

	cmp	DWORD PTR _c$[ebp], 0
	je	$LN38@ComRUDPSen

; 703  : 		ComIP *cudp = (ComIP *)c;

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _cudp$1[ebp], eax

; 704  : 		// Check for exceeding buffer
; 705  : 		if (msgsize > cudp->buffer_size){

	mov	ecx, DWORD PTR _cudp$1[ebp]
	mov	edx, DWORD PTR _msgsize$[ebp]
	cmp	edx, DWORD PTR [ecx+48]
	jle	SHORT $LN37@ComRUDPSen

; 706  : 			return COMAPI_MESSAGE_TOO_BIG;

	mov	eax, -6					; fffffffaH
	jmp	$LN39@ComRUDPSen
$LN37@ComRUDPSen:

; 707  : 		}
; 708  : 
; 709  : 		if (msgsize){

	cmp	DWORD PTR _msgsize$[ebp], 0
	je	$LN36@ComRUDPSen

; 710  : 			count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 711  : 			lp = cudp->rudp_data.sending;

	mov	eax, DWORD PTR _cudp$1[ebp]
	mov	ecx, DWORD PTR [eax+620]
	mov	DWORD PTR _lp$[ebp], ecx
$LN35@ComRUDPSen:

; 712  : 			// sfr: TODO remove JB check
; 713  : 
; 714  : 			while (lp && !F4IsBadReadPtrC(lp, sizeof(Reliable_Packet))){

	cmp	DWORD PTR _lp$[ebp], 0
	je	SHORT $LN34@ComRUDPSen
	push	24					; 00000018H
	mov	edx, DWORD PTR _lp$[ebp]
	push	edx
	call	_F4IsBadReadPtrC
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN34@ComRUDPSen

; 715  : 				count ++;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax

; 716  : 				lp = lp->next;

	mov	ecx, DWORD PTR _lp$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _lp$[ebp], edx

; 717  : 			}

	jmp	SHORT $LN35@ComRUDPSen
$LN34@ComRUDPSen:

; 718  : 			
; 719  : 			lp = cudp->rudp_data.oob_sending;

	mov	eax, DWORD PTR _cudp$1[ebp]
	mov	ecx, DWORD PTR [eax+664]
	mov	DWORD PTR _lp$[ebp], ecx
$LN33@ComRUDPSen:

; 720  : 
; 721  : 			while (lp && !F4IsBadReadPtrC(lp, sizeof(Reliable_Packet))){ // JB 010220 CTD

	cmp	DWORD PTR _lp$[ebp], 0
	je	SHORT $LN32@ComRUDPSen
	push	24					; 00000018H
	mov	edx, DWORD PTR _lp$[ebp]
	push	edx
	call	_F4IsBadReadPtrC
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN32@ComRUDPSen

; 722  : 				count ++;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax

; 723  : 				lp = lp->next;

	mov	ecx, DWORD PTR _lp$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _lp$[ebp], edx

; 724  : 			}

	jmp	SHORT $LN33@ComRUDPSen
$LN32@ComRUDPSen:

; 725  : 
; 726  : 			if (count > 0x2000){

	cmp	DWORD PTR _count$[ebp], 8192		; 00002000H
	jle	SHORT $LN31@ComRUDPSen

; 727  : 				return COMAPI_WOULDBLOCK;

	mov	eax, -8					; fffffff8H
	jmp	$LN39@ComRUDPSen
$LN31@ComRUDPSen:

; 728  : 			}
; 729  : 			
; 730  : 			// Packetize, or create a single reliable packet
; 731  : 			// NOTE: we may want to packetize only if the additional packets are reasonably sized
; 732  : 			left = msgsize;

	mov	eax, DWORD PTR _msgsize$[ebp]
	mov	DWORD PTR _left$[ebp], eax

; 733  : 			parts = 1 + ((msgsize-1) / (cudp->ideal_packet_size - MAX_RUDP_HEADER_SIZE));

	mov	eax, DWORD PTR _msgsize$[ebp]
	sub	eax, 1
	mov	ecx, DWORD PTR _cudp$1[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	sub	ecx, 17					; 00000011H
	xor	edx, edx
	div	ecx
	add	eax, 1
	mov	DWORD PTR _parts$[ebp], eax

; 734  : 			if (parts > 1){

	cmp	DWORD PTR _parts$[ebp], 1
	jle	SHORT $LN28@ComRUDPSen

; 735  : 				cudp->rudp_data.message_number++;

	mov	edx, DWORD PTR _cudp$1[ebp]
	mov	ax, WORD PTR [edx+616]
	add	ax, 1
	mov	ecx, DWORD PTR _cudp$1[ebp]
	mov	WORD PTR [ecx+616], ax

; 736  : 				if (!cudp->rudp_data.message_number){

	mov	edx, DWORD PTR _cudp$1[ebp]
	movsx	eax, WORD PTR [edx+616]
	test	eax, eax
	jne	SHORT $LN28@ComRUDPSen

; 737  : 					cudp->rudp_data.message_number = 1;

	mov	ecx, 1
	mov	edx, DWORD PTR _cudp$1[ebp]
	mov	WORD PTR [edx+616], cx
$LN28@ComRUDPSen:

; 738  : 				}
; 739  : 			}
; 740  : 
; 741  : 			while (left > 0){

	cmp	DWORD PTR _left$[ebp], 0
	jle	$LN27@ComRUDPSen

; 742  : 				// Make a new packet
; 743  : 				rp = (Reliable_Packet *) malloc (sizeof(Reliable_Packet));

	push	24					; 00000018H
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _rp$[ebp], eax

; 744  : 				rp->dispatched = FALSE;

	mov	eax, DWORD PTR _rp$[ebp]
	mov	BYTE PTR [eax+14], 0

; 745  : 				rp->send_count = 0;

	mov	ecx, DWORD PTR _rp$[ebp]
	mov	BYTE PTR [ecx+10], 0

; 746  : 				rp->oob = (unsigned char)oob;

	mov	edx, DWORD PTR _rp$[ebp]
	mov	al, BYTE PTR _oob$[ebp]
	mov	BYTE PTR [edx+11], al

; 747  : 				rp->acknowledged = FALSE;

	mov	ecx, DWORD PTR _rp$[ebp]
	mov	BYTE PTR [ecx+15], 0

; 748  : 
; 749  : 				if (oob){

	cmp	DWORD PTR _oob$[ebp], 0
	je	SHORT $LN26@ComRUDPSen

; 750  : 					cudp->rudp_data.oob_sequence_number = (unsigned short)((cudp->rudp_data.oob_sequence_number + 1) & 0xffff);

	mov	edx, DWORD PTR _cudp$1[ebp]
	movzx	eax, WORD PTR [edx+614]
	add	eax, 1
	and	eax, 65535				; 0000ffffH
	mov	ecx, DWORD PTR _cudp$1[ebp]
	mov	WORD PTR [ecx+614], ax

; 751  : 					rp->sequence_number = cudp->rudp_data.oob_sequence_number;

	mov	edx, DWORD PTR _rp$[ebp]
	mov	eax, DWORD PTR _cudp$1[ebp]
	mov	cx, WORD PTR [eax+614]
	mov	WORD PTR [edx+4], cx

; 752  : 				}
; 753  : 				else{

	jmp	SHORT $LN25@ComRUDPSen
$LN26@ComRUDPSen:

; 754  : 					cudp->rudp_data.sequence_number = (unsigned short)((cudp->rudp_data.sequence_number + 1) & 0xffff);

	mov	edx, DWORD PTR _cudp$1[ebp]
	movzx	eax, WORD PTR [edx+612]
	add	eax, 1
	and	eax, 65535				; 0000ffffH
	mov	ecx, DWORD PTR _cudp$1[ebp]
	mov	WORD PTR [ecx+612], ax

; 755  : 					rp->sequence_number = cudp->rudp_data.sequence_number;

	mov	edx, DWORD PTR _rp$[ebp]
	mov	eax, DWORD PTR _cudp$1[ebp]
	mov	cx, WORD PTR [eax+612]
	mov	WORD PTR [edx+4], cx
$LN25@ComRUDPSen:

; 756  : 				}
; 757  : 
; 758  : 				if (parts > 1){

	cmp	DWORD PTR _parts$[ebp], 1
	jle	SHORT $LN24@ComRUDPSen

; 759  : 					rp->message_number = cudp->rudp_data.message_number;

	mov	edx, DWORD PTR _rp$[ebp]
	mov	eax, DWORD PTR _cudp$1[ebp]
	mov	cx, WORD PTR [eax+616]
	mov	WORD PTR [edx+6], cx

; 760  : 				}
; 761  : 				else{

	jmp	SHORT $LN23@ComRUDPSen
$LN24@ComRUDPSen:

; 762  : 					rp->message_number = 0;

	xor	edx, edx
	mov	eax, DWORD PTR _rp$[ebp]
	mov	WORD PTR [eax+6], dx
$LN23@ComRUDPSen:

; 763  : 				}
; 764  : 
; 765  : 				rp->message_slot = (unsigned char)slot;

	mov	ecx, DWORD PTR _rp$[ebp]
	mov	dl, BYTE PTR _slot$[ebp]
	mov	BYTE PTR [ecx+12], dl

; 766  : 				rp->message_parts = (unsigned char)parts;

	mov	eax, DWORD PTR _rp$[ebp]
	mov	cl, BYTE PTR _parts$[ebp]
	mov	BYTE PTR [eax+13], cl

; 767  : 				rp->last_sent_at = 0;

	mov	edx, DWORD PTR _rp$[ebp]
	mov	DWORD PTR [edx], 0

; 768  : 
; 769  : 				if (left > cudp->ideal_packet_size - (int)MAX_RUDP_HEADER_SIZE){

	mov	eax, DWORD PTR _cudp$1[ebp]
	mov	ecx, DWORD PTR [eax+56]
	sub	ecx, 17					; 00000011H
	cmp	DWORD PTR _left$[ebp], ecx
	jle	SHORT $LN22@ComRUDPSen

; 770  : 					rp->size = (unsigned short)(cudp->ideal_packet_size - MAX_RUDP_HEADER_SIZE);

	mov	edx, DWORD PTR _cudp$1[ebp]
	mov	eax, DWORD PTR [edx+56]
	sub	eax, 17					; 00000011H
	mov	ecx, DWORD PTR _rp$[ebp]
	mov	WORD PTR [ecx+8], ax

; 771  : 				}
; 772  : 				else{

	jmp	SHORT $LN21@ComRUDPSen
$LN22@ComRUDPSen:

; 773  : 					rp->size = (unsigned short)left;

	mov	edx, DWORD PTR _rp$[ebp]
	mov	ax, WORD PTR _left$[ebp]
	mov	WORD PTR [edx+8], ax
$LN21@ComRUDPSen:

; 774  : 				}
; 775  : 
; 776  : 				rp->data = (char*)malloc (rp->size);

	mov	ecx, DWORD PTR _rp$[ebp]
	movzx	edx, WORD PTR [ecx+8]
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _rp$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 777  : 				assert (rp->data);
; 778  : 				assert (cudp->buffer_size >= (signed int) (offset  + rp->size)); // JPO check length
; 779  : 				memcpy (rp->data, cudp->send_buffer.buf+offset, rp->size);

	mov	edx, DWORD PTR _rp$[ebp]
	movzx	eax, WORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _cudp$1[ebp]
	mov	edx, DWORD PTR [ecx+64]
	add	edx, DWORD PTR _offset$[ebp]
	push	edx
	mov	eax, DWORD PTR _rp$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 780  : 
; 781  : 				// Increment our sizes
; 782  : 				left -= rp->size;

	mov	edx, DWORD PTR _rp$[ebp]
	movzx	eax, WORD PTR [edx+8]
	mov	ecx, DWORD PTR _left$[ebp]
	sub	ecx, eax
	mov	DWORD PTR _left$[ebp], ecx

; 783  : 				offset += rp->size;

	mov	edx, DWORD PTR _rp$[ebp]
	movzx	eax, WORD PTR [edx+8]
	add	eax, DWORD PTR _offset$[ebp]
	mov	DWORD PTR _offset$[ebp], eax

; 784  : 				slot++;

	mov	ecx, DWORD PTR _slot$[ebp]
	add	ecx, 1
	mov	DWORD PTR _slot$[ebp], ecx

; 785  : 				
; 786  : 				// Add the new packet to our sending list
; 787  : 
; 788  : 				if (oob){

	cmp	DWORD PTR _oob$[ebp], 0
	je	SHORT $LN20@ComRUDPSen

; 789  : 					lp = cudp->rudp_data.oob_sending;

	mov	edx, DWORD PTR _cudp$1[ebp]
	mov	eax, DWORD PTR [edx+664]
	mov	DWORD PTR _lp$[ebp], eax

; 790  : 				}
; 791  : 				else{

	jmp	SHORT $LN19@ComRUDPSen
$LN20@ComRUDPSen:

; 792  : 					lp = cudp->rudp_data.sending;

	mov	ecx, DWORD PTR _cudp$1[ebp]
	mov	edx, DWORD PTR [ecx+620]
	mov	DWORD PTR _lp$[ebp], edx
$LN19@ComRUDPSen:

; 793  : 				}
; 794  : 
; 795  : 				pp = NULL;

	mov	DWORD PTR _pp$[ebp], 0

; 796  : 				if (lp){

	cmp	DWORD PTR _lp$[ebp], 0
	je	$LN18@ComRUDPSen

; 797  : 					if (oob){

	cmp	DWORD PTR _oob$[ebp], 0
	je	SHORT $LN17@ComRUDPSen

; 798  : 						//if (cudp->rudp_data.oob_last_sent) // JB 010221 CTD
; 799  : 						if (cudp->rudp_data.oob_last_sent && !F4IsBadReadPtrC(cudp->rudp_data.oob_last_sent, sizeof(Reliable_Packet))) // JB 010221 CTD

	mov	eax, DWORD PTR _cudp$1[ebp]
	cmp	DWORD PTR [eax+668], 0
	je	SHORT $LN16@ComRUDPSen
	push	24					; 00000018H
	mov	ecx, DWORD PTR _cudp$1[ebp]
	mov	edx, DWORD PTR [ecx+668]
	push	edx
	call	_F4IsBadReadPtrC
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN16@ComRUDPSen

; 800  : 						{
; 801  : 							cudp->rudp_data.oob_last_sent->next = rp;

	mov	eax, DWORD PTR _cudp$1[ebp]
	mov	ecx, DWORD PTR [eax+668]
	mov	edx, DWORD PTR _rp$[ebp]
	mov	DWORD PTR [ecx+20], edx
$LN16@ComRUDPSen:

; 802  : 						}
; 803  : 
; 804  : 						cudp->rudp_data.oob_last_sent = rp;

	mov	eax, DWORD PTR _cudp$1[ebp]
	mov	ecx, DWORD PTR _rp$[ebp]
	mov	DWORD PTR [eax+668], ecx

; 805  : 						rp->next = NULL;

	mov	edx, DWORD PTR _rp$[ebp]
	mov	DWORD PTR [edx+20], 0

; 806  : 					}
; 807  : 					else{

	jmp	SHORT $LN15@ComRUDPSen
$LN17@ComRUDPSen:

; 808  : 						//if (cudp->rudp_data.last_sent) // JB 010221 CTD
; 809  : 						if (cudp->rudp_data.last_sent && !F4IsBadReadPtrC(cudp->rudp_data.last_sent, sizeof(Reliable_Packet))) // JB 010221 CTD

	mov	eax, DWORD PTR _cudp$1[ebp]
	cmp	DWORD PTR [eax+624], 0
	je	SHORT $LN14@ComRUDPSen
	push	24					; 00000018H
	mov	ecx, DWORD PTR _cudp$1[ebp]
	mov	edx, DWORD PTR [ecx+624]
	push	edx
	call	_F4IsBadReadPtrC
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN14@ComRUDPSen

; 810  : 						{
; 811  : 							cudp->rudp_data.last_sent->next = rp;

	mov	eax, DWORD PTR _cudp$1[ebp]
	mov	ecx, DWORD PTR [eax+624]
	mov	edx, DWORD PTR _rp$[ebp]
	mov	DWORD PTR [ecx+20], edx
$LN14@ComRUDPSen:

; 812  : 						}
; 813  : 
; 814  : 						cudp->rudp_data.last_sent = rp;

	mov	eax, DWORD PTR _cudp$1[ebp]
	mov	ecx, DWORD PTR _rp$[ebp]
	mov	DWORD PTR [eax+624], ecx

; 815  : 						rp->next = NULL;

	mov	edx, DWORD PTR _rp$[ebp]
	mov	DWORD PTR [edx+20], 0
$LN15@ComRUDPSen:

; 816  : 					}
; 817  : 				}
; 818  : 				else{

	jmp	SHORT $LN13@ComRUDPSen
$LN18@ComRUDPSen:

; 819  : 					if (oob){

	cmp	DWORD PTR _oob$[ebp], 0
	je	SHORT $LN12@ComRUDPSen

; 820  : 						cudp->rudp_data.oob_sending = cudp->rudp_data.oob_last_sent = rp;

	mov	eax, DWORD PTR _cudp$1[ebp]
	mov	ecx, DWORD PTR _rp$[ebp]
	mov	DWORD PTR [eax+668], ecx
	mov	edx, DWORD PTR _cudp$1[ebp]
	mov	eax, DWORD PTR _rp$[ebp]
	mov	DWORD PTR [edx+664], eax

; 821  : 						rp->next = NULL;

	mov	ecx, DWORD PTR _rp$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 822  : 					}
; 823  : 					else{

	jmp	SHORT $LN13@ComRUDPSen
$LN12@ComRUDPSen:

; 824  : 						cudp->rudp_data.sending = cudp->rudp_data.last_sent = rp;

	mov	edx, DWORD PTR _cudp$1[ebp]
	mov	eax, DWORD PTR _rp$[ebp]
	mov	DWORD PTR [edx+624], eax
	mov	ecx, DWORD PTR _cudp$1[ebp]
	mov	edx, DWORD PTR _rp$[ebp]
	mov	DWORD PTR [ecx+620], edx

; 825  : 						rp->next = NULL;

	mov	eax, DWORD PTR _rp$[ebp]
	mov	DWORD PTR [eax+20], 0
$LN13@ComRUDPSen:

; 826  : 					}
; 827  : 				}
; 828  : 			}

	jmp	$LN28@ComRUDPSen
$LN27@ComRUDPSen:

; 829  : 		}
; 830  : 		else{

	jmp	$LN10@ComRUDPSen
$LN36@ComRUDPSen:

; 831  : 			// If any of our sending packets are timed out
; 832  : 			// and haven't been ACK'd send them now
; 833  : 			now = GetTickCount();

	call	DWORD PTR __imp__GetTickCount@0
	mov	DWORD PTR _now$[ebp], eax

; 834  : 			lp = cudp->rudp_data.oob_sending;

	mov	ecx, DWORD PTR _cudp$1[ebp]
	mov	edx, DWORD PTR [ecx+664]
	mov	DWORD PTR _lp$[ebp], edx

; 835  : 			time = RUDP_OOB_RESEND_TIME;

	mov	DWORD PTR _time$[ebp], 750		; 000002eeH
$LN9@ComRUDPSen:

; 836  : 
; 837  : 			while (lp){

	cmp	DWORD PTR _lp$[ebp], 0
	je	SHORT $LN8@ComRUDPSen

; 838  : 				if ((!lp->acknowledged) && ((int)(now - lp->last_sent_at) > time)) // && ((lp->sequence_number - cudp->rudp_data.last_sequence - 8) & 0x8000))

	mov	eax, DWORD PTR _lp$[ebp]
	movzx	ecx, BYTE PTR [eax+15]
	test	ecx, ecx
	jne	SHORT $LN7@ComRUDPSen
	mov	edx, DWORD PTR _lp$[ebp]
	mov	eax, DWORD PTR _now$[ebp]
	sub	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _time$[ebp]
	jle	SHORT $LN7@ComRUDPSen

; 839  : 				{
; 840  : 					lp->send_count ++;

	mov	ecx, DWORD PTR _lp$[ebp]
	mov	dl, BYTE PTR [ecx+10]
	add	dl, 1
	mov	eax, DWORD PTR _lp$[ebp]
	mov	BYTE PTR [eax+10], dl

; 841  : 					
; 842  : 					if (/*(lp->oob) || */(check_bandwidth(lp->size, 1, type))){

	mov	ecx, DWORD PTR _type$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _lp$[ebp]
	movzx	eax, WORD PTR [edx+8]
	push	eax
	call	_check_bandwidth
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@ComRUDPSen

; 843  : 						return send_rudp_packet (cudp, lp, type);

	mov	ecx, DWORD PTR _type$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lp$[ebp]
	push	edx
	mov	eax, DWORD PTR _cudp$1[ebp]
	push	eax
	call	_send_rudp_packet
	add	esp, 12					; 0000000cH
	jmp	$LN39@ComRUDPSen
$LN6@ComRUDPSen:

; 844  : 					}
; 845  : 					// sfr: we dont have this anymore
; 846  : 					// TODO maybe we have to reserve its now
; 847  : 					//else
; 848  : 					//{
; 849  : 					//	rudp_bandwidth (lp->size * 2);
; 850  : 					//}
; 851  : 					return 0;

	xor	eax, eax
	jmp	$LN39@ComRUDPSen
$LN7@ComRUDPSen:

; 852  : 				}
; 853  : 
; 854  : 				lp = lp->next; // - only used if we change the "if (lp)" to a while

	mov	ecx, DWORD PTR _lp$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _lp$[ebp], edx

; 855  : 			}

	jmp	SHORT $LN9@ComRUDPSen
$LN8@ComRUDPSen:

; 856  : 
; 857  : 			now = GetTickCount();

	call	DWORD PTR __imp__GetTickCount@0
	mov	DWORD PTR _now$[ebp], eax

; 858  : 			lp = cudp->rudp_data.sending;

	mov	eax, DWORD PTR _cudp$1[ebp]
	mov	ecx, DWORD PTR [eax+620]
	mov	DWORD PTR _lp$[ebp], ecx

; 859  : 			time = RUDP_RESEND_TIME;

	mov	DWORD PTR _time$[ebp], 1500		; 000005dcH
$LN5@ComRUDPSen:

; 860  : 
; 861  : 			while (lp){

	cmp	DWORD PTR _lp$[ebp], 0
	je	SHORT $LN4@ComRUDPSen

; 862  : 				if ((!lp->acknowledged) && ((int)(now - lp->last_sent_at) > time)) // && ((lp->sequence_number - cudp->rudp_data.last_sequence - 8) & 0x8000))

	mov	edx, DWORD PTR _lp$[ebp]
	movzx	eax, BYTE PTR [edx+15]
	test	eax, eax
	jne	SHORT $LN3@ComRUDPSen
	mov	ecx, DWORD PTR _lp$[ebp]
	mov	edx, DWORD PTR _now$[ebp]
	sub	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR _time$[ebp]
	jle	SHORT $LN3@ComRUDPSen

; 863  : 				{
; 864  : 					lp->send_count ++;

	mov	eax, DWORD PTR _lp$[ebp]
	mov	cl, BYTE PTR [eax+10]
	add	cl, 1
	mov	edx, DWORD PTR _lp$[ebp]
	mov	BYTE PTR [edx+10], cl

; 865  : 					
; 866  : 					if (/*(lp->oob) || */(check_bandwidth(lp->size, 1, type))){

	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _lp$[ebp]
	movzx	edx, WORD PTR [ecx+8]
	push	edx
	call	_check_bandwidth
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN2@ComRUDPSen

; 867  : 						return send_rudp_packet (cudp, lp, type);

	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cudp$1[ebp]
	push	edx
	call	_send_rudp_packet
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN39@ComRUDPSen
$LN2@ComRUDPSen:

; 868  : 					}
; 869  : 					// sfr: we dont have this anymore
; 870  : 					// maybe we need to reserve rudp bw
; 871  : 					//else
; 872  : 					//{
; 873  : 					//	rudp_bandwidth (lp->size * 2);
; 874  : 					//}
; 875  : 
; 876  : 					return 0;

	xor	eax, eax
	jmp	SHORT $LN39@ComRUDPSen
$LN3@ComRUDPSen:

; 877  : 				}
; 878  : 
; 879  : 				lp = lp->next; // - only used if we change the "if (lp)" to a while

	mov	eax, DWORD PTR _lp$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _lp$[ebp], ecx

; 880  : 			}

	jmp	SHORT $LN5@ComRUDPSen
$LN4@ComRUDPSen:

; 881  : 
; 882  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN39@ComRUDPSen
$LN10@ComRUDPSen:

; 883  : 		}
; 884  : 		
; 885  : 		cudp->sendmessagecount++;

	mov	edx, DWORD PTR _cudp$1[ebp]
	mov	eax, DWORD PTR [edx+524]
	add	eax, 1
	mov	ecx, DWORD PTR _cudp$1[ebp]
	mov	DWORD PTR [ecx+524], eax

; 886  : 		return msgsize;

	mov	eax, DWORD PTR _msgsize$[ebp]
	jmp	SHORT $LN39@ComRUDPSen

; 887  : 	}
; 888  : 	else{

	jmp	SHORT $LN39@ComRUDPSen
$LN38@ComRUDPSen:

; 889  : 		// no comm handle
; 890  : 		return 0;

	xor	eax, eax
$LN39@ComRUDPSen:

; 891  : 	}
; 892  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ComRUDPSend ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\rudp.c
_TEXT	SEGMENT
tv151 = -28						; size = 4
tv145 = -24						; size = 4
_curr$ = -20						; size = 4
_parent$1 = -16						; size = 4
_count$ = -12						; size = 4
_sockerror$ = -8					; size = 4
_cudp$2 = -4						; size = 4
_c$ = 8							; size = 4
_ComRUDPClose PROC

; 1982 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 1983 : 	int count;
; 1984 : 	int sockerror;
; 1985 : 	CAPIList *curr = 0;

	mov	DWORD PTR _curr$[ebp], 0

; 1986 : 	
; 1987 : //	MonoPrint ("Closing RUDP\n");
; 1988 : 
; 1989 : 	if(c)

	cmp	DWORD PTR _c$[ebp], 0
	je	$LN39@ComRUDPClo

; 1990 : 	{
; 1991 : 		ComIP *cudp = (ComIP *)c;

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _cudp$2[ebp], eax

; 1992 : //		int trueValue = 1;
; 1993 : //		int falseValue = 0;
; 1994 : 
; 1995 : 		if ((cudp->rudp_data.sequence_number) || (cudp->rudp_data.oob_sequence_number))

	mov	ecx, DWORD PTR _cudp$2[ebp]
	movzx	edx, WORD PTR [ecx+612]
	test	edx, edx
	jne	SHORT $LN36@ComRUDPClo
	mov	eax, DWORD PTR _cudp$2[ebp]
	movzx	ecx, WORD PTR [eax+614]
	test	ecx, ecx
	je	SHORT $LN37@ComRUDPClo
$LN36@ComRUDPClo:

; 1996 : 		{
; 1997 : 			cudp->rudp_data.reset_send = RUDP_EXIT;

	mov	edx, DWORD PTR _cudp$2[ebp]
	mov	DWORD PTR [edx+628], 6

; 1998 : 		}
; 1999 : 		else

	jmp	SHORT $LN35@ComRUDPClo
$LN37@ComRUDPClo:

; 2000 : 		{
; 2001 : 			cudp->rudp_data.reset_send = RUDP_DROP;

	mov	eax, DWORD PTR _cudp$2[ebp]
	mov	DWORD PTR [eax+628], 7
$LN35@ComRUDPClo:

; 2002 : 		}
; 2003 : 			
; 2004 : 		for (count = 0; count < 8; count ++)

	mov	DWORD PTR _count$[ebp], 0
	jmp	SHORT $LN34@ComRUDPClo
$LN33@ComRUDPClo:
	mov	ecx, DWORD PTR _count$[ebp]
	add	ecx, 1
	mov	DWORD PTR _count$[ebp], ecx
$LN34@ComRUDPClo:
	cmp	DWORD PTR _count$[ebp], 8
	jge	SHORT $LN32@ComRUDPClo

; 2005 : 		{
; 2006 : 			send_rudp_packet (cudp, NULL, 0);

	push	0
	push	0
	mov	edx, DWORD PTR _cudp$2[ebp]
	push	edx
	call	_send_rudp_packet
	add	esp, 12					; 0000000cH

; 2007 : 			send_rudp_packet (cudp, NULL, 0);

	push	0
	push	0
	mov	eax, DWORD PTR _cudp$2[ebp]
	push	eax
	call	_send_rudp_packet
	add	esp, 12					; 0000000cH

; 2008 : 			send_rudp_packet (cudp, NULL, 0);

	push	0
	push	0
	mov	ecx, DWORD PTR _cudp$2[ebp]
	push	ecx
	call	_send_rudp_packet
	add	esp, 12					; 0000000cH

; 2009 : 			send_rudp_packet (cudp, NULL, 0);

	push	0
	push	0
	mov	edx, DWORD PTR _cudp$2[ebp]
	push	edx
	call	_send_rudp_packet
	add	esp, 12					; 0000000cH

; 2010 : 			Sleep (100);

	push	100					; 00000064H
	call	DWORD PTR __imp__Sleep@4

; 2011 : 		}

	jmp	SHORT $LN33@ComRUDPClo
$LN32@ComRUDPClo:

; 2012 : 
; 2013 : 		if (cudp->parent)

	mov	eax, DWORD PTR _cudp$2[ebp]
	cmp	DWORD PTR [eax+564], 0
	je	SHORT $LN31@ComRUDPClo

; 2014 : 		{
; 2015 : 			ComIP *parent;
; 2016 : 			parent = cudp->parent;

	mov	ecx, DWORD PTR _cudp$2[ebp]
	mov	edx, DWORD PTR [ecx+564]
	mov	DWORD PTR _parent$1[ebp], edx

; 2017 : 			//GlobalListHead = CAPIListRemove(GlobalListHead,c);
; 2018 : 			comListRemove(cudp);

	mov	eax, DWORD PTR _cudp$2[ebp]
	push	eax
	call	_comListRemove
	add	esp, 4

; 2019 : 
; 2020 : 			
; 2021 : 			if (cudp->send_buffer.buf)

	mov	ecx, DWORD PTR _cudp$2[ebp]
	cmp	DWORD PTR [ecx+64], 0
	je	SHORT $LN30@ComRUDPClo

; 2022 : 			{
; 2023 : 				free ( cudp->send_buffer.buf);

	mov	edx, DWORD PTR _cudp$2[ebp]
	mov	eax, DWORD PTR [edx+64]
	push	eax
	call	_free
	add	esp, 4
$LN30@ComRUDPClo:

; 2024 : 			}
; 2025 : 
; 2026 : 			free(cudp);

	mov	ecx, DWORD PTR _cudp$2[ebp]
	push	ecx
	call	_free
	add	esp, 4

; 2027 : 			parent->referencecount--;

	mov	edx, DWORD PTR _parent$1[ebp]
	mov	eax, DWORD PTR [edx+568]
	sub	eax, 1
	mov	ecx, DWORD PTR _parent$1[ebp]
	mov	DWORD PTR [ecx+568], eax

; 2028 : 			cudp = parent;

	mov	edx, DWORD PTR _parent$1[ebp]
	mov	DWORD PTR _cudp$2[ebp], edx

; 2029 : 		}
; 2030 : 		else 

	jmp	SHORT $LN29@ComRUDPClo
$LN31@ComRUDPClo:

; 2031 : 		{
; 2032 : 			cudp->referencecount--;

	mov	eax, DWORD PTR _cudp$2[ebp]
	mov	ecx, DWORD PTR [eax+568]
	sub	ecx, 1
	mov	edx, DWORD PTR _cudp$2[ebp]
	mov	DWORD PTR [edx+568], ecx
$LN29@ComRUDPClo:

; 2033 : 		}
; 2034 : 		
; 2035 : 		if(cudp->referencecount)

	mov	eax, DWORD PTR _cudp$2[ebp]
	cmp	DWORD PTR [eax+568], 0
	je	SHORT $LN28@ComRUDPClo

; 2036 : 		{	
; 2037 : 			return;

	jmp	$LN39@ComRUDPClo
$LN28@ComRUDPClo:

; 2038 : 		}
; 2039 : 		
; 2040 : 		//GlobalListHead = CAPIListRemove(GlobalListHead,(ComAPIHandle)cudp);
; 2041 : 		comListRemove(cudp);

	mov	ecx, DWORD PTR _cudp$2[ebp]
	push	ecx
	call	_comListRemove
	add	esp, 4

; 2042 : 		
; 2043 : 		
; 2044 : 		if (sockerror = CAPI_closesocket(cudp->recv_sock))

	mov	edx, DWORD PTR _cudp$2[ebp]
	mov	eax, DWORD PTR [edx+516]
	push	eax
	call	DWORD PTR _CAPI_closesocket
	mov	DWORD PTR _sockerror$[ebp], eax
	cmp	DWORD PTR _sockerror$[ebp], 0
	je	SHORT $LN27@ComRUDPClo

; 2045 : 		{
; 2046 : 			sockerror = CAPI_WSAGetLastError();

	call	DWORD PTR _CAPI_WSAGetLastError
	mov	DWORD PTR _sockerror$[ebp], eax

; 2047 : 			switch(sockerror)

	mov	ecx, DWORD PTR _sockerror$[ebp]
	mov	DWORD PTR tv145[ebp], ecx
$LN27@ComRUDPClo:

; 2048 : 			{
; 2049 : 				case WSANOTINITIALISED:
; 2050 : 					break;
; 2051 : 				case WSAENETDOWN:
; 2052 : 					break;
; 2053 : 				case WSAENOTSOCK:
; 2054 : 					break;
; 2055 : 				case WSAEINPROGRESS:
; 2056 : 					break;
; 2057 : 				case WSAEINTR:
; 2058 : 					break;
; 2059 : 				case WSAEWOULDBLOCK:
; 2060 : 					break;
; 2061 : 				default :
; 2062 : 					break;
; 2063 : 			}
; 2064 : 		}
; 2065 : 		
; 2066 : 		if (sockerror = CAPI_closesocket(cudp->send_sock))

	mov	edx, DWORD PTR _cudp$2[ebp]
	mov	eax, DWORD PTR [edx+512]
	push	eax
	call	DWORD PTR _CAPI_closesocket
	mov	DWORD PTR _sockerror$[ebp], eax
	cmp	DWORD PTR _sockerror$[ebp], 0
	je	SHORT $LN17@ComRUDPClo

; 2067 : 		{
; 2068 : 			sockerror = CAPI_WSAGetLastError();

	call	DWORD PTR _CAPI_WSAGetLastError
	mov	DWORD PTR _sockerror$[ebp], eax

; 2069 : 			switch(sockerror)

	mov	ecx, DWORD PTR _sockerror$[ebp]
	mov	DWORD PTR tv151[ebp], ecx
$LN17@ComRUDPClo:

; 2070 : 			{
; 2071 : 				case WSANOTINITIALISED:
; 2072 : 					break;
; 2073 : 				case WSAENETDOWN:
; 2074 : 					break;
; 2075 : 				case WSAENOTSOCK:
; 2076 : 					break;
; 2077 : 				case WSAEINPROGRESS:
; 2078 : 					break;
; 2079 : 				case WSAEINTR:
; 2080 : 					break;
; 2081 : 				case WSAEWOULDBLOCK:
; 2082 : 					break;
; 2083 : 				default :
; 2084 : 					break;
; 2085 : 			}
; 2086 : 		}
; 2087 : 
; 2088 : 		WS2Connections--;

	mov	edx, DWORD PTR _WS2Connections
	sub	edx, 1
	mov	DWORD PTR _WS2Connections, edx

; 2089 : 		
; 2090 : 		/* if No more connections then WSACleanup() */
; 2091 : 		if (!WS2Connections)

	jne	SHORT $LN7@ComRUDPClo

; 2092 : 		{
; 2093 : 			if(sockerror = CAPI_WSACleanup())

	call	DWORD PTR _CAPI_WSACleanup
	mov	DWORD PTR _sockerror$[ebp], eax
	cmp	DWORD PTR _sockerror$[ebp], 0
	je	SHORT $LN6@ComRUDPClo

; 2094 : 			{
; 2095 : 				sockerror = CAPI_WSAGetLastError();

	call	DWORD PTR _CAPI_WSAGetLastError
	mov	DWORD PTR _sockerror$[ebp], eax
$LN6@ComRUDPClo:

; 2096 : 			}
; 2097 : 
; 2098 : #ifdef LOAD_DLLS
; 2099 : 			FreeLibrary(hWinSockDLL);

	mov	eax, DWORD PTR _hWinSockDLL
	push	eax
	call	DWORD PTR __imp__FreeLibrary@4

; 2100 : 			hWinSockDLL = 0;

	mov	DWORD PTR _hWinSockDLL, 0
$LN7@ComRUDPClo:

; 2101 : #endif
; 2102 : 		}
; 2103 : 		
; 2104 : 		if(cudp->recv_buffer.buf)

	mov	ecx, DWORD PTR _cudp$2[ebp]
	cmp	DWORD PTR [ecx+72], 0
	je	SHORT $LN5@ComRUDPClo

; 2105 : 		{
; 2106 : 			free(cudp->recv_buffer.buf);

	mov	edx, DWORD PTR _cudp$2[ebp]
	mov	eax, DWORD PTR [edx+72]
	push	eax
	call	_free
	add	esp, 4
$LN5@ComRUDPClo:

; 2107 : 		}
; 2108 : 
; 2109 : 		if(cudp->send_buffer.buf)

	mov	ecx, DWORD PTR _cudp$2[ebp]
	cmp	DWORD PTR [ecx+64], 0
	je	SHORT $LN4@ComRUDPClo

; 2110 : 		{
; 2111 : 			free(cudp->send_buffer.buf);

	mov	edx, DWORD PTR _cudp$2[ebp]
	mov	eax, DWORD PTR [edx+64]
	push	eax
	call	_free
	add	esp, 4
$LN4@ComRUDPClo:

; 2112 : 		}
; 2113 : 
; 2114 : 		if(cudp->rudp_data.real_send_buffer)

	mov	ecx, DWORD PTR _cudp$2[ebp]
	cmp	DWORD PTR [ecx+712], 0
	je	SHORT $LN3@ComRUDPClo

; 2115 : 		{
; 2116 : 			free(cudp->rudp_data.real_send_buffer);

	mov	edx, DWORD PTR _cudp$2[ebp]
	mov	eax, DWORD PTR [edx+712]
	push	eax
	call	_free
	add	esp, 4
$LN3@ComRUDPClo:

; 2117 : 		}
; 2118 : 
; 2119 : 		if(cudp->compression_buffer)

	mov	ecx, DWORD PTR _cudp$2[ebp]
	cmp	DWORD PTR [ecx+476], 0
	je	SHORT $LN2@ComRUDPClo

; 2120 : 		{
; 2121 : 			free(cudp->compression_buffer);

	mov	edx, DWORD PTR _cudp$2[ebp]
	mov	eax, DWORD PTR [edx+476]
	push	eax
	call	_free
	add	esp, 4
$LN2@ComRUDPClo:

; 2122 : 		}
; 2123 : 
; 2124 : 		// JB 010718 remove the protocol test?
; 2125 : 		if (c->protocol >=0 && c->protocol <= CAPI_LAST_PROTOCOL &&// JB 010222 CTD
; 2126 : 			!F4IsBadReadPtrC(cudp, sizeof(ComIP))) // JB 010710 CTD

	mov	ecx, DWORD PTR _c$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jl	SHORT $LN39@ComRUDPClo
	mov	edx, DWORD PTR _c$[ebp]
	cmp	DWORD PTR [edx+4], 11			; 0000000bH
	jg	SHORT $LN39@ComRUDPClo
	push	716					; 000002ccH
	mov	eax, DWORD PTR _cudp$2[ebp]
	push	eax
	call	_F4IsBadReadPtrC
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN39@ComRUDPClo

; 2127 : 		{
; 2128 : 			free(cudp);

	mov	ecx, DWORD PTR _cudp$2[ebp]
	push	ecx
	call	_free
	add	esp, 4
$LN39@ComRUDPClo:

; 2129 : 		}
; 2130 : 	}
; 2131 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ComRUDPClose ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\comms\rudp.c
_TEXT	SEGMENT
_ret_val$1 = -428					; size = 4
_err$ = -424						; size = 4
_comRUDP$ = -420					; size = 4
_trueValue$ = -416					; size = 4
_size$ = -412						; size = 4
_c$ = -408						; size = 4
_wsaData$ = -404					; size = 400
__$ArrayPad$ = -4					; size = 4
_name_in$ = 8						; size = 4
_buffersize$ = 12					; size = 4
_gamename$ = 16						; size = 4
_localPort$ = 20					; size = 2
_remotePort$ = 24					; size = 2
_IPaddress$ = 28					; size = 4
_id$ = 32						; size = 4
_idealpacketsize$ = 36					; size = 4
_ComRUDPOpen PROC

; 240  : ){

	push	ebp
	mov	ebp, esp
	sub	esp, 428				; 000001acH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 241  : 	ComIP *c;
; 242  : 	unsigned long trueValue = 1;

	mov	DWORD PTR _trueValue$[ebp], 1

; 243  : 	int	err, size;
; 244  : 	//CAPIList *listitem, *curr = 0;
; 245  : 	ComIP *comRUDP;
; 246  : 	WSADATA wsaData;
; 247  : 
; 248  : 	// capi critical section 
; 249  : 	enter_cs ();

	call	_enter_cs

; 250  : 	// init socket stuff
; 251  : 	if (InitWS2(&wsaData) == 0) {

	lea	eax, DWORD PTR _wsaData$[ebp]
	push	eax
	call	_InitWS2
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN7@ComRUDPOpe

; 252  : 		leave_cs ();

	call	_leave_cs

; 253  : 		return 0;

	xor	eax, eax
	jmp	$LN8@ComRUDPOpe
$LN7@ComRUDPOpe:

; 254  : 	}
; 255  : 	
; 256  : 	// we already setup comms, use a clone
; 257  : 	comRUDP = comListFindProtocolRport(CAPI_RUDP_PROTOCOL, localPort);

	movzx	ecx, WORD PTR _localPort$[ebp]
	push	ecx
	push	10					; 0000000aH
	call	_comListFindProtocolRport
	add	esp, 8
	mov	DWORD PTR _comRUDP$[ebp], eax

; 258  : 	if (comRUDP != NULL){

	cmp	DWORD PTR _comRUDP$[ebp], 0
	je	SHORT $LN6@ComRUDPOpe

; 259  : 		ComAPIHandle ret_val;
; 260  : 		ret_val = ComRUDPOpenSendClone(name_in, comRUDP, buffersize, gamename, remotePort, IPaddress, id);

	mov	edx, DWORD PTR _id$[ebp]
	push	edx
	mov	eax, DWORD PTR _IPaddress$[ebp]
	push	eax
	movzx	ecx, WORD PTR _remotePort$[ebp]
	push	ecx
	mov	edx, DWORD PTR _gamename$[ebp]
	push	edx
	mov	eax, DWORD PTR _buffersize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _comRUDP$[ebp]
	push	ecx
	mov	edx, DWORD PTR _name_in$[ebp]
	push	edx
	call	_ComRUDPOpenSendClone
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _ret_val$1[ebp], eax

; 261  : 		leave_cs ();

	call	_leave_cs

; 262  : 		return ret_val;

	mov	eax, DWORD PTR _ret_val$1[ebp]
	jmp	$LN8@ComRUDPOpe
$LN6@ComRUDPOpe:

; 263  : 	}
; 264  : 	
; 265  : 	// allocate and zero
; 266  : 	c = (ComIP*)malloc(sizeof(ComIP));

	push	716					; 000002ccH
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _c$[ebp], eax

; 267  : 	memset(c, 0, sizeof(ComIP));

	push	716					; 000002ccH
	push	0
	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 268  : 	((ComAPIHandle)c)->name = strdup(name_in);

	mov	ecx, DWORD PTR _name_in$[ebp]
	push	ecx
	call	_strdup
	add	esp, 4
	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [edx], eax

; 269  : 
; 270  : 
; 271  : 	// sfr: get ID instead of IP if IP is flag
; 272  : 	if (IPaddress == CAPI_DANGLING_IP){

	cmp	DWORD PTR _IPaddress$[ebp], -1
	jne	SHORT $LN5@ComRUDPOpe

; 273  : 		ComIPHostIDGet(&c->apiheader, (char*)&IPaddress, 0);

	push	0
	lea	eax, DWORD PTR _IPaddress$[ebp]
	push	eax
	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	call	_ComIPHostIDGet
	add	esp, 12					; 0000000cH

; 274  : 		IPaddress = CAPI_htonl (IPaddress);

	mov	edx, DWORD PTR _IPaddress$[ebp]
	push	edx
	call	DWORD PTR _CAPI_htonl
	mov	DWORD PTR _IPaddress$[ebp], eax
$LN5@ComRUDPOpe:

; 275  : 	}
; 276  : 
; 277  : 	// initialize header data
; 278  : 	c->apiheader.protocol = CAPI_RUDP_PROTOCOL;

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+4], 10			; 0000000aH

; 279  : 	c->apiheader.send_func = ComRUDPSend;

	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+8], OFFSET _ComRUDPSend

; 280  : 	c->apiheader.sendX_func = ComRUDPSendX;

	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [edx+16], OFFSET _ComRUDPSendX

; 281  : 	c->apiheader.recv_func = ComRUDPGet;

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+20], OFFSET _ComRUDPGet

; 282  : 	c->apiheader.send_buf_func = ComRUDPSendBufferGet;

	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+24], OFFSET _ComRUDPSendBufferGet

; 283  : 	c->apiheader.recv_buf_func = ComRUDPRecvBufferGet;

	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [edx+28], OFFSET _ComRUDPRecvBufferGet

; 284  : 	c->apiheader.addr_func = ComIPHostIDGet;

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+32], OFFSET _ComIPHostIDGet

; 285  : 	c->apiheader.close_func = ComRUDPClose;

	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+36], OFFSET _ComRUDPClose

; 286  : 	c->apiheader.query_func = ComRUDPQuery;

	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [edx+40], OFFSET _ComRUDPQuery

; 287  : 	c->apiheader.get_timestamp_func = ComRUDPGetTimeStamp;

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+44], OFFSET _ComRUDPGetTimeStamp

; 288  : 	c->sendmessagecount = 0;

	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+524], 0

; 289  : 	c->recvmessagecount = 0;

	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [edx+520], 0

; 290  : 	c->recvwouldblockcount = 0;

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+528], 0

; 291  : 	c->sendwouldblockcount = 0;

	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+532], 0

; 292  : 	c->referencecount = 1;

	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [edx+568], 1

; 293  : 	c->timestamp = 0;

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+600], 0

; 294  : 	c->max_buffer_size = 0;

	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+52], 0

; 295  : 	c->ideal_packet_size = idealpacketsize;

	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR _idealpacketsize$[ebp]
	mov	DWORD PTR [edx+56], eax

; 296  : 	
; 297  : 	memset (&c->rudp_data, 0, sizeof (Reliable_Data));

	push	104					; 00000068H
	push	0
	mov	ecx, DWORD PTR _c$[ebp]
	add	ecx, 612				; 00000264H
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 298  : 	
; 299  : 	c->recv_sock = CAPI_socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

	push	17					; 00000011H
	push	2
	push	2
	call	DWORD PTR _CAPI_socket
	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [edx+516], eax

; 300  : 
; 301  : 	size = CAPI_SENDBUFSIZE;

	mov	DWORD PTR _size$[ebp], 1024		; 00000400H

; 302  : 	CAPI_setsockopt (c->recv_sock, SOL_SOCKET, SO_SNDBUF, (char*) &size, 4);

	push	4
	lea	eax, DWORD PTR _size$[ebp]
	push	eax
	push	4097					; 00001001H
	push	65535					; 0000ffffH
	mov	ecx, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR [ecx+516]
	push	edx
	call	DWORD PTR _CAPI_setsockopt

; 303  : 	size = CAPI_RECVBUFSIZE;

	mov	DWORD PTR _size$[ebp], 65536		; 00010000H

; 304  : 	CAPI_setsockopt (c->recv_sock, SOL_SOCKET, SO_RCVBUF, (char*) &size, 4);

	push	4
	lea	eax, DWORD PTR _size$[ebp]
	push	eax
	push	4098					; 00001002H
	push	65535					; 0000ffffH
	mov	ecx, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR [ecx+516]
	push	edx
	call	DWORD PTR _CAPI_setsockopt

; 305  : 	
; 306  : 	CAPI_ioctlsocket(c->recv_sock, FIONBIO, &trueValue);

	lea	eax, DWORD PTR _trueValue$[ebp]
	push	eax
	push	-2147195266				; 8004667eH
	mov	ecx, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR [ecx+516]
	push	edx
	call	DWORD PTR _CAPI_ioctlsocket

; 307  : 
; 308  : 	c->buffer_size = sizeof(ComAPIHeader) + buffersize;

	mov	eax, DWORD PTR _buffersize$[ebp]
	add	eax, 8
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+48], eax

; 309  : 	
; 310  : 	if ((c->max_buffer_size > 0) && (c->buffer_size  > c->max_buffer_size))

	mov	edx, DWORD PTR _c$[ebp]
	cmp	DWORD PTR [edx+52], 0
	jle	SHORT $LN4@ComRUDPOpe
	mov	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR [eax+48]
	cmp	edx, DWORD PTR [ecx+52]
	jle	SHORT $LN4@ComRUDPOpe

; 311  : 	{
; 312  : 		c->buffer_size = c->max_buffer_size;

	mov	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	DWORD PTR [eax+48], edx
$LN4@ComRUDPOpe:

; 313  : 	}
; 314  : 
; 315  : 	c->recv_buffer.buf = (char *)malloc(c->buffer_size);

	mov	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	push	ecx
	call	_malloc
	add	esp, 4
	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [edx+72], eax

; 316  : 	c->recv_buffer.len = c->buffer_size;

	mov	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR [eax+68], edx

; 317  : 	c->send_buffer.buf = (char *)malloc(c->buffer_size);

	mov	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	push	ecx
	call	_malloc
	add	esp, 4
	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [edx+64], eax

; 318  : 	c->rudp_data.real_send_buffer = (char *)malloc(c->buffer_size);

	mov	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	push	ecx
	call	_malloc
	add	esp, 4
	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [edx+712], eax

; 319  : 	
; 320  : 	c->compression_buffer = (char *)malloc(c->buffer_size);

	mov	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	push	ecx
	call	_malloc
	add	esp, 4
	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [edx+476], eax

; 321  : 	
; 322  : 	//sfr: store as network. function returns host
; 323  : 	ComIPHostIDGet(&c->apiheader, (char *)&c->whoami, 0);

	push	0
	mov	eax, DWORD PTR _c$[ebp]
	add	eax, 580				; 00000244H
	push	eax
	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	call	_ComIPHostIDGet
	add	esp, 12					; 0000000cH

; 324  : 	c->whoami = CAPI_htonl(c->whoami);

	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [edx+580]
	push	eax
	call	DWORD PTR _CAPI_htonl
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+580], eax

; 325  : 
; 326  : 	
; 327  : 	strncpy(((ComAPIHeader *)c->rudp_data.real_send_buffer)->gamename, gamename, GAME_NAME_LENGTH);

	push	4
	mov	edx, DWORD PTR _gamename$[ebp]
	push	edx
	mov	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR [eax+712]
	push	ecx
	call	_strncpy
	add	esp, 12					; 0000000cH

; 328  : 	//sfr id network order
; 329  : 	((ComAPIHeader *)c->rudp_data.real_send_buffer)->id = c->whoami;

	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [edx+712]
	mov	ecx, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR [ecx+580]
	mov	DWORD PTR [eax+4], edx

; 330  : 
; 331  : 	CAPI_ioctlsocket(c->recv_sock, FIONBIO, &trueValue);

	lea	eax, DWORD PTR _trueValue$[ebp]
	push	eax
	push	-2147195266				; 8004667eH
	mov	ecx, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR [ecx+516]
	push	edx
	call	DWORD PTR _CAPI_ioctlsocket

; 332  : 
; 333  : 	if(c->recv_sock == INVALID_SOCKET) {

	mov	eax, DWORD PTR _c$[ebp]
	cmp	DWORD PTR [eax+516], -1
	jne	SHORT $LN3@ComRUDPOpe

; 334  : 		leave_cs ();

	call	_leave_cs

; 335  : 		return 0;

	xor	eax, eax
	jmp	$LN8@ComRUDPOpe
$LN3@ComRUDPOpe:

; 336  : 	}
; 337  : 	
; 338  : 	// Incoming...
; 339  : 	memset ((char*)&comRecvAddr, 0, sizeof(comRecvAddr));

	push	16					; 00000010H
	push	0
	push	OFFSET _comRecvAddr
	call	_memset
	add	esp, 12					; 0000000cH

; 340  : 	comRecvAddr.sin_family       = AF_INET;

	mov	ecx, 2
	mov	WORD PTR _comRecvAddr, cx

; 341  : 	comRecvAddr.sin_addr.s_addr  = CAPI_htonl(INADDR_ANY);

	push	0
	call	DWORD PTR _CAPI_htonl
	mov	DWORD PTR _comRecvAddr+4, eax

; 342  : 	comRecvAddr.sin_port         = CAPI_htons(localPort);

	movzx	edx, WORD PTR _localPort$[ebp]
	push	edx
	call	DWORD PTR _CAPI_htons
	mov	WORD PTR _comRecvAddr+2, ax

; 343  : 	memcpy(&c->recAddress, &comRecvAddr, sizeof(struct sockaddr_in));

	push	16					; 00000010H
	push	OFFSET _comRecvAddr
	mov	eax, DWORD PTR _c$[ebp]
	add	eax, 496				; 000001f0H
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 344  : 
; 345  : 	err = CAPI_bind(c->recv_sock, (struct sockaddr*)&comRecvAddr,sizeof(comRecvAddr));

	push	16					; 00000010H
	push	OFFSET _comRecvAddr
	mov	ecx, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR [ecx+516]
	push	edx
	call	DWORD PTR _CAPI_bind
	mov	DWORD PTR _err$[ebp], eax

; 346  : 	if (err) {

	cmp	DWORD PTR _err$[ebp], 0
	je	SHORT $LN2@ComRUDPOpe

; 347  : 		leave_cs ();

	call	_leave_cs

; 348  : 		return 0;

	xor	eax, eax
	jmp	$LN8@ComRUDPOpe
$LN2@ComRUDPOpe:

; 349  : 	}
; 350  : 	
; 351  : 	//c->send_sock = CAPI_socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
; 352  : 	c->send_sock = c->recv_sock;

	mov	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR [ecx+516]
	mov	DWORD PTR [eax+512], edx

; 353  : 	
; 354  : 	size = CAPI_SENDBUFSIZE;

	mov	DWORD PTR _size$[ebp], 1024		; 00000400H

; 355  : 	CAPI_setsockopt (c->send_sock, SOL_SOCKET, SO_SNDBUF, (char*) &size, 4);

	push	4
	lea	eax, DWORD PTR _size$[ebp]
	push	eax
	push	4097					; 00001001H
	push	65535					; 0000ffffH
	mov	ecx, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR [ecx+512]
	push	edx
	call	DWORD PTR _CAPI_setsockopt

; 356  : 	size = CAPI_RECVBUFSIZE;

	mov	DWORD PTR _size$[ebp], 65536		; 00010000H

; 357  : 	CAPI_setsockopt (c->send_sock, SOL_SOCKET, SO_RCVBUF, (char*) &size, 4);

	push	4
	lea	eax, DWORD PTR _size$[ebp]
	push	eax
	push	4098					; 00001002H
	push	65535					; 0000ffffH
	mov	ecx, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR [ecx+512]
	push	edx
	call	DWORD PTR _CAPI_setsockopt

; 358  : 	
; 359  : 	if (c->send_sock == INVALID_SOCKET) {

	mov	eax, DWORD PTR _c$[ebp]
	cmp	DWORD PTR [eax+512], -1
	jne	SHORT $LN1@ComRUDPOpe

; 360  : 		leave_cs ();

	call	_leave_cs

; 361  : 		return 0;

	xor	eax, eax
	jmp	$LN8@ComRUDPOpe
$LN1@ComRUDPOpe:

; 362  : 	}
; 363  : 	/**  .. on ISPs modem maybe better to set to Non-Blocking on send **/
; 364  : 	CAPI_ioctlsocket(c->send_sock, FIONBIO, &trueValue);

	lea	ecx, DWORD PTR _trueValue$[ebp]
	push	ecx
	push	-2147195266				; 8004667eH
	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [edx+512]
	push	eax
	call	DWORD PTR _CAPI_ioctlsocket

; 365  : 	
; 366  : 	/* Outgoing... */
; 367  : 	memset ((char*)&c->sendAddress, 0, sizeof(c->sendAddress));

	push	16					; 00000010H
	push	0
	mov	ecx, DWORD PTR _c$[ebp]
	add	ecx, 480				; 000001e0H
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 368  : 	c->sendAddress.sin_family       = AF_INET;

	mov	edx, 2
	mov	eax, DWORD PTR _c$[ebp]
	mov	WORD PTR [eax+480], dx

; 369  : 	c->sendAddress.sin_addr.s_addr  = CAPI_htonl(IPaddress);

	mov	ecx, DWORD PTR _IPaddress$[ebp]
	push	ecx
	call	DWORD PTR _CAPI_htonl
	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [edx+484], eax

; 370  : 	c->sendAddress.sin_port         = CAPI_htons(remotePort);

	movzx	eax, WORD PTR _remotePort$[ebp]
	push	eax
	call	DWORD PTR _CAPI_htons
	mov	ecx, DWORD PTR _c$[ebp]
	mov	WORD PTR [ecx+482], ax

; 371  : 	
; 372  : 	c->rudp_data.sequence_number = 0;		/* sequence number for sending */

	xor	edx, edx
	mov	eax, DWORD PTR _c$[ebp]
	mov	WORD PTR [eax+612], dx

; 373  : 	c->rudp_data.oob_sequence_number = 0;		/* sequence number for sending */

	xor	ecx, ecx
	mov	edx, DWORD PTR _c$[ebp]
	mov	WORD PTR [edx+614], cx

; 374  : 	c->rudp_data.message_number = 0;		/* message number for sending */

	xor	eax, eax
	mov	ecx, DWORD PTR _c$[ebp]
	mov	WORD PTR [ecx+616], ax

; 375  : 	c->rudp_data.sending = 0;				/* list of sent packets */

	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [edx+620], 0

; 376  : 	c->rudp_data.oob_sending = 0;				/* list of sent packets */

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+664], 0

; 377  : 	c->rudp_data.last_sent = 0;				/* list of sent packets */

	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+624], 0

; 378  : 	c->rudp_data.oob_last_sent = 0;				/* list of sent packets */

	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [edx+668], 0

; 379  : 
; 380  : 	c->rudp_data.reset_send = 0;			/* I need to get a S0 or I send a reset */

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+628], 0

; 381  : 
; 382  : 	c->rudp_data.send_ack = 0;

	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+644], 0

; 383  : 	c->rudp_data.send_oob_ack = 0;

	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [edx+684], 0

; 384  : 	c->rudp_data.last_sequence = 0;			/* other's last seen sequence number */

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+632], 0

; 385  : 	c->rudp_data.last_oob_sequence = 0;			/* other's last seen sequence number */

	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+672], 0

; 386  : 	c->rudp_data.last_received = 0;			/* my last received sequential sequence number for ack.*/

	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [edx+636], 0

; 387  : 	c->rudp_data.last_oob_received = 0;			/* my last received sequential sequence number for ack.*/

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+676], 0

; 388  : 	c->rudp_data.last_sent_received = 0;	/* the last last_received that I acknowledged */

	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+640], 0

; 389  : 	c->rudp_data.last_oob_sent_received = 0;	/* the last last_received that I acknowledged */

	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [edx+680], 0

; 390  : 
; 391  : 	c->rudp_data.last_dispatched = 0;		/* the last dispatched message */

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+648], 0

; 392  : 	c->rudp_data.last_oob_dispatched = 0;		/* the last dispatched message */

	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+688], 0

; 393  : 
; 394  : 	c->rudp_data.receiving = 0;				/* list of received packets */

	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [edx+652], 0

; 395  : 	c->rudp_data.oob_receiving = 0;				/* list of received packets */

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+692], 0

; 396  : 
; 397  : 	c->rudp_data.sent_received = 0;			/* what the last received I sent */

	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+656], 0

; 398  : 	c->rudp_data.sent_oob_received = 0;			/* what the last received I sent */

	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [edx+696], 0

; 399  : 	c->rudp_data.last_send_time = 0;		/* last time we checked for ack */

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+660], 0

; 400  : 	c->rudp_data.last_oob_send_time = 0;		/* last time we checked for ack */

	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+700], 0

; 401  : 
; 402  : 	c->rudp_data.last_ping_send_time = 0;

	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [edx+704], 0

; 403  : 	c->rudp_data.last_ping_recv_time = GetTickCount ();

	call	DWORD PTR __imp__GetTickCount@0
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+708], eax

; 404  : 
; 405  : 	// sfr: id (store network order)
; 406  : 	c->id = CAPI_htonl(id);

	mov	edx, DWORD PTR _id$[ebp]
	push	edx
	call	DWORD PTR _CAPI_htonl
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [ecx+584], eax

; 407  : 
; 408  : 	// sfr add to com list
; 409  : 	comListAdd(c);

	mov	edx, DWORD PTR _c$[ebp]
	push	edx
	call	_comListAdd
	add	esp, 4

; 410  : 	leave_cs ();

	call	_leave_cs

; 411  : 	return (ComAPIHandle)c;

	mov	eax, DWORD PTR _c$[ebp]
$LN8@ComRUDPOpe:

; 412  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_ComRUDPOpen ENDP
_TEXT	ENDS
END
