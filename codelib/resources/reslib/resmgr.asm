; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\codelib\resources\reslib\src\resmgr.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_RES_ERR_OR_MSGS
PUBLIC	??_C@_0BC@BAKIAKOF@Not?5enough?5memory?$AA@	; `string'
PUBLIC	??_C@_0BE@LKCLELBC@Incorrect?5parameter?$AA@	; `string'
PUBLIC	??_C@_0P@BEENDNPK@Path?5not?5found?$AA@		; `string'
PUBLIC	??_C@_0BN@DNMGFDAK@File?5sharing?5?$CInetwork?5error?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BP@DEOHHFOO@There?5is?5no?5matching?5cd?5number?$AA@ ; `string'
PUBLIC	??_C@_0BE@KMOBFGNI@File?5already?5closed?$AA@	; `string'
PUBLIC	??_C@_0P@DBCHBMCI@File?5not?5found?$AA@		; `string'
PUBLIC	??_C@_0BH@MIFJGKOA@Can?8t?5attrib?5directory?$AA@ ; `string'
PUBLIC	??_C@_0BC@HHNHIHPB@Can?8t?5attrib?5file?$AA@	; `string'
PUBLIC	??_C@_0BJ@PLCFHEH@Directory?5already?5exists?$AA@ ; `string'
PUBLIC	??_C@_0BA@CJBACOOL@Not?5a?5directory?$AA@	; `string'
PUBLIC	??_C@_0BB@IABAONNM@Could?5not?5delete?$AA@	; `string'
PUBLIC	??_C@_0BL@DIIOCEOH@Could?5not?5change?5directory?$AA@ ; `string'
PUBLIC	??_C@_0BI@PLCOOFMO@Must?5create?5search?5path?$AA@ ; `string'
PUBLIC	??_C@_0BH@NCOJHDNK@Could?5not?5spawn?5thread?$AA@ ; `string'
PUBLIC	??_C@_0BE@LONNMHBH@Could?5not?5open?5file?$AA@	; `string'
PUBLIC	??_C@_0BF@EOEHJNMJ@Problem?5reading?5file?$AA@	; `string'
PUBLIC	??_C@_0BF@LGIFEKAE@Problem?5writing?5file?$AA@	; `string'
PUBLIC	??_C@_0CF@JGABHBLI@System?5path?5has?5not?5been?5created@ ; `string'
PUBLIC	??_C@_0BL@HFOBOEIA@Cannot?5interpret?5file?1path?$AA@ ; `string'
PUBLIC	??_C@_0BA@LHLFIPNL@Unknown?5archive?$AA@	; `string'
PUBLIC	??_C@_0BE@INBJMKGG@Too?5many?5open?5files?$AA@	; `string'
PUBLIC	??_C@_0BE@JICGOOKO@Illegal?5file?5handle?$AA@	; `string'
PUBLIC	??_C@_0BD@JGOCCEAF@Cannot?5delete?5file?$AA@	; `string'
PUBLIC	??_C@_0BJ@CDJCFEPH@Cannot?5open?5archive?5file?$AA@ ; `string'
PUBLIC	??_C@_0BF@PBLFINPE@Corrupt?5archive?5file?$AA@	; `string'
PUBLIC	??_C@_0O@NIPGCINC@Unknown?5error?$AA@		; `string'
PUBLIC	??_C@_0CB@GJGCMPE@Directory?5already?5in?5search?5path@ ; `string'
PUBLIC	??_C@_0DB@EMOKBBOG@Destination?5directory?5not?5known?5@ ; `string'
PUBLIC	??_C@_0BL@EOMEJANG@Cannot?5write?5to?5an?5archive?$AA@ ; `string'
PUBLIC	??_C@_0BN@LNHOKABC@Unsupported?5compression?5type?$AA@ ; `string'
PUBLIC	??_C@_0BF@EPOHEPPD@Too?5many?5directories?$AA@	; `string'
PUBLIC	_RES_ERR_COUNT
PUBLIC	_RES_DEBUG_FLAG
PUBLIC	_RES_DEBUG_LOGGING
PUBLIC	_RES_DEBUG_OPEN_LOG
PUBLIC	_RES_DEBUG_FILE
PUBLIC	_GLOBAL_HASH_TABLE
PUBLIC	_FILE_HANDLES
PUBLIC	_RESMGR_INIT
PUBLIC	_GLOBAL_PATH_LIST
PUBLIC	_RES_DEVICES
PUBLIC	_GLOBAL_VOLUME_MASK
PUBLIC	_GLOBAL_SEARCH_INDEX
_BSS	SEGMENT
_RES_DEBUG_LOGGING DD 01H DUP (?)
_RES_DEBUG_OPEN_LOG DD 01H DUP (?)
_GLOCK	DD	01H DUP (?)
_GLOBAL_HASH_TABLE DD 01H DUP (?)
_FILE_HANDLES DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_RES_CALLBACK:DWORD:0aH
_DATA	ENDS
_BSS	SEGMENT
_ARCHIVE_LIST DD 01H DUP (?)
_OPEN_DIR_LIST DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_RES_PATH:DWORD:011H
COMM	_GLOBAL_SEARCH_PATH:DWORD:0faH
COMM	_GLOBAL_INIT_PATH:BYTE:0104H
COMM	_GLOBAL_CURRENT_PATH:BYTE:0104H
_DATA	ENDS
_BSS	SEGMENT
_RESMGR_INIT DD	01H DUP (?)
_GLOBAL_PATH_LIST DD 01H DUP (?)
_RES_DEVICES DD	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_GLOBAL_INIT_DRIVE:DWORD
COMM	_GLOBAL_CURRENT_DRIVE:DWORD
COMM	_GLOBAL_CURRENT_CD:DWORD
_DATA	ENDS
_BSS	SEGMENT
_GLOBAL_VOLUME_MASK DD 01H DUP (?)
_GLOBAL_SEARCH_INDEX DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_GLOBAL_CD_DEVICE:DWORD
COMM	_RES_DEBUG_ERRNO:DWORD
_DATA	ENDS
;	COMDAT ??_C@_0BF@EPOHEPPD@Too?5many?5directories?$AA@
CONST	SEGMENT
??_C@_0BF@EPOHEPPD@Too?5many?5directories?$AA@ DB 'Too many directories', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LNHOKABC@Unsupported?5compression?5type?$AA@
CONST	SEGMENT
??_C@_0BN@LNHOKABC@Unsupported?5compression?5type?$AA@ DB 'Unsupported co'
	DB	'mpression type', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@EOMEJANG@Cannot?5write?5to?5an?5archive?$AA@
CONST	SEGMENT
??_C@_0BL@EOMEJANG@Cannot?5write?5to?5an?5archive?$AA@ DB 'Cannot write t'
	DB	'o an archive', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@EMOKBBOG@Destination?5directory?5not?5known?5@
CONST	SEGMENT
??_C@_0DB@EMOKBBOG@Destination?5directory?5not?5known?5@ DB 'Destination '
	DB	'directory not known (must add first)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@GJGCMPE@Directory?5already?5in?5search?5path@
CONST	SEGMENT
??_C@_0CB@GJGCMPE@Directory?5already?5in?5search?5path@ DB 'Directory alr'
	DB	'eady in search path', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NIPGCINC@Unknown?5error?$AA@
CONST	SEGMENT
??_C@_0O@NIPGCINC@Unknown?5error?$AA@ DB 'Unknown error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PBLFINPE@Corrupt?5archive?5file?$AA@
CONST	SEGMENT
??_C@_0BF@PBLFINPE@Corrupt?5archive?5file?$AA@ DB 'Corrupt archive file', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CDJCFEPH@Cannot?5open?5archive?5file?$AA@
CONST	SEGMENT
??_C@_0BJ@CDJCFEPH@Cannot?5open?5archive?5file?$AA@ DB 'Cannot open archi'
	DB	've file', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JGOCCEAF@Cannot?5delete?5file?$AA@
CONST	SEGMENT
??_C@_0BD@JGOCCEAF@Cannot?5delete?5file?$AA@ DB 'Cannot delete file', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JICGOOKO@Illegal?5file?5handle?$AA@
CONST	SEGMENT
??_C@_0BE@JICGOOKO@Illegal?5file?5handle?$AA@ DB 'Illegal file handle', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@INBJMKGG@Too?5many?5open?5files?$AA@
CONST	SEGMENT
??_C@_0BE@INBJMKGG@Too?5many?5open?5files?$AA@ DB 'Too many open files', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LHLFIPNL@Unknown?5archive?$AA@
CONST	SEGMENT
??_C@_0BA@LHLFIPNL@Unknown?5archive?$AA@ DB 'Unknown archive', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@HFOBOEIA@Cannot?5interpret?5file?1path?$AA@
CONST	SEGMENT
??_C@_0BL@HFOBOEIA@Cannot?5interpret?5file?1path?$AA@ DB 'Cannot interpre'
	DB	't file/path', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@JGABHBLI@System?5path?5has?5not?5been?5created@
CONST	SEGMENT
??_C@_0CF@JGABHBLI@System?5path?5has?5not?5been?5created@ DB 'System path'
	DB	' has not been created yet', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@LGIFEKAE@Problem?5writing?5file?$AA@
CONST	SEGMENT
??_C@_0BF@LGIFEKAE@Problem?5writing?5file?$AA@ DB 'Problem writing file', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@EOEHJNMJ@Problem?5reading?5file?$AA@
CONST	SEGMENT
??_C@_0BF@EOEHJNMJ@Problem?5reading?5file?$AA@ DB 'Problem reading file', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LONNMHBH@Could?5not?5open?5file?$AA@
CONST	SEGMENT
??_C@_0BE@LONNMHBH@Could?5not?5open?5file?$AA@ DB 'Could not open file', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@NCOJHDNK@Could?5not?5spawn?5thread?$AA@
CONST	SEGMENT
??_C@_0BH@NCOJHDNK@Could?5not?5spawn?5thread?$AA@ DB 'Could not spawn thr'
	DB	'ead', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@PLCOOFMO@Must?5create?5search?5path?$AA@
CONST	SEGMENT
??_C@_0BI@PLCOOFMO@Must?5create?5search?5path?$AA@ DB 'Must create search'
	DB	' path', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@DIIOCEOH@Could?5not?5change?5directory?$AA@
CONST	SEGMENT
??_C@_0BL@DIIOCEOH@Could?5not?5change?5directory?$AA@ DB 'Could not chang'
	DB	'e directory', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IABAONNM@Could?5not?5delete?$AA@
CONST	SEGMENT
??_C@_0BB@IABAONNM@Could?5not?5delete?$AA@ DB 'Could not delete', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@CJBACOOL@Not?5a?5directory?$AA@
CONST	SEGMENT
??_C@_0BA@CJBACOOL@Not?5a?5directory?$AA@ DB 'Not a directory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@PLCFHEH@Directory?5already?5exists?$AA@
CONST	SEGMENT
??_C@_0BJ@PLCFHEH@Directory?5already?5exists?$AA@ DB 'Directory already e'
	DB	'xists', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HHNHIHPB@Can?8t?5attrib?5file?$AA@
CONST	SEGMENT
??_C@_0BC@HHNHIHPB@Can?8t?5attrib?5file?$AA@ DB 'Can''t attrib file', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@MIFJGKOA@Can?8t?5attrib?5directory?$AA@
CONST	SEGMENT
??_C@_0BH@MIFJGKOA@Can?8t?5attrib?5directory?$AA@ DB 'Can''t attrib direc'
	DB	'tory', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DBCHBMCI@File?5not?5found?$AA@
CONST	SEGMENT
??_C@_0P@DBCHBMCI@File?5not?5found?$AA@ DB 'File not found', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KMOBFGNI@File?5already?5closed?$AA@
CONST	SEGMENT
??_C@_0BE@KMOBFGNI@File?5already?5closed?$AA@ DB 'File already closed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DEOHHFOO@There?5is?5no?5matching?5cd?5number?$AA@
CONST	SEGMENT
??_C@_0BP@DEOHHFOO@There?5is?5no?5matching?5cd?5number?$AA@ DB 'There is '
	DB	'no matching cd number', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@DNMGFDAK@File?5sharing?5?$CInetwork?5error?$CJ?$AA@
CONST	SEGMENT
??_C@_0BN@DNMGFDAK@File?5sharing?5?$CInetwork?5error?$CJ?$AA@ DB 'File sh'
	DB	'aring (network error)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BEENDNPK@Path?5not?5found?$AA@
CONST	SEGMENT
??_C@_0P@BEENDNPK@Path?5not?5found?$AA@ DB 'Path not found', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LKCLELBC@Incorrect?5parameter?$AA@
CONST	SEGMENT
??_C@_0BE@LKCLELBC@Incorrect?5parameter?$AA@ DB 'Incorrect parameter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BAKIAKOF@Not?5enough?5memory?$AA@
CONST	SEGMENT
??_C@_0BC@BAKIAKOF@Not?5enough?5memory?$AA@ DB 'Not enough memory', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
_RES_ERR_OR_MSGS DD FLAT:??_C@_0BC@BAKIAKOF@Not?5enough?5memory?$AA@
	DD	FLAT:??_C@_0BE@LKCLELBC@Incorrect?5parameter?$AA@
	DD	FLAT:??_C@_0P@BEENDNPK@Path?5not?5found?$AA@
	DD	FLAT:??_C@_0BN@DNMGFDAK@File?5sharing?5?$CInetwork?5error?$CJ?$AA@
	DD	FLAT:??_C@_0BP@DEOHHFOO@There?5is?5no?5matching?5cd?5number?$AA@
	DD	FLAT:??_C@_0BE@KMOBFGNI@File?5already?5closed?$AA@
	DD	FLAT:??_C@_0P@DBCHBMCI@File?5not?5found?$AA@
	DD	FLAT:??_C@_0BH@MIFJGKOA@Can?8t?5attrib?5directory?$AA@
	DD	FLAT:??_C@_0BC@HHNHIHPB@Can?8t?5attrib?5file?$AA@
	DD	FLAT:??_C@_0BJ@PLCFHEH@Directory?5already?5exists?$AA@
	DD	FLAT:??_C@_0BA@CJBACOOL@Not?5a?5directory?$AA@
	DD	FLAT:??_C@_0BB@IABAONNM@Could?5not?5delete?$AA@
	DD	FLAT:??_C@_0BL@DIIOCEOH@Could?5not?5change?5directory?$AA@
	DD	FLAT:??_C@_0BI@PLCOOFMO@Must?5create?5search?5path?$AA@
	DD	FLAT:??_C@_0BH@NCOJHDNK@Could?5not?5spawn?5thread?$AA@
	DD	FLAT:??_C@_0BE@LONNMHBH@Could?5not?5open?5file?$AA@
	DD	FLAT:??_C@_0BF@EOEHJNMJ@Problem?5reading?5file?$AA@
	DD	FLAT:??_C@_0BF@LGIFEKAE@Problem?5writing?5file?$AA@
	DD	FLAT:??_C@_0CF@JGABHBLI@System?5path?5has?5not?5been?5created@
	DD	FLAT:??_C@_0BL@HFOBOEIA@Cannot?5interpret?5file?1path?$AA@
	DD	FLAT:??_C@_0BA@LHLFIPNL@Unknown?5archive?$AA@
	DD	FLAT:??_C@_0BE@INBJMKGG@Too?5many?5open?5files?$AA@
	DD	FLAT:??_C@_0BE@JICGOOKO@Illegal?5file?5handle?$AA@
	DD	FLAT:??_C@_0BD@JGOCCEAF@Cannot?5delete?5file?$AA@
	DD	FLAT:??_C@_0BJ@CDJCFEPH@Cannot?5open?5archive?5file?$AA@
	DD	FLAT:??_C@_0BF@PBLFINPE@Corrupt?5archive?5file?$AA@
	DD	FLAT:??_C@_0O@NIPGCINC@Unknown?5error?$AA@
	DD	FLAT:??_C@_0CB@GJGCMPE@Directory?5already?5in?5search?5path@
	DD	FLAT:??_C@_0DB@EMOKBBOG@Destination?5directory?5not?5known?5@
	DD	FLAT:??_C@_0BL@EOMEJANG@Cannot?5write?5to?5an?5archive?$AA@
	DD	FLAT:??_C@_0BN@LNHOKABC@Unsupported?5compression?5type?$AA@
	DD	FLAT:??_C@_0BF@EPOHEPPD@Too?5many?5directories?$AA@
_RES_ERR_COUNT DD 020H
_RES_DEBUG_FLAG DD 01H
_RES_DEBUG_FILE DD 0ffffffffH
_resmgr_version DB '[Version] ResMgr version 2.0', 00H
_DATA	ENDS
PUBLIC	__filbuf
PUBLIC	_ResInit
PUBLIC	_ResExit
PUBLIC	_ResMountCD
PUBLIC	_ResDismountCD
PUBLIC	_ResCheckMedia
PUBLIC	_ResDevice
PUBLIC	_ResPurge
PUBLIC	_ResAttach
PUBLIC	_ResDetach
PUBLIC	_ResOpenFile
PUBLIC	_ResSizeFile
PUBLIC	_ResReadFile
PUBLIC	_ResLoadFile
PUBLIC	_ResUnloadFile
PUBLIC	_ResCloseFile
PUBLIC	_ResWriteFile
PUBLIC	_ResDeleteFile
PUBLIC	_ResModifyFile
PUBLIC	_ResTellFile
PUBLIC	_ResSeekFile
PUBLIC	_ResStatusFile
PUBLIC	_ResExtractFile
PUBLIC	_ResFOpen
PUBLIC	_ResFClose
PUBLIC	_ResFTell
PUBLIC	_ResFRead
PUBLIC	_ResFSeek
PUBLIC	_ResMakeDirectory
PUBLIC	_ResDeleteDirectory
PUBLIC	_ResOpenDirectory
PUBLIC	_ResReadDirectory
PUBLIC	_ResCloseDirectory
PUBLIC	_ResExistFile
PUBLIC	_ResExistDirectory
PUBLIC	_ResSetDirectory
PUBLIC	_ResGetDirectory
PUBLIC	_ResCountDirectory
PUBLIC	_ResWhereIs
PUBLIC	_ResWhichCD
PUBLIC	_ResWriteTOC
PUBLIC	_ResSetCallback
PUBLIC	_ResGetCallback
PUBLIC	_ResAssignPath
PUBLIC	_ResBuildPathname
PUBLIC	_ResGetPath
PUBLIC	_ResCreatePath
PUBLIC	_ResAddPath
PUBLIC	_ResGetArchive
PUBLIC	_ResAsynchRead
PUBLIC	_ResAsynchWrite
PUBLIC	_ResDbg
PUBLIC	_ResDbgLogOpen
PUBLIC	_ResDbgLogClose
PUBLIC	_ResDbgPrintf
PUBLIC	_ResDbgLogPause
PUBLIC	_ResDbgDump
PUBLIC	_dbg_analyze_hash
PUBLIC	_dbg_print
PUBLIC	_dbg_dir
PUBLIC	_dbg_device
PUBLIC	__say_error
PUBLIC	_asynch_write
PUBLIC	_asynch_read
PUBLIC	_hash
PUBLIC	_hash_resize
PUBLIC	_hash_delete
PUBLIC	_hash_destroy
PUBLIC	_hash_purge
PUBLIC	_hash_create
PUBLIC	_hash_find
PUBLIC	_hash_add
PUBLIC	_hash_find_table
PUBLIC	_hash_strcpy
PUBLIC	_get_handle
PUBLIC	_split_path
PUBLIC	_shut_down
PUBLIC	_res_fullpath
PUBLIC	_res_detach_ex
PUBLIC	_sort_path
PUBLIC	_get_dir_index
PUBLIC	_hash_copy
PUBLIC	??_C@_03GIOIKFCO@C?3?2?$AA@			; `string'
PUBLIC	??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@		; `string'
PUBLIC	??_C@_07FLKJDOFF@ResInit?$AA@			; `string'
PUBLIC	??_C@_07CIFAGBMG@unknown?$AA@			; `string'
PUBLIC	??_C@_0M@CPHMKFFF@multithread?$AA@		; `string'
PUBLIC	??_C@_0BN@IAPPECNM@ResCheckMedia?5?$CIuse?5ordinals?$CJ?$AA@ ; `string'
PUBLIC	??_C@_09IPANOAMB@ResAttach?$AA@			; `string'
PUBLIC	??_C@_09BPGFBLJK@ResDevice?$AA@			; `string'
PUBLIC	??_C@_09BFLPBOFI@ResDetach?$AA@			; `string'
PUBLIC	??_C@_0M@OGEGBBAK@ResOpenFile?$AA@		; `string'
PUBLIC	??_C@_0BB@EDJDNCBI@ResOpen?5?9?5create?$AA@	; `string'
PUBLIC	??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@		; `string'
PUBLIC	??_C@_01CLKCMJKC@?5?$AA@			; `string'
PUBLIC	??_C@_07DNABHHOL@Inflate?$AA@			; `string'
PUBLIC	??_C@_0M@DEBHJGIL@ResSizeFile?$AA@		; `string'
PUBLIC	??_C@_0M@NKEGIMBG@ResReadFile?$AA@		; `string'
PUBLIC	??_C@_0M@CPIEAJDN@ResLoadFile?$AA@		; `string'
PUBLIC	??_C@_0O@KLAMIEJI@ResUnloadFile?$AA@		; `string'
PUBLIC	??_C@_0N@MFBOIEDA@ResCloseFile?$AA@		; `string'
PUBLIC	??_C@_08OOOIBLGC@set?5size?$AA@			; `string'
PUBLIC	??_C@_0N@IMJBALEI@ResWriteFile?$AA@		; `string'
PUBLIC	??_C@_0O@FDOOBIGA@ResDeleteFile?$AA@		; `string'
PUBLIC	??_C@_0O@FHKDEOHM@ResModifyFile?$AA@		; `string'
PUBLIC	??_C@_0BB@LJPCDDOA@ResMakeDirectory?$AA@	; `string'
PUBLIC	??_C@_06BNHEIDIH@?$CFs?2?$CK?4?$CK?$AA@		; `string'
PUBLIC	??_C@_01LFCBOECM@?4?$AA@			; `string'
PUBLIC	??_C@_02DJGKEECL@?4?4?$AA@			; `string'
PUBLIC	??_C@_05BMGBEOOC@?$CFs?2?$CFs?$AA@		; `string'
PUBLIC	??_C@_0BB@PLBNNMEI@ResOpenDirectory?$AA@	; `string'
PUBLIC	??_C@_0BB@GCNEOGEN@ResReadDirectory?$AA@	; `string'
PUBLIC	??_C@_0BC@EGBEGFJA@ResCloseDirectory?$AA@	; `string'
PUBLIC	??_C@_0N@DHMJDPLD@ResExistFile?$AA@		; `string'
PUBLIC	??_C@_0BC@NEGNMGMD@ResExistDirectory?$AA@	; `string'
PUBLIC	??_C@_0M@CENIBGDB@ResTellFile?$AA@		; `string'
PUBLIC	??_C@_0M@MICEAOJD@ResSeekFile?$AA@		; `string'
PUBLIC	??_C@_0BA@OJNFJCCI@ResSetDirectory?$AA@		; `string'
PUBLIC	??_C@_0BA@JNGLFOGE@ResGetDirectory?$AA@		; `string'
PUBLIC	??_C@_0O@COOJBPCO@ResStatusFile?$AA@		; `string'
PUBLIC	??_C@_0P@PADJMKNI@ResSetCallback?$AA@		; `string'
PUBLIC	??_C@_0P@PPCHBMFL@ResGetCallback?$AA@		; `string'
PUBLIC	??_C@_06JGBJPOPP@Global?$AA@			; `string'
PUBLIC	??_C@_0L@GLEIDJF@ResAddPath?$AA@		; `string'
PUBLIC	??_C@_0CF@CKADNGLC@You?5must?5first?5call?5ResCreatePat@ ; `string'
PUBLIC	??_C@_04BDGLLBHF@?2?$CFs?2?$AA@			; `string'
PUBLIC	??_C@_0BB@KDLJIOGI@ResBuildPathname?$AA@	; `string'
PUBLIC	??_C@_0BC@EJOCHHKO@ResCountDirectory?$AA@	; `string'
PUBLIC	??_C@_0O@JNKBGNLK@ResAssignPath?$AA@		; `string'
PUBLIC	??_C@_0M@CHANDFDP@Assign?5path?$AA@		; `string'
PUBLIC	??_C@_0O@GDKGMDJD@ResAsynchRead?$AA@		; `string'
PUBLIC	??_C@_0P@CKHAKKGB@ResAsynchWrite?$AA@		; `string'
PUBLIC	??_C@_0L@GFEJONIC@ResExtract?$AA@		; `string'
PUBLIC	??_C@_08KJEBKLNA@ResPurge?$AA@			; `string'
PUBLIC	??_C@_08NNCGCPFP@ResFOpen?$AA@			; `string'
PUBLIC	??_C@_0BC@CPGLDEPP@ResFOpen?5?9?5create?$AA@	; `string'
PUBLIC	??_C@_09EKBCJPBH@ResFClose?$AA@			; `string'
PUBLIC	??_C@_05BILPOFMK@ftell?$AA@			; `string'
PUBLIC	??_C@_07HNDGCFOP@_filbuf?$AA@			; `string'
PUBLIC	??_C@_0BH@IMBIDIIM@_filbuf?5internal?5error?$AA@ ; `string'
PUBLIC	??_C@_05OKAPJEJC@fseek?$AA@			; `string'
PUBLIC	??_C@_0M@CIGDFLFE@hash_create?$AA@		; `string'
PUBLIC	??_C@_08KMLNCKGK@hash_add?$AA@			; `string'
PUBLIC	??_C@_0M@NHJDJJMK@hash_resize?$AA@		; `string'
PUBLIC	??_C@_0BI@KKHIDFIG@Resource?5Manager?5Error?$CB?$AA@ ; `string'
PUBLIC	??_C@_03BBKEAIF@?$DP?$DP?$DP?$AA@		; `string'
PUBLIC	??_C@_0CP@MDMMLIAJ@Tried?5to?5open?5read?9only?5file?5?$CI?$CFs@ ; `string'
PUBLIC	??_C@_0DJ@PDPAPLDJ@Create?5flag?5specified?0?5but?5filen@ ; `string'
PUBLIC	??_C@_0BO@EMKGDOO@File?5or?5path?5not?5found?4?5?$CI?$CFs?$CJ?4?$AA@ ; `string'
PUBLIC	??_C@_0BM@HGBGFIMO@?$CFs?5?$CI?$CFs?$CJ?6?6?6File?3?5?$CFs?6Line?3?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0DP@KAFHBHNB@Unknown?5error?5encountered?5with?5f@ ; `string'
PUBLIC	??_C@_05ENKMGHII@?$CF?917s?$AA@			; `string'
PUBLIC	??_C@_0L@DMPNKCFM@size?3?5?$CF5d?5?$AA@		; `string'
PUBLIC	??_C@_0M@HDGDGLCH@csize?3?5?$CF5d?5?$AA@	; `string'
PUBLIC	??_C@_0N@MCEGBKEA@method?3?5?$CF1d?5?$AA@	; `string'
PUBLIC	??_C@_01DGKLNCNG@R?$AA@				; `string'
PUBLIC	??_C@_01IGIGCIAN@H?$AA@				; `string'
PUBLIC	??_C@_01CPLAODJH@S?$AA@				; `string'
PUBLIC	??_C@_01FHEEJDEE@A?$AA@				; `string'
PUBLIC	??_C@_07GCALBCF@?7?7?$DMDIR?$DO?$AA@		; `string'
PUBLIC	??_C@_07NLJMJJCA@?7?7?5?5?5?5?5?$AA@		; `string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_03MINKAKBA@c?3?2?$AA@			; `string'
PUBLIC	__real@3f59999a
PUBLIC	__real@3f933333
PUBLIC	__real@3fe999999999999a
PUBLIC	__real@3feb333333333333
PUBLIC	__real@3ff2666666666666
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_toupper:PROC
EXTRN	_memcmp:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_strcpy:PROC
EXTRN	_strcmp:PROC
EXTRN	_strlen:PROC
EXTRN	_strchr:PROC
EXTRN	_strncpy:PROC
EXTRN	_strstr:PROC
EXTRN	_strdup:PROC
EXTRN	_stricmp:PROC
EXTRN	_strnicmp:PROC
EXTRN	__imp__GetDriveTypeA@4:PROC
EXTRN	__imp__GetLogicalDrives@0:PROC
EXTRN	__imp__DebugBreak@0:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__ReleaseMutex@4:PROC
EXTRN	__imp__WaitForSingleObject@8:PROC
EXTRN	__imp__CreateMutexA@12:PROC
EXTRN	__imp__GetTempPathA@8:PROC
EXTRN	__imp__GetVolumeInformationA@32:PROC
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	_ListAppend:PROC
EXTRN	_ListAppendEnd:PROC
EXTRN	_ListCatenate:PROC
EXTRN	_ListNth:PROC
EXTRN	_ListRemove:PROC
EXTRN	_ListDestroy:PROC
EXTRN	__errno:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	_realloc:PROC
EXTRN	__fileno:PROC
EXTRN	_printf:PROC
EXTRN	_remove:PROC
EXTRN	_sprintf:PROC
EXTRN	_vsprintf:PROC
EXTRN	__lock_file:PROC
EXTRN	__unlock_file:PROC
EXTRN	__close:PROC
EXTRN	__commit:PROC
EXTRN	__findclose:PROC
EXTRN	__lseek:PROC
EXTRN	__read:PROC
EXTRN	__write:PROC
EXTRN	__findfirst64i32:PROC
EXTRN	__findnext64i32:PROC
EXTRN	__open:PROC
EXTRN	_chmod:PROC
EXTRN	_lseek:PROC
EXTRN	__getcwd:PROC
EXTRN	__getdcwd:PROC
EXTRN	__chdir:PROC
EXTRN	__mkdir:PROC
EXTRN	__rmdir:PROC
EXTRN	__chdrive:PROC
EXTRN	__getdrive:PROC
EXTRN	__beginthread:PROC
EXTRN	_inflate:PROC
EXTRN	_inflate_free:PROC
EXTRN	__getstream:PROC
EXTRN	__openfile:PROC
EXTRN	__getbuf:PROC
EXTRN	__flush:PROC
EXTRN	_archive_create:PROC
EXTRN	_process_local_file_hdr:PROC
EXTRN	__freebuf:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memset:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_RES_GLOBAL_HWND DD 01H DUP (?)
_BSS	ENDS
;	COMDAT __real@3ff2666666666666
CONST	SEGMENT
__real@3ff2666666666666 DQ 03ff2666666666666r	; 1.15
CONST	ENDS
;	COMDAT __real@3feb333333333333
CONST	SEGMENT
__real@3feb333333333333 DQ 03feb333333333333r	; 0.85
CONST	ENDS
;	COMDAT __real@3fe999999999999a
CONST	SEGMENT
__real@3fe999999999999a DQ 03fe999999999999ar	; 0.8
CONST	ENDS
;	COMDAT __real@3f933333
CONST	SEGMENT
__real@3f933333 DD 03f933333r			; 1.15
CONST	ENDS
;	COMDAT __real@3f59999a
CONST	SEGMENT
__real@3f59999a DD 03f59999ar			; 0.85
CONST	ENDS
;	COMDAT ??_C@_03MINKAKBA@c?3?2?$AA@
CONST	SEGMENT
??_C@_03MINKAKBA@c?3?2?$AA@ DB 'c:\', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07NLJMJJCA@?7?7?5?5?5?5?5?$AA@
CONST	SEGMENT
??_C@_07NLJMJJCA@?7?7?5?5?5?5?5?$AA@ DB 09H, 09H, '     ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07GCALBCF@?7?7?$DMDIR?$DO?$AA@
CONST	SEGMENT
??_C@_07GCALBCF@?7?7?$DMDIR?$DO?$AA@ DB 09H, 09H, '<DIR>', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01FHEEJDEE@A?$AA@
CONST	SEGMENT
??_C@_01FHEEJDEE@A?$AA@ DB 'A', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01CPLAODJH@S?$AA@
CONST	SEGMENT
??_C@_01CPLAODJH@S?$AA@ DB 'S', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01IGIGCIAN@H?$AA@
CONST	SEGMENT
??_C@_01IGIGCIAN@H?$AA@ DB 'H', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01DGKLNCNG@R?$AA@
CONST	SEGMENT
??_C@_01DGKLNCNG@R?$AA@ DB 'R', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MCEGBKEA@method?3?5?$CF1d?5?$AA@
CONST	SEGMENT
??_C@_0N@MCEGBKEA@method?3?5?$CF1d?5?$AA@ DB 'method: %1d ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HDGDGLCH@csize?3?5?$CF5d?5?$AA@
CONST	SEGMENT
??_C@_0M@HDGDGLCH@csize?3?5?$CF5d?5?$AA@ DB 'csize: %5d ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DMPNKCFM@size?3?5?$CF5d?5?$AA@
CONST	SEGMENT
??_C@_0L@DMPNKCFM@size?3?5?$CF5d?5?$AA@ DB 'size: %5d ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05ENKMGHII@?$CF?917s?$AA@
CONST	SEGMENT
??_C@_05ENKMGHII@?$CF?917s?$AA@ DB '%-17s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@KAFHBHNB@Unknown?5error?5encountered?5with?5f@
CONST	SEGMENT
??_C@_0DP@KAFHBHNB@Unknown?5error?5encountered?5with?5f@ DB 'Unknown erro'
	DB	'r encountered with file. (%s)', 0aH, 0aH, 0aH, 'File: %s', 0aH
	DB	'Line: %d', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@HGBGFIMO@?$CFs?5?$CI?$CFs?$CJ?6?6?6File?3?5?$CFs?6Line?3?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BM@HGBGFIMO@?$CFs?5?$CI?$CFs?$CJ?6?6?6File?3?5?$CFs?6Line?3?5?$CFd?$AA@ DB '%'
	DB	's (%s)', 0aH, 0aH, 0aH, 'File: %s', 0aH, 'Line: %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@EMKGDOO@File?5or?5path?5not?5found?4?5?$CI?$CFs?$CJ?4?$AA@
CONST	SEGMENT
??_C@_0BO@EMKGDOO@File?5or?5path?5not?5found?4?5?$CI?$CFs?$CJ?4?$AA@ DB 'F'
	DB	'ile or path not found. (%s).', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@PDPAPLDJ@Create?5flag?5specified?0?5but?5filen@
CONST	SEGMENT
??_C@_0DJ@PDPAPLDJ@Create?5flag?5specified?0?5but?5filen@ DB 'Create flag'
	DB	' specified, but filename (%s) already exists.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@MDMMLIAJ@Tried?5to?5open?5read?9only?5file?5?$CI?$CFs@
CONST	SEGMENT
??_C@_0CP@MDMMLIAJ@Tried?5to?5open?5read?9only?5file?5?$CI?$CFs@ DB 'Trie'
	DB	'd to open read-only file (%s) for writing.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03BBKEAIF@?$DP?$DP?$DP?$AA@
CONST	SEGMENT
??_C@_03BBKEAIF@?$DP?$DP?$DP?$AA@ DB '???', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@KKHIDFIG@Resource?5Manager?5Error?$CB?$AA@
CONST	SEGMENT
??_C@_0BI@KKHIDFIG@Resource?5Manager?5Error?$CB?$AA@ DB 'Resource Manager'
	DB	' Error!', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NHJDJJMK@hash_resize?$AA@
CONST	SEGMENT
??_C@_0M@NHJDJJMK@hash_resize?$AA@ DB 'hash_resize', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08KMLNCKGK@hash_add?$AA@
CONST	SEGMENT
??_C@_08KMLNCKGK@hash_add?$AA@ DB 'hash_add', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CIGDFLFE@hash_create?$AA@
CONST	SEGMENT
??_C@_0M@CIGDFLFE@hash_create?$AA@ DB 'hash_create', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05OKAPJEJC@fseek?$AA@
CONST	SEGMENT
??_C@_05OKAPJEJC@fseek?$AA@ DB 'fseek', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@IMBIDIIM@_filbuf?5internal?5error?$AA@
CONST	SEGMENT
??_C@_0BH@IMBIDIIM@_filbuf?5internal?5error?$AA@ DB '_filbuf internal err'
	DB	'or', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_07HNDGCFOP@_filbuf?$AA@
CONST	SEGMENT
??_C@_07HNDGCFOP@_filbuf?$AA@ DB '_filbuf', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05BILPOFMK@ftell?$AA@
CONST	SEGMENT
??_C@_05BILPOFMK@ftell?$AA@ DB 'ftell', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09EKBCJPBH@ResFClose?$AA@
CONST	SEGMENT
??_C@_09EKBCJPBH@ResFClose?$AA@ DB 'ResFClose', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CPGLDEPP@ResFOpen?5?9?5create?$AA@
CONST	SEGMENT
??_C@_0BC@CPGLDEPP@ResFOpen?5?9?5create?$AA@ DB 'ResFOpen - create', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08NNCGCPFP@ResFOpen?$AA@
CONST	SEGMENT
??_C@_08NNCGCPFP@ResFOpen?$AA@ DB 'ResFOpen', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08KJEBKLNA@ResPurge?$AA@
CONST	SEGMENT
??_C@_08KJEBKLNA@ResPurge?$AA@ DB 'ResPurge', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GFEJONIC@ResExtract?$AA@
CONST	SEGMENT
??_C@_0L@GFEJONIC@ResExtract?$AA@ DB 'ResExtract', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CKHAKKGB@ResAsynchWrite?$AA@
CONST	SEGMENT
??_C@_0P@CKHAKKGB@ResAsynchWrite?$AA@ DB 'ResAsynchWrite', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GDKGMDJD@ResAsynchRead?$AA@
CONST	SEGMENT
??_C@_0O@GDKGMDJD@ResAsynchRead?$AA@ DB 'ResAsynchRead', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CHANDFDP@Assign?5path?$AA@
CONST	SEGMENT
??_C@_0M@CHANDFDP@Assign?5path?$AA@ DB 'Assign path', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JNKBGNLK@ResAssignPath?$AA@
CONST	SEGMENT
??_C@_0O@JNKBGNLK@ResAssignPath?$AA@ DB 'ResAssignPath', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EJOCHHKO@ResCountDirectory?$AA@
CONST	SEGMENT
??_C@_0BC@EJOCHHKO@ResCountDirectory?$AA@ DB 'ResCountDirectory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KDLJIOGI@ResBuildPathname?$AA@
CONST	SEGMENT
??_C@_0BB@KDLJIOGI@ResBuildPathname?$AA@ DB 'ResBuildPathname', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04BDGLLBHF@?2?$CFs?2?$AA@
CONST	SEGMENT
??_C@_04BDGLLBHF@?2?$CFs?2?$AA@ DB '\%s\', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@CKADNGLC@You?5must?5first?5call?5ResCreatePat@
CONST	SEGMENT
??_C@_0CF@CKADNGLC@You?5must?5first?5call?5ResCreatePat@ DB 'You must fir'
	DB	'st call ResCreatePath()', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GLEIDJF@ResAddPath?$AA@
CONST	SEGMENT
??_C@_0L@GLEIDJF@ResAddPath?$AA@ DB 'ResAddPath', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06JGBJPOPP@Global?$AA@
CONST	SEGMENT
??_C@_06JGBJPOPP@Global?$AA@ DB 'Global', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PPCHBMFL@ResGetCallback?$AA@
CONST	SEGMENT
??_C@_0P@PPCHBMFL@ResGetCallback?$AA@ DB 'ResGetCallback', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PADJMKNI@ResSetCallback?$AA@
CONST	SEGMENT
??_C@_0P@PADJMKNI@ResSetCallback?$AA@ DB 'ResSetCallback', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@COOJBPCO@ResStatusFile?$AA@
CONST	SEGMENT
??_C@_0O@COOJBPCO@ResStatusFile?$AA@ DB 'ResStatusFile', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JNGLFOGE@ResGetDirectory?$AA@
CONST	SEGMENT
??_C@_0BA@JNGLFOGE@ResGetDirectory?$AA@ DB 'ResGetDirectory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OJNFJCCI@ResSetDirectory?$AA@
CONST	SEGMENT
??_C@_0BA@OJNFJCCI@ResSetDirectory?$AA@ DB 'ResSetDirectory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MICEAOJD@ResSeekFile?$AA@
CONST	SEGMENT
??_C@_0M@MICEAOJD@ResSeekFile?$AA@ DB 'ResSeekFile', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CENIBGDB@ResTellFile?$AA@
CONST	SEGMENT
??_C@_0M@CENIBGDB@ResTellFile?$AA@ DB 'ResTellFile', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NEGNMGMD@ResExistDirectory?$AA@
CONST	SEGMENT
??_C@_0BC@NEGNMGMD@ResExistDirectory?$AA@ DB 'ResExistDirectory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DHMJDPLD@ResExistFile?$AA@
CONST	SEGMENT
??_C@_0N@DHMJDPLD@ResExistFile?$AA@ DB 'ResExistFile', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EGBEGFJA@ResCloseDirectory?$AA@
CONST	SEGMENT
??_C@_0BC@EGBEGFJA@ResCloseDirectory?$AA@ DB 'ResCloseDirectory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GCNEOGEN@ResReadDirectory?$AA@
CONST	SEGMENT
??_C@_0BB@GCNEOGEN@ResReadDirectory?$AA@ DB 'ResReadDirectory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PLBNNMEI@ResOpenDirectory?$AA@
CONST	SEGMENT
??_C@_0BB@PLBNNMEI@ResOpenDirectory?$AA@ DB 'ResOpenDirectory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05BMGBEOOC@?$CFs?2?$CFs?$AA@
CONST	SEGMENT
??_C@_05BMGBEOOC@?$CFs?2?$CFs?$AA@ DB '%s\%s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02DJGKEECL@?4?4?$AA@
CONST	SEGMENT
??_C@_02DJGKEECL@?4?4?$AA@ DB '..', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01LFCBOECM@?4?$AA@
CONST	SEGMENT
??_C@_01LFCBOECM@?4?$AA@ DB '.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06BNHEIDIH@?$CFs?2?$CK?4?$CK?$AA@
CONST	SEGMENT
??_C@_06BNHEIDIH@?$CFs?2?$CK?4?$CK?$AA@ DB '%s\*.*', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LJPCDDOA@ResMakeDirectory?$AA@
CONST	SEGMENT
??_C@_0BB@LJPCDDOA@ResMakeDirectory?$AA@ DB 'ResMakeDirectory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FHKDEOHM@ResModifyFile?$AA@
CONST	SEGMENT
??_C@_0O@FHKDEOHM@ResModifyFile?$AA@ DB 'ResModifyFile', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FDOOBIGA@ResDeleteFile?$AA@
CONST	SEGMENT
??_C@_0O@FDOOBIGA@ResDeleteFile?$AA@ DB 'ResDeleteFile', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IMJBALEI@ResWriteFile?$AA@
CONST	SEGMENT
??_C@_0N@IMJBALEI@ResWriteFile?$AA@ DB 'ResWriteFile', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08OOOIBLGC@set?5size?$AA@
CONST	SEGMENT
??_C@_08OOOIBLGC@set?5size?$AA@ DB 'set size', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MFBOIEDA@ResCloseFile?$AA@
CONST	SEGMENT
??_C@_0N@MFBOIEDA@ResCloseFile?$AA@ DB 'ResCloseFile', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KLAMIEJI@ResUnloadFile?$AA@
CONST	SEGMENT
??_C@_0O@KLAMIEJI@ResUnloadFile?$AA@ DB 'ResUnloadFile', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CPIEAJDN@ResLoadFile?$AA@
CONST	SEGMENT
??_C@_0M@CPIEAJDN@ResLoadFile?$AA@ DB 'ResLoadFile', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NKEGIMBG@ResReadFile?$AA@
CONST	SEGMENT
??_C@_0M@NKEGIMBG@ResReadFile?$AA@ DB 'ResReadFile', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DEBHJGIL@ResSizeFile?$AA@
CONST	SEGMENT
??_C@_0M@DEBHJGIL@ResSizeFile?$AA@ DB 'ResSizeFile', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DNABHHOL@Inflate?$AA@
CONST	SEGMENT
??_C@_07DNABHHOL@Inflate?$AA@ DB 'Inflate', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5?$AA@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5?$AA@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
CONST	SEGMENT
??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@ DB '%s%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EDJDNCBI@ResOpen?5?9?5create?$AA@
CONST	SEGMENT
??_C@_0BB@EDJDNCBI@ResOpen?5?9?5create?$AA@ DB 'ResOpen - create', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OGEGBBAK@ResOpenFile?$AA@
CONST	SEGMENT
??_C@_0M@OGEGBBAK@ResOpenFile?$AA@ DB 'ResOpenFile', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09BFLPBOFI@ResDetach?$AA@
CONST	SEGMENT
??_C@_09BFLPBOFI@ResDetach?$AA@ DB 'ResDetach', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09BPGFBLJK@ResDevice?$AA@
CONST	SEGMENT
??_C@_09BPGFBLJK@ResDevice?$AA@ DB 'ResDevice', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09IPANOAMB@ResAttach?$AA@
CONST	SEGMENT
??_C@_09IPANOAMB@ResAttach?$AA@ DB 'ResAttach', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@IAPPECNM@ResCheckMedia?5?$CIuse?5ordinals?$CJ?$AA@
CONST	SEGMENT
??_C@_0BN@IAPPECNM@ResCheckMedia?5?$CIuse?5ordinals?$CJ?$AA@ DB 'ResCheck'
	DB	'Media (use ordinals)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CPHMKFFF@multithread?$AA@
CONST	SEGMENT
??_C@_0M@CPHMKFFF@multithread?$AA@ DB 'multithread', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07CIFAGBMG@unknown?$AA@
CONST	SEGMENT
??_C@_07CIFAGBMG@unknown?$AA@ DB 'unknown', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07FLKJDOFF@ResInit?$AA@
CONST	SEGMENT
??_C@_07FLKJDOFF@ResInit?$AA@ DB 'ResInit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
CONST	SEGMENT
??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@ DB 'src\resmgr.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03GIOIKFCO@C?3?2?$AA@
CONST	SEGMENT
??_C@_03GIOIKFCO@C?3?2?$AA@ DB 'C:\', 00H		; `string'
CONST	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_hash_copy PROC

; 6618 : {

	push	ebp
	mov	ebp, esp

; 6619 :     if( dst -> attrib ) {

	mov	eax, DWORD PTR _dst$[ebp]
	cmp	DWORD PTR [eax+28], 0
	je	SHORT $LN4@hash_copy
$LN3@hash_copy:

; 6620 :         while( dst -> next )                        /* go to the end of the list                    */

	mov	ecx, DWORD PTR _dst$[ebp]
	cmp	DWORD PTR [ecx+44], 0
	je	SHORT $LN2@hash_copy

; 6621 :             dst = dst -> next;

	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR _dst$[ebp], eax
	jmp	SHORT $LN3@hash_copy
$LN2@hash_copy:

; 6622 : 
; 6623 : 		#ifdef USE_SH_POOLS
; 6624 :         dst -> next = (HASH_ENTRY *)MemAllocPtr( gResmgrMemPool, sizeof(HASH_ENTRY), 0 );
; 6625 : 		#else
; 6626 :         dst -> next = (HASH_ENTRY *)MemMalloc( sizeof(HASH_ENTRY), "Hash entry" );

	push	48					; 00000030H
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	DWORD PTR [ecx+44], eax

; 6627 : 		#endif
; 6628 : 		if(dst->next) memset(dst->next, 0, sizeof(HASH_ENTRY));	// OW BC

	mov	edx, DWORD PTR _dst$[ebp]
	cmp	DWORD PTR [edx+44], 0
	je	SHORT $LN1@hash_copy
	push	48					; 00000030H
	push	0
	mov	eax, DWORD PTR _dst$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
$LN1@hash_copy:

; 6629 :         dst = dst -> next;

	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR _dst$[ebp], eax
$LN4@hash_copy:

; 6630 :     }
; 6631 : 
; 6632 :     dst -> name   = src -> name;

	mov	ecx, DWORD PTR _dst$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 6633 :     dst -> offset = src -> offset;

	mov	ecx, DWORD PTR _dst$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax

; 6634 :     dst -> size   = src -> size;

	mov	ecx, DWORD PTR _dst$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax

; 6635 :     dst -> csize  = src -> csize;

	mov	ecx, DWORD PTR _dst$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], eax

; 6636 :     dst -> method = src -> method;

	mov	ecx, DWORD PTR _dst$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	ax, WORD PTR [edx+16]
	mov	WORD PTR [ecx+16], ax

; 6637 :     dst -> volume = src -> volume;

	mov	ecx, DWORD PTR _dst$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	al, BYTE PTR [edx+36]
	mov	BYTE PTR [ecx+36], al

; 6638 :     dst -> directory = src -> directory;

	mov	ecx, DWORD PTR _dst$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR [ecx+32], eax

; 6639 :     dst -> file_position = src -> file_position;

	mov	ecx, DWORD PTR _dst$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx+20], eax

; 6640 :     dst -> archive = src -> archive;

	mov	ecx, DWORD PTR _dst$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR [ecx+24], eax

; 6641 :     dst -> attrib = src -> attrib;

	mov	ecx, DWORD PTR _dst$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR [ecx+28], eax

; 6642 :     dst -> dir    = src -> dir;

	mov	ecx, DWORD PTR _dst$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR [ecx+40], eax

; 6643 :     dst -> next   = NULL;

	mov	ecx, DWORD PTR _dst$[ebp]
	mov	DWORD PTR [ecx+44], 0

; 6644 : }

	pop	ebp
	ret	0
_hash_copy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_dir_index$ = -4					; size = 4
_path$ = 8						; size = 4
_get_dir_index PROC

; 6143 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 6144 :     int dir_index;
; 6145 : 
; 6146 :     for( dir_index = 0; dir_index < GLOBAL_SEARCH_INDEX; dir_index++ ) {

	mov	DWORD PTR _dir_index$[ebp], 0
	jmp	SHORT $LN4@get_dir_in
$LN3@get_dir_in:
	mov	eax, DWORD PTR _dir_index$[ebp]
	add	eax, 1
	mov	DWORD PTR _dir_index$[ebp], eax
$LN4@get_dir_in:
	mov	ecx, DWORD PTR _dir_index$[ebp]
	cmp	ecx, DWORD PTR _GLOBAL_SEARCH_INDEX
	jge	SHORT $LN2@get_dir_in

; 6147 :         if( !stricmp( path, GLOBAL_SEARCH_PATH[ dir_index ] )) 

	mov	edx, DWORD PTR _dir_index$[ebp]
	mov	eax, DWORD PTR _GLOBAL_SEARCH_PATH[edx*4]
	push	eax
	mov	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN1@get_dir_in

; 6148 :             return( dir_index );

	mov	eax, DWORD PTR _dir_index$[ebp]
	jmp	SHORT $LN5@get_dir_in
$LN1@get_dir_in:

; 6149 :     }

	jmp	SHORT $LN3@get_dir_in
$LN2@get_dir_in:

; 6150 : 
; 6151 :     return( -1 );

	or	eax, -1
$LN5@get_dir_in:

; 6152 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_get_dir_index ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_hd_list$ = -20						; size = 4
_cd_list$ = -16						; size = 4
_ht$ = -12						; size = 4
_list$ = -8						; size = 4
_cd_id$ = -1						; size = 1
_sort_path PROC

; 6193 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi

; 6194 :     char   cd_id;
; 6195 : 
; 6196 :     HASH_TABLE * ht;
; 6197 : 
; 6198 :     LIST * hd_list = NULL,

	mov	DWORD PTR _hd_list$[ebp], 0

; 6199 :          * cd_list = NULL;

	mov	DWORD PTR _cd_list$[ebp], 0

; 6200 : 
; 6201 :     LIST * list;
; 6202 : 
; 6203 :     cd_id = (char)(GLOBAL_CD_DEVICE + 'A');

	mov	eax, DWORD PTR _GLOBAL_CD_DEVICE
	add	eax, 65					; 00000041H
	mov	BYTE PTR _cd_id$[ebp], al

; 6204 :     
; 6205 :     /* ugly - look at the first character in the pathname to
; 6206 :        determine which volume is referenced.  If this volume
; 6207 :        is the CD-drive, subjigate this to the cd list.  The
; 6208 :        new search path is hard-drive list + cd list. */
; 6209 : 
; 6210 :     for( list = GLOBAL_PATH_LIST; list; list = list -> next ) {

	mov	ecx, DWORD PTR _GLOBAL_PATH_LIST
	mov	DWORD PTR _list$[ebp], ecx
	jmp	SHORT $LN5@sort_path
$LN4@sort_path:
	mov	edx, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _list$[ebp], eax
$LN5@sort_path:
	cmp	DWORD PTR _list$[ebp], 0
	je	SHORT $LN3@sort_path

; 6211 : 
; 6212 :         ht = (HASH_TABLE *)list -> node;

	mov	ecx, DWORD PTR _list$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _ht$[ebp], edx

; 6213 : 
; 6214 :         if( cd_id == toupper( ht -> name[0] ))

	movsx	esi, BYTE PTR _cd_id$[ebp]
	mov	eax, 1
	imul	eax, 0
	mov	ecx, DWORD PTR _ht$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	movsx	eax, BYTE PTR [edx+eax]
	push	eax
	call	_toupper
	add	esp, 4
	cmp	esi, eax
	jne	SHORT $LN2@sort_path

; 6215 :             cd_list = LIST_APPEND_END( cd_list, ht );

	mov	ecx, DWORD PTR _ht$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cd_list$[ebp]
	push	edx
	call	_ListAppendEnd
	add	esp, 8
	mov	DWORD PTR _cd_list$[ebp], eax

; 6216 :         else

	jmp	SHORT $LN1@sort_path
$LN2@sort_path:

; 6217 :             hd_list = LIST_APPEND_END( hd_list, ht );

	mov	eax, DWORD PTR _ht$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hd_list$[ebp]
	push	ecx
	call	_ListAppendEnd
	add	esp, 8
	mov	DWORD PTR _hd_list$[ebp], eax
$LN1@sort_path:

; 6218 :     }

	jmp	SHORT $LN4@sort_path
$LN3@sort_path:

; 6219 : 
; 6220 :     LIST_DESTROY( GLOBAL_PATH_LIST, NULL );

	push	0
	mov	edx, DWORD PTR _GLOBAL_PATH_LIST
	push	edx
	call	_ListDestroy
	add	esp, 8

; 6221 : 
; 6222 :     GLOBAL_PATH_LIST = LIST_CATENATE( hd_list, cd_list );

	mov	eax, DWORD PTR _cd_list$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hd_list$[ebp]
	push	ecx
	call	_ListCatenate
	add	esp, 8
	mov	DWORD PTR _GLOBAL_PATH_LIST, eax

; 6223 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_sort_path ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_table$ = -12						; size = 4
_entry$ = -8						; size = 4
_i$ = -4						; size = 4
_archive$ = 8						; size = 4
_res_detach_ex PROC

; 6240 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 6241 :     HASH_ENTRY * entry;
; 6242 : 
; 6243 :     int i;
; 6244 : 
; 6245 : #if( !RES_USE_FLAT_MODEL )
; 6246 :     HASH_TABLE * table;
; 6247 : 
; 6248 :     for( i=0; i<archive -> num_entries; i++ ) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN5@res_detach
$LN4@res_detach:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN5@res_detach:
	mov	ecx, DWORD PTR _archive$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+256]
	jge	SHORT $LN3@res_detach

; 6249 :         entry = hash_find_table( &archive -> name[i], &table );

	lea	eax, DWORD PTR _table$[ebp]
	push	eax
	mov	ecx, DWORD PTR _archive$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	push	ecx
	call	_hash_find_table
	add	esp, 8
	mov	DWORD PTR _entry$[ebp], eax

; 6250 : 
; 6251 :         if( !entry ) {

	cmp	DWORD PTR _entry$[ebp], 0
	jne	SHORT $LN2@res_detach

; 6252 :             SAY_ERROR( RES_ERR_FILE_NOT_FOUND, &archive -> name[i] );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	6252					; 0000186cH
	mov	edx, DWORD PTR _archive$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	push	edx
	push	-4993					; ffffec7fH
	call	__say_error
	add	esp, 16					; 00000010H

; 6253 :             continue;

	jmp	SHORT $LN4@res_detach
$LN2@res_detach:

; 6254 :         }
; 6255 : 
; 6256 :         if( ((ARCHIVE*)entry -> archive) -> os_handle ==             archive -> os_handle ) /* make sure the entry wasn't overridden */

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _archive$[ebp]
	mov	eax, DWORD PTR [ecx+260]
	cmp	eax, DWORD PTR [edx+260]
	jne	SHORT $LN1@res_detach

; 6257 : 
; 6258 :             hash_delete( entry, table );

	mov	ecx, DWORD PTR _table$[ebp]
	push	ecx
	mov	edx, DWORD PTR _entry$[ebp]
	push	edx
	call	_hash_delete
	add	esp, 8
$LN1@res_detach:

; 6259 :     }

	jmp	SHORT $LN4@res_detach
$LN3@res_detach:

; 6260 : #else
; 6261 :     for( i=0; i<archive -> num_entries; i++ ) {
; 6262 :         entry = hash_find( &archive -> name[i], GLOBAL_HASH_TABLE );
; 6263 :         if( !entry ) {
; 6264 :             SAY_ERROR( RES_ERR_FILE_NOT_FOUND, &archive -> name[i] );
; 6265 :             continue;
; 6266 :         }
; 6267 : 
; 6268 :         if( ((ARCHIVE *)entry -> archive) -> os_handle == archive -> os_handle ) /* make sure the entry wasn't overridden */
; 6269 :             hash_delete( entry, GLOBAL_HASH_TABLE );
; 6270 :     }
; 6271 : #endif /* !USE_FLAT_MODEL */
; 6272 : 
; 6273 :     _close( archive -> os_handle );

	mov	eax, DWORD PTR _archive$[ebp]
	mov	ecx, DWORD PTR [eax+260]
	push	ecx
	call	__close
	add	esp, 4

; 6274 : 
; 6275 :     DESTROY_LOCK( archive -> lock );

	mov	edx, DWORD PTR _archive$[ebp]
	mov	eax, DWORD PTR [edx+276]
	push	eax
	call	DWORD PTR __imp__CloseHandle@4

; 6276 : 
; 6277 : 	#ifdef USE_SH_POOLS
; 6278 :     MemFreePtr( archive );
; 6279 : 	#else
; 6280 :     MemFree( archive );

	mov	ecx, DWORD PTR _archive$[ebp]
	push	ecx
	call	_free
	add	esp, 4

; 6281 : 	#endif
; 6282 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_res_detach_ex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_colon$ = -556						; size = 4
_len$ = -552						; size = 4
$T1 = -548						; size = 4
$T2 = -544						; size = 4
_chop$ = -540						; size = 4
_drive$ = -536						; size = 4
_i$ = -532						; size = 4
_rel$ = -528						; size = 4
_tmp_buffer$ = -524					; size = 260
_current_path$ = -264					; size = 260
__$ArrayPad$ = -4					; size = 4
_abs_buffer$ = 8					; size = 4
_rel_buffer$ = 12					; size = 4
_maxlen$ = 16						; size = 4
_res_fullpath PROC

; 7601 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 556				; 0000022cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 7602 : #if( RES_USE_FULLPATH )
; 7603 : 
; 7604 :     char  * colon;
; 7605 :     char  * rel;
; 7606 : 
; 7607 :     char    drive[4];
; 7608 :     char    tmp_buffer[ _MAX_PATH ];
; 7609 :     char    current_path[ _MAX_PATH ];
; 7610 : 
; 7611 :     int     chop = 0,

	mov	DWORD PTR _chop$[ebp], 0

; 7612 :             len,
; 7613 :             i;
; 7614 : 
; 7615 : 	maxlen;
; 7616 : 
; 7617 :     if( !GLOBAL_PATH_LIST )

	cmp	DWORD PTR _GLOBAL_PATH_LIST, 0
	jne	SHORT $LN16@res_fullpa

; 7618 :         strcpy( current_path, "c:\\" );

	push	OFFSET ??_C@_03MINKAKBA@c?3?2?$AA@
	lea	eax, DWORD PTR _current_path$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 7619 :     else

	jmp	SHORT $LN15@res_fullpa
$LN16@res_fullpa:

; 7620 :         strcpy( current_path, ((HASH_TABLE *)(GLOBAL_PATH_LIST -> node)) -> name );

	mov	ecx, DWORD PTR _GLOBAL_PATH_LIST
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	lea	ecx, DWORD PTR _current_path$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8
$LN15@res_fullpa:

; 7621 : 
; 7622 :     rel = (char *)rel_buffer;

	mov	edx, DWORD PTR _rel_buffer$[ebp]
	mov	DWORD PTR _rel$[ebp], edx

; 7623 : 
; 7624 :     colon = strchr( rel, ASCII_COLON );

	push	58					; 0000003aH
	mov	eax, DWORD PTR _rel$[ebp]
	push	eax
	call	_strchr
	add	esp, 8
	mov	DWORD PTR _colon$[ebp], eax

; 7625 : 
; 7626 :     if( colon ) {

	cmp	DWORD PTR _colon$[ebp], 0
	je	$LN14@res_fullpa

; 7627 :         if( rel_buffer[1] != ASCII_COLON ) {

	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _rel_buffer$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 58					; 0000003aH
	je	SHORT $LN13@res_fullpa

; 7628 :             *abs_buffer = 0x00;

	mov	ecx, DWORD PTR _abs_buffer$[ebp]
	mov	BYTE PTR [ecx], 0

; 7629 :             return( NULL );

	xor	eax, eax
	jmp	$LN18@res_fullpa
$LN13@res_fullpa:

; 7630 :         }
; 7631 : 
; 7632 :         if( !strstr( rel_buffer, ".." ))

	push	OFFSET ??_C@_02DJGKEECL@?4?4?$AA@
	mov	edx, DWORD PTR _rel_buffer$[ebp]
	push	edx
	call	_strstr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN12@res_fullpa

; 7633 :             return( strcpy( abs_buffer, rel_buffer ));

	mov	eax, DWORD PTR _rel_buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _abs_buffer$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8
	jmp	$LN18@res_fullpa
$LN12@res_fullpa:

; 7634 :         
; 7635 :         strncpy( drive, rel_buffer, 2 );

	push	2
	mov	edx, DWORD PTR _rel_buffer$[ebp]
	push	edx
	lea	eax, DWORD PTR _drive$[ebp]
	push	eax
	call	_strncpy
	add	esp, 12					; 0000000cH

; 7636 :         drive[2] = ASCII_BACKSLASH;

	mov	ecx, 1
	shl	ecx, 1
	mov	BYTE PTR _drive$[ebp+ecx], 92		; 0000005cH

; 7637 :         drive[3] = 0x00;

	mov	edx, 1
	imul	edx, 3
	mov	DWORD PTR $T2[ebp], edx
	cmp	DWORD PTR $T2[ebp], 4
	jae	SHORT $LN19@res_fullpa
	jmp	SHORT $LN20@res_fullpa
$LN19@res_fullpa:
	call	___report_rangecheckfailure
$LN20@res_fullpa:
	mov	eax, DWORD PTR $T2[ebp]
	mov	BYTE PTR _drive$[ebp+eax], 0

; 7638 : 
; 7639 :         rel += 2;

	mov	ecx, DWORD PTR _rel$[ebp]
	add	ecx, 2
	mov	DWORD PTR _rel$[ebp], ecx

; 7640 :     }
; 7641 :     else {

	jmp	$LN11@res_fullpa
$LN14@res_fullpa:

; 7642 :         strncpy( drive, current_path, 2 );

	push	2
	lea	edx, DWORD PTR _current_path$[ebp]
	push	edx
	lea	eax, DWORD PTR _drive$[ebp]
	push	eax
	call	_strncpy
	add	esp, 12					; 0000000cH

; 7643 :         drive[2] = ASCII_BACKSLASH;

	mov	ecx, 1
	shl	ecx, 1
	mov	BYTE PTR _drive$[ebp+ecx], 92		; 0000005cH

; 7644 :         drive[3] = 0x00;

	mov	edx, 1
	imul	edx, 3
	mov	DWORD PTR $T1[ebp], edx
	cmp	DWORD PTR $T1[ebp], 4
	jae	SHORT $LN21@res_fullpa
	jmp	SHORT $LN22@res_fullpa
$LN21@res_fullpa:
	call	___report_rangecheckfailure
$LN22@res_fullpa:
	mov	eax, DWORD PTR $T1[ebp]
	mov	BYTE PTR _drive$[ebp+eax], 0

; 7645 : 
; 7646 :         if( rel_buffer[0] == ASCII_BACKSLASH ) {

	mov	ecx, 1
	imul	ecx, 0
	mov	edx, DWORD PTR _rel_buffer$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 92					; 0000005cH
	jne	SHORT $LN11@res_fullpa

; 7647 :             sprintf( abs_buffer, "%s%s", drive, &rel_buffer[1] );

	mov	ecx, 1
	shl	ecx, 0
	add	ecx, DWORD PTR _rel_buffer$[ebp]
	push	ecx
	lea	edx, DWORD PTR _drive$[ebp]
	push	edx
	push	OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
	mov	eax, DWORD PTR _abs_buffer$[ebp]
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H

; 7648 :             return( abs_buffer );       

	mov	eax, DWORD PTR _abs_buffer$[ebp]
	jmp	$LN18@res_fullpa
$LN11@res_fullpa:

; 7649 :         }
; 7650 :     }
; 7651 : 
; 7652 :     if( *rel == ASCII_BACKSLASH ) {

	mov	ecx, DWORD PTR _rel$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 92					; 0000005cH
	jne	SHORT $LN8@res_fullpa

; 7653 :         sprintf( abs_buffer, "%s%s", drive, rel );

	mov	eax, DWORD PTR _rel$[ebp]
	push	eax
	lea	ecx, DWORD PTR _drive$[ebp]
	push	ecx
	push	OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
	mov	edx, DWORD PTR _abs_buffer$[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 7654 :         return( abs_buffer );

	mov	eax, DWORD PTR _abs_buffer$[ebp]
	jmp	$LN18@res_fullpa
$LN8@res_fullpa:

; 7655 :     }    
; 7656 : 
; 7657 :     while( !memcmp( rel, "..", 3 )) {

	push	3
	push	OFFSET ??_C@_02DJGKEECL@?4?4?$AA@
	mov	eax, DWORD PTR _rel$[ebp]
	push	eax
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN7@res_fullpa

; 7658 :         chop++;

	mov	ecx, DWORD PTR _chop$[ebp]
	add	ecx, 1
	mov	DWORD PTR _chop$[ebp], ecx

; 7659 :         rel += 2;

	mov	edx, DWORD PTR _rel$[ebp]
	add	edx, 2
	mov	DWORD PTR _rel$[ebp], edx

; 7660 :         if( *rel == ASCII_BACKSLASH )

	mov	eax, DWORD PTR _rel$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 92					; 0000005cH
	jne	SHORT $LN6@res_fullpa

; 7661 :             //*rel++;
; 7662 :             (*rel) = (*rel) + 1; //Pu239

	mov	edx, DWORD PTR _rel$[ebp]
	movsx	eax, BYTE PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _rel$[ebp]
	mov	BYTE PTR [ecx], al
$LN6@res_fullpa:

; 7663 :     }

	jmp	SHORT $LN8@res_fullpa
$LN7@res_fullpa:

; 7664 : 
; 7665 :     len = strlen( current_path ) - 2;

	lea	edx, DWORD PTR _current_path$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	sub	eax, 2
	mov	DWORD PTR _len$[ebp], eax

; 7666 : 
; 7667 :     for( i=len; i && chop; i-- )

	mov	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN5@res_fullpa
$LN4@res_fullpa:
	mov	ecx, DWORD PTR _i$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN5@res_fullpa:
	cmp	DWORD PTR _i$[ebp], 0
	je	SHORT $LN3@res_fullpa
	cmp	DWORD PTR _chop$[ebp], 0
	je	SHORT $LN3@res_fullpa

; 7668 :         if( current_path[i] == ASCII_BACKSLASH )

	mov	edx, DWORD PTR _i$[ebp]
	movsx	eax, BYTE PTR _current_path$[ebp+edx]
	cmp	eax, 92					; 0000005cH
	jne	SHORT $LN2@res_fullpa

; 7669 :             chop--;

	mov	ecx, DWORD PTR _chop$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _chop$[ebp], ecx
$LN2@res_fullpa:

; 7670 : 
; 7671 :     if( !i ) 

	jmp	SHORT $LN4@res_fullpa
$LN3@res_fullpa:
	cmp	DWORD PTR _i$[ebp], 0
	jne	SHORT $LN1@res_fullpa

; 7672 :         i=1;

	mov	DWORD PTR _i$[ebp], 1
$LN1@res_fullpa:

; 7673 : 
; 7674 :     strncpy( tmp_buffer, current_path, i+2 );

	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 2
	push	edx
	lea	eax, DWORD PTR _current_path$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tmp_buffer$[ebp]
	push	ecx
	call	_strncpy
	add	esp, 12					; 0000000cH

; 7675 : 
; 7676 :     strcpy( &tmp_buffer[i+2], rel );

	mov	edx, DWORD PTR _rel$[ebp]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	lea	ecx, DWORD PTR _tmp_buffer$[ebp+eax+2]
	push	ecx
	call	_strcpy
	add	esp, 8

; 7677 : 
; 7678 :     return( strcpy( abs_buffer, tmp_buffer ));

	lea	edx, DWORD PTR _tmp_buffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _abs_buffer$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8
$LN18@res_fullpa:

; 7679 : 
; 7680 : #else
; 7681 : 
; 7682 :     return( _fullpath( abs_path, rel_path, maxlen ));
; 7683 : 
; 7684 : #endif
; 7685 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_res_fullpath ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_dir$1 = -12						; size = 4
_list$ = -8						; size = 4
_index$ = -4						; size = 4
_shut_down PROC

; 6019 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 6020 :     LIST    * list;
; 6021 :     int       index;
; 6022 : 
; 6023 :     /* Reset system paths.  The paths were stored with strdup, so we
; 6024 :        free them here. */
; 6025 : 
; 6026 :     for( index=0; index<RES_DIR_LAST; index++ )

	mov	DWORD PTR _index$[ebp], 0
	jmp	SHORT $LN27@shut_down
$LN26@shut_down:
	mov	eax, DWORD PTR _index$[ebp]
	add	eax, 1
	mov	DWORD PTR _index$[ebp], eax
$LN27@shut_down:
	cmp	DWORD PTR _index$[ebp], 17		; 00000011H
	jge	SHORT $LN25@shut_down

; 6027 :         if( RES_PATH[ index ] )

	mov	ecx, DWORD PTR _index$[ebp]
	cmp	DWORD PTR _RES_PATH[ecx*4], 0
	je	SHORT $LN24@shut_down

; 6028 : 			#ifdef USE_SH_POOLS
; 6029 :             MemFreePtr( RES_PATH[ index ] );
; 6030 : 			#else
; 6031 :             MemFree( RES_PATH[ index ] );

	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _RES_PATH[edx*4]
	push	eax
	call	_free
	add	esp, 4
$LN24@shut_down:

; 6032 : 			#endif
; 6033 : 
; 6034 :     if( GLOBAL_SEARCH_INDEX ) 

	jmp	SHORT $LN26@shut_down
$LN25@shut_down:
	cmp	DWORD PTR _GLOBAL_SEARCH_INDEX, 0
	je	SHORT $LN23@shut_down

; 6035 :         for( index=0; index<GLOBAL_SEARCH_INDEX; index++ )

	mov	DWORD PTR _index$[ebp], 0
	jmp	SHORT $LN22@shut_down
$LN21@shut_down:
	mov	ecx, DWORD PTR _index$[ebp]
	add	ecx, 1
	mov	DWORD PTR _index$[ebp], ecx
$LN22@shut_down:
	mov	edx, DWORD PTR _index$[ebp]
	cmp	edx, DWORD PTR _GLOBAL_SEARCH_INDEX
	jge	SHORT $LN23@shut_down

; 6036 : 			#ifdef USE_SH_POOLS
; 6037 :             MemFreePtr( GLOBAL_SEARCH_PATH[ index ] );
; 6038 : 			#else
; 6039 :             MemFree( GLOBAL_SEARCH_PATH[ index ] );

	mov	eax, DWORD PTR _index$[ebp]
	mov	ecx, DWORD PTR _GLOBAL_SEARCH_PATH[eax*4]
	push	ecx
	call	_free
	add	esp, 4
	jmp	SHORT $LN21@shut_down
$LN23@shut_down:

; 6040 : 			#endif
; 6041 : 
; 6042 :     memset( GLOBAL_SEARCH_PATH, 0, sizeof(GLOBAL_SEARCH_PATH));

	push	1000					; 000003e8H
	push	0
	push	OFFSET _GLOBAL_SEARCH_PATH
	call	_memset
	add	esp, 12					; 0000000cH

; 6043 :     GLOBAL_SEARCH_INDEX = 0;

	mov	DWORD PTR _GLOBAL_SEARCH_INDEX, 0

; 6044 : 
; 6045 :     memset( RES_PATH, 0, sizeof(char*) * RES_DIR_LAST );   /* reset system paths */

	push	68					; 00000044H
	push	0
	push	OFFSET _RES_PATH
	call	_memset
	add	esp, 12					; 0000000cH

; 6046 : 
; 6047 : 
; 6048 :     /* If there are any files that are still open (regardless of whether the
; 6049 :        media has been ejected by the user or not) allocations will still 
; 6050 :        exist.  Close any of them here. */
; 6051 : 
; 6052 :     if( FILE_HANDLES ) { /* close any open file handles, clear for heck of it */

	cmp	DWORD PTR _FILE_HANDLES, 0
	je	SHORT $LN19@shut_down

; 6053 :         for( index = 0; index < MAX_FILE_HANDLES; index++ )

	mov	DWORD PTR _index$[ebp], 0
	jmp	SHORT $LN18@shut_down
$LN17@shut_down:
	mov	edx, DWORD PTR _index$[ebp]
	add	edx, 1
	mov	DWORD PTR _index$[ebp], edx
$LN18@shut_down:
	cmp	DWORD PTR _index$[ebp], 256		; 00000100H
	jge	SHORT $LN16@shut_down

; 6054 :             if( FILE_HANDLES[ index ].os_handle != -1 )

	mov	eax, DWORD PTR _index$[ebp]
	imul	eax, 52					; 00000034H
	mov	ecx, DWORD PTR _FILE_HANDLES
	cmp	DWORD PTR [ecx+eax], -1
	je	SHORT $LN15@shut_down

; 6055 :                 ResCloseFile( index );

	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	call	_ResCloseFile
	add	esp, 4
$LN15@shut_down:

; 6056 : 
; 6057 : 		#ifdef USE_SH_POOLS
; 6058 :         MemFreePtr( FILE_HANDLES );
; 6059 : 		#else
; 6060 :         MemFree( FILE_HANDLES );

	jmp	SHORT $LN17@shut_down
$LN16@shut_down:
	mov	eax, DWORD PTR _FILE_HANDLES
	push	eax
	call	_free
	add	esp, 4

; 6061 : 		#endif
; 6062 : 
; 6063 :         FILE_HANDLES = NULL;

	mov	DWORD PTR _FILE_HANDLES, 0
$LN19@shut_down:

; 6064 :     }
; 6065 : 
; 6066 : 
; 6067 :     /* If there are any archive files that haven't been closed, do
; 6068 :        so now. */
; 6069 : 
; 6070 :     if( ARCHIVE_LIST ) {

	cmp	DWORD PTR _ARCHIVE_LIST, 0
	je	SHORT $LN14@shut_down

; 6071 :         for( list = ARCHIVE_LIST; list; list = list -> next )

	mov	ecx, DWORD PTR _ARCHIVE_LIST
	mov	DWORD PTR _list$[ebp], ecx
	jmp	SHORT $LN13@shut_down
$LN12@shut_down:
	mov	edx, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _list$[ebp], eax
$LN13@shut_down:
	cmp	DWORD PTR _list$[ebp], 0
	je	SHORT $LN11@shut_down

; 6072 :             res_detach_ex((ARCHIVE *)list -> node );

	mov	ecx, DWORD PTR _list$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_res_detach_ex
	add	esp, 4
	jmp	SHORT $LN12@shut_down
$LN11@shut_down:

; 6073 : 
; 6074 :         LIST_DESTROY( ARCHIVE_LIST, NULL );

	push	0
	mov	eax, DWORD PTR _ARCHIVE_LIST
	push	eax
	call	_ListDestroy
	add	esp, 8

; 6075 :             
; 6076 :         //UGGH! --> Why won't this compile? LIST_DESTROY( ARCHIVE_LIST, res_detach_ex );
; 6077 : 
; 6078 :         ARCHIVE_LIST = NULL;

	mov	DWORD PTR _ARCHIVE_LIST, 0

; 6079 : 
; 6080 :         inflate_free(); 

	call	_inflate_free
$LN14@shut_down:

; 6081 :     }
; 6082 : 
; 6083 : #if( RES_DEBUG_VERSION )
; 6084 :     /* If you've called any ResOpenDirectory()'s without calling the 
; 6085 :        destructor ResCloseDirectory, the debug version takes care of
; 6086 :        it for you.  Do this using the Release version and you'll 
; 6087 :        leak.                                                            */
; 6088 : 
; 6089 :     if( OPEN_DIR_LIST ) {

	cmp	DWORD PTR _OPEN_DIR_LIST, 0
	je	SHORT $LN10@shut_down

; 6090 :         RES_DIR * dir;
; 6091 : 
; 6092 :         for( list = OPEN_DIR_LIST; list; list = list -> next ) {

	mov	ecx, DWORD PTR _OPEN_DIR_LIST
	mov	DWORD PTR _list$[ebp], ecx
	jmp	SHORT $LN9@shut_down
$LN8@shut_down:
	mov	edx, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _list$[ebp], eax
$LN9@shut_down:
	cmp	DWORD PTR _list$[ebp], 0
	je	SHORT $LN7@shut_down

; 6093 :             dir = (RES_DIR *)list -> node;

	mov	ecx, DWORD PTR _list$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _dir$1[ebp], edx

; 6094 :             ResCloseDirectory( dir );

	mov	eax, DWORD PTR _dir$1[ebp]
	push	eax
	call	_ResCloseDirectory
	add	esp, 4

; 6095 :             IF_LOG( LOG( "directory leak prevented: %s\n", dir -> name ));
; 6096 :         }

	jmp	SHORT $LN8@shut_down
$LN7@shut_down:

; 6097 : 
; 6098 :         LIST_DESTROY( OPEN_DIR_LIST, NULL );

	push	0
	mov	ecx, DWORD PTR _OPEN_DIR_LIST
	push	ecx
	call	_ListDestroy
	add	esp, 8

; 6099 :         OPEN_DIR_LIST = NULL;

	mov	DWORD PTR _OPEN_DIR_LIST, 0
$LN10@shut_down:

; 6100 :     }
; 6101 : #endif /* RES_DEBUG_VERSION */
; 6102 : 
; 6103 :     if( RES_DEVICES )

	cmp	DWORD PTR _RES_DEVICES, 0
	je	SHORT $LN6@shut_down

; 6104 : 		#ifdef USE_SH_POOLS
; 6105 :         MemFreePtr( RES_DEVICES );
; 6106 : 		#else
; 6107 :         MemFree( RES_DEVICES );

	mov	edx, DWORD PTR _RES_DEVICES
	push	edx
	call	_free
	add	esp, 4
$LN6@shut_down:

; 6108 : 		#endif
; 6109 : 
; 6110 :     RES_DEVICES = NULL;

	mov	DWORD PTR _RES_DEVICES, 0

; 6111 : 
; 6112 :     if( GLOBAL_PATH_LIST ) {

	cmp	DWORD PTR _GLOBAL_PATH_LIST, 0
	je	SHORT $LN5@shut_down

; 6113 :         for( list = GLOBAL_PATH_LIST; list; list = list -> next )

	mov	eax, DWORD PTR _GLOBAL_PATH_LIST
	mov	DWORD PTR _list$[ebp], eax
	jmp	SHORT $LN4@shut_down
$LN3@shut_down:
	mov	ecx, DWORD PTR _list$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _list$[ebp], edx
$LN4@shut_down:
	cmp	DWORD PTR _list$[ebp], 0
	je	SHORT $LN2@shut_down

; 6114 :             hash_destroy((HASH_TABLE *)list -> node );

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_hash_destroy
	add	esp, 4
	jmp	SHORT $LN3@shut_down
$LN2@shut_down:

; 6115 : 
; 6116 :         LIST_DESTROY( GLOBAL_PATH_LIST, NULL );

	push	0
	mov	edx, DWORD PTR _GLOBAL_PATH_LIST
	push	edx
	call	_ListDestroy
	add	esp, 8

; 6117 :         GLOBAL_PATH_LIST = NULL;

	mov	DWORD PTR _GLOBAL_PATH_LIST, 0
$LN5@shut_down:

; 6118 :     }
; 6119 :   
; 6120 :     if( GLOBAL_HASH_TABLE ) {

	cmp	DWORD PTR _GLOBAL_HASH_TABLE, 0
	je	SHORT $LN28@shut_down

; 6121 :         hash_destroy( GLOBAL_HASH_TABLE );

	mov	eax, DWORD PTR _GLOBAL_HASH_TABLE
	push	eax
	call	_hash_destroy
	add	esp, 4

; 6122 :         GLOBAL_HASH_TABLE = NULL;

	mov	DWORD PTR _GLOBAL_HASH_TABLE, 0
$LN28@shut_down:

; 6123 :     }
; 6124 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_shut_down ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_len$ = -276						; size = 4
$T1 = -272						; size = 4
_i$ = -268						; size = 4
_fullpath$ = -264					; size = 260
__$ArrayPad$ = -4					; size = 4
_in_name$ = 8						; size = 4
_out_filename$ = 12					; size = 4
_out_dirpath$ = 16					; size = 4
_split_path PROC

; 7274 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 276				; 00000114H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 7275 :     char fullpath[ _MAX_PATH ];
; 7276 :     int  len,
; 7277 :          i;
; 7278 : 
; 7279 :     if( res_fullpath( fullpath, in_name, _MAX_PATH ) == NULL )

	push	260					; 00000104H
	mov	eax, DWORD PTR _in_name$[ebp]
	push	eax
	lea	ecx, DWORD PTR _fullpath$[ebp]
	push	ecx
	call	_res_fullpath
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN12@split_path

; 7280 :     {
; 7281 :         if( out_filename ) *out_filename = '\0';

	cmp	DWORD PTR _out_filename$[ebp], 0
	je	SHORT $LN11@split_path
	mov	edx, DWORD PTR _out_filename$[ebp]
	mov	BYTE PTR [edx], 0
$LN11@split_path:

; 7282 :         if( out_dirpath  ) *out_dirpath = '\0';

	cmp	DWORD PTR _out_dirpath$[ebp], 0
	je	SHORT $LN10@split_path
	mov	eax, DWORD PTR _out_dirpath$[ebp]
	mov	BYTE PTR [eax], 0
$LN10@split_path:

; 7283 :         return;

	jmp	$LN14@split_path
$LN12@split_path:

; 7284 :     }
; 7285 : 
; 7286 :     len = strlen( fullpath );

	lea	ecx, DWORD PTR _fullpath$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _len$[ebp], eax

; 7287 : 
; 7288 :     for( i=len; i>=0; i-- ) {

	mov	edx, DWORD PTR _len$[ebp]
	mov	DWORD PTR _i$[ebp], edx
	jmp	SHORT $LN9@split_path
$LN8@split_path:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN9@split_path:
	cmp	DWORD PTR _i$[ebp], 0
	jl	$LN7@split_path

; 7289 :         if(( fullpath[i] == ASCII_BACKSLASH ) ||
; 7290 :            ( fullpath[i] == ASCII_COLON ))

	mov	ecx, DWORD PTR _i$[ebp]
	movsx	edx, BYTE PTR _fullpath$[ebp+ecx]
	cmp	edx, 92					; 0000005cH
	je	SHORT $LN5@split_path
	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR _fullpath$[ebp+eax]
	cmp	ecx, 58					; 0000003aH
	jne	SHORT $LN6@split_path
$LN5@split_path:

; 7291 :         {
; 7292 :             if( out_filename ) strcpy( out_filename, &fullpath[i+1] );

	cmp	DWORD PTR _out_filename$[ebp], 0
	je	SHORT $LN4@split_path
	mov	edx, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR _fullpath$[ebp+edx+1]
	push	eax
	mov	ecx, DWORD PTR _out_filename$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8
$LN4@split_path:

; 7293 :             fullpath[i+1] = 0x00;

	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR $T1[ebp], edx
	cmp	DWORD PTR $T1[ebp], 260			; 00000104H
	jae	SHORT $LN15@split_path
	jmp	SHORT $LN16@split_path
$LN15@split_path:
	call	___report_rangecheckfailure
$LN16@split_path:
	mov	eax, DWORD PTR $T1[ebp]
	mov	BYTE PTR _fullpath$[ebp+eax], 0

; 7294 :             if( out_dirpath  ) strcpy( out_dirpath, fullpath );

	cmp	DWORD PTR _out_dirpath$[ebp], 0
	je	SHORT $LN3@split_path
	lea	ecx, DWORD PTR _fullpath$[ebp]
	push	ecx
	mov	edx, DWORD PTR _out_dirpath$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8
$LN3@split_path:

; 7295 :             return;

	jmp	SHORT $LN14@split_path
$LN6@split_path:

; 7296 :         }
; 7297 :     }

	jmp	$LN8@split_path
$LN7@split_path:

; 7298 : 
; 7299 :     if( out_filename ) strcpy( out_filename, fullpath );

	cmp	DWORD PTR _out_filename$[ebp], 0
	je	SHORT $LN2@split_path
	lea	eax, DWORD PTR _fullpath$[ebp]
	push	eax
	mov	ecx, DWORD PTR _out_filename$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8
$LN2@split_path:

; 7300 :     if( out_dirpath  ) *out_dirpath = '\0';

	cmp	DWORD PTR _out_dirpath$[ebp], 0
	je	SHORT $LN14@split_path
	mov	edx, DWORD PTR _out_dirpath$[ebp]
	mov	BYTE PTR [edx], 0
$LN14@split_path:

; 7301 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_split_path ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_get_handle PROC

; 7242 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 7243 :     int i;
; 7244 : 
; 7245 :     for( i=0; i<MAX_FILE_HANDLES; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@get_handle
$LN3@get_handle:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@get_handle:
	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jge	SHORT $LN2@get_handle

; 7246 :         if( FILE_HANDLES[i].os_handle == -1 )

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 52					; 00000034H
	mov	edx, DWORD PTR _FILE_HANDLES
	cmp	DWORD PTR [edx+ecx], -1
	jne	SHORT $LN1@get_handle

; 7247 :             return(i);

	mov	eax, DWORD PTR _i$[ebp]
	jmp	SHORT $LN5@get_handle
$LN1@get_handle:

; 7248 : 
; 7249 :     return( -1 );

	jmp	SHORT $LN3@get_handle
$LN2@get_handle:
	or	eax, -1
$LN5@get_handle:

; 7250 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_get_handle ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_ptr_out$ = -12						; size = 4
_string_space$ = -8					; size = 4
_size$ = -4						; size = 4
_hsh$ = 8						; size = 4
_string$ = 12						; size = 4
_hash_strcpy PROC

; 6475 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 6476 :     char * string_space;
; 6477 :     char * ptr_out;
; 6478 :     int    size;
; 6479 : 
; 6480 :     ptr_out = hsh -> ptr_in;

	mov	eax, DWORD PTR _hsh$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _ptr_out$[ebp], ecx

; 6481 : 
; 6482 :     strcpy( hsh -> ptr_in, string );

	mov	edx, DWORD PTR _string$[ebp]
	push	edx
	mov	eax, DWORD PTR _hsh$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	_strcpy
	add	esp, 8

; 6483 : 
; 6484 :     hsh -> ptr_in += strlen( string );

	mov	edx, DWORD PTR _string$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _hsh$[ebp]
	add	eax, DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _hsh$[ebp]
	mov	DWORD PTR [edx+12], eax

; 6485 :     *hsh -> ptr_in = '\0'; /*safety*/

	mov	eax, DWORD PTR _hsh$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	BYTE PTR [ecx], 0

; 6486 :     hsh -> ptr_in++;

	mov	edx, DWORD PTR _hsh$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, 1
	mov	ecx, DWORD PTR _hsh$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 6487 : 
; 6488 :     if( hsh -> ptr_in > hsh -> ptr_end ) {

	mov	edx, DWORD PTR _hsh$[ebp]
	mov	eax, DWORD PTR _hsh$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	cmp	ecx, DWORD PTR [eax+16]
	jbe	SHORT $LN1@hash_strcp

; 6489 :         size = HASH_TABLE_SIZE * MAX_FILENAME;

	mov	DWORD PTR _size$[ebp], 1740		; 000006ccH

; 6490 : 
; 6491 : 		#ifdef USE_SH_POOLS
; 6492 : 		string_space = (char *)MemAllocPtr( gResmgrMemPool, size, 0 );
; 6493 : 		#else
; 6494 : 		string_space = (char *)MemMalloc( size, "Strings" );

	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _string_space$[ebp], eax

; 6495 : 		#endif
; 6496 : 
; 6497 :         hsh -> str_list = LIST_APPEND( hsh -> str_list, string_space );

	mov	eax, DWORD PTR _string_space$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hsh$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	call	_ListAppend
	add	esp, 8
	mov	ecx, DWORD PTR _hsh$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 6498 :         hsh -> ptr_in = string_space;

	mov	edx, DWORD PTR _hsh$[ebp]
	mov	eax, DWORD PTR _string_space$[ebp]
	mov	DWORD PTR [edx+12], eax

; 6499 : 
; 6500 :         size = (int)((float)STRING_SAFETY_SIZE * (float)size);

	cvtsi2ss xmm0, DWORD PTR _size$[ebp]
	mulss	xmm0, DWORD PTR __real@3f59999a
	cvttss2si ecx, xmm0
	mov	DWORD PTR _size$[ebp], ecx

; 6501 :         hsh -> ptr_end = string_space + size;

	mov	edx, DWORD PTR _string_space$[ebp]
	add	edx, DWORD PTR _size$[ebp]
	mov	eax, DWORD PTR _hsh$[ebp]
	mov	DWORD PTR [eax+16], edx
$LN1@hash_strcp:

; 6502 :     }
; 6503 : 
; 6504 :     return( ptr_out );

	mov	eax, DWORD PTR _ptr_out$[ebp]

; 6505 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_hash_strcpy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
$T1 = -560						; size = 4
$T2 = -556						; size = 4
_path_used$ = -552					; size = 4
_wild_path$ = -548					; size = 4
_len$ = -544						; size = 4
_ht$ = -540						; size = 4
_i$ = -536						; size = 4
_list$ = -532						; size = 4
_wild_len$ = -528					; size = 4
_entry$ = -524						; size = 4
_filename$ = -520					; size = 256
_fullpath$ = -264					; size = 260
__$ArrayPad$ = -4					; size = 4
_name$ = 8						; size = 4
_table$ = 12						; size = 4
_hash_find_table PROC

; 7011 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 560				; 00000230H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 7012 :     int  path_used = FALSE,

	mov	DWORD PTR _path_used$[ebp], 0

; 7013 :           wild_path = FALSE;

	mov	DWORD PTR _wild_path$[ebp], 0

; 7014 : 
; 7015 :     HASH_TABLE * ht = NULL;

	mov	DWORD PTR _ht$[ebp], 0

; 7016 : 
; 7017 : 
; 7018 :     int  wild_len=0,

	mov	DWORD PTR _wild_len$[ebp], 0

; 7019 :          len=0,

	mov	DWORD PTR _len$[ebp], 0

; 7020 :          i;
; 7021 : 
; 7022 :     char fullpath[ _MAX_PATH ]={0},

	mov	BYTE PTR _fullpath$[ebp], 0
	push	259					; 00000103H
	push	0
	lea	eax, DWORD PTR _fullpath$[ebp+1]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 7023 :          filename[ _MAX_FNAME ]={0};

	mov	BYTE PTR _filename$[ebp], 0
	push	255					; 000000ffH
	push	0
	lea	ecx, DWORD PTR _filename$[ebp+1]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 7024 : 
; 7025 :     HASH_ENTRY * entry=NULL;

	mov	DWORD PTR _entry$[ebp], 0

; 7026 : 
; 7027 : #if( !RES_USE_FLAT_MODEL )
; 7028 :     LIST       * list=NULL;

	mov	DWORD PTR _list$[ebp], 0

; 7029 : #endif /* !RES_USE_FLAT_MODEL */
; 7030 : 
; 7031 :     if( !GLOBAL_HASH_TABLE )

	cmp	DWORD PTR _GLOBAL_HASH_TABLE, 0
	jne	SHORT $LN38@hash_find_

; 7032 :         return( NULL );

	xor	eax, eax
	jmp	$LN40@hash_find_
$LN38@hash_find_:

; 7033 : 
; 7034 : 
; 7035 : #if( RES_WILDCARD_PATHS )       
; 7036 : 
; 7037 :     /* wildcard directory */
; 7038 : 
; 7039 : 
; 7040 :     /* wild carding a directory means that you can specify a neo-absolute path.  Where
; 7041 :        an absolute path is really a shortcut to typing a path relative to your current
; 7042 :        working directory, wildcarding a path allows you to specify a branch from a directory
; 7043 :        tree, and that you want to look for files in a file in all directories that have
; 7044 :        the same branch.  For instance,
; 7045 : 
; 7046 :             given this:   
; 7047 : 
; 7048 :                 *\objects\foo.dat
; 7049 : 
; 7050 :             all of these would be found:
; 7051 :     
; 7052 :                 c:\game\install\objects\foo.dat
; 7053 :                 f:\objects\foo.dat
; 7054 :                 <archive>\data\objects\foo.dat
; 7055 : 
; 7056 :         Obviously this is primarily to find files that can be found on multiple volumes,
; 7057 :         rather than multiple locations on one volume.  The other way of doing this would
; 7058 :         have been to simply leave the volume identifier out of the hash lookup function.
; 7059 :         This however, would have made it impossible to explicitly specify a volume to
; 7060 :         differentiate between two files. */
; 7061 : 
; 7062 : 
; 7063 :     /* It may not be a good idea to implement this here (at a point so low in the code).  
; 7064 :        I haven't made up my mind yet whether this should be done at a higher level 
; 7065 :        (like the way unix expands argv[] wildcards) or whether it should be so 
; 7066 :        cancerously ingrained here.  For now, here it goes. */
; 7067 : 
; 7068 :     if( name[0] == ASCII_ASTERISK ) {

	mov	edx, 1
	imul	edx, 0
	mov	eax, DWORD PTR _name$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 42					; 0000002aH
	jne	$LN37@hash_find_

; 7069 : 
; 7070 :         /* strip the filename out of 'name' and then stuff what path information we 
; 7071 :            do have into fullpath.  'wild_len' is the number of characters that we will
; 7072 :            compare of each of the directory entries in our search path with the path 
; 7073 :            we have here. */
; 7074 : 
; 7075 :         wild_path = TRUE;

	mov	DWORD PTR _wild_path$[ebp], 1

; 7076 :         path_used = TRUE;

	mov	DWORD PTR _path_used$[ebp], 1

; 7077 : 
; 7078 :         name++;

	mov	edx, DWORD PTR _name$[ebp]
	add	edx, 1
	mov	DWORD PTR _name$[ebp], edx

; 7079 :         strcpy( fullpath, name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	lea	ecx, DWORD PTR _fullpath$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 7080 :         wild_len = strlen(name);

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _wild_len$[ebp], eax
	jmp	SHORT $LN36@hash_find_
$LN35@hash_find_:

; 7081 :         for( wild_len; (name[wild_len] != ASCII_BACKSLASH) && wild_len; wild_len-- ) ;

	mov	eax, DWORD PTR _wild_len$[ebp]
	sub	eax, 1
	mov	DWORD PTR _wild_len$[ebp], eax
$LN36@hash_find_:
	mov	ecx, DWORD PTR _name$[ebp]
	add	ecx, DWORD PTR _wild_len$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 92					; 0000005cH
	je	SHORT $LN34@hash_find_
	cmp	DWORD PTR _wild_len$[ebp], 0
	je	SHORT $LN34@hash_find_
	jmp	SHORT $LN35@hash_find_
$LN34@hash_find_:

; 7082 : 
; 7083 :         if( wild_len ) {

	cmp	DWORD PTR _wild_len$[ebp], 0
	je	SHORT $LN33@hash_find_

; 7084 :             strcpy( filename, &name[ wild_len + 1 ] );

	mov	eax, DWORD PTR _wild_len$[ebp]
	mov	ecx, DWORD PTR _name$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	push	edx
	lea	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 7085 :             fullpath[wild_len + 1] = 0x00;

	mov	ecx, DWORD PTR _wild_len$[ebp]
	add	ecx, 1
	mov	DWORD PTR $T1[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 260			; 00000104H
	jae	SHORT $LN41@hash_find_
	jmp	SHORT $LN42@hash_find_
$LN41@hash_find_:
	call	___report_rangecheckfailure
$LN42@hash_find_:
	mov	edx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _fullpath$[ebp+edx], 0

; 7086 :         }
; 7087 :         else

	jmp	SHORT $LN37@hash_find_
$LN33@hash_find_:

; 7088 :             return( NULL ); /* improper use of wildcard directory! */

	xor	eax, eax
	jmp	$LN40@hash_find_
$LN37@hash_find_:

; 7089 :     }
; 7090 : 
; 7091 : #endif /* RES_WILDCARD_PATHS */
; 7092 : 
; 7093 :     /* check to see if a directory name is specified */
; 7094 : 
; 7095 :     if( !wild_path && (strchr( name, ASCII_BACKSLASH ) || (name[0] == ASCII_DOT))) {

	cmp	DWORD PTR _wild_path$[ebp], 0
	jne	$LN31@hash_find_
	push	92					; 0000005cH
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strchr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN30@hash_find_
	mov	ecx, 1
	imul	ecx, 0
	mov	edx, DWORD PTR _name$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 46					; 0000002eH
	jne	$LN31@hash_find_
$LN30@hash_find_:

; 7096 :         /* utterly non-portable */
; 7097 :         /* create a full path name from what could be a partial path */
; 7098 :         if( res_fullpath( fullpath, name, _MAX_PATH ) == NULL ) {

	push	260					; 00000104H
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	lea	edx, DWORD PTR _fullpath$[ebp]
	push	edx
	call	_res_fullpath
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN29@hash_find_

; 7099 :             SAY_ERROR( RES_ERR_CANT_INTERPRET, name );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	7099					; 00001bbbH
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	-4980					; ffffec8cH
	call	__say_error
	add	esp, 16					; 00000010H

; 7100 :             return( NULL );

	xor	eax, eax
	jmp	$LN40@hash_find_
$LN29@hash_find_:

; 7101 :         }
; 7102 : 
; 7103 :         /* split the full path name into components */
; 7104 : 
; 7105 :         len = strlen( fullpath );

	lea	ecx, DWORD PTR _fullpath$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _len$[ebp], eax

; 7106 :         for( i=len; i>=0; i-- ) {

	mov	edx, DWORD PTR _len$[ebp]
	mov	DWORD PTR _i$[ebp], edx
	jmp	SHORT $LN28@hash_find_
$LN27@hash_find_:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN28@hash_find_:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN26@hash_find_

; 7107 :             if( fullpath[i] == ASCII_BACKSLASH ) {

	mov	ecx, DWORD PTR _i$[ebp]
	movsx	edx, BYTE PTR _fullpath$[ebp+ecx]
	cmp	edx, 92					; 0000005cH
	jne	SHORT $LN25@hash_find_

; 7108 :                 strcpy( filename, &fullpath[i+1] );

	mov	eax, DWORD PTR _i$[ebp]
	lea	ecx, DWORD PTR _fullpath$[ebp+eax+1]
	push	ecx
	lea	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 7109 :                 fullpath[i+1] = 0x00;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR $T2[ebp], eax
	cmp	DWORD PTR $T2[ebp], 260			; 00000104H
	jae	SHORT $LN43@hash_find_
	jmp	SHORT $LN44@hash_find_
$LN43@hash_find_:
	call	___report_rangecheckfailure
$LN44@hash_find_:
	mov	ecx, DWORD PTR $T2[ebp]
	mov	BYTE PTR _fullpath$[ebp+ecx], 0

; 7110 :                 break;

	jmp	SHORT $LN26@hash_find_
$LN25@hash_find_:

; 7111 :             }
; 7112 :         }

	jmp	SHORT $LN27@hash_find_
$LN26@hash_find_:

; 7113 : 
; 7114 : #if( RES_USE_FLAT_MODEL )
; 7115 :         if( filename[0] == 0x00 ) {
; 7116 :             SAY_ERROR( RES_ERR_CANT_INTERPRET, name );
; 7117 :             if( table )
; 7118 :                 *table = NULL;
; 7119 : 
; 7120 :             return( NULL );
; 7121 :         }
; 7122 : #endif /* RES_USE_FLAT_MODEL */
; 7123 : 
; 7124 :         path_used = TRUE;

	mov	DWORD PTR _path_used$[ebp], 1
$LN31@hash_find_:

; 7125 :     }
; 7126 : 
; 7127 : #if( !RES_USE_FLAT_MODEL ) /* HIERARCHICAL MODEL */
; 7128 : 
; 7129 :     if( path_used ) {

	cmp	DWORD PTR _path_used$[ebp], 0
	je	$LN24@hash_find_

; 7130 : 
; 7131 : #if( RES_WILDCARD_PATHS )       
; 7132 :         if( wild_path ) {

	cmp	DWORD PTR _wild_path$[ebp], 0
	je	$LN23@hash_find_

; 7133 : 
; 7134 :             for( list = GLOBAL_PATH_LIST; list; list = list -> next ) {

	mov	edx, DWORD PTR _GLOBAL_PATH_LIST
	mov	DWORD PTR _list$[ebp], edx
	jmp	SHORT $LN22@hash_find_
$LN21@hash_find_:
	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _list$[ebp], ecx
$LN22@hash_find_:
	cmp	DWORD PTR _list$[ebp], 0
	je	$LN20@hash_find_

; 7135 : 
; 7136 :                 ht = (HASH_TABLE *)list -> node;

	mov	edx, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _ht$[ebp], eax

; 7137 : 
; 7138 :                 len = strlen( ht -> name );

	mov	ecx, DWORD PTR _ht$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _len$[ebp], eax

; 7139 : 
; 7140 :                 if( wild_len > len )

	mov	eax, DWORD PTR _wild_len$[ebp]
	cmp	eax, DWORD PTR _len$[ebp]
	jle	SHORT $LN19@hash_find_

; 7141 :                     continue;

	jmp	SHORT $LN21@hash_find_
$LN19@hash_find_:

; 7142 : 
; 7143 :                 if( !strnicmp( &ht -> name[ len - wild_len - 1 ], fullpath, wild_len )) {

	mov	ecx, DWORD PTR _wild_len$[ebp]
	push	ecx
	lea	edx, DWORD PTR _fullpath$[ebp]
	push	edx
	mov	eax, DWORD PTR _len$[ebp]
	sub	eax, DWORD PTR _wild_len$[ebp]
	mov	ecx, DWORD PTR _ht$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	lea	eax, DWORD PTR [edx+eax-1]
	push	eax
	call	_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN18@hash_find_

; 7144 :                     entry = hash_find( filename, ht );

	mov	ecx, DWORD PTR _ht$[ebp]
	push	ecx
	lea	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	_hash_find
	add	esp, 8
	mov	DWORD PTR _entry$[ebp], eax

; 7145 : 
; 7146 :                     if( table )

	cmp	DWORD PTR _table$[ebp], 0
	je	SHORT $LN17@hash_find_

; 7147 :                         *table = ht;

	mov	eax, DWORD PTR _table$[ebp]
	mov	ecx, DWORD PTR _ht$[ebp]
	mov	DWORD PTR [eax], ecx
$LN17@hash_find_:

; 7148 : 
; 7149 :                     if( entry ) 

	cmp	DWORD PTR _entry$[ebp], 0
	je	SHORT $LN18@hash_find_

; 7150 :                         return( entry );

	mov	eax, DWORD PTR _entry$[ebp]
	jmp	$LN40@hash_find_
$LN18@hash_find_:

; 7151 :                 }
; 7152 : 
; 7153 :             }

	jmp	$LN21@hash_find_
$LN20@hash_find_:

; 7154 : 
; 7155 :             if( table )

	cmp	DWORD PTR _table$[ebp], 0
	je	SHORT $LN15@hash_find_

; 7156 :                 *table = NULL;

	mov	edx, DWORD PTR _table$[ebp]
	mov	DWORD PTR [edx], 0
$LN15@hash_find_:

; 7157 :         
; 7158 :             return( NULL );

	xor	eax, eax
	jmp	$LN40@hash_find_

; 7159 :         }
; 7160 :         else {

	jmp	SHORT $LN14@hash_find_
$LN23@hash_find_:

; 7161 : #endif /* RES_WILDCARD_PATHS */
; 7162 : 
; 7163 :             entry = hash_find( fullpath, GLOBAL_HASH_TABLE );

	mov	eax, DWORD PTR _GLOBAL_HASH_TABLE
	push	eax
	lea	ecx, DWORD PTR _fullpath$[ebp]
	push	ecx
	call	_hash_find
	add	esp, 8
	mov	DWORD PTR _entry$[ebp], eax

; 7164 : 
; 7165 :             if( entry ) {

	cmp	DWORD PTR _entry$[ebp], 0
	je	SHORT $LN13@hash_find_

; 7166 :                 if( entry -> dir ) {        

	mov	edx, DWORD PTR _entry$[ebp]
	cmp	DWORD PTR [edx+40], 0
	je	SHORT $LN12@hash_find_

; 7167 :                     if( table )

	cmp	DWORD PTR _table$[ebp], 0
	je	SHORT $LN11@hash_find_

; 7168 :                         *table = (HASH_TABLE * )entry -> dir;

	mov	eax, DWORD PTR _table$[ebp]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR [eax], edx
$LN11@hash_find_:

; 7169 : 
; 7170 :                     return( hash_find( filename, (HASH_TABLE * )entry -> dir ));

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	lea	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	_hash_find
	add	esp, 8
	jmp	$LN40@hash_find_
$LN12@hash_find_:

; 7171 :                 }
; 7172 :             }
; 7173 :             else {

	jmp	SHORT $LN14@hash_find_
$LN13@hash_find_:

; 7174 :                 if( table )

	cmp	DWORD PTR _table$[ebp], 0
	je	SHORT $LN9@hash_find_

; 7175 :                     *table = NULL;

	mov	eax, DWORD PTR _table$[ebp]
	mov	DWORD PTR [eax], 0
$LN9@hash_find_:

; 7176 : 
; 7177 :                 return( NULL );

	xor	eax, eax
	jmp	$LN40@hash_find_
$LN14@hash_find_:

; 7178 :             }
; 7179 :         }
; 7180 : 
; 7181 :     }
; 7182 :     else { /* path_used == FALSE */

	jmp	SHORT $LN8@hash_find_
$LN24@hash_find_:

; 7183 : 
; 7184 :         /* look in order */
; 7185 :         for( list = GLOBAL_PATH_LIST; list; list = list -> next ) {

	mov	ecx, DWORD PTR _GLOBAL_PATH_LIST
	mov	DWORD PTR _list$[ebp], ecx
	jmp	SHORT $LN7@hash_find_
$LN6@hash_find_:
	mov	edx, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _list$[ebp], eax
$LN7@hash_find_:
	cmp	DWORD PTR _list$[ebp], 0
	je	SHORT $LN5@hash_find_

; 7186 :             entry = hash_find( name, (HASH_TABLE *)list -> node );

	mov	ecx, DWORD PTR _list$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_hash_find
	add	esp, 8
	mov	DWORD PTR _entry$[ebp], eax

; 7187 : 
; 7188 :             if( entry ) {

	cmp	DWORD PTR _entry$[ebp], 0
	je	SHORT $LN4@hash_find_

; 7189 :                 if( table )

	cmp	DWORD PTR _table$[ebp], 0
	je	SHORT $LN3@hash_find_

; 7190 :                     *table = (HASH_TABLE *)list -> node;

	mov	ecx, DWORD PTR _table$[ebp]
	mov	edx, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
$LN3@hash_find_:

; 7191 : 
; 7192 :                 return( entry );

	mov	eax, DWORD PTR _entry$[ebp]
	jmp	SHORT $LN40@hash_find_
$LN4@hash_find_:

; 7193 :             }
; 7194 :         }

	jmp	SHORT $LN6@hash_find_
$LN5@hash_find_:

; 7195 : 
; 7196 :         if( table )

	cmp	DWORD PTR _table$[ebp], 0
	je	SHORT $LN2@hash_find_

; 7197 :             *table = NULL;

	mov	ecx, DWORD PTR _table$[ebp]
	mov	DWORD PTR [ecx], 0
$LN2@hash_find_:

; 7198 : 
; 7199 :         return( NULL );

	xor	eax, eax
	jmp	SHORT $LN40@hash_find_
$LN8@hash_find_:

; 7200 :     }
; 7201 : #else /* !RES_USE_FLAT_MODEL */
; 7202 : 
; 7203 :     if( path_used )
; 7204 :         entry = hash_find( filename, GLOBAL_HASH_TABLE );
; 7205 :     else
; 7206 :         entry = hash_find( name, GLOBAL_HASH_TABLE );
; 7207 : 
; 7208 :     if( !entry ) {
; 7209 :         if( table )
; 7210 :             *table = NULL;
; 7211 :     }
; 7212 :     else
; 7213 :         if( table )
; 7214 :             *table = GLOBAL_HASH_TABLE;
; 7215 : 
; 7216 :     return( entry );
; 7217 : #endif
; 7218 : 
; 7219 :     if( table )

	cmp	DWORD PTR _table$[ebp], 0
	je	SHORT $LN1@hash_find_

; 7220 :         *table = NULL;

	mov	edx, DWORD PTR _table$[ebp]
	mov	DWORD PTR [edx], 0
$LN1@hash_find_:

; 7221 : 
; 7222 :     return( NULL );

	xor	eax, eax
$LN40@hash_find_:

; 7223 : }   

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_hash_find_table ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_ratio$1 = -12						; size = 4
_hash_val$ = -8						; size = 4
_entry$ = -4						; size = 4
_data$ = 8						; size = 4
_hsh$ = 12						; size = 4
_hash_add PROC

; 6521 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 6522 :     int   hash_val;    
; 6523 : 
; 6524 :     HASH_ENTRY * entry=NULL;

	mov	DWORD PTR _entry$[ebp], 0

; 6525 : 
; 6526 : 
; 6527 :     /* If we need to do a resize, we want to do it when there
; 6528 :        are no HASH_ENTRY pointers being used.  Currently, the
; 6529 :        HASH_TABLE is NOT being checked for a lock before 
; 6530 :        a resize is performed.  This is not safe. */
; 6531 : 
; 6532 :     /* Resize before searching (and returning) a HASH_ENTRY ptr */
; 6533 : 
; 6534 : 	if(hsh -> num_entries)

	mov	eax, DWORD PTR _hsh$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN6@hash_add

; 6535 : 	{
; 6536 : 		/* efficiency ratio of the hash table (entries/num slots)   */
; 6537 : 		float ratio = ((float)hsh -> table_size / (float)hsh -> num_entries );

	mov	ecx, DWORD PTR _hsh$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _hsh$[ebp]
	cvtsi2ss xmm1, DWORD PTR [edx+4]
	divss	xmm0, xmm1
	movss	DWORD PTR _ratio$1[ebp], xmm0

; 6538 : 
; 6539 : 		if( ratio < HASH_MINIMAL_RATIO )

	cvtss2sd xmm0, DWORD PTR _ratio$1[ebp]
	movsd	xmm1, QWORD PTR __real@3fe999999999999a
	comisd	xmm1, xmm0
	jbe	SHORT $LN6@hash_add

; 6540 : 			hash_resize( hsh );             /* WARNING: THIS IS STILL NOT THREAD SAFE! */

	mov	eax, DWORD PTR _hsh$[ebp]
	push	eax
	call	_hash_resize
	add	esp, 4
$LN6@hash_add:

; 6541 : 	}
; 6542 : 
; 6543 :     hash_val = hash( data -> name, hsh -> table_size );

	mov	ecx, DWORD PTR _hsh$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _data$[ebp]
	add	eax, 36					; 00000024H
	push	eax
	call	_hash
	add	esp, 8
	mov	DWORD PTR _hash_val$[ebp], eax

; 6544 : 
; 6545 :     if( hsh -> table[ hash_val ].attrib ) {   /* an entry already exists here                    */

	mov	ecx, DWORD PTR _hash_val$[ebp]
	imul	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _hsh$[ebp]
	mov	eax, DWORD PTR [edx+24]
	cmp	DWORD PTR [eax+ecx+28], 0
	je	SHORT $LN5@hash_add

; 6546 : #if( RES_USE_FLAT_MODEL )
; 6547 :         entry = hash_find( data -> name, hsh );
; 6548 : 
; 6549 :         if( entry ) {/* override automatically if this is the flat model */
; 6550 :             IF_LOG( LOG( "Override %s\n", data -> name ));
; 6551 : 
; 6552 :             entry -> name = hash_strcpy( hsh, data -> name );
; 6553 :             entry -> offset = 0;
; 6554 :             entry -> size = data -> size;
; 6555 :             entry -> attrib = data -> attrib | FORCE_BIT; /* FORCE_BIT ensures the field will be non-zero */
; 6556 :             /* entry -> next stays the same         */
; 6557 :             /* hsh -> num_entries stays the same    */
; 6558 :             return( entry );
; 6559 :         }
; 6560 : #endif /* RES_USE_FLAT_MODEL */
; 6561 : 
; 6562 :         entry = &hsh -> table[ hash_val ];

	mov	ecx, DWORD PTR _hash_val$[ebp]
	imul	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _hsh$[ebp]
	add	ecx, DWORD PTR [edx+24]
	mov	DWORD PTR _entry$[ebp], ecx
$LN4@hash_add:

; 6563 : 
; 6564 :         while( entry -> next )                        /* go to the end of the list                    */

	mov	eax, DWORD PTR _entry$[ebp]
	cmp	DWORD PTR [eax+44], 0
	je	SHORT $LN3@hash_add

; 6565 :             entry = entry -> next;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR _entry$[ebp], edx
	jmp	SHORT $LN4@hash_add
$LN3@hash_add:

; 6566 : 
; 6567 : 		#ifdef USE_SH_POOLS
; 6568 :         entry -> next = (HASH_ENTRY *)MemAllocPtr( gResmgrMemPool, sizeof(HASH_ENTRY), 0 );
; 6569 : 		#else
; 6570 :         entry -> next = (HASH_ENTRY *)MemMalloc( sizeof(HASH_ENTRY), "Hash entry" );

	push	48					; 00000030H
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+44], eax

; 6571 : 		#endif
; 6572 : 
; 6573 :         if( !entry -> next ) {                        /* malloc failed                                */ 

	mov	edx, DWORD PTR _entry$[ebp]
	cmp	DWORD PTR [edx+44], 0
	jne	SHORT $LN2@hash_add

; 6574 :             SAY_ERROR( RES_ERR_NO_MEMORY, "hash_add" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	6574					; 000019aeH
	push	OFFSET ??_C@_08KMLNCKGK@hash_add?$AA@
	push	-4999					; ffffec79H
	call	__say_error
	add	esp, 16					; 00000010H

; 6575 :             return( NULL );

	xor	eax, eax
	jmp	$LN8@hash_add
$LN2@hash_add:

; 6576 :         }
; 6577 : 
; 6578 : 		memset(entry ->next, 0, sizeof(HASH_ENTRY));	// OW BC

	push	48					; 00000030H
	push	0
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 6579 : 
; 6580 :         entry = entry -> next;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR _entry$[ebp], eax

; 6581 :     }
; 6582 :     else {

	jmp	SHORT $LN1@hash_add
$LN5@hash_add:

; 6583 :         entry = &hsh -> table[ hash_val ];

	mov	ecx, DWORD PTR _hash_val$[ebp]
	imul	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _hsh$[ebp]
	add	ecx, DWORD PTR [edx+24]
	mov	DWORD PTR _entry$[ebp], ecx
$LN1@hash_add:

; 6584 :     }
; 6585 : 
; 6586 :     entry -> name = hash_strcpy( hsh, data -> name );

	mov	eax, DWORD PTR _data$[ebp]
	add	eax, 36					; 00000024H
	push	eax
	mov	ecx, DWORD PTR _hsh$[ebp]
	push	ecx
	call	_hash_strcpy
	add	esp, 8
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx], eax

; 6587 :     entry -> offset = 0;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+4], 0

; 6588 :     entry -> size = data -> size;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR _data$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR [ecx+8], eax

; 6589 :     entry -> attrib = data -> attrib | FORCE_BIT; /* FORCE_BIT ensures the field will be non-zero */

	mov	ecx, DWORD PTR _data$[ebp]
	mov	edx, DWORD PTR [ecx]
	or	edx, -2147483648			; 80000000H
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+28], edx

; 6590 :     entry -> next = NULL;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+44], 0

; 6591 :     entry -> archive = -1; // Changed on AUG30th  [KBR]

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+24], -1

; 6592 : #if( !RES_USE_FLAT_MODEL )
; 6593 :     entry -> dir = NULL;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+40], 0

; 6594 : #endif /* !RES_USE_FLAT_MODEL */
; 6595 : 
; 6596 :     hsh -> num_entries++;

	mov	ecx, DWORD PTR _hsh$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 1
	mov	eax, DWORD PTR _hsh$[ebp]
	mov	DWORD PTR [eax+4], edx

; 6597 : 
; 6598 :     return( entry );

	mov	eax, DWORD PTR _entry$[ebp]
$LN8@hash_add:

; 6599 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_hash_add ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_entry$ = -8						; size = 4
_hash_val$ = -4						; size = 4
_name$ = 8						; size = 4
_hsh$ = 12						; size = 4
_hash_find PROC

; 6775 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 6776 :     int hash_val;
; 6777 :     HASH_ENTRY * entry;
; 6778 :     
; 6779 :     if( !GLOBAL_HASH_TABLE )

	cmp	DWORD PTR _GLOBAL_HASH_TABLE, 0
	jne	SHORT $LN8@hash_find

; 6780 :         return( NULL );

	xor	eax, eax
	jmp	$LN9@hash_find
$LN8@hash_find:

; 6781 : 
; 6782 :     hash_val = hash( name, hsh -> table_size );             /* calc the hash value for the given string */

	mov	eax, DWORD PTR _hsh$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_hash
	add	esp, 8
	mov	DWORD PTR _hash_val$[ebp], eax

; 6783 : 
; 6784 :     if( !hsh -> table[ hash_val ].attrib )                  /* no hash entry found                        */

	mov	eax, DWORD PTR _hash_val$[ebp]
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _hsh$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	cmp	DWORD PTR [edx+eax+28], 0
	jne	SHORT $LN7@hash_find

; 6785 :         return( NULL );                    

	xor	eax, eax
	jmp	$LN9@hash_find
$LN7@hash_find:

; 6786 : 
; 6787 :     if( hsh -> table[ hash_val ].next == NULL )

	mov	eax, DWORD PTR _hash_val$[ebp]
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _hsh$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	cmp	DWORD PTR [edx+eax+44], 0
	jne	SHORT $LN6@hash_find

; 6788 :         if( !stricmp( hsh -> table[ hash_val ].name, name ))

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hash_val$[ebp]
	imul	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _hsh$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR [eax+ecx]
	push	ecx
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN6@hash_find

; 6789 :             return( &hsh -> table[ hash_val ] );            /* just one entry found in the hash position */

	mov	eax, DWORD PTR _hash_val$[ebp]
	imul	eax, 48					; 00000030H
	mov	edx, DWORD PTR _hsh$[ebp]
	add	eax, DWORD PTR [edx+24]
	jmp	SHORT $LN9@hash_find
$LN6@hash_find:

; 6790 : 
; 6791 :                                                             /* found imperfect hash entry                    */
; 6792 :     for( entry = &hsh -> table[ hash_val ]; entry; entry = entry -> next )

	mov	eax, DWORD PTR _hash_val$[ebp]
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _hsh$[ebp]
	add	eax, DWORD PTR [ecx+24]
	mov	DWORD PTR _entry$[ebp], eax
	jmp	SHORT $LN4@hash_find
$LN3@hash_find:
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR _entry$[ebp], eax
$LN4@hash_find:
	cmp	DWORD PTR _entry$[ebp], 0
	je	SHORT $LN2@hash_find

; 6793 :         if( !stricmp( entry -> name, name ))

	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN1@hash_find

; 6794 :             return( entry );                                /* assumes only one occurrence of a given name    */

	mov	eax, DWORD PTR _entry$[ebp]
	jmp	SHORT $LN9@hash_find
$LN1@hash_find:

; 6795 : 
; 6796 :     return( NULL );                                         /* not found                                    */

	jmp	SHORT $LN3@hash_find
$LN2@hash_find:
	xor	eax, eax
$LN9@hash_find:

; 6797 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_hash_find ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_sizeb$ = -12						; size = 4
_string_space$ = -8					; size = 4
_hsh$ = -4						; size = 4
_size$ = 8						; size = 4
_name$ = 12						; size = 4
_hash_create PROC

; 6348 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 6349 :     HASH_TABLE * hsh;
; 6350 :     char * string_space;
; 6351 :     int    sizeb;
; 6352 : 
; 6353 : 	#ifdef USE_SH_POOLS
; 6354 :     hsh = (HASH_TABLE *)MemAllocPtr( gResmgrMemPool, sizeof(HASH_TABLE), 0 );
; 6355 : 	#else
; 6356 :     hsh = (HASH_TABLE *)MemMalloc( sizeof(HASH_TABLE), "Hash wrapper" );

	push	28					; 0000001cH
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _hsh$[ebp], eax

; 6357 : 	#endif
; 6358 : 
; 6359 :     if( !hsh ) {

	cmp	DWORD PTR _hsh$[ebp], 0
	jne	SHORT $LN3@hash_creat

; 6360 :         SAY_ERROR( RES_ERR_NO_MEMORY, "hash_create" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	6360					; 000018d8H
	push	OFFSET ??_C@_0M@CIGDFLFE@hash_create?$AA@
	push	-4999					; ffffec79H
	call	__say_error
	add	esp, 16					; 00000010H

; 6361 :         return( NULL );

	xor	eax, eax
	jmp	$LN4@hash_creat
$LN3@hash_creat:

; 6362 :     }
; 6363 :     
; 6364 : 	#ifdef USE_SH_POOLS
; 6365 :     hsh -> table = (HASH_ENTRY *)MemAllocPtr( gResmgrMemPool, size * sizeof(HASH_ENTRY), 0 );
; 6366 : 	#else
; 6367 :     hsh -> table = (HASH_ENTRY *)MemMalloc( size * sizeof(HASH_ENTRY), name );

	mov	eax, DWORD PTR _size$[ebp]
	imul	eax, 48					; 00000030H
	push	eax
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _hsh$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 6368 : 	#endif
; 6369 : 
; 6370 :     if( !hsh -> table ) {

	mov	edx, DWORD PTR _hsh$[ebp]
	cmp	DWORD PTR [edx+24], 0
	jne	SHORT $LN2@hash_creat

; 6371 :         SAY_ERROR( RES_ERR_NO_MEMORY, "hash_create" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	6371					; 000018e3H
	push	OFFSET ??_C@_0M@CIGDFLFE@hash_create?$AA@
	push	-4999					; ffffec79H
	call	__say_error
	add	esp, 16					; 00000010H

; 6372 :         return( NULL );

	xor	eax, eax
	jmp	$LN4@hash_creat
$LN2@hash_creat:

; 6373 :     }
; 6374 :     memset( hsh -> table, 0, size * sizeof(HASH_ENTRY));

	mov	eax, DWORD PTR _size$[ebp]
	imul	eax, 48					; 00000030H
	push	eax
	push	0
	mov	ecx, DWORD PTR _hsh$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 6375 : 
; 6376 :     sizeb = size * MAX_FILENAME;

	mov	eax, DWORD PTR _size$[ebp]
	imul	eax, 60					; 0000003cH
	mov	DWORD PTR _sizeb$[ebp], eax

; 6377 : 
; 6378 : 	#ifdef USE_SH_POOLS
; 6379 :     string_space = (char *)MemAllocPtr( gResmgrMemPool, sizeb, 0 );
; 6380 : 	#else
; 6381 :     string_space = (char *)MemMalloc( sizeb, "Strings" );

	mov	ecx, DWORD PTR _sizeb$[ebp]
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _string_space$[ebp], eax

; 6382 : 	#endif
; 6383 : 
; 6384 :     if( !string_space ) {

	cmp	DWORD PTR _string_space$[ebp], 0
	jne	SHORT $LN1@hash_creat

; 6385 :         SAY_ERROR( RES_ERR_NO_MEMORY, "hash_create" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	6385					; 000018f1H
	push	OFFSET ??_C@_0M@CIGDFLFE@hash_create?$AA@
	push	-4999					; ffffec79H
	call	__say_error
	add	esp, 16					; 00000010H

; 6386 :         return( NULL );

	xor	eax, eax
	jmp	SHORT $LN4@hash_creat
$LN1@hash_creat:

; 6387 :     }
; 6388 : 
; 6389 :     hsh -> table_size = size;

	mov	edx, DWORD PTR _hsh$[ebp]
	mov	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR [edx], eax

; 6390 :     hsh -> num_entries = 0;

	mov	ecx, DWORD PTR _hsh$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 6391 :     hsh -> ptr_in = string_space;

	mov	edx, DWORD PTR _hsh$[ebp]
	mov	eax, DWORD PTR _string_space$[ebp]
	mov	DWORD PTR [edx+12], eax

; 6392 : 
; 6393 :     size = (int)(STRING_SAFETY_SIZE * (float)sizeb); /* safety buffer on string pool */

	cvtsi2ss xmm0, DWORD PTR _sizeb$[ebp]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3feb333333333333
	cvttsd2si ecx, xmm0
	mov	DWORD PTR _size$[ebp], ecx

; 6394 :     hsh -> ptr_end = string_space + size;

	mov	edx, DWORD PTR _string_space$[ebp]
	add	edx, DWORD PTR _size$[ebp]
	mov	eax, DWORD PTR _hsh$[ebp]
	mov	DWORD PTR [eax+16], edx

; 6395 :     hsh -> str_list = NULL;

	mov	ecx, DWORD PTR _hsh$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 6396 :     hsh -> str_list = LIST_APPEND( hsh->str_list, string_space );

	mov	edx, DWORD PTR _string_space$[ebp]
	push	edx
	mov	eax, DWORD PTR _hsh$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	_ListAppend
	add	esp, 8
	mov	edx, DWORD PTR _hsh$[ebp]
	mov	DWORD PTR [edx+20], eax

; 6397 : 
; 6398 :     hsh -> name = hash_strcpy( hsh, name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hsh$[ebp]
	push	ecx
	call	_hash_strcpy
	add	esp, 8
	mov	edx, DWORD PTR _hsh$[ebp]
	mov	DWORD PTR [edx+8], eax

; 6399 : 
; 6400 :     return( hsh );

	mov	eax, DWORD PTR _hsh$[ebp]
$LN4@hash_creat:

; 6401 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_hash_create ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_index$ = -16						; size = 4
_curr$ = -12						; size = 4
_prev$ = -8						; size = 4
_entry$ = -4						; size = 4
_hsh$ = 8						; size = 4
_archive$ = 12						; size = 4
_volume$ = 16						; size = 4
_directory$ = 20					; size = 4
_filename$ = 24						; size = 4
_hash_purge PROC

; 6896 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 6897 :     int index;
; 6898 : 
; 6899 :     HASH_ENTRY * entry,
; 6900 :                * prev,
; 6901 :                * curr;
; 6902 : 
; 6903 :     if( archive ) {
; 6904 :         IF_LOG( LOG( "purging entries from archive %d\n", *archive ));
; 6905 :     }
; 6906 : 
; 6907 :     if( volume ) {
; 6908 :         IF_LOG( LOG( "purging entries from volume %d\n", *volume ));
; 6909 :     }
; 6910 : 
; 6911 :     if( directory ) {
; 6912 :         IF_LOG( LOG( "purging entries from directory %d\n", *directory ));
; 6913 :     }
; 6914 : 
; 6915 :     if( filename ) {
; 6916 :         IF_LOG( LOG( "purging entries named %s\n", filename ));
; 6917 :     }
; 6918 : 
; 6919 :     for( index = 0; index < hsh -> table_size; index++ ) {

	mov	DWORD PTR _index$[ebp], 0
	jmp	SHORT $LN24@hash_purge
$LN23@hash_purge:
	mov	eax, DWORD PTR _index$[ebp]
	add	eax, 1
	mov	DWORD PTR _index$[ebp], eax
$LN24@hash_purge:
	mov	ecx, DWORD PTR _hsh$[ebp]
	mov	edx, DWORD PTR _index$[ebp]
	cmp	edx, DWORD PTR [ecx]
	jge	$LN29@hash_purge

; 6920 :         entry = &hsh -> table[ index ];

	mov	eax, DWORD PTR _index$[ebp]
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _hsh$[ebp]
	add	eax, DWORD PTR [ecx+24]
	mov	DWORD PTR _entry$[ebp], eax

; 6921 : 
; 6922 :         if( !entry -> attrib )

	mov	edx, DWORD PTR _entry$[ebp]
	cmp	DWORD PTR [edx+28], 0
	jne	SHORT $LN21@hash_purge

; 6923 :             continue; /* empty hash entry */

	jmp	SHORT $LN23@hash_purge
$LN21@hash_purge:

; 6924 :             
; 6925 :         if( entry -> next ) {

	mov	eax, DWORD PTR _entry$[ebp]
	cmp	DWORD PTR [eax+44], 0
	je	$LN20@hash_purge

; 6926 :             prev = entry;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR _prev$[ebp], ecx

; 6927 :             curr = entry -> next;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR _curr$[ebp], eax
$LN19@hash_purge:

; 6928 : 
; 6929 :             while( curr ) {

	cmp	DWORD PTR _curr$[ebp], 0
	je	$LN20@hash_purge

; 6930 :                 if( (volume && (curr -> volume == *volume)) ||
; 6931 :                     (archive && (curr -> archive == *archive)) ||
; 6932 :                     (directory && (curr -> directory == *directory)) ||
; 6933 :                     (filename && !strcmp(entry -> name, filename)) )

	cmp	DWORD PTR _volume$[ebp], 0
	je	SHORT $LN15@hash_purge
	mov	ecx, DWORD PTR _curr$[ebp]
	movsx	edx, BYTE PTR [ecx+36]
	mov	eax, DWORD PTR _volume$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	je	SHORT $LN16@hash_purge
$LN15@hash_purge:
	cmp	DWORD PTR _archive$[ebp], 0
	je	SHORT $LN14@hash_purge
	mov	edx, DWORD PTR _archive$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _curr$[ebp]
	cmp	DWORD PTR [ecx+24], eax
	je	SHORT $LN16@hash_purge
$LN14@hash_purge:
	cmp	DWORD PTR _directory$[ebp], 0
	je	SHORT $LN13@hash_purge
	mov	edx, DWORD PTR _curr$[ebp]
	mov	eax, DWORD PTR _directory$[ebp]
	mov	ecx, DWORD PTR [edx+32]
	cmp	ecx, DWORD PTR [eax]
	je	SHORT $LN16@hash_purge
$LN13@hash_purge:
	cmp	DWORD PTR _filename$[ebp], 0
	je	SHORT $LN17@hash_purge
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN17@hash_purge
$LN16@hash_purge:

; 6934 :                 {
; 6935 :                     if( curr -> dir )

	mov	edx, DWORD PTR _curr$[ebp]
	cmp	DWORD PTR [edx+40], 0
	je	SHORT $LN12@hash_purge

; 6936 :                         hash_destroy((HASH_TABLE*)prev -> dir );

	mov	eax, DWORD PTR _prev$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	call	_hash_destroy
	add	esp, 4
$LN12@hash_purge:

; 6937 :                
; 6938 :                     prev -> next = curr -> next;

	mov	edx, DWORD PTR _prev$[ebp]
	mov	eax, DWORD PTR _curr$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR [edx+44], ecx

; 6939 : 
; 6940 : 					#ifdef USE_SH_POOLS
; 6941 : 					MemFreePtr( curr );
; 6942 : 					#else
; 6943 : 					MemFree( curr );

	mov	edx, DWORD PTR _curr$[ebp]
	push	edx
	call	_free
	add	esp, 4

; 6944 : 					#endif
; 6945 :                 }
; 6946 :                 else

	jmp	SHORT $LN11@hash_purge
$LN17@hash_purge:

; 6947 :                     prev = curr;

	mov	eax, DWORD PTR _curr$[ebp]
	mov	DWORD PTR _prev$[ebp], eax
$LN11@hash_purge:

; 6948 : 
; 6949 :                 curr = prev -> next;

	mov	ecx, DWORD PTR _prev$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR _curr$[ebp], edx

; 6950 :             }

	jmp	$LN19@hash_purge
$LN20@hash_purge:

; 6951 :         }
; 6952 :             
; 6953 :         if( (volume && (entry -> volume == *volume)) ||
; 6954 :             (archive && (entry -> archive == *archive)) ||
; 6955 :             (directory && (entry -> directory == *directory)) ||
; 6956 :             (filename && !strcmp(entry -> name, filename)) )

	cmp	DWORD PTR _volume$[ebp], 0
	je	SHORT $LN8@hash_purge
	mov	eax, DWORD PTR _entry$[ebp]
	movsx	ecx, BYTE PTR [eax+36]
	mov	edx, DWORD PTR _volume$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	je	SHORT $LN9@hash_purge
$LN8@hash_purge:
	cmp	DWORD PTR _archive$[ebp], 0
	je	SHORT $LN7@hash_purge
	mov	ecx, DWORD PTR _archive$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _entry$[ebp]
	cmp	DWORD PTR [eax+24], edx
	je	SHORT $LN9@hash_purge
$LN7@hash_purge:
	cmp	DWORD PTR _directory$[ebp], 0
	je	SHORT $LN6@hash_purge
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR _directory$[ebp]
	mov	eax, DWORD PTR [ecx+32]
	cmp	eax, DWORD PTR [edx]
	je	SHORT $LN9@hash_purge
$LN6@hash_purge:
	cmp	DWORD PTR _filename$[ebp], 0
	je	$LN10@hash_purge
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	$LN10@hash_purge
$LN9@hash_purge:

; 6957 :         {
; 6958 :             if( entry -> dir ) {

	mov	ecx, DWORD PTR _entry$[ebp]
	cmp	DWORD PTR [ecx+40], 0
	je	SHORT $LN5@hash_purge

; 6959 :                 hash_destroy((HASH_TABLE *)entry -> dir);

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+40]
	push	eax
	call	_hash_destroy
	add	esp, 4

; 6960 :                 entry -> dir = NULL;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+40], 0
$LN5@hash_purge:

; 6961 :             }
; 6962 : 
; 6963 :             if( entry -> next ) {

	mov	edx, DWORD PTR _entry$[ebp]
	cmp	DWORD PTR [edx+44], 0
	je	SHORT $LN4@hash_purge

; 6964 :                 prev = entry -> next;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _prev$[ebp], ecx

; 6965 : 
; 6966 :                 memcpy( entry, prev, sizeof(HASH_ENTRY));

	push	48					; 00000030H
	mov	edx, DWORD PTR _prev$[ebp]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 6967 : 
; 6968 :                 if( prev -> dir )

	mov	ecx, DWORD PTR _prev$[ebp]
	cmp	DWORD PTR [ecx+40], 0
	je	SHORT $LN3@hash_purge

; 6969 :                    hash_destroy((HASH_TABLE *)prev -> dir ); // navio: (408)328-0630

	mov	edx, DWORD PTR _prev$[ebp]
	mov	eax, DWORD PTR [edx+40]
	push	eax
	call	_hash_destroy
	add	esp, 4
$LN3@hash_purge:

; 6970 : 
; 6971 :                 entry -> next = prev -> next;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR _prev$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR [ecx+44], eax

; 6972 : 
; 6973 : 				#ifdef USE_SH_POOLS
; 6974 : 				MemFreePtr( prev );
; 6975 : 				#else
; 6976 : 				MemFree( prev );

	mov	ecx, DWORD PTR _prev$[ebp]
	push	ecx
	call	_free
	add	esp, 4

; 6977 : 				#endif
; 6978 :             }
; 6979 :             else {

	jmp	SHORT $LN10@hash_purge
$LN4@hash_purge:

; 6980 :                 entry -> attrib = 0;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+28], 0

; 6981 : 
; 6982 :                 if( entry -> dir ) {

	mov	eax, DWORD PTR _entry$[ebp]
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $LN10@hash_purge

; 6983 :                     hash_destroy((HASH_TABLE *) entry -> dir );

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	call	_hash_destroy
	add	esp, 4

; 6984 :                     entry -> dir = NULL;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+40], 0
$LN10@hash_purge:

; 6985 :                 }
; 6986 :             }
; 6987 :         }
; 6988 :     }

	jmp	$LN23@hash_purge
$LN29@hash_purge:

; 6989 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_hash_purge ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_entry$ = -16						; size = 4
_prev$ = -12						; size = 4
_curr$ = -8						; size = 4
_index$ = -4						; size = 4
_hsh$ = 8						; size = 4
_hash_destroy PROC

; 6418 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 6419 :     int index;
; 6420 :     HASH_ENTRY * entry,
; 6421 :                * prev,
; 6422 :                * curr;
; 6423 : 
; 6424 :     for( index=0; index < hsh -> table_size; index++ ) {

	mov	DWORD PTR _index$[ebp], 0
	jmp	SHORT $LN6@hash_destr
$LN5@hash_destr:
	mov	eax, DWORD PTR _index$[ebp]
	add	eax, 1
	mov	DWORD PTR _index$[ebp], eax
$LN6@hash_destr:
	mov	ecx, DWORD PTR _hsh$[ebp]
	mov	edx, DWORD PTR _index$[ebp]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN4@hash_destr

; 6425 :         entry = &hsh -> table[index];

	mov	eax, DWORD PTR _index$[ebp]
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _hsh$[ebp]
	add	eax, DWORD PTR [ecx+24]
	mov	DWORD PTR _entry$[ebp], eax

; 6426 : 
; 6427 :         entry -> attrib = 0;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+28], 0

; 6428 : 
; 6429 :         if( !entry -> next )

	mov	eax, DWORD PTR _entry$[ebp]
	cmp	DWORD PTR [eax+44], 0
	jne	SHORT $LN3@hash_destr

; 6430 :             continue;

	jmp	SHORT $LN5@hash_destr
$LN3@hash_destr:

; 6431 : 
; 6432 :         prev = entry -> next;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR _prev$[ebp], edx

; 6433 :         curr = prev -> next;

	mov	eax, DWORD PTR _prev$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _curr$[ebp], ecx
$LN2@hash_destr:

; 6434 : 
; 6435 :         while( curr ) {

	cmp	DWORD PTR _curr$[ebp], 0
	je	SHORT $LN1@hash_destr

; 6436 : 			#ifdef USE_SH_POOLS
; 6437 : 			MemFreePtr( prev );
; 6438 : 			#else
; 6439 : 			MemFree( prev );

	mov	edx, DWORD PTR _prev$[ebp]
	push	edx
	call	_free
	add	esp, 4

; 6440 : 			#endif
; 6441 : 
; 6442 :             prev = curr;

	mov	eax, DWORD PTR _curr$[ebp]
	mov	DWORD PTR _prev$[ebp], eax

; 6443 :             curr = curr -> next;

	mov	ecx, DWORD PTR _curr$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR _curr$[ebp], edx

; 6444 :         }

	jmp	SHORT $LN2@hash_destr
$LN1@hash_destr:

; 6445 : 
; 6446 : 		#ifdef USE_SH_POOLS
; 6447 : 		MemFreePtr( prev );
; 6448 : 		#else
; 6449 : 		MemFree( prev );

	mov	eax, DWORD PTR _prev$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 6450 : 		#endif
; 6451 :     }

	jmp	SHORT $LN5@hash_destr
$LN4@hash_destr:

; 6452 : 
; 6453 : #if( RES_DEBUG_VERSION )
; 6454 :     hsh -> num_entries = 0;

	mov	ecx, DWORD PTR _hsh$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 6455 :     hsh -> table_size = 0;

	mov	edx, DWORD PTR _hsh$[ebp]
	mov	DWORD PTR [edx], 0

; 6456 : #endif
; 6457 : 
; 6458 : 	#ifdef USE_SH_POOLS
; 6459 :     LIST_DESTROY(hsh->str_list, free);
; 6460 : 	#else
; 6461 :     LIST_DESTROY(hsh->str_list, MemFreePtr);

	push	OFFSET _free
	mov	eax, DWORD PTR _hsh$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	_ListDestroy
	add	esp, 8

; 6462 : 	#endif
; 6463 : 
; 6464 : 	#ifdef USE_SH_POOLS
; 6465 :     MemFreePtr( hsh -> table );
; 6466 :     MemFreePtr( hsh );
; 6467 : 	#else
; 6468 :     MemFree( hsh -> table );

	mov	edx, DWORD PTR _hsh$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	_free
	add	esp, 4

; 6469 :     MemFree( hsh );

	mov	ecx, DWORD PTR _hsh$[ebp]
	push	ecx
	call	_free
	add	esp, 4

; 6470 : 	#endif
; 6471 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_hash_destroy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_prev$ = -12						; size = 4
_i$ = -8						; size = 4
_entry$ = -4						; size = 4
_hash_entry$ = 8					; size = 4
_hsh$ = 12						; size = 4
_hash_delete PROC

; 6815 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 6816 :     int i;
; 6817 :     
; 6818 :     HASH_ENTRY * entry,
; 6819 :                * prev;
; 6820 : 
; 6821 :     if( hash_entry -> dir )

	mov	eax, DWORD PTR _hash_entry$[ebp]
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $LN11@hash_delet

; 6822 :         hash_destroy((HASH_TABLE *)hash_entry -> dir );

	mov	ecx, DWORD PTR _hash_entry$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	call	_hash_destroy
	add	esp, 4
$LN11@hash_delet:

; 6823 : 
; 6824 :     for( i=0; i<hsh -> table_size; i++ ) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN10@hash_delet
$LN9@hash_delet:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN10@hash_delet:
	mov	ecx, DWORD PTR _hsh$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx]
	jge	$LN8@hash_delet

; 6825 :         entry = &hsh -> table[i];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _hsh$[ebp]
	add	eax, DWORD PTR [ecx+24]
	mov	DWORD PTR _entry$[ebp], eax

; 6826 : 
; 6827 :         if( entry == hash_entry ) {

	mov	edx, DWORD PTR _entry$[ebp]
	cmp	edx, DWORD PTR _hash_entry$[ebp]
	jne	SHORT $LN7@hash_delet

; 6828 :             if( hash_entry -> next ) {              /* pop the chain of hash collisions */

	mov	eax, DWORD PTR _hash_entry$[ebp]
	cmp	DWORD PTR [eax+44], 0
	je	SHORT $LN6@hash_delet

; 6829 :                 entry = hash_entry -> next;

	mov	ecx, DWORD PTR _hash_entry$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR _entry$[ebp], edx

; 6830 : 
; 6831 :                 memcpy( hash_entry, entry, sizeof( HASH_ENTRY ));

	push	48					; 00000030H
	mov	eax, DWORD PTR _entry$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hash_entry$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 6832 : 
; 6833 : 				#ifdef USE_SH_POOLS
; 6834 :                 MemFreePtr( entry );
; 6835 : 				#else
; 6836 :                 MemFree( entry );

	mov	edx, DWORD PTR _entry$[ebp]
	push	edx
	call	_free
	add	esp, 4

; 6837 : 				#endif
; 6838 :                 hsh -> num_entries--;

	mov	eax, DWORD PTR _hsh$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	mov	edx, DWORD PTR _hsh$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 6839 :             }
; 6840 :             else

	jmp	SHORT $LN5@hash_delet
$LN6@hash_delet:

; 6841 :             {
; 6842 :                 entry -> attrib = 0;                /* no chain to pop.  just flag this entry as being empty */

	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+28], 0

; 6843 :                 hsh -> num_entries--;

	mov	ecx, DWORD PTR _hsh$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, 1
	mov	eax, DWORD PTR _hsh$[ebp]
	mov	DWORD PTR [eax+4], edx
$LN5@hash_delet:

; 6844 :             }
; 6845 : 
; 6846 :             return( TRUE );

	mov	eax, 1
	jmp	SHORT $LN12@hash_delet
$LN7@hash_delet:

; 6847 :         }
; 6848 : 
; 6849 :         if( entry -> next ) {                       /* look for hash entry on a chain */

	mov	ecx, DWORD PTR _entry$[ebp]
	cmp	DWORD PTR [ecx+44], 0
	je	SHORT $LN4@hash_delet

; 6850 :             prev = entry;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR _prev$[ebp], edx

; 6851 :             entry = entry -> next;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _entry$[ebp], ecx
$LN3@hash_delet:

; 6852 : 
; 6853 :             while( entry ) {

	cmp	DWORD PTR _entry$[ebp], 0
	je	SHORT $LN4@hash_delet

; 6854 :                 if( entry == hash_entry ) {

	mov	edx, DWORD PTR _entry$[ebp]
	cmp	edx, DWORD PTR _hash_entry$[ebp]
	jne	SHORT $LN1@hash_delet

; 6855 :                     prev -> next = entry -> next;   /* cut from chain */

	mov	eax, DWORD PTR _prev$[ebp]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR [eax+44], edx

; 6856 : 
; 6857 : 					#ifdef USE_SH_POOLS
; 6858 : 					MemFreePtr( entry );
; 6859 : 					#else
; 6860 : 					MemFree( entry );

	mov	eax, DWORD PTR _entry$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 6861 : 					#endif
; 6862 :                     hsh -> num_entries--;

	mov	ecx, DWORD PTR _hsh$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, 1
	mov	eax, DWORD PTR _hsh$[ebp]
	mov	DWORD PTR [eax+4], edx

; 6863 : 
; 6864 :                     return( TRUE );

	mov	eax, 1
	jmp	SHORT $LN12@hash_delet
$LN1@hash_delet:

; 6865 :                 }
; 6866 : 
; 6867 :                 prev = entry;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR _prev$[ebp], ecx

; 6868 :                 entry = entry -> next;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR _entry$[ebp], eax

; 6869 :             }

	jmp	SHORT $LN3@hash_delet
$LN4@hash_delet:

; 6870 :         }
; 6871 :     }    

	jmp	$LN9@hash_delet
$LN8@hash_delet:

; 6872 : 
; 6873 :     return( FALSE );

	xor	eax, eax
$LN12@hash_delet:

; 6874 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_hash_delete ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_val$ = -28						; size = 4
_entry$ = -24						; size = 4
_size$ = -20						; size = 4
_prev$ = -16						; size = 4
_dst$ = -12						; size = 4
_i$ = -8						; size = 4
_src$ = -4						; size = 4
_hsh$ = 8						; size = 4
_hash_resize PROC

; 6665 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 6666 :     int size;
; 6667 :     int i, val;
; 6668 : 
; 6669 :     HASH_ENTRY * entry;
; 6670 :     HASH_ENTRY * src,
; 6671 :                * dst,
; 6672 :                * prev;
; 6673 : 
; 6674 :     IF_LOG( LOG( "resizing hash table %s\n", hsh -> name ));
; 6675 : 
; 6676 :     /* calc the size of the new hash table  */
; 6677 :     size = (int)((float)hsh -> num_entries * HASH_OPTIMAL_RATIO);

	mov	eax, DWORD PTR _hsh$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+4]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3ff2666666666666
	cvttsd2si ecx, xmm0
	mov	DWORD PTR _size$[ebp], ecx

; 6678 : 
; 6679 :     /* create the new hash entries          */
; 6680 : 
; 6681 : 	#ifdef USE_SH_POOLS
; 6682 :     entry = (HASH_ENTRY *)MemAllocPtr( gResmgrMemPool, size * sizeof( HASH_ENTRY ), 0 );
; 6683 : 	#else
; 6684 :     entry = (HASH_ENTRY *)MemMalloc( size * sizeof( HASH_ENTRY ), "Hash resized" );

	mov	edx, DWORD PTR _size$[ebp]
	imul	edx, 48					; 00000030H
	push	edx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _entry$[ebp], eax

; 6685 : 	#endif
; 6686 : 
; 6687 :     if( !entry ) {

	cmp	DWORD PTR _entry$[ebp], 0
	jne	SHORT $LN15@hash_resiz

; 6688 :         SAY_ERROR( RES_ERR_NO_MEMORY, "hash_resize" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	6688					; 00001a20H
	push	OFFSET ??_C@_0M@NHJDJJMK@hash_resize?$AA@
	push	-4999					; ffffec79H
	call	__say_error
	add	esp, 16					; 00000010H

; 6689 :         return( FALSE );

	xor	eax, eax
	jmp	$LN16@hash_resiz
$LN15@hash_resiz:

; 6690 :     }
; 6691 : 
; 6692 :     memset( entry, 0, size * sizeof(HASH_ENTRY));

	mov	eax, DWORD PTR _size$[ebp]
	imul	eax, 48					; 00000030H
	push	eax
	push	0
	mov	ecx, DWORD PTR _entry$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 6693 : 
; 6694 :     /* we have to rehash ALL of the entries in the old table into the new table */
; 6695 : 
; 6696 :     for( i=0; i<hsh -> table_size; i++ ) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN14@hash_resiz
$LN13@hash_resiz:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN14@hash_resiz:
	mov	eax, DWORD PTR _hsh$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	$LN12@hash_resiz

; 6697 :         src = &hsh -> table[i];

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 48					; 00000030H
	mov	eax, DWORD PTR _hsh$[ebp]
	add	edx, DWORD PTR [eax+24]
	mov	DWORD PTR _src$[ebp], edx

; 6698 : 
; 6699 :         if( src -> attrib ) {

	mov	ecx, DWORD PTR _src$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	je	SHORT $LN11@hash_resiz

; 6700 :             val = hash( src -> name, size );

	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_hash
	add	esp, 8
	mov	DWORD PTR _val$[ebp], eax

; 6701 :             dst = &entry[ val ];

	mov	edx, DWORD PTR _val$[ebp]
	imul	edx, 48					; 00000030H
	add	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR _dst$[ebp], edx

; 6702 :             hash_copy( dst, src );

	mov	eax, DWORD PTR _src$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dst$[ebp]
	push	ecx
	call	_hash_copy
	add	esp, 8
$LN11@hash_resiz:

; 6703 :         }
; 6704 : 
; 6705 :         if( src -> next ) {

	mov	edx, DWORD PTR _src$[ebp]
	cmp	DWORD PTR [edx+44], 0
	je	SHORT $LN7@hash_resiz

; 6706 :             for( src = src -> next; src; src = src -> next ) {

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _src$[ebp], ecx
	jmp	SHORT $LN9@hash_resiz
$LN8@hash_resiz:
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR _src$[ebp], eax
$LN9@hash_resiz:
	cmp	DWORD PTR _src$[ebp], 0
	je	SHORT $LN7@hash_resiz

; 6707 :                 val = hash( src -> name, size );

	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_hash
	add	esp, 8
	mov	DWORD PTR _val$[ebp], eax

; 6708 :                 dst = &entry[ val ];

	mov	ecx, DWORD PTR _val$[ebp]
	imul	ecx, 48					; 00000030H
	add	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR _dst$[ebp], ecx

; 6709 :                 hash_copy( dst, src );

	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	mov	eax, DWORD PTR _dst$[ebp]
	push	eax
	call	_hash_copy
	add	esp, 8

; 6710 :             }        

	jmp	SHORT $LN8@hash_resiz
$LN7@hash_resiz:

; 6711 :         }
; 6712 :     }

	jmp	$LN13@hash_resiz
$LN12@hash_resiz:

; 6713 : 
; 6714 :     for( i=0; i<hsh -> table_size; i++ ) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@hash_resiz
$LN5@hash_resiz:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN6@hash_resiz:
	mov	edx, DWORD PTR _hsh$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx]
	jge	SHORT $LN4@hash_resiz

; 6715 :         src = &hsh -> table[i];

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _hsh$[ebp]
	add	ecx, DWORD PTR [edx+24]
	mov	DWORD PTR _src$[ebp], ecx

; 6716 : 
; 6717 :         src -> attrib = 0;

	mov	eax, DWORD PTR _src$[ebp]
	mov	DWORD PTR [eax+28], 0

; 6718 : 
; 6719 :         if( !src -> next )

	mov	ecx, DWORD PTR _src$[ebp]
	cmp	DWORD PTR [ecx+44], 0
	jne	SHORT $LN3@hash_resiz

; 6720 :             continue;

	jmp	SHORT $LN5@hash_resiz
$LN3@hash_resiz:

; 6721 : 
; 6722 :         prev = src -> next;

	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR _prev$[ebp], eax

; 6723 :         dst = prev -> next;

	mov	ecx, DWORD PTR _prev$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR _dst$[ebp], edx
$LN2@hash_resiz:

; 6724 : 
; 6725 :         while( dst ) {

	cmp	DWORD PTR _dst$[ebp], 0
	je	SHORT $LN1@hash_resiz

; 6726 :             prev -> next = NULL;

	mov	eax, DWORD PTR _prev$[ebp]
	mov	DWORD PTR [eax+44], 0

; 6727 : 
; 6728 : 			#ifdef USE_SH_POOLS
; 6729 : 			MemFreePtr( prev );
; 6730 : 			#else
; 6731 : 			MemFree( prev );

	mov	ecx, DWORD PTR _prev$[ebp]
	push	ecx
	call	_free
	add	esp, 4

; 6732 : 			#endif
; 6733 : 
; 6734 :             prev = dst;

	mov	edx, DWORD PTR _dst$[ebp]
	mov	DWORD PTR _prev$[ebp], edx

; 6735 :             dst = dst -> next;

	mov	eax, DWORD PTR _dst$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _dst$[ebp], ecx

; 6736 :         }

	jmp	SHORT $LN2@hash_resiz
$LN1@hash_resiz:

; 6737 : 
; 6738 : 		#ifdef USE_SH_POOLS
; 6739 : 		MemFreePtr( prev );
; 6740 : 		#else
; 6741 : 		MemFree( prev );

	mov	edx, DWORD PTR _prev$[ebp]
	push	edx
	call	_free
	add	esp, 4

; 6742 : 		#endif
; 6743 : 
; 6744 :         src -> next = NULL;

	mov	eax, DWORD PTR _src$[ebp]
	mov	DWORD PTR [eax+44], 0

; 6745 :     }

	jmp	$LN5@hash_resiz
$LN4@hash_resiz:

; 6746 : 
; 6747 : 	#ifdef USE_SH_POOLS
; 6748 : 	MemFreePtr( hsh->table );
; 6749 : 	#else
; 6750 : 	MemFree( hsh->table );

	mov	ecx, DWORD PTR _hsh$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	_free
	add	esp, 4

; 6751 : 	#endif
; 6752 : 
; 6753 :     hsh -> table_size = size;

	mov	eax, DWORD PTR _hsh$[ebp]
	mov	ecx, DWORD PTR _size$[ebp]
	mov	DWORD PTR [eax], ecx

; 6754 :     hsh -> table = entry;

	mov	edx, DWORD PTR _hsh$[ebp]
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+24], eax

; 6755 : 
; 6756 :     return( TRUE );

	mov	eax, 1
$LN16@hash_resiz:

; 6757 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_hash_resize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_i$ = -12						; size = 4
_res$ = -8						; size = 4
_pos$ = -4						; size = 4
_string$ = 8						; size = 4
_size$ = 12						; size = 4
_hash	PROC

; 6300 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 6301 :     int i;
; 6302 : 
; 6303 : #if( USE_SEDGEWICK )
; 6304 :     for( i = 0; *string != '\0'; string++ )
; 6305 :         i = (HASH_CONST * i + (toupper(*string))) % size;
; 6306 : #   error   DO NOT USE SEDGEWICK - RH
; 6307 : #endif
; 6308 : 
; 6309 : #if( USE_AFU )
; 6310 :     int  res = 0;

	mov	DWORD PTR _res$[ebp], 0

; 6311 :     int  pos = 1;

	mov	DWORD PTR _pos$[ebp], 1
$LN2@hash:

; 6312 : 
; 6313 :     while( *string ) {

	mov	eax, DWORD PTR _string$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN1@hash

; 6314 :       res += toupper(*string) * pos;

	mov	edx, DWORD PTR _string$[ebp]
	movsx	eax, BYTE PTR [edx]
	push	eax
	call	_toupper
	add	esp, 4
	imul	eax, DWORD PTR _pos$[ebp]
	add	eax, DWORD PTR _res$[ebp]
	mov	DWORD PTR _res$[ebp], eax

; 6315 : 
; 6316 :       pos++;

	mov	ecx, DWORD PTR _pos$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pos$[ebp], ecx

; 6317 :       string++;

	mov	edx, DWORD PTR _string$[ebp]
	add	edx, 1
	mov	DWORD PTR _string$[ebp], edx

; 6318 :     }

	jmp	SHORT $LN2@hash
$LN1@hash:

; 6319 : 
; 6320 :     i = ( res & 0xffffff ) % size;

	mov	eax, DWORD PTR _res$[ebp]
	and	eax, 16777215				; 00ffffffH
	cdq
	idiv	DWORD PTR _size$[ebp]
	mov	DWORD PTR _i$[ebp], edx

; 6321 : #endif
; 6322 : 
; 6323 :     return(i);

	mov	eax, DWORD PTR _i$[ebp]

; 6324 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_hash	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_data$ = -4						; size = 4
_thread_data$ = 8					; size = 4
_asynch_read PROC

; 5979 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 5980 :    ASYNCH_DATA * data;
; 5981 : 
; 5982 :    data = (ASYNCH_DATA *)thread_data;

	mov	eax, DWORD PTR _thread_data$[ebp]
	mov	DWORD PTR _data$[ebp], eax

; 5983 : 
; 5984 :    _read( data->file, data->buffer, data->size );

	mov	ecx, DWORD PTR _data$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _data$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	__read
	add	esp, 12					; 0000000cH

; 5985 : 
; 5986 :    if( data->callback )

	mov	ecx, DWORD PTR _data$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $LN1@asynch_rea

; 5987 :       (*(data->callback))(data->file);

	mov	edx, DWORD PTR _data$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	call	edx
	add	esp, 4
$LN1@asynch_rea:

; 5988 : 
; 5989 : 	#ifdef USE_SH_POOLS
; 5990 :     MemFreePtr(data);
; 5991 : 	#else
; 5992 :     MemFree(data);

	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 5993 : 	#endif
; 5994 : 
; 5995 :    IF_LOG( LOG( "Read thread exited." ));
; 5996 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_asynch_read ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_check$ = -8						; size = 4
_data$ = -4						; size = 4
_thread_data$ = 8					; size = 4
_asynch_write PROC

; 5943 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 5944 :    int check;
; 5945 :    ASYNCH_DATA * data;
; 5946 : 
; 5947 :    data = (ASYNCH_DATA *)thread_data;

	mov	eax, DWORD PTR _thread_data$[ebp]
	mov	DWORD PTR _data$[ebp], eax

; 5948 : 
; 5949 :    check = _write( data->file, data->buffer, data->size );

	mov	ecx, DWORD PTR _data$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _data$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	__write
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _check$[ebp], eax

; 5950 : 
; 5951 :    if( data->callback )

	mov	ecx, DWORD PTR _data$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $LN1@asynch_wri

; 5952 :       (*(data->callback))(data->file);

	mov	edx, DWORD PTR _data$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	call	edx
	add	esp, 4
$LN1@asynch_wri:

; 5953 : 
; 5954 : 	#ifdef USE_SH_POOLS
; 5955 :     MemFreePtr(data);
; 5956 : 	#else
; 5957 :     MemFree(data);

	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 5958 : 	#endif
; 5959 : 
; 5960 :    IF_LOG( LOG( "Write thread exited." ));
; 5961 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_asynch_write ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_err_code$ = -300					; size = 4
_blank$ = -296						; size = 4
_retval$ = -292						; size = 4
tv75 = -288						; size = 4
_buffer$ = -284						; size = 255
_title$ = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
_error$ = 8						; size = 4
_msg$ = 12						; size = 4
_line$ = 16						; size = 4
_filename$ = 20						; size = 4
__say_error PROC

; 7320 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 300				; 0000012cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 7321 :     int err_code;
; 7322 :     char buffer[ 255 ];
; 7323 :     char title[] = "Resource Manager Error!";

	mov	eax, DWORD PTR ??_C@_0BI@KKHIDFIG@Resource?5Manager?5Error?$CB?$AA@
	mov	DWORD PTR _title$[ebp], eax
	mov	ecx, DWORD PTR ??_C@_0BI@KKHIDFIG@Resource?5Manager?5Error?$CB?$AA@+4
	mov	DWORD PTR _title$[ebp+4], ecx
	mov	edx, DWORD PTR ??_C@_0BI@KKHIDFIG@Resource?5Manager?5Error?$CB?$AA@+8
	mov	DWORD PTR _title$[ebp+8], edx
	mov	eax, DWORD PTR ??_C@_0BI@KKHIDFIG@Resource?5Manager?5Error?$CB?$AA@+12
	mov	DWORD PTR _title$[ebp+12], eax
	mov	ecx, DWORD PTR ??_C@_0BI@KKHIDFIG@Resource?5Manager?5Error?$CB?$AA@+16
	mov	DWORD PTR _title$[ebp+16], ecx
	mov	edx, DWORD PTR ??_C@_0BI@KKHIDFIG@Resource?5Manager?5Error?$CB?$AA@+20
	mov	DWORD PTR _title$[ebp+20], edx

; 7324 :     char blank[] = "???";

	mov	eax, DWORD PTR ??_C@_03BBKEAIF@?$DP?$DP?$DP?$AA@
	mov	DWORD PTR _blank$[ebp], eax

; 7325 :     int  retval = 1;

	mov	DWORD PTR _retval$[ebp], 1

; 7326 : 
; 7327 :     IF_LOG( LOG( "ERROR (line: %d  file: %s):\n", line, filename ));
; 7328 : 
; 7329 :     if( !msg )

	cmp	DWORD PTR _msg$[ebp], 0
	jne	SHORT $LN11@say_error

; 7330 :         msg = blank;

	lea	ecx, DWORD PTR _blank$[ebp]
	mov	DWORD PTR _msg$[ebp], ecx
$LN11@say_error:

; 7331 : 
; 7332 :     RES_DEBUG_ERRNO = error;    /* set the equiv. of an errno */

	mov	edx, DWORD PTR _error$[ebp]
	mov	DWORD PTR _RES_DEBUG_ERRNO, edx

; 7333 :     err_code = error;

	mov	eax, DWORD PTR _error$[ebp]
	mov	DWORD PTR _err_code$[ebp], eax

; 7334 : 
; 7335 :     switch( error ) {

	mov	ecx, DWORD PTR _error$[ebp]
	mov	DWORD PTR tv75[ebp], ecx
	cmp	DWORD PTR tv75[ebp], 2
	je	SHORT $LN6@say_error
	cmp	DWORD PTR tv75[ebp], 13			; 0000000dH
	je	SHORT $LN8@say_error
	cmp	DWORD PTR tv75[ebp], 17			; 00000011H
	je	SHORT $LN7@say_error
	jmp	SHORT $LN5@say_error
$LN8@say_error:

; 7336 :         /* from erno.h */
; 7337 : 
; 7338 :         case EACCES:
; 7339 :             sprintf( buffer, "Tried to open read-only file (%s) for writing.", msg );

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	push	OFFSET ??_C@_0CP@MDMMLIAJ@Tried?5to?5open?5read?9only?5file?5?$CI?$CFs@
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 7340 :             break;

	jmp	$LN9@say_error
$LN7@say_error:

; 7341 : 
; 7342 :         case EEXIST:
; 7343 :             sprintf( buffer, "Create flag specified, but filename (%s) already exists.", msg );

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	push	OFFSET ??_C@_0DJ@PDPAPLDJ@Create?5flag?5specified?0?5but?5filen@
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 7344 :             break;

	jmp	$LN9@say_error
$LN6@say_error:

; 7345 : 
; 7346 :         case ENOENT:
; 7347 :             sprintf( buffer, "File or path not found. (%s).", msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	push	OFFSET ??_C@_0BO@EMKGDOO@File?5or?5path?5not?5found?4?5?$CI?$CFs?$CJ?4?$AA@
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 7348 :             break;

	jmp	SHORT $LN9@say_error
$LN5@say_error:

; 7349 : 
; 7350 :         default:    /* an error that is specific to this file */
; 7351 :             if( (error > RES_ERR_FIRST_ERROR) && (error < RES_ERR_LAST_ERROR) ) {

	cmp	DWORD PTR _error$[ebp], -5000		; ffffec78H
	jle	SHORT $LN4@say_error
	cmp	DWORD PTR _error$[ebp], -4967		; ffffec99H
	jge	SHORT $LN4@say_error

; 7352 :                 /* error values run from -5000 up, so error will always be negative,
; 7353 :                    and so will (RES_ERR_OR_FIRST+1).  We want to normalize this to 
; 7354 :                    0,1,2,3... */
; 7355 : 
; 7356 :                 error = error + (-RES_ERR_FIRST_ERROR - 1);

	mov	edx, DWORD PTR _error$[ebp]
	add	edx, 4999				; 00001387H
	mov	DWORD PTR _error$[ebp], edx

; 7357 : 
; 7358 :                 sprintf( buffer, "%s (%s)\n\n\nFile: %s\nLine: %d",  RES_ERR_OR_MSGS[ error ], msg, filename, line );

	mov	eax, DWORD PTR _line$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	mov	eax, DWORD PTR _error$[ebp]
	mov	ecx, DWORD PTR _RES_ERR_OR_MSGS[eax*4]
	push	ecx
	push	OFFSET ??_C@_0BM@HGBGFIMO@?$CFs?5?$CI?$CFs?$CJ?6?6?6File?3?5?$CFs?6Line?3?5?$CFd?$AA@
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_sprintf
	add	esp, 24					; 00000018H

; 7359 :             }
; 7360 :             else {

	jmp	SHORT $LN9@say_error
$LN4@say_error:

; 7361 :                 sprintf( buffer, "Unknown error encountered with file. (%s)\n\n\nFile: %s\nLine: %d\n", msg, filename, line );

	mov	eax, DWORD PTR _line$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	push	OFFSET ??_C@_0DP@KAFHBHNB@Unknown?5error?5encountered?5with?5f@
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_sprintf
	add	esp, 20					; 00000014H
$LN9@say_error:

; 7362 :             }
; 7363 :     }
; 7364 : 
; 7365 :     IF_LOG( LOG( "---> %s\n", buffer ));
; 7366 : 
; 7367 :     SHOULD_I_CALL_WITH( CALLBACK_ERROR, err_code, retval );

	mov	ecx, 4
	shl	ecx, 3
	cmp	DWORD PTR _RES_CALLBACK[ecx], 0
	je	SHORT $LN2@say_error
	mov	edx, DWORD PTR _err_code$[ebp]
	push	edx
	mov	eax, 4
	shl	eax, 3
	mov	ecx, DWORD PTR _RES_CALLBACK[eax]
	call	ecx
	add	esp, 4
	mov	DWORD PTR _retval$[ebp], eax
$LN2@say_error:

; 7368 : 
; 7369 : //    MessageBox( NULL, buffer, title, MB_OK | MB_ICONEXCLAMATION );
; 7370 : 
; 7371 :     if( !retval )

	cmp	DWORD PTR _retval$[ebp], 0
	jne	SHORT $LN12@say_error

; 7372 :         MessageBox( RES_GLOBAL_HWND, buffer, title, MB_OK | MB_ICONEXCLAMATION );

	push	48					; 00000030H
	lea	edx, DWORD PTR _title$[ebp]
	push	edx
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _RES_GLOBAL_HWND
	push	ecx
	call	DWORD PTR __imp__MessageBoxA@16
$LN12@say_error:

; 7373 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
__say_error ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
tv66 = -4						; size = 4
_dev$ = 8						; size = 4
_dbg_device PROC

; 7425 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 7426 :     IF_LOG( LOG( "Drive letter:  %c\n", dev -> letter  ));
; 7427 :     IF_LOG( LOG( "Volume name:   %s\n", dev -> name ));
; 7428 :     IF_LOG( LOG( "Serial num:    %x-%x\n", HI_WORD(dev->serial), LO_WORD(dev -> serial)));
; 7429 :     IF_LOG( LOG( "Type:          [%d] ", dev -> type ));
; 7430 : 
; 7431 :     switch( dev -> type ) {

	mov	eax, DWORD PTR _dev$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	mov	DWORD PTR tv66[ebp], ecx

; 7432 :         case 1:                    IF_LOG( LOG( "The root directory does not exist.\n" )); break;
; 7433 :         case DRIVE_REMOVABLE:    IF_LOG( LOG( "The drive can be removed from the drive.\n" )); break;
; 7434 :         case DRIVE_FIXED:        IF_LOG( LOG( "The disk cannot be removed from the drive.\n" )); break;
; 7435 :         case DRIVE_REMOTE:        IF_LOG( LOG( "The drive is a remote (network) drive.\n" )); break;
; 7436 :         case DRIVE_CDROM:        IF_LOG( LOG( "The drive is a CD-ROM drive.\n" )); break;
; 7437 :         case DRIVE_RAMDISK:        IF_LOG( LOG( "The drive is a RAM disk.\n" )); break;
; 7438 :             
; 7439 :         case 0:
; 7440 :         default:                IF_LOG( LOG( "The drive type cannot be determined.\n" ));
; 7441 :     }
; 7442 :            
; 7443 :     IF_LOG( LOG( "----------------\n" ));
; 7444 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_dbg_device ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_hits$ = -16						; size = 4
_entry$ = -12						; size = 4
_count$ = -8						; size = 4
_i$ = -4						; size = 4
_hsh$ = 8						; size = 4
_dbg_dir PROC

; 7512 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 7513 :     int i,
; 7514 :         count,
; 7515 :         hits = 0;

	mov	DWORD PTR _hits$[ebp], 0

; 7516 : 
; 7517 :     HASH_ENTRY * entry;
; 7518 : 
; 7519 :     count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 7520 : 
; 7521 :     IF_LOG( LOG( "\n\n" ));
; 7522 : 
; 7523 :     for( i=0; i<hsh->table_size; i++ ) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN10@dbg_dir
$LN9@dbg_dir:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN10@dbg_dir:
	mov	ecx, DWORD PTR _hsh$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx]
	jge	$LN11@dbg_dir

; 7524 :         if( hsh -> table[i].next ) {

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _hsh$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	cmp	DWORD PTR [edx+eax+44], 0
	je	SHORT $LN7@dbg_dir

; 7525 :             hits++;

	mov	eax, DWORD PTR _hits$[ebp]
	add	eax, 1
	mov	DWORD PTR _hits$[ebp], eax

; 7526 :             entry = &hsh -> table[i];

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _hsh$[ebp]
	add	ecx, DWORD PTR [edx+24]
	mov	DWORD PTR _entry$[ebp], ecx
$LN6@dbg_dir:

; 7527 : 
; 7528 :             while( entry ) {

	cmp	DWORD PTR _entry$[ebp], 0
	je	SHORT $LN5@dbg_dir

; 7529 :                 IF_LOG( LOG( "%-14s ", entry -> name ));
; 7530 :                 count++;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax

; 7531 :                 if( !(count % 4)) IF_LOG( LOG( "\n" ));

	mov	ecx, DWORD PTR _count$[ebp]
	and	ecx, -2147483645			; 80000003H
	jns	SHORT $LN13@dbg_dir
	dec	ecx
	or	ecx, -4					; fffffffcH
	inc	ecx
$LN13@dbg_dir:

; 7532 :            
; 7533 :                 entry = entry -> next;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR _entry$[ebp], eax

; 7534 :             }

	jmp	SHORT $LN6@dbg_dir
$LN5@dbg_dir:

; 7535 :         }
; 7536 :         else

	jmp	SHORT $LN3@dbg_dir
$LN7@dbg_dir:

; 7537 :             if( hsh -> table[i].attrib ) {

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _hsh$[ebp]
	mov	eax, DWORD PTR [edx+24]
	cmp	DWORD PTR [eax+ecx+28], 0
	je	SHORT $LN3@dbg_dir

; 7538 :                 IF_LOG( LOG( "%-14s ", hsh -> table[i].name ));
; 7539 :                 count++;

	mov	ecx, DWORD PTR _count$[ebp]
	add	ecx, 1
	mov	DWORD PTR _count$[ebp], ecx

; 7540 :                 if( !(count % 4)) IF_LOG( LOG( "\n" ));

	mov	edx, DWORD PTR _count$[ebp]
	and	edx, -2147483645			; 80000003H
	jns	SHORT $LN14@dbg_dir
	dec	edx
	or	edx, -4					; fffffffcH
	inc	edx
$LN14@dbg_dir:
$LN3@dbg_dir:

; 7541 :             }
; 7542 :     }

	jmp	$LN9@dbg_dir
$LN11@dbg_dir:

; 7543 : 
; 7544 :     IF_LOG( LOG( "\n\n" ));
; 7545 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_dbg_dir ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_attrib$ = -4						; size = 4
_data$ = 8						; size = 4
_dbg_print PROC

; 7390 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 7391 :     int attrib;
; 7392 : 
; 7393 :     attrib = data -> attrib;

	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR _attrib$[ebp], ecx

; 7394 :     
; 7395 :     printf( "%-17s", data -> name );

	mov	edx, DWORD PTR _data$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	OFFSET ??_C@_05ENKMGHII@?$CF?917s?$AA@
	call	_printf
	add	esp, 8

; 7396 :     printf( "size: %5d ", data -> size );

	mov	ecx, DWORD PTR _data$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	push	OFFSET ??_C@_0L@DMPNKCFM@size?3?5?$CF5d?5?$AA@
	call	_printf
	add	esp, 8

; 7397 :     printf( "csize: %5d ", data -> csize );

	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	push	OFFSET ??_C@_0M@HDGDGLCH@csize?3?5?$CF5d?5?$AA@
	call	_printf
	add	esp, 8

; 7398 :     printf( "method: %1d ", data -> method );

	mov	edx, DWORD PTR _data$[ebp]
	movsx	eax, WORD PTR [edx+16]
	push	eax
	push	OFFSET ??_C@_0N@MCEGBKEA@method?3?5?$CF1d?5?$AA@
	call	_printf
	add	esp, 8

; 7399 : 
; 7400 :     if( attrib & _A_RDONLY )  printf( "R" );   else   printf( " " );

	mov	ecx, DWORD PTR _attrib$[ebp]
	and	ecx, 1
	je	SHORT $LN10@dbg_print
	push	OFFSET ??_C@_01DGKLNCNG@R?$AA@
	call	_printf
	add	esp, 4
	jmp	SHORT $LN9@dbg_print
$LN10@dbg_print:
	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	call	_printf
	add	esp, 4
$LN9@dbg_print:

; 7401 :     if( attrib & _A_HIDDEN )  printf( "H" );   else   printf( " " );

	mov	edx, DWORD PTR _attrib$[ebp]
	and	edx, 2
	je	SHORT $LN8@dbg_print
	push	OFFSET ??_C@_01IGIGCIAN@H?$AA@
	call	_printf
	add	esp, 4
	jmp	SHORT $LN7@dbg_print
$LN8@dbg_print:
	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	call	_printf
	add	esp, 4
$LN7@dbg_print:

; 7402 :     if( attrib & _A_SYSTEM )  printf( "S" );   else   printf( " " );

	mov	eax, DWORD PTR _attrib$[ebp]
	and	eax, 4
	je	SHORT $LN6@dbg_print
	push	OFFSET ??_C@_01CPLAODJH@S?$AA@
	call	_printf
	add	esp, 4
	jmp	SHORT $LN5@dbg_print
$LN6@dbg_print:
	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	call	_printf
	add	esp, 4
$LN5@dbg_print:

; 7403 :     if( attrib & _A_ARCH )    printf( "A" );   else   printf( " " );

	mov	ecx, DWORD PTR _attrib$[ebp]
	and	ecx, 32					; 00000020H
	je	SHORT $LN4@dbg_print
	push	OFFSET ??_C@_01FHEEJDEE@A?$AA@
	call	_printf
	add	esp, 4
	jmp	SHORT $LN3@dbg_print
$LN4@dbg_print:
	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	call	_printf
	add	esp, 4
$LN3@dbg_print:

; 7404 : 
; 7405 :     if( attrib & _A_SUBDIR )  printf( "\t\t<DIR>" );  else  printf( "\t\t     " );

	mov	edx, DWORD PTR _attrib$[ebp]
	and	edx, 16					; 00000010H
	je	SHORT $LN2@dbg_print
	push	OFFSET ??_C@_07GCALBCF@?7?7?$DMDIR?$DO?$AA@
	call	_printf
	add	esp, 4
	jmp	SHORT $LN1@dbg_print
$LN2@dbg_print:
	push	OFFSET ??_C@_07NLJMJJCA@?7?7?5?5?5?5?5?$AA@
	call	_printf
	add	esp, 4
$LN1@dbg_print:

; 7406 : 
; 7407 :     printf( "\n" );

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	_printf
	add	esp, 4

; 7408 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_dbg_print ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_max_len$ = -20						; size = 4
_hits$ = -16						; size = 4
_entry$ = -12						; size = 4
_len$ = -8						; size = 4
_i$ = -4						; size = 4
_hsh$ = 8						; size = 4
_dbg_analyze_hash PROC

; 7460 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 7461 :     int i,
; 7462 :         len,
; 7463 :         max_len,
; 7464 :         hits = 0;

	mov	DWORD PTR _hits$[ebp], 0

; 7465 : 
; 7466 :     HASH_ENTRY * entry;
; 7467 : 
; 7468 :     IF_LOG( LOG( "Table name............. %s\n", hsh -> name ));
; 7469 :     IF_LOG( LOG( "Hash size.............. %d\n", hsh -> table_size ));
; 7470 :     IF_LOG( LOG( "Num entries............ %d\n", hsh -> num_entries ));
; 7471 :     IF_LOG( LOG( "Ratio.................. %-3.0f%%\n", ((float)hsh -> table_size / (float)hsh -> num_entries)*100.0));
; 7472 : 
; 7473 :     max_len = 0;

	mov	DWORD PTR _max_len$[ebp], 0

; 7474 : 
; 7475 :     for( i=0; i<hsh->table_size; i++ ) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@dbg_analyz
$LN6@dbg_analyz:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@dbg_analyz:
	mov	ecx, DWORD PTR _hsh$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN8@dbg_analyz

; 7476 :         if( hsh -> table[i].next ) {

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _hsh$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	cmp	DWORD PTR [edx+eax+44], 0
	je	SHORT $LN4@dbg_analyz

; 7477 :             hits++;

	mov	eax, DWORD PTR _hits$[ebp]
	add	eax, 1
	mov	DWORD PTR _hits$[ebp], eax

; 7478 :             entry = &hsh -> table[i];

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _hsh$[ebp]
	add	ecx, DWORD PTR [edx+24]
	mov	DWORD PTR _entry$[ebp], ecx

; 7479 :             len = 0;

	mov	DWORD PTR _len$[ebp], 0
$LN3@dbg_analyz:

; 7480 : 
; 7481 :             while( entry ) {

	cmp	DWORD PTR _entry$[ebp], 0
	je	SHORT $LN2@dbg_analyz

; 7482 :                 entry = entry -> next;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _entry$[ebp], ecx

; 7483 :                 len++;

	mov	edx, DWORD PTR _len$[ebp]
	add	edx, 1
	mov	DWORD PTR _len$[ebp], edx

; 7484 :             }

	jmp	SHORT $LN3@dbg_analyz
$LN2@dbg_analyz:

; 7485 : 
; 7486 :             if( len > max_len ) 

	mov	eax, DWORD PTR _len$[ebp]
	cmp	eax, DWORD PTR _max_len$[ebp]
	jle	SHORT $LN4@dbg_analyz

; 7487 :                 max_len = len;

	mov	ecx, DWORD PTR _len$[ebp]
	mov	DWORD PTR _max_len$[ebp], ecx
$LN4@dbg_analyz:

; 7488 :         }
; 7489 :     }

	jmp	SHORT $LN6@dbg_analyz
$LN8@dbg_analyz:

; 7490 : 
; 7491 :     IF_LOG( LOG( "Hash collisions........ %d\n", hits ));
; 7492 :     IF_LOG( LOG( "Hash peformance........ %-3.0f%%\n", (1.0 - ((float)hits/(float)hsh->num_entries))*100.0));
; 7493 :     IF_LOG( LOG( "Maximum chain length... %d\n", max_len ));
; 7494 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_dbg_analyze_hash ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
tv76 = -20						; size = 4
_table$ = -16						; size = 4
_i$ = -12						; size = 4
_dev$ = -8						; size = 4
_list$ = -4						; size = 4
_ResDbgDump PROC

; 5875 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 5876 :     HASH_TABLE   * table;
; 5877 :     DEVICE_ENTRY * dev;
; 5878 :     LIST         * list;
; 5879 :     int            i;
; 5880 : 
; 5881 :     if( RES_DEBUG_LOGGING && RES_DEBUG_OPEN_LOG ) {

	cmp	DWORD PTR _RES_DEBUG_LOGGING, 0
	je	$LN10@ResDbgDump
	cmp	DWORD PTR _RES_DEBUG_OPEN_LOG, 0
	je	$LN10@ResDbgDump

; 5882 : 
; 5883 :         IF_LOG( LOG( "\n\n-------------\n" ));
; 5884 :         IF_LOG( LOG( "Statistics...\n" ));
; 5885 :         IF_LOG( LOG( "-------------\n" ));
; 5886 : 
; 5887 :         for( list = GLOBAL_PATH_LIST; list; list = list -> next ) {

	mov	eax, DWORD PTR _GLOBAL_PATH_LIST
	mov	DWORD PTR _list$[ebp], eax
	jmp	SHORT $LN8@ResDbgDump
$LN7@ResDbgDump:
	mov	ecx, DWORD PTR _list$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _list$[ebp], edx
$LN8@ResDbgDump:
	cmp	DWORD PTR _list$[ebp], 0
	je	SHORT $LN6@ResDbgDump

; 5888 :             table = (HASH_TABLE *)list -> node;

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _table$[ebp], ecx

; 5889 : 
; 5890 :             dbg_analyze_hash( table );

	mov	edx, DWORD PTR _table$[ebp]
	push	edx
	call	_dbg_analyze_hash
	add	esp, 4

; 5891 :             dbg_dir( table );

	mov	eax, DWORD PTR _table$[ebp]
	push	eax
	call	_dbg_dir
	add	esp, 4

; 5892 :         }

	jmp	SHORT $LN7@ResDbgDump
$LN6@ResDbgDump:

; 5893 : 
; 5894 :         dev = RES_DEVICES;

	mov	ecx, DWORD PTR _RES_DEVICES
	mov	DWORD PTR _dev$[ebp], ecx

; 5895 : 
; 5896 :         for( i=0; i<MAX_DEVICES; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN5@ResDbgDump
$LN4@ResDbgDump:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN5@ResDbgDump:
	cmp	DWORD PTR _i$[ebp], 26			; 0000001aH
	jge	SHORT $LN10@ResDbgDump

; 5897 :             if( dev -> serial )

	mov	eax, DWORD PTR _dev$[ebp]
	cmp	DWORD PTR [eax+36], 0
	je	SHORT $LN2@ResDbgDump

; 5898 :                 dbg_device( dev++ );

	mov	ecx, DWORD PTR _dev$[ebp]
	mov	DWORD PTR tv76[ebp], ecx
	mov	edx, DWORD PTR tv76[ebp]
	push	edx
	call	_dbg_device
	add	esp, 4
	mov	eax, DWORD PTR _dev$[ebp]
	add	eax, 40					; 00000028H
	mov	DWORD PTR _dev$[ebp], eax
$LN2@ResDbgDump:

; 5899 :    }

	jmp	SHORT $LN4@ResDbgDump
$LN10@ResDbgDump:

; 5900 :    else
; 5901 :       IF_LOG( LOG( "Either no open log file, or event logging paused.\n" ));
; 5902 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ResDbgDump ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_on$ = 8						; size = 4
_ResDbgLogPause PROC

; 5856 : {

	push	ebp
	mov	ebp, esp

; 5857 :     RES_DEBUG_LOGGING = on;

	mov	eax, DWORD PTR _on$[ebp]
	mov	DWORD PTR _RES_DEBUG_LOGGING, eax

; 5858 : }

	pop	ebp
	ret	0
_ResDbgLogPause ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_length$ = -268						; size = 4
_data$ = -264						; size = 4
_buffer$ = -260						; size = 255
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_ResDbgPrintf PROC

; 5821 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 268				; 0000010cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 5822 :    va_list data;                            /* c sucks                      */
; 5823 :    char buffer[255];
; 5824 :    int length;
; 5825 : 
; 5826 :    va_start( data, msg );                   /* init variable args           */

	lea	eax, DWORD PTR _msg$[ebp+4]
	mov	DWORD PTR _data$[ebp], eax

; 5827 : 
; 5828 :    length = vsprintf( buffer, msg, data );

	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_vsprintf
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _length$[ebp], eax

; 5829 : 
; 5830 :    if( RES_DEBUG_OPEN_LOG && RES_DEBUG_LOGGING )

	cmp	DWORD PTR _RES_DEBUG_OPEN_LOG, 0
	je	SHORT $LN1@ResDbgPrin
	cmp	DWORD PTR _RES_DEBUG_LOGGING, 0
	je	SHORT $LN1@ResDbgPrin

; 5831 :       _write( RES_DEBUG_FILE, buffer, length );

	mov	ecx, DWORD PTR _length$[ebp]
	push	ecx
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _RES_DEBUG_FILE
	push	eax
	call	__write
	add	esp, 12					; 0000000cH
$LN1@ResDbgPrin:

; 5832 : 
; 5833 : #ifdef RES_DEBUG_STDIO 
; 5834 :    RES_DEBUG_STDIO( buffer, length );       /* external func for dumping text msg's to the console */
; 5835 : #endif /*RES_DEBUG_STDIO */
; 5836 : 
; 5837 :    va_end( data );                          /* reset variable args          */

	mov	DWORD PTR _data$[ebp], 0

; 5838 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_ResDbgPrintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_ResDbgLogClose PROC

; 5797 : {

	push	ebp
	mov	ebp, esp

; 5798 :     if( RES_DEBUG_OPEN_LOG )

	cmp	DWORD PTR _RES_DEBUG_OPEN_LOG, 0
	je	SHORT $LN1@ResDbgLogC

; 5799 :         _close( RES_DEBUG_FILE );

	mov	eax, DWORD PTR _RES_DEBUG_FILE
	push	eax
	call	__close
	add	esp, 4
$LN1@ResDbgLogC:

; 5800 : 
; 5801 :     RES_DEBUG_OPEN_LOG = FALSE;

	mov	DWORD PTR _RES_DEBUG_OPEN_LOG, 0

; 5802 : 
; 5803 :     RES_DEBUG_LOGGING = FALSE;

	mov	DWORD PTR _RES_DEBUG_LOGGING, 0

; 5804 : }

	pop	ebp
	ret	0
_ResDbgLogClose ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_ResDbgLogOpen PROC

; 5757 : {

	push	ebp
	mov	ebp, esp

; 5758 :     if( RES_DEBUG_LOGGING )

	cmp	DWORD PTR _RES_DEBUG_LOGGING, 0
	je	SHORT $LN2@ResDbgLogO

; 5759 :         ResDbgLogClose();

	call	_ResDbgLogClose
$LN2@ResDbgLogO:

; 5760 : 
; 5761 :     /* there is actually a third parameter to open() (MSVC just doesn't admit it) 
; 5762 :        octal 666 ensures that stack-crap won't accidently create this file as
; 5763 :        read-only.  Thank to Roger Fujii for this fix! */
; 5764 : 
; 5765 :     RES_DEBUG_FILE = _open( filename, _O_RDWR | _O_CREAT | _O_TEXT, 0x1b6 /* Choked on O666L and O666 */ );

	push	438					; 000001b6H
	push	16642					; 00004102H
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	__open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _RES_DEBUG_FILE, eax

; 5766 : 
; 5767 :     if( RES_DEBUG_FILE == -1 ) {

	cmp	DWORD PTR _RES_DEBUG_FILE, -1
	jne	SHORT $LN1@ResDbgLogO

; 5768 :         SAY_ERROR( RES_ERR_COULDNT_OPEN_FILE, filename );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	5768					; 00001688H
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	push	-4984					; ffffec88H
	call	__say_error
	add	esp, 16					; 00000010H

; 5769 :         RES_DEBUG_OPEN_LOG = FALSE;

	mov	DWORD PTR _RES_DEBUG_OPEN_LOG, 0

; 5770 :         RES_DEBUG_LOGGING = FALSE;

	mov	DWORD PTR _RES_DEBUG_LOGGING, 0

; 5771 :         return( FALSE );

	xor	eax, eax
	jmp	SHORT $LN3@ResDbgLogO
$LN1@ResDbgLogO:

; 5772 :     }
; 5773 : 
; 5774 :     RES_DEBUG_OPEN_LOG = TRUE;

	mov	DWORD PTR _RES_DEBUG_OPEN_LOG, 1

; 5775 :     RES_DEBUG_LOGGING = TRUE;

	mov	DWORD PTR _RES_DEBUG_LOGGING, 1

; 5776 : 
; 5777 :     IF_DEBUG( LOG( "Log file opened.\n\n" ));
; 5778 : 
; 5779 :     return( TRUE );

	mov	eax, 1
$LN3@ResDbgLogO:

; 5780 : }

	pop	ebp
	ret	0
_ResDbgLogOpen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_on$ = 8						; size = 4
_ResDbg	PROC

; 5738 : {

	push	ebp
	mov	ebp, esp

; 5739 :    RES_DEBUG_FLAG = on;

	mov	eax, DWORD PTR _on$[ebp]
	mov	DWORD PTR _RES_DEBUG_FLAG, eax

; 5740 : }

	pop	ebp
	ret	0
_ResDbg	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_thread_id$ = -8					; size = 4
_data$ = -4						; size = 4
_file$ = 8						; size = 4
_buffer$ = 12						; size = 4
_callback$ = 16						; size = 4
_ResAsynchWrite PROC

; 4065 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 4066 :     ASYNCH_DATA * data;
; 4067 :     int thread_id;
; 4068 : 
; 4069 : #if( RES_DEBUG_PARAMS )
; 4070 :     if( !buffer || (file < 0) || (file > MAX_FILE_HANDLES) ) {

	cmp	DWORD PTR _buffer$[ebp], 0
	je	SHORT $LN3@ResAsynchW
	cmp	DWORD PTR _file$[ebp], 0
	jl	SHORT $LN3@ResAsynchW
	cmp	DWORD PTR _file$[ebp], 256		; 00000100H
	jle	SHORT $LN4@ResAsynchW
$LN3@ResAsynchW:

; 4071 :         SAY_ERROR( RES_ERR_INCORRECT_PARAMETER, "ResAsynchWrite" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	4071					; 00000fe7H
	push	OFFSET ??_C@_0P@CKHAKKGB@ResAsynchWrite?$AA@
	push	-4998					; ffffec7aH
	call	__say_error
	add	esp, 16					; 00000010H

; 4072 :         return( FALSE );

	xor	eax, eax
	jmp	$LN5@ResAsynchW
$LN4@ResAsynchW:

; 4073 :     }
; 4074 : #endif
; 4075 : 
; 4076 :     IF_LOG( LOG( "asynch write %s\n", FILE_HANDLES[file].filename ));
; 4077 : 
; 4078 : 	#ifdef USE_SH_POOLS
; 4079 :     data = (ASYNCH_DATA *)MemAllocPtr( gResmgrMemPool, sizeof( ASYNCH_DATA ), 0 );
; 4080 : 	#else
; 4081 :     data = (ASYNCH_DATA *)MemMalloc( sizeof( ASYNCH_DATA ), "Asynch data" );

	push	16					; 00000010H
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _data$[ebp], eax

; 4082 : 	#endif
; 4083 : 
; 4084 :     if( !data ) {

	cmp	DWORD PTR _data$[ebp], 0
	jne	SHORT $LN2@ResAsynchW

; 4085 :         SAY_ERROR( RES_ERR_NO_MEMORY, NULL );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	4085					; 00000ff5H
	push	0
	push	-4999					; ffffec79H
	call	__say_error
	add	esp, 16					; 00000010H

; 4086 :         return( FALSE );

	xor	eax, eax
	jmp	SHORT $LN5@ResAsynchW
$LN2@ResAsynchW:

; 4087 :     }
; 4088 : 
; 4089 :     data -> file = file;

	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR _file$[ebp]
	mov	DWORD PTR [eax], ecx

; 4090 :     data -> buffer = buffer;

	mov	edx, DWORD PTR _data$[ebp]
	mov	eax, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR [edx+4], eax

; 4091 :     data -> callback = callback;

	mov	ecx, DWORD PTR _data$[ebp]
	mov	edx, DWORD PTR _callback$[ebp]
	mov	DWORD PTR [ecx+12], edx

; 4092 :  
; 4093 :     thread_id = _beginthread( asynch_write, 128 /*stack size*/, (void *)(data));

	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	push	128					; 00000080H
	push	OFFSET _asynch_write
	call	__beginthread
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _thread_id$[ebp], eax

; 4094 : 
; 4095 : //SetThreadPriority( thread_id, THREAD_PRIORITY_LOWEST );
; 4096 : //#error PROTOTYPE THIS!
; 4097 : 
; 4098 : 
; 4099 :     if( thread_id == -1 ) {

	cmp	DWORD PTR _thread_id$[ebp], -1
	jne	SHORT $LN1@ResAsynchW

; 4100 :         SAY_ERROR( RES_ERR_COULDNT_SPAWN_THREAD, NULL );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	4100					; 00001004H
	push	0
	push	-4985					; ffffec87H
	call	__say_error
	add	esp, 16					; 00000010H

; 4101 :         return( FALSE );

	xor	eax, eax
	jmp	SHORT $LN5@ResAsynchW
$LN1@ResAsynchW:

; 4102 :     }
; 4103 : 
; 4104 :     IF_DEBUG( LOG( "Write thread (%d) spawned.", thread_id ));
; 4105 :     return( TRUE );

	mov	eax, 1
$LN5@ResAsynchW:

; 4106 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ResAsynchWrite ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_thread_id$ = -8					; size = 4
_data$ = -4						; size = 4
_file$ = 8						; size = 4
_buffer$ = 12						; size = 4
_callback$ = 16						; size = 4
_ResAsynchRead PROC

; 3994 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3995 :     ASYNCH_DATA * data;
; 3996 :     int thread_id;
; 3997 : 
; 3998 : #if( RES_DEBUG_PARAMS )   
; 3999 :     if( !buffer || (file < 0) || (file > MAX_FILE_HANDLES) ) {

	cmp	DWORD PTR _buffer$[ebp], 0
	je	SHORT $LN3@ResAsynchR
	cmp	DWORD PTR _file$[ebp], 0
	jl	SHORT $LN3@ResAsynchR
	cmp	DWORD PTR _file$[ebp], 256		; 00000100H
	jle	SHORT $LN4@ResAsynchR
$LN3@ResAsynchR:

; 4000 :         SAY_ERROR( RES_ERR_INCORRECT_PARAMETER, "ResAsynchRead" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	4000					; 00000fa0H
	push	OFFSET ??_C@_0O@GDKGMDJD@ResAsynchRead?$AA@
	push	-4998					; ffffec7aH
	call	__say_error
	add	esp, 16					; 00000010H

; 4001 :         return( FALSE );

	xor	eax, eax
	jmp	$LN5@ResAsynchR
$LN4@ResAsynchR:

; 4002 :     }
; 4003 : #endif
; 4004 : 
; 4005 :     IF_LOG( LOG( "asynch read %s\n", FILE_HANDLES[file].filename ));
; 4006 : 
; 4007 : 	#ifdef USE_SH_POOLS
; 4008 :     data = (ASYNCH_DATA *)MemAllocPtr( gResmgrMemPool, sizeof( ASYNCH_DATA ), 0 );
; 4009 : 	#else
; 4010 :     data = (ASYNCH_DATA *)MemMalloc( sizeof( ASYNCH_DATA ), "Asynch data" );

	push	16					; 00000010H
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _data$[ebp], eax

; 4011 : 	#endif
; 4012 : 
; 4013 :     if( !data ) {

	cmp	DWORD PTR _data$[ebp], 0
	jne	SHORT $LN2@ResAsynchR

; 4014 :         SAY_ERROR( RES_ERR_NO_MEMORY, NULL );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	4014					; 00000faeH
	push	0
	push	-4999					; ffffec79H
	call	__say_error
	add	esp, 16					; 00000010H

; 4015 :         return( FALSE );

	xor	eax, eax
	jmp	SHORT $LN5@ResAsynchR
$LN2@ResAsynchR:

; 4016 :     }
; 4017 : 
; 4018 :     data -> file = file;

	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR _file$[ebp]
	mov	DWORD PTR [eax], ecx

; 4019 :     data -> buffer = buffer;

	mov	edx, DWORD PTR _data$[ebp]
	mov	eax, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR [edx+4], eax

; 4020 :     data -> callback = callback;

	mov	ecx, DWORD PTR _data$[ebp]
	mov	edx, DWORD PTR _callback$[ebp]
	mov	DWORD PTR [ecx+12], edx

; 4021 : 
; 4022 :     thread_id = _beginthread( asynch_read, 128 /*stack size*/, (void *)(data));

	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	push	128					; 00000080H
	push	OFFSET _asynch_read
	call	__beginthread
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _thread_id$[ebp], eax

; 4023 : 
; 4024 :     if( thread_id == -1 ) {

	cmp	DWORD PTR _thread_id$[ebp], -1
	jne	SHORT $LN1@ResAsynchR

; 4025 :         SAY_ERROR( RES_ERR_COULDNT_SPAWN_THREAD, NULL );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	4025					; 00000fb9H
	push	0
	push	-4985					; ffffec87H
	call	__say_error
	add	esp, 16					; 00000010H

; 4026 :         return( FALSE );

	xor	eax, eax
	jmp	SHORT $LN5@ResAsynchR
$LN1@ResAsynchR:

; 4027 :     }
; 4028 :     return( TRUE );

	mov	eax, 1
$LN5@ResAsynchR:

; 4029 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ResAsynchRead ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_archive$ = -8						; size = 4
_list$ = -4						; size = 4
_handle$ = 8						; size = 4
_buffer$ = 12						; size = 4
_ResGetArchive PROC

; 2934 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2935 :     ARCHIVE    * archive=NULL;

	mov	DWORD PTR _archive$[ebp], 0

; 2936 :     LIST       * list=NULL;

	mov	DWORD PTR _list$[ebp], 0

; 2937 : 
; 2938 : #if( RES_DEBUG_PARAMS )
; 2939 :     if( !ARCHIVE_LIST ) {

	cmp	DWORD PTR _ARCHIVE_LIST, 0
	jne	SHORT $LN6@ResGetArch

; 2940 :         *buffer = 0x00;

	mov	eax, DWORD PTR _buffer$[ebp]
	mov	BYTE PTR [eax], 0

; 2941 :         return(0);

	xor	eax, eax
	jmp	SHORT $LN7@ResGetArch
$LN6@ResGetArch:

; 2942 :     }
; 2943 : #endif /* RES_DEBUG_PARAMS */
; 2944 : 
; 2945 :     /* using the handle, search the list for the structure */
; 2946 : 
; 2947 :     for( list = ARCHIVE_LIST; list; list = list -> next ) {

	mov	ecx, DWORD PTR _ARCHIVE_LIST
	mov	DWORD PTR _list$[ebp], ecx
	jmp	SHORT $LN5@ResGetArch
$LN4@ResGetArch:
	mov	edx, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _list$[ebp], eax
$LN5@ResGetArch:
	cmp	DWORD PTR _list$[ebp], 0
	je	SHORT $LN3@ResGetArch

; 2948 :         archive = (ARCHIVE *)list -> node;

	mov	ecx, DWORD PTR _list$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _archive$[ebp], edx

; 2949 : 
; 2950 :         if( archive -> os_handle == handle )

	mov	eax, DWORD PTR _archive$[ebp]
	mov	ecx, DWORD PTR [eax+260]
	cmp	ecx, DWORD PTR _handle$[ebp]
	jne	SHORT $LN2@ResGetArch

; 2951 :             break;

	jmp	SHORT $LN3@ResGetArch
$LN2@ResGetArch:

; 2952 :     }

	jmp	SHORT $LN4@ResGetArch
$LN3@ResGetArch:

; 2953 : 
; 2954 :     if( !list ) { /* couldn't find it, may already have been closed - or handle is incorrect */

	cmp	DWORD PTR _list$[ebp], 0
	jne	SHORT $LN1@ResGetArch

; 2955 :         *buffer = 0x00;

	mov	edx, DWORD PTR _buffer$[ebp]
	mov	BYTE PTR [edx], 0

; 2956 :         return(0);

	xor	eax, eax
	jmp	SHORT $LN7@ResGetArch
$LN1@ResGetArch:

; 2957 :     }
; 2958 : 
; 2959 :     strcpy( buffer, archive -> name );

	mov	eax, DWORD PTR _archive$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 2960 : 
; 2961 :     return( strlen(buffer));

	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
$LN7@ResGetArch:

; 2962 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ResGetArchive ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_ln$1 = -1160						; size = 4
tv147 = -1156						; size = 4
_currentDrive$ = -1152					; size = 4
$T2 = -1148						; size = 4
$T3 = -1144						; size = 4
_full_yet$ = -1140					; size = 4
_directory$ = -1136					; size = 4
_retval$ = -1132					; size = 4
_dir_was$ = -1128					; size = 4
_filecount$ = -1124					; size = 4
_done$ = -1120						; size = 4
_refresh$ = -1116					; size = 4
_idx$4 = -1112						; size = 4
_count$ = -1108						; size = 4
_local_table$ = -1104					; size = 4
_file_data$ = -1100					; size = 4
_vol_was$ = -1093					; size = 1
_filenum$ = -1092					; size = 4
_length$ = -1088					; size = 4
_entry$ = -1084						; size = 4
_data$ = -1080						; size = 296
_currentPath$ = -784					; size = 260
_buffer$ = -524						; size = 260
_tmp_path$ = -264					; size = 260
__$ArrayPad$ = -4					; size = 4
_path$ = 8						; size = 4
_recurse$ = 12						; size = 4
_ResAddPath PROC

; 3334 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1160				; 00000488H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 3335 :     struct _finddata_t data;
; 3336 : 
; 3337 :     int  length=0,

	mov	DWORD PTR _length$[ebp], 0

; 3338 :          count=0,

	mov	DWORD PTR _count$[ebp], 0

; 3339 :          done=0,

	mov	DWORD PTR _done$[ebp], 0

; 3340 :          refresh = FALSE,

	mov	DWORD PTR _refresh$[ebp], 0

; 3341 :          full_yet = FALSE,

	mov	DWORD PTR _full_yet$[ebp], 0

; 3342 :          retval = TRUE,

	mov	DWORD PTR _retval$[ebp], 1

; 3343 :          filenum=0, filecount=0;

	mov	DWORD PTR _filenum$[ebp], 0
	mov	DWORD PTR _filecount$[ebp], 0

; 3344 : 
; 3345 :     long directory=0;

	mov	DWORD PTR _directory$[ebp], 0

; 3346 :     
; 3347 :     char tmp_path[ _MAX_PATH ]={0};

	mov	BYTE PTR _tmp_path$[ebp], 0
	push	259					; 00000103H
	push	0
	lea	eax, DWORD PTR _tmp_path$[ebp+1]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 3348 :     char buffer[ _MAX_PATH ]={0};

	mov	BYTE PTR _buffer$[ebp], 0
	push	259					; 00000103H
	push	0
	lea	ecx, DWORD PTR _buffer$[ebp+1]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 3349 : 
; 3350 :     HASH_TABLE * local_table=NULL;

	mov	DWORD PTR _local_table$[ebp], 0

; 3351 :     HASH_ENTRY * entry=NULL;

	mov	DWORD PTR _entry$[ebp], 0

; 3352 : 
; 3353 :     char vol_was=0;

	mov	BYTE PTR _vol_was$[ebp], 0

; 3354 :     int  dir_was=0;

	mov	DWORD PTR _dir_was$[ebp], 0

; 3355 : 
; 3356 :     struct _finddata_t  *file_data=NULL;

	mov	DWORD PTR _file_data$[ebp], 0

; 3357 : 
; 3358 :     int currentDrive;
; 3359 :     char currentPath[ _MAX_PATH];
; 3360 : 
; 3361 :     /* Save original drive/path.*/
; 3362 :      currentDrive = _getdrive();

	call	__getdrive
	mov	DWORD PTR _currentDrive$[ebp], eax

; 3363 :     _getdcwd( currentDrive,currentPath, _MAX_PATH );

	push	260					; 00000104H
	lea	edx, DWORD PTR _currentPath$[ebp]
	push	edx
	mov	eax, DWORD PTR _currentDrive$[ebp]
	push	eax
	call	__getdcwd
	add	esp, 12					; 0000000cH

; 3364 : 
; 3365 : 
; 3366 : 
; 3367 : #ifdef RES_NO_REPEATED_ADDPATHS
; 3368 :             if ( get_dir_index( path ) != -1 ) 

	mov	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	_get_dir_index
	add	esp, 4
	cmp	eax, -1
	je	SHORT $LN41@ResAddPath

; 3369 :             {
; 3370 :                  return TRUE;

	mov	eax, 1
	jmp	$LN42@ResAddPath
$LN41@ResAddPath:

; 3371 :             }
; 3372 : #endif
; 3373 : 
; 3374 :     IF_LOG( LOG( "adding path: %s\n", path ));
; 3375 : 
; 3376 : #if( RES_DEBUG_PARAMS )
; 3377 :     if( !path ) {

	cmp	DWORD PTR _path$[ebp], 0
	jne	SHORT $LN40@ResAddPath

; 3378 :         SAY_ERROR( RES_ERR_INCORRECT_PARAMETER, "ResAddPath" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	3378					; 00000d32H
	push	OFFSET ??_C@_0L@GLEIDJF@ResAddPath?$AA@
	push	-4998					; ffffec7aH
	call	__say_error
	add	esp, 16					; 00000010H

; 3379 :         return( FALSE );

	xor	eax, eax
	jmp	$LN42@ResAddPath
$LN40@ResAddPath:

; 3380 :     }
; 3381 : 
; 3382 :     if( !GLOBAL_HASH_TABLE ) {

	cmp	DWORD PTR _GLOBAL_HASH_TABLE, 0
	jne	SHORT $LN39@ResAddPath

; 3383 :         printf( "You must first call ResCreatePath()\n" );

	push	OFFSET ??_C@_0CF@CKADNGLC@You?5must?5first?5call?5ResCreatePat@
	call	_printf
	add	esp, 4

; 3384 :         return( FALSE );

	xor	eax, eax
	jmp	$LN42@ResAddPath
$LN39@ResAddPath:

; 3385 :     }
; 3386 : #endif /* RES_DEBUG_VERSON */
; 3387 :     
; 3388 : #if( RES_DEBUG_VERSION )
; 3389 : 
; 3390 :     if( GLOBAL_SEARCH_INDEX >= (MAX_DIRECTORIES-1)) {

	cmp	DWORD PTR _GLOBAL_SEARCH_INDEX, 249	; 000000f9H
	jl	SHORT $LN38@ResAddPath

; 3391 :           assert(!"Exceeded MAX_DIRECTORIES as defined in omni.h");
; 3392 : //        SAY_ERROR( RES_ERR_TOO_MANY_DIRECTORIES, "ResAddPath" );
; 3393 :         return( FALSE );

	xor	eax, eax
	jmp	$LN42@ResAddPath
$LN38@ResAddPath:

; 3394 :     }
; 3395 : #endif
; 3396 : 
; 3397 : 
; 3398 : 
; 3399 : 
; 3400 :     /* The hash index must be determined from hashing the full pathname */
; 3401 : 
; 3402 :     res_fullpath( tmp_path, path, (_MAX_PATH - 2));  /* non-portable */

	push	258					; 00000102H
	mov	edx, DWORD PTR _path$[ebp]
	push	edx
	lea	eax, DWORD PTR _tmp_path$[ebp]
	push	eax
	call	_res_fullpath
	add	esp, 12					; 0000000cH

; 3403 : 
; 3404 : #if( !RES_USE_FLAT_MODEL )
; 3405 :     entry = hash_find( tmp_path, GLOBAL_HASH_TABLE );

	mov	ecx, DWORD PTR _GLOBAL_HASH_TABLE
	push	ecx
	lea	edx, DWORD PTR _tmp_path$[ebp]
	push	edx
	call	_hash_find
	add	esp, 8
	mov	DWORD PTR _entry$[ebp], eax

; 3406 : 
; 3407 :     if( entry )

	cmp	DWORD PTR _entry$[ebp], 0
	je	SHORT $LN37@ResAddPath

; 3408 :         refresh = TRUE;

	mov	DWORD PTR _refresh$[ebp], 1
$LN37@ResAddPath:

; 3409 : #endif
; 3410 : 
; 3411 :     /* we need a trailing backslash */
; 3412 : 
; 3413 :     length = strlen( tmp_path );

	lea	eax, DWORD PTR _tmp_path$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _length$[ebp], eax

; 3414 : 
; 3415 :     if( tmp_path[ length-1 ] != ASCII_BACKSLASH ) {

	mov	ecx, DWORD PTR _length$[ebp]
	movsx	edx, BYTE PTR _tmp_path$[ebp+ecx-1]
	cmp	edx, 92					; 0000005cH
	je	SHORT $LN36@ResAddPath

; 3416 :         tmp_path[ length++ ] = ASCII_BACKSLASH;

	mov	eax, DWORD PTR _length$[ebp]
	mov	BYTE PTR _tmp_path$[ebp+eax], 92	; 0000005cH
	mov	ecx, DWORD PTR _length$[ebp]
	add	ecx, 1
	mov	DWORD PTR _length$[ebp], ecx

; 3417 :         tmp_path[ length ] = '\0';

	mov	edx, DWORD PTR _length$[ebp]
	mov	DWORD PTR $T2[ebp], edx
	cmp	DWORD PTR $T2[ebp], 260			; 00000104H
	jae	SHORT $LN44@ResAddPath
	jmp	SHORT $LN45@ResAddPath
$LN44@ResAddPath:
	call	___report_rangecheckfailure
$LN45@ResAddPath:
	mov	eax, DWORD PTR $T2[ebp]
	mov	BYTE PTR _tmp_path$[ebp+eax], 0
$LN36@ResAddPath:

; 3418 :     }
; 3419 : 
; 3420 :     /* the size of the hash table for this directory will be defined by
; 3421 :        the macro HASH_OPTIMAL_RATIO times the number of files in the 
; 3422 :        directory (a small price to pay) */
; 3423 : 
; 3424 :     filecount = count = ResCountDirectory( tmp_path, &file_data);

	lea	ecx, DWORD PTR _file_data$[ebp]
	push	ecx
	lea	edx, DWORD PTR _tmp_path$[ebp]
	push	edx
	call	_ResCountDirectory
	add	esp, 8
	mov	DWORD PTR _count$[ebp], eax
	mov	eax, DWORD PTR _count$[ebp]
	mov	DWORD PTR _filecount$[ebp], eax

; 3425 :     if(count == -1)

	cmp	DWORD PTR _count$[ebp], -1
	jne	SHORT $LN35@ResAddPath

; 3426 :       {
; 3427 : 		#ifdef USE_SH_POOLS
; 3428 :         if(file_data) MemFreePtr(file_data);
; 3429 : 		#else
; 3430 :         if(file_data) MemFree(file_data);

	cmp	DWORD PTR _file_data$[ebp], 0
	je	SHORT $LN34@ResAddPath
	mov	ecx, DWORD PTR _file_data$[ebp]
	push	ecx
	call	_free
	add	esp, 4
$LN34@ResAddPath:

; 3431 : 		#endif
; 3432 :         return FALSE;

	xor	eax, eax
	jmp	$LN42@ResAddPath
$LN35@ResAddPath:

; 3433 :       }
; 3434 : 
; 3435 :     count = (int)((float)count * (float)(HASH_OPTIMAL_RATIO));

	cvtsi2ss xmm0, DWORD PTR _count$[ebp]
	mulss	xmm0, DWORD PTR __real@3f933333
	cvttss2si edx, xmm0
	mov	DWORD PTR _count$[ebp], edx

; 3436 : 
; 3437 :     count = MAX( count, 10 ); /* minimum of 10 entries set aside for a directory */

	cmp	DWORD PTR _count$[ebp], 10		; 0000000aH
	jle	SHORT $LN46@ResAddPath
	mov	eax, DWORD PTR _count$[ebp]
	mov	DWORD PTR tv147[ebp], eax
	jmp	SHORT $LN47@ResAddPath
$LN46@ResAddPath:
	mov	DWORD PTR tv147[ebp], 10		; 0000000aH
$LN47@ResAddPath:
	mov	ecx, DWORD PTR tv147[ebp]
	mov	DWORD PTR _count$[ebp], ecx

; 3438 : 
; 3439 :     strcpy( buffer, tmp_path );

	lea	edx, DWORD PTR _tmp_path$[ebp]
	push	edx
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 3440 : 
; 3441 :     length = strlen( tmp_path );    /* append wildcard to the filename (*.*) */

	lea	ecx, DWORD PTR _tmp_path$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _length$[ebp], eax

; 3442 :     tmp_path[ length++ ] = ASCII_ASTERISK;

	mov	edx, DWORD PTR _length$[ebp]
	mov	BYTE PTR _tmp_path$[ebp+edx], 42	; 0000002aH
	mov	eax, DWORD PTR _length$[ebp]
	add	eax, 1
	mov	DWORD PTR _length$[ebp], eax

; 3443 :     tmp_path[ length++ ] = ASCII_PERIOD;

	mov	ecx, DWORD PTR _length$[ebp]
	mov	BYTE PTR _tmp_path$[ebp+ecx], 46	; 0000002eH
	mov	edx, DWORD PTR _length$[ebp]
	add	edx, 1
	mov	DWORD PTR _length$[ebp], edx

; 3444 :     tmp_path[ length++ ] = ASCII_ASTERISK;

	mov	eax, DWORD PTR _length$[ebp]
	mov	BYTE PTR _tmp_path$[ebp+eax], 42	; 0000002aH
	mov	ecx, DWORD PTR _length$[ebp]
	add	ecx, 1
	mov	DWORD PTR _length$[ebp], ecx

; 3445 :     tmp_path[ length ]   = '\0';

	mov	edx, DWORD PTR _length$[ebp]
	mov	DWORD PTR $T3[ebp], edx
	cmp	DWORD PTR $T3[ebp], 260			; 00000104H
	jae	SHORT $LN48@ResAddPath
	jmp	SHORT $LN49@ResAddPath
$LN48@ResAddPath:
	call	___report_rangecheckfailure
$LN49@ResAddPath:
	mov	eax, DWORD PTR $T3[ebp]
	mov	BYTE PTR _tmp_path$[ebp+eax], 0

; 3446 : 
; 3447 : #if( !RES_USE_FLAT_MODEL )
; 3448 : 
; 3449 :     /* for the hierarchical model, we create a new hash table for the directory to
; 3450 :        be added.  Then we insert a hashed entry into the GLOBAL_HASH_TABLE which
; 3451 :        points to this new table. */
; 3452 : 
; 3453 : #if 1
; 3454 :     memcpy(&data,file_data,sizeof(struct _finddata_t));

	push	296					; 00000128H
	mov	ecx, DWORD PTR _file_data$[ebp]
	push	ecx
	lea	edx, DWORD PTR _data$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 3455 : #else
; 3456 :     directory = _findfirst( tmp_path, &data );      /* make sure it exists                              */
; 3457 :     if( directory == -1 ) {
; 3458 :         SAY_ERROR( RES_ERR_PATH_NOT_FOUND, tmp_path );
; 3459 :         return( FALSE );
; 3460 :     }
; 3461 :     _findclose( directory );
; 3462 :     
; 3463 : #endif
; 3464 : 
; 3465 :     if( !entry || !entry -> dir )

	cmp	DWORD PTR _entry$[ebp], 0
	je	SHORT $LN32@ResAddPath
	mov	eax, DWORD PTR _entry$[ebp]
	cmp	DWORD PTR [eax+40], 0
	jne	SHORT $LN33@ResAddPath
$LN32@ResAddPath:

; 3466 :         local_table = hash_create( count, buffer ); /* create a new table                               */

	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _count$[ebp]
	push	edx
	call	_hash_create
	add	esp, 8
	mov	DWORD PTR _local_table$[ebp], eax

; 3467 :     else

	jmp	SHORT $LN30@ResAddPath
$LN33@ResAddPath:

; 3468 :         if( entry )

	cmp	DWORD PTR _entry$[ebp], 0
	je	SHORT $LN30@ResAddPath

; 3469 :             local_table = entry -> dir;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR _local_table$[ebp], ecx
$LN30@ResAddPath:

; 3470 :     
; 3471 :     if( !local_table )

	cmp	DWORD PTR _local_table$[ebp], 0
	jne	SHORT $LN29@ResAddPath

; 3472 :         return( FALSE );

	xor	eax, eax
	jmp	$LN42@ResAddPath
$LN29@ResAddPath:

; 3473 : 
; 3474 :     strcpy( data.name, buffer );                    /* insert a dummy entry into the global hash table  */

	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	lea	eax, DWORD PTR _data$[ebp+36]
	push	eax
	call	_strcpy
	add	esp, 8

; 3475 :     data.attrib = _A_SUBDIR | (unsigned int)FORCE_BIT;

	mov	DWORD PTR _data$[ebp], -2147483632	; 80000010H

; 3476 :     data.time_create = 0;

	xorpd	xmm0, xmm0
	movlpd	QWORD PTR _data$[ebp+8], xmm0

; 3477 :     data.time_access = 0;

	xorpd	xmm0, xmm0
	movlpd	QWORD PTR _data$[ebp+16], xmm0

; 3478 :     data.size = 0;

	mov	DWORD PTR _data$[ebp+32], 0

; 3479 : 
; 3480 :     if( !entry )

	cmp	DWORD PTR _entry$[ebp], 0
	jne	SHORT $LN28@ResAddPath

; 3481 :         entry = hash_add( &data, GLOBAL_HASH_TABLE );

	mov	ecx, DWORD PTR _GLOBAL_HASH_TABLE
	push	ecx
	lea	edx, DWORD PTR _data$[ebp]
	push	edx
	call	_hash_add
	add	esp, 8
	mov	DWORD PTR _entry$[ebp], eax
$LN28@ResAddPath:

; 3482 : 
; 3483 :     if( !entry )

	cmp	DWORD PTR _entry$[ebp], 0
	jne	SHORT $LN27@ResAddPath

; 3484 :         return( FALSE );

	xor	eax, eax
	jmp	$LN42@ResAddPath
$LN27@ResAddPath:

; 3485 : 
; 3486 :     if( !entry -> dir )

	mov	eax, DWORD PTR _entry$[ebp]
	cmp	DWORD PTR [eax+40], 0
	jne	SHORT $LN26@ResAddPath

; 3487 :         entry -> dir = local_table;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR _local_table$[ebp]
	mov	DWORD PTR [ecx+40], edx
$LN26@ResAddPath:

; 3488 : 
; 3489 :     if( !refresh ) {

	cmp	DWORD PTR _refresh$[ebp], 0
	jne	$LN25@ResAddPath

; 3490 :         entry -> offset = 0;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+4], 0

; 3491 :         entry -> csize  = 0;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 3492 :         entry -> method = 0;

	xor	edx, edx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	WORD PTR [eax+16], dx

; 3493 :         entry -> archive = -1;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+24], -1

; 3494 :         entry -> file_position = -1;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+20], -1

; 3495 :         entry -> volume = (char)(toupper(tmp_path[0]) - 'A');

	mov	eax, 1
	imul	eax, 0
	movsx	ecx, BYTE PTR _tmp_path$[ebp+eax]
	push	ecx
	call	_toupper
	add	esp, 4
	sub	eax, 65					; 00000041H
	mov	edx, DWORD PTR _entry$[ebp]
	mov	BYTE PTR [edx+36], al

; 3496 :         entry -> directory = GLOBAL_SEARCH_INDEX;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR _GLOBAL_SEARCH_INDEX
	mov	DWORD PTR [eax+32], ecx

; 3497 : 
; 3498 :         GLOBAL_PATH_LIST = LIST_APPEND( GLOBAL_PATH_LIST, local_table );

	mov	edx, DWORD PTR _local_table$[ebp]
	push	edx
	mov	eax, DWORD PTR _GLOBAL_PATH_LIST
	push	eax
	call	_ListAppend
	add	esp, 8
	mov	DWORD PTR _GLOBAL_PATH_LIST, eax
$LN25@ResAddPath:

; 3499 :     }
; 3500 : #else
; 3501 :     local_table = GLOBAL_HASH_TABLE;                /* flat mode - all entries go into the root         */
; 3502 : #endif  /* !RES_USE_FLAT_MODEL */
; 3503 : 
; 3504 :     /* enter the files into the local hash table, keeping count of the total 
; 3505 :        number of entries. */
; 3506 : 
; 3507 :     done = 0;

	mov	DWORD PTR _done$[ebp], 0

; 3508 : 
; 3509 :     vol_was = (char)(toupper(tmp_path[0]) - 'A');

	mov	ecx, 1
	imul	ecx, 0
	movsx	edx, BYTE PTR _tmp_path$[ebp+ecx]
	push	edx
	call	_toupper
	add	esp, 4
	sub	eax, 65					; 00000041H
	mov	BYTE PTR _vol_was$[ebp], al

; 3510 : 
; 3511 : 
; 3512 : 
; 3513 :     if( !refresh ) {

	cmp	DWORD PTR _refresh$[ebp], 0
	jne	SHORT $LN24@ResAddPath

; 3514 :         dir_was = GLOBAL_SEARCH_INDEX;

	mov	eax, DWORD PTR _GLOBAL_SEARCH_INDEX
	mov	DWORD PTR _dir_was$[ebp], eax

; 3515 : 
; 3516 :         GLOBAL_SEARCH_PATH[ GLOBAL_SEARCH_INDEX++ ] = MemStrDup( buffer );

	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_strdup
	add	esp, 4
	mov	edx, DWORD PTR _GLOBAL_SEARCH_INDEX
	mov	DWORD PTR _GLOBAL_SEARCH_PATH[edx*4], eax
	mov	eax, DWORD PTR _GLOBAL_SEARCH_INDEX
	add	eax, 1
	mov	DWORD PTR _GLOBAL_SEARCH_INDEX, eax

; 3517 :         
; 3518 :         strcpy( GLOBAL_CURRENT_PATH, buffer );

	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	push	OFFSET _GLOBAL_CURRENT_PATH
	call	_strcpy
	add	esp, 8

; 3519 :     }
; 3520 :     else 

	jmp	SHORT $LN23@ResAddPath
$LN24@ResAddPath:

; 3521 :         dir_was = get_dir_index( path );

	mov	edx, DWORD PTR _path$[ebp]
	push	edx
	call	_get_dir_index
	add	esp, 4
	mov	DWORD PTR _dir_was$[ebp], eax
$LN23@ResAddPath:

; 3522 :     
; 3523 : //    if( _chdir( buffer ))        // GFG MAY 05 / 98
; 3524 : //        SAY_ERROR( errno, "ResAddPath" );
; 3525 : 
; 3526 : #if 1
; 3527 :     memcpy(&data,file_data,sizeof(struct _finddata_t));

	push	296					; 00000128H
	mov	eax, DWORD PTR _file_data$[ebp]
	push	eax
	lea	ecx, DWORD PTR _data$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 3528 :     directory = 1;

	mov	DWORD PTR _directory$[ebp], 1

; 3529 :     filenum = 0;

	mov	DWORD PTR _filenum$[ebp], 0

; 3530 : #else
; 3531 :     directory = _findfirst( tmp_path, &data );
; 3532 : #endif
; 3533 :     if( directory != -1 ) {

	cmp	DWORD PTR _directory$[ebp], -1
	je	$LN20@ResAddPath
$LN50@ResAddPath:

; 3534 :         /* integral volume id & path index */
; 3535 : 
; 3536 :         while( !done ) {

	cmp	DWORD PTR _done$[ebp], 0
	jne	$LN20@ResAddPath

; 3537 : 
; 3538 :             /* don't add directories to the hash table,
; 3539 :                ResTreeAdd is used to recurse directories */
; 3540 : 
; 3541 :             if( !(data.attrib & _A_SUBDIR)) {

	mov	edx, DWORD PTR _data$[ebp]
	and	edx, 16					; 00000010H
	jne	$LN19@ResAddPath

; 3542 : 
; 3543 :                    /* Reject empty files before calling hash_add.  This
; 3544 :                       allows file creation to still be able to use hash_add. */
; 3545 : 
; 3546 : #if( RES_REJECT_EMPTY_FILES )
; 3547 :                    if( data.size == 0 ) {
; 3548 :                        IF_LOG( LOG( "empty file rejected: %s\n", data.name ));
; 3549 : #if 1 
; 3550 :                        if(filenum < filecount-1)
; 3551 :                        {
; 3552 :                            filenum++;
; 3553 :                            memcpy(&data,file_data+filenum,sizeof(struct _finddata_t));
; 3554 :                        }
; 3555 :                        else
; 3556 :                            done = filenum;
; 3557 : 
; 3558 : #else
; 3559 :                        done = _findnext( directory, &data );
; 3560 : #endif
; 3561 :                        continue;
; 3562 :                    }
; 3563 : #endif /* !RES_ALLOW_EMPTY_FILES */
; 3564 : 
; 3565 :                if( refresh ) {

	cmp	DWORD PTR _refresh$[ebp], 0
	je	$LN18@ResAddPath

; 3566 :                    if( hash_find( data.name, local_table )) {

	mov	eax, DWORD PTR _local_table$[ebp]
	push	eax
	lea	ecx, DWORD PTR _data$[ebp+36]
	push	ecx
	call	_hash_find
	add	esp, 8
	test	eax, eax
	je	SHORT $LN17@ResAddPath

; 3567 : #if 1
; 3568 :                        if(filenum < filecount-1)

	mov	edx, DWORD PTR _filecount$[ebp]
	sub	edx, 1
	cmp	DWORD PTR _filenum$[ebp], edx
	jge	SHORT $LN16@ResAddPath

; 3569 :                        {
; 3570 :                            filenum++;

	mov	eax, DWORD PTR _filenum$[ebp]
	add	eax, 1
	mov	DWORD PTR _filenum$[ebp], eax

; 3571 :                            memcpy(&data,file_data+filenum,sizeof(struct _finddata_t));

	push	296					; 00000128H
	mov	ecx, DWORD PTR _filenum$[ebp]
	imul	ecx, 296				; 00000128H
	add	ecx, DWORD PTR _file_data$[ebp]
	push	ecx
	lea	edx, DWORD PTR _data$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 3572 :                        }
; 3573 :                        else

	jmp	SHORT $LN15@ResAddPath
$LN16@ResAddPath:

; 3574 :                            done = filenum;

	mov	eax, DWORD PTR _filenum$[ebp]
	mov	DWORD PTR _done$[ebp], eax
$LN15@ResAddPath:

; 3575 : 
; 3576 : #else
; 3577 : 
; 3578 :                        done = _findnext( directory, &data );
; 3579 : #endif
; 3580 :                        continue;

	jmp	$LN50@ResAddPath
$LN17@ResAddPath:

; 3581 :                    }
; 3582 : 
; 3583 :                     entry = hash_find( data.name, local_table );

	mov	ecx, DWORD PTR _local_table$[ebp]
	push	ecx
	lea	edx, DWORD PTR _data$[ebp+36]
	push	edx
	call	_hash_find
	add	esp, 8
	mov	DWORD PTR _entry$[ebp], eax

; 3584 : 
; 3585 :                    if( !entry )

	cmp	DWORD PTR _entry$[ebp], 0
	jne	SHORT $LN14@ResAddPath

; 3586 :                       entry = hash_add( &data, local_table );

	mov	eax, DWORD PTR _local_table$[ebp]
	push	eax
	lea	ecx, DWORD PTR _data$[ebp]
	push	ecx
	call	_hash_add
	add	esp, 8
	mov	DWORD PTR _entry$[ebp], eax
$LN14@ResAddPath:

; 3587 : 
; 3588 :                    if( entry ) {

	cmp	DWORD PTR _entry$[ebp], 0
	je	SHORT $LN13@ResAddPath

; 3589 :                       entry -> size = data.size;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR _data$[ebp+32]
	mov	DWORD PTR [edx+8], eax

; 3590 :                       entry -> attrib = data.attrib | FORCE_BIT;

	mov	ecx, DWORD PTR _data$[ebp]
	or	ecx, -2147483648			; 80000000H
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+28], ecx
$LN13@ResAddPath:

; 3591 :                    }
; 3592 :                } 
; 3593 :                else {

	jmp	SHORT $LN12@ResAddPath
$LN18@ResAddPath:

; 3594 :                    entry = hash_add( &data, local_table );

	mov	eax, DWORD PTR _local_table$[ebp]
	push	eax
	lea	ecx, DWORD PTR _data$[ebp]
	push	ecx
	call	_hash_add
	add	esp, 8
	mov	DWORD PTR _entry$[ebp], eax
$LN12@ResAddPath:

; 3595 :                }
; 3596 : 
; 3597 : 
; 3598 :                if( entry ) { /* empty files may be rejected from hash_add */

	cmp	DWORD PTR _entry$[ebp], 0
	je	SHORT $LN11@ResAddPath

; 3599 : 
; 3600 :                     IF_LOG( LOG( "add: %s\n", entry -> name ));
; 3601 : 
; 3602 :                     entry -> offset = 0;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+4], 0

; 3603 :                     entry -> csize  = 0;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+12], 0

; 3604 :                     entry -> method = 0;

	xor	ecx, ecx
	mov	edx, DWORD PTR _entry$[ebp]
	mov	WORD PTR [edx+16], cx

; 3605 :                     entry -> volume = vol_was;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	cl, BYTE PTR _vol_was$[ebp]
	mov	BYTE PTR [eax+36], cl

; 3606 :                     entry -> directory = dir_was;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR _dir_was$[ebp]
	mov	DWORD PTR [edx+32], eax

; 3607 :                     entry -> archive = -1;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+24], -1

; 3608 :                     entry -> file_position = -1;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+20], -1
$LN11@ResAddPath:

; 3609 :                }
; 3610 :             }
; 3611 :             else {    /* if we want to add an entire directory tree, recurse is TRUE */

	jmp	$LN4@ResAddPath
$LN19@ResAddPath:

; 3612 :                 if( recurse && !full_yet ) {

	cmp	DWORD PTR _recurse$[ebp], 0
	je	$LN4@ResAddPath
	cmp	DWORD PTR _full_yet$[ebp], 0
	jne	$LN4@ResAddPath

; 3613 :                     if( strcmp( data.name, "." ) && strcmp( data.name, ".." )) {

	push	OFFSET ??_C@_01LFCBOECM@?4?$AA@
	lea	eax, DWORD PTR _data$[ebp+36]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	je	$LN4@ResAddPath
	push	OFFSET ??_C@_02DJGKEECL@?4?4?$AA@
	lea	ecx, DWORD PTR _data$[ebp+36]
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	je	$LN4@ResAddPath

; 3614 :                         int idx, ln;
; 3615 : 
; 3616 :                         ln = strlen( tmp_path );

	lea	edx, DWORD PTR _tmp_path$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _ln$1[ebp], eax

; 3617 : 
; 3618 :                         for( idx=ln-1; idx, tmp_path[idx] != ASCII_BACKSLASH; idx-- ) ;

	mov	eax, DWORD PTR _ln$1[ebp]
	sub	eax, 1
	mov	DWORD PTR _idx$4[ebp], eax
	jmp	SHORT $LN7@ResAddPath
$LN6@ResAddPath:
	mov	ecx, DWORD PTR _idx$4[ebp]
	sub	ecx, 1
	mov	DWORD PTR _idx$4[ebp], ecx
$LN7@ResAddPath:
	mov	edx, DWORD PTR _idx$4[ebp]
	movsx	eax, BYTE PTR _tmp_path$[ebp+edx]
	cmp	eax, 92					; 0000005cH
	je	SHORT $LN5@ResAddPath
	jmp	SHORT $LN6@ResAddPath
$LN5@ResAddPath:

; 3619 : 
; 3620 :                         strncpy( buffer, tmp_path, idx );

	mov	ecx, DWORD PTR _idx$4[ebp]
	push	ecx
	lea	edx, DWORD PTR _tmp_path$[ebp]
	push	edx
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_strncpy
	add	esp, 12					; 0000000cH

; 3621 :                         sprintf( &buffer[idx], "\\%s\\", data.name );

	lea	ecx, DWORD PTR _data$[ebp+36]
	push	ecx
	push	OFFSET ??_C@_04BDGLLBHF@?2?$CFs?2?$AA@
	mov	edx, DWORD PTR _idx$4[ebp]
	lea	eax, DWORD PTR _buffer$[ebp+edx]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 3622 : 
; 3623 :                         if( !ResAddPath( buffer, TRUE )) { /* Recursively call this function. */

	push	1
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_ResAddPath
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN4@ResAddPath

; 3624 :                             full_yet = TRUE;               /* We want to continue adding this directory, and THEN */

	mov	DWORD PTR _full_yet$[ebp], 1

; 3625 :                             retval = FALSE;                /* trickle up a return flag.                           */

	mov	DWORD PTR _retval$[ebp], 0
$LN4@ResAddPath:

; 3626 :                         }
; 3627 :                     }
; 3628 :                 }
; 3629 :             }
; 3630 : #if 1
; 3631 :                        if(filenum < filecount-1)

	mov	edx, DWORD PTR _filecount$[ebp]
	sub	edx, 1
	cmp	DWORD PTR _filenum$[ebp], edx
	jge	SHORT $LN3@ResAddPath

; 3632 :                        {
; 3633 :                            filenum++;

	mov	eax, DWORD PTR _filenum$[ebp]
	add	eax, 1
	mov	DWORD PTR _filenum$[ebp], eax

; 3634 :                            memcpy(&data,file_data+filenum,sizeof(struct _finddata_t));

	push	296					; 00000128H
	mov	ecx, DWORD PTR _filenum$[ebp]
	imul	ecx, 296				; 00000128H
	add	ecx, DWORD PTR _file_data$[ebp]
	push	ecx
	lea	edx, DWORD PTR _data$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 3635 :                        }
; 3636 :                        else

	jmp	SHORT $LN2@ResAddPath
$LN3@ResAddPath:

; 3637 :                            done = filenum;

	mov	eax, DWORD PTR _filenum$[ebp]
	mov	DWORD PTR _done$[ebp], eax
$LN2@ResAddPath:

; 3638 : 
; 3639 : #else
; 3640 : 
; 3641 :             done = _findnext( directory, &data );
; 3642 : #endif
; 3643 : 
; 3644 :         }

	jmp	$LN50@ResAddPath
$LN20@ResAddPath:

; 3645 : 
; 3646 : #if 0        
; 3647 :         _findclose( directory ); /* done! */
; 3648 : #endif
; 3649 : 
; 3650 :     }
; 3651 : 
; 3652 :     sort_path();

	call	_sort_path

; 3653 : 
; 3654 :     if(file_data)

	cmp	DWORD PTR _file_data$[ebp], 0
	je	SHORT $LN1@ResAddPath

; 3655 :     {
; 3656 : 		#ifdef USE_SH_POOLS
; 3657 :         MemFreePtr(file_data);
; 3658 : 		#else
; 3659 :         MemFree(file_data);

	mov	ecx, DWORD PTR _file_data$[ebp]
	push	ecx
	call	_free
	add	esp, 4

; 3660 : 		#endif
; 3661 :         file_data = NULL;

	mov	DWORD PTR _file_data$[ebp], 0
$LN1@ResAddPath:

; 3662 :     }
; 3663 : 
; 3664 :     /* Restore original drive.*/  // GFG MAY 05 /98
; 3665 :     _chdrive( currentDrive );

	mov	edx, DWORD PTR _currentDrive$[ebp]
	push	edx
	call	__chdrive
	add	esp, 4

; 3666 :     _chdir  ( currentPath  );

	lea	eax, DWORD PTR _currentPath$[ebp]
	push	eax
	call	__chdir
	add	esp, 4

; 3667 : 
; 3668 : 
; 3669 :     return( retval );

	mov	eax, DWORD PTR _retval$[ebp]
$LN42@ResAddPath:

; 3670 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_ResAddPath ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_list$ = -4						; size = 4
_path$ = 8						; size = 4
_recurse$ = 12						; size = 4
_ResCreatePath PROC

; 3262 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 3263 :     LIST * list;
; 3264 : 
; 3265 : #if( RES_DEBUG_VERSON )
; 3266 :     if( !path ) {
; 3267 :         SAY_ERROR( RES_ERR_INCORRECT_PARAMETER, "ResCreatePath" );
; 3268 :         return( FALSE );
; 3269 :     }
; 3270 : #endif /* RES_DEBUG_VERSON */
; 3271 : #if (RES_MULTITHREAD)
; 3272 : 	REQUEST_LOCK(GLOCK);

	push	-1
	mov	eax, DWORD PTR _GLOCK
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8

; 3273 : #endif
; 3274 : 
; 3275 :     IF_LOG( LOG( "create path: %s\n", path ));
; 3276 : 
; 3277 :     if( GLOBAL_HASH_TABLE )

	cmp	DWORD PTR _GLOBAL_HASH_TABLE, 0
	je	SHORT $LN6@ResCreateP

; 3278 :         hash_destroy( GLOBAL_HASH_TABLE );

	mov	ecx, DWORD PTR _GLOBAL_HASH_TABLE
	push	ecx
	call	_hash_destroy
	add	esp, 4
$LN6@ResCreateP:

; 3279 : 
; 3280 :     if( GLOBAL_PATH_LIST ) {

	cmp	DWORD PTR _GLOBAL_PATH_LIST, 0
	je	SHORT $LN5@ResCreateP

; 3281 :         for( list = GLOBAL_PATH_LIST; list; list = list -> next ) {

	mov	edx, DWORD PTR _GLOBAL_PATH_LIST
	mov	DWORD PTR _list$[ebp], edx
	jmp	SHORT $LN4@ResCreateP
$LN3@ResCreateP:
	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _list$[ebp], ecx
$LN4@ResCreateP:
	cmp	DWORD PTR _list$[ebp], 0
	je	SHORT $LN2@ResCreateP

; 3282 : #if( RES_USE_FLAT_MODEL )
; 3283 : 			#ifdef USE_SH_POOLS
; 3284 :             MemFreePtr( list -> node );
; 3285 : 			#else
; 3286 :             MemFree( list -> node );
; 3287 : 			#endif
; 3288 : #else
; 3289 :             hash_destroy( (HASH_TABLE *)list -> node );

	mov	edx, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_hash_destroy
	add	esp, 4

; 3290 : #endif /* RES_USE_FLAT_MODEL */     
; 3291 :         }

	jmp	SHORT $LN3@ResCreateP
$LN2@ResCreateP:

; 3292 : 
; 3293 :         LIST_DESTROY( GLOBAL_PATH_LIST, NULL );

	push	0
	mov	ecx, DWORD PTR _GLOBAL_PATH_LIST
	push	ecx
	call	_ListDestroy
	add	esp, 8
$LN5@ResCreateP:

; 3294 :     }
; 3295 : 
; 3296 :     GLOBAL_PATH_LIST = NULL;

	mov	DWORD PTR _GLOBAL_PATH_LIST, 0

; 3297 : 
; 3298 :     GLOBAL_HASH_TABLE = hash_create( HASH_TABLE_SIZE, "Global" );

	push	OFFSET ??_C@_06JGBJPOPP@Global?$AA@
	push	29					; 0000001dH
	call	_hash_create
	add	esp, 8
	mov	DWORD PTR _GLOBAL_HASH_TABLE, eax

; 3299 : #if (RES_MULTITHREAD)
; 3300 : 	RELEASE_LOCK(GLOCK);

	mov	edx, DWORD PTR _GLOCK
	push	edx
	call	DWORD PTR __imp__ReleaseMutex@4

; 3301 : #endif
; 3302 : 
; 3303 :     if( !GLOBAL_HASH_TABLE )

	cmp	DWORD PTR _GLOBAL_HASH_TABLE, 0
	jne	SHORT $LN1@ResCreateP

; 3304 :         return( FALSE );

	xor	eax, eax
	jmp	SHORT $LN7@ResCreateP
$LN1@ResCreateP:

; 3305 : 
; 3306 :     return( ResAddPath( path, recurse ));

	mov	eax, DWORD PTR _recurse$[ebp]
	push	eax
	mov	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	_ResAddPath
	add	esp, 8
$LN7@ResCreateP:

; 3307 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ResCreatePath ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
tv78 = -12						; size = 4
_check$ = -8						; size = 4
_list$ = -4						; size = 4
_idx$ = 8						; size = 4
_buffer$ = 12						; size = 4
_ResGetPath PROC

; 2897 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 2898 :     LIST * list;
; 2899 :     char * check = NULL;

	mov	DWORD PTR _check$[ebp], 0

; 2900 : 
; 2901 : #if( RES_DEBUG_PARAMS )
; 2902 :     if( !buffer || idx < 0 ) {

	cmp	DWORD PTR _buffer$[ebp], 0
	je	SHORT $LN3@ResGetPath
	cmp	DWORD PTR _idx$[ebp], 0
	jge	SHORT $LN4@ResGetPath
$LN3@ResGetPath:

; 2903 :         return( 0 );

	xor	eax, eax
	jmp	SHORT $LN5@ResGetPath
$LN4@ResGetPath:

; 2904 :     }
; 2905 : #endif /* RES_DEBUG_PARAMS */
; 2906 : 
; 2907 :     list = LIST_NTH( GLOBAL_PATH_LIST, idx );

	mov	eax, DWORD PTR _idx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _GLOBAL_PATH_LIST
	push	ecx
	call	_ListNth
	add	esp, 8
	mov	DWORD PTR _list$[ebp], eax

; 2908 : 
; 2909 :     if( list ) 

	cmp	DWORD PTR _list$[ebp], 0
	je	SHORT $LN2@ResGetPath

; 2910 :         check = strcpy( buffer, ((HASH_TABLE *)(list -> node)) -> name );

	mov	edx, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8
	mov	DWORD PTR _check$[ebp], eax

; 2911 :     else

	jmp	SHORT $LN1@ResGetPath
$LN2@ResGetPath:

; 2912 :         *buffer = 0x00;

	mov	eax, DWORD PTR _buffer$[ebp]
	mov	BYTE PTR [eax], 0
$LN1@ResGetPath:

; 2913 : 
; 2914 :     return( check ? strlen(buffer) : 0 );

	cmp	DWORD PTR _check$[ebp], 0
	je	SHORT $LN7@ResGetPath
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR tv78[ebp], eax
	jmp	SHORT $LN8@ResGetPath
$LN7@ResGetPath:
	mov	DWORD PTR tv78[ebp], 0
$LN8@ResGetPath:
	mov	eax, DWORD PTR tv78[ebp]
$LN5@ResGetPath:

; 2915 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ResGetPath ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
$T1 = -284						; size = 4
$T2 = -280						; size = 4
$T3 = -276						; size = 4
_ptr$ = -272						; size = 4
_len$ = -268						; size = 4
_tmp$ = -264						; size = 260
__$ArrayPad$ = -4					; size = 4
_index$ = 8						; size = 4
_path_in$ = 12						; size = 4
_path_out$ = 16						; size = 4
_ResBuildPathname PROC

; 3701 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 284				; 0000011cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 3702 :     char tmp[ _MAX_PATH ]={0};

	mov	BYTE PTR _tmp$[ebp], 0
	push	259					; 00000103H
	push	0
	lea	eax, DWORD PTR _tmp$[ebp+1]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 3703 :     int  len=0;

	mov	DWORD PTR _len$[ebp], 0

; 3704 :     char * ptr=NULL;

	mov	DWORD PTR _ptr$[ebp], 0

; 3705 :     
; 3706 : #if( RES_DEBUG_PARAMS )
; 3707 :     if((index < RES_DIR_NONE)  ||
; 3708 :        (index >= RES_DIR_LAST) ||
; 3709 :        ( !path_out )) 

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN13@ResBuildPa
	cmp	DWORD PTR _index$[ebp], 17		; 00000011H
	jge	SHORT $LN13@ResBuildPa
	cmp	DWORD PTR _path_out$[ebp], 0
	jne	SHORT $LN14@ResBuildPa
$LN13@ResBuildPa:

; 3710 :     {
; 3711 :         SAY_ERROR( RES_ERR_INCORRECT_PARAMETER, "ResBuildPathname" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	3711					; 00000e7fH
	push	OFFSET ??_C@_0BB@KDLJIOGI@ResBuildPathname?$AA@
	push	-4998					; ffffec7aH
	call	__say_error
	add	esp, 16					; 00000010H

; 3712 :         return( -1 );

	or	eax, -1
	jmp	$LN16@ResBuildPa
$LN14@ResBuildPa:

; 3713 :     }
; 3714 : 
; 3715 : 
; 3716 :     if(( index != RES_DIR_NONE ) && ( RES_PATH[ index ] == NULL )) {

	cmp	DWORD PTR _index$[ebp], 0
	je	SHORT $LN12@ResBuildPa
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	DWORD PTR _RES_PATH[ecx*4], 0
	jne	SHORT $LN12@ResBuildPa

; 3717 :         SAY_ERROR( RES_ERR_NO_SYSTEM_PATH, "ResBuildPathname" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	3717					; 00000e85H
	push	OFFSET ??_C@_0BB@KDLJIOGI@ResBuildPathname?$AA@
	push	-4981					; ffffec8bH
	call	__say_error
	add	esp, 16					; 00000010H

; 3718 :         *path_out = '\0';

	mov	edx, DWORD PTR _path_out$[ebp]
	mov	BYTE PTR [edx], 0

; 3719 :         return( -1 );

	or	eax, -1
	jmp	$LN16@ResBuildPa
$LN12@ResBuildPa:

; 3720 :     }
; 3721 :     
; 3722 : #endif /* RES_DEBUG_PARAMS */
; 3723 : 
; 3724 : 
; 3725 :     /* path_in is optional, but, of course without it you get the same 
; 3726 :        effect as strcpy( path_out, RES_PATH[ index ]) */
; 3727 : 
; 3728 :     if( path_in ) {

	cmp	DWORD PTR _path_in$[ebp], 0
	je	$LN11@ResBuildPa

; 3729 :         if( index != RES_DIR_NONE )                    /* since all these end with a slash  */

	cmp	DWORD PTR _index$[ebp], 0
	je	SHORT $LN10@ResBuildPa
$LN9@ResBuildPa:

; 3730 :             while( *path_in == ASCII_BACKSLASH )    /* trim leading backslashes             */

	mov	eax, DWORD PTR _path_in$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 92					; 0000005cH
	jne	SHORT $LN10@ResBuildPa

; 3731 :                 path_in++;

	mov	edx, DWORD PTR _path_in$[ebp]
	add	edx, 1
	mov	DWORD PTR _path_in$[ebp], edx
	jmp	SHORT $LN9@ResBuildPa
$LN10@ResBuildPa:

; 3732 : 
; 3733 :         strcpy( tmp, path_in );

	mov	eax, DWORD PTR _path_in$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tmp$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 3734 :         ptr = tmp;

	lea	edx, DWORD PTR _tmp$[ebp]
	mov	DWORD PTR _ptr$[ebp], edx
$LN7@ResBuildPa:

; 3735 : 
; 3736 :         while( *ptr ) {

	mov	eax, DWORD PTR _ptr$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN6@ResBuildPa

; 3737 :             if( *ptr == ASCII_FORESLASH )    /* substitute backslash for forward slashes */

	mov	edx, DWORD PTR _ptr$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 47					; 0000002fH
	jne	SHORT $LN5@ResBuildPa

; 3738 :                 *ptr = ASCII_BACKSLASH;

	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	BYTE PTR [ecx], 92			; 0000005cH
$LN5@ResBuildPa:

; 3739 : 
; 3740 :             *ptr = (char)(toupper( *ptr ));         /* force to upper case */

	mov	edx, DWORD PTR _ptr$[ebp]
	movsx	eax, BYTE PTR [edx]
	push	eax
	call	_toupper
	add	esp, 4
	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	BYTE PTR [ecx], al

; 3741 : 
; 3742 :             ptr++;

	mov	edx, DWORD PTR _ptr$[ebp]
	add	edx, 1
	mov	DWORD PTR _ptr$[ebp], edx

; 3743 :         }

	jmp	SHORT $LN7@ResBuildPa
$LN6@ResBuildPa:

; 3744 : 
; 3745 :         /* trailing backslash */
; 3746 : 
; 3747 :         len = strlen( tmp );

	lea	eax, DWORD PTR _tmp$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _len$[ebp], eax

; 3748 : 
; 3749 :         if( len && (tmp[len-1] != ASCII_BACKSLASH)) {

	cmp	DWORD PTR _len$[ebp], 0
	je	SHORT $LN4@ResBuildPa
	mov	ecx, DWORD PTR _len$[ebp]
	movsx	edx, BYTE PTR _tmp$[ebp+ecx-1]
	cmp	edx, 92					; 0000005cH
	je	SHORT $LN4@ResBuildPa

; 3750 :             tmp[len++] = ASCII_BACKSLASH;

	mov	eax, DWORD PTR _len$[ebp]
	mov	BYTE PTR _tmp$[ebp+eax], 92		; 0000005cH
	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, 1
	mov	DWORD PTR _len$[ebp], ecx

; 3751 :             tmp[len] = '\0';

	mov	edx, DWORD PTR _len$[ebp]
	mov	DWORD PTR $T3[ebp], edx
	cmp	DWORD PTR $T3[ebp], 260			; 00000104H
	jae	SHORT $LN17@ResBuildPa
	jmp	SHORT $LN18@ResBuildPa
$LN17@ResBuildPa:
	call	___report_rangecheckfailure
$LN18@ResBuildPa:
	mov	eax, DWORD PTR $T3[ebp]
	mov	BYTE PTR _tmp$[ebp+eax], 0
$LN4@ResBuildPa:

; 3752 :         }
; 3753 :     }
; 3754 :     else {

	jmp	SHORT $LN3@ResBuildPa
$LN11@ResBuildPa:

; 3755 :         tmp[0] = '\0';

	mov	ecx, 1
	imul	ecx, 0
	mov	DWORD PTR $T1[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 260			; 00000104H
	jae	SHORT $LN19@ResBuildPa
	jmp	SHORT $LN20@ResBuildPa
$LN19@ResBuildPa:
	call	___report_rangecheckfailure
$LN20@ResBuildPa:
	mov	edx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _tmp$[ebp+edx], 0

; 3756 :         tmp[1] = '\0';

	mov	DWORD PTR $T2[ebp], 1
	cmp	DWORD PTR $T2[ebp], 260			; 00000104H
	jae	SHORT $LN21@ResBuildPa
	jmp	SHORT $LN22@ResBuildPa
$LN21@ResBuildPa:
	call	___report_rangecheckfailure
$LN22@ResBuildPa:
	mov	eax, DWORD PTR $T2[ebp]
	mov	BYTE PTR _tmp$[ebp+eax], 0
$LN3@ResBuildPa:

; 3757 :     }
; 3758 : 
; 3759 : 
; 3760 :     /* if there is a system path index */
; 3761 : 
; 3762 :     if( index != RES_DIR_NONE )

	cmp	DWORD PTR _index$[ebp], 0
	je	SHORT $LN2@ResBuildPa

; 3763 :         sprintf( path_out, "%s%s", RES_PATH[ index ], tmp );

	lea	ecx, DWORD PTR _tmp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _RES_PATH[edx*4]
	push	eax
	push	OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
	mov	ecx, DWORD PTR _path_out$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 3764 :     else

	jmp	SHORT $LN1@ResBuildPa
$LN2@ResBuildPa:

; 3765 :         strcpy( path_out, tmp );

	lea	edx, DWORD PTR _tmp$[ebp]
	push	edx
	mov	eax, DWORD PTR _path_out$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8
$LN1@ResBuildPa:

; 3766 : 
; 3767 :     return( len );

	mov	eax, DWORD PTR _len$[ebp]
$LN16@ResBuildPa:

; 3768 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_ResBuildPathname ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_len$ = -8						; size = 4
_ptr$ = -4						; size = 4
_index$ = 8						; size = 4
_path$ = 12						; size = 4
_ResAssignPath PROC

; 3909 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3910 :     char * ptr;
; 3911 :     int len;
; 3912 : 
; 3913 : #if( RES_DEBUG_PARAMS )
; 3914 :     if(( index <= RES_DIR_NONE ) ||
; 3915 :        ( index >= RES_DIR_LAST ) ||
; 3916 :        ( !path ))

	cmp	DWORD PTR _index$[ebp], 0
	jle	SHORT $LN6@ResAssignP
	cmp	DWORD PTR _index$[ebp], 17		; 00000011H
	jge	SHORT $LN6@ResAssignP
	cmp	DWORD PTR _path$[ebp], 0
	jne	SHORT $LN7@ResAssignP
$LN6@ResAssignP:

; 3917 :     {
; 3918 :         SAY_ERROR( RES_ERR_INCORRECT_PARAMETER, "ResAssignPath" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	3918					; 00000f4eH
	push	OFFSET ??_C@_0O@JNKBGNLK@ResAssignPath?$AA@
	push	-4998					; ffffec7aH
	call	__say_error
	add	esp, 16					; 00000010H

; 3919 :         return;

	jmp	$LN8@ResAssignP
$LN7@ResAssignP:

; 3920 :     }
; 3921 : #endif /* RES_DEBUG_PARAMS */
; 3922 : 
; 3923 :     if( RES_PATH[ index ] )

	mov	eax, DWORD PTR _index$[ebp]
	cmp	DWORD PTR _RES_PATH[eax*4], 0
	je	SHORT $LN5@ResAssignP

; 3924 : 		#ifdef USE_SH_POOLS
; 3925 :         MemFreePtr( RES_PATH[ index ] );
; 3926 : 		#else
; 3927 :         MemFree( RES_PATH[ index ] );

	mov	ecx, DWORD PTR _index$[ebp]
	mov	edx, DWORD PTR _RES_PATH[ecx*4]
	push	edx
	call	_free
	add	esp, 4
$LN5@ResAssignP:

; 3928 : 		#endif
; 3929 : 
; 3930 : 	#ifdef USE_SH_POOLS
; 3931 :     ptr = (char *)MemAllocPtr( gResmgrMemPool, _MAX_PATH, 0 );
; 3932 : 	#else
; 3933 :     ptr = (char *)MemMalloc( _MAX_PATH, path );

	push	260					; 00000104H
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _ptr$[ebp], eax

; 3934 : 	#endif
; 3935 :     if( !ptr ) {

	cmp	DWORD PTR _ptr$[ebp], 0
	jne	SHORT $LN3@ResAssignP

; 3936 :         SAY_ERROR( RES_ERR_NO_MEMORY, "Assign path" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	3936					; 00000f60H
	push	OFFSET ??_C@_0M@CHANDFDP@Assign?5path?$AA@
	push	-4999					; ffffec79H
	call	__say_error
	add	esp, 16					; 00000010H

; 3937 :         return;

	jmp	SHORT $LN8@ResAssignP
$LN3@ResAssignP:

; 3938 :     }
; 3939 : 
; 3940 :     /* All of the pathnames within the RES_PATH array should end with
; 3941 :        a backslash, therefore, we want to trim any leading backslashes
; 3942 :        from the path here. */
; 3943 :     
; 3944 :     while( *path == ASCII_BACKSLASH )

	mov	eax, DWORD PTR _path$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 92					; 0000005cH
	jne	SHORT $LN2@ResAssignP

; 3945 :         path++;

	mov	edx, DWORD PTR _path$[ebp]
	add	edx, 1
	mov	DWORD PTR _path$[ebp], edx
	jmp	SHORT $LN3@ResAssignP
$LN2@ResAssignP:

; 3946 : 
; 3947 :     strcpy( ptr, path );

	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 3948 : 
; 3949 :     len = strlen( ptr );

	mov	edx, DWORD PTR _ptr$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _len$[ebp], eax

; 3950 :     if( len && ( ptr[ len-1 ] != ASCII_BACKSLASH )) {

	cmp	DWORD PTR _len$[ebp], 0
	je	SHORT $LN1@ResAssignP
	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	movsx	ecx, BYTE PTR [eax-1]
	cmp	ecx, 92					; 0000005cH
	je	SHORT $LN1@ResAssignP

; 3951 :         ptr[len++] = ASCII_BACKSLASH;

	mov	edx, DWORD PTR _ptr$[ebp]
	add	edx, DWORD PTR _len$[ebp]
	mov	BYTE PTR [edx], 92			; 0000005cH
	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 1
	mov	DWORD PTR _len$[ebp], eax

; 3952 :         ptr[len] = '\0';

	mov	ecx, DWORD PTR _ptr$[ebp]
	add	ecx, DWORD PTR _len$[ebp]
	mov	BYTE PTR [ecx], 0
$LN1@ResAssignP:

; 3953 :     }
; 3954 : 
; 3955 :     RES_PATH[ index ] = ptr;

	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR _RES_PATH[edx*4], eax
$LN8@ResAssignP:

; 3956 : 
; 3957 :     IF_LOG( LOG( "assign: %s [%d]\n", ptr, index ));
; 3958 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ResAssignPath ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_which$ = 8						; size = 4
_ResGetCallback PROC

; 3228 : {

	push	ebp
	mov	ebp, esp

; 3229 : #if( RES_DEBUG_PARAMS )
; 3230 :    if((which < 0) || (which >= NUMBER_OF_CALLBACKS)) {

	cmp	DWORD PTR _which$[ebp], 0
	jl	SHORT $LN1@ResGetCall
	cmp	DWORD PTR _which$[ebp], 10		; 0000000aH
	jl	SHORT $LN2@ResGetCall
$LN1@ResGetCall:

; 3231 :       SAY_ERROR( RES_ERR_INCORRECT_PARAMETER, "ResGetCallback" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	3231					; 00000c9fH
	push	OFFSET ??_C@_0P@PPCHBMFL@ResGetCallback?$AA@
	push	-4998					; ffffec7aH
	call	__say_error
	add	esp, 16					; 00000010H

; 3232 :       return( NULL );

	xor	eax, eax
	jmp	SHORT $LN3@ResGetCall
$LN2@ResGetCall:

; 3233 :    }
; 3234 : #endif /* RES_DEBUG_PARAMS */
; 3235 : 
; 3236 :    IF_LOG( LOG( "get callback: %d\n", which ));
; 3237 : 
; 3238 :    return( RES_CALLBACK[ which ] );

	mov	eax, DWORD PTR _which$[ebp]
	mov	eax, DWORD PTR _RES_CALLBACK[eax*4]
$LN3@ResGetCall:

; 3239 : }

	pop	ebp
	ret	0
_ResGetCallback ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_old_ptr$ = -4						; size = 4
_which$ = 8						; size = 4
_func$ = 12						; size = 4
_ResSetCallback PROC

; 3193 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 3194 :    PFI old_ptr;
; 3195 : 
; 3196 : #if( RES_DEBUG_PARAMS )
; 3197 :    if(( which < 0 ) || ( which >=  NUMBER_OF_CALLBACKS )) {

	cmp	DWORD PTR _which$[ebp], 0
	jl	SHORT $LN1@ResSetCall
	cmp	DWORD PTR _which$[ebp], 10		; 0000000aH
	jl	SHORT $LN2@ResSetCall
$LN1@ResSetCall:

; 3198 :       SAY_ERROR( RES_ERR_INCORRECT_PARAMETER, "ResSetCallback" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	3198					; 00000c7eH
	push	OFFSET ??_C@_0P@PADJMKNI@ResSetCallback?$AA@
	push	-4998					; ffffec7aH
	call	__say_error
	add	esp, 16					; 00000010H

; 3199 :       return( NULL );

	xor	eax, eax
	jmp	SHORT $LN3@ResSetCall
$LN2@ResSetCall:

; 3200 :    }
; 3201 : #endif /* RES_DEBUG_PARAMS */
; 3202 : 
; 3203 :    old_ptr = RES_CALLBACK[ which ];

	mov	eax, DWORD PTR _which$[ebp]
	mov	ecx, DWORD PTR _RES_CALLBACK[eax*4]
	mov	DWORD PTR _old_ptr$[ebp], ecx

; 3204 :    RES_CALLBACK[ which ] = func;

	mov	edx, DWORD PTR _which$[ebp]
	mov	eax, DWORD PTR _func$[ebp]
	mov	DWORD PTR _RES_CALLBACK[edx*4], eax

; 3205 : 
; 3206 :    IF_LOG( LOG( "set callback: %d\n", which ));
; 3207 : 
; 3208 :    return( old_ptr );

	mov	eax, DWORD PTR _old_ptr$[ebp]
$LN3@ResSetCall:

; 3209 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ResSetCallback ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_ResWriteTOC PROC

; 3096 : {

	push	ebp
	mov	ebp, esp

; 3097 : 	filename;
; 3098 : 
; 3099 :     IF_LOG( LOG( "write t.o.c.: %s\n", filename ));
; 3100 :     
; 3101 : 	return( FALSE );

	xor	eax, eax

; 3102 : }

	pop	ebp
	ret	0
_ResWriteTOC ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_ResWhichCD PROC

; 3073 : {

	push	ebp
	mov	ebp, esp

; 3074 :     IF_LOG( LOG( "which cd: %d\n", GLOBAL_CURRENT_CD ));
; 3075 :     return( GLOBAL_CURRENT_CD );

	mov	eax, DWORD PTR _GLOBAL_CURRENT_CD

; 3076 : }

	pop	ebp
	ret	0
_ResWhichCD ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_type$ = -12						; size = 4
_entry$ = -8						; size = 4
_retval$ = -4						; size = 4
_filename$ = 8						; size = 4
_path$ = 12						; size = 4
_ResWhereIs PROC

; 2995 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 2996 :     HASH_ENTRY * entry;
; 2997 : 
; 2998 :     int retval = 0,

	mov	DWORD PTR _retval$[ebp], 0

; 2999 :         type;
; 3000 : 
; 3001 : #if( RES_DEBUG_PARAMS )
; 3002 :     if( !filename ) {

	cmp	DWORD PTR _filename$[ebp], 0
	jne	SHORT $LN8@ResWhereIs

; 3003 :         SAY_ERROR( RES_ERR_INCORRECT_PARAMETER, "ResGetDirectory" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	3003					; 00000bbbH
	push	OFFSET ??_C@_0BA@JNGLFOGE@ResGetDirectory?$AA@
	push	-4998					; ffffec7aH
	call	__say_error
	add	esp, 16					; 00000010H

; 3004 :         return( -1 );

	or	eax, -1
	jmp	$LN9@ResWhereIs
$LN8@ResWhereIs:

; 3005 :     }
; 3006 : #endif
; 3007 : #if (RES_MULTITHREAD)
; 3008 : 	REQUEST_LOCK(GLOCK);

	push	-1
	mov	eax, DWORD PTR _GLOCK
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8

; 3009 : #endif
; 3010 : 
; 3011 : #if( !RES_USE_FLAT_MODEL )
; 3012 :     entry = hash_find_table( filename, NULL );

	push	0
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_hash_find_table
	add	esp, 8
	mov	DWORD PTR _entry$[ebp], eax

; 3013 : #else /* flat model */
; 3014 : //    entry = hash_find( file, GLOBAL_HASH_TABLE );  /* GFG  31/01/98 */
; 3015 :     entry = hash_find( filename, GLOBAL_HASH_TABLE );
; 3016 : #endif /* !RES_USE_FLAT_MODEL */
; 3017 : 
; 3018 :     if( !entry )

	cmp	DWORD PTR _entry$[ebp], 0
	jne	SHORT $LN7@ResWhereIs

; 3019 : 	{
; 3020 : #if (RES_MULTITHREAD)
; 3021 :   	    RELEASE_LOCK(GLOCK);

	mov	edx, DWORD PTR _GLOCK
	push	edx
	call	DWORD PTR __imp__ReleaseMutex@4

; 3022 : #endif
; 3023 :         return( -1 );

	or	eax, -1
	jmp	$LN9@ResWhereIs
$LN7@ResWhereIs:

; 3024 : 	}
; 3025 :     if( entry -> archive != -1 )

	mov	eax, DWORD PTR _entry$[ebp]
	cmp	DWORD PTR [eax+24], -1
	je	SHORT $LN6@ResWhereIs

; 3026 :         retval |= RES_ARCHIVE;

	mov	ecx, DWORD PTR _retval$[ebp]
	or	ecx, 524288				; 00080000H
	mov	DWORD PTR _retval$[ebp], ecx
$LN6@ResWhereIs:

; 3027 : 
; 3028 :     type = RES_DEVICES[ entry -> volume ].type;

	mov	edx, DWORD PTR _entry$[ebp]
	movsx	eax, BYTE PTR [edx+36]
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _RES_DEVICES
	movsx	edx, BYTE PTR [ecx+eax+1]
	mov	DWORD PTR _type$[ebp], edx

; 3029 : 
; 3030 :     if( type == DRIVE_CDROM ) {

	cmp	DWORD PTR _type$[ebp], 5
	jne	SHORT $LN5@ResWhereIs

; 3031 :         retval |= RES_CD;

	mov	eax, DWORD PTR _retval$[ebp]
	or	eax, 131072				; 00020000H
	mov	DWORD PTR _retval$[ebp], eax

; 3032 :         retval |= RES_DEVICES[ entry -> volume ].id;

	mov	ecx, DWORD PTR _entry$[ebp]
	movsx	edx, BYTE PTR [ecx+36]
	imul	edx, 40					; 00000028H
	mov	eax, DWORD PTR _RES_DEVICES
	movsx	ecx, BYTE PTR [eax+edx+34]
	or	ecx, DWORD PTR _retval$[ebp]
	mov	DWORD PTR _retval$[ebp], ecx
$LN5@ResWhereIs:

; 3033 :     }
; 3034 : 
; 3035 :     if( type == DRIVE_REMOTE ) 

	cmp	DWORD PTR _type$[ebp], 4
	jne	SHORT $LN4@ResWhereIs

; 3036 :         retval |= RES_NET;

	mov	edx, DWORD PTR _retval$[ebp]
	or	edx, 262144				; 00040000H
	mov	DWORD PTR _retval$[ebp], edx
$LN4@ResWhereIs:

; 3037 : 
; 3038 :     if( type == DRIVE_FIXED ) 

	cmp	DWORD PTR _type$[ebp], 3
	jne	SHORT $LN3@ResWhereIs

; 3039 :         retval |= RES_HD;

	mov	eax, DWORD PTR _retval$[ebp]
	or	eax, 65536				; 00010000H
	mov	DWORD PTR _retval$[ebp], eax
$LN3@ResWhereIs:

; 3040 : 
; 3041 :     if( type == DRIVE_REMOVABLE ) 

	cmp	DWORD PTR _type$[ebp], 2
	jne	SHORT $LN2@ResWhereIs

; 3042 :         retval |= RES_FLOPPY;

	mov	ecx, DWORD PTR _retval$[ebp]
	or	ecx, 1048576				; 00100000H
	mov	DWORD PTR _retval$[ebp], ecx
$LN2@ResWhereIs:

; 3043 :     
; 3044 :     if( path )

	cmp	DWORD PTR _path$[ebp], 0
	je	SHORT $LN1@ResWhereIs

; 3045 :         strcpy( path, GLOBAL_SEARCH_PATH[ entry -> directory ]);

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _GLOBAL_SEARCH_PATH[eax*4]
	push	ecx
	mov	edx, DWORD PTR _path$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8
$LN1@ResWhereIs:

; 3046 : 
; 3047 :     IF_LOG( LOG( "where is: %s\n", filename ));
; 3048 : #if (RES_MULTITHREAD)
; 3049 : 	RELEASE_LOCK(GLOCK);

	mov	eax, DWORD PTR _GLOCK
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4

; 3050 : #endif
; 3051 : 
; 3052 :     return( retval );

	mov	eax, DWORD PTR _retval$[ebp]
$LN9@ResWhereIs:

; 3053 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ResWhereIs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_ret$ = -292						; size = 4
$T1 = -288						; size = 4
_dir$ = -284						; size = 4
_data_count$ = -280					; size = 4
_count$ = -276						; size = 4
_data$ = -272						; size = 4
_len$ = -268						; size = 4
_fullpath$ = -264					; size = 260
__$ArrayPad$ = -4					; size = 4
_path$ = 8						; size = 4
_file_data$ = 12					; size = 4
_ResCountDirectory PROC

; 3788 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 3789 : //    HASH_ENTRY * entry=NULL;
; 3790 : 
; 3791 :     char fullpath[ _MAX_PATH ];
; 3792 : 
; 3793 : //    struct _finddata_t data;
; 3794 :     struct _finddata_t *data;
; 3795 : 
; 3796 :     int dir,
; 3797 :         len,
; 3798 :         count = -1,

	mov	DWORD PTR _count$[ebp], -1

; 3799 :         data_count = 0,

	mov	DWORD PTR _data_count$[ebp], 0

; 3800 :         ret;
; 3801 : 
; 3802 : 
; 3803 :     IF_LOG( LOG( "count: %s\n", path ));
; 3804 : 
; 3805 : #if( RES_DEBUG_PARAMS )
; 3806 :     if( !path ) {

	cmp	DWORD PTR _path$[ebp], 0
	jne	SHORT $LN9@ResCountDi

; 3807 :         SAY_ERROR( RES_ERR_INCORRECT_PARAMETER, "ResCountDirectory" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	3807					; 00000edfH
	push	OFFSET ??_C@_0BC@EJOCHHKO@ResCountDirectory?$AA@
	push	-4998					; ffffec7aH
	call	__say_error
	add	esp, 16					; 00000010H

; 3808 :         return( -1 );

	or	eax, -1
	jmp	$LN11@ResCountDi
$LN9@ResCountDi:

; 3809 :     }
; 3810 : #endif /* RES_DEBUG_PARAMS */
; 3811 : 
; 3812 : 
; 3813 : 
; 3814 :     /* we need to make sure we have an absolute (full) path */
; 3815 :     
; 3816 :     res_fullpath( fullpath, path, (_MAX_PATH - 3));

	push	257					; 00000101H
	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	lea	ecx, DWORD PTR _fullpath$[ebp]
	push	ecx
	call	_res_fullpath
	add	esp, 12					; 0000000cH

; 3817 : 
; 3818 : #if( !RES_USE_FLAT_MODEL )
; 3819 : 
; 3820 : #if 0
; 3821 :     entry = hash_find( fullpath, GLOBAL_HASH_TABLE );
; 3822 : 
; 3823 :     if( entry && entry -> dir )
; 3824 :         return( ((HASH_TABLE *)entry -> dir) -> num_entries );
; 3825 : #endif
; 3826 : 
; 3827 : #endif /* RES_USE_FLAT_MODEL */
; 3828 : 
; 3829 :     /* add a wildcard to the end of the path */
; 3830 : 
; 3831 :     len = strlen( fullpath );

	lea	edx, DWORD PTR _fullpath$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _len$[ebp], eax

; 3832 :     fullpath[ len++ ] = ASCII_ASTERISK;

	mov	eax, DWORD PTR _len$[ebp]
	mov	BYTE PTR _fullpath$[ebp+eax], 42	; 0000002aH
	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, 1
	mov	DWORD PTR _len$[ebp], ecx

; 3833 :     fullpath[ len++ ] = ASCII_PERIOD;

	mov	edx, DWORD PTR _len$[ebp]
	mov	BYTE PTR _fullpath$[ebp+edx], 46	; 0000002eH
	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 1
	mov	DWORD PTR _len$[ebp], eax

; 3834 :     fullpath[ len++ ] = ASCII_ASTERISK;

	mov	ecx, DWORD PTR _len$[ebp]
	mov	BYTE PTR _fullpath$[ebp+ecx], 42	; 0000002aH
	mov	edx, DWORD PTR _len$[ebp]
	add	edx, 1
	mov	DWORD PTR _len$[ebp], edx

; 3835 :     fullpath[ len ] = '\0';

	mov	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 260			; 00000104H
	jae	SHORT $LN12@ResCountDi
	jmp	SHORT $LN13@ResCountDi
$LN12@ResCountDi:
	call	___report_rangecheckfailure
$LN13@ResCountDi:
	mov	ecx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _fullpath$[ebp+ecx], 0

; 3836 : 
; 3837 :     data_count = RES_INIT_DIRECTORY_SIZE;

	mov	DWORD PTR _data_count$[ebp], 8

; 3838 : 	#ifdef USE_SH_POOLS
; 3839 :     *file_data = data = MemAllocPtr( gResmgrMemPool, data_count * sizeof(struct _finddata_t), 0);
; 3840 : 	#else
; 3841 :     *file_data = data = MemMalloc(data_count * sizeof(struct _finddata_t),"ResCountDirectory");

	mov	edx, DWORD PTR _data_count$[ebp]
	imul	edx, 296				; 00000128H
	push	edx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _data$[ebp], eax
	mov	eax, DWORD PTR _file_data$[ebp]
	mov	ecx, DWORD PTR _data$[ebp]
	mov	DWORD PTR [eax], ecx

; 3842 : 	#endif
; 3843 :     if( ! data)

	cmp	DWORD PTR _data$[ebp], 0
	jne	SHORT $LN8@ResCountDi

; 3844 :     {
; 3845 :         SAY_ERROR( RES_ERR_NO_MEMORY, "ResCountDirectory" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	3845					; 00000f05H
	push	OFFSET ??_C@_0BC@EJOCHHKO@ResCountDirectory?$AA@
	push	-4999					; ffffec79H
	call	__say_error
	add	esp, 16					; 00000010H

; 3846 :         return (-1);

	or	eax, -1
	jmp	$LN11@ResCountDi
$LN8@ResCountDi:

; 3847 :     }
; 3848 : 
; 3849 : 
; 3850 :     /* try to open the directory */
; 3851 : 
; 3852 : //    dir = _findfirst( fullpath, &data );
; 3853 :     dir = _findfirst( fullpath, data );

	mov	edx, DWORD PTR _data$[ebp]
	push	edx
	lea	eax, DWORD PTR _fullpath$[ebp]
	push	eax
	call	__findfirst64i32
	add	esp, 8
	mov	DWORD PTR _dir$[ebp], eax

; 3854 : 
; 3855 :     if( dir != -1 ) {

	cmp	DWORD PTR _dir$[ebp], -1
	je	$LN1@ResCountDi

; 3856 :         count = 1;

	mov	DWORD PTR _count$[ebp], 1
$LN6@ResCountDi:

; 3857 :         
; 3858 :         do
; 3859 :         {
; 3860 :             if(count >= data_count )

	mov	ecx, DWORD PTR _count$[ebp]
	cmp	ecx, DWORD PTR _data_count$[ebp]
	jl	SHORT $LN3@ResCountDi

; 3861 :             {
; 3862 :                data_count += RES_INIT_DIRECTORY_SIZE;

	mov	edx, DWORD PTR _data_count$[ebp]
	add	edx, 8
	mov	DWORD PTR _data_count$[ebp], edx

; 3863 : 			   #ifdef USE_SH_POOLS
; 3864 :                *file_data =  MemReAllocPtr(*file_data,data_count * sizeof(struct _finddata_t),0);
; 3865 : 			   #else
; 3866 :                *file_data =  MemRealloc(*file_data,data_count * sizeof(struct _finddata_t));

	mov	eax, DWORD PTR _data_count$[ebp]
	imul	eax, 296				; 00000128H
	push	eax
	mov	ecx, DWORD PTR _file_data$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_realloc
	add	esp, 8
	mov	ecx, DWORD PTR _file_data$[ebp]
	mov	DWORD PTR [ecx], eax

; 3867 : 			   #endif
; 3868 :                data = *file_data + (count-1);

	mov	edx, DWORD PTR _count$[ebp]
	sub	edx, 1
	imul	edx, 296				; 00000128H
	mov	eax, DWORD PTR _file_data$[ebp]
	add	edx, DWORD PTR [eax]
	mov	DWORD PTR _data$[ebp], edx
$LN3@ResCountDi:

; 3869 :             }
; 3870 :             data++;

	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 296				; 00000128H
	mov	DWORD PTR _data$[ebp], ecx

; 3871 :             ret =  _findnext( dir, data );

	mov	edx, DWORD PTR _data$[ebp]
	push	edx
	mov	eax, DWORD PTR _dir$[ebp]
	push	eax
	call	__findnext64i32
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 3872 :             if (!ret)

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN5@ResCountDi

; 3873 :             {
; 3874 :             count++;

	mov	ecx, DWORD PTR _count$[ebp]
	add	ecx, 1
	mov	DWORD PTR _count$[ebp], ecx
$LN5@ResCountDi:

; 3875 :             }
; 3876 :         }while( !ret);   

	cmp	DWORD PTR _ret$[ebp], 0
	je	$LN6@ResCountDi

; 3877 : 
; 3878 : 
; 3879 :         _findclose( dir );

	mov	edx, DWORD PTR _dir$[ebp]
	push	edx
	call	__findclose
	add	esp, 4
$LN1@ResCountDi:

; 3880 :     }
; 3881 :     else {
; 3882 :         IF_LOG( LOG( "Could not open directory %s\n", fullpath ));
; 3883 :     }
; 3884 : 
; 3885 :     return( count );

	mov	eax, DWORD PTR _count$[ebp]
$LN11@ResCountDi:

; 3886 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_ResCountDirectory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_check$ = -4						; size = 4
_buffer$ = 8						; size = 4
_ResGetDirectory PROC

; 2853 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2854 :     char * check;
; 2855 : 
; 2856 : #if( RES_DEBUG_PARAMS )
; 2857 :     if( !buffer ) {

	cmp	DWORD PTR _buffer$[ebp], 0
	jne	SHORT $LN3@ResGetDire

; 2858 :         SAY_ERROR( RES_ERR_INCORRECT_PARAMETER, "ResGetDirectory" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	2858					; 00000b2aH
	push	OFFSET ??_C@_0BA@JNGLFOGE@ResGetDirectory?$AA@
	push	-4998					; ffffec7aH
	call	__say_error
	add	esp, 16					; 00000010H

; 2859 :         return(0);

	xor	eax, eax
	jmp	SHORT $LN4@ResGetDire
$LN3@ResGetDire:

; 2860 :     }
; 2861 : 
; 2862 :     if( !GLOBAL_PATH_LIST ) {

	cmp	DWORD PTR _GLOBAL_PATH_LIST, 0
	jne	SHORT $LN2@ResGetDire

; 2863 :         SAY_ERROR(  RES_ERR_MUST_CREATE_PATH, "ResSetDirectory" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	2863					; 00000b2fH
	push	OFFSET ??_C@_0BA@OJNFJCCI@ResSetDirectory?$AA@
	push	-4986					; ffffec86H
	call	__say_error
	add	esp, 16					; 00000010H

; 2864 :         return(0);

	xor	eax, eax
	jmp	SHORT $LN4@ResGetDire
$LN2@ResGetDire:

; 2865 :     }
; 2866 : #endif
; 2867 : 
; 2868 : #if( !RES_USE_FLAT_MODEL )
; 2869 :     check = strcpy( buffer, ((HASH_TABLE *)(GLOBAL_PATH_LIST -> node)) -> name );

	mov	eax, DWORD PTR _GLOBAL_PATH_LIST
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8
	mov	DWORD PTR _check$[ebp], eax

; 2870 : #else
; 2871 :     check = strcpy( buffer, GLOBAL_CURRENT_PATH );
; 2872 : #endif /* !RES_USE_FLAT_MODEL */
; 2873 : 
; 2874 :     IF_LOG( LOG( "get dir: %s\n", buffer ));
; 2875 : 
; 2876 :     if( check )

	cmp	DWORD PTR _check$[ebp], 0
	je	SHORT $LN1@ResGetDire

; 2877 :         return( strlen( buffer ));

	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	jmp	SHORT $LN4@ResGetDire
$LN1@ResGetDire:

; 2878 : 
; 2879 :     return( 0 );    /* nothing was copied into buffer */

	xor	eax, eax
$LN4@ResGetDire:

; 2880 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ResGetDirectory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
$T1 = -276						; size = 4
_entry$ = -272						; size = 4
_len$ = -268						; size = 4
_full$ = -264						; size = 260
__$ArrayPad$ = -4					; size = 4
_pathname$ = 8						; size = 4
_ResSetDirectory PROC

; 2762 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 276				; 00000114H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2763 :     HASH_ENTRY * entry;
; 2764 : #if( RES_COERCE_FILENAMES )
; 2765 :     char full[_MAX_PATH];
; 2766 :     int  len;
; 2767 : #endif 
; 2768 : 
; 2769 : #if( RES_DEBUG_PARAMS )
; 2770 :     if( !pathname || !(*pathname)) {

	cmp	DWORD PTR _pathname$[ebp], 0
	je	SHORT $LN5@ResSetDire
	mov	eax, DWORD PTR _pathname$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN6@ResSetDire
$LN5@ResSetDire:

; 2771 :         SAY_ERROR( RES_ERR_INCORRECT_PARAMETER, "ResSetDirectory" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	2771					; 00000ad3H
	push	OFFSET ??_C@_0BA@OJNFJCCI@ResSetDirectory?$AA@
	push	-4998					; ffffec7aH
	call	__say_error
	add	esp, 16					; 00000010H

; 2772 :         return( FALSE );

	xor	eax, eax
	jmp	$LN8@ResSetDire
$LN6@ResSetDire:

; 2773 :     }
; 2774 : 
; 2775 :     if( !GLOBAL_PATH_LIST ) {

	cmp	DWORD PTR _GLOBAL_PATH_LIST, 0
	jne	SHORT $LN4@ResSetDire

; 2776 :         SAY_ERROR( RES_ERR_MUST_CREATE_PATH, "ResSetDirectory" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	2776					; 00000ad8H
	push	OFFSET ??_C@_0BA@OJNFJCCI@ResSetDirectory?$AA@
	push	-4986					; ffffec86H
	call	__say_error
	add	esp, 16					; 00000010H

; 2777 :         return( FALSE );

	xor	eax, eax
	jmp	$LN8@ResSetDire
$LN4@ResSetDire:

; 2778 :     }
; 2779 : #endif
; 2780 : 
; 2781 : #if( RES_COERCE_FILENAMES )
; 2782 :     res_fullpath( full, pathname, ( _MAX_PATH - 2 ));

	push	258					; 00000102H
	mov	edx, DWORD PTR _pathname$[ebp]
	push	edx
	lea	eax, DWORD PTR _full$[ebp]
	push	eax
	call	_res_fullpath
	add	esp, 12					; 0000000cH

; 2783 :     
; 2784 :     len = strlen( full );

	lea	ecx, DWORD PTR _full$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _len$[ebp], eax

; 2785 : 
; 2786 :     if( full[len-1] != ASCII_BACKSLASH ) {

	mov	edx, DWORD PTR _len$[ebp]
	movsx	eax, BYTE PTR _full$[ebp+edx-1]
	cmp	eax, 92					; 0000005cH
	je	SHORT $LN3@ResSetDire

; 2787 :         full[len++] = ASCII_BACKSLASH;

	mov	ecx, DWORD PTR _len$[ebp]
	mov	BYTE PTR _full$[ebp+ecx], 92		; 0000005cH
	mov	edx, DWORD PTR _len$[ebp]
	add	edx, 1
	mov	DWORD PTR _len$[ebp], edx

; 2788 :         full[len++] = '\0';

	mov	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, 1
	mov	DWORD PTR _len$[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 260			; 00000104H
	jae	SHORT $LN9@ResSetDire
	jmp	SHORT $LN10@ResSetDire
$LN9@ResSetDire:
	call	___report_rangecheckfailure
$LN10@ResSetDire:
	mov	edx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _full$[ebp+edx], 0
$LN3@ResSetDire:

; 2789 :     }
; 2790 : 
; 2791 :     pathname = full;

	lea	eax, DWORD PTR _full$[ebp]
	mov	DWORD PTR _pathname$[ebp], eax

; 2792 : #endif /* RES_COERCE_FILENAMES */
; 2793 : 
; 2794 :     entry = hash_find( pathname, GLOBAL_HASH_TABLE );

	mov	ecx, DWORD PTR _GLOBAL_HASH_TABLE
	push	ecx
	mov	edx, DWORD PTR _pathname$[ebp]
	push	edx
	call	_hash_find
	add	esp, 8
	mov	DWORD PTR _entry$[ebp], eax

; 2795 : 
; 2796 :     if( !entry || !entry -> dir ) {

	cmp	DWORD PTR _entry$[ebp], 0
	je	SHORT $LN1@ResSetDire
	mov	eax, DWORD PTR _entry$[ebp]
	cmp	DWORD PTR [eax+40], 0
	jne	SHORT $LN2@ResSetDire
$LN1@ResSetDire:

; 2797 :         SAY_ERROR( RES_ERR_PATH_NOT_FOUND, pathname );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	2797					; 00000aedH
	mov	ecx, DWORD PTR _pathname$[ebp]
	push	ecx
	push	-4997					; ffffec7bH
	call	__say_error
	add	esp, 16					; 00000010H

; 2798 :         return( FALSE );

	xor	eax, eax
	jmp	SHORT $LN8@ResSetDire
$LN2@ResSetDire:

; 2799 :     }
; 2800 : 
; 2801 :     sort_path();    /* sort path BEFORE forcing one of the entries

	call	_sort_path

; 2802 :                        to the top.  Since we subjigate all of the 
; 2803 :                        paths that are based on the CD, this allows
; 2804 :                        the caller to force a CD path to be on top
; 2805 :                        of the search path.  All of the other CD
; 2806 :                        paths, however, are still at the bottom. */
; 2807 : 
; 2808 : #if( !RES_USE_FLAT_MODEL )
; 2809 :     /* Force to the head of the list */
; 2810 :     GLOBAL_PATH_LIST = LIST_REMOVE( GLOBAL_PATH_LIST, entry -> dir );

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+40]
	push	eax
	mov	ecx, DWORD PTR _GLOBAL_PATH_LIST
	push	ecx
	call	_ListRemove
	add	esp, 8
	mov	DWORD PTR _GLOBAL_PATH_LIST, eax

; 2811 :     GLOBAL_PATH_LIST = LIST_APPEND( GLOBAL_PATH_LIST, entry -> dir );

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+40]
	push	eax
	mov	ecx, DWORD PTR _GLOBAL_PATH_LIST
	push	ecx
	call	_ListAppend
	add	esp, 8
	mov	DWORD PTR _GLOBAL_PATH_LIST, eax

; 2812 : #endif /* RES_USE_FLAT_MODEL */
; 2813 : 
; 2814 :     strcpy( GLOBAL_CURRENT_PATH, pathname );

	mov	edx, DWORD PTR _pathname$[ebp]
	push	edx
	push	OFFSET _GLOBAL_CURRENT_PATH
	call	_strcpy
	add	esp, 8

; 2815 : 
; 2816 :     /* If we allow alias attach points ('fake' directories to 
; 2817 :        attach archive's onto) we should disable the error 
; 2818 :        reporting. */
; 2819 : 
; 2820 : 
; 2821 : #if 0   // GFG May 05/98
; 2822 : #if( !RES_ALLOW_ALIAS )
; 2823 :     if( _chdir( pathname )) {
; 2824 :         SAY_ERROR( errno, "ResSetDirectory" );
; 2825 :     }
; 2826 : #else
; 2827 :     _chdir( pathname );
; 2828 : #endif
; 2829 : #endif
; 2830 : 
; 2831 :     GLOBAL_CURRENT_DRIVE = pathname[0];

	mov	eax, 1
	imul	eax, 0
	mov	ecx, DWORD PTR _pathname$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	mov	DWORD PTR _GLOBAL_CURRENT_DRIVE, edx

; 2832 : 
; 2833 :     IF_LOG( LOG( "set dir: %s\n", pathname ));
; 2834 :     return( TRUE ); 

	mov	eax, 1
$LN8@ResSetDire:

; 2835 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_ResSetDirectory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
$T1 = -272						; size = 4
_len$ = -268						; size = 4
_path$ = -264						; size = 260
__$ArrayPad$ = -4					; size = 4
_pathname$ = 8						; size = 4
_ResExistDirectory PROC

; 2602 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 272				; 00000110H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2603 :     char path[_MAX_PATH];
; 2604 :     int len;
; 2605 : 
; 2606 : #if( RES_DEBUG_PARAMS )
; 2607 :     if( !pathname ) {

	cmp	DWORD PTR _pathname$[ebp], 0
	jne	SHORT $LN2@ResExistDi

; 2608 :         SAY_ERROR( RES_ERR_INCORRECT_PARAMETER, "ResExistDirectory" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	2608					; 00000a30H
	push	OFFSET ??_C@_0BC@NEGNMGMD@ResExistDirectory?$AA@
	push	-4998					; ffffec7aH
	call	__say_error
	add	esp, 16					; 00000010H

; 2609 :         return( FALSE );

	xor	eax, eax
	jmp	$LN4@ResExistDi
$LN2@ResExistDi:

; 2610 :     }
; 2611 : #endif
; 2612 : 
; 2613 :     res_fullpath( path, pathname, _MAX_PATH );

	push	260					; 00000104H
	mov	eax, DWORD PTR _pathname$[ebp]
	push	eax
	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	_res_fullpath
	add	esp, 12					; 0000000cH

; 2614 : 
; 2615 : #if( RES_COERCE_FILENAMES )
; 2616 :     len = strlen(path);

	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _len$[ebp], eax

; 2617 :     if( path[len-1] != ASCII_BACKSLASH ) {

	mov	eax, DWORD PTR _len$[ebp]
	movsx	ecx, BYTE PTR _path$[ebp+eax-1]
	cmp	ecx, 92					; 0000005cH
	je	SHORT $LN1@ResExistDi

; 2618 :         path[len++] = ASCII_BACKSLASH;

	mov	edx, DWORD PTR _len$[ebp]
	mov	BYTE PTR _path$[ebp+edx], 92		; 0000005cH
	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 1
	mov	DWORD PTR _len$[ebp], eax

; 2619 :         path[len] = 0x00;

	mov	ecx, DWORD PTR _len$[ebp]
	mov	DWORD PTR $T1[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 260			; 00000104H
	jae	SHORT $LN5@ResExistDi
	jmp	SHORT $LN6@ResExistDi
$LN5@ResExistDi:
	call	___report_rangecheckfailure
$LN6@ResExistDi:
	mov	edx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _path$[ebp+edx], 0
$LN1@ResExistDi:

; 2620 :     }
; 2621 : #endif /* RES_COERCE_FILENAMES */
; 2622 : 
; 2623 :     IF_LOG( LOG( "exist dir: %s\n", pathname ));
; 2624 : 
; 2625 :     return((int)hash_find(path, GLOBAL_HASH_TABLE));

	mov	eax, DWORD PTR _GLOBAL_HASH_TABLE
	push	eax
	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	_hash_find
	add	esp, 8
$LN4@ResExistDi:

; 2626 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_ResExistDirectory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_entry$ = -4						; size = 4
_name$ = 8						; size = 4
_ResExistFile PROC

; 2556 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2557 :     HASH_ENTRY * entry;
; 2558 : 
; 2559 : #if( RES_DEBUG_PARAMS )
; 2560 :     if( !name ) {

	cmp	DWORD PTR _name$[ebp], 0
	jne	SHORT $LN2@ResExistFi

; 2561 :        SAY_ERROR( RES_ERR_INCORRECT_PARAMETER, "ResExistFile" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	2561					; 00000a01H
	push	OFFSET ??_C@_0N@DHMJDPLD@ResExistFile?$AA@
	push	-4998					; ffffec7aH
	call	__say_error
	add	esp, 16					; 00000010H

; 2562 :        return( FALSE );

	xor	eax, eax
	jmp	SHORT $LN3@ResExistFi
$LN2@ResExistFi:

; 2563 :     }
; 2564 : #endif
; 2565 : #if (RES_MULTITHREAD)
; 2566 : 	REQUEST_LOCK(GLOCK);

	push	-1
	mov	eax, DWORD PTR _GLOCK
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8

; 2567 : #endif
; 2568 : 
; 2569 :    IF_LOG( LOG( "exist file: %s\n", name ));
; 2570 : 
; 2571 : #if( !RES_USE_FLAT_MODEL )
; 2572 :     entry = hash_find_table( name, NULL );

	push	0
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_hash_find_table
	add	esp, 8
	mov	DWORD PTR _entry$[ebp], eax

; 2573 : #else /* flat model */
; 2574 :     entry = hash_find( name, GLOBAL_HASH_TABLE );
; 2575 : #endif
; 2576 : 
; 2577 : #if (RES_MULTITHREAD)
; 2578 : 	RELEASE_LOCK(GLOCK);

	mov	edx, DWORD PTR _GLOCK
	push	edx
	call	DWORD PTR __imp__ReleaseMutex@4

; 2579 : #endif
; 2580 : 
; 2581 :     if( entry )

	cmp	DWORD PTR _entry$[ebp], 0
	je	SHORT $LN1@ResExistFi

; 2582 :         return( TRUE );

	mov	eax, 1
	jmp	SHORT $LN3@ResExistFi
$LN1@ResExistFi:

; 2583 : 
; 2584 :     return( FALSE );

	xor	eax, eax
$LN3@ResExistFi:

; 2585 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ResExistFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_dir$ = 8						; size = 4
_ResCloseDirectory PROC

; 2520 : {

	push	ebp
	mov	ebp, esp

; 2521 : #if( RES_DEBUG_PARAMS )
; 2522 :     if( !dir ) {

	cmp	DWORD PTR _dir$[ebp], 0
	jne	SHORT $LN1@ResCloseDi

; 2523 :         SAY_ERROR( RES_ERR_INCORRECT_PARAMETER, "ResCloseDirectory" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	2523					; 000009dbH
	push	OFFSET ??_C@_0BC@EGBEGFJA@ResCloseDirectory?$AA@
	push	-4998					; ffffec7aH
	call	__say_error
	add	esp, 16					; 00000010H

; 2524 :         return;

	jmp	SHORT $LN2@ResCloseDi
$LN1@ResCloseDi:

; 2525 :     }
; 2526 : #endif /* RES_DEBUG_PARAMS */
; 2527 : 
; 2528 :     IF_LOG( LOG( "closedir: %s\n", dir -> name ));
; 2529 : 
; 2530 : 	#ifdef USE_SH_POOLS
; 2531 :     MemFreePtr( dir );
; 2532 : 	#else
; 2533 :     MemFree( dir );

	mov	eax, DWORD PTR _dir$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 2534 : 	#endif
; 2535 : 
; 2536 : #if( RES_DEBUG_VERSION )
; 2537 :     OPEN_DIR_LIST = LIST_REMOVE( OPEN_DIR_LIST, dir );

	mov	ecx, DWORD PTR _dir$[ebp]
	push	ecx
	mov	edx, DWORD PTR _OPEN_DIR_LIST
	push	edx
	call	_ListRemove
	add	esp, 8
	mov	DWORD PTR _OPEN_DIR_LIST, eax
$LN2@ResCloseDi:

; 2538 : #endif
; 2539 : }

	pop	ebp
	ret	0
_ResCloseDirectory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
tv79 = -4						; size = 4
_dir$ = 8						; size = 4
_ResReadDirectory PROC

; 2488 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2489 : #if( RES_DEBUG_PARAMS )
; 2490 :     if( !dir ) {

	cmp	DWORD PTR _dir$[ebp], 0
	jne	SHORT $LN2@ResReadDir

; 2491 :         SAY_ERROR( RES_ERR_INCORRECT_PARAMETER, "ResReadDirectory" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	2491					; 000009bbH
	push	OFFSET ??_C@_0BB@GCNEOGEN@ResReadDirectory?$AA@
	push	-4998					; ffffec7aH
	call	__say_error
	add	esp, 16					; 00000010H

; 2492 :         return( NULL );

	xor	eax, eax
	jmp	SHORT $LN3@ResReadDir
$LN2@ResReadDir:

; 2493 :     }
; 2494 : #endif /* RES_DEBUG_PARAMS */
; 2495 :    
; 2496 : 
; 2497 :     IF_LOG( LOG( "readdir: %s\n", dir -> name ));
; 2498 : 
; 2499 :     if( dir -> current >= dir -> num_entries ) 

	mov	eax, DWORD PTR _dir$[ebp]
	mov	ecx, DWORD PTR _dir$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+4]
	jl	SHORT $LN1@ResReadDir

; 2500 :         return( NULL );

	xor	eax, eax
	jmp	SHORT $LN3@ResReadDir
$LN1@ResReadDir:

; 2501 : 
; 2502 :     return((char *)(dir -> filenames[ dir -> current++ ]));

	mov	eax, DWORD PTR _dir$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _dir$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR tv79[ebp], ecx
	mov	edx, DWORD PTR _dir$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _dir$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR tv79[ebp]
$LN3@ResReadDir:

; 2503 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ResReadDirectory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_i$ = -288						; size = 4
_hsh$ = -284						; size = 4
_size$ = -280						; size = 4
_index$ = -276						; size = 4
_entry$ = -272						; size = 4
_dir$ = -268						; size = 4
_dirpath$ = -264					; size = 260
__$ArrayPad$ = -4					; size = 4
_pathname$ = 8						; size = 4
_ResOpenDirectory PROC

; 2393 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 288				; 00000120H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2394 : //    int count = 0;
; 2395 : 
; 2396 : #if( !RES_USE_FLAT_MODEL )
; 2397 : 
; 2398 :     HASH_TABLE * hsh;
; 2399 :     HASH_ENTRY * entry;
; 2400 :     RES_DIR    * dir;
; 2401 :     size_t       size;
; 2402 :     char         dirpath[_MAX_PATH];
; 2403 :     int          index, i;
; 2404 : 
; 2405 : #if( RES_DEBUG_PARAMS )
; 2406 :     if( !GLOBAL_SEARCH_INDEX )

	cmp	DWORD PTR _GLOBAL_SEARCH_INDEX, 0
	jne	SHORT $LN12@ResOpenDir

; 2407 :         return( NULL );

	xor	eax, eax
	jmp	$LN13@ResOpenDir
$LN12@ResOpenDir:

; 2408 : #endif
; 2409 : 
; 2410 :     IF_LOG( LOG( "opendir: %s\n", pathname ));
; 2411 : 
; 2412 :     res_fullpath( dirpath, pathname, _MAX_PATH );

	push	260					; 00000104H
	mov	eax, DWORD PTR _pathname$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dirpath$[ebp]
	push	ecx
	call	_res_fullpath
	add	esp, 12					; 0000000cH

; 2413 : 
; 2414 :     entry = hash_find( dirpath, GLOBAL_HASH_TABLE );

	mov	edx, DWORD PTR _GLOBAL_HASH_TABLE
	push	edx
	lea	eax, DWORD PTR _dirpath$[ebp]
	push	eax
	call	_hash_find
	add	esp, 8
	mov	DWORD PTR _entry$[ebp], eax

; 2415 : 
; 2416 :     if( entry && entry -> dir ) {

	cmp	DWORD PTR _entry$[ebp], 0
	je	$LN11@ResOpenDir
	mov	ecx, DWORD PTR _entry$[ebp]
	cmp	DWORD PTR [ecx+40], 0
	je	$LN11@ResOpenDir

; 2417 :         hsh = (HASH_TABLE *)entry -> dir;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR _hsh$[ebp], eax

; 2418 : 
; 2419 :         size = sizeof( RES_DIR );

	mov	DWORD PTR _size$[ebp], 24		; 00000018H

; 2420 :         size += sizeof(char *) * (hsh -> num_entries);

	mov	ecx, DWORD PTR _hsh$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _size$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _size$[ebp], ecx

; 2421 :         size += MAX_FILENAME * (hsh -> num_entries + 12);

	mov	edx, DWORD PTR _hsh$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 12					; 0000000cH
	imul	eax, 60					; 0000003cH
	add	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _size$[ebp], eax

; 2422 : 
; 2423 : 		#ifdef USE_SH_POOLS
; 2424 :         dir = (RES_DIR *)MemAllocPtr( gResmgrMemPool, size, 0 );
; 2425 : 		#else
; 2426 :         dir = (RES_DIR *)MemMalloc( size, "RES_DIR" );

	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _dir$[ebp], eax

; 2427 : 		#endif
; 2428 :     
; 2429 :         dir -> filenames = (char**)((char*)dir + sizeof( RES_DIR ));

	mov	edx, DWORD PTR _dir$[ebp]
	add	edx, 24					; 00000018H
	mov	eax, DWORD PTR _dir$[ebp]
	mov	DWORD PTR [eax+8], edx

; 2430 :         dir -> string_pool = (char*)dir + sizeof( RES_DIR ) + (sizeof(char *) * (hsh -> num_entries));

	mov	ecx, DWORD PTR _hsh$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _dir$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4+24]
	mov	edx, DWORD PTR _dir$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 2431 : 
; 2432 :         if( !dir -> filenames || !dir -> string_pool ) {

	mov	eax, DWORD PTR _dir$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN9@ResOpenDir
	mov	ecx, DWORD PTR _dir$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	jne	SHORT $LN10@ResOpenDir
$LN9@ResOpenDir:

; 2433 :             SAY_ERROR( RES_ERR_NO_MEMORY, "ResOpenDirectory" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	2433					; 00000981H
	push	OFFSET ??_C@_0BB@PLBNNMEI@ResOpenDirectory?$AA@
	push	-4999					; ffffec79H
	call	__say_error
	add	esp, 16					; 00000010H

; 2434 :             return( NULL );

	xor	eax, eax
	jmp	$LN13@ResOpenDir
$LN10@ResOpenDir:

; 2435 :         }
; 2436 : 
; 2437 :         dir -> string_ptr = dir -> string_pool;

	mov	edx, DWORD PTR _dir$[ebp]
	mov	eax, DWORD PTR _dir$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 2438 : 
; 2439 :         RES_STRING_SET( dir -> name, entry -> name, dir -> string_ptr );

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _dir$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_strcpy
	add	esp, 8
	mov	eax, DWORD PTR _dir$[ebp]
	mov	ecx, DWORD PTR _dir$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+20], edx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	edx, DWORD PTR _dir$[ebp]
	mov	ecx, DWORD PTR [edx+16]
	lea	edx, DWORD PTR [eax+ecx+1]
	mov	eax, DWORD PTR _dir$[ebp]
	mov	DWORD PTR [eax+16], edx

; 2440 : 
; 2441 :         index = 0;

	mov	DWORD PTR _index$[ebp], 0

; 2442 : 
; 2443 :         for( i = 0; i < hsh->table_size; i++ ) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN8@ResOpenDir
$LN7@ResOpenDir:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN8@ResOpenDir:
	mov	edx, DWORD PTR _hsh$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx]
	jge	$LN6@ResOpenDir

; 2444 :             entry = &hsh -> table[i];

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _hsh$[ebp]
	add	ecx, DWORD PTR [edx+24]
	mov	DWORD PTR _entry$[ebp], ecx

; 2445 : 
; 2446 :             if( entry -> next ) {

	mov	eax, DWORD PTR _entry$[ebp]
	cmp	DWORD PTR [eax+44], 0
	je	$LN5@ResOpenDir
$LN4@ResOpenDir:

; 2447 :                 while( entry ) {

	cmp	DWORD PTR _entry$[ebp], 0
	je	$LN3@ResOpenDir

; 2448 :                     RES_STRING_SET( dir -> filenames[ index++ ], entry -> name, dir -> string_ptr );

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _dir$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_strcpy
	add	esp, 8
	mov	edx, DWORD PTR _dir$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _index$[ebp]
	mov	edx, DWORD PTR _dir$[ebp]
	mov	edx, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+ecx*4], edx
	mov	eax, DWORD PTR _index$[ebp]
	add	eax, 1
	mov	DWORD PTR _index$[ebp], eax
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _dir$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	lea	eax, DWORD PTR [eax+edx+1]
	mov	ecx, DWORD PTR _dir$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 2449 :                     entry = entry -> next;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR _entry$[ebp], eax

; 2450 :                 }

	jmp	$LN4@ResOpenDir
$LN3@ResOpenDir:

; 2451 :             }
; 2452 :             else {

	jmp	SHORT $LN2@ResOpenDir
$LN5@ResOpenDir:

; 2453 :                 if( entry -> attrib ) {

	mov	ecx, DWORD PTR _entry$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	je	SHORT $LN2@ResOpenDir

; 2454 :                     RES_STRING_SET( dir -> filenames[ index++ ], entry -> name, dir -> string_ptr );

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _dir$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_strcpy
	add	esp, 8
	mov	eax, DWORD PTR _dir$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _dir$[ebp]
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+edx*4], eax
	mov	ecx, DWORD PTR _index$[ebp]
	add	ecx, 1
	mov	DWORD PTR _index$[ebp], ecx
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _dir$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	lea	eax, DWORD PTR [eax+edx+1]
	mov	ecx, DWORD PTR _dir$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN2@ResOpenDir:

; 2455 :                 }
; 2456 :             }
; 2457 :         }

	jmp	$LN7@ResOpenDir
$LN6@ResOpenDir:

; 2458 : 
; 2459 :         dir -> num_entries = index;

	mov	edx, DWORD PTR _dir$[ebp]
	mov	eax, DWORD PTR _index$[ebp]
	mov	DWORD PTR [edx+4], eax

; 2460 :         dir -> current = 0;

	mov	ecx, DWORD PTR _dir$[ebp]
	mov	DWORD PTR [ecx], 0

; 2461 : 
; 2462 : #if( RES_DEBUG_VERSION )
; 2463 :         OPEN_DIR_LIST = LIST_APPEND( OPEN_DIR_LIST, dir );

	mov	edx, DWORD PTR _dir$[ebp]
	push	edx
	mov	eax, DWORD PTR _OPEN_DIR_LIST
	push	eax
	call	_ListAppend
	add	esp, 8
	mov	DWORD PTR _OPEN_DIR_LIST, eax

; 2464 : #endif /* RES_DEBUG_VERSION */
; 2465 : 
; 2466 :         return( dir );

	mov	eax, DWORD PTR _dir$[ebp]
	jmp	SHORT $LN13@ResOpenDir
$LN11@ResOpenDir:

; 2467 :     }
; 2468 : #endif /* !RES_USE_FLAT_MODEL */
; 2469 : 
; 2470 :     return( NULL ); /* only usefull in the hierarchical version */

	xor	eax, eax
$LN13@ResOpenDir:

; 2471 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_ResOpenDirectory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_check$ = -1092						; size = 4
_status$ = -1088					; size = 4
_handle$ = -1084					; size = 4
_fileinfo$ = -1080					; size = 296
_old_cwd$ = -784					; size = 260
_recurse_path$1 = -524					; size = 260
_full_path$ = -264					; size = 260
__$ArrayPad$ = -4					; size = 4
_pathname$ = 8						; size = 4
_forced$ = 12						; size = 4
_ResDeleteDirectory PROC

; 2275 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1092				; 00000444H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2276 :    int  handle,
; 2277 :         check,
; 2278 :         status;
; 2279 : 
; 2280 :     char full_path[ MAX_PATH ], 
; 2281 :          old_cwd[ MAX_PATH ];
; 2282 : 
; 2283 :     struct _finddata_t fileinfo;
; 2284 : 
; 2285 :     status = 0;

	mov	DWORD PTR _status$[ebp], 0

; 2286 : 
; 2287 :     handle = _findfirst( pathname, &fileinfo );

	lea	eax, DWORD PTR _fileinfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pathname$[ebp]
	push	ecx
	call	__findfirst64i32
	add	esp, 8
	mov	DWORD PTR _handle$[ebp], eax

; 2288 : 
; 2289 :     if( handle == -1 )

	cmp	DWORD PTR _handle$[ebp], -1
	jne	SHORT $LN11@ResDeleteD

; 2290 :         return( FALSE );   /* couldn't find directory */

	xor	eax, eax
	jmp	$LN12@ResDeleteD
$LN11@ResDeleteD:

; 2291 : 
; 2292 :     IF_LOG( LOG( "deltree: %s\n", pathname ));
; 2293 : 
; 2294 :     if(!(fileinfo.attrib & _A_SUBDIR)) {

	mov	edx, DWORD PTR _fileinfo$[ebp]
	and	edx, 16					; 00000010H
	jne	SHORT $LN10@ResDeleteD

; 2295 :         SAY_ERROR( RES_ERR_IS_NOT_DIRECTORY, pathname );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	2295					; 000008f7H
	mov	eax, DWORD PTR _pathname$[ebp]
	push	eax
	push	-4989					; ffffec83H
	call	__say_error
	add	esp, 16					; 00000010H

; 2296 :         return( FALSE );

	xor	eax, eax
	jmp	$LN12@ResDeleteD
$LN10@ResDeleteD:

; 2297 :     }
; 2298 : 
; 2299 :     _findclose( handle );

	mov	ecx, DWORD PTR _handle$[ebp]
	push	ecx
	call	__findclose
	add	esp, 4

; 2300 :    
; 2301 :     _getcwd(old_cwd,MAX_PATH);

	push	260					; 00000104H
	lea	edx, DWORD PTR _old_cwd$[ebp]
	push	edx
	call	__getcwd
	add	esp, 8

; 2302 :     _chdir(pathname);

	mov	eax, DWORD PTR _pathname$[ebp]
	push	eax
	call	__chdir
	add	esp, 4

; 2303 : 
; 2304 :     sprintf(full_path,"%s\\*.*",pathname);

	mov	ecx, DWORD PTR _pathname$[ebp]
	push	ecx
	push	OFFSET ??_C@_06BNHEIDIH@?$CFs?2?$CK?4?$CK?$AA@
	lea	edx, DWORD PTR _full_path$[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 2305 :     handle = _findfirst( full_path, &fileinfo );

	lea	eax, DWORD PTR _fileinfo$[ebp]
	push	eax
	lea	ecx, DWORD PTR _full_path$[ebp]
	push	ecx
	call	__findfirst64i32
	add	esp, 8
	mov	DWORD PTR _handle$[ebp], eax
$LN9@ResDeleteD:

; 2306 : 
; 2307 :     while( status != -1 ) {

	cmp	DWORD PTR _status$[ebp], -1
	je	$LN8@ResDeleteD

; 2308 : 
; 2309 :         if (!stricmp(fileinfo.name,".") || !stricmp(fileinfo.name,"..")) {

	push	OFFSET ??_C@_01LFCBOECM@?4?$AA@
	lea	edx, DWORD PTR _fileinfo$[ebp+36]
	push	edx
	call	_stricmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@ResDeleteD
	push	OFFSET ??_C@_02DJGKEECL@?4?4?$AA@
	lea	eax, DWORD PTR _fileinfo$[ebp+36]
	push	eax
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN7@ResDeleteD
$LN6@ResDeleteD:

; 2310 :             status = _findnext( handle, &fileinfo );

	lea	ecx, DWORD PTR _fileinfo$[ebp]
	push	ecx
	mov	edx, DWORD PTR _handle$[ebp]
	push	edx
	call	__findnext64i32
	add	esp, 8
	mov	DWORD PTR _status$[ebp], eax

; 2311 :             continue;

	jmp	SHORT $LN9@ResDeleteD
$LN7@ResDeleteD:

; 2312 :         }
; 2313 : 
; 2314 :         if(fileinfo.attrib & _A_SUBDIR) {

	mov	eax, DWORD PTR _fileinfo$[ebp]
	and	eax, 16					; 00000010H
	je	SHORT $LN5@ResDeleteD

; 2315 :             char recurse_path[MAX_PATH];
; 2316 :             sprintf(recurse_path,"%s\\%s",pathname,fileinfo.name);

	lea	ecx, DWORD PTR _fileinfo$[ebp+36]
	push	ecx
	mov	edx, DWORD PTR _pathname$[ebp]
	push	edx
	push	OFFSET ??_C@_05BMGBEOOC@?$CFs?2?$CFs?$AA@
	lea	eax, DWORD PTR _recurse_path$1[ebp]
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H

; 2317 :             ResDeleteDirectory(recurse_path,TRUE);

	push	1
	lea	ecx, DWORD PTR _recurse_path$1[ebp]
	push	ecx
	call	_ResDeleteDirectory
	add	esp, 8

; 2318 :             status = _findnext( handle, &fileinfo );

	lea	edx, DWORD PTR _fileinfo$[ebp]
	push	edx
	mov	eax, DWORD PTR _handle$[ebp]
	push	eax
	call	__findnext64i32
	add	esp, 8
	mov	DWORD PTR _status$[ebp], eax

; 2319 :             continue;

	jmp	$LN9@ResDeleteD
$LN5@ResDeleteD:

; 2320 :         }
; 2321 : 
; 2322 :         check = remove( fileinfo.name );

	lea	ecx, DWORD PTR _fileinfo$[ebp+36]
	push	ecx
	call	_remove
	add	esp, 4
	mov	DWORD PTR _check$[ebp], eax

; 2323 : 
; 2324 :         if( check == -1 ) {

	cmp	DWORD PTR _check$[ebp], -1
	jne	SHORT $LN4@ResDeleteD

; 2325 :             if( forced ) {

	cmp	DWORD PTR _forced$[ebp], 0
	je	SHORT $LN3@ResDeleteD

; 2326 :                 chmod( fileinfo.name, _S_IWRITE );

	push	128					; 00000080H
	lea	edx, DWORD PTR _fileinfo$[ebp+36]
	push	edx
	call	_chmod
	add	esp, 8

; 2327 :                 check = remove( fileinfo.name );

	lea	eax, DWORD PTR _fileinfo$[ebp+36]
	push	eax
	call	_remove
	add	esp, 4
	mov	DWORD PTR _check$[ebp], eax
$LN3@ResDeleteD:

; 2328 :             }
; 2329 : 
; 2330 :             if( check == -1 ) {

	cmp	DWORD PTR _check$[ebp], -1
	jne	SHORT $LN4@ResDeleteD

; 2331 :                 SAY_ERROR( RES_ERR_COULD_NOT_DELETE, fileinfo.name );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	2331					; 0000091bH
	lea	ecx, DWORD PTR _fileinfo$[ebp+36]
	push	ecx
	push	-4988					; ffffec84H
	call	__say_error
	add	esp, 16					; 00000010H

; 2332 :                 break;

	jmp	SHORT $LN8@ResDeleteD
$LN4@ResDeleteD:

; 2333 :             }
; 2334 :         }
; 2335 : 
; 2336 :         status = _findnext( handle, &fileinfo );

	lea	edx, DWORD PTR _fileinfo$[ebp]
	push	edx
	mov	eax, DWORD PTR _handle$[ebp]
	push	eax
	call	__findnext64i32
	add	esp, 8
	mov	DWORD PTR _status$[ebp], eax

; 2337 :     }

	jmp	$LN9@ResDeleteD
$LN8@ResDeleteD:

; 2338 :       
; 2339 :     _findclose( handle );

	mov	ecx, DWORD PTR _handle$[ebp]
	push	ecx
	call	__findclose
	add	esp, 4

; 2340 : 
; 2341 :     _chdir(old_cwd);

	lea	edx, DWORD PTR _old_cwd$[ebp]
	push	edx
	call	__chdir
	add	esp, 4

; 2342 : 
; 2343 :     _rmdir(pathname);

	mov	eax, DWORD PTR _pathname$[ebp]
	push	eax
	call	__rmdir
	add	esp, 4

; 2344 : 
; 2345 :     if( handle == -1 ) {

	cmp	DWORD PTR _handle$[ebp], -1
	jne	SHORT $LN1@ResDeleteD

; 2346 :         SAY_ERROR( RES_ERR_COULD_NOT_DELETE, pathname );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	2346					; 0000092aH
	mov	ecx, DWORD PTR _pathname$[ebp]
	push	ecx
	push	-4988					; ffffec84H
	call	__say_error
	add	esp, 16					; 00000010H

; 2347 :         return( FALSE );

	xor	eax, eax
	jmp	SHORT $LN12@ResDeleteD
$LN1@ResDeleteD:

; 2348 :     }
; 2349 : 
; 2350 :     return( TRUE );  

	mov	eax, 1
$LN12@ResDeleteD:

; 2351 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_ResDeleteDirectory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_check$ = -4						; size = 4
_pathname$ = 8						; size = 4
_ResMakeDirectory PROC

; 2225 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2226 :     int check;
; 2227 : 
; 2228 : #if( RES_DEBUG_PARAMS )
; 2229 :     if( !pathname ) {

	cmp	DWORD PTR _pathname$[ebp], 0
	jne	SHORT $LN5@ResMakeDir

; 2230 :         SAY_ERROR( RES_ERR_INCORRECT_PARAMETER, "ResMakeDirectory" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	2230					; 000008b6H
	push	OFFSET ??_C@_0BB@LJPCDDOA@ResMakeDirectory?$AA@
	push	-4998					; ffffec7aH
	call	__say_error
	add	esp, 16					; 00000010H

; 2231 :         return( FALSE );

	xor	eax, eax
	jmp	SHORT $LN6@ResMakeDir
$LN5@ResMakeDir:

; 2232 :     }
; 2233 : #endif
; 2234 : 
; 2235 :     check = _mkdir( pathname );

	mov	eax, DWORD PTR _pathname$[ebp]
	push	eax
	call	__mkdir
	add	esp, 4
	mov	DWORD PTR _check$[ebp], eax

; 2236 : 
; 2237 :     IF_LOG( LOG( "mkdir: %s\n", pathname ));
; 2238 : 
; 2239 :     if( check == -1 ) {

	cmp	DWORD PTR _check$[ebp], -1
	jne	SHORT $LN4@ResMakeDir

; 2240 : #if( RES_DEBUG_PARAMS )
; 2241 :         if( errno == EACCES ) {

	call	__errno
	cmp	DWORD PTR [eax], 13			; 0000000dH
	jne	SHORT $LN3@ResMakeDir

; 2242 :             SAY_ERROR( RES_ERR_DIRECTORY_EXISTS, pathname );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	2242					; 000008c2H
	mov	ecx, DWORD PTR _pathname$[ebp]
	push	ecx
	push	-4990					; ffffec82H
	call	__say_error
	add	esp, 16					; 00000010H

; 2243 :         }
; 2244 :         else

	jmp	SHORT $LN2@ResMakeDir
$LN3@ResMakeDir:

; 2245 :             if( errno == ENOENT ) {

	call	__errno
	cmp	DWORD PTR [eax], 2
	jne	SHORT $LN2@ResMakeDir

; 2246 :                 SAY_ERROR( RES_ERR_PATH_NOT_FOUND, pathname );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	2246					; 000008c6H
	mov	edx, DWORD PTR _pathname$[ebp]
	push	edx
	push	-4997					; ffffec7bH
	call	__say_error
	add	esp, 16					; 00000010H
$LN2@ResMakeDir:

; 2247 :             }
; 2248 : #endif /* RES_DEBUG_PARAMS */
; 2249 : 
; 2250 :         return( FALSE );

	xor	eax, eax
	jmp	SHORT $LN6@ResMakeDir
$LN4@ResMakeDir:

; 2251 :     }
; 2252 : 
; 2253 :     ResAddPath( pathname, FALSE );

	push	0
	mov	eax, DWORD PTR _pathname$[ebp]
	push	eax
	call	_ResAddPath
	add	esp, 8

; 2254 : 
; 2255 :     return( TRUE );

	mov	eax, 1
$LN6@ResMakeDir:

; 2256 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ResMakeDirectory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
tv79 = -8						; size = 4
_pos$ = -4						; size = 4
_stream$ = 8						; size = 4
_offset$ = 12						; size = 4
_whence$ = 16						; size = 4
_ResFSeek PROC

; 5583 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 5584 :     unsigned int pos;
; 5585 : 
; 5586 : #if( RES_DEBUG_PARAMS )
; 5587 :     if( !stream ) {

	cmp	DWORD PTR _stream$[ebp], 0
	jne	SHORT $LN17@ResFSeek

; 5588 :         SAY_ERROR( RES_ERR_INCORRECT_PARAMETER, "fseek" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	5588					; 000015d4H
	push	OFFSET ??_C@_05OKAPJEJC@fseek?$AA@
	push	-4998					; ffffec7aH
	call	__say_error
	add	esp, 16					; 00000010H

; 5589 :         return(-1);

	or	eax, -1
	jmp	$LN18@ResFSeek
$LN17@ResFSeek:

; 5590 :     }
; 5591 : #endif /* RES_DEBUG_PARAMS */
; 5592 : #if (RES_MULTITHREAD)
; 5593 : 	REQUEST_LOCK(GLOCK);

	push	-1
	mov	eax, DWORD PTR _GLOCK
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8

; 5594 : #endif
; 5595 : 
; 5596 :     LOCK_STREAM( stream );

	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	call	__lock_file
	add	esp, 4

; 5597 : 
; 5598 :     if( stream -> _flag & _IOARCHIVE ) {

	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx+12]
	and	eax, 65536				; 00010000H
	je	$LN16@ResFSeek

; 5599 :        pos = FILE_HANDLES[ stream -> _file ].current_pos;

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	imul	edx, 52					; 00000034H
	mov	eax, DWORD PTR _FILE_HANDLES
	mov	ecx, DWORD PTR [eax+edx+8]
	mov	DWORD PTR _pos$[ebp], ecx

; 5600 : 
; 5601 :         switch( whence ) {

	mov	edx, DWORD PTR _whence$[ebp]
	mov	DWORD PTR tv79[ebp], edx
	cmp	DWORD PTR tv79[ebp], 0
	je	SHORT $LN13@ResFSeek
	cmp	DWORD PTR tv79[ebp], 1
	je	SHORT $LN12@ResFSeek
	cmp	DWORD PTR tv79[ebp], 2
	je	SHORT $LN11@ResFSeek
	jmp	SHORT $LN14@ResFSeek
$LN13@ResFSeek:

; 5602 :             case SEEK_SET: /* 0 */
; 5603 :                 pos = offset;

	mov	eax, DWORD PTR _offset$[ebp]
	mov	DWORD PTR _pos$[ebp], eax

; 5604 :                 break;

	jmp	SHORT $LN14@ResFSeek
$LN12@ResFSeek:

; 5605 :             case SEEK_CUR: /* 1 */
; 5606 :                 pos += offset;

	mov	ecx, DWORD PTR _pos$[ebp]
	add	ecx, DWORD PTR _offset$[ebp]
	mov	DWORD PTR _pos$[ebp], ecx

; 5607 :                 break;

	jmp	SHORT $LN14@ResFSeek
$LN11@ResFSeek:

; 5608 :             case SEEK_END: /* 2 */
; 5609 :                 pos = FILE_HANDLES[ stream -> _file ].size + offset;

	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx+16]
	imul	eax, 52					; 00000034H
	mov	ecx, DWORD PTR _FILE_HANDLES
	mov	edx, DWORD PTR [ecx+eax+12]
	add	edx, DWORD PTR _offset$[ebp]
	mov	DWORD PTR _pos$[ebp], edx
$LN14@ResFSeek:

; 5610 :                 break;
; 5611 :         }
; 5612 : 
; 5613 :         stream -> _cnt = 0; /* force next read to replenish buffers */

	mov	eax, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [eax+4], 0

; 5614 :         stream -> _ptr = stream -> _base;

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx], eax

; 5615 : 
; 5616 :         UNLOCK_STREAM( stream );

	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	call	__unlock_file
	add	esp, 4

; 5617 :         if( pos > FILE_HANDLES[ stream -> _file ].size )

	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx+16]
	imul	eax, 52					; 00000034H
	mov	ecx, DWORD PTR _FILE_HANDLES
	mov	edx, DWORD PTR _pos$[ebp]
	cmp	edx, DWORD PTR [ecx+eax+12]
	jbe	SHORT $LN10@ResFSeek

; 5618 : 		{
; 5619 : #if (RES_MULTITHREAD)
; 5620 : 	RELEASE_LOCK(GLOCK);

	mov	eax, DWORD PTR _GLOCK
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4

; 5621 : #endif
; 5622 :               return( -1 );

	or	eax, -1
	jmp	$LN18@ResFSeek
$LN10@ResFSeek:

; 5623 : 		}
; 5624 :         FILE_HANDLES[ stream -> _file ].current_pos = pos;

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	imul	edx, 52					; 00000034H
	mov	eax, DWORD PTR _FILE_HANDLES
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	DWORD PTR [eax+edx+8], ecx

; 5625 :   
; 5626 : 
; 5627 : #if (RES_MULTITHREAD)
; 5628 : 	RELEASE_LOCK(GLOCK);

	mov	edx, DWORD PTR _GLOCK
	push	edx
	call	DWORD PTR __imp__ReleaseMutex@4

; 5629 : #endif
; 5630 : 
; 5631 :         return(0);

	xor	eax, eax
	jmp	$LN18@ResFSeek

; 5632 :     }
; 5633 :     else {    

	jmp	$LN9@ResFSeek
$LN16@ResFSeek:

; 5634 :         if( !inuse(stream) || 
; 5635 :              ((whence != SEEK_SET) && 
; 5636 :               (whence != SEEK_CUR) &&
; 5637 :               (whence != SEEK_END)) ) 

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 131				; 00000083H
	je	SHORT $LN7@ResFSeek
	cmp	DWORD PTR _whence$[ebp], 0
	je	SHORT $LN8@ResFSeek
	cmp	DWORD PTR _whence$[ebp], 1
	je	SHORT $LN8@ResFSeek
	cmp	DWORD PTR _whence$[ebp], 2
	je	SHORT $LN8@ResFSeek
$LN7@ResFSeek:

; 5638 :         {
; 5639 :             errno=EINVAL;

	call	__errno
	mov	DWORD PTR [eax], 22			; 00000016H

; 5640 :             UNLOCK_STREAM( stream );

	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	call	__unlock_file
	add	esp, 4

; 5641 : #if (RES_MULTITHREAD)
; 5642 : 	RELEASE_LOCK(GLOCK);

	mov	eax, DWORD PTR _GLOCK
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4

; 5643 : #endif
; 5644 :             return(-1);

	or	eax, -1
	jmp	$LN18@ResFSeek
$LN8@ResFSeek:

; 5645 :         }
; 5646 : 
; 5647 :         /* Clear EOF flag */
; 5648 : 
; 5649 :         stream -> _flag &= ~_IOEOF;

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	and	edx, -17				; ffffffefH
	mov	eax, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [eax+12], edx

; 5650 : 
; 5651 :         /* If seeking relative to current location, then convert to
; 5652 :            a seek relative to beginning of file.  This accounts for
; 5653 :            buffering, etc. by letting fseek() tell us where we are. */
; 5654 : 
; 5655 :         if( whence == SEEK_CUR ) {

	cmp	DWORD PTR _whence$[ebp], 1
	jne	SHORT $LN6@ResFSeek

; 5656 :             offset += ftell( stream );

	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	call	_ResFTell
	add	esp, 4
	add	eax, DWORD PTR _offset$[ebp]
	mov	DWORD PTR _offset$[ebp], eax

; 5657 :             whence = SEEK_SET;

	mov	DWORD PTR _whence$[ebp], 0
$LN6@ResFSeek:

; 5658 :         }
; 5659 : 
; 5660 :         /* Flush buffer as necessary */
; 5661 : 
; 5662 :         _flush(stream);

	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	call	__flush
	add	esp, 4

; 5663 : 
; 5664 :         /* If file opened for read/write, clear flags since we don't know
; 5665 :            what the user is going to do next. If the file was opened for
; 5666 :            read access only, decrease _bufsiz so that the next _filbuf
; 5667 :            won't cost quite so much */
; 5668 : 
; 5669 :         if( stream->_flag & _IORW )

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 128				; 00000080H
	je	SHORT $LN5@ResFSeek

; 5670 :             stream->_flag &= ~(_IOWRT|_IOREAD);

	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx+12]
	and	eax, -4					; fffffffcH
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 5671 :         else {

	jmp	SHORT $LN4@ResFSeek
$LN5@ResFSeek:

; 5672 :             if( (stream->_flag & _IOREAD) && 
; 5673 :                 (stream->_flag & _IOMYBUF) &&
; 5674 :                !(stream->_flag & _IOSETVBUF))

	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx+12]
	and	eax, 1
	je	SHORT $LN4@ResFSeek
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	and	edx, 8
	je	SHORT $LN4@ResFSeek
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 1024				; 00000400H
	jne	SHORT $LN4@ResFSeek

; 5675 :             {
; 5676 :                 stream->_bufsiz = _SMALL_BUFSIZ;

	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx+24], 512			; 00000200H
$LN4@ResFSeek:

; 5677 :             }
; 5678 :         }
; 5679 : 
; 5680 : 
; 5681 :         /* Seek to the desired locale and return. */
; 5682 : 
; 5683 :         //#ifdef _MT
; 5684 :             pos = _lseek( stream -> _file, offset, whence );

	mov	eax, DWORD PTR _whence$[ebp]
	push	eax
	mov	ecx, DWORD PTR _offset$[ebp]
	push	ecx
	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	__lseek
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pos$[ebp], eax

; 5685 :         //#else
; 5686 :         //    pos = _lseek_lk( stream -> _file, offset, whence );
; 5687 :         //#endif
; 5688 : 
; 5689 : 
; 5690 :         stream -> _ptr = stream -> _base;

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx], eax

; 5691 : 
; 5692 :         // There is no file handle assosciated with a streaming 'loose'
; 5693 :         // file.  Therefore... the following fix was actually scribling
; 5694 :         // memory.
; 5695 :         
; 5696 :         // if( pos != -1 )
; 5697 :         //     FILE_HANDLES[ stream -> _file ].current_pos = pos; [KBR SEPT 10 96]
; 5698 : 
; 5699 :         if( pos == -1 )

	cmp	DWORD PTR _pos$[ebp], -1
	jne	SHORT $LN2@ResFSeek

; 5700 : 		{
; 5701 : #if (RES_MULTITHREAD)
; 5702 : 	RELEASE_LOCK(GLOCK);

	mov	ecx, DWORD PTR _GLOCK
	push	ecx
	call	DWORD PTR __imp__ReleaseMutex@4

; 5703 : #endif
; 5704 :             return( -1 );

	or	eax, -1
	jmp	SHORT $LN18@ResFSeek
$LN2@ResFSeek:

; 5705 : 		}
; 5706 : 
; 5707 : 
; 5708 :         if(( stream -> _flag & _IOARCHIVE ) && (pos != -1))

	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx+12]
	and	eax, 65536				; 00010000H
	je	SHORT $LN9@ResFSeek
	cmp	DWORD PTR _pos$[ebp], -1
	je	SHORT $LN9@ResFSeek

; 5709 :             FILE_HANDLES[ stream -> _file ].current_pos = pos;

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	imul	edx, 52					; 00000034H
	mov	eax, DWORD PTR _FILE_HANDLES
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	DWORD PTR [eax+edx+8], ecx
$LN9@ResFSeek:

; 5710 :     }
; 5711 : 
; 5712 :     UNLOCK_STREAM( stream );

	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	call	__unlock_file
	add	esp, 4

; 5713 : #if (RES_MULTITHREAD)
; 5714 : 	RELEASE_LOCK(GLOCK);

	mov	eax, DWORD PTR _GLOCK
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4

; 5715 : #endif
; 5716 : 
; 5717 :     return(0);    

	xor	eax, eax
$LN18@ResFSeek:

; 5718 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ResFSeek ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_c$ = -36						; size = 4
tv146 = -32						; size = 4
tv82 = -28						; size = 4
_total$ = -24						; size = 4
_nread$ = -20						; size = 4
_bufsize$ = -16						; size = 4
_nbytes$ = -12						; size = 4
_data$ = -8						; size = 4
_count$ = -4						; size = 4
_buffer$ = 8						; size = 4
_size$ = 12						; size = 4
_num$ = 16						; size = 4
_stream$ = 20						; size = 4
_ResFRead PROC

; 5232 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 5233 :     char *data;                     /* point to where should be read next */
; 5234 :     unsigned total;                 /* total bytes to read */
; 5235 :     unsigned count;                 /* num bytes left to read */
; 5236 :     unsigned bufsize;               /* size of stream buffer */
; 5237 :     unsigned nbytes;                /* how much to read now */
; 5238 :     unsigned nread;                 /* how much we did read */
; 5239 :     int c;                          /* a temp char */
; 5240 : 
; 5241 : 
; 5242 :     /* initialize local vars */
; 5243 :     data = buffer;

	mov	eax, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _data$[ebp], eax

; 5244 : 
; 5245 : 
; 5246 :     if((count = total = size * num) == 0 )

	mov	ecx, DWORD PTR _size$[ebp]
	imul	ecx, DWORD PTR _num$[ebp]
	mov	DWORD PTR _total$[ebp], ecx
	mov	edx, DWORD PTR _total$[ebp]
	mov	DWORD PTR _count$[ebp], edx
	cmp	DWORD PTR _count$[ebp], 0
	jne	SHORT $LN15@ResFRead

; 5247 :         return 0;

	xor	eax, eax
	jmp	$LN16@ResFRead
$LN15@ResFRead:

; 5248 : 
; 5249 : #if (RES_MULTITHREAD)
; 5250 : 	REQUEST_LOCK(GLOCK);

	push	-1
	mov	eax, DWORD PTR _GLOCK
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8

; 5251 : #endif
; 5252 : 
; 5253 :     LOCK_STREAM( stream );

	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	call	__lock_file
	add	esp, 4

; 5254 : 
; 5255 :     if(anybuf(stream)) /* already has buffer, use its size */

	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx+12]
	and	eax, 268				; 0000010cH
	je	SHORT $LN14@ResFRead

; 5256 :         bufsize = stream->_bufsiz;

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _bufsize$[ebp], edx

; 5257 :     else 

	jmp	SHORT $LN12@ResFRead
$LN14@ResFRead:

; 5258 : #if defined (_M_M68K) || defined (_M_MPPC)
; 5259 :         bufsize = BUFSIZ;           /* assume will get BUFSIZ buffer */
; 5260 : #else  /* defined (_M_M68K) || defined (_M_MPPC) */
; 5261 :         bufsize = _INTERNAL_BUFSIZ; /* assume will get _INTERNAL_BUFSIZ buffer */

	mov	DWORD PTR _bufsize$[ebp], 4096		; 00001000H
$LN12@ResFRead:

; 5262 : #endif  /* defined (_M_M68K) || defined (_M_MPPC) */
; 5263 : 
; 5264 :         /* here is the main loop -- we go through here until we're done */
; 5265 :         while (count != 0) {

	cmp	DWORD PTR _count$[ebp], 0
	je	$LN11@ResFRead

; 5266 :                 /* if the buffer exists and has characters, copy them to user
; 5267 :                    buffer */
; 5268 :                 if (anybuf(stream) && stream->_cnt != 0) {

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 268				; 0000010cH
	je	$LN10@ResFRead
	mov	edx, DWORD PTR _stream$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	$LN10@ResFRead

; 5269 :                         /* how much do we want? */
; 5270 :                         nbytes = (count < (unsigned)stream->_cnt) ? count : stream->_cnt;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN18@ResFRead
	mov	edx, DWORD PTR _count$[ebp]
	mov	DWORD PTR tv82[ebp], edx
	jmp	SHORT $LN19@ResFRead
$LN18@ResFRead:
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR tv82[ebp], ecx
$LN19@ResFRead:
	mov	edx, DWORD PTR tv82[ebp]
	mov	DWORD PTR _nbytes$[ebp], edx

; 5271 :                         memcpy(data, stream->_ptr, nbytes);

	mov	eax, DWORD PTR _nbytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 5272 : 
; 5273 :                         /* update stream and amt of data read */
; 5274 :                         count -= nbytes;

	mov	ecx, DWORD PTR _count$[ebp]
	sub	ecx, DWORD PTR _nbytes$[ebp]
	mov	DWORD PTR _count$[ebp], ecx

; 5275 :                         stream->_cnt -= nbytes;

	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, DWORD PTR _nbytes$[ebp]
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 5276 :                         stream->_ptr += nbytes;

	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, DWORD PTR _nbytes$[ebp]
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx], eax

; 5277 :                         data += nbytes;

	mov	edx, DWORD PTR _data$[ebp]
	add	edx, DWORD PTR _nbytes$[ebp]
	mov	DWORD PTR _data$[ebp], edx

; 5278 : /* GFG_NOV06 */
; 5279 :                         if( stream -> _flag & _IOARCHIVE )

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 65536				; 00010000H
	je	SHORT $LN9@ResFRead

; 5280 :                              FILE_HANDLES[ stream -> _file ].current_pos += nbytes;

	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx+16]
	imul	eax, 52					; 00000034H
	mov	ecx, DWORD PTR _FILE_HANDLES
	mov	edx, DWORD PTR [ecx+eax+8]
	add	edx, DWORD PTR _nbytes$[ebp]
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	imul	ecx, 52					; 00000034H
	mov	eax, DWORD PTR _FILE_HANDLES
	mov	DWORD PTR [eax+ecx+8], edx
$LN9@ResFRead:

; 5281 : 
; 5282 : 
; 5283 : 
; 5284 : 
; 5285 :                 }              //          |<---------- MODIFIED ----------->|
; 5286 :                 else if ((count >= bufsize) && !(stream -> _flag & _IOARCHIVE)) {

	jmp	$LN8@ResFRead
$LN10@ResFRead:
	mov	ecx, DWORD PTR _count$[ebp]
	cmp	ecx, DWORD PTR _bufsize$[ebp]
	jb	$LN7@ResFRead
	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx+12]
	and	eax, 65536				; 00010000H
	jne	$LN7@ResFRead

; 5287 :                                //          |<---------- MODIFIED ----------->|
; 5288 :                         /* If we have more than bufsize chars to read, get data
; 5289 :                            by calling read with an integral number of bufsiz
; 5290 :                            blocks.  Note that if the stream is text mode, read
; 5291 :                            will return less chars than we ordered. */
; 5292 : 
; 5293 :                         /* calc chars to read -- (count/bufsize) * bufsize */
; 5294 :                         nbytes = ( bufsize ? (count - count % bufsize) :
; 5295 :                                    count );

	cmp	DWORD PTR _bufsize$[ebp], 0
	je	SHORT $LN20@ResFRead
	mov	eax, DWORD PTR _count$[ebp]
	xor	edx, edx
	div	DWORD PTR _bufsize$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	sub	ecx, edx
	mov	DWORD PTR tv146[ebp], ecx
	jmp	SHORT $LN21@ResFRead
$LN20@ResFRead:
	mov	edx, DWORD PTR _count$[ebp]
	mov	DWORD PTR tv146[ebp], edx
$LN21@ResFRead:
	mov	eax, DWORD PTR tv146[ebp]
	mov	DWORD PTR _nbytes$[ebp], eax

; 5296 : 
; 5297 :                         UNLOCK_STREAM( stream );

	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	call	__unlock_file
	add	esp, 4

; 5298 :                         nread = _read(_fileno(stream), data, nbytes);

	mov	edx, DWORD PTR _nbytes$[ebp]
	push	edx
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	call	__fileno
	add	esp, 4
	push	eax
	call	__read
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _nread$[ebp], eax

; 5299 :                         LOCK_STREAM( stream );

	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	call	__lock_file
	add	esp, 4

; 5300 : 
; 5301 :                         if (nread == 0) {

	cmp	DWORD PTR _nread$[ebp], 0
	jne	SHORT $LN6@ResFRead

; 5302 :                                 /* end of file -- out of here */
; 5303 :                                 stream->_flag |= _IOEOF;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	or	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 5304 :                                 UNLOCK_STREAM( stream );

	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	call	__unlock_file
	add	esp, 4

; 5305 : #if (RES_MULTITHREAD)
; 5306 : 	RELEASE_LOCK(GLOCK);

	mov	ecx, DWORD PTR _GLOCK
	push	ecx
	call	DWORD PTR __imp__ReleaseMutex@4

; 5307 : #endif
; 5308 :                                 return (total - count) / size;

	mov	eax, DWORD PTR _total$[ebp]
	sub	eax, DWORD PTR _count$[ebp]
	xor	edx, edx
	div	DWORD PTR _size$[ebp]
	jmp	$LN16@ResFRead
	jmp	SHORT $LN5@ResFRead
$LN6@ResFRead:

; 5309 :                         }
; 5310 :                         else if (nread == (unsigned)-1) {

	cmp	DWORD PTR _nread$[ebp], -1
	jne	SHORT $LN5@ResFRead

; 5311 :                                 /* error -- out of here */
; 5312 :                                 stream->_flag |= _IOERR;

	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx+12]
	or	eax, 32					; 00000020H
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 5313 :                                 UNLOCK_STREAM( stream );

	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	call	__unlock_file
	add	esp, 4

; 5314 : #if (RES_MULTITHREAD)
; 5315 : 	RELEASE_LOCK(GLOCK);

	mov	eax, DWORD PTR _GLOCK
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4

; 5316 : #endif
; 5317 :                                 return (total - count) / size;

	mov	eax, DWORD PTR _total$[ebp]
	sub	eax, DWORD PTR _count$[ebp]
	xor	edx, edx
	div	DWORD PTR _size$[ebp]
	jmp	$LN16@ResFRead
$LN5@ResFRead:

; 5318 :                         }
; 5319 : 
; 5320 :                         /* update count and data to reflect read */
; 5321 :                         count -= nread;

	mov	ecx, DWORD PTR _count$[ebp]
	sub	ecx, DWORD PTR _nread$[ebp]
	mov	DWORD PTR _count$[ebp], ecx

; 5322 :                         data += nread;

	mov	edx, DWORD PTR _data$[ebp]
	add	edx, DWORD PTR _nread$[ebp]
	mov	DWORD PTR _data$[ebp], edx

; 5323 :                 }
; 5324 :                 else {

	jmp	$LN8@ResFRead
$LN7@ResFRead:

; 5325 :                         /* less than bufsize chars to read, so call _filbuf to
; 5326 :                            fill buffer */
; 5327 :                         if ((c = _filbuf(stream)) == EOF) {

	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	call	__filbuf
	add	esp, 4
	mov	DWORD PTR _c$[ebp], eax
	cmp	DWORD PTR _c$[ebp], -1
	jne	SHORT $LN2@ResFRead

; 5328 :                                 /* error or eof, stream flags set by _filbuf */
; 5329 :                                 UNLOCK_STREAM( stream );

	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	call	__unlock_file
	add	esp, 4

; 5330 : #if (RES_MULTITHREAD)
; 5331 : 	RELEASE_LOCK(GLOCK);

	mov	edx, DWORD PTR _GLOCK
	push	edx
	call	DWORD PTR __imp__ReleaseMutex@4

; 5332 : #endif
; 5333 :                                 return (total - count) / size;

	mov	eax, DWORD PTR _total$[ebp]
	sub	eax, DWORD PTR _count$[ebp]
	xor	edx, edx
	div	DWORD PTR _size$[ebp]
	jmp	SHORT $LN16@ResFRead
$LN2@ResFRead:

; 5334 :                         }
; 5335 : 
; 5336 :                         /* _filbuf returned a char -- store it */
; 5337 :                         *data++ = (char) c;

	mov	eax, DWORD PTR _data$[ebp]
	mov	cl, BYTE PTR _c$[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _data$[ebp]
	add	edx, 1
	mov	DWORD PTR _data$[ebp], edx

; 5338 :                         --count;

	mov	eax, DWORD PTR _count$[ebp]
	sub	eax, 1
	mov	DWORD PTR _count$[ebp], eax

; 5339 : /* GFG_NOV06 */
; 5340 :                         if( stream -> _flag & _IOARCHIVE )

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	and	edx, 65536				; 00010000H
	je	SHORT $LN1@ResFRead

; 5341 :                              FILE_HANDLES[ stream -> _file ].current_pos++;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	imul	ecx, 52					; 00000034H
	mov	edx, DWORD PTR _FILE_HANDLES
	mov	eax, DWORD PTR [edx+ecx+8]
	add	eax, 1
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	imul	edx, 52					; 00000034H
	mov	ecx, DWORD PTR _FILE_HANDLES
	mov	DWORD PTR [ecx+edx+8], eax
$LN1@ResFRead:

; 5342 : 
; 5343 :                         /* update buffer size */
; 5344 :                         bufsize = stream->_bufsiz;

	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _bufsize$[ebp], eax
$LN8@ResFRead:

; 5345 :                 }
; 5346 :         }

	jmp	$LN12@ResFRead
$LN11@ResFRead:

; 5347 : 
; 5348 :         UNLOCK_STREAM( stream );

	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	call	__unlock_file
	add	esp, 4

; 5349 : #if (RES_MULTITHREAD)
; 5350 : 	RELEASE_LOCK(GLOCK);

	mov	edx, DWORD PTR _GLOCK
	push	edx
	call	DWORD PTR __imp__ReleaseMutex@4

; 5351 : #endif
; 5352 : 
; 5353 :         /* we finished successfully, so just return num */
; 5354 :         return num;

	mov	eax, DWORD PTR _num$[ebp]
$LN16@ResFRead:

; 5355 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ResFRead ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_max$ = -32						; size = 4
_count$ = -28						; size = 4
_fd$ = -24						; size = 4
_handle$ = -20						; size = 4
_offset$ = -16						; size = 4
_filepos$ = -12						; size = 4
_p$ = -8						; size = 4
_rdcnt$ = -4						; size = 4
_stream$ = 8						; size = 4
_ResFTell PROC

; 4992 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 4993 :     unsigned int offset;
; 4994 :     long filepos;
; 4995 :     register char * p;
; 4996 :     char * max;
; 4997 :     int fd;
; 4998 :     unsigned int rdcnt;
; 4999 : 
; 5000 :     int handle,
; 5001 :         count;
; 5002 : 
; 5003 : #if( RES_DEBUG_PARAMS )
; 5004 :     if( !stream ) {

	cmp	DWORD PTR _stream$[ebp], 0
	jne	SHORT $LN32@ResFTell

; 5005 :         SAY_ERROR( RES_ERR_INCORRECT_PARAMETER, "ftell" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	5005					; 0000138dH
	push	OFFSET ??_C@_05BILPOFMK@ftell?$AA@
	push	-4998					; ffffec7aH
	call	__say_error
	add	esp, 16					; 00000010H

; 5006 :         return(-1);

	or	eax, -1
	jmp	$LN33@ResFTell
$LN32@ResFTell:

; 5007 :     }
; 5008 : #endif /* RES_DEBUG_PARAMS */
; 5009 : 
; 5010 : #if (RES_MULTITHREAD)
; 5011 : 	REQUEST_LOCK(GLOCK);

	push	-1
	mov	eax, DWORD PTR _GLOCK
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8

; 5012 : #endif
; 5013 :    
; 5014 :     /* --------- File within a compressed archive --------- */
; 5015 : 
; 5016 : 
; 5017 :     LOCK_STREAM( stream );

	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	call	__lock_file
	add	esp, 4

; 5018 : 
; 5019 :     if((stream -> _flag) & _IOARCHIVE ) {

	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx+12]
	and	eax, 65536				; 00010000H
	je	$LN31@ResFTell

; 5020 :         handle = stream -> _file;

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _handle$[ebp], edx

; 5021 : 
; 5022 : /* GFG_NOV06        count = (int)( stream -> _ptr - stream -> _base ); *//* should be safe (key word: SHOULD) */
; 5023 : 
; 5024 :         if( handle < 0 || handle > MAX_FILE_HANDLES || (FILE_HANDLES[ handle ].os_handle == -1 && !(stream -> _flag & _IOLOOSE))) {

	cmp	DWORD PTR _handle$[ebp], 0
	jl	SHORT $LN29@ResFTell
	cmp	DWORD PTR _handle$[ebp], 256		; 00000100H
	jg	SHORT $LN29@ResFTell
	mov	eax, DWORD PTR _handle$[ebp]
	imul	eax, 52					; 00000034H
	mov	ecx, DWORD PTR _FILE_HANDLES
	cmp	DWORD PTR [ecx+eax], -1
	jne	SHORT $LN30@ResFTell
	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx+12]
	and	eax, 131072				; 00020000H
	jne	SHORT $LN30@ResFTell
$LN29@ResFTell:

; 5025 :             SAY_ERROR( RES_ERR_ILLEGAL_FILE_HANDLE, "ftell" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	5025					; 000013a1H
	push	OFFSET ??_C@_05BILPOFMK@ftell?$AA@
	push	-4977					; ffffec8fH
	call	__say_error
	add	esp, 16					; 00000010H

; 5026 :             UNLOCK_STREAM( stream );

	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	call	__unlock_file
	add	esp, 4

; 5027 : #if (RES_MULTITHREAD)
; 5028 : 	RELEASE_LOCK(GLOCK);

	mov	edx, DWORD PTR _GLOCK
	push	edx
	call	DWORD PTR __imp__ReleaseMutex@4

; 5029 : #endif
; 5030 :             return(-1);

	or	eax, -1
	jmp	$LN33@ResFTell
$LN30@ResFTell:

; 5031 :         }
; 5032 :  /***  GFG_NOV06  
; 5033 :         if( stream -> _flag & _IOARCHIVE )
; 5034 :             count = FILE_HANDLES[ handle ].current_pos - stream -> _cnt;
; 5035 :         else
; 5036 :             count += FILE_HANDLES[ handle ].current_pos;
; 5037 : ***/
; 5038 :         count = FILE_HANDLES[ handle ].current_pos;;

	mov	eax, DWORD PTR _handle$[ebp]
	imul	eax, 52					; 00000034H
	mov	ecx, DWORD PTR _FILE_HANDLES
	mov	edx, DWORD PTR [ecx+eax+8]
	mov	DWORD PTR _count$[ebp], edx

; 5039 : 
; 5040 :         UNLOCK_STREAM( stream );

	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	call	__unlock_file
	add	esp, 4

; 5041 : #if (RES_MULTITHREAD)
; 5042 : 	RELEASE_LOCK(GLOCK);

	mov	ecx, DWORD PTR _GLOCK
	push	ecx
	call	DWORD PTR __imp__ReleaseMutex@4

; 5043 : #endif
; 5044 :         return( count );

	mov	eax, DWORD PTR _count$[ebp]
	jmp	$LN33@ResFTell
$LN31@ResFTell:

; 5045 :     }
; 5046 : 
; 5047 : 
; 5048 :     /* ------------------- Loose file ------------------- */
; 5049 : 
; 5050 : 
; 5051 :     /* Init stream pointer and file descriptor */
; 5052 : 
; 5053 :     fd = _fileno(stream);

	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	call	__fileno
	add	esp, 4
	mov	DWORD PTR _fd$[ebp], eax

; 5054 : 
; 5055 :     if( stream->_cnt < 0 )

	mov	eax, DWORD PTR _stream$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jge	SHORT $LN28@ResFTell

; 5056 :         stream->_cnt = 0;

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx+4], 0
$LN28@ResFTell:

; 5057 : 
; 5058 :     UNLOCK_STREAM( stream );

	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	call	__unlock_file
	add	esp, 4

; 5059 : 
; 5060 :     if((filepos = _lseek(fd, 0L, SEEK_CUR)) < 0L) 

	push	1
	push	0
	mov	eax, DWORD PTR _fd$[ebp]
	push	eax
	call	__lseek
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _filepos$[ebp], eax
	cmp	DWORD PTR _filepos$[ebp], 0
	jge	SHORT $LN27@ResFTell

; 5061 : 	{
; 5062 : #if (RES_MULTITHREAD)
; 5063 : 	RELEASE_LOCK(GLOCK);

	mov	ecx, DWORD PTR _GLOCK
	push	ecx
	call	DWORD PTR __imp__ReleaseMutex@4

; 5064 : #endif
; 5065 :         return(-1L);    

	or	eax, -1
	jmp	$LN33@ResFTell
$LN27@ResFTell:

; 5066 : 	}
; 5067 : 
; 5068 :     if(!bigbuf(stream))            /* _IONBF or no buffering designated */

	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx+12]
	and	eax, 264				; 00000108H
	jne	SHORT $LN26@ResFTell

; 5069 : 	{
; 5070 : #if (RES_MULTITHREAD)
; 5071 : 	RELEASE_LOCK(GLOCK);

	mov	ecx, DWORD PTR _GLOCK
	push	ecx
	call	DWORD PTR __imp__ReleaseMutex@4

; 5072 : #endif
; 5073 : 		return(filepos - stream->_cnt);

	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR _filepos$[ebp]
	sub	eax, DWORD PTR [edx+4]
	jmp	$LN33@ResFTell
$LN26@ResFTell:

; 5074 : 	}
; 5075 :     LOCK_STREAM( stream );

	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	call	__lock_file
	add	esp, 4

; 5076 : 
; 5077 :     offset = stream->_ptr - stream->_base;

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [ecx]
	sub	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _offset$[ebp], eax

; 5078 : 
; 5079 :     if( stream->_flag & (_IOWRT|_IOREAD)) {

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	and	edx, 3
	je	SHORT $LN25@ResFTell

; 5080 :         if( stream -> _flag & _O_TEXT )

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 16384				; 00004000H
	je	SHORT $LN24@ResFTell

; 5081 :             for (p = stream->_base; p < stream->_ptr; p++)

	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _p$[ebp], eax
	jmp	SHORT $LN23@ResFTell
$LN22@ResFTell:
	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 1
	mov	DWORD PTR _p$[ebp], ecx
$LN23@ResFTell:
	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR _p$[ebp]
	cmp	eax, DWORD PTR [edx]
	jae	SHORT $LN24@ResFTell

; 5082 :                 if (*p == '\n')  /* adjust for '\r' */

	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jne	SHORT $LN20@ResFTell

; 5083 :                     offset++;

	mov	eax, DWORD PTR _offset$[ebp]
	add	eax, 1
	mov	DWORD PTR _offset$[ebp], eax
$LN20@ResFTell:

; 5084 :     }

	jmp	SHORT $LN22@ResFTell
$LN24@ResFTell:

; 5085 :     else 

	jmp	SHORT $LN19@ResFTell
$LN25@ResFTell:

; 5086 :         if(!(stream->_flag & _IORW)) {

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	and	edx, 128				; 00000080H
	jne	SHORT $LN19@ResFTell

; 5087 :             errno=EINVAL;

	call	__errno
	mov	DWORD PTR [eax], 22			; 00000016H

; 5088 :             UNLOCK_STREAM( stream );

	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	call	__unlock_file
	add	esp, 4

; 5089 : #if (RES_MULTITHREAD)
; 5090 : 	RELEASE_LOCK(GLOCK);

	mov	ecx, DWORD PTR _GLOCK
	push	ecx
	call	DWORD PTR __imp__ReleaseMutex@4

; 5091 : #endif
; 5092 :             return(-1L);

	or	eax, -1
	jmp	$LN33@ResFTell
$LN19@ResFTell:

; 5093 :         }
; 5094 : 
; 5095 :     if( filepos == 0L ) {

	cmp	DWORD PTR _filepos$[ebp], 0
	jne	SHORT $LN17@ResFTell

; 5096 :         UNLOCK_STREAM( stream );

	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	call	__unlock_file
	add	esp, 4

; 5097 : #if (RES_MULTITHREAD)
; 5098 : 	RELEASE_LOCK(GLOCK);

	mov	eax, DWORD PTR _GLOCK
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4

; 5099 : #endif
; 5100 :         return((long)offset);

	mov	eax, DWORD PTR _offset$[ebp]
	jmp	$LN33@ResFTell
$LN17@ResFTell:

; 5101 :     }
; 5102 : 
; 5103 :     if( stream->_flag & _IOREAD ) { /* go to preceding sector */

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	and	edx, 1
	je	$LN16@ResFTell

; 5104 : 
; 5105 :         if( stream->_cnt == 0 ) {   /* filepos holds correct location */

	mov	eax, DWORD PTR _stream$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN15@ResFTell

; 5106 :             UNLOCK_STREAM( stream );

	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	call	__unlock_file
	add	esp, 4

; 5107 :             offset = 0;

	mov	DWORD PTR _offset$[ebp], 0

; 5108 :         }
; 5109 :         else {

	jmp	$LN14@ResFTell
$LN15@ResFTell:

; 5110 :             /* Subtract out the number of unread bytes left in the
; 5111 :                buffer. [We can't simply use _iob[]._bufsiz because
; 5112 :                the last read may have hit EOF and, thus, the buffer
; 5113 :                was not completely filled.] */
; 5114 : 
; 5115 :             rdcnt = stream->_cnt + (stream->_ptr - stream->_base);

	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [edx]
	sub	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _stream$[ebp]
	add	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR _rdcnt$[ebp], ecx

; 5116 : 
; 5117 :             /* If text mode, adjust for the cr/lf substitution. If
; 5118 :                binary mode, we're outta here. */
; 5119 : 
; 5120 :             if( stream -> _flag & _O_TEXT ) {

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 16384				; 00004000H
	je	$LN13@ResFTell

; 5121 :                 /* (1) If we're not at eof, simply copy _bufsiz
; 5122 :                    onto rdcnt to get the # of untranslated
; 5123 :                    chars read. (2) If we're at eof, we must
; 5124 :                    look through the buffer expanding the '\n'
; 5125 :                    chars one at a time. */
; 5126 : 
; 5127 :                 /* [NOTE: Performance issue -- it is faster to
; 5128 :                    do the two _lseek() calls than to blindly go
; 5129 :                    through and expand the '\n' chars regardless
; 5130 :                    of whether we're at eof or not.] */
; 5131 : 
; 5132 :                 UNLOCK_STREAM( stream );

	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	call	__unlock_file
	add	esp, 4

; 5133 : 
; 5134 :                 if (_lseek(fd, 0L, 2) == filepos) {

	push	2
	push	0
	mov	eax, DWORD PTR _fd$[ebp]
	push	eax
	call	__lseek
	add	esp, 12					; 0000000cH
	cmp	eax, DWORD PTR _filepos$[ebp]
	jne	SHORT $LN12@ResFTell

; 5135 : 
; 5136 :                     LOCK_STREAM( stream );

	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	call	__lock_file
	add	esp, 4

; 5137 : 
; 5138 :                     max = stream->_base + rdcnt;

	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, DWORD PTR _rdcnt$[ebp]
	mov	DWORD PTR _max$[ebp], eax

; 5139 :                     for (p = stream->_base; p < max; p++)

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _p$[ebp], edx
	jmp	SHORT $LN11@ResFTell
$LN10@ResFTell:
	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 1
	mov	DWORD PTR _p$[ebp], eax
$LN11@ResFTell:
	mov	ecx, DWORD PTR _p$[ebp]
	cmp	ecx, DWORD PTR _max$[ebp]
	jae	SHORT $LN9@ResFTell

; 5140 :                         if (*p == '\n')                     /* adjust for '\r' */

	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN8@ResFTell

; 5141 :                             rdcnt++;

	mov	ecx, DWORD PTR _rdcnt$[ebp]
	add	ecx, 1
	mov	DWORD PTR _rdcnt$[ebp], ecx
$LN8@ResFTell:

; 5142 : 
; 5143 :                     /* If last byte was ^Z, the lowio read
; 5144 :                        didn't tell us about it.  Check flag
; 5145 :                        and bump count, if necessary. */
; 5146 : 
; 5147 :                     if (stream->_flag & _IOCTRLZ)

	jmp	SHORT $LN10@ResFTell
$LN9@ResFTell:
	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx+12]
	and	eax, 8192				; 00002000H
	je	SHORT $LN7@ResFTell

; 5148 :                         ++rdcnt;

	mov	ecx, DWORD PTR _rdcnt$[ebp]
	add	ecx, 1
	mov	DWORD PTR _rdcnt$[ebp], ecx
$LN7@ResFTell:

; 5149 : 
; 5150 :                     UNLOCK_STREAM( stream );

	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	call	__unlock_file
	add	esp, 4

; 5151 :                 }
; 5152 :                 else {

	jmp	SHORT $LN6@ResFTell
$LN12@ResFTell:

; 5153 : 
; 5154 :                     _lseek(fd, filepos, 0);

	push	0
	mov	eax, DWORD PTR _filepos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fd$[ebp]
	push	ecx
	call	__lseek
	add	esp, 12					; 0000000cH

; 5155 : 
; 5156 :                     /* We want to set rdcnt to the number
; 5157 :                        of bytes originally read into the
; 5158 :                        stream buffer (before crlf->lf
; 5159 :                        translation). In most cases, this
; 5160 :                        will just be _bufsiz. However, the
; 5161 :                        buffer size may have been changed,
; 5162 :                        due to fseek optimization, at the
; 5163 :                        END of the last _filbuf call. */
; 5164 : 
; 5165 :                     LOCK_STREAM( stream );

	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	call	__lock_file
	add	esp, 4

; 5166 : 
; 5167 :                     if( (rdcnt <= _SMALL_BUFSIZ) &&
; 5168 :                         (stream->_flag & _IOMYBUF) &&
; 5169 :                        !(stream->_flag & _IOSETVBUF) )

	cmp	DWORD PTR _rdcnt$[ebp], 512		; 00000200H
	ja	SHORT $LN5@ResFTell
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 8
	je	SHORT $LN5@ResFTell
	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx+12]
	and	eax, 1024				; 00000400H
	jne	SHORT $LN5@ResFTell

; 5170 :                     {
; 5171 :                     /* The translated contents of
; 5172 :                        the buffer is small and we
; 5173 :                        are not at eof. The buffer
; 5174 :                        size must have been set to
; 5175 :                        _SMALL_BUFSIZ during the
; 5176 :                        last _filbuf call. */
; 5177 : 
; 5178 :                         rdcnt = _SMALL_BUFSIZ;

	mov	DWORD PTR _rdcnt$[ebp], 512		; 00000200H

; 5179 :                     }
; 5180 :                     else

	jmp	SHORT $LN4@ResFTell
$LN5@ResFTell:

; 5181 :                         rdcnt = stream->_bufsiz;

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _rdcnt$[ebp], edx
$LN4@ResFTell:

; 5182 : 
; 5183 : 
; 5184 :                     /* If first byte in untranslated buffer
; 5185 :                        was a '\n', assume it was preceeded
; 5186 :                        by a '\r' which was discarded by the
; 5187 :                        previous read operation and count
; 5188 :                        the '\n'. */
; 5189 :                     if( *stream->_base == '\n' )

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jne	SHORT $LN3@ResFTell

; 5190 :                         ++rdcnt;

	mov	eax, DWORD PTR _rdcnt$[ebp]
	add	eax, 1
	mov	DWORD PTR _rdcnt$[ebp], eax
$LN3@ResFTell:

; 5191 : 
; 5192 :                     UNLOCK_STREAM( stream );

	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	call	__unlock_file
	add	esp, 4
$LN6@ResFTell:

; 5193 :                 }
; 5194 : 
; 5195 :             } /* end if FTEXT */
; 5196 :             else

	jmp	SHORT $LN2@ResFTell
$LN13@ResFTell:

; 5197 :                 UNLOCK_STREAM( stream );

	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	call	__unlock_file
	add	esp, 4
$LN2@ResFTell:

; 5198 : 
; 5199 :             filepos -= (long)rdcnt;

	mov	eax, DWORD PTR _filepos$[ebp]
	sub	eax, DWORD PTR _rdcnt$[ebp]
	mov	DWORD PTR _filepos$[ebp], eax
$LN14@ResFTell:

; 5200 : 
; 5201 :         } /* end else stream->_cnt != 0 */
; 5202 :     }
; 5203 :     else

	jmp	SHORT $LN1@ResFTell
$LN16@ResFTell:

; 5204 :         UNLOCK_STREAM( stream );

	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	call	__unlock_file
	add	esp, 4
$LN1@ResFTell:

; 5205 : 
; 5206 : #if (RES_MULTITHREAD)
; 5207 : 	RELEASE_LOCK(GLOCK);

	mov	edx, DWORD PTR _GLOCK
	push	edx
	call	DWORD PTR __imp__ReleaseMutex@4

; 5208 : #endif
; 5209 :     return( filepos + (long)offset );

	mov	eax, DWORD PTR _filepos$[ebp]
	add	eax, DWORD PTR _offset$[ebp]
$LN33@ResFTell:

; 5210 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ResFTell ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_result$ = -8						; size = 4
_handle$ = -4						; size = 4
_file$ = 8						; size = 4
_ResFClose PROC

; 4853 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 4854 :     int handle,
; 4855 :         result;
; 4856 : 
; 4857 : #if( RES_DEBUG_PARAMS )
; 4858 :     /* check to see if it's one of our two flavors of FILE ptrs */
; 4859 : 
; 4860 :     if( !file || !(file -> _flag, (_IOARCHIVE | _IOLOOSE)) ) {

	cmp	DWORD PTR _file$[ebp], 0
	je	SHORT $LN5@ResFClose
	mov	eax, 196608				; 00030000H
	test	eax, eax
	jne	SHORT $LN6@ResFClose
$LN5@ResFClose:

; 4861 :         SAY_ERROR( RES_ERR_INCORRECT_PARAMETER, "ResFClose" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	4861					; 000012fdH
	push	OFFSET ??_C@_09EKBCJPBH@ResFClose?$AA@
	push	-4998					; ffffec7aH
	call	__say_error
	add	esp, 16					; 00000010H

; 4862 :         return(EOF); /* error */

	or	eax, -1
	jmp	$LN7@ResFClose
$LN6@ResFClose:

; 4863 :     }
; 4864 : #endif
; 4865 : 
; 4866 : #if (RES_MULTITHREAD)
; 4867 : 	REQUEST_LOCK(GLOCK);

	push	-1
	mov	ecx, DWORD PTR _GLOCK
	push	ecx
	call	DWORD PTR __imp__WaitForSingleObject@8

; 4868 : #endif
; 4869 : 
; 4870 :     if( FLAG_TEST( file -> _flag, _IOARCHIVE )) {

	mov	edx, DWORD PTR _file$[ebp]
	mov	eax, DWORD PTR [edx+12]
	and	eax, 65536				; 00010000H
	je	$LN4@ResFClose

; 4871 :         handle = file -> _file;

	mov	ecx, DWORD PTR _file$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _handle$[ebp], edx

; 4872 : 
; 4873 :         if( FILE_HANDLES[ handle ].zip )

	mov	eax, DWORD PTR _handle$[ebp]
	imul	eax, 52					; 00000034H
	mov	ecx, DWORD PTR _FILE_HANDLES
	cmp	DWORD PTR [ecx+eax+48], 0
	je	SHORT $LN3@ResFClose

; 4874 : 			#ifdef USE_SH_POOLS
; 4875 :             MemFreePtr( FILE_HANDLES[ handle ].zip );
; 4876 : 			#else
; 4877 :             MemFree( FILE_HANDLES[ handle ].zip );

	mov	edx, DWORD PTR _handle$[ebp]
	imul	edx, 52					; 00000034H
	mov	eax, DWORD PTR _FILE_HANDLES
	mov	ecx, DWORD PTR [eax+edx+48]
	push	ecx
	call	_free
	add	esp, 4
$LN3@ResFClose:

; 4878 : 			#endif
; 4879 : 
; 4880 : 		#ifdef USE_SH_POOLS
; 4881 :         MemFreePtr( FILE_HANDLES[ handle ].filename );
; 4882 : 		#else
; 4883 :         MemFree( FILE_HANDLES[ handle ].filename );

	mov	edx, DWORD PTR _handle$[ebp]
	imul	edx, 52					; 00000034H
	mov	eax, DWORD PTR _FILE_HANDLES
	mov	ecx, DWORD PTR [eax+edx+40]
	push	ecx
	call	_free
	add	esp, 4

; 4884 : 		#endif
; 4885 : 
; 4886 :         FILE_HANDLES[ handle ].zip = NULL;

	mov	edx, DWORD PTR _handle$[ebp]
	imul	edx, 52					; 00000034H
	mov	eax, DWORD PTR _FILE_HANDLES
	mov	DWORD PTR [eax+edx+48], 0

; 4887 :         FILE_HANDLES[ handle ].filename = NULL;

	mov	ecx, DWORD PTR _handle$[ebp]
	imul	ecx, 52					; 00000034H
	mov	edx, DWORD PTR _FILE_HANDLES
	mov	DWORD PTR [edx+ecx+40], 0

; 4888 :         FILE_HANDLES[ handle ].os_handle = -1;

	mov	eax, DWORD PTR _handle$[ebp]
	imul	eax, 52					; 00000034H
	mov	ecx, DWORD PTR _FILE_HANDLES
	mov	DWORD PTR [ecx+eax], -1

; 4889 : 
; 4890 :         /* since microsoft doesn't use have symmetry with it's _getstream()
; 4891 :            function (eg; _freestream()), we just set the _flag field to 0
; 4892 :            and assume that's all there is to do (seems like this is true
; 4893 :            after looking at close.c and fclose.c */
; 4894 : 
; 4895 :         /* Actually, not quite. If the streaming io functions are used then
; 4896 :            a call to _freebuf is needed. Looking closely at fclose.c and
; 4897 :            _freebuf.c it seems safe to do all the time. LRKUDGE
; 4898 :         */
; 4899 :         LOCK_STREAM( file );

	mov	edx, DWORD PTR _file$[ebp]
	push	edx
	call	__lock_file
	add	esp, 4

; 4900 : 
; 4901 :         _freebuf( file );

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	__freebuf
	add	esp, 4

; 4902 :         file -> _flag = 0;

	mov	ecx, DWORD PTR _file$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 4903 :         file -> _ptr = NULL;

	mov	edx, DWORD PTR _file$[ebp]
	mov	DWORD PTR [edx], 0

; 4904 :         file -> _cnt = 0;

	mov	eax, DWORD PTR _file$[ebp]
	mov	DWORD PTR [eax+4], 0

; 4905 : 
; 4906 :         UNLOCK_STREAM( file );

	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	__unlock_file
	add	esp, 4

; 4907 : #if (RES_MULTITHREAD)
; 4908 : 	RELEASE_LOCK(GLOCK);

	mov	edx, DWORD PTR _GLOCK
	push	edx
	call	DWORD PTR __imp__ReleaseMutex@4

; 4909 : #endif
; 4910 : 
; 4911 :         return(0);

	xor	eax, eax
	jmp	$LN7@ResFClose

; 4912 : 
; 4913 :     } else {

	jmp	$LN7@ResFClose
$LN4@ResFClose:

; 4914 :         FLAG_UNSET( file -> _flag, _IOLOOSE );  /* we want to unset our unique flags before */

	mov	eax, DWORD PTR _file$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	xor	ecx, -131073				; fffdffffH
	mov	edx, DWORD PTR _file$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 4915 :         FLAG_UNSET( file -> _flag, _IOSTRG  );  /* calling any CRT functions.               */

	mov	eax, DWORD PTR _file$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	xor	ecx, -65				; ffffffbfH
	mov	edx, DWORD PTR _file$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 4916 : 
; 4917 :                                                 /* this is basically all that fclose does   */
; 4918 :         LOCK_STREAM( file );

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	__lock_file
	add	esp, 4

; 4919 : 
; 4920 :         result = _flush( file );

	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	__flush
	add	esp, 4
	mov	DWORD PTR _result$[ebp], eax

; 4921 : 
; 4922 :         _freebuf( file );

	mov	edx, DWORD PTR _file$[ebp]
	push	edx
	call	__freebuf
	add	esp, 4

; 4923 : 
; 4924 :         if( _close(_fileno( file )) < 0)

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	__fileno
	add	esp, 4
	push	eax
	call	__close
	add	esp, 4
	test	eax, eax
	jge	SHORT $LN1@ResFClose

; 4925 :            result = EOF;

	mov	DWORD PTR _result$[ebp], -1
$LN1@ResFClose:

; 4926 : 
; 4927 :         UNLOCK_STREAM( file );

	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	__unlock_file
	add	esp, 4

; 4928 : 
; 4929 :         file -> _flag = 0;                      /* now we clear all flags                   */

	mov	edx, DWORD PTR _file$[ebp]
	mov	DWORD PTR [edx+12], 0

; 4930 : 
; 4931 : #if (RES_MULTITHREAD)
; 4932 : 	RELEASE_LOCK(GLOCK);

	mov	eax, DWORD PTR _GLOCK
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4

; 4933 : #endif
; 4934 :         return( result );

	mov	eax, DWORD PTR _result$[ebp]
$LN7@ResFClose:

; 4935 :     }
; 4936 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ResFClose ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
tv389 = -928						; size = 4
tv329 = -924						; size = 4
_retval$ = -920						; size = 4
_write_flag$ = -916					; size = 4
_table$ = -912						; size = 4
_dir_index$ = -908					; size = 4
_handle$1 = -904					; size = 4
_list$2 = -900						; size = 4
_archive$3 = -896					; size = 4
_zip$4 = -892						; size = 4
_file$5 = -888						; size = 4
_stream$ = -884						; size = 4
_entry$ = -880						; size = 4
_data$ = -876						; size = 296
_lrec$ = -580						; size = 28
_dirpath$ = -552					; size = 260
_filename$ = -292					; size = 260
_tmp$ = -32						; size = 26
__$ArrayPad$ = -4					; size = 4
_name$ = 8						; size = 4
_mode$ = 12						; size = 4
_ResFOpen PROC

; 4373 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 928				; 000003a0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 4374 :     FILE * stream;
; 4375 :     int    write_flag = FALSE;

	mov	DWORD PTR _write_flag$[ebp], 0

; 4376 : 
; 4377 :     HASH_ENTRY * entry;
; 4378 :     HASH_TABLE * table = NULL;

	mov	DWORD PTR _table$[ebp], 0

; 4379 : 
; 4380 :     char filename[_MAX_PATH],
; 4381 :          dirpath[_MAX_PATH];
; 4382 : 
; 4383 :     int  retval = 1;     /* to test return value of callbacks */

	mov	DWORD PTR _retval$[ebp], 1

; 4384 :     int  dir_index;
; 4385 :     struct _finddata_t data;
; 4386 : 
; 4387 :     char tmp[LREC_SIZE];
; 4388 :     local_file_hdr lrec;
; 4389 : 
; 4390 : #if( RES_DEBUG_PARAMS )
; 4391 :     if( !name || !mode ) {

	cmp	DWORD PTR _name$[ebp], 0
	je	SHORT $LN42@ResFOpen
	cmp	DWORD PTR _mode$[ebp], 0
	jne	SHORT $LN43@ResFOpen
$LN42@ResFOpen:

; 4392 :         SAY_ERROR( RES_ERR_INCORRECT_PARAMETER, "ResFOpen" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	4392					; 00001128H
	push	OFFSET ??_C@_08NNCGCPFP@ResFOpen?$AA@
	push	-4998					; ffffec7aH
	call	__say_error
	add	esp, 16					; 00000010H

; 4393 :         return( FALSE );

	xor	eax, eax
	jmp	$LN44@ResFOpen
$LN43@ResFOpen:

; 4394 :     }
; 4395 : #endif /* RES_DEBUG_PARAMS */
; 4396 : #if (RES_MULTITHREAD)
; 4397 : 	REQUEST_LOCK(GLOCK);

	push	-1
	mov	eax, DWORD PTR _GLOCK
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8

; 4398 : #endif
; 4399 : 
; 4400 : 
; 4401 :     /* if the mode string contains either a 'w' or a '+' we
; 4402 :        need to return an error if the file being operated on
; 4403 :        is an archive file (eventually, this may be otherwise) */
; 4404 : 
; 4405 :     if( strchr( mode, 'w' ) || strchr( mode, 'a' ))

	push	119					; 00000077H
	mov	ecx, DWORD PTR _mode$[ebp]
	push	ecx
	call	_strchr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN40@ResFOpen
	push	97					; 00000061H
	mov	edx, DWORD PTR _mode$[ebp]
	push	edx
	call	_strchr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN41@ResFOpen
$LN40@ResFOpen:

; 4406 :         write_flag = TRUE;

	mov	DWORD PTR _write_flag$[ebp], 1
$LN41@ResFOpen:

; 4407 : 
; 4408 : 
; 4409 :     /* find the file */
; 4410 : 
; 4411 : #if( !RES_USE_FLAT_MODEL ) 
; 4412 :     entry = hash_find_table( name, &table );        /* look through tables in search path order */

	lea	eax, DWORD PTR _table$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_hash_find_table
	add	esp, 8
	mov	DWORD PTR _entry$[ebp], eax

; 4413 : #else                      
; 4414 :     entry = hash_find( name, GLOBAL_HASH_TABLE );   /* look in the root hash table (flat model) */
; 4415 : #endif
; 4416 :     
; 4417 :     if(!entry && table && !write_flag ) {

	cmp	DWORD PTR _entry$[ebp], 0
	jne	SHORT $LN39@ResFOpen
	cmp	DWORD PTR _table$[ebp], 0
	je	SHORT $LN39@ResFOpen
	cmp	DWORD PTR _write_flag$[ebp], 0
	jne	SHORT $LN39@ResFOpen

; 4418 :         SAY_ERROR( RES_ERR_FILE_NOT_FOUND, name );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	4418					; 00001142H
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	push	-4993					; ffffec7fH
	call	__say_error
	add	esp, 16					; 00000010H

; 4419 : 		SHOULD_I_CALL_WITH( CALLBACK_OPEN_FILE, -1, retval );

	mov	eax, 4
	shl	eax, 2
	cmp	DWORD PTR _RES_CALLBACK[eax], 0
	je	SHORT $LN38@ResFOpen
	push	-1
	mov	ecx, 4
	shl	ecx, 2
	mov	edx, DWORD PTR _RES_CALLBACK[ecx]
	call	edx
	add	esp, 4
	mov	DWORD PTR _retval$[ebp], eax
$LN38@ResFOpen:

; 4420 : #if (RES_MULTITHREAD)
; 4421 : 	RELEASE_LOCK(GLOCK);

	mov	eax, DWORD PTR _GLOCK
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4

; 4422 : #endif
; 4423 : 	    return( NULL );

	xor	eax, eax
	jmp	$LN44@ResFOpen
$LN39@ResFOpen:

; 4424 :     }
; 4425 : 
; 4426 :     /* -------------------------------------
; 4427 :            Creating a file for writing
; 4428 :        ------------------------------------- */
; 4429 : 
; 4430 :     if( !entry && write_flag ) {  /* FILE NOT FOUND */

	cmp	DWORD PTR _entry$[ebp], 0
	jne	$LN37@ResFOpen
	cmp	DWORD PTR _write_flag$[ebp], 0
	je	$LN37@ResFOpen

; 4431 : 
; 4432 :         /* if the user is trying to create a file on the harddrive,
; 4433 :            this is ok (entry not found), but if they are not even 
; 4434 :            openning the file for any writing, we can return with 
; 4435 :            an error now. */
; 4436 : 
; 4437 : #if( !RES_USE_FLAT_MODEL )
; 4438 : 
; 4439 :         /* see if the destination directory exists */
; 4440 : 
; 4441 :         if( strchr( name, ASCII_BACKSLASH )) {

	push	92					; 0000005cH
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_strchr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN36@ResFOpen

; 4442 :             split_path( (char *)name, filename, dirpath );

	lea	edx, DWORD PTR _dirpath$[ebp]
	push	edx
	lea	eax, DWORD PTR _filename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_split_path
	add	esp, 12					; 0000000cH

; 4443 :             entry = hash_find( dirpath, GLOBAL_HASH_TABLE );

	mov	edx, DWORD PTR _GLOBAL_HASH_TABLE
	push	edx
	lea	eax, DWORD PTR _dirpath$[ebp]
	push	eax
	call	_hash_find
	add	esp, 8
	mov	DWORD PTR _entry$[ebp], eax

; 4444 :         }
; 4445 :         else {  /* current directory */

	jmp	SHORT $LN35@ResFOpen
$LN36@ResFOpen:

; 4446 :             strcpy( filename, name );

	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	lea	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 4447 :             strcpy( dirpath, GLOBAL_CURRENT_PATH );

	push	OFFSET _GLOBAL_CURRENT_PATH
	lea	eax, DWORD PTR _dirpath$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 4448 :             entry = hash_find( GLOBAL_CURRENT_PATH, GLOBAL_HASH_TABLE );

	mov	ecx, DWORD PTR _GLOBAL_HASH_TABLE
	push	ecx
	push	OFFSET _GLOBAL_CURRENT_PATH
	call	_hash_find
	add	esp, 8
	mov	DWORD PTR _entry$[ebp], eax
$LN35@ResFOpen:

; 4449 :         }
; 4450 : 
; 4451 : 
; 4452 :         /* if the directory does not exist, this is an error.  Otherwise,
; 4453 :            we get the ptr to the hash table for the destination directory */
; 4454 : 
; 4455 :         if( !entry || !entry -> dir ) { /* directory not found in resmgr */

	cmp	DWORD PTR _entry$[ebp], 0
	je	SHORT $LN33@ResFOpen
	mov	edx, DWORD PTR _entry$[ebp]
	cmp	DWORD PTR [edx+40], 0
	jne	SHORT $LN34@ResFOpen
$LN33@ResFOpen:

; 4456 :             SAY_ERROR( RES_ERR_UNKNOWN_WRITE_TO, name );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	4456					; 00001168H
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	-4971					; ffffec95H
	call	__say_error
	add	esp, 16					; 00000010H

; 4457 : #if (RES_MULTITHREAD)
; 4458 : 	RELEASE_LOCK(GLOCK);

	mov	ecx, DWORD PTR _GLOCK
	push	ecx
	call	DWORD PTR __imp__ReleaseMutex@4

; 4459 : #endif
; 4460 :             return( NULL );

	xor	eax, eax
	jmp	$LN44@ResFOpen

; 4461 :         }
; 4462 :         else {

	jmp	SHORT $LN32@ResFOpen
$LN34@ResFOpen:

; 4463 :             table = (HASH_TABLE *)entry -> dir;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR _table$[ebp], eax
$LN32@ResFOpen:

; 4464 :         }
; 4465 : 
; 4466 : #else /* flat model */
; 4467 : 
; 4468 :         /* if this is flat-mode, just look in the root hash table for
; 4469 :            existance of the file, and set the table ptr to be the global
; 4470 :            hash table (the sole hash table in this case). */
; 4471 : 
; 4472 :         if( strchr( name, ASCII_BACKSLASH ))
; 4473 :             split_path( name, filename, dirpath );
; 4474 :         else
; 4475 :             strcpy( filename, name );
; 4476 :         
; 4477 :         table = GLOBAL_HASH_TABLE;
; 4478 : 
; 4479 : #endif /* !RES_USE_FLAT_MODEL */
; 4480 : 
; 4481 : 
; 4482 :         /* We use a dummy _finddata_t struct to stuff an entry for
; 4483 :            this file into the hash table */
; 4484 :         
; 4485 :         strcpy( data.name, filename );

	lea	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	lea	edx, DWORD PTR _data$[ebp+36]
	push	edx
	call	_strcpy
	add	esp, 8

; 4486 :         data.attrib = (unsigned int)FORCE_BIT;

	mov	DWORD PTR _data$[ebp], -2147483648	; 80000000H

; 4487 :         data.time_create = 0;

	xorpd	xmm0, xmm0
	movlpd	QWORD PTR _data$[ebp+8], xmm0

; 4488 :         data.time_access = 0;

	xorpd	xmm0, xmm0
	movlpd	QWORD PTR _data$[ebp+16], xmm0

; 4489 :         data.size = 0;

	mov	DWORD PTR _data$[ebp+32], 0

; 4490 : 
; 4491 :         entry = hash_add( &data, table );

	mov	eax, DWORD PTR _table$[ebp]
	push	eax
	lea	ecx, DWORD PTR _data$[ebp]
	push	ecx
	call	_hash_add
	add	esp, 8
	mov	DWORD PTR _entry$[ebp], eax

; 4492 : 
; 4493 :         if( !entry ) {

	cmp	DWORD PTR _entry$[ebp], 0
	jne	SHORT $LN31@ResFOpen

; 4494 :             SAY_ERROR( RES_ERR_UNKNOWN, "ResFOpen - create" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	4494					; 0000118eH
	push	OFFSET ??_C@_0BC@CPGLDEPP@ResFOpen?5?9?5create?$AA@
	push	-4973					; ffffec93H
	call	__say_error
	add	esp, 16					; 00000010H

; 4495 : #if (RES_MULTITHREAD)
; 4496 : 	RELEASE_LOCK(GLOCK);

	mov	edx, DWORD PTR _GLOCK
	push	edx
	call	DWORD PTR __imp__ReleaseMutex@4

; 4497 : #endif
; 4498 :             return( NULL );

	xor	eax, eax
	jmp	$LN44@ResFOpen
$LN31@ResFOpen:

; 4499 :         }
; 4500 : 
; 4501 :         /* Look through the array of directory names comparing these to
; 4502 :            our destination directory.  The index value of the match is
; 4503 :            set in our hash entry for later use.  If no match is found
; 4504 :            ( this should never occur ), there is a big problem in the
; 4505 :            hash tables */
; 4506 : 
; 4507 :         for( dir_index = 0; dir_index <= GLOBAL_SEARCH_INDEX; dir_index++ ) {

	mov	DWORD PTR _dir_index$[ebp], 0
	jmp	SHORT $LN30@ResFOpen
$LN29@ResFOpen:
	mov	eax, DWORD PTR _dir_index$[ebp]
	add	eax, 1
	mov	DWORD PTR _dir_index$[ebp], eax
$LN30@ResFOpen:
	mov	ecx, DWORD PTR _dir_index$[ebp]
	cmp	ecx, DWORD PTR _GLOBAL_SEARCH_INDEX
	jg	SHORT $LN28@ResFOpen

; 4508 :             if( !stricmp( dirpath, GLOBAL_SEARCH_PATH[ dir_index ] )) {

	mov	edx, DWORD PTR _dir_index$[ebp]
	mov	eax, DWORD PTR _GLOBAL_SEARCH_PATH[edx*4]
	push	eax
	lea	ecx, DWORD PTR _dirpath$[ebp]
	push	ecx
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN27@ResFOpen

; 4509 :                 entry -> directory = dir_index;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR _dir_index$[ebp]
	mov	DWORD PTR [edx+32], eax

; 4510 :                 entry -> volume = (char)(toupper(dirpath[0]) - 'A');

	mov	ecx, 1
	imul	ecx, 0
	movsx	edx, BYTE PTR _dirpath$[ebp+ecx]
	push	edx
	call	_toupper
	add	esp, 4
	sub	eax, 65					; 00000041H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	BYTE PTR [ecx+36], al

; 4511 :                 break;

	jmp	SHORT $LN28@ResFOpen
$LN27@ResFOpen:

; 4512 :             }
; 4513 :         }

	jmp	SHORT $LN29@ResFOpen
$LN28@ResFOpen:

; 4514 : 
; 4515 :         /* oops.  big problem. */
; 4516 : 
; 4517 :         if( dir_index > GLOBAL_SEARCH_INDEX ) {

	mov	edx, DWORD PTR _dir_index$[ebp]
	cmp	edx, DWORD PTR _GLOBAL_SEARCH_INDEX
	jle	SHORT $LN37@ResFOpen

; 4518 :             SAY_ERROR( RES_ERR_UNKNOWN, "ResFOpen - create" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	4518					; 000011a6H
	push	OFFSET ??_C@_0BC@CPGLDEPP@ResFOpen?5?9?5create?$AA@
	push	-4973					; ffffec93H
	call	__say_error
	add	esp, 16					; 00000010H

; 4519 : #if (RES_MULTITHREAD)
; 4520 : 	RELEASE_LOCK(GLOCK);

	mov	eax, DWORD PTR _GLOCK
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4

; 4521 : #endif
; 4522 :             return( NULL );

	xor	eax, eax
	jmp	$LN44@ResFOpen
$LN37@ResFOpen:

; 4523 :         }
; 4524 :     }
; 4525 : 
; 4526 : 
; 4527 :     /* Make sure the user isn't trying to write to an archive file.
; 4528 :        Someday this may be possible, but not for a while. */
; 4529 : 
; 4530 :     if( entry && ( entry -> archive != -1 ) && write_flag ) {

	cmp	DWORD PTR _entry$[ebp], 0
	je	SHORT $LN25@ResFOpen
	mov	ecx, DWORD PTR _entry$[ebp]
	cmp	DWORD PTR [ecx+24], -1
	je	SHORT $LN25@ResFOpen
	cmp	DWORD PTR _write_flag$[ebp], 0
	je	SHORT $LN25@ResFOpen

; 4531 :         SAY_ERROR( RES_ERR_CANT_WRITE_ARCHIVE, "ResFOpen" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	4531					; 000011b3H
	push	OFFSET ??_C@_08NNCGCPFP@ResFOpen?$AA@
	push	-4970					; ffffec96H
	call	__say_error
	add	esp, 16					; 00000010H

; 4532 : #if (RES_MULTITHREAD)
; 4533 : 	RELEASE_LOCK(GLOCK);

	mov	edx, DWORD PTR _GLOCK
	push	edx
	call	DWORD PTR __imp__ReleaseMutex@4

; 4534 : #endif
; 4535 :         return( NULL );

	xor	eax, eax
	jmp	$LN44@ResFOpen
$LN25@ResFOpen:

; 4536 :     }
; 4537 : 
; 4538 : 	
; 4539 :     /* we want to use the same allocation scheme that the 
; 4540 :        visual c++ run-time uses because a) it isn't that 
; 4541 :        bad, b) it assures the highest integration with the 
; 4542 :        stream i/o functions, and c) it may keep fclose(file)
; 4543 :        from thrashing your system. */
; 4544 : 
; 4545 :     stream = _getstream(); /* taken from open.c */

	call	__getstream
	mov	DWORD PTR _stream$[ebp], eax

; 4546 : 
; 4547 :     if( !stream ) {

	cmp	DWORD PTR _stream$[ebp], 0
	jne	SHORT $LN24@ResFOpen

; 4548 :         SAY_ERROR( RES_ERR_TOO_MANY_FILES, "ResFOpen" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	4548					; 000011c4H
	push	OFFSET ??_C@_08NNCGCPFP@ResFOpen?$AA@
	push	-4978					; ffffec8eH
	call	__say_error
	add	esp, 16					; 00000010H

; 4549 : #if (RES_MULTITHREAD)
; 4550 : 	RELEASE_LOCK(GLOCK);

	mov	eax, DWORD PTR _GLOCK
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4

; 4551 : #endif
; 4552 :         return( NULL );

	xor	eax, eax
	jmp	$LN44@ResFOpen
$LN24@ResFOpen:

; 4553 :     }
; 4554 :     
; 4555 : 
; 4556 :     /* these initialization values may change */
; 4557 : 
; 4558 :     stream -> _ptr     = NULL;

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx], 0

; 4559 :     stream -> _cnt     = 0;

	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx+4], 0

; 4560 :     stream -> _base    = NULL;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [eax+8], 0

; 4561 :     stream -> _flag    = _IOREAD; /* *MUST* have this for inuse to think it's full */

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx+12], 1

; 4562 :     stream -> _file    = 0;

	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx+16], 0

; 4563 :     stream -> _charbuf = 0;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [eax+20], 0

; 4564 :     stream -> _bufsiz  = 0;

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx+24], 0

; 4565 :     stream -> _tmpfname = NULL;

	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx+28], 0

; 4566 : 
; 4567 :     if( !entry || (entry -> archive == -1)) {

	cmp	DWORD PTR _entry$[ebp], 0
	je	SHORT $LN22@ResFOpen
	mov	eax, DWORD PTR _entry$[ebp]
	cmp	DWORD PTR [eax+24], -1
	jne	$LN23@ResFOpen
$LN22@ResFOpen:

; 4568 : 
; 4569 :         /* ----- Loose file ----- */
; 4570 : 
; 4571 :     
; 4572 :         /* If the file is loose (not in an archive) we will want
; 4573 :            _filbuf to work as normal - therefore the file handle
; 4574 :            should be the OS handle of the open file.  If the file
; 4575 :            is in an archive, the handle is our file handle which
; 4576 :            we use to access the archive and read the file. */
; 4577 : 
; 4578 :         if( !entry ) /* assume it's a 'create' acceptable mode */

	cmp	DWORD PTR _entry$[ebp], 0
	jne	SHORT $LN21@ResFOpen

; 4579 :             res_fullpath( filename, name, _MAX_PATH );  /* regardless of coercion state */

	push	260					; 00000104H
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	lea	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	_res_fullpath
	add	esp, 12					; 0000000cH

; 4580 :         else

	jmp	SHORT $LN20@ResFOpen
$LN21@ResFOpen:

; 4581 :             sprintf( filename, "%s%s", GLOBAL_SEARCH_PATH[ entry -> directory ], entry -> name );

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _GLOBAL_SEARCH_PATH[eax*4]
	push	ecx
	push	OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
	lea	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H
$LN20@ResFOpen:

; 4582 : 
; 4583 : 
; 4584 :         /* call the same low-level open file that fopen uses */
; 4585 : 
; 4586 :         if( !_openfile( filename, mode, _SH_DENYNO, stream )) {

	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	push	64					; 00000040H
	mov	ecx, DWORD PTR _mode$[ebp]
	push	ecx
	lea	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	__openfile
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	$LN19@ResFOpen

; 4587 : 
; 4588 : 			if( errno == EACCES )

	call	__errno
	cmp	DWORD PTR [eax], 13			; 0000000dH
	jne	SHORT $LN18@ResFOpen

; 4589 :                           {SAY_ERROR( RES_ERR_FILE_SHARING, filename );}

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	4589					; 000011edH
	lea	eax, DWORD PTR _filename$[ebp]
	push	eax
	push	-4996					; ffffec7cH
	call	__say_error
	add	esp, 16					; 00000010H

; 4590 : 			else

	jmp	SHORT $LN17@ResFOpen
$LN18@ResFOpen:

; 4591 :                           {SAY_ERROR( RES_ERR_PROBLEM_READING, filename );}

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	4591					; 000011efH
	lea	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	push	-4983					; ffffec89H
	call	__say_error
	add	esp, 16					; 00000010H
$LN17@ResFOpen:

; 4592 : 
; 4593 :             /* Don't forget to free the stream handle, duh */
; 4594 :             stream -> _flag = 0;

	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx+12], 0

; 4595 :             stream -> _ptr = NULL;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [eax], 0

; 4596 :             stream -> _cnt = 0;

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 4597 : 
; 4598 :             UNLOCK_STREAM( stream );

	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	call	__unlock_file
	add	esp, 4

; 4599 : #if (RES_MULTITHREAD)
; 4600 : 	RELEASE_LOCK(GLOCK);

	mov	eax, DWORD PTR _GLOCK
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4

; 4601 : #endif
; 4602 :             return( NULL );

	xor	eax, eax
	jmp	$LN44@ResFOpen
$LN19@ResFOpen:

; 4603 :         }
; 4604 :         
; 4605 : 
; 4606 :         SHOULD_I_CALL_WITH( CALLBACK_OPEN_FILE, -1, retval );

	mov	ecx, 4
	shl	ecx, 2
	cmp	DWORD PTR _RES_CALLBACK[ecx], 0
	je	SHORT $LN16@ResFOpen
	push	-1
	mov	edx, 4
	shl	edx, 2
	mov	eax, DWORD PTR _RES_CALLBACK[edx]
	call	eax
	add	esp, 4
	mov	DWORD PTR _retval$[ebp], eax
$LN16@ResFOpen:

; 4607 : 
; 4608 : 
; 4609 :         /* tag the structure as our own flavor (specifically 'loose') */
; 4610 : 
; 4611 :         stream -> _flag |= _IOLOOSE;

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	or	edx, 131072				; 00020000H
	mov	eax, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [eax+12], edx

; 4612 : 
; 4613 :         UNLOCK_STREAM( stream );

	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	call	__unlock_file
	add	esp, 4

; 4614 : 
; 4615 : #if (RES_MULTITHREAD)
; 4616 : 	RELEASE_LOCK(GLOCK);

	mov	edx, DWORD PTR _GLOCK
	push	edx
	call	DWORD PTR __imp__ReleaseMutex@4

; 4617 : #endif
; 4618 :         return( stream );

	mov	eax, DWORD PTR _stream$[ebp]
	jmp	$LN44@ResFOpen

; 4619 :     }
; 4620 :     else {

	jmp	$LN15@ResFOpen
$LN23@ResFOpen:

; 4621 : 
; 4622 :         /* ----- Archive File ----- */
; 4623 : 
; 4624 : 
; 4625 :         /* This is the case that we're doing all the work for.
; 4626 :            If the file being read is a member of an archive, we
; 4627 :            treat it as if we were using ResOpenFile at this 
; 4628 :            point.  Later, during the _filbuf() function, we'll
; 4629 :            use this data to simulate the stream i/o filling
; 4630 :            routine. */        
; 4631 : 
; 4632 : 
; 4633 :         /* We need one of our special file descriptors */
; 4634 : 
; 4635 :         int           handle=0;

	mov	DWORD PTR _handle$1[ebp], 0

; 4636 :         FILE_ENTRY  * file=NULL;

	mov	DWORD PTR _file$5[ebp], 0

; 4637 :         LIST        * list=NULL;

	mov	DWORD PTR _list$2[ebp], 0

; 4638 :         ARCHIVE     * archive=NULL;

	mov	DWORD PTR _archive$3[ebp], 0

; 4639 : 
; 4640 :         handle = get_handle();

	call	_get_handle
	mov	DWORD PTR _handle$1[ebp], eax

; 4641 : 
; 4642 :         if( handle == -1 ) { /* none left */

	cmp	DWORD PTR _handle$1[ebp], -1
	jne	SHORT $LN14@ResFOpen

; 4643 :             SAY_ERROR( RES_ERR_TOO_MANY_FILES, "ResOpenFile" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	4643					; 00001223H
	push	OFFSET ??_C@_0M@OGEGBBAK@ResOpenFile?$AA@
	push	-4978					; ffffec8eH
	call	__say_error
	add	esp, 16					; 00000010H

; 4644 :             UNLOCK_STREAM( stream );

	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	call	__unlock_file
	add	esp, 4

; 4645 : #if (RES_MULTITHREAD)
; 4646 : 	RELEASE_LOCK(GLOCK);

	mov	ecx, DWORD PTR _GLOCK
	push	ecx
	call	DWORD PTR __imp__ReleaseMutex@4

; 4647 : #endif
; 4648 :             return( NULL );

	xor	eax, eax
	jmp	$LN44@ResFOpen
$LN14@ResFOpen:

; 4649 :         }
; 4650 : 
; 4651 :         file = &FILE_HANDLES[ handle ];

	mov	edx, DWORD PTR _handle$1[ebp]
	imul	edx, 52					; 00000034H
	add	edx, DWORD PTR _FILE_HANDLES
	mov	DWORD PTR _file$5[ebp], edx

; 4652 : 
; 4653 :         /* Find the archive file from which this file is found */
; 4654 : 
; 4655 :         for( list = ARCHIVE_LIST; list; list = list -> next ) {

	mov	eax, DWORD PTR _ARCHIVE_LIST
	mov	DWORD PTR _list$2[ebp], eax
	jmp	SHORT $LN13@ResFOpen
$LN12@ResFOpen:
	mov	ecx, DWORD PTR _list$2[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _list$2[ebp], edx
$LN13@ResFOpen:
	cmp	DWORD PTR _list$2[ebp], 0
	je	SHORT $LN11@ResFOpen

; 4656 :             archive = (ARCHIVE *)list -> node;

	mov	eax, DWORD PTR _list$2[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _archive$3[ebp], ecx

; 4657 : 
; 4658 :             if( archive -> os_handle == entry -> archive )

	mov	edx, DWORD PTR _archive$3[ebp]
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [edx+260]
	cmp	ecx, DWORD PTR [eax+24]
	jne	SHORT $LN10@ResFOpen

; 4659 :                break;

	jmp	SHORT $LN11@ResFOpen
$LN10@ResFOpen:

; 4660 :         }

	jmp	SHORT $LN12@ResFOpen
$LN11@ResFOpen:

; 4661 : 
; 4662 : 
; 4663 :         /* oops.  big problem. */
; 4664 : 
; 4665 :         if( !list ) {

	cmp	DWORD PTR _list$2[ebp], 0
	jne	SHORT $LN9@ResFOpen

; 4666 :            SAY_ERROR( RES_ERR_UNKNOWN, "ResFOpen" ); /* archive handle in hash entry is incorrect (or archive detached) */

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	4666					; 0000123aH
	push	OFFSET ??_C@_08NNCGCPFP@ResFOpen?$AA@
	push	-4973					; ffffec93H
	call	__say_error
	add	esp, 16					; 00000010H

; 4667 :            UNLOCK_STREAM( stream );

	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	call	__unlock_file
	add	esp, 4

; 4668 : #if (RES_MULTITHREAD)
; 4669 : 	RELEASE_LOCK(GLOCK);

	mov	eax, DWORD PTR _GLOCK
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4

; 4670 : #endif
; 4671 :            return( NULL );

	xor	eax, eax
	jmp	$LN44@ResFOpen
$LN9@ResFOpen:

; 4672 :         }
; 4673 : 
; 4674 : 
; 4675 :         /* Use our own file descriptor here.  This is where we do two cheats, one
; 4676 :            obvious, one subtle.  We stuff our own descriptor into the file member
; 4677 :            of the stream structure so we can use our own access methods within our
; 4678 :            modified _filbuf routine.  However, we also use a sleazy little VC++
; 4679 :            uniqueness by setting a flag that this is a _IOSTRG (stream is really
; 4680 :            a string).  This ensures that if the user accidently passes the FILE
; 4681 :            ptr to fclose, nothing nasty will occur.  It also ensures that should
; 4682 :            the run-time library decide to go south, the clean-up code won't
; 4683 :            exaserbate the problem, possibly allowing you to debug the original
; 4684 :            problem. */
; 4685 : 
; 4686 :         stream -> _file = handle; 

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR _handle$1[ebp]
	mov	DWORD PTR [ecx+16], edx

; 4687 : 
; 4688 :         /* Tag the structure as our own flavor (specifically 'archive'), as well
; 4689 :            as use a vc++ uniqueness. */
; 4690 : 
; 4691 :         stream -> _flag |= (_IOARCHIVE | _IOSTRG | _IOREAD);

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	or	ecx, 65601				; 00010041H
	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 4692 : 
; 4693 : 
; 4694 :         /* ---------------------------------------------------------------------------
; 4695 : 
; 4696 :                                           UGGGH!!
; 4697 : 
; 4698 :            Microsoft morons didn't implement any of their stdio streaming functions
; 4699 :            like everyone else in the fucking world, so this is a sordid fix.  The
; 4700 :            problem is that fread will bypass _filbuf if the requested read size is
; 4701 :            larger than the buffer.  Now, this alone is not a bad optimization, but
; 4702 :            it would have been a hell of lot easier if they had done it like everyone
; 4703 :            else and just put a function ptr for read/write within the iobuf struct.
; 4704 : 
; 4705 :            --------------------------------------------------------------------------- */
; 4706 : 
; 4707 :         stream -> _bufsiz = 0xffffffff;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [eax+24], -1

; 4708 : 
; 4709 :         /* --------------------------------------------------------------------------- */
; 4710 : 
; 4711 : 
; 4712 : 
; 4713 :         UNLOCK_STREAM( stream );

	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	call	__unlock_file
	add	esp, 4

; 4714 : 
; 4715 :         REQUEST_LOCK( archive -> lock );

	push	-1
	mov	edx, DWORD PTR _archive$3[ebp]
	mov	eax, DWORD PTR [edx+276]
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8

; 4716 : 
; 4717 :         sprintf( filename, "%s%s", GLOBAL_SEARCH_PATH[ entry -> directory ], entry -> name );

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _GLOBAL_SEARCH_PATH[ecx*4]
	push	edx
	push	OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
	lea	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H

; 4718 : 
; 4719 :         lseek( archive -> os_handle, entry -> file_position + SIGNATURE_SIZE, SEEK_SET );

	push	0
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	add	edx, 4
	push	edx
	mov	eax, DWORD PTR _archive$3[ebp]
	mov	ecx, DWORD PTR [eax+260]
	push	ecx
	call	_lseek
	add	esp, 12					; 0000000cH

; 4720 : 
; 4721 :         _read( archive -> os_handle, tmp, LREC_SIZE );

	push	26					; 0000001aH
	lea	edx, DWORD PTR _tmp$[ebp]
	push	edx
	mov	eax, DWORD PTR _archive$3[ebp]
	mov	ecx, DWORD PTR [eax+260]
	push	ecx
	call	__read
	add	esp, 12					; 0000000cH

; 4722 : 
; 4723 :         process_local_file_hdr( &lrec, tmp );    /* return PK-type error code */

	lea	edx, DWORD PTR _tmp$[ebp]
	push	edx
	lea	eax, DWORD PTR _lrec$[ebp]
	push	eax
	call	_process_local_file_hdr
	add	esp, 8

; 4724 : 
; 4725 :         file -> seek_start = lseek( archive -> os_handle, lrec.filename_length + lrec.extra_field_length, SEEK_CUR );

	push	1
	movzx	ecx, WORD PTR _lrec$[ebp+24]
	movzx	edx, WORD PTR _lrec$[ebp+26]
	add	ecx, edx
	push	ecx
	mov	eax, DWORD PTR _archive$3[ebp]
	mov	ecx, DWORD PTR [eax+260]
	push	ecx
	call	_lseek
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _file$5[ebp]
	mov	DWORD PTR [edx+4], eax

; 4726 : 
; 4727 : 
; 4728 : 		/* Initialize some common data */
; 4729 : 		file -> current_pos = 0;

	mov	eax, DWORD PTR _file$5[ebp]
	mov	DWORD PTR [eax+8], 0

; 4730 : 		file -> current_filbuf_pos = 0;

	mov	ecx, DWORD PTR _file$5[ebp]
	mov	DWORD PTR [ecx+44], 0

; 4731 : 
; 4732 : 
; 4733 :         switch( entry -> method ) {

	mov	edx, DWORD PTR _entry$[ebp]
	movsx	eax, WORD PTR [edx+16]
	mov	DWORD PTR tv329[ebp], eax
	cmp	DWORD PTR tv329[ebp], 0
	je	SHORT $LN6@ResFOpen
	cmp	DWORD PTR tv329[ebp], 8
	je	$LN4@ResFOpen
	jmp	$LN1@ResFOpen
$LN6@ResFOpen:

; 4734 :             case STORED: {
; 4735 :                 file -> os_handle   = archive -> os_handle;

	mov	ecx, DWORD PTR _file$5[ebp]
	mov	edx, DWORD PTR _archive$3[ebp]
	mov	eax, DWORD PTR [edx+260]
	mov	DWORD PTR [ecx], eax

; 4736 :                 //file -> seek_start  = entry -> file_position;
; 4737 :                 file -> csize       = 0;

	mov	ecx, DWORD PTR _file$5[ebp]
	mov	DWORD PTR [ecx+16], 0

; 4738 :                 file -> size        = entry -> size;

	mov	edx, DWORD PTR _file$5[ebp]
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+12], ecx

; 4739 :                 file -> filename    = MemStrDup( filename );

	lea	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	_strdup
	add	esp, 4
	mov	ecx, DWORD PTR _file$5[ebp]
	mov	DWORD PTR [ecx+40], eax

; 4740 :                 file -> mode        = _O_RDONLY | _O_BINARY;

	mov	edx, DWORD PTR _file$5[ebp]
	mov	DWORD PTR [edx+24], 32768		; 00008000H

; 4741 :                 file -> device      = entry -> volume;

	mov	eax, DWORD PTR _file$5[ebp]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	dl, BYTE PTR [ecx+36]
	mov	BYTE PTR [eax+32], dl

; 4742 :                 file -> zip         = NULL; /* only used if we need to deflate */

	mov	eax, DWORD PTR _file$5[ebp]
	mov	DWORD PTR [eax+48], 0

; 4743 : 
; 4744 :                 SHOULD_I_CALL_WITH( CALLBACK_OPEN_FILE, handle, retval );

	mov	ecx, 4
	shl	ecx, 2
	cmp	DWORD PTR _RES_CALLBACK[ecx], 0
	je	SHORT $LN5@ResFOpen
	mov	edx, DWORD PTR _handle$1[ebp]
	push	edx
	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _RES_CALLBACK[eax]
	call	ecx
	add	esp, 4
	mov	DWORD PTR _retval$[ebp], eax
$LN5@ResFOpen:

; 4745 : 
; 4746 :                 RELEASE_LOCK( archive -> lock );

	mov	edx, DWORD PTR _archive$3[ebp]
	mov	eax, DWORD PTR [edx+276]
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4

; 4747 : #if (RES_MULTITHREAD)
; 4748 : 	RELEASE_LOCK(GLOCK);

	mov	ecx, DWORD PTR _GLOCK
	push	ecx
	call	DWORD PTR __imp__ReleaseMutex@4

; 4749 : #endif
; 4750 :                 return( stream );

	mov	eax, DWORD PTR _stream$[ebp]
	jmp	$LN44@ResFOpen

; 4751 :                 break;

	jmp	$LN7@ResFOpen
$LN4@ResFOpen:

; 4752 :             }
; 4753 : 
; 4754 :             case DEFLATED: {
; 4755 :                 COMPRESSED_FILE * zip;
; 4756 :                                  
; 4757 : 				#ifdef USE_SH_POOLS
; 4758 :                 zip = (COMPRESSED_FILE *)MemAllocPtr( gResmgrMemPool, sizeof(COMPRESSED_FILE) + (entry -> size), 0 );
; 4759 : 				#else
; 4760 :                 zip = (COMPRESSED_FILE *)MemMalloc( sizeof(COMPRESSED_FILE) + (entry -> size), "Inflate" );

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, 48					; 00000030H
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _zip$4[ebp], eax

; 4761 : 				#endif
; 4762 : 
; 4763 :                 if( !zip ) {

	cmp	DWORD PTR _zip$4[ebp], 0
	jne	SHORT $LN3@ResFOpen

; 4764 :                     SAY_ERROR( RES_ERR_NO_MEMORY, "Inflate" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	4764					; 0000129cH
	push	OFFSET ??_C@_07DNABHHOL@Inflate?$AA@
	push	-4999					; ffffec79H
	call	__say_error
	add	esp, 16					; 00000010H

; 4765 :                     RELEASE_LOCK( archive -> lock );

	mov	ecx, DWORD PTR _archive$3[ebp]
	mov	edx, DWORD PTR [ecx+276]
	push	edx
	call	DWORD PTR __imp__ReleaseMutex@4

; 4766 : #if (RES_MULTITHREAD)
; 4767 : 	RELEASE_LOCK(GLOCK);

	mov	eax, DWORD PTR _GLOCK
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4

; 4768 : #endif
; 4769 :                     return( NULL );

	xor	eax, eax
	jmp	$LN44@ResFOpen
$LN3@ResFOpen:

; 4770 :                 }
; 4771 : 
; 4772 :                 file -> os_handle   = archive -> os_handle;

	mov	ecx, DWORD PTR _file$5[ebp]
	mov	edx, DWORD PTR _archive$3[ebp]
	mov	eax, DWORD PTR [edx+260]
	mov	DWORD PTR [ecx], eax

; 4773 :                 //file -> seek_start  = entry -> file_position;
; 4774 :                 file -> csize       = entry -> csize;

	mov	ecx, DWORD PTR _file$5[ebp]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+16], eax

; 4775 :                 file -> size        = entry -> size;

	mov	ecx, DWORD PTR _file$5[ebp]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+12], eax

; 4776 :                 file -> filename    = MemStrDup( filename );

	lea	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_strdup
	add	esp, 4
	mov	edx, DWORD PTR _file$5[ebp]
	mov	DWORD PTR [edx+40], eax

; 4777 :                 file -> mode        = _O_RDONLY | _O_BINARY;

	mov	eax, DWORD PTR _file$5[ebp]
	mov	DWORD PTR [eax+24], 32768		; 00008000H

; 4778 :                 file -> device      = entry -> volume;

	mov	ecx, DWORD PTR _file$5[ebp]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	al, BYTE PTR [edx+36]
	mov	BYTE PTR [ecx+32], al

; 4779 : 
; 4780 : 				#ifdef USE_SH_POOLS
; 4781 :                 zip -> slide      = (uch *)MemAllocPtr( gResmgrMemPool, UNZIP_SLIDE_SIZE + INPUTBUFSIZE, 0 ); /* glob temporary allocations */
; 4782 : 				#else
; 4783 :                 zip -> slide      = (uch *)MemMalloc( UNZIP_SLIDE_SIZE + INPUTBUFSIZE, "deflate" ); /* glob temporary allocations */

	push	53248					; 0000d000H
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _zip$4[ebp]
	mov	DWORD PTR [ecx], eax

; 4784 : 				#endif
; 4785 : 
; 4786 :                 zip -> in_buffer  = (uch *)zip -> slide + UNZIP_SLIDE_SIZE;

	mov	edx, DWORD PTR _zip$4[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 32768				; 00008000H
	mov	ecx, DWORD PTR _zip$4[ebp]
	mov	DWORD PTR [ecx+4], eax

; 4787 :                 zip -> in_ptr     = (uch *)zip -> in_buffer;

	mov	edx, DWORD PTR _zip$4[ebp]
	mov	eax, DWORD PTR _zip$4[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 4788 :                 zip -> in_count   = 0;

	mov	edx, DWORD PTR _zip$4[ebp]
	mov	DWORD PTR [edx+12], 0

; 4789 :                 zip -> in_size    = file -> csize > INPUTBUFSIZE ? INPUTBUFSIZE : file -> csize;

	mov	eax, DWORD PTR _file$5[ebp]
	cmp	DWORD PTR [eax+16], 20480		; 00005000H
	jbe	SHORT $LN46@ResFOpen
	mov	DWORD PTR tv389[ebp], 20480		; 00005000H
	jmp	SHORT $LN47@ResFOpen
$LN46@ResFOpen:
	mov	ecx, DWORD PTR _file$5[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR tv389[ebp], edx
$LN47@ResFOpen:
	mov	eax, DWORD PTR _zip$4[ebp]
	mov	ecx, DWORD PTR tv389[ebp]
	mov	DWORD PTR [eax+16], ecx

; 4790 :                 zip -> csize      = file -> csize;

	mov	edx, DWORD PTR _zip$4[ebp]
	mov	eax, DWORD PTR _file$5[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+40], ecx

; 4791 : 
; 4792 :                 zip -> out_buffer = (char *)zip + sizeof(COMPRESSED_FILE);

	mov	edx, DWORD PTR _zip$4[ebp]
	add	edx, 48					; 00000030H
	mov	eax, DWORD PTR _zip$4[ebp]
	mov	DWORD PTR [eax+20], edx

; 4793 :                 zip -> out_count  = 0;

	mov	ecx, DWORD PTR _zip$4[ebp]
	mov	DWORD PTR [ecx+24], 0

; 4794 :                 zip -> archive    = archive;

	mov	edx, DWORD PTR _zip$4[ebp]
	mov	eax, DWORD PTR _archive$3[ebp]
	mov	DWORD PTR [edx+44], eax

; 4795 : 
; 4796 :                 file -> zip       = zip;    /* Future use: I may add incremental deflation */

	mov	ecx, DWORD PTR _file$5[ebp]
	mov	edx, DWORD PTR _zip$4[ebp]
	mov	DWORD PTR [ecx+48], edx

; 4797 : 
; 4798 :                 //lseek( file -> os_handle, file -> seek_start, SEEK_SET );
; 4799 :                 inflate( zip );

	mov	eax, DWORD PTR _zip$4[ebp]
	push	eax
	call	_inflate
	add	esp, 4

; 4800 : 
; 4801 : 				#ifdef USE_SH_POOLS
; 4802 :                 MemFreePtr( zip -> slide );    /* Free temporary allocations */
; 4803 : 				#else
; 4804 :                 MemFree( zip -> slide );    /* Free temporary allocations */

	mov	ecx, DWORD PTR _zip$4[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_free
	add	esp, 4

; 4805 : 				#endif
; 4806 : 
; 4807 :                 SHOULD_I_CALL_WITH( CALLBACK_OPEN_FILE, handle, retval );

	mov	eax, 4
	shl	eax, 2
	cmp	DWORD PTR _RES_CALLBACK[eax], 0
	je	SHORT $LN2@ResFOpen
	mov	ecx, DWORD PTR _handle$1[ebp]
	push	ecx
	mov	edx, 4
	shl	edx, 2
	mov	eax, DWORD PTR _RES_CALLBACK[edx]
	call	eax
	add	esp, 4
	mov	DWORD PTR _retval$[ebp], eax
$LN2@ResFOpen:

; 4808 : 
; 4809 :                 RELEASE_LOCK( archive -> lock );

	mov	ecx, DWORD PTR _archive$3[ebp]
	mov	edx, DWORD PTR [ecx+276]
	push	edx
	call	DWORD PTR __imp__ReleaseMutex@4

; 4810 : #if (RES_MULTITHREAD)
; 4811 : 	RELEASE_LOCK(GLOCK);

	mov	eax, DWORD PTR _GLOCK
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4

; 4812 : #endif
; 4813 :                 return( stream );

	mov	eax, DWORD PTR _stream$[ebp]
	jmp	SHORT $LN44@ResFOpen

; 4814 :                 break;

	jmp	SHORT $LN7@ResFOpen
$LN1@ResFOpen:

; 4815 :             }
; 4816 : 
; 4817 :             default:
; 4818 :                 SAY_ERROR( RES_ERR_UNSUPPORTED_COMPRESSION, entry -> name );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	4818					; 000012d2H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	push	-4969					; ffffec97H
	call	__say_error
	add	esp, 16					; 00000010H

; 4819 : #if (RES_MULTITHREAD)
; 4820 : 	RELEASE_LOCK(GLOCK);

	mov	eax, DWORD PTR _GLOCK
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4

; 4821 : #endif
; 4822 :                 return( NULL );

	xor	eax, eax
	jmp	SHORT $LN44@ResFOpen
$LN7@ResFOpen:

; 4823 :                 break;
; 4824 :         }
; 4825 : 
; 4826 :         RELEASE_LOCK( archive -> lock );

	mov	ecx, DWORD PTR _archive$3[ebp]
	mov	edx, DWORD PTR [ecx+276]
	push	edx
	call	DWORD PTR __imp__ReleaseMutex@4
$LN15@ResFOpen:

; 4827 :     }
; 4828 : #if (RES_MULTITHREAD)
; 4829 : 	RELEASE_LOCK(GLOCK);

	mov	eax, DWORD PTR _GLOCK
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4

; 4830 : #endif
; 4831 : 
; 4832 :     return( NULL );

	xor	eax, eax
$LN44@ResFOpen:

; 4833 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_ResFOpen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_fdst$ = -544						; size = 4
_fsrc$ = -540						; size = 4
_buffer$ = -536						; size = 4
_handle$ = -532						; size = 4
_size$ = -528						; size = 4
_fullsrc$ = -524					; size = 260
_fulldst$ = -264					; size = 260
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_ResExtractFile PROC

; 4126 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 544				; 00000220H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 4127 :     char * buffer;
; 4128 :     int    handle;
; 4129 :     unsigned int size;
; 4130 : 
; 4131 :     const char * fdst = dst; /* expanded pathnames */

	mov	eax, DWORD PTR _dst$[ebp]
	mov	DWORD PTR _fdst$[ebp], eax

; 4132 : 	const char * fsrc = src;

	mov	ecx, DWORD PTR _src$[ebp]
	mov	DWORD PTR _fsrc$[ebp], ecx

; 4133 : 
; 4134 : #if( RES_COERCE_FILENAMES )
; 4135 :     char   fulldst[_MAX_PATH],
; 4136 :            fullsrc[_MAX_PATH];
; 4137 : #endif /*RES_COERCE_FILENAMES */
; 4138 : 
; 4139 : #if( RES_DEBUG_PARAMS )
; 4140 :     if( !dst || !src ) {

	cmp	DWORD PTR _dst$[ebp], 0
	je	SHORT $LN6@ResExtract
	cmp	DWORD PTR _src$[ebp], 0
	jne	SHORT $LN7@ResExtract
$LN6@ResExtract:

; 4141 :         SAY_ERROR( RES_ERR_INCORRECT_PARAMETER, "ResExtract" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	4141					; 0000102dH
	push	OFFSET ??_C@_0L@GFEJONIC@ResExtract?$AA@
	push	-4998					; ffffec7aH
	call	__say_error
	add	esp, 16					; 00000010H

; 4142 :         return( -1 );

	or	eax, -1
	jmp	$LN8@ResExtract
$LN7@ResExtract:

; 4143 :     }
; 4144 : #endif /* RES_DEBUG_PARAMS */
; 4145 : 
; 4146 : #if( RES_COERCE_FILENAMES )
; 4147 :     if( strchr( dst, ASCII_BACKSLASH )) {

	push	92					; 0000005cH
	mov	edx, DWORD PTR _dst$[ebp]
	push	edx
	call	_strchr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN5@ResExtract

; 4148 :         res_fullpath( fulldst, dst, _MAX_PATH );

	push	260					; 00000104H
	mov	eax, DWORD PTR _dst$[ebp]
	push	eax
	lea	ecx, DWORD PTR _fulldst$[ebp]
	push	ecx
	call	_res_fullpath
	add	esp, 12					; 0000000cH

; 4149 :         fdst = fulldst;

	lea	edx, DWORD PTR _fulldst$[ebp]
	mov	DWORD PTR _fdst$[ebp], edx
$LN5@ResExtract:

; 4150 :     }
; 4151 : 
; 4152 :     if( strchr( src, ASCII_BACKSLASH )) {

	push	92					; 0000005cH
	mov	eax, DWORD PTR _src$[ebp]
	push	eax
	call	_strchr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN4@ResExtract

; 4153 :         res_fullpath( fullsrc, src, _MAX_PATH );

	push	260					; 00000104H
	mov	ecx, DWORD PTR _src$[ebp]
	push	ecx
	lea	edx, DWORD PTR _fullsrc$[ebp]
	push	edx
	call	_res_fullpath
	add	esp, 12					; 0000000cH

; 4154 :         fsrc = fullsrc;

	lea	eax, DWORD PTR _fullsrc$[ebp]
	mov	DWORD PTR _fsrc$[ebp], eax
$LN4@ResExtract:

; 4155 :     }
; 4156 : #endif /* RES_COERCE_FILENAMES */
; 4157 : 
; 4158 :     buffer = ResLoadFile( fsrc, NULL, &size );

	lea	ecx, DWORD PTR _size$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _fsrc$[ebp]
	push	edx
	call	_ResLoadFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _buffer$[ebp], eax

; 4159 : 
; 4160 :     if( buffer ) {

	cmp	DWORD PTR _buffer$[ebp], 0
	je	SHORT $LN3@ResExtract

; 4161 :         handle = ResOpenFile( fdst, _O_CREAT | _O_WRONLY | _O_BINARY );

	push	33025					; 00008101H
	mov	eax, DWORD PTR _fdst$[ebp]
	push	eax
	call	_ResOpenFile
	add	esp, 8
	mov	DWORD PTR _handle$[ebp], eax

; 4162 :         if( handle != -1 ) {

	cmp	DWORD PTR _handle$[ebp], -1
	je	SHORT $LN2@ResExtract

; 4163 :             size = ResWriteFile( handle, buffer, size );

	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _handle$[ebp]
	push	eax
	call	_ResWriteFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _size$[ebp], eax

; 4164 :             ResCloseFile( handle );

	mov	ecx, DWORD PTR _handle$[ebp]
	push	ecx
	call	_ResCloseFile
	add	esp, 4
$LN2@ResExtract:

; 4165 :         }
; 4166 :         ResUnloadFile( buffer );

	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_ResUnloadFile
	add	esp, 4

; 4167 :     }
; 4168 :     else

	jmp	SHORT $LN1@ResExtract
$LN3@ResExtract:

; 4169 :         return( -1 );

	or	eax, -1
	jmp	SHORT $LN8@ResExtract
$LN1@ResExtract:

; 4170 : 
; 4171 :     return( size );

	mov	eax, DWORD PTR _size$[ebp]
$LN8@ResExtract:

; 4172 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_ResExtractFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_src$ = -16						; size = 4
_hit$ = -12						; size = 4
_list$ = -8						; size = 4
_entry$ = -4						; size = 4
_filename$ = 8						; size = 4
_stat_buffer$ = 12					; size = 4
_ResStatusFile PROC

; 3117 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 3118 :     HASH_ENTRY * entry;
; 3119 :     LIST * list;
; 3120 :     int hit;
; 3121 : 
; 3122 :     char * src;
; 3123 : 
; 3124 : #if( RES_DEBUG_PARAMS )
; 3125 :     if( !filename || !stat_buffer ) {

	cmp	DWORD PTR _filename$[ebp], 0
	je	SHORT $LN7@ResStatusF
	cmp	DWORD PTR _stat_buffer$[ebp], 0
	jne	SHORT $LN8@ResStatusF
$LN7@ResStatusF:

; 3126 :         SAY_ERROR( RES_ERR_INCORRECT_PARAMETER, "ResStatusFile" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	3126					; 00000c36H
	push	OFFSET ??_C@_0O@COOJBPCO@ResStatusFile?$AA@
	push	-4998					; ffffec7aH
	call	__say_error
	add	esp, 16					; 00000010H

; 3127 :         return( FALSE );

	xor	eax, eax
	jmp	$LN9@ResStatusF
$LN8@ResStatusF:

; 3128 :     }
; 3129 : #endif /* RES_DEBUG_PARAMS */
; 3130 : 
; 3131 :     if( !GLOBAL_SEARCH_INDEX ) {

	cmp	DWORD PTR _GLOBAL_SEARCH_INDEX, 0
	jne	SHORT $LN6@ResStatusF

; 3132 :         SAY_ERROR( RES_ERR_MUST_CREATE_PATH, "ResStatusFile" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	3132					; 00000c3cH
	push	OFFSET ??_C@_0O@COOJBPCO@ResStatusFile?$AA@
	push	-4986					; ffffec86H
	call	__say_error
	add	esp, 16					; 00000010H

; 3133 :         return( FALSE );

	xor	eax, eax
	jmp	$LN9@ResStatusF
$LN6@ResStatusF:

; 3134 :     }
; 3135 : #if (RES_MULTITHREAD)
; 3136 : 	REQUEST_LOCK(GLOCK);

	push	-1
	mov	eax, DWORD PTR _GLOCK
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8

; 3137 : #endif
; 3138 : 
; 3139 :     entry = hash_find_table( filename, NULL );

	push	0
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_hash_find_table
	add	esp, 8
	mov	DWORD PTR _entry$[ebp], eax

; 3140 : 
; 3141 :     if( !entry )

	cmp	DWORD PTR _entry$[ebp], 0
	jne	SHORT $LN5@ResStatusF

; 3142 : 	{
; 3143 : #if (RES_MULTITHREAD)
; 3144 : 	RELEASE_LOCK(GLOCK);

	mov	edx, DWORD PTR _GLOCK
	push	edx
	call	DWORD PTR __imp__ReleaseMutex@4

; 3145 : #endif
; 3146 :         return( FALSE );

	xor	eax, eax
	jmp	$LN9@ResStatusF
$LN5@ResStatusF:

; 3147 : 	}
; 3148 :     stat_buffer -> size       = entry -> size;

	mov	eax, DWORD PTR _stat_buffer$[ebp]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax], edx

; 3149 :     stat_buffer -> csize      = entry -> csize;

	mov	eax, DWORD PTR _stat_buffer$[ebp]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+4], edx

; 3150 :     stat_buffer -> volume     = entry -> volume;

	mov	eax, DWORD PTR _entry$[ebp]
	movsx	ecx, BYTE PTR [eax+36]
	mov	edx, DWORD PTR _stat_buffer$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 3151 :     stat_buffer -> attributes = entry -> attrib;

	mov	eax, DWORD PTR _stat_buffer$[ebp]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+20], edx

; 3152 :     stat_buffer -> archive    = entry -> archive;

	mov	eax, DWORD PTR _stat_buffer$[ebp]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+16], edx

; 3153 : 
; 3154 :     stat_buffer -> directory  = -1;

	mov	eax, DWORD PTR _stat_buffer$[ebp]
	mov	DWORD PTR [eax+8], -1

; 3155 : 
; 3156 :     src = GLOBAL_SEARCH_PATH[ entry -> directory ];

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _GLOBAL_SEARCH_PATH[edx*4]
	mov	DWORD PTR _src$[ebp], eax

; 3157 : 
; 3158 :     hit = 0;

	mov	DWORD PTR _hit$[ebp], 0

; 3159 : 
; 3160 :     for( list = GLOBAL_PATH_LIST; list; list = list -> next ) {

	mov	ecx, DWORD PTR _GLOBAL_PATH_LIST
	mov	DWORD PTR _list$[ebp], ecx
	jmp	SHORT $LN4@ResStatusF
$LN3@ResStatusF:
	mov	edx, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _list$[ebp], eax
$LN4@ResStatusF:
	cmp	DWORD PTR _list$[ebp], 0
	je	SHORT $LN2@ResStatusF

; 3161 :         if( !(strcmp( src, ((HASH_TABLE *)(list -> node)) -> name ))) {

	mov	ecx, DWORD PTR _list$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _src$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN1@ResStatusF

; 3162 :             stat_buffer -> directory = hit;

	mov	edx, DWORD PTR _stat_buffer$[ebp]
	mov	eax, DWORD PTR _hit$[ebp]
	mov	DWORD PTR [edx+8], eax

; 3163 :             break;

	jmp	SHORT $LN2@ResStatusF
$LN1@ResStatusF:

; 3164 :         }
; 3165 :         hit++;

	mov	ecx, DWORD PTR _hit$[ebp]
	add	ecx, 1
	mov	DWORD PTR _hit$[ebp], ecx

; 3166 :     }

	jmp	SHORT $LN3@ResStatusF
$LN2@ResStatusF:

; 3167 :         
; 3168 :     IF_LOG( LOG( "stat: %s\n", filename ));
; 3169 : 
; 3170 : #if (RES_MULTITHREAD)
; 3171 : 	RELEASE_LOCK(GLOCK);

	mov	edx, DWORD PTR _GLOCK
	push	edx
	call	DWORD PTR __imp__ReleaseMutex@4

; 3172 : #endif
; 3173 :     return( TRUE );

	mov	eax, 1
$LN9@ResStatusF:

; 3174 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ResStatusFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
tv135 = -4						; size = 4
_handle$ = 8						; size = 4
_offset$ = 12						; size = 4
_origin$ = 16						; size = 4
_ResSeekFile PROC

; 2693 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2694 : #if( RES_DEBUG_PARAMS )
; 2695 :     if( handle < 0 || handle >= MAX_FILE_HANDLES ) {

	cmp	DWORD PTR _handle$[ebp], 0
	jl	SHORT $LN10@ResSeekFil
	cmp	DWORD PTR _handle$[ebp], 256		; 00000100H
	jl	SHORT $LN11@ResSeekFil
$LN10@ResSeekFil:

; 2696 :         SAY_ERROR( RES_ERR_INCORRECT_PARAMETER, "ResSeekFile" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	2696					; 00000a88H
	push	OFFSET ??_C@_0M@MICEAOJD@ResSeekFile?$AA@
	push	-4998					; ffffec7aH
	call	__say_error
	add	esp, 16					; 00000010H

; 2697 :         return( -1 );

	or	eax, -1
	jmp	$LN12@ResSeekFil
$LN11@ResSeekFil:

; 2698 :     }
; 2699 : 
; 2700 :     if((origin != SEEK_CUR) && (origin != SEEK_SET) && (origin != SEEK_END)) {

	cmp	DWORD PTR _origin$[ebp], 1
	je	SHORT $LN9@ResSeekFil
	cmp	DWORD PTR _origin$[ebp], 0
	je	SHORT $LN9@ResSeekFil
	cmp	DWORD PTR _origin$[ebp], 2
	je	SHORT $LN9@ResSeekFil

; 2701 :         SAY_ERROR( RES_ERR_INCORRECT_PARAMETER, "ResSeekFile" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	2701					; 00000a8dH
	push	OFFSET ??_C@_0M@MICEAOJD@ResSeekFile?$AA@
	push	-4998					; ffffec7aH
	call	__say_error
	add	esp, 16					; 00000010H

; 2702 :         return( -1 );

	or	eax, -1
	jmp	$LN12@ResSeekFil
$LN9@ResSeekFil:

; 2703 :     }
; 2704 : #endif /* RES_DEBUG_PARAMS */
; 2705 : #if (RES_MULTITHREAD)
; 2706 : 	REQUEST_LOCK(GLOCK);

	push	-1
	mov	eax, DWORD PTR _GLOCK
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8

; 2707 : #endif
; 2708 : 
; 2709 :     IF_LOG( LOG( "seek: %s\n", FILE_HANDLES[handle].filename ));
; 2710 : 
; 2711 :     if( FILE_HANDLES[ handle ].os_handle == -1 ) {

	mov	ecx, DWORD PTR _handle$[ebp]
	imul	ecx, 52					; 00000034H
	mov	edx, DWORD PTR _FILE_HANDLES
	cmp	DWORD PTR [edx+ecx], -1
	jne	SHORT $LN8@ResSeekFil

; 2712 :         SAY_ERROR( RES_ERR_ILLEGAL_FILE_HANDLE, "ResReadFile" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	2712					; 00000a98H
	push	OFFSET ??_C@_0M@NKEGIMBG@ResReadFile?$AA@
	push	-4977					; ffffec8fH
	call	__say_error
	add	esp, 16					; 00000010H

; 2713 : #if (RES_MULTITHREAD)
; 2714 : 	RELEASE_LOCK(GLOCK);

	mov	eax, DWORD PTR _GLOCK
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4

; 2715 : #endif
; 2716 :         return( -1 );

	or	eax, -1
	jmp	$LN12@ResSeekFil
$LN8@ResSeekFil:

; 2717 :     }
; 2718 :     
; 2719 :     /* If we are writing, do seek anyway */
; 2720 :     if( FILE_HANDLES[ handle ].mode & (O_WRONLY|O_RDWR) ) {

	mov	ecx, DWORD PTR _handle$[ebp]
	imul	ecx, 52					; 00000034H
	mov	edx, DWORD PTR _FILE_HANDLES
	mov	eax, DWORD PTR [edx+ecx+24]
	and	eax, 3
	je	SHORT $LN7@ResSeekFil

; 2721 :         FILE_HANDLES[ handle ].current_pos  = lseek( FILE_HANDLES[ handle ].os_handle, offset, origin );

	mov	ecx, DWORD PTR _origin$[ebp]
	push	ecx
	mov	edx, DWORD PTR _offset$[ebp]
	push	edx
	mov	eax, DWORD PTR _handle$[ebp]
	imul	eax, 52					; 00000034H
	mov	ecx, DWORD PTR _FILE_HANDLES
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	call	_lseek
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _handle$[ebp]
	imul	ecx, 52					; 00000034H
	mov	edx, DWORD PTR _FILE_HANDLES
	mov	DWORD PTR [edx+ecx+8], eax

; 2722 :     }
; 2723 :     else {

	jmp	SHORT $LN6@ResSeekFil
$LN7@ResSeekFil:

; 2724 :         /* cache the seek until we perform the read */
; 2725 : 
; 2726 :         switch( origin ) {

	mov	eax, DWORD PTR _origin$[ebp]
	mov	DWORD PTR tv135[ebp], eax
	cmp	DWORD PTR tv135[ebp], 0
	je	SHORT $LN3@ResSeekFil
	cmp	DWORD PTR tv135[ebp], 1
	je	SHORT $LN2@ResSeekFil
	cmp	DWORD PTR tv135[ebp], 2
	je	SHORT $LN1@ResSeekFil
	jmp	SHORT $LN6@ResSeekFil
$LN3@ResSeekFil:

; 2727 :             case SEEK_SET: /* 0 */
; 2728 :                 FILE_HANDLES[ handle ].current_pos = offset;

	mov	ecx, DWORD PTR _handle$[ebp]
	imul	ecx, 52					; 00000034H
	mov	edx, DWORD PTR _FILE_HANDLES
	mov	eax, DWORD PTR _offset$[ebp]
	mov	DWORD PTR [edx+ecx+8], eax

; 2729 :                 break;

	jmp	SHORT $LN6@ResSeekFil
$LN2@ResSeekFil:

; 2730 :             case SEEK_CUR: /* 1 */
; 2731 :                 FILE_HANDLES[ handle ].current_pos += offset;

	mov	ecx, DWORD PTR _handle$[ebp]
	imul	ecx, 52					; 00000034H
	mov	edx, DWORD PTR _FILE_HANDLES
	mov	eax, DWORD PTR [edx+ecx+8]
	add	eax, DWORD PTR _offset$[ebp]
	mov	ecx, DWORD PTR _handle$[ebp]
	imul	ecx, 52					; 00000034H
	mov	edx, DWORD PTR _FILE_HANDLES
	mov	DWORD PTR [edx+ecx+8], eax

; 2732 :                 break;

	jmp	SHORT $LN6@ResSeekFil
$LN1@ResSeekFil:

; 2733 :             case SEEK_END: /* 2 */
; 2734 :                 FILE_HANDLES[ handle ].current_pos = FILE_HANDLES[ handle ].size + offset;

	mov	eax, DWORD PTR _handle$[ebp]
	imul	eax, 52					; 00000034H
	mov	ecx, DWORD PTR _FILE_HANDLES
	mov	edx, DWORD PTR [ecx+eax+12]
	add	edx, DWORD PTR _offset$[ebp]
	mov	eax, DWORD PTR _handle$[ebp]
	imul	eax, 52					; 00000034H
	mov	ecx, DWORD PTR _FILE_HANDLES
	mov	DWORD PTR [ecx+eax+8], edx
$LN6@ResSeekFil:

; 2735 :                 break;
; 2736 :         }
; 2737 :     }
; 2738 : 
; 2739 : #if (RES_MULTITHREAD)
; 2740 : 	RELEASE_LOCK(GLOCK);

	mov	edx, DWORD PTR _GLOCK
	push	edx
	call	DWORD PTR __imp__ReleaseMutex@4

; 2741 : #endif
; 2742 :     return( FILE_HANDLES[ handle ].current_pos );

	mov	eax, DWORD PTR _handle$[ebp]
	imul	eax, 52					; 00000034H
	mov	ecx, DWORD PTR _FILE_HANDLES
	mov	eax, DWORD PTR [ecx+eax+8]
$LN12@ResSeekFil:

; 2743 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ResSeekFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_handle$ = 8						; size = 4
_ResTellFile PROC

; 2645 : {

	push	ebp
	mov	ebp, esp

; 2646 : #if( RES_DEBUG_PARAMS )
; 2647 :     if( handle < 0 || handle >= MAX_FILE_HANDLES ) {

	cmp	DWORD PTR _handle$[ebp], 0
	jl	SHORT $LN2@ResTellFil
	cmp	DWORD PTR _handle$[ebp], 256		; 00000100H
	jl	SHORT $LN3@ResTellFil
$LN2@ResTellFil:

; 2648 :         SAY_ERROR( RES_ERR_INCORRECT_PARAMETER, "ResTellFile" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	2648					; 00000a58H
	push	OFFSET ??_C@_0M@CENIBGDB@ResTellFile?$AA@
	push	-4998					; ffffec7aH
	call	__say_error
	add	esp, 16					; 00000010H

; 2649 :         return( -1 );

	or	eax, -1
	jmp	SHORT $LN4@ResTellFil
$LN3@ResTellFil:

; 2650 :     }
; 2651 : #endif
; 2652 : #if (RES_MULTITHREAD)
; 2653 : 	REQUEST_LOCK(GLOCK);

	push	-1
	mov	eax, DWORD PTR _GLOCK
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8

; 2654 : #endif
; 2655 : 
; 2656 :     if( FILE_HANDLES[ handle ].os_handle == -1 ) {

	mov	ecx, DWORD PTR _handle$[ebp]
	imul	ecx, 52					; 00000034H
	mov	edx, DWORD PTR _FILE_HANDLES
	cmp	DWORD PTR [edx+ecx], -1
	jne	SHORT $LN1@ResTellFil

; 2657 :         SAY_ERROR( RES_ERR_ILLEGAL_FILE_HANDLE, "ResTellFile" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	2657					; 00000a61H
	push	OFFSET ??_C@_0M@CENIBGDB@ResTellFile?$AA@
	push	-4977					; ffffec8fH
	call	__say_error
	add	esp, 16					; 00000010H

; 2658 : #if (RES_MULTITHREAD)
; 2659 : 	RELEASE_LOCK(GLOCK);

	mov	eax, DWORD PTR _GLOCK
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4

; 2660 : #endif
; 2661 :         return( -1 );

	or	eax, -1
	jmp	SHORT $LN4@ResTellFil
$LN1@ResTellFil:

; 2662 :     }
; 2663 : #if (RES_MULTITHREAD)
; 2664 : 	RELEASE_LOCK(GLOCK);

	mov	ecx, DWORD PTR _GLOCK
	push	ecx
	call	DWORD PTR __imp__ReleaseMutex@4

; 2665 : #endif
; 2666 : 
; 2667 :     return( FILE_HANDLES[ handle ].current_pos );

	mov	edx, DWORD PTR _handle$[ebp]
	imul	edx, 52					; 00000034H
	mov	eax, DWORD PTR _FILE_HANDLES
	mov	eax, DWORD PTR [eax+edx+8]
$LN4@ResTellFil:

; 2668 : }

	pop	ebp
	ret	0
_ResTellFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_check$ = -8						; size = 4
_entry$ = -4						; size = 4
_name$ = 8						; size = 4
_flags$ = 12						; size = 4
_ResModifyFile PROC

; 2153 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2154 :     HASH_ENTRY * entry;                        /* ptr to entry in hash table            */
; 2155 :     int          check;                        /* test return val from system calls    */
; 2156 : 
; 2157 : #if( RES_DEBUG_PARAMS )
; 2158 :     if( !name ) {

	cmp	DWORD PTR _name$[ebp], 0
	jne	SHORT $LN5@ResModifyF

; 2159 :         SAY_ERROR( RES_ERR_INCORRECT_PARAMETER, "ResModifyFile" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	2159					; 0000086fH
	push	OFFSET ??_C@_0O@FHKDEOHM@ResModifyFile?$AA@
	push	-4998					; ffffec7aH
	call	__say_error
	add	esp, 16					; 00000010H

; 2160 :         return( FALSE );

	xor	eax, eax
	jmp	$LN6@ResModifyF
$LN5@ResModifyF:

; 2161 :     }
; 2162 : #endif
; 2163 : #if (RES_MULTITHREAD)
; 2164 : 	REQUEST_LOCK(GLOCK);

	push	-1
	mov	eax, DWORD PTR _GLOCK
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8

; 2165 : #endif
; 2166 : 
; 2167 :     IF_LOG( LOG( "modify: %s %d\n", name, flags ));
; 2168 : 
; 2169 : #if( !RES_USE_FLAT_MODEL )
; 2170 :     entry = hash_find_table( name, NULL );

	push	0
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_hash_find_table
	add	esp, 8
	mov	DWORD PTR _entry$[ebp], eax

; 2171 : #else
; 2172 :     entry = hash_find( name, GLOBAL_HASH_TABLE );
; 2173 : #endif
; 2174 : 
; 2175 :     if( !entry ) {

	cmp	DWORD PTR _entry$[ebp], 0
	jne	SHORT $LN4@ResModifyF

; 2176 :         SAY_ERROR( RES_ERR_FILE_NOT_FOUND, name );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	2176					; 00000880H
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	push	-4993					; ffffec7fH
	call	__say_error
	add	esp, 16					; 00000010H

; 2177 : #if (RES_MULTITHREAD)
; 2178 : 	RELEASE_LOCK(GLOCK);

	mov	eax, DWORD PTR _GLOCK
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4

; 2179 : #endif
; 2180 :         return( FALSE );

	xor	eax, eax
	jmp	$LN6@ResModifyF
$LN4@ResModifyF:

; 2181 :     }
; 2182 : 
; 2183 :     if( entry -> file_position == -1 ) {       /* is the file on the harddrive        */

	mov	ecx, DWORD PTR _entry$[ebp]
	cmp	DWORD PTR [ecx+20], -1
	jne	SHORT $LN3@ResModifyF

; 2184 :         check = chmod( entry -> name, flags );

	mov	edx, DWORD PTR _flags$[ebp]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_chmod
	add	esp, 8
	mov	DWORD PTR _check$[ebp], eax

; 2185 : 
; 2186 :         if( check == -1 ) {

	cmp	DWORD PTR _check$[ebp], -1
	jne	SHORT $LN2@ResModifyF

; 2187 :             SAY_ERROR( RES_ERR_CANT_ATTRIB_FILE, name );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	2187					; 0000088bH
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	push	-4991					; ffffec81H
	call	__say_error
	add	esp, 16					; 00000010H

; 2188 : #if (RES_MULTITHREAD)
; 2189 : 	RELEASE_LOCK(GLOCK);

	mov	eax, DWORD PTR _GLOCK
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4

; 2190 : #endif
; 2191 :             return( FALSE );

	xor	eax, eax
	jmp	SHORT $LN6@ResModifyF
$LN2@ResModifyF:

; 2192 :         }
; 2193 :         
; 2194 :         entry -> attrib = flags | FORCE_BIT;

	mov	ecx, DWORD PTR _flags$[ebp]
	or	ecx, -2147483648			; 80000000H
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+28], ecx

; 2195 :     }
; 2196 :     else {

	jmp	SHORT $LN1@ResModifyF
$LN3@ResModifyF:

; 2197 :         SAY_ERROR( RES_ERR_CANT_ATTRIB_FILE, name );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	2197					; 00000895H
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	-4991					; ffffec81H
	call	__say_error
	add	esp, 16					; 00000010H

; 2198 : #if (RES_MULTITHREAD)
; 2199 : 	RELEASE_LOCK(GLOCK);

	mov	ecx, DWORD PTR _GLOCK
	push	ecx
	call	DWORD PTR __imp__ReleaseMutex@4

; 2200 : #endif
; 2201 :         return( FALSE );

	xor	eax, eax
	jmp	SHORT $LN6@ResModifyF
$LN1@ResModifyF:

; 2202 :     }
; 2203 : 
; 2204 : #if (RES_MULTITHREAD)
; 2205 : 	RELEASE_LOCK(GLOCK);

	mov	edx, DWORD PTR _GLOCK
	push	edx
	call	DWORD PTR __imp__ReleaseMutex@4

; 2206 : #endif
; 2207 :     return( TRUE );

	mov	eax, 1
$LN6@ResModifyF:

; 2208 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ResModifyFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_table$ = -12						; size = 4
_check$ = -8						; size = 4
_entry$ = -4						; size = 4
_name$ = 8						; size = 4
_ResDeleteFile PROC

; 2084 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 2085 :     HASH_ENTRY * entry;
; 2086 :     HASH_TABLE * table;
; 2087 : 
; 2088 :     int check;
; 2089 : 
; 2090 : #if( RES_DEBUG_PARAMS )
; 2091 :     if( !name ) {

	cmp	DWORD PTR _name$[ebp], 0
	jne	SHORT $LN4@ResDeleteF

; 2092 :         SAY_ERROR( RES_ERR_INCORRECT_PARAMETER, "ResDeleteFile" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	2092					; 0000082cH
	push	OFFSET ??_C@_0O@FDOOBIGA@ResDeleteFile?$AA@
	push	-4998					; ffffec7aH
	call	__say_error
	add	esp, 16					; 00000010H

; 2093 :         return( FALSE );

	xor	eax, eax
	jmp	$LN5@ResDeleteF
$LN4@ResDeleteF:

; 2094 :     }
; 2095 : #endif
; 2096 : #if (RES_MULTITHREAD)
; 2097 : 	REQUEST_LOCK(GLOCK);

	push	-1
	mov	eax, DWORD PTR _GLOCK
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8

; 2098 : #endif
; 2099 : 
; 2100 :     IF_LOG( LOG( "delete: %s\n", name ));
; 2101 : 
; 2102 : #if( !RES_USE_FLAT_MODEL )
; 2103 :     /* find both the entry & the table it resides in */
; 2104 :     entry = hash_find_table( name, &table );

	lea	ecx, DWORD PTR _table$[ebp]
	push	ecx
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_hash_find_table
	add	esp, 8
	mov	DWORD PTR _entry$[ebp], eax

; 2105 : #else
; 2106 :     entry = hash_find( name, GLOBAL_HASH_TABLE );
; 2107 : 
; 2108 :     table = GLOBAL_HASH_TABLE;
; 2109 : #endif
; 2110 : 
; 2111 :     if( !entry ) {

	cmp	DWORD PTR _entry$[ebp], 0
	jne	SHORT $LN3@ResDeleteF

; 2112 :         SAY_ERROR( RES_ERR_FILE_NOT_FOUND, name );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	2112					; 00000840H
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	-4993					; ffffec7fH
	call	__say_error
	add	esp, 16					; 00000010H

; 2113 : #if (RES_MULTITHREAD)
; 2114 : 	RELEASE_LOCK(GLOCK);

	mov	ecx, DWORD PTR _GLOCK
	push	ecx
	call	DWORD PTR __imp__ReleaseMutex@4

; 2115 : #endif
; 2116 :         return( FALSE );

	xor	eax, eax
	jmp	SHORT $LN5@ResDeleteF
$LN3@ResDeleteF:

; 2117 :     }
; 2118 : 
; 2119 :     if( entry -> file_position == -1 ) {

	mov	edx, DWORD PTR _entry$[ebp]
	cmp	DWORD PTR [edx+20], -1
	jne	SHORT $LN2@ResDeleteF

; 2120 :         chmod( entry -> name, _S_IWRITE );

	push	128					; 00000080H
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_chmod
	add	esp, 8

; 2121 :         check = remove( entry -> name );

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_remove
	add	esp, 4
	mov	DWORD PTR _check$[ebp], eax

; 2122 : 
; 2123 :         if( check == -1 ) {

	cmp	DWORD PTR _check$[ebp], -1
	jne	SHORT $LN2@ResDeleteF

; 2124 :             SAY_ERROR( RES_ERR_CANT_DELETE_FILE, name );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	2124					; 0000084cH
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	-4976					; ffffec90H
	call	__say_error
	add	esp, 16					; 00000010H
$LN2@ResDeleteF:

; 2125 :         }
; 2126 : 
; 2127 :         /* don't return yet, remove file from hash 
; 2128 :            table even if delete at os level fails */
; 2129 :     }
; 2130 : 
; 2131 : #if (RES_MULTITHREAD)
; 2132 : 	RELEASE_LOCK(GLOCK);

	mov	edx, DWORD PTR _GLOCK
	push	edx
	call	DWORD PTR __imp__ReleaseMutex@4

; 2133 : #endif
; 2134 :     return( hash_delete( entry, table ));

	mov	eax, DWORD PTR _table$[ebp]
	push	eax
	mov	ecx, DWORD PTR _entry$[ebp]
	push	ecx
	call	_hash_delete
	add	esp, 8
$LN5@ResDeleteF:

; 2135 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ResDeleteFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_retval$ = -12						; size = 4
_check$ = -8						; size = 4
_file$ = -4						; size = 4
_handle$ = 8						; size = 4
_buffer$ = 12						; size = 4
_count$ = 16						; size = 4
_ResWriteFile PROC

; 2013 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 2014 :     FILE_ENTRY * file;
; 2015 :     int check;
; 2016 :     int retval = 1;

	mov	DWORD PTR _retval$[ebp], 1

; 2017 : 
; 2018 : #if( RES_DEBUG_PARAMS )
; 2019 :     if( handle < 0 || handle >= MAX_FILE_HANDLES || !buffer ) {

	cmp	DWORD PTR _handle$[ebp], 0
	jl	SHORT $LN6@ResWriteFi
	cmp	DWORD PTR _handle$[ebp], 256		; 00000100H
	jge	SHORT $LN6@ResWriteFi
	cmp	DWORD PTR _buffer$[ebp], 0
	jne	SHORT $LN7@ResWriteFi
$LN6@ResWriteFi:

; 2020 :         SAY_ERROR( RES_ERR_INCORRECT_PARAMETER, "ResWriteFile" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	2020					; 000007e4H
	push	OFFSET ??_C@_0N@IMJBALEI@ResWriteFile?$AA@
	push	-4998					; ffffec7aH
	call	__say_error
	add	esp, 16					; 00000010H

; 2021 :         return( 0 );

	xor	eax, eax
	jmp	$LN8@ResWriteFi
$LN7@ResWriteFi:

; 2022 :     }
; 2023 : #endif /* RES_DEBUG_PARAMS */
; 2024 : #if (RES_MULTITHREAD)
; 2025 : 	REQUEST_LOCK(GLOCK);

	push	-1
	mov	eax, DWORD PTR _GLOCK
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8

; 2026 : #endif
; 2027 : 
; 2028 :     file = &FILE_HANDLES[ handle ];

	mov	ecx, DWORD PTR _handle$[ebp]
	imul	ecx, 52					; 00000034H
	add	ecx, DWORD PTR _FILE_HANDLES
	mov	DWORD PTR _file$[ebp], ecx

; 2029 : 
; 2030 :     if( file -> os_handle == -1 ) {

	mov	edx, DWORD PTR _file$[ebp]
	cmp	DWORD PTR [edx], -1
	jne	SHORT $LN5@ResWriteFi

; 2031 :         SAY_ERROR( RES_ERR_ILLEGAL_FILE_HANDLE, "ResWriteFile" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	2031					; 000007efH
	push	OFFSET ??_C@_0N@IMJBALEI@ResWriteFile?$AA@
	push	-4977					; ffffec8fH
	call	__say_error
	add	esp, 16					; 00000010H

; 2032 : #if (RES_MULTITHREAD)
; 2033 : 	RELEASE_LOCK(GLOCK);

	mov	eax, DWORD PTR _GLOCK
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4

; 2034 : #endif
; 2035 : 
; 2036 :         return(0);

	xor	eax, eax
	jmp	$LN8@ResWriteFi
$LN5@ResWriteFi:

; 2037 :     }
; 2038 :    
; 2039 :     if( !(file -> mode & (_O_CREAT | _O_APPEND | _O_RDWR | _O_WRONLY))) {

	mov	ecx, DWORD PTR _file$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	and	edx, 267				; 0000010bH
	jne	SHORT $LN4@ResWriteFi

; 2040 :         SAY_ERROR( RES_ERR_PROBLEM_WRITING, file -> filename );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	2040					; 000007f8H
	mov	eax, DWORD PTR _file$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	push	-4982					; ffffec8aH
	call	__say_error
	add	esp, 16					; 00000010H

; 2041 : #if (RES_MULTITHREAD)
; 2042 : 	RELEASE_LOCK(GLOCK);

	mov	edx, DWORD PTR _GLOCK
	push	edx
	call	DWORD PTR __imp__ReleaseMutex@4

; 2043 : #endif
; 2044 :         return(0);

	xor	eax, eax
	jmp	$LN8@ResWriteFi
$LN4@ResWriteFi:

; 2045 :     }
; 2046 : 
; 2047 :     SHOULD_I_CALL_WITH( CALLBACK_WRITE_FILE, handle, retval );

	mov	eax, 4
	imul	eax, 7
	cmp	DWORD PTR _RES_CALLBACK[eax], 0
	je	SHORT $LN3@ResWriteFi
	mov	ecx, DWORD PTR _handle$[ebp]
	push	ecx
	mov	edx, 4
	imul	edx, 7
	mov	eax, DWORD PTR _RES_CALLBACK[edx]
	call	eax
	add	esp, 4
	mov	DWORD PTR _retval$[ebp], eax
$LN3@ResWriteFi:

; 2048 : 
; 2049 :     /* Set a bit so we know to reestablish the file size on ResCloseFile()        */
; 2050 :     /* Use the csize field since we no this is not used for files we can write to */
; 2051 : 
; 2052 :     file -> csize = (unsigned int)WRITTEN_TO_FLAG;

	mov	ecx, DWORD PTR _file$[ebp]
	mov	DWORD PTR [ecx+16], -1

; 2053 : 
; 2054 :     IF_LOG( LOG( "write (%s): (%d bytes)\n", file -> filename, count ));
; 2055 : 
; 2056 :     check = _write( file -> os_handle, buffer, count );

	mov	edx, DWORD PTR _count$[ebp]
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _file$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	__write
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _check$[ebp], eax

; 2057 : 
; 2058 :     if( check < 0 )

	cmp	DWORD PTR _check$[ebp], 0
	jge	SHORT $LN2@ResWriteFi

; 2059 :         ResCheckMedia( file -> device );

	mov	eax, DWORD PTR _file$[ebp]
	movsx	ecx, BYTE PTR [eax+32]
	push	ecx
	call	_ResCheckMedia
	add	esp, 4

; 2060 :     else

	jmp	SHORT $LN1@ResWriteFi
$LN2@ResWriteFi:

; 2061 :         file -> current_pos += count;

	mov	edx, DWORD PTR _file$[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, DWORD PTR _count$[ebp]
	mov	ecx, DWORD PTR _file$[ebp]
	mov	DWORD PTR [ecx+8], eax
$LN1@ResWriteFi:

; 2062 : #if (RES_MULTITHREAD)
; 2063 : 	RELEASE_LOCK(GLOCK);

	mov	edx, DWORD PTR _GLOCK
	push	edx
	call	DWORD PTR __imp__ReleaseMutex@4

; 2064 : #endif
; 2065 : 
; 2066 :     return( check );

	mov	eax, DWORD PTR _check$[ebp]
$LN8@ResWriteFi:

; 2067 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ResWriteFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_retval$ = -536						; size = 4
_size$ = -532						; size = 4
_entry$ = -528						; size = 4
_filename$ = -524					; size = 260
_dirpath$ = -264					; size = 260
__$ArrayPad$ = -4					; size = 4
_file$ = 8						; size = 4
_ResCloseFile PROC

; 1890 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 536				; 00000218H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1891 :     HASH_ENTRY * entry;
; 1892 :     char         filename[_MAX_PATH],
; 1893 :                  dirpath[_MAX_PATH];
; 1894 :     long         size;
; 1895 :     int          retval = 1;

	mov	DWORD PTR _retval$[ebp], 1

; 1896 : 
; 1897 : 
; 1898 : #if( RES_DEBUG_PARAMS )
; 1899 :     if( file < 0 || file >= MAX_FILE_HANDLES ) {

	cmp	DWORD PTR _file$[ebp], 0
	jl	SHORT $LN11@ResCloseFi
	cmp	DWORD PTR _file$[ebp], 256		; 00000100H
	jl	SHORT $LN12@ResCloseFi
$LN11@ResCloseFi:

; 1900 :         SAY_ERROR( RES_ERR_INCORRECT_PARAMETER, "ResCloseFile" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	1900					; 0000076cH
	push	OFFSET ??_C@_0N@MFBOIEDA@ResCloseFile?$AA@
	push	-4998					; ffffec7aH
	call	__say_error
	add	esp, 16					; 00000010H

; 1901 :         return( FALSE );

	xor	eax, eax
	jmp	$LN13@ResCloseFi
$LN12@ResCloseFi:

; 1902 :     }
; 1903 : 
; 1904 :     if( FILE_HANDLES[ file ].os_handle == -1 ) {

	mov	eax, DWORD PTR _file$[ebp]
	imul	eax, 52					; 00000034H
	mov	ecx, DWORD PTR _FILE_HANDLES
	cmp	DWORD PTR [ecx+eax], -1
	jne	SHORT $LN10@ResCloseFi

; 1905 :         SAY_ERROR( RES_ERR_ILLEGAL_FILE_HANDLE, "ResCloseFile" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	1905					; 00000771H
	push	OFFSET ??_C@_0N@MFBOIEDA@ResCloseFile?$AA@
	push	-4977					; ffffec8fH
	call	__say_error
	add	esp, 16					; 00000010H

; 1906 :         return( FALSE );

	xor	eax, eax
	jmp	$LN13@ResCloseFi
$LN10@ResCloseFi:

; 1907 :     }
; 1908 : #endif /* RES_DEBUG_PARAMS */
; 1909 : 
; 1910 : #if (RES_MULTITHREAD)
; 1911 : 	REQUEST_LOCK(GLOCK);

	push	-1
	mov	edx, DWORD PTR _GLOCK
	push	edx
	call	DWORD PTR __imp__WaitForSingleObject@8

; 1912 : #endif
; 1913 : 
; 1914 :     IF_LOG( LOG( "close (%s):\n", FILE_HANDLES[ file ].filename ));
; 1915 : 
; 1916 :     SHOULD_I_CALL_WITH( CALLBACK_CLOSE_FILE, file, retval );

	mov	eax, 4
	imul	eax, 5
	cmp	DWORD PTR _RES_CALLBACK[eax], 0
	je	SHORT $LN9@ResCloseFi
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	mov	edx, 4
	imul	edx, 5
	mov	eax, DWORD PTR _RES_CALLBACK[edx]
	call	eax
	add	esp, 4
	mov	DWORD PTR _retval$[ebp], eax
$LN9@ResCloseFi:

; 1917 : 
; 1918 :     if( !FILE_HANDLES[file].zip ) {

	mov	ecx, DWORD PTR _file$[ebp]
	imul	ecx, 52					; 00000034H
	mov	edx, DWORD PTR _FILE_HANDLES
	cmp	DWORD PTR [edx+ecx+48], 0
	jne	$LN8@ResCloseFi

; 1919 :         /* if the file has been written to, recheck the size */
; 1920 : 
; 1921 :         if( FILE_HANDLES[file].csize == (unsigned int)WRITTEN_TO_FLAG ) {

	mov	eax, DWORD PTR _file$[ebp]
	imul	eax, 52					; 00000034H
	mov	ecx, DWORD PTR _FILE_HANDLES
	cmp	DWORD PTR [ecx+eax+16], -1
	jne	$LN7@ResCloseFi

; 1922 :             /* flush to disk */
; 1923 :             _commit( FILE_HANDLES[file].os_handle );

	mov	edx, DWORD PTR _file$[ebp]
	imul	edx, 52					; 00000034H
	mov	eax, DWORD PTR _FILE_HANDLES
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	call	__commit
	add	esp, 4

; 1924 : 
; 1925 :             /* go to the end of the file */
; 1926 :             size = lseek( FILE_HANDLES[file].os_handle, 0, SEEK_END );

	push	2
	push	0
	mov	edx, DWORD PTR _file$[ebp]
	imul	edx, 52					; 00000034H
	mov	eax, DWORD PTR _FILE_HANDLES
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	call	_lseek
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _size$[ebp], eax

; 1927 : 
; 1928 :             split_path( FILE_HANDLES[file].filename, filename, dirpath );

	lea	edx, DWORD PTR _dirpath$[ebp]
	push	edx
	lea	eax, DWORD PTR _filename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _file$[ebp]
	imul	ecx, 52					; 00000034H
	mov	edx, DWORD PTR _FILE_HANDLES
	mov	eax, DWORD PTR [edx+ecx+40]
	push	eax
	call	_split_path
	add	esp, 12					; 0000000cH

; 1929 : 
; 1930 : #if( !RES_USE_FLAT_MODEL )
; 1931 :             entry = hash_find( dirpath, GLOBAL_HASH_TABLE );

	mov	ecx, DWORD PTR _GLOBAL_HASH_TABLE
	push	ecx
	lea	edx, DWORD PTR _dirpath$[ebp]
	push	edx
	call	_hash_find
	add	esp, 8
	mov	DWORD PTR _entry$[ebp], eax

; 1932 :             
; 1933 :             if( entry ) {

	cmp	DWORD PTR _entry$[ebp], 0
	je	SHORT $LN6@ResCloseFi

; 1934 :                 entry = hash_find( filename, (HASH_TABLE *)entry -> dir );

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	lea	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	_hash_find
	add	esp, 8
	mov	DWORD PTR _entry$[ebp], eax

; 1935 :                 if( entry )

	cmp	DWORD PTR _entry$[ebp], 0
	je	SHORT $LN5@ResCloseFi

; 1936 :                     entry -> size = size;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR _size$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 1937 :                 else {

	jmp	SHORT $LN4@ResCloseFi
$LN5@ResCloseFi:

; 1938 :                     SAY_ERROR( RES_ERR_UNKNOWN, "set size" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	1938					; 00000792H
	push	OFFSET ??_C@_08OOOIBLGC@set?5size?$AA@
	push	-4973					; ffffec93H
	call	__say_error
	add	esp, 16					; 00000010H
$LN4@ResCloseFi:

; 1939 :                 }
; 1940 :             }
; 1941 :             else {

	jmp	SHORT $LN7@ResCloseFi
$LN6@ResCloseFi:

; 1942 :                 SAY_ERROR( RES_ERR_UNKNOWN, "set size" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	1942					; 00000796H
	push	OFFSET ??_C@_08OOOIBLGC@set?5size?$AA@
	push	-4973					; ffffec93H
	call	__say_error
	add	esp, 16					; 00000010H
$LN7@ResCloseFi:

; 1943 :             }
; 1944 : #else /* flat model */
; 1945 : 
; 1946 :             entry = hash_find( filename, GLOBAL_HASH_TABLE );
; 1947 : 
; 1948 :             if( entry )
; 1949 :                 entry -> size = size;
; 1950 :             else {
; 1951 :                 SAY_ERROR( RES_ERR_UNKNOWN, "set size" );
; 1952 :             }
; 1953 : #endif /* !RES_USE_FLAT_MODEL */
; 1954 :         }
; 1955 : 
; 1956 :         if( !FILE_HANDLES[ file ].seek_start )  /* don't close an archive */

	mov	edx, DWORD PTR _file$[ebp]
	imul	edx, 52					; 00000034H
	mov	eax, DWORD PTR _FILE_HANDLES
	cmp	DWORD PTR [eax+edx+4], 0
	jne	SHORT $LN2@ResCloseFi

; 1957 :             _close( FILE_HANDLES[ file ].os_handle );

	mov	ecx, DWORD PTR _file$[ebp]
	imul	ecx, 52					; 00000034H
	mov	edx, DWORD PTR _FILE_HANDLES
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	call	__close
	add	esp, 4
$LN2@ResCloseFi:

; 1958 : 
; 1959 : 		#ifdef USE_SH_POOLS
; 1960 :         MemFreePtr( FILE_HANDLES[ file ].filename );
; 1961 : 		#else
; 1962 :         MemFree( FILE_HANDLES[ file ].filename );

	mov	ecx, DWORD PTR _file$[ebp]
	imul	ecx, 52					; 00000034H
	mov	edx, DWORD PTR _FILE_HANDLES
	mov	eax, DWORD PTR [edx+ecx+40]
	push	eax
	call	_free
	add	esp, 4

; 1963 : 		#endif
; 1964 :         FILE_HANDLES[ file ].filename = NULL;

	mov	ecx, DWORD PTR _file$[ebp]
	imul	ecx, 52					; 00000034H
	mov	edx, DWORD PTR _FILE_HANDLES
	mov	DWORD PTR [edx+ecx+40], 0

; 1965 :         FILE_HANDLES[ file ].os_handle = -1;

	mov	eax, DWORD PTR _file$[ebp]
	imul	eax, 52					; 00000034H
	mov	ecx, DWORD PTR _FILE_HANDLES
	mov	DWORD PTR [ecx+eax], -1

; 1966 : #if (RES_MULTITHREAD)
; 1967 : 	RELEASE_LOCK(GLOCK);

	mov	edx, DWORD PTR _GLOCK
	push	edx
	call	DWORD PTR __imp__ReleaseMutex@4

; 1968 : #endif
; 1969 : 
; 1970 :         return( TRUE );

	mov	eax, 1
	jmp	$LN13@ResCloseFi

; 1971 :     }
; 1972 :     else

	jmp	SHORT $LN1@ResCloseFi
$LN8@ResCloseFi:

; 1973 :     {
; 1974 : 		#ifdef USE_SH_POOLS
; 1975 :         MemFreePtr( FILE_HANDLES[file].zip );
; 1976 :         MemFreePtr( FILE_HANDLES[file].filename );
; 1977 : 		#else
; 1978 :         MemFree( FILE_HANDLES[file].zip );

	mov	eax, DWORD PTR _file$[ebp]
	imul	eax, 52					; 00000034H
	mov	ecx, DWORD PTR _FILE_HANDLES
	mov	edx, DWORD PTR [ecx+eax+48]
	push	edx
	call	_free
	add	esp, 4

; 1979 :         MemFree( FILE_HANDLES[file].filename );

	mov	eax, DWORD PTR _file$[ebp]
	imul	eax, 52					; 00000034H
	mov	ecx, DWORD PTR _FILE_HANDLES
	mov	edx, DWORD PTR [ecx+eax+40]
	push	edx
	call	_free
	add	esp, 4

; 1980 : 		#endif
; 1981 :         FILE_HANDLES[ file ].zip = NULL;

	mov	eax, DWORD PTR _file$[ebp]
	imul	eax, 52					; 00000034H
	mov	ecx, DWORD PTR _FILE_HANDLES
	mov	DWORD PTR [ecx+eax+48], 0

; 1982 :         FILE_HANDLES[ file ].filename = NULL;

	mov	edx, DWORD PTR _file$[ebp]
	imul	edx, 52					; 00000034H
	mov	eax, DWORD PTR _FILE_HANDLES
	mov	DWORD PTR [eax+edx+40], 0

; 1983 :         FILE_HANDLES[ file ].os_handle = -1;

	mov	ecx, DWORD PTR _file$[ebp]
	imul	ecx, 52					; 00000034H
	mov	edx, DWORD PTR _FILE_HANDLES
	mov	DWORD PTR [edx+ecx], -1

; 1984 : #if (RES_MULTITHREAD)
; 1985 : 	RELEASE_LOCK(GLOCK);

	mov	eax, DWORD PTR _GLOCK
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4

; 1986 : #endif
; 1987 : 
; 1988 :         return( TRUE );

	mov	eax, 1
	jmp	SHORT $LN13@ResCloseFi
$LN1@ResCloseFi:

; 1989 :     }
; 1990 : #if (RES_MULTITHREAD)
; 1991 : 	RELEASE_LOCK(GLOCK);

	mov	ecx, DWORD PTR _GLOCK
	push	ecx
	call	DWORD PTR __imp__ReleaseMutex@4

; 1992 : #endif
; 1993 : 
; 1994 :     return( FALSE );

	xor	eax, eax
$LN13@ResCloseFi:

; 1995 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_ResCloseFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_buffer$ = 8						; size = 4
_ResUnloadFile PROC

; 1859 : {

	push	ebp
	mov	ebp, esp

; 1860 : 
; 1861 : #if( RES_DEBUG_PARAMS )
; 1862 :    if( !buffer ) {

	cmp	DWORD PTR _buffer$[ebp], 0
	jne	SHORT $LN1@ResUnloadF

; 1863 :       SAY_ERROR( RES_ERR_INCORRECT_PARAMETER, "ResUnloadFile" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	1863					; 00000747H
	push	OFFSET ??_C@_0O@KLAMIEJI@ResUnloadFile?$AA@
	push	-4998					; ffffec7aH
	call	__say_error
	add	esp, 16					; 00000010H

; 1864 :       return;

	jmp	SHORT $LN2@ResUnloadF
$LN1@ResUnloadF:

; 1865 :    }
; 1866 : #endif /* RES_DEBUG_PARAMS */
; 1867 : 
; 1868 : 	#ifdef USE_SH_POOLS
; 1869 :     MemFreePtr( buffer );
; 1870 : 	#else
; 1871 :     MemFree( buffer );

	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_free
	add	esp, 4
$LN2@ResUnloadF:

; 1872 : 	#endif
; 1873 : }

	pop	ebp
	ret	0
_ResUnloadFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_check$ = -16						; size = 4
_s$ = -12						; size = 4
_file$ = -8						; size = 4
_alloc_buffer$ = -4					; size = 4
_filename$ = 8						; size = 4
_buffer$ = 12						; size = 4
_size$ = 16						; size = 4
_ResLoadFile PROC

; 1778 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 1779 :     int file;
; 1780 :     int check;
; 1781 :     int s;
; 1782 :     char * alloc_buffer;
; 1783 : 
; 1784 :     IF_LOG( LOG( "load (%s):\n", filename ));
; 1785 : 
; 1786 : #if( RES_DEBUG_PARAMS )
; 1787 :     if( !filename ) {

	cmp	DWORD PTR _filename$[ebp], 0
	jne	SHORT $LN8@ResLoadFil

; 1788 :         SAY_ERROR( RES_ERR_INCORRECT_PARAMETER, "ResLoadFile" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	1788					; 000006fcH
	push	OFFSET ??_C@_0M@CPIEAJDN@ResLoadFile?$AA@
	push	-4998					; ffffec7aH
	call	__say_error
	add	esp, 16					; 00000010H

; 1789 :         return( NULL );

	xor	eax, eax
	jmp	$LN9@ResLoadFil
$LN8@ResLoadFil:

; 1790 :     }
; 1791 : #endif /* RES_DEBUG_PARAMS */
; 1792 : 
; 1793 :     file = ResOpenFile( filename, _O_RDONLY | _O_BINARY );

	push	32768					; 00008000H
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_ResOpenFile
	add	esp, 8
	mov	DWORD PTR _file$[ebp], eax

; 1794 : 
; 1795 :     if( EMPTY(file))

	cmp	DWORD PTR _file$[ebp], -1
	jne	SHORT $LN7@ResLoadFil

; 1796 :         return( NULL ); /* message will already have been printed if using the debug version */

	xor	eax, eax
	jmp	$LN9@ResLoadFil
$LN7@ResLoadFil:

; 1797 : 
; 1798 :     s = ResSizeFile( file );

	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	_ResSizeFile
	add	esp, 4
	mov	DWORD PTR _s$[ebp], eax

; 1799 : 
; 1800 :     if( !buffer ) {

	cmp	DWORD PTR _buffer$[ebp], 0
	jne	SHORT $LN6@ResLoadFil

; 1801 : 		#ifdef USE_SH_POOLS
; 1802 :         alloc_buffer = (char *)MemAllocPtr( gResmgrMemPool, s, 0 );
; 1803 : 		#else
; 1804 :         alloc_buffer = (char *)MemMalloc( s, filename );

	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _alloc_buffer$[ebp], eax

; 1805 : 		#endif
; 1806 : 
; 1807 :         if( !alloc_buffer ) {

	cmp	DWORD PTR _alloc_buffer$[ebp], 0
	jne	SHORT $LN5@ResLoadFil

; 1808 :             SAY_ERROR( RES_ERR_NO_MEMORY, filename );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	1808					; 00000710H
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	push	-4999					; ffffec79H
	call	__say_error
	add	esp, 16					; 00000010H

; 1809 :             ResCloseFile( file );

	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	_ResCloseFile
	add	esp, 4

; 1810 :             if( size )

	cmp	DWORD PTR _size$[ebp], 0
	je	SHORT $LN4@ResLoadFil

; 1811 :                 *size = 0;

	mov	edx, DWORD PTR _size$[ebp]
	mov	DWORD PTR [edx], 0
$LN4@ResLoadFil:

; 1812 :             return( NULL );

	xor	eax, eax
	jmp	SHORT $LN9@ResLoadFil
$LN5@ResLoadFil:

; 1813 :         }
; 1814 :     }
; 1815 :     else

	jmp	SHORT $LN3@ResLoadFil
$LN6@ResLoadFil:

; 1816 :         alloc_buffer = buffer;

	mov	eax, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _alloc_buffer$[ebp], eax
$LN3@ResLoadFil:

; 1817 : 
; 1818 :     check = ResReadFile( file, alloc_buffer, s );

	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	mov	edx, DWORD PTR _alloc_buffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_ResReadFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _check$[ebp], eax

; 1819 : 
; 1820 :     ResCloseFile( file );

	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	_ResCloseFile
	add	esp, 4

; 1821 :    
; 1822 :     if( check < 0 ) /* error reading file */

	cmp	DWORD PTR _check$[ebp], 0
	jge	SHORT $LN2@ResLoadFil

; 1823 :     {
; 1824 : 		#ifdef USE_SH_POOLS
; 1825 :         MemFreePtr( alloc_buffer );
; 1826 : 		#else
; 1827 :         MemFree( alloc_buffer );

	mov	edx, DWORD PTR _alloc_buffer$[ebp]
	push	edx
	call	_free
	add	esp, 4

; 1828 : 		#endif
; 1829 :         alloc_buffer = NULL;

	mov	DWORD PTR _alloc_buffer$[ebp], 0
$LN2@ResLoadFil:

; 1830 :     }
; 1831 : 
; 1832 :     if( size )

	cmp	DWORD PTR _size$[ebp], 0
	je	SHORT $LN1@ResLoadFil

; 1833 :         *size = check;

	mov	eax, DWORD PTR _size$[ebp]
	mov	ecx, DWORD PTR _check$[ebp]
	mov	DWORD PTR [eax], ecx
$LN1@ResLoadFil:

; 1834 : 
; 1835 :     return( alloc_buffer );

	mov	eax, DWORD PTR _alloc_buffer$[ebp]
$LN9@ResLoadFil:

; 1836 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ResLoadFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_retval$ = -12						; size = 4
_len$ = -8						; size = 4
_file$ = -4						; size = 4
_handle$ = 8						; size = 4
_buffer$ = 12						; size = 4
_count$ = 16						; size = 4
_ResReadFile PROC

; 1680 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1681 :     FILE_ENTRY * file;
; 1682 :     int len;
; 1683 :     int retval = 1;

	mov	DWORD PTR _retval$[ebp], 1

; 1684 : 
; 1685 : #if( RES_DEBUG_PARAMS )
; 1686 :     if( !buffer || handle < 0 || handle > MAX_FILE_HANDLES ) {

	cmp	DWORD PTR _buffer$[ebp], 0
	je	SHORT $LN9@ResReadFil
	cmp	DWORD PTR _handle$[ebp], 0
	jl	SHORT $LN9@ResReadFil
	cmp	DWORD PTR _handle$[ebp], 256		; 00000100H
	jle	SHORT $LN10@ResReadFil
$LN9@ResReadFil:

; 1687 :         SAY_ERROR( RES_ERR_INCORRECT_PARAMETER, "ResReadFile" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	1687					; 00000697H
	push	OFFSET ??_C@_0M@NKEGIMBG@ResReadFile?$AA@
	push	-4998					; ffffec7aH
	call	__say_error
	add	esp, 16					; 00000010H

; 1688 :         return( -1 );

	or	eax, -1
	jmp	$LN11@ResReadFil
$LN10@ResReadFil:

; 1689 :     }
; 1690 : #endif /* RES_DEBUG_PARAMS */
; 1691 : #if (RES_MULTITHREAD)
; 1692 : 	REQUEST_LOCK(GLOCK); /* GFG */

	push	-1
	mov	eax, DWORD PTR _GLOCK
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8

; 1693 : #endif
; 1694 :     file = &FILE_HANDLES[ handle ];

	mov	ecx, DWORD PTR _handle$[ebp]
	imul	ecx, 52					; 00000034H
	add	ecx, DWORD PTR _FILE_HANDLES
	mov	DWORD PTR _file$[ebp], ecx

; 1695 :     
; 1696 :     if( file -> os_handle == -1 ) {

	mov	edx, DWORD PTR _file$[ebp]
	cmp	DWORD PTR [edx], -1
	jne	SHORT $LN8@ResReadFil

; 1697 :         SAY_ERROR( RES_ERR_ILLEGAL_FILE_HANDLE, "ResReadFile" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	1697					; 000006a1H
	push	OFFSET ??_C@_0M@NKEGIMBG@ResReadFile?$AA@
	push	-4977					; ffffec8fH
	call	__say_error
	add	esp, 16					; 00000010H

; 1698 :         return( -1 );  

	or	eax, -1
	jmp	$LN11@ResReadFil
$LN8@ResReadFil:

; 1699 :     }
; 1700 : 
; 1701 :     IF_LOG( LOG( "read (%s): (%d bytes)\n", file -> filename, count ));
; 1702 : 
; 1703 :     SHOULD_I_CALL_WITH( CALLBACK_READ_FILE, handle, retval );

	mov	eax, 4
	imul	eax, 6
	cmp	DWORD PTR _RES_CALLBACK[eax], 0
	je	SHORT $LN7@ResReadFil
	mov	ecx, DWORD PTR _handle$[ebp]
	push	ecx
	mov	edx, 4
	imul	edx, 6
	mov	eax, DWORD PTR _RES_CALLBACK[edx]
	call	eax
	add	esp, 4
	mov	DWORD PTR _retval$[ebp], eax
$LN7@ResReadFil:

; 1704 : 
; 1705 :     if( file -> current_pos >= file -> size )

	mov	ecx, DWORD PTR _file$[ebp]
	mov	edx, DWORD PTR _file$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	cmp	eax, DWORD PTR [edx+12]
	jb	SHORT $LN6@ResReadFil

; 1706 : 	{
; 1707 : #if (RES_MULTITHREAD)
; 1708 : 		RELEASE_LOCK(GLOCK); /* GFG */

	mov	ecx, DWORD PTR _GLOCK
	push	ecx
	call	DWORD PTR __imp__ReleaseMutex@4

; 1709 : #endif
; 1710 :         return( 0 );  /* GFG NOV 18   was return (-1) */

	xor	eax, eax
	jmp	$LN11@ResReadFil
$LN6@ResReadFil:

; 1711 : 	
; 1712 : 
; 1713 : 	}
; 1714 :     if( !file -> zip ) {

	mov	edx, DWORD PTR _file$[ebp]
	cmp	DWORD PTR [edx+48], 0
	jne	SHORT $LN5@ResReadFil

; 1715 : 
; 1716 :         /* The only way to insure that the heads will be in the right place is
; 1717 :            to reseek on every read (since multiple threads may be reading this
; 1718 :            file).  This is actually not as expensive as it seems.  First of all, 
; 1719 :            if the heads are in the same position, or the cache contains the byte
; 1720 :            stream from that offset, no seek will be done.  If that isn't so, a 
; 1721 :            seek was going to happen anyway when the OS tries to do the read. */
; 1722 : 
; 1723 :         lseek( file -> os_handle, (file -> seek_start + file -> current_pos), SEEK_SET );

	push	0
	mov	eax, DWORD PTR _file$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _file$[ebp]
	add	ecx, DWORD PTR [edx+8]
	push	ecx
	mov	eax, DWORD PTR _file$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_lseek
	add	esp, 12					; 0000000cH

; 1724 : 
; 1725 :         len = _read( file -> os_handle, buffer, count );

	mov	edx, DWORD PTR _count$[ebp]
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _file$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	__read
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _len$[ebp], eax

; 1726 : 
; 1727 :         if( len < 0 ) /* error, see if media has changed */

	cmp	DWORD PTR _len$[ebp], 0
	jge	SHORT $LN4@ResReadFil

; 1728 :             ResCheckMedia( file -> device );

	mov	eax, DWORD PTR _file$[ebp]
	movsx	ecx, BYTE PTR [eax+32]
	push	ecx
	call	_ResCheckMedia
	add	esp, 4

; 1729 :         else

	jmp	SHORT $LN3@ResReadFil
$LN4@ResReadFil:

; 1730 :             file -> current_pos += len;

	mov	edx, DWORD PTR _file$[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, DWORD PTR _len$[ebp]
	mov	ecx, DWORD PTR _file$[ebp]
	mov	DWORD PTR [ecx+8], eax
$LN3@ResReadFil:

; 1731 : 
; 1732 :         IF_LOG( LOG( "read (%s): %d\n", file -> filename, len ));
; 1733 : #if (RES_MULTITHREAD)
; 1734 : 		RELEASE_LOCK(GLOCK); /* GFG */

	mov	edx, DWORD PTR _GLOCK
	push	edx
	call	DWORD PTR __imp__ReleaseMutex@4

; 1735 : #endif
; 1736 :         return( len );

	mov	eax, DWORD PTR _len$[ebp]
	jmp	SHORT $LN11@ResReadFil

; 1737 :     }
; 1738 :     else {

	jmp	SHORT $LN2@ResReadFil
$LN5@ResReadFil:

; 1739 : 
; 1740 :         if( count > (file -> size - file -> current_pos))

	mov	eax, DWORD PTR _file$[ebp]
	mov	ecx, DWORD PTR _file$[ebp]
	mov	edx, DWORD PTR [eax+12]
	sub	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR _count$[ebp], edx
	jbe	SHORT $LN1@ResReadFil

; 1741 :             count = file -> size - file -> current_pos;

	mov	eax, DWORD PTR _file$[ebp]
	mov	ecx, DWORD PTR _file$[ebp]
	mov	edx, DWORD PTR [eax+12]
	sub	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _count$[ebp], edx
$LN1@ResReadFil:

; 1742 : 
; 1743 :         memcpy( buffer, file -> zip -> out_buffer + file -> current_pos, count );

	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _file$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _file$[ebp]
	add	eax, DWORD PTR [ecx+8]
	push	eax
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1744 :         file -> current_pos += count;

	mov	eax, DWORD PTR _file$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, DWORD PTR _count$[ebp]
	mov	edx, DWORD PTR _file$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1745 : #if (RES_MULTITHREAD)
; 1746 : 		RELEASE_LOCK(GLOCK); /* GFG */

	mov	eax, DWORD PTR _GLOCK
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4

; 1747 : #endif
; 1748 :         return(count);

	mov	eax, DWORD PTR _count$[ebp]
	jmp	SHORT $LN11@ResReadFil
$LN2@ResReadFil:

; 1749 :     }
; 1750 :     
; 1751 :     return( 0 );

	xor	eax, eax
$LN11@ResReadFil:

; 1752 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ResReadFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_file$ = 8						; size = 4
_ResSizeFile PROC

; 1648 : {

	push	ebp
	mov	ebp, esp

; 1649 : #if( RES_DEBUG_PARAMS )
; 1650 :     if( file < 0 || file >= MAX_FILE_HANDLES ) {

	cmp	DWORD PTR _file$[ebp], 0
	jl	SHORT $LN2@ResSizeFil
	cmp	DWORD PTR _file$[ebp], 256		; 00000100H
	jl	SHORT $LN3@ResSizeFil
$LN2@ResSizeFil:

; 1651 :         SAY_ERROR( RES_ERR_INCORRECT_PARAMETER, "ResSizeFile" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	1651					; 00000673H
	push	OFFSET ??_C@_0M@DEBHJGIL@ResSizeFile?$AA@
	push	-4998					; ffffec7aH
	call	__say_error
	add	esp, 16					; 00000010H

; 1652 :         return( -1 );

	or	eax, -1
	jmp	SHORT $LN4@ResSizeFil
$LN3@ResSizeFil:

; 1653 :     }
; 1654 : 
; 1655 :     if( FILE_HANDLES[ file ].os_handle == -1 ) {

	mov	eax, DWORD PTR _file$[ebp]
	imul	eax, 52					; 00000034H
	mov	ecx, DWORD PTR _FILE_HANDLES
	cmp	DWORD PTR [ecx+eax], -1
	jne	SHORT $LN1@ResSizeFil

; 1656 :         SAY_ERROR( RES_ERR_ILLEGAL_FILE_HANDLE, "ResSizeFile" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	1656					; 00000678H
	push	OFFSET ??_C@_0M@DEBHJGIL@ResSizeFile?$AA@
	push	-4977					; ffffec8fH
	call	__say_error
	add	esp, 16					; 00000010H

; 1657 :         return( -1 );

	or	eax, -1
	jmp	SHORT $LN4@ResSizeFil
$LN1@ResSizeFil:

; 1658 :     }
; 1659 : #endif /* RES_DEBUG_PARAMS */
; 1660 : 
; 1661 :     return( FILE_HANDLES[ file ].size );

	mov	edx, DWORD PTR _file$[ebp]
	imul	edx, 52					; 00000034H
	mov	eax, DWORD PTR _FILE_HANDLES
	mov	eax, DWORD PTR [eax+edx+12]
$LN4@ResSizeFil:

; 1662 : }

	pop	ebp
	ret	0
_ResSizeFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
tv348 = -924						; size = 4
tv292 = -920						; size = 4
_retval$ = -916						; size = 4
_table$ = -912						; size = 4
_check$1 = -908						; size = 4
_list$ = -904						; size = 4
_dir_index$ = -900					; size = 4
_archive$ = -896					; size = 4
_handle$ = -892						; size = 4
_zip$2 = -888						; size = 4
_entry$ = -884						; size = 4
_file$ = -880						; size = 4
_data$ = -876						; size = 296
_lrec$ = -580						; size = 28
_dirpath$ = -552					; size = 260
_filename$ = -292					; size = 260
_tmp$ = -32						; size = 26
__$ArrayPad$ = -4					; size = 4
_name$ = 8						; size = 4
_mode$ = 12						; size = 4
_ResOpenFile PROC

; 1278 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 924				; 0000039cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1279 :     HASH_TABLE * table=NULL;

	mov	DWORD PTR _table$[ebp], 0

; 1280 :     HASH_ENTRY * entry=NULL;

	mov	DWORD PTR _entry$[ebp], 0

; 1281 :     FILE_ENTRY * file=NULL;

	mov	DWORD PTR _file$[ebp], 0

; 1282 : 
; 1283 :     LIST * list=NULL;

	mov	DWORD PTR _list$[ebp], 0

; 1284 : 
; 1285 :     ARCHIVE * archive=NULL;

	mov	DWORD PTR _archive$[ebp], 0

; 1286 : 
; 1287 :     char dirpath[_MAX_PATH];
; 1288 :     char filename[_MAX_PATH];
; 1289 : 
; 1290 :     int   retval = 1;

	mov	DWORD PTR _retval$[ebp], 1

; 1291 :     int   handle;
; 1292 :     int   dir_index;
; 1293 : 
; 1294 :     struct _finddata_t data; /* used to dummy-up a hash entry */
; 1295 : 
; 1296 :     char tmp[LREC_SIZE];
; 1297 :     local_file_hdr lrec;
; 1298 :         
; 1299 :     IF_LOG( LOG( "open (%s):\n", name ));
; 1300 : 
; 1301 : 
; 1302 : #if( RES_DEBUG_PARAMS )
; 1303 :     if( !name ) {

	cmp	DWORD PTR _name$[ebp], 0
	jne	SHORT $LN39@ResOpenFil

; 1304 :         SAY_ERROR( RES_ERR_INCORRECT_PARAMETER, "ResOpenFile" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	1304					; 00000518H
	push	OFFSET ??_C@_0M@OGEGBBAK@ResOpenFile?$AA@
	push	-4998					; ffffec7aH
	call	__say_error
	add	esp, 16					; 00000010H

; 1305 :         return( -1 );

	or	eax, -1
	jmp	$LN40@ResOpenFil
$LN39@ResOpenFil:

; 1306 :     }
; 1307 : #endif
; 1308 : 
; 1309 : #if (RES_MULTITHREAD)
; 1310 : 	REQUEST_LOCK(GLOCK);

	push	-1
	mov	eax, DWORD PTR _GLOCK
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8

; 1311 : #endif
; 1312 : 
; 1313 : 
; 1314 :     /* get the next available file handle */
; 1315 :     handle = get_handle();

	call	_get_handle
	mov	DWORD PTR _handle$[ebp], eax

; 1316 : 
; 1317 :     if( handle == -1 ) { /* none left */

	cmp	DWORD PTR _handle$[ebp], -1
	jne	SHORT $LN38@ResOpenFil

; 1318 :         SAY_ERROR( RES_ERR_TOO_MANY_FILES, "ResOpenFile" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	1318					; 00000526H
	push	OFFSET ??_C@_0M@OGEGBBAK@ResOpenFile?$AA@
	push	-4978					; ffffec8eH
	call	__say_error
	add	esp, 16					; 00000010H

; 1319 : #if (RES_MULTITHREAD)
; 1320 : 		RELEASE_LOCK(GLOCK); /* GFG */ 

	mov	ecx, DWORD PTR _GLOCK
	push	ecx
	call	DWORD PTR __imp__ReleaseMutex@4

; 1321 : #endif
; 1322 : 
; 1323 :         return( -1 );

	or	eax, -1
	jmp	$LN40@ResOpenFil
$LN38@ResOpenFil:

; 1324 :     }
; 1325 : 
; 1326 :     file = &FILE_HANDLES[ handle ];

	mov	edx, DWORD PTR _handle$[ebp]
	imul	edx, 52					; 00000034H
	add	edx, DWORD PTR _FILE_HANDLES
	mov	DWORD PTR _file$[ebp], edx

; 1327 :    
; 1328 : 
; 1329 :     /* ----------------------------------------------------
; 1330 :        Find the hash entry for the given filename.  If we
; 1331 :        are building a hierarchical model, we need to search
; 1332 :        all of the tables in the order of our search path
; 1333 :        (hash_find_table), otherwise, we just need to search
; 1334 :        our main hash table (hash_find).
; 1335 : 
; 1336 :        If filename coercion is being used, the filename
; 1337 :        string is scanned for the occurence of a backslash.
; 1338 :        If there is one, the code forces a fullpath name
; 1339 :        conversion on this string in-case it is a relative
; 1340 :        pathname (eg; ..\windows\foo.c).
; 1341 :        ----------------------------------------------------  */
; 1342 : 
; 1343 : #if( !RES_USE_FLAT_MODEL )
; 1344 :     entry = hash_find_table( name, &table );

	lea	eax, DWORD PTR _table$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_hash_find_table
	add	esp, 8
	mov	DWORD PTR _entry$[ebp], eax

; 1345 : #else /* flat model */
; 1346 :     entry = hash_find( name, GLOBAL_HASH_TABLE );
; 1347 : #endif
; 1348 : 
; 1349 :     if( !entry ) {   /* NOT FOUND */

	cmp	DWORD PTR _entry$[ebp], 0
	jne	$LN37@ResOpenFil

; 1350 :         /* if the user is trying to create a file on the harddrive,
; 1351 :            this is ok. */
; 1352 : 
; 1353 :         if( !(mode & _O_CREAT)) {

	mov	edx, DWORD PTR _mode$[ebp]
	and	edx, 256				; 00000100H
	jne	SHORT $LN36@ResOpenFil

; 1354 :             SAY_ERROR( RES_ERR_FILE_NOT_FOUND, name );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	1354					; 0000054aH
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	-4993					; ffffec7fH
	call	__say_error
	add	esp, 16					; 00000010H

; 1355 : #if (RES_MULTITHREAD)
; 1356 : 		RELEASE_LOCK(GLOCK); /* GFG */

	mov	ecx, DWORD PTR _GLOCK
	push	ecx
	call	DWORD PTR __imp__ReleaseMutex@4

; 1357 : #endif
; 1358 : 
; 1359 :             return( -1 );

	or	eax, -1
	jmp	$LN40@ResOpenFil

; 1360 :         }
; 1361 :         else {

	jmp	$LN37@ResOpenFil
$LN36@ResOpenFil:

; 1362 :             /* CREATING A FILE */
; 1363 : 
; 1364 :             /* In this case, we need to make sure that the directory is already 'added'
; 1365 :                to the resource manager if we are using hierarchical model.  If we are
; 1366 :                using the flat model, we just need to create a dummy hash_entry for the
; 1367 :                file.  The file size member of the hash entry structure will be set 
; 1368 :                in ResFileClose. */
; 1369 : 
; 1370 :             IF_LOG( LOG( "creating file: %s\n", name ));
; 1371 : 
; 1372 : #if( !RES_USE_FLAT_MODEL )
; 1373 :             if( strchr( name, ASCII_BACKSLASH )) {

	push	92					; 0000005cH
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_strchr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN34@ResOpenFil

; 1374 :                 split_path( name, filename, dirpath );

	lea	eax, DWORD PTR _dirpath$[ebp]
	push	eax
	lea	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_split_path
	add	esp, 12					; 0000000cH

; 1375 :                 entry = hash_find( dirpath, GLOBAL_HASH_TABLE );

	mov	eax, DWORD PTR _GLOBAL_HASH_TABLE
	push	eax
	lea	ecx, DWORD PTR _dirpath$[ebp]
	push	ecx
	call	_hash_find
	add	esp, 8
	mov	DWORD PTR _entry$[ebp], eax

; 1376 :             }
; 1377 :             else {/* current directory */

	jmp	SHORT $LN33@ResOpenFil
$LN34@ResOpenFil:

; 1378 :                 strcpy( filename, name );

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	lea	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 1379 :                 strcpy( dirpath, GLOBAL_CURRENT_PATH );

	push	OFFSET _GLOBAL_CURRENT_PATH
	lea	ecx, DWORD PTR _dirpath$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 1380 :                 entry = hash_find( GLOBAL_CURRENT_PATH, GLOBAL_HASH_TABLE );

	mov	edx, DWORD PTR _GLOBAL_HASH_TABLE
	push	edx
	push	OFFSET _GLOBAL_CURRENT_PATH
	call	_hash_find
	add	esp, 8
	mov	DWORD PTR _entry$[ebp], eax
$LN33@ResOpenFil:

; 1381 :             }
; 1382 : 
; 1383 :             if( !entry || !entry -> dir ) { /* directory is not already added */

	cmp	DWORD PTR _entry$[ebp], 0
	je	SHORT $LN31@ResOpenFil
	mov	eax, DWORD PTR _entry$[ebp]
	cmp	DWORD PTR [eax+40], 0
	jne	SHORT $LN32@ResOpenFil
$LN31@ResOpenFil:

; 1384 :                 SAY_ERROR( RES_ERR_UNKNOWN_WRITE_TO, name );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	1384					; 00000568H
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	-4971					; ffffec95H
	call	__say_error
	add	esp, 16					; 00000010H

; 1385 : #if (RES_MULTITHREAD)
; 1386 : 		RELEASE_LOCK(GLOCK); /* GFG */

	mov	edx, DWORD PTR _GLOCK
	push	edx
	call	DWORD PTR __imp__ReleaseMutex@4

; 1387 : #endif
; 1388 : 
; 1389 :                 return( -1 );

	or	eax, -1
	jmp	$LN40@ResOpenFil

; 1390 :             }
; 1391 :             else {

	jmp	SHORT $LN30@ResOpenFil
$LN32@ResOpenFil:

; 1392 :                 table = (HASH_TABLE *)entry -> dir;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR _table$[ebp], ecx
$LN30@ResOpenFil:

; 1393 :             }
; 1394 : 
; 1395 : #else /* flat model */
; 1396 :             if( strchr( name, ASCII_BACKSLASH ))
; 1397 :                 split_path( name, filename, dirpath );
; 1398 :             else /* current directory */
; 1399 :                 strcpy( filename, name );
; 1400 :         
; 1401 :             table = GLOBAL_HASH_TABLE;
; 1402 : #endif /* !RES_USE_FLAT_MODEL */
; 1403 : 
; 1404 :             strcpy( data.name, filename );

	lea	edx, DWORD PTR _filename$[ebp]
	push	edx
	lea	eax, DWORD PTR _data$[ebp+36]
	push	eax
	call	_strcpy
	add	esp, 8

; 1405 : 
; 1406 :             data.attrib = (unsigned int)FORCE_BIT;

	mov	DWORD PTR _data$[ebp], -2147483648	; 80000000H

; 1407 :             data.time_create = 0;

	xorpd	xmm0, xmm0
	movlpd	QWORD PTR _data$[ebp+8], xmm0

; 1408 :             data.time_access = 0;

	xorpd	xmm0, xmm0
	movlpd	QWORD PTR _data$[ebp+16], xmm0

; 1409 :             data.size = 0;

	mov	DWORD PTR _data$[ebp+32], 0

; 1410 : 
; 1411 :             entry = hash_add( &data, table );

	mov	ecx, DWORD PTR _table$[ebp]
	push	ecx
	lea	edx, DWORD PTR _data$[ebp]
	push	edx
	call	_hash_add
	add	esp, 8
	mov	DWORD PTR _entry$[ebp], eax

; 1412 : 
; 1413 :             if( !entry ) {

	cmp	DWORD PTR _entry$[ebp], 0
	jne	SHORT $LN29@ResOpenFil

; 1414 :                 SAY_ERROR( RES_ERR_UNKNOWN, "ResOpen - create" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	1414					; 00000586H
	push	OFFSET ??_C@_0BB@EDJDNCBI@ResOpen?5?9?5create?$AA@
	push	-4973					; ffffec93H
	call	__say_error
	add	esp, 16					; 00000010H

; 1415 : #if (RES_MULTITHREAD)
; 1416 : 		RELEASE_LOCK(GLOCK); /* GFG */

	mov	eax, DWORD PTR _GLOCK
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4

; 1417 : #endif
; 1418 : 
; 1419 :                 return( -1 );

	or	eax, -1
	jmp	$LN40@ResOpenFil
$LN29@ResOpenFil:

; 1420 :             }
; 1421 : 
; 1422 :             for( dir_index = 0; dir_index <= GLOBAL_SEARCH_INDEX; dir_index++ ) {

	mov	DWORD PTR _dir_index$[ebp], 0
	jmp	SHORT $LN28@ResOpenFil
$LN27@ResOpenFil:
	mov	ecx, DWORD PTR _dir_index$[ebp]
	add	ecx, 1
	mov	DWORD PTR _dir_index$[ebp], ecx
$LN28@ResOpenFil:
	mov	edx, DWORD PTR _dir_index$[ebp]
	cmp	edx, DWORD PTR _GLOBAL_SEARCH_INDEX
	jg	SHORT $LN26@ResOpenFil

; 1423 :                 if( !stricmp( dirpath, GLOBAL_SEARCH_PATH[ dir_index ] )) {

	mov	eax, DWORD PTR _dir_index$[ebp]
	mov	ecx, DWORD PTR _GLOBAL_SEARCH_PATH[eax*4]
	push	ecx
	lea	edx, DWORD PTR _dirpath$[ebp]
	push	edx
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN25@ResOpenFil

; 1424 :                     entry -> directory = dir_index;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR _dir_index$[ebp]
	mov	DWORD PTR [eax+32], ecx

; 1425 :                     entry -> volume = (char)(toupper(dirpath[0]) - 'A');

	mov	edx, 1
	imul	edx, 0
	movsx	eax, BYTE PTR _dirpath$[ebp+edx]
	push	eax
	call	_toupper
	add	esp, 4
	sub	eax, 65					; 00000041H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	BYTE PTR [ecx+36], al

; 1426 :                     break;

	jmp	SHORT $LN26@ResOpenFil
$LN25@ResOpenFil:

; 1427 :                 }
; 1428 :             }

	jmp	SHORT $LN27@ResOpenFil
$LN26@ResOpenFil:

; 1429 : 
; 1430 :             if( dir_index > GLOBAL_SEARCH_INDEX ) {

	mov	edx, DWORD PTR _dir_index$[ebp]
	cmp	edx, DWORD PTR _GLOBAL_SEARCH_INDEX
	jle	SHORT $LN24@ResOpenFil

; 1431 : #if (RES_MULTITHREAD)
; 1432 : 		RELEASE_LOCK(GLOCK); /* GFG */

	mov	eax, DWORD PTR _GLOCK
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4

; 1433 : #endif
; 1434 :                 return( -1 );

	or	eax, -1
	jmp	$LN40@ResOpenFil
$LN24@ResOpenFil:

; 1435 : 			}
; 1436 : 
; 1437 :             entry -> archive = -1;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+24], -1
$LN37@ResOpenFil:

; 1438 :         }
; 1439 :     }
; 1440 : 
; 1441 : 
; 1442 :     /* Make sure the user isn't trying to write to an archive file.
; 1443 :        Someday this may be possible, but not for a while. */
; 1444 : 
; 1445 :     if( entry -> archive != -1 ) {

	mov	edx, DWORD PTR _entry$[ebp]
	cmp	DWORD PTR [edx+24], -1
	je	SHORT $LN23@ResOpenFil

; 1446 :         int check;
; 1447 : 
; 1448 :         check = (_O_CREAT | _O_APPEND | _O_RDWR | _O_WRONLY);

	mov	DWORD PTR _check$1[ebp], 267		; 0000010bH

; 1449 :         check &= mode;

	mov	eax, DWORD PTR _check$1[ebp]
	and	eax, DWORD PTR _mode$[ebp]
	mov	DWORD PTR _check$1[ebp], eax

; 1450 : 
; 1451 :         if( check ) {/* don't known why had to do it broken out like this - ask MSVC */

	je	SHORT $LN23@ResOpenFil

; 1452 :             SAY_ERROR( RES_ERR_CANT_WRITE_ARCHIVE, name );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	1452					; 000005acH
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	-4970					; ffffec96H
	call	__say_error
	add	esp, 16					; 00000010H

; 1453 : #if (RES_MULTITHREAD)
; 1454 : 		RELEASE_LOCK(GLOCK); /* GFG */

	mov	edx, DWORD PTR _GLOCK
	push	edx
	call	DWORD PTR __imp__ReleaseMutex@4

; 1455 : #endif
; 1456 :             return( -1 );

	or	eax, -1
	jmp	$LN40@ResOpenFil
$LN23@ResOpenFil:

; 1457 :         }
; 1458 :     }
; 1459 : 
; 1460 :     
; 1461 : 	/* Initialize some common data */
; 1462 :     file -> current_pos = 0;

	mov	eax, DWORD PTR _file$[ebp]
	mov	DWORD PTR [eax+8], 0

; 1463 :     file -> current_filbuf_pos = 0;

	mov	ecx, DWORD PTR _file$[ebp]
	mov	DWORD PTR [ecx+44], 0

; 1464 : 
; 1465 : 
; 1466 :     /* Is this a loose file (not in an archive?) */
; 1467 : 
; 1468 :     if( entry -> archive == -1 ) {

	mov	edx, DWORD PTR _entry$[ebp]
	cmp	DWORD PTR [edx+24], -1
	jne	$LN21@ResOpenFil

; 1469 :         /* may seem redundant but there are too many pathological cases otherwise */
; 1470 : 
; 1471 :         if( mode & _O_CREAT )

	mov	eax, DWORD PTR _mode$[ebp]
	and	eax, 256				; 00000100H
	je	SHORT $LN20@ResOpenFil

; 1472 :             res_fullpath( filename, name, _MAX_PATH );  /* regardless of coercion state */

	push	260					; 00000104H
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	lea	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	_res_fullpath
	add	esp, 12					; 0000000cH

; 1473 :         else

	jmp	SHORT $LN19@ResOpenFil
$LN20@ResOpenFil:

; 1474 :             sprintf( filename, "%s%s", GLOBAL_SEARCH_PATH[ entry -> directory ], entry -> name );

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _GLOBAL_SEARCH_PATH[eax*4]
	push	ecx
	push	OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
	lea	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H
$LN19@ResOpenFil:

; 1475 : 
; 1476 :         /* there is actually a third parameter to open() (MSVC just doesn't admit it) 
; 1477 :            octal 666 ensures that stack-crap won't accidently create this file as
; 1478 :            read-only.  Thank to Roger Fujii for this fix! */
; 1479 : 
; 1480 :         file -> os_handle = _open( filename, mode, 0x1b6 /* choked on O666 and O666L */ );

	push	438					; 000001b6H
	mov	eax, DWORD PTR _mode$[ebp]
	push	eax
	lea	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	__open
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _file$[ebp]
	mov	DWORD PTR [edx], eax

; 1481 :     
; 1482 :         if( file -> os_handle == -1 ) {

	mov	eax, DWORD PTR _file$[ebp]
	cmp	DWORD PTR [eax], -1
	jne	SHORT $LN18@ResOpenFil

; 1483 : 
; 1484 : 			if( errno == EACCES )

	call	__errno
	cmp	DWORD PTR [eax], 13			; 0000000dH
	jne	SHORT $LN17@ResOpenFil

; 1485 :                           {SAY_ERROR( RES_ERR_FILE_SHARING, filename );}

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	1485					; 000005cdH
	lea	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	push	-4996					; ffffec7cH
	call	__say_error
	add	esp, 16					; 00000010H

; 1486 : 			else

	jmp	SHORT $LN16@ResOpenFil
$LN17@ResOpenFil:

; 1487 :                           {SAY_ERROR( RES_ERR_FILE_NOT_FOUND, filename );}

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	1487					; 000005cfH
	lea	edx, DWORD PTR _filename$[ebp]
	push	edx
	push	-4993					; ffffec7fH
	call	__say_error
	add	esp, 16					; 00000010H
$LN16@ResOpenFil:

; 1488 : 
; 1489 :             ResCheckMedia( entry -> volume );

	mov	eax, DWORD PTR _entry$[ebp]
	movsx	ecx, BYTE PTR [eax+36]
	push	ecx
	call	_ResCheckMedia
	add	esp, 4

; 1490 : #if (RES_MULTITHREAD)
; 1491 : 		RELEASE_LOCK(GLOCK); /* GFG */

	mov	edx, DWORD PTR _GLOCK
	push	edx
	call	DWORD PTR __imp__ReleaseMutex@4

; 1492 : #endif
; 1493 :             return( -1 );

	or	eax, -1
	jmp	$LN40@ResOpenFil
$LN18@ResOpenFil:

; 1494 :         }
; 1495 : 
; 1496 :         file -> seek_start  = 0;

	mov	eax, DWORD PTR _file$[ebp]
	mov	DWORD PTR [eax+4], 0

; 1497 :         file -> size        = entry -> size;

	mov	ecx, DWORD PTR _file$[ebp]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+12], eax

; 1498 :         file -> csize       = 0;

	mov	ecx, DWORD PTR _file$[ebp]
	mov	DWORD PTR [ecx+16], 0

; 1499 :         file -> attrib      = entry -> attrib;

	mov	edx, DWORD PTR _file$[ebp]
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR [edx+20], ecx

; 1500 :         file -> mode        = mode;

	mov	edx, DWORD PTR _file$[ebp]
	mov	eax, DWORD PTR _mode$[ebp]
	mov	DWORD PTR [edx+24], eax

; 1501 :         file -> location    = -1;

	mov	ecx, DWORD PTR _file$[ebp]
	mov	DWORD PTR [ecx+28], -1

; 1502 :         file -> zip         = NULL;

	mov	edx, DWORD PTR _file$[ebp]
	mov	DWORD PTR [edx+48], 0

; 1503 :         file -> filename    = MemStrDup( filename );

	lea	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_strdup
	add	esp, 4
	mov	ecx, DWORD PTR _file$[ebp]
	mov	DWORD PTR [ecx+40], eax

; 1504 :         file -> device      = entry -> volume;

	mov	edx, DWORD PTR _file$[ebp]
	mov	eax, DWORD PTR _entry$[ebp]
	mov	cl, BYTE PTR [eax+36]
	mov	BYTE PTR [edx+32], cl

; 1505 :     
; 1506 :         SHOULD_I_CALL_WITH( CALLBACK_OPEN_FILE, handle, retval );

	mov	edx, 4
	shl	edx, 2
	cmp	DWORD PTR _RES_CALLBACK[edx], 0
	je	SHORT $LN15@ResOpenFil
	mov	eax, DWORD PTR _handle$[ebp]
	push	eax
	mov	ecx, 4
	shl	ecx, 2
	mov	edx, DWORD PTR _RES_CALLBACK[ecx]
	call	edx
	add	esp, 4
	mov	DWORD PTR _retval$[ebp], eax
$LN15@ResOpenFil:

; 1507 : #if (RES_MULTITHREAD)
; 1508 : 		RELEASE_LOCK(GLOCK); /* GFG */

	mov	eax, DWORD PTR _GLOCK
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4

; 1509 : #endif
; 1510 :         return( handle );

	mov	eax, DWORD PTR _handle$[ebp]
	jmp	$LN40@ResOpenFil

; 1511 :     }
; 1512 :     else {   /* in an archive */

	jmp	$LN14@ResOpenFil
$LN21@ResOpenFil:

; 1513 :         /* using the handle, search the list for the structure */
; 1514 : 
; 1515 :         for( list = ARCHIVE_LIST; list; list = list -> next ) {

	mov	ecx, DWORD PTR _ARCHIVE_LIST
	mov	DWORD PTR _list$[ebp], ecx
	jmp	SHORT $LN13@ResOpenFil
$LN12@ResOpenFil:
	mov	edx, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _list$[ebp], eax
$LN13@ResOpenFil:
	cmp	DWORD PTR _list$[ebp], 0
	je	SHORT $LN11@ResOpenFil

; 1516 :             archive = (ARCHIVE *)list -> node;

	mov	ecx, DWORD PTR _list$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _archive$[ebp], edx

; 1517 : 
; 1518 :             if( archive -> os_handle == entry -> archive )

	mov	eax, DWORD PTR _archive$[ebp]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [eax+260]
	cmp	edx, DWORD PTR [ecx+24]
	jne	SHORT $LN10@ResOpenFil

; 1519 :                break;

	jmp	SHORT $LN11@ResOpenFil
$LN10@ResOpenFil:

; 1520 :         }

	jmp	SHORT $LN12@ResOpenFil
$LN11@ResOpenFil:

; 1521 : 
; 1522 :         if( !list ) {

	cmp	DWORD PTR _list$[ebp], 0
	jne	SHORT $LN9@ResOpenFil

; 1523 :            SAY_ERROR( RES_ERR_UNKNOWN, " " ); /* archive handle in hash entry is incorrect (or archive detached) */

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	1523					; 000005f3H
	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	push	-4973					; ffffec93H
	call	__say_error
	add	esp, 16					; 00000010H

; 1524 : #if (RES_MULTITHREAD)
; 1525 : 		RELEASE_LOCK(GLOCK); /* GFG */

	mov	eax, DWORD PTR _GLOCK
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4

; 1526 : #endif
; 1527 :            return( -1 );

	or	eax, -1
	jmp	$LN40@ResOpenFil
$LN9@ResOpenFil:

; 1528 :         }
; 1529 : 
; 1530 :         sprintf( filename, "%s%s", GLOBAL_SEARCH_PATH[ entry -> directory ], entry -> name );

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _GLOBAL_SEARCH_PATH[ecx*4]
	push	edx
	push	OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
	lea	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H

; 1531 : 
; 1532 :         lseek( archive -> os_handle, entry -> file_position + SIGNATURE_SIZE, SEEK_SET );

	push	0
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	add	edx, 4
	push	edx
	mov	eax, DWORD PTR _archive$[ebp]
	mov	ecx, DWORD PTR [eax+260]
	push	ecx
	call	_lseek
	add	esp, 12					; 0000000cH

; 1533 : 
; 1534 :         _read( archive -> os_handle, tmp, LREC_SIZE );

	push	26					; 0000001aH
	lea	edx, DWORD PTR _tmp$[ebp]
	push	edx
	mov	eax, DWORD PTR _archive$[ebp]
	mov	ecx, DWORD PTR [eax+260]
	push	ecx
	call	__read
	add	esp, 12					; 0000000cH

; 1535 : 
; 1536 :         process_local_file_hdr( &lrec, tmp );    /* return PK-type error code */

	lea	edx, DWORD PTR _tmp$[ebp]
	push	edx
	lea	eax, DWORD PTR _lrec$[ebp]
	push	eax
	call	_process_local_file_hdr
	add	esp, 8

; 1537 : 
; 1538 :         file -> seek_start = lseek( archive -> os_handle, lrec.filename_length + lrec.extra_field_length, SEEK_CUR );

	push	1
	movzx	ecx, WORD PTR _lrec$[ebp+24]
	movzx	edx, WORD PTR _lrec$[ebp+26]
	add	ecx, edx
	push	ecx
	mov	eax, DWORD PTR _archive$[ebp]
	mov	ecx, DWORD PTR [eax+260]
	push	ecx
	call	_lseek
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _file$[ebp]
	mov	DWORD PTR [edx+4], eax

; 1539 : 
; 1540 :         switch( entry -> method ) {

	mov	eax, DWORD PTR _entry$[ebp]
	movsx	ecx, WORD PTR [eax+16]
	mov	DWORD PTR tv292[ebp], ecx
	cmp	DWORD PTR tv292[ebp], 0
	je	SHORT $LN6@ResOpenFil
	cmp	DWORD PTR tv292[ebp], 8
	je	$LN4@ResOpenFil
	jmp	$LN1@ResOpenFil
$LN6@ResOpenFil:

; 1541 :             case STORED: {
; 1542 :                 file -> os_handle   = archive -> os_handle;

	mov	edx, DWORD PTR _file$[ebp]
	mov	eax, DWORD PTR _archive$[ebp]
	mov	ecx, DWORD PTR [eax+260]
	mov	DWORD PTR [edx], ecx

; 1543 :                 //file -> seek_start  = entry -> file_position;
; 1544 :                 file -> csize       = 0;

	mov	edx, DWORD PTR _file$[ebp]
	mov	DWORD PTR [edx+16], 0

; 1545 :                 file -> size        = entry -> size;

	mov	eax, DWORD PTR _file$[ebp]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+12], edx

; 1546 :                 file -> filename    = MemStrDup( filename );

	lea	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_strdup
	add	esp, 4
	mov	ecx, DWORD PTR _file$[ebp]
	mov	DWORD PTR [ecx+40], eax

; 1547 :                 file -> mode        = mode;

	mov	edx, DWORD PTR _file$[ebp]
	mov	eax, DWORD PTR _mode$[ebp]
	mov	DWORD PTR [edx+24], eax

; 1548 :                 file -> device      = entry -> volume;

	mov	ecx, DWORD PTR _file$[ebp]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	al, BYTE PTR [edx+36]
	mov	BYTE PTR [ecx+32], al

; 1549 :                 file -> zip         = NULL; /* only used if we need to deflate */

	mov	ecx, DWORD PTR _file$[ebp]
	mov	DWORD PTR [ecx+48], 0

; 1550 : 
; 1551 :                 SHOULD_I_CALL_WITH( CALLBACK_OPEN_FILE, handle, retval );

	mov	edx, 4
	shl	edx, 2
	cmp	DWORD PTR _RES_CALLBACK[edx], 0
	je	SHORT $LN5@ResOpenFil
	mov	eax, DWORD PTR _handle$[ebp]
	push	eax
	mov	ecx, 4
	shl	ecx, 2
	mov	edx, DWORD PTR _RES_CALLBACK[ecx]
	call	edx
	add	esp, 4
	mov	DWORD PTR _retval$[ebp], eax
$LN5@ResOpenFil:

; 1552 : #if (RES_MULTITHREAD)
; 1553 : 		RELEASE_LOCK(GLOCK); /* GFG */

	mov	eax, DWORD PTR _GLOCK
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4

; 1554 : #endif
; 1555 :                 return( handle );

	mov	eax, DWORD PTR _handle$[ebp]
	jmp	$LN40@ResOpenFil

; 1556 :                 break;

	jmp	$LN14@ResOpenFil
$LN4@ResOpenFil:

; 1557 :             }
; 1558 : 
; 1559 :             case DEFLATED: {
; 1560 :                 COMPRESSED_FILE * zip;
; 1561 :                                  
; 1562 : 				#ifdef USE_SH_POOLS
; 1563 :                 zip = (COMPRESSED_FILE *)MemAllocPtr( gResmgrMemPool, sizeof(COMPRESSED_FILE) + (entry -> size), 0 );
; 1564 : 				#else
; 1565 :                 zip = (COMPRESSED_FILE *)MemMalloc( sizeof(COMPRESSED_FILE) + (entry -> size), "Inflate" );

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, 48					; 00000030H
	push	edx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _zip$2[ebp], eax

; 1566 : 				#endif
; 1567 : 
; 1568 :                 if( !zip ) {

	cmp	DWORD PTR _zip$2[ebp], 0
	jne	SHORT $LN3@ResOpenFil

; 1569 :                     SAY_ERROR( RES_ERR_NO_MEMORY, "Inflate" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	1569					; 00000621H
	push	OFFSET ??_C@_07DNABHHOL@Inflate?$AA@
	push	-4999					; ffffec79H
	call	__say_error
	add	esp, 16					; 00000010H

; 1570 : #if (RES_MULTITHREAD)
; 1571 : 		RELEASE_LOCK(GLOCK); /* GFG */

	mov	eax, DWORD PTR _GLOCK
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4

; 1572 : #endif
; 1573 :                     return(-1);

	or	eax, -1
	jmp	$LN40@ResOpenFil
$LN3@ResOpenFil:

; 1574 :                 }
; 1575 : 
; 1576 :                 file -> os_handle   = archive -> os_handle;

	mov	ecx, DWORD PTR _file$[ebp]
	mov	edx, DWORD PTR _archive$[ebp]
	mov	eax, DWORD PTR [edx+260]
	mov	DWORD PTR [ecx], eax

; 1577 :                 //file -> seek_start  = entry -> file_position;
; 1578 :                 file -> csize       = entry -> csize;

	mov	ecx, DWORD PTR _file$[ebp]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+16], eax

; 1579 :                 file -> size        = entry -> size;

	mov	ecx, DWORD PTR _file$[ebp]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+12], eax

; 1580 :                 file -> filename    = MemStrDup( filename );

	lea	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_strdup
	add	esp, 4
	mov	edx, DWORD PTR _file$[ebp]
	mov	DWORD PTR [edx+40], eax

; 1581 :                 file -> mode        = mode;

	mov	eax, DWORD PTR _file$[ebp]
	mov	ecx, DWORD PTR _mode$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 1582 :                 file -> device      = entry -> volume;

	mov	edx, DWORD PTR _file$[ebp]
	mov	eax, DWORD PTR _entry$[ebp]
	mov	cl, BYTE PTR [eax+36]
	mov	BYTE PTR [edx+32], cl

; 1583 : 
; 1584 : 				#ifdef USE_SH_POOLS
; 1585 :                 zip -> slide      = (uch *)MemAllocPtr( gResmgrMemPool, UNZIP_SLIDE_SIZE + INPUTBUFSIZE, 0 ); /* glob temporary allocations */
; 1586 : 				#else
; 1587 :                 zip -> slide      = (uch *)MemMalloc( UNZIP_SLIDE_SIZE + INPUTBUFSIZE, "deflate" ); /* glob temporary allocations */

	push	53248					; 0000d000H
	call	_malloc
	add	esp, 4
	mov	edx, DWORD PTR _zip$2[ebp]
	mov	DWORD PTR [edx], eax

; 1588 : 				#endif
; 1589 : 
; 1590 :                 zip -> in_buffer  = (uch *)zip -> slide + UNZIP_SLIDE_SIZE;

	mov	eax, DWORD PTR _zip$2[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 32768				; 00008000H
	mov	edx, DWORD PTR _zip$2[ebp]
	mov	DWORD PTR [edx+4], ecx

; 1591 :                 zip -> in_ptr     = (uch *)zip -> in_buffer;

	mov	eax, DWORD PTR _zip$2[ebp]
	mov	ecx, DWORD PTR _zip$2[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+8], edx

; 1592 :                 zip -> in_count   = 0;

	mov	eax, DWORD PTR _zip$2[ebp]
	mov	DWORD PTR [eax+12], 0

; 1593 :                 zip -> in_size    = file -> csize > INPUTBUFSIZE ? INPUTBUFSIZE : file -> csize;

	mov	ecx, DWORD PTR _file$[ebp]
	cmp	DWORD PTR [ecx+16], 20480		; 00005000H
	jbe	SHORT $LN42@ResOpenFil
	mov	DWORD PTR tv348[ebp], 20480		; 00005000H
	jmp	SHORT $LN43@ResOpenFil
$LN42@ResOpenFil:
	mov	edx, DWORD PTR _file$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR tv348[ebp], eax
$LN43@ResOpenFil:
	mov	ecx, DWORD PTR _zip$2[ebp]
	mov	edx, DWORD PTR tv348[ebp]
	mov	DWORD PTR [ecx+16], edx

; 1594 :                 zip -> csize      = file -> csize;

	mov	eax, DWORD PTR _zip$2[ebp]
	mov	ecx, DWORD PTR _file$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+40], edx

; 1595 : 
; 1596 :                 zip -> out_buffer = (char *)zip + sizeof(COMPRESSED_FILE);

	mov	eax, DWORD PTR _zip$2[ebp]
	add	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _zip$2[ebp]
	mov	DWORD PTR [ecx+20], eax

; 1597 :                 zip -> out_count  = 0;

	mov	edx, DWORD PTR _zip$2[ebp]
	mov	DWORD PTR [edx+24], 0

; 1598 :                 zip -> archive    = archive;

	mov	eax, DWORD PTR _zip$2[ebp]
	mov	ecx, DWORD PTR _archive$[ebp]
	mov	DWORD PTR [eax+44], ecx

; 1599 : 
; 1600 :                 file -> zip       = zip;    /* Future use: I may add incremental deflation */

	mov	edx, DWORD PTR _file$[ebp]
	mov	eax, DWORD PTR _zip$2[ebp]
	mov	DWORD PTR [edx+48], eax

; 1601 : 
; 1602 :                 inflate( zip );

	mov	ecx, DWORD PTR _zip$2[ebp]
	push	ecx
	call	_inflate
	add	esp, 4

; 1603 : 
; 1604 : 				#ifdef USE_SH_POOLS
; 1605 :                 MemFreePtr( zip -> slide );    /* Free temporary allocations */
; 1606 : 				#else
; 1607 :                 MemFree( zip -> slide );    /* Free temporary allocations */

	mov	edx, DWORD PTR _zip$2[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_free
	add	esp, 4

; 1608 : 				#endif
; 1609 : 
; 1610 :                 SHOULD_I_CALL_WITH( CALLBACK_OPEN_FILE, handle, retval );

	mov	ecx, 4
	shl	ecx, 2
	cmp	DWORD PTR _RES_CALLBACK[ecx], 0
	je	SHORT $LN2@ResOpenFil
	mov	edx, DWORD PTR _handle$[ebp]
	push	edx
	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _RES_CALLBACK[eax]
	call	ecx
	add	esp, 4
	mov	DWORD PTR _retval$[ebp], eax
$LN2@ResOpenFil:

; 1611 : #if (RES_MULTITHREAD)
; 1612 : 		RELEASE_LOCK(GLOCK); /* GFG */

	mov	edx, DWORD PTR _GLOCK
	push	edx
	call	DWORD PTR __imp__ReleaseMutex@4

; 1613 : #endif
; 1614 :                 return( handle );

	mov	eax, DWORD PTR _handle$[ebp]
	jmp	SHORT $LN40@ResOpenFil

; 1615 :                 break;

	jmp	SHORT $LN14@ResOpenFil
$LN1@ResOpenFil:

; 1616 :             }
; 1617 : 
; 1618 :             default:
; 1619 :                 SAY_ERROR( RES_ERR_UNSUPPORTED_COMPRESSION, entry -> name );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	1619					; 00000653H
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	-4969					; ffffec97H
	call	__say_error
	add	esp, 16					; 00000010H

; 1620 : #if (RES_MULTITHREAD)
; 1621 : 		RELEASE_LOCK(GLOCK); /* GFG */

	mov	edx, DWORD PTR _GLOCK
	push	edx
	call	DWORD PTR __imp__ReleaseMutex@4

; 1622 : #endif
; 1623 :                 return( -1 );

	or	eax, -1
	jmp	SHORT $LN40@ResOpenFil
$LN14@ResOpenFil:

; 1624 :                 break;
; 1625 :         }
; 1626 :     }
; 1627 : 
; 1628 : #if (RES_MULTITHREAD)
; 1629 : 		RELEASE_LOCK(GLOCK); /* GFG */

	mov	eax, DWORD PTR _GLOCK
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4

; 1630 : #endif
; 1631 :     return( -1 );

	or	eax, -1
$LN40@ResOpenFil:

; 1632 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_ResOpenFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_list$ = -8						; size = 4
_archive$ = -4						; size = 4
_handle$ = 8						; size = 4
_ResDetach PROC

; 1205 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1206 :     ARCHIVE    * archive=NULL;

	mov	DWORD PTR _archive$[ebp], 0

; 1207 :     LIST       * list=NULL;

	mov	DWORD PTR _list$[ebp], 0

; 1208 : 
; 1209 : #if( RES_DEBUG_PARAMS )
; 1210 :     if( !ARCHIVE_LIST ) {

	cmp	DWORD PTR _ARCHIVE_LIST, 0
	jne	SHORT $LN7@ResDetach

; 1211 :         //SAY_ERROR( RES_ERR_UNKNOWN_ARCHIVE, "ResDetach" );
; 1212 :         return;

	jmp	$LN8@ResDetach
$LN7@ResDetach:

; 1213 :     }
; 1214 : #endif /* RES_DEBUG_PARAMS */
; 1215 : 
; 1216 :     /* using the handle, search the list for the structure */
; 1217 : 
; 1218 :     for( list = ARCHIVE_LIST; list; list = list -> next ) {

	mov	eax, DWORD PTR _ARCHIVE_LIST
	mov	DWORD PTR _list$[ebp], eax
	jmp	SHORT $LN6@ResDetach
$LN5@ResDetach:
	mov	ecx, DWORD PTR _list$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _list$[ebp], edx
$LN6@ResDetach:
	cmp	DWORD PTR _list$[ebp], 0
	je	SHORT $LN4@ResDetach

; 1219 :         archive = (ARCHIVE *)list -> node;

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _archive$[ebp], ecx

; 1220 : 
; 1221 :         if( archive -> os_handle == handle )

	mov	edx, DWORD PTR _archive$[ebp]
	mov	eax, DWORD PTR [edx+260]
	cmp	eax, DWORD PTR _handle$[ebp]
	jne	SHORT $LN3@ResDetach

; 1222 :             break;

	jmp	SHORT $LN4@ResDetach
$LN3@ResDetach:

; 1223 :     }

	jmp	SHORT $LN5@ResDetach
$LN4@ResDetach:

; 1224 : 
; 1225 :     if( !list ) { /* couldn't find it, may already have been closed - or handle is incorrect */

	cmp	DWORD PTR _list$[ebp], 0
	jne	SHORT $LN2@ResDetach

; 1226 :         SAY_ERROR( RES_ERR_UNKNOWN_ARCHIVE, "ResDetach" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	1226					; 000004caH
	push	OFFSET ??_C@_09BFLPBOFI@ResDetach?$AA@
	push	-4979					; ffffec8dH
	call	__say_error
	add	esp, 16					; 00000010H

; 1227 :         return;

	jmp	$LN8@ResDetach
$LN2@ResDetach:

; 1228 :     }
; 1229 : 
; 1230 :     IF_LOG( LOG( "detach: %s\n", archive -> name ));
; 1231 :     
; 1232 :     REQUEST_LOCK( archive -> lock );

	push	-1
	mov	ecx, DWORD PTR _archive$[ebp]
	mov	edx, DWORD PTR [ecx+276]
	push	edx
	call	DWORD PTR __imp__WaitForSingleObject@8

; 1233 : 
; 1234 :     ResPurge((char *)&archive -> os_handle, NULL, NULL, NULL );

	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _archive$[ebp]
	add	eax, 260				; 00000104H
	push	eax
	call	_ResPurge
	add	esp, 16					; 00000010H

; 1235 : 
; 1236 :     /* remove the archive from out list */
; 1237 :     ARCHIVE_LIST = LIST_REMOVE( ARCHIVE_LIST, archive );

	mov	ecx, DWORD PTR _archive$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ARCHIVE_LIST
	push	edx
	call	_ListRemove
	add	esp, 8
	mov	DWORD PTR _ARCHIVE_LIST, eax

; 1238 : 
; 1239 : 
; 1240 :     /* The inflation code builds a table of constant values for decompressing 
; 1241 :        files compressed with pkzip's FIXED compression mode.  The tables are
; 1242 :        dynamically created (if they don't already exist) when you decompress
; 1243 :        data via that method.  Therefore, we don't want to free it up until
; 1244 :        all the zips are detached - then we might as well to reclaim memory */
; 1245 : 
; 1246 :     if( !ARCHIVE_LIST ) 

	cmp	DWORD PTR _ARCHIVE_LIST, 0
	jne	SHORT $LN1@ResDetach

; 1247 :         inflate_free(); 

	call	_inflate_free
$LN1@ResDetach:

; 1248 : 
; 1249 :     /* close the actual archive file */
; 1250 :     _close( archive -> os_handle );

	mov	eax, DWORD PTR _archive$[ebp]
	mov	ecx, DWORD PTR [eax+260]
	push	ecx
	call	__close
	add	esp, 4

; 1251 : 
; 1252 :     RELEASE_LOCK( archive -> lock );

	mov	edx, DWORD PTR _archive$[ebp]
	mov	eax, DWORD PTR [edx+276]
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4

; 1253 :     DESTROY_LOCK( archive -> lock );

	mov	ecx, DWORD PTR _archive$[ebp]
	mov	edx, DWORD PTR [ecx+276]
	push	edx
	call	DWORD PTR __imp__CloseHandle@4

; 1254 : 
; 1255 : 	#ifdef USE_SH_POOLS
; 1256 :     MemFreePtr( archive );
; 1257 : 	#else
; 1258 :     MemFree( archive );

	mov	eax, DWORD PTR _archive$[ebp]
	push	eax
	call	_free
	add	esp, 4
$LN8@ResDetach:

; 1259 : 	#endif
; 1260 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ResDetach ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_table$ = -844						; size = 4
_archive$ = -840					; size = 4
_len$ = -836						; size = 4
_i$ = -832						; size = 4
_entry$ = -828						; size = 4
_attach_point$ = -824					; size = 4
_info$ = -820						; size = 296
_attach_point_backup$ = -524				; size = 260
_path$ = -264						; size = 260
__$ArrayPad$ = -4					; size = 4
_attach_point_arg$ = 8					; size = 4
_filename$ = 12						; size = 4
_replace_flag$ = 16					; size = 4
_ResAttach PROC

; 1013 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 844				; 0000034cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1014 :     ARCHIVE    * archive;
; 1015 :     HASH_TABLE * table = NULL;

	mov	DWORD PTR _table$[ebp], 0

; 1016 :     char         path[_MAX_PATH];
; 1017 :     char         attach_point_backup[_MAX_PATH];
; 1018 :     char       * attach_point;
; 1019 :     int          len, i;
; 1020 :     struct _finddata_t  info;
; 1021 : 
; 1022 :   
; 1023 : 
; 1024 : #if( !RES_USE_FLAT_MODEL )
; 1025 :     HASH_ENTRY * entry;
; 1026 : #endif
; 1027 : 
; 1028 : //      _getcwd(old_cwd,MAX_PATH);
; 1029 : 
; 1030 :     if(attach_point_arg)

	cmp	DWORD PTR _attach_point_arg$[ebp], 0
	je	SHORT $LN16@ResAttach

; 1031 :       {
; 1032 :         strcpy( attach_point_backup, attach_point_arg );

	mov	eax, DWORD PTR _attach_point_arg$[ebp]
	push	eax
	lea	ecx, DWORD PTR _attach_point_backup$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 1033 :         attach_point = attach_point_backup;

	lea	edx, DWORD PTR _attach_point_backup$[ebp]
	mov	DWORD PTR _attach_point$[ebp], edx

; 1034 :       }
; 1035 :     else

	jmp	SHORT $LN15@ResAttach
$LN16@ResAttach:

; 1036 :       {
; 1037 :         attach_point = NULL;

	mov	DWORD PTR _attach_point$[ebp], 0
$LN15@ResAttach:

; 1038 :       }
; 1039 : 
; 1040 : 
; 1041 :     IF_LOG( LOG( "attach: %s %s\n", attach_point, filename ));
; 1042 : 
; 1043 : #if( RES_DEBUG_PARAMS )
; 1044 :     if( !filename || (strlen(filename) > _MAX_FNAME)) {

	cmp	DWORD PTR _filename$[ebp], 0
	je	SHORT $LN13@ResAttach
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	cmp	eax, 256				; 00000100H
	jbe	SHORT $LN14@ResAttach
$LN13@ResAttach:

; 1045 :         SAY_ERROR( RES_ERR_INCORRECT_PARAMETER, "ResAttach" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	1045					; 00000415H
	push	OFFSET ??_C@_09IPANOAMB@ResAttach?$AA@
	push	-4998					; ffffec7aH
	call	__say_error
	add	esp, 16					; 00000010H

; 1046 :         return( -1 );

	or	eax, -1
	jmp	$LN17@ResAttach
$LN14@ResAttach:

; 1047 :     }
; 1048 : #endif
; 1049 : 
; 1050 :     if( !GLOBAL_HASH_TABLE ) {

	cmp	DWORD PTR _GLOBAL_HASH_TABLE, 0
	jne	SHORT $LN12@ResAttach

; 1051 :         SAY_ERROR( RES_ERR_INCORRECT_PARAMETER, "ResAttach" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	1051					; 0000041bH
	push	OFFSET ??_C@_09IPANOAMB@ResAttach?$AA@
	push	-4998					; ffffec7aH
	call	__say_error
	add	esp, 16					; 00000010H

; 1052 :         return( -1 );

	or	eax, -1
	jmp	$LN17@ResAttach
$LN12@ResAttach:

; 1053 :     }
; 1054 : 
; 1055 :     if( !attach_point )

	cmp	DWORD PTR _attach_point$[ebp], 0
	jne	SHORT $LN11@ResAttach

; 1056 :         attach_point = GLOBAL_CURRENT_PATH;

	mov	DWORD PTR _attach_point$[ebp], OFFSET _GLOBAL_CURRENT_PATH
$LN11@ResAttach:

; 1057 : 
; 1058 : #if( RES_COERCE_FILENAMES )
; 1059 :     len = strlen( attach_point );

	mov	ecx, DWORD PTR _attach_point$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _len$[ebp], eax

; 1060 : 
; 1061 :     if( attach_point[len-1] != ASCII_BACKSLASH ) {

	mov	edx, DWORD PTR _attach_point$[ebp]
	add	edx, DWORD PTR _len$[ebp]
	movsx	eax, BYTE PTR [edx-1]
	cmp	eax, 92					; 0000005cH
	je	SHORT $LN10@ResAttach

; 1062 :         attach_point[len++] = ASCII_BACKSLASH;

	mov	ecx, DWORD PTR _attach_point$[ebp]
	add	ecx, DWORD PTR _len$[ebp]
	mov	BYTE PTR [ecx], 92			; 0000005cH
	mov	edx, DWORD PTR _len$[ebp]
	add	edx, 1
	mov	DWORD PTR _len$[ebp], edx

; 1063 :         attach_point[len] = 0x00;

	mov	eax, DWORD PTR _attach_point$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	mov	BYTE PTR [eax], 0
$LN10@ResAttach:

; 1064 :     }
; 1065 : 
; 1066 :     res_fullpath( path, attach_point, _MAX_PATH );

	push	260					; 00000104H
	mov	ecx, DWORD PTR _attach_point$[ebp]
	push	ecx
	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	call	_res_fullpath
	add	esp, 12					; 0000000cH

; 1067 : 
; 1068 :     attach_point = path;

	lea	eax, DWORD PTR _path$[ebp]
	mov	DWORD PTR _attach_point$[ebp], eax

; 1069 : 
; 1070 : #endif /* RES_COERCE_FILENAMES */
; 1071 : 
; 1072 :       info.size = 0;

	mov	DWORD PTR _info$[ebp+32], 0

; 1073 : 
; 1074 : #if( !RES_USE_FLAT_MODEL )
; 1075 :     entry = hash_find( attach_point, GLOBAL_HASH_TABLE );

	mov	ecx, DWORD PTR _GLOBAL_HASH_TABLE
	push	ecx
	mov	edx, DWORD PTR _attach_point$[ebp]
	push	edx
	call	_hash_find
	add	esp, 8
	mov	DWORD PTR _entry$[ebp], eax

; 1076 : 
; 1077 : 
; 1078 :     /* I used to force you to use a directory already in
; 1079 :        the resource manager for the attach point.  Roger
; 1080 :        Fujii asked for anything to be used (allowing you
; 1081 :        to create artificial directories).  If you want
; 1082 :        the original functionality, define RES_ALLOW_ALIAS
; 1083 :        to false. */
; 1084 : 
; 1085 : 
; 1086 : #if( !RES_ALLOW_ALIAS )
; 1087 :        if( !entry ) {
; 1088 :            SAY_ERROR( RES_ERR_PATH_NOT_FOUND, attach_point );
; 1089 :            return( -1 );
; 1090 :        }
; 1091 : #else
; 1092 : 
; 1093 :     /* The attach point does not have to be either a directory -or- 
; 1094 :        an 'added' directory (a directory that has been incorporated
; 1095 :        into the Resource Manager via ResAddPath or ResCreatePath */
; 1096 : 
; 1097 :     if( !entry ) {

	cmp	DWORD PTR _entry$[ebp], 0
	jne	$LN9@ResAttach

; 1098 : 
; 1099 : #if( RES_DEBUG_VERSION )
; 1100 :         if( GLOBAL_SEARCH_INDEX >= (MAX_DIRECTORIES-1)) {

	cmp	DWORD PTR _GLOBAL_SEARCH_INDEX, 249	; 000000f9H
	jl	SHORT $LN8@ResAttach

; 1101 :           assert(!"Exceeded MAX_DIRECTORIES as defined in omni.h");
; 1102 : //            SAY_ERROR( RES_ERR_TOO_MANY_DIRECTORIES, "ResAddPath" );
; 1103 :             return( FALSE );

	xor	eax, eax
	jmp	$LN17@ResAttach
$LN8@ResAttach:

; 1104 :         }
; 1105 : #endif
; 1106 :         table = hash_create( ARCHIVE_TABLE_SIZE, attach_point );

	mov	eax, DWORD PTR _attach_point$[ebp]
	push	eax
	push	29					; 0000001dH
	call	_hash_create
	add	esp, 8
	mov	DWORD PTR _table$[ebp], eax

; 1107 : 
; 1108 :         strcpy( info.name, attach_point );                /* insert a dummy entry into the global hash table  */

	mov	ecx, DWORD PTR _attach_point$[ebp]
	push	ecx
	lea	edx, DWORD PTR _info$[ebp+36]
	push	edx
	call	_strcpy
	add	esp, 8

; 1109 :         info.attrib = _A_SUBDIR | (unsigned int)FORCE_BIT;

	mov	DWORD PTR _info$[ebp], -2147483632	; 80000010H

; 1110 :         info.time_create = 0;

	xorpd	xmm0, xmm0
	movlpd	QWORD PTR _info$[ebp+8], xmm0

; 1111 :         info.time_access = 0;

	xorpd	xmm0, xmm0
	movlpd	QWORD PTR _info$[ebp+16], xmm0

; 1112 :         info.size = 0;

	mov	DWORD PTR _info$[ebp+32], 0

; 1113 : 
; 1114 :         entry = hash_add( &info, GLOBAL_HASH_TABLE );

	mov	eax, DWORD PTR _GLOBAL_HASH_TABLE
	push	eax
	lea	ecx, DWORD PTR _info$[ebp]
	push	ecx
	call	_hash_add
	add	esp, 8
	mov	DWORD PTR _entry$[ebp], eax

; 1115 : 
; 1116 :         if( !entry ) {

	cmp	DWORD PTR _entry$[ebp], 0
	jne	SHORT $LN7@ResAttach

; 1117 :             SAY_ERROR( RES_ERR_UNKNOWN, "ResAttach" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	1117					; 0000045dH
	push	OFFSET ??_C@_09IPANOAMB@ResAttach?$AA@
	push	-4973					; ffffec93H
	call	__say_error
	add	esp, 16					; 00000010H

; 1118 :             return( -1 );

	or	eax, -1
	jmp	$LN17@ResAttach
$LN7@ResAttach:

; 1119 :         }
; 1120 : 
; 1121 :         entry -> archive       = -1; /* the actual directory existence should not be considered

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+24], -1

; 1122 :                                         as part of the archive.  All of the contents found within
; 1123 :                                         the directory are.   This allows a hard disk based file to
; 1124 :                                         override a zip archive */
; 1125 : 
; 1126 :         entry -> volume = (char)(toupper(attach_point[0]) - 'A');

	mov	eax, 1
	imul	eax, 0
	mov	ecx, DWORD PTR _attach_point$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	push	edx
	call	_toupper
	add	esp, 4
	sub	eax, 65					; 00000041H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	BYTE PTR [ecx+36], al

; 1127 :         entry -> directory = GLOBAL_SEARCH_INDEX;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR _GLOBAL_SEARCH_INDEX
	mov	DWORD PTR [edx+32], eax

; 1128 : 
; 1129 :         GLOBAL_SEARCH_PATH[ GLOBAL_SEARCH_INDEX++ ] = MemStrDup( attach_point );

	mov	ecx, DWORD PTR _attach_point$[ebp]
	push	ecx
	call	_strdup
	add	esp, 4
	mov	edx, DWORD PTR _GLOBAL_SEARCH_INDEX
	mov	DWORD PTR _GLOBAL_SEARCH_PATH[edx*4], eax
	mov	eax, DWORD PTR _GLOBAL_SEARCH_INDEX
	add	eax, 1
	mov	DWORD PTR _GLOBAL_SEARCH_INDEX, eax

; 1130 :         GLOBAL_PATH_LIST = LIST_APPEND( GLOBAL_PATH_LIST, table );

	mov	ecx, DWORD PTR _table$[ebp]
	push	ecx
	mov	edx, DWORD PTR _GLOBAL_PATH_LIST
	push	edx
	call	_ListAppend
	add	esp, 8
	mov	DWORD PTR _GLOBAL_PATH_LIST, eax

; 1131 :         strcpy( GLOBAL_CURRENT_PATH, attach_point );

	mov	eax, DWORD PTR _attach_point$[ebp]
	push	eax
	push	OFFSET _GLOBAL_CURRENT_PATH
	call	_strcpy
	add	esp, 8

; 1132 : 
; 1133 :         entry -> dir = table;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR _table$[ebp]
	mov	DWORD PTR [ecx+40], edx
$LN9@ResAttach:

; 1134 :     }
; 1135 : #endif /* RES_ALLOW_ALIAS */
; 1136 :     archive = archive_create( attach_point, filename, (HASH_TABLE *)entry -> dir, replace_flag );

	mov	eax, DWORD PTR _replace_flag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _attach_point$[ebp]
	push	ecx
	call	_archive_create
	add	esp, 16					; 00000010H
	mov	DWORD PTR _archive$[ebp], eax

; 1137 : #else  /* RES_FLAT_MODEL  */
; 1138 :     archive = archive_create( attach_point, filename, GLOBAL_HASH_TABLE, replace_flag );
; 1139 : #endif /* RES_FLAT_MODEL  */
; 1140 : 
; 1141 :     if( !archive ) {

	cmp	DWORD PTR _archive$[ebp], 0
	jne	SHORT $LN6@ResAttach

; 1142 :         SAY_ERROR( RES_ERR_CANT_OPEN_ARCHIVE, filename );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	1142					; 00000476H
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	push	-4975					; ffffec91H
	call	__say_error
	add	esp, 16					; 00000010H

; 1143 :         return( -1 );

	or	eax, -1
	jmp	$LN17@ResAttach
$LN6@ResAttach:

; 1144 :     }
; 1145 : 
; 1146 :     for( i=0; i<(GLOBAL_SEARCH_INDEX-1); i++ ) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN5@ResAttach
$LN4@ResAttach:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN5@ResAttach:
	mov	ecx, DWORD PTR _GLOBAL_SEARCH_INDEX
	sub	ecx, 1
	cmp	DWORD PTR _i$[ebp], ecx
	jge	SHORT $LN3@ResAttach

; 1147 :         if( !stricmp( GLOBAL_SEARCH_PATH[i], attach_point )) {

	mov	edx, DWORD PTR _attach_point$[ebp]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _GLOBAL_SEARCH_PATH[eax*4]
	push	ecx
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN2@ResAttach

; 1148 : //            archive -> directory = (char)i;   /* GFG */
; 1149 :             archive -> directory = (char)(i);     /* GFG */

	mov	edx, DWORD PTR _archive$[ebp]
	mov	al, BYTE PTR _i$[ebp]
	mov	BYTE PTR [edx+273], al

; 1150 :             break;

	jmp	SHORT $LN3@ResAttach
$LN2@ResAttach:

; 1151 :         }
; 1152 :     }

	jmp	SHORT $LN4@ResAttach
$LN3@ResAttach:

; 1153 : 
; 1154 :     if( i == GLOBAL_SEARCH_INDEX )

	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _GLOBAL_SEARCH_INDEX
	jne	SHORT $LN1@ResAttach

; 1155 :         DebugBreak();

	call	DWORD PTR __imp__DebugBreak@0
$LN1@ResAttach:

; 1156 : 
; 1157 :     ARCHIVE_LIST = LIST_APPEND( ARCHIVE_LIST, archive );

	mov	edx, DWORD PTR _archive$[ebp]
	push	edx
	mov	eax, DWORD PTR _ARCHIVE_LIST
	push	eax
	call	_ListAppend
	add	esp, 8
	mov	DWORD PTR _ARCHIVE_LIST, eax

; 1158 : 
; 1159 :     return( archive -> os_handle );

	mov	ecx, DWORD PTR _archive$[ebp]
	mov	eax, DWORD PTR [ecx+260]
$LN17@ResAttach:

; 1160 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_ResAttach ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_list$ = -4						; size = 4
_archive$ = 8						; size = 4
_volume$ = 12						; size = 4
_directory$ = 16					; size = 4
_filename$ = 20						; size = 4
_ResPurge PROC

; 4194 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 4195 :     LIST * list;
; 4196 : 
; 4197 :     if( !archive && !volume && !directory && !filename ) {

	cmp	DWORD PTR _archive$[ebp], 0
	jne	SHORT $LN5@ResPurge
	cmp	DWORD PTR _volume$[ebp], 0
	jne	SHORT $LN5@ResPurge
	cmp	DWORD PTR _directory$[ebp], 0
	jne	SHORT $LN5@ResPurge
	cmp	DWORD PTR _filename$[ebp], 0
	jne	SHORT $LN5@ResPurge

; 4198 :         SAY_ERROR( RES_ERR_INCORRECT_PARAMETER, "ResPurge" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	4198					; 00001066H
	push	OFFSET ??_C@_08KJEBKLNA@ResPurge?$AA@
	push	-4998					; ffffec7aH
	call	__say_error
	add	esp, 16					; 00000010H

; 4199 :         return;

	jmp	SHORT $LN6@ResPurge
$LN5@ResPurge:

; 4200 :     }
; 4201 : 
; 4202 :     if( !GLOBAL_PATH_LIST )

	cmp	DWORD PTR _GLOBAL_PATH_LIST, 0
	jne	SHORT $LN4@ResPurge

; 4203 :         return;

	jmp	SHORT $LN6@ResPurge
$LN4@ResPurge:

; 4204 : 
; 4205 :     for( list = GLOBAL_PATH_LIST; list; list = list -> next )

	mov	eax, DWORD PTR _GLOBAL_PATH_LIST
	mov	DWORD PTR _list$[ebp], eax
	jmp	SHORT $LN3@ResPurge
$LN2@ResPurge:
	mov	ecx, DWORD PTR _list$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _list$[ebp], edx
$LN3@ResPurge:
	cmp	DWORD PTR _list$[ebp], 0
	je	SHORT $LN6@ResPurge

; 4206 :         hash_purge((HASH_TABLE*)list -> node, archive, volume, directory, filename );

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _directory$[ebp]
	push	ecx
	mov	edx, DWORD PTR _volume$[ebp]
	push	edx
	mov	eax, DWORD PTR _archive$[ebp]
	push	eax
	mov	ecx, DWORD PTR _list$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_hash_purge
	add	esp, 20					; 00000014H
	jmp	SHORT $LN2@ResPurge
$LN6@ResPurge:

; 4207 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ResPurge ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_device_id$ = 8						; size = 4
_dev$ = 12						; size = 4
_ResDevice PROC

; 1177 : {

	push	ebp
	mov	ebp, esp

; 1178 : #if( RES_DEBUG_PARAMS )
; 1179 :     if( device_id < 0 || device_id > MAX_DEVICES || !dev ) {

	cmp	DWORD PTR _device_id$[ebp], 0
	jl	SHORT $LN1@ResDevice
	cmp	DWORD PTR _device_id$[ebp], 26		; 0000001aH
	jg	SHORT $LN1@ResDevice
	cmp	DWORD PTR _dev$[ebp], 0
	jne	SHORT $LN2@ResDevice
$LN1@ResDevice:

; 1180 :         SAY_ERROR( RES_ERR_INCORRECT_PARAMETER, "ResDevice" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	1180					; 0000049cH
	push	OFFSET ??_C@_09BPGFBLJK@ResDevice?$AA@
	push	-4998					; ffffec7aH
	call	__say_error
	add	esp, 16					; 00000010H

; 1181 :         return( FALSE );

	xor	eax, eax
	jmp	SHORT $LN3@ResDevice
$LN2@ResDevice:

; 1182 :     }
; 1183 : #endif /* RES_DEBUG_PARAMS */
; 1184 : 
; 1185 :     memcpy( dev, (void *)&RES_DEVICES[device_id], sizeof( DEVICE_ENTRY ));

	push	40					; 00000028H
	mov	eax, DWORD PTR _device_id$[ebp]
	imul	eax, 40					; 00000028H
	add	eax, DWORD PTR _RES_DEVICES
	push	eax
	mov	ecx, DWORD PTR _dev$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1186 : 
; 1187 :     return( TRUE );

	mov	eax, 1
$LN3@ResDevice:

; 1188 : }

	pop	ebp
	ret	0
_ResDevice ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_long2$ = -68						; size = 4
_long1$ = -64						; size = 4
_drive$ = -60						; size = 4
_retval$ = -56						; size = 4
_root$ = -52						; size = 4
_serial$ = -48						; size = 4
_dev$ = -44						; size = 4
_name$ = -40						; size = 26
_dummy$ = -12						; size = 6
__$ArrayPad$ = -4					; size = 4
_device$ = 8						; size = 4
_ResCheckMedia PROC

; 939  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 940  :     int  drive;
; 941  :     int  retval = 1;

	mov	DWORD PTR _retval$[ebp], 1

; 942  :     char root[] = "C:\\";

	mov	eax, DWORD PTR ??_C@_03GIOIKFCO@C?3?2?$AA@
	mov	DWORD PTR _root$[ebp], eax

; 943  :     char name[26],
; 944  :          dummy[6];          /* possible bug in GetVolumeInformation */
; 945  : 
; 946  :     unsigned long serial,
; 947  :                   long1,    /* possible bug in GetVolumeInformation */
; 948  :                   long2;    /* possible bug in GetVolumeInformation */
; 949  : 
; 950  :     DEVICE_ENTRY * dev;
; 951  : 
; 952  : #if( RES_DEBUG_PARAMS )
; 953  :     if( device < 0 || device > MAX_DEVICES ) {

	cmp	DWORD PTR _device$[ebp], 0
	jl	SHORT $LN6@ResCheckMe
	cmp	DWORD PTR _device$[ebp], 26		; 0000001aH
	jle	SHORT $LN7@ResCheckMe
$LN6@ResCheckMe:

; 954  :         SAY_ERROR( RES_ERR_INCORRECT_PARAMETER, "ResCheckMedia (use ordinals)" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	954					; 000003baH
	push	OFFSET ??_C@_0BN@IAPPECNM@ResCheckMedia?5?$CIuse?5ordinals?$CJ?$AA@
	push	-4998					; ffffec7aH
	call	__say_error
	add	esp, 16					; 00000010H

; 955  :         return( -1 );

	or	eax, -1
	jmp	$LN8@ResCheckMe
$LN7@ResCheckMe:

; 956  :     }
; 957  : #endif /* RES_DEBUG_PARAMS */
; 958  : 
; 959  :     drive = _getdrive();

	call	__getdrive
	mov	DWORD PTR _drive$[ebp], eax

; 960  : 
; 961  :     if( _chdrive( device + 1 ))

	mov	ecx, DWORD PTR _device$[ebp]
	add	ecx, 1
	push	ecx
	call	__chdrive
	add	esp, 4
	test	eax, eax
	je	SHORT $LN5@ResCheckMe

; 962  :         return( -1 );

	or	eax, -1
	jmp	$LN8@ResCheckMe
$LN5@ResCheckMe:

; 963  : 
; 964  :     _chdrive(drive);

	mov	edx, DWORD PTR _drive$[ebp]
	push	edx
	call	__chdrive
	add	esp, 4

; 965  : 
; 966  :     dev = &RES_DEVICES[ device ];

	mov	eax, DWORD PTR _device$[ebp]
	imul	eax, 40					; 00000028H
	add	eax, DWORD PTR _RES_DEVICES
	mov	DWORD PTR _dev$[ebp], eax

; 967  :     root[0] = (char)(device + 'A');

	mov	ecx, DWORD PTR _device$[ebp]
	add	ecx, 65					; 00000041H
	mov	edx, 1
	imul	edx, 0
	mov	BYTE PTR _root$[ebp+edx], cl

; 968  : 
; 969  :     if( GetVolumeInformation( root, name, 22, &serial, &long1, &long2, dummy, 5 )) {

	push	5
	lea	eax, DWORD PTR _dummy$[ebp]
	push	eax
	lea	ecx, DWORD PTR _long2$[ebp]
	push	ecx
	lea	edx, DWORD PTR _long1$[ebp]
	push	edx
	lea	eax, DWORD PTR _serial$[ebp]
	push	eax
	push	22					; 00000016H
	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	lea	edx, DWORD PTR _root$[ebp]
	push	edx
	call	DWORD PTR __imp__GetVolumeInformationA@32
	test	eax, eax
	je	SHORT $LN4@ResCheckMe

; 970  :         if( strcmp( name, dev -> name ) || ( serial != dev -> serial )) {

	mov	eax, DWORD PTR _dev$[ebp]
	add	eax, 2
	push	eax
	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN2@ResCheckMe
	mov	edx, DWORD PTR _dev$[ebp]
	mov	eax, DWORD PTR _serial$[ebp]
	cmp	eax, DWORD PTR [edx+36]
	je	SHORT $LN3@ResCheckMe
$LN2@ResCheckMe:

; 971  :             strcpy( dev -> name, name );

	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dev$[ebp]
	add	edx, 2
	push	edx
	call	_strcpy
	add	esp, 8

; 972  :             dev -> serial = serial;

	mov	eax, DWORD PTR _dev$[ebp]
	mov	ecx, DWORD PTR _serial$[ebp]
	mov	DWORD PTR [eax+36], ecx

; 973  :             IF_DEBUG( LOG( "Media has changed on volume %s\n", root ));
; 974  : 
; 975  :             SHOULD_I_CALL_WITH( CALLBACK_SWAP_CD, GLOBAL_CURRENT_CD, retval );

	mov	edx, 4
	shl	edx, 0
	cmp	DWORD PTR _RES_CALLBACK[edx], 0
	je	SHORT $LN1@ResCheckMe
	mov	eax, DWORD PTR _GLOBAL_CURRENT_CD
	push	eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _RES_CALLBACK[ecx]
	call	edx
	add	esp, 4
	mov	DWORD PTR _retval$[ebp], eax
$LN1@ResCheckMe:

; 976  : 
; 977  :             return(0);

	xor	eax, eax
	jmp	SHORT $LN8@ResCheckMe
$LN3@ResCheckMe:

; 978  :         }
; 979  : 
; 980  :         return(1);

	mov	eax, 1
	jmp	SHORT $LN8@ResCheckMe
$LN4@ResCheckMe:

; 981  :     }
; 982  : 
; 983  :     IF_DEBUG( LOG( "Could not read media on volume %s\n", root ));
; 984  :     return( -1 );

	or	eax, -1
$LN8@ResCheckMe:

; 985  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_ResCheckMedia ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_dir$ = -16						; size = 4
_hit$ = -12						; size = 4
_list$ = -8						; size = 4
_archive$ = -4						; size = 4
_ResDismountCD PROC

; 882  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 883  :     ARCHIVE    * archive;
; 884  :     LIST       * list;
; 885  :     int          hit;
; 886  :     int         dir;   /* GFG change from char to int */
; 887  : 
; 888  :     if( GLOBAL_CD_DEVICE == -1 )

	cmp	DWORD PTR _GLOBAL_CD_DEVICE, -1
	jne	SHORT $LN9@ResDismoun

; 889  :         return( FALSE );

	xor	eax, eax
	jmp	$LN10@ResDismoun
$LN9@ResDismoun:

; 890  : 
; 891  :     if( ARCHIVE_LIST ) {

	cmp	DWORD PTR _ARCHIVE_LIST, 0
	je	$LN8@ResDismoun
$LN7@ResDismoun:

; 892  : 
; 893  :         do {
; 894  :     
; 895  :             hit = 0;

	mov	DWORD PTR _hit$[ebp], 0

; 896  : 
; 897  :             for( list = ARCHIVE_LIST; list; list = list -> next ) {

	mov	eax, DWORD PTR _ARCHIVE_LIST
	mov	DWORD PTR _list$[ebp], eax
	jmp	SHORT $LN4@ResDismoun
$LN3@ResDismoun:
	mov	ecx, DWORD PTR _list$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _list$[ebp], edx
$LN4@ResDismoun:
	cmp	DWORD PTR _list$[ebp], 0
	je	SHORT $LN6@ResDismoun

; 898  :                 archive = (ARCHIVE *)list -> node;

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _archive$[ebp], ecx

; 899  : 
; 900  :                 if( archive -> volume == (char)GLOBAL_CD_DEVICE ) {

	mov	edx, DWORD PTR _archive$[ebp]
	movsx	eax, BYTE PTR [edx+272]
	movsx	ecx, BYTE PTR _GLOBAL_CD_DEVICE
	cmp	eax, ecx
	jne	SHORT $LN1@ResDismoun

; 901  :                     REQUEST_LOCK( archive -> lock );

	push	-1
	mov	edx, DWORD PTR _archive$[ebp]
	mov	eax, DWORD PTR [edx+276]
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8

; 902  :                     dir = archive -> directory;

	mov	ecx, DWORD PTR _archive$[ebp]
	movsx	edx, BYTE PTR [ecx+273]
	mov	DWORD PTR _dir$[ebp], edx

; 903  :                     ResDetach( archive -> os_handle );

	mov	eax, DWORD PTR _archive$[ebp]
	mov	ecx, DWORD PTR [eax+260]
	push	ecx
	call	_ResDetach
	add	esp, 4

; 904  :                     ResPurge( NULL, NULL, &dir, NULL );

	push	0
	lea	edx, DWORD PTR _dir$[ebp]
	push	edx
	push	0
	push	0
	call	_ResPurge
	add	esp, 16					; 00000010H

; 905  :                     hit = 1;

	mov	DWORD PTR _hit$[ebp], 1

; 906  :                     RELEASE_LOCK( archive -> lock );

	mov	eax, DWORD PTR _archive$[ebp]
	mov	ecx, DWORD PTR [eax+276]
	push	ecx
	call	DWORD PTR __imp__ReleaseMutex@4

; 907  :                     break;

	jmp	SHORT $LN6@ResDismoun
$LN1@ResDismoun:

; 908  :                 }
; 909  :             }

	jmp	$LN3@ResDismoun
$LN6@ResDismoun:

; 910  : 
; 911  :         } while( hit );

	cmp	DWORD PTR _hit$[ebp], 0
	jne	$LN7@ResDismoun
$LN8@ResDismoun:

; 912  :     }
; 913  : 
; 914  : 
; 915  :     ResPurge( NULL, (char *)&GLOBAL_CD_DEVICE, NULL, NULL );

	push	0
	push	0
	push	OFFSET _GLOBAL_CD_DEVICE
	push	0
	call	_ResPurge
	add	esp, 16					; 00000010H

; 916  : 
; 917  :     return( TRUE );

	mov	eax, 1
$LN10@ResDismoun:

; 918  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ResDismountCD ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_resynch$ = -8						; size = 4
_retval$ = -4						; size = 4
_cd_number$ = 8						; size = 4
_device$ = 12						; size = 4
_ResMountCD PROC

; 824  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 825  :     int resynch = FALSE;

	mov	DWORD PTR _resynch$[ebp], 0

; 826  :     int retval = 1;

	mov	DWORD PTR _retval$[ebp], 1

; 827  : 
; 828  :     IF_LOG( LOG( "mounted cd %d\n", cd_number ));
; 829  : 
; 830  : #if( RES_DEBUG_PARAMS )   /* parameter checking only with debug version */
; 831  :   
; 832  :     if( cd_number < 1 || cd_number > MAX_CD )

	cmp	DWORD PTR _cd_number$[ebp], 1
	jl	SHORT $LN8@ResMountCD
	cmp	DWORD PTR _cd_number$[ebp], 2
	jle	SHORT $LN9@ResMountCD
$LN8@ResMountCD:

; 833  :         SHOULD_I_CALL_WITH( CALLBACK_UNKNOWN_CD, RES_ERR_ILLEGAL_CD, retval );

	mov	eax, 4
	imul	eax, 0
	cmp	DWORD PTR _RES_CALLBACK[eax], 0
	je	SHORT $LN9@ResMountCD
	push	-4995					; ffffec7dH
	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _RES_CALLBACK[ecx]
	call	edx
	add	esp, 4
	mov	DWORD PTR _retval$[ebp], eax
$LN9@ResMountCD:

; 834  : 
; 835  :     if( !retval ) 

	cmp	DWORD PTR _retval$[ebp], 0
	jne	SHORT $LN6@ResMountCD

; 836  :         return( FALSE );

	xor	eax, eax
	jmp	$LN10@ResMountCD
$LN6@ResMountCD:

; 837  : 
; 838  : #endif
; 839  : 
; 840  :     GLOBAL_CD_DEVICE = device;

	mov	eax, DWORD PTR _device$[ebp]
	mov	DWORD PTR _GLOBAL_CD_DEVICE, eax

; 841  : 
; 842  :     if( GLOBAL_CURRENT_CD != cd_number )  /* we need this flag later */

	mov	ecx, DWORD PTR _GLOBAL_CURRENT_CD
	cmp	ecx, DWORD PTR _cd_number$[ebp]
	je	SHORT $LN5@ResMountCD

; 843  :         resynch = TRUE;

	mov	DWORD PTR _resynch$[ebp], 1
$LN5@ResMountCD:

; 844  : 
; 845  :     /* has the user installed a handler for swap cd? */
; 846  : 
; 847  :     SHOULD_I_CALL_WITH( CALLBACK_SWAP_CD, cd_number, retval );

	mov	edx, 4
	shl	edx, 0
	cmp	DWORD PTR _RES_CALLBACK[edx], 0
	je	SHORT $LN4@ResMountCD
	mov	eax, DWORD PTR _cd_number$[ebp]
	push	eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _RES_CALLBACK[ecx]
	call	edx
	add	esp, 4
	mov	DWORD PTR _retval$[ebp], eax
$LN4@ResMountCD:

; 848  : 
; 849  :     if( !retval ) 

	cmp	DWORD PTR _retval$[ebp], 0
	jne	SHORT $LN3@ResMountCD

; 850  :         return( FALSE );

	xor	eax, eax
	jmp	SHORT $LN10@ResMountCD
$LN3@ResMountCD:

; 851  : 
; 852  :     GLOBAL_CURRENT_CD = cd_number;

	mov	eax, DWORD PTR _cd_number$[ebp]
	mov	DWORD PTR _GLOBAL_CURRENT_CD, eax

; 853  : 
; 854  :     /* has the user installed a handler for resynch to the new cd? */
; 855  : 
; 856  :     SHOULD_I_CALL_WITH( CALLBACK_RESYNCH_CD, cd_number, retval );

	mov	ecx, 4
	imul	ecx, 3
	cmp	DWORD PTR _RES_CALLBACK[ecx], 0
	je	SHORT $LN2@ResMountCD
	mov	edx, DWORD PTR _cd_number$[ebp]
	push	edx
	mov	eax, 4
	imul	eax, 3
	mov	ecx, DWORD PTR _RES_CALLBACK[eax]
	call	ecx
	add	esp, 4
	mov	DWORD PTR _retval$[ebp], eax
$LN2@ResMountCD:

; 857  : 
; 858  :     if( !retval ) 

	cmp	DWORD PTR _retval$[ebp], 0
	jne	SHORT $LN1@ResMountCD

; 859  :         return( FALSE );

	xor	eax, eax
	jmp	SHORT $LN10@ResMountCD
$LN1@ResMountCD:

; 860  : 
; 861  :     /* haven't failed so far... */
; 862  : 
; 863  :     return( TRUE );

	mov	eax, 1
$LN10@ResMountCD:

; 864  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ResMountCD ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_ResExit PROC

; 772  : {

	push	ebp
	mov	ebp, esp

; 773  :     IF_LOG( LOG( "Resource Manager Exiting.\n" ));
; 774  : 
; 775  : #if (RES_MULTITHREAD)
; 776  :    if(GLOCK) DESTROY_LOCK(GLOCK);   

	cmp	DWORD PTR _GLOCK, 0
	je	SHORT $LN2@ResExit
	mov	eax, DWORD PTR _GLOCK
	push	eax
	call	DWORD PTR __imp__CloseHandle@4
$LN2@ResExit:

; 777  :    GLOCK = 0;

	mov	DWORD PTR _GLOCK, 0

; 778  : #endif
; 779  : 
; 780  :     shut_down();

	call	_shut_down

; 781  : 
; 782  :     /* Restore original drive.*/
; 783  : 
; 784  :     _chdrive( GLOBAL_INIT_DRIVE );

	mov	ecx, DWORD PTR _GLOBAL_INIT_DRIVE
	push	ecx
	call	__chdrive
	add	esp, 4

; 785  :     _chdir( GLOBAL_INIT_PATH );

	push	OFFSET _GLOBAL_INIT_PATH
	call	__chdir
	add	esp, 4

; 786  : 
; 787  : #if( RES_DEBUG_VERSION )
; 788  :     if( RES_DEBUG_LOGGING )

	cmp	DWORD PTR _RES_DEBUG_LOGGING, 0
	je	SHORT $LN3@ResExit

; 789  :         ResDbgLogClose();

	call	_ResDbgLogClose
$LN3@ResExit:

; 790  : 
; 791  : #   if( USE_MEMMGR )
; 792  :         MemSanity();
; 793  : #   endif /* USE_MEMMGR */
; 794  : 
; 795  : #endif /*RES_DEBUG_VERSION */
; 796  : 
; 797  : 	#if USE_SH_POOLS
; 798  : 	if ( gResmgrMemPool != NULL )
; 799  : 	{
; 800  : 		MemPoolFree( gResmgrMemPool );
; 801  : 		gResmgrMemPool = NULL;
; 802  : 	}
; 803  : 	#endif
; 804  : }

	pop	ebp
	ret	0
_ResExit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
_file$ = -288						; size = 4
_length$ = -284						; size = 4
_index$ = -280						; size = 4
_root$ = -276						; size = 4
_drive$ = -272						; size = 4
_dev$ = -268						; size = 4
_string$ = -264						; size = 260
__$ArrayPad$ = -4					; size = 4
_hwnd$ = 8						; size = 4
_ResInit PROC

; 585  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 288				; 00000120H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 586  :     DEVICE_ENTRY * dev;
; 587  : 
; 588  :     unsigned long  length,
; 589  :                    file;
; 590  : 
; 591  :     int            drive,
; 592  :                    index;
; 593  : 
; 594  :     char root[] = "C:\\";       /* root dir mask used to query devices     */

	mov	eax, DWORD PTR ??_C@_03GIOIKFCO@C?3?2?$AA@
	mov	DWORD PTR _root$[ebp], eax

; 595  :     char string[_MAX_PATH];     /* dummy string to fill out parameter list */
; 596  : 
; 597  : 	#if USE_SH_POOLS
; 598  : 	if ( gResmgrMemPool == NULL )
; 599  : 	{
; 600  : 		gResmgrMemPool = MemPoolInit( 0 );
; 601  : 	}
; 602  : 	#endif
; 603  : 
; 604  :          
; 605  :     /* if the user is calling ResInit to re-initialize the resource manager
; 606  :        (since this is allowable), we need to free up any previous allocations. */
; 607  : 
; 608  :     if( !RESMGR_INIT ) {

	cmp	DWORD PTR _RESMGR_INIT, 0
	jne	SHORT $LN17@ResInit

; 609  :         memset( GLOBAL_SEARCH_PATH, 0, sizeof(GLOBAL_SEARCH_PATH));

	push	1000					; 000003e8H
	push	0
	push	OFFSET _GLOBAL_SEARCH_PATH
	call	_memset
	add	esp, 12					; 0000000cH

; 610  :         memset( RES_PATH, 0, sizeof(char*) * RES_DIR_LAST );   /* reset system paths */

	push	68					; 00000044H
	push	0
	push	OFFSET _RES_PATH
	call	_memset
	add	esp, 12					; 0000000cH

; 611  :         GLOBAL_SEARCH_INDEX = 0;

	mov	DWORD PTR _GLOBAL_SEARCH_INDEX, 0
$LN17@ResInit:

; 612  :     }
; 613  : 
; 614  :     shut_down();

	call	_shut_down

; 615  : 
; 616  :     RES_GLOBAL_HWND = hwnd;

	mov	ecx, DWORD PTR _hwnd$[ebp]
	mov	DWORD PTR _RES_GLOBAL_HWND, ecx

; 617  : 
; 618  : 	#ifdef USE_SH_POOLS
; 619  :     FILE_HANDLES = (FILE_ENTRY *)MemAllocPtr( gResmgrMemPool, sizeof(FILE_ENTRY) * MAX_FILE_HANDLES, 0 );
; 620  : 	#else
; 621  :     FILE_HANDLES = (FILE_ENTRY *)MemMalloc( sizeof(FILE_ENTRY) * MAX_FILE_HANDLES, "File handles" );

	push	13312					; 00003400H
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _FILE_HANDLES, eax

; 622  : 	#endif
; 623  : 
; 624  :     if( !FILE_HANDLES ) {

	cmp	DWORD PTR _FILE_HANDLES, 0
	jne	SHORT $LN16@ResInit

; 625  :         SAY_ERROR( RES_ERR_NO_MEMORY, "ResInit" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	625					; 00000271H
	push	OFFSET ??_C@_07FLKJDOFF@ResInit?$AA@
	push	-4999					; ffffec79H
	call	__say_error
	add	esp, 16					; 00000010H

; 626  :         return( FALSE );

	xor	eax, eax
	jmp	$LN18@ResInit
$LN16@ResInit:

; 627  :     }
; 628  :     
; 629  :     memset( FILE_HANDLES, 0, sizeof( FILE_ENTRY ) * MAX_FILE_HANDLES );

	push	13312					; 00003400H
	push	0
	mov	edx, DWORD PTR _FILE_HANDLES
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 630  : 
; 631  :     for( index = 0; index < MAX_FILE_HANDLES; index++ )

	mov	DWORD PTR _index$[ebp], 0
	jmp	SHORT $LN15@ResInit
$LN14@ResInit:
	mov	eax, DWORD PTR _index$[ebp]
	add	eax, 1
	mov	DWORD PTR _index$[ebp], eax
$LN15@ResInit:
	cmp	DWORD PTR _index$[ebp], 256		; 00000100H
	jge	SHORT $LN13@ResInit

; 632  :         FILE_HANDLES[ index ].os_handle = -1;

	mov	ecx, DWORD PTR _index$[ebp]
	imul	ecx, 52					; 00000034H
	mov	edx, DWORD PTR _FILE_HANDLES
	mov	DWORD PTR [edx+ecx], -1
	jmp	SHORT $LN14@ResInit
$LN13@ResInit:

; 633  : 
; 634  : 
; 635  :     /* Save current drive. */
; 636  : 
; 637  :     GLOBAL_INIT_DRIVE = _getdrive();

	call	__getdrive
	mov	DWORD PTR _GLOBAL_INIT_DRIVE, eax

; 638  :     _getdcwd( GLOBAL_INIT_DRIVE, GLOBAL_INIT_PATH, _MAX_PATH );

	push	260					; 00000104H
	push	OFFSET _GLOBAL_INIT_PATH
	mov	eax, DWORD PTR _GLOBAL_INIT_DRIVE
	push	eax
	call	__getdcwd
	add	esp, 12					; 0000000cH

; 639  : 
; 640  :     RES_PATH[ RES_DIR_CURR ] = MemStrDup( GLOBAL_INIT_PATH );

	push	OFFSET _GLOBAL_INIT_PATH
	call	_strdup
	add	esp, 4
	mov	ecx, 4
	imul	ecx, 3
	mov	DWORD PTR _RES_PATH[ecx], eax

; 641  : 
; 642  : 
; 643  :     /* -------------------------------------------------------------
; 644  : 
; 645  :         Minimal Hardware Query
; 646  : 
; 647  :        -------------------------------------------------------------
; 648  : 
; 649  :         We determine all devices in the host machine and store the
; 650  :         volume name and volume serial number of the media that is
; 651  :         current mounted on that device.  It there is ever a read
; 652  :         failure, or ResCheckMedia is explicitly called, we use 
; 653  :         this information to determine if the end-user has swapped
; 654  :         the media without our knowledge.
; 655  : 
; 656  :         Since it's not unimagineable that a user that is attached
; 657  :         to a LAN has all his drive letters mapped to network drives,
; 658  :         or, that under Win95 his CD letter is towards the high end
; 659  :         of the alphabet because of network drives, it is recommended
; 660  :         that you use 26 as the value for MAX_DEVICES.  It's not
; 661  :         very much memory to give up, and you may be glad you did.
; 662  :        ------------------------------------------------------------- */
; 663  : 
; 664  : 
; 665  :     GLOBAL_VOLUME_MASK = 0;

	mov	DWORD PTR _GLOBAL_VOLUME_MASK, 0

; 666  : 
; 667  : #if 0
; 668  :     for( drive = 1; drive <= MAX_DEVICES; drive++ ) {
; 669  :         /* If we can switch to the drive, it exists. - not if there is a seriously
; 670  :            damaged floppy in the drive, it is possible to crash VxD HFLOP just by
; 671  :            switching to the device.  Of course, for this case, anytime the user
; 672  :            double clicks on the floppy icon from the desktop will also cause this
; 673  :            crash.  Caveat Emptor.   */
; 674  :         if( !_chdrive( drive ))
; 675  :         {
; 676  :             GLOBAL_VOLUME_MASK |= (1<<drive);
; 677  :         }
; 678  :      }
; 679  : #endif
; 680  : 
; 681  :     GLOBAL_VOLUME_MASK = GetLogicalDrives();

	call	DWORD PTR __imp__GetLogicalDrives@0
	mov	DWORD PTR _GLOBAL_VOLUME_MASK, eax

; 682  :     GLOBAL_VOLUME_MASK <<= 1; /* 1 is drive A in ResMgr, GetLogicalDrives returns A equals 0 */

	mov	edx, DWORD PTR _GLOBAL_VOLUME_MASK
	shl	edx, 1
	mov	DWORD PTR _GLOBAL_VOLUME_MASK, edx

; 683  : 
; 684  : 	#ifdef USE_SH_POOLS
; 685  :     RES_DEVICES = (DEVICE_ENTRY *)MemAllocPtr( gResmgrMemPool, MAX_DEVICES * sizeof( DEVICE_ENTRY ), 0 );
; 686  : 	#else
; 687  :     RES_DEVICES = (DEVICE_ENTRY *)MemMalloc( MAX_DEVICES * sizeof( DEVICE_ENTRY ), "Devices" );

	push	1040					; 00000410H
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _RES_DEVICES, eax

; 688  : 	#endif
; 689  :     if( !RES_DEVICES ) {

	cmp	DWORD PTR _RES_DEVICES, 0
	jne	SHORT $LN12@ResInit

; 690  :         SAY_ERROR( RES_ERR_NO_MEMORY, "ResInit" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	690					; 000002b2H
	push	OFFSET ??_C@_07FLKJDOFF@ResInit?$AA@
	push	-4999					; ffffec79H
	call	__say_error
	add	esp, 16					; 00000010H

; 691  :         return( FALSE );

	xor	eax, eax
	jmp	$LN18@ResInit
$LN12@ResInit:

; 692  :     }
; 693  : 
; 694  :     GLOBAL_CD_DEVICE = -1;

	mov	DWORD PTR _GLOBAL_CD_DEVICE, -1

; 695  : 
; 696  :     for( drive = 1; drive <= MAX_DEVICES; drive++ ) {

	mov	DWORD PTR _drive$[ebp], 1
	jmp	SHORT $LN11@ResInit
$LN10@ResInit:
	mov	eax, DWORD PTR _drive$[ebp]
	add	eax, 1
	mov	DWORD PTR _drive$[ebp], eax
$LN11@ResInit:
	cmp	DWORD PTR _drive$[ebp], 26		; 0000001aH
	jg	$LN9@ResInit

; 697  :         dev = &RES_DEVICES[drive-1];

	mov	ecx, DWORD PTR _drive$[ebp]
	sub	ecx, 1
	imul	ecx, 40					; 00000028H
	add	ecx, DWORD PTR _RES_DEVICES
	mov	DWORD PTR _dev$[ebp], ecx

; 698  : 
; 699  :         if( GLOBAL_VOLUME_MASK & ((char)(1<<drive))) {

	mov	edx, 1
	mov	ecx, DWORD PTR _drive$[ebp]
	shl	edx, cl
	movsx	eax, dl
	and	eax, DWORD PTR _GLOBAL_VOLUME_MASK
	je	$LN8@ResInit

; 700  :             root[0] = (char)('A' + (drive-1));

	mov	ecx, DWORD PTR _drive$[ebp]
	add	ecx, 64					; 00000040H
	mov	edx, 1
	imul	edx, 0
	mov	BYTE PTR _root$[ebp+edx], cl

; 701  : 
; 702  :             /* According to Microsoft, most of the parameters to GetVolumeInformation are optional, however
; 703  :                this is not the case.  It is possible to completely destroy the file system on a floppy
; 704  :                diskette by calling this seemingly innocuous function without all of the parameters! */
; 705  : 
; 706  :             dev -> type = (char)(GetDriveType( root ));

	lea	eax, DWORD PTR _root$[ebp]
	push	eax
	call	DWORD PTR __imp__GetDriveTypeA@4
	mov	ecx, DWORD PTR _dev$[ebp]
	mov	BYTE PTR [ecx+1], al

; 707  :             dev -> letter = root[0];

	mov	edx, 1
	imul	edx, 0
	mov	eax, DWORD PTR _dev$[ebp]
	mov	cl, BYTE PTR _root$[ebp+edx]
	mov	BYTE PTR [eax], cl

; 708  :             
; 709  :             if((dev -> type == DRIVE_FIXED) ||
; 710  :                (dev -> type == DRIVE_CDROM) ||
; 711  :                (dev -> type == DRIVE_RAMDISK)) {

	mov	edx, DWORD PTR _dev$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	cmp	eax, 3
	je	SHORT $LN6@ResInit
	mov	ecx, DWORD PTR _dev$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	cmp	edx, 5
	je	SHORT $LN6@ResInit
	mov	eax, DWORD PTR _dev$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 6
	jne	SHORT $LN7@ResInit
$LN6@ResInit:

; 712  : 
; 713  :                 GetVolumeInformation( root, dev -> name, 24, &dev -> serial, &length, &file, string, _MAX_PATH );

	push	260					; 00000104H
	lea	edx, DWORD PTR _string$[ebp]
	push	edx
	lea	eax, DWORD PTR _file$[ebp]
	push	eax
	lea	ecx, DWORD PTR _length$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dev$[ebp]
	add	edx, 36					; 00000024H
	push	edx
	push	24					; 00000018H
	mov	eax, DWORD PTR _dev$[ebp]
	add	eax, 2
	push	eax
	lea	ecx, DWORD PTR _root$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetVolumeInformationA@32

; 714  :             }
; 715  :             else {

	jmp	SHORT $LN5@ResInit
$LN7@ResInit:

; 716  :                 strcpy( dev -> name, "unknown" );

	push	OFFSET ??_C@_07CIFAGBMG@unknown?$AA@
	mov	edx, DWORD PTR _dev$[ebp]
	add	edx, 2
	push	edx
	call	_strcpy
	add	esp, 8

; 717  :                 dev -> serial = 0L;

	mov	eax, DWORD PTR _dev$[ebp]
	mov	DWORD PTR [eax+36], 0
$LN5@ResInit:

; 718  :             }
; 719  : 
; 720  : 
; 721  :             /* Initialize default entries into the system path tables */
; 722  : 
; 723  :             if(( dev -> type == DRIVE_CDROM ) && !RES_PATH[ RES_DIR_CD ])

	mov	ecx, DWORD PTR _dev$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	cmp	edx, 5
	jne	SHORT $LN4@ResInit
	mov	eax, 4
	shl	eax, 2
	cmp	DWORD PTR _RES_PATH[eax], 0
	jne	SHORT $LN4@ResInit

; 724  :             {
; 725  :                 GLOBAL_CD_DEVICE = drive - 1; /* NEED A BETTER WAY!! */

	mov	ecx, DWORD PTR _drive$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _GLOBAL_CD_DEVICE, ecx

; 726  :                 RES_PATH[ RES_DIR_CD ] = MemStrDup( root );

	lea	edx, DWORD PTR _root$[ebp]
	push	edx
	call	_strdup
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 2
	mov	DWORD PTR _RES_PATH[ecx], eax
$LN4@ResInit:

; 727  :             }
; 728  : 
; 729  :             if((drive == 3) && (dev -> type == DRIVE_FIXED))

	cmp	DWORD PTR _drive$[ebp], 3
	jne	SHORT $LN3@ResInit
	mov	edx, DWORD PTR _dev$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	cmp	eax, 3
	jne	SHORT $LN3@ResInit

; 730  :                 RES_PATH[ RES_DIR_HD ] = MemStrDup( root );

	lea	ecx, DWORD PTR _root$[ebp]
	push	ecx
	call	_strdup
	add	esp, 4
	mov	edx, 4
	imul	edx, 5
	mov	DWORD PTR _RES_PATH[edx], eax
$LN3@ResInit:

; 731  :         }
; 732  :         else {

	jmp	SHORT $LN2@ResInit
$LN8@ResInit:

; 733  :             dev -> type = -1;

	mov	eax, DWORD PTR _dev$[ebp]
	mov	BYTE PTR [eax+1], -1

; 734  :             dev -> letter = ASCII_DOT;

	mov	ecx, DWORD PTR _dev$[ebp]
	mov	BYTE PTR [ecx], 46			; 0000002eH

; 735  : 	    strcpy( dev -> name, "unknown" );

	push	OFFSET ??_C@_07CIFAGBMG@unknown?$AA@
	mov	edx, DWORD PTR _dev$[ebp]
	add	edx, 2
	push	edx
	call	_strcpy
	add	esp, 8

; 736  : 	    dev -> serial = 0L;

	mov	eax, DWORD PTR _dev$[ebp]
	mov	DWORD PTR [eax+36], 0
$LN2@ResInit:

; 737  : 
; 738  :         }
; 739  :     }

	jmp	$LN10@ResInit
$LN9@ResInit:

; 740  : 
; 741  :     GetTempPath( _MAX_PATH, string );

	lea	ecx, DWORD PTR _string$[ebp]
	push	ecx
	push	260					; 00000104H
	call	DWORD PTR __imp__GetTempPathA@8

; 742  :     RES_PATH[ RES_DIR_TEMP ] = MemStrDup( string );

	lea	edx, DWORD PTR _string$[ebp]
	push	edx
	call	_strdup
	add	esp, 4
	mov	ecx, 4
	imul	ecx, 6
	mov	DWORD PTR _RES_PATH[ecx], eax

; 743  :     
; 744  : #if (RES_MULTITHREAD)
; 745  :    if(!GLOCK) GLOCK = CREATE_LOCK("multithread");   

	cmp	DWORD PTR _GLOCK, 0
	jne	SHORT $LN1@ResInit
	push	OFFSET ??_C@_0M@CPHMKFFF@multithread?$AA@
	push	0
	push	0
	call	DWORD PTR __imp__CreateMutexA@12
	mov	DWORD PTR _GLOCK, eax
$LN1@ResInit:

; 746  : #endif
; 747  : 
; 748  :     IF_LOG( LOG( "Resource Manager Initialized.\n" ));
; 749  : 
; 750  :     RESMGR_INIT = TRUE; /* reinitialize the statics */

	mov	DWORD PTR _RESMGR_INIT, 1

; 751  : 
; 752  : 
; 753  :     return( TRUE );

	mov	eax, 1
$LN18@ResInit:

; 754  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_ResInit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\resmgr.c
_TEXT	SEGMENT
tv237 = -28						; size = 4
tv213 = -24						; size = 4
_compressed_flag$ = -20					; size = 4
_retval$ = -16						; size = 4
_handle$ = -12						; size = 4
_count$1 = -8						; size = 4
_file$ = -4						; size = 4
_stream$ = 8						; size = 4
__filbuf PROC

; 5392 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 5393 :     int retval = FALSE;     /* used for the callback */

	mov	DWORD PTR _retval$[ebp], 0

; 5394 :     int handle=0;

	mov	DWORD PTR _handle$[ebp], 0

; 5395 : 
; 5396 :     FILE_ENTRY * file = NULL;      /* my file descriptor */

	mov	DWORD PTR _file$[ebp], 0

; 5397 : 
; 5398 :     int compressed_flag = TRUE;

	mov	DWORD PTR _compressed_flag$[ebp], 1

; 5399 : 
; 5400 : 
; 5401 : #if( RES_DEBUG_PARAMS )
; 5402 :     if( !stream ) {

	cmp	DWORD PTR _stream$[ebp], 0
	jne	SHORT $LN22@filbuf

; 5403 :         SAY_ERROR( RES_ERR_INCORRECT_PARAMETER, "_filbuf" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	5403					; 0000151bH
	push	OFFSET ??_C@_07HNDGCFOP@_filbuf?$AA@
	push	-4998					; ffffec7aH
	call	__say_error
	add	esp, 16					; 00000010H

; 5404 :         return( EOF );

	or	eax, -1
	jmp	$LN23@filbuf
$LN22@filbuf:

; 5405 :     }
; 5406 : 
; 5407 :     // if( !(stream -> _flag & ( _IOARCHIVE | _IOLOOSE )) ) {
; 5408 :     //    /* You can actually remove this error trap if you want fopen
; 5409 :     //       as well as ResFOpen */
; 5410 :     //    SAY_ERROR( RES_ERR_UNKNOWN, "Stream not created with ResFOpen!" );
; 5411 :     //    stream -> _flag |= _IOREAD;
; 5412 :     //    return( EOF );
; 5413 :     // }
; 5414 : #endif
; 5415 : 
; 5416 :    //LRKLUDGE
; 5417 :    // If its a string return
; 5418 :    if (!inuse(stream) ||
; 5419 :        ((stream->_flag & _IOSTRG) &&
; 5420 :        !(stream->_flag & (_IOLOOSE | _IOARCHIVE))))

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 131				; 00000083H
	je	SHORT $LN20@filbuf
	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx+12]
	and	eax, 64					; 00000040H
	je	SHORT $LN21@filbuf
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	and	edx, 196608				; 00030000H
	jne	SHORT $LN21@filbuf
$LN20@filbuf:

; 5421 :       return(EOF);

	or	eax, -1
	jmp	$LN23@filbuf
$LN21@filbuf:

; 5422 : 
; 5423 :    /* if stream is opened as WRITE ONLY, set error and return */
; 5424 :     if( stream -> _flag & _IOWRT ) {

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 2
	je	SHORT $LN19@filbuf

; 5425 :         stream -> _flag |= _IOERR;

	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx+12]
	or	eax, 32					; 00000020H
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 5426 :         return( EOF );

	or	eax, -1
	jmp	$LN23@filbuf
$LN19@filbuf:

; 5427 :     }
; 5428 : 
; 5429 :     /* force flag */
; 5430 : 
; 5431 :     stream -> _flag |= _IOREAD;

	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx+12]
	or	eax, 1
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 5432 : 
; 5433 :     /* Get a buffer, if necessary. (taken from _filbuf.c) */
; 5434 : 
; 5435 :     if( !( stream -> _base ))

	mov	edx, DWORD PTR _stream$[ebp]
	cmp	DWORD PTR [edx+8], 0
	jne	SHORT $LN18@filbuf

; 5436 :         _getbuf( stream );

	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	call	__getbuf
	add	esp, 4

; 5437 :     else

	jmp	SHORT $LN17@filbuf
$LN18@filbuf:

; 5438 :         stream -> _ptr = stream -> _base;

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx], eax
$LN17@filbuf:

; 5439 : 
; 5440 :     /* if the callback routine does the fill it should return TRUE,
; 5441 :        designating that this routine can exit immediately */
; 5442 : 
; 5443 :     SHOULD_I_CALL_WITH( CALLBACK_FILL_STREAM, stream, retval );

	mov	ecx, 4
	imul	ecx, 9
	cmp	DWORD PTR _RES_CALLBACK[ecx], 0
	je	SHORT $LN16@filbuf
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, 4
	imul	eax, 9
	mov	ecx, DWORD PTR _RES_CALLBACK[eax]
	call	ecx
	add	esp, 4
	mov	DWORD PTR _retval$[ebp], eax
$LN16@filbuf:

; 5444 : 
; 5445 :     if( retval )

	cmp	DWORD PTR _retval$[ebp], 0
	je	SHORT $LN15@filbuf

; 5446 :         return( 0xff & retval );

	mov	eax, DWORD PTR _retval$[ebp]
	and	eax, 255				; 000000ffH
	jmp	$LN23@filbuf
$LN15@filbuf:

; 5447 : 
; 5448 :     /* READ OR DECOMPRESS ? */
; 5449 : 
; 5450 :     /* if a file is loose on the hard-drive, we will want to replenish
; 5451 :        the buffer by simply reading the file directly.  If a file is
; 5452 :        'stored' (not compressed) within an archive file, we replenish 
; 5453 :        the buffer by seeking within the archive, and then doing a
; 5454 :        simple read.  Finally, if the file is compressed within an 
; 5455 :        archive, we assume we already have a decomressed buffer from
; 5456 :        which to copy bytes. */
; 5457 : 
; 5458 :     if( !(stream -> _flag & _IOARCHIVE)) {

	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx+12]
	and	eax, 65536				; 00010000H
	jne	SHORT $LN14@filbuf

; 5459 :         compressed_flag = FALSE;

	mov	DWORD PTR _compressed_flag$[ebp], 0

; 5460 :         handle = stream -> _file;

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _handle$[ebp], edx

; 5461 :     } else {

	jmp	$LN13@filbuf
$LN14@filbuf:

; 5462 : 
; 5463 :         file = &FILE_HANDLES[ stream -> _file ];

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	imul	ecx, 52					; 00000034H
	add	ecx, DWORD PTR _FILE_HANDLES
	mov	DWORD PTR _file$[ebp], ecx

; 5464 : 
; 5465 : /*        if( file -> current_pos >= file -> size )  was GFG */
; 5466 : 		 if( file -> current_filbuf_pos >= file -> size )

	mov	edx, DWORD PTR _file$[ebp]
	mov	eax, DWORD PTR _file$[ebp]
	mov	ecx, DWORD PTR [edx+44]
	cmp	ecx, DWORD PTR [eax+12]
	jb	SHORT $LN12@filbuf

; 5467 : 		 {
; 5468 :             return(EOF);

	or	eax, -1
	jmp	$LN23@filbuf
$LN12@filbuf:

; 5469 : 		 }
; 5470 : 
; 5471 :         if( file -> os_handle == -1 ) {

	mov	edx, DWORD PTR _file$[ebp]
	cmp	DWORD PTR [edx], -1
	jne	SHORT $LN11@filbuf

; 5472 :             SAY_ERROR( RES_ERR_ILLEGAL_FILE_HANDLE, "_filbuf internal error" );

	push	OFFSET ??_C@_0N@OMEJCDNJ@src?2resmgr?4c?$AA@
	push	5472					; 00001560H
	push	OFFSET ??_C@_0BH@IMBIDIIM@_filbuf?5internal?5error?$AA@
	push	-4977					; ffffec8fH
	call	__say_error
	add	esp, 16					; 00000010H

; 5473 :             stream -> _flag |= _IOERR;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	or	ecx, 32					; 00000020H
	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 5474 :             return( EOF );

	or	eax, -1
	jmp	$LN23@filbuf
$LN11@filbuf:

; 5475 :         }
; 5476 : 
; 5477 :         if( !file -> zip ) {   /* file is just stored */

	mov	eax, DWORD PTR _file$[ebp]
	cmp	DWORD PTR [eax+48], 0
	jne	SHORT $LN10@filbuf

; 5478 :             compressed_flag = FALSE;

	mov	DWORD PTR _compressed_flag$[ebp], 0

; 5479 :             handle = file -> os_handle;

	mov	ecx, DWORD PTR _file$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _handle$[ebp], edx

; 5480 :             //#ifdef _MT
; 5481 :             //    _lseek_lk( handle, (file -> seek_start + file -> current_pos), SEEK_SET );
; 5482 :             //#else
; 5483 :                 lseek( handle, (file -> seek_start + file -> current_pos), SEEK_SET );

	push	0
	mov	eax, DWORD PTR _file$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _file$[ebp]
	add	ecx, DWORD PTR [edx+8]
	push	ecx
	mov	eax, DWORD PTR _handle$[ebp]
	push	eax
	call	_lseek
	add	esp, 12					; 0000000cH

; 5484 :             //#endif
; 5485 :         }
; 5486 :         else {    /* end of file check ? */

	jmp	SHORT $LN13@filbuf
$LN10@filbuf:

; 5487 : 
; 5488 :             int count;
; 5489 : 
; 5490 :             count = stream -> _bufsiz;

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _count$1[ebp], edx

; 5491 : 
; 5492 :             if( count > (int)(file -> size - file -> current_filbuf_pos)) {  /* was current_pos */

	mov	eax, DWORD PTR _file$[ebp]
	mov	ecx, DWORD PTR _file$[ebp]
	mov	edx, DWORD PTR [eax+12]
	sub	edx, DWORD PTR [ecx+44]
	cmp	DWORD PTR _count$1[ebp], edx
	jle	SHORT $LN8@filbuf

; 5493 :                 memset( stream -> _base, 0, stream -> _bufsiz );

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	push	0
	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 5494 :                 count = file -> size - file -> current_filbuf_pos;    /* was current_pos */

	mov	ecx, DWORD PTR _file$[ebp]
	mov	edx, DWORD PTR _file$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+44]
	mov	DWORD PTR _count$1[ebp], eax
$LN8@filbuf:

; 5495 :             }
; 5496 : 
; 5497 :             memcpy( stream -> _base, file -> zip -> out_buffer + file -> current_filbuf_pos, count );/* was current_pos */

	mov	ecx, DWORD PTR _count$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _file$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _file$[ebp]
	add	ecx, DWORD PTR [edx+44]
	push	ecx
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 5498 :             file -> current_filbuf_pos += count;       /* GFG_NOV06 */

	mov	edx, DWORD PTR _file$[ebp]
	mov	eax, DWORD PTR [edx+44]
	add	eax, DWORD PTR _count$1[ebp]
	mov	ecx, DWORD PTR _file$[ebp]
	mov	DWORD PTR [ecx+44], eax

; 5499 :             stream -> _cnt = count;

	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR _count$1[ebp]
	mov	DWORD PTR [edx+4], eax
$LN13@filbuf:

; 5500 :         }
; 5501 :     }
; 5502 : 
; 5503 :     if( !compressed_flag ) {

	cmp	DWORD PTR _compressed_flag$[ebp], 0
	jne	$LN7@filbuf

; 5504 :     
; 5505 :         /* taken (and modified) from the vc++ run-time source file _filbuf.c */
; 5506 : 
; 5507 :         //#ifdef _MT
; 5508 :         //    stream -> _cnt = _read_lk( handle, stream -> _base, stream -> _bufsiz );
; 5509 :         //#else
; 5510 :             stream -> _cnt = _read( handle, stream -> _base, stream -> _bufsiz );

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _handle$[ebp]
	push	edx
	call	__read
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 5511 :         //#endif    
; 5512 :         
; 5513 : 
; 5514 :         if( file ) { /* stored in an archive */

	cmp	DWORD PTR _file$[ebp], 0
	je	SHORT $LN6@filbuf

; 5515 : 
; 5516 :             if( stream -> _cnt < 0 ) {    /* error reading */

	mov	edx, DWORD PTR _stream$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jge	SHORT $LN6@filbuf

; 5517 :                 stream -> _flag |= _IOERR;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	or	ecx, 32					; 00000020H
	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 5518 :                 if( stream -> _flag & (_IOARCHIVE | _IOLOOSE))  /* make sure this is an fopen() file */

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 196608				; 00030000H
	je	SHORT $LN4@filbuf

; 5519 :                     ResCheckMedia( file -> device );            /* if not, has media changed?        */

	mov	edx, DWORD PTR _file$[ebp]
	movsx	eax, BYTE PTR [edx+32]
	push	eax
	call	_ResCheckMedia
	add	esp, 4
$LN4@filbuf:

; 5520 :                 return( EOF );

	or	eax, -1
	jmp	$LN23@filbuf
$LN6@filbuf:

; 5521 :             }
; 5522 : /****    GFG_NOV06         
; 5523 :             else
; 5524 :                 file -> current_pos += stream -> _cnt;  
; 5525 : ***/
; 5526 :         }
; 5527 : 
; 5528 :         if(( stream -> _cnt == 0 ) || ( stream -> _cnt == -1 )) {

	mov	ecx, DWORD PTR _stream$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN2@filbuf
	mov	edx, DWORD PTR _stream$[ebp]
	cmp	DWORD PTR [edx+4], -1
	jne	SHORT $LN3@filbuf
$LN2@filbuf:

; 5529 :             stream -> _flag |= stream -> _cnt ? _IOERR : _IOEOF;

	mov	eax, DWORD PTR _stream$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN25@filbuf
	mov	DWORD PTR tv213[ebp], 32		; 00000020H
	jmp	SHORT $LN26@filbuf
$LN25@filbuf:
	mov	DWORD PTR tv213[ebp], 16		; 00000010H
$LN26@filbuf:
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	or	edx, DWORD PTR tv213[ebp]
	mov	eax, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [eax+12], edx

; 5530 :             stream -> _cnt = 0;

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 5531 :             return( EOF );

	or	eax, -1
	jmp	SHORT $LN23@filbuf
$LN3@filbuf:

; 5532 :         }
; 5533 : 
; 5534 :         //  Don't think I need this, but... _osfile_safe(i) expands to (_pioinfo_safe(i)->osfile)
; 5535 :         //  if( !(stream -> _flag & ( _IOWRT | _IORW )) && ((_osfile_safe(_fileno(stream)) & (FTEXT|FEOFLAG)) == (FTEXT|FEOFLAG)))
; 5536 :         //      stream -> _flag |= _IOCTRLZ;
; 5537 : 
; 5538 :         /* Check for small _bufsiz (_SMALL_BUFSIZ). If it is small and
; 5539 :            if it is our buffer, then this must be the first _filbuf after
; 5540 :            an fseek on a read-access-only stream. Restore _bufsiz to its
; 5541 :            larger value (_INTERNAL_BUFSIZ) so that the next _filbuf call,
; 5542 :            if one is made, will fill the whole buffer. */
; 5543 : 
; 5544 :         if( (stream -> _bufsiz == _SMALL_BUFSIZ) && 
; 5545 :             (stream -> _flag & _IOMYBUF        ) && 
; 5546 :            !(stream -> _flag & _IOSETVBUF      ) ) 

	mov	edx, DWORD PTR _stream$[ebp]
	cmp	DWORD PTR [edx+24], 512			; 00000200H
	jne	SHORT $LN7@filbuf
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 8
	je	SHORT $LN7@filbuf
	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx+12]
	and	eax, 1024				; 00000400H
	jne	SHORT $LN7@filbuf

; 5547 :         {
; 5548 :             stream -> _bufsiz = _INTERNAL_BUFSIZ;

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx+24], 4096		; 00001000H
$LN7@filbuf:

; 5549 :         }
; 5550 :     }
; 5551 : 
; 5552 :     stream -> _cnt--;

	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 5553 :     return( 0xff & *stream -> _ptr++ );

	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax]
	and	ecx, 255				; 000000ffH
	mov	DWORD PTR tv237[ebp], ecx
	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR tv237[ebp]
$LN23@filbuf:

; 5554 : }

	mov	esp, ebp
	pop	ebp
	ret	0
__filbuf ENDP
_TEXT	ENDS
END
