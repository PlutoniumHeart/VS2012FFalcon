; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\codelib\resources\reslib\src\inflate.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_mask
PUBLIC	_lbits
PUBLIC	_dbits
PUBLIC	_fixed_tl
_DATA	SEGMENT
COMM	_hufts:DWORD
_DATA	ENDS
_BSS	SEGMENT
_fixed_tl DD	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_fixed_td:DWORD
COMM	_fixed_bl:DWORD
COMM	_fixed_bd:DWORD
_DATA	ENDS
_DATA	SEGMENT
_border	DD	010H
	DD	011H
	DD	012H
	DD	00H
	DD	08H
	DD	07H
	DD	09H
	DD	06H
	DD	0aH
	DD	05H
	DD	0bH
	DD	04H
	DD	0cH
	DD	03H
	DD	0dH
	DD	02H
	DD	0eH
	DD	01H
	DD	0fH
_cplens	DW	03H
	DW	04H
	DW	05H
	DW	06H
	DW	07H
	DW	08H
	DW	09H
	DW	0aH
	DW	0bH
	DW	0dH
	DW	0fH
	DW	011H
	DW	013H
	DW	017H
	DW	01bH
	DW	01fH
	DW	023H
	DW	02bH
	DW	033H
	DW	03bH
	DW	043H
	DW	053H
	DW	063H
	DW	073H
	DW	083H
	DW	0a3H
	DW	0c3H
	DW	0e3H
	DW	0102H
	DW	00H
	DW	00H
	ORG $+2
_cplext	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	02H
	DW	02H
	DW	02H
	DW	03H
	DW	03H
	DW	03H
	DW	03H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	05H
	DW	05H
	DW	05H
	DW	05H
	DW	00H
	DW	063H
	DW	063H
	ORG $+2
_cpdist	DW	01H
	DW	02H
	DW	03H
	DW	04H
	DW	05H
	DW	07H
	DW	09H
	DW	0dH
	DW	011H
	DW	019H
	DW	021H
	DW	031H
	DW	041H
	DW	061H
	DW	081H
	DW	0c1H
	DW	0101H
	DW	0181H
	DW	0201H
	DW	0301H
	DW	0401H
	DW	0601H
	DW	0801H
	DW	0c01H
	DW	01001H
	DW	01801H
	DW	02001H
	DW	03001H
	DW	04001H
	DW	06001H
_cpdext	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	01H
	DW	01H
	DW	02H
	DW	02H
	DW	03H
	DW	03H
	DW	04H
	DW	04H
	DW	05H
	DW	05H
	DW	06H
	DW	06H
	DW	07H
	DW	07H
	DW	08H
	DW	08H
	DW	09H
	DW	09H
	DW	0aH
	DW	0aH
	DW	0bH
	DW	0bH
	DW	0cH
	DW	0cH
	DW	0dH
	DW	0dH
_mask	DW	00H
	DW	01H
	DW	03H
	DW	07H
	DW	0fH
	DW	01fH
	DW	03fH
	DW	07fH
	DW	0ffH
	DW	01ffH
	DW	03ffH
	DW	07ffH
	DW	0fffH
	DW	01fffH
	DW	03fffH
	DW	07fffH
	DW	0ffffH
	ORG $+2
_lbits	DD	09H
_dbits	DD	06H
_DATA	ENDS
PUBLIC	_inflate
PUBLIC	_inflate_free
PUBLIC	_huft_build
PUBLIC	_huft_free
PUBLIC	_inflate_codes
PUBLIC	_inflate_stored
PUBLIC	_inflate_fixed
PUBLIC	_inflate_dynamic
PUBLIC	_inflate_block
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_readbyte:PROC
EXTRN	_flush:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
?v@?1??huft_build@@9@9 DD 0120H DUP (?)			; `huft_build'::`2'::v
?l@?2??inflate_fixed@@9@9 DD 0120H DUP (?)		; `inflate_fixed'::`3'::l
?ll@?1??inflate_dynamic@@9@9 DD 0140H DUP (?)		; `inflate_dynamic'::`2'::ll
_BSS	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\inflate.c
_TEXT	SEGMENT
tv144 = -44						; size = 4
tv85 = -40						; size = 4
tv145 = -36						; size = 4
tv143 = -32						; size = 4
tv133 = -28						; size = 4
tv86 = -24						; size = 4
tv84 = -20						; size = 4
tv74 = -16						; size = 4
_t$ = -12						; size = 4
_b$ = -8						; size = 4
_k$ = -4						; size = 4
_e$ = 8							; size = 4
_cmp$ = 12						; size = 4
_inflate_block PROC

; 1096 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 1097 :     unsigned t;                 /* block type */
; 1098 :     register ulg b;             /* bit buffer */
; 1099 :     register unsigned k;        /* number of bits in bit buffer */
; 1100 : 
; 1101 : 
; 1102 :     /* make local bit buffer */
; 1103 :     b = cmp->bb;

	mov	eax, DWORD PTR _cmp$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _b$[ebp], ecx

; 1104 :     k = cmp->bk;

	mov	edx, DWORD PTR _cmp$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR _k$[ebp], eax
$LN7@inflate_bl:

; 1105 : 
; 1106 :     /* read in last block bit */
; 1107 :     NEEDBITS(1)

	cmp	DWORD PTR _k$[ebp], 1
	jae	$LN6@inflate_bl
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR tv85[ebp], edx
	mov	eax, DWORD PTR _cmp$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	sub	ecx, 1
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	DWORD PTR [edx+40], ecx
	cmp	DWORD PTR tv85[ebp], 0
	jg	SHORT $LN12@inflate_bl
	mov	DWORD PTR tv86[ebp], -1
	jmp	SHORT $LN13@inflate_bl
$LN12@inflate_bl:
	mov	eax, DWORD PTR _cmp$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sub	ecx, 1
	mov	DWORD PTR tv74[ebp], ecx
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	eax, DWORD PTR tv74[ebp]
	mov	DWORD PTR [edx+12], eax
	cmp	DWORD PTR tv74[ebp], 0
	jl	SHORT $LN10@inflate_bl
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	movzx	eax, BYTE PTR [edx]
	mov	DWORD PTR tv84[ebp], eax
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, 1
	mov	eax, DWORD PTR _cmp$[ebp]
	mov	DWORD PTR [eax+8], edx
	jmp	SHORT $LN11@inflate_bl
$LN10@inflate_bl:
	mov	ecx, DWORD PTR _cmp$[ebp]
	push	ecx
	call	_readbyte
	add	esp, 4
	mov	DWORD PTR tv84[ebp], eax
$LN11@inflate_bl:
	mov	edx, DWORD PTR tv84[ebp]
	mov	DWORD PTR tv86[ebp], edx
$LN13@inflate_bl:
	mov	eax, DWORD PTR tv86[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	shl	eax, cl
	or	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR _b$[ebp], eax
	mov	ecx, DWORD PTR _k$[ebp]
	add	ecx, 8
	mov	DWORD PTR _k$[ebp], ecx
	jmp	$LN7@inflate_bl
$LN6@inflate_bl:

; 1108 :     * e = (int)b & 1;

	mov	edx, DWORD PTR _b$[ebp]
	and	edx, 1
	mov	eax, DWORD PTR _e$[ebp]
	mov	DWORD PTR [eax], edx

; 1109 :     DUMPBITS(1)

	mov	ecx, DWORD PTR _b$[ebp]
	shr	ecx, 1
	mov	DWORD PTR _b$[ebp], ecx
	mov	edx, DWORD PTR _k$[ebp]
	sub	edx, 1
	mov	DWORD PTR _k$[ebp], edx
$LN5@inflate_bl:

; 1110 : 
; 1111 : 
; 1112 :     /* read in block type */
; 1113 :     NEEDBITS(2)

	cmp	DWORD PTR _k$[ebp], 2
	jae	$LN4@inflate_bl
	mov	eax, DWORD PTR _cmp$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR tv144[ebp], ecx
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	eax, DWORD PTR [edx+40]
	sub	eax, 1
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	DWORD PTR [ecx+40], eax
	cmp	DWORD PTR tv144[ebp], 0
	jg	SHORT $LN16@inflate_bl
	mov	DWORD PTR tv145[ebp], -1
	jmp	SHORT $LN17@inflate_bl
$LN16@inflate_bl:
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	eax, DWORD PTR [edx+12]
	sub	eax, 1
	mov	DWORD PTR tv133[ebp], eax
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	edx, DWORD PTR tv133[ebp]
	mov	DWORD PTR [ecx+12], edx
	cmp	DWORD PTR tv133[ebp], 0
	jl	SHORT $LN14@inflate_bl
	mov	eax, DWORD PTR _cmp$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR tv143[ebp], edx
	mov	eax, DWORD PTR _cmp$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 1
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	DWORD PTR [edx+8], ecx
	jmp	SHORT $LN15@inflate_bl
$LN14@inflate_bl:
	mov	eax, DWORD PTR _cmp$[ebp]
	push	eax
	call	_readbyte
	add	esp, 4
	mov	DWORD PTR tv143[ebp], eax
$LN15@inflate_bl:
	mov	ecx, DWORD PTR tv143[ebp]
	mov	DWORD PTR tv145[ebp], ecx
$LN17@inflate_bl:
	mov	edx, DWORD PTR tv145[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	shl	edx, cl
	or	edx, DWORD PTR _b$[ebp]
	mov	DWORD PTR _b$[ebp], edx
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 8
	mov	DWORD PTR _k$[ebp], eax
	jmp	$LN5@inflate_bl
$LN4@inflate_bl:

; 1114 :     t = (unsigned)b & 3;

	mov	ecx, DWORD PTR _b$[ebp]
	and	ecx, 3
	mov	DWORD PTR _t$[ebp], ecx

; 1115 :     DUMPBITS(2)

	mov	edx, DWORD PTR _b$[ebp]
	shr	edx, 2
	mov	DWORD PTR _b$[ebp], edx
	mov	eax, DWORD PTR _k$[ebp]
	sub	eax, 2
	mov	DWORD PTR _k$[ebp], eax

; 1116 : 
; 1117 : 
; 1118 :     /* restore the global bit buffer */
; 1119 :     cmp->bb = b;

	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	edx, DWORD PTR _b$[ebp]
	mov	DWORD PTR [ecx+32], edx

; 1120 :     cmp->bk = k;

	mov	eax, DWORD PTR _cmp$[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	mov	DWORD PTR [eax+36], ecx

; 1121 : 
; 1122 : 
; 1123 :     /* inflate that block type */
; 1124 :     if (t == 2)

	cmp	DWORD PTR _t$[ebp], 2
	jne	SHORT $LN3@inflate_bl

; 1125 :         return inflate_dynamic(cmp);

	mov	edx, DWORD PTR _cmp$[ebp]
	push	edx
	call	_inflate_dynamic
	add	esp, 4
	jmp	SHORT $LN8@inflate_bl
$LN3@inflate_bl:

; 1126 :     if (t == 0)

	cmp	DWORD PTR _t$[ebp], 0
	jne	SHORT $LN2@inflate_bl

; 1127 :         return inflate_stored(cmp);

	mov	eax, DWORD PTR _cmp$[ebp]
	push	eax
	call	_inflate_stored
	add	esp, 4
	jmp	SHORT $LN8@inflate_bl
$LN2@inflate_bl:

; 1128 :     if (t == 1)

	cmp	DWORD PTR _t$[ebp], 1
	jne	SHORT $LN1@inflate_bl

; 1129 :         return inflate_fixed(cmp);

	mov	ecx, DWORD PTR _cmp$[ebp]
	push	ecx
	call	_inflate_fixed
	add	esp, 4
	jmp	SHORT $LN8@inflate_bl
$LN1@inflate_bl:

; 1130 : 
; 1131 : 
; 1132 :     /* bad block type */
; 1133 :     return 2;

	mov	eax, 2
$LN8@inflate_bl:

; 1134 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_inflate_block ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\inflate.c
_TEXT	SEGMENT
tv382 = -196						; size = 4
_nb$ = -192						; size = 4
tv369 = -188						; size = 4
tv258 = -184						; size = 4
tv346 = -180						; size = 4
tv145 = -176						; size = 4
tv333 = -172						; size = 4
tv205 = -168						; size = 4
tv309 = -164						; size = 4
tv173 = -160						; size = 4
tv296 = -156						; size = 4
_m$ = -152						; size = 4
tv85 = -148						; size = 4
tv247 = -144						; size = 4
tv285 = -140						; size = 4
tv204 = -136						; size = 4
tv297 = -132						; size = 4
tv174 = -128						; size = 4
tv74 = -124						; size = 4
tv162 = -120						; size = 4
tv295 = -116						; size = 4
tv144 = -112						; size = 4
tv259 = -108						; size = 4
tv86 = -104						; size = 4
tv322 = -100						; size = 4
tv206 = -96						; size = 4
_bd$ = -92						; size = 4
tv194 = -88						; size = 4
tv370 = -84						; size = 4
tv172 = -80						; size = 4
tv368 = -76						; size = 4
tv146 = -72						; size = 4
tv358 = -68						; size = 4
tv134 = -64						; size = 4
tv334 = -60						; size = 4
tv84 = -56						; size = 4
tv332 = -52						; size = 4
tv257 = -48						; size = 4
_nd$ = -44						; size = 4
_n$ = -40						; size = 4
_nl$ = -36						; size = 4
_td$ = -32						; size = 4
_tl$ = -28						; size = 4
_l$ = -24						; size = 4
_bl$ = -20						; size = 4
_i$ = -16						; size = 4
_j$ = -12						; size = 4
_b$ = -8						; size = 4
_k$ = -4						; size = 4
_cmp$ = 8						; size = 4
_inflate_dynamic PROC

; 935  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H

; 936  :   int i;                /* temporary variables */
; 937  :   unsigned j;
; 938  :   unsigned l;           /* last length */
; 939  :   unsigned m;           /* mask for bit lengths table */
; 940  :   unsigned n;           /* number of lengths to get */
; 941  :   struct huft *tl;      /* literal/length code table */
; 942  :   struct huft *td;      /* distance code table */
; 943  :   int bl;               /* lookup bits for tl */
; 944  :   int bd;               /* lookup bits for td */
; 945  :   unsigned nb;          /* number of bit length codes */
; 946  :   unsigned nl;          /* number of literal/length codes */
; 947  :   unsigned nd;          /* number of distance codes */
; 948  :   static unsigned ll[288+32]; /* literal/length and distance code lengths */
; 949  :   register ulg b;       /* bit buffer */
; 950  :   register unsigned k;  /* number of bits in bit buffer */
; 951  : 
; 952  : 
; 953  :   /* make local bit buffer */
; 954  :   Trace((stderr, "\ndynamic block"));
; 955  :   b = cmp -> bb;

	mov	eax, DWORD PTR _cmp$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _b$[ebp], ecx

; 956  :   k = cmp -> bk;

	mov	edx, DWORD PTR _cmp$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR _k$[ebp], eax
$LN46@inflate_dy:

; 957  : 
; 958  : 
; 959  :   /* read in table lengths */
; 960  :   NEEDBITS(5)

	cmp	DWORD PTR _k$[ebp], 5
	jae	$LN45@inflate_dy
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR tv85[ebp], edx
	mov	eax, DWORD PTR _cmp$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	sub	ecx, 1
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	DWORD PTR [edx+40], ecx
	cmp	DWORD PTR tv85[ebp], 0
	jg	SHORT $LN51@inflate_dy
	mov	DWORD PTR tv86[ebp], -1
	jmp	SHORT $LN52@inflate_dy
$LN51@inflate_dy:
	mov	eax, DWORD PTR _cmp$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sub	ecx, 1
	mov	DWORD PTR tv74[ebp], ecx
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	eax, DWORD PTR tv74[ebp]
	mov	DWORD PTR [edx+12], eax
	cmp	DWORD PTR tv74[ebp], 0
	jl	SHORT $LN49@inflate_dy
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	movzx	eax, BYTE PTR [edx]
	mov	DWORD PTR tv84[ebp], eax
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, 1
	mov	eax, DWORD PTR _cmp$[ebp]
	mov	DWORD PTR [eax+8], edx
	jmp	SHORT $LN50@inflate_dy
$LN49@inflate_dy:
	mov	ecx, DWORD PTR _cmp$[ebp]
	push	ecx
	call	_readbyte
	add	esp, 4
	mov	DWORD PTR tv84[ebp], eax
$LN50@inflate_dy:
	mov	edx, DWORD PTR tv84[ebp]
	mov	DWORD PTR tv86[ebp], edx
$LN52@inflate_dy:
	mov	eax, DWORD PTR tv86[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	shl	eax, cl
	or	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR _b$[ebp], eax
	mov	ecx, DWORD PTR _k$[ebp]
	add	ecx, 8
	mov	DWORD PTR _k$[ebp], ecx
	jmp	$LN46@inflate_dy
$LN45@inflate_dy:

; 961  :   nl = 257 + ((unsigned)b & 0x1f);      /* number of literal/length codes */

	mov	edx, DWORD PTR _b$[ebp]
	and	edx, 31					; 0000001fH
	add	edx, 257				; 00000101H
	mov	DWORD PTR _nl$[ebp], edx

; 962  :   DUMPBITS(5)

	mov	eax, DWORD PTR _b$[ebp]
	shr	eax, 5
	mov	DWORD PTR _b$[ebp], eax
	mov	ecx, DWORD PTR _k$[ebp]
	sub	ecx, 5
	mov	DWORD PTR _k$[ebp], ecx
$LN44@inflate_dy:

; 963  :   NEEDBITS(5)

	cmp	DWORD PTR _k$[ebp], 5
	jae	$LN43@inflate_dy
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR tv145[ebp], eax
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	sub	edx, 1
	mov	eax, DWORD PTR _cmp$[ebp]
	mov	DWORD PTR [eax+40], edx
	cmp	DWORD PTR tv145[ebp], 0
	jg	SHORT $LN55@inflate_dy
	mov	DWORD PTR tv146[ebp], -1
	jmp	SHORT $LN56@inflate_dy
$LN55@inflate_dy:
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	sub	edx, 1
	mov	DWORD PTR tv134[ebp], edx
	mov	eax, DWORD PTR _cmp$[ebp]
	mov	ecx, DWORD PTR tv134[ebp]
	mov	DWORD PTR [eax+12], ecx
	cmp	DWORD PTR tv134[ebp], 0
	jl	SHORT $LN53@inflate_dy
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	eax, DWORD PTR [edx+8]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv144[ebp], ecx
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, 1
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	DWORD PTR [ecx+8], eax
	jmp	SHORT $LN54@inflate_dy
$LN53@inflate_dy:
	mov	edx, DWORD PTR _cmp$[ebp]
	push	edx
	call	_readbyte
	add	esp, 4
	mov	DWORD PTR tv144[ebp], eax
$LN54@inflate_dy:
	mov	eax, DWORD PTR tv144[ebp]
	mov	DWORD PTR tv146[ebp], eax
$LN56@inflate_dy:
	mov	edx, DWORD PTR tv146[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	shl	edx, cl
	or	edx, DWORD PTR _b$[ebp]
	mov	DWORD PTR _b$[ebp], edx
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 8
	mov	DWORD PTR _k$[ebp], eax
	jmp	$LN44@inflate_dy
$LN43@inflate_dy:

; 964  :   nd = 1 + ((unsigned)b & 0x1f);        /* number of distance codes */

	mov	ecx, DWORD PTR _b$[ebp]
	and	ecx, 31					; 0000001fH
	add	ecx, 1
	mov	DWORD PTR _nd$[ebp], ecx

; 965  :   DUMPBITS(5)

	mov	edx, DWORD PTR _b$[ebp]
	shr	edx, 5
	mov	DWORD PTR _b$[ebp], edx
	mov	eax, DWORD PTR _k$[ebp]
	sub	eax, 5
	mov	DWORD PTR _k$[ebp], eax
$LN42@inflate_dy:

; 966  :   NEEDBITS(4)

	cmp	DWORD PTR _k$[ebp], 4
	jae	$LN41@inflate_dy
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR tv173[ebp], edx
	mov	eax, DWORD PTR _cmp$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	sub	ecx, 1
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	DWORD PTR [edx+40], ecx
	cmp	DWORD PTR tv173[ebp], 0
	jg	SHORT $LN59@inflate_dy
	mov	DWORD PTR tv174[ebp], -1
	jmp	SHORT $LN60@inflate_dy
$LN59@inflate_dy:
	mov	eax, DWORD PTR _cmp$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sub	ecx, 1
	mov	DWORD PTR tv162[ebp], ecx
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	eax, DWORD PTR tv162[ebp]
	mov	DWORD PTR [edx+12], eax
	cmp	DWORD PTR tv162[ebp], 0
	jl	SHORT $LN57@inflate_dy
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	movzx	eax, BYTE PTR [edx]
	mov	DWORD PTR tv172[ebp], eax
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, 1
	mov	eax, DWORD PTR _cmp$[ebp]
	mov	DWORD PTR [eax+8], edx
	jmp	SHORT $LN58@inflate_dy
$LN57@inflate_dy:
	mov	ecx, DWORD PTR _cmp$[ebp]
	push	ecx
	call	_readbyte
	add	esp, 4
	mov	DWORD PTR tv172[ebp], eax
$LN58@inflate_dy:
	mov	edx, DWORD PTR tv172[ebp]
	mov	DWORD PTR tv174[ebp], edx
$LN60@inflate_dy:
	mov	eax, DWORD PTR tv174[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	shl	eax, cl
	or	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR _b$[ebp], eax
	mov	ecx, DWORD PTR _k$[ebp]
	add	ecx, 8
	mov	DWORD PTR _k$[ebp], ecx
	jmp	$LN42@inflate_dy
$LN41@inflate_dy:

; 967  :   nb = 4 + ((unsigned)b & 0xf);         /* number of bit length codes */

	mov	edx, DWORD PTR _b$[ebp]
	and	edx, 15					; 0000000fH
	add	edx, 4
	mov	DWORD PTR _nb$[ebp], edx

; 968  :   DUMPBITS(4)

	mov	eax, DWORD PTR _b$[ebp]
	shr	eax, 4
	mov	DWORD PTR _b$[ebp], eax
	mov	ecx, DWORD PTR _k$[ebp]
	sub	ecx, 4
	mov	DWORD PTR _k$[ebp], ecx

; 969  :   if (nl > 288 || nd > 32)

	cmp	DWORD PTR _nl$[ebp], 288		; 00000120H
	ja	SHORT $LN39@inflate_dy
	cmp	DWORD PTR _nd$[ebp], 32			; 00000020H
	jbe	SHORT $LN40@inflate_dy
$LN39@inflate_dy:

; 970  :     return 1;                   /* bad lengths */

	mov	eax, 1
	jmp	$LN47@inflate_dy
$LN40@inflate_dy:

; 971  : 
; 972  : 
; 973  :   /* read in bit-length-code lengths */
; 974  :   for (j = 0; j < nb; j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN38@inflate_dy
$LN37@inflate_dy:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$LN38@inflate_dy:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _nb$[ebp]
	jae	$LN36@inflate_dy
$LN35@inflate_dy:

; 975  :   {
; 976  :     NEEDBITS(3)

	cmp	DWORD PTR _k$[ebp], 3
	jae	$LN34@inflate_dy
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR tv205[ebp], edx
	mov	eax, DWORD PTR _cmp$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	sub	ecx, 1
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	DWORD PTR [edx+40], ecx
	cmp	DWORD PTR tv205[ebp], 0
	jg	SHORT $LN63@inflate_dy
	mov	DWORD PTR tv206[ebp], -1
	jmp	SHORT $LN64@inflate_dy
$LN63@inflate_dy:
	mov	eax, DWORD PTR _cmp$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sub	ecx, 1
	mov	DWORD PTR tv194[ebp], ecx
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	eax, DWORD PTR tv194[ebp]
	mov	DWORD PTR [edx+12], eax
	cmp	DWORD PTR tv194[ebp], 0
	jl	SHORT $LN61@inflate_dy
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	movzx	eax, BYTE PTR [edx]
	mov	DWORD PTR tv204[ebp], eax
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, 1
	mov	eax, DWORD PTR _cmp$[ebp]
	mov	DWORD PTR [eax+8], edx
	jmp	SHORT $LN62@inflate_dy
$LN61@inflate_dy:
	mov	ecx, DWORD PTR _cmp$[ebp]
	push	ecx
	call	_readbyte
	add	esp, 4
	mov	DWORD PTR tv204[ebp], eax
$LN62@inflate_dy:
	mov	edx, DWORD PTR tv204[ebp]
	mov	DWORD PTR tv206[ebp], edx
$LN64@inflate_dy:
	mov	eax, DWORD PTR tv206[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	shl	eax, cl
	or	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR _b$[ebp], eax
	mov	ecx, DWORD PTR _k$[ebp]
	add	ecx, 8
	mov	DWORD PTR _k$[ebp], ecx
	jmp	$LN35@inflate_dy
$LN34@inflate_dy:

; 977  :     ll[border[j]] = (unsigned)b & 7;

	mov	edx, DWORD PTR _b$[ebp]
	and	edx, 7
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _border[eax*4]
	mov	DWORD PTR ?ll@?1??inflate_dynamic@@9@9[ecx*4], edx

; 978  :     DUMPBITS(3)

	mov	edx, DWORD PTR _b$[ebp]
	shr	edx, 3
	mov	DWORD PTR _b$[ebp], edx
	mov	eax, DWORD PTR _k$[ebp]
	sub	eax, 3
	mov	DWORD PTR _k$[ebp], eax

; 979  :   }

	jmp	$LN37@inflate_dy
$LN36@inflate_dy:

; 980  :   for (; j < 19; j++)

	jmp	SHORT $LN33@inflate_dy
$LN32@inflate_dy:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$LN33@inflate_dy:
	cmp	DWORD PTR _j$[ebp], 19			; 00000013H
	jae	SHORT $LN31@inflate_dy

; 981  :     ll[border[j]] = 0;

	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _border[edx*4]
	mov	DWORD PTR ?ll@?1??inflate_dynamic@@9@9[eax*4], 0
	jmp	SHORT $LN32@inflate_dy
$LN31@inflate_dy:

; 982  : 
; 983  : 
; 984  :   /* build decoding table for trees--single level, 7 bit lookup */
; 985  :   bl = 7;

	mov	DWORD PTR _bl$[ebp], 7

; 986  :   if ((i = huft_build(ll, 19, 19, NULL, NULL, &tl, &bl)) != 0)

	lea	ecx, DWORD PTR _bl$[ebp]
	push	ecx
	lea	edx, DWORD PTR _tl$[ebp]
	push	edx
	push	0
	push	0
	push	19					; 00000013H
	push	19					; 00000013H
	push	OFFSET ?ll@?1??inflate_dynamic@@9@9
	call	_huft_build
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _i$[ebp], eax
	cmp	DWORD PTR _i$[ebp], 0
	je	SHORT $LN30@inflate_dy

; 987  :   {
; 988  :     if (i == 1)

	cmp	DWORD PTR _i$[ebp], 1
	jne	SHORT $LN29@inflate_dy

; 989  :       huft_free(tl);

	mov	eax, DWORD PTR _tl$[ebp]
	push	eax
	call	_huft_free
	add	esp, 4
$LN29@inflate_dy:

; 990  :     return i;                   /* incomplete code set */

	mov	eax, DWORD PTR _i$[ebp]
	jmp	$LN47@inflate_dy
$LN30@inflate_dy:

; 991  :   }
; 992  : 
; 993  : 
; 994  :   /* read in literal and distance code lengths */
; 995  :   n = nl + nd;

	mov	ecx, DWORD PTR _nl$[ebp]
	add	ecx, DWORD PTR _nd$[ebp]
	mov	DWORD PTR _n$[ebp], ecx

; 996  :   m = mask[bl];

	mov	edx, DWORD PTR _bl$[ebp]
	movzx	eax, WORD PTR _mask[edx*2]
	mov	DWORD PTR _m$[ebp], eax

; 997  :   i = l = 0;

	mov	DWORD PTR _l$[ebp], 0
	mov	ecx, DWORD PTR _l$[ebp]
	mov	DWORD PTR _i$[ebp], ecx
$LN28@inflate_dy:

; 998  :   while ((unsigned)i < n)

	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _n$[ebp]
	jae	$LN27@inflate_dy
$LN26@inflate_dy:

; 999  :   {
; 1000 :     NEEDBITS((unsigned)bl)

	mov	eax, DWORD PTR _k$[ebp]
	cmp	eax, DWORD PTR _bl$[ebp]
	jae	$LN25@inflate_dy
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR tv258[ebp], edx
	mov	eax, DWORD PTR _cmp$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	sub	ecx, 1
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	DWORD PTR [edx+40], ecx
	cmp	DWORD PTR tv258[ebp], 0
	jg	SHORT $LN67@inflate_dy
	mov	DWORD PTR tv259[ebp], -1
	jmp	SHORT $LN68@inflate_dy
$LN67@inflate_dy:
	mov	eax, DWORD PTR _cmp$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sub	ecx, 1
	mov	DWORD PTR tv247[ebp], ecx
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	eax, DWORD PTR tv247[ebp]
	mov	DWORD PTR [edx+12], eax
	cmp	DWORD PTR tv247[ebp], 0
	jl	SHORT $LN65@inflate_dy
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	movzx	eax, BYTE PTR [edx]
	mov	DWORD PTR tv257[ebp], eax
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, 1
	mov	eax, DWORD PTR _cmp$[ebp]
	mov	DWORD PTR [eax+8], edx
	jmp	SHORT $LN66@inflate_dy
$LN65@inflate_dy:
	mov	ecx, DWORD PTR _cmp$[ebp]
	push	ecx
	call	_readbyte
	add	esp, 4
	mov	DWORD PTR tv257[ebp], eax
$LN66@inflate_dy:
	mov	edx, DWORD PTR tv257[ebp]
	mov	DWORD PTR tv259[ebp], edx
$LN68@inflate_dy:
	mov	eax, DWORD PTR tv259[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	shl	eax, cl
	or	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR _b$[ebp], eax
	mov	ecx, DWORD PTR _k$[ebp]
	add	ecx, 8
	mov	DWORD PTR _k$[ebp], ecx
	jmp	$LN26@inflate_dy
$LN25@inflate_dy:

; 1001 :     j = (td = tl + ((unsigned)b & m))->b;

	mov	edx, DWORD PTR _b$[ebp]
	and	edx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR _tl$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR _td$[ebp], ecx
	mov	edx, DWORD PTR _td$[ebp]
	movzx	eax, BYTE PTR [edx+1]
	mov	DWORD PTR _j$[ebp], eax

; 1002 :     DUMPBITS(j)

	mov	edx, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	shr	edx, cl
	mov	DWORD PTR _b$[ebp], edx
	mov	eax, DWORD PTR _k$[ebp]
	sub	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR _k$[ebp], eax

; 1003 :     j = td->v.n;

	mov	ecx, DWORD PTR _td$[ebp]
	movzx	edx, WORD PTR [ecx+4]
	mov	DWORD PTR _j$[ebp], edx

; 1004 :     if (j < 16)                 /* length of code in bits (0..15) */

	cmp	DWORD PTR _j$[ebp], 16			; 00000010H
	jae	SHORT $LN24@inflate_dy

; 1005 :       ll[i++] = l = j;          /* save last length in l */

	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR _l$[ebp], eax
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _l$[ebp]
	mov	DWORD PTR ?ll@?1??inflate_dynamic@@9@9[ecx*4], edx
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	$LN23@inflate_dy
$LN24@inflate_dy:

; 1006 :     else if (j == 16)           /* repeat last length 3 to 6 times */

	cmp	DWORD PTR _j$[ebp], 16			; 00000010H
	jne	$LN22@inflate_dy
$LN21@inflate_dy:

; 1007 :     {
; 1008 :       NEEDBITS(2)

	cmp	DWORD PTR _k$[ebp], 2
	jae	$LN20@inflate_dy
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR tv296[ebp], edx
	mov	eax, DWORD PTR _cmp$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	sub	ecx, 1
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	DWORD PTR [edx+40], ecx
	cmp	DWORD PTR tv296[ebp], 0
	jg	SHORT $LN71@inflate_dy
	mov	DWORD PTR tv297[ebp], -1
	jmp	SHORT $LN72@inflate_dy
$LN71@inflate_dy:
	mov	eax, DWORD PTR _cmp$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sub	ecx, 1
	mov	DWORD PTR tv285[ebp], ecx
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	eax, DWORD PTR tv285[ebp]
	mov	DWORD PTR [edx+12], eax
	cmp	DWORD PTR tv285[ebp], 0
	jl	SHORT $LN69@inflate_dy
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	movzx	eax, BYTE PTR [edx]
	mov	DWORD PTR tv295[ebp], eax
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, 1
	mov	eax, DWORD PTR _cmp$[ebp]
	mov	DWORD PTR [eax+8], edx
	jmp	SHORT $LN70@inflate_dy
$LN69@inflate_dy:
	mov	ecx, DWORD PTR _cmp$[ebp]
	push	ecx
	call	_readbyte
	add	esp, 4
	mov	DWORD PTR tv295[ebp], eax
$LN70@inflate_dy:
	mov	edx, DWORD PTR tv295[ebp]
	mov	DWORD PTR tv297[ebp], edx
$LN72@inflate_dy:
	mov	eax, DWORD PTR tv297[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	shl	eax, cl
	or	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR _b$[ebp], eax
	mov	ecx, DWORD PTR _k$[ebp]
	add	ecx, 8
	mov	DWORD PTR _k$[ebp], ecx
	jmp	$LN21@inflate_dy
$LN20@inflate_dy:

; 1009 :       j = 3 + ((unsigned)b & 3);

	mov	edx, DWORD PTR _b$[ebp]
	and	edx, 3
	add	edx, 3
	mov	DWORD PTR _j$[ebp], edx

; 1010 :       DUMPBITS(2)

	mov	eax, DWORD PTR _b$[ebp]
	shr	eax, 2
	mov	DWORD PTR _b$[ebp], eax
	mov	ecx, DWORD PTR _k$[ebp]
	sub	ecx, 2
	mov	DWORD PTR _k$[ebp], ecx

; 1011 :       if ((unsigned)i + j > n)

	mov	edx, DWORD PTR _i$[ebp]
	add	edx, DWORD PTR _j$[ebp]
	cmp	edx, DWORD PTR _n$[ebp]
	jbe	SHORT $LN18@inflate_dy

; 1012 :         return 1;

	mov	eax, 1
	jmp	$LN47@inflate_dy
$LN18@inflate_dy:

; 1013 :       while (j--)

	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR tv309[ebp], eax
	mov	ecx, DWORD PTR _j$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
	cmp	DWORD PTR tv309[ebp], 0
	je	SHORT $LN17@inflate_dy

; 1014 :         ll[i++] = l;

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _l$[ebp]
	mov	DWORD PTR ?ll@?1??inflate_dynamic@@9@9[edx*4], eax
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	jmp	SHORT $LN18@inflate_dy
$LN17@inflate_dy:

; 1015 :     }
; 1016 :     else if (j == 17)           /* 3 to 10 zero length codes */

	jmp	$LN23@inflate_dy
$LN22@inflate_dy:
	cmp	DWORD PTR _j$[ebp], 17			; 00000011H
	jne	$LN8@inflate_dy
$LN14@inflate_dy:

; 1017 :     {
; 1018 :       NEEDBITS(3)

	cmp	DWORD PTR _k$[ebp], 3
	jae	$LN13@inflate_dy
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR tv333[ebp], eax
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	sub	edx, 1
	mov	eax, DWORD PTR _cmp$[ebp]
	mov	DWORD PTR [eax+40], edx
	cmp	DWORD PTR tv333[ebp], 0
	jg	SHORT $LN75@inflate_dy
	mov	DWORD PTR tv334[ebp], -1
	jmp	SHORT $LN76@inflate_dy
$LN75@inflate_dy:
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	sub	edx, 1
	mov	DWORD PTR tv322[ebp], edx
	mov	eax, DWORD PTR _cmp$[ebp]
	mov	ecx, DWORD PTR tv322[ebp]
	mov	DWORD PTR [eax+12], ecx
	cmp	DWORD PTR tv322[ebp], 0
	jl	SHORT $LN73@inflate_dy
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	eax, DWORD PTR [edx+8]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv332[ebp], ecx
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, 1
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	DWORD PTR [ecx+8], eax
	jmp	SHORT $LN74@inflate_dy
$LN73@inflate_dy:
	mov	edx, DWORD PTR _cmp$[ebp]
	push	edx
	call	_readbyte
	add	esp, 4
	mov	DWORD PTR tv332[ebp], eax
$LN74@inflate_dy:
	mov	eax, DWORD PTR tv332[ebp]
	mov	DWORD PTR tv334[ebp], eax
$LN76@inflate_dy:
	mov	edx, DWORD PTR tv334[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	shl	edx, cl
	or	edx, DWORD PTR _b$[ebp]
	mov	DWORD PTR _b$[ebp], edx
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 8
	mov	DWORD PTR _k$[ebp], eax
	jmp	$LN14@inflate_dy
$LN13@inflate_dy:

; 1019 :       j = 3 + ((unsigned)b & 7);

	mov	ecx, DWORD PTR _b$[ebp]
	and	ecx, 7
	add	ecx, 3
	mov	DWORD PTR _j$[ebp], ecx

; 1020 :       DUMPBITS(3)

	mov	edx, DWORD PTR _b$[ebp]
	shr	edx, 3
	mov	DWORD PTR _b$[ebp], edx
	mov	eax, DWORD PTR _k$[ebp]
	sub	eax, 3
	mov	DWORD PTR _k$[ebp], eax

; 1021 :       if ((unsigned)i + j > n)

	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR _n$[ebp]
	jbe	SHORT $LN11@inflate_dy

; 1022 :         return 1;

	mov	eax, 1
	jmp	$LN47@inflate_dy
$LN11@inflate_dy:

; 1023 :       while (j--)

	mov	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR tv346[ebp], edx
	mov	eax, DWORD PTR _j$[ebp]
	sub	eax, 1
	mov	DWORD PTR _j$[ebp], eax
	cmp	DWORD PTR tv346[ebp], 0
	je	SHORT $LN10@inflate_dy

; 1024 :         ll[i++] = 0;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR ?ll@?1??inflate_dynamic@@9@9[ecx*4], 0
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	jmp	SHORT $LN11@inflate_dy
$LN10@inflate_dy:

; 1025 :       l = 0;

	mov	DWORD PTR _l$[ebp], 0

; 1026 :     }
; 1027 :     else                        /* j == 18: 11 to 138 zero length codes */

	jmp	$LN23@inflate_dy
$LN8@inflate_dy:

; 1028 :     {
; 1029 :       NEEDBITS(7)

	cmp	DWORD PTR _k$[ebp], 7
	jae	$LN7@inflate_dy
	mov	eax, DWORD PTR _cmp$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR tv369[ebp], ecx
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	eax, DWORD PTR [edx+40]
	sub	eax, 1
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	DWORD PTR [ecx+40], eax
	cmp	DWORD PTR tv369[ebp], 0
	jg	SHORT $LN79@inflate_dy
	mov	DWORD PTR tv370[ebp], -1
	jmp	SHORT $LN80@inflate_dy
$LN79@inflate_dy:
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	eax, DWORD PTR [edx+12]
	sub	eax, 1
	mov	DWORD PTR tv358[ebp], eax
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	edx, DWORD PTR tv358[ebp]
	mov	DWORD PTR [ecx+12], edx
	cmp	DWORD PTR tv358[ebp], 0
	jl	SHORT $LN77@inflate_dy
	mov	eax, DWORD PTR _cmp$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR tv368[ebp], edx
	mov	eax, DWORD PTR _cmp$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 1
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	DWORD PTR [edx+8], ecx
	jmp	SHORT $LN78@inflate_dy
$LN77@inflate_dy:
	mov	eax, DWORD PTR _cmp$[ebp]
	push	eax
	call	_readbyte
	add	esp, 4
	mov	DWORD PTR tv368[ebp], eax
$LN78@inflate_dy:
	mov	ecx, DWORD PTR tv368[ebp]
	mov	DWORD PTR tv370[ebp], ecx
$LN80@inflate_dy:
	mov	edx, DWORD PTR tv370[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	shl	edx, cl
	or	edx, DWORD PTR _b$[ebp]
	mov	DWORD PTR _b$[ebp], edx
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 8
	mov	DWORD PTR _k$[ebp], eax
	jmp	$LN8@inflate_dy
$LN7@inflate_dy:

; 1030 :       j = 11 + ((unsigned)b & 0x7f);

	mov	ecx, DWORD PTR _b$[ebp]
	and	ecx, 127				; 0000007fH
	add	ecx, 11					; 0000000bH
	mov	DWORD PTR _j$[ebp], ecx

; 1031 :       DUMPBITS(7)

	mov	edx, DWORD PTR _b$[ebp]
	shr	edx, 7
	mov	DWORD PTR _b$[ebp], edx
	mov	eax, DWORD PTR _k$[ebp]
	sub	eax, 7
	mov	DWORD PTR _k$[ebp], eax

; 1032 :       if ((unsigned)i + j > n)

	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR _n$[ebp]
	jbe	SHORT $LN5@inflate_dy

; 1033 :         return 1;

	mov	eax, 1
	jmp	$LN47@inflate_dy
$LN5@inflate_dy:

; 1034 :       while (j--)

	mov	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR tv382[ebp], edx
	mov	eax, DWORD PTR _j$[ebp]
	sub	eax, 1
	mov	DWORD PTR _j$[ebp], eax
	cmp	DWORD PTR tv382[ebp], 0
	je	SHORT $LN4@inflate_dy

; 1035 :         ll[i++] = 0;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR ?ll@?1??inflate_dynamic@@9@9[ecx*4], 0
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	jmp	SHORT $LN5@inflate_dy
$LN4@inflate_dy:

; 1036 :       l = 0;

	mov	DWORD PTR _l$[ebp], 0
$LN23@inflate_dy:

; 1037 :     }
; 1038 :   }

	jmp	$LN28@inflate_dy
$LN27@inflate_dy:

; 1039 : 
; 1040 : 
; 1041 :   /* free decoding table for trees */
; 1042 :   huft_free(tl);

	mov	eax, DWORD PTR _tl$[ebp]
	push	eax
	call	_huft_free
	add	esp, 4

; 1043 : 
; 1044 : 
; 1045 :   /* restore the global bit buffer */
; 1046 :   cmp -> bb = b;

	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	edx, DWORD PTR _b$[ebp]
	mov	DWORD PTR [ecx+32], edx

; 1047 :   cmp -> bk = k;

	mov	eax, DWORD PTR _cmp$[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	mov	DWORD PTR [eax+36], ecx

; 1048 : 
; 1049 : 
; 1050 :   /* build the decoding tables for literal/length and distance codes */
; 1051 :   bl = lbits;

	mov	edx, DWORD PTR _lbits
	mov	DWORD PTR _bl$[ebp], edx

; 1052 :   if ((i = huft_build(ll, nl, 257, cplens, cplext, &tl, &bl)) != 0) {

	lea	eax, DWORD PTR _bl$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tl$[ebp]
	push	ecx
	push	OFFSET _cplext
	push	OFFSET _cplens
	push	257					; 00000101H
	mov	edx, DWORD PTR _nl$[ebp]
	push	edx
	push	OFFSET ?ll@?1??inflate_dynamic@@9@9
	call	_huft_build
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _i$[ebp], eax
	cmp	DWORD PTR _i$[ebp], 0
	je	SHORT $LN3@inflate_dy

; 1053 : //    if (i == 1 && !qflag) {
; 1054 : //      fprintf(stderr, "(incomplete l-tree)  ");
; 1055 : //      huft_free(tl);
; 1056 : //    }
; 1057 :     return i;                   /* incomplete code set */

	mov	eax, DWORD PTR _i$[ebp]
	jmp	SHORT $LN47@inflate_dy
$LN3@inflate_dy:

; 1058 :   }
; 1059 :   bd = dbits;

	mov	eax, DWORD PTR _dbits
	mov	DWORD PTR _bd$[ebp], eax

; 1060 :   if ((i = huft_build(ll + nl, nd, 0, cpdist, cpdext, &td, &bd)) != 0) {

	lea	ecx, DWORD PTR _bd$[ebp]
	push	ecx
	lea	edx, DWORD PTR _td$[ebp]
	push	edx
	push	OFFSET _cpdext
	push	OFFSET _cpdist
	push	0
	mov	eax, DWORD PTR _nd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nl$[ebp]
	lea	edx, DWORD PTR ?ll@?1??inflate_dynamic@@9@9[ecx*4]
	push	edx
	call	_huft_build
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _i$[ebp], eax

; 1061 : //    if (i == 1 && !qflag) {
; 1062 : //      fprintf(stderr, "(incomplete d-tree)  ");
; 1063 : //      i = 0;
; 1064 : //    }
; 1065 :   }
; 1066 : 
; 1067 : 
; 1068 :   /* decompress until an end-of-block code */
; 1069 :   if (inflate_codes(tl, td, bl, bd, cmp))

	mov	eax, DWORD PTR _cmp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bd$[ebp]
	push	ecx
	mov	edx, DWORD PTR _bl$[ebp]
	push	edx
	mov	eax, DWORD PTR _td$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tl$[ebp]
	push	ecx
	call	_inflate_codes
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN1@inflate_dy

; 1070 :     return 1;

	mov	eax, 1
	jmp	SHORT $LN47@inflate_dy
$LN1@inflate_dy:

; 1071 : 
; 1072 : 
; 1073 :   /* free the decoding tables, return */
; 1074 :   huft_free(tl);

	mov	edx, DWORD PTR _tl$[ebp]
	push	edx
	call	_huft_free
	add	esp, 4

; 1075 :   huft_free(td);

	mov	eax, DWORD PTR _td$[ebp]
	push	eax
	call	_huft_free
	add	esp, 4

; 1076 :   return 0;

	xor	eax, eax
$LN47@inflate_dy:

; 1077 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_inflate_dynamic ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\inflate.c
_TEXT	SEGMENT
tv143 = -8						; size = 4
_i$1 = -4						; size = 4
_cmp$ = 8						; size = 4
_inflate_fixed PROC

; 870  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 871  :     Trace((stderr, "\nliteral block"));
; 872  : 
; 873  :     /* if first time, set up tables for fixed blocks */
; 874  : 
; 875  :     if( fixed_tl == NULL )

	cmp	DWORD PTR _fixed_tl, 0
	jne	$LN18@inflate_fi

; 876  :     {
; 877  :         int   i;                /* temporary variable */
; 878  :         static unsigned l[288]; /* length list for huft_build */
; 879  : 
; 880  :         /* literal table */
; 881  :         for (i = 0; i < 144; i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN17@inflate_fi
$LN16@inflate_fi:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN17@inflate_fi:
	cmp	DWORD PTR _i$1[ebp], 144		; 00000090H
	jge	SHORT $LN15@inflate_fi

; 882  :             l[i] = 8;

	mov	ecx, DWORD PTR _i$1[ebp]
	mov	DWORD PTR ?l@?2??inflate_fixed@@9@9[ecx*4], 8
	jmp	SHORT $LN16@inflate_fi
$LN15@inflate_fi:

; 883  : 
; 884  :         for (; i < 256; i++)

	jmp	SHORT $LN14@inflate_fi
$LN13@inflate_fi:
	mov	edx, DWORD PTR _i$1[ebp]
	add	edx, 1
	mov	DWORD PTR _i$1[ebp], edx
$LN14@inflate_fi:
	cmp	DWORD PTR _i$1[ebp], 256		; 00000100H
	jge	SHORT $LN12@inflate_fi

; 885  :             l[i] = 9;

	mov	eax, DWORD PTR _i$1[ebp]
	mov	DWORD PTR ?l@?2??inflate_fixed@@9@9[eax*4], 9
	jmp	SHORT $LN13@inflate_fi
$LN12@inflate_fi:

; 886  : 
; 887  :         for (; i < 280; i++)

	jmp	SHORT $LN11@inflate_fi
$LN10@inflate_fi:
	mov	ecx, DWORD PTR _i$1[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$1[ebp], ecx
$LN11@inflate_fi:
	cmp	DWORD PTR _i$1[ebp], 280		; 00000118H
	jge	SHORT $LN9@inflate_fi

; 888  :             l[i] = 7;

	mov	edx, DWORD PTR _i$1[ebp]
	mov	DWORD PTR ?l@?2??inflate_fixed@@9@9[edx*4], 7
	jmp	SHORT $LN10@inflate_fi
$LN9@inflate_fi:

; 889  : 
; 890  :         for (; i < 288; i++)    /* make a complete, but wrong code set */

	jmp	SHORT $LN8@inflate_fi
$LN7@inflate_fi:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN8@inflate_fi:
	cmp	DWORD PTR _i$1[ebp], 288		; 00000120H
	jge	SHORT $LN6@inflate_fi

; 891  :             l[i] = 8;

	mov	ecx, DWORD PTR _i$1[ebp]
	mov	DWORD PTR ?l@?2??inflate_fixed@@9@9[ecx*4], 8
	jmp	SHORT $LN7@inflate_fi
$LN6@inflate_fi:

; 892  : 
; 893  :         fixed_bl = 7;

	mov	DWORD PTR _fixed_bl, 7

; 894  : 
; 895  :         if((i = huft_build(l, 288, 257, cplens, cplext, &fixed_tl, &fixed_bl)) != 0)

	push	OFFSET _fixed_bl
	push	OFFSET _fixed_tl
	push	OFFSET _cplext
	push	OFFSET _cplens
	push	257					; 00000101H
	push	288					; 00000120H
	push	OFFSET ?l@?2??inflate_fixed@@9@9
	call	_huft_build
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _i$1[ebp], eax
	cmp	DWORD PTR _i$1[ebp], 0
	je	SHORT $LN5@inflate_fi

; 896  :         {
; 897  :             fixed_tl = NULL;

	mov	DWORD PTR _fixed_tl, 0

; 898  :             return i;

	mov	eax, DWORD PTR _i$1[ebp]
	jmp	$LN19@inflate_fi
$LN5@inflate_fi:

; 899  :         }
; 900  : 
; 901  :         /* distance table */
; 902  :         for (i = 0; i < 30; i++)    /* make an incomplete code set */

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@inflate_fi
$LN3@inflate_fi:
	mov	edx, DWORD PTR _i$1[ebp]
	add	edx, 1
	mov	DWORD PTR _i$1[ebp], edx
$LN4@inflate_fi:
	cmp	DWORD PTR _i$1[ebp], 30			; 0000001eH
	jge	SHORT $LN2@inflate_fi

; 903  :             l[i] = 5;

	mov	eax, DWORD PTR _i$1[ebp]
	mov	DWORD PTR ?l@?2??inflate_fixed@@9@9[eax*4], 5
	jmp	SHORT $LN3@inflate_fi
$LN2@inflate_fi:

; 904  : 
; 905  :         fixed_bd = 5;

	mov	DWORD PTR _fixed_bd, 5

; 906  : 
; 907  :         if((i = huft_build(l, 30, 0, cpdist, cpdext, &fixed_td, &fixed_bd)) > 1)

	push	OFFSET _fixed_bd
	push	OFFSET _fixed_td
	push	OFFSET _cpdext
	push	OFFSET _cpdist
	push	0
	push	30					; 0000001eH
	push	OFFSET ?l@?2??inflate_fixed@@9@9
	call	_huft_build
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _i$1[ebp], eax
	cmp	DWORD PTR _i$1[ebp], 1
	jle	SHORT $LN18@inflate_fi

; 908  :         {
; 909  :             huft_free(fixed_tl);

	mov	ecx, DWORD PTR _fixed_tl
	push	ecx
	call	_huft_free
	add	esp, 4

; 910  :             fixed_tl = NULL;

	mov	DWORD PTR _fixed_tl, 0

; 911  :             return i;

	mov	eax, DWORD PTR _i$1[ebp]
	jmp	SHORT $LN19@inflate_fi
$LN18@inflate_fi:

; 912  :         }
; 913  :     }
; 914  : 
; 915  :     /* decompress until an end-of-block code */
; 916  :     return inflate_codes(fixed_tl, fixed_td, fixed_bl, fixed_bd, cmp) != 0;

	mov	edx, DWORD PTR _cmp$[ebp]
	push	edx
	mov	eax, DWORD PTR _fixed_bd
	push	eax
	mov	ecx, DWORD PTR _fixed_bl
	push	ecx
	mov	edx, DWORD PTR _fixed_td
	push	edx
	mov	eax, DWORD PTR _fixed_tl
	push	eax
	call	_inflate_codes
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN21@inflate_fi
	mov	DWORD PTR tv143[ebp], 1
	jmp	SHORT $LN22@inflate_fi
$LN21@inflate_fi:
	mov	DWORD PTR tv143[ebp], 0
$LN22@inflate_fi:
	mov	eax, DWORD PTR tv143[ebp]
$LN19@inflate_fi:

; 917  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_inflate_fixed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\inflate.c
_TEXT	SEGMENT
tv180 = -68						; size = 4
tv160 = -64						; size = 4
tv148 = -60						; size = 4
tv89 = -56						; size = 4
tv181 = -52						; size = 4
tv179 = -48						; size = 4
tv169 = -44						; size = 4
tv149 = -40						; size = 4
tv147 = -36						; size = 4
tv137 = -32						; size = 4
tv90 = -28						; size = 4
tv88 = -24						; size = 4
tv78 = -20						; size = 4
_w$ = -16						; size = 4
_n$ = -12						; size = 4
_b$ = -8						; size = 4
_k$ = -4						; size = 4
_cmp$ = 8						; size = 4
_inflate_stored PROC

; 796  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H

; 797  :     unsigned n;                 /* number of bytes in block */
; 798  :     unsigned w;                 /* current window position */
; 799  :     register ulg b;             /* bit buffer */
; 800  :     register unsigned k;        /* number of bits in bit buffer */
; 801  : 
; 802  : 
; 803  :     /* make local copies of globals */
; 804  :     Trace((stderr, "\nstored block"));
; 805  :     b = cmp->bb;                /* initialize bit buffer */

	mov	eax, DWORD PTR _cmp$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _b$[ebp], ecx

; 806  :     k = cmp->bk;

	mov	edx, DWORD PTR _cmp$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR _k$[ebp], eax

; 807  :     w = cmp->wp;                /* initialize window position */

	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR _w$[ebp], edx

; 808  : 
; 809  :     /* go to byte boundary */
; 810  :     n = k & 7;

	mov	eax, DWORD PTR _k$[ebp]
	and	eax, 7
	mov	DWORD PTR _n$[ebp], eax

; 811  :     DUMPBITS(n);

	mov	edx, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR _n$[ebp]
	shr	edx, cl
	mov	DWORD PTR _b$[ebp], edx
	mov	eax, DWORD PTR _k$[ebp]
	sub	eax, DWORD PTR _n$[ebp]
	mov	DWORD PTR _k$[ebp], eax
$LN10@inflate_st:

; 812  : 
; 813  : 
; 814  :     /* get the length and its complement */
; 815  :     NEEDBITS(16)

	cmp	DWORD PTR _k$[ebp], 16			; 00000010H
	jae	$LN9@inflate_st
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR tv89[ebp], edx
	mov	eax, DWORD PTR _cmp$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	sub	ecx, 1
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	DWORD PTR [edx+40], ecx
	cmp	DWORD PTR tv89[ebp], 0
	jg	SHORT $LN15@inflate_st
	mov	DWORD PTR tv90[ebp], -1
	jmp	SHORT $LN16@inflate_st
$LN15@inflate_st:
	mov	eax, DWORD PTR _cmp$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sub	ecx, 1
	mov	DWORD PTR tv78[ebp], ecx
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	eax, DWORD PTR tv78[ebp]
	mov	DWORD PTR [edx+12], eax
	cmp	DWORD PTR tv78[ebp], 0
	jl	SHORT $LN13@inflate_st
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	movzx	eax, BYTE PTR [edx]
	mov	DWORD PTR tv88[ebp], eax
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, 1
	mov	eax, DWORD PTR _cmp$[ebp]
	mov	DWORD PTR [eax+8], edx
	jmp	SHORT $LN14@inflate_st
$LN13@inflate_st:
	mov	ecx, DWORD PTR _cmp$[ebp]
	push	ecx
	call	_readbyte
	add	esp, 4
	mov	DWORD PTR tv88[ebp], eax
$LN14@inflate_st:
	mov	edx, DWORD PTR tv88[ebp]
	mov	DWORD PTR tv90[ebp], edx
$LN16@inflate_st:
	mov	eax, DWORD PTR tv90[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	shl	eax, cl
	or	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR _b$[ebp], eax
	mov	ecx, DWORD PTR _k$[ebp]
	add	ecx, 8
	mov	DWORD PTR _k$[ebp], ecx
	jmp	$LN10@inflate_st
$LN9@inflate_st:

; 816  :     n = ((unsigned)b & 0xffff);

	mov	edx, DWORD PTR _b$[ebp]
	and	edx, 65535				; 0000ffffH
	mov	DWORD PTR _n$[ebp], edx

; 817  :     DUMPBITS(16)

	mov	eax, DWORD PTR _b$[ebp]
	shr	eax, 16					; 00000010H
	mov	DWORD PTR _b$[ebp], eax
	mov	ecx, DWORD PTR _k$[ebp]
	sub	ecx, 16					; 00000010H
	mov	DWORD PTR _k$[ebp], ecx
$LN8@inflate_st:

; 818  : 
; 819  :     NEEDBITS(16)

	cmp	DWORD PTR _k$[ebp], 16			; 00000010H
	jae	$LN7@inflate_st
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR tv148[ebp], eax
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	sub	edx, 1
	mov	eax, DWORD PTR _cmp$[ebp]
	mov	DWORD PTR [eax+40], edx
	cmp	DWORD PTR tv148[ebp], 0
	jg	SHORT $LN19@inflate_st
	mov	DWORD PTR tv149[ebp], -1
	jmp	SHORT $LN20@inflate_st
$LN19@inflate_st:
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	sub	edx, 1
	mov	DWORD PTR tv137[ebp], edx
	mov	eax, DWORD PTR _cmp$[ebp]
	mov	ecx, DWORD PTR tv137[ebp]
	mov	DWORD PTR [eax+12], ecx
	cmp	DWORD PTR tv137[ebp], 0
	jl	SHORT $LN17@inflate_st
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	eax, DWORD PTR [edx+8]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv147[ebp], ecx
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, 1
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	DWORD PTR [ecx+8], eax
	jmp	SHORT $LN18@inflate_st
$LN17@inflate_st:
	mov	edx, DWORD PTR _cmp$[ebp]
	push	edx
	call	_readbyte
	add	esp, 4
	mov	DWORD PTR tv147[ebp], eax
$LN18@inflate_st:
	mov	eax, DWORD PTR tv147[ebp]
	mov	DWORD PTR tv149[ebp], eax
$LN20@inflate_st:
	mov	edx, DWORD PTR tv149[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	shl	edx, cl
	or	edx, DWORD PTR _b$[ebp]
	mov	DWORD PTR _b$[ebp], edx
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 8
	mov	DWORD PTR _k$[ebp], eax
	jmp	$LN8@inflate_st
$LN7@inflate_st:

; 820  :     if (n != (unsigned)((~b) & 0xffff))

	mov	ecx, DWORD PTR _b$[ebp]
	not	ecx
	and	ecx, 65535				; 0000ffffH
	cmp	DWORD PTR _n$[ebp], ecx
	je	SHORT $LN6@inflate_st

; 821  :        return 1;               /* error in compressed data */

	mov	eax, 1
	jmp	$LN11@inflate_st
$LN6@inflate_st:

; 822  :     DUMPBITS(16)

	mov	edx, DWORD PTR _b$[ebp]
	shr	edx, 16					; 00000010H
	mov	DWORD PTR _b$[ebp], edx
	mov	eax, DWORD PTR _k$[ebp]
	sub	eax, 16					; 00000010H
	mov	DWORD PTR _k$[ebp], eax
$LN5@inflate_st:

; 823  : 
; 824  :     /* read and output the compressed data */
; 825  :     while (n--)

	mov	ecx, DWORD PTR _n$[ebp]
	mov	DWORD PTR tv160[ebp], ecx
	mov	edx, DWORD PTR _n$[ebp]
	sub	edx, 1
	mov	DWORD PTR _n$[ebp], edx
	cmp	DWORD PTR tv160[ebp], 0
	je	$LN4@inflate_st
$LN3@inflate_st:

; 826  :     {
; 827  :         NEEDBITS(8)

	cmp	DWORD PTR _k$[ebp], 8
	jae	$LN2@inflate_st
	mov	eax, DWORD PTR _cmp$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR tv180[ebp], ecx
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	eax, DWORD PTR [edx+40]
	sub	eax, 1
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	DWORD PTR [ecx+40], eax
	cmp	DWORD PTR tv180[ebp], 0
	jg	SHORT $LN23@inflate_st
	mov	DWORD PTR tv181[ebp], -1
	jmp	SHORT $LN24@inflate_st
$LN23@inflate_st:
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	eax, DWORD PTR [edx+12]
	sub	eax, 1
	mov	DWORD PTR tv169[ebp], eax
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	edx, DWORD PTR tv169[ebp]
	mov	DWORD PTR [ecx+12], edx
	cmp	DWORD PTR tv169[ebp], 0
	jl	SHORT $LN21@inflate_st
	mov	eax, DWORD PTR _cmp$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR tv179[ebp], edx
	mov	eax, DWORD PTR _cmp$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 1
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	DWORD PTR [edx+8], ecx
	jmp	SHORT $LN22@inflate_st
$LN21@inflate_st:
	mov	eax, DWORD PTR _cmp$[ebp]
	push	eax
	call	_readbyte
	add	esp, 4
	mov	DWORD PTR tv179[ebp], eax
$LN22@inflate_st:
	mov	ecx, DWORD PTR tv179[ebp]
	mov	DWORD PTR tv181[ebp], ecx
$LN24@inflate_st:
	mov	edx, DWORD PTR tv181[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	shl	edx, cl
	or	edx, DWORD PTR _b$[ebp]
	mov	DWORD PTR _b$[ebp], edx
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 8
	mov	DWORD PTR _k$[ebp], eax
	jmp	$LN3@inflate_st
$LN2@inflate_st:

; 828  :         cmp->slide[w++] = (uch) b;

	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _w$[ebp]
	mov	cl, BYTE PTR _b$[ebp]
	mov	BYTE PTR [edx+eax], cl
	mov	edx, DWORD PTR _w$[ebp]
	add	edx, 1
	mov	DWORD PTR _w$[ebp], edx

; 829  : 
; 830  :         if (w == WSIZE)

	cmp	DWORD PTR _w$[ebp], 32768		; 00008000H
	jne	SHORT $LN1@inflate_st

; 831  :         {
; 832  :             FLUSH(w);

	mov	eax, DWORD PTR _cmp$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _w$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_flush
	add	esp, 16					; 00000010H

; 833  :             w = 0;

	mov	DWORD PTR _w$[ebp], 0
$LN1@inflate_st:

; 834  :         }
; 835  :         DUMPBITS(8)

	mov	ecx, DWORD PTR _b$[ebp]
	shr	ecx, 8
	mov	DWORD PTR _b$[ebp], ecx
	mov	edx, DWORD PTR _k$[ebp]
	sub	edx, 8
	mov	DWORD PTR _k$[ebp], edx

; 836  :     }

	jmp	$LN5@inflate_st
$LN4@inflate_st:

; 837  : 
; 838  :     /* restore the globals from the locals */
; 839  :     cmp->wp = w;                /* restore global window pointer */

	mov	eax, DWORD PTR _cmp$[ebp]
	mov	ecx, DWORD PTR _w$[ebp]
	mov	DWORD PTR [eax+28], ecx

; 840  :     cmp->bb = b;                /* restore global bit buffer */

	mov	edx, DWORD PTR _cmp$[ebp]
	mov	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR [edx+32], eax

; 841  :     cmp->bk = k;

	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	edx, DWORD PTR _k$[ebp]
	mov	DWORD PTR [ecx+36], edx

; 842  : 
; 843  :     return 0;

	xor	eax, eax
$LN11@inflate_st:

; 844  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_inflate_stored ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\inflate.c
_TEXT	SEGMENT
tv327 = -140						; size = 4
tv163 = -136						; size = 4
tv287 = -132						; size = 4
tv216 = -128						; size = 4
_md$ = -124						; size = 4
_ml$ = -120						; size = 4
tv249 = -116						; size = 4
tv93 = -112						; size = 4
tv276 = -108						; size = 4
tv94 = -104						; size = 4
tv82 = -100						; size = 4
tv162 = -96						; size = 4
tv217 = -92						; size = 4
tv286 = -88						; size = 4
tv205 = -84						; size = 4
tv250 = -80						; size = 4
tv347 = -76						; size = 4
tv238 = -72						; size = 4
tv344 = -68						; size = 4
tv215 = -64						; size = 4
tv328 = -60						; size = 4
tv164 = -56						; size = 4
tv326 = -52						; size = 4
tv152 = -48						; size = 4
tv316 = -44						; size = 4
tv92 = -40						; size = 4
tv288 = -36						; size = 4
tv248 = -32						; size = 4
_n$ = -28						; size = 4
_d$ = -24						; size = 4
_w$ = -20						; size = 4
_t$ = -16						; size = 4
_b$ = -12						; size = 4
_k$ = -8						; size = 4
_e$ = -4						; size = 4
_tl$ = 8						; size = 4
_td$ = 12						; size = 4
_bl$ = 16						; size = 4
_bd$ = 20						; size = 4
_cmp$ = 24						; size = 4
_inflate_codes PROC

; 664  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	push	esi

; 665  :     register unsigned e;        /* table entry flag/number of extra bits */
; 666  :     unsigned n,
; 667  :              d;                    /* length and index for copy */
; 668  :     unsigned w;                 /* current window position */
; 669  :     struct huft *t;             /* pointer to table entry */
; 670  :     unsigned ml,
; 671  :              md;                   /* masks for bl and bd bits */
; 672  :     register ulg b;             /* bit buffer */
; 673  :     register unsigned k;        /* number of bits in bit buffer */
; 674  : 
; 675  : 
; 676  :     /* make local copies of globals */
; 677  :     b = cmp->bb;                /* initialize bit buffer */

	mov	eax, DWORD PTR _cmp$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _b$[ebp], ecx

; 678  :     k = cmp->bk;

	mov	edx, DWORD PTR _cmp$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR _k$[ebp], eax

; 679  :     w = cmp->wp;                /* initialize window position */

	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR _w$[ebp], edx

; 680  : 
; 681  : 
; 682  :     /* inflate the coded data */
; 683  :     ml = mask[bl];              /* precompute masks for speed */

	mov	eax, DWORD PTR _bl$[ebp]
	movzx	ecx, WORD PTR _mask[eax*2]
	mov	DWORD PTR _ml$[ebp], ecx

; 684  :     md = mask[bd];

	mov	edx, DWORD PTR _bd$[ebp]
	movzx	eax, WORD PTR _mask[edx*2]
	mov	DWORD PTR _md$[ebp], eax
$LN37@inflate_co:

; 685  :     while (TRUE)                /* do until end of block */

	mov	ecx, 1
	test	ecx, ecx
	je	$LN36@inflate_co
$LN35@inflate_co:

; 686  :     {
; 687  :         NEEDBITS((unsigned)bl)

	mov	edx, DWORD PTR _k$[ebp]
	cmp	edx, DWORD PTR _bl$[ebp]
	jae	$LN34@inflate_co
	mov	eax, DWORD PTR _cmp$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR tv93[ebp], ecx
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	eax, DWORD PTR [edx+40]
	sub	eax, 1
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	DWORD PTR [ecx+40], eax
	cmp	DWORD PTR tv93[ebp], 0
	jg	SHORT $LN42@inflate_co
	mov	DWORD PTR tv94[ebp], -1
	jmp	SHORT $LN43@inflate_co
$LN42@inflate_co:
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	eax, DWORD PTR [edx+12]
	sub	eax, 1
	mov	DWORD PTR tv82[ebp], eax
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	edx, DWORD PTR tv82[ebp]
	mov	DWORD PTR [ecx+12], edx
	cmp	DWORD PTR tv82[ebp], 0
	jl	SHORT $LN40@inflate_co
	mov	eax, DWORD PTR _cmp$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR tv92[ebp], edx
	mov	eax, DWORD PTR _cmp$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 1
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	DWORD PTR [edx+8], ecx
	jmp	SHORT $LN41@inflate_co
$LN40@inflate_co:
	mov	eax, DWORD PTR _cmp$[ebp]
	push	eax
	call	_readbyte
	add	esp, 4
	mov	DWORD PTR tv92[ebp], eax
$LN41@inflate_co:
	mov	ecx, DWORD PTR tv92[ebp]
	mov	DWORD PTR tv94[ebp], ecx
$LN43@inflate_co:
	mov	edx, DWORD PTR tv94[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	shl	edx, cl
	or	edx, DWORD PTR _b$[ebp]
	mov	DWORD PTR _b$[ebp], edx
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 8
	mov	DWORD PTR _k$[ebp], eax
	jmp	$LN35@inflate_co
$LN34@inflate_co:

; 688  :         if ((e = (t = tl + ((unsigned)b & ml))->e) > 16)

	mov	ecx, DWORD PTR _b$[ebp]
	and	ecx, DWORD PTR _ml$[ebp]
	mov	edx, DWORD PTR _tl$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR _t$[ebp], eax
	mov	ecx, DWORD PTR _t$[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR _e$[ebp], edx
	cmp	DWORD PTR _e$[ebp], 16			; 00000010H
	jbe	$LN33@inflate_co
$LN32@inflate_co:

; 689  :         do
; 690  :         {
; 691  :             if (e == 99)

	cmp	DWORD PTR _e$[ebp], 99			; 00000063H
	jne	SHORT $LN29@inflate_co

; 692  :                 return 1;

	mov	eax, 1
	jmp	$LN38@inflate_co
$LN29@inflate_co:

; 693  :             DUMPBITS(t->b)

	mov	eax, DWORD PTR _t$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	mov	edx, DWORD PTR _b$[ebp]
	shr	edx, cl
	mov	DWORD PTR _b$[ebp], edx
	mov	eax, DWORD PTR _t$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	mov	edx, DWORD PTR _k$[ebp]
	sub	edx, ecx
	mov	DWORD PTR _k$[ebp], edx

; 694  :             e -= 16;

	mov	eax, DWORD PTR _e$[ebp]
	sub	eax, 16					; 00000010H
	mov	DWORD PTR _e$[ebp], eax
$LN28@inflate_co:

; 695  :             NEEDBITS(e)

	mov	ecx, DWORD PTR _k$[ebp]
	cmp	ecx, DWORD PTR _e$[ebp]
	jae	$LN31@inflate_co
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR tv163[ebp], eax
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	sub	edx, 1
	mov	eax, DWORD PTR _cmp$[ebp]
	mov	DWORD PTR [eax+40], edx
	cmp	DWORD PTR tv163[ebp], 0
	jg	SHORT $LN46@inflate_co
	mov	DWORD PTR tv164[ebp], -1
	jmp	SHORT $LN47@inflate_co
$LN46@inflate_co:
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	sub	edx, 1
	mov	DWORD PTR tv152[ebp], edx
	mov	eax, DWORD PTR _cmp$[ebp]
	mov	ecx, DWORD PTR tv152[ebp]
	mov	DWORD PTR [eax+12], ecx
	cmp	DWORD PTR tv152[ebp], 0
	jl	SHORT $LN44@inflate_co
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	eax, DWORD PTR [edx+8]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv162[ebp], ecx
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, 1
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	DWORD PTR [ecx+8], eax
	jmp	SHORT $LN45@inflate_co
$LN44@inflate_co:
	mov	edx, DWORD PTR _cmp$[ebp]
	push	edx
	call	_readbyte
	add	esp, 4
	mov	DWORD PTR tv162[ebp], eax
$LN45@inflate_co:
	mov	eax, DWORD PTR tv162[ebp]
	mov	DWORD PTR tv164[ebp], eax
$LN47@inflate_co:
	mov	edx, DWORD PTR tv164[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	shl	edx, cl
	or	edx, DWORD PTR _b$[ebp]
	mov	DWORD PTR _b$[ebp], edx
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 8
	mov	DWORD PTR _k$[ebp], eax
	jmp	$LN28@inflate_co
$LN31@inflate_co:

; 696  :         }
; 697  : 
; 698  :         while((e = (t = t->v.t + ((unsigned)b & mask[e]))->e) > 16) ;

	mov	ecx, DWORD PTR _e$[ebp]
	movzx	edx, WORD PTR _mask[ecx*2]
	and	edx, DWORD PTR _b$[ebp]
	mov	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	lea	edx, DWORD PTR [ecx+edx*8]
	mov	DWORD PTR _t$[ebp], edx
	mov	eax, DWORD PTR _t$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _e$[ebp], ecx
	cmp	DWORD PTR _e$[ebp], 16			; 00000010H
	ja	$LN32@inflate_co
$LN33@inflate_co:

; 699  : 
; 700  :         DUMPBITS(t->b)

	mov	edx, DWORD PTR _t$[ebp]
	movzx	ecx, BYTE PTR [edx+1]
	mov	eax, DWORD PTR _b$[ebp]
	shr	eax, cl
	mov	DWORD PTR _b$[ebp], eax
	mov	ecx, DWORD PTR _t$[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	mov	eax, DWORD PTR _k$[ebp]
	sub	eax, edx
	mov	DWORD PTR _k$[ebp], eax

; 701  : 
; 702  :         if (e == 16)        /* then it's a literal */

	cmp	DWORD PTR _e$[ebp], 16			; 00000010H
	jne	SHORT $LN26@inflate_co

; 703  :         {
; 704  :             cmp->slide[w++] = (uch) t->v.n;

	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _w$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	cl, BYTE PTR [ecx+4]
	mov	BYTE PTR [edx+eax], cl
	mov	edx, DWORD PTR _w$[ebp]
	add	edx, 1
	mov	DWORD PTR _w$[ebp], edx

; 705  :             if (w == WSIZE)

	cmp	DWORD PTR _w$[ebp], 32768		; 00008000H
	jne	SHORT $LN25@inflate_co

; 706  :             {
; 707  :                 FLUSH(w);

	mov	eax, DWORD PTR _cmp$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _w$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_flush
	add	esp, 16					; 00000010H

; 708  :                 w = 0;

	mov	DWORD PTR _w$[ebp], 0
$LN25@inflate_co:

; 709  :             }
; 710  :         }
; 711  :         else /* it's an EOB or a length */

	jmp	$LN24@inflate_co
$LN26@inflate_co:

; 712  :         {
; 713  :             /* exit if end of block */
; 714  :             if (e == 15)

	cmp	DWORD PTR _e$[ebp], 15			; 0000000fH
	jne	SHORT $LN22@inflate_co

; 715  :                 break;

	jmp	$LN36@inflate_co
$LN22@inflate_co:

; 716  : 
; 717  :             /* get length of block to copy */
; 718  :             NEEDBITS(e)

	mov	ecx, DWORD PTR _k$[ebp]
	cmp	ecx, DWORD PTR _e$[ebp]
	jae	$LN21@inflate_co
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR tv216[ebp], eax
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	sub	edx, 1
	mov	eax, DWORD PTR _cmp$[ebp]
	mov	DWORD PTR [eax+40], edx
	cmp	DWORD PTR tv216[ebp], 0
	jg	SHORT $LN50@inflate_co
	mov	DWORD PTR tv217[ebp], -1
	jmp	SHORT $LN51@inflate_co
$LN50@inflate_co:
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	sub	edx, 1
	mov	DWORD PTR tv205[ebp], edx
	mov	eax, DWORD PTR _cmp$[ebp]
	mov	ecx, DWORD PTR tv205[ebp]
	mov	DWORD PTR [eax+12], ecx
	cmp	DWORD PTR tv205[ebp], 0
	jl	SHORT $LN48@inflate_co
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	eax, DWORD PTR [edx+8]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv215[ebp], ecx
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, 1
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	DWORD PTR [ecx+8], eax
	jmp	SHORT $LN49@inflate_co
$LN48@inflate_co:
	mov	edx, DWORD PTR _cmp$[ebp]
	push	edx
	call	_readbyte
	add	esp, 4
	mov	DWORD PTR tv215[ebp], eax
$LN49@inflate_co:
	mov	eax, DWORD PTR tv215[ebp]
	mov	DWORD PTR tv217[ebp], eax
$LN51@inflate_co:
	mov	edx, DWORD PTR tv217[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	shl	edx, cl
	or	edx, DWORD PTR _b$[ebp]
	mov	DWORD PTR _b$[ebp], edx
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 8
	mov	DWORD PTR _k$[ebp], eax
	jmp	$LN22@inflate_co
$LN21@inflate_co:

; 719  :             n = t->v.n + ((unsigned)b & mask[e]);

	mov	ecx, DWORD PTR _t$[ebp]
	movzx	edx, WORD PTR [ecx+4]
	mov	eax, DWORD PTR _e$[ebp]
	movzx	ecx, WORD PTR _mask[eax*2]
	and	ecx, DWORD PTR _b$[ebp]
	add	edx, ecx
	mov	DWORD PTR _n$[ebp], edx

; 720  :             DUMPBITS(e);

	mov	edx, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR _e$[ebp]
	shr	edx, cl
	mov	DWORD PTR _b$[ebp], edx
	mov	eax, DWORD PTR _k$[ebp]
	sub	eax, DWORD PTR _e$[ebp]
	mov	DWORD PTR _k$[ebp], eax
$LN20@inflate_co:

; 721  : 
; 722  :             /* decode distance of block to copy */
; 723  :             NEEDBITS((unsigned)bd)

	mov	ecx, DWORD PTR _k$[ebp]
	cmp	ecx, DWORD PTR _bd$[ebp]
	jae	$LN19@inflate_co
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR tv249[ebp], eax
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	sub	edx, 1
	mov	eax, DWORD PTR _cmp$[ebp]
	mov	DWORD PTR [eax+40], edx
	cmp	DWORD PTR tv249[ebp], 0
	jg	SHORT $LN54@inflate_co
	mov	DWORD PTR tv250[ebp], -1
	jmp	SHORT $LN55@inflate_co
$LN54@inflate_co:
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	sub	edx, 1
	mov	DWORD PTR tv238[ebp], edx
	mov	eax, DWORD PTR _cmp$[ebp]
	mov	ecx, DWORD PTR tv238[ebp]
	mov	DWORD PTR [eax+12], ecx
	cmp	DWORD PTR tv238[ebp], 0
	jl	SHORT $LN52@inflate_co
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	eax, DWORD PTR [edx+8]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv248[ebp], ecx
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, 1
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	DWORD PTR [ecx+8], eax
	jmp	SHORT $LN53@inflate_co
$LN52@inflate_co:
	mov	edx, DWORD PTR _cmp$[ebp]
	push	edx
	call	_readbyte
	add	esp, 4
	mov	DWORD PTR tv248[ebp], eax
$LN53@inflate_co:
	mov	eax, DWORD PTR tv248[ebp]
	mov	DWORD PTR tv250[ebp], eax
$LN55@inflate_co:
	mov	edx, DWORD PTR tv250[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	shl	edx, cl
	or	edx, DWORD PTR _b$[ebp]
	mov	DWORD PTR _b$[ebp], edx
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 8
	mov	DWORD PTR _k$[ebp], eax
	jmp	$LN20@inflate_co
$LN19@inflate_co:

; 724  :             if ((e = (t = td + ((unsigned)b & md))->e) > 16)

	mov	ecx, DWORD PTR _b$[ebp]
	and	ecx, DWORD PTR _md$[ebp]
	mov	edx, DWORD PTR _td$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR _t$[ebp], eax
	mov	ecx, DWORD PTR _t$[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR _e$[ebp], edx
	cmp	DWORD PTR _e$[ebp], 16			; 00000010H
	jbe	$LN18@inflate_co
$LN17@inflate_co:

; 725  :                 do
; 726  :                 {
; 727  :                     if (e == 99)

	cmp	DWORD PTR _e$[ebp], 99			; 00000063H
	jne	SHORT $LN14@inflate_co

; 728  :                         return 1;

	mov	eax, 1
	jmp	$LN38@inflate_co
$LN14@inflate_co:

; 729  :                     DUMPBITS(t->b)

	mov	eax, DWORD PTR _t$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	mov	edx, DWORD PTR _b$[ebp]
	shr	edx, cl
	mov	DWORD PTR _b$[ebp], edx
	mov	eax, DWORD PTR _t$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	mov	edx, DWORD PTR _k$[ebp]
	sub	edx, ecx
	mov	DWORD PTR _k$[ebp], edx

; 730  :                     e -= 16;

	mov	eax, DWORD PTR _e$[ebp]
	sub	eax, 16					; 00000010H
	mov	DWORD PTR _e$[ebp], eax
$LN13@inflate_co:

; 731  :                     NEEDBITS(e)

	mov	ecx, DWORD PTR _k$[ebp]
	cmp	ecx, DWORD PTR _e$[ebp]
	jae	$LN16@inflate_co
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR tv287[ebp], eax
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	sub	edx, 1
	mov	eax, DWORD PTR _cmp$[ebp]
	mov	DWORD PTR [eax+40], edx
	cmp	DWORD PTR tv287[ebp], 0
	jg	SHORT $LN58@inflate_co
	mov	DWORD PTR tv288[ebp], -1
	jmp	SHORT $LN59@inflate_co
$LN58@inflate_co:
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	sub	edx, 1
	mov	DWORD PTR tv276[ebp], edx
	mov	eax, DWORD PTR _cmp$[ebp]
	mov	ecx, DWORD PTR tv276[ebp]
	mov	DWORD PTR [eax+12], ecx
	cmp	DWORD PTR tv276[ebp], 0
	jl	SHORT $LN56@inflate_co
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	eax, DWORD PTR [edx+8]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv286[ebp], ecx
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, 1
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	DWORD PTR [ecx+8], eax
	jmp	SHORT $LN57@inflate_co
$LN56@inflate_co:
	mov	edx, DWORD PTR _cmp$[ebp]
	push	edx
	call	_readbyte
	add	esp, 4
	mov	DWORD PTR tv286[ebp], eax
$LN57@inflate_co:
	mov	eax, DWORD PTR tv286[ebp]
	mov	DWORD PTR tv288[ebp], eax
$LN59@inflate_co:
	mov	edx, DWORD PTR tv288[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	shl	edx, cl
	or	edx, DWORD PTR _b$[ebp]
	mov	DWORD PTR _b$[ebp], edx
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 8
	mov	DWORD PTR _k$[ebp], eax
	jmp	$LN13@inflate_co
$LN16@inflate_co:

; 732  :                 }
; 733  : 
; 734  :             while ((e = (t = t->v.t + ((unsigned)b & mask[e]))->e) > 16) ;

	mov	ecx, DWORD PTR _e$[ebp]
	movzx	edx, WORD PTR _mask[ecx*2]
	and	edx, DWORD PTR _b$[ebp]
	mov	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	lea	edx, DWORD PTR [ecx+edx*8]
	mov	DWORD PTR _t$[ebp], edx
	mov	eax, DWORD PTR _t$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _e$[ebp], ecx
	cmp	DWORD PTR _e$[ebp], 16			; 00000010H
	ja	$LN17@inflate_co
$LN18@inflate_co:

; 735  : 
; 736  :             DUMPBITS(t->b)

	mov	edx, DWORD PTR _t$[ebp]
	movzx	ecx, BYTE PTR [edx+1]
	mov	eax, DWORD PTR _b$[ebp]
	shr	eax, cl
	mov	DWORD PTR _b$[ebp], eax
	mov	ecx, DWORD PTR _t$[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	mov	eax, DWORD PTR _k$[ebp]
	sub	eax, edx
	mov	DWORD PTR _k$[ebp], eax
$LN11@inflate_co:

; 737  :             NEEDBITS(e)

	mov	ecx, DWORD PTR _k$[ebp]
	cmp	ecx, DWORD PTR _e$[ebp]
	jae	$LN10@inflate_co
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR tv327[ebp], eax
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	sub	edx, 1
	mov	eax, DWORD PTR _cmp$[ebp]
	mov	DWORD PTR [eax+40], edx
	cmp	DWORD PTR tv327[ebp], 0
	jg	SHORT $LN62@inflate_co
	mov	DWORD PTR tv328[ebp], -1
	jmp	SHORT $LN63@inflate_co
$LN62@inflate_co:
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	sub	edx, 1
	mov	DWORD PTR tv316[ebp], edx
	mov	eax, DWORD PTR _cmp$[ebp]
	mov	ecx, DWORD PTR tv316[ebp]
	mov	DWORD PTR [eax+12], ecx
	cmp	DWORD PTR tv316[ebp], 0
	jl	SHORT $LN60@inflate_co
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	eax, DWORD PTR [edx+8]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv326[ebp], ecx
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, 1
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	DWORD PTR [ecx+8], eax
	jmp	SHORT $LN61@inflate_co
$LN60@inflate_co:
	mov	edx, DWORD PTR _cmp$[ebp]
	push	edx
	call	_readbyte
	add	esp, 4
	mov	DWORD PTR tv326[ebp], eax
$LN61@inflate_co:
	mov	eax, DWORD PTR tv326[ebp]
	mov	DWORD PTR tv328[ebp], eax
$LN63@inflate_co:
	mov	edx, DWORD PTR tv328[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	shl	edx, cl
	or	edx, DWORD PTR _b$[ebp]
	mov	DWORD PTR _b$[ebp], edx
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 8
	mov	DWORD PTR _k$[ebp], eax
	jmp	$LN11@inflate_co
$LN10@inflate_co:

; 738  :             d = w - t->v.n - ((unsigned)b & mask[e]);

	mov	ecx, DWORD PTR _t$[ebp]
	movzx	edx, WORD PTR [ecx+4]
	mov	eax, DWORD PTR _w$[ebp]
	sub	eax, edx
	mov	ecx, DWORD PTR _e$[ebp]
	movzx	edx, WORD PTR _mask[ecx*2]
	and	edx, DWORD PTR _b$[ebp]
	sub	eax, edx
	mov	DWORD PTR _d$[ebp], eax

; 739  :             DUMPBITS(e)

	mov	eax, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR _e$[ebp]
	shr	eax, cl
	mov	DWORD PTR _b$[ebp], eax
	mov	ecx, DWORD PTR _k$[ebp]
	sub	ecx, DWORD PTR _e$[ebp]
	mov	DWORD PTR _k$[ebp], ecx
$LN9@inflate_co:

; 740  : 
; 741  :             /* do the copy */
; 742  :             do
; 743  :             {
; 744  :                 n -= (e = (e = WSIZE - ((d &= WSIZE - 1) > w ? d : w)) > n ? n : e);

	mov	edx, DWORD PTR _d$[ebp]
	and	edx, 32767				; 00007fffH
	mov	DWORD PTR _d$[ebp], edx
	mov	eax, DWORD PTR _d$[ebp]
	cmp	eax, DWORD PTR _w$[ebp]
	jbe	SHORT $LN64@inflate_co
	mov	ecx, DWORD PTR _d$[ebp]
	mov	DWORD PTR tv344[ebp], ecx
	jmp	SHORT $LN65@inflate_co
$LN64@inflate_co:
	mov	edx, DWORD PTR _w$[ebp]
	mov	DWORD PTR tv344[ebp], edx
$LN65@inflate_co:
	mov	eax, 32768				; 00008000H
	sub	eax, DWORD PTR tv344[ebp]
	mov	DWORD PTR _e$[ebp], eax
	mov	ecx, DWORD PTR _e$[ebp]
	cmp	ecx, DWORD PTR _n$[ebp]
	jbe	SHORT $LN66@inflate_co
	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR tv347[ebp], edx
	jmp	SHORT $LN67@inflate_co
$LN66@inflate_co:
	mov	eax, DWORD PTR _e$[ebp]
	mov	DWORD PTR tv347[ebp], eax
$LN67@inflate_co:
	mov	ecx, DWORD PTR tv347[ebp]
	mov	DWORD PTR _e$[ebp], ecx
	mov	edx, DWORD PTR _n$[ebp]
	sub	edx, DWORD PTR _e$[ebp]
	mov	DWORD PTR _n$[ebp], edx

; 745  : #ifndef NOMEMCPY
; 746  :                 if (w - d >= e) /* (this test assumes unsigned comparison) */

	mov	eax, DWORD PTR _w$[ebp]
	sub	eax, DWORD PTR _d$[ebp]
	cmp	eax, DWORD PTR _e$[ebp]
	jb	SHORT $LN4@inflate_co

; 747  :                 {
; 748  :                     memcpy((void *)(cmp->slide + w), (void *)(cmp->slide + d), e);

	mov	ecx, DWORD PTR _e$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, DWORD PTR _d$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, DWORD PTR _w$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 749  :                     w += e;

	mov	eax, DWORD PTR _w$[ebp]
	add	eax, DWORD PTR _e$[ebp]
	mov	DWORD PTR _w$[ebp], eax

; 750  :                     d += e;

	mov	ecx, DWORD PTR _d$[ebp]
	add	ecx, DWORD PTR _e$[ebp]
	mov	DWORD PTR _d$[ebp], ecx

; 751  :                 }
; 752  :                 else            /* do it slow to avoid memcpy() overlap */

	jmp	SHORT $LN5@inflate_co
$LN4@inflate_co:

; 753  : #endif  /* !NOMEMCPY */
; 754  :                     do
; 755  :                     {
; 756  :                         cmp->slide[w++] = cmp->slide[d++];

	mov	edx, DWORD PTR _cmp$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _w$[ebp]
	mov	esi, DWORD PTR _d$[ebp]
	mov	al, BYTE PTR [eax+esi]
	mov	BYTE PTR [edx+ecx], al
	mov	ecx, DWORD PTR _w$[ebp]
	add	ecx, 1
	mov	DWORD PTR _w$[ebp], ecx
	mov	edx, DWORD PTR _d$[ebp]
	add	edx, 1
	mov	DWORD PTR _d$[ebp], edx

; 757  :                     } while(--e);

	mov	eax, DWORD PTR _e$[ebp]
	sub	eax, 1
	mov	DWORD PTR _e$[ebp], eax
	jne	SHORT $LN4@inflate_co
$LN5@inflate_co:

; 758  : 
; 759  :                 if (w == WSIZE)

	cmp	DWORD PTR _w$[ebp], 32768		; 00008000H
	jne	SHORT $LN8@inflate_co

; 760  :                 {
; 761  :                     FLUSH(w);

	mov	ecx, DWORD PTR _cmp$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _w$[ebp]
	push	edx
	mov	eax, DWORD PTR _cmp$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_flush
	add	esp, 16					; 00000010H

; 762  :                     w = 0;

	mov	DWORD PTR _w$[ebp], 0
$LN8@inflate_co:

; 763  :                 }
; 764  : 
; 765  :             } while (n);

	cmp	DWORD PTR _n$[ebp], 0
	jne	$LN9@inflate_co
$LN24@inflate_co:

; 766  :         }
; 767  :     }

	jmp	$LN37@inflate_co
$LN36@inflate_co:

; 768  : 
; 769  : 
; 770  :     /* restore the globals from the locals */
; 771  :     cmp->wp = w;                /* restore global window pointer */

	mov	edx, DWORD PTR _cmp$[ebp]
	mov	eax, DWORD PTR _w$[ebp]
	mov	DWORD PTR [edx+28], eax

; 772  :     cmp->bb = b;                /* restore global bit buffer */

	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	edx, DWORD PTR _b$[ebp]
	mov	DWORD PTR [ecx+32], edx

; 773  :     cmp->bk = k;

	mov	eax, DWORD PTR _cmp$[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	mov	DWORD PTR [eax+36], ecx

; 774  : 
; 775  : 
; 776  :     /* done */
; 777  :     return 0;

	xor	eax, eax
$LN38@inflate_co:

; 778  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_inflate_codes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\inflate.c
_TEXT	SEGMENT
_q$ = -8						; size = 4
_p$ = -4						; size = 4
_t$ = 8							; size = 4
_huft_free PROC

; 625  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 626  :     register struct huft *p, *q;
; 627  : 
; 628  :     /* Go through linked list, freeing from the malloced (t[-1]) address. */
; 629  : 
; 630  :     p = t;

	mov	eax, DWORD PTR _t$[ebp]
	mov	DWORD PTR _p$[ebp], eax
$LN2@huft_free:

; 631  : 
; 632  :     while( p != (struct huft *)NULL )

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN1@huft_free

; 633  :     {
; 634  :         q = (--p)->v.t;

	mov	ecx, DWORD PTR _p$[ebp]
	sub	ecx, 8
	mov	DWORD PTR _p$[ebp], ecx
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _q$[ebp], eax

; 635  : 		#ifdef USE_SH_POOLS
; 636  :         MemFreePtr(p);
; 637  : 		#else
; 638  :         MemFree(p);

	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	_free
	add	esp, 4

; 639  : 		#endif
; 640  :         p = q;

	mov	edx, DWORD PTR _q$[ebp]
	mov	DWORD PTR _p$[ebp], edx

; 641  :     }

	jmp	SHORT $LN2@huft_free
$LN1@huft_free:

; 642  : 
; 643  :     return 0;

	xor	eax, eax

; 644  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_huft_free ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\inflate.c
_TEXT	SEGMENT
_u$ = -364						; size = 64
tv157 = -300						; size = 4
tv181 = -296						; size = 4
tv192 = -292						; size = 4
tv68 = -288						; size = 4
tv328 = -284						; size = 4
tv290 = -280						; size = 4
_g$ = -276						; size = 4
_el$ = -272						; size = 4
_a$ = -268						; size = 4
_r$ = -264						; size = 8
_l$ = -256						; size = 4
_xp$ = -252						; size = 4
_z$ = -248						; size = 4
_q$ = -244						; size = 4
_f$ = -240						; size = 4
_k$ = -236						; size = 4
_y$ = -232						; size = 4
_w$ = -228						; size = 4
_h$ = -224						; size = 4
_p$ = -220						; size = 4
_i$ = -216						; size = 4
_j$ = -212						; size = 4
_lx$ = -208						; size = 68
_x$ = -140						; size = 68
_c$ = -72						; size = 68
__$ArrayPad$ = -4					; size = 4
_b$ = 8							; size = 4
_n$ = 12						; size = 4
_s$ = 16						; size = 4
_d$ = 20						; size = 4
_e$ = 24						; size = 4
_t$ = 28						; size = 4
_m$ = 32						; size = 4
_huft_build PROC

; 413  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 364				; 0000016cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 414  :   unsigned a;                   /* counter for codes of length k */
; 415  :   unsigned c[BMAX+1];           /* bit length count table */
; 416  :   unsigned el;                  /* length of EOB code (value 256) */
; 417  :   unsigned f;                   /* i repeats in table every f entries */
; 418  :   int g;                        /* maximum code length */
; 419  :   int h;                        /* table level */
; 420  :   register unsigned i;          /* counter, current code */
; 421  :   register unsigned j;          /* counter */
; 422  :   register int k;               /* number of bits in current code */
; 423  :   int lx[BMAX+1];               /* memory for l[-1..BMAX-1] */
; 424  :   int *l = lx+1;                /* stack of bits per table */

	lea	eax, DWORD PTR _lx$[ebp+4]
	mov	DWORD PTR _l$[ebp], eax

; 425  :   register unsigned *p;         /* pointer into c[], b[], or v[] */
; 426  :   register struct huft *q;      /* points to current table */
; 427  :   struct huft r;                /* table entry for structure assignment */
; 428  :   struct huft *u[BMAX];         /* table stack */
; 429  :   static unsigned v[N_MAX];     /* values in order of bit length */
; 430  :   register int w;               /* bits before this table == (l * h) */
; 431  :   unsigned x[BMAX+1];           /* bit offsets, then code stack */
; 432  :   unsigned *xp;                 /* pointer into x */
; 433  :   int y;                        /* number of dummy codes added */
; 434  :   unsigned z;                   /* number of entries in current table */
; 435  : 
; 436  : 
; 437  :   /* Generate counts for each bit length */
; 438  :   el = n > 256 ? b[256] : BMAX; /* set length of EOB code, if any */

	cmp	DWORD PTR _n$[ebp], 256			; 00000100H
	jbe	SHORT $LN55@huft_build
	mov	ecx, 4
	shl	ecx, 8
	mov	edx, DWORD PTR _b$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	mov	DWORD PTR tv68[ebp], eax
	jmp	SHORT $LN56@huft_build
$LN55@huft_build:
	mov	DWORD PTR tv68[ebp], 16			; 00000010H
$LN56@huft_build:
	mov	ecx, DWORD PTR tv68[ebp]
	mov	DWORD PTR _el$[ebp], ecx

; 439  :   memzero((char *)c, sizeof(c));

	push	68					; 00000044H
	push	0
	lea	edx, DWORD PTR _c$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 440  :   p = b;  i = n;

	mov	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR _p$[ebp], eax
	mov	ecx, DWORD PTR _n$[ebp]
	mov	DWORD PTR _i$[ebp], ecx
$LN52@huft_build:

; 441  :   do {
; 442  :     c[*p]++; p++;               /* assume all entries <= BMAX */

	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _c$[ebp+eax*4]
	add	ecx, 1
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _c$[ebp+eax*4], ecx
	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 4
	mov	DWORD PTR _p$[ebp], ecx

; 443  :   } while (--i);

	mov	edx, DWORD PTR _i$[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	jne	SHORT $LN52@huft_build

; 444  :   if (c[0] == n)                /* null input--all zero length codes */

	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _c$[ebp+eax]
	cmp	ecx, DWORD PTR _n$[ebp]
	jne	SHORT $LN49@huft_build

; 445  :   {
; 446  :     *t = (struct huft *)NULL;

	mov	edx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [edx], 0

; 447  :     *m = 0;

	mov	eax, DWORD PTR _m$[ebp]
	mov	DWORD PTR [eax], 0

; 448  :     return 0;

	xor	eax, eax
	jmp	$LN53@huft_build
$LN49@huft_build:

; 449  :   }
; 450  : 
; 451  : 
; 452  :   /* Find minimum and maximum length, bound *m by those */
; 453  :   for (j = 1; j <= BMAX; j++)

	mov	DWORD PTR _j$[ebp], 1
	jmp	SHORT $LN48@huft_build
$LN47@huft_build:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$LN48@huft_build:
	cmp	DWORD PTR _j$[ebp], 16			; 00000010H
	ja	SHORT $LN46@huft_build

; 454  :     if (c[j])

	mov	edx, DWORD PTR _j$[ebp]
	cmp	DWORD PTR _c$[ebp+edx*4], 0
	je	SHORT $LN45@huft_build

; 455  :       break;

	jmp	SHORT $LN46@huft_build
$LN45@huft_build:

; 456  :   k = j;                        /* minimum code length */

	jmp	SHORT $LN47@huft_build
$LN46@huft_build:
	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR _k$[ebp], eax

; 457  :   if ((unsigned)*m < j)

	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR _j$[ebp]
	jae	SHORT $LN44@huft_build

; 458  :     *m = j;

	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [eax], ecx
$LN44@huft_build:

; 459  :   for (i = BMAX; i; i--)

	mov	DWORD PTR _i$[ebp], 16			; 00000010H
	jmp	SHORT $LN43@huft_build
$LN42@huft_build:
	mov	edx, DWORD PTR _i$[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN43@huft_build:
	cmp	DWORD PTR _i$[ebp], 0
	je	SHORT $LN41@huft_build

; 460  :     if (c[i])

	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _c$[ebp+eax*4], 0
	je	SHORT $LN40@huft_build

; 461  :       break;

	jmp	SHORT $LN41@huft_build
$LN40@huft_build:

; 462  :   g = i;                        /* maximum code length */

	jmp	SHORT $LN42@huft_build
$LN41@huft_build:
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _g$[ebp], ecx

; 463  :   if ((unsigned)*m > i)

	mov	edx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _i$[ebp]
	jbe	SHORT $LN39@huft_build

; 464  :     *m = i;

	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [ecx], edx
$LN39@huft_build:

; 465  : 
; 466  : 
; 467  :   /* Adjust last length count to fill out codes, if needed */
; 468  :   for (y = 1 << j; j < i; j++, y <<= 1)

	mov	eax, 1
	mov	ecx, DWORD PTR _j$[ebp]
	shl	eax, cl
	mov	DWORD PTR _y$[ebp], eax
	jmp	SHORT $LN38@huft_build
$LN37@huft_build:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
	mov	edx, DWORD PTR _y$[ebp]
	shl	edx, 1
	mov	DWORD PTR _y$[ebp], edx
$LN38@huft_build:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _i$[ebp]
	jae	SHORT $LN36@huft_build

; 469  :     if ((y -= c[j]) < 0)

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _y$[ebp]
	sub	edx, DWORD PTR _c$[ebp+ecx*4]
	mov	DWORD PTR _y$[ebp], edx
	jns	SHORT $LN35@huft_build

; 470  :       return 2;                 /* bad input: more codes than bits */

	mov	eax, 2
	jmp	$LN53@huft_build
$LN35@huft_build:

; 471  :   if ((y -= c[i]) < 0)

	jmp	SHORT $LN37@huft_build
$LN36@huft_build:
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _y$[ebp]
	sub	ecx, DWORD PTR _c$[ebp+eax*4]
	mov	DWORD PTR _y$[ebp], ecx
	jns	SHORT $LN34@huft_build

; 472  :     return 2;

	mov	eax, 2
	jmp	$LN53@huft_build
$LN34@huft_build:

; 473  :   c[i] += y;

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _c$[ebp+edx*4]
	add	eax, DWORD PTR _y$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _c$[ebp+ecx*4], eax

; 474  : 
; 475  : 
; 476  :   /* Generate starting offsets into the value table for each length */
; 477  :   x[1] = j = 0;

	mov	DWORD PTR _j$[ebp], 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR _x$[ebp+edx], eax

; 478  :   p = c + 1;  xp = x + 2;

	lea	ecx, DWORD PTR _c$[ebp+4]
	mov	DWORD PTR _p$[ebp], ecx
	lea	edx, DWORD PTR _x$[ebp+8]
	mov	DWORD PTR _xp$[ebp], edx
$LN33@huft_build:

; 479  :   while (--i) {                 /* note that i == g from above */

	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	je	SHORT $LN32@huft_build

; 480  :     *xp++ = (j += *p++);

	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, DWORD PTR [ecx]
	mov	DWORD PTR _j$[ebp], edx
	mov	eax, DWORD PTR _xp$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _xp$[ebp]
	add	edx, 4
	mov	DWORD PTR _xp$[ebp], edx
	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 4
	mov	DWORD PTR _p$[ebp], eax

; 481  :   }

	jmp	SHORT $LN33@huft_build
$LN32@huft_build:

; 482  : 
; 483  : 
; 484  :   /* Make a table of values in order of bit lengths */
; 485  :   p = b;  i = 0;

	mov	ecx, DWORD PTR _b$[ebp]
	mov	DWORD PTR _p$[ebp], ecx
	mov	DWORD PTR _i$[ebp], 0
$LN31@huft_build:

; 486  :   do {
; 487  :     if ((j = *p++) != 0)

	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _j$[ebp], eax
	mov	ecx, DWORD PTR _j$[ebp]
	mov	DWORD PTR tv157[ebp], ecx
	mov	edx, DWORD PTR _p$[ebp]
	add	edx, 4
	mov	DWORD PTR _p$[ebp], edx
	cmp	DWORD PTR tv157[ebp], 0
	je	SHORT $LN30@huft_build

; 488  :       v[x[j]++] = i;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _x$[ebp+eax*4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR ?v@?1??huft_build@@9@9[ecx*4], edx
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _x$[ebp+eax*4]
	add	ecx, 1
	mov	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR _x$[ebp+edx*4], ecx
$LN30@huft_build:

; 489  :   } while (++i < n);

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _n$[ebp]
	jb	$LN31@huft_build

; 490  : 
; 491  : 
; 492  :   /* Generate the Huffman codes and for each, make the table entries */
; 493  :   x[0] = i = 0;                 /* first Huffman code is zero */

	mov	DWORD PTR _i$[ebp], 0
	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _x$[ebp+edx], eax

; 494  :   p = v;                        /* grab values in bit order */

	mov	DWORD PTR _p$[ebp], OFFSET ?v@?1??huft_build@@9@9

; 495  :   h = -1;                       /* no tables yet--level -1 */

	mov	DWORD PTR _h$[ebp], -1

; 496  :   w = l[-1] = 0;                /* no bits decoded yet */

	mov	ecx, 4
	imul	ecx, -1
	mov	edx, DWORD PTR _l$[ebp]
	mov	DWORD PTR [edx+ecx], 0
	mov	DWORD PTR _w$[ebp], 0

; 497  :   u[0] = (struct huft *)NULL;   /* just to keep compilers happy */

	mov	eax, 4
	imul	eax, 0
	mov	DWORD PTR _u$[ebp+eax], 0

; 498  :   q = (struct huft *)NULL;      /* ditto */

	mov	DWORD PTR _q$[ebp], 0

; 499  :   z = 0;                        /* ditto */

	mov	DWORD PTR _z$[ebp], 0

; 500  : 
; 501  :   /* go through the bit lengths (k already is bits in shortest code) */
; 502  :   for (; k <= g; k++)

	jmp	SHORT $LN27@huft_build
$LN26@huft_build:
	mov	ecx, DWORD PTR _k$[ebp]
	add	ecx, 1
	mov	DWORD PTR _k$[ebp], ecx
$LN27@huft_build:
	mov	edx, DWORD PTR _k$[ebp]
	cmp	edx, DWORD PTR _g$[ebp]
	jg	$LN25@huft_build

; 503  :   {
; 504  :     a = c[k];

	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _c$[ebp+eax*4]
	mov	DWORD PTR _a$[ebp], ecx
$LN24@huft_build:

; 505  :     while (a--)

	mov	edx, DWORD PTR _a$[ebp]
	mov	DWORD PTR tv181[ebp], edx
	mov	eax, DWORD PTR _a$[ebp]
	sub	eax, 1
	mov	DWORD PTR _a$[ebp], eax
	cmp	DWORD PTR tv181[ebp], 0
	je	$LN23@huft_build
$LN22@huft_build:

; 506  :     {
; 507  :       /* here i is the Huffman code of length k bits for value *p */
; 508  :       /* make tables up to required level */
; 509  :       while (k > w + l[h])

	mov	ecx, DWORD PTR _h$[ebp]
	mov	edx, DWORD PTR _l$[ebp]
	mov	eax, DWORD PTR _w$[ebp]
	add	eax, DWORD PTR [edx+ecx*4]
	cmp	DWORD PTR _k$[ebp], eax
	jle	$LN21@huft_build

; 510  :       {
; 511  :         w += l[h++];            /* add bits already decoded */

	mov	ecx, DWORD PTR _h$[ebp]
	mov	edx, DWORD PTR _l$[ebp]
	mov	eax, DWORD PTR _w$[ebp]
	add	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _w$[ebp], eax
	mov	ecx, DWORD PTR _h$[ebp]
	add	ecx, 1
	mov	DWORD PTR _h$[ebp], ecx

; 512  : 
; 513  :         /* compute minimum size table less than or equal to *m bits */
; 514  :         z = (z = g - w) > (unsigned)*m ? *m : z;        /* upper limit */

	mov	edx, DWORD PTR _g$[ebp]
	sub	edx, DWORD PTR _w$[ebp]
	mov	DWORD PTR _z$[ebp], edx
	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR _z$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jbe	SHORT $LN57@huft_build
	mov	edx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv192[ebp], eax
	jmp	SHORT $LN58@huft_build
$LN57@huft_build:
	mov	ecx, DWORD PTR _z$[ebp]
	mov	DWORD PTR tv192[ebp], ecx
$LN58@huft_build:
	mov	edx, DWORD PTR tv192[ebp]
	mov	DWORD PTR _z$[ebp], edx

; 515  :         if ((f = 1 << (j = k - w)) > a + 1)     /* try a k-w bit table */

	mov	eax, DWORD PTR _k$[ebp]
	sub	eax, DWORD PTR _w$[ebp]
	mov	DWORD PTR _j$[ebp], eax
	mov	edx, 1
	mov	ecx, DWORD PTR _j$[ebp]
	shl	edx, cl
	mov	DWORD PTR _f$[ebp], edx
	mov	eax, DWORD PTR _a$[ebp]
	add	eax, 1
	cmp	DWORD PTR _f$[ebp], eax
	jbe	$LN20@huft_build

; 516  :         {                       /* too few codes for k-w bit table */
; 517  :           f -= a + 1;           /* deduct codes from patterns left */

	mov	ecx, DWORD PTR _a$[ebp]
	add	ecx, 1
	mov	edx, DWORD PTR _f$[ebp]
	sub	edx, ecx
	mov	DWORD PTR _f$[ebp], edx

; 518  :           xp = c + k;

	mov	eax, DWORD PTR _k$[ebp]
	lea	ecx, DWORD PTR _c$[ebp+eax*4]
	mov	DWORD PTR _xp$[ebp], ecx
$LN19@huft_build:

; 519  :           while (++j < z)       /* try smaller tables up to z bits */

	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _z$[ebp]
	jae	SHORT $LN20@huft_build

; 520  :           {
; 521  :             if ((f <<= 1) <= *++xp)

	mov	ecx, DWORD PTR _f$[ebp]
	shl	ecx, 1
	mov	DWORD PTR _f$[ebp], ecx
	mov	edx, DWORD PTR _xp$[ebp]
	add	edx, 4
	mov	DWORD PTR _xp$[ebp], edx
	mov	eax, DWORD PTR _xp$[ebp]
	mov	ecx, DWORD PTR _f$[ebp]
	cmp	ecx, DWORD PTR [eax]
	ja	SHORT $LN17@huft_build

; 522  :               break;            /* enough codes to use up j bits */

	jmp	SHORT $LN20@huft_build
$LN17@huft_build:

; 523  :             f -= *xp;           /* else deduct codes from patterns */

	mov	edx, DWORD PTR _xp$[ebp]
	mov	eax, DWORD PTR _f$[ebp]
	sub	eax, DWORD PTR [edx]
	mov	DWORD PTR _f$[ebp], eax

; 524  :           }

	jmp	SHORT $LN19@huft_build
$LN20@huft_build:

; 525  :         }
; 526  :         if (w + j > el && (unsigned)w < el)

	mov	ecx, DWORD PTR _w$[ebp]
	add	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR _el$[ebp]
	jbe	SHORT $LN16@huft_build
	mov	edx, DWORD PTR _w$[ebp]
	cmp	edx, DWORD PTR _el$[ebp]
	jae	SHORT $LN16@huft_build

; 527  :           j = el - w;           /* make EOB code end at table */

	mov	eax, DWORD PTR _el$[ebp]
	sub	eax, DWORD PTR _w$[ebp]
	mov	DWORD PTR _j$[ebp], eax
$LN16@huft_build:

; 528  :         z = 1 << j;             /* table entries for j-bit table */

	mov	edx, 1
	mov	ecx, DWORD PTR _j$[ebp]
	shl	edx, cl
	mov	DWORD PTR _z$[ebp], edx

; 529  :         l[h] = j;               /* set table size in stack */

	mov	eax, DWORD PTR _h$[ebp]
	mov	ecx, DWORD PTR _l$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 530  : 
; 531  :         /* allocate and link in new table */
; 532  : 		#ifdef USE_SH_POOLS
; 533  :         if ((q = (struct huft *)MemAllocPtr(gResmgrMemPool, (z + 1)*sizeof(struct huft), 0)) ==
; 534  :             (struct huft *)NULL)
; 535  :         {
; 536  :           if (h)
; 537  :             huft_free(u[0]);
; 538  :           return 3;             /* not enough memory */
; 539  :         }
; 540  : 		#else
; 541  :         if ((q = (struct huft *)MemMalloc((z + 1)*sizeof(struct huft), "huft")) ==
; 542  :             (struct huft *)NULL)

	mov	eax, DWORD PTR _z$[ebp]
	lea	ecx, DWORD PTR [eax*8+8]
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _q$[ebp], eax
	cmp	DWORD PTR _q$[ebp], 0
	jne	SHORT $LN15@huft_build

; 543  :         {
; 544  :           if (h)

	cmp	DWORD PTR _h$[ebp], 0
	je	SHORT $LN14@huft_build

; 545  :             huft_free(u[0]);

	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _u$[ebp+edx]
	push	eax
	call	_huft_free
	add	esp, 4
$LN14@huft_build:

; 546  :           return 3;             /* not enough memory */

	mov	eax, 3
	jmp	$LN53@huft_build
$LN15@huft_build:

; 547  :         }
; 548  : 		#endif
; 549  :         hufts += z + 1;         /* track memory usage */

	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR _hufts
	lea	eax, DWORD PTR [edx+ecx+1]
	mov	DWORD PTR _hufts, eax

; 550  :         *t = q + 1;             /* link to list for huft_free() */

	mov	ecx, DWORD PTR _q$[ebp]
	add	ecx, 8
	mov	edx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [edx], ecx

; 551  :         *(t = &(q->v.t)) = (struct huft *)NULL;

	mov	eax, DWORD PTR _q$[ebp]
	add	eax, 4
	mov	DWORD PTR _t$[ebp], eax
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [ecx], 0

; 552  :         u[h] = ++q;             /* table starts after link */

	mov	edx, DWORD PTR _q$[ebp]
	add	edx, 8
	mov	DWORD PTR _q$[ebp], edx
	mov	eax, DWORD PTR _h$[ebp]
	mov	ecx, DWORD PTR _q$[ebp]
	mov	DWORD PTR _u$[ebp+eax*4], ecx

; 553  : 
; 554  :         /* connect to last table, if there is one */
; 555  :         if (h)

	cmp	DWORD PTR _h$[ebp], 0
	je	$LN13@huft_build

; 556  :         {
; 557  :           x[h] = i;             /* save pattern for backing up */

	mov	edx, DWORD PTR _h$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _x$[ebp+edx*4], eax

; 558  :           r.b = (uch)l[h-1];    /* bits to dump before this table */

	mov	ecx, DWORD PTR _h$[ebp]
	mov	edx, DWORD PTR _l$[ebp]
	mov	al, BYTE PTR [edx+ecx*4-4]
	mov	BYTE PTR _r$[ebp+1], al

; 559  :           r.e = (uch)(16 + j);  /* bits in this table */

	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 16					; 00000010H
	mov	BYTE PTR _r$[ebp], cl

; 560  :           r.v.t = q;            /* pointer to this table */

	mov	edx, DWORD PTR _q$[ebp]
	mov	DWORD PTR _r$[ebp+4], edx

; 561  :           j = (i & ((1 << w) - 1)) >> (w - l[h-1]);

	mov	eax, 1
	mov	ecx, DWORD PTR _w$[ebp]
	shl	eax, cl
	sub	eax, 1
	and	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _h$[ebp]
	mov	edx, DWORD PTR _l$[ebp]
	mov	esi, DWORD PTR _w$[ebp]
	sub	esi, DWORD PTR [edx+ecx*4-4]
	mov	ecx, esi
	shr	eax, cl
	mov	DWORD PTR _j$[ebp], eax

; 562  :           u[h-1][j] = r;        /* connect to last table */

	mov	eax, DWORD PTR _h$[ebp]
	mov	ecx, DWORD PTR _u$[ebp+eax*4-4]
	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _r$[ebp]
	mov	DWORD PTR [ecx+edx*8], eax
	mov	eax, DWORD PTR _r$[ebp+4]
	mov	DWORD PTR [ecx+edx*8+4], eax
$LN13@huft_build:

; 563  :         }
; 564  :       }

	jmp	$LN22@huft_build
$LN21@huft_build:

; 565  : 
; 566  :       /* set up table entry in r */
; 567  :       r.b = (uch)(k - w);

	mov	ecx, DWORD PTR _k$[ebp]
	sub	ecx, DWORD PTR _w$[ebp]
	mov	BYTE PTR _r$[ebp+1], cl

; 568  :       if (p >= v + n)

	mov	edx, DWORD PTR _n$[ebp]
	lea	eax, DWORD PTR ?v@?1??huft_build@@9@9[edx*4]
	cmp	DWORD PTR _p$[ebp], eax
	jb	SHORT $LN12@huft_build

; 569  :         r.e = 99;               /* out of values--invalid code */

	mov	BYTE PTR _r$[ebp], 99			; 00000063H
	jmp	$LN11@huft_build
$LN12@huft_build:

; 570  :       else if (*p < s)

	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR _s$[ebp]
	jae	SHORT $LN10@huft_build

; 571  :       {
; 572  :         r.e = (uch)(*p < 256 ? 16 : 15);    /* 256 is end-of-block code */

	mov	eax, DWORD PTR _p$[ebp]
	cmp	DWORD PTR [eax], 256			; 00000100H
	jae	SHORT $LN59@huft_build
	mov	DWORD PTR tv290[ebp], 16		; 00000010H
	jmp	SHORT $LN60@huft_build
$LN59@huft_build:
	mov	DWORD PTR tv290[ebp], 15		; 0000000fH
$LN60@huft_build:
	mov	cl, BYTE PTR tv290[ebp]
	mov	BYTE PTR _r$[ebp], cl

; 573  :         r.v.n = (ush)*p++;           /* simple code is just the value */

	mov	edx, DWORD PTR _p$[ebp]
	mov	ax, WORD PTR [edx]
	mov	WORD PTR _r$[ebp+4], ax
	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 4
	mov	DWORD PTR _p$[ebp], ecx

; 574  :       }
; 575  :       else

	jmp	SHORT $LN11@huft_build
$LN10@huft_build:

; 576  :       {
; 577  :         r.e = (uch)e[*p - s];   /* non-simple--look up in lists */

	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [edx]
	sub	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	dl, BYTE PTR [ecx+eax*2]
	mov	BYTE PTR _r$[ebp], dl

; 578  :         r.v.n = d[*p++ - s];

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR _d$[ebp]
	mov	ax, WORD PTR [edx+ecx*2]
	mov	WORD PTR _r$[ebp+4], ax
	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 4
	mov	DWORD PTR _p$[ebp], ecx
$LN11@huft_build:

; 579  :       }
; 580  : 
; 581  :       /* fill code-like entries with r */
; 582  :       f = 1 << (k - w);

	mov	ecx, DWORD PTR _k$[ebp]
	sub	ecx, DWORD PTR _w$[ebp]
	mov	edx, 1
	shl	edx, cl
	mov	DWORD PTR _f$[ebp], edx

; 583  :       for (j = i >> w; j < z; j += f)

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _w$[ebp]
	shr	eax, cl
	mov	DWORD PTR _j$[ebp], eax
	jmp	SHORT $LN8@huft_build
$LN7@huft_build:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, DWORD PTR _f$[ebp]
	mov	DWORD PTR _j$[ebp], ecx
$LN8@huft_build:
	mov	edx, DWORD PTR _j$[ebp]
	cmp	edx, DWORD PTR _z$[ebp]
	jae	SHORT $LN6@huft_build

; 584  :         q[j] = r;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _q$[ebp]
	mov	edx, DWORD PTR _r$[ebp]
	mov	DWORD PTR [ecx+eax*8], edx
	mov	edx, DWORD PTR _r$[ebp+4]
	mov	DWORD PTR [ecx+eax*8+4], edx
	jmp	SHORT $LN7@huft_build
$LN6@huft_build:

; 585  : 
; 586  :       /* backwards increment the k-bit code i */
; 587  :       for (j = 1 << (k - 1); i & j; j >>= 1)

	mov	ecx, DWORD PTR _k$[ebp]
	sub	ecx, 1
	mov	eax, 1
	shl	eax, cl
	mov	DWORD PTR _j$[ebp], eax
	jmp	SHORT $LN5@huft_build
$LN4@huft_build:
	mov	ecx, DWORD PTR _j$[ebp]
	shr	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$LN5@huft_build:
	mov	edx, DWORD PTR _i$[ebp]
	and	edx, DWORD PTR _j$[ebp]
	je	SHORT $LN3@huft_build

; 588  :         i ^= j;

	mov	eax, DWORD PTR _i$[ebp]
	xor	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN4@huft_build
$LN3@huft_build:

; 589  :       i ^= j;

	mov	ecx, DWORD PTR _i$[ebp]
	xor	ecx, DWORD PTR _j$[ebp]
	mov	DWORD PTR _i$[ebp], ecx
$LN2@huft_build:

; 590  : 
; 591  :       /* backup over finished tables */
; 592  :       while ((i & ((1 << w) - 1)) != x[h])

	mov	edx, 1
	mov	ecx, DWORD PTR _w$[ebp]
	shl	edx, cl
	sub	edx, 1
	and	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _h$[ebp]
	cmp	edx, DWORD PTR _x$[ebp+eax*4]
	je	SHORT $LN1@huft_build

; 593  :         w -= l[--h];            /* don't need to update q */

	mov	ecx, DWORD PTR _h$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _h$[ebp], ecx
	mov	edx, DWORD PTR _h$[ebp]
	mov	eax, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR _w$[ebp]
	sub	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _w$[ebp], ecx
	jmp	SHORT $LN2@huft_build
$LN1@huft_build:

; 594  :     }

	jmp	$LN24@huft_build
$LN23@huft_build:

; 595  :   }

	jmp	$LN26@huft_build
$LN25@huft_build:

; 596  : 
; 597  : 
; 598  :   /* return actual size of base table */
; 599  :   *m = l[0];

	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR _l$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [eax], edx

; 600  : 
; 601  : 
; 602  :   /* Return true (1) if we were given an incomplete table */
; 603  :   return y != 0 && g != 1;

	cmp	DWORD PTR _y$[ebp], 0
	je	SHORT $LN61@huft_build
	cmp	DWORD PTR _g$[ebp], 1
	je	SHORT $LN61@huft_build
	mov	DWORD PTR tv328[ebp], 1
	jmp	SHORT $LN62@huft_build
$LN61@huft_build:
	mov	DWORD PTR tv328[ebp], 0
$LN62@huft_build:
	mov	eax, DWORD PTR tv328[ebp]
$LN53@huft_build:

; 604  : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_huft_build ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\inflate.c
_TEXT	SEGMENT
_inflate_free PROC

; 1208 : {

	push	ebp
	mov	ebp, esp

; 1209 :    if( fixed_tl != NULL ) {

	cmp	DWORD PTR _fixed_tl, 0
	je	SHORT $LN1@inflate_fr

; 1210 :        huft_free( fixed_td );

	mov	eax, DWORD PTR _fixed_td
	push	eax
	call	_huft_free
	add	esp, 4

; 1211 :        huft_free( fixed_tl );

	mov	ecx, DWORD PTR _fixed_tl
	push	ecx
	call	_huft_free
	add	esp, 4

; 1212 : 
; 1213 :        fixed_td = NULL;

	mov	DWORD PTR _fixed_td, 0

; 1214 :        fixed_tl = NULL;

	mov	DWORD PTR _fixed_tl, 0
$LN1@inflate_fr:

; 1215 :    }
; 1216 : 
; 1217 :    return( 0 );

	xor	eax, eax

; 1218 : }

	pop	ebp
	ret	0
_inflate_free ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\inflate.c
_TEXT	SEGMENT
_e$ = -12						; size = 4
_h$ = -8						; size = 4
_r$ = -4						; size = 4
_cmp$ = 8						; size = 4
_inflate PROC

; 1155 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1156 :     int   e;                    /* last block flag */
; 1157 :     int   r;                    /* result code */
; 1158 :     unsigned h;                 /* maximum struct huft's malloc'ed */
; 1159 : 
; 1160 : 
; 1161 :     /* initialize window, bit buffer */
; 1162 : 
; 1163 :     cmp -> wp = 0;

	mov	eax, DWORD PTR _cmp$[ebp]
	mov	DWORD PTR [eax+28], 0

; 1164 :     cmp -> bk = 0;

	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	DWORD PTR [ecx+36], 0

; 1165 :     cmp -> bb = 0;

	mov	edx, DWORD PTR _cmp$[ebp]
	mov	DWORD PTR [edx+32], 0

; 1166 : 
; 1167 : 
; 1168 :     /* decompress until the last block */
; 1169 : 
; 1170 :     h = 0;

	mov	DWORD PTR _h$[ebp], 0
$LN5@inflate:

; 1171 : 
; 1172 :     do {
; 1173 :         hufts = 0;

	mov	DWORD PTR _hufts, 0

; 1174 : 
; 1175 :         if ((r = inflate_block(&e, cmp)) != 0)

	mov	eax, DWORD PTR _cmp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _e$[ebp]
	push	ecx
	call	_inflate_block
	add	esp, 8
	mov	DWORD PTR _r$[ebp], eax
	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $LN2@inflate

; 1176 :             return( r );

	mov	eax, DWORD PTR _r$[ebp]
	jmp	SHORT $LN6@inflate
$LN2@inflate:

; 1177 : 
; 1178 :         if (hufts > h)

	mov	edx, DWORD PTR _hufts
	cmp	edx, DWORD PTR _h$[ebp]
	jbe	SHORT $LN4@inflate

; 1179 :             h = hufts;

	mov	eax, DWORD PTR _hufts
	mov	DWORD PTR _h$[ebp], eax
$LN4@inflate:

; 1180 : 
; 1181 :     } while (!e);

	cmp	DWORD PTR _e$[ebp], 0
	je	SHORT $LN5@inflate

; 1182 : 
; 1183 : 
; 1184 :     /* flush out slide */
; 1185 :     FLUSH( cmp -> wp );

	mov	ecx, DWORD PTR _cmp$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_flush
	add	esp, 16					; 00000010H

; 1186 : 
; 1187 :     //Trace((stderr, "\n%u bytes in Huffman tables (%d/entry)", h * sizeof(struct huft), sizeof(struct huft)));
; 1188 : 
; 1189 :     /* return success */
; 1190 :     return( 0 );

	xor	eax, eax
$LN6@inflate:

; 1191 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_inflate ENDP
_TEXT	ENDS
END
