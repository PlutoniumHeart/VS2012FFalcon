; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\codelib\resources\reslib\src\unzip.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_UNZIP_ERROR
_BSS	SEGMENT
_seeklocked DB	01H DUP (?)
	ALIGN	4

_UNZIP_ERROR DD	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
_central_hdr_sig DB 00H
	DB	04bH
	DB	01H
	DB	02H
	ORG $+1
	ORG $+3
_local_hdr_sig DB 00H
	DB	04bH
	DB	03H
	DB	04H
	ORG $+1
	ORG $+3
_end_central_sig DB 00H
	DB	04bH
	DB	05H
	DB	06H
	ORG $+1
_DATA	ENDS
PUBLIC	_readbuf
PUBLIC	_readbyte
PUBLIC	_flush
PUBLIC	_find_end_central_dir
PUBLIC	_extract_or_test_member
PUBLIC	_archive_size
PUBLIC	_unzip_seek
PUBLIC	_process_local_file_hdr
PUBLIC	_archive_create
PUBLIC	_archive_delete
PUBLIC	??_C@_07CNOHFBBG@Archive?$AA@			; `string'
PUBLIC	??_C@_0M@MJJIOMHC@src?2unzip?4c?$AA@		; `string'
PUBLIC	??_C@_05BMGBEOOC@?$CFs?2?$CFs?$AA@		; `string'
PUBLIC	??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@		; `string'
PUBLIC	??_C@_0BM@IGMCHILJ@Big?5problemo?0?5read?5comment?$CB?$AA@ ; `string'
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_toupper:PROC
EXTRN	_memcpy:PROC
EXTRN	_strcpy:PROC
EXTRN	_strcmp:PROC
EXTRN	_strlen:PROC
EXTRN	_strncmp:PROC
EXTRN	_strncpy:PROC
EXTRN	_strdup:PROC
EXTRN	_stricmp:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__CreateMutexA@12:PROC
EXTRN	_ListAppend:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	_sprintf:PROC
EXTRN	__close:PROC
EXTRN	__open:PROC
EXTRN	_lseek:PROC
EXTRN	_read:PROC
EXTRN	_ResCheckMedia:PROC
EXTRN	__stat64i32:PROC
EXTRN	_inflate:PROC
EXTRN	_inflate_free:PROC
EXTRN	_hash_add:PROC
EXTRN	_hash_find:PROC
EXTRN	_hash_create:PROC
EXTRN	_res_fullpath:PROC
EXTRN	__say_error:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_GLOBAL_HASH_TABLE:DWORD
EXTRN	_GLOBAL_PATH_LIST:DWORD
EXTRN	_GLOBAL_SEARCH_PATH:BYTE
EXTRN	_GLOBAL_SEARCH_INDEX:DWORD
EXTRN	___security_cookie:DWORD
;	COMDAT ??_C@_0BM@IGMCHILJ@Big?5problemo?0?5read?5comment?$CB?$AA@
CONST	SEGMENT
??_C@_0BM@IGMCHILJ@Big?5problemo?0?5read?5comment?$CB?$AA@ DB 'Big proble'
	DB	'mo, read comment!', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
CONST	SEGMENT
??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@ DB '%s%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05BMGBEOOC@?$CFs?2?$CFs?$AA@
CONST	SEGMENT
??_C@_05BMGBEOOC@?$CFs?2?$CFs?$AA@ DB '%s\%s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MJJIOMHC@src?2unzip?4c?$AA@
CONST	SEGMENT
??_C@_0M@MJJIOMHC@src?2unzip?4c?$AA@ DB 'src\unzip.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07CNOHFBBG@Archive?$AA@
CONST	SEGMENT
??_C@_07CNOHFBBG@Archive?$AA@ DB 'Archive', 00H		; `string'
CONST	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\unzip.c
_TEXT	SEGMENT
_sig$ = 8						; size = 4
_makelong PROC

; 940  : {

	push	ebp
	mov	ebp, esp

; 941  :     return (((ulg)sig[3])<<24)|(((ulg)sig[2])<<16)|(((ulg)sig[1])<<8)|((ulg)sig[0]);

	mov	eax, 1
	imul	eax, 3
	mov	ecx, DWORD PTR _sig$[ebp]
	movzx	eax, BYTE PTR [ecx+eax]
	shl	eax, 24					; 00000018H
	mov	edx, 1
	shl	edx, 1
	mov	ecx, DWORD PTR _sig$[ebp]
	movzx	edx, BYTE PTR [ecx+edx]
	shl	edx, 16					; 00000010H
	or	eax, edx
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _sig$[ebp]
	movzx	ecx, BYTE PTR [edx+ecx]
	shl	ecx, 8
	or	eax, ecx
	mov	edx, 1
	imul	edx, 0
	mov	ecx, DWORD PTR _sig$[ebp]
	movzx	edx, BYTE PTR [ecx+edx]
	or	eax, edx

; 942  : }

	pop	ebp
	ret	0
_makelong ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\unzip.c
_TEXT	SEGMENT
_b$ = 8							; size = 4
_makeword PROC

; 920  : {

	push	ebp
	mov	ebp, esp

; 921  :     return (ush)((b[1] << 8) | b[0]);

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _b$[ebp]
	movzx	eax, BYTE PTR [ecx+eax]
	shl	eax, 8
	mov	edx, 1
	imul	edx, 0
	mov	ecx, DWORD PTR _b$[ebp]
	movzx	edx, BYTE PTR [ecx+edx]
	or	eax, edx

; 922  : }

	pop	ebp
	ret	0
_makeword ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\unzip.c
_TEXT	SEGMENT
_arc$ = 8						; size = 4
_archive_delete PROC

; 644  : {

	push	ebp
	mov	ebp, esp

; 645  :     _close( arc -> os_handle );

	mov	eax, DWORD PTR _arc$[ebp]
	mov	ecx, DWORD PTR [eax+260]
	push	ecx
	call	__close
	add	esp, 4

; 646  : 
; 647  :     DESTROY_LOCK( arc -> lock );

	mov	edx, DWORD PTR _arc$[ebp]
	mov	eax, DWORD PTR [edx+276]
	push	eax
	call	DWORD PTR __imp__CloseHandle@4

; 648  : 
; 649  : 	#ifdef USE_SH_POOLS
; 650  : 	MemFreePtr( arc );
; 651  : 	#else
; 652  : 	MemFree( arc );

	mov	ecx, DWORD PTR _arc$[ebp]
	push	ecx
	call	_free
	add	esp, 4

; 653  : 	#endif
; 654  : }

	pop	ebp
	ret	0
_archive_delete ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\unzip.c
_TEXT	SEGMENT
tv353 = -1580						; size = 4
tv354 = -1576						; size = 4
_len$ = -1572						; size = 4
tv213 = -1568						; size = 4
tv169 = -1564						; size = 4
tv189 = -1560						; size = 4
$T1 = -1556						; size = 4
tv141 = -1552						; size = 4
tv95 = -1548						; size = 4
_fname$ = -1544						; size = 4
$T2 = -1540						; size = 4
_dir_was$ = -1536					; size = 4
_path_idx$ = -1532					; size = 4
_members_remaining$ = -1528				; size = 2
_vol_was$ = -1521					; size = 1
_error_in_archive$ = -1520				; size = 4
_i$ = -1516						; size = 4
_entry$ = -1512						; size = 4
_error$ = -1508						; size = 4
_arc$ = -1504						; size = 4
_info$ = -1500						; size = 296
_data$ = -1204						; size = 296
_statbuf$3 = -908					; size = 48
_ecrec$ = -860						; size = 20
_crec$ = -840						; size = 44
_path_was$ = -796					; size = 260
_curfilename$ = -536					; size = 261
_path$ = -272						; size = 260
_sig$ = -12						; size = 5
__$ArrayPad$ = -4					; size = 4
_attach_point$ = 8					; size = 4
_filename$ = 12						; size = 4
_table$ = 16						; size = 4
_replace_flag$ = 20					; size = 4
_archive_create PROC

; 168  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1580				; 0000062cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 169  :     ARCHIVE     * arc;
; 170  :     HASH_ENTRY  * entry;
; 171  : 	struct _finddata_t data;     /* for hash_find */
; 172  :     struct _finddata_t info;
; 173  :     
; 174  :     char    sig[5];
; 175  :     char    vol_was;
; 176  :     int     dir_was;
; 177  :     int     error = 0, 

	mov	DWORD PTR _error$[ebp], 0

; 178  :             error_in_archive = 0,

	mov	DWORD PTR _error_in_archive$[ebp], 0

; 179  :             i, len;
; 180  : 
; 181  :     char    path_was[_MAX_PATH],
; 182  :             path[_MAX_PATH];
; 183  :     char *  fname;                  /* used to truncate path from filename */
; 184  :     int     path_idx;
; 185  : 
; 186  :     ecdir_rec ecrec;                /* used in unzip.c, extract.c */
; 187  : 
; 188  : //    int filnum=(-1);
; 189  : 
; 190  :     ush members_remaining;//, 
; 191  : //        num_skipped = 0, 
; 192  : //        num_bad_pwd = 0;
; 193  : 
; 194  :     char curfilename[FILNAMSIZ];
; 195  :     cdir_file_hdr crec;             /* used in unzip.c, extract.c, misc.c */
; 196  : 
; 197  : 	#ifdef USE_SH_POOLS
; 198  :     arc = (ARCHIVE *)MemAllocPtr( gResmgrMemPool, sizeof(ARCHIVE), 0 );
; 199  : 	#else
; 200  :     arc = (ARCHIVE *)MemMalloc( sizeof(ARCHIVE), filename );

	push	328					; 00000148H
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _arc$[ebp], eax

; 201  : 	#endif
; 202  : 
; 203  :     if( !arc ) {

	cmp	DWORD PTR _arc$[ebp], 0
	jne	SHORT $LN44@archive_cr

; 204  :         UNZIP_ERROR = RES_ERR_NO_MEMORY;

	mov	DWORD PTR _UNZIP_ERROR, -4999		; ffffec79H

; 205  :         return( NULL );

	xor	eax, eax
	jmp	$LN46@archive_cr
$LN44@archive_cr:

; 206  :     }
; 207  :   
; 208  :     strcpy( arc -> name, filename );

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _arc$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 209  : 
; 210  :     arc -> lock = CREATE_LOCK( "Archive" );

	push	OFFSET ??_C@_07CNOHFBBG@Archive?$AA@
	push	0
	push	0
	call	DWORD PTR __imp__CreateMutexA@12
	mov	edx, DWORD PTR _arc$[ebp]
	mov	DWORD PTR [edx+276], eax

; 211  : 
; 212  :     /*---------------------------------------------------------------------------
; 213  :        Start by constructing the various PK signature strings.
; 214  :       ---------------------------------------------------------------------------*/
; 215  : 
; 216  :     local_hdr_sig[0]   = '\120';   /* ASCII 'P', */

	mov	eax, 1
	imul	eax, 0
	mov	BYTE PTR _local_hdr_sig[eax], 80	; 00000050H

; 217  :     central_hdr_sig[0] = '\120';

	mov	ecx, 1
	imul	ecx, 0
	mov	BYTE PTR _central_hdr_sig[ecx], 80	; 00000050H

; 218  :     end_central_sig[0] = '\120';   /* not EBCDIC */

	mov	edx, 1
	imul	edx, 0
	mov	BYTE PTR _end_central_sig[edx], 80	; 00000050H

; 219  : 
; 220  :     strcpy( path_was, attach_point );

	mov	eax, DWORD PTR _attach_point$[ebp]
	push	eax
	lea	ecx, DWORD PTR _path_was$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 221  :     
; 222  : 	#ifdef USE_SH_POOLS
; 223  :     arc -> tmp_slide = (uch *)MemAllocPtr( gResmgrMemPool,  UNZIP_SLIDE_SIZE, 0 );
; 224  : 	#else
; 225  :     arc -> tmp_slide = (uch *)MemMalloc( UNZIP_SLIDE_SIZE, "Slide" );

	push	32768					; 00008000H
	call	_malloc
	add	esp, 4
	mov	edx, DWORD PTR _arc$[ebp]
	mov	DWORD PTR [edx+284], eax

; 226  : 	#endif
; 227  : 
; 228  :     if( arc -> tmp_slide == NULL ) {

	mov	eax, DWORD PTR _arc$[ebp]
	cmp	DWORD PTR [eax+284], 0
	jne	SHORT $LN43@archive_cr

; 229  :         UNZIP_ERROR = RES_ERR_NO_MEMORY;

	mov	DWORD PTR _UNZIP_ERROR, -4999		; ffffec79H

; 230  :         return( NULL );    /* 4 extra for hold[] (below) */

	xor	eax, eax
	jmp	$LN46@archive_cr
$LN43@archive_cr:

; 231  :     }
; 232  : 
; 233  :     {
; 234  :         struct stat statbuf;
; 235  : 
; 236  :         if( SSTAT(filename, &statbuf) || (error = S_ISDIR(statbuf.st_mode)) != 0)

	lea	ecx, DWORD PTR _statbuf$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	_stat
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN41@archive_cr
	movzx	eax, WORD PTR _statbuf$3[ebp+6]
	and	eax, 61440				; 0000f000H
	cmp	eax, 16384				; 00004000H
	jne	SHORT $LN47@archive_cr
	mov	DWORD PTR tv95[ebp], 1
	jmp	SHORT $LN48@archive_cr
$LN47@archive_cr:
	mov	DWORD PTR tv95[ebp], 0
$LN48@archive_cr:
	mov	ecx, DWORD PTR tv95[ebp]
	mov	DWORD PTR _error$[ebp], ecx
	cmp	DWORD PTR _error$[ebp], 0
	je	SHORT $LN42@archive_cr
$LN41@archive_cr:

; 237  :         {
; 238  :             ResCheckMedia( toupper(filename[0]) - 'A' ); /* see if media has been swapped */

	mov	edx, 1
	imul	edx, 0
	mov	eax, DWORD PTR _filename$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	push	ecx
	call	_toupper
	add	esp, 4
	sub	eax, 65					; 00000041H
	push	eax
	call	_ResCheckMedia
	add	esp, 4

; 239  : 
; 240  : 			#ifdef USE_SH_POOLS
; 241  :             MemFreePtr( arc -> tmp_slide );
; 242  :             MemFreePtr( arc );
; 243  : 			#else
; 244  :             MemFree( arc -> tmp_slide );

	mov	edx, DWORD PTR _arc$[ebp]
	mov	eax, DWORD PTR [edx+284]
	push	eax
	call	_free
	add	esp, 4

; 245  :             MemFree( arc );

	mov	ecx, DWORD PTR _arc$[ebp]
	push	ecx
	call	_free
	add	esp, 4

; 246  : 			#endif
; 247  :             UNZIP_ERROR = RES_ERR_UNKNOWN;

	mov	DWORD PTR _UNZIP_ERROR, -4973		; ffffec93H

; 248  :             return( NULL );

	xor	eax, eax
	jmp	$LN46@archive_cr
$LN42@archive_cr:

; 249  :         }
; 250  : 
; 251  :         arc -> length = statbuf.st_size;

	mov	edx, DWORD PTR _arc$[ebp]
	mov	eax, DWORD PTR _statbuf$3[ebp+20]
	mov	DWORD PTR [edx+264], eax

; 252  :     }
; 253  : 
; 254  :     if(( arc -> os_handle = _open( filename, O_RDONLY | O_BINARY )) < 0 )

	push	32768					; 00008000H
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	__open
	add	esp, 8
	mov	DWORD PTR tv141[ebp], eax
	mov	edx, DWORD PTR _arc$[ebp]
	mov	eax, DWORD PTR tv141[ebp]
	mov	DWORD PTR [edx+260], eax
	cmp	DWORD PTR tv141[ebp], 0
	jge	SHORT $LN40@archive_cr

; 255  :     {
; 256  :         ResCheckMedia( toupper(filename[0]) - 'A' ); /* see if media has been swapped */

	mov	ecx, 1
	imul	ecx, 0
	mov	edx, DWORD PTR _filename$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	push	eax
	call	_toupper
	add	esp, 4
	sub	eax, 65					; 00000041H
	push	eax
	call	_ResCheckMedia
	add	esp, 4

; 257  : 
; 258  : 		#ifdef USE_SH_POOLS
; 259  : 		MemFreePtr( arc -> tmp_slide );
; 260  : 		MemFreePtr( arc );
; 261  : 		#else
; 262  : 		MemFree( arc -> tmp_slide );

	mov	ecx, DWORD PTR _arc$[ebp]
	mov	edx, DWORD PTR [ecx+284]
	push	edx
	call	_free
	add	esp, 4

; 263  : 		MemFree( arc );

	mov	eax, DWORD PTR _arc$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 264  : 		#endif
; 265  :         UNZIP_ERROR = RES_ERR_NO_MEMORY;

	mov	DWORD PTR _UNZIP_ERROR, -4999		; ffffec79H

; 266  :         return( NULL );

	xor	eax, eax
	jmp	$LN46@archive_cr
$LN40@archive_cr:

; 267  :     }
; 268  : 
; 269  :     res_fullpath( path, filename, _MAX_PATH );

	push	260					; 00000104H
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	call	_res_fullpath
	add	esp, 12					; 0000000cH

; 270  :     arc -> volume = (char)(toupper( path[0] ) - 'A');

	mov	eax, 1
	imul	eax, 0
	movsx	ecx, BYTE PTR _path$[ebp+eax]
	push	ecx
	call	_toupper
	add	esp, 4
	sub	eax, 65					; 00000041H
	mov	edx, DWORD PTR _arc$[ebp]
	mov	BYTE PTR [edx+272], al

; 271  : 
; 272  :     arc -> start_buffer = 0;

	mov	eax, DWORD PTR _arc$[ebp]
	mov	DWORD PTR [eax+268], 0

; 273  : 
; 274  :     // Use 2048 size buffer for now, so we don't break things
; 275  :     // But Input buffer is set to INPUTBUFSIZE >> 2048 + 4
; 276  : 
; 277  :     arc -> tmp_in_size = UNZIP_BUFFER_SIZE;

	mov	ecx, DWORD PTR _arc$[ebp]
	mov	DWORD PTR [ecx+300], 2048		; 00000800H

; 278  : 
; 279  : 	#ifdef USE_SH_POOLS
; 280  :     if(( arc -> tmp_in_buffer = (uch *)MemAllocPtr( gResmgrMemPool, INPUTBUFSIZE, 0 )) == NULL )
; 281  :     {
; 282  :          _close( arc -> os_handle );
; 283  :         MemFreePtr( arc -> tmp_slide );
; 284  :         MemFreePtr( arc );
; 285  :         UNZIP_ERROR = RES_ERR_NO_MEMORY;
; 286  :         return( NULL );
; 287  :     }
; 288  : 	#else
; 289  :     if(( arc -> tmp_in_buffer = (uch *)MemMalloc( INPUTBUFSIZE, "input buffer" )) == NULL )

	push	20480					; 00005000H
	call	_malloc
	add	esp, 4
	mov	DWORD PTR tv169[ebp], eax
	mov	edx, DWORD PTR _arc$[ebp]
	mov	eax, DWORD PTR tv169[ebp]
	mov	DWORD PTR [edx+288], eax
	cmp	DWORD PTR tv169[ebp], 0
	jne	SHORT $LN39@archive_cr

; 290  :     {
; 291  :          _close( arc -> os_handle );

	mov	ecx, DWORD PTR _arc$[ebp]
	mov	edx, DWORD PTR [ecx+260]
	push	edx
	call	__close
	add	esp, 4

; 292  :         MemFree( arc -> tmp_slide );

	mov	eax, DWORD PTR _arc$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	push	ecx
	call	_free
	add	esp, 4

; 293  :         MemFree( arc );

	mov	edx, DWORD PTR _arc$[ebp]
	push	edx
	call	_free
	add	esp, 4

; 294  :         UNZIP_ERROR = RES_ERR_NO_MEMORY;

	mov	DWORD PTR _UNZIP_ERROR, -4999		; ffffec79H

; 295  :         return( NULL );

	xor	eax, eax
	jmp	$LN46@archive_cr
$LN39@archive_cr:

; 296  :     }
; 297  : 	#endif
; 298  : 
; 299  :     arc -> tmp_hold = (uch *)(arc -> tmp_in_buffer + arc -> tmp_in_size);    /* to check for boundary-spanning signatures */

	mov	eax, DWORD PTR _arc$[ebp]
	mov	ecx, DWORD PTR [eax+288]
	mov	edx, DWORD PTR _arc$[ebp]
	add	ecx, DWORD PTR [edx+300]
	mov	eax, DWORD PTR _arc$[ebp]
	mov	DWORD PTR [eax+280], ecx

; 300  : 
; 301  :     arc -> tmp_in_ptr = (uch *)(arc -> tmp_in_buffer);

	mov	ecx, DWORD PTR _arc$[ebp]
	mov	edx, DWORD PTR _arc$[ebp]
	mov	eax, DWORD PTR [edx+288]
	mov	DWORD PTR [ecx+292], eax

; 302  : 
; 303  : #if( RES_PREDETERMINE_SIZE )
; 304  :     int sz;
; 305  : 
; 306  :     sz = archive_size( arc );
; 307  : 
; 308  :    /* printf( "archive size: %d\n", sz );*/
; 309  : 
; 310  :     if( ARCHIVE_TABLE_SIZE < (sz>>1)) {
; 311  :         table -> num_entries = sz;
; 312  :         if( !hash_resize( table )) {
; 313  :             _close( arc -> os_handle );
; 314  : 			#ifdef USE_SH_POOLS
; 315  :             MemFreePtr( arc -> tmp_in_buffer );
; 316  : 			MemFreePtr( arc -> tmp_slide );
; 317  : 			MemFreePtr( arc );
; 318  : 			#else
; 319  :             MemFree( arc -> tmp_in_buffer );
; 320  : 			MemFree( arc -> tmp_slide );
; 321  : 			MemFree( arc );
; 322  : 			#endif
; 323  :             UNZIP_ERROR = RES_ERR_NO_MEMORY;
; 324  :             return( NULL );
; 325  :         }
; 326  :     }
; 327  : #endif /*RES_PREDETERMINE_SIZE */
; 328  : 
; 329  :     //****** (arc -> len) ?  66000L ? *****//
; 330  :     if(( ((error_in_archive = find_end_central_dir(MIN((arc -> length),66000L), &ecrec, arc)) != 0 ))) 

	mov	ecx, DWORD PTR _arc$[ebp]
	cmp	DWORD PTR [ecx+264], 66000		; 000101d0H
	jge	SHORT $LN49@archive_cr
	mov	edx, DWORD PTR _arc$[ebp]
	mov	eax, DWORD PTR [edx+264]
	mov	DWORD PTR tv189[ebp], eax
	jmp	SHORT $LN50@archive_cr
$LN49@archive_cr:
	mov	DWORD PTR tv189[ebp], 66000		; 000101d0H
$LN50@archive_cr:
	mov	ecx, DWORD PTR _arc$[ebp]
	push	ecx
	lea	edx, DWORD PTR _ecrec$[ebp]
	push	edx
	mov	eax, DWORD PTR tv189[ebp]
	push	eax
	call	_find_end_central_dir
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _error_in_archive$[ebp], eax
	cmp	DWORD PTR _error_in_archive$[ebp], 0
	je	SHORT $LN38@archive_cr

; 331  :     {
; 332  :         _close( arc -> os_handle );

	mov	ecx, DWORD PTR _arc$[ebp]
	mov	edx, DWORD PTR [ecx+260]
	push	edx
	call	__close
	add	esp, 4

; 333  : 		#ifdef USE_SH_POOLS
; 334  : 		MemFreePtr( arc -> tmp_in_buffer );
; 335  : 		MemFreePtr( arc -> tmp_slide );
; 336  : 		MemFreePtr( arc );
; 337  : 		#else
; 338  : 		MemFree( arc -> tmp_in_buffer );

	mov	eax, DWORD PTR _arc$[ebp]
	mov	ecx, DWORD PTR [eax+288]
	push	ecx
	call	_free
	add	esp, 4

; 339  : 		MemFree( arc -> tmp_slide );

	mov	edx, DWORD PTR _arc$[ebp]
	mov	eax, DWORD PTR [edx+284]
	push	eax
	call	_free
	add	esp, 4

; 340  : 		MemFree( arc );

	mov	ecx, DWORD PTR _arc$[ebp]
	push	ecx
	call	_free
	add	esp, 4

; 341  : 		#endif
; 342  :         UNZIP_ERROR = RES_ERR_NO_MEMORY;

	mov	DWORD PTR _UNZIP_ERROR, -4999		; ffffec79H

; 343  :         return( NULL );

	xor	eax, eax
	jmp	$LN46@archive_cr
$LN38@archive_cr:

; 344  :     }
; 345  : 
; 346  :     /*-----------------------------------------------------------------------
; 347  :         Compensate for missing or extra bytes, and seek to where the start
; 348  :         of central directory should be.  If header not found, uncompensate
; 349  :         and try again (necessary for at least some Atari archives created
; 350  :         with STZIP, as well as archives created by J.H. Holm's ZIPSPLIT 1.1).
; 351  :       ----------------------------------------------------------------------- */
; 352  : 
; 353  :     //LSEEK( ecrec.offset_start_central_directory );
; 354  : 
; 355  :     if( UNZIP_LSEEK( ecrec.offset_start_central_directory, arc )) {

	mov	edx, DWORD PTR _arc$[ebp]
	push	edx
	mov	eax, DWORD PTR _ecrec$[ebp+12]
	push	eax
	call	_unzip_seek
	add	esp, 8
	test	eax, eax
	je	SHORT $LN37@archive_cr

; 356  :         _close( arc -> os_handle );

	mov	ecx, DWORD PTR _arc$[ebp]
	mov	edx, DWORD PTR [ecx+260]
	push	edx
	call	__close
	add	esp, 4

; 357  : 		#ifdef USE_SH_POOLS
; 358  : 		MemFreePtr( arc -> tmp_in_buffer );
; 359  : 		MemFreePtr( arc -> tmp_slide );
; 360  : 		MemFreePtr( arc );
; 361  : 		#else
; 362  : 		MemFree( arc -> tmp_in_buffer );

	mov	eax, DWORD PTR _arc$[ebp]
	mov	ecx, DWORD PTR [eax+288]
	push	ecx
	call	_free
	add	esp, 4

; 363  : 		MemFree( arc -> tmp_slide );

	mov	edx, DWORD PTR _arc$[ebp]
	mov	eax, DWORD PTR [edx+284]
	push	eax
	call	_free
	add	esp, 4

; 364  : 		MemFree( arc );

	mov	ecx, DWORD PTR _arc$[ebp]
	push	ecx
	call	_free
	add	esp, 4

; 365  : 		#endif
; 366  :         UNZIP_ERROR = RES_ERR_NO_MEMORY;

	mov	DWORD PTR _UNZIP_ERROR, -4999		; ffffec79H

; 367  :         return( NULL );

	xor	eax, eax
	jmp	$LN46@archive_cr
$LN37@archive_cr:

; 368  :     }
; 369  : 
; 370  : 
; 371  :     /* -----------------------------------------------------------------------
; 372  :         Seek to the start of the central directory one last time, since we
; 373  :         have just read the first entry's signature bytes; then list, extract
; 374  :         or test member files as instructed, and close the zipfile.
; 375  :        -----------------------------------------------------------------------*/
; 376  : 
; 377  :     /* ---------------------------------------------------------------------------
; 378  :         The basic idea of this function is as follows.  Since the central di-
; 379  :         rectory lies at the end of the zipfile and the member files lie at the
; 380  :         beginning or middle or wherever, it is not very desirable to simply
; 381  :         read a central directory entry, jump to the member and extract it, and
; 382  :         then jump back to the central directory.  In the case of a large zipfile
; 383  :         this would lead to a whole lot of disk-grinding, especially if each mem-
; 384  :         ber file is small.  Instead, we read from the central directory the per-
; 385  :         tinent information for a block of files, then go extract/test the whole
; 386  :         block.  Thus this routine contains two small(er) loops within a very
; 387  :         large outer loop:  the first of the small ones reads a block of files
; 388  :         from the central directory; the second extracts or tests each file; and
; 389  :         the outer one loops over blocks.  There's some file-pointer positioning
; 390  :         stuff in between, but that's about it.  Btw, it's because of this jump-
; 391  :         ing around that we can afford to be lenient if an error occurs in one of
; 392  :         the member files:  we should still be able to go find the other members,
; 393  :         since we know the offset of each from the beginning of the zipfile.
; 394  : 
; 395  :         Begin main loop over blocks of member files.  We know the entire central
; 396  :         directory is on this disk:  we would not have any of this information un-
; 397  :         less the end-of-central-directory record was on this disk, and we would
; 398  :         not have gotten to this routine unless this is also the disk on which
; 399  :         the central directory starts.  In practice, this had better be the ONLY
; 400  :         disk in the archive, but maybe someday we'll add multi-disk support.
; 401  :        ---------------------------------------------------------------------------*/
; 402  : 
; 403  :     members_remaining = ecrec.total_entries_central_dir;

	mov	dx, WORD PTR _ecrec$[ebp+6]
	mov	WORD PTR _members_remaining$[ebp], dx
$LN36@archive_cr:

; 404  : 
; 405  :     //filelistcount = 0;
; 406  :     //filelistmax = members_remaining + 30;
; 407  :     //files = new direntry [ filelistmax ];
; 408  :     
; 409  :     while( members_remaining-- )

	movzx	eax, WORD PTR _members_remaining$[ebp]
	mov	DWORD PTR tv213[ebp], eax
	mov	cx, WORD PTR _members_remaining$[ebp]
	sub	cx, 1
	mov	WORD PTR _members_remaining$[ebp], cx
	cmp	DWORD PTR tv213[ebp], 0
	je	$LN35@archive_cr

; 410  :     {
; 411  :         if( readbuf( sig, 4, arc ) <= 0 )

	mov	edx, DWORD PTR _arc$[ebp]
	push	edx
	push	4
	lea	eax, DWORD PTR _sig$[ebp]
	push	eax
	call	_readbuf
	add	esp, 12					; 0000000cH
	test	eax, eax
	jg	SHORT $LN34@archive_cr

; 412  :         {
; 413  :             error_in_archive = PK_EOF;

	mov	DWORD PTR _error_in_archive$[ebp], 51	; 00000033H

; 414  :             SAY_ERROR( RES_ERR_BAD_ARCHIVE, filename );

	push	OFFSET ??_C@_0M@MJJIOMHC@src?2unzip?4c?$AA@
	push	414					; 0000019eH
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	push	-4974					; ffffec92H
	call	__say_error
	add	esp, 16					; 00000010H

; 415  :             break;

	jmp	$LN35@archive_cr
$LN34@archive_cr:

; 416  :         }
; 417  : 
; 418  :         if( strncmp( sig, central_hdr_sig, 4 ))     /* just to make sure                            */

	push	4
	push	OFFSET _central_hdr_sig
	lea	edx, DWORD PTR _sig$[ebp]
	push	edx
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN33@archive_cr

; 419  :         {  
; 420  :             error_in_archive = PK_BADERR;

	mov	DWORD PTR _error_in_archive$[ebp], 3

; 421  :             SAY_ERROR( RES_ERR_BAD_ARCHIVE, filename );

	push	OFFSET ??_C@_0M@MJJIOMHC@src?2unzip?4c?$AA@
	push	421					; 000001a5H
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	push	-4974					; ffffec92H
	call	__say_error
	add	esp, 16					; 00000010H

; 422  :             break;

	jmp	$LN35@archive_cr
$LN33@archive_cr:

; 423  :         }
; 424  : 
; 425  :         /* process_cdir_file_hdr() sets pInfo->hostnum, pInfo->lcflag */
; 426  : 
; 427  :         if(( error = process_cdir_file_hdr( &crec, arc )) != PK_COOL ) {

	mov	ecx, DWORD PTR _arc$[ebp]
	push	ecx
	lea	edx, DWORD PTR _crec$[ebp]
	push	edx
	call	_process_cdir_file_hdr
	add	esp, 8
	mov	DWORD PTR _error$[ebp], eax
	cmp	DWORD PTR _error$[ebp], 0
	je	SHORT $LN32@archive_cr

; 428  :             error_in_archive = error;               /* only PK_EOF defined                          */

	mov	eax, DWORD PTR _error$[ebp]
	mov	DWORD PTR _error_in_archive$[ebp], eax

; 429  :             SAY_ERROR( RES_ERR_BAD_ARCHIVE, filename );

	push	OFFSET ??_C@_0M@MJJIOMHC@src?2unzip?4c?$AA@
	push	429					; 000001adH
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	push	-4974					; ffffec92H
	call	__say_error
	add	esp, 16					; 00000010H

; 430  :             break;

	jmp	$LN35@archive_cr
$LN32@archive_cr:

; 431  :         }
; 432  : 
; 433  :         if((error = do_string( crec.filename_length, FILENAME, curfilename, arc )) != PK_COOL) {

	mov	edx, DWORD PTR _arc$[ebp]
	push	edx
	lea	eax, DWORD PTR _curfilename$[ebp]
	push	eax
	push	2
	movzx	ecx, WORD PTR _crec$[ebp+24]
	push	ecx
	call	_do_string
	add	esp, 16					; 00000010H
	mov	DWORD PTR _error$[ebp], eax
	cmp	DWORD PTR _error$[ebp], 0
	je	SHORT $LN31@archive_cr

; 434  :             if( error > error_in_archive )

	mov	edx, DWORD PTR _error$[ebp]
	cmp	edx, DWORD PTR _error_in_archive$[ebp]
	jle	SHORT $LN30@archive_cr

; 435  :                 error_in_archive = error;

	mov	eax, DWORD PTR _error$[ebp]
	mov	DWORD PTR _error_in_archive$[ebp], eax
$LN30@archive_cr:

; 436  : 
; 437  :             if( error > PK_WARN ) {                 /* fatal:  no more left to do                   */

	cmp	DWORD PTR _error$[ebp], 1
	jle	SHORT $LN31@archive_cr

; 438  :                 UNZIP_ERROR = RES_ERR_UNKNOWN;

	mov	DWORD PTR _UNZIP_ERROR, -4973		; ffffec93H

; 439  :                 SAY_ERROR( RES_ERR_BAD_ARCHIVE, filename );

	push	OFFSET ??_C@_0M@MJJIOMHC@src?2unzip?4c?$AA@
	push	439					; 000001b7H
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	push	-4974					; ffffec92H
	call	__say_error
	add	esp, 16					; 00000010H

; 440  :                 break;

	jmp	$LN35@archive_cr
$LN31@archive_cr:

; 441  :             }
; 442  :         }
; 443  : 
; 444  :         if(( error = do_string( crec.extra_field_length, SKIP, NULL, arc )) != PK_COOL ) {

	mov	edx, DWORD PTR _arc$[ebp]
	push	edx
	push	0
	push	0
	movzx	eax, WORD PTR _crec$[ebp+26]
	push	eax
	call	_do_string
	add	esp, 16					; 00000010H
	mov	DWORD PTR _error$[ebp], eax
	cmp	DWORD PTR _error$[ebp], 0
	je	SHORT $LN28@archive_cr

; 445  :             if( error > error_in_archive )

	mov	ecx, DWORD PTR _error$[ebp]
	cmp	ecx, DWORD PTR _error_in_archive$[ebp]
	jle	SHORT $LN27@archive_cr

; 446  :                 error_in_archive = error;

	mov	edx, DWORD PTR _error$[ebp]
	mov	DWORD PTR _error_in_archive$[ebp], edx
$LN27@archive_cr:

; 447  : 
; 448  :             if( error > PK_WARN ) {                 /* fatal: bail now                               */

	cmp	DWORD PTR _error$[ebp], 1
	jle	SHORT $LN28@archive_cr

; 449  :                 UNZIP_ERROR = RES_ERR_UNKNOWN;

	mov	DWORD PTR _UNZIP_ERROR, -4973		; ffffec93H

; 450  :                 SAY_ERROR( RES_ERR_BAD_ARCHIVE, filename );

	push	OFFSET ??_C@_0M@MJJIOMHC@src?2unzip?4c?$AA@
	push	450					; 000001c2H
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	push	-4974					; ffffec92H
	call	__say_error
	add	esp, 16					; 00000010H

; 451  :                 break;

	jmp	$LN35@archive_cr
$LN28@archive_cr:

; 452  :             }
; 453  :         }
; 454  : 
; 455  :         if(( error = do_string( crec.file_comment_length, SKIP, NULL, arc )) != PK_COOL ) {

	mov	ecx, DWORD PTR _arc$[ebp]
	push	ecx
	push	0
	push	0
	movzx	edx, WORD PTR _crec$[ebp+28]
	push	edx
	call	_do_string
	add	esp, 16					; 00000010H
	mov	DWORD PTR _error$[ebp], eax
	cmp	DWORD PTR _error$[ebp], 0
	je	SHORT $LN25@archive_cr

; 456  :             if( error > error_in_archive )

	mov	eax, DWORD PTR _error$[ebp]
	cmp	eax, DWORD PTR _error_in_archive$[ebp]
	jle	SHORT $LN24@archive_cr

; 457  :                 error_in_archive = error;

	mov	ecx, DWORD PTR _error$[ebp]
	mov	DWORD PTR _error_in_archive$[ebp], ecx
$LN24@archive_cr:

; 458  : 
; 459  :             if( error > PK_WARN ) {                 /* fatal: bail now                               */

	cmp	DWORD PTR _error$[ebp], 1
	jle	SHORT $LN25@archive_cr

; 460  :                 UNZIP_ERROR = RES_ERR_UNKNOWN;

	mov	DWORD PTR _UNZIP_ERROR, -4973		; ffffec93H

; 461  :                 SAY_ERROR( RES_ERR_BAD_ARCHIVE, filename );

	push	OFFSET ??_C@_0M@MJJIOMHC@src?2unzip?4c?$AA@
	push	461					; 000001cdH
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	push	-4974					; ffffec92H
	call	__say_error
	add	esp, 16					; 00000010H

; 462  :                 break;

	jmp	$LN35@archive_cr
$LN25@archive_cr:

; 463  :             }
; 464  :         }
; 465  : 
; 466  :         fname = curfilename;

	lea	eax, DWORD PTR _curfilename$[ebp]
	mov	DWORD PTR _fname$[ebp], eax

; 467  :         path_idx = 0;                               /* see if directory has changed                 */

	mov	DWORD PTR _path_idx$[ebp], 0

; 468  : 
; 469  :         if( attach_point[ strlen(attach_point)-1 ] != ASCII_BACKSLASH )

	mov	ecx, DWORD PTR _attach_point$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	edx, DWORD PTR _attach_point$[ebp]
	movsx	eax, BYTE PTR [edx+eax-1]
	cmp	eax, 92					; 0000005cH
	je	SHORT $LN22@archive_cr

; 470  :             sprintf( path, "%s\\%s", attach_point, curfilename );

	lea	ecx, DWORD PTR _curfilename$[ebp]
	push	ecx
	mov	edx, DWORD PTR _attach_point$[ebp]
	push	edx
	push	OFFSET ??_C@_05BMGBEOOC@?$CFs?2?$CFs?$AA@
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H

; 471  :         else

	jmp	SHORT $LN21@archive_cr
$LN22@archive_cr:

; 472  :             sprintf( path, "%s%s", attach_point, curfilename );

	lea	ecx, DWORD PTR _curfilename$[ebp]
	push	ecx
	mov	edx, DWORD PTR _attach_point$[ebp]
	push	edx
	push	OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H
$LN21@archive_cr:

; 473  : 
; 474  :         len = strlen( path );

	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _len$[ebp], eax

; 475  : 
; 476  :         for( i=len; i>2; i-- )

	mov	edx, DWORD PTR _len$[ebp]
	mov	DWORD PTR _i$[ebp], edx
	jmp	SHORT $LN20@archive_cr
$LN19@archive_cr:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN20@archive_cr:
	cmp	DWORD PTR _i$[ebp], 2
	jle	SHORT $LN18@archive_cr

; 477  :         {
; 478  :             if( path[i-1] == ASCII_FORESLASH )

	mov	ecx, DWORD PTR _i$[ebp]
	movsx	edx, BYTE PTR _path$[ebp+ecx-1]
	cmp	edx, 47					; 0000002fH
	jne	SHORT $LN17@archive_cr

; 479  :             {
; 480  :                 if( !path_idx )

	cmp	DWORD PTR _path_idx$[ebp], 0
	jne	SHORT $LN16@archive_cr

; 481  :                 {
; 482  :                     path_idx = i-1;

	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _path_idx$[ebp], eax

; 483  :                     fname = &path[ path_idx+1 ];

	mov	ecx, DWORD PTR _path_idx$[ebp]
	lea	edx, DWORD PTR _path$[ebp+ecx+1]
	mov	DWORD PTR _fname$[ebp], edx
$LN16@archive_cr:

; 484  :                 }
; 485  : 
; 486  :                 path[i-1] = ASCII_BACKSLASH;

	mov	eax, DWORD PTR _i$[ebp]
	mov	BYTE PTR _path$[ebp+eax-1], 92		; 0000005cH
$LN17@archive_cr:

; 487  :             }
; 488  :         }

	jmp	SHORT $LN19@archive_cr
$LN18@archive_cr:

; 489  : 
; 490  :         strcpy( data.name, fname ); /* use a dummy to add entry to the hash table    */

	mov	ecx, DWORD PTR _fname$[ebp]
	push	ecx
	lea	edx, DWORD PTR _data$[ebp+36]
	push	edx
	call	_strcpy
	add	esp, 8

; 491  : 
; 492  :         // (wrong -->) dir_was = GLOBAL_SEARCH_INDEX - 1;
; 493  :         // KBR 9/4/97 - fixed.
; 494  :         // dir_was was being set based on the CWD rather than the attach point.
; 495  : 
; 496  :         i = 0; dir_was = 0;

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _dir_was$[ebp], 0
$LN15@archive_cr:

; 497  : 
; 498  :         do {
; 499  : 
; 500  :             if( !stricmp( GLOBAL_SEARCH_PATH[i], attach_point )) {

	mov	eax, DWORD PTR _attach_point$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _GLOBAL_SEARCH_PATH[ecx*4]
	push	edx
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN14@archive_cr

; 501  :                 dir_was = i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _dir_was$[ebp], eax

; 502  :                 break;

	jmp	SHORT $LN13@archive_cr
$LN14@archive_cr:

; 503  :             }
; 504  : 
; 505  :         } while( i++ < GLOBAL_SEARCH_INDEX );

	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR tv353[ebp], ecx
	mov	edx, DWORD PTR _GLOBAL_SEARCH_INDEX
	mov	DWORD PTR tv354[ebp], edx
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR tv353[ebp]
	cmp	ecx, DWORD PTR tv354[ebp]
	jl	SHORT $LN15@archive_cr
$LN13@archive_cr:

; 506  : 
; 507  :         vol_was = (char)(toupper(path[0]) - 'A');

	mov	edx, 1
	imul	edx, 0
	movsx	eax, BYTE PTR _path$[ebp+edx]
	push	eax
	call	_toupper
	add	esp, 4
	sub	eax, 65					; 00000041H
	mov	BYTE PTR _vol_was$[ebp], al

; 508  : 
; 509  : #if( !RES_USE_FLAT_MODEL )
; 510  : 
; 511  :         /* See if there is a new directory name.  If so, we need to create a new hash table,
; 512  :            add this path into the global hash table, and continue add files into the new
; 513  :            table.  This is assuming you're building the hierarchical model of course. */
; 514  : 
; 515  : 
; 516  :         path[ path_idx+1 ] = '\0';

	mov	ecx, DWORD PTR _path_idx$[ebp]
	add	ecx, 1
	mov	DWORD PTR $T2[ebp], ecx
	cmp	DWORD PTR $T2[ebp], 260			; 00000104H
	jae	SHORT $LN51@archive_cr
	jmp	SHORT $LN52@archive_cr
$LN51@archive_cr:
	call	___report_rangecheckfailure
$LN52@archive_cr:
	mov	edx, DWORD PTR $T2[ebp]
	mov	BYTE PTR _path$[ebp+edx], 0

; 517  :         path[ path_idx+2 ] = '\0';

	mov	eax, DWORD PTR _path_idx$[ebp]
	add	eax, 2
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 260			; 00000104H
	jae	SHORT $LN53@archive_cr
	jmp	SHORT $LN54@archive_cr
$LN53@archive_cr:
	call	___report_rangecheckfailure
$LN54@archive_cr:
	mov	ecx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _path$[ebp+ecx], 0

; 518  : 
; 519  :         if( path_idx && strcmp( path, path_was ))    /* new directory! */

	cmp	DWORD PTR _path_idx$[ebp], 0
	je	$LN11@archive_cr
	lea	edx, DWORD PTR _path_was$[ebp]
	push	edx
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	je	$LN11@archive_cr

; 520  :         {           
; 521  :             strcpy( path_was, path );

	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	lea	edx, DWORD PTR _path_was$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 522  : 
; 523  :             /* see if it already exists */
; 524  : 
; 525  : /*            RES_LOCK( GLOBAL_HASH_TABLE ); GFG */
; 526  :             entry = hash_find( path, GLOBAL_HASH_TABLE );

	mov	eax, DWORD PTR _GLOBAL_HASH_TABLE
	push	eax
	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	_hash_find
	add	esp, 8
	mov	DWORD PTR _entry$[ebp], eax

; 527  : 
; 528  :             if( entry )

	cmp	DWORD PTR _entry$[ebp], 0
	je	SHORT $LN10@archive_cr

; 529  :             {
; 530  :                 table = (HASH_TABLE *)entry -> dir;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR _table$[ebp], eax

; 531  :                 if( !table )

	cmp	DWORD PTR _table$[ebp], 0
	jne	SHORT $LN9@archive_cr

; 532  :                     break;

	jmp	$LN35@archive_cr
$LN9@archive_cr:

; 533  :             }
; 534  :             else

	jmp	$LN11@archive_cr
$LN10@archive_cr:

; 535  :             {
; 536  : #if( RES_DEBUG_VERSION )
; 537  :                 if( GLOBAL_SEARCH_INDEX >= (MAX_DIRECTORIES-1)) {

	cmp	DWORD PTR _GLOBAL_SEARCH_INDEX, 249	; 000000f9H
	jl	SHORT $LN7@archive_cr

; 538  :                     assert(!"Exceeded MAX_DIRECTORIES as defined in omni.h");
; 539  : //                  SAY_ERROR( RES_ERR_TOO_MANY_DIRECTORIES, "ResAddPath" );
; 540  :                     return( FALSE );

	xor	eax, eax
	jmp	$LN46@archive_cr
$LN7@archive_cr:

; 541  :                 }
; 542  : #endif
; 543  :                 table = hash_create( ARCHIVE_TABLE_SIZE, path );

	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	push	29					; 0000001dH
	call	_hash_create
	add	esp, 8
	mov	DWORD PTR _table$[ebp], eax

; 544  : 
; 545  :                 strcpy( info.name, path );                /* insert a dummy entry into the global hash table  */

	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	lea	eax, DWORD PTR _info$[ebp+36]
	push	eax
	call	_strcpy
	add	esp, 8

; 546  :                 info.attrib = _A_SUBDIR | (unsigned int)FORCE_BIT;

	mov	DWORD PTR _info$[ebp], -2147483632	; 80000010H

; 547  :                 info.time_create = 0;

	xorpd	xmm0, xmm0
	movlpd	QWORD PTR _info$[ebp+8], xmm0

; 548  :                 info.time_access = 0;

	xorpd	xmm0, xmm0
	movlpd	QWORD PTR _info$[ebp+16], xmm0

; 549  :                 info.size = 0;

	mov	DWORD PTR _info$[ebp+32], 0

; 550  : 
; 551  :                 entry = hash_add( &info, GLOBAL_HASH_TABLE );

	mov	ecx, DWORD PTR _GLOBAL_HASH_TABLE
	push	ecx
	lea	edx, DWORD PTR _info$[ebp]
	push	edx
	call	_hash_add
	add	esp, 8
	mov	DWORD PTR _entry$[ebp], eax

; 552  : 
; 553  :                 if( !entry )

	cmp	DWORD PTR _entry$[ebp], 0
	jne	SHORT $LN6@archive_cr

; 554  :                     break;

	jmp	$LN35@archive_cr
$LN6@archive_cr:

; 555  : 
; 556  :                 entry -> archive       = -1; /* the actual directory existence should not be considered

	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+24], -1

; 557  :                                                 as part of the archive.  All of the contents found within
; 558  :                                                 the directory are.   This allows a hard disk based file to
; 559  :                                                 override a zip archvie */
; 560  : 
; 561  :                 entry -> volume        = vol_was;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	dl, BYTE PTR _vol_was$[ebp]
	mov	BYTE PTR [ecx+36], dl

; 562  :                 entry -> directory     = dir_was;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR _dir_was$[ebp]
	mov	DWORD PTR [eax+32], ecx

; 563  : 
; 564  :                 GLOBAL_PATH_LIST = LIST_APPEND( GLOBAL_PATH_LIST, table );

	mov	edx, DWORD PTR _table$[ebp]
	push	edx
	mov	eax, DWORD PTR _GLOBAL_PATH_LIST
	push	eax
	call	_ListAppend
	add	esp, 8
	mov	DWORD PTR _GLOBAL_PATH_LIST, eax

; 565  :                 GLOBAL_SEARCH_PATH[ GLOBAL_SEARCH_INDEX ] = MemStrDup( path );

	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	_strdup
	add	esp, 4
	mov	edx, DWORD PTR _GLOBAL_SEARCH_INDEX
	mov	DWORD PTR _GLOBAL_SEARCH_PATH[edx*4], eax

; 566  :                 dir_was = GLOBAL_SEARCH_INDEX++;

	mov	eax, DWORD PTR _GLOBAL_SEARCH_INDEX
	mov	DWORD PTR _dir_was$[ebp], eax
	mov	ecx, DWORD PTR _GLOBAL_SEARCH_INDEX
	add	ecx, 1
	mov	DWORD PTR _GLOBAL_SEARCH_INDEX, ecx

; 567  : 
; 568  :                 entry -> dir = table;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR _table$[ebp]
	mov	DWORD PTR [edx+40], eax
$LN11@archive_cr:

; 569  :             }
; 570  : /*            RES_UNLOCK( GLOBAL_HASH_TABLE );  GFG */
; 571  :         }
; 572  : #endif /* !RES_USE_FLAT_MODEL */
; 573  : 
; 574  :         if( !(*data.name))

	mov	ecx, 1
	imul	ecx, 0
	movsx	edx, BYTE PTR _data$[ebp+ecx+36]
	test	edx, edx
	jne	SHORT $LN5@archive_cr

; 575  :             continue;  /* this is usually a directory entry, which we'll decipher later */

	jmp	$LN36@archive_cr
$LN5@archive_cr:

; 576  : 
; 577  : 
; 578  : #if( RES_REJECT_EMPTY_FILES )
; 579  :         if( !crec.csize )
; 580  :             continue;
; 581  : #endif 
; 582  :         data.attrib = (unsigned int)FORCE_BIT;

	mov	DWORD PTR _data$[ebp], -2147483648	; 80000000H

; 583  :         data.time_create = 0;

	xorpd	xmm0, xmm0
	movlpd	QWORD PTR _data$[ebp+8], xmm0

; 584  :         data.time_access = 0;

	xorpd	xmm0, xmm0
	movlpd	QWORD PTR _data$[ebp+16], xmm0

; 585  :         data.size = crec.csize;

	mov	eax, DWORD PTR _crec$[ebp+16]
	mov	DWORD PTR _data$[ebp+32], eax

; 586  : 
; 587  : /*        RES_LOCK( table );  GFG */
; 588  :         entry = hash_find( data.name, table );  /* see if an entry already exists */

	mov	ecx, DWORD PTR _table$[ebp]
	push	ecx
	lea	edx, DWORD PTR _data$[ebp+36]
	push	edx
	call	_hash_find
	add	esp, 8
	mov	DWORD PTR _entry$[ebp], eax

; 589  : 
; 590  :         if( !entry )

	cmp	DWORD PTR _entry$[ebp], 0
	jne	SHORT $LN4@archive_cr

; 591  :             entry = hash_add( &data, table );   /* if not, create one             */

	mov	eax, DWORD PTR _table$[ebp]
	push	eax
	lea	ecx, DWORD PTR _data$[ebp]
	push	ecx
	call	_hash_add
	add	esp, 8
	mov	DWORD PTR _entry$[ebp], eax

; 592  :         else /* there is already a file with the same name here! */

	jmp	SHORT $LN3@archive_cr
$LN4@archive_cr:

; 593  :             if( !replace_flag )

	cmp	DWORD PTR _replace_flag$[ebp], 0
	jne	SHORT $LN3@archive_cr

; 594  :                 continue;

	jmp	$LN36@archive_cr
$LN3@archive_cr:

; 595  : 
; 596  : 
; 597  :         entry -> file_position = crec.relative_offset_local_header;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR _crec$[ebp+40]
	mov	DWORD PTR [edx+20], eax

; 598  : 
; 599  :         //entry -> file_position = crec.relative_offset_local_header + 4 + LREC_SIZE + crec.filename_length;
; 600  :         
; 601  :         //if( crec.extra_field_length )
; 602  :         //    entry -> file_position += crec.extra_field_length + 4 /* ?4? */;
; 603  :         
; 604  :         entry -> method        = crec.compression_method;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	dx, WORD PTR _crec$[ebp+6]
	mov	WORD PTR [ecx+16], dx

; 605  :         entry -> size          = crec.ucsize;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR _crec$[ebp+20]
	mov	DWORD PTR [eax+8], ecx

; 606  :         entry -> csize         = crec.csize;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR _crec$[ebp+16]
	mov	DWORD PTR [edx+12], eax

; 607  :         entry -> archive       = arc -> os_handle;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR _arc$[ebp]
	mov	eax, DWORD PTR [edx+260]
	mov	DWORD PTR [ecx+24], eax

; 608  :         entry -> volume        = vol_was;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	dl, BYTE PTR _vol_was$[ebp]
	mov	BYTE PTR [ecx+36], dl

; 609  :         entry -> directory     = dir_was;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR _dir_was$[ebp]
	mov	DWORD PTR [eax+32], ecx

; 610  : /*        RES_UNLOCK( table );  GFG */
; 611  :     }

	jmp	$LN36@archive_cr
$LN35@archive_cr:

; 612  : 
; 613  :     if( error > PK_WARN )   /* if error occurred, see if user ejected media during long inflation job */

	cmp	DWORD PTR _error$[ebp], 1
	jle	SHORT $LN1@archive_cr

; 614  :         ResCheckMedia( toupper(filename[0]) - 'A' );

	mov	edx, 1
	imul	edx, 0
	mov	eax, DWORD PTR _filename$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	push	ecx
	call	_toupper
	add	esp, 4
	sub	eax, 65					; 00000041H
	push	eax
	call	_ResCheckMedia
	add	esp, 4
$LN1@archive_cr:

; 615  : 
; 616  : 	#ifdef USE_SH_POOLS
; 617  : 	MemFreePtr( arc -> tmp_in_buffer );
; 618  : 	MemFreePtr( arc -> tmp_slide );
; 619  : 	#else
; 620  : 	MemFree( arc -> tmp_in_buffer );

	mov	edx, DWORD PTR _arc$[ebp]
	mov	eax, DWORD PTR [edx+288]
	push	eax
	call	_free
	add	esp, 4

; 621  : 	MemFree( arc -> tmp_slide );

	mov	ecx, DWORD PTR _arc$[ebp]
	mov	edx, DWORD PTR [ecx+284]
	push	edx
	call	_free
	add	esp, 4

; 622  : 	#endif
; 623  :     
; 624  :     return( arc );

	mov	eax, DWORD PTR _arc$[ebp]
$LN46@archive_cr:

; 625  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_archive_create ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\unzip.c
_TEXT	SEGMENT
_byterec$ = -32						; size = 26
__$ArrayPad$ = -4					; size = 4
_lrec$ = 8						; size = 4
_buffer$ = 12						; size = 4
_process_local_file_hdr PROC

; 1479 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1480 :     local_byte_hdr byterec;
; 1481 : 
; 1482 : 
; 1483 :   /*---------------------------------------------------------------------------
; 1484 :     Read the next local file header and do any necessary machine-type con-
; 1485 :     versions (byte ordering, structure padding compensation--do so by copy-
; 1486 :     ing the data from the array into which it was read (byterec) to the
; 1487 :     usable struct (lrec)).
; 1488 :     ---------------------------------------------------------------------------*/
; 1489 : 
; 1490 :     //if( readbuf((char *)byterec, LREC_SIZE) <= 0)
; 1491 :     //    return PK_EOF;
; 1492 : 
; 1493 :     memcpy( byterec, buffer, LREC_SIZE );

	push	26					; 0000001aH
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	lea	ecx, DWORD PTR _byterec$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1494 : 
; 1495 :     lrec->version_needed_to_extract[0] = byterec[L_VERSION_NEEDED_TO_EXTRACT_0];

	mov	edx, 1
	imul	edx, 0
	mov	eax, 1
	imul	eax, 0
	mov	ecx, DWORD PTR _lrec$[ebp]
	mov	dl, BYTE PTR _byterec$[ebp+edx]
	mov	BYTE PTR [ecx+eax], dl

; 1496 :     lrec->version_needed_to_extract[1] = byterec[L_VERSION_NEEDED_TO_EXTRACT_1];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _lrec$[ebp]
	mov	al, BYTE PTR _byterec$[ebp+eax]
	mov	BYTE PTR [edx+ecx], al

; 1497 : 
; 1498 :     lrec->general_purpose_bit_flag = makeword(&byterec[L_GENERAL_PURPOSE_BIT_FLAG]);

	mov	ecx, 1
	shl	ecx, 1
	lea	edx, DWORD PTR _byterec$[ebp+ecx]
	push	edx
	call	_makeword
	add	esp, 4
	mov	ecx, DWORD PTR _lrec$[ebp]
	mov	WORD PTR [ecx+2], ax

; 1499 :     lrec->compression_method = makeword(&byterec[L_COMPRESSION_METHOD]);

	mov	edx, 1
	shl	edx, 2
	lea	eax, DWORD PTR _byterec$[ebp+edx]
	push	eax
	call	_makeword
	add	esp, 4
	mov	ecx, DWORD PTR _lrec$[ebp]
	mov	WORD PTR [ecx+4], ax

; 1500 :     lrec->last_mod_file_time = makeword(&byterec[L_LAST_MOD_FILE_TIME]);

	mov	edx, 1
	imul	edx, 6
	lea	eax, DWORD PTR _byterec$[ebp+edx]
	push	eax
	call	_makeword
	add	esp, 4
	mov	ecx, DWORD PTR _lrec$[ebp]
	mov	WORD PTR [ecx+6], ax

; 1501 :     lrec->last_mod_file_date = makeword(&byterec[L_LAST_MOD_FILE_DATE]);

	mov	edx, 1
	shl	edx, 3
	lea	eax, DWORD PTR _byterec$[ebp+edx]
	push	eax
	call	_makeword
	add	esp, 4
	mov	ecx, DWORD PTR _lrec$[ebp]
	mov	WORD PTR [ecx+8], ax

; 1502 :     lrec->crc32 = makelong(&byterec[L_CRC32]);

	mov	edx, 1
	imul	edx, 10					; 0000000aH
	lea	eax, DWORD PTR _byterec$[ebp+edx]
	push	eax
	call	_makelong
	add	esp, 4
	mov	ecx, DWORD PTR _lrec$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1503 :     lrec->csize = makelong(&byterec[L_COMPRESSED_SIZE]);

	mov	edx, 1
	imul	edx, 14					; 0000000eH
	lea	eax, DWORD PTR _byterec$[ebp+edx]
	push	eax
	call	_makelong
	add	esp, 4
	mov	ecx, DWORD PTR _lrec$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1504 :     lrec->ucsize = makelong(&byterec[L_UNCOMPRESSED_SIZE]);

	mov	edx, 1
	imul	edx, 18					; 00000012H
	lea	eax, DWORD PTR _byterec$[ebp+edx]
	push	eax
	call	_makelong
	add	esp, 4
	mov	ecx, DWORD PTR _lrec$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 1505 :     lrec->filename_length = makeword(&byterec[L_FILENAME_LENGTH]);

	mov	edx, 1
	imul	edx, 22					; 00000016H
	lea	eax, DWORD PTR _byterec$[ebp+edx]
	push	eax
	call	_makeword
	add	esp, 4
	mov	ecx, DWORD PTR _lrec$[ebp]
	mov	WORD PTR [ecx+24], ax

; 1506 :     lrec->extra_field_length = makeword(&byterec[L_EXTRA_FIELD_LENGTH]);

	mov	edx, 1
	imul	edx, 24					; 00000018H
	lea	eax, DWORD PTR _byterec$[ebp+edx]
	push	eax
	call	_makeword
	add	esp, 4
	mov	ecx, DWORD PTR _lrec$[ebp]
	mov	WORD PTR [ecx+26], ax

; 1507 : 
; 1508 :     if ((lrec->general_purpose_bit_flag & 8) != 0) {

	mov	edx, DWORD PTR _lrec$[ebp]
	movzx	eax, WORD PTR [edx+2]
	and	eax, 8
	je	SHORT $LN1@process_lo

; 1509 :         /* can't trust local header, use central directory
; 1510 :            If this is the problem, you should probably extract the
; 1511 :            entire zip and then rebuild it.  The local header should
; 1512 :            always be more reliable than the global, and in your case
; 1513 :            it is not (sorry, but you're fucked) */
; 1514 :         SAY_ERROR( RES_ERR_BAD_ARCHIVE, "Big problemo, read comment!" );

	push	OFFSET ??_C@_0M@MJJIOMHC@src?2unzip?4c?$AA@
	push	1514					; 000005eaH
	push	OFFSET ??_C@_0BM@IGMCHILJ@Big?5problemo?0?5read?5comment?$CB?$AA@
	push	-4974					; ffffec92H
	call	__say_error
	add	esp, 16					; 00000010H

; 1515 :         return( PK_ERR );

	mov	eax, 2
	jmp	SHORT $LN2@process_lo
$LN1@process_lo:

; 1516 :     }
; 1517 : 
; 1518 :     return( PK_COOL );

	xor	eax, eax
$LN2@process_lo:

; 1519 : 
; 1520 : } /* end function process_local_file_hdr() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_process_local_file_hdr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\unzip.c
_TEXT	SEGMENT
tv76 = -16						; size = 4
_bufstart$ = -12					; size = 4
_request$ = -8						; size = 4
_inbuf_offset$ = -4					; size = 4
_val$ = 8						; size = 4
_arc$ = 12						; size = 4
_unzip_seek PROC

; 771  : {    

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 772  :     LONGINT request = val/*+extra_bytes*/,

	mov	eax, DWORD PTR _val$[ebp]
	mov	DWORD PTR _request$[ebp], eax

; 773  :             inbuf_offset = request % INBUFSIZ,

	mov	ecx, DWORD PTR _request$[ebp]
	and	ecx, -2147481601			; 800007ffH
	jns	SHORT $LN8@unzip_seek
	dec	ecx
	or	ecx, -2048				; fffff800H
	inc	ecx
$LN8@unzip_seek:
	mov	DWORD PTR _inbuf_offset$[ebp], ecx

; 774  :             bufstart = request - inbuf_offset;

	mov	edx, DWORD PTR _request$[ebp]
	sub	edx, DWORD PTR _inbuf_offset$[ebp]
	mov	DWORD PTR _bufstart$[ebp], edx

; 775  : 
; 776  :     if( request < 0 )

	cmp	DWORD PTR _request$[ebp], 0
	jge	SHORT $LN5@unzip_seek

; 777  :     {
; 778  :         return( -1 );

	or	eax, -1
	jmp	$LN6@unzip_seek

; 779  :     }
; 780  :     else

	jmp	$LN4@unzip_seek
$LN5@unzip_seek:

; 781  :     {
; 782  :         if( bufstart != arc -> start_buffer )

	mov	eax, DWORD PTR _arc$[ebp]
	mov	ecx, DWORD PTR _bufstart$[ebp]
	cmp	ecx, DWORD PTR [eax+268]
	je	$LN3@unzip_seek

; 783  :         {
; 784  :             arc -> start_buffer = lseek( arc -> os_handle, (LONGINT)bufstart, SEEK_SET );

	push	0
	mov	edx, DWORD PTR _bufstart$[ebp]
	push	edx
	mov	eax, DWORD PTR _arc$[ebp]
	mov	ecx, DWORD PTR [eax+260]
	push	ecx
	call	_lseek
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _arc$[ebp]
	mov	DWORD PTR [edx+268], eax

; 785  :   
; 786  :             if(( arc -> tmp_in_count = read( arc -> os_handle,(char *)arc -> tmp_in_buffer, INBUFSIZ )) <= 0 )

	push	2048					; 00000800H
	mov	eax, DWORD PTR _arc$[ebp]
	mov	ecx, DWORD PTR [eax+288]
	push	ecx
	mov	edx, DWORD PTR _arc$[ebp]
	mov	eax, DWORD PTR [edx+260]
	push	eax
	call	_read
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv76[ebp], eax
	mov	ecx, DWORD PTR _arc$[ebp]
	mov	edx, DWORD PTR tv76[ebp]
	mov	DWORD PTR [ecx+296], edx
	cmp	DWORD PTR tv76[ebp], 0
	jg	SHORT $LN2@unzip_seek

; 787  :                 return( -1 );

	or	eax, -1
	jmp	SHORT $LN6@unzip_seek
$LN2@unzip_seek:

; 788  : 
; 789  :             arc -> tmp_in_ptr = arc -> tmp_in_buffer + inbuf_offset;

	mov	eax, DWORD PTR _arc$[ebp]
	mov	ecx, DWORD PTR [eax+288]
	add	ecx, DWORD PTR _inbuf_offset$[ebp]
	mov	edx, DWORD PTR _arc$[ebp]
	mov	DWORD PTR [edx+292], ecx

; 790  :             arc -> tmp_in_count -= (int)inbuf_offset;

	mov	eax, DWORD PTR _arc$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	sub	ecx, DWORD PTR _inbuf_offset$[ebp]
	mov	edx, DWORD PTR _arc$[ebp]
	mov	DWORD PTR [edx+296], ecx

; 791  :         } 
; 792  :         else

	jmp	SHORT $LN4@unzip_seek
$LN3@unzip_seek:

; 793  :         {
; 794  :             arc -> tmp_in_count += (arc -> tmp_in_ptr - arc -> tmp_in_buffer) - inbuf_offset;

	mov	eax, DWORD PTR _arc$[ebp]
	mov	ecx, DWORD PTR _arc$[ebp]
	mov	edx, DWORD PTR [eax+292]
	sub	edx, DWORD PTR [ecx+288]
	sub	edx, DWORD PTR _inbuf_offset$[ebp]
	mov	eax, DWORD PTR _arc$[ebp]
	add	edx, DWORD PTR [eax+296]
	mov	ecx, DWORD PTR _arc$[ebp]
	mov	DWORD PTR [ecx+296], edx

; 795  :             arc -> tmp_in_ptr = arc -> tmp_in_buffer + inbuf_offset;

	mov	edx, DWORD PTR _arc$[ebp]
	mov	eax, DWORD PTR [edx+288]
	add	eax, DWORD PTR _inbuf_offset$[ebp]
	mov	ecx, DWORD PTR _arc$[ebp]
	mov	DWORD PTR [ecx+292], eax
$LN4@unzip_seek:

; 796  :         }
; 797  :     }
; 798  : 
; 799  :     return( 0 ); /* success (i guess) */

	xor	eax, eax
$LN6@unzip_seek:

; 800  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_unzip_seek ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\unzip.c
_TEXT	SEGMENT
tv86 = -364						; size = 4
tv76 = -360						; size = 4
_count$ = -356						; size = 4
_members_remaining$ = -352				; size = 2
_error_in_archive$ = -348				; size = 4
_error$ = -344						; size = 4
_crec$ = -340						; size = 44
_ecrec$ = -296						; size = 20
_curfilename$ = -276					; size = 261
_sig$ = -12						; size = 5
__$ArrayPad$ = -4					; size = 4
_arc$ = 8						; size = 4
_archive_size PROC

; 676  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 364				; 0000016cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 677  :     char    sig[5];
; 678  :     int     error = 0, 

	mov	DWORD PTR _error$[ebp], 0

; 679  :             error_in_archive = 0;

	mov	DWORD PTR _error_in_archive$[ebp], 0

; 680  :     int     count;
; 681  : 
; 682  :     ecdir_rec ecrec;                /* used in unzip.c, extract.c */
; 683  : 
; 684  : //    int filnum=(-1);
; 685  : 
; 686  :     ush members_remaining;//, 
; 687  : //        num_skipped = 0, 
; 688  : //        num_bad_pwd = 0;
; 689  : 
; 690  :     char curfilename[FILNAMSIZ];
; 691  :     cdir_file_hdr crec;             /* used in unzip.c, extract.c, misc.c */
; 692  : 
; 693  :     /*---------------------------------------------------------------------------
; 694  :        Start by constructing the various PK signature strings.
; 695  :       ---------------------------------------------------------------------------*/
; 696  : 
; 697  :     local_hdr_sig[0]   = '\120';   /* ASCII 'P', */

	mov	eax, 1
	imul	eax, 0
	mov	BYTE PTR _local_hdr_sig[eax], 80	; 00000050H

; 698  :     central_hdr_sig[0] = '\120';

	mov	ecx, 1
	imul	ecx, 0
	mov	BYTE PTR _central_hdr_sig[ecx], 80	; 00000050H

; 699  :     end_central_sig[0] = '\120';   /* not EBCDIC */

	mov	edx, 1
	imul	edx, 0
	mov	BYTE PTR _end_central_sig[edx], 80	; 00000050H

; 700  : 
; 701  :     if(( ((error_in_archive = find_end_central_dir(MIN((arc -> length),66000L), &ecrec, arc)) != 0 ))) 

	mov	eax, DWORD PTR _arc$[ebp]
	cmp	DWORD PTR [eax+264], 66000		; 000101d0H
	jge	SHORT $LN18@archive_si
	mov	ecx, DWORD PTR _arc$[ebp]
	mov	edx, DWORD PTR [ecx+264]
	mov	DWORD PTR tv76[ebp], edx
	jmp	SHORT $LN19@archive_si
$LN18@archive_si:
	mov	DWORD PTR tv76[ebp], 66000		; 000101d0H
$LN19@archive_si:
	mov	eax, DWORD PTR _arc$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ecrec$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv76[ebp]
	push	edx
	call	_find_end_central_dir
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _error_in_archive$[ebp], eax
	cmp	DWORD PTR _error_in_archive$[ebp], 0
	je	SHORT $LN15@archive_si

; 702  :         return( -1 );

	or	eax, -1
	jmp	$LN16@archive_si
$LN15@archive_si:

; 703  : 
; 704  :     if( UNZIP_LSEEK( ecrec.offset_start_central_directory, arc ))

	mov	eax, DWORD PTR _arc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ecrec$[ebp+12]
	push	ecx
	call	_unzip_seek
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@archive_si

; 705  :         return( -1 );

	or	eax, -1
	jmp	$LN16@archive_si
$LN14@archive_si:

; 706  :     
; 707  :     members_remaining = ecrec.total_entries_central_dir;

	mov	dx, WORD PTR _ecrec$[ebp+6]
	mov	WORD PTR _members_remaining$[ebp], dx

; 708  : 
; 709  :     count = 0;

	mov	DWORD PTR _count$[ebp], 0
$LN13@archive_si:

; 710  : 
; 711  :     while( members_remaining-- )

	movzx	eax, WORD PTR _members_remaining$[ebp]
	mov	DWORD PTR tv86[ebp], eax
	mov	cx, WORD PTR _members_remaining$[ebp]
	sub	cx, 1
	mov	WORD PTR _members_remaining$[ebp], cx
	cmp	DWORD PTR tv86[ebp], 0
	je	$LN12@archive_si

; 712  :     {
; 713  :         if( readbuf( sig, 4, arc ) <= 0 )

	mov	edx, DWORD PTR _arc$[ebp]
	push	edx
	push	4
	lea	eax, DWORD PTR _sig$[ebp]
	push	eax
	call	_readbuf
	add	esp, 12					; 0000000cH
	test	eax, eax
	jg	SHORT $LN11@archive_si

; 714  :         {
; 715  :             error_in_archive = PK_EOF;

	mov	DWORD PTR _error_in_archive$[ebp], 51	; 00000033H

; 716  :             break;

	jmp	$LN12@archive_si
$LN11@archive_si:

; 717  :         }
; 718  : 
; 719  :         if( strncmp( sig, central_hdr_sig, 4 ))     /* just to make sure                            */

	push	4
	push	OFFSET _central_hdr_sig
	lea	ecx, DWORD PTR _sig$[ebp]
	push	ecx
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN10@archive_si

; 720  :         {  
; 721  :             error_in_archive = PK_BADERR;

	mov	DWORD PTR _error_in_archive$[ebp], 3

; 722  :             break;

	jmp	$LN12@archive_si
$LN10@archive_si:

; 723  :         }
; 724  : 
; 725  :         /* process_cdir_file_hdr() sets pInfo->hostnum, pInfo->lcflag */
; 726  : 
; 727  :         if(( error = process_cdir_file_hdr( &crec, arc )) != PK_COOL )

	mov	edx, DWORD PTR _arc$[ebp]
	push	edx
	lea	eax, DWORD PTR _crec$[ebp]
	push	eax
	call	_process_cdir_file_hdr
	add	esp, 8
	mov	DWORD PTR _error$[ebp], eax
	cmp	DWORD PTR _error$[ebp], 0
	je	SHORT $LN9@archive_si

; 728  :         {
; 729  :             error_in_archive = error;               /* only PK_EOF defined                          */

	mov	ecx, DWORD PTR _error$[ebp]
	mov	DWORD PTR _error_in_archive$[ebp], ecx

; 730  :             break;

	jmp	$LN12@archive_si
$LN9@archive_si:

; 731  :         }
; 732  : 
; 733  :         if((error = do_string( crec.filename_length, FILENAME, curfilename, arc )) != PK_COOL) 

	mov	edx, DWORD PTR _arc$[ebp]
	push	edx
	lea	eax, DWORD PTR _curfilename$[ebp]
	push	eax
	push	2
	movzx	ecx, WORD PTR _crec$[ebp+24]
	push	ecx
	call	_do_string
	add	esp, 16					; 00000010H
	mov	DWORD PTR _error$[ebp], eax
	cmp	DWORD PTR _error$[ebp], 0
	je	SHORT $LN8@archive_si

; 734  :         {
; 735  :             if( error > error_in_archive )

	mov	edx, DWORD PTR _error$[ebp]
	cmp	edx, DWORD PTR _error_in_archive$[ebp]
	jle	SHORT $LN7@archive_si

; 736  :                 error_in_archive = error;

	mov	eax, DWORD PTR _error$[ebp]
	mov	DWORD PTR _error_in_archive$[ebp], eax
$LN7@archive_si:

; 737  : 
; 738  :             if( error > PK_WARN )                   /* fatal:  no more left to do                   */

	cmp	DWORD PTR _error$[ebp], 1
	jle	SHORT $LN8@archive_si

; 739  :             {  
; 740  :                 UNZIP_ERROR = RES_ERR_UNKNOWN;

	mov	DWORD PTR _UNZIP_ERROR, -4973		; ffffec93H

; 741  :                 break;

	jmp	$LN12@archive_si
$LN8@archive_si:

; 742  :             }
; 743  :         }
; 744  : 
; 745  :         if(( error = do_string( crec.file_comment_length, SKIP, NULL, arc )) != PK_COOL ) 

	mov	ecx, DWORD PTR _arc$[ebp]
	push	ecx
	push	0
	push	0
	movzx	edx, WORD PTR _crec$[ebp+28]
	push	edx
	call	_do_string
	add	esp, 16					; 00000010H
	mov	DWORD PTR _error$[ebp], eax
	cmp	DWORD PTR _error$[ebp], 0
	je	SHORT $LN5@archive_si

; 746  :         {
; 747  :             if( error > error_in_archive )

	mov	eax, DWORD PTR _error$[ebp]
	cmp	eax, DWORD PTR _error_in_archive$[ebp]
	jle	SHORT $LN4@archive_si

; 748  :                 error_in_archive = error;

	mov	ecx, DWORD PTR _error$[ebp]
	mov	DWORD PTR _error_in_archive$[ebp], ecx
$LN4@archive_si:

; 749  : 
; 750  :             if( error > PK_WARN )                   /* fatal: bail now                               */

	cmp	DWORD PTR _error$[ebp], 1
	jle	SHORT $LN5@archive_si

; 751  :             {  
; 752  :                 UNZIP_ERROR = RES_ERR_UNKNOWN;

	mov	DWORD PTR _UNZIP_ERROR, -4973		; ffffec93H

; 753  :                 break;

	jmp	SHORT $LN12@archive_si
$LN5@archive_si:

; 754  :             }
; 755  :         }
; 756  : 
; 757  :         if( !(*curfilename))

	mov	edx, 1
	imul	edx, 0
	movsx	eax, BYTE PTR _curfilename$[ebp+edx]
	test	eax, eax
	jne	SHORT $LN2@archive_si

; 758  :             continue;  /* this is usually a directory entry, which we'll decipher later */

	jmp	$LN13@archive_si
$LN2@archive_si:

; 759  : 
; 760  :         count++;

	mov	ecx, DWORD PTR _count$[ebp]
	add	ecx, 1
	mov	DWORD PTR _count$[ebp], ecx

; 761  :     }

	jmp	$LN13@archive_si
$LN12@archive_si:

; 762  : 
; 763  :     if( error > PK_WARN )   /* if error occurred, see if user ejected media during long inflation job */

	cmp	DWORD PTR _error$[ebp], 1
	jle	SHORT $LN1@archive_si

; 764  :         return( -1 );

	or	eax, -1
	jmp	SHORT $LN16@archive_si
$LN1@archive_si:

; 765  : 
; 766  :     return( count );

	mov	eax, DWORD PTR _count$[ebp]
$LN16@archive_si:

; 767  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_archive_size ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\unzip.c
_TEXT	SEGMENT
_byterec$ = -48						; size = 42
__$ArrayPad$ = -4					; size = 4
_crec$ = 8						; size = 4
_arc$ = 12						; size = 4
_get_cdir_file_hdr PROC

; 1335 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1336 :     cdir_byte_hdr byterec;
; 1337 : 
; 1338 :     /*---------------------------------------------------------------------------
; 1339 :         Read the next central directory entry and do any necessary machine-type
; 1340 :         conversions (byte ordering, structure padding compensation--do so by
; 1341 :         copying the data from the array into which it was read (byterec) to the
; 1342 :         usable struct (crec)).
; 1343 :       ---------------------------------------------------------------------------*/
; 1344 : 
; 1345 :     if( readbuf((char *)byterec, CREC_SIZE, arc) <= 0 )

	mov	eax, DWORD PTR _arc$[ebp]
	push	eax
	push	42					; 0000002aH
	lea	ecx, DWORD PTR _byterec$[ebp]
	push	ecx
	call	_readbuf
	add	esp, 12					; 0000000cH
	test	eax, eax
	jg	SHORT $LN1@get_cdir_f

; 1346 :         return( PK_EOF );

	mov	eax, 51					; 00000033H
	jmp	$LN2@get_cdir_f
$LN1@get_cdir_f:

; 1347 : 
; 1348 :     crec->version_made_by[0] = byterec[C_VERSION_MADE_BY_0];

	mov	edx, 1
	imul	edx, 0
	mov	eax, 1
	imul	eax, 0
	mov	ecx, DWORD PTR _crec$[ebp]
	mov	dl, BYTE PTR _byterec$[ebp+edx]
	mov	BYTE PTR [ecx+eax], dl

; 1349 :     crec->version_made_by[1] = byterec[C_VERSION_MADE_BY_1];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _crec$[ebp]
	mov	al, BYTE PTR _byterec$[ebp+eax]
	mov	BYTE PTR [edx+ecx], al

; 1350 :     crec->version_needed_to_extract[0] = byterec[C_VERSION_NEEDED_TO_EXTRACT_0];

	mov	ecx, 1
	shl	ecx, 1
	mov	edx, 1
	imul	edx, 0
	mov	eax, DWORD PTR _crec$[ebp]
	mov	cl, BYTE PTR _byterec$[ebp+ecx]
	mov	BYTE PTR [eax+edx+2], cl

; 1351 :     crec->version_needed_to_extract[1] = byterec[C_VERSION_NEEDED_TO_EXTRACT_1];

	mov	edx, 1
	imul	edx, 3
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _crec$[ebp]
	mov	dl, BYTE PTR _byterec$[ebp+edx]
	mov	BYTE PTR [ecx+eax+2], dl

; 1352 : 
; 1353 :     crec->general_purpose_bit_flag = makeword(&byterec[C_GENERAL_PURPOSE_BIT_FLAG]);

	mov	eax, 1
	shl	eax, 2
	lea	ecx, DWORD PTR _byterec$[ebp+eax]
	push	ecx
	call	_makeword
	add	esp, 4
	mov	edx, DWORD PTR _crec$[ebp]
	mov	WORD PTR [edx+4], ax

; 1354 :     crec->compression_method = makeword(&byterec[C_COMPRESSION_METHOD]);

	mov	eax, 1
	imul	eax, 6
	lea	ecx, DWORD PTR _byterec$[ebp+eax]
	push	ecx
	call	_makeword
	add	esp, 4
	mov	edx, DWORD PTR _crec$[ebp]
	mov	WORD PTR [edx+6], ax

; 1355 :     crec->last_mod_file_time = makeword(&byterec[C_LAST_MOD_FILE_TIME]);

	mov	eax, 1
	shl	eax, 3
	lea	ecx, DWORD PTR _byterec$[ebp+eax]
	push	ecx
	call	_makeword
	add	esp, 4
	mov	edx, DWORD PTR _crec$[ebp]
	mov	WORD PTR [edx+8], ax

; 1356 :     crec->last_mod_file_date = makeword(&byterec[C_LAST_MOD_FILE_DATE]);

	mov	eax, 1
	imul	eax, 10					; 0000000aH
	lea	ecx, DWORD PTR _byterec$[ebp+eax]
	push	ecx
	call	_makeword
	add	esp, 4
	mov	edx, DWORD PTR _crec$[ebp]
	mov	WORD PTR [edx+10], ax

; 1357 :     crec->crc32 = makelong(&byterec[C_CRC32]);

	mov	eax, 1
	imul	eax, 12					; 0000000cH
	lea	ecx, DWORD PTR _byterec$[ebp+eax]
	push	ecx
	call	_makelong
	add	esp, 4
	mov	edx, DWORD PTR _crec$[ebp]
	mov	DWORD PTR [edx+12], eax

; 1358 :     crec->csize = makelong(&byterec[C_COMPRESSED_SIZE]);

	mov	eax, 1
	shl	eax, 4
	lea	ecx, DWORD PTR _byterec$[ebp+eax]
	push	ecx
	call	_makelong
	add	esp, 4
	mov	edx, DWORD PTR _crec$[ebp]
	mov	DWORD PTR [edx+16], eax

; 1359 :     crec->ucsize = makelong(&byterec[C_UNCOMPRESSED_SIZE]);

	mov	eax, 1
	imul	eax, 20					; 00000014H
	lea	ecx, DWORD PTR _byterec$[ebp+eax]
	push	ecx
	call	_makelong
	add	esp, 4
	mov	edx, DWORD PTR _crec$[ebp]
	mov	DWORD PTR [edx+20], eax

; 1360 :     crec->filename_length = makeword(&byterec[C_FILENAME_LENGTH]);

	mov	eax, 1
	imul	eax, 24					; 00000018H
	lea	ecx, DWORD PTR _byterec$[ebp+eax]
	push	ecx
	call	_makeword
	add	esp, 4
	mov	edx, DWORD PTR _crec$[ebp]
	mov	WORD PTR [edx+24], ax

; 1361 :     crec->extra_field_length = makeword(&byterec[C_EXTRA_FIELD_LENGTH]);

	mov	eax, 1
	imul	eax, 26					; 0000001aH
	lea	ecx, DWORD PTR _byterec$[ebp+eax]
	push	ecx
	call	_makeword
	add	esp, 4
	mov	edx, DWORD PTR _crec$[ebp]
	mov	WORD PTR [edx+26], ax

; 1362 :     crec->file_comment_length = makeword(&byterec[C_FILE_COMMENT_LENGTH]);

	mov	eax, 1
	imul	eax, 28					; 0000001cH
	lea	ecx, DWORD PTR _byterec$[ebp+eax]
	push	ecx
	call	_makeword
	add	esp, 4
	mov	edx, DWORD PTR _crec$[ebp]
	mov	WORD PTR [edx+28], ax

; 1363 :     crec->disk_number_start = makeword(&byterec[C_DISK_NUMBER_START]);

	mov	eax, 1
	imul	eax, 30					; 0000001eH
	lea	ecx, DWORD PTR _byterec$[ebp+eax]
	push	ecx
	call	_makeword
	add	esp, 4
	mov	edx, DWORD PTR _crec$[ebp]
	mov	WORD PTR [edx+30], ax

; 1364 :     crec->internal_file_attributes = makeword(&byterec[C_INTERNAL_FILE_ATTRIBUTES]);

	mov	eax, 1
	shl	eax, 5
	lea	ecx, DWORD PTR _byterec$[ebp+eax]
	push	ecx
	call	_makeword
	add	esp, 4
	mov	edx, DWORD PTR _crec$[ebp]
	mov	WORD PTR [edx+32], ax

; 1365 :     crec->external_file_attributes = makelong(&byterec[C_EXTERNAL_FILE_ATTRIBUTES]);  /* LONG, not word! */

	mov	eax, 1
	imul	eax, 34					; 00000022H
	lea	ecx, DWORD PTR _byterec$[ebp+eax]
	push	ecx
	call	_makelong
	add	esp, 4
	mov	edx, DWORD PTR _crec$[ebp]
	mov	DWORD PTR [edx+36], eax

; 1366 :     crec->relative_offset_local_header = makelong(&byterec[C_RELATIVE_OFFSET_LOCAL_HEADER]);

	mov	eax, 1
	imul	eax, 38					; 00000026H
	lea	ecx, DWORD PTR _byterec$[ebp+eax]
	push	ecx
	call	_makelong
	add	esp, 4
	mov	edx, DWORD PTR _crec$[ebp]
	mov	DWORD PTR [edx+40], eax

; 1367 :     
; 1368 :     return( PK_COOL );

	xor	eax, eax
$LN2@get_cdir_f:

; 1369 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_get_cdir_file_hdr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\unzip.c
_TEXT	SEGMENT
_error$ = -12						; size = 4
tv65 = -8						; size = 4
_extra_len$ = -4					; size = 2
_len$ = 8						; size = 4
_option$ = 12						; size = 4
_filename$ = 16						; size = 4
_arc$ = 20						; size = 4
_do_string PROC

; 1380 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1381 :     int error=PK_OK;

	mov	DWORD PTR _error$[ebp], 0

; 1382 :     ush extra_len;
; 1383 : 
; 1384 :   /*---------------------------------------------------------------------------
; 1385 :     This function processes arbitrary-length (well, usually) strings.  Three
; 1386 :     options are allowed:  SKIP, wherein the string is skipped (pretty logical,
; 1387 :     eh?); DISPLAY, wherein the string is printed to standard output after un-
; 1388 :     dergoing any necessary or unnecessary character conversions; and FILENAME,
; 1389 :     wherein the string is put into the filename[] array after undergoing ap-
; 1390 :     propriate conversions (including case-conversion, if that is indicated:
; 1391 :     see the global variable pInfo->lcflag).  The latter option should be OK,
; 1392 :     since filename is now dimensioned at 1025, but we check anyway.
; 1393 : 
; 1394 :     The string, by the way, is assumed to start at the current file-pointer
; 1395 :     position; its length is given by len.  So start off by checking length
; 1396 :     of string:  if zero, we're already done.
; 1397 :     ---------------------------------------------------------------------------*/
; 1398 : 
; 1399 :     if( !len )

	cmp	DWORD PTR _len$[ebp], 0
	jne	SHORT $LN9@do_string

; 1400 :         return( PK_COOL );

	xor	eax, eax
	jmp	$LN10@do_string
$LN9@do_string:

; 1401 : 
; 1402 :     switch (option) 

	mov	eax, DWORD PTR _option$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	cmp	DWORD PTR tv65[ebp], 0
	je	SHORT $LN2@do_string
	cmp	DWORD PTR tv65[ebp], 0
	jle	$LN7@do_string
	cmp	DWORD PTR tv65[ebp], 2
	jle	SHORT $LN6@do_string
	jmp	$LN7@do_string
$LN6@do_string:

; 1403 :     {
; 1404 : 
; 1405 :         /*
; 1406 :          * First case:  print string on standard output.  First set loop vari-
; 1407 :          * ables, then loop through the comment in chunks of OUTBUFSIZ bytes,
; 1408 :          * converting formats and printing as we go.  The second half of the
; 1409 :          * loop conditional was added because the file might be truncated, in
; 1410 :          * which case comment_bytes_left will remain at some non-zero value for
; 1411 :          * all time.  outbuf is used as a scratch buffer because it is avail-
; 1412 :          * able (we should be either before or in between any file processing).
; 1413 :          * [The typecast in front of the MIN() macro was added because of the
; 1414 :          * new promotion rules under ANSI C; readbuf() wants an int, but MIN()
; 1415 :          * returns a signed long, if I understand things correctly.  The proto-
; 1416 :          * type should handle it, but just in case...]
; 1417 :          */
; 1418 : 
; 1419 :         case DISPLAY:
; 1420 :         case FILENAME:
; 1421 :             extra_len = 0;

	xor	ecx, ecx
	mov	WORD PTR _extra_len$[ebp], cx

; 1422 :             if( len >= FILNAMSIZ ) 

	cmp	DWORD PTR _len$[ebp], 261		; 00000105H
	jb	SHORT $LN5@do_string

; 1423 :             {
; 1424 :                 // fprintf(stderr, "warning:  filename too long--truncating.\n");
; 1425 :                 error = PK_WARN;

	mov	DWORD PTR _error$[ebp], 1

; 1426 :                 extra_len = (ush)( len - FILNAMSIZ + 1 );

	mov	edx, DWORD PTR _len$[ebp]
	sub	edx, 260				; 00000104H
	mov	WORD PTR _extra_len$[ebp], dx

; 1427 :                 len = FILNAMSIZ - 1;

	mov	DWORD PTR _len$[ebp], 260		; 00000104H
$LN5@do_string:

; 1428 :             }
; 1429 : 
; 1430 :             if( readbuf(filename, len, arc) <= 0 )

	mov	eax, DWORD PTR _arc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	_readbuf
	add	esp, 12					; 0000000cH
	test	eax, eax
	jg	SHORT $LN4@do_string

; 1431 :                 return( PK_EOF );

	mov	eax, 51					; 00000033H
	jmp	SHORT $LN10@do_string
$LN4@do_string:

; 1432 : 
; 1433 :             filename[ len ] = '\0';        /* terminate w/zero:  ASCIIZ    */

	mov	eax, DWORD PTR _filename$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	mov	BYTE PTR [eax], 0

; 1434 : 
; 1435 :             A_TO_N(filename);            /* translate string to native    */
; 1436 : 
; 1437 :             if( !extra_len )            /* we're done here                */

	movzx	ecx, WORD PTR _extra_len$[ebp]
	test	ecx, ecx
	jne	SHORT $LN3@do_string

; 1438 :                 break;

	jmp	SHORT $LN7@do_string
$LN3@do_string:

; 1439 : 
; 1440 :             /*
; 1441 :              * We truncated the filename, so print what's left and then fall
; 1442 :              * through to the SKIP routine.
; 1443 :              */
; 1444 : 
; 1445 :             // fprintf(stderr, "[ %s ]\n", filename);
; 1446 : 
; 1447 :             len = extra_len;

	movzx	edx, WORD PTR _extra_len$[ebp]
	mov	DWORD PTR _len$[ebp], edx
$LN2@do_string:

; 1448 : 
; 1449 :             /* =========== FALL THROUGH =========== */
; 1450 : 
; 1451 :         /*
; 1452 :          * Third case:  skip string, adjusting readbuf's internal variables
; 1453 :          * as necessary (and possibly skipping to and reading a new block of
; 1454 :          * data).
; 1455 :          */
; 1456 : 
; 1457 :         case SKIP:
; 1458 :             if( UNZIP_LSEEK((int)(arc -> start_buffer) + ((int)(arc -> tmp_in_ptr) - (int)(arc -> tmp_in_buffer)) + len, arc ))

	mov	eax, DWORD PTR _arc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _arc$[ebp]
	mov	edx, DWORD PTR _arc$[ebp]
	mov	eax, DWORD PTR [ecx+292]
	sub	eax, DWORD PTR [edx+288]
	mov	ecx, DWORD PTR _arc$[ebp]
	mov	edx, DWORD PTR [ecx+268]
	add	edx, eax
	add	edx, DWORD PTR _len$[ebp]
	push	edx
	call	_unzip_seek
	add	esp, 8
	test	eax, eax
	je	SHORT $LN7@do_string

; 1459 :                 return( PK_WARN );

	mov	eax, 1
	jmp	SHORT $LN10@do_string
$LN7@do_string:

; 1460 :             break;
; 1461 : 
; 1462 :         /*
; 1463 :          * Fourth case:  assume we're at the start of an "extra field"; malloc
; 1464 :          * storage for it and read data into the allocated space.
; 1465 :          */
; 1466 : 
; 1467 :     } /* switch */
; 1468 : 
; 1469 :     return( error );

	mov	eax, DWORD PTR _error$[ebp]
$LN10@do_string:

; 1470 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_do_string ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\unzip.c
_TEXT	SEGMENT
_error$ = -4						; size = 4
_crec$ = 8						; size = 4
_arc$ = 12						; size = 4
_process_cdir_file_hdr PROC

; 962  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 963  :     int error;
; 964  : 
; 965  :     if((error = get_cdir_file_hdr(crec, arc)) != 0)

	mov	eax, DWORD PTR _arc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _crec$[ebp]
	push	ecx
	call	_get_cdir_file_hdr
	add	esp, 8
	mov	DWORD PTR _error$[ebp], eax
	cmp	DWORD PTR _error$[ebp], 0
	je	SHORT $LN1@process_cd

; 966  :         return( error );

	mov	eax, DWORD PTR _error$[ebp]
	jmp	SHORT $LN2@process_cd
$LN1@process_cd:

; 967  : 
; 968  :     return( PK_COOL );

	xor	eax, eax
$LN2@process_cd:

; 969  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_process_cdir_file_hdr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\unzip.c
_TEXT	SEGMENT
tv81 = -24						; size = 4
tv67 = -20						; size = 4
tv64 = -16						; size = 4
_error$ = -12						; size = 4
_pos$ = -8						; size = 4
_r$ = -4						; size = 4
_method$ = 8						; size = 4
_fcsize$ = 12						; size = 4
_cmp$ = 16						; size = 4
_extract_or_test_member PROC

; 988  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 989  :     int    r, 
; 990  :            error = PK_COOL;

	mov	DWORD PTR _error$[ebp], 0

; 991  : 
; 992  :     char * pos;
; 993  : 
; 994  :     switch( method )

	mov	eax, DWORD PTR _method$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 8
	ja	$LN1@extract_or
	mov	ecx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN19@extract_or[ecx*4]
$LN10@extract_or:

; 995  :     {
; 996  :         case STORED:
; 997  :             pos  = (char *)cmp -> out_buffer;

	mov	edx, DWORD PTR _cmp$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR _pos$[ebp], eax

; 998  :             seeklocked = TRUE;

	mov	BYTE PTR _seeklocked, 1
$LN9@extract_or:

; 999  :             do 
; 1000 :             {
; 1001 :                 r = (fcsize > INPUTBUFSIZE) ? INPUTBUFSIZE : fcsize;

	cmp	DWORD PTR _fcsize$[ebp], 20480		; 00005000H
	jle	SHORT $LN15@extract_or
	mov	DWORD PTR tv67[ebp], 20480		; 00005000H
	jmp	SHORT $LN16@extract_or
$LN15@extract_or:
	mov	ecx, DWORD PTR _fcsize$[ebp]
	mov	DWORD PTR tv67[ebp], ecx
$LN16@extract_or:
	mov	edx, DWORD PTR tv67[ebp]
	mov	DWORD PTR _r$[ebp], edx

; 1002 :                 read( cmp -> archive -> os_handle, pos, r );

	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR [eax+260]
	push	ecx
	call	_read
	add	esp, 12					; 0000000cH

; 1003 :                 pos += r;

	mov	edx, DWORD PTR _pos$[ebp]
	add	edx, DWORD PTR _r$[ebp]
	mov	DWORD PTR _pos$[ebp], edx

; 1004 :                 fcsize -= r;

	mov	eax, DWORD PTR _fcsize$[ebp]
	sub	eax, DWORD PTR _r$[ebp]
	mov	DWORD PTR _fcsize$[ebp], eax

; 1005 :             } while( fcsize > 0 );

	cmp	DWORD PTR _fcsize$[ebp], 0
	jg	SHORT $LN9@extract_or

; 1006 : 
; 1007 :             seeklocked = FALSE;

	mov	BYTE PTR _seeklocked, 0

; 1008 :             break;

	jmp	SHORT $LN11@extract_or
$LN6@extract_or:

; 1009 : 
; 1010 : #ifndef SFX
; 1011 :         case SHRUNK:
; 1012 :             break;

	jmp	SHORT $LN11@extract_or
$LN5@extract_or:

; 1013 :         case REDUCED1:
; 1014 :         case REDUCED2:
; 1015 :         case REDUCED3:
; 1016 :         case REDUCED4:
; 1017 :             break;

	jmp	SHORT $LN11@extract_or
$LN4@extract_or:

; 1018 :         case IMPLODED:
; 1019 :             break;

	jmp	SHORT $LN11@extract_or
$LN3@extract_or:

; 1020 : #endif /* !SFX */
; 1021 : 
; 1022 :         case DEFLATED:
; 1023 :             cmp -> csize = fcsize;

	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	edx, DWORD PTR _fcsize$[ebp]
	mov	DWORD PTR [ecx+40], edx

; 1024 :             seeklocked = TRUE;

	mov	BYTE PTR _seeklocked, 1

; 1025 : 
; 1026 :             if ((r = inflate( cmp )) != 0)

	mov	eax, DWORD PTR _cmp$[ebp]
	push	eax
	call	_inflate
	add	esp, 4
	mov	DWORD PTR _r$[ebp], eax
	cmp	DWORD PTR _r$[ebp], 0
	je	SHORT $LN2@extract_or

; 1027 :                 error = (r == 3)? PK_MEM2 : PK_ERR;

	cmp	DWORD PTR _r$[ebp], 3
	jne	SHORT $LN17@extract_or
	mov	DWORD PTR tv81[ebp], 5
	jmp	SHORT $LN18@extract_or
$LN17@extract_or:
	mov	DWORD PTR tv81[ebp], 2
$LN18@extract_or:
	mov	ecx, DWORD PTR tv81[ebp]
	mov	DWORD PTR _error$[ebp], ecx
$LN2@extract_or:

; 1028 : 
; 1029 :             /* free allocated memory */
; 1030 :             seeklocked = FALSE;

	mov	BYTE PTR _seeklocked, 0

; 1031 :             inflate_free();

	call	_inflate_free

; 1032 :             break;

	jmp	SHORT $LN11@extract_or
$LN1@extract_or:

; 1033 : 
; 1034 :         default:   /* should never get to this point */
; 1035 :             /* close and delete file before return? */
; 1036 :             error = PK_WARN;

	mov	DWORD PTR _error$[ebp], 1
$LN11@extract_or:

; 1037 :             break;
; 1038 :     } /* end switch (compression method) */
; 1039 : 
; 1040 :     /* NOTE THAT WE ****DISABLE**** crc checking on here..... and in fileio */
; 1041 : 
; 1042 :     return( error );

	mov	eax, DWORD PTR _error$[ebp]

; 1043 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN19@extract_or:
	DD	$LN10@extract_or
	DD	$LN6@extract_or
	DD	$LN5@extract_or
	DD	$LN5@extract_or
	DD	$LN5@extract_or
	DD	$LN5@extract_or
	DD	$LN4@extract_or
	DD	$LN1@extract_or
	DD	$LN3@extract_or
_extract_or_test_member ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\unzip.c
_TEXT	SEGMENT
_expect_ecrec_offset$ = -60				; size = 4
_real_ecrec_offset$ = -56				; size = 4
_numblks$ = -52						; size = 4
tv72 = -48						; size = 4
tv214 = -44						; size = 4
_i$ = -40						; size = 4
_found$ = -36						; size = 4
_tail_len$ = -32					; size = 4
_byterec$ = -28						; size = 22
__$ArrayPad$ = -4					; size = 4
_searchlen$ = 8						; size = 4
_ecrec$ = 12						; size = 4
_arc$ = 16						; size = 4
_find_end_central_dir PROC

; 1168 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1169 :     int i, 
; 1170 :         numblks, 
; 1171 :         found = FALSE;

	mov	DWORD PTR _found$[ebp], 0

; 1172 : 
; 1173 :     LONGINT tail_len;
; 1174 :     ec_byte_rec byterec;
; 1175 : 
; 1176 :     LONGINT real_ecrec_offset, 
; 1177 :             expect_ecrec_offset;
; 1178 : 
; 1179 :     /*---------------------------------------------------------------------------
; 1180 :         Treat case of short zipfile separately.
; 1181 :       ---------------------------------------------------------------------------*/
; 1182 : 
; 1183 :     if((arc -> length ) <= arc -> tmp_in_size )

	mov	eax, DWORD PTR _arc$[ebp]
	mov	ecx, DWORD PTR _arc$[ebp]
	mov	edx, DWORD PTR [eax+264]
	cmp	edx, DWORD PTR [ecx+300]
	jg	$LN24@find_end_c

; 1184 :     {
; 1185 :         lseek( arc -> os_handle, 0L, SEEK_SET);

	push	0
	push	0
	mov	eax, DWORD PTR _arc$[ebp]
	mov	ecx, DWORD PTR [eax+260]
	push	ecx
	call	_lseek
	add	esp, 12					; 0000000cH

; 1186 : 
; 1187 :         if(( arc -> tmp_in_count = read( arc -> os_handle, (char *)arc -> tmp_in_buffer, (unsigned int)(arc -> length))) == (int)(arc -> length))

	mov	edx, DWORD PTR _arc$[ebp]
	mov	eax, DWORD PTR [edx+264]
	push	eax
	mov	ecx, DWORD PTR _arc$[ebp]
	mov	edx, DWORD PTR [ecx+288]
	push	edx
	mov	eax, DWORD PTR _arc$[ebp]
	mov	ecx, DWORD PTR [eax+260]
	push	ecx
	call	_read
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv72[ebp], eax
	mov	edx, DWORD PTR _arc$[ebp]
	mov	eax, DWORD PTR tv72[ebp]
	mov	DWORD PTR [edx+296], eax
	mov	ecx, DWORD PTR _arc$[ebp]
	mov	edx, DWORD PTR tv72[ebp]
	cmp	edx, DWORD PTR [ecx+264]
	jne	$LN23@find_end_c

; 1188 :         {
; 1189 :             /* 'P' must be at least 22 bytes from end of zipfile */
; 1190 : 
; 1191 :             for( arc -> tmp_in_ptr = arc -> tmp_in_buffer + (arc -> length - 22);
; 1192 :                  arc -> tmp_in_ptr >= arc -> tmp_in_buffer;
; 1193 :                  arc -> tmp_in_ptr = arc -> tmp_in_ptr - 1 /* was: --inptr  uggh! */
; 1194 :                )

	mov	eax, DWORD PTR _arc$[ebp]
	mov	ecx, DWORD PTR [eax+264]
	mov	edx, DWORD PTR _arc$[ebp]
	mov	eax, DWORD PTR [edx+288]
	lea	ecx, DWORD PTR [ecx+eax-22]
	mov	edx, DWORD PTR _arc$[ebp]
	mov	DWORD PTR [edx+292], ecx
	jmp	SHORT $LN22@find_end_c
$LN21@find_end_c:
	mov	eax, DWORD PTR _arc$[ebp]
	mov	ecx, DWORD PTR [eax+292]
	sub	ecx, 1
	mov	edx, DWORD PTR _arc$[ebp]
	mov	DWORD PTR [edx+292], ecx
$LN22@find_end_c:
	mov	eax, DWORD PTR _arc$[ebp]
	mov	ecx, DWORD PTR _arc$[ebp]
	mov	edx, DWORD PTR [eax+292]
	cmp	edx, DWORD PTR [ecx+288]
	jb	SHORT $LN23@find_end_c

; 1195 :             {
; 1196 : //                if((native(*((int*)arc -> tmp_in_ptr)) == 'P') && 
; 1197 : //                    !strncmp((char *)arc -> tmp_in_ptr, end_central_sig, 4))  /* GFG 31/01/98
; 1198 :                 if(( (*(char*)(arc -> tmp_in_ptr)) == 'P') && !strncmp((char *)arc -> tmp_in_ptr, end_central_sig, 4))

	mov	eax, DWORD PTR _arc$[ebp]
	mov	ecx, DWORD PTR [eax+292]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 80					; 00000050H
	jne	SHORT $LN19@find_end_c
	push	4
	push	OFFSET _end_central_sig
	mov	eax, DWORD PTR _arc$[ebp]
	mov	ecx, DWORD PTR [eax+292]
	push	ecx
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN19@find_end_c

; 1199 : 
; 1200 :                 {
; 1201 :                     arc -> tmp_in_count -= (int)arc -> tmp_in_ptr - (int)arc -> tmp_in_buffer;

	mov	edx, DWORD PTR _arc$[ebp]
	mov	eax, DWORD PTR _arc$[ebp]
	mov	ecx, DWORD PTR [edx+292]
	sub	ecx, DWORD PTR [eax+288]
	mov	edx, DWORD PTR _arc$[ebp]
	mov	eax, DWORD PTR [edx+296]
	sub	eax, ecx
	mov	ecx, DWORD PTR _arc$[ebp]
	mov	DWORD PTR [ecx+296], eax

; 1202 :                     found = TRUE;

	mov	DWORD PTR _found$[ebp], 1

; 1203 :                     break;

	jmp	SHORT $LN23@find_end_c
$LN19@find_end_c:

; 1204 :                 }
; 1205 :             }

	jmp	$LN21@find_end_c
$LN23@find_end_c:

; 1206 :         }
; 1207 :     }
; 1208 :     else    /* --------------------------------------------------------------------------- */

	jmp	$fail$27
$LN24@find_end_c:

; 1209 :     {       /*  Zipfile is longer than inbufsiz:  may need to loop.  Start with short      */
; 1210 :             /*  block at end of zipfile (if not TOO short).                                */
; 1211 :             /* --------------------------------------------------------------------------- */
; 1212 :     
; 1213 :         if((tail_len = (arc -> length) % arc -> tmp_in_size) > ECREC_SIZE )

	mov	edx, DWORD PTR _arc$[ebp]
	mov	ecx, DWORD PTR _arc$[ebp]
	mov	eax, DWORD PTR [edx+264]
	cdq
	idiv	DWORD PTR [ecx+300]
	mov	DWORD PTR _tail_len$[ebp], edx
	cmp	DWORD PTR _tail_len$[ebp], 18		; 00000012H
	jle	$LN17@find_end_c

; 1214 :         {
; 1215 :             arc -> start_buffer = lseek( arc -> os_handle, (arc -> length) - tail_len, SEEK_SET );

	push	0
	mov	edx, DWORD PTR _arc$[ebp]
	mov	eax, DWORD PTR [edx+264]
	sub	eax, DWORD PTR _tail_len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _arc$[ebp]
	mov	edx, DWORD PTR [ecx+260]
	push	edx
	call	_lseek
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _arc$[ebp]
	mov	DWORD PTR [ecx+268], eax

; 1216 :             arc -> tmp_in_count = read( arc -> os_handle, (char *)arc -> tmp_in_buffer, (unsigned int)tail_len );

	mov	edx, DWORD PTR _tail_len$[ebp]
	push	edx
	mov	eax, DWORD PTR _arc$[ebp]
	mov	ecx, DWORD PTR [eax+288]
	push	ecx
	mov	edx, DWORD PTR _arc$[ebp]
	mov	eax, DWORD PTR [edx+260]
	push	eax
	call	_read
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _arc$[ebp]
	mov	DWORD PTR [ecx+296], eax

; 1217 : 
; 1218 :             if( arc -> tmp_in_count != (int)tail_len )

	mov	edx, DWORD PTR _arc$[ebp]
	mov	eax, DWORD PTR [edx+296]
	cmp	eax, DWORD PTR _tail_len$[ebp]
	je	SHORT $LN16@find_end_c

; 1219 :                 goto fail;      /* shut up; it's expedient */

	jmp	$fail$27
$LN16@find_end_c:

; 1220 : 
; 1221 :             /* 'P' must be at least 22 bytes from end of zipfile */
; 1222 :             for( arc -> tmp_in_ptr = arc -> tmp_in_buffer + (tail_len - 22);
; 1223 :                  arc -> tmp_in_ptr >= arc -> tmp_in_buffer;
; 1224 :                  arc -> tmp_in_ptr = arc -> tmp_in_ptr - 1
; 1225 :                 )

	mov	ecx, DWORD PTR _arc$[ebp]
	mov	edx, DWORD PTR [ecx+288]
	mov	eax, DWORD PTR _tail_len$[ebp]
	lea	ecx, DWORD PTR [eax+edx-22]
	mov	edx, DWORD PTR _arc$[ebp]
	mov	DWORD PTR [edx+292], ecx
	jmp	SHORT $LN15@find_end_c
$LN14@find_end_c:
	mov	eax, DWORD PTR _arc$[ebp]
	mov	ecx, DWORD PTR [eax+292]
	sub	ecx, 1
	mov	edx, DWORD PTR _arc$[ebp]
	mov	DWORD PTR [edx+292], ecx
$LN15@find_end_c:
	mov	eax, DWORD PTR _arc$[ebp]
	mov	ecx, DWORD PTR _arc$[ebp]
	mov	edx, DWORD PTR [eax+292]
	cmp	edx, DWORD PTR [ecx+288]
	jb	SHORT $LN13@find_end_c

; 1226 :             {
; 1227 :                 if(( (*(char*)(arc -> tmp_in_ptr)) == 'P') && !strncmp((char *)arc -> tmp_in_ptr, end_central_sig, 4))

	mov	eax, DWORD PTR _arc$[ebp]
	mov	ecx, DWORD PTR [eax+292]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 80					; 00000050H
	jne	SHORT $LN12@find_end_c
	push	4
	push	OFFSET _end_central_sig
	mov	eax, DWORD PTR _arc$[ebp]
	mov	ecx, DWORD PTR [eax+292]
	push	ecx
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN12@find_end_c

; 1228 :                 {
; 1229 :                     arc -> tmp_in_count -= (int)arc -> tmp_in_ptr - (int)arc -> tmp_in_buffer;

	mov	edx, DWORD PTR _arc$[ebp]
	mov	eax, DWORD PTR _arc$[ebp]
	mov	ecx, DWORD PTR [edx+292]
	sub	ecx, DWORD PTR [eax+288]
	mov	edx, DWORD PTR _arc$[ebp]
	mov	eax, DWORD PTR [edx+296]
	sub	eax, ecx
	mov	ecx, DWORD PTR _arc$[ebp]
	mov	DWORD PTR [ecx+296], eax

; 1230 :                     found = TRUE;

	mov	DWORD PTR _found$[ebp], 1

; 1231 :                     break;

	jmp	SHORT $LN13@find_end_c
$LN12@find_end_c:

; 1232 :                 }
; 1233 :             }

	jmp	$LN14@find_end_c
$LN13@find_end_c:

; 1234 : 
; 1235 :             /* sig may span block boundary: */
; 1236 :             strncpy((char *)arc -> tmp_hold, (char *)arc -> tmp_in_buffer, 3);

	push	3
	mov	edx, DWORD PTR _arc$[ebp]
	mov	eax, DWORD PTR [edx+288]
	push	eax
	mov	ecx, DWORD PTR _arc$[ebp]
	mov	edx, DWORD PTR [ecx+280]
	push	edx
	call	_strncpy
	add	esp, 12					; 0000000cH

; 1237 :         } 
; 1238 :         else

	jmp	SHORT $LN11@find_end_c
$LN17@find_end_c:

; 1239 :             arc -> start_buffer = (arc -> length) - tail_len;

	mov	eax, DWORD PTR _arc$[ebp]
	mov	ecx, DWORD PTR [eax+264]
	sub	ecx, DWORD PTR _tail_len$[ebp]
	mov	edx, DWORD PTR _arc$[ebp]
	mov	DWORD PTR [edx+268], ecx
$LN11@find_end_c:

; 1240 : 
; 1241 : 
; 1242 :         /*-----------------------------------------------------------------------
; 1243 :             Loop through blocks of zipfile data, starting at the end and going
; 1244 :             toward the beginning.  In general, need not check whole zipfile for
; 1245 :             signature, but may want to do so if testing.
; 1246 :           -----------------------------------------------------------------------*/
; 1247 : 
; 1248 :         numblks = (int)((searchlen - tail_len + (arc -> tmp_in_size - 1)) / arc -> tmp_in_size);

	mov	eax, DWORD PTR _searchlen$[ebp]
	sub	eax, DWORD PTR _tail_len$[ebp]
	mov	ecx, DWORD PTR _arc$[ebp]
	mov	edx, DWORD PTR [ecx+300]
	lea	eax, DWORD PTR [eax+edx-1]
	mov	ecx, DWORD PTR _arc$[ebp]
	cdq
	idiv	DWORD PTR [ecx+300]
	mov	DWORD PTR _numblks$[ebp], eax

; 1249 : 
; 1250 :         /*   ==amount=   ==done==   ==rounding==    =blksiz=  */
; 1251 : 
; 1252 :         for( i = 1;  !found && (i <= numblks);  ++i ) 

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN10@find_end_c
$LN9@find_end_c:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN10@find_end_c:
	cmp	DWORD PTR _found$[ebp], 0
	jne	$fail$27
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _numblks$[ebp]
	jg	$fail$27

; 1253 :         {
; 1254 :             arc -> start_buffer -= arc -> tmp_in_size;

	mov	ecx, DWORD PTR _arc$[ebp]
	mov	edx, DWORD PTR _arc$[ebp]
	mov	eax, DWORD PTR [ecx+268]
	sub	eax, DWORD PTR [edx+300]
	mov	ecx, DWORD PTR _arc$[ebp]
	mov	DWORD PTR [ecx+268], eax

; 1255 :             lseek( arc -> os_handle, arc -> start_buffer, SEEK_SET );

	push	0
	mov	edx, DWORD PTR _arc$[ebp]
	mov	eax, DWORD PTR [edx+268]
	push	eax
	mov	ecx, DWORD PTR _arc$[ebp]
	mov	edx, DWORD PTR [ecx+260]
	push	edx
	call	_lseek
	add	esp, 12					; 0000000cH

; 1256 : 
; 1257 :             if(( arc -> tmp_in_count = read(arc -> os_handle,(char *)arc -> tmp_in_buffer, arc -> tmp_in_size )) != arc -> tmp_in_size )

	mov	eax, DWORD PTR _arc$[ebp]
	mov	ecx, DWORD PTR [eax+300]
	push	ecx
	mov	edx, DWORD PTR _arc$[ebp]
	mov	eax, DWORD PTR [edx+288]
	push	eax
	mov	ecx, DWORD PTR _arc$[ebp]
	mov	edx, DWORD PTR [ecx+260]
	push	edx
	call	_read
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv214[ebp], eax
	mov	eax, DWORD PTR _arc$[ebp]
	mov	ecx, DWORD PTR tv214[ebp]
	mov	DWORD PTR [eax+296], ecx
	mov	edx, DWORD PTR _arc$[ebp]
	mov	eax, DWORD PTR tv214[ebp]
	cmp	eax, DWORD PTR [edx+300]
	je	SHORT $LN7@find_end_c

; 1258 :                 break;   /* fall through and fail */

	jmp	$fail$27
$LN7@find_end_c:

; 1259 : 
; 1260 :             for( arc -> tmp_in_ptr = arc -> tmp_in_buffer + arc -> tmp_in_size - 1;
; 1261 :                  arc -> tmp_in_ptr >= arc -> tmp_in_buffer;
; 1262 :                  arc -> tmp_in_ptr = arc -> tmp_in_ptr - 1
; 1263 :                )

	mov	ecx, DWORD PTR _arc$[ebp]
	mov	edx, DWORD PTR [ecx+288]
	mov	eax, DWORD PTR _arc$[ebp]
	mov	ecx, DWORD PTR [eax+300]
	lea	edx, DWORD PTR [edx+ecx-1]
	mov	eax, DWORD PTR _arc$[ebp]
	mov	DWORD PTR [eax+292], edx
	jmp	SHORT $LN6@find_end_c
$LN5@find_end_c:
	mov	ecx, DWORD PTR _arc$[ebp]
	mov	edx, DWORD PTR [ecx+292]
	sub	edx, 1
	mov	eax, DWORD PTR _arc$[ebp]
	mov	DWORD PTR [eax+292], edx
$LN6@find_end_c:
	mov	ecx, DWORD PTR _arc$[ebp]
	mov	edx, DWORD PTR _arc$[ebp]
	mov	eax, DWORD PTR [ecx+292]
	cmp	eax, DWORD PTR [edx+288]
	jb	SHORT $LN4@find_end_c

; 1264 :             {
; 1265 :                 if((*(char *)arc -> tmp_in_ptr == 'P')  && !strncmp((char *)arc -> tmp_in_ptr, end_central_sig, 4)) 

	mov	ecx, DWORD PTR _arc$[ebp]
	mov	edx, DWORD PTR [ecx+292]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 80					; 00000050H
	jne	SHORT $LN3@find_end_c
	push	4
	push	OFFSET _end_central_sig
	mov	ecx, DWORD PTR _arc$[ebp]
	mov	edx, DWORD PTR [ecx+292]
	push	edx
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN3@find_end_c

; 1266 :                 {
; 1267 :                     arc -> tmp_in_count -= ((int)arc -> tmp_in_ptr - (int)arc -> tmp_in_buffer);

	mov	eax, DWORD PTR _arc$[ebp]
	mov	ecx, DWORD PTR _arc$[ebp]
	mov	edx, DWORD PTR [eax+292]
	sub	edx, DWORD PTR [ecx+288]
	mov	eax, DWORD PTR _arc$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	sub	ecx, edx
	mov	edx, DWORD PTR _arc$[ebp]
	mov	DWORD PTR [edx+296], ecx

; 1268 :                     found = TRUE;

	mov	DWORD PTR _found$[ebp], 1

; 1269 :                     break;

	jmp	SHORT $LN4@find_end_c
$LN3@find_end_c:

; 1270 :                 }
; 1271 :             }

	jmp	$LN5@find_end_c
$LN4@find_end_c:

; 1272 : 
; 1273 :             /* sig may span block boundary: */
; 1274 :             strncpy( (char *)arc -> tmp_hold, (char *)arc -> tmp_in_buffer, 3 );

	push	3
	mov	eax, DWORD PTR _arc$[ebp]
	mov	ecx, DWORD PTR [eax+288]
	push	ecx
	mov	edx, DWORD PTR _arc$[ebp]
	mov	eax, DWORD PTR [edx+280]
	push	eax
	call	_strncpy
	add	esp, 12					; 0000000cH

; 1275 :         }

	jmp	$LN9@find_end_c
$fail$27:

; 1276 :        
; 1277 :     }
; 1278 : 
; 1279 :     /*---------------------------------------------------------------------------
; 1280 :         Searched through whole region where signature should be without finding
; 1281 :         it.  Print informational message and die a horrible death.
; 1282 :       ---------------------------------------------------------------------------*/
; 1283 : 
; 1284 : 
; 1285 : fail:
; 1286 : 
; 1287 :     if (!found) 

	cmp	DWORD PTR _found$[ebp], 0
	jne	SHORT $LN2@find_end_c

; 1288 :     {
; 1289 : #ifdef MSWIN
; 1290 :         MessageBeep(1);
; 1291 : #endif
; 1292 :         //  if (qflag || (zipinfo_mode && !hflag))
; 1293 :         //        fprintf(stderr, "[%s]\n", zipfn);
; 1294 :         //  fprintf(stderr, "\
; 1295 :         //    End-of-central-directory signature not found.  Either this file is not\n\
; 1296 :         //    a zipfile, or it constitutes one disk of a multi-part archive.  In the\n\
; 1297 :         //    latter case the central directory and zipfile comment will be found on\n\
; 1298 :         //    the last disk(s) of this archive.\n\n");
; 1299 : 
; 1300 :         return PK_ERR;   /* failed */

	mov	eax, 2
	jmp	$LN25@find_end_c
$LN2@find_end_c:

; 1301 :     }
; 1302 : 
; 1303 :     /*---------------------------------------------------------------------------
; 1304 :         Found the signature, so get the end-central data before returning.  Do
; 1305 :         any necessary machine-type conversions (byte ordering, structure padding
; 1306 :         compensation) by reading data into character array and copying to struct.
; 1307 :       ---------------------------------------------------------------------------*/
; 1308 : 
; 1309 :     real_ecrec_offset = (int)arc -> start_buffer + ((int)arc -> tmp_in_ptr - (int)arc -> tmp_in_buffer);

	mov	ecx, DWORD PTR _arc$[ebp]
	mov	edx, DWORD PTR _arc$[ebp]
	mov	eax, DWORD PTR [ecx+292]
	sub	eax, DWORD PTR [edx+288]
	mov	ecx, DWORD PTR _arc$[ebp]
	add	eax, DWORD PTR [ecx+268]
	mov	DWORD PTR _real_ecrec_offset$[ebp], eax

; 1310 : 
; 1311 :     if( readbuf((char *)byterec, ECREC_SIZE+4, arc ) <= 0 )

	mov	edx, DWORD PTR _arc$[ebp]
	push	edx
	push	22					; 00000016H
	lea	eax, DWORD PTR _byterec$[ebp]
	push	eax
	call	_readbuf
	add	esp, 12					; 0000000cH
	test	eax, eax
	jg	SHORT $LN1@find_end_c

; 1312 :         return( PK_EOF );

	mov	eax, 51					; 00000033H
	jmp	$LN25@find_end_c
$LN1@find_end_c:

; 1313 : 
; 1314 :     ecrec -> number_this_disk                   = MAKE_WORD( NUMBER_THIS_DISK                 );

	mov	ecx, 1
	shl	ecx, 2
	lea	edx, DWORD PTR _byterec$[ebp+ecx]
	push	edx
	call	_makeword
	add	esp, 4
	mov	ecx, DWORD PTR _ecrec$[ebp]
	mov	WORD PTR [ecx], ax

; 1315 :     ecrec -> num_disk_with_start_central_dir    = MAKE_WORD( NUM_DISK_WITH_START_CENTRAL_DIR  );

	mov	edx, 1
	imul	edx, 6
	lea	eax, DWORD PTR _byterec$[ebp+edx]
	push	eax
	call	_makeword
	add	esp, 4
	mov	ecx, DWORD PTR _ecrec$[ebp]
	mov	WORD PTR [ecx+2], ax

; 1316 :     ecrec -> num_entries_centrl_dir_ths_disk    = MAKE_WORD( NUM_ENTRIES_CENTRL_DIR_THS_DISK  );

	mov	edx, 1
	shl	edx, 3
	lea	eax, DWORD PTR _byterec$[ebp+edx]
	push	eax
	call	_makeword
	add	esp, 4
	mov	ecx, DWORD PTR _ecrec$[ebp]
	mov	WORD PTR [ecx+4], ax

; 1317 :     ecrec -> total_entries_central_dir          = MAKE_WORD( TOTAL_ENTRIES_CENTRAL_DIR        );

	mov	edx, 1
	imul	edx, 10					; 0000000aH
	lea	eax, DWORD PTR _byterec$[ebp+edx]
	push	eax
	call	_makeword
	add	esp, 4
	mov	ecx, DWORD PTR _ecrec$[ebp]
	mov	WORD PTR [ecx+6], ax

; 1318 :     ecrec -> size_central_directory             = MAKE_LONG( SIZE_CENTRAL_DIRECTORY           );

	mov	edx, 1
	imul	edx, 12					; 0000000cH
	lea	eax, DWORD PTR _byterec$[ebp+edx]
	push	eax
	call	_makelong
	add	esp, 4
	mov	ecx, DWORD PTR _ecrec$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1319 :     ecrec -> offset_start_central_directory     = MAKE_LONG( OFFSET_START_CENTRAL_DIRECTORY   );

	mov	edx, 1
	shl	edx, 4
	lea	eax, DWORD PTR _byterec$[ebp+edx]
	push	eax
	call	_makelong
	add	esp, 4
	mov	ecx, DWORD PTR _ecrec$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1320 :     ecrec -> zipfile_comment_length             = MAKE_WORD( ZIPFILE_COMMENT_LENGTH           );

	mov	edx, 1
	imul	edx, 20					; 00000014H
	lea	eax, DWORD PTR _byterec$[ebp+edx]
	push	eax
	call	_makeword
	add	esp, 4
	mov	ecx, DWORD PTR _ecrec$[ebp]
	mov	WORD PTR [ecx+16], ax

; 1321 : 
; 1322 :     expect_ecrec_offset = ecrec -> offset_start_central_directory + ecrec -> size_central_directory;

	mov	edx, DWORD PTR _ecrec$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _ecrec$[ebp]
	add	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR _expect_ecrec_offset$[ebp], eax

; 1323 : 
; 1324 :     return( PK_COOL );

	xor	eax, eax
$LN25@find_end_c:

; 1325 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_find_end_central_dir ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\unzip.c
_TEXT	SEGMENT
_rawbuf$ = 8						; size = 4
_size$ = 12						; size = 4
_unshrink$ = 16						; size = 4
_cmp$ = 20						; size = 4
_flush	PROC

; 1141 : {

	push	ebp
	mov	ebp, esp

; 1142 :     if( size == 0L )    /* testing or nothing to write:  all done    */

	cmp	DWORD PTR _size$[ebp], 0
	jne	SHORT $LN1@flush

; 1143 :         return( 0 );

	xor	eax, eax
	jmp	SHORT $LN2@flush
$LN1@flush:

; 1144 : 
; 1145 :     unshrink = 0;        /* Keep compiler from complaining            */

	mov	DWORD PTR _unshrink$[ebp], 0

; 1146 :     
; 1147 :     memcpy( cmp -> out_buffer + cmp -> out_count, rawbuf, size );

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rawbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _cmp$[ebp]
	add	eax, DWORD PTR [ecx+24]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1148 :     cmp -> out_count += size;

	mov	edx, DWORD PTR _cmp$[ebp]
	mov	eax, DWORD PTR [edx+24]
	add	eax, DWORD PTR _size$[ebp]
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 1149 : 
; 1150 :     return( 0 );

	xor	eax, eax
$LN2@flush:

; 1151 : }

	pop	ebp
	ret	0
_flush	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\unzip.c
_TEXT	SEGMENT
tv65 = -8						; size = 4
tv84 = -1						; size = 1
_cmp$ = 8						; size = 4
_readbyte PROC

; 1111 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1112 :     if((cmp -> in_count = read(cmp -> archive -> os_handle, (char *)cmp -> in_buffer, cmp -> in_size )) <= 0 )

	mov	eax, DWORD PTR _cmp$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx+260]
	push	eax
	call	_read
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv65[ebp], eax
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	edx, DWORD PTR tv65[ebp]
	mov	DWORD PTR [ecx+12], edx
	cmp	DWORD PTR tv65[ebp], 0
	jg	SHORT $LN1@readbyte

; 1113 :         return( EOF );

	or	eax, -1
	jmp	SHORT $LN2@readbyte
$LN1@readbyte:

; 1114 : 
; 1115 :     // nuke(?) cmp -> start_buffer += cmp -> in_size;   /* always starts on a block boundary */
; 1116 :     cmp -> in_ptr = cmp -> in_buffer;

	mov	eax, DWORD PTR _cmp$[ebp]
	mov	ecx, DWORD PTR _cmp$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+8], edx

; 1117 :     --cmp -> in_count;

	mov	eax, DWORD PTR _cmp$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sub	ecx, 1
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 1118 : 
; 1119 :  //   return( (*(int*)(cmp -> in_ptr))++ );
; 1120 :     return(*cmp->in_ptr++);

	mov	eax, DWORD PTR _cmp$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv84[ebp], dl
	mov	eax, DWORD PTR _cmp$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 1
	mov	edx, DWORD PTR _cmp$[ebp]
	mov	DWORD PTR [edx+8], ecx
	movzx	eax, BYTE PTR tv84[ebp]
$LN2@readbyte:

; 1121 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_readbyte ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\resources\reslib\src\unzip.c
_TEXT	SEGMENT
_n$ = -16						; size = 4
tv88 = -12						; size = 4
tv68 = -8						; size = 4
_count$ = -4						; size = 4
_buf$ = 8						; size = 4
_size$ = 12						; size = 4
_arc$ = 16						; size = 4
_readbuf PROC

; 1060 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 1061 :     register int count;
; 1062 :     int n;
; 1063 : 
; 1064 :     n = size;

	mov	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _n$[ebp], eax
$LN6@readbuf:

; 1065 :     while( size ) {

	cmp	DWORD PTR _size$[ebp], 0
	je	$LN5@readbuf

; 1066 :         if( arc -> tmp_in_count == 0 ) {

	mov	ecx, DWORD PTR _arc$[ebp]
	cmp	DWORD PTR [ecx+296], 0
	jne	$LN4@readbuf

; 1067 :             if(( arc -> tmp_in_count = read( arc -> os_handle, (char *)arc -> tmp_in_buffer, arc -> tmp_in_size )) == 0 ) {

	mov	edx, DWORD PTR _arc$[ebp]
	mov	eax, DWORD PTR [edx+300]
	push	eax
	mov	ecx, DWORD PTR _arc$[ebp]
	mov	edx, DWORD PTR [ecx+288]
	push	edx
	mov	eax, DWORD PTR _arc$[ebp]
	mov	ecx, DWORD PTR [eax+260]
	push	ecx
	call	_read
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv68[ebp], eax
	mov	edx, DWORD PTR _arc$[ebp]
	mov	eax, DWORD PTR tv68[ebp]
	mov	DWORD PTR [edx+296], eax
	cmp	DWORD PTR tv68[ebp], 0
	jne	SHORT $LN3@readbuf

; 1068 :                 //arc -> start_buffer += arc -> tmp_in_size;
; 1069 :                 return( (int)(n-size) );

	mov	eax, DWORD PTR _n$[ebp]
	sub	eax, DWORD PTR _size$[ebp]
	jmp	$LN7@readbuf

; 1070 :             }
; 1071 :             else {

	jmp	SHORT $LN2@readbuf
$LN3@readbuf:

; 1072 :                 if( arc -> tmp_in_count < 0 ) {

	mov	ecx, DWORD PTR _arc$[ebp]
	cmp	DWORD PTR [ecx+296], 0
	jge	SHORT $LN2@readbuf

; 1073 :                     //arc -> start_buffer += arc -> tmp_in_size;
; 1074 :                     return( -1 );  /* discarding some data, but better than lockup */

	or	eax, -1
	jmp	$LN7@readbuf
$LN2@readbuf:

; 1075 :                 }
; 1076 :             }
; 1077 : 
; 1078 :             /* buffer ALWAYS starts on a block boundary:  */
; 1079 : 
; 1080 :             arc -> start_buffer += arc -> tmp_in_size; /* NUKE??? */

	mov	edx, DWORD PTR _arc$[ebp]
	mov	eax, DWORD PTR [edx+268]
	mov	ecx, DWORD PTR _arc$[ebp]
	add	eax, DWORD PTR [ecx+300]
	mov	edx, DWORD PTR _arc$[ebp]
	mov	DWORD PTR [edx+268], eax

; 1081 :             arc -> tmp_in_ptr = arc -> tmp_in_buffer;

	mov	eax, DWORD PTR _arc$[ebp]
	mov	ecx, DWORD PTR _arc$[ebp]
	mov	edx, DWORD PTR [ecx+288]
	mov	DWORD PTR [eax+292], edx
$LN4@readbuf:

; 1082 :         }
; 1083 : 
; 1084 :         count = MIN( size, (unsigned)arc -> tmp_in_count );

	mov	eax, DWORD PTR _arc$[ebp]
	mov	ecx, DWORD PTR _size$[ebp]
	cmp	ecx, DWORD PTR [eax+296]
	jae	SHORT $LN9@readbuf
	mov	edx, DWORD PTR _size$[ebp]
	mov	DWORD PTR tv88[ebp], edx
	jmp	SHORT $LN10@readbuf
$LN9@readbuf:
	mov	eax, DWORD PTR _arc$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	DWORD PTR tv88[ebp], ecx
$LN10@readbuf:
	mov	edx, DWORD PTR tv88[ebp]
	mov	DWORD PTR _count$[ebp], edx

; 1085 :         memcpy( buf, arc -> tmp_in_ptr, count );

	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _arc$[ebp]
	mov	edx, DWORD PTR [ecx+292]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1086 :         buf += count;

	mov	ecx, DWORD PTR _buf$[ebp]
	add	ecx, DWORD PTR _count$[ebp]
	mov	DWORD PTR _buf$[ebp], ecx

; 1087 :         arc -> tmp_in_ptr += count;

	mov	edx, DWORD PTR _arc$[ebp]
	mov	eax, DWORD PTR [edx+292]
	add	eax, DWORD PTR _count$[ebp]
	mov	ecx, DWORD PTR _arc$[ebp]
	mov	DWORD PTR [ecx+292], eax

; 1088 :         arc -> tmp_in_count -= count;

	mov	edx, DWORD PTR _arc$[ebp]
	mov	eax, DWORD PTR [edx+296]
	sub	eax, DWORD PTR _count$[ebp]
	mov	ecx, DWORD PTR _arc$[ebp]
	mov	DWORD PTR [ecx+296], eax

; 1089 :         size -= count;

	mov	edx, DWORD PTR _size$[ebp]
	sub	edx, DWORD PTR _count$[ebp]
	mov	DWORD PTR _size$[ebp], edx

; 1090 :     }

	jmp	$LN6@readbuf
$LN5@readbuf:

; 1091 : 
; 1092 :     return( n );

	mov	eax, DWORD PTR _n$[ebp]
$LN7@readbuf:

; 1093 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_readbuf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\sys\stat.inl
_TEXT	SEGMENT
__Filename$ = 8						; size = 4
__Stat$ = 12						; size = 4
_stat	PROC

; 57   : {

	push	ebp
	mov	ebp, esp

; 58   :     _STATIC_ASSERT( sizeof(struct stat) == sizeof(struct _stat64i32) );
; 59   :     return _stat64i32(_Filename,(struct _stat64i32 *)_Stat);

	mov	eax, DWORD PTR __Stat$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Filename$[ebp]
	push	ecx
	call	__stat64i32
	add	esp, 8

; 60   : }

	pop	ebp
	ret	0
_stat	ENDP
_TEXT	ENDS
END
