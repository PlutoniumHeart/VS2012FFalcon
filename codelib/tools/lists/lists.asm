; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\codelib\tools\lists\lists.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_LIST_MUTEX
_BSS	SEGMENT
_LIST_MUTEX DD	01H DUP (?)
_BSS	ENDS
PUBLIC	_ListAppend
PUBLIC	_ListAppendEnd
PUBLIC	_ListAppendSecond
PUBLIC	_ListCatenate
PUBLIC	_ListNth
PUBLIC	_ListCount
PUBLIC	_ListRemove
PUBLIC	_ListFind
PUBLIC	_ListDestroy
PUBLIC	_ListWhere
PUBLIC	_ListSearch
PUBLIC	_ListDup
PUBLIC	_ListSort
EXTRN	_free:PROC
EXTRN	_malloc:PROC
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\tools\lists\lists.c
_TEXT	SEGMENT
_swap_b_child$1 = -24					; size = 4
_swap_a$2 = -20						; size = 4
_swap_a_child$3 = -16					; size = 4
_swap_b$4 = -12						; size = 4
_parent_b$ = -8						; size = 4
_parent_a$ = -4						; size = 4
_list$ = 8						; size = 4
_func_ptr$ = 12						; size = 4
_ListSort PROC

; 794  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 795  :    LIST **parent_a;
; 796  :    LIST **parent_b;
; 797  : 
; 798  :    for( parent_a = list; *parent_a; parent_a = &(*parent_a) -> next )

	mov	eax, DWORD PTR _list$[ebp]
	mov	DWORD PTR _parent_a$[ebp], eax
	jmp	SHORT $LN9@ListSort
$LN8@ListSort:
	mov	ecx, DWORD PTR _parent_a$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 8
	mov	DWORD PTR _parent_a$[ebp], edx
$LN9@ListSort:
	mov	eax, DWORD PTR _parent_a$[ebp]
	cmp	DWORD PTR [eax], 0
	je	$LN7@ListSort

; 799  :    {
; 800  :       for( parent_b = &(*parent_a) -> next; *parent_b; parent_b = &(*parent_b) -> next )

	mov	ecx, DWORD PTR _parent_a$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 8
	mov	DWORD PTR _parent_b$[ebp], edx
	jmp	SHORT $LN6@ListSort
$LN5@ListSort:
	mov	eax, DWORD PTR _parent_b$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 8
	mov	DWORD PTR _parent_b$[ebp], ecx
$LN6@ListSort:
	mov	edx, DWORD PTR _parent_b$[ebp]
	cmp	DWORD PTR [edx], 0
	je	$LN4@ListSort

; 801  :       {
; 802  :          if( func_ptr(*parent_a, *parent_b) > 0 )

	mov	eax, DWORD PTR _parent_b$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _parent_a$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR _func_ptr$[ebp]
	add	esp, 8
	test	eax, eax
	jle	SHORT $LN3@ListSort

; 803  :          {
; 804  :             LIST *swap_a, *swap_a_child;
; 805  :             LIST *swap_b, *swap_b_child;
; 806  : 
; 807  :             swap_a       = *parent_a;

	mov	ecx, DWORD PTR _parent_a$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _swap_a$2[ebp], edx

; 808  :             swap_a_child = (*parent_a) -> next;

	mov	eax, DWORD PTR _parent_a$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _swap_a_child$3[ebp], edx

; 809  :             swap_b       = *parent_b;

	mov	eax, DWORD PTR _parent_b$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _swap_b$4[ebp], ecx

; 810  :             swap_b_child = (*parent_b) -> next;

	mov	edx, DWORD PTR _parent_b$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _swap_b_child$1[ebp], ecx

; 811  : 
; 812  :             (*parent_a) -> next = swap_b_child;

	mov	edx, DWORD PTR _parent_a$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _swap_b_child$1[ebp]
	mov	DWORD PTR [eax+8], ecx

; 813  :             (*parent_a)         = swap_b;

	mov	edx, DWORD PTR _parent_a$[ebp]
	mov	eax, DWORD PTR _swap_b$4[ebp]
	mov	DWORD PTR [edx], eax

; 814  : 
; 815  :             if( swap_b == swap_a_child )

	mov	ecx, DWORD PTR _swap_b$4[ebp]
	cmp	ecx, DWORD PTR _swap_a_child$3[ebp]
	jne	SHORT $LN2@ListSort

; 816  :             {
; 817  :                 (*parent_a) -> next = swap_a;

	mov	edx, DWORD PTR _parent_a$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _swap_a$2[ebp]
	mov	DWORD PTR [eax+8], ecx

; 818  :                 parent_b            = &(*parent_a) -> next;

	mov	edx, DWORD PTR _parent_a$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 8
	mov	DWORD PTR _parent_b$[ebp], eax

; 819  :             }
; 820  :             else {

	jmp	SHORT $LN3@ListSort
$LN2@ListSort:

; 821  :                 (*parent_b) -> next = swap_a_child;

	mov	ecx, DWORD PTR _parent_b$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _swap_a_child$3[ebp]
	mov	DWORD PTR [edx+8], eax

; 822  :                 (*parent_b)         = swap_a;

	mov	ecx, DWORD PTR _parent_b$[ebp]
	mov	edx, DWORD PTR _swap_a$2[ebp]
	mov	DWORD PTR [ecx], edx
$LN3@ListSort:

; 823  :             }
; 824  :          }
; 825  : 
; 826  :       }

	jmp	$LN5@ListSort
$LN4@ListSort:

; 827  :    }

	jmp	$LN8@ListSort
$LN7@ListSort:

; 828  : 
; 829  :    return( *list );

	mov	eax, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR [eax]

; 830  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ListSort ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\tools\lists\lists.c
_TEXT	SEGMENT
_newlist$ = -4						; size = 4
_list$ = 8						; size = 4
_ListDup PROC

; 779  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 780  :    LIST * newlist;
; 781  : 
; 782  :    newlist = (LIST *)LIST_ALLOC();

	push	12					; 0000000cH
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _newlist$[ebp], eax

; 783  : 
; 784  :    newlist -> next = NULL;

	mov	eax, DWORD PTR _newlist$[ebp]
	mov	DWORD PTR [eax+8], 0

; 785  :    newlist -> node = list -> node;

	mov	ecx, DWORD PTR _newlist$[ebp]
	mov	edx, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 786  :    newlist -> user = list -> user;

	mov	ecx, DWORD PTR _newlist$[ebp]
	mov	edx, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax

; 787  : 
; 788  :    return (newlist);

	mov	eax, DWORD PTR _newlist$[ebp]

; 789  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ListDup ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\tools\lists\lists.c
_TEXT	SEGMENT
_l$ = -4						; size = 4
_list$ = 8						; size = 4
_node$ = 12						; size = 4
_func_ptr$ = 16						; size = 4
_ListSearch PROC

; 766  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 767  :    LIST * l;
; 768  : 
; 769  :    for( l =  list; list; list = list -> next )

	mov	eax, DWORD PTR _list$[ebp]
	mov	DWORD PTR _l$[ebp], eax
	jmp	SHORT $LN4@ListSearch
$LN3@ListSearch:
	mov	ecx, DWORD PTR _list$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _list$[ebp], edx
$LN4@ListSearch:
	cmp	DWORD PTR _list$[ebp], 0
	je	SHORT $LN2@ListSearch

; 770  :       if( !((*func_ptr)( list -> node, node )) )

	mov	eax, DWORD PTR _node$[ebp]
	push	eax
	mov	ecx, DWORD PTR _list$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR _func_ptr$[ebp]
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN1@ListSearch

; 771  :          return( l );

	mov	eax, DWORD PTR _l$[ebp]
	jmp	SHORT $LN5@ListSearch
$LN1@ListSearch:

; 772  : 
; 773  :    return( NULL );

	jmp	SHORT $LN3@ListSearch
$LN2@ListSearch:
	xor	eax, eax
$LN5@ListSearch:

; 774  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ListSearch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\tools\lists\lists.c
_TEXT	SEGMENT
_i$ = -8						; size = 4
_curr$ = -4						; size = 4
_list$ = 8						; size = 4
_node$ = 12						; size = 4
_ListWhere PROC

; 690  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 691  :    LIST * curr;
; 692  :    int i;
; 693  : 
; 694  :    for( i = 0, curr = list; curr; i++, curr = curr  ->  next ) 

	mov	DWORD PTR _i$[ebp], 0
	mov	eax, DWORD PTR _list$[ebp]
	mov	DWORD PTR _curr$[ebp], eax
	jmp	SHORT $LN4@ListWhere
$LN3@ListWhere:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	mov	edx, DWORD PTR _curr$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _curr$[ebp], eax
$LN4@ListWhere:
	cmp	DWORD PTR _curr$[ebp], 0
	je	SHORT $LN2@ListWhere

; 695  :    {
; 696  :       if ( curr -> node == node )

	mov	ecx, DWORD PTR _curr$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR _node$[ebp]
	jne	SHORT $LN1@ListWhere

; 697  :          return( i );

	mov	eax, DWORD PTR _i$[ebp]
	jmp	SHORT $LN5@ListWhere
$LN1@ListWhere:

; 698  :    }

	jmp	SHORT $LN3@ListWhere
$LN2@ListWhere:

; 699  :    
; 700  :    /* not found */
; 701  :    return( -1 );

	or	eax, -1
$LN5@ListWhere:

; 702  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ListWhere ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\tools\lists\lists.c
_TEXT	SEGMENT
_curr$ = -8						; size = 4
_prev$ = -4						; size = 4
_list$ = 8						; size = 4
_destructor$ = 12					; size = 4
_ListDestroy PROC

; 611  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 612  :    LIST * prev,
; 613  :         * curr;
; 614  : 
; 615  :    if ( !list )

	cmp	DWORD PTR _list$[ebp], 0
	jne	SHORT $LN5@ListDestro

; 616  :       return;

	jmp	SHORT $LN6@ListDestro
$LN5@ListDestro:

; 617  : 
; 618  :    prev = list;

	mov	eax, DWORD PTR _list$[ebp]
	mov	DWORD PTR _prev$[ebp], eax

; 619  :    curr = list -> next;

	mov	ecx, DWORD PTR _list$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _curr$[ebp], edx
$LN4@ListDestro:

; 620  : 
; 621  :    while ( curr )

	cmp	DWORD PTR _curr$[ebp], 0
	je	SHORT $LN3@ListDestro

; 622  :    {
; 623  :       if ( destructor )

	cmp	DWORD PTR _destructor$[ebp], 0
	je	SHORT $LN2@ListDestro

; 624  :          (*destructor)(prev -> node);

	mov	eax, DWORD PTR _prev$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR _destructor$[ebp]
	add	esp, 4
$LN2@ListDestro:

; 625  : 
; 626  :       prev -> next = NULL;

	mov	edx, DWORD PTR _prev$[ebp]
	mov	DWORD PTR [edx+8], 0

; 627  : 
; 628  :       LIST_FREE( prev );

	mov	eax, DWORD PTR _prev$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 629  : 
; 630  :       prev = curr;

	mov	ecx, DWORD PTR _curr$[ebp]
	mov	DWORD PTR _prev$[ebp], ecx

; 631  :       curr = curr -> next;

	mov	edx, DWORD PTR _curr$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _curr$[ebp], eax

; 632  :    }

	jmp	SHORT $LN4@ListDestro
$LN3@ListDestro:

; 633  : 
; 634  :    if( destructor )

	cmp	DWORD PTR _destructor$[ebp], 0
	je	SHORT $LN1@ListDestro

; 635  :       (*destructor)( prev -> node );

	mov	ecx, DWORD PTR _prev$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR _destructor$[ebp]
	add	esp, 4
$LN1@ListDestro:

; 636  : 
; 637  :    prev -> next = NULL;

	mov	eax, DWORD PTR _prev$[ebp]
	mov	DWORD PTR [eax+8], 0

; 638  : 
; 639  :    LIST_FREE( prev );

	mov	ecx, DWORD PTR _prev$[ebp]
	push	ecx
	call	_free
	add	esp, 4
$LN6@ListDestro:

; 640  : 
; 641  :    //ListGlobalPack();
; 642  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ListDestroy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\tools\lists\lists.c
_TEXT	SEGMENT
_curr$ = -4						; size = 4
_list$ = 8						; size = 4
_node$ = 12						; size = 4
_ListFind PROC

; 752  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 753  :    LIST * curr;
; 754  : 
; 755  :    for( curr = list; curr; curr = curr -> next ) 

	mov	eax, DWORD PTR _list$[ebp]
	mov	DWORD PTR _curr$[ebp], eax
	jmp	SHORT $LN4@ListFind
$LN3@ListFind:
	mov	ecx, DWORD PTR _curr$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _curr$[ebp], edx
$LN4@ListFind:
	cmp	DWORD PTR _curr$[ebp], 0
	je	SHORT $LN2@ListFind

; 756  :    {
; 757  :       if ( curr -> node == node )

	mov	eax, DWORD PTR _curr$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _node$[ebp]
	jne	SHORT $LN1@ListFind

; 758  :          return curr;

	mov	eax, DWORD PTR _curr$[ebp]
	jmp	SHORT $LN5@ListFind
$LN1@ListFind:

; 759  :    }

	jmp	SHORT $LN3@ListFind
$LN2@ListFind:

; 760  :    
; 761  :    return( NULL );

	xor	eax, eax
$LN5@ListFind:

; 762  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ListFind ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\tools\lists\lists.c
_TEXT	SEGMENT
_prev$ = -8						; size = 4
_curr$ = -4						; size = 4
_list$ = 8						; size = 4
_node$ = 12						; size = 4
_ListRemove PROC

; 712  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 713  :    LIST * prev,
; 714  :         * curr;
; 715  : 
; 716  :    if ( !list )

	cmp	DWORD PTR _list$[ebp], 0
	jne	SHORT $LN6@ListRemove

; 717  :       return( NULL );

	xor	eax, eax
	jmp	SHORT $LN7@ListRemove
$LN6@ListRemove:

; 718  : 
; 719  :    prev = NULL;

	mov	DWORD PTR _prev$[ebp], 0

; 720  :    curr = list;

	mov	eax, DWORD PTR _list$[ebp]
	mov	DWORD PTR _curr$[ebp], eax
$LN5@ListRemove:

; 721  : 
; 722  :    while( curr && (curr -> node != node) )

	cmp	DWORD PTR _curr$[ebp], 0
	je	SHORT $LN4@ListRemove
	mov	ecx, DWORD PTR _curr$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR _node$[ebp]
	je	SHORT $LN4@ListRemove

; 723  :    {
; 724  :       prev = curr;

	mov	eax, DWORD PTR _curr$[ebp]
	mov	DWORD PTR _prev$[ebp], eax

; 725  :       curr = curr -> next;

	mov	ecx, DWORD PTR _curr$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _curr$[ebp], edx

; 726  :    }

	jmp	SHORT $LN5@ListRemove
$LN4@ListRemove:

; 727  : 
; 728  :    /* not found, return list unmodified */
; 729  :    if ( !curr )

	cmp	DWORD PTR _curr$[ebp], 0
	jne	SHORT $LN3@ListRemove

; 730  :       return( list );

	mov	eax, DWORD PTR _list$[ebp]
	jmp	SHORT $LN7@ListRemove
$LN3@ListRemove:

; 731  : 
; 732  :    /* found at head */
; 733  :    if ( !prev )

	cmp	DWORD PTR _prev$[ebp], 0
	jne	SHORT $LN2@ListRemove

; 734  :       list = list -> next;

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _list$[ebp], ecx

; 735  :    else

	jmp	SHORT $LN1@ListRemove
$LN2@ListRemove:

; 736  :       prev -> next = curr -> next;

	mov	edx, DWORD PTR _prev$[ebp]
	mov	eax, DWORD PTR _curr$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx
$LN1@ListRemove:

; 737  :    
; 738  :    curr -> next = NULL;

	mov	edx, DWORD PTR _curr$[ebp]
	mov	DWORD PTR [edx+8], 0

; 739  : 
; 740  :    LIST_FREE( curr );

	mov	eax, DWORD PTR _curr$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 741  : 
; 742  :    return( list );

	mov	eax, DWORD PTR _list$[ebp]
$LN7@ListRemove:

; 743  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ListRemove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\tools\lists\lists.c
_TEXT	SEGMENT
_i$ = -8						; size = 4
_curr$ = -4						; size = 4
_list$ = 8						; size = 4
_ListCount PROC

; 672  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 673  :    LIST * curr;
; 674  :    int i;
; 675  : 
; 676  :    for( i = 0, curr = list; curr; i++, curr = curr  ->  next ) 

	mov	DWORD PTR _i$[ebp], 0
	mov	eax, DWORD PTR _list$[ebp]
	mov	DWORD PTR _curr$[ebp], eax
	jmp	SHORT $LN3@ListCount
$LN2@ListCount:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	mov	edx, DWORD PTR _curr$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _curr$[ebp], eax
$LN3@ListCount:
	cmp	DWORD PTR _curr$[ebp], 0
	je	SHORT $LN1@ListCount

; 677  :        ;

	jmp	SHORT $LN2@ListCount
$LN1@ListCount:

; 678  :    
; 679  :    return( i );

	mov	eax, DWORD PTR _i$[ebp]

; 680  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ListCount ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\tools\lists\lists.c
_TEXT	SEGMENT
_i$ = -8						; size = 4
_curr$ = -4						; size = 4
_list$ = 8						; size = 4
_n$ = 12						; size = 4
_ListNth PROC

; 653  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 654  :    int    i;
; 655  :    LIST * curr;
; 656  : 
; 657  :    curr = list;

	mov	eax, DWORD PTR _list$[ebp]
	mov	DWORD PTR _curr$[ebp], eax

; 658  : 
; 659  :    for( i=0 ; i<n && curr; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@ListNth
$LN2@ListNth:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN3@ListNth:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _n$[ebp]
	jge	SHORT $LN1@ListNth
	cmp	DWORD PTR _curr$[ebp], 0
	je	SHORT $LN1@ListNth

; 660  :       curr = curr -> next;

	mov	eax, DWORD PTR _curr$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _curr$[ebp], ecx
	jmp	SHORT $LN2@ListNth
$LN1@ListNth:

; 661  : 
; 662  :    return( curr );

	mov	eax, DWORD PTR _curr$[ebp]

; 663  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ListNth ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\tools\lists\lists.c
_TEXT	SEGMENT
_curr$ = -4						; size = 4
_l1$ = 8						; size = 4
_l2$ = 12						; size = 4
_ListCatenate PROC

; 584  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 585  :    LIST *curr;
; 586  : 
; 587  :    if ( !l1 )

	cmp	DWORD PTR _l1$[ebp], 0
	jne	SHORT $LN5@ListCatena

; 588  :       return l2;

	mov	eax, DWORD PTR _l2$[ebp]
	jmp	SHORT $LN6@ListCatena
$LN5@ListCatena:

; 589  : 
; 590  :    if ( !l2 )

	cmp	DWORD PTR _l2$[ebp], 0
	jne	SHORT $LN4@ListCatena

; 591  :       return l1;

	mov	eax, DWORD PTR _l1$[ebp]
	jmp	SHORT $LN6@ListCatena
$LN4@ListCatena:

; 592  : 
; 593  :    /* find last element of l1 */
; 594  :    for( curr = l1; curr -> next != NULL; curr = curr -> next );

	mov	eax, DWORD PTR _l1$[ebp]
	mov	DWORD PTR _curr$[ebp], eax
	jmp	SHORT $LN3@ListCatena
$LN2@ListCatena:
	mov	ecx, DWORD PTR _curr$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _curr$[ebp], edx
$LN3@ListCatena:
	mov	eax, DWORD PTR _curr$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN1@ListCatena
	jmp	SHORT $LN2@ListCatena
$LN1@ListCatena:

; 595  : 
; 596  :    /* catenate */
; 597  :    curr -> next = l2;

	mov	ecx, DWORD PTR _curr$[ebp]
	mov	edx, DWORD PTR _l2$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 598  : 
; 599  :    return l1;

	mov	eax, DWORD PTR _l1$[ebp]
$LN6@ListCatena:

; 600  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ListCatenate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\tools\lists\lists.c
_TEXT	SEGMENT
_newnode$ = -4						; size = 4
_list$ = 8						; size = 4
_node$ = 12						; size = 4
_ListAppendSecond PROC

; 561  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 562  :    LIST * newnode;
; 563  : 
; 564  :    newnode = (LIST *)LIST_ALLOC();

	push	12					; 0000000cH
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _newnode$[ebp], eax

; 565  : 
; 566  :    newnode -> node = node;

	mov	eax, DWORD PTR _newnode$[ebp]
	mov	ecx, DWORD PTR _node$[ebp]
	mov	DWORD PTR [eax], ecx

; 567  : 
; 568  :    /* chain in after first element */
; 569  :    newnode -> next = list -> next;

	mov	edx, DWORD PTR _newnode$[ebp]
	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx

; 570  : 
; 571  :    list -> next = newnode;

	mov	edx, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR _newnode$[ebp]
	mov	DWORD PTR [edx+8], eax

; 572  : 
; 573  :    /* return original head unchanged */
; 574  :    return( list );

	mov	eax, DWORD PTR _list$[ebp]

; 575  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ListAppendSecond ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\tools\lists\lists.c
_TEXT	SEGMENT
_newnode$ = -8						; size = 4
_curr$ = -4						; size = 4
_list$ = 8						; size = 4
_node$ = 12						; size = 4
_ListAppendEnd PROC

; 526  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 527  :    LIST * newnode;
; 528  :    LIST * curr;
; 529  : 
; 530  :    newnode = (LIST *)LIST_ALLOC();

	push	12					; 0000000cH
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _newnode$[ebp], eax

; 531  : 
; 532  :    newnode -> node = node;

	mov	eax, DWORD PTR _newnode$[ebp]
	mov	ecx, DWORD PTR _node$[ebp]
	mov	DWORD PTR [eax], ecx

; 533  :    newnode -> next = NULL;

	mov	edx, DWORD PTR _newnode$[ebp]
	mov	DWORD PTR [edx+8], 0

; 534  : 
; 535  :    /* list was null */
; 536  :    if ( !list ) 

	cmp	DWORD PTR _list$[ebp], 0
	jne	SHORT $LN5@ListAppend

; 537  :    {
; 538  :      list = newnode;

	mov	eax, DWORD PTR _newnode$[ebp]
	mov	DWORD PTR _list$[ebp], eax

; 539  :    }
; 540  :    else 

	jmp	SHORT $LN4@ListAppend
$LN5@ListAppend:

; 541  :    {
; 542  :       /* find end of list */
; 543  :       for( curr=list ; curr -> next != NULL ; curr = curr -> next ) ;

	mov	ecx, DWORD PTR _list$[ebp]
	mov	DWORD PTR _curr$[ebp], ecx
	jmp	SHORT $LN3@ListAppend
$LN2@ListAppend:
	mov	edx, DWORD PTR _curr$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _curr$[ebp], eax
$LN3@ListAppend:
	mov	ecx, DWORD PTR _curr$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN1@ListAppend
	jmp	SHORT $LN2@ListAppend
$LN1@ListAppend:

; 544  : 
; 545  :       /* chain in at end */
; 546  :       curr -> next = newnode;

	mov	edx, DWORD PTR _curr$[ebp]
	mov	eax, DWORD PTR _newnode$[ebp]
	mov	DWORD PTR [edx+8], eax
$LN4@ListAppend:

; 547  :    }
; 548  : 
; 549  :    return( list );

	mov	eax, DWORD PTR _list$[ebp]

; 550  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ListAppendEnd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\codelib\tools\lists\lists.c
_TEXT	SEGMENT
_newnode$ = -4						; size = 4
_list$ = 8						; size = 4
_node$ = 12						; size = 4
_ListAppend PROC

; 507  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 508  :    LIST * newnode;
; 509  : 
; 510  :    newnode = (LIST *)LIST_ALLOC();

	push	12					; 0000000cH
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _newnode$[ebp], eax

; 511  : 
; 512  :    newnode -> node = node;

	mov	eax, DWORD PTR _newnode$[ebp]
	mov	ecx, DWORD PTR _node$[ebp]
	mov	DWORD PTR [eax], ecx

; 513  :    newnode -> next = list;

	mov	edx, DWORD PTR _newnode$[ebp]
	mov	eax, DWORD PTR _list$[ebp]
	mov	DWORD PTR [edx+8], eax

; 514  : 
; 515  :    return( newnode );

	mov	eax, DWORD PTR _newnode$[ebp]

; 516  : }                         

	mov	esp, ebp
	pop	ebp
	ret	0
_ListAppend ENDP
_TEXT	ENDS
END
