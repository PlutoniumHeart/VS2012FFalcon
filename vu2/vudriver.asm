; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\vu2\src\vudriver.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?toSend@VuMaster@@0HA				; VuMaster::toSend
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
_BSS	SEGMENT
?toSend@VuMaster@@0HA DD 01H DUP (?)			; VuMaster::toSend
_BSS	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
PUBLIC	??8VU_SESSION_ID@@QBEHABV0@@Z			; VU_SESSION_ID::operator==
PUBLIC	??8VU_ID@@QBE_NABV0@@Z				; VU_ID::operator==
PUBLIC	?SetYPR@VuEntity@@QAEXMMM@Z			; VuEntity::SetYPR
PUBLIC	?SetYPRDelta@VuEntity@@QAEXMMM@Z		; VuEntity::SetYPRDelta
PUBLIC	?SetUpdateTime@VuEntity@@QAEXK@Z		; VuEntity::SetUpdateTime
PUBLIC	?OwnerId@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::OwnerId
PUBLIC	?XPos@VuEntity@@QBEMXZ				; VuEntity::XPos
PUBLIC	?YPos@VuEntity@@QBEMXZ				; VuEntity::YPos
PUBLIC	?ZPos@VuEntity@@QBEMXZ				; VuEntity::ZPos
PUBLIC	?XDelta@VuEntity@@QBEMXZ			; VuEntity::XDelta
PUBLIC	?YDelta@VuEntity@@QBEMXZ			; VuEntity::YDelta
PUBLIC	?ZDelta@VuEntity@@QBEMXZ			; VuEntity::ZDelta
PUBLIC	?Yaw@VuEntity@@QBEMXZ				; VuEntity::Yaw
PUBLIC	?Pitch@VuEntity@@QBEMXZ				; VuEntity::Pitch
PUBLIC	?Roll@VuEntity@@QBEMXZ				; VuEntity::Roll
PUBLIC	?LastUpdateTime@VuEntity@@QBEKXZ		; VuEntity::LastUpdateTime
PUBLIC	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ		; VuBin<VuSessionEntity>::operator bool
PUBLIC	??C?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::operator->
PUBLIC	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
PUBLIC	?RequestReliableTransmit@VuMessage@@QAEXXZ	; VuMessage::RequestReliableTransmit
PUBLIC	?RequestOutOfBandTransmit@VuMessage@@QAEXXZ	; VuMessage::RequestOutOfBandTransmit
PUBLIC	?GetDT@@YANKK@Z					; GetDT
PUBLIC	??0VuDriver@@IAE@PAVVuEntity@@@Z		; VuDriver::VuDriver
PUBLIC	??1VuDriver@@UAE@XZ				; VuDriver::~VuDriver
PUBLIC	?ResetLastUpdateTime@VuDriver@@UAEXK@Z		; VuDriver::ResetLastUpdateTime
PUBLIC	??_GVuDriver@@UAEPAXI@Z				; VuDriver::`scalar deleting destructor'
PUBLIC	??0VuDeadReckon@@QAE@PAVVuEntity@@@Z		; VuDeadReckon::VuDeadReckon
PUBLIC	??1VuDeadReckon@@UAE@XZ				; VuDeadReckon::~VuDeadReckon
PUBLIC	?NoExec@VuDeadReckon@@UAEXK@Z			; VuDeadReckon::NoExec
PUBLIC	?ExecDR@VuDeadReckon@@UAEXK@Z			; VuDeadReckon::ExecDR
PUBLIC	?Reset@VuDeadReckon@@IAEXXZ			; VuDeadReckon::Reset
PUBLIC	??_GVuDeadReckon@@UAEPAXI@Z			; VuDeadReckon::`scalar deleting destructor'
PUBLIC	??0VuDelaySlave@@QAE@PAVVuEntity@@@Z		; VuDelaySlave::VuDelaySlave
PUBLIC	??1VuDelaySlave@@UAE@XZ				; VuDelaySlave::~VuDelaySlave
PUBLIC	?Exec@VuDelaySlave@@UAEXK@Z			; VuDelaySlave::Exec
PUBLIC	?NoExec@VuDelaySlave@@UAEXK@Z			; VuDelaySlave::NoExec
PUBLIC	?Reset@VuDelaySlave@@QAEXXZ			; VuDelaySlave::Reset
PUBLIC	?Handle@VuDelaySlave@@UAEHPAVVuEvent@@@Z	; VuDelaySlave::Handle
PUBLIC	?Handle@VuDelaySlave@@UAEHPAVVuFullUpdateEvent@@@Z ; VuDelaySlave::Handle
PUBLIC	?Handle@VuDelaySlave@@UAEHPAVVuPositionUpdateEvent@@@Z ; VuDelaySlave::Handle
PUBLIC	??_GVuDelaySlave@@UAEPAXI@Z			; VuDelaySlave::`scalar deleting destructor'
PUBLIC	??0VuMaster@@QAE@PAVVuEntity@@@Z		; VuMaster::VuMaster
PUBLIC	??1VuMaster@@UAE@XZ				; VuMaster::~VuMaster
PUBLIC	?NoExec@VuMaster@@UAEXK@Z			; VuMaster::NoExec
PUBLIC	?Exec@VuMaster@@UAEXK@Z				; VuMaster::Exec
PUBLIC	?Handle@VuMaster@@UAEHPAVVuEvent@@@Z		; VuMaster::Handle
PUBLIC	?Handle@VuMaster@@UAEHPAVVuFullUpdateEvent@@@Z	; VuMaster::Handle
PUBLIC	?Handle@VuMaster@@UAEHPAVVuPositionUpdateEvent@@@Z ; VuMaster::Handle
PUBLIC	?ResetToSendIfTime@VuMaster@@CAXXZ		; VuMaster::ResetToSendIfTime
PUBLIC	?SendsPerPlayer@VuMaster@@SAIXZ			; VuMaster::SendsPerPlayer
PUBLIC	?GeneratePositionUpdate@VuMaster@@QAEH_N0KPAVVuSessionEntity@@@Z ; VuMaster::GeneratePositionUpdate
PUBLIC	??_GVuMaster@@UAEPAXI@Z				; VuMaster::`scalar deleting destructor'
PUBLIC	?SessionCount@VuGroupEntity@@QAEHXZ		; VuGroupEntity::SessionCount
PUBLIC	?MaxSends@?A0x2ad2fc6c@@YAIXZ			; `anonymous namespace'::MaxSends
PUBLIC	??$?8VVuSessionEntity@@@@YA_NPBXABV?$VuBin@VVuSessionEntity@@@@@Z ; operator==<VuSessionEntity>
PUBLIC	??$?0W4SCORE@VuMaster@@M@?$pair@W4SCORE@VuMaster@@M@std@@QAE@$$QAU01@PAPAX@Z ; std::pair<enum VuMaster::SCORE,float>::pair<enum VuMaster::SCORE,float><enum VuMaster::SCORE,float>
PUBLIC	??$forward@W4SCORE@VuMaster@@@std@@YA$$QAW4SCORE@VuMaster@@AAW412@@Z ; std::forward<enum VuMaster::SCORE>
PUBLIC	??$forward@M@std@@YA$$QAMAAM@Z			; std::forward<float>
PUBLIC	??_7VuDriver@@6B@				; VuDriver::`vftable'
PUBLIC	??_7VuDeadReckon@@6B@				; VuDeadReckon::`vftable'
PUBLIC	??_7VuDelaySlave@@6B@				; VuDelaySlave::`vftable'
PUBLIC	??_7VuMaster@@6B@				; VuMaster::`vftable'
PUBLIC	??_R4VuDriver@@6B@				; VuDriver::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVVuDriver@@@8				; VuDriver `RTTI Type Descriptor'
PUBLIC	??_R3VuDriver@@8				; VuDriver::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2VuDriver@@8				; VuDriver::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@VuDriver@@8			; VuDriver::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4VuDeadReckon@@6B@				; VuDeadReckon::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVVuDeadReckon@@@8			; VuDeadReckon `RTTI Type Descriptor'
PUBLIC	??_R3VuDeadReckon@@8				; VuDeadReckon::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2VuDeadReckon@@8				; VuDeadReckon::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@VuDeadReckon@@8			; VuDeadReckon::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4VuMaster@@6B@				; VuMaster::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVVuMaster@@@8				; VuMaster `RTTI Type Descriptor'
PUBLIC	??_R3VuMaster@@8				; VuMaster::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2VuMaster@@8				; VuMaster::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@VuMaster@@8			; VuMaster::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4VuDelaySlave@@6B@				; VuDelaySlave::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVVuDelaySlave@@@8			; VuDelaySlave `RTTI Type Descriptor'
PUBLIC	??_R3VuDelaySlave@@8				; VuDelaySlave::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2VuDelaySlave@@8				; VuDelaySlave::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@VuDelaySlave@@8			; VuDelaySlave::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
PUBLIC	__real@3a83126f
PUBLIC	__real@40490fdb
PUBLIC	__real@40c90fdb
PUBLIC	__real@c0490fdb
PUBLIC	__xmm@41f00000000000000000000000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	?SetPosition@VuEntity@@QAEXMMM@Z:PROC		; VuEntity::SetPosition
EXTRN	?SetDelta@VuEntity@@QAEXMMM@Z:PROC		; VuEntity::SetDelta
EXTRN	??0VuPositionUpdateEvent@@QAE@PAVVuEntity@@PAVVuTargetEntity@@E@Z:PROC ; VuPositionUpdateEvent::VuPositionUpdateEvent
EXTRN	??_EVuDriver@@UAEPAXI@Z:PROC			; VuDriver::`vector deleting destructor'
EXTRN	??_EVuDeadReckon@@UAEPAXI@Z:PROC		; VuDeadReckon::`vector deleting destructor'
EXTRN	??_EVuDelaySlave@@UAEPAXI@Z:PROC		; VuDelaySlave::`vector deleting destructor'
EXTRN	??_EVuMaster@@UAEPAXI@Z:PROC			; VuMaster::`vector deleting destructor'
EXTRN	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ:PROC ; VuSessionEntity::Game
EXTRN	?EnqueuePositionUpdate@VuSessionEntity@@QAEXMPAVVuEntity@@@Z:PROC ; VuSessionEntity::EnqueuePositionUpdate
EXTRN	?EnqueueOobPositionUpdate@VuSessionEntity@@QAEXPAVVuEntity@@@Z:PROC ; VuSessionEntity::EnqueueOobPositionUpdate
EXTRN	?PostVuMessage@VuMessageQueue@@SAHPAVVuMessage@@@Z:PROC ; VuMessageQueue::PostVuMessage
EXTRN	??0VuSessionsIterator@@QAE@PAVVuGroupEntity@@@Z:PROC ; VuSessionsIterator::VuSessionsIterator
EXTRN	??1VuSessionsIterator@@UAE@XZ:PROC		; VuSessionsIterator::~VuSessionsIterator
EXTRN	?GetFirst@VuSessionsIterator@@QAEPAVVuSessionEntity@@XZ:PROC ; VuSessionsIterator::GetFirst
EXTRN	?GetNext@VuSessionsIterator@@QAEPAVVuSessionEntity@@XZ:PROC ; VuSessionsIterator::GetNext
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A:DWORD ; vuLocalSessionEntity
EXTRN	?vuLocalSession@@3VVU_ID@@A:QWORD		; vuLocalSession
EXTRN	?vuxGameTime@@3KA:DWORD				; vuxGameTime
EXTRN	?vuxRealTime@@3KA:DWORD				; vuxRealTime
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@c0490fdb
CONST	SEGMENT
__real@c0490fdb DD 0c0490fdbr			; -3.14159
CONST	ENDS
;	COMDAT __real@40c90fdb
CONST	SEGMENT
__real@40c90fdb DD 040c90fdbr			; 6.28319
CONST	ENDS
;	COMDAT __real@40490fdb
CONST	SEGMENT
__real@40490fdb DD 040490fdbr			; 3.14159
CONST	ENDS
;	COMDAT __real@3a83126f
CONST	SEGMENT
__real@3a83126f DD 03a83126fr			; 0.001
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@VuDelaySlave@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@VuDelaySlave@@8 DD FLAT:??_R0?AVVuDelaySlave@@@8 ; VuDelaySlave::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3VuDelaySlave@@8
rdata$r	ENDS
;	COMDAT ??_R2VuDelaySlave@@8
rdata$r	SEGMENT
??_R2VuDelaySlave@@8 DD FLAT:??_R1A@?0A@EA@VuDelaySlave@@8 ; VuDelaySlave::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@VuDeadReckon@@8
	DD	FLAT:??_R1A@?0A@EA@VuDriver@@8
rdata$r	ENDS
;	COMDAT ??_R3VuDelaySlave@@8
rdata$r	SEGMENT
??_R3VuDelaySlave@@8 DD 00H				; VuDelaySlave::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2VuDelaySlave@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVVuDelaySlave@@@8
_DATA	SEGMENT
??_R0?AVVuDelaySlave@@@8 DD FLAT:??_7type_info@@6B@	; VuDelaySlave `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVVuDelaySlave@@', 00H
_DATA	ENDS
;	COMDAT ??_R4VuDelaySlave@@6B@
rdata$r	SEGMENT
??_R4VuDelaySlave@@6B@ DD 00H				; VuDelaySlave::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVVuDelaySlave@@@8
	DD	FLAT:??_R3VuDelaySlave@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@VuMaster@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@VuMaster@@8 DD FLAT:??_R0?AVVuMaster@@@8	; VuMaster::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3VuMaster@@8
rdata$r	ENDS
;	COMDAT ??_R2VuMaster@@8
rdata$r	SEGMENT
??_R2VuMaster@@8 DD FLAT:??_R1A@?0A@EA@VuMaster@@8	; VuMaster::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@VuDeadReckon@@8
	DD	FLAT:??_R1A@?0A@EA@VuDriver@@8
rdata$r	ENDS
;	COMDAT ??_R3VuMaster@@8
rdata$r	SEGMENT
??_R3VuMaster@@8 DD 00H					; VuMaster::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2VuMaster@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVVuMaster@@@8
_DATA	SEGMENT
??_R0?AVVuMaster@@@8 DD FLAT:??_7type_info@@6B@		; VuMaster `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVVuMaster@@', 00H
_DATA	ENDS
;	COMDAT ??_R4VuMaster@@6B@
rdata$r	SEGMENT
??_R4VuMaster@@6B@ DD 00H				; VuMaster::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVVuMaster@@@8
	DD	FLAT:??_R3VuMaster@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@VuDeadReckon@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@VuDeadReckon@@8 DD FLAT:??_R0?AVVuDeadReckon@@@8 ; VuDeadReckon::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3VuDeadReckon@@8
rdata$r	ENDS
;	COMDAT ??_R2VuDeadReckon@@8
rdata$r	SEGMENT
??_R2VuDeadReckon@@8 DD FLAT:??_R1A@?0A@EA@VuDeadReckon@@8 ; VuDeadReckon::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@VuDriver@@8
rdata$r	ENDS
;	COMDAT ??_R3VuDeadReckon@@8
rdata$r	SEGMENT
??_R3VuDeadReckon@@8 DD 00H				; VuDeadReckon::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2VuDeadReckon@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVVuDeadReckon@@@8
_DATA	SEGMENT
??_R0?AVVuDeadReckon@@@8 DD FLAT:??_7type_info@@6B@	; VuDeadReckon `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVVuDeadReckon@@', 00H
_DATA	ENDS
;	COMDAT ??_R4VuDeadReckon@@6B@
rdata$r	SEGMENT
??_R4VuDeadReckon@@6B@ DD 00H				; VuDeadReckon::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVVuDeadReckon@@@8
	DD	FLAT:??_R3VuDeadReckon@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@VuDriver@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@VuDriver@@8 DD FLAT:??_R0?AVVuDriver@@@8	; VuDriver::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3VuDriver@@8
rdata$r	ENDS
;	COMDAT ??_R2VuDriver@@8
rdata$r	SEGMENT
??_R2VuDriver@@8 DD FLAT:??_R1A@?0A@EA@VuDriver@@8	; VuDriver::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3VuDriver@@8
rdata$r	SEGMENT
??_R3VuDriver@@8 DD 00H					; VuDriver::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2VuDriver@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVVuDriver@@@8
_DATA	SEGMENT
??_R0?AVVuDriver@@@8 DD FLAT:??_7type_info@@6B@		; VuDriver `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVVuDriver@@', 00H
_DATA	ENDS
;	COMDAT ??_R4VuDriver@@6B@
rdata$r	SEGMENT
??_R4VuDriver@@6B@ DD 00H				; VuDriver::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVVuDriver@@@8
	DD	FLAT:??_R3VuDriver@@8
rdata$r	ENDS
;	COMDAT ??_7VuMaster@@6B@
CONST	SEGMENT
??_7VuMaster@@6B@ DD FLAT:??_R4VuMaster@@6B@		; VuMaster::`vftable'
	DD	FLAT:??_EVuMaster@@UAEPAXI@Z
	DD	FLAT:?NoExec@VuMaster@@UAEXK@Z
	DD	FLAT:?Exec@VuMaster@@UAEXK@Z
	DD	FLAT:?Handle@VuMaster@@UAEHPAVVuPositionUpdateEvent@@@Z
	DD	FLAT:?Handle@VuMaster@@UAEHPAVVuFullUpdateEvent@@@Z
	DD	FLAT:?Handle@VuMaster@@UAEHPAVVuEvent@@@Z
	DD	FLAT:?ResetLastUpdateTime@VuDriver@@UAEXK@Z
	DD	FLAT:?ExecDR@VuDeadReckon@@UAEXK@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_7VuDelaySlave@@6B@
CONST	SEGMENT
??_7VuDelaySlave@@6B@ DD FLAT:??_R4VuDelaySlave@@6B@	; VuDelaySlave::`vftable'
	DD	FLAT:??_EVuDelaySlave@@UAEPAXI@Z
	DD	FLAT:?NoExec@VuDelaySlave@@UAEXK@Z
	DD	FLAT:?Exec@VuDelaySlave@@UAEXK@Z
	DD	FLAT:?Handle@VuDelaySlave@@UAEHPAVVuPositionUpdateEvent@@@Z
	DD	FLAT:?Handle@VuDelaySlave@@UAEHPAVVuFullUpdateEvent@@@Z
	DD	FLAT:?Handle@VuDelaySlave@@UAEHPAVVuEvent@@@Z
	DD	FLAT:?ResetLastUpdateTime@VuDriver@@UAEXK@Z
	DD	FLAT:?ExecDR@VuDeadReckon@@UAEXK@Z
CONST	ENDS
;	COMDAT ??_7VuDeadReckon@@6B@
CONST	SEGMENT
??_7VuDeadReckon@@6B@ DD FLAT:??_R4VuDeadReckon@@6B@	; VuDeadReckon::`vftable'
	DD	FLAT:??_EVuDeadReckon@@UAEPAXI@Z
	DD	FLAT:?NoExec@VuDeadReckon@@UAEXK@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?ResetLastUpdateTime@VuDriver@@UAEXK@Z
	DD	FLAT:?ExecDR@VuDeadReckon@@UAEXK@Z
CONST	ENDS
;	COMDAT ??_7VuDriver@@6B@
CONST	SEGMENT
??_7VuDriver@@6B@ DD FLAT:??_R4VuDriver@@6B@		; VuDriver::`vftable'
	DD	FLAT:??_EVuDriver@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?ResetLastUpdateTime@VuDriver@@UAEXK@Z
CONST	ENDS
xdata$x	SEGMENT
__unwindtable$?GeneratePositionUpdate@VuMaster@@QAEH_N0KPAVVuSessionEntity@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GeneratePositionUpdate@VuMaster@@QAEH_N0KPAVVuSessionEntity@@@Z$0
__unwindtable$?Exec@VuMaster@@UAEXK@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Exec@VuMaster@@UAEXK@Z$0
__unwindtable$??0VuMaster@@QAE@PAVVuEntity@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0VuMaster@@QAE@PAVVuEntity@@@Z$0
__unwindtable$??0VuDelaySlave@@QAE@PAVVuEntity@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0VuDelaySlave@@QAE@PAVVuEntity@@@Z$0
__unwindtable$??0VuDeadReckon@@QAE@PAVVuEntity@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0VuDeadReckon@@QAE@PAVVuEntity@@@Z$0
__ehfuncinfo$?GeneratePositionUpdate@VuMaster@@QAEH_N0KPAVVuSessionEntity@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GeneratePositionUpdate@VuMaster@@QAEH_N0KPAVVuSessionEntity@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?Exec@VuMaster@@UAEXK@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Exec@VuMaster@@UAEXK@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??0VuMaster@@QAE@PAVVuEntity@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0VuMaster@@QAE@PAVVuEntity@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??0VuDelaySlave@@QAE@PAVVuEntity@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0VuDelaySlave@@QAE@PAVVuEntity@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??0VuDeadReckon@@QAE@PAVVuEntity@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0VuDeadReckon@@QAE@PAVVuEntity@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@M@std@@YA$$QAMAAM@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@M@std@@YA$$QAMAAM@Z PROC			; std::forward<float>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	ebp
	ret	0
??$forward@M@std@@YA$$QAMAAM@Z ENDP			; std::forward<float>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@W4SCORE@VuMaster@@@std@@YA$$QAW4SCORE@VuMaster@@AAW412@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@W4SCORE@VuMaster@@@std@@YA$$QAW4SCORE@VuMaster@@AAW412@@Z PROC ; std::forward<enum VuMaster::SCORE>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	ebp
	ret	0
??$forward@W4SCORE@VuMaster@@@std@@YA$$QAW4SCORE@VuMaster@@AAW412@@Z ENDP ; std::forward<enum VuMaster::SCORE>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??$?0W4SCORE@VuMaster@@M@?$pair@W4SCORE@VuMaster@@M@std@@QAE@$$QAU01@PAPAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?0W4SCORE@VuMaster@@M@?$pair@W4SCORE@VuMaster@@M@std@@QAE@$$QAU01@PAPAX@Z PROC ; std::pair<enum VuMaster::SCORE,float>::pair<enum VuMaster::SCORE,float><enum VuMaster::SCORE,float>, COMDAT
; _this$ = ecx

; 182  : 		{	// construct from moved compatible pair

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	call	??$forward@W4SCORE@VuMaster@@@std@@YA$$QAW4SCORE@VuMaster@@AAW412@@Z ; std::forward<enum VuMaster::SCORE>
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 4
	push	eax
	call	??$forward@M@std@@YA$$QAMAAM@Z		; std::forward<float>
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], edx

; 183  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??$?0W4SCORE@VuMaster@@M@?$pair@W4SCORE@VuMaster@@M@std@@QAE@$$QAU01@PAPAX@Z ENDP ; std::pair<enum VuMaster::SCORE,float>::pair<enum VuMaster::SCORE,float><enum VuMaster::SCORE,float>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??$?8VVuSessionEntity@@@@YA_NPBXABV?$VuBin@VVuSessionEntity@@@@@Z
_TEXT	SEGMENT
tv67 = -4						; size = 4
_le$ = 8						; size = 4
_re$ = 12						; size = 4
??$?8VVuSessionEntity@@@@YA_NPBXABV?$VuBin@VVuSessionEntity@@@@@Z PROC ; operator==<VuSessionEntity>, COMDAT

; 72   : template <class E> bool operator==(const void* le, const VuBin<E> &re){ return ((void*)re.get()) == le; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	ecx, DWORD PTR _re$[ebp]
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	cmp	eax, DWORD PTR _le$[ebp]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv67[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??$?8VVuSessionEntity@@@@YA_NPBXABV?$VuBin@VVuSessionEntity@@@@@Z ENDP ; operator==<VuSessionEntity>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\src\vudriver.cpp
_TEXT	SEGMENT
$T1 = -20						; size = 8
tv145 = -12						; size = 4
tv128 = -8						; size = 4
tv75 = -4						; size = 4
?MaxSends@?A0x2ad2fc6c@@YAIXZ PROC			; `anonymous namespace'::MaxSends

; 227  : 	unsigned int MaxSends(){

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 228  : 		if (vuLocalGame->OwnerId() == vuLocalSession){

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN5@MaxSends
	mov	DWORD PTR tv75[ebp], 0
	jmp	SHORT $LN6@MaxSends
$LN5@MaxSends:
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??C?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::operator->
	mov	ecx, eax
	call	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ ; VuSessionEntity::Game
	mov	DWORD PTR tv75[ebp], eax
$LN6@MaxSends:
	push	OFFSET ?vuLocalSession@@3VVU_ID@@A	; vuLocalSession
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR tv75[ebp]
	call	?OwnerId@VuEntity@@QBE?AVVU_ID@@XZ	; VuEntity::OwnerId
	mov	ecx, eax
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@MaxSends

; 229  : 			return MAX_SERVER_SENDS_PER_UPDATE*(vuLocalGame->SessionCount()-1);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN7@MaxSends
	mov	DWORD PTR tv128[ebp], 0
	jmp	SHORT $LN8@MaxSends
$LN7@MaxSends:
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??C?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::operator->
	mov	ecx, eax
	call	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ ; VuSessionEntity::Game
	mov	DWORD PTR tv128[ebp], eax
$LN8@MaxSends:
	mov	ecx, DWORD PTR tv128[ebp]
	call	?SessionCount@VuGroupEntity@@QAEHXZ	; VuGroupEntity::SessionCount
	sub	eax, 1
	imul	eax, 40					; 00000028H
	jmp	SHORT $LN3@MaxSends

; 230  : 		}
; 231  : 		else {

	jmp	SHORT $LN3@MaxSends
$LN2@MaxSends:

; 232  : 			return MAX_CLIENT_SENDS_PER_UPDATE*(vuLocalGame->SessionCount()-1);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN9@MaxSends
	mov	DWORD PTR tv145[ebp], 0
	jmp	SHORT $LN10@MaxSends
$LN9@MaxSends:
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??C?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::operator->
	mov	ecx, eax
	call	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ ; VuSessionEntity::Game
	mov	DWORD PTR tv145[ebp], eax
$LN10@MaxSends:
	mov	ecx, DWORD PTR tv145[ebp]
	call	?SessionCount@VuGroupEntity@@QAEHXZ	; VuGroupEntity::SessionCount
	sub	eax, 1
	imul	eax, 5
$LN3@MaxSends:

; 233  : 		}	
; 234  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?MaxSends@?A0x2ad2fc6c@@YAIXZ ENDP			; `anonymous namespace'::MaxSends
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vusessn.h
;	COMDAT ?SessionCount@VuGroupEntity@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SessionCount@VuGroupEntity@@QAEHXZ PROC		; VuGroupEntity::SessionCount, COMDAT
; _this$ = ecx

; 341  : 	int SessionCount()    { return sessionCollection_->Count(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+336]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+336]
	mov	edx, DWORD PTR [eax+4]
	call	edx
	mov	esp, ebp
	pop	ebp
	ret	0
?SessionCount@VuGroupEntity@@QAEHXZ ENDP		; VuGroupEntity::SessionCount
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GVuMaster@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GVuMaster@@UAEPAXI@Z PROC				; VuMaster::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1VuMaster@@UAE@XZ			; VuMaster::~VuMaster
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GVuMaster@@UAEPAXI@Z ENDP				; VuMaster::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\src\vudriver.cpp
_TEXT	SEGMENT
$T2 = -32						; size = 4
tv83 = -28						; size = 4
$T3 = -24						; size = 4
_event$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_reliable$ = 8						; size = 1
_oob$ = 12						; size = 1
_time$ = 16						; size = 4
_target$ = 20						; size = 4
?GeneratePositionUpdate@VuMaster@@QAEH_N0KPAVVuSessionEntity@@@Z PROC ; VuMaster::GeneratePositionUpdate
; _this$ = ecx

; 269  : VU_ERRCODE VuMaster::GeneratePositionUpdate(bool reliable, bool oob, VU_TIME time, VuSessionEntity *target){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GeneratePositionUpdate@VuMaster@@QAEH_N0KPAVVuSessionEntity@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 270  : 	// send message
; 271  : 	VuPositionUpdateEvent *event = new VuPositionUpdateEvent(entity_, target);

	push	93					; 0000005dH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN6@GeneratePo
	push	0
	mov	eax, DWORD PTR _target$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0VuPositionUpdateEvent@@QAE@PAVVuEntity@@PAVVuTargetEntity@@E@Z ; VuPositionUpdateEvent::VuPositionUpdateEvent
	mov	DWORD PTR tv83[ebp], eax
	jmp	SHORT $LN7@GeneratePo
$LN6@GeneratePo:
	mov	DWORD PTR tv83[ebp], 0
$LN7@GeneratePo:
	mov	eax, DWORD PTR tv83[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR _event$[ebp], ecx

; 272  : 	if (reliable){

	movzx	edx, BYTE PTR _reliable$[ebp]
	test	edx, edx
	je	SHORT $LN3@GeneratePo

; 273  : 		event->RequestReliableTransmit();

	mov	ecx, DWORD PTR _event$[ebp]
	call	?RequestReliableTransmit@VuMessage@@QAEXXZ ; VuMessage::RequestReliableTransmit
$LN3@GeneratePo:

; 274  : 	}
; 275  : 	if (oob){

	movzx	eax, BYTE PTR _oob$[ebp]
	test	eax, eax
	je	SHORT $LN2@GeneratePo

; 276  : 		event->RequestOutOfBandTransmit();

	mov	ecx, DWORD PTR _event$[ebp]
	call	?RequestOutOfBandTransmit@VuMessage@@QAEXXZ ; VuMessage::RequestOutOfBandTransmit
$LN2@GeneratePo:

; 277  : 	}
; 278  : 	if (VuMessageQueue::PostVuMessage(event) <= 0) {

	mov	ecx, DWORD PTR _event$[ebp]
	push	ecx
	call	?PostVuMessage@VuMessageQueue@@SAHPAVVuMessage@@@Z ; VuMessageQueue::PostVuMessage
	add	esp, 4
	test	eax, eax
	jg	SHORT $LN1@GeneratePo

; 279  : 		return VU_ERROR; // send failed

	or	eax, -1
	jmp	SHORT $LN4@GeneratePo
$LN1@GeneratePo:

; 280  : 	}
; 281  : 	// update sent
; 282  : 	xsent_ = entity_->XPos();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+64]

; 283  : 	ysent_ = entity_->YPos();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+68]

; 284  : 	zsent_ = entity_->ZPos();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+72]

; 285  : 	yawsent_ = entity_->Yaw();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+88]

; 286  : 	pitchsent_ = entity_->Pitch();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	call	?Pitch@VuEntity@@QBEMXZ			; VuEntity::Pitch
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+92]

; 287  : 	rollsent_ = entity_->Roll();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	call	?Roll@VuEntity@@QBEMXZ			; VuEntity::Roll
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+96]

; 288  : 	updateSentRealTime_ = vuxRealTime;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ?vuxRealTime@@3KA	; vuxRealTime
	mov	DWORD PTR [edx+60], eax

; 289  : 	return VU_SUCCESS;

	mov	eax, 1
$LN4@GeneratePo:

; 290  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?GeneratePositionUpdate@VuMaster@@QAEH_N0KPAVVuSessionEntity@@@Z$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?GeneratePositionUpdate@VuMaster@@QAEH_N0KPAVVuSessionEntity@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GeneratePositionUpdate@VuMaster@@QAEH_N0KPAVVuSessionEntity@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GeneratePositionUpdate@VuMaster@@QAEH_N0KPAVVuSessionEntity@@@Z ENDP ; VuMaster::GeneratePositionUpdate
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\src\vudriver.cpp
_TEXT	SEGMENT
tv79 = -8						; size = 4
_otherPlayers$ = -4					; size = 4
?SendsPerPlayer@VuMaster@@SAIXZ PROC			; VuMaster::SendsPerPlayer

; 247  : unsigned int VuMaster::SendsPerPlayer(){

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 248  : 	int otherPlayers = vuLocalSessionEntity->Game()->SessionCount() - 1;

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??C?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::operator->
	mov	ecx, eax
	call	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ ; VuSessionEntity::Game
	mov	ecx, eax
	call	?SessionCount@VuGroupEntity@@QAEHXZ	; VuGroupEntity::SessionCount
	sub	eax, 1
	mov	DWORD PTR _otherPlayers$[ebp], eax

; 249  : 	// avoids division by zero
; 250  : 	return ((otherPlayers > 0) && (toSend > 0)) ? (MaxSends() / otherPlayers) : 0;

	cmp	DWORD PTR _otherPlayers$[ebp], 0
	jle	SHORT $LN3@SendsPerPl
	cmp	DWORD PTR ?toSend@VuMaster@@0HA, 0	; VuMaster::toSend
	jle	SHORT $LN3@SendsPerPl
	call	?MaxSends@?A0x2ad2fc6c@@YAIXZ		; `anonymous namespace'::MaxSends
	xor	edx, edx
	div	DWORD PTR _otherPlayers$[ebp]
	mov	DWORD PTR tv79[ebp], eax
	jmp	SHORT $LN4@SendsPerPl
$LN3@SendsPerPl:
	mov	DWORD PTR tv79[ebp], 0
$LN4@SendsPerPl:
	mov	eax, DWORD PTR tv79[ebp]

; 251  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SendsPerPlayer@VuMaster@@SAIXZ ENDP			; VuMaster::SendsPerPlayer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\src\vudriver.cpp
_TEXT	SEGMENT
_lastSend$ = -8						; size = 4
_now$ = -4						; size = 4
?ResetToSendIfTime@VuMaster@@CAXXZ PROC			; VuMaster::ResetToSendIfTime

; 237  : void VuMaster::ResetToSendIfTime(){

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 238  : 	VU_TIME lastSend = 0;

	mov	DWORD PTR _lastSend$[ebp], 0

; 239  : 	VU_TIME now = vuxGameTime;

	mov	eax, DWORD PTR ?vuxGameTime@@3KA	; vuxGameTime
	mov	DWORD PTR _now$[ebp], eax

; 240  : 	// every half second, renews position updates allowed
; 241  : 	if (now >= lastSend + (VU_TICS_PER_SECOND/RENEWS_PER_SECOND)){

	mov	ecx, DWORD PTR _lastSend$[ebp]
	add	ecx, 500				; 000001f4H
	cmp	DWORD PTR _now$[ebp], ecx
	jb	SHORT $LN2@ResetToSen

; 242  : 		lastSend = now;

	mov	edx, DWORD PTR _now$[ebp]
	mov	DWORD PTR _lastSend$[ebp], edx

; 243  : 		toSend = static_cast<int>(MaxSends());

	call	?MaxSends@?A0x2ad2fc6c@@YAIXZ		; `anonymous namespace'::MaxSends
	mov	DWORD PTR ?toSend@VuMaster@@0HA, eax	; VuMaster::toSend
$LN2@ResetToSen:

; 244  : 	}
; 245  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ResetToSendIfTime@VuMaster@@CAXXZ ENDP			; VuMaster::ResetToSendIfTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vudriver.h
;	COMDAT ?Handle@VuMaster@@UAEHPAVVuPositionUpdateEvent@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_event$ = 8						; size = 4
?Handle@VuMaster@@UAEHPAVVuPositionUpdateEvent@@@Z PROC	; VuMaster::Handle, COMDAT
; _this$ = ecx

; 156  : 	virtual VU_ERRCODE Handle(VuPositionUpdateEvent *event){ return VU_NO_OP; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	4
?Handle@VuMaster@@UAEHPAVVuPositionUpdateEvent@@@Z ENDP	; VuMaster::Handle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vudriver.h
;	COMDAT ?Handle@VuMaster@@UAEHPAVVuFullUpdateEvent@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_event$ = 8						; size = 4
?Handle@VuMaster@@UAEHPAVVuFullUpdateEvent@@@Z PROC	; VuMaster::Handle, COMDAT
; _this$ = ecx

; 155  : 	virtual VU_ERRCODE Handle(VuFullUpdateEvent *event){ return VU_NO_OP; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	4
?Handle@VuMaster@@UAEHPAVVuFullUpdateEvent@@@Z ENDP	; VuMaster::Handle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vudriver.h
;	COMDAT ?Handle@VuMaster@@UAEHPAVVuEvent@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_event$ = 8						; size = 4
?Handle@VuMaster@@UAEHPAVVuEvent@@@Z PROC		; VuMaster::Handle, COMDAT
; _this$ = ecx

; 154  : 	virtual VU_ERRCODE Handle(VuEvent *event){ return VU_NO_OP; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	4
?Handle@VuMaster@@UAEHPAVVuEvent@@@Z ENDP		; VuMaster::Handle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\src\vudriver.cpp
_TEXT	SEGMENT
_iter$ = -56						; size = 12
$T2 = -44						; size = 8
_score$3 = -36						; size = 8
_timeDelta$ = -28					; size = 4
tv134 = -24						; size = 4
_s$4 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_timestamp$ = 8						; size = 4
?Exec@VuMaster@@UAEXK@Z PROC				; VuMaster::Exec
; _this$ = ecx

; 303  : void VuMaster::Exec(VU_TIME timestamp){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Exec@VuMaster@@UAEXK@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 44					; 0000002cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 304  : 	ResetToSendIfTime();

	call	?ResetToSendIfTime@VuMaster@@CAXXZ	; VuMaster::ResetToSendIfTime

; 305  : 
; 306  : 	// exec model, if fails, exec DR
; 307  : 	if (!ExecModel(timestamp)){

	mov	eax, DWORD PTR _timestamp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN8@Exec

; 308  : 		ExecDR(timestamp);

	mov	edx, DWORD PTR _timestamp$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	call	eax
$LN8@Exec:

; 309  : 	}
; 310  : 
; 311  : 	// unit updated
; 312  : 	ResetLastUpdateTime(timestamp);

	mov	ecx, DWORD PTR _timestamp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+24]
	call	edx

; 313  : 
; 314  : 	//bool sent = false;
; 315  : 	VU_TIME timeDelta = vuxRealTime - updateSentRealTime_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?vuxRealTime@@3KA	; vuxRealTime
	sub	ecx, DWORD PTR [eax+60]
	mov	DWORD PTR _timeDelta$[ebp], ecx

; 316  : 	VuSessionsIterator iter(vuLocalGame);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN11@Exec
	mov	DWORD PTR tv134[ebp], 0
	jmp	SHORT $LN12@Exec
$LN11@Exec:
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??C?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::operator->
	mov	ecx, eax
	call	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ ; VuSessionEntity::Game
	mov	DWORD PTR tv134[ebp], eax
$LN12@Exec:
	mov	eax, DWORD PTR tv134[ebp]
	push	eax
	lea	ecx, DWORD PTR _iter$[ebp]
	call	??0VuSessionsIterator@@QAE@PAVVuGroupEntity@@@Z ; VuSessionsIterator::VuSessionsIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 317  : 	for (VuSessionEntity *s=iter.GetFirst();s!=NULL;s=iter.GetNext()){

	lea	ecx, DWORD PTR _iter$[ebp]
	call	?GetFirst@VuSessionsIterator@@QAEPAVVuSessionEntity@@XZ ; VuSessionsIterator::GetFirst
	mov	DWORD PTR _s$4[ebp], eax
	jmp	SHORT $LN7@Exec
$LN6@Exec:
	lea	ecx, DWORD PTR _iter$[ebp]
	call	?GetNext@VuSessionsIterator@@QAEPAVVuSessionEntity@@XZ ; VuSessionsIterator::GetNext
	mov	DWORD PTR _s$4[ebp], eax
$LN7@Exec:
	cmp	DWORD PTR _s$4[ebp], 0
	je	$LN5@Exec

; 318  : 		// dont send to ourselves!
; 319  : 		if (s == vuLocalSessionEntity){

	push	OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	mov	ecx, DWORD PTR _s$4[ebp]
	push	ecx
	call	??$?8VVuSessionEntity@@@@YA_NPBXABV?$VuBin@VVuSessionEntity@@@@@Z ; operator==<VuSessionEntity>
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN4@Exec

; 320  : 			continue;

	jmp	SHORT $LN6@Exec
$LN4@Exec:

; 321  : 		}
; 322  : 		// check if we should send position to this session
; 323  : 		SEND_SCORE score = SendScore(s, timeDelta);

	push	0
	mov	eax, DWORD PTR _timeDelta$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$4[ebp]
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	call	eax
	push	eax
	lea	ecx, DWORD PTR _score$3[ebp]
	call	??$?0W4SCORE@VuMaster@@M@?$pair@W4SCORE@VuMaster@@M@std@@QAE@$$QAU01@PAPAX@Z ; std::pair<enum VuMaster::SCORE,float>::pair<enum VuMaster::SCORE,float><enum VuMaster::SCORE,float>

; 324  : 		if (score.first >= SEND_OOB){

	cmp	DWORD PTR _score$3[ebp], 2
	jl	SHORT $LN3@Exec

; 325  : 			s->EnqueueOobPositionUpdate(entity_);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _s$4[ebp]
	call	?EnqueueOobPositionUpdate@VuSessionEntity@@QAEXPAVVuEntity@@@Z ; VuSessionEntity::EnqueueOobPositionUpdate

; 326  : 			--toSend;

	mov	eax, DWORD PTR ?toSend@VuMaster@@0HA	; VuMaster::toSend
	sub	eax, 1
	mov	DWORD PTR ?toSend@VuMaster@@0HA, eax	; VuMaster::toSend
	jmp	SHORT $LN1@Exec
$LN3@Exec:

; 327  : 		}
; 328  : 		else if ((score.first == ENQUEUE_SEND) && (toSend > 0)){

	cmp	DWORD PTR _score$3[ebp], 1
	jne	SHORT $LN1@Exec
	cmp	DWORD PTR ?toSend@VuMaster@@0HA, 0	; VuMaster::toSend
	jle	SHORT $LN1@Exec

; 329  : 			// enqeue send, dont decrement to sent (will be done during enqueued sends)
; 330  : 			// do this to optimize enqueued PU (they wont be sent if OOB)
; 331  : 			s->EnqueuePositionUpdate(score.second, entity_);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _score$3[ebp+4]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _s$4[ebp]
	call	?EnqueuePositionUpdate@VuSessionEntity@@QAEXMPAVVuEntity@@@Z ; VuSessionEntity::EnqueuePositionUpdate
$LN1@Exec:

; 332  : 		}
; 333  : 	}

	jmp	$LN6@Exec
$LN5@Exec:

; 334  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _iter$[ebp]
	call	??1VuSessionsIterator@@UAE@XZ		; VuSessionsIterator::~VuSessionsIterator
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?Exec@VuMaster@@UAEXK@Z$0:
	lea	ecx, DWORD PTR _iter$[ebp]
	jmp	??1VuSessionsIterator@@UAE@XZ		; VuSessionsIterator::~VuSessionsIterator
__ehhandler$?Exec@VuMaster@@UAEXK@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-48]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Exec@VuMaster@@UAEXK@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Exec@VuMaster@@UAEXK@Z ENDP				; VuMaster::Exec
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vudriver.h
;	COMDAT ?NoExec@VuMaster@@UAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_timestamp$ = 8						; size = 4
?NoExec@VuMaster@@UAEXK@Z PROC				; VuMaster::NoExec, COMDAT
; _this$ = ecx

; 144  : 	virtual void NoExec(VU_TIME timestamp){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?NoExec@VuMaster@@UAEXK@Z ENDP				; VuMaster::NoExec
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\src\vudriver.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1VuMaster@@UAE@XZ PROC				; VuMaster::~VuMaster
; _this$ = ecx

; 266  : VuMaster::~VuMaster(){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7VuMaster@@6B@

; 267  : }

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1VuDeadReckon@@UAE@XZ			; VuDeadReckon::~VuDeadReckon
	mov	esp, ebp
	pop	ebp
	ret	0
??1VuMaster@@UAE@XZ ENDP				; VuMaster::~VuMaster
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\src\vudriver.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_entity$ = 8						; size = 4
??0VuMaster@@QAE@PAVVuEntity@@@Z PROC			; VuMaster::VuMaster
; _this$ = ecx

; 253  : VuMaster::VuMaster(VuEntity* entity) : VuDeadReckon(entity){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0VuMaster@@QAE@PAVVuEntity@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _entity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0VuDeadReckon@@QAE@PAVVuEntity@@@Z	; VuDeadReckon::VuDeadReckon
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7VuMaster@@6B@

; 254  : 	updateSentRealTime_ = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+60], 0

; 255  : 	xsent_ = entity_->XPos();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+64]

; 256  : 	ysent_ = entity_->YPos();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+68]

; 257  : 	zsent_ = entity_->ZPos();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+72]

; 258  : 	dxsent_ = entity->XDelta();

	mov	ecx, DWORD PTR _entity$[ebp]
	call	?XDelta@VuEntity@@QBEMXZ		; VuEntity::XDelta
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+76]

; 259  : 	dxsent_ = entity->YDelta();

	mov	ecx, DWORD PTR _entity$[ebp]
	call	?YDelta@VuEntity@@QBEMXZ		; VuEntity::YDelta
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+76]

; 260  : 	dxsent_ = entity->ZDelta();

	mov	ecx, DWORD PTR _entity$[ebp]
	call	?ZDelta@VuEntity@@QBEMXZ		; VuEntity::ZDelta
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+76]

; 261  : 	yawsent_ = entity_->Yaw();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+88]

; 262  : 	pitchsent_ = entity_->Pitch();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	call	?Pitch@VuEntity@@QBEMXZ			; VuEntity::Pitch
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+92]

; 263  : 	rollsent_ = entity_->Roll();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	call	?Roll@VuEntity@@QBEMXZ			; VuEntity::Roll
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+96]

; 264  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0VuMaster@@QAE@PAVVuEntity@@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1VuDeadReckon@@UAE@XZ			; VuDeadReckon::~VuDeadReckon
__ehhandler$??0VuMaster@@QAE@PAVVuEntity@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0VuMaster@@QAE@PAVVuEntity@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0VuMaster@@QAE@PAVVuEntity@@@Z ENDP			; VuMaster::VuMaster
; Function compile flags: /Odtp
;	COMDAT ??_GVuDelaySlave@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GVuDelaySlave@@UAEPAXI@Z PROC			; VuDelaySlave::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1VuDelaySlave@@UAE@XZ			; VuDelaySlave::~VuDelaySlave
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GVuDelaySlave@@UAEPAXI@Z ENDP			; VuDelaySlave::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\src\vudriver.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_event$ = 8						; size = 4
?Handle@VuDelaySlave@@UAEHPAVVuPositionUpdateEvent@@@Z PROC ; VuDelaySlave::Handle
; _this$ = ecx

; 203  : VU_ERRCODE VuDelaySlave::Handle(VuPositionUpdateEvent* event){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 	// here we just set position
; 205  : 	// only accept events newer than last update
; 206  : 	if (event->updateTime_ < lastRemoteUpdateTime_){

	mov	eax, DWORD PTR _event$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+44]
	cmp	edx, DWORD PTR [ecx+60]
	jae	SHORT $LN1@Handle

; 207  : 		return VU_NO_OP;

	xor	eax, eax
	jmp	$LN2@Handle
$LN1@Handle:

; 208  : 	}
; 209  : 
; 210  : 	// we do not receive any dYPR data
; 211  : 	entity_->SetPosition(event->x_, event->y_, event->z_);

	mov	eax, DWORD PTR _event$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+71]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _event$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+67]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _event$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+63]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	call	?SetPosition@VuEntity@@QAEXMMM@Z	; VuEntity::SetPosition

; 212  : 	entity_->SetDelta(event->dx_, event->dy_, event->dz_);

	mov	ecx, DWORD PTR _event$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+83]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _event$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+79]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _event$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+75]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	call	?SetDelta@VuEntity@@QAEXMMM@Z		; VuEntity::SetDelta

; 213  : 	entity_->SetYPR(event->yaw_, event->pitch_, event->roll_);

	mov	edx, DWORD PTR _event$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+56]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _event$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+52]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _event$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+48]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	call	?SetYPR@VuEntity@@QAEXMMM@Z		; VuEntity::SetYPR

; 214  : 
; 215  : 	return VU_SUCCESS;

	mov	eax, 1
$LN2@Handle:

; 216  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Handle@VuDelaySlave@@UAEHPAVVuPositionUpdateEvent@@@Z ENDP ; VuDelaySlave::Handle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vudriver.h
;	COMDAT ?Handle@VuDelaySlave@@UAEHPAVVuFullUpdateEvent@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_event$ = 8						; size = 4
?Handle@VuDelaySlave@@UAEHPAVVuFullUpdateEvent@@@Z PROC	; VuDelaySlave::Handle, COMDAT
; _this$ = ecx

; 116  : 	virtual VU_ERRCODE Handle(VuFullUpdateEvent *event){ return VU_NO_OP; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	4
?Handle@VuDelaySlave@@UAEHPAVVuFullUpdateEvent@@@Z ENDP	; VuDelaySlave::Handle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vudriver.h
;	COMDAT ?Handle@VuDelaySlave@@UAEHPAVVuEvent@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_event$ = 8						; size = 4
?Handle@VuDelaySlave@@UAEHPAVVuEvent@@@Z PROC		; VuDelaySlave::Handle, COMDAT
; _this$ = ecx

; 115  : 	virtual VU_ERRCODE Handle(VuEvent *event){ return VU_NO_OP; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	4
?Handle@VuDelaySlave@@UAEHPAVVuEvent@@@Z ENDP		; VuDelaySlave::Handle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\src\vudriver.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Reset@VuDelaySlave@@QAEXXZ PROC			; VuDelaySlave::Reset
; _this$ = ecx

; 180  : void VuDelaySlave::Reset(){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 181  : 	VuDeadReckon::Reset();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Reset@VuDeadReckon@@IAEXXZ		; VuDeadReckon::Reset

; 182  : 	predictedTime_ = 0;//vuxGameTime;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+76], 0

; 183  : 	lastRemoteUpdateTime_ = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+60], 0

; 184  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Reset@VuDelaySlave@@QAEXXZ ENDP			; VuDelaySlave::Reset
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\src\vudriver.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_timestamp$ = 8						; size = 4
?NoExec@VuDelaySlave@@UAEXK@Z PROC			; VuDelaySlave::NoExec
; _this$ = ecx

; 186  : void VuDelaySlave::NoExec(VU_TIME timestamp){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 187  : 	VuDeadReckon::NoExec(timestamp);

	mov	eax, DWORD PTR _timestamp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NoExec@VuDeadReckon@@UAEXK@Z		; VuDeadReckon::NoExec

; 188  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?NoExec@VuDelaySlave@@UAEXK@Z ENDP			; VuDelaySlave::NoExec
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\src\vudriver.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_timestamp$ = 8						; size = 4
?Exec@VuDelaySlave@@UAEXK@Z PROC			; VuDelaySlave::Exec
; _this$ = ecx

; 190  : void VuDelaySlave::Exec(VU_TIME timestamp){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 191  : 	// check if prediction is recent
; 192  : 	if (predictedTime_ > timestamp){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	cmp	ecx, DWORD PTR _timestamp$[ebp]
	jbe	SHORT $LN2@Exec

; 193  : 		// speed is already set by handle, execute dead reckon
; 194  : 		ExecDR(timestamp);

	mov	edx, DWORD PTR _timestamp$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	call	eax

; 195  : 	}
; 196  : 	// our prediction is far past, this prolly means we didnt receive
; 197  : 	// an update for this units for sometime
; 198  : 	else{

	jmp	SHORT $LN3@Exec
$LN2@Exec:

; 199  : 		VuDelaySlave::NoExec(timestamp);

	mov	ecx, DWORD PTR _timestamp$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NoExec@VuDelaySlave@@UAEXK@Z		; VuDelaySlave::NoExec
$LN3@Exec:

; 200  : 	}
; 201  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Exec@VuDelaySlave@@UAEXK@Z ENDP			; VuDelaySlave::Exec
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vudriver.h
;	COMDAT ??1VuDelaySlave@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1VuDelaySlave@@UAE@XZ PROC				; VuDelaySlave::~VuDelaySlave, COMDAT
; _this$ = ecx

; 105  : 	virtual ~VuDelaySlave(){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7VuDelaySlave@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1VuDeadReckon@@UAE@XZ			; VuDeadReckon::~VuDeadReckon
	mov	esp, ebp
	pop	ebp
	ret	0
??1VuDelaySlave@@UAE@XZ ENDP				; VuDelaySlave::~VuDelaySlave
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\src\vudriver.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_entity$ = 8						; size = 4
??0VuDelaySlave@@QAE@PAVVuEntity@@@Z PROC		; VuDelaySlave::VuDelaySlave
; _this$ = ecx

; 176  : VuDelaySlave::VuDelaySlave(VuEntity *entity) : VuDeadReckon(entity){ 

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0VuDelaySlave@@QAE@PAVVuEntity@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _entity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0VuDeadReckon@@QAE@PAVVuEntity@@@Z	; VuDeadReckon::VuDeadReckon
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7VuDelaySlave@@6B@

; 177  : 	VuDelaySlave::Reset();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Reset@VuDelaySlave@@QAEXXZ		; VuDelaySlave::Reset

; 178  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0VuDelaySlave@@QAE@PAVVuEntity@@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1VuDeadReckon@@UAE@XZ			; VuDeadReckon::~VuDeadReckon
__ehhandler$??0VuDelaySlave@@QAE@PAVVuEntity@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0VuDelaySlave@@QAE@PAVVuEntity@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0VuDelaySlave@@QAE@PAVVuEntity@@@Z ENDP		; VuDelaySlave::VuDelaySlave
; Function compile flags: /Odtp
;	COMDAT ??_GVuDeadReckon@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GVuDeadReckon@@UAEPAXI@Z PROC			; VuDeadReckon::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1VuDeadReckon@@UAE@XZ			; VuDeadReckon::~VuDeadReckon
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GVuDeadReckon@@UAEPAXI@Z ENDP			; VuDeadReckon::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\src\vudriver.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Reset@VuDeadReckon@@IAEXXZ PROC			; VuDeadReckon::Reset
; _this$ = ecx

; 80   : void VuDeadReckon::Reset(){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 81   : 	// get unit position and heading
; 82   : 	d_drx_     = entity_->XDelta();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	call	?XDelta@VuEntity@@QBEMXZ		; VuEntity::XDelta
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+24]

; 83   : 	d_dry_     = entity_->YDelta();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	call	?YDelta@VuEntity@@QBEMXZ		; VuEntity::YDelta
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+28]

; 84   : 	d_drz_     = entity_->ZDelta();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	call	?ZDelta@VuEntity@@QBEMXZ		; VuEntity::ZDelta
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+32]

; 85   : 	drx_       = entity_->XPos();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+12]

; 86   : 	dry_       = entity_->YPos();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+16]

; 87   : 	drz_       = entity_->ZPos();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+20]

; 88   : 	dryaw_     = entity_->Yaw();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+36]

; 89   : 	drpitch_   = entity_->Pitch();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	call	?Pitch@VuEntity@@QBEMXZ			; VuEntity::Pitch
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+40]

; 90   : 	drroll_    = entity_->Roll();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	call	?Roll@VuEntity@@QBEMXZ			; VuEntity::Roll
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+44]

; 91   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Reset@VuDeadReckon@@IAEXXZ ENDP			; VuDeadReckon::Reset
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\src\vudriver.cpp
_TEXT	SEGMENT
_dt$ = -76						; size = 4
tv79 = -72						; size = 4
_inc$1 = -68						; size = 4
_bu$ = -64						; size = 4
_i$2 = -60						; size = 4
_this$ = -56						; size = 4
_dpval$ = -52						; size = 12
_dtval$ = -40						; size = 12
_pval$ = -28						; size = 12
_tval$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_timestamp$ = 8						; size = 4
?ExecDR@VuDeadReckon@@UAEXK@Z PROC			; VuDeadReckon::ExecDR
; _this$ = ecx

; 97   : void VuDeadReckon::ExecDR(VU_TIME timestamp){

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 98   : 	BIG_SCALAR dt = 
; 99   : 		(lastUpdateGameTime_ == 0) ? 0 : static_cast<BIG_SCALAR>(GetDT(timestamp, lastUpdateGameTime_))
; 100  : 	;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN11@ExecDR
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv79[ebp], xmm0
	jmp	SHORT $LN12@ExecDR
$LN11@ExecDR:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _timestamp$[ebp]
	push	eax
	call	?GetDT@@YANKK@Z				; GetDT
	add	esp, 8
	fstp	DWORD PTR tv79[ebp]
$LN12@ExecDR:
	movss	xmm0, DWORD PTR tv79[ebp]
	movss	DWORD PTR _dt$[ebp], xmm0

; 101  : 
; 102  : 	// if update was not enough to change the value, we zero it...
; 103  : 	// this is a float precision problem
; 104  : 	BIG_SCALAR bu; // values before update
; 105  : 	BIG_SCALAR pval[3], dpval[3], tval[3], dtval[3]; // value and increment
; 106  : 	pval[0] = drx_;    pval[1] = dry_;     pval[2] = drz_;

	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _pval$[ebp+ecx], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _pval$[ebp+ecx], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR _pval$[ebp+ecx], eax

; 107  : 	dpval[0] = d_drx_; dpval[1] = d_dry_;  dpval[2] = d_drz_;

	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _dpval$[ebp+ecx], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR _dpval$[ebp+ecx], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR _dpval$[ebp+ecx], eax

; 108  : 	tval[0] = dryaw_;  tval[1] = drpitch_; tval[2] = drroll_;

	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR _tval$[ebp+ecx], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR _tval$[ebp+ecx], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR _tval$[ebp+ecx], eax

; 109  : 	dtval[0] = d_dryaw_;  dtval[1] = d_drpitch_; dtval[2] = d_drroll_;

	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	DWORD PTR _dtval$[ebp+ecx], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+52]
	mov	DWORD PTR _dtval$[ebp+ecx], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	DWORD PTR _dtval$[ebp+ecx], eax

; 110  : 
; 111  : 	for (unsigned int i=0;i<3;++i){

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN8@ExecDR
$LN7@ExecDR:
	mov	ecx, DWORD PTR _i$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$2[ebp], ecx
$LN8@ExecDR:
	cmp	DWORD PTR _i$2[ebp], 3
	jae	$LN6@ExecDR

; 112  : 		// position
; 113  : 		BIG_SCALAR inc = dt*dpval[i];

	mov	edx, DWORD PTR _i$2[ebp]
	movss	xmm0, DWORD PTR _dt$[ebp]
	mulss	xmm0, DWORD PTR _dpval$[ebp+edx*4]
	movss	DWORD PTR _inc$1[ebp], xmm0

; 114  : 		bu = pval[i];

	mov	eax, DWORD PTR _i$2[ebp]
	movss	xmm0, DWORD PTR _pval$[ebp+eax*4]
	movss	DWORD PTR _bu$[ebp], xmm0

; 115  : 		pval[i] += inc;

	mov	ecx, DWORD PTR _i$2[ebp]
	movss	xmm0, DWORD PTR _pval$[ebp+ecx*4]
	addss	xmm0, DWORD PTR _inc$1[ebp]
	mov	edx, DWORD PTR _i$2[ebp]
	movss	DWORD PTR _pval$[ebp+edx*4], xmm0

; 116  : 		if (bu == pval[i]){ dpval[i] = 0; } // if increment was not enough to update, set speed to 0

	mov	eax, DWORD PTR _i$2[ebp]
	movss	xmm0, DWORD PTR _bu$[ebp]
	ucomiss	xmm0, DWORD PTR _pval$[ebp+eax*4]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@ExecDR
	mov	ecx, DWORD PTR _i$2[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _dpval$[ebp+ecx*4], xmm0
$LN5@ExecDR:

; 117  : 		// turn
; 118  : 		inc = dt*dtval[i];

	mov	edx, DWORD PTR _i$2[ebp]
	movss	xmm0, DWORD PTR _dt$[ebp]
	mulss	xmm0, DWORD PTR _dtval$[ebp+edx*4]
	movss	DWORD PTR _inc$1[ebp], xmm0

; 119  : 		bu = tval[i];

	mov	eax, DWORD PTR _i$2[ebp]
	movss	xmm0, DWORD PTR _tval$[ebp+eax*4]
	movss	DWORD PTR _bu$[ebp], xmm0

; 120  : 		tval[i] += inc;

	mov	ecx, DWORD PTR _i$2[ebp]
	movss	xmm0, DWORD PTR _tval$[ebp+ecx*4]
	addss	xmm0, DWORD PTR _inc$1[ebp]
	mov	edx, DWORD PTR _i$2[ebp]
	movss	DWORD PTR _tval$[ebp+edx*4], xmm0

; 121  : 		if (bu == tval[i]){ dtval[i] = 0; } // if increment was not enough to update, set speed to 0

	mov	eax, DWORD PTR _i$2[ebp]
	movss	xmm0, DWORD PTR _bu$[ebp]
	ucomiss	xmm0, DWORD PTR _tval$[ebp+eax*4]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN4@ExecDR
	mov	ecx, DWORD PTR _i$2[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _dtval$[ebp+ecx*4], xmm0
$LN4@ExecDR:

; 122  : 
; 123  : 		// keeps turn between -PI and +PI
; 124  : 		if (tval[i] > VU_PI){ 

	mov	edx, DWORD PTR _i$2[ebp]
	movss	xmm0, DWORD PTR _tval$[ebp+edx*4]
	comiss	xmm0, DWORD PTR __real@40490fdb
	jbe	SHORT $LN3@ExecDR

; 125  : 			tval[i] -= VU_TWOPI; 

	mov	eax, DWORD PTR _i$2[ebp]
	movss	xmm0, DWORD PTR _tval$[ebp+eax*4]
	subss	xmm0, DWORD PTR __real@40c90fdb
	mov	ecx, DWORD PTR _i$2[ebp]
	movss	DWORD PTR _tval$[ebp+ecx*4], xmm0
	jmp	SHORT $LN1@ExecDR
$LN3@ExecDR:

; 126  : 		}
; 127  : 		else if (tval[i] < -VU_PI){

	mov	edx, DWORD PTR _i$2[ebp]
	movss	xmm0, DWORD PTR __real@c0490fdb
	comiss	xmm0, DWORD PTR _tval$[ebp+edx*4]
	jbe	SHORT $LN1@ExecDR

; 128  : 			tval[i] += VU_TWOPI; 

	mov	eax, DWORD PTR _i$2[ebp]
	movss	xmm0, DWORD PTR _tval$[ebp+eax*4]
	addss	xmm0, DWORD PTR __real@40c90fdb
	mov	ecx, DWORD PTR _i$2[ebp]
	movss	DWORD PTR _tval$[ebp+ecx*4], xmm0
$LN1@ExecDR:

; 129  : 		}
; 130  : 	}

	jmp	$LN7@ExecDR
$LN6@ExecDR:

; 131  : 	drx_ = pval[0];     dry_ = pval[1];      drz_ = pval[2];

	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pval$[ebp+edx]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pval$[ebp+edx]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pval$[ebp+edx]
	mov	DWORD PTR [eax+20], ecx

; 132  : 	d_drx_ = dpval[0];  d_dry_ = dpval[1];   d_drz_ = dpval[2];

	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _dpval$[ebp+edx]
	mov	DWORD PTR [eax+24], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _dpval$[ebp+edx]
	mov	DWORD PTR [eax+28], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _dpval$[ebp+edx]
	mov	DWORD PTR [eax+32], ecx

; 133  : 	dryaw_ = tval[0];   drpitch_ = tval[1];  drroll_ = tval[2];

	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _tval$[ebp+edx]
	mov	DWORD PTR [eax+36], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _tval$[ebp+edx]
	mov	DWORD PTR [eax+40], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _tval$[ebp+edx]
	mov	DWORD PTR [eax+44], ecx

; 134  : 	d_dryaw_ = dtval[0];   d_drpitch_ = dtval[1];  d_drroll_ = dtval[2];

	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _dtval$[ebp+edx]
	mov	DWORD PTR [eax+48], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _dtval$[ebp+edx]
	mov	DWORD PTR [eax+52], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _dtval$[ebp+edx]
	mov	DWORD PTR [eax+56], ecx

; 135  : 
; 136  : 	entity_->SetPosition(drx_, dry_, drz_);

	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+20]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+16]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+12]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	call	?SetPosition@VuEntity@@QAEXMMM@Z	; VuEntity::SetPosition

; 137  : 	entity_->SetDelta(d_drx_, d_dry_, d_drz_);

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+32]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+28]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+24]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	call	?SetDelta@VuEntity@@QAEXMMM@Z		; VuEntity::SetDelta

; 138  : 	entity_->SetYPR(dryaw_, drpitch_, drroll_);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+44]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+40]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+36]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	call	?SetYPR@VuEntity@@QAEXMMM@Z		; VuEntity::SetYPR

; 139  : 	entity_->SetYPRDelta(d_dryaw_, d_drpitch_, d_drroll_);

	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+56]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+52]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+48]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	call	?SetYPRDelta@VuEntity@@QAEXMMM@Z	; VuEntity::SetYPRDelta

; 140  : 
; 141  : /*
; 142  : 	val = bu = drx_;
; 143  : 	inc = dt*d_drx_;
; 144  : 	drx_ = val + inc;
; 145  : 	if (bu == drx_){ d_drx_ = 0; } // if increment was not enough to update, set speed to 0
; 146  : 
; 147  : 	val = bu = dry_;
; 148  : 	inc = dt*d_dry_;
; 149  : 	dry_ = val + inc;
; 150  : 	if (bu == dry_){ d_dry_ = 0; }
; 151  : 	
; 152  : 	val = bu = drz_;
; 153  : 	inc = dt*d_drz_;
; 154  : 	drz_ = val + inc;
; 155  : 	if (bu == drz_){ d_drz_ = 0; }
; 156  : 
; 157  : 	// sfr: we should use AGL instead of 0 here, since some places can be below 0...
; 158  : 	//if (drz_ > 0.0f){
; 159  : 	//	// z is inverted (- is up)
; 160  : 	//	drz_ = 0.0f;
; 161  : 	//}
; 162  : 	//entity update
; 163  : 	entity_->SetPosition(
; 164  : 		static_cast<SM_SCALAR>(drx_), 
; 165  : 		static_cast<SM_SCALAR>(dry_), 
; 166  : 		static_cast<SM_SCALAR>(drz_)
; 167  : 	);
; 168  : 	entity_->SetDelta(d_drx_, d_dry_, d_drz_);
; 169  : 	*/
; 170  : 	ResetLastUpdateTime(timestamp);

	mov	eax, DWORD PTR _timestamp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	call	eax

; 171  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?ExecDR@VuDeadReckon@@UAEXK@Z ENDP			; VuDeadReckon::ExecDR
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\src\vudriver.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_time$ = 8						; size = 4
?NoExec@VuDeadReckon@@UAEXK@Z PROC			; VuDeadReckon::NoExec
; _this$ = ecx

; 93   : void VuDeadReckon::NoExec(VU_TIME time){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 94   : 	ResetLastUpdateTime(time);

	mov	eax, DWORD PTR _time$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	call	eax

; 95   : }

	mov	esp, ebp
	pop	ebp
	ret	4
?NoExec@VuDeadReckon@@UAEXK@Z ENDP			; VuDeadReckon::NoExec
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\src\vudriver.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1VuDeadReckon@@UAE@XZ PROC				; VuDeadReckon::~VuDeadReckon
; _this$ = ecx

; 77   : VuDeadReckon::~VuDeadReckon(){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7VuDeadReckon@@6B@

; 78   : }

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1VuDriver@@UAE@XZ			; VuDriver::~VuDriver
	mov	esp, ebp
	pop	ebp
	ret	0
??1VuDeadReckon@@UAE@XZ ENDP				; VuDeadReckon::~VuDeadReckon
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\src\vudriver.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_entity$ = 8						; size = 4
??0VuDeadReckon@@QAE@PAVVuEntity@@@Z PROC		; VuDeadReckon::VuDeadReckon
; _this$ = ecx

; 72   : VuDeadReckon::VuDeadReckon(VuEntity* entity) : VuDriver(entity){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0VuDeadReckon@@QAE@PAVVuEntity@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _entity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0VuDriver@@IAE@PAVVuEntity@@@Z	; VuDriver::VuDriver
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7VuDeadReckon@@6B@

; 73   : 	VuDeadReckon::Reset();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Reset@VuDeadReckon@@IAEXXZ		; VuDeadReckon::Reset

; 74   : 	ResetLastUpdateTime(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetLastUpdateTime@VuDriver@@UAEXK@Z	; VuDriver::ResetLastUpdateTime

; 75   : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0VuDeadReckon@@QAE@PAVVuEntity@@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1VuDriver@@UAE@XZ			; VuDriver::~VuDriver
__ehhandler$??0VuDeadReckon@@QAE@PAVVuEntity@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0VuDeadReckon@@QAE@PAVVuEntity@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0VuDeadReckon@@QAE@PAVVuEntity@@@Z ENDP		; VuDeadReckon::VuDeadReckon
; Function compile flags: /Odtp
;	COMDAT ??_GVuDriver@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GVuDriver@@UAEPAXI@Z PROC				; VuDriver::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1VuDriver@@UAE@XZ			; VuDriver::~VuDriver
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GVuDriver@@UAEPAXI@Z ENDP				; VuDriver::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\src\vudriver.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_time$ = 8						; size = 4
?ResetLastUpdateTime@VuDriver@@UAEXK@Z PROC		; VuDriver::ResetLastUpdateTime
; _this$ = ecx

; 64   : void VuDriver::ResetLastUpdateTime(VU_TIME time){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 65   : 	lastUpdateGameTime_ = time;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _time$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 66   : 	entity_->SetUpdateTime(time);

	mov	edx, DWORD PTR _time$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	call	?SetUpdateTime@VuEntity@@QAEXK@Z	; VuEntity::SetUpdateTime

; 67   : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ResetLastUpdateTime@VuDriver@@UAEXK@Z ENDP		; VuDriver::ResetLastUpdateTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\src\vudriver.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1VuDriver@@UAE@XZ PROC				; VuDriver::~VuDriver
; _this$ = ecx

; 51   : VuDriver::~VuDriver(){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7VuDriver@@6B@

; 52   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??1VuDriver@@UAE@XZ ENDP				; VuDriver::~VuDriver
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\src\vudriver.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_entity$ = 8						; size = 4
??0VuDriver@@IAE@PAVVuEntity@@@Z PROC			; VuDriver::VuDriver
; _this$ = ecx

; 46   : VuDriver::VuDriver(VuEntity* entity) : entity_(entity){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7VuDriver@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _entity$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 47   : 	//lastUpdateGameTime_ = 0;
; 48   : 	lastUpdateGameTime_ = entity->LastUpdateTime();

	mov	ecx, DWORD PTR _entity$[ebp]
	call	?LastUpdateTime@VuEntity@@QBEKXZ	; VuEntity::LastUpdateTime
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 49   : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0VuDriver@@IAE@PAVVuEntity@@@Z ENDP			; VuDriver::VuDriver
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\src\vudriver.cpp
;	COMDAT ?GetDT@@YANKK@Z
_TEXT	SEGMENT
tv129 = -32						; size = 8
tv84 = -24						; size = 8
tv134 = -16						; size = 4
tv89 = -12						; size = 4
tv94 = -8						; size = 4
tv81 = -4						; size = 4
_timestamp$ = 8						; size = 4
_last_timestamp$ = 12					; size = 4
?GetDT@@YANKK@Z PROC					; GetDT, COMDAT

; 33   : inline double GetDT(VU_TIME timestamp, VU_TIME last_timestamp){

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 34   : 	// look out here, time is unsigned, hence the check
; 35   : 	if (timestamp > last_timestamp){

	mov	eax, DWORD PTR _timestamp$[ebp]
	cmp	eax, DWORD PTR _last_timestamp$[ebp]
	jbe	SHORT $LN2@GetDT

; 36   : 		return ((SM_SCALAR)(timestamp - last_timestamp))*VU_TICS_PER_SEC_INV;

	mov	ecx, DWORD PTR _timestamp$[ebp]
	sub	ecx, DWORD PTR _last_timestamp$[ebp]
	mov	DWORD PTR tv81[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv81[ebp]
	mov	edx, DWORD PTR tv81[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv84[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv84[ebp]
	mulss	xmm0, DWORD PTR __real@3a83126f
	movss	DWORD PTR tv89[ebp], xmm0
	fld	DWORD PTR tv89[ebp]
	jmp	SHORT $LN1@GetDT

; 37   : 	}
; 38   : 	else {

	jmp	SHORT $LN1@GetDT
$LN2@GetDT:

; 39   : 		return -(((SM_SCALAR)(last_timestamp - timestamp))*VU_TICS_PER_SEC_INV);

	mov	eax, DWORD PTR _last_timestamp$[ebp]
	sub	eax, DWORD PTR _timestamp$[ebp]
	mov	DWORD PTR tv94[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv94[ebp]
	mov	ecx, DWORD PTR tv94[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv129[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv129[ebp]
	mulss	xmm0, DWORD PTR __real@3a83126f
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv134[ebp], xmm0
	fld	DWORD PTR tv134[ebp]
$LN1@GetDT:

; 40   : 	}
; 41   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetDT@@YANKK@Z ENDP					; GetDT
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuevent.h
;	COMDAT ?RequestOutOfBandTransmit@VuMessage@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?RequestOutOfBandTransmit@VuMessage@@QAEXXZ PROC	; VuMessage::RequestOutOfBandTransmit, COMDAT
; _this$ = ecx

; 181  : 	void RequestOutOfBandTransmit() { flags_ |= VU_OUT_OF_BAND_MSG_FLAG; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+6]
	or	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+6], cl
	mov	esp, ebp
	pop	ebp
	ret	0
?RequestOutOfBandTransmit@VuMessage@@QAEXXZ ENDP	; VuMessage::RequestOutOfBandTransmit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuevent.h
;	COMDAT ?RequestReliableTransmit@VuMessage@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?RequestReliableTransmit@VuMessage@@QAEXXZ PROC		; VuMessage::RequestReliableTransmit, COMDAT
; _this$ = ecx

; 180  : 	void RequestReliableTransmit() { flags_ |= VU_RELIABLE_MSG_FLAG; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+6]
	or	ecx, 8
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+6], cl
	mov	esp, ebp
	pop	ebp
	ret	0
?RequestReliableTransmit@VuMessage@@QAEXXZ ENDP		; VuMessage::RequestReliableTransmit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ PROC ; VuBin<VuSessionEntity>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ENDP ; VuBin<VuSessionEntity>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??C?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??C?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ PROC ; VuBin<VuSessionEntity>::operator->, COMDAT
; _this$ = ecx

; 50   : 	E *operator->() const {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 51   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 52   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??C?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ENDP ; VuBin<VuSessionEntity>::operator->
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ PROC		; VuBin<VuSessionEntity>::operator bool, COMDAT
; _this$ = ecx

; 40   : 	operator bool() const{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 		return e != NULL;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@operator
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv66[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv66[ebp]

; 42   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ ENDP		; VuBin<VuSessionEntity>::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?LastUpdateTime@VuEntity@@QBEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?LastUpdateTime@VuEntity@@QBEKXZ PROC			; VuEntity::LastUpdateTime, COMDAT
; _this$ = ecx

; 172  : 	VU_TIME LastUpdateTime() const { return lastUpdateTime_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+100]
	mov	esp, ebp
	pop	ebp
	ret	0
?LastUpdateTime@VuEntity@@QBEKXZ ENDP			; VuEntity::LastUpdateTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Roll@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Roll@VuEntity@@QBEMXZ PROC				; VuEntity::Roll, COMDAT
; _this$ = ecx

; 166  : 	SM_SCALAR Roll() const { return orient_.roll_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+68]
	mov	esp, ebp
	pop	ebp
	ret	0
?Roll@VuEntity@@QBEMXZ ENDP				; VuEntity::Roll
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Pitch@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Pitch@VuEntity@@QBEMXZ PROC				; VuEntity::Pitch, COMDAT
; _this$ = ecx

; 165  : 	SM_SCALAR Pitch() const { return orient_.pitch_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+64]
	mov	esp, ebp
	pop	ebp
	ret	0
?Pitch@VuEntity@@QBEMXZ ENDP				; VuEntity::Pitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Yaw@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Yaw@VuEntity@@QBEMXZ PROC				; VuEntity::Yaw, COMDAT
; _this$ = ecx

; 164  : 	SM_SCALAR Yaw() const { return orient_.yaw_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+60]
	mov	esp, ebp
	pop	ebp
	ret	0
?Yaw@VuEntity@@QBEMXZ ENDP				; VuEntity::Yaw
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?ZDelta@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ZDelta@VuEntity@@QBEMXZ PROC				; VuEntity::ZDelta, COMDAT
; _this$ = ecx

; 163  : 	SM_SCALAR ZDelta() const { return pos_.dz_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+56]
	mov	esp, ebp
	pop	ebp
	ret	0
?ZDelta@VuEntity@@QBEMXZ ENDP				; VuEntity::ZDelta
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?YDelta@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?YDelta@VuEntity@@QBEMXZ PROC				; VuEntity::YDelta, COMDAT
; _this$ = ecx

; 162  : 	SM_SCALAR YDelta() const { return pos_.dy_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+52]
	mov	esp, ebp
	pop	ebp
	ret	0
?YDelta@VuEntity@@QBEMXZ ENDP				; VuEntity::YDelta
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?XDelta@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?XDelta@VuEntity@@QBEMXZ PROC				; VuEntity::XDelta, COMDAT
; _this$ = ecx

; 161  : 	SM_SCALAR XDelta() const { return pos_.dx_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+48]
	mov	esp, ebp
	pop	ebp
	ret	0
?XDelta@VuEntity@@QBEMXZ ENDP				; VuEntity::XDelta
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?ZPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ZPos@VuEntity@@QBEMXZ PROC				; VuEntity::ZPos, COMDAT
; _this$ = ecx

; 160  : 	BIG_SCALAR ZPos()	const { return pos_.z_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+44]
	mov	esp, ebp
	pop	ebp
	ret	0
?ZPos@VuEntity@@QBEMXZ ENDP				; VuEntity::ZPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?YPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?YPos@VuEntity@@QBEMXZ PROC				; VuEntity::YPos, COMDAT
; _this$ = ecx

; 159  : 	BIG_SCALAR YPos()	const { return pos_.y_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+40]
	mov	esp, ebp
	pop	ebp
	ret	0
?YPos@VuEntity@@QBEMXZ ENDP				; VuEntity::YPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?XPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?XPos@VuEntity@@QBEMXZ PROC				; VuEntity::XPos, COMDAT
; _this$ = ecx

; 158  : 	BIG_SCALAR XPos() const { return pos_.x_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+36]
	mov	esp, ebp
	pop	ebp
	ret	0
?XPos@VuEntity@@QBEMXZ ENDP				; VuEntity::XPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?OwnerId@VuEntity@@QBE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?OwnerId@VuEntity@@QBE?AVVU_ID@@XZ PROC			; VuEntity::OwnerId, COMDAT
; _this$ = ecx

; 152  : 	VU_ID OwnerId() const     { return share_.ownerId_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR [eax+24]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?OwnerId@VuEntity@@QBE?AVVU_ID@@XZ ENDP			; VuEntity::OwnerId
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?SetUpdateTime@VuEntity@@QAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_currentTime$ = 8					; size = 4
?SetUpdateTime@VuEntity@@QAEXK@Z PROC			; VuEntity::SetUpdateTime, COMDAT
; _this$ = ecx

; 119  : 	void SetUpdateTime(VU_TIME currentTime){ lastUpdateTime_ = currentTime; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _currentTime$[ebp]
	mov	DWORD PTR [eax+100], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUpdateTime@VuEntity@@QAEXK@Z ENDP			; VuEntity::SetUpdateTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?SetYPRDelta@VuEntity@@QAEXMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_dyaw$ = 8						; size = 4
_dpitch$ = 12						; size = 4
_droll$ = 16						; size = 4
?SetYPRDelta@VuEntity@@QAEXMMM@Z PROC			; VuEntity::SetYPRDelta, COMDAT
; _this$ = ecx

; 116  : 	void SetYPRDelta(SM_SCALAR dyaw, SM_SCALAR dpitch,SM_SCALAR droll){ 

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 117  : 		orient_.dyaw_ = dyaw; orient_.dpitch_ = dpitch; orient_.droll_=droll; 

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _dyaw$[ebp]
	movss	DWORD PTR [eax+72], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _dpitch$[ebp]
	movss	DWORD PTR [ecx+76], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _droll$[ebp]
	movss	DWORD PTR [edx+80], xmm0

; 118  : 	}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SetYPRDelta@VuEntity@@QAEXMMM@Z ENDP			; VuEntity::SetYPRDelta
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?SetYPR@VuEntity@@QAEXMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_yaw$ = 8						; size = 4
_pitch$ = 12						; size = 4
_roll$ = 16						; size = 4
?SetYPR@VuEntity@@QAEXMMM@Z PROC			; VuEntity::SetYPR, COMDAT
; _this$ = ecx

; 113  : 	void SetYPR(SM_SCALAR yaw, SM_SCALAR pitch, SM_SCALAR roll){ 

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 114  : 		orient_.yaw_ = yaw; orient_.pitch_ = pitch; orient_.roll_ = roll; 

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _yaw$[ebp]
	movss	DWORD PTR [eax+60], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _pitch$[ebp]
	movss	DWORD PTR [ecx+64], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _roll$[ebp]
	movss	DWORD PTR [edx+68], xmm0

; 115  : 	}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SetYPR@VuEntity@@QAEXMMM@Z ENDP			; VuEntity::SetYPR
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
;	COMDAT ??8VU_ID@@QBE_NABV0@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -2						; size = 1
tv73 = -1						; size = 1
_rhs$ = 8						; size = 4
??8VU_ID@@QBE_NABV0@@Z PROC				; VU_ID::operator==, COMDAT
; _this$ = ecx

; 104  : 	bool operator == (const VU_ID &rhs) const { 

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 105  : 		return (
; 106  : 			num_ == rhs.num_ ? 
; 107  : 			(creator_ == rhs.creator_ ? true : false) : 
; 108  : 			false
; 109  : 		); 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN5@operator
	mov	eax, DWORD PTR _rhs$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??8VU_SESSION_ID@@QBEHABV0@@Z		; VU_SESSION_ID::operator==
	test	eax, eax
	je	SHORT $LN3@operator
	mov	BYTE PTR tv73[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	BYTE PTR tv73[ebp], 0
$LN4@operator:
	mov	cl, BYTE PTR tv73[ebp]
	mov	BYTE PTR tv74[ebp], cl
	jmp	SHORT $LN6@operator
$LN5@operator:
	mov	BYTE PTR tv74[ebp], 0
$LN6@operator:
	mov	al, BYTE PTR tv74[ebp]

; 110  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
??8VU_ID@@QBE_NABV0@@Z ENDP				; VU_ID::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
;	COMDAT ??8VU_SESSION_ID@@QBEHABV0@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_rhs$ = 8						; size = 4
??8VU_SESSION_ID@@QBEHABV0@@Z PROC			; VU_SESSION_ID::operator==, COMDAT
; _this$ = ecx

; 55   : 	int operator == (const VU_SESSION_ID &rhs) const{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return (value_ == rhs.value_ ? TRUE : FALSE); 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv67[ebp], 0
$LN4@operator:
	mov	eax, DWORD PTR tv67[ebp]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
??8VU_SESSION_ID@@QBEHABV0@@Z ENDP			; VU_SESSION_ID::operator==
_TEXT	ENDS
END
