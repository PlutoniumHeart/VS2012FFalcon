; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\vu2\src\vu_hash_iterator.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
PUBLIC	??4VuIterator@@QAEAAV0@ABV0@@Z			; VuIterator::operator=
PUBLIC	??4VuListIterator@@QAEAAV0@ABV0@@Z		; VuListIterator::operator=
PUBLIC	??0VuHashIterator@@QAE@PAVVuHashTable@@@Z	; VuHashIterator::VuHashIterator
PUBLIC	??1VuHashIterator@@UAE@XZ			; VuHashIterator::~VuHashIterator
PUBLIC	?GetFirst@VuHashIterator@@QAEPAVVuEntity@@XZ	; VuHashIterator::GetFirst
PUBLIC	?GetNext@VuHashIterator@@QAEPAVVuEntity@@XZ	; VuHashIterator::GetNext
PUBLIC	?GetFirst@VuHashIterator@@QAEPAVVuEntity@@PAVVuFilter@@@Z ; VuHashIterator::GetFirst
PUBLIC	?GetNext@VuHashIterator@@QAEPAVVuEntity@@PAVVuFilter@@@Z ; VuHashIterator::GetNext
PUBLIC	?CurrEnt@VuHashIterator@@UAEPAVVuEntity@@XZ	; VuHashIterator::CurrEnt
PUBLIC	?Cleanup@VuHashIterator@@UAEHXZ			; VuHashIterator::Cleanup
PUBLIC	??_GVuHashIterator@@UAEPAXI@Z			; VuHashIterator::`scalar deleting destructor'
PUBLIC	??_7VuHashIterator@@6B@				; VuHashIterator::`vftable'
PUBLIC	??_R4VuHashIterator@@6B@			; VuHashIterator::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVVuHashIterator@@@8			; VuHashIterator `RTTI Type Descriptor'
PUBLIC	??_R3VuHashIterator@@8				; VuHashIterator::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2VuHashIterator@@8				; VuHashIterator::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@VuHashIterator@@8			; VuHashIterator::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@VuIterator@@8			; VuIterator::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVVuIterator@@@8				; VuIterator `RTTI Type Descriptor'
PUBLIC	??_R3VuIterator@@8				; VuIterator::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2VuIterator@@8				; VuIterator::`RTTI Base Class Array'
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??0VuIterator@@IAE@PAVVuCollection@@@Z:PROC	; VuIterator::VuIterator
EXTRN	??1VuIterator@@MAE@XZ:PROC			; VuIterator::~VuIterator
EXTRN	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z:PROC	; VuListIterator::VuListIterator
EXTRN	??1VuListIterator@@UAE@XZ:PROC			; VuListIterator::~VuListIterator
EXTRN	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ:PROC ; VuListIterator::GetFirst
EXTRN	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ:PROC ; VuListIterator::GetNext
EXTRN	??_EVuHashIterator@@UAEPAXI@Z:PROC		; VuHashIterator::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
_allocator_arg DB 01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT ??_R2VuIterator@@8
rdata$r	SEGMENT
??_R2VuIterator@@8 DD FLAT:??_R1A@?0A@EA@VuIterator@@8	; VuIterator::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3VuIterator@@8
rdata$r	SEGMENT
??_R3VuIterator@@8 DD 00H				; VuIterator::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2VuIterator@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVVuIterator@@@8
_DATA	SEGMENT
??_R0?AVVuIterator@@@8 DD FLAT:??_7type_info@@6B@	; VuIterator `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVVuIterator@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@VuIterator@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@VuIterator@@8 DD FLAT:??_R0?AVVuIterator@@@8 ; VuIterator::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3VuIterator@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@VuHashIterator@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@VuHashIterator@@8 DD FLAT:??_R0?AVVuHashIterator@@@8 ; VuHashIterator::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3VuHashIterator@@8
rdata$r	ENDS
;	COMDAT ??_R2VuHashIterator@@8
rdata$r	SEGMENT
??_R2VuHashIterator@@8 DD FLAT:??_R1A@?0A@EA@VuHashIterator@@8 ; VuHashIterator::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@VuIterator@@8
rdata$r	ENDS
;	COMDAT ??_R3VuHashIterator@@8
rdata$r	SEGMENT
??_R3VuHashIterator@@8 DD 00H				; VuHashIterator::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2VuHashIterator@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVVuHashIterator@@@8
_DATA	SEGMENT
??_R0?AVVuHashIterator@@@8 DD FLAT:??_7type_info@@6B@	; VuHashIterator `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVVuHashIterator@@', 00H
_DATA	ENDS
;	COMDAT ??_R4VuHashIterator@@6B@
rdata$r	SEGMENT
??_R4VuHashIterator@@6B@ DD 00H				; VuHashIterator::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVVuHashIterator@@@8
	DD	FLAT:??_R3VuHashIterator@@8
rdata$r	ENDS
;	COMDAT ??_7VuHashIterator@@6B@
CONST	SEGMENT
??_7VuHashIterator@@6B@ DD FLAT:??_R4VuHashIterator@@6B@ ; VuHashIterator::`vftable'
	DD	FLAT:?CurrEnt@VuHashIterator@@UAEPAVVuEntity@@XZ
	DD	FLAT:?Cleanup@VuHashIterator@@UAEHXZ
	DD	FLAT:??_EVuHashIterator@@UAEPAXI@Z
CONST	ENDS
xdata$x	SEGMENT
__unwindtable$??1VuHashIterator@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1VuHashIterator@@UAE@XZ$0
__unwindtable$??0VuHashIterator@@QAE@PAVVuHashTable@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0VuHashIterator@@QAE@PAVVuHashTable@@@Z$0
__ehfuncinfo$??1VuHashIterator@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1VuHashIterator@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??0VuHashIterator@@QAE@PAVVuHashTable@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0VuHashIterator@@QAE@PAVVuHashTable@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GVuHashIterator@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GVuHashIterator@@UAEPAXI@Z PROC			; VuHashIterator::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1VuHashIterator@@UAE@XZ		; VuHashIterator::~VuHashIterator
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GVuHashIterator@@UAEPAXI@Z ENDP			; VuHashIterator::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\src\vu_hash_iterator.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Cleanup@VuHashIterator@@UAEHXZ PROC			; VuHashIterator::Cleanup
; _this$ = ecx

; 201  : VU_ERRCODE VuHashIterator::Cleanup(){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 202  : #if 0
; 203  : 	curr_ = vuTailNode;
; 204  : #endif
; 205  : 	return VU_SUCCESS;

	mov	eax, 1

; 206  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Cleanup@VuHashIterator@@UAEHXZ ENDP			; VuHashIterator::Cleanup
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\src\vu_hash_iterator.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CurrEnt@VuHashIterator@@UAEPAVVuEntity@@XZ PROC	; VuHashIterator::CurrEnt
; _this$ = ecx

; 176  : VuEntity *VuHashIterator::CurrEnt(){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 177  : 	return curr_.CurrEnt();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	mov	eax, DWORD PTR [edx]
	call	eax

; 178  : #if 0
; 179  : 	// sfr: smartpointer
; 180  : 	return curr_->entity_.get();
; 181  : #endif
; 182  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CurrEnt@VuHashIterator@@UAEPAVVuEntity@@XZ ENDP	; VuHashIterator::CurrEnt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\src\vu_hash_iterator.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_ret$ = -4						; size = 4
_filter$ = 8						; size = 4
?GetNext@VuHashIterator@@QAEPAVVuEntity@@PAVVuFilter@@@Z PROC ; VuHashIterator::GetNext
; _this$ = ecx

; 143  : VuEntity *VuHashIterator::GetNext(VuFilter* filter){

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 144  : 	if (!filter){ return GetNext(); }

	cmp	DWORD PTR _filter$[ebp], 0
	jne	SHORT $LN5@GetNext
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNext@VuHashIterator@@QAEPAVVuEntity@@XZ ; VuHashIterator::GetNext
	jmp	SHORT $LN7@GetNext
$LN5@GetNext:

; 145  : 	VuEntity *ret;
; 146  : 	do {
; 147  : 		ret = GetNext();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNext@VuHashIterator@@QAEPAVVuEntity@@XZ ; VuHashIterator::GetNext
	mov	DWORD PTR _ret$[ebp], eax

; 148  : 		if (ret == NULL || filter->Test(ret)){

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN1@GetNext
	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filter$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _filter$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@GetNext
$LN1@GetNext:

; 149  : 			return ret;

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	SHORT $LN7@GetNext
$LN4@GetNext:

; 150  : 		}
; 151  : 	} while (1);

	mov	edx, 1
	test	edx, edx
	jne	SHORT $LN5@GetNext
$LN7@GetNext:

; 152  : 
; 153  : #if 0
; 154  : 	// sfr: smartpointer
; 155  : 	GetNext();
; 156  : 	
; 157  : 	if (filter)
; 158  : 	{
; 159  : 		if (curr_->entity_.get() == 0)
; 160  : 		{
; 161  : 			return curr_->entity_.get();
; 162  : 		}
; 163  : 
; 164  : 		if (filter->Test(curr_->entity_.get()))
; 165  : 		{
; 166  : 			return curr_->entity_.get();
; 167  : 		}
; 168  : 
; 169  : 		return GetNext(filter);
; 170  : 	}
; 171  : 	
; 172  : 	return curr_->entity_.get();
; 173  : #endif
; 174  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetNext@VuHashIterator@@QAEPAVVuEntity@@PAVVuFilter@@@Z ENDP ; VuHashIterator::GetNext
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\src\vu_hash_iterator.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_ret$ = -4						; size = 4
_filter$ = 8						; size = 4
?GetFirst@VuHashIterator@@QAEPAVVuEntity@@PAVVuFilter@@@Z PROC ; VuHashIterator::GetFirst
; _this$ = ecx

; 109  : VuEntity *VuHashIterator::GetFirst(VuFilter* filter){

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 110  : 	if (!filter){ return GetFirst(); }

	cmp	DWORD PTR _filter$[ebp], 0
	jne	SHORT $LN4@GetFirst
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetFirst@VuHashIterator@@QAEPAVVuEntity@@XZ ; VuHashIterator::GetFirst
	jmp	SHORT $LN5@GetFirst
$LN4@GetFirst:

; 111  : 	VuEntity *ret = GetFirst();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetFirst@VuHashIterator@@QAEPAVVuEntity@@XZ ; VuHashIterator::GetFirst
	mov	DWORD PTR _ret$[ebp], eax

; 112  : 	if (ret == NULL){ return NULL; }

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN3@GetFirst
	xor	eax, eax
	jmp	SHORT $LN5@GetFirst
$LN3@GetFirst:

; 113  : 	if (filter->Test(ret)){

	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filter$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _filter$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@GetFirst

; 114  : 		return ret;

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	SHORT $LN5@GetFirst

; 115  : 	}
; 116  : 	else {

	jmp	SHORT $LN5@GetFirst
$LN2@GetFirst:

; 117  : 		return GetNext(filter);

	mov	edx, DWORD PTR _filter$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNext@VuHashIterator@@QAEPAVVuEntity@@PAVVuFilter@@@Z ; VuHashIterator::GetNext
$LN5@GetFirst:

; 118  : 	}
; 119  : 	
; 120  : #if 0
; 121  : 	// sfr: smartpointer
; 122  : 	GetFirst();
; 123  : 	
; 124  : 	if (filter)
; 125  : 	{
; 126  : 		if (curr_->entity_.get() == 0)
; 127  : 		{
; 128  : 			return curr_->entity_.get();
; 129  : 		}
; 130  : 
; 131  : 		if (filter->Test(curr_->entity_.get()))
; 132  : 		{
; 133  : 			return curr_->entity_.get();
; 134  : 		}
; 135  : 
; 136  : 		return GetNext(filter);
; 137  : 	}
; 138  : 
; 139  : 	return curr_->entity_.get();
; 140  : #endif
; 141  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetFirst@VuHashIterator@@QAEPAVVuEntity@@PAVVuFilter@@@Z ENDP ; VuHashIterator::GetFirst
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\src\vu_hash_iterator.cpp
_TEXT	SEGMENT
$T1 = -32						; size = 12
tv135 = -20						; size = 4
tv79 = -16						; size = 4
_h$ = -12						; size = 4
_ret$ = -8						; size = 4
_this$ = -4						; size = 4
?GetNext@VuHashIterator@@QAEPAVVuEntity@@XZ PROC	; VuHashIterator::GetNext
; _this$ = ecx

; 65   : VuEntity *VuHashIterator::GetNext(){

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 66   : 	VuHashTable *h = static_cast<VuHashTable*>(collection_);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _h$[ebp], ecx
$LN6@GetNext:

; 67   : 	VuEntity *ret;
; 68   : 	do {
; 69   : 		// try next
; 70   : 		ret = curr_.GetNext();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _ret$[ebp], eax
$LN3@GetNext:

; 71   : 		while (ret == NULL && ++idx_ < h->capacity_){

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN5@GetNext
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, 1
	mov	DWORD PTR tv79[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR tv79[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _h$[ebp]
	mov	ecx, DWORD PTR tv79[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jae	SHORT $LN5@GetNext

; 72   : 			// here we couldnt find a valid next, so try next entry until we find a valid one
; 73   : 			curr_ = VuListIterator(&h->table_[idx_]);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _h$[ebp]
	add	eax, DWORD PTR [ecx+24]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	DWORD PTR tv135[ebp], eax
	mov	edx, DWORD PTR tv135[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??4VuListIterator@@QAEAAV0@ABV0@@Z
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator

; 74   : 			ret = curr_.GetFirst();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetFirst
	mov	DWORD PTR _ret$[ebp], eax

; 75   : 		}

	jmp	SHORT $LN3@GetNext
$LN5@GetNext:

; 76   : 	} while (ret == NULL && idx_ < h->capacity_);

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN4@GetNext
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _h$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+16]
	jb	$LN6@GetNext
$LN4@GetNext:

; 77   : 	return ret;

	mov	eax, DWORD PTR _ret$[ebp]

; 78   : 
; 79   : #if 0
; 80   : 	curr_ = curr_->next_;
; 81   : 
; 82   : 	if (curr_ != vuTailNode)
; 83   : 	{
; 84   : 		// sfr: smartpointer
; 85   : 		return curr_->entity_.get();
; 86   : 	}
; 87   : 
; 88   : 	entry_++;
; 89   : 
; 90   : 	while (*entry_ == vuTailNode)
; 91   : 	{
; 92   : 		entry_++;
; 93   : 	}
; 94   : 
; 95   : 	if (*entry_ == 0)
; 96   : 	{
; 97   : 		curr_ = vuTailNode;
; 98   : 	}
; 99   : 	else
; 100  : 	{
; 101  : 		curr_ = *entry_;
; 102  : 	}
; 103  : 
; 104  : 	// sfr: smartpointer
; 105  : 	return curr_->entity_.get();
; 106  : #endif
; 107  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNext@VuHashIterator@@QAEPAVVuEntity@@XZ ENDP	; VuHashIterator::GetNext
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\src\vu_hash_iterator.cpp
_TEXT	SEGMENT
$T1 = -32						; size = 12
tv132 = -20						; size = 4
_ret$ = -16						; size = 4
tv128 = -12						; size = 4
_h$ = -8						; size = 4
_this$ = -4						; size = 4
?GetFirst@VuHashIterator@@QAEPAVVuEntity@@XZ PROC	; VuHashIterator::GetFirst
; _this$ = ecx

; 27   : VuEntity *VuHashIterator::GetFirst(){

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 28   : 	VuHashTable *h = static_cast<VuHashTable*>(collection_);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _h$[ebp], ecx

; 29   : 	if (!h || h->capacity_ <= 0){ return NULL; }

	cmp	DWORD PTR _h$[ebp], 0
	je	SHORT $LN5@GetFirst
	mov	edx, DWORD PTR _h$[ebp]
	cmp	DWORD PTR [edx+16], 0
	ja	SHORT $LN6@GetFirst
$LN5@GetFirst:
	xor	eax, eax
	jmp	SHORT $LN7@GetFirst
$LN6@GetFirst:

; 30   : 	idx_ = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
$LN4@GetFirst:

; 31   : 	VuEntity *ret;
; 32   : 	do {
; 33   : 		curr_ = VuListIterator(&h->table_[idx_]);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _h$[ebp]
	add	edx, DWORD PTR [eax+24]
	push	edx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	DWORD PTR tv132[ebp], eax
	mov	ecx, DWORD PTR tv132[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??4VuListIterator@@QAEAAV0@ABV0@@Z
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator

; 34   : 		ret = curr_.GetFirst();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetFirst
	mov	DWORD PTR _ret$[ebp], eax

; 35   : 	} while (ret == NULL && ++idx_ < h->capacity_);

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN2@GetFirst
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, 1
	mov	DWORD PTR tv128[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR tv128[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _h$[ebp]
	mov	ecx, DWORD PTR tv128[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN4@GetFirst
$LN2@GetFirst:

; 36   : 	return ret;

	mov	eax, DWORD PTR _ret$[ebp]
$LN7@GetFirst:

; 37   : 	
; 38   : #if 0
; 39   : 	if (collection_)
; 40   : 	{
; 41   : 		entry_ = ((VuHashTable*)collection_)->table_;
; 42   : 		
; 43   : 		while (*entry_ == vuTailNode)
; 44   : 		{
; 45   : 			entry_++;
; 46   : 		}
; 47   : 
; 48   : 		if (*entry_ == 0)
; 49   : 		{
; 50   : 			curr_ = vuTailNode;
; 51   : 		}
; 52   : 		else
; 53   : 		{
; 54   : 			curr_ = *entry_;
; 55   : 		}
; 56   : 
; 57   : 		// sfr: smartpointer
; 58   : 		return curr_->entity_.get();
; 59   : 	}
; 60   : 
; 61   : 	return 0;
; 62   : #endif
; 63   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFirst@VuHashIterator@@QAEPAVVuEntity@@XZ ENDP	; VuHashIterator::GetFirst
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\src\vu_hash_iterator.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1VuHashIterator@@UAE@XZ PROC				; VuHashIterator::~VuHashIterator
; _this$ = ecx

; 22   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1VuHashIterator@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7VuHashIterator@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 23   : //	vuCollectionManager->DeRegister(this);
; 24   : }

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1VuIterator@@MAE@XZ			; VuIterator::~VuIterator
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??1VuHashIterator@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1VuIterator@@MAE@XZ			; VuIterator::~VuIterator
__ehhandler$??1VuHashIterator@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1VuHashIterator@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1VuHashIterator@@UAE@XZ ENDP				; VuHashIterator::~VuHashIterator
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\src\vu_hash_iterator.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_coll$ = 8						; size = 4
??0VuHashIterator@@QAE@PAVVuHashTable@@@Z PROC		; VuHashIterator::VuHashIterator
; _this$ = ecx

; 12   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0VuHashIterator@@QAE@PAVVuHashTable@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _coll$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0VuIterator@@IAE@PAVVuCollection@@@Z	; VuIterator::VuIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7VuHashIterator@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _coll$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+8], ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator

; 13   : #if 0
; 14   : 	curr_ = vuTailNode;
; 15   : 	entry_ = 0;
; 16   : #endif
; 17   : 
; 18   : //	vuCollectionManager->Register(this);
; 19   : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0VuHashIterator@@QAE@PAVVuHashTable@@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1VuIterator@@MAE@XZ			; VuIterator::~VuIterator
__ehhandler$??0VuHashIterator@@QAE@PAVVuHashTable@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0VuHashIterator@@QAE@PAVVuHashTable@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0VuHashIterator@@QAE@PAVVuHashTable@@@Z ENDP		; VuHashIterator::VuHashIterator
; Function compile flags: /Odtp
;	COMDAT ??4VuListIterator@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4VuListIterator@@QAEAAV0@ABV0@@Z PROC			; VuListIterator::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4VuIterator@@QAEAAV0@ABV0@@Z
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4VuListIterator@@QAEAAV0@ABV0@@Z ENDP			; VuListIterator::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??4VuIterator@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4VuIterator@@QAEAAV0@ABV0@@Z PROC			; VuIterator::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4VuIterator@@QAEAAV0@ABV0@@Z ENDP			; VuIterator::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
END
