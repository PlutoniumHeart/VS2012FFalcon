; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\vu2\Src\vu_mq.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?queuecollhead_@VuMessageQueue@@0PAV1@A		; VuMessageQueue::queuecollhead_
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
_BSS	SEGMENT
?queuecollhead_@VuMessageQueue@@0PAV1@A DD 01H DUP (?)	; VuMessageQueue::queuecollhead_
_BSS	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
PUBLIC	??9VU_SESSION_ID@@QBEHABV0@@Z			; VU_SESSION_ID::operator!=
PUBLIC	?SetTransmissionTime@VuEntity@@QAEXK@Z		; VuEntity::SetTransmissionTime
PUBLIC	?IsPrivate@VuEntity@@QBEEXZ			; VuEntity::IsPrivate
PUBLIC	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
PUBLIC	?Type@VuMessage@@QBEEXZ				; VuMessage::Type
PUBLIC	?EntityId@VuMessage@@QBE?AVVU_ID@@XZ		; VuMessage::EntityId
PUBLIC	?Flags@VuMessage@@QBEEXZ			; VuMessage::Flags
PUBLIC	?Entity@VuMessage@@QBEPAVVuEntity@@XZ		; VuMessage::Entity
PUBLIC	?Target@VuMessage@@QBEPAVVuTargetEntity@@XZ	; VuMessage::Target
PUBLIC	?get@?$VuBin@VVuTargetEntity@@@@QBEPAVVuTargetEntity@@XZ ; VuBin<VuTargetEntity>::get
PUBLIC	?get@?$VuBin@VVuEntity@@@@QBEPAVVuEntity@@XZ	; VuBin<VuEntity>::get
PUBLIC	?Connected@VuGlobalGroup@@QAEEXZ		; VuGlobalGroup::Connected
PUBLIC	?SendQueue@VuMainThread@@QBEPAVVuPendingSendQueue@@XZ ; VuMainThread::SendQueue
PUBLIC	??0VuMessageQueue@@QAE@HPAVVuMessageFilter@@@Z	; VuMessageQueue::VuMessageQueue
PUBLIC	??1VuMessageQueue@@QAE@XZ			; VuMessageQueue::~VuMessageQueue
PUBLIC	?DispatchVuMessage@VuMessageQueue@@UAEEE@Z	; VuMessageQueue::DispatchVuMessage
PUBLIC	?DispatchMessages@VuMessageQueue@@QAEHHE@Z	; VuMessageQueue::DispatchMessages
PUBLIC	?InvalidateQueueMessages@VuMessageQueue@@QAEHP6AEPAVVuMessage@@PAX@Z1@Z ; VuMessageQueue::InvalidateQueueMessages
PUBLIC	?PostVuMessage@VuMessageQueue@@SAHPAVVuMessage@@@Z ; VuMessageQueue::PostVuMessage
PUBLIC	?FlushAllQueues@VuMessageQueue@@SAXXZ		; VuMessageQueue::FlushAllQueues
PUBLIC	?RepostMessage@VuMessageQueue@@SAXPAVVuMessage@@H@Z ; VuMessageQueue::RepostMessage
PUBLIC	?ReallocQueue@VuMessageQueue@@MAEEXZ		; VuMessageQueue::ReallocQueue
PUBLIC	?AddMessage@VuMessageQueue@@MAEEPAVVuMessage@@@Z ; VuMessageQueue::AddMessage
PUBLIC	??0VuMainMessageQueue@@QAE@HPAVVuMessageFilter@@@Z ; VuMainMessageQueue::VuMainMessageQueue
PUBLIC	??1VuMainMessageQueue@@QAE@XZ			; VuMainMessageQueue::~VuMainMessageQueue
PUBLIC	?DispatchVuMessage@VuMainMessageQueue@@UAEEE@Z	; VuMainMessageQueue::DispatchVuMessage
PUBLIC	?AddMessage@VuMainMessageQueue@@MAEEPAVVuMessage@@@Z ; VuMainMessageQueue::AddMessage
PUBLIC	??0VuPendingSendQueue@@QAE@H@Z			; VuPendingSendQueue::VuPendingSendQueue
PUBLIC	??1VuPendingSendQueue@@QAE@XZ			; VuPendingSendQueue::~VuPendingSendQueue
PUBLIC	?DispatchVuMessage@VuPendingSendQueue@@UAEEE@Z	; VuPendingSendQueue::DispatchVuMessage
PUBLIC	?RemoveTarget@VuPendingSendQueue@@QAEXPAVVuTargetEntity@@@Z ; VuPendingSendQueue::RemoveTarget
PUBLIC	?AddMessage@VuPendingSendQueue@@MAEEPAVVuMessage@@@Z ; VuPendingSendQueue::AddMessage
PUBLIC	??0VuMessageFilter@@QAE@XZ			; VuMessageFilter::VuMessageFilter
PUBLIC	??1VuMessageFilter@@UAE@XZ			; VuMessageFilter::~VuMessageFilter
PUBLIC	??_GVuMessageFilter@@UAEPAXI@Z			; VuMessageFilter::`scalar deleting destructor'
PUBLIC	??0VuResendMsgFilter@@QAE@XZ			; VuResendMsgFilter::VuResendMsgFilter
PUBLIC	??1VuResendMsgFilter@@UAE@XZ			; VuResendMsgFilter::~VuResendMsgFilter
PUBLIC	?Copy@VuResendMsgFilter@@UBEPAVVuMessageFilter@@XZ ; VuResendMsgFilter::Copy
PUBLIC	??_GVuResendMsgFilter@@UAEPAXI@Z		; VuResendMsgFilter::`scalar deleting destructor'
PUBLIC	??0VuNullMessageFilter@@QAE@XZ			; VuNullMessageFilter::VuNullMessageFilter
PUBLIC	??1VuNullMessageFilter@@UAE@XZ			; VuNullMessageFilter::~VuNullMessageFilter
PUBLIC	?Test@VuNullMessageFilter@@UBEEPAVVuMessage@@@Z	; VuNullMessageFilter::Test
PUBLIC	?Copy@VuNullMessageFilter@@UBEPAVVuMessageFilter@@XZ ; VuNullMessageFilter::Copy
PUBLIC	??_GVuNullMessageFilter@@UAEPAXI@Z		; VuNullMessageFilter::`scalar deleting destructor'
PUBLIC	??$?9VVuSessionEntity@@@@YA_NPBXABV?$VuBin@VVuSessionEntity@@@@@Z ; operator!=<VuSessionEntity>
PUBLIC	?TargetInvalidateCheck@?A0xc27c1e1b@@YAEPAVVuMessage@@PAX@Z ; `anonymous namespace'::TargetInvalidateCheck
PUBLIC	??_7VuMessageQueue@@6B@				; VuMessageQueue::`vftable'
PUBLIC	??_7VuMainMessageQueue@@6B@			; VuMainMessageQueue::`vftable'
PUBLIC	??_7VuPendingSendQueue@@6B@			; VuPendingSendQueue::`vftable'
PUBLIC	??_7VuMessageFilter@@6B@			; VuMessageFilter::`vftable'
PUBLIC	??_7VuResendMsgFilter@@6B@			; VuResendMsgFilter::`vftable'
PUBLIC	??_7VuNullMessageFilter@@6B@			; VuNullMessageFilter::`vftable'
PUBLIC	??_R4VuMessageFilter@@6B@			; VuMessageFilter::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVVuMessageFilter@@@8			; VuMessageFilter `RTTI Type Descriptor'
PUBLIC	??_R3VuMessageFilter@@8				; VuMessageFilter::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2VuMessageFilter@@8				; VuMessageFilter::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@VuMessageFilter@@8		; VuMessageFilter::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4VuNullMessageFilter@@6B@			; VuNullMessageFilter::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVVuNullMessageFilter@@@8			; VuNullMessageFilter `RTTI Type Descriptor'
PUBLIC	??_R3VuNullMessageFilter@@8			; VuNullMessageFilter::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2VuNullMessageFilter@@8			; VuNullMessageFilter::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@VuNullMessageFilter@@8		; VuNullMessageFilter::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4VuResendMsgFilter@@6B@			; VuResendMsgFilter::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVVuResendMsgFilter@@@8			; VuResendMsgFilter `RTTI Type Descriptor'
PUBLIC	??_R3VuResendMsgFilter@@8			; VuResendMsgFilter::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2VuResendMsgFilter@@8			; VuResendMsgFilter::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@VuResendMsgFilter@@8		; VuResendMsgFilter::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4VuMessageQueue@@6B@			; VuMessageQueue::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVVuMessageQueue@@@8			; VuMessageQueue `RTTI Type Descriptor'
PUBLIC	??_R3VuMessageQueue@@8				; VuMessageQueue::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2VuMessageQueue@@8				; VuMessageQueue::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@VuMessageQueue@@8			; VuMessageQueue::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4VuMainMessageQueue@@6B@			; VuMainMessageQueue::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVVuMainMessageQueue@@@8			; VuMainMessageQueue `RTTI Type Descriptor'
PUBLIC	??_R3VuMainMessageQueue@@8			; VuMainMessageQueue::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2VuMainMessageQueue@@8			; VuMainMessageQueue::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@VuMainMessageQueue@@8		; VuMainMessageQueue::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4VuPendingSendQueue@@6B@			; VuPendingSendQueue::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVVuPendingSendQueue@@@8			; VuPendingSendQueue `RTTI Type Descriptor'
PUBLIC	??_R3VuPendingSendQueue@@8			; VuPendingSendQueue::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2VuPendingSendQueue@@8			; VuPendingSendQueue::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@VuPendingSendQueue@@8		; VuPendingSendQueue::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	?IsLocal@VuEntity@@QBEEXZ:PROC			; VuEntity::IsLocal
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	?Handle@VuDatabase@@QAEHPAVVuMessage@@@Z:PROC	; VuDatabase::Handle
EXTRN	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z:PROC ; VuDatabase::Find
EXTRN	?VuEnterCriticalSection@@YAXXZ:PROC		; VuEnterCriticalSection
EXTRN	?VuExitCriticalSection@@YAXXZ:PROC		; VuExitCriticalSection
EXTRN	?IsLocal@VuMessage@@QBEEXZ:PROC			; VuMessage::IsLocal
EXTRN	?Dispatch@VuMessage@@IAEHE@Z:PROC		; VuMessage::Dispatch
EXTRN	?Send@VuMessage@@IAEHXZ:PROC			; VuMessage::Send
EXTRN	?Ref@VuMessage@@QAEHXZ:PROC			; VuMessage::Ref
EXTRN	?UnRef@VuMessage@@QAEHXZ:PROC			; VuMessage::UnRef
EXTRN	??0VuTimerEvent@@QAE@PAVVuEntity@@KGPAVVuMessage@@@Z:PROC ; VuTimerEvent::VuTimerEvent
EXTRN	??0VuUnknownMessage@@QAE@XZ:PROC		; VuUnknownMessage::VuUnknownMessage
EXTRN	??_EVuMessageFilter@@UAEPAXI@Z:PROC		; VuMessageFilter::`vector deleting destructor'
EXTRN	?Test@VuResendMsgFilter@@UBEEPAVVuMessage@@@Z:PROC ; VuResendMsgFilter::Test
EXTRN	??_EVuResendMsgFilter@@UAEPAXI@Z:PROC		; VuResendMsgFilter::`vector deleting destructor'
EXTRN	??_EVuNullMessageFilter@@UAEPAXI@Z:PROC		; VuNullMessageFilter::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	?vuDatabase@@3PAVVuDatabase@@A:DWORD		; vuDatabase
EXTRN	?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A:DWORD ; vuLocalSessionEntity
EXTRN	?vuGlobalGroup@@3PAVVuGlobalGroup@@A:DWORD	; vuGlobalGroup
EXTRN	?vuLocalSession@@3VVU_ID@@A:QWORD		; vuLocalSession
EXTRN	?vuNullId@@3VVU_ID@@A:QWORD			; vuNullId
EXTRN	?vuxRealTime@@3KA:DWORD				; vuxRealTime
EXTRN	?vuMainThread@@3PAVVuMainThread@@A:DWORD	; vuMainThread
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
	ALIGN	4

_vuNullFilter DD 01H DUP (?)
_resendMsgFilter DD 01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT ??_R1A@?0A@EA@VuPendingSendQueue@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@VuPendingSendQueue@@8 DD FLAT:??_R0?AVVuPendingSendQueue@@@8 ; VuPendingSendQueue::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3VuPendingSendQueue@@8
rdata$r	ENDS
;	COMDAT ??_R2VuPendingSendQueue@@8
rdata$r	SEGMENT
??_R2VuPendingSendQueue@@8 DD FLAT:??_R1A@?0A@EA@VuPendingSendQueue@@8 ; VuPendingSendQueue::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@VuMessageQueue@@8
rdata$r	ENDS
;	COMDAT ??_R3VuPendingSendQueue@@8
rdata$r	SEGMENT
??_R3VuPendingSendQueue@@8 DD 00H			; VuPendingSendQueue::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2VuPendingSendQueue@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVVuPendingSendQueue@@@8
_DATA	SEGMENT
??_R0?AVVuPendingSendQueue@@@8 DD FLAT:??_7type_info@@6B@ ; VuPendingSendQueue `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVVuPendingSendQueue@@', 00H
_DATA	ENDS
;	COMDAT ??_R4VuPendingSendQueue@@6B@
rdata$r	SEGMENT
??_R4VuPendingSendQueue@@6B@ DD 00H			; VuPendingSendQueue::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVVuPendingSendQueue@@@8
	DD	FLAT:??_R3VuPendingSendQueue@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@VuMainMessageQueue@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@VuMainMessageQueue@@8 DD FLAT:??_R0?AVVuMainMessageQueue@@@8 ; VuMainMessageQueue::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3VuMainMessageQueue@@8
rdata$r	ENDS
;	COMDAT ??_R2VuMainMessageQueue@@8
rdata$r	SEGMENT
??_R2VuMainMessageQueue@@8 DD FLAT:??_R1A@?0A@EA@VuMainMessageQueue@@8 ; VuMainMessageQueue::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@VuMessageQueue@@8
rdata$r	ENDS
;	COMDAT ??_R3VuMainMessageQueue@@8
rdata$r	SEGMENT
??_R3VuMainMessageQueue@@8 DD 00H			; VuMainMessageQueue::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2VuMainMessageQueue@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVVuMainMessageQueue@@@8
_DATA	SEGMENT
??_R0?AVVuMainMessageQueue@@@8 DD FLAT:??_7type_info@@6B@ ; VuMainMessageQueue `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVVuMainMessageQueue@@', 00H
_DATA	ENDS
;	COMDAT ??_R4VuMainMessageQueue@@6B@
rdata$r	SEGMENT
??_R4VuMainMessageQueue@@6B@ DD 00H			; VuMainMessageQueue::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVVuMainMessageQueue@@@8
	DD	FLAT:??_R3VuMainMessageQueue@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@VuMessageQueue@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@VuMessageQueue@@8 DD FLAT:??_R0?AVVuMessageQueue@@@8 ; VuMessageQueue::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3VuMessageQueue@@8
rdata$r	ENDS
;	COMDAT ??_R2VuMessageQueue@@8
rdata$r	SEGMENT
??_R2VuMessageQueue@@8 DD FLAT:??_R1A@?0A@EA@VuMessageQueue@@8 ; VuMessageQueue::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3VuMessageQueue@@8
rdata$r	SEGMENT
??_R3VuMessageQueue@@8 DD 00H				; VuMessageQueue::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2VuMessageQueue@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVVuMessageQueue@@@8
_DATA	SEGMENT
??_R0?AVVuMessageQueue@@@8 DD FLAT:??_7type_info@@6B@	; VuMessageQueue `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVVuMessageQueue@@', 00H
_DATA	ENDS
;	COMDAT ??_R4VuMessageQueue@@6B@
rdata$r	SEGMENT
??_R4VuMessageQueue@@6B@ DD 00H				; VuMessageQueue::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVVuMessageQueue@@@8
	DD	FLAT:??_R3VuMessageQueue@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@VuResendMsgFilter@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@VuResendMsgFilter@@8 DD FLAT:??_R0?AVVuResendMsgFilter@@@8 ; VuResendMsgFilter::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3VuResendMsgFilter@@8
rdata$r	ENDS
;	COMDAT ??_R2VuResendMsgFilter@@8
rdata$r	SEGMENT
??_R2VuResendMsgFilter@@8 DD FLAT:??_R1A@?0A@EA@VuResendMsgFilter@@8 ; VuResendMsgFilter::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@VuMessageFilter@@8
rdata$r	ENDS
;	COMDAT ??_R3VuResendMsgFilter@@8
rdata$r	SEGMENT
??_R3VuResendMsgFilter@@8 DD 00H			; VuResendMsgFilter::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2VuResendMsgFilter@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVVuResendMsgFilter@@@8
_DATA	SEGMENT
??_R0?AVVuResendMsgFilter@@@8 DD FLAT:??_7type_info@@6B@ ; VuResendMsgFilter `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVVuResendMsgFilter@@', 00H
_DATA	ENDS
;	COMDAT ??_R4VuResendMsgFilter@@6B@
rdata$r	SEGMENT
??_R4VuResendMsgFilter@@6B@ DD 00H			; VuResendMsgFilter::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVVuResendMsgFilter@@@8
	DD	FLAT:??_R3VuResendMsgFilter@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@VuNullMessageFilter@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@VuNullMessageFilter@@8 DD FLAT:??_R0?AVVuNullMessageFilter@@@8 ; VuNullMessageFilter::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3VuNullMessageFilter@@8
rdata$r	ENDS
;	COMDAT ??_R2VuNullMessageFilter@@8
rdata$r	SEGMENT
??_R2VuNullMessageFilter@@8 DD FLAT:??_R1A@?0A@EA@VuNullMessageFilter@@8 ; VuNullMessageFilter::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@VuMessageFilter@@8
rdata$r	ENDS
;	COMDAT ??_R3VuNullMessageFilter@@8
rdata$r	SEGMENT
??_R3VuNullMessageFilter@@8 DD 00H			; VuNullMessageFilter::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2VuNullMessageFilter@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVVuNullMessageFilter@@@8
_DATA	SEGMENT
??_R0?AVVuNullMessageFilter@@@8 DD FLAT:??_7type_info@@6B@ ; VuNullMessageFilter `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVVuNullMessageFilter@@', 00H
_DATA	ENDS
;	COMDAT ??_R4VuNullMessageFilter@@6B@
rdata$r	SEGMENT
??_R4VuNullMessageFilter@@6B@ DD 00H			; VuNullMessageFilter::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVVuNullMessageFilter@@@8
	DD	FLAT:??_R3VuNullMessageFilter@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@VuMessageFilter@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@VuMessageFilter@@8 DD FLAT:??_R0?AVVuMessageFilter@@@8 ; VuMessageFilter::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3VuMessageFilter@@8
rdata$r	ENDS
;	COMDAT ??_R2VuMessageFilter@@8
rdata$r	SEGMENT
??_R2VuMessageFilter@@8 DD FLAT:??_R1A@?0A@EA@VuMessageFilter@@8 ; VuMessageFilter::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3VuMessageFilter@@8
rdata$r	SEGMENT
??_R3VuMessageFilter@@8 DD 00H				; VuMessageFilter::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2VuMessageFilter@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVVuMessageFilter@@@8
_DATA	SEGMENT
??_R0?AVVuMessageFilter@@@8 DD FLAT:??_7type_info@@6B@	; VuMessageFilter `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVVuMessageFilter@@', 00H
_DATA	ENDS
;	COMDAT ??_R4VuMessageFilter@@6B@
rdata$r	SEGMENT
??_R4VuMessageFilter@@6B@ DD 00H			; VuMessageFilter::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVVuMessageFilter@@@8
	DD	FLAT:??_R3VuMessageFilter@@8
rdata$r	ENDS
;	COMDAT ??_7VuNullMessageFilter@@6B@
CONST	SEGMENT
??_7VuNullMessageFilter@@6B@ DD FLAT:??_R4VuNullMessageFilter@@6B@ ; VuNullMessageFilter::`vftable'
	DD	FLAT:??_EVuNullMessageFilter@@UAEPAXI@Z
	DD	FLAT:?Test@VuNullMessageFilter@@UBEEPAVVuMessage@@@Z
	DD	FLAT:?Copy@VuNullMessageFilter@@UBEPAVVuMessageFilter@@XZ
CONST	ENDS
;	COMDAT ??_7VuResendMsgFilter@@6B@
CONST	SEGMENT
??_7VuResendMsgFilter@@6B@ DD FLAT:??_R4VuResendMsgFilter@@6B@ ; VuResendMsgFilter::`vftable'
	DD	FLAT:??_EVuResendMsgFilter@@UAEPAXI@Z
	DD	FLAT:?Test@VuResendMsgFilter@@UBEEPAVVuMessage@@@Z
	DD	FLAT:?Copy@VuResendMsgFilter@@UBEPAVVuMessageFilter@@XZ
CONST	ENDS
;	COMDAT ??_7VuMessageFilter@@6B@
CONST	SEGMENT
??_7VuMessageFilter@@6B@ DD FLAT:??_R4VuMessageFilter@@6B@ ; VuMessageFilter::`vftable'
	DD	FLAT:??_EVuMessageFilter@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_7VuPendingSendQueue@@6B@
CONST	SEGMENT
??_7VuPendingSendQueue@@6B@ DD FLAT:??_R4VuPendingSendQueue@@6B@ ; VuPendingSendQueue::`vftable'
	DD	FLAT:?DispatchVuMessage@VuPendingSendQueue@@UAEEE@Z
	DD	FLAT:?ReallocQueue@VuMessageQueue@@MAEEXZ
	DD	FLAT:?AddMessage@VuPendingSendQueue@@MAEEPAVVuMessage@@@Z
CONST	ENDS
;	COMDAT ??_7VuMainMessageQueue@@6B@
CONST	SEGMENT
??_7VuMainMessageQueue@@6B@ DD FLAT:??_R4VuMainMessageQueue@@6B@ ; VuMainMessageQueue::`vftable'
	DD	FLAT:?DispatchVuMessage@VuMainMessageQueue@@UAEEE@Z
	DD	FLAT:?ReallocQueue@VuMessageQueue@@MAEEXZ
	DD	FLAT:?AddMessage@VuMainMessageQueue@@MAEEPAVVuMessage@@@Z
CONST	ENDS
;	COMDAT ??_7VuMessageQueue@@6B@
CONST	SEGMENT
??_7VuMessageQueue@@6B@ DD FLAT:??_R4VuMessageQueue@@6B@ ; VuMessageQueue::`vftable'
	DD	FLAT:?DispatchVuMessage@VuMessageQueue@@UAEEE@Z
	DD	FLAT:?ReallocQueue@VuMessageQueue@@MAEEXZ
	DD	FLAT:?AddMessage@VuMessageQueue@@MAEEPAVVuMessage@@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Copy@VuNullMessageFilter@@UBEPAVVuMessageFilter@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Copy@VuNullMessageFilter@@UBEPAVVuMessageFilter@@XZ$0
__ehfuncinfo$?Copy@VuNullMessageFilter@@UBEPAVVuMessageFilter@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Copy@VuNullMessageFilter@@UBEPAVVuMessageFilter@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Copy@VuResendMsgFilter@@UBEPAVVuMessageFilter@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Copy@VuResendMsgFilter@@UBEPAVVuMessageFilter@@XZ$0
__ehfuncinfo$?Copy@VuResendMsgFilter@@UBEPAVVuMessageFilter@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Copy@VuResendMsgFilter@@UBEPAVVuMessageFilter@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
xdata$x	SEGMENT
__unwindtable$??1VuPendingSendQueue@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1VuPendingSendQueue@@QAE@XZ$0
__unwindtable$?RepostMessage@VuMessageQueue@@SAXPAVVuMessage@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RepostMessage@VuMessageQueue@@SAXPAVVuMessage@@H@Z$0
__unwindtable$?InvalidateQueueMessages@VuMessageQueue@@QAEHP6AEPAVVuMessage@@PAX@Z1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?InvalidateQueueMessages@VuMessageQueue@@QAEHP6AEPAVVuMessage@@PAX@Z1@Z$0
__ehfuncinfo$??1VuPendingSendQueue@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1VuPendingSendQueue@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?RepostMessage@VuMessageQueue@@SAXPAVVuMessage@@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?RepostMessage@VuMessageQueue@@SAXPAVVuMessage@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?InvalidateQueueMessages@VuMessageQueue@@QAEHP6AEPAVVuMessage@@PAX@Z1@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?InvalidateQueueMessages@VuMessageQueue@@QAEHP6AEPAVVuMessage@@PAX@Z1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_vuNullFilter$initializer$ DD FLAT:??__EvuNullFilter@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_resendMsgFilter$initializer$ DD FLAT:??__EresendMsgFilter@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\src\vu_mq.cpp
_TEXT	SEGMENT
_msg$ = 8						; size = 4
_arg$ = 12						; size = 4
?TargetInvalidateCheck@?A0xc27c1e1b@@YAEPAVVuMessage@@PAX@Z PROC ; `anonymous namespace'::TargetInvalidateCheck

; 387  : 	VU_BOOL TargetInvalidateCheck(VuMessage* msg, void *arg){

	push	ebp
	mov	ebp, esp

; 388  : 		if (msg->Target() == arg) {

	mov	ecx, DWORD PTR _msg$[ebp]
	call	?Target@VuMessage@@QBEPAVVuTargetEntity@@XZ ; VuMessage::Target
	cmp	eax, DWORD PTR _arg$[ebp]
	jne	SHORT $LN1@TargetInva

; 389  : 			return TRUE;

	mov	al, 1
	jmp	SHORT $LN2@TargetInva
$LN1@TargetInva:

; 390  : 		}
; 391  : 		return FALSE;

	xor	al, al
$LN2@TargetInva:

; 392  : 	}

	pop	ebp
	ret	0
?TargetInvalidateCheck@?A0xc27c1e1b@@YAEPAVVuMessage@@PAX@Z ENDP ; `anonymous namespace'::TargetInvalidateCheck
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__FresendMsgFilter@@YAXXZ
text$yd	SEGMENT
??__FresendMsgFilter@@YAXXZ PROC			; `dynamic atexit destructor for 'resendMsgFilter'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET _resendMsgFilter
	call	??1VuResendMsgFilter@@UAE@XZ		; VuResendMsgFilter::~VuResendMsgFilter
	pop	ebp
	ret	0
??__FresendMsgFilter@@YAXXZ ENDP			; `dynamic atexit destructor for 'resendMsgFilter''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\src\vu_mq.cpp
;	COMDAT ??__EresendMsgFilter@@YAXXZ
text$yc	SEGMENT
??__EresendMsgFilter@@YAXXZ PROC			; `dynamic initializer for 'resendMsgFilter'', COMDAT

; 341  : static VuResendMsgFilter resendMsgFilter;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET _resendMsgFilter
	call	??0VuResendMsgFilter@@QAE@XZ		; VuResendMsgFilter::VuResendMsgFilter
	push	OFFSET ??__FresendMsgFilter@@YAXXZ	; `dynamic atexit destructor for 'resendMsgFilter''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__EresendMsgFilter@@YAXXZ ENDP			; `dynamic initializer for 'resendMsgFilter''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??$?9VVuSessionEntity@@@@YA_NPBXABV?$VuBin@VVuSessionEntity@@@@@Z
_TEXT	SEGMENT
tv67 = -4						; size = 4
_le$ = 8						; size = 4
_re$ = 12						; size = 4
??$?9VVuSessionEntity@@@@YA_NPBXABV?$VuBin@VVuSessionEntity@@@@@Z PROC ; operator!=<VuSessionEntity>, COMDAT

; 74   : template <class E> bool operator!=(const void* le, const VuBin<E> &re){ return ((void*)re.get()) != le; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	ecx, DWORD PTR _re$[ebp]
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	cmp	eax, DWORD PTR _le$[ebp]
	je	SHORT $LN3@operator
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv67[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??$?9VVuSessionEntity@@@@YA_NPBXABV?$VuBin@VVuSessionEntity@@@@@Z ENDP ; operator!=<VuSessionEntity>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__FvuNullFilter@@YAXXZ
text$yd	SEGMENT
??__FvuNullFilter@@YAXXZ PROC				; `dynamic atexit destructor for 'vuNullFilter'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET _vuNullFilter
	call	??1VuNullMessageFilter@@UAE@XZ		; VuNullMessageFilter::~VuNullMessageFilter
	pop	ebp
	ret	0
??__FvuNullFilter@@YAXXZ ENDP				; `dynamic atexit destructor for 'vuNullFilter''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\src\vu_mq.cpp
;	COMDAT ??__EvuNullFilter@@YAXXZ
text$yc	SEGMENT
??__EvuNullFilter@@YAXXZ PROC				; `dynamic initializer for 'vuNullFilter'', COMDAT

; 11   : static VuNullMessageFilter vuNullFilter;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET _vuNullFilter
	call	??0VuNullMessageFilter@@QAE@XZ		; VuNullMessageFilter::VuNullMessageFilter
	push	OFFSET ??__FvuNullFilter@@YAXXZ		; `dynamic atexit destructor for 'vuNullFilter''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__EvuNullFilter@@YAXXZ ENDP				; `dynamic initializer for 'vuNullFilter''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GVuNullMessageFilter@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GVuNullMessageFilter@@UAEPAXI@Z PROC			; VuNullMessageFilter::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1VuNullMessageFilter@@UAE@XZ		; VuNullMessageFilter::~VuNullMessageFilter
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GVuNullMessageFilter@@UAEPAXI@Z ENDP			; VuNullMessageFilter::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_mf.h
;	COMDAT ?Copy@VuNullMessageFilter@@UBEPAVVuMessageFilter@@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T2 = -24						; size = 4
tv74 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?Copy@VuNullMessageFilter@@UBEPAVVuMessageFilter@@XZ PROC ; VuNullMessageFilter::Copy, COMDAT
; _this$ = ecx

; 71   : 	virtual VuMessageFilter *Copy() const { return new VuNullMessageFilter; }

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Copy@VuNullMessageFilter@@UBEPAVVuMessageFilter@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@Copy
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0VuNullMessageFilter@@QAE@XZ		; VuNullMessageFilter::VuNullMessageFilter
	mov	DWORD PTR tv74[ebp], eax
	jmp	SHORT $LN4@Copy
$LN3@Copy:
	mov	DWORD PTR tv74[ebp], 0
$LN4@Copy:
	mov	eax, DWORD PTR tv74[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T2[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Copy@VuNullMessageFilter@@UBEPAVVuMessageFilter@@XZ$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?Copy@VuNullMessageFilter@@UBEPAVVuMessageFilter@@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Copy@VuNullMessageFilter@@UBEPAVVuMessageFilter@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Copy@VuNullMessageFilter@@UBEPAVVuMessageFilter@@XZ ENDP ; VuNullMessageFilter::Copy
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_mf.h
;	COMDAT ?Test@VuNullMessageFilter@@UBEEPAVVuMessage@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?Test@VuNullMessageFilter@@UBEEPAVVuMessage@@@Z PROC	; VuNullMessageFilter::Test, COMDAT
; _this$ = ecx

; 70   : 	virtual VU_BOOL Test(VuMessage *) const { return TRUE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	al, 1
	mov	esp, ebp
	pop	ebp
	ret	4
?Test@VuNullMessageFilter@@UBEEPAVVuMessage@@@Z ENDP	; VuNullMessageFilter::Test
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_mf.h
;	COMDAT ??1VuNullMessageFilter@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1VuNullMessageFilter@@UAE@XZ PROC			; VuNullMessageFilter::~VuNullMessageFilter, COMDAT
; _this$ = ecx

; 69   : 	virtual ~VuNullMessageFilter() { }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7VuNullMessageFilter@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1VuMessageFilter@@UAE@XZ		; VuMessageFilter::~VuMessageFilter
	mov	esp, ebp
	pop	ebp
	ret	0
??1VuNullMessageFilter@@UAE@XZ ENDP			; VuNullMessageFilter::~VuNullMessageFilter
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_mf.h
;	COMDAT ??0VuNullMessageFilter@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0VuNullMessageFilter@@QAE@XZ PROC			; VuNullMessageFilter::VuNullMessageFilter, COMDAT
; _this$ = ecx

; 68   : 	VuNullMessageFilter() : VuMessageFilter() { }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0VuMessageFilter@@QAE@XZ		; VuMessageFilter::VuMessageFilter
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7VuNullMessageFilter@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0VuNullMessageFilter@@QAE@XZ ENDP			; VuNullMessageFilter::VuNullMessageFilter
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GVuResendMsgFilter@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GVuResendMsgFilter@@UAEPAXI@Z PROC			; VuResendMsgFilter::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1VuResendMsgFilter@@UAE@XZ		; VuResendMsgFilter::~VuResendMsgFilter
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GVuResendMsgFilter@@UAEPAXI@Z ENDP			; VuResendMsgFilter::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_mf.h
;	COMDAT ?Copy@VuResendMsgFilter@@UBEPAVVuMessageFilter@@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T2 = -24						; size = 4
tv74 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?Copy@VuResendMsgFilter@@UBEPAVVuMessageFilter@@XZ PROC	; VuResendMsgFilter::Copy, COMDAT
; _this$ = ecx

; 49   : 	virtual VuMessageFilter *Copy() const { return new VuResendMsgFilter; }

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Copy@VuResendMsgFilter@@UBEPAVVuMessageFilter@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@Copy
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0VuResendMsgFilter@@QAE@XZ		; VuResendMsgFilter::VuResendMsgFilter
	mov	DWORD PTR tv74[ebp], eax
	jmp	SHORT $LN4@Copy
$LN3@Copy:
	mov	DWORD PTR tv74[ebp], 0
$LN4@Copy:
	mov	eax, DWORD PTR tv74[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T2[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Copy@VuResendMsgFilter@@UBEPAVVuMessageFilter@@XZ$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?Copy@VuResendMsgFilter@@UBEPAVVuMessageFilter@@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Copy@VuResendMsgFilter@@UBEPAVVuMessageFilter@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Copy@VuResendMsgFilter@@UBEPAVVuMessageFilter@@XZ ENDP	; VuResendMsgFilter::Copy
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_mf.h
;	COMDAT ??1VuResendMsgFilter@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1VuResendMsgFilter@@UAE@XZ PROC			; VuResendMsgFilter::~VuResendMsgFilter, COMDAT
; _this$ = ecx

; 47   : 	virtual ~VuResendMsgFilter(){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7VuResendMsgFilter@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1VuMessageFilter@@UAE@XZ		; VuMessageFilter::~VuMessageFilter
	mov	esp, ebp
	pop	ebp
	ret	0
??1VuResendMsgFilter@@UAE@XZ ENDP			; VuResendMsgFilter::~VuResendMsgFilter
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_mf.h
;	COMDAT ??0VuResendMsgFilter@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0VuResendMsgFilter@@QAE@XZ PROC			; VuResendMsgFilter::VuResendMsgFilter, COMDAT
; _this$ = ecx

; 46   : 	VuResendMsgFilter(){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0VuMessageFilter@@QAE@XZ		; VuMessageFilter::VuMessageFilter
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7VuResendMsgFilter@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0VuResendMsgFilter@@QAE@XZ ENDP			; VuResendMsgFilter::VuResendMsgFilter
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GVuMessageFilter@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GVuMessageFilter@@UAEPAXI@Z PROC			; VuMessageFilter::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1VuMessageFilter@@UAE@XZ		; VuMessageFilter::~VuMessageFilter
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GVuMessageFilter@@UAEPAXI@Z ENDP			; VuMessageFilter::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_mf.h
;	COMDAT ??1VuMessageFilter@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1VuMessageFilter@@UAE@XZ PROC				; VuMessageFilter::~VuMessageFilter, COMDAT
; _this$ = ecx

; 15   : 	virtual ~VuMessageFilter() { }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7VuMessageFilter@@6B@
	mov	esp, ebp
	pop	ebp
	ret	0
??1VuMessageFilter@@UAE@XZ ENDP				; VuMessageFilter::~VuMessageFilter
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_mf.h
;	COMDAT ??0VuMessageFilter@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0VuMessageFilter@@QAE@XZ PROC				; VuMessageFilter::VuMessageFilter, COMDAT
; _this$ = ecx

; 14   : 	VuMessageFilter() { }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7VuMessageFilter@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0VuMessageFilter@@QAE@XZ ENDP				; VuMessageFilter::VuMessageFilter
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\src\vu_mq.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_retval$ = -1						; size = 1
_msg$ = 8						; size = 4
?AddMessage@VuPendingSendQueue@@MAEEPAVVuMessage@@@Z PROC ; VuPendingSendQueue::AddMessage
; _this$ = ecx

; 399  : VU_BOOL VuPendingSendQueue::AddMessage(VuMessage* msg){

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 400  : 	VU_BOOL retval = VuMessageQueue::AddMessage(msg);

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddMessage@VuMessageQueue@@MAEEPAVVuMessage@@@Z ; VuMessageQueue::AddMessage
	mov	BYTE PTR _retval$[ebp], al

; 401  : 	if (retval > 0) {

	movzx	ecx, BYTE PTR _retval$[ebp]
	test	ecx, ecx
	jle	SHORT $LN1@AddMessage

; 402  : 		bytesPending_ += msg->Size();

	mov	edx, DWORD PTR _msg$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _msg$[ebp]
	mov	edx, DWORD PTR [eax+4]
	call	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+28], eax
$LN1@AddMessage:

; 403  : 	}
; 404  : 	return retval;

	mov	al, BYTE PTR _retval$[ebp]

; 405  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?AddMessage@VuPendingSendQueue@@MAEEPAVVuMessage@@@Z ENDP ; VuPendingSendQueue::AddMessage
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\src\vu_mq.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_target$ = 8						; size = 4
?RemoveTarget@VuPendingSendQueue@@QAEXPAVVuTargetEntity@@@Z PROC ; VuPendingSendQueue::RemoveTarget
; _this$ = ecx

; 395  : void VuPendingSendQueue::RemoveTarget(VuTargetEntity* target){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 396  : 	InvalidateQueueMessages(TargetInvalidateCheck, target);

	mov	eax, DWORD PTR _target$[ebp]
	push	eax
	push	OFFSET ?TargetInvalidateCheck@?A0xc27c1e1b@@YAEPAVVuMessage@@PAX@Z ; `anonymous namespace'::TargetInvalidateCheck
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InvalidateQueueMessages@VuMessageQueue@@QAEHP6AEPAVVuMessage@@PAX@Z1@Z ; VuMessageQueue::InvalidateQueueMessages

; 397  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?RemoveTarget@VuPendingSendQueue@@QAEXPAVVuTargetEntity@@@Z ENDP ; VuPendingSendQueue::RemoveTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\src\vu_mq.cpp
_TEXT	SEGMENT
_msg$ = -12						; size = 4
_this$ = -8						; size = 4
_retval$ = -1						; size = 1
_autod$ = 8						; size = 1
?DispatchVuMessage@VuPendingSendQueue@@UAEEE@Z PROC	; VuPendingSendQueue::DispatchVuMessage
; _this$ = ecx

; 353  : VU_BOOL VuPendingSendQueue::DispatchVuMessage(VU_BOOL autod){

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 354  : 	VuMessage* msg    = 0;

	mov	DWORD PTR _msg$[ebp], 0

; 355  : 	VU_BOOL retval = FALSE;

	mov	BYTE PTR _retval$[ebp], 0

; 356  : 
; 357  : 	VuEnterCriticalSection();

	call	?VuEnterCriticalSection@@YAXXZ		; VuEnterCriticalSection

; 358  : 
; 359  : 	if (*read_) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	DWORD PTR [ecx], 0
	je	$LN5@DispatchVu

; 360  : 		msg = *read_;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _msg$[ebp], ecx

; 361  : 		*read_++ = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx

; 362  : 		if (read_ == tail_) {

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	cmp	eax, DWORD PTR [edx+16]
	jne	SHORT $LN4@DispatchVu

; 363  : 			read_ = head_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+8], eax
$LN4@DispatchVu:

; 364  : 		}
; 365  : 		msg->Ref();

	mov	ecx, DWORD PTR _msg$[ebp]
	call	?Ref@VuMessage@@QAEHXZ			; VuMessage::Ref

; 366  : 		bytesPending_ -= msg->Size();

	mov	ecx, DWORD PTR _msg$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _msg$[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	sub	edx, eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], edx

; 367  : 		retval = TRUE;

	mov	BYTE PTR _retval$[ebp], 1

; 368  : 		if (msg->DoSend()) {

	mov	ecx, DWORD PTR _msg$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _msg$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@DispatchVu

; 369  : 			if (msg->Send() == 0) {

	mov	ecx, DWORD PTR _msg$[ebp]
	call	?Send@VuMessage@@IAEHXZ			; VuMessage::Send
	test	eax, eax
	jne	SHORT $LN3@DispatchVu

; 370  : 				retval = FALSE;

	mov	BYTE PTR _retval$[ebp], 0

; 371  : 				if (!autod) {

	movzx	edx, BYTE PTR _autod$[ebp]
	test	edx, edx
	jne	SHORT $LN3@DispatchVu

; 372  : 					// note: this puts the unsent message on the end of the send queue
; 373  : 					AddMessage(msg);

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
$LN3@DispatchVu:

; 374  : 				}
; 375  : 			}
; 376  : 		}
; 377  : 		msg->UnRef(); // list reference

	mov	ecx, DWORD PTR _msg$[ebp]
	call	?UnRef@VuMessage@@QAEHXZ		; VuMessage::UnRef

; 378  : 		msg->UnRef(); // local reference

	mov	ecx, DWORD PTR _msg$[ebp]
	call	?UnRef@VuMessage@@QAEHXZ		; VuMessage::UnRef
$LN5@DispatchVu:

; 379  : 	}
; 380  : 
; 381  : 	VuExitCriticalSection();

	call	?VuExitCriticalSection@@YAXXZ		; VuExitCriticalSection

; 382  : 	return retval;

	mov	al, BYTE PTR _retval$[ebp]

; 383  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?DispatchVuMessage@VuPendingSendQueue@@UAEEE@Z ENDP	; VuPendingSendQueue::DispatchVuMessage
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\src\vu_mq.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1VuPendingSendQueue@@QAE@XZ PROC			; VuPendingSendQueue::~VuPendingSendQueue
; _this$ = ecx

; 349  : VuPendingSendQueue::~VuPendingSendQueue(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1VuPendingSendQueue@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7VuPendingSendQueue@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 350  : 	DispatchMessages(-1, TRUE);

	push	1
	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DispatchMessages@VuMessageQueue@@QAEHHE@Z ; VuMessageQueue::DispatchMessages

; 351  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1VuMessageQueue@@QAE@XZ		; VuMessageQueue::~VuMessageQueue
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??1VuPendingSendQueue@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1VuMessageQueue@@QAE@XZ		; VuMessageQueue::~VuMessageQueue
__ehhandler$??1VuPendingSendQueue@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1VuPendingSendQueue@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1VuPendingSendQueue@@QAE@XZ ENDP			; VuPendingSendQueue::~VuPendingSendQueue
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\src\vu_mq.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_queueSize$ = 8						; size = 4
??0VuPendingSendQueue@@QAE@H@Z PROC			; VuPendingSendQueue::VuPendingSendQueue
; _this$ = ecx

; 345  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET _resendMsgFilter
	mov	eax, DWORD PTR _queueSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0VuMessageQueue@@QAE@HPAVVuMessageFilter@@@Z ; VuMessageQueue::VuMessageQueue
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7VuPendingSendQueue@@6B@

; 346  : 	bytesPending_ = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+28], 0

; 347  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0VuPendingSendQueue@@QAE@H@Z ENDP			; VuPendingSendQueue::VuPendingSendQueue
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\src\vu_mq.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
_last$1 = -12						; size = 4
_insert$2 = -8						; size = 4
_cur$3 = -4						; size = 4
_msg$ = 8						; size = 4
?AddMessage@VuMainMessageQueue@@MAEEPAVVuMessage@@@Z PROC ; VuMainMessageQueue::AddMessage
; _this$ = ecx

; 311  : VU_BOOL VuMainMessageQueue::AddMessage(VuMessage* msg){

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 312  : 	if (msg->Type() == VU_TIMER_EVENT) {

	mov	ecx, DWORD PTR _msg$[ebp]
	call	?Type@VuMessage@@QBEEXZ			; VuMessage::Type
	movzx	eax, al
	cmp	eax, 5
	jne	SHORT $LN6@AddMessage

; 313  : 		// add to timer event list in correct place (sorted by time mark)
; 314  : 		msg->Ref();

	mov	ecx, DWORD PTR _msg$[ebp]
	call	?Ref@VuMessage@@QAEHXZ			; VuMessage::Ref

; 315  : 		VuTimerEvent* insert = (VuTimerEvent*)msg;

	mov	ecx, DWORD PTR _msg$[ebp]
	mov	DWORD PTR _insert$2[ebp], ecx

; 316  : 		VuTimerEvent* last = 0;

	mov	DWORD PTR _last$1[ebp], 0

; 317  : 		VuTimerEvent* cur = timerlisthead_;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR _cur$3[ebp], eax
$LN5@AddMessage:

; 318  : 		while (cur && cur->mark_ <= insert->mark_) {

	cmp	DWORD PTR _cur$3[ebp], 0
	je	SHORT $LN4@AddMessage
	mov	ecx, DWORD PTR _cur$3[ebp]
	mov	edx, DWORD PTR _insert$2[ebp]
	mov	eax, DWORD PTR [ecx+48]
	cmp	eax, DWORD PTR [edx+48]
	ja	SHORT $LN4@AddMessage

; 319  : 			last = cur;

	mov	ecx, DWORD PTR _cur$3[ebp]
	mov	DWORD PTR _last$1[ebp], ecx

; 320  : 			cur  = cur->next_;

	mov	edx, DWORD PTR _cur$3[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	DWORD PTR _cur$3[ebp], eax

; 321  : 		}

	jmp	SHORT $LN5@AddMessage
$LN4@AddMessage:

; 322  : 		insert->next_ = cur;

	mov	ecx, DWORD PTR _insert$2[ebp]
	mov	edx, DWORD PTR _cur$3[ebp]
	mov	DWORD PTR [ecx+60], edx

; 323  : 		
; 324  : 		if (last){

	cmp	DWORD PTR _last$1[ebp], 0
	je	SHORT $LN3@AddMessage

; 325  : 			last->next_    = insert;

	mov	eax, DWORD PTR _last$1[ebp]
	mov	ecx, DWORD PTR _insert$2[ebp]
	mov	DWORD PTR [eax+60], ecx

; 326  : 		}
; 327  : 		else{

	jmp	SHORT $LN2@AddMessage
$LN3@AddMessage:

; 328  : 			timerlisthead_ = insert;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _insert$2[ebp]
	mov	DWORD PTR [edx+28], eax
$LN2@AddMessage:

; 329  : 		}
; 330  : 
; 331  : 		return TRUE;

	mov	al, 1
	jmp	SHORT $LN7@AddMessage

; 332  : 	} 
; 333  : 	else{

	jmp	SHORT $LN7@AddMessage
$LN6@AddMessage:

; 334  : 		return VuMessageQueue::AddMessage(msg);

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddMessage@VuMessageQueue@@MAEEPAVVuMessage@@@Z ; VuMessageQueue::AddMessage
$LN7@AddMessage:

; 335  : 	}
; 336  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?AddMessage@VuMainMessageQueue@@MAEEPAVVuMessage@@@Z ENDP ; VuMainMessageQueue::AddMessage
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\src\vu_mq.cpp
_TEXT	SEGMENT
_oldhead$1 = -8						; size = 4
_this$ = -4						; size = 4
_autod$ = 8						; size = 1
?DispatchVuMessage@VuMainMessageQueue@@UAEEE@Z PROC	; VuMainMessageQueue::DispatchVuMessage
; _this$ = ecx

; 298  : VU_BOOL VuMainMessageQueue::DispatchVuMessage(VU_BOOL autod){

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 299  : 	VuEnterCriticalSection();

	call	?VuEnterCriticalSection@@YAXXZ		; VuEnterCriticalSection
$LN2@DispatchVu:

; 300  : 	while (timerlisthead_ && timerlisthead_->mark_ < vuxRealTime) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+28], 0
	je	SHORT $LN1@DispatchVu
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+48]
	cmp	eax, DWORD PTR ?vuxRealTime@@3KA	; vuxRealTime
	jae	SHORT $LN1@DispatchVu

; 301  : 		// message timer mark is older than current timestamp
; 302  : 		VuTimerEvent* oldhead = timerlisthead_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR _oldhead$1[ebp], edx

; 303  : 		timerlisthead_ = timerlisthead_->next_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+60]
	mov	DWORD PTR [edx+28], eax

; 304  : 		oldhead->Dispatch(autod);

	movzx	ecx, BYTE PTR _autod$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _oldhead$1[ebp]
	call	?Dispatch@VuMessage@@IAEHE@Z		; VuMessage::Dispatch

; 305  : 		oldhead->UnRef();

	mov	ecx, DWORD PTR _oldhead$1[ebp]
	call	?UnRef@VuMessage@@QAEHXZ		; VuMessage::UnRef

; 306  : 	}

	jmp	SHORT $LN2@DispatchVu
$LN1@DispatchVu:

; 307  : 	VuExitCriticalSection();

	call	?VuExitCriticalSection@@YAXXZ		; VuExitCriticalSection

; 308  : 	return VuMessageQueue::DispatchVuMessage(autod);

	movzx	edx, BYTE PTR _autod$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DispatchVuMessage@VuMessageQueue@@UAEEE@Z ; VuMessageQueue::DispatchVuMessage

; 309  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?DispatchVuMessage@VuMainMessageQueue@@UAEEE@Z ENDP	; VuMainMessageQueue::DispatchVuMessage
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\src\vu_mq.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1VuMainMessageQueue@@QAE@XZ PROC			; VuMainMessageQueue::~VuMainMessageQueue
; _this$ = ecx

; 296  : VuMainMessageQueue::~VuMainMessageQueue(){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7VuMainMessageQueue@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1VuMessageQueue@@QAE@XZ		; VuMessageQueue::~VuMessageQueue
	mov	esp, ebp
	pop	ebp
	ret	0
??1VuMainMessageQueue@@QAE@XZ ENDP			; VuMainMessageQueue::~VuMainMessageQueue
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\src\vu_mq.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_queueSize$ = 8						; size = 4
_filter$ = 12						; size = 4
??0VuMainMessageQueue@@QAE@HPAVVuMessageFilter@@@Z PROC	; VuMainMessageQueue::VuMainMessageQueue
; _this$ = ecx

; 292  : : VuMessageQueue(queueSize, filter){	

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _filter$[ebp]
	push	eax
	mov	ecx, DWORD PTR _queueSize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0VuMessageQueue@@QAE@HPAVVuMessageFilter@@@Z ; VuMessageQueue::VuMessageQueue
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], OFFSET ??_7VuMainMessageQueue@@6B@

; 293  : 	timerlisthead_ = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], 0

; 294  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0VuMainMessageQueue@@QAE@HPAVVuMessageFilter@@@Z ENDP	; VuMainMessageQueue::VuMainMessageQueue
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\src\vu_mq.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_event$ = 8						; size = 4
?AddMessage@VuMessageQueue@@MAEEPAVVuMessage@@@Z PROC	; VuMessageQueue::AddMessage
; _this$ = ecx

; 262  : VU_BOOL VuMessageQueue::AddMessage(VuMessage* event){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 263  : 	// JB 010121
; 264  : 	if (!event || !filter_){

	cmp	DWORD PTR _event$[ebp], 0
	je	SHORT $LN5@AddMessage
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 0
	jne	SHORT $LN6@AddMessage
$LN5@AddMessage:

; 265  : 		return 0;

	xor	al, al
	jmp	$LN7@AddMessage
$LN6@AddMessage:

; 266  : 	}
; 267  : 
; 268  : 	if (filter_->Test(event) && event->Type() != VU_TIMER_EVENT) {

	mov	ecx, DWORD PTR _event$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	je	$LN4@AddMessage
	mov	ecx, DWORD PTR _event$[ebp]
	call	?Type@VuMessage@@QBEEXZ			; VuMessage::Type
	movzx	edx, al
	cmp	edx, 5
	je	$LN4@AddMessage

; 269  : 		event->Ref();

	mov	ecx, DWORD PTR _event$[ebp]
	call	?Ref@VuMessage@@QAEHXZ			; VuMessage::Ref

; 270  : 		*write_++ = event;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _event$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 271  : 		if (write_ == tail_) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	cmp	edx, DWORD PTR [ecx+16]
	jne	SHORT $LN3@AddMessage

; 272  : 			write_ = head_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+12], edx
$LN3@AddMessage:

; 273  : 		}
; 274  : 
; 275  : 		if (write_ == read_ && *read_) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN2@AddMessage
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN2@AddMessage

; 276  : 			if (!ReallocQueue() && write_ == read_ && *read_) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	call	edx
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@AddMessage
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN2@AddMessage
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN2@AddMessage

; 277  : 				// do simple dispatch -- cannot be handled by user
; 278  : 				// danm_note: should we issue a warning here?
; 279  : 				DispatchVuMessage(TRUE);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
$LN2@AddMessage:

; 280  : 			}
; 281  : 		}
; 282  : 		return TRUE;

	mov	al, 1
	jmp	SHORT $LN7@AddMessage
$LN4@AddMessage:

; 283  : 	}
; 284  : 	return FALSE;

	xor	al, al
$LN7@AddMessage:

; 285  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?AddMessage@VuMessageQueue@@MAEEPAVVuMessage@@@Z ENDP	; VuMessageQueue::AddMessage
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\src\vu_mq.cpp
_TEXT	SEGMENT
$T1 = -28						; size = 4
$T2 = -24						; size = 4
_size$ = -20						; size = 4
_newhead$ = -16						; size = 4
_rp$ = -12						; size = 4
_cp$ = -8						; size = 4
_this$ = -4						; size = 4
?ReallocQueue@VuMessageQueue@@MAEEXZ PROC		; VuMessageQueue::ReallocQueue
; _this$ = ecx

; 236  : VU_BOOL VuMessageQueue::ReallocQueue(){

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 237  : 	int size = (tail_ - head_)*2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+16]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	shl	edx, 1
	mov	DWORD PTR _size$[ebp], edx

; 238  : 	VuMessage	**newhead, **cp, **rp;
; 239  : 
; 240  : 	newhead = new VuMessage*[size];

	xor	ecx, ecx
	mov	eax, DWORD PTR _size$[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _newhead$[ebp], eax

; 241  : 	cp      = newhead;

	mov	ecx, DWORD PTR _newhead$[ebp]
	mov	DWORD PTR _cp$[ebp], ecx

; 242  : 
; 243  : 	for (rp = read_; rp != tail_; cp++,rp++)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _rp$[ebp], eax
	jmp	SHORT $LN8@ReallocQue
$LN7@ReallocQue:
	mov	ecx, DWORD PTR _cp$[ebp]
	add	ecx, 4
	mov	DWORD PTR _cp$[ebp], ecx
	mov	edx, DWORD PTR _rp$[ebp]
	add	edx, 4
	mov	DWORD PTR _rp$[ebp], edx
$LN8@ReallocQue:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rp$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	je	SHORT $LN6@ReallocQue

; 244  : 		*cp = *rp;

	mov	edx, DWORD PTR _cp$[ebp]
	mov	eax, DWORD PTR _rp$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN7@ReallocQue
$LN6@ReallocQue:

; 245  : 
; 246  : 	for (rp = head_; rp != write_; cp++,rp++)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _rp$[ebp], eax
	jmp	SHORT $LN5@ReallocQue
$LN4@ReallocQue:
	mov	ecx, DWORD PTR _cp$[ebp]
	add	ecx, 4
	mov	DWORD PTR _cp$[ebp], ecx
	mov	edx, DWORD PTR _rp$[ebp]
	add	edx, 4
	mov	DWORD PTR _rp$[ebp], edx
$LN5@ReallocQue:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rp$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	je	SHORT $LN3@ReallocQue

; 247  : 		*cp = *rp;

	mov	edx, DWORD PTR _cp$[ebp]
	mov	eax, DWORD PTR _rp$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN4@ReallocQue
$LN3@ReallocQue:

; 248  : 
; 249  : 	delete[] head_;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 250  : 	head_  = newhead;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _newhead$[ebp]
	mov	DWORD PTR [edx+4], eax

; 251  : 	read_  = head_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+8], eax

; 252  : 	write_ = cp;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _cp$[ebp]
	mov	DWORD PTR [ecx+12], edx

; 253  : 	tail_  = head_ + size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _size$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN2@ReallocQue:

; 254  : 
; 255  : 	while (cp != tail_){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _cp$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	je	SHORT $LN1@ReallocQue

; 256  : 		*cp++ = 0;

	mov	ecx, DWORD PTR _cp$[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR _cp$[ebp]
	add	edx, 4
	mov	DWORD PTR _cp$[ebp], edx

; 257  : 	}

	jmp	SHORT $LN2@ReallocQue
$LN1@ReallocQue:

; 258  : 
; 259  : 	return TRUE;

	mov	al, 1

; 260  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ReallocQueue@VuMessageQueue@@MAEEXZ ENDP		; VuMessageQueue::ReallocQueue
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\src\vu_mq.cpp
_TEXT	SEGMENT
_timer$ = -28						; size = 4
$T2 = -24						; size = 4
tv81 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_msg$ = 8						; size = 4
_delay$ = 12						; size = 4
?RepostMessage@VuMessageQueue@@SAXPAVVuMessage@@H@Z PROC ; VuMessageQueue::RepostMessage

; 227  : void VuMessageQueue::RepostMessage(VuMessage* msg, int delay){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?RepostMessage@VuMessageQueue@@SAXPAVVuMessage@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 228  : 	msg->flags_ |= ~VU_LOOPBACK_MSG_FLAG;

	mov	eax, DWORD PTR _msg$[ebp]
	movzx	ecx, BYTE PTR [eax+6]
	or	ecx, -17				; ffffffefH
	mov	edx, DWORD PTR _msg$[ebp]
	mov	BYTE PTR [edx+6], cl

; 229  : 	VuTimerEvent *timer = new VuTimerEvent(0, vuxRealTime + delay, VU_DELAY_TIMER, msg);

	push	64					; 00000040H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@RepostMess
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR ?vuxRealTime@@3KA	; vuxRealTime
	add	ecx, DWORD PTR _delay$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0VuTimerEvent@@QAE@PAVVuEntity@@KGPAVVuMessage@@@Z ; VuTimerEvent::VuTimerEvent
	mov	DWORD PTR tv81[ebp], eax
	jmp	SHORT $LN4@RepostMess
$LN3@RepostMess:
	mov	DWORD PTR tv81[ebp], 0
$LN4@RepostMess:
	mov	edx, DWORD PTR tv81[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _timer$[ebp], eax

; 230  : 	VuMessageQueue::PostVuMessage(timer);

	mov	ecx, DWORD PTR _timer$[ebp]
	push	ecx
	call	?PostVuMessage@VuMessageQueue@@SAHPAVVuMessage@@@Z ; VuMessageQueue::PostVuMessage
	add	esp, 4

; 231  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?RepostMessage@VuMessageQueue@@SAXPAVVuMessage@@H@Z$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?RepostMessage@VuMessageQueue@@SAXPAVVuMessage@@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?RepostMessage@VuMessageQueue@@SAXPAVVuMessage@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?RepostMessage@VuMessageQueue@@SAXPAVVuMessage@@H@Z ENDP ; VuMessageQueue::RepostMessage
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\src\vu_mq.cpp
_TEXT	SEGMENT
_cur$1 = -4						; size = 4
?FlushAllQueues@VuMessageQueue@@SAXXZ PROC		; VuMessageQueue::FlushAllQueues

; 200  : void VuMessageQueue::FlushAllQueues(){

	push	ebp
	mov	ebp, esp
	push	ecx

; 201  : 	// must enter critical section as this modifies multiple threads' queues
; 202  : 	VuEnterCriticalSection();

	call	?VuEnterCriticalSection@@YAXXZ		; VuEnterCriticalSection

; 203  : 	for (

	mov	eax, DWORD PTR ?queuecollhead_@VuMessageQueue@@0PAV1@A ; VuMessageQueue::queuecollhead_
	mov	DWORD PTR _cur$1[ebp], eax

; 204  : 		VuMessageQueue* cur = queuecollhead_;
; 205  : 		cur != NULL;

	jmp	SHORT $LN3@FlushAllQu
$LN2@FlushAllQu:

; 206  : 		cur = cur->nextqueue_
; 207  : 	){

	mov	ecx, DWORD PTR _cur$1[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _cur$1[ebp], edx
$LN3@FlushAllQu:
	cmp	DWORD PTR _cur$1[ebp], 0
	je	SHORT $LN1@FlushAllQu

; 208  : 		cur->DispatchMessages(-1, TRUE);

	push	1
	push	-1
	mov	ecx, DWORD PTR _cur$1[ebp]
	call	?DispatchMessages@VuMessageQueue@@QAEHHE@Z ; VuMessageQueue::DispatchMessages

; 209  : 	}

	jmp	SHORT $LN2@FlushAllQu
$LN1@FlushAllQu:

; 210  : 	VuExitCriticalSection();

	call	?VuExitCriticalSection@@YAXXZ		; VuExitCriticalSection

; 211  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FlushAllQueues@VuMessageQueue@@SAXXZ ENDP		; VuMessageQueue::FlushAllQueues
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\src\vu_mq.cpp
_TEXT	SEGMENT
$T1 = -24						; size = 8
_sq$2 = -16						; size = 4
_retval$ = -12						; size = 4
_cur$3 = -8						; size = 4
_ent$ = -4						; size = 4
_msg$ = 8						; size = 4
?PostVuMessage@VuMessageQueue@@SAHPAVVuMessage@@@Z PROC	; VuMessageQueue::PostVuMessage

; 118  : int VuMessageQueue::PostVuMessage(VuMessage* msg) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 119  : 	int retval = 0;

	mov	DWORD PTR _retval$[ebp], 0

; 120  : 	retval = 1;

	mov	DWORD PTR _retval$[ebp], 1

; 121  : 
; 122  : 	// must enter critical section as this modifies multiple threads' queues
; 123  : 	VuEnterCriticalSection();

	call	?VuEnterCriticalSection@@YAXXZ		; VuEnterCriticalSection

; 124  : 	msg->Ref(); // Ref/UnRef pair will delete unhandled messages

	mov	ecx, DWORD PTR _msg$[ebp]
	call	?Ref@VuMessage@@QAEHXZ			; VuMessage::Ref

; 125  : 
; 126  : 	// set post time
; 127  : 	if (msg->postTime_ == 0){

	mov	eax, DWORD PTR _msg$[ebp]
	cmp	DWORD PTR [eax+36], 0
	jne	SHORT $LN14@PostVuMess

; 128  : 		msg->postTime_ = vuxRealTime;

	mov	ecx, DWORD PTR _msg$[ebp]
	mov	edx, DWORD PTR ?vuxRealTime@@3KA	; vuxRealTime
	mov	DWORD PTR [ecx+36], edx
$LN14@PostVuMess:

; 129  : 	}
; 130  : 
; 131  : 	// activate entity
; 132  : 	VuEntity* ent = msg->Entity();

	mov	ecx, DWORD PTR _msg$[ebp]
	call	?Entity@VuMessage@@QBEPAVVuEntity@@XZ	; VuMessage::Entity
	mov	DWORD PTR _ent$[ebp], eax

; 133  : 	if (ent == 0){

	cmp	DWORD PTR _ent$[ebp], 0
	jne	SHORT $LN13@PostVuMess

; 134  : 		ent = vuDatabase->Find(msg->EntityId());

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	call	?EntityId@VuMessage@@QBE?AVVU_ID@@XZ	; VuMessage::EntityId
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _ent$[ebp], eax
$LN13@PostVuMess:

; 135  : 	}
; 136  : 	msg->Activate(ent);

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _msg$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 137  : 
; 138  : 	if (ent && !msg->IsLocal() && !ent->IsLocal()) {

	cmp	DWORD PTR _ent$[ebp], 0
	je	SHORT $LN12@PostVuMess
	mov	ecx, DWORD PTR _msg$[ebp]
	call	?IsLocal@VuMessage@@QBEEXZ		; VuMessage::IsLocal
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN12@PostVuMess
	mov	ecx, DWORD PTR _ent$[ebp]
	call	?IsLocal@VuEntity@@QBEEXZ		; VuEntity::IsLocal
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN12@PostVuMess

; 139  : 		ent->SetTransmissionTime(msg->postTime_);

	mov	eax, DWORD PTR _msg$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	mov	ecx, DWORD PTR _ent$[ebp]
	call	?SetTransmissionTime@VuEntity@@QAEXK@Z	; VuEntity::SetTransmissionTime
$LN12@PostVuMess:

; 140  : 	}
; 141  : 
; 142  : 	// outgoing message, try send. If fails, add to send queue
; 143  : 	if (
; 144  : 		vuGlobalGroup && vuGlobalGroup->Connected() &&
; 145  : 		msg->Target() && msg->Target() != vuLocalSessionEntity &&
; 146  : 		msg->DoSend() && (!ent || !ent->IsPrivate()) &&
; 147  : 		(vuLocalSession.creator_ != VU_SESSION_NULL_CONNECTION.creator_)
; 148  : 	){

	cmp	DWORD PTR ?vuGlobalGroup@@3PAVVuGlobalGroup@@A, 0 ; vuGlobalGroup
	je	$LN11@PostVuMess
	mov	ecx, DWORD PTR ?vuGlobalGroup@@3PAVVuGlobalGroup@@A ; vuGlobalGroup
	call	?Connected@VuGlobalGroup@@QAEEXZ	; VuGlobalGroup::Connected
	movzx	edx, al
	test	edx, edx
	je	$LN11@PostVuMess
	mov	ecx, DWORD PTR _msg$[ebp]
	call	?Target@VuMessage@@QBEPAVVuTargetEntity@@XZ ; VuMessage::Target
	test	eax, eax
	je	$LN11@PostVuMess
	push	OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	mov	ecx, DWORD PTR _msg$[ebp]
	call	?Target@VuMessage@@QBEPAVVuTargetEntity@@XZ ; VuMessage::Target
	push	eax
	call	??$?9VVuSessionEntity@@@@YA_NPBXABV?$VuBin@VVuSessionEntity@@@@@Z ; operator!=<VuSessionEntity>
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	$LN11@PostVuMess
	mov	ecx, DWORD PTR _msg$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _msg$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	je	$LN11@PostVuMess
	cmp	DWORD PTR _ent$[ebp], 0
	je	SHORT $LN10@PostVuMess
	mov	ecx, DWORD PTR _ent$[ebp]
	call	?IsPrivate@VuEntity@@QBEEXZ		; VuEntity::IsPrivate
	movzx	edx, al
	test	edx, edx
	jne	$LN11@PostVuMess
$LN10@PostVuMess:
	push	OFFSET ?vuNullId@@3VVU_ID@@A+4
	mov	ecx, OFFSET ?vuLocalSession@@3VVU_ID@@A+4
	call	??9VU_SESSION_ID@@QBEHABV0@@Z		; VU_SESSION_ID::operator!=
	test	eax, eax
	je	SHORT $LN11@PostVuMess

; 149  : 		retval = msg->Send();

	mov	ecx, DWORD PTR _msg$[ebp]
	call	?Send@VuMessage@@IAEHXZ			; VuMessage::Send
	mov	DWORD PTR _retval$[ebp], eax

; 150  : 		VuPendingSendQueue *sq = vuMainThread->SendQueue();

	mov	ecx, DWORD PTR ?vuMainThread@@3PAVVuMainThread@@A ; vuMainThread
	call	?SendQueue@VuMainThread@@QBEPAVVuPendingSendQueue@@XZ ; VuMainThread::SendQueue
	mov	DWORD PTR _sq$2[ebp], eax

; 151  : 		if (
; 152  : 			(retval == 0) && sq &&
; 153  : 			(msg->Flags() & VU_SEND_FAILED_MSG_FLAG) &&
; 154  : 			((msg->Flags() & VU_RELIABLE_MSG_FLAG) || (msg->Flags() & VU_KEEPALIVE_MSG_FLAG)) 
; 155  : 		){

	cmp	DWORD PTR _retval$[ebp], 0
	jne	SHORT $LN11@PostVuMess
	cmp	DWORD PTR _sq$2[ebp], 0
	je	SHORT $LN11@PostVuMess
	mov	ecx, DWORD PTR _msg$[ebp]
	call	?Flags@VuMessage@@QBEEXZ		; VuMessage::Flags
	movzx	eax, al
	and	eax, 64					; 00000040H
	je	SHORT $LN11@PostVuMess
	mov	ecx, DWORD PTR _msg$[ebp]
	call	?Flags@VuMessage@@QBEEXZ		; VuMessage::Flags
	movzx	ecx, al
	and	ecx, 8
	jne	SHORT $LN8@PostVuMess
	mov	ecx, DWORD PTR _msg$[ebp]
	call	?Flags@VuMessage@@QBEEXZ		; VuMessage::Flags
	movzx	edx, al
	and	edx, 4
	je	SHORT $LN11@PostVuMess
$LN8@PostVuMess:

; 156  : 			//if (msg->Flags() & VU_NORMAL_PRIORITY_MSG_FLAG){
; 157  : 				sq->AddMessage(msg);

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sq$2[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _sq$2[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 158  : 			//}
; 159  : 			//else{
; 160  : 			//	vuLowSendQueue->AddMessage(msg);				
; 161  : 				//retval = msg->Size();
; 162  : 			//}
; 163  : 			// sfr: why not for both?
; 164  : 			retval = msg->Size();

	mov	ecx, DWORD PTR _msg$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _msg$[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	mov	DWORD PTR _retval$[ebp], eax
$LN11@PostVuMess:

; 165  : 		}
; 166  : 	}
; 167  : 
; 168  : 	// if message is remote or is a local message loopback, place in local queues
; 169  : 	if (
; 170  : 		!msg->IsLocal() ||
; 171  : 		((msg->Flags() & VU_LOOPBACK_MSG_FLAG) && msg->IsLocal())
; 172  : 	){

	mov	ecx, DWORD PTR _msg$[ebp]
	call	?IsLocal@VuMessage@@QBEEXZ		; VuMessage::IsLocal
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@PostVuMess
	mov	ecx, DWORD PTR _msg$[ebp]
	call	?Flags@VuMessage@@QBEEXZ		; VuMessage::Flags
	movzx	edx, al
	and	edx, 16					; 00000010H
	je	SHORT $LN7@PostVuMess
	mov	ecx, DWORD PTR _msg$[ebp]
	call	?IsLocal@VuMessage@@QBEEXZ		; VuMessage::IsLocal
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN7@PostVuMess
$LN6@PostVuMess:

; 173  : 		VuMessageQueue* cur = queuecollhead_;

	mov	ecx, DWORD PTR ?queuecollhead_@VuMessageQueue@@0PAV1@A ; VuMessageQueue::queuecollhead_
	mov	DWORD PTR _cur$3[ebp], ecx
$LN5@PostVuMess:

; 174  : 		while (cur){

	cmp	DWORD PTR _cur$3[ebp], 0
	je	SHORT $LN7@PostVuMess

; 175  : 			// sfr: this is only for received messages. exclude send queues
; 176  : 			if (/*cur != vuLowSendQueue && */cur != vuMainThread->SendQueue()){

	mov	ecx, DWORD PTR ?vuMainThread@@3PAVVuMainThread@@A ; vuMainThread
	call	?SendQueue@VuMainThread@@QBEPAVVuPendingSendQueue@@XZ ; VuMainThread::SendQueue
	cmp	DWORD PTR _cur$3[ebp], eax
	je	SHORT $LN3@PostVuMess

; 177  : 				cur->AddMessage(msg);

	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	mov	eax, DWORD PTR _cur$3[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cur$3[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
$LN3@PostVuMess:

; 178  : 			}
; 179  : 			cur = cur->nextqueue_;

	mov	ecx, DWORD PTR _cur$3[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _cur$3[ebp], edx

; 180  : 		}

	jmp	SHORT $LN5@PostVuMess
$LN7@PostVuMess:

; 181  : 	}
; 182  : 	
; 183  : 	// message not added to any queue, auto destroy
; 184  : 	if (
; 185  : 		(msg->refcnt_ == 1) &&
; 186  : 		(!msg->IsLocal() || (msg->Flags() & VU_LOOPBACK_MSG_FLAG))
; 187  : 	){

	mov	eax, DWORD PTR _msg$[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	cmp	ecx, 1
	jne	SHORT $LN2@PostVuMess
	mov	ecx, DWORD PTR _msg$[ebp]
	call	?IsLocal@VuMessage@@QBEEXZ		; VuMessage::IsLocal
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@PostVuMess
	mov	ecx, DWORD PTR _msg$[ebp]
	call	?Flags@VuMessage@@QBEEXZ		; VuMessage::Flags
	movzx	eax, al
	and	eax, 16					; 00000010H
	je	SHORT $LN2@PostVuMess
$LN1@PostVuMess:

; 188  : 		VuExitCriticalSection();

	call	?VuExitCriticalSection@@YAXXZ		; VuExitCriticalSection

; 189  : 		msg->Process(TRUE);

	push	1
	mov	ecx, DWORD PTR _msg$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _msg$[ebp]
	mov	eax, DWORD PTR [edx+16]
	call	eax

; 190  : 		vuDatabase->Handle(msg);

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Handle@VuDatabase@@QAEHPAVVuMessage@@@Z ; VuDatabase::Handle

; 191  : 		msg->UnRef();

	mov	ecx, DWORD PTR _msg$[ebp]
	call	?UnRef@VuMessage@@QAEHXZ		; VuMessage::UnRef

; 192  : 		return retval;

	mov	eax, DWORD PTR _retval$[ebp]
	jmp	SHORT $LN15@PostVuMess
$LN2@PostVuMess:

; 193  : 	}
; 194  : 	msg->UnRef();

	mov	ecx, DWORD PTR _msg$[ebp]
	call	?UnRef@VuMessage@@QAEHXZ		; VuMessage::UnRef

; 195  : 	VuExitCriticalSection();

	call	?VuExitCriticalSection@@YAXXZ		; VuExitCriticalSection

; 196  : 
; 197  : 	return retval;

	mov	eax, DWORD PTR _retval$[ebp]
$LN15@PostVuMess:

; 198  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PostVuMessage@VuMessageQueue@@SAHPAVVuMessage@@@Z ENDP	; VuMessageQueue::PostVuMessage
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\src\vu_mq.cpp
_TEXT	SEGMENT
$T2 = -36						; size = 4
tv82 = -32						; size = 4
$T3 = -28						; size = 4
_count$ = -24						; size = 4
_this$ = -20						; size = 4
_cur$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_evalFunc$ = 8						; size = 4
_arg$ = 12						; size = 4
?InvalidateQueueMessages@VuMessageQueue@@QAEHP6AEPAVVuMessage@@PAX@Z1@Z PROC ; VuMessageQueue::InvalidateQueueMessages
; _this$ = ecx

; 94   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?InvalidateQueueMessages@VuMessageQueue@@QAEHP6AEPAVVuMessage@@PAX@Z1@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 95   : 	VuEnterCriticalSection();

	call	?VuEnterCriticalSection@@YAXXZ		; VuEnterCriticalSection

; 96   : 	int         count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 97   : 	VuMessage** cur = read_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _cur$[ebp], ecx
$LN4@Invalidate:

; 98   : 
; 99   : 	while (*cur) {

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx], 0
	je	$LN3@Invalidate

; 100  : 		if ((*evalFunc)(*cur, arg) == TRUE) {

	mov	eax, DWORD PTR _arg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR _evalFunc$[ebp]
	add	esp, 8
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN2@Invalidate

; 101  : 			(*cur)->UnRef();

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?UnRef@VuMessage@@QAEHXZ		; VuMessage::UnRef

; 102  : 			*cur = new VuUnknownMessage();

	push	44					; 0000002cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN7@Invalidate
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0VuUnknownMessage@@QAE@XZ		; VuUnknownMessage::VuUnknownMessage
	mov	DWORD PTR tv82[ebp], eax
	jmp	SHORT $LN8@Invalidate
$LN7@Invalidate:
	mov	DWORD PTR tv82[ebp], 0
$LN8@Invalidate:
	mov	edx, DWORD PTR tv82[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR [eax], ecx

; 103  : 			(*cur)->Ref();

	mov	edx, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?Ref@VuMessage@@QAEHXZ			; VuMessage::Ref

; 104  : 			count++;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax
$LN2@Invalidate:

; 105  : 		}
; 106  : 		*cur++;

	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 4
	mov	DWORD PTR _cur$[ebp], ecx

; 107  : 		if (cur == tail_) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jne	SHORT $LN1@Invalidate

; 108  : 			cur = head_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _cur$[ebp], edx
$LN1@Invalidate:

; 109  : 		}
; 110  : 	}

	jmp	$LN4@Invalidate
$LN3@Invalidate:

; 111  : 
; 112  : 	VuExitCriticalSection();

	call	?VuExitCriticalSection@@YAXXZ		; VuExitCriticalSection

; 113  : 	return count;

	mov	eax, DWORD PTR _count$[ebp]

; 114  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?InvalidateQueueMessages@VuMessageQueue@@QAEHP6AEPAVVuMessage@@PAX@Z1@Z$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?InvalidateQueueMessages@VuMessageQueue@@QAEHP6AEPAVVuMessage@@PAX@Z1@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?InvalidateQueueMessages@VuMessageQueue@@QAEHP6AEPAVVuMessage@@PAX@Z1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?InvalidateQueueMessages@VuMessageQueue@@QAEHP6AEPAVVuMessage@@PAX@Z1@Z ENDP ; VuMessageQueue::InvalidateQueueMessages
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\src\vu_mq.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$ = -4						; size = 4
_max$ = 8						; size = 4
_autod$ = 12						; size = 1
?DispatchMessages@VuMessageQueue@@QAEHHE@Z PROC		; VuMessageQueue::DispatchMessages
; _this$ = ecx

; 86   : int VuMessageQueue::DispatchMessages(int max, VU_BOOL autod){

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 87   : 	if (max == -1){ max = 0x7fffffff; }

	cmp	DWORD PTR _max$[ebp], -1
	jne	SHORT $LN3@DispatchMe
	mov	DWORD PTR _max$[ebp], 2147483647	; 7fffffffH
$LN3@DispatchMe:

; 88   : 	int i = 0;

	mov	DWORD PTR _i$[ebp], 0
$LN2@DispatchMe:

; 89   : 	while (DispatchVuMessage(autod) && (++i < max)) ;

	movzx	eax, BYTE PTR _autod$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@DispatchMe
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _max$[ebp]
	jge	SHORT $LN1@DispatchMe
	jmp	SHORT $LN2@DispatchMe
$LN1@DispatchMe:

; 90   : 	return i;

	mov	eax, DWORD PTR _i$[ebp]

; 91   : }

	mov	esp, ebp
	pop	ebp
	ret	8
?DispatchMessages@VuMessageQueue@@QAEHHE@Z ENDP		; VuMessageQueue::DispatchMessages
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\src\vu_mq.cpp
_TEXT	SEGMENT
_msg$ = -8						; size = 4
_this$ = -4						; size = 4
_autod$ = 8						; size = 1
?DispatchVuMessage@VuMessageQueue@@UAEEE@Z PROC		; VuMessageQueue::DispatchVuMessage
; _this$ = ecx

; 64   : VU_BOOL VuMessageQueue::DispatchVuMessage(VU_BOOL autod) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 65   : 	// used to return message... not anymore
; 66   : 	VuMessage *msg = 0;

	mov	DWORD PTR _msg$[ebp], 0

; 67   : 	VuEnterCriticalSection();

	call	?VuEnterCriticalSection@@YAXXZ		; VuEnterCriticalSection

; 68   : 
; 69   : 	if (*read_) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN2@DispatchVu

; 70   : 		msg = *read_;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _msg$[ebp], ecx

; 71   : 		*read_++ = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx

; 72   : 		if (read_ == tail_) {

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	cmp	eax, DWORD PTR [edx+16]
	jne	SHORT $LN1@DispatchVu

; 73   : 			read_ = head_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+8], eax
$LN1@DispatchVu:

; 74   : 		}
; 75   : 		msg->Ref();

	mov	ecx, DWORD PTR _msg$[ebp]
	call	?Ref@VuMessage@@QAEHXZ			; VuMessage::Ref

; 76   : 		VuExitCriticalSection();

	call	?VuExitCriticalSection@@YAXXZ		; VuExitCriticalSection

; 77   : 		msg->Dispatch(autod);

	movzx	ecx, BYTE PTR _autod$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _msg$[ebp]
	call	?Dispatch@VuMessage@@IAEHE@Z		; VuMessage::Dispatch

; 78   : 		msg->UnRef();

	mov	ecx, DWORD PTR _msg$[ebp]
	call	?UnRef@VuMessage@@QAEHXZ		; VuMessage::UnRef

; 79   : 		msg->UnRef();

	mov	ecx, DWORD PTR _msg$[ebp]
	call	?UnRef@VuMessage@@QAEHXZ		; VuMessage::UnRef

; 80   : 		return TRUE;

	mov	al, 1
	jmp	SHORT $LN3@DispatchVu
$LN2@DispatchVu:

; 81   : 	}
; 82   : 	VuExitCriticalSection();

	call	?VuExitCriticalSection@@YAXXZ		; VuExitCriticalSection

; 83   : 	return FALSE;

	xor	al, al
$LN3@DispatchVu:

; 84   : }

	mov	esp, ebp
	pop	ebp
	ret	4
?DispatchVuMessage@VuMessageQueue@@UAEEE@Z ENDP		; VuMessageQueue::DispatchVuMessage
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\src\vu_mq.cpp
_TEXT	SEGMENT
tv74 = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
_last$ = -16						; size = 4
$T3 = -12						; size = 4
_cur$ = -8						; size = 4
_this$ = -4						; size = 4
??1VuMessageQueue@@QAE@XZ PROC				; VuMessageQueue::~VuMessageQueue
; _this$ = ecx

; 38   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7VuMessageQueue@@6B@

; 39   : 	delete [] head_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T2[ebp], edx
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 40   : 	delete filter_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR $T3[ebp], eax
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN8@VuMessageQ
	push	1
	mov	ecx, DWORD PTR $T3[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv74[ebp], eax
	jmp	SHORT $LN9@VuMessageQ
$LN8@VuMessageQ:
	mov	DWORD PTR tv74[ebp], 0
$LN9@VuMessageQ:

; 41   : 	filter_ = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 42   : 
; 43   : 	// delete this queue from list of queues
; 44   : 	VuEnterCriticalSection();

	call	?VuEnterCriticalSection@@YAXXZ		; VuEnterCriticalSection

; 45   : 	VuMessageQueue* last = 0;

	mov	DWORD PTR _last$[ebp], 0

; 46   : 	VuMessageQueue* cur = queuecollhead_;

	mov	edx, DWORD PTR ?queuecollhead_@VuMessageQueue@@0PAV1@A ; VuMessageQueue::queuecollhead_
	mov	DWORD PTR _cur$[ebp], edx
$LN5@VuMessageQ:

; 47   : 	while (cur) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN4@VuMessageQ

; 48   : 		if (this == cur) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR _cur$[ebp]
	jne	SHORT $LN3@VuMessageQ

; 49   : 			if (last) {

	cmp	DWORD PTR _last$[ebp], 0
	je	SHORT $LN2@VuMessageQ

; 50   : 				last->nextqueue_ = this->nextqueue_;

	mov	ecx, DWORD PTR _last$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR [ecx+24], eax

; 51   : 			} 
; 52   : 			else {

	jmp	SHORT $LN1@VuMessageQ
$LN2@VuMessageQ:

; 53   : 				queuecollhead_ = this->nextqueue_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR ?queuecollhead_@VuMessageQueue@@0PAV1@A, edx ; VuMessageQueue::queuecollhead_
$LN1@VuMessageQ:

; 54   : 			}
; 55   : 			// we've removed it... break out of while() loop
; 56   : 			break;

	jmp	SHORT $LN4@VuMessageQ
$LN3@VuMessageQ:

; 57   : 		}
; 58   : 		last = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _last$[ebp], eax

; 59   : 		cur  = cur->nextqueue_;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _cur$[ebp], edx

; 60   : 	}

	jmp	SHORT $LN5@VuMessageQ
$LN4@VuMessageQ:

; 61   : 	VuExitCriticalSection();

	call	?VuExitCriticalSection@@YAXXZ		; VuExitCriticalSection

; 62   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??1VuMessageQueue@@QAE@XZ ENDP				; VuMessageQueue::~VuMessageQueue
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\src\vu_mq.cpp
_TEXT	SEGMENT
$T1 = -12						; size = 4
_i$2 = -8						; size = 4
_this$ = -4						; size = 4
_queueSize$ = 8						; size = 4
_filter$ = 12						; size = 4
??0VuMessageQueue@@QAE@HPAVVuMessageFilter@@@Z PROC	; VuMessageQueue::VuMessageQueue
; _this$ = ecx

; 15   : VuMessageQueue::VuMessageQueue(int queueSize, VuMessageFilter* filter){

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7VuMessageQueue@@6B@

; 16   : 	head_  = new VuMessage*[queueSize];

	xor	ecx, ecx
	mov	eax, DWORD PTR _queueSize$[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [eax+4], ecx

; 17   : 	read_  = head_;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 18   : 	write_ = head_;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+12], ecx

; 19   : 	tail_  = head_ + queueSize;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _queueSize$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], edx

; 20   : 
; 21   : 	// initialize queue
; 22   : 	for (int i = 0; i < queueSize; i++) {

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN4@VuMessageQ
$LN3@VuMessageQ:
	mov	ecx, DWORD PTR _i$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$2[ebp], ecx
$LN4@VuMessageQ:
	mov	edx, DWORD PTR _i$2[ebp]
	cmp	edx, DWORD PTR _queueSize$[ebp]
	jge	SHORT $LN2@VuMessageQ

; 23   : 		head_[i] = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$2[ebp]
	mov	DWORD PTR [ecx+edx*4], 0

; 24   : 	}

	jmp	SHORT $LN3@VuMessageQ
$LN2@VuMessageQ:

; 25   : 	if (!filter) {

	cmp	DWORD PTR _filter$[ebp], 0
	jne	SHORT $LN1@VuMessageQ

; 26   : 		filter = &vuNullFilter;

	mov	DWORD PTR _filter$[ebp], OFFSET _vuNullFilter
$LN1@VuMessageQ:

; 27   : 	}
; 28   : 	filter_ = filter->Copy();

	mov	eax, DWORD PTR _filter$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _filter$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 29   : 
; 30   : 	// add this queue to list of queues
; 31   : 	VuEnterCriticalSection();

	call	?VuEnterCriticalSection@@YAXXZ		; VuEnterCriticalSection

; 32   : 	nextqueue_     = queuecollhead_;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ?queuecollhead_@VuMessageQueue@@0PAV1@A ; VuMessageQueue::queuecollhead_
	mov	DWORD PTR [edx+24], eax

; 33   : 	queuecollhead_ = this;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR ?queuecollhead_@VuMessageQueue@@0PAV1@A, ecx ; VuMessageQueue::queuecollhead_

; 34   : 	VuExitCriticalSection();

	call	?VuExitCriticalSection@@YAXXZ		; VuExitCriticalSection

; 35   : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0VuMessageQueue@@QAE@HPAVVuMessageFilter@@@Z ENDP	; VuMessageQueue::VuMessageQueue
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_thread.h
;	COMDAT ?SendQueue@VuMainThread@@QBEPAVVuPendingSendQueue@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SendQueue@VuMainThread@@QBEPAVVuPendingSendQueue@@XZ PROC ; VuMainThread::SendQueue, COMDAT
; _this$ = ecx

; 92   : 	VuPendingSendQueue *SendQueue() const { return const_cast<VuMainThread*>(this)->sendQueue_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?SendQueue@VuMainThread@@QBEPAVVuPendingSendQueue@@XZ ENDP ; VuMainThread::SendQueue
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vusessn.h
;	COMDAT ?Connected@VuGlobalGroup@@QAEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Connected@VuGlobalGroup@@QAEEXZ PROC			; VuGlobalGroup::Connected, COMDAT
; _this$ = ecx

; 472  : 	VU_BOOL Connected() { return connected_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+344]
	mov	esp, ebp
	pop	ebp
	ret	0
?Connected@VuGlobalGroup@@QAEEXZ ENDP			; VuGlobalGroup::Connected
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VVuEntity@@@@QBEPAVVuEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VVuEntity@@@@QBEPAVVuEntity@@XZ PROC	; VuBin<VuEntity>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VVuEntity@@@@QBEPAVVuEntity@@XZ ENDP	; VuBin<VuEntity>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VVuTargetEntity@@@@QBEPAVVuTargetEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VVuTargetEntity@@@@QBEPAVVuTargetEntity@@XZ PROC ; VuBin<VuTargetEntity>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VVuTargetEntity@@@@QBEPAVVuTargetEntity@@XZ ENDP ; VuBin<VuTargetEntity>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuevent.h
;	COMDAT ?Target@VuMessage@@QBEPAVVuTargetEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Target@VuMessage@@QBEPAVVuTargetEntity@@XZ PROC	; VuMessage::Target, COMDAT
; _this$ = ecx

; 161  : 	VuTargetEntity *Target() const { return target_.get(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	?get@?$VuBin@VVuTargetEntity@@@@QBEPAVVuTargetEntity@@XZ ; VuBin<VuTargetEntity>::get
	mov	esp, ebp
	pop	ebp
	ret	0
?Target@VuMessage@@QBEPAVVuTargetEntity@@XZ ENDP	; VuMessage::Target
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuevent.h
;	COMDAT ?Entity@VuMessage@@QBEPAVVuEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Entity@VuMessage@@QBEPAVVuEntity@@XZ PROC		; VuMessage::Entity, COMDAT
; _this$ = ecx

; 159  : 	VuEntity *Entity() const { return ent_.get(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	call	?get@?$VuBin@VVuEntity@@@@QBEPAVVuEntity@@XZ ; VuBin<VuEntity>::get
	mov	esp, ebp
	pop	ebp
	ret	0
?Entity@VuMessage@@QBEPAVVuEntity@@XZ ENDP		; VuMessage::Entity
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuevent.h
;	COMDAT ?Flags@VuMessage@@QBEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Flags@VuMessage@@QBEEXZ PROC				; VuMessage::Flags, COMDAT
; _this$ = ecx

; 158  : 	VU_BYTE Flags() const { return flags_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+6]
	mov	esp, ebp
	pop	ebp
	ret	0
?Flags@VuMessage@@QBEEXZ ENDP				; VuMessage::Flags
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuevent.h
;	COMDAT ?EntityId@VuMessage@@QBE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?EntityId@VuMessage@@QBE?AVVU_ID@@XZ PROC		; VuMessage::EntityId, COMDAT
; _this$ = ecx

; 157  : 	VU_ID EntityId() const { return entityId_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?EntityId@VuMessage@@QBE?AVVU_ID@@XZ ENDP		; VuMessage::EntityId
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuevent.h
;	COMDAT ?Type@VuMessage@@QBEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Type@VuMessage@@QBEEXZ PROC				; VuMessage::Type, COMDAT
; _this$ = ecx

; 153  : 	VU_MSG_TYPE Type() const { return type_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+5]
	mov	esp, ebp
	pop	ebp
	ret	0
?Type@VuMessage@@QBEEXZ ENDP				; VuMessage::Type
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ PROC ; VuBin<VuSessionEntity>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ENDP ; VuBin<VuSessionEntity>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?IsPrivate@VuEntity@@QBEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsPrivate@VuEntity@@QBEEXZ PROC			; VuEntity::IsPrivate, COMDAT
; _this$ = ecx

; 134  : 	VU_BOOL IsPrivate() const       { return (VU_BOOL)share_.flags_.breakdown_.private_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPrivate@VuEntity@@QBEEXZ ENDP			; VuEntity::IsPrivate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?SetTransmissionTime@VuEntity@@QAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_currentTime$ = 8					; size = 4
?SetTransmissionTime@VuEntity@@QAEXK@Z PROC		; VuEntity::SetTransmissionTime, COMDAT
; _this$ = ecx

; 120  : 	void SetTransmissionTime(VU_TIME currentTime){ lastTransmissionTime_ = currentTime; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _currentTime$[ebp]
	mov	DWORD PTR [eax+108], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetTransmissionTime@VuEntity@@QAEXK@Z ENDP		; VuEntity::SetTransmissionTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
;	COMDAT ??9VU_SESSION_ID@@QBEHABV0@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_rhs$ = 8						; size = 4
??9VU_SESSION_ID@@QBEHABV0@@Z PROC			; VU_SESSION_ID::operator!=, COMDAT
; _this$ = ecx

; 59   : 	int operator != (const VU_SESSION_ID &rhs) const { 

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 60   : 		return (value_ != rhs.value_ ? TRUE : FALSE); 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	je	SHORT $LN3@operator
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv67[ebp], 0
$LN4@operator:
	mov	eax, DWORD PTR tv67[ebp]

; 61   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
??9VU_SESSION_ID@@QBEHABV0@@Z ENDP			; VU_SESSION_ID::operator!=
_TEXT	ENDS
END
