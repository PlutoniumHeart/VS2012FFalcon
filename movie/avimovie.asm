; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\movie\avimovie.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
_numOfMovies DD	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
_abortMovie DD	01H
_DATA	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
PUBLIC	_movieInit
PUBLIC	_movieUnInit
PUBLIC	_movieOpen
PUBLIC	_movieClose
PUBLIC	_movieStart
PUBLIC	_movieStop
PUBLIC	_movieIsPlaying
PUBLIC	_movieCount
PUBLIC	_movieGetLastError
PUBLIC	??_C@_0BF@KBGFNKNN@Movie?5open?5?$FLENTER?$FN?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BA@MPFNLFK@Movie?5aborted?4?6?$AA@	; `string'
PUBLIC	??_C@_0BP@LAEPMALO@No?5slots?5available?5for?5movie?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BE@KHDDDMJC@Movie?5open?5failed?4?6?$AA@	; `string'
PUBLIC	??_C@_0BI@BEMFGEKH@Unsupported?5bit?5depth?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BL@GJIIPJPD@Compressor?5open?$CI?$CJ?5failed?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BC@PPNGHBLD@Unsupported?5DIB?4?6?$AA@	; `string'
PUBLIC	??_C@_0BG@HMJCPNEL@No?5memory?5for?5movie?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BE@ENGGGLMF@Movie?5open?5?$FLEXIT?$FN?4?6?$AA@ ; `string'
PUBLIC	__real@3f000000
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__InitializeCriticalSection@4:PROC
EXTRN	__imp__EnterCriticalSection@4:PROC
EXTRN	__imp__LeaveCriticalSection@4:PROC
EXTRN	__imp__DeleteCriticalSection@4:PROC
EXTRN	__imp__WaitForSingleObject@8:PROC
EXTRN	__imp__Sleep@4:PROC
EXTRN	__imp__GetCurrentThreadId@0:PROC
EXTRN	__imp__timeGetTime@0:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	_F4CreateStream:PROC
EXTRN	_F4StreamPlayed:PROC
EXTRN	_F4StartCallbackStream:PROC
EXTRN	_F4StopStream:PROC
EXTRN	_F4SetStreamVolume:PROC
EXTRN	_ICSendMessage@16:PROC
EXTRN	_ICDecompress:PROC
EXTRN	_ICLocate@20:PROC
EXTRN	__beginthreadex:PROC
EXTRN	_close:PROC
EXTRN	_open:PROC
EXTRN	_read:PROC
EXTRN	_aviOpen:PROC
EXTRN	_aviClose:PROC
EXTRN	_aviReadRecord:PROC
EXTRN	_waveReadBlock:PROC
EXTRN	_surfaceGetPointer:PROC
EXTRN	_surfaceReleasePointer:PROC
EXTRN	_surfaceGetDescription:PROC
EXTRN	_surfaceCreate:PROC
EXTRN	_surfaceRelease:PROC
EXTRN	_surfaceBlit:PROC
EXTRN	_MonoPrint:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_ddPointer DD	01H DUP (?)
_movie	DD	01H DUP (?)
_movieCriticalSection DB 018H DUP (?)
_BSS	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT ??_C@_0BE@ENGGGLMF@Movie?5open?5?$FLEXIT?$FN?4?6?$AA@
CONST	SEGMENT
??_C@_0BE@ENGGGLMF@Movie?5open?5?$FLEXIT?$FN?4?6?$AA@ DB 'Movie open [EXI'
	DB	'T].', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HMJCPNEL@No?5memory?5for?5movie?4?6?$AA@
CONST	SEGMENT
??_C@_0BG@HMJCPNEL@No?5memory?5for?5movie?4?6?$AA@ DB 'No memory for movi'
	DB	'e.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PPNGHBLD@Unsupported?5DIB?4?6?$AA@
CONST	SEGMENT
??_C@_0BC@PPNGHBLD@Unsupported?5DIB?4?6?$AA@ DB 'Unsupported DIB.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@GJIIPJPD@Compressor?5open?$CI?$CJ?5failed?4?6?$AA@
CONST	SEGMENT
??_C@_0BL@GJIIPJPD@Compressor?5open?$CI?$CJ?5failed?4?6?$AA@ DB 'Compress'
	DB	'or open() failed.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@BEMFGEKH@Unsupported?5bit?5depth?4?6?$AA@
CONST	SEGMENT
??_C@_0BI@BEMFGEKH@Unsupported?5bit?5depth?4?6?$AA@ DB 'Unsupported bit d'
	DB	'epth.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KHDDDMJC@Movie?5open?5failed?4?6?$AA@
CONST	SEGMENT
??_C@_0BE@KHDDDMJC@Movie?5open?5failed?4?6?$AA@ DB 'Movie open failed.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@LAEPMALO@No?5slots?5available?5for?5movie?4?6?$AA@
CONST	SEGMENT
??_C@_0BP@LAEPMALO@No?5slots?5available?5for?5movie?4?6?$AA@ DB 'No slots'
	DB	' available for movie.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MPFNLFK@Movie?5aborted?4?6?$AA@
CONST	SEGMENT
??_C@_0BA@MPFNLFK@Movie?5aborted?4?6?$AA@ DB 'Movie aborted.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@KBGFNKNN@Movie?5open?5?$FLENTER?$FN?4?6?$AA@
CONST	SEGMENT
??_C@_0BF@KBGFNKNN@Movie?5open?5?$FLENTER?$FN?4?6?$AA@ DB 'Movie open [EN'
	DB	'TER].', 0aH, 00H				; `string'
CONST	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\movie\avimovie.cpp
_TEXT	SEGMENT
_movieHandle$ = -36					; size = 4
_filler$ = -32						; size = 4
_item$ = -28						; size = 4
_fillerSize$ = -24					; size = 4
_ptr$ = -20						; size = 4
_size$ = -16						; size = 4
_dsb$ = -12						; size = 4
_dataToCopy$ = -8					; size = 4
_streams$ = -4						; size = 4
_me$ = 8						; size = 4
_soundBuffer$ = 12					; size = 4
_length$ = 16						; size = 4
?fillSoundBuffer@@YAKPAXPADK@Z PROC			; fillSoundBuffer

; 1278 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 1279 : //   AUDIO_ITEM  *audio;
; 1280 :    int         movieHandle, fillerSize, dataToCopy, filler;
; 1281 :    int         size;
; 1282 :    PMOVIE      item;
; 1283 :    PAVISTREAMS streams;
; 1284 :    char        *ptr, *dsb;
; 1285 : 
; 1286 : //   audio = AudioGetItem( item_handle );
; 1287 : //   movieHandle = audio->user_data[0];
; 1288 : 
; 1289 :    movieHandle=*((int*)me);

	mov	eax, DWORD PTR _me$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _movieHandle$[ebp], ecx

; 1290 :    item = &( movie[movieHandle] );

	mov	edx, DWORD PTR _movieHandle$[ebp]
	imul	edx, 880				; 00000370H
	add	edx, DWORD PTR _movie
	mov	DWORD PTR _item$[ebp], edx

; 1291 :    if ( !( item->status & MOVIE_STATUS_PLAYING ) )

	mov	eax, DWORD PTR _item$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	and	ecx, 1
	jne	SHORT $LN9@fillSoundB

; 1292 :       return 0;

	xor	eax, eax
	jmp	$LN10@fillSoundB
$LN9@fillSoundB:

; 1293 : 
; 1294 :    streams = &( item->aviStreams );

	mov	edx, DWORD PTR _item$[ebp]
	add	edx, 128				; 00000080H
	mov	DWORD PTR _streams$[ebp], edx

; 1295 : 
; 1296 :    ptr = streams->waveBuffer + streams->waveBufferRead;

	mov	eax, DWORD PTR _streams$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	mov	edx, DWORD PTR _streams$[ebp]
	add	ecx, DWORD PTR [edx+300]
	mov	DWORD PTR _ptr$[ebp], ecx

; 1297 :    dsb = ( char * ) soundBuffer;

	mov	eax, DWORD PTR _soundBuffer$[ebp]
	mov	DWORD PTR _dsb$[ebp], eax

; 1298 : 
; 1299 :    EnterCriticalSection( &( streams->criticalSection ) );

	mov	ecx, DWORD PTR _streams$[ebp]
	add	ecx, 704				; 000002c0H
	push	ecx
	call	DWORD PTR __imp__EnterCriticalSection@4

; 1300 : 
; 1301 :    if ( streams->dataInWaveBuffer > ( DWORD ) length )

	mov	edx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR [edx+288]
	cmp	eax, DWORD PTR _length$[ebp]
	jbe	SHORT $LN8@fillSoundB

; 1302 :    {
; 1303 :       fillerSize = 0;

	mov	DWORD PTR _fillerSize$[ebp], 0

; 1304 :       dataToCopy = length;

	mov	ecx, DWORD PTR _length$[ebp]
	mov	DWORD PTR _dataToCopy$[ebp], ecx

; 1305 :    }
; 1306 :    else

	jmp	SHORT $LN7@fillSoundB
$LN8@fillSoundB:

; 1307 :    {
; 1308 :       fillerSize = length - streams->dataInWaveBuffer;

	mov	edx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR _length$[ebp]
	sub	eax, DWORD PTR [edx+288]
	mov	DWORD PTR _fillerSize$[ebp], eax

; 1309 :       dataToCopy = streams->dataInWaveBuffer;

	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR [ecx+288]
	mov	DWORD PTR _dataToCopy$[ebp], edx
$LN7@fillSoundB:

; 1310 :    }
; 1311 : 
; 1312 :    streams->dataInWaveBuffer -= dataToCopy;

	mov	eax, DWORD PTR _streams$[ebp]
	mov	ecx, DWORD PTR [eax+288]
	sub	ecx, DWORD PTR _dataToCopy$[ebp]
	mov	edx, DWORD PTR _streams$[ebp]
	mov	DWORD PTR [edx+288], ecx

; 1313 : 
; 1314 :    LeaveCriticalSection( &( streams->criticalSection ) );

	mov	eax, DWORD PTR _streams$[ebp]
	add	eax, 704				; 000002c0H
	push	eax
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 1315 : 
; 1316 :    if ( dataToCopy )

	cmp	DWORD PTR _dataToCopy$[ebp], 0
	je	$LN6@fillSoundB

; 1317 :    {
; 1318 :       size = streams->waveBufferRead + dataToCopy;

	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR [ecx+300]
	add	edx, DWORD PTR _dataToCopy$[ebp]
	mov	DWORD PTR _size$[ebp], edx

; 1319 :       size -= streams->waveBufferLen;

	mov	eax, DWORD PTR _streams$[ebp]
	mov	ecx, DWORD PTR _size$[ebp]
	sub	ecx, DWORD PTR [eax+292]
	mov	DWORD PTR _size$[ebp], ecx

; 1320 : 
; 1321 :       if ( size <= 0 )

	cmp	DWORD PTR _size$[ebp], 0
	jg	SHORT $LN5@fillSoundB

; 1322 :       {
; 1323 :          memcpy( dsb, ptr, dataToCopy );

	mov	edx, DWORD PTR _dataToCopy$[ebp]
	push	edx
	mov	eax, DWORD PTR _ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dsb$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1324 :          ptr += dataToCopy;

	mov	edx, DWORD PTR _ptr$[ebp]
	add	edx, DWORD PTR _dataToCopy$[ebp]
	mov	DWORD PTR _ptr$[ebp], edx

; 1325 :          dsb += dataToCopy;

	mov	eax, DWORD PTR _dsb$[ebp]
	add	eax, DWORD PTR _dataToCopy$[ebp]
	mov	DWORD PTR _dsb$[ebp], eax

; 1326 :          streams->waveBufferRead += dataToCopy;

	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR [ecx+300]
	add	edx, DWORD PTR _dataToCopy$[ebp]
	mov	eax, DWORD PTR _streams$[ebp]
	mov	DWORD PTR [eax+300], edx

; 1327 :          if ( !size )

	cmp	DWORD PTR _size$[ebp], 0
	jne	SHORT $LN4@fillSoundB

; 1328 :             streams->waveBufferRead = 0;

	mov	ecx, DWORD PTR _streams$[ebp]
	mov	DWORD PTR [ecx+300], 0
$LN4@fillSoundB:

; 1329 :       }
; 1330 :       else

	jmp	SHORT $LN6@fillSoundB
$LN5@fillSoundB:

; 1331 :       {
; 1332 :          dataToCopy = streams->waveBufferLen -
; 1333 :                         streams->waveBufferRead;

	mov	edx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR _streams$[ebp]
	mov	ecx, DWORD PTR [edx+292]
	sub	ecx, DWORD PTR [eax+300]
	mov	DWORD PTR _dataToCopy$[ebp], ecx

; 1334 :          memcpy( dsb, ptr, dataToCopy );

	mov	edx, DWORD PTR _dataToCopy$[ebp]
	push	edx
	mov	eax, DWORD PTR _ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dsb$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1335 :          ptr = streams->waveBuffer;

	mov	edx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR [edx+284]
	mov	DWORD PTR _ptr$[ebp], eax

; 1336 :          dsb += dataToCopy;

	mov	ecx, DWORD PTR _dsb$[ebp]
	add	ecx, DWORD PTR _dataToCopy$[ebp]
	mov	DWORD PTR _dsb$[ebp], ecx

; 1337 :          memcpy( dsb, ptr, size );

	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	mov	eax, DWORD PTR _ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dsb$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1338 :          streams->waveBufferRead = size;

	mov	edx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR [edx+300], eax

; 1339 :          dsb += size;

	mov	ecx, DWORD PTR _dsb$[ebp]
	add	ecx, DWORD PTR _size$[ebp]
	mov	DWORD PTR _dsb$[ebp], ecx
$LN6@fillSoundB:

; 1340 :       }
; 1341 :    }
; 1342 : 
; 1343 :    if ( fillerSize )

	cmp	DWORD PTR _fillerSize$[ebp], 0
	je	SHORT $LN2@fillSoundB

; 1344 :    {
; 1345 :       filler = 0x80;

	mov	DWORD PTR _filler$[ebp], 128		; 00000080H

; 1346 :       if ( streams->waveFormat.wBitsPerSample != 8 )

	mov	edx, DWORD PTR _streams$[ebp]
	movzx	eax, WORD PTR [edx+278]
	cmp	eax, 8
	je	SHORT $LN1@fillSoundB

; 1347 :          filler = 0;

	mov	DWORD PTR _filler$[ebp], 0
$LN1@fillSoundB:

; 1348 : 
; 1349 :       memset( dsb, filler, fillerSize );

	mov	ecx, DWORD PTR _fillerSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _filler$[ebp]
	push	edx
	mov	eax, DWORD PTR _dsb$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
$LN2@fillSoundB:

; 1350 :    }
; 1351 : 
; 1352 :    return length;

	mov	eax, DWORD PTR _length$[ebp]
$LN10@fillSoundB:

; 1353 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?fillSoundBuffer@@YAKPAXPADK@Z ENDP			; fillSoundBuffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\movie\avimovie.cpp
_TEXT	SEGMENT
_streams$ = -40						; size = 4
_padding$ = -36						; size = 4
tv179 = -32						; size = 4
tv132 = -28						; size = 4
_height$ = -24						; size = 4
_width$ = -20						; size = 4
_buffer$ = -16						; size = 4
_i$ = -12						; size = 4
_sa$ = -8						; size = 4
_tempPtr$ = -4						; size = 4
_item$ = 8						; size = 4
?doFrame@@YAXPAUtagMOVIE@@@Z PROC			; doFrame

; 137  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 138  :    char           *tempPtr, *buffer;
; 139  :    int            padding, width, height;
; 140  :    int            i;
; 141  :    SURFACEACCESS  *sa;
; 142  :    AVISTREAMS     *streams;
; 143  : 
; 144  : #ifdef MEASURE_TIME
; 145  : 
; 146  : 	double diff;
; 147  : 
; 148  : 	if(!once) {
; 149  : 
; 150  : 		_ftime(&now);
; 151  : 		once = TRUE;
; 152  : 	}
; 153  : 	else {
; 154  : 
; 155  : 		last.time		= now.time;
; 156  : 		last.millitm	= now.millitm;
; 157  : 
; 158  : 		_ftime(&now);
; 159  : 
; 160  : 		diff			= (now.time + now.millitm / 1000.0) - (last.time + last.millitm / 1000.0);
; 161  : 		total			+= diff;
; 162  : 		count++;
; 163  : 	}
; 164  : 
; 165  : #endif
; 166  : 
; 167  :    streams = &( item->aviStreams );

	mov	eax, DWORD PTR _item$[ebp]
	add	eax, 128				; 00000080H
	mov	DWORD PTR _streams$[ebp], eax

; 168  : 
; 169  :    if ( item->sbType & SURFACE_TYPE_SYSTEM )

	mov	ecx, DWORD PTR _item$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	and	edx, 1
	je	$LN21@doFrame

; 170  :    {
; 171  :       width = item->aviStreams.bihIn.biWidth *
; 172  :                          item->pixelSize;          // width in bytes

	mov	eax, DWORD PTR _item$[ebp]
	mov	ecx, DWORD PTR _item$[ebp]
	mov	edx, DWORD PTR [eax+292]
	imul	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR _width$[ebp], edx

; 173  :       height = item->aviStreams.bihIn.biHeight;

	mov	eax, DWORD PTR _item$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	DWORD PTR _height$[ebp], ecx

; 174  :       buffer = ( char * ) item->surfaceBuffer;     // bitmap to render

	mov	edx, DWORD PTR _item$[ebp]
	mov	eax, DWORD PTR [edx+68]
	mov	DWORD PTR _buffer$[ebp], eax

; 175  : 
; 176  :       sa = &( item->sa );

	mov	ecx, DWORD PTR _item$[ebp]
	add	ecx, 868				; 00000364H
	mov	DWORD PTR _sa$[ebp], ecx

; 177  : 
; 178  :       /*
; 179  :          Lock surface.
; 180  :       */
; 181  :       if (  ( sa->lockStatus == SURFACE_IS_UNLOCKED ) &&
; 182  :             !( item->sbType & SURFACE_TRY_FAST ) )

	mov	edx, DWORD PTR _sa$[ebp]
	cmp	DWORD PTR [edx+8], 0
	jne	SHORT $LN20@doFrame
	mov	eax, DWORD PTR _item$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	and	ecx, 4
	jne	SHORT $LN20@doFrame

; 183  :       {
; 184  :          surfaceGetPointer( item->ddSurface, sa );

	mov	edx, DWORD PTR _sa$[ebp]
	push	edx
	mov	eax, DWORD PTR _item$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_surfaceGetPointer
	add	esp, 8

; 185  :          if ( sa->lockStatus == SURFACE_IS_UNLOCKED )

	mov	edx, DWORD PTR _sa$[ebp]
	cmp	DWORD PTR [edx+8], 0
	jne	SHORT $LN20@doFrame

; 186  :             return;

	jmp	$LN22@doFrame
$LN20@doFrame:

; 187  :       }
; 188  : 
; 189  :       tempPtr = ( char * ) sa->surfacePtr;         // get pointer to the surface

	mov	eax, DWORD PTR _sa$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _tempPtr$[ebp], ecx

; 190  :       tempPtr += item->startY * sa->lPitch;        // get startY address

	mov	edx, DWORD PTR _item$[ebp]
	mov	eax, DWORD PTR _sa$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	imul	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _tempPtr$[ebp]
	mov	DWORD PTR _tempPtr$[ebp], ecx

; 191  :       tempPtr += item->startX * item->pixelSize;   // get upper left address

	mov	edx, DWORD PTR _item$[ebp]
	mov	eax, DWORD PTR _item$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	imul	ecx, DWORD PTR [eax+76]
	add	ecx, DWORD PTR _tempPtr$[ebp]
	mov	DWORD PTR _tempPtr$[ebp], ecx

; 192  :       padding = sa->lPitch -  width;               // offset to next scan line

	mov	edx, DWORD PTR _sa$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, DWORD PTR _width$[ebp]
	mov	DWORD PTR _padding$[ebp], eax

; 193  : 
; 194  :       switch ( item->videoMode )

	mov	ecx, DWORD PTR _item$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	DWORD PTR tv132[ebp], edx
	cmp	DWORD PTR tv132[ebp], 1
	je	SHORT $LN16@doFrame
	cmp	DWORD PTR tv132[ebp], 2
	je	SHORT $LN12@doFrame
	jmp	$LN8@doFrame
$LN16@doFrame:

; 195  :       {
; 196  :          case MOVIE_MODE_V_DOUBLE:
; 197  :             for ( i = 0; i < height; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN15@doFrame
$LN14@doFrame:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN15@doFrame:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _height$[ebp]
	jge	SHORT $LN13@doFrame

; 198  :             {
; 199  :                memcpy( tempPtr, buffer, width );

	mov	edx, DWORD PTR _width$[ebp]
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tempPtr$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 200  :                tempPtr += sa->lPitch;

	mov	edx, DWORD PTR _sa$[ebp]
	mov	eax, DWORD PTR _tempPtr$[ebp]
	add	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _tempPtr$[ebp], eax

; 201  : 
; 202  :                memcpy( tempPtr, buffer, width );

	mov	ecx, DWORD PTR _width$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _tempPtr$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 203  :                tempPtr += sa->lPitch;

	mov	ecx, DWORD PTR _sa$[ebp]
	mov	edx, DWORD PTR _tempPtr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _tempPtr$[ebp], edx

; 204  :                buffer += width;

	mov	eax, DWORD PTR _buffer$[ebp]
	add	eax, DWORD PTR _width$[ebp]
	mov	DWORD PTR _buffer$[ebp], eax

; 205  :             }

	jmp	SHORT $LN14@doFrame
$LN13@doFrame:

; 206  :             break;

	jmp	$LN17@doFrame
$LN12@doFrame:

; 207  : 
; 208  : 
; 209  :          case MOVIE_MODE_INTERLACE:
; 210  :             for ( i = 0; i < height; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN11@doFrame
$LN10@doFrame:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN11@doFrame:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _height$[ebp]
	jge	SHORT $LN9@doFrame

; 211  :             {
; 212  :                memcpy( tempPtr, buffer, width );

	mov	eax, DWORD PTR _width$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tempPtr$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 213  :                tempPtr += sa->lPitch + sa->lPitch;

	mov	eax, DWORD PTR _sa$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _sa$[ebp]
	add	ecx, DWORD PTR [edx+4]
	add	ecx, DWORD PTR _tempPtr$[ebp]
	mov	DWORD PTR _tempPtr$[ebp], ecx

; 214  :                buffer += width;

	mov	eax, DWORD PTR _buffer$[ebp]
	add	eax, DWORD PTR _width$[ebp]
	mov	DWORD PTR _buffer$[ebp], eax

; 215  :             }

	jmp	SHORT $LN10@doFrame
$LN9@doFrame:

; 216  :             break;

	jmp	SHORT $LN17@doFrame
$LN8@doFrame:

; 217  : 
; 218  :          default:
; 219  :             if ( padding )

	cmp	DWORD PTR _padding$[ebp], 0
	je	SHORT $LN7@doFrame

; 220  :                for ( i = 0; i < height; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@doFrame
$LN5@doFrame:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN6@doFrame:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _height$[ebp]
	jge	SHORT $LN4@doFrame

; 221  :                {
; 222  :                   memcpy( tempPtr, buffer, width );

	mov	eax, DWORD PTR _width$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tempPtr$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 223  :                   tempPtr += sa->lPitch;

	mov	eax, DWORD PTR _sa$[ebp]
	mov	ecx, DWORD PTR _tempPtr$[ebp]
	add	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _tempPtr$[ebp], ecx

; 224  :                   buffer += width;

	mov	edx, DWORD PTR _buffer$[ebp]
	add	edx, DWORD PTR _width$[ebp]
	mov	DWORD PTR _buffer$[ebp], edx

; 225  :                }

	jmp	SHORT $LN5@doFrame
$LN4@doFrame:
	jmp	SHORT $LN17@doFrame
$LN7@doFrame:

; 226  :             else
; 227  :                memcpy( tempPtr, buffer, width * height );

	mov	eax, DWORD PTR _width$[ebp]
	imul	eax, DWORD PTR _height$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tempPtr$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN17@doFrame:

; 228  :             break;
; 229  :       }
; 230  : 
; 231  :       if ( sa->lockStatus == SURFACE_IS_LOCKED )

	mov	eax, DWORD PTR _sa$[ebp]
	cmp	DWORD PTR [eax+8], 1
	jne	SHORT $LN2@doFrame

; 232  :          surfaceReleasePointer( item->ddSurface, sa );

	mov	ecx, DWORD PTR _sa$[ebp]
	push	ecx
	mov	edx, DWORD PTR _item$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_surfaceReleasePointer
	add	esp, 8
$LN2@doFrame:

; 233  :    }
; 234  :    else

	jmp	SHORT $LN22@doFrame
$LN21@doFrame:

; 235  :    {
; 236  :       surfaceBlit( item->ddSurface, item->startX, item->startY,
; 237  :             item->surfaceBuffer, item->aviStreams.bihIn.biWidth,
; 238  :             item->aviStreams.bihIn.biHeight,
; 239  :             ( item->videoMode == MOVIE_MODE_NORMAL ) ?
; 240  :                BLIT_MODE_NORMAL : BLIT_MODE_DOUBLE_V );

	mov	ecx, DWORD PTR _item$[ebp]
	cmp	DWORD PTR [ecx+72], 0
	jne	SHORT $LN24@doFrame
	mov	DWORD PTR tv179[ebp], 0
	jmp	SHORT $LN25@doFrame
$LN24@doFrame:
	mov	DWORD PTR tv179[ebp], 1
$LN25@doFrame:
	mov	edx, DWORD PTR tv179[ebp]
	push	edx
	mov	eax, DWORD PTR _item$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	push	ecx
	mov	edx, DWORD PTR _item$[ebp]
	mov	eax, DWORD PTR [edx+292]
	push	eax
	mov	ecx, DWORD PTR _item$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	push	edx
	mov	eax, DWORD PTR _item$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _item$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _item$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_surfaceBlit
	add	esp, 28					; 0000001cH
$LN22@doFrame:

; 241  :    }
; 242  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?doFrame@@YAXPAUtagMOVIE@@@Z ENDP			; doFrame
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\movie\avimovie.cpp
_TEXT	SEGMENT
_exitCode$ = -16					; size = 4
_status$ = -12						; size = 4
_streams$ = -8						; size = 4
_item$ = -4						; size = 4
_itemIn$ = 8						; size = 4
?fillerThread@@YGIPAX@Z PROC				; fillerThread

; 979  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 980  :    int            status;
; 981  :    int            exitCode;
; 982  :    PAVISTREAMS    streams;
; 983  :    PMOVIE item = (PMOVIE)itemIn;

	mov	eax, DWORD PTR _itemIn$[ebp]
	mov	DWORD PTR _item$[ebp], eax

; 984  : 
; 985  :    exitCode = MOVIE_OK;

	mov	DWORD PTR _exitCode$[ebp], 0

; 986  :    streams = &( item->aviStreams );

	mov	ecx, DWORD PTR _item$[ebp]
	add	ecx, 128				; 00000080H
	mov	DWORD PTR _streams$[ebp], ecx
$LN10@fillerThre:

; 987  : 
; 988  :    while ( !( ( item->status & MOVIE_STATUS_QUIT ) ||
; 989  :             ( item->status & MOVIE_STATUS_STOP_THREAD ) ) )

	mov	edx, DWORD PTR _item$[ebp]
	mov	eax, DWORD PTR [edx+96]
	and	eax, 4
	jne	$LN9@fillerThre
	mov	ecx, DWORD PTR _item$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	and	edx, 64					; 00000040H
	jne	$LN9@fillerThre

; 990  :    {
; 991  :       /*
; 992  :          Read only if there are free blocks.
; 993  :       */
; 994  : 
; 995  :       if ( !streams->nextBlockToFill->currentBlockSize )

	mov	eax, DWORD PTR _streams$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	cmp	DWORD PTR [ecx+4], 0
	jne	$LN8@fillerThre

; 996  :       {
; 997  :          if ( item->status & MOVIE_STATUS_EOF )

	mov	edx, DWORD PTR _item$[ebp]
	mov	eax, DWORD PTR [edx+96]
	and	eax, 2
	je	SHORT $LN7@fillerThre

; 998  :             break;

	jmp	$LN9@fillerThre
$LN7@fillerThre:

; 999  : 
; 1000 :          status = aviReadRecord( streams );

	mov	ecx, DWORD PTR _streams$[ebp]
	push	ecx
	call	_aviReadRecord
	add	esp, 4
	mov	DWORD PTR _status$[ebp], eax

; 1001 : 
; 1002 :          if ( status < RIFF_OK )

	cmp	DWORD PTR _status$[ebp], 0
	jge	SHORT $LN6@fillerThre

; 1003 :          {
; 1004 :             item->lastError = exitCode = MOVIE_THREAD_BAD_FILE;

	mov	DWORD PTR _exitCode$[ebp], -11		; fffffff5H
	mov	edx, DWORD PTR _item$[ebp]
	mov	eax, DWORD PTR _exitCode$[ebp]
	mov	DWORD PTR [edx+864], eax

; 1005 :             item->status |= MOVIE_STATUS_STOP_THREAD;

	mov	ecx, DWORD PTR _item$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	or	edx, 64					; 00000040H
	mov	eax, DWORD PTR _item$[ebp]
	mov	DWORD PTR [eax+96], edx

; 1006 :             break;

	jmp	$LN9@fillerThre
$LN6@fillerThre:

; 1007 :          }
; 1008 : 
; 1009 :          if ( status == RIFF_END_FILE )

	cmp	DWORD PTR _status$[ebp], 1
	jne	SHORT $LN5@fillerThre

; 1010 :             item->status |= MOVIE_STATUS_EOF;

	mov	ecx, DWORD PTR _item$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	or	edx, 2
	mov	eax, DWORD PTR _item$[ebp]
	mov	DWORD PTR [eax+96], edx
$LN5@fillerThre:

; 1011 : 
; 1012 :          /*
; 1013 :             Read audio data from an external sound file.
; 1014 :          */
; 1015 : 
; 1016 :          if ( ( streams->audioFlag & STREAM_AUDIO_EXTERNAL ) &&
; 1017 :                !( item->status & MOVIE_STATUS_AUDIO_EOF ) &&
; 1018 :                !( streams->audioFlag & STREAM_AUDIO_PRELOAD ) )

	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	and	edx, 2
	je	SHORT $LN4@fillerThre
	mov	eax, DWORD PTR _item$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	and	ecx, 8
	jne	SHORT $LN4@fillerThre
	mov	edx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 4
	jne	SHORT $LN4@fillerThre

; 1019 :          {
; 1020 :             status = waveReadBlock( streams );

	mov	ecx, DWORD PTR _streams$[ebp]
	push	ecx
	call	_waveReadBlock
	add	esp, 4
	mov	DWORD PTR _status$[ebp], eax

; 1021 : 
; 1022 :             if ( status < RIFF_OK )

	cmp	DWORD PTR _status$[ebp], 0
	jge	SHORT $LN3@fillerThre

; 1023 :             {
; 1024 :                item->lastError = exitCode = MOVIE_THREAD_BAD_AUDIO_FILE;

	mov	DWORD PTR _exitCode$[ebp], -12		; fffffff4H
	mov	edx, DWORD PTR _item$[ebp]
	mov	eax, DWORD PTR _exitCode$[ebp]
	mov	DWORD PTR [edx+864], eax

; 1025 :                item->status |= MOVIE_STATUS_STOP_THREAD;

	mov	ecx, DWORD PTR _item$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	or	edx, 64					; 00000040H
	mov	eax, DWORD PTR _item$[ebp]
	mov	DWORD PTR [eax+96], edx

; 1026 :                break;

	jmp	SHORT $LN9@fillerThre
$LN3@fillerThre:

; 1027 :             }
; 1028 : 
; 1029 :             if ( status == RIFF_AUDIO_END_FILE )

	cmp	DWORD PTR _status$[ebp], 2
	jne	SHORT $LN4@fillerThre

; 1030 :                item->status |= MOVIE_STATUS_AUDIO_EOF;

	mov	ecx, DWORD PTR _item$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	or	edx, 8
	mov	eax, DWORD PTR _item$[ebp]
	mov	DWORD PTR [eax+96], edx
$LN4@fillerThre:

; 1031 :          }
; 1032 :       }
; 1033 :       else

	jmp	SHORT $LN1@fillerThre
$LN8@fillerThre:

; 1034 :          Sleep( 0 );

	push	0
	call	DWORD PTR __imp__Sleep@4
$LN1@fillerThre:

; 1035 :    }

	jmp	$LN10@fillerThre
$LN9@fillerThre:

; 1036 : 
; 1037 :    return ( unsigned int ) exitCode;

	mov	eax, DWORD PTR _exitCode$[ebp]

; 1038 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?fillerThread@@YGIPAX@Z ENDP				; fillerThread
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\movie\avimovie.cpp
_TEXT	SEGMENT
_sa$ = -56						; size = 12
_timeBegin$1 = -44					; size = 4
_test$2 = -40						; size = 4
_errorCode$ = -36					; size = 4
_bytesProcessed$3 = -32					; size = 4
_firstTime$ = -28					; size = 4
_dropFlag$ = -24					; size = 4
_timeElapsed$ = -20					; size = 4
_timeFrames$ = -16					; size = 4
_exitCode$ = -12					; size = 4
_streams$ = -8						; size = 4
_item$ = -4						; size = 4
_itemIn$ = 8						; size = 4
?movieThread@@YGIPAX@Z PROC				; movieThread

; 1053 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H

; 1054 :    int            timeFrames, dropFlag;
; 1055 :    int            exitCode;
; 1056 :    unsigned long  timeElapsed, firstTime;
; 1057 :    DWORD          errorCode;
; 1058 :    SURFACEACCESS  sa;
; 1059 :    PAVISTREAMS    streams;
; 1060 :    PMOVIE item = (PMOVIE)itemIn;

	mov	eax, DWORD PTR _itemIn$[ebp]
	mov	DWORD PTR _item$[ebp], eax

; 1061 : 
; 1062 :    firstTime = TRUE;

	mov	DWORD PTR _firstTime$[ebp], 1

; 1063 :    exitCode = MOVIE_OK;

	mov	DWORD PTR _exitCode$[ebp], 0

; 1064 :    item->status |= MOVIE_STATUS_THREAD_RUNNING;

	mov	ecx, DWORD PTR _item$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	or	edx, 32					; 00000020H
	mov	eax, DWORD PTR _item$[ebp]
	mov	DWORD PTR [eax+96], edx

; 1065 :    streams = &( item->aviStreams );

	mov	ecx, DWORD PTR _item$[ebp]
	add	ecx, 128				; 00000080H
	mov	DWORD PTR _streams$[ebp], ecx

; 1066 : 
; 1067 :    if (  ( item->sbType & SURFACE_TYPE_SYSTEM ) &&
; 1068 :          ( item->sbType & SURFACE_TRY_FAST ) )

	mov	edx, DWORD PTR _item$[ebp]
	mov	eax, DWORD PTR [edx+100]
	and	eax, 1
	je	$LN29@movieThrea
	mov	ecx, DWORD PTR _item$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	and	edx, 4
	je	SHORT $LN29@movieThrea

; 1069 :    {
; 1070 :       surfaceGetPointer( item->ddSurface, &( item->sa ) );

	mov	eax, DWORD PTR _item$[ebp]
	add	eax, 868				; 00000364H
	push	eax
	mov	ecx, DWORD PTR _item$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_surfaceGetPointer
	add	esp, 8

; 1071 :       if ( item->sa.lockStatus == SURFACE_IS_UNLOCKED )

	mov	eax, DWORD PTR _item$[ebp]
	cmp	DWORD PTR [eax+876], 0
	jne	SHORT $LN28@movieThrea

; 1072 :       {
; 1073 :          item->status |= MOVIE_STATUS_STOP_THREAD;

	mov	ecx, DWORD PTR _item$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	or	edx, 64					; 00000040H
	mov	eax, DWORD PTR _item$[ebp]
	mov	DWORD PTR [eax+96], edx

; 1074 :          item->lastError = exitCode = MOVIE_BUFFER_LOCK_FAIL;

	mov	DWORD PTR _exitCode$[ebp], -21		; ffffffebH
	mov	ecx, DWORD PTR _item$[ebp]
	mov	edx, DWORD PTR _exitCode$[ebp]
	mov	DWORD PTR [ecx+864], edx

; 1075 :          WaitForSingleObject( ( HANDLE ) item->hFillerThread, INFINITE );

	push	-1
	mov	eax, DWORD PTR _item$[ebp]
	mov	ecx, DWORD PTR [eax+116]
	push	ecx
	call	DWORD PTR __imp__WaitForSingleObject@8

; 1076 :          item->status &= ~MOVIE_STATUS_PLAYING;

	mov	edx, DWORD PTR _item$[ebp]
	mov	eax, DWORD PTR [edx+96]
	and	eax, -2					; fffffffeH
	mov	ecx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [ecx+96], eax
$LN28@movieThrea:

; 1077 :       }
; 1078 :       surfaceReleasePointer( item->ddSurface, &( item->sa ) );

	mov	edx, DWORD PTR _item$[ebp]
	add	edx, 868				; 00000364H
	push	edx
	mov	eax, DWORD PTR _item$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_surfaceReleasePointer
	add	esp, 8
$LN29@movieThrea:

; 1079 :    }
; 1080 : 
; 1081 :    while ( !( item->status & MOVIE_STATUS_QUIT ) )

	mov	edx, DWORD PTR _item$[ebp]
	mov	eax, DWORD PTR [edx+96]
	and	eax, 4
	jne	$LN26@movieThrea

; 1082 :    {
; 1083 :       /*
; 1084 :          Process a frame.
; 1085 :       */
; 1086 : 
; 1087 :       if ( streams->currentBlock->currentBlockSize )

	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR [ecx+688]
	cmp	DWORD PTR [edx+4], 0
	je	$LN25@movieThrea

; 1088 :       {
; 1089 :          if ( firstTime )

	cmp	DWORD PTR _firstTime$[ebp], 0
	je	SHORT $LN24@movieThrea

; 1090 :             timeFrames = 0;

	mov	DWORD PTR _timeFrames$[ebp], 0

; 1091 :          else

	jmp	SHORT $LN23@movieThrea
$LN24@movieThrea:

; 1092 :          {
; 1093 :             if ( streams->audioFlag & STREAM_AUDIO_ON)

	mov	eax, DWORD PTR _streams$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 1
	je	SHORT $LN22@movieThrea

; 1094 :             {
; 1095 : #if   AUDIO_ON
; 1096 :                /*
; 1097 :                   Use audio to synch up if it's on.
; 1098 :                */
; 1099 : 
; 1100 : 
; 1101 : //               timeElapsed = AudioCount( item->audioHandle,
; 1102 : //                                       AUDIO_UNIT_SIZE, AUDIO_SIZE_PLAYED );
; 1103 :                timeElapsed=F4StreamPlayed(item->audioChannel); // psound

	mov	edx, DWORD PTR _item$[ebp]
	mov	eax, DWORD PTR [edx+856]
	push	eax
	call	_F4StreamPlayed
	add	esp, 4
	mov	DWORD PTR _timeElapsed$[ebp], eax

; 1104 :                timeFrames = timeElapsed / streams->audioSizePerFrame;

	mov	ecx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR _timeElapsed$[ebp]
	xor	edx, edx
	div	DWORD PTR [ecx+24]
	mov	DWORD PTR _timeFrames$[ebp], eax

; 1105 : 
; 1106 : #else
; 1107 : 
; 1108 :                timeElapsed = timeGetTime( ) - item->startTime;
; 1109 :                timeFrames = timeElapsed / streams->timePerFrame;
; 1110 : #endif
; 1111 :             }
; 1112 :             else

	jmp	SHORT $LN21@movieThrea
$LN22@movieThrea:

; 1113 :             {
; 1114 :                /*
; 1115 :                   Use timer to synch up.
; 1116 :                */
; 1117 : 
; 1118 :                timeElapsed = timeGetTime( ) - item->startTime;

	call	DWORD PTR __imp__timeGetTime@0
	mov	edx, DWORD PTR _item$[ebp]
	sub	eax, DWORD PTR [edx+104]
	mov	DWORD PTR _timeElapsed$[ebp], eax

; 1119 :                timeFrames = timeElapsed / streams->timePerFrame;

	mov	ecx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR _timeElapsed$[ebp]
	xor	edx, edx
	div	DWORD PTR [ecx+20]
	mov	DWORD PTR _timeFrames$[ebp], eax
$LN21@movieThrea:

; 1120 :             }
; 1121 : 
; 1122 :             timeFrames -= item->totalFrames;

	mov	edx, DWORD PTR _item$[ebp]
	mov	eax, DWORD PTR _timeFrames$[ebp]
	sub	eax, DWORD PTR [edx+80]
	mov	DWORD PTR _timeFrames$[ebp], eax
$LN23@movieThrea:

; 1123 :          }
; 1124 : 
; 1125 :          if ( timeFrames > -1 )

	cmp	DWORD PTR _timeFrames$[ebp], -1
	jle	$LN20@movieThrea

; 1126 :          {
; 1127 :             /*
; 1128 :                Decompress a frame if audio/timer is behind or on time.
; 1129 :             */
; 1130 : 
; 1131 :             if ( item->sbType & SURFACE_TYPE_SYSTEM )

	mov	ecx, DWORD PTR _item$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	and	edx, 1
	je	SHORT $LN19@movieThrea

; 1132 :             {
; 1133 :                errorCode = ICDecompress( item->hIC, 0, &( streams->bihIn ),
; 1134 :                               streams->currentBlock->buffer,
; 1135 :                               ( LPBITMAPINFOHEADER )
; 1136 :                               &( item->bihOut ),
; 1137 :                               item->surfaceBuffer );

	mov	eax, DWORD PTR _item$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	push	ecx
	mov	edx, DWORD PTR _item$[ebp]
	add	edx, 16					; 00000010H
	push	edx
	mov	eax, DWORD PTR _streams$[ebp]
	mov	ecx, DWORD PTR [eax+688]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _streams$[ebp]
	add	eax, 160				; 000000a0H
	push	eax
	push	0
	mov	ecx, DWORD PTR _item$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_ICDecompress
	add	esp, 24					; 00000018H
	mov	DWORD PTR _errorCode$[ebp], eax

; 1138 :             }
; 1139 :             else

	jmp	$LN16@movieThrea
$LN19@movieThrea:

; 1140 :             {
; 1141 :                surfaceGetPointer( item->surfaceBuffer, &sa );

	lea	eax, DWORD PTR _sa$[ebp]
	push	eax
	mov	ecx, DWORD PTR _item$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	push	edx
	call	_surfaceGetPointer
	add	esp, 8

; 1142 :                if ( sa.lockStatus == SURFACE_IS_LOCKED )

	cmp	DWORD PTR _sa$[ebp+8], 1
	jne	SHORT $LN17@movieThrea

; 1143 :                {
; 1144 :                   errorCode = ICDecompress( item->hIC, 0, &( streams->bihIn ),
; 1145 :                                  streams->currentBlock->buffer,
; 1146 :                                  ( LPBITMAPINFOHEADER )
; 1147 :                                  &( item->bihOut ),
; 1148 :                                  sa.surfacePtr );

	mov	eax, DWORD PTR _sa$[ebp]
	push	eax
	mov	ecx, DWORD PTR _item$[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	mov	edx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR [edx+688]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _streams$[ebp]
	add	edx, 160				; 000000a0H
	push	edx
	push	0
	mov	eax, DWORD PTR _item$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_ICDecompress
	add	esp, 24					; 00000018H
	mov	DWORD PTR _errorCode$[ebp], eax

; 1149 :                   surfaceReleasePointer( item->surfaceBuffer, &sa );

	lea	edx, DWORD PTR _sa$[ebp]
	push	edx
	mov	eax, DWORD PTR _item$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	push	ecx
	call	_surfaceReleasePointer
	add	esp, 8

; 1150 :                }
; 1151 :                else

	jmp	SHORT $LN16@movieThrea
$LN17@movieThrea:

; 1152 :                {
; 1153 :                   item->status |= MOVIE_STATUS_STOP_THREAD;

	mov	edx, DWORD PTR _item$[ebp]
	mov	eax, DWORD PTR [edx+96]
	or	eax, 64					; 00000040H
	mov	ecx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [ecx+96], eax

; 1154 :                   item->lastError = exitCode = MOVIE_BUFFER_LOCK_FAIL;

	mov	DWORD PTR _exitCode$[ebp], -21		; ffffffebH
	mov	edx, DWORD PTR _item$[ebp]
	mov	eax, DWORD PTR _exitCode$[ebp]
	mov	DWORD PTR [edx+864], eax

; 1155 :                   break;

	jmp	$LN26@movieThrea
$LN16@movieThrea:

; 1156 :                }
; 1157 :             }
; 1158 : 
; 1159 :             if ( errorCode != ICERR_OK )

	cmp	DWORD PTR _errorCode$[ebp], 0
	je	SHORT $LN15@movieThrea

; 1160 :             {
; 1161 :                item->status |= MOVIE_STATUS_STOP_THREAD;

	mov	ecx, DWORD PTR _item$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	or	edx, 64					; 00000040H
	mov	eax, DWORD PTR _item$[ebp]
	mov	DWORD PTR [eax+96], edx

; 1162 :                item->lastError = exitCode = MOVIE_THREAD_BAD_DECOMPRESS;

	mov	DWORD PTR _exitCode$[ebp], -13		; fffffff3H
	mov	ecx, DWORD PTR _item$[ebp]
	mov	edx, DWORD PTR _exitCode$[ebp]
	mov	DWORD PTR [ecx+864], edx

; 1163 :                break;

	jmp	$LN26@movieThrea
$LN15@movieThrea:

; 1164 :             }
; 1165 : 
; 1166 :             dropFlag = 0;

	mov	DWORD PTR _dropFlag$[ebp], 0

; 1167 : 
; 1168 :             if ( timeFrames > 1 )

	cmp	DWORD PTR _timeFrames$[ebp], 1
	jle	SHORT $LN14@movieThrea

; 1169 :             {
; 1170 :                /*
; 1171 :                   Skip copy if behind.
; 1172 :                */
; 1173 : 
; 1174 :                item->dropFrames++;

	mov	eax, DWORD PTR _item$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	add	ecx, 1
	mov	edx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [edx+84], ecx

; 1175 :                dropFlag++;

	mov	eax, DWORD PTR _dropFlag$[ebp]
	add	eax, 1
	mov	DWORD PTR _dropFlag$[ebp], eax

; 1176 :             }
; 1177 :             else

	jmp	SHORT $LN13@movieThrea
$LN14@movieThrea:

; 1178 :                doFrame( item );

	mov	ecx, DWORD PTR _item$[ebp]
	push	ecx
	call	?doFrame@@YAXPAUtagMOVIE@@@Z		; doFrame
	add	esp, 4
$LN13@movieThrea:

; 1179 : 
; 1180 :             /*
; 1181 :                Issue a callback.
; 1182 :             */
; 1183 : 
; 1184 :             if ( item->callBack )

	mov	edx, DWORD PTR _item$[ebp]
	cmp	DWORD PTR [edx+124], 0
	je	SHORT $LN12@movieThrea

; 1185 :                 item->callBack( item->handle, item->ddSurface,
; 1186 :                                  item->totalFrames, item->callBackID,
; 1187 :                                  dropFlag, &( item->sa ) );

	mov	eax, DWORD PTR _item$[ebp]
	add	eax, 868				; 00000364H
	push	eax
	mov	ecx, DWORD PTR _dropFlag$[ebp]
	push	ecx
	mov	edx, DWORD PTR _item$[ebp]
	mov	eax, DWORD PTR [edx+92]
	push	eax
	mov	ecx, DWORD PTR _item$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	push	edx
	mov	eax, DWORD PTR _item$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _item$[ebp]
	mov	eax, DWORD PTR [edx+88]
	push	eax
	mov	ecx, DWORD PTR _item$[ebp]
	mov	edx, DWORD PTR [ecx+124]
	call	edx
	add	esp, 24					; 00000018H
$LN12@movieThrea:

; 1188 : 
; 1189 :             item->totalFrames++;          // increment frame number

	mov	eax, DWORD PTR _item$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	add	ecx, 1
	mov	edx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [edx+80], ecx

; 1190 : 
; 1191 :             if ( firstTime )

	cmp	DWORD PTR _firstTime$[ebp], 0
	je	$LN11@movieThrea

; 1192 :             {
; 1193 : 				firstTime = FALSE;

	mov	DWORD PTR _firstTime$[ebp], 0

; 1194 : #if   AUDIO_ON
; 1195 : 					if ( streams->audioFlag & STREAM_AUDIO_ON )

	mov	eax, DWORD PTR _streams$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 1
	je	$LN5@movieThrea

; 1196 : 					{
; 1197 : 					unsigned long   timeBegin;
; 1198 : 					DWORD           bytesProcessed;
; 1199 : 
; 1200 : 						item->audioChannel=(int)F4CreateStream(&streams->waveFormat,0.5f);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _streams$[ebp]
	add	edx, 264				; 00000108H
	push	edx
	call	_F4CreateStream
	add	esp, 8
	mov	ecx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [ecx+856], eax

; 1201 : 						if(item->audioChannel != 0)

	mov	edx, DWORD PTR _item$[ebp]
	cmp	DWORD PTR [edx+856], 0
	je	SHORT $LN9@movieThrea

; 1202 : 						{
; 1203 : 							void *test;
; 1204 : 							test=&item->handle;

	mov	eax, DWORD PTR _item$[ebp]
	add	eax, 88					; 00000058H
	mov	DWORD PTR _test$2[ebp], eax

; 1205 : 							F4StartCallbackStream(item->audioChannel,test,fillSoundBuffer);

	push	OFFSET ?fillSoundBuffer@@YAKPAXPADK@Z	; fillSoundBuffer
	mov	ecx, DWORD PTR _test$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _item$[ebp]
	mov	eax, DWORD PTR [edx+856]
	push	eax
	call	_F4StartCallbackStream
	add	esp, 12					; 0000000cH

; 1206 : 							F4SetStreamVolume(item->audioChannel,0);

	push	0
	mov	ecx, DWORD PTR _item$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	push	edx
	call	_F4SetStreamVolume
	add	esp, 8
$LN9@movieThrea:

; 1207 : 						}
; 1208 : 
; 1209 : 						/*
; 1210 : 							Wait until audio starts
; 1211 : 						*/
; 1212 : 						timeBegin = timeGetTime( );

	call	DWORD PTR __imp__timeGetTime@0
	mov	DWORD PTR _timeBegin$1[ebp], eax

; 1213 : 						bytesProcessed = F4StreamPlayed( item->audioChannel );

	mov	eax, DWORD PTR _item$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	push	ecx
	call	_F4StreamPlayed
	add	esp, 4
	mov	DWORD PTR _bytesProcessed$3[ebp], eax
$LN8@movieThrea:

; 1214 : 						while( !bytesProcessed )

	cmp	DWORD PTR _bytesProcessed$3[ebp], 0
	jne	SHORT $LN7@movieThrea

; 1215 : 						{
; 1216 : 							if ( ( timeGetTime( ) - timeBegin ) > AUDIO_TIMEOUT )

	call	DWORD PTR __imp__timeGetTime@0
	sub	eax, DWORD PTR _timeBegin$1[ebp]
	cmp	eax, 5000				; 00001388H
	jbe	SHORT $LN6@movieThrea

; 1217 : 							{
; 1218 : 								item->status |= MOVIE_STATUS_STOP_THREAD;

	mov	edx, DWORD PTR _item$[ebp]
	mov	eax, DWORD PTR [edx+96]
	or	eax, 64					; 00000040H
	mov	ecx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [ecx+96], eax

; 1219 : 								item->lastError = exitCode = MOVIE_THREAD_AUDIO_TIMEOUT;

	mov	DWORD PTR _exitCode$[ebp], -20		; ffffffecH
	mov	edx, DWORD PTR _item$[ebp]
	mov	eax, DWORD PTR _exitCode$[ebp]
	mov	DWORD PTR [edx+864], eax

; 1220 : 								break;

	jmp	SHORT $LN7@movieThrea
$LN6@movieThrea:

; 1221 : 							}
; 1222 : 							bytesProcessed = F4StreamPlayed( item->audioChannel );

	mov	ecx, DWORD PTR _item$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	push	edx
	call	_F4StreamPlayed
	add	esp, 4
	mov	DWORD PTR _bytesProcessed$3[ebp], eax

; 1223 : 						}

	jmp	SHORT $LN8@movieThrea
$LN7@movieThrea:

; 1224 : 
; 1225 : 						if ( !bytesProcessed )

	cmp	DWORD PTR _bytesProcessed$3[ebp], 0
	jne	SHORT $LN5@movieThrea

; 1226 : 						{
; 1227 : 							break;                                 // time out

	jmp	SHORT $LN26@movieThrea
$LN5@movieThrea:

; 1228 : 						}
; 1229 : 					}
; 1230 : 
; 1231 : #endif
; 1232 :                item->startTime = timeGetTime( );            // record start time

	call	DWORD PTR __imp__timeGetTime@0
	mov	ecx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [ecx+104], eax
$LN11@movieThrea:

; 1233 :             }
; 1234 : 
; 1235 :             // Free video block.
; 1236 :             streams->currentBlock->currentBlockSize = 0;

	mov	edx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR [edx+688]
	mov	DWORD PTR [eax+4], 0

; 1237 :             streams->currentBlock = streams->currentBlock->next;

	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR [ecx+688]
	mov	eax, DWORD PTR _streams$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+688], ecx

; 1238 :          }
; 1239 :          else

	jmp	SHORT $LN4@movieThrea
$LN20@movieThrea:

; 1240 :             Sleep( 10 );

	push	10					; 0000000aH
	call	DWORD PTR __imp__Sleep@4
$LN4@movieThrea:

; 1241 :       }
; 1242 :       else

	jmp	SHORT $LN2@movieThrea
$LN25@movieThrea:

; 1243 :          if ( ( item->status & MOVIE_STATUS_EOF ) ||
; 1244 :                ( item->status & MOVIE_STATUS_STOP_THREAD ) )

	mov	edx, DWORD PTR _item$[ebp]
	mov	eax, DWORD PTR [edx+96]
	and	eax, 2
	jne	SHORT $LN1@movieThrea
	mov	ecx, DWORD PTR _item$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	and	edx, 64					; 00000040H
	je	SHORT $LN2@movieThrea
$LN1@movieThrea:

; 1245 :             break;

	jmp	SHORT $LN26@movieThrea
$LN2@movieThrea:

; 1246 :    }

	jmp	$LN29@movieThrea
$LN26@movieThrea:

; 1247 : 
; 1248 :    WaitForSingleObject( ( HANDLE ) item->hFillerThread, INFINITE );

	push	-1
	mov	eax, DWORD PTR _item$[ebp]
	mov	ecx, DWORD PTR [eax+116]
	push	ecx
	call	DWORD PTR __imp__WaitForSingleObject@8

; 1249 : 
; 1250 : #if   AUDIO_ON
; 1251 :        F4StopStream(item->audioChannel);

	mov	edx, DWORD PTR _item$[ebp]
	mov	eax, DWORD PTR [edx+856]
	push	eax
	call	_F4StopStream
	add	esp, 4

; 1252 : //
; 1253 : //   if ( item->audioChannel )
; 1254 : //      SoundReleaseChannel( item->audioChannel );
; 1255 : //
; 1256 : #endif
; 1257 : 
; 1258 :    item->status &= ~MOVIE_STATUS_PLAYING;

	mov	ecx, DWORD PTR _item$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	and	edx, -2					; fffffffeH
	mov	eax, DWORD PTR _item$[ebp]
	mov	DWORD PTR [eax+96], edx

; 1259 :    return ( unsigned int ) exitCode;

	mov	eax, DWORD PTR _exitCode$[ebp]

; 1260 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?movieThread@@YGIPAX@Z ENDP				; movieThread
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\movie\avimovie.cpp
_TEXT	SEGMENT
_handle$ = 8						; size = 4
_movieGetLastError PROC

; 1368 : {

	push	ebp
	mov	ebp, esp

; 1369 :    if ( ( DWORD ) handle >= numOfMovies )

	mov	eax, DWORD PTR _handle$[ebp]
	cmp	eax, DWORD PTR _numOfMovies
	jb	SHORT $LN1@movieGetLa

; 1370 :       return MOVIE_INVALID_HANDLE;

	mov	eax, -14				; fffffff2H
	jmp	SHORT $LN2@movieGetLa
$LN1@movieGetLa:

; 1371 : 
; 1372 :    return movie[handle].lastError;

	mov	ecx, DWORD PTR _handle$[ebp]
	imul	ecx, 880				; 00000370H
	mov	edx, DWORD PTR _movie
	mov	eax, DWORD PTR [edx+ecx+864]
$LN2@movieGetLa:

; 1373 : }

	pop	ebp
	ret	0
_movieGetLastError ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\movie\avimovie.cpp
_TEXT	SEGMENT
_i$ = -8						; size = 4
_count$ = -4						; size = 4
_movieCount PROC

; 949  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 950  :    DWORD i, count;
; 951  : 
; 952  :    EnterCriticalSection( &movieCriticalSection );

	push	OFFSET _movieCriticalSection
	call	DWORD PTR __imp__EnterCriticalSection@4

; 953  : 
; 954  :    if ( abortMovie )

	cmp	DWORD PTR _abortMovie, 0
	je	SHORT $LN6@movieCount

; 955  :       count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 956  :    else

	jmp	SHORT $LN5@movieCount
$LN6@movieCount:

; 957  :       for ( i = count = 0; i < numOfMovies; i++ )

	mov	DWORD PTR _count$[ebp], 0
	mov	eax, DWORD PTR _count$[ebp]
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN4@movieCount
$LN3@movieCount:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@movieCount:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _numOfMovies
	jae	SHORT $LN5@movieCount

; 958  :          if ( movie[i].status & MOVIE_STATUS_IN_USE )

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 880				; 00000370H
	mov	ecx, DWORD PTR _movie
	mov	edx, DWORD PTR [ecx+eax+96]
	and	edx, 16					; 00000010H
	je	SHORT $LN1@movieCount

; 959  :             count++;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax
$LN1@movieCount:

; 960  : 
; 961  :    LeaveCriticalSection( &movieCriticalSection );

	jmp	SHORT $LN3@movieCount
$LN5@movieCount:
	push	OFFSET _movieCriticalSection
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 962  : 
; 963  :    return count;

	mov	eax, DWORD PTR _count$[ebp]

; 964  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_movieCount ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\movie\avimovie.cpp
_TEXT	SEGMENT
tv70 = -4						; size = 4
_handle$ = 8						; size = 4
_movieIsPlaying PROC

; 928  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 929  :    if ( ( DWORD ) handle >= numOfMovies )

	mov	eax, DWORD PTR _handle$[ebp]
	cmp	eax, DWORD PTR _numOfMovies
	jb	SHORT $LN1@movieIsPla

; 930  :       return FALSE;

	xor	eax, eax
	jmp	SHORT $LN2@movieIsPla
$LN1@movieIsPla:

; 931  : 
; 932  :    return ( ( movie[handle].status &
; 933  :             MOVIE_STATUS_PLAYING ) ? TRUE : FALSE );

	mov	ecx, DWORD PTR _handle$[ebp]
	imul	ecx, 880				; 00000370H
	mov	edx, DWORD PTR _movie
	mov	eax, DWORD PTR [edx+ecx+96]
	and	eax, 1
	je	SHORT $LN4@movieIsPla
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN5@movieIsPla
$LN4@movieIsPla:
	mov	DWORD PTR tv70[ebp], 0
$LN5@movieIsPla:
	mov	eax, DWORD PTR tv70[ebp]
$LN2@movieIsPla:

; 934  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_movieIsPlaying ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\movie\avimovie.cpp
_TEXT	SEGMENT
_item$ = -4						; size = 4
_handle$ = 8						; size = 4
_movieStop PROC

; 899  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 900  :    PMOVIE         item;
; 901  : 
; 902  :    if ( ( DWORD ) handle >= numOfMovies )

	mov	eax, DWORD PTR _handle$[ebp]
	cmp	eax, DWORD PTR _numOfMovies
	jb	SHORT $LN2@movieStop

; 903  :       return MOVIE_INVALID_HANDLE;

	mov	eax, -14				; fffffff2H
	jmp	SHORT $LN3@movieStop
$LN2@movieStop:

; 904  : 
; 905  :    item = &( movie[handle] );

	mov	ecx, DWORD PTR _handle$[ebp]
	imul	ecx, 880				; 00000370H
	add	ecx, DWORD PTR _movie
	mov	DWORD PTR _item$[ebp], ecx

; 906  : 
; 907  :    if ( !( item->status & MOVIE_STATUS_IN_USE ) )

	mov	edx, DWORD PTR _item$[ebp]
	mov	eax, DWORD PTR [edx+96]
	and	eax, 16					; 00000010H
	jne	SHORT $LN1@movieStop

; 908  :       return MOVIE_NOT_IN_USE;

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN3@movieStop
$LN1@movieStop:

; 909  : 
; 910  :    item->status |= MOVIE_STATUS_QUIT;

	mov	ecx, DWORD PTR _item$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	or	edx, 4
	mov	eax, DWORD PTR _item$[ebp]
	mov	DWORD PTR [eax+96], edx

; 911  : 
; 912  :    return MOVIE_OK;

	xor	eax, eax
$LN3@movieStop:

; 913  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_movieStop ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\movie\avimovie.cpp
_TEXT	SEGMENT
tv77 = -20						; size = 4
_status$ = -16						; size = 4
_i$ = -12						; size = 4
_streams$ = -8						; size = 4
_item$ = -4						; size = 4
_handle$ = 8						; size = 4
_movieStart PROC

; 673  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 674  :    int            i, status;
; 675  :    PMOVIE         item;
; 676  :    PAVISTREAMS    streams;
; 677  : 
; 678  : 
; 679  : #ifdef MEASURE_TIME
; 680  : 
; 681  : 	now.time	= 0;
; 682  : 	now.millitm	= 0;
; 683  : 
; 684  : 	last.time	= 0;
; 685  : 	last.millitm	= 0;
; 686  : 
; 687  : 	average		= 0.0;
; 688  : 	total		= 0.0;
; 689  : 	count		= 0;
; 690  : 
; 691  : 	once = FALSE;
; 692  : 
; 693  : #endif
; 694  : 
; 695  : 
; 696  :    if ( ( DWORD ) handle >= numOfMovies )

	mov	eax, DWORD PTR _handle$[ebp]
	cmp	eax, DWORD PTR _numOfMovies
	jb	SHORT $LN20@movieStart

; 697  :       return MOVIE_INVALID_HANDLE;

	mov	eax, -14				; fffffff2H
	jmp	$LN21@movieStart
$LN20@movieStart:

; 698  : 
; 699  :    item = &( movie[handle] );

	mov	ecx, DWORD PTR _handle$[ebp]
	imul	ecx, 880				; 00000370H
	add	ecx, DWORD PTR _movie
	mov	DWORD PTR _item$[ebp], ecx

; 700  : 
; 701  :    /*
; 702  :       Cache in some audio and video data.
; 703  :    */
; 704  : 
; 705  :    streams = &( item->aviStreams );

	mov	edx, DWORD PTR _item$[ebp]
	add	edx, 128				; 00000080H
	mov	DWORD PTR _streams$[ebp], edx

; 706  : 
; 707  :    if ( streams->audioFlag & STREAM_AUDIO_PRELOAD )

	mov	eax, DWORD PTR _streams$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 4
	je	SHORT $LN19@movieStart

; 708  :    {
; 709  :       if ( waveReadBlock( streams ) < RIFF_OK )

	mov	edx, DWORD PTR _streams$[ebp]
	push	edx
	call	_waveReadBlock
	add	esp, 4
	test	eax, eax
	jge	SHORT $LN18@movieStart

; 710  :          return MOVIE_BAD_AUDIO_FILE;

	mov	eax, -19				; ffffffedH
	jmp	$LN21@movieStart
$LN18@movieStart:

; 711  :    }
; 712  :    else

	jmp	$LN17@movieStart
$LN19@movieStart:

; 713  :    {
; 714  :       /*
; 715  :          Get number of audio chunks ahead of video and read those chunks.
; 716  :       */
; 717  : 
; 718  :       i = streams->initialFrames;

	mov	eax, DWORD PTR _streams$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _i$[ebp], ecx
$LN16@movieStart:

; 719  : 
; 720  :       while ( i-- )

	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR tv77[ebp], edx
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	cmp	DWORD PTR tv77[ebp], 0
	je	SHORT $LN17@movieStart

; 721  :       {
; 722  :          /*
; 723  :             Read from AVI file if interleaved.  Otherwise, read from an
; 724  :             external sound file and discard interleaved audio data in AVI if
; 725  :             any.
; 726  :          */
; 727  : 
; 728  :          if ( !( streams->audioFlag & STREAM_AUDIO_EXTERNAL ) )

	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	and	edx, 2
	jne	SHORT $LN14@movieStart

; 729  :          {
; 730  :             // Interleaved.
; 731  : 
; 732  :             status = aviReadRecord( streams );

	mov	eax, DWORD PTR _streams$[ebp]
	push	eax
	call	_aviReadRecord
	add	esp, 4
	mov	DWORD PTR _status$[ebp], eax

; 733  :             if ( status != RIFF_OK )

	cmp	DWORD PTR _status$[ebp], 0
	je	SHORT $LN13@movieStart

; 734  :                return MOVIE_BAD_FILE;

	mov	eax, -18				; ffffffeeH
	jmp	$LN21@movieStart
$LN13@movieStart:

; 735  :          }
; 736  :          else

	jmp	SHORT $LN12@movieStart
$LN14@movieStart:

; 737  :          {
; 738  :             // External audio file.
; 739  : 
; 740  :             if ( streams->mainAVIHeader.dwInitialFrames )

	mov	ecx, DWORD PTR _streams$[ebp]
	cmp	DWORD PTR [ecx+60], 0
	je	SHORT $LN11@movieStart

; 741  :             {
; 742  :                status = aviReadRecord( streams );

	mov	edx, DWORD PTR _streams$[ebp]
	push	edx
	call	_aviReadRecord
	add	esp, 4
	mov	DWORD PTR _status$[ebp], eax

; 743  :                if ( status != RIFF_OK )

	cmp	DWORD PTR _status$[ebp], 0
	je	SHORT $LN11@movieStart

; 744  :                   return MOVIE_BAD_FILE;

	mov	eax, -18				; ffffffeeH
	jmp	$LN21@movieStart
$LN11@movieStart:

; 745  :             }
; 746  : 
; 747  :             status = waveReadBlock( streams );

	mov	eax, DWORD PTR _streams$[ebp]
	push	eax
	call	_waveReadBlock
	add	esp, 4
	mov	DWORD PTR _status$[ebp], eax

; 748  :             if ( status != RIFF_OK )

	cmp	DWORD PTR _status$[ebp], 0
	je	SHORT $LN12@movieStart

; 749  :                return MOVIE_BAD_AUDIO_FILE;

	mov	eax, -19				; ffffffedH
	jmp	$LN21@movieStart
$LN12@movieStart:

; 750  :          }
; 751  :       }

	jmp	$LN16@movieStart
$LN17@movieStart:

; 752  :    }
; 753  : 
; 754  :    /*
; 755  :       Preload a few chunks to make sure there is ample audio data.
; 756  :       ( preloading some video chunks is also necessary if streaming and
; 757  :          decompressing/rendering are decoupled )
; 758  :    */
; 759  : 
; 760  :    for ( i = 0; i < streams->numOfVidBlocks; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN8@movieStart
$LN7@movieStart:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN8@movieStart:
	mov	edx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+32]
	jge	SHORT $LN6@movieStart

; 761  :    {
; 762  :       if ( aviReadRecord( streams ) != RIFF_OK )

	mov	ecx, DWORD PTR _streams$[ebp]
	push	ecx
	call	_aviReadRecord
	add	esp, 4
	test	eax, eax
	je	SHORT $LN5@movieStart

; 763  :          return MOVIE_BAD_FILE;

	mov	eax, -18				; ffffffeeH
	jmp	$LN21@movieStart
$LN5@movieStart:

; 764  : 
; 765  :       if ( ( streams->audioFlag & STREAM_AUDIO_EXTERNAL ) &&
; 766  :             !( streams->audioFlag & STREAM_AUDIO_PRELOAD ) )

	mov	edx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 2
	je	SHORT $LN4@movieStart
	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	and	edx, 4
	jne	SHORT $LN4@movieStart

; 767  :          if ( waveReadBlock( streams ) != RIFF_OK )

	mov	eax, DWORD PTR _streams$[ebp]
	push	eax
	call	_waveReadBlock
	add	esp, 4
	test	eax, eax
	je	SHORT $LN4@movieStart

; 768  :             return MOVIE_BAD_AUDIO_FILE;

	mov	eax, -19				; ffffffedH
	jmp	$LN21@movieStart
$LN4@movieStart:

; 769  :    }

	jmp	SHORT $LN7@movieStart
$LN6@movieStart:

; 770  : 
; 771  :    // Launch filler thread.
; 772  : 
; 773  :    item->hFillerThread = _beginthreadex( NULL, 0, fillerThread, item,
; 774  :                                           0, (unsigned int *)&( item->fillerThreadID ) );

	mov	ecx, DWORD PTR _item$[ebp]
	add	ecx, 120				; 00000078H
	push	ecx
	push	0
	mov	edx, DWORD PTR _item$[ebp]
	push	edx
	push	OFFSET ?fillerThread@@YGIPAX@Z		; fillerThread
	push	0
	push	0
	call	__beginthreadex
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [ecx+116], eax

; 775  : 
; 776  :    if ( !item->hFillerThread )

	mov	edx, DWORD PTR _item$[ebp]
	cmp	DWORD PTR [edx+116], 0
	jne	SHORT $LN2@movieStart

; 777  :       return MOVIE_UNABLE_TO_LAUNCH_THREAD;

	mov	eax, -17				; ffffffefH
	jmp	$LN21@movieStart
$LN2@movieStart:

; 778  : 
; 779  :    // Launch movie thread.
; 780  : 
; 781  :    item->hMovieThread = _beginthreadex( NULL, 0, movieThread, item,
; 782  :                                           0, (unsigned int *)&( item->movieThreadID ) );

	mov	eax, DWORD PTR _item$[ebp]
	add	eax, 112				; 00000070H
	push	eax
	push	0
	mov	ecx, DWORD PTR _item$[ebp]
	push	ecx
	push	OFFSET ?movieThread@@YGIPAX@Z		; movieThread
	push	0
	push	0
	call	__beginthreadex
	add	esp, 24					; 00000018H
	mov	edx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [edx+108], eax

; 783  : 
; 784  :    if ( !item->hMovieThread )

	mov	eax, DWORD PTR _item$[ebp]
	cmp	DWORD PTR [eax+108], 0
	jne	SHORT $LN1@movieStart

; 785  :    {
; 786  :       /*
; 787  :          Stop filler thread.
; 788  :       */
; 789  :       item->status |= MOVIE_STATUS_STOP_THREAD;

	mov	ecx, DWORD PTR _item$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	or	edx, 64					; 00000040H
	mov	eax, DWORD PTR _item$[ebp]
	mov	DWORD PTR [eax+96], edx

; 790  :       WaitForSingleObject( ( HANDLE ) item->hFillerThread, INFINITE );

	push	-1
	mov	ecx, DWORD PTR _item$[ebp]
	mov	edx, DWORD PTR [ecx+116]
	push	edx
	call	DWORD PTR __imp__WaitForSingleObject@8

; 791  :       CloseHandle( ( HANDLE ) item->hFillerThread );

	mov	eax, DWORD PTR _item$[ebp]
	mov	ecx, DWORD PTR [eax+116]
	push	ecx
	call	DWORD PTR __imp__CloseHandle@4

; 792  : 
; 793  :       /*
; 794  :          Reset movie thread ID.
; 795  :       */
; 796  :       item->movieThreadID = 0;            // reset thread ID

	mov	edx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [edx+112], 0

; 797  :       return MOVIE_UNABLE_TO_LAUNCH_THREAD;

	mov	eax, -17				; ffffffefH
	jmp	SHORT $LN21@movieStart
$LN1@movieStart:

; 798  :    }
; 799  : 
; 800  :    item->status |= MOVIE_STATUS_PLAYING;

	mov	eax, DWORD PTR _item$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	or	ecx, 1
	mov	edx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [edx+96], ecx

; 801  :    Sleep( 0 );                             // give up time slice

	push	0
	call	DWORD PTR __imp__Sleep@4

; 802  : 
; 803  :    return MOVIE_OK;

	xor	eax, eax
$LN21@movieStart:

; 804  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_movieStart ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\movie\avimovie.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 4
_item$ = -4						; size = 4
_handle$ = 8						; size = 4
_movieClose PROC

; 825  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 826  :    PMOVIE         item;
; 827  : 
; 828  : 
; 829  : #ifdef MEASURE_TIME
; 830  : 
; 831  : 	average		= count / total; //fps
; 832  : 	FILE* fp	= fopen("measure.dat", "a");
; 833  : 	fprintf(fp, "average framerate = %f fps\n", average);
; 834  : 	fclose(fp);
; 835  : 
; 836  : #endif
; 837  : 
; 838  : 
; 839  : 
; 840  :    if ( ( DWORD ) handle >= numOfMovies )

	mov	eax, DWORD PTR _handle$[ebp]
	cmp	eax, DWORD PTR _numOfMovies
	jb	SHORT $LN8@movieClose

; 841  :       return MOVIE_INVALID_HANDLE;

	mov	eax, -14				; fffffff2H
	jmp	$LN9@movieClose
$LN8@movieClose:

; 842  : 
; 843  :    item = &( movie[handle] );

	mov	ecx, DWORD PTR _handle$[ebp]
	imul	ecx, 880				; 00000370H
	add	ecx, DWORD PTR _movie
	mov	DWORD PTR _item$[ebp], ecx

; 844  : 
; 845  :    EnterCriticalSection( &movieCriticalSection );

	push	OFFSET _movieCriticalSection
	call	DWORD PTR __imp__EnterCriticalSection@4

; 846  :    if ( !( item->status & MOVIE_STATUS_IN_USE ) )

	mov	edx, DWORD PTR _item$[ebp]
	mov	eax, DWORD PTR [edx+96]
	and	eax, 16					; 00000010H
	jne	SHORT $LN7@movieClose

; 847  :    {
; 848  :       LeaveCriticalSection( &movieCriticalSection );

	push	OFFSET _movieCriticalSection
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 849  :       return MOVIE_NOT_IN_USE;

	mov	eax, -16				; fffffff0H
	jmp	$LN9@movieClose
$LN7@movieClose:

; 850  :    }
; 851  : 
; 852  :    if ( item->movieThreadID == GetCurrentThreadId( ) )

	call	DWORD PTR __imp__GetCurrentThreadId@0
	mov	ecx, DWORD PTR _item$[ebp]
	cmp	DWORD PTR [ecx+112], eax
	jne	SHORT $LN6@movieClose

; 853  :    {
; 854  :       LeaveCriticalSection( &movieCriticalSection );

	push	OFFSET _movieCriticalSection
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 855  :       return MOVIE_CLOSE_THREAD_ERROR;

	mov	eax, -15				; fffffff1H
	jmp	$LN9@movieClose
$LN6@movieClose:

; 856  :    }
; 857  : 
; 858  :    if ( ( item->status & MOVIE_STATUS_PLAYING ) ||
; 859  :             ( item->status & MOVIE_STATUS_THREAD_RUNNING ) )

	mov	edx, DWORD PTR _item$[ebp]
	mov	eax, DWORD PTR [edx+96]
	and	eax, 1
	jne	SHORT $LN4@movieClose
	mov	ecx, DWORD PTR _item$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	and	edx, 32					; 00000020H
	je	SHORT $LN5@movieClose
$LN4@movieClose:

; 860  :    {
; 861  :       item->status |= MOVIE_STATUS_QUIT;

	mov	eax, DWORD PTR _item$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	or	ecx, 4
	mov	edx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [edx+96], ecx

; 862  :       WaitForSingleObject( ( HANDLE ) item->hMovieThread, INFINITE );

	push	-1
	mov	eax, DWORD PTR _item$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	push	ecx
	call	DWORD PTR __imp__WaitForSingleObject@8

; 863  :       CloseHandle( ( HANDLE ) item->hMovieThread );

	mov	edx, DWORD PTR _item$[ebp]
	mov	eax, DWORD PTR [edx+108]
	push	eax
	call	DWORD PTR __imp__CloseHandle@4

; 864  :       CloseHandle( ( HANDLE ) item->hFillerThread );

	mov	ecx, DWORD PTR _item$[ebp]
	mov	edx, DWORD PTR [ecx+116]
	push	edx
	call	DWORD PTR __imp__CloseHandle@4
$LN5@movieClose:

; 865  :    }
; 866  : 
; 867  :    ICDecompressEnd( item->hIC );

	push	0
	push	0
	push	16398					; 0000400eH
	mov	eax, DWORD PTR _item$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_ICSendMessage@16

; 868  :    DeleteCriticalSection( &( item->aviStreams.criticalSection ) );

	mov	edx, DWORD PTR _item$[ebp]
	add	edx, 832				; 00000340H
	push	edx
	call	DWORD PTR __imp__DeleteCriticalSection@4

; 869  : 
; 870  :    if ( item->surfaceBuffer )

	mov	eax, DWORD PTR _item$[ebp]
	cmp	DWORD PTR [eax+68], 0
	je	SHORT $LN3@movieClose

; 871  :    {
; 872  :       if ( item->sbType & SURFACE_TYPE_SYSTEM )

	mov	ecx, DWORD PTR _item$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	and	edx, 1
	je	SHORT $LN2@movieClose

; 873  :          delete [] item->surfaceBuffer;

	mov	eax, DWORD PTR _item$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 874  :       else

	jmp	SHORT $LN1@movieClose
$LN2@movieClose:

; 875  :          surfaceRelease( item->surfaceBuffer );

	mov	eax, DWORD PTR _item$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	push	ecx
	call	_surfaceRelease
	add	esp, 4
$LN1@movieClose:

; 876  : 
; 877  :       item->surfaceBuffer = NULL;

	mov	edx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [edx+68], 0
$LN3@movieClose:

; 878  :    }
; 879  :    aviClose ( &( item->aviStreams ) );

	mov	eax, DWORD PTR _item$[ebp]
	add	eax, 128				; 00000080H
	push	eax
	call	_aviClose
	add	esp, 4

; 880  :    item->status = 0;

	mov	ecx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [ecx+96], 0

; 881  :    LeaveCriticalSection( &movieCriticalSection );

	push	OFFSET _movieCriticalSection
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 882  : 
; 883  :    return MOVIE_OK;

	xor	eax, eax
$LN9@movieClose:

; 884  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_movieClose ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\movie\avimovie.cpp
_TEXT	SEGMENT
_retval$ = -80						; size = 4
$T1 = -76						; size = 4
_status$ = -72						; size = 4
_hnd$ = -68						; size = 4
_buf$ = -64						; size = 4
_screenHeight$ = -60					; size = 4
_screenWidth$ = -56					; size = 4
tv291 = -52						; size = 4
_dibWidth$ = -48					; size = 4
_dibHeight$ = -44					; size = 4
_handle$ = -40						; size = 4
_item$ = -36						; size = 4
_sd$ = -32						; size = 28
__$ArrayPad$ = -4					; size = 4
_aviFileName$ = 8					; size = 4
_audioFileName$ = 12					; size = 4
_ddSurface$ = 16					; size = 4
_callBackID$ = 20					; size = 4
_callBack$ = 24						; size = 4
_startX$ = 28						; size = 4
_startY$ = 32						; size = 4
_videoMode$ = 36					; size = 4
_audioFlag$ = 40					; size = 4
_movieOpen PROC

; 349  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 350  :    DWORD                handle;
; 351  :    int                  status;
; 352  :    PMOVIE               item;
; 353  :    SURFACEDESCRIPTION   sd;
; 354  :    int                  screenWidth, screenHeight;
; 355  :    int                  dibWidth, dibHeight;
; 356  : 
; 357  :    EnterCriticalSection( &movieCriticalSection );

	push	OFFSET _movieCriticalSection
	call	DWORD PTR __imp__EnterCriticalSection@4

; 358  : 
; 359  :    /*
; 360  :       Movie system has been or is being uninitialized.
; 361  :       Do not play new movies.
; 362  :    */
; 363  : 
; 364  : 	PF( "Movie open [ENTER].\n");

	push	OFFSET ??_C@_0BF@KBGFNKNN@Movie?5open?5?$FLENTER?$FN?4?6?$AA@
	call	_MonoPrint
	add	esp, 4

; 365  : 
; 366  :    if ( abortMovie )

	cmp	DWORD PTR _abortMovie, 0
	je	SHORT $LN29@movieOpen

; 367  :    {
; 368  : 	  PF( "Movie aborted.\n" );

	push	OFFSET ??_C@_0BA@MPFNLFK@Movie?5aborted?4?6?$AA@
	call	_MonoPrint
	add	esp, 4

; 369  :       LeaveCriticalSection( &movieCriticalSection );

	push	OFFSET _movieCriticalSection
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 370  :       return MOVIE_ABORT;

	mov	eax, -10				; fffffff6H
	jmp	$LN30@movieOpen
$LN29@movieOpen:

; 371  :    }
; 372  : 
; 373  : 
; 374  :    /* Pre-spin the cd */
; 375  : 
; 376  : #ifdef PRESPIN_CD
; 377  : 
; 378  : 	char * buf;
; 379  : 	int hnd;
; 380  : 	int retval;
; 381  : 
; 382  : 	buf = (char *)malloc( CD_CACHE_SIZE );

	push	2048					; 00000800H
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _buf$[ebp], eax

; 383  : 	hnd = open( aviFileName, _O_BINARY | _O_RDONLY );

	push	32768					; 00008000H
	mov	eax, DWORD PTR _aviFileName$[ebp]
	push	eax
	call	_open
	add	esp, 8
	mov	DWORD PTR _hnd$[ebp], eax

; 384  : 	retval = read( hnd, buf, CD_CACHE_SIZE );

	push	2048					; 00000800H
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hnd$[ebp]
	push	edx
	call	_read
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _retval$[ebp], eax

; 385  : 	close(hnd);

	mov	eax, DWORD PTR _hnd$[ebp]
	push	eax
	call	_close
	add	esp, 4

; 386  : 	free( buf );

	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_free
	add	esp, 4

; 387  : 
; 388  : #endif
; 389  : 
; 390  :    /*
; 391  :       Find an unused slot.
; 392  :    */
; 393  : 
; 394  :    for ( handle = 0; handle < numOfMovies; handle++ )

	mov	DWORD PTR _handle$[ebp], 0
	jmp	SHORT $LN28@movieOpen
$LN27@movieOpen:
	mov	edx, DWORD PTR _handle$[ebp]
	add	edx, 1
	mov	DWORD PTR _handle$[ebp], edx
$LN28@movieOpen:
	mov	eax, DWORD PTR _handle$[ebp]
	cmp	eax, DWORD PTR _numOfMovies
	jae	SHORT $LN26@movieOpen

; 395  :       if ( !movie[handle].status )

	mov	ecx, DWORD PTR _handle$[ebp]
	imul	ecx, 880				; 00000370H
	mov	edx, DWORD PTR _movie
	cmp	DWORD PTR [edx+ecx+96], 0
	jne	SHORT $LN25@movieOpen

; 396  :          break;

	jmp	SHORT $LN26@movieOpen
$LN25@movieOpen:

; 397  : 
; 398  :    /*
; 399  :       Exit if unable to find a slot.
; 400  :    */
; 401  : 
; 402  :    if ( handle == numOfMovies )

	jmp	SHORT $LN27@movieOpen
$LN26@movieOpen:
	mov	eax, DWORD PTR _handle$[ebp]
	cmp	eax, DWORD PTR _numOfMovies
	jne	SHORT $LN24@movieOpen

; 403  :    {
; 404  : 	  PF( "No slots available for movie.\n" );

	push	OFFSET ??_C@_0BP@LAEPMALO@No?5slots?5available?5for?5movie?4?6?$AA@
	call	_MonoPrint
	add	esp, 4

; 405  :       LeaveCriticalSection( &movieCriticalSection );

	push	OFFSET _movieCriticalSection
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 406  :       return MOVIE_NO_SLOT;

	mov	eax, -7					; fffffff9H
	jmp	$LN30@movieOpen
$LN24@movieOpen:

; 407  :    }
; 408  : 
; 409  :    /*
; 410  :       Mark the slot 'in use'.
; 411  :    */
; 412  : 
; 413  :    item = &movie[handle];

	mov	ecx, DWORD PTR _handle$[ebp]
	imul	ecx, 880				; 00000370H
	add	ecx, DWORD PTR _movie
	mov	DWORD PTR _item$[ebp], ecx

; 414  :    item->status = MOVIE_STATUS_IN_USE;

	mov	edx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [edx+96], 16			; 00000010H

; 415  :    LeaveCriticalSection( &movieCriticalSection );

	push	OFFSET _movieCriticalSection
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 416  : 
; 417  :    if ( videoMode & MOVIE_MODE_HURRY )

	mov	eax, DWORD PTR _videoMode$[ebp]
	and	eax, 65536				; 00010000H
	je	SHORT $LN23@movieOpen

; 418  :       item->sbType = SURFACE_TRY_FAST;

	mov	ecx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [ecx+100], 4

; 419  :    else

	jmp	SHORT $LN22@movieOpen
$LN23@movieOpen:

; 420  :       item->sbType = 0;

	mov	edx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [edx+100], 0
$LN22@movieOpen:

; 421  : 
; 422  :    videoMode &= 0xffff;             // Clear high word

	mov	eax, DWORD PTR _videoMode$[ebp]
	and	eax, 65535				; 0000ffffH
	mov	DWORD PTR _videoMode$[ebp], eax

; 423  : 
; 424  :    if ( !( audioFlag & MOVIE_NO_AUDIO ) )

	mov	ecx, DWORD PTR _audioFlag$[ebp]
	and	ecx, 1
	jne	SHORT $LN21@movieOpen

; 425  :    {
; 426  :       item->aviStreams.audioFlag |= STREAM_AUDIO_ON;

	mov	edx, DWORD PTR _item$[ebp]
	mov	eax, DWORD PTR [edx+136]
	or	eax, 1
	mov	ecx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [ecx+136], eax

; 427  : 
; 428  :       if ( audioFileName )

	cmp	DWORD PTR _audioFileName$[ebp], 0
	je	SHORT $LN21@movieOpen

; 429  :       {
; 430  :          item->aviStreams.audioFlag |= STREAM_AUDIO_EXTERNAL;

	mov	edx, DWORD PTR _item$[ebp]
	mov	eax, DWORD PTR [edx+136]
	or	eax, 2
	mov	ecx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [ecx+136], eax

; 431  :          if ( audioFlag & MOVIE_PRELOAD_AUDIO )

	mov	edx, DWORD PTR _audioFlag$[ebp]
	and	edx, 2
	je	SHORT $LN21@movieOpen

; 432  :             item->aviStreams.audioFlag |= STREAM_AUDIO_PRELOAD;

	mov	eax, DWORD PTR _item$[ebp]
	mov	ecx, DWORD PTR [eax+136]
	or	ecx, 4
	mov	edx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [edx+136], ecx
$LN21@movieOpen:

; 433  :       }
; 434  :    }
; 435  : 
; 436  :    /*
; 437  :       Open file(s) and read headers.
; 438  :    */
; 439  : 
; 440  :    status = aviOpen( aviFileName, audioFileName,
; 441  :                      &( item->aviStreams ) );

	mov	eax, DWORD PTR _item$[ebp]
	add	eax, 128				; 00000080H
	push	eax
	mov	ecx, DWORD PTR _audioFileName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _aviFileName$[ebp]
	push	edx
	call	_aviOpen
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _status$[ebp], eax

; 442  : 
; 443  :    if ( status != RIFF_OK )

	cmp	DWORD PTR _status$[ebp], 0
	je	SHORT $LN18@movieOpen

; 444  :    {
; 445  :       aviClose( &( item->aviStreams ) );

	mov	eax, DWORD PTR _item$[ebp]
	add	eax, 128				; 00000080H
	push	eax
	call	_aviClose
	add	esp, 4

; 446  :       item->status = 0;

	mov	ecx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [ecx+96], 0

; 447  : 	  PF( "Movie open failed.\n" );

	push	OFFSET ??_C@_0BE@KHDDDMJC@Movie?5open?5failed?4?6?$AA@
	call	_MonoPrint
	add	esp, 4

; 448  :       return MOVIE_OPEN_FAILED;

	mov	eax, -2					; fffffffeH
	jmp	$LN30@movieOpen
$LN18@movieOpen:

; 449  :    }
; 450  : 
; 451  :    /*
; 452  :       Get the surface properties.
; 453  :    */
; 454  : 
; 455  :    surfaceGetDescription( ddSurface, &sd );

	lea	edx, DWORD PTR _sd$[ebp]
	push	edx
	mov	eax, DWORD PTR _ddSurface$[ebp]
	push	eax
	call	_surfaceGetDescription
	add	esp, 8

; 456  : 
; 457  :    /*
; 458  :       Movie player supports HIGH COLOR or TRUE COLOR only.
; 459  :    */
; 460  : 
; 461  :    if ( sd.bitCount < HICOLOR )

	cmp	DWORD PTR _sd$[ebp], 16			; 00000010H
	jae	SHORT $LN17@movieOpen

; 462  :    {
; 463  :       aviClose( &( item->aviStreams ) );

	mov	ecx, DWORD PTR _item$[ebp]
	add	ecx, 128				; 00000080H
	push	ecx
	call	_aviClose
	add	esp, 4

; 464  :       item->status = 0;

	mov	edx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [edx+96], 0

; 465  : 	  PF( "Unsupported bit depth.\n" );

	push	OFFSET ??_C@_0BI@BEMFGEKH@Unsupported?5bit?5depth?4?6?$AA@
	call	_MonoPrint
	add	esp, 4

; 466  :       return MOVIE_UNSUPPORTED_BITDEPTH;

	mov	eax, -3					; fffffffdH
	jmp	$LN30@movieOpen
$LN17@movieOpen:

; 467  :    }
; 468  : 
; 469  :    /*
; 470  :       Set the decompression output format.
; 471  : 
; 472  :       If it's in 16 bit pixel-depth mode, check if it is 555 or 565
; 473  :       and set the color format of the decompression output accordingly.
; 474  :       Default is BI_RGB for 555.
; 475  :    */
; 476  : 
; 477  :    item->bihOut.bmiHeader.biCompression = BI_RGB;

	mov	eax, DWORD PTR _item$[ebp]
	mov	DWORD PTR [eax+32], 0

; 478  :    item->bihOut.bmiHeader.biSize = sizeof( BITMAPINFOHEADER );

	mov	ecx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [ecx+16], 40			; 00000028H

; 479  : 
; 480  :    if ( sd.bitCount == HICOLOR )

	cmp	DWORD PTR _sd$[ebp], 16			; 00000010H
	jne	SHORT $LN16@movieOpen

; 481  :    {
; 482  :       if ( ( sd.redMask & 0x8000 ) )

	mov	edx, DWORD PTR _sd$[ebp+4]
	and	edx, 32768				; 00008000H
	je	SHORT $LN16@movieOpen

; 483  :       {
; 484  :          /*
; 485  :             HICOLOR 565 mode.
; 486  :          */
; 487  : 
; 488  :          item->bihOut.bmiHeader.biSize = sizeof( BITMAPINFOHEADEREX );

	mov	eax, DWORD PTR _item$[ebp]
	mov	DWORD PTR [eax+16], 52			; 00000034H

; 489  :          item->bihOut.bmiHeader.biCompression = BI_BITFIELDS;

	mov	ecx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [ecx+32], 3

; 490  :          item->bihOut.redMask =
; 491  :                         sd.redMask;

	mov	edx, DWORD PTR _item$[ebp]
	mov	eax, DWORD PTR _sd$[ebp+4]
	mov	DWORD PTR [edx+56], eax

; 492  :          item->bihOut.greenMask =
; 493  :                         sd.greenMask;

	mov	ecx, DWORD PTR _item$[ebp]
	mov	edx, DWORD PTR _sd$[ebp+8]
	mov	DWORD PTR [ecx+60], edx

; 494  :          item->bihOut.blueMask =
; 495  :                         sd.blueMask;

	mov	eax, DWORD PTR _item$[ebp]
	mov	ecx, DWORD PTR _sd$[ebp+12]
	mov	DWORD PTR [eax+64], ecx
$LN16@movieOpen:

; 496  :       }
; 497  :    }
; 498  : 
; 499  :    item->bihOut.bmiHeader.biPlanes = 1;

	mov	edx, 1
	mov	eax, DWORD PTR _item$[ebp]
	mov	WORD PTR [eax+28], dx

; 500  :    item->bihOut.bmiHeader.biBitCount =
; 501  :                ( WORD ) sd.bitCount;

	mov	ecx, DWORD PTR _item$[ebp]
	mov	dx, WORD PTR _sd$[ebp]
	mov	WORD PTR [ecx+30], dx

; 502  :    item->bihOut.bmiHeader.biWidth =
; 503  :                item->aviStreams.bihIn.biWidth;

	mov	eax, DWORD PTR _item$[ebp]
	mov	ecx, DWORD PTR _item$[ebp]
	mov	edx, DWORD PTR [ecx+292]
	mov	DWORD PTR [eax+20], edx

; 504  : 
; 505  :    /*
; 506  :       Do inverted DIB.
; 507  :    */
; 508  : 
; 509  :    item->bihOut.bmiHeader.biHeight =
; 510  :                -item->aviStreams.bihIn.biHeight;

	mov	eax, DWORD PTR _item$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	neg	ecx
	mov	edx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [edx+24], ecx

; 511  : 
; 512  :    /*
; 513  :       Locate the decompress.
; 514  :    */
; 515  : 
; 516  :    item->hIC = ICDecompressOpen( ICTYPE_VIDEO,
; 517  :                   item->aviStreams.strh1.fccHandler,
; 518  :                   &( item->aviStreams.bihIn ),
; 519  :                   ( LPBITMAPINFOHEADER ) &( item->bihOut ) );

	push	2
	mov	eax, DWORD PTR _item$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	mov	ecx, DWORD PTR _item$[ebp]
	add	ecx, 288				; 00000120H
	push	ecx
	mov	edx, DWORD PTR _item$[ebp]
	mov	eax, DWORD PTR [edx+228]
	push	eax
	push	1667524982				; 63646976H
	call	_ICLocate@20
	mov	ecx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [ecx], eax

; 520  : 
; 521  :    /*
; 522  :       Exit if unable to find the decompressor.
; 523  :    */
; 524  : 
; 525  :    if ( !item->hIC )

	mov	edx, DWORD PTR _item$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN14@movieOpen

; 526  :    {
; 527  : 	  PF( "Compressor open() failed.\n" );

	push	OFFSET ??_C@_0BL@GJIIPJPD@Compressor?5open?$CI?$CJ?5failed?4?6?$AA@
	call	_MonoPrint
	add	esp, 4

; 528  :       aviClose( &( item->aviStreams ) );

	mov	eax, DWORD PTR _item$[ebp]
	add	eax, 128				; 00000080H
	push	eax
	call	_aviClose
	add	esp, 4

; 529  :       item->status = 0;

	mov	ecx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [ecx+96], 0

; 530  :       return MOVIE_OPEN_COMPRESSOR_FAILED;

	mov	eax, -4					; fffffffcH
	jmp	$LN30@movieOpen
$LN14@movieOpen:

; 531  :    }
; 532  : 
; 533  :    /*
; 534  :       Check if both input and output are supported by codec.
; 535  :    */
; 536  : 
; 537  :    if ( ICDecompressQuery( item->hIC, &( item->aviStreams.bihIn ),
; 538  :                            ( LPBITMAPINFOHEADER )
; 539  :                            &( item->bihOut ) ) != ICERR_OK )

	mov	edx, DWORD PTR _item$[ebp]
	add	edx, 16					; 00000010H
	push	edx
	mov	eax, DWORD PTR _item$[ebp]
	add	eax, 288				; 00000120H
	push	eax
	push	16395					; 0000400bH
	mov	ecx, DWORD PTR _item$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_ICSendMessage@16
	test	eax, eax
	je	SHORT $LN13@movieOpen

; 540  :    {
; 541  :       aviClose( &( item->aviStreams ) );

	mov	eax, DWORD PTR _item$[ebp]
	add	eax, 128				; 00000080H
	push	eax
	call	_aviClose
	add	esp, 4

; 542  :       item->status = 0;

	mov	ecx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [ecx+96], 0

; 543  :       return MOVIE_UNSUPPORTED_DIB;

	mov	eax, -5					; fffffffbH
	jmp	$LN30@movieOpen
$LN13@movieOpen:

; 544  :    }
; 545  : 
; 546  :    if ( ICDecompressBegin( item->hIC, &( item->aviStreams.bihIn ),
; 547  :                            ( LPBITMAPINFOHEADER )
; 548  :                            &( item->bihOut ) ) != ICERR_OK )

	mov	edx, DWORD PTR _item$[ebp]
	add	edx, 16					; 00000010H
	push	edx
	mov	eax, DWORD PTR _item$[ebp]
	add	eax, 288				; 00000120H
	push	eax
	push	16396					; 0000400cH
	mov	ecx, DWORD PTR _item$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_ICSendMessage@16
	test	eax, eax
	je	SHORT $LN12@movieOpen

; 549  :    {
; 550  :       aviClose( &( item->aviStreams ) );

	mov	eax, DWORD PTR _item$[ebp]
	add	eax, 128				; 00000080H
	push	eax
	call	_aviClose
	add	esp, 4

; 551  :       item->status = 0;

	mov	ecx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [ecx+96], 0

; 552  : 	  PF( "Unsupported DIB.\n" );

	push	OFFSET ??_C@_0BC@PPNGHBLD@Unsupported?5DIB?4?6?$AA@
	call	_MonoPrint
	add	esp, 4

; 553  :       return MOVIE_UNSUPPORTED_DIB;

	mov	eax, -5					; fffffffbH
	jmp	$LN30@movieOpen
$LN12@movieOpen:

; 554  :    }
; 555  : 
; 556  :    /*
; 557  :       Check if the movie is within a given surface.
; 558  :    */
; 559  : 
; 560  :    screenWidth = sd.dwWidth;                    // surface width

	mov	edx, DWORD PTR _sd$[ebp+16]
	mov	DWORD PTR _screenWidth$[ebp], edx

; 561  :    screenHeight = sd.dwHeight;                  // surface height

	mov	eax, DWORD PTR _sd$[ebp+20]
	mov	DWORD PTR _screenHeight$[ebp], eax

; 562  :    dibWidth = item->aviStreams.bihIn.biWidth;   // movie width

	mov	ecx, DWORD PTR _item$[ebp]
	mov	edx, DWORD PTR [ecx+292]
	mov	DWORD PTR _dibWidth$[ebp], edx

; 563  :    dibHeight = item->aviStreams.bihIn.biHeight; // movie height

	mov	eax, DWORD PTR _item$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	DWORD PTR _dibHeight$[ebp], ecx

; 564  : 
; 565  :    switch ( videoMode )

	mov	edx, DWORD PTR _videoMode$[ebp]
	mov	DWORD PTR tv291[ebp], edx
	cmp	DWORD PTR tv291[ebp], 0
	jle	$LN6@movieOpen
	cmp	DWORD PTR tv291[ebp], 2
	jle	SHORT $LN9@movieOpen
	jmp	$LN6@movieOpen
$LN9@movieOpen:

; 566  :    {
; 567  :       case MOVIE_MODE_V_DOUBLE:
; 568  :       case MOVIE_MODE_INTERLACE:
; 569  : 		  break; // THIS LINE is to fix the MPR stuff NOT returning a screen width relative to the window

	jmp	$LN10@movieOpen

; 570  :          if ( ( startX + dibWidth ) > screenWidth )

	mov	eax, DWORD PTR _startX$[ebp]
	add	eax, DWORD PTR _dibWidth$[ebp]
	cmp	eax, DWORD PTR _screenWidth$[ebp]
	jle	SHORT $LN8@movieOpen

; 571  :          {
; 572  :             ICDecompressEnd ( item->hIC );

	push	0
	push	0
	push	16398					; 0000400eH
	mov	ecx, DWORD PTR _item$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_ICSendMessage@16

; 573  :             aviClose( &( item->aviStreams ) );

	mov	eax, DWORD PTR _item$[ebp]
	add	eax, 128				; 00000080H
	push	eax
	call	_aviClose
	add	esp, 4

; 574  :             item->status = 0;

	mov	ecx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [ecx+96], 0

; 575  :             return MOVIE_BAD_STARTING_COORDINATES;

	mov	eax, -6					; fffffffaH
	jmp	$LN30@movieOpen
$LN8@movieOpen:

; 576  :          }
; 577  :          if ( ( startY + dibHeight * 2 ) > screenHeight )

	mov	edx, DWORD PTR _dibHeight$[ebp]
	mov	eax, DWORD PTR _startY$[ebp]
	lea	ecx, DWORD PTR [eax+edx*2]
	cmp	ecx, DWORD PTR _screenHeight$[ebp]
	jle	SHORT $LN7@movieOpen

; 578  :          {
; 579  :             ICDecompressEnd ( item->hIC );

	push	0
	push	0
	push	16398					; 0000400eH
	mov	edx, DWORD PTR _item$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_ICSendMessage@16

; 580  :             aviClose( &( item->aviStreams ) );

	mov	ecx, DWORD PTR _item$[ebp]
	add	ecx, 128				; 00000080H
	push	ecx
	call	_aviClose
	add	esp, 4

; 581  :             item->status = 0;

	mov	edx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [edx+96], 0

; 582  :             return MOVIE_BAD_STARTING_COORDINATES;

	mov	eax, -6					; fffffffaH
	jmp	$LN30@movieOpen
$LN7@movieOpen:

; 583  :          }
; 584  :          break;

	jmp	$LN10@movieOpen
$LN6@movieOpen:

; 585  : 
; 586  :       default:
; 587  :          if ( ( startX + dibWidth ) > screenWidth )

	mov	eax, DWORD PTR _startX$[ebp]
	add	eax, DWORD PTR _dibWidth$[ebp]
	cmp	eax, DWORD PTR _screenWidth$[ebp]
	jle	SHORT $LN5@movieOpen

; 588  :          {
; 589  :             ICDecompressEnd ( item->hIC );

	push	0
	push	0
	push	16398					; 0000400eH
	mov	ecx, DWORD PTR _item$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_ICSendMessage@16

; 590  :             aviClose( &( item->aviStreams ) );

	mov	eax, DWORD PTR _item$[ebp]
	add	eax, 128				; 00000080H
	push	eax
	call	_aviClose
	add	esp, 4

; 591  :             item->status = 0;

	mov	ecx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [ecx+96], 0

; 592  :             return MOVIE_BAD_STARTING_COORDINATES;

	mov	eax, -6					; fffffffaH
	jmp	$LN30@movieOpen
$LN5@movieOpen:

; 593  :          }
; 594  :          if ( ( startY + dibHeight ) > screenHeight )

	mov	edx, DWORD PTR _startY$[ebp]
	add	edx, DWORD PTR _dibHeight$[ebp]
	cmp	edx, DWORD PTR _screenHeight$[ebp]
	jle	SHORT $LN10@movieOpen

; 595  :          {
; 596  :             ICDecompressEnd ( item->hIC );

	push	0
	push	0
	push	16398					; 0000400eH
	mov	eax, DWORD PTR _item$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_ICSendMessage@16

; 597  :             aviClose( &( item->aviStreams ) );

	mov	edx, DWORD PTR _item$[ebp]
	add	edx, 128				; 00000080H
	push	edx
	call	_aviClose
	add	esp, 4

; 598  :             item->status = 0;

	mov	eax, DWORD PTR _item$[ebp]
	mov	DWORD PTR [eax+96], 0

; 599  :             return MOVIE_BAD_STARTING_COORDINATES;

	mov	eax, -6					; fffffffaH
	jmp	$LN30@movieOpen
$LN10@movieOpen:

; 600  :          }
; 601  :          break;
; 602  :    }
; 603  : 
; 604  :    /*
; 605  :       Initialized remaining movie variables.
; 606  :    */
; 607  : 
; 608  :    item->videoMode = videoMode;        // render mode

	mov	ecx, DWORD PTR _item$[ebp]
	mov	edx, DWORD PTR _videoMode$[ebp]
	mov	DWORD PTR [ecx+72], edx

; 609  :    item->handle = handle;              // handle to be passed to callback

	mov	eax, DWORD PTR _item$[ebp]
	mov	ecx, DWORD PTR _handle$[ebp]
	mov	DWORD PTR [eax+88], ecx

; 610  :    item->startX = startX;              // upper left x of movie

	mov	edx, DWORD PTR _item$[ebp]
	mov	eax, DWORD PTR _startX$[ebp]
	mov	DWORD PTR [edx+8], eax

; 611  :    item->startY = startY;              // upper left y of movie

	mov	ecx, DWORD PTR _item$[ebp]
	mov	edx, DWORD PTR _startY$[ebp]
	mov	DWORD PTR [ecx+12], edx

; 612  :    item->totalFrames = 0;              // frames that have been processed

	mov	eax, DWORD PTR _item$[ebp]
	mov	DWORD PTR [eax+80], 0

; 613  :    item->dropFrames = 0;               // frames being dropped

	mov	ecx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [ecx+84], 0

; 614  :    item->callBack = callBack;          // callback function

	mov	edx, DWORD PTR _item$[ebp]
	mov	eax, DWORD PTR _callBack$[ebp]
	mov	DWORD PTR [edx+124], eax

; 615  :    item->callBackID = callBackID;      // ID to be passed to callback

	mov	ecx, DWORD PTR _item$[ebp]
	mov	edx, DWORD PTR _callBackID$[ebp]
	mov	DWORD PTR [ecx+92], edx

; 616  :    item->ddSurface = ddSurface;        // destination surface

	mov	eax, DWORD PTR _item$[ebp]
	mov	ecx, DWORD PTR _ddSurface$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 617  :    item->pixelSize = item->bihOut.bmiHeader.biBitCount / 8;

	mov	edx, DWORD PTR _item$[ebp]
	movzx	eax, WORD PTR [edx+30]
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	mov	ecx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [ecx+76], eax

; 618  :                                        // output pixel in bytes
; 619  :    item->movieThreadID = 0;

	mov	edx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [edx+112], 0

; 620  :    item->audioChannel = 0;

	mov	eax, DWORD PTR _item$[ebp]
	mov	DWORD PTR [eax+856], 0

; 621  :    item->lastError = MOVIE_OK;

	mov	ecx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [ecx+864], 0

; 622  : 
; 623  :    /*
; 624  :       Buffer to hold decompressed data.
; 625  :    */
; 626  : 
; 627  : // OW
; 628  : //   if ( ddPointer && ( videoMode != MOVIE_MODE_INTERLACE ) )
; 629  :    if ( 1 )

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN3@movieOpen

; 630  :    {
; 631  :       item->sbType |= SURFACE_TYPE_DDRAW;

	mov	eax, DWORD PTR _item$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	or	ecx, 2
	mov	edx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [edx+100], ecx

; 632  :       item->surfaceBuffer = surfaceCreate( ddPointer, dibWidth, dibHeight );

	mov	eax, DWORD PTR _dibHeight$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dibWidth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ddPointer
	push	edx
	call	_surfaceCreate
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [ecx+68], eax

; 633  :    }
; 634  :    else

	jmp	SHORT $LN2@movieOpen
$LN3@movieOpen:

; 635  :    {
; 636  : //      item->surfaceBuffer = AVI_MALLOC( item->pixelSize *
; 637  : //                                    item->aviStreams.bihIn.biWidth *
; 638  : //                                    item->aviStreams.bihIn.biHeight );
; 639  :       item->surfaceBuffer = new char[item->pixelSize *
; 640  :                                     item->aviStreams.bihIn.biWidth *
; 641  :                                     item->aviStreams.bihIn.biHeight];

	mov	edx, DWORD PTR _item$[ebp]
	mov	eax, DWORD PTR _item$[ebp]
	mov	ecx, DWORD PTR [edx+76]
	imul	ecx, DWORD PTR [eax+292]
	mov	edx, DWORD PTR _item$[ebp]
	imul	ecx, DWORD PTR [edx+296]
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR _item$[ebp]
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [eax+68], ecx

; 642  :       item->sbType |= SURFACE_TYPE_SYSTEM;

	mov	edx, DWORD PTR _item$[ebp]
	mov	eax, DWORD PTR [edx+100]
	or	eax, 1
	mov	ecx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [ecx+100], eax
$LN2@movieOpen:

; 643  :    }
; 644  : 
; 645  :    if ( !item->surfaceBuffer )

	mov	edx, DWORD PTR _item$[ebp]
	cmp	DWORD PTR [edx+68], 0
	jne	SHORT $LN1@movieOpen

; 646  :    {
; 647  :       ICDecompressEnd ( item->hIC );

	push	0
	push	0
	push	16398					; 0000400eH
	mov	eax, DWORD PTR _item$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_ICSendMessage@16

; 648  :       aviClose( &( item->aviStreams ) );

	mov	edx, DWORD PTR _item$[ebp]
	add	edx, 128				; 00000080H
	push	edx
	call	_aviClose
	add	esp, 4

; 649  :       item->status = 0;

	mov	eax, DWORD PTR _item$[ebp]
	mov	DWORD PTR [eax+96], 0

; 650  : 	  PF( "No memory for movie.\n" );

	push	OFFSET ??_C@_0BG@HMJCPNEL@No?5memory?5for?5movie?4?6?$AA@
	call	_MonoPrint
	add	esp, 4

; 651  :       return MOVIE_MALLOC_FAILED;

	or	eax, -1
	jmp	SHORT $LN30@movieOpen
$LN1@movieOpen:

; 652  :    }
; 653  : 
; 654  :    InitializeCriticalSection( &( item->aviStreams.criticalSection ) );

	mov	ecx, DWORD PTR _item$[ebp]
	add	ecx, 832				; 00000340H
	push	ecx
	call	DWORD PTR __imp__InitializeCriticalSection@4

; 655  : 
; 656  : 	PF( "Movie open [EXIT].\n");

	push	OFFSET ??_C@_0BE@ENGGGLMF@Movie?5open?5?$FLEXIT?$FN?4?6?$AA@
	call	_MonoPrint
	add	esp, 4

; 657  :    return ( int ) handle;

	mov	eax, DWORD PTR _handle$[ebp]
$LN30@movieOpen:

; 658  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_movieOpen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\movie\avimovie.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 4
_i$ = -4						; size = 4
_movieUnInit PROC

; 301  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 302  :    DWORD    i;
; 303  : 
; 304  :    if ( !numOfMovies )

	cmp	DWORD PTR _numOfMovies, 0
	jne	SHORT $LN5@movieUnIni

; 305  :       return;

	jmp	$LN6@movieUnIni
$LN5@movieUnIni:

; 306  : 
; 307  :    EnterCriticalSection( &movieCriticalSection );

	push	OFFSET _movieCriticalSection
	call	DWORD PTR __imp__EnterCriticalSection@4

; 308  :    abortMovie++;

	mov	eax, DWORD PTR _abortMovie
	add	eax, 1
	mov	DWORD PTR _abortMovie, eax

; 309  :    LeaveCriticalSection( &movieCriticalSection );

	push	OFFSET _movieCriticalSection
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 310  : 
; 311  :    for ( i = 0; i < numOfMovies; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@movieUnIni
$LN3@movieUnIni:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@movieUnIni:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _numOfMovies
	jae	SHORT $LN2@movieUnIni

; 312  :       if ( movie[i].status & ( MOVIE_STATUS_IN_USE | MOVIE_STATUS_PLAYING ) )

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 880				; 00000370H
	mov	ecx, DWORD PTR _movie
	mov	edx, DWORD PTR [ecx+eax+96]
	and	edx, 17					; 00000011H
	je	SHORT $LN1@movieUnIni

; 313  :          movieClose( i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	call	_movieClose
	add	esp, 4
$LN1@movieUnIni:

; 314  : 
; 315  :    delete [] movie;

	jmp	SHORT $LN3@movieUnIni
$LN2@movieUnIni:
	mov	ecx, DWORD PTR _movie
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 316  :    ddPointer = NULL;

	mov	DWORD PTR _ddPointer, 0

; 317  :    numOfMovies = 0;

	mov	DWORD PTR _numOfMovies, 0

; 318  :    DeleteCriticalSection( &movieCriticalSection );

	push	OFFSET _movieCriticalSection
	call	DWORD PTR __imp__DeleteCriticalSection@4
$LN6@movieUnIni:

; 319  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_movieUnInit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\movie\avimovie.cpp
_TEXT	SEGMENT
$T1 = -4						; size = 4
_numMovies$ = 8						; size = 4
_lpDD$ = 12						; size = 4
_movieInit PROC

; 262  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 263  : 
; 264  : 
; 265  :    if ( numOfMovies )

	cmp	DWORD PTR _numOfMovies, 0
	je	SHORT $LN4@movieInit

; 266  :       return MOVIE_HAS_BEEN_INITIALIZED;

	mov	eax, -8					; fffffff8H
	jmp	$LN5@movieInit
$LN4@movieInit:

; 267  : 
; 268  :    if ( !numMovies || numMovies > MAX_MOVIES )

	cmp	DWORD PTR _numMovies$[ebp], 0
	je	SHORT $LN2@movieInit
	cmp	DWORD PTR _numMovies$[ebp], 4
	jle	SHORT $LN3@movieInit
$LN2@movieInit:

; 269  :       return MOVIE_INVALID_NUMBER;

	mov	eax, -9					; fffffff7H
	jmp	SHORT $LN5@movieInit
$LN3@movieInit:

; 270  : 
; 271  : //   move = AVI_MALLOC( numMovies * sizeof( MOVIE ) );
; 272  :    movie = new MOVIE[numMovies];

	xor	ecx, ecx
	mov	eax, DWORD PTR _numMovies$[ebp]
	mov	edx, 880				; 00000370H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR _movie, eax

; 273  :    if ( !movie )

	cmp	DWORD PTR _movie, 0
	jne	SHORT $LN1@movieInit

; 274  :       return MOVIE_MALLOC_FAILED;

	or	eax, -1
	jmp	SHORT $LN5@movieInit
$LN1@movieInit:

; 275  : 
; 276  :    abortMovie = 0;

	mov	DWORD PTR _abortMovie, 0

; 277  :    memset( movie, 0, numMovies * sizeof( MOVIE ) );

	mov	ecx, DWORD PTR _numMovies$[ebp]
	imul	ecx, 880				; 00000370H
	push	ecx
	push	0
	mov	edx, DWORD PTR _movie
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 278  :    numOfMovies = numMovies;

	mov	eax, DWORD PTR _numMovies$[ebp]
	mov	DWORD PTR _numOfMovies, eax

; 279  : 
; 280  :    InitializeCriticalSection( &movieCriticalSection );

	push	OFFSET _movieCriticalSection
	call	DWORD PTR __imp__InitializeCriticalSection@4

; 281  : 
; 282  :    ddPointer = lpDD;

	mov	ecx, DWORD PTR _lpDD$[ebp]
	mov	DWORD PTR _ddPointer, ecx

; 283  : 
; 284  :    return MOVIE_OK;

	xor	eax, eax
$LN5@movieInit:

; 285  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_movieInit ENDP
_TEXT	ENDS
END
