; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\movie\SURFACE.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_surfaceGetPointer
PUBLIC	_surfaceReleasePointer
PUBLIC	_surfaceGetDescription
PUBLIC	_surfaceCreate
PUBLIC	_surfaceRelease
PUBLIC	_surfaceBlit
EXTRN	_memset:PROC
EXTRN	?F4IsBadReadPtr@@YA_NPBXI@Z:PROC		; F4IsBadReadPtr
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___security_cookie:DWORD
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\movie\surface.cpp
_TEXT	SEGMENT
_hr$ = -56						; size = 4
_pDSSrc$ = -52						; size = 4
_pDSDst$ = -48						; size = 4
_dstHeight$ = -44					; size = 4
tv78 = -40						; size = 4
_dstRectangle$ = -36					; size = 16
_srcRectangle$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_dstSurface$ = 8					; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_srcSurface$ = 20					; size = 4
_srcWidth$ = 24						; size = 4
_srcHeight$ = 28					; size = 4
_mode$ = 32						; size = 4
_surfaceBlit PROC

; 247  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 248  :     int     dstHeight;
; 249  :     RECT    srcRectangle, dstRectangle;
; 250  : 
; 251  :     if ( mode == BLIT_MODE_NORMAL )

	cmp	DWORD PTR _mode$[ebp], 0
	jne	SHORT $LN2@surfaceBli

; 252  :         dstHeight = srcHeight;

	mov	eax, DWORD PTR _srcHeight$[ebp]
	mov	DWORD PTR _dstHeight$[ebp], eax

; 253  :     else

	jmp	SHORT $LN1@surfaceBli
$LN2@surfaceBli:

; 254  :         dstHeight = srcHeight * 2;

	mov	ecx, DWORD PTR _srcHeight$[ebp]
	shl	ecx, 1
	mov	DWORD PTR _dstHeight$[ebp], ecx
$LN1@surfaceBli:

; 255  : 
; 256  :     srcRectangle.left = 0;

	mov	DWORD PTR _srcRectangle$[ebp], 0

; 257  :     srcRectangle.top = 0;

	mov	DWORD PTR _srcRectangle$[ebp+4], 0

; 258  :     srcRectangle.right = srcWidth;

	mov	edx, DWORD PTR _srcWidth$[ebp]
	mov	DWORD PTR _srcRectangle$[ebp+8], edx

; 259  :     srcRectangle.bottom = srcHeight;

	mov	eax, DWORD PTR _srcHeight$[ebp]
	mov	DWORD PTR _srcRectangle$[ebp+12], eax

; 260  : 
; 261  :     dstRectangle.left = x;

	mov	ecx, DWORD PTR _x$[ebp]
	mov	DWORD PTR _dstRectangle$[ebp], ecx

; 262  :     dstRectangle.top = y;

	mov	edx, DWORD PTR _y$[ebp]
	mov	DWORD PTR _dstRectangle$[ebp+4], edx

; 263  :     dstRectangle.right = x + srcWidth;

	mov	eax, DWORD PTR _x$[ebp]
	add	eax, DWORD PTR _srcWidth$[ebp]
	mov	DWORD PTR _dstRectangle$[ebp+8], eax

; 264  :     dstRectangle.bottom = y + dstHeight;

	mov	ecx, DWORD PTR _y$[ebp]
	add	ecx, DWORD PTR _dstHeight$[ebp]
	mov	DWORD PTR _dstRectangle$[ebp+12], ecx

; 265  : 
; 266  : // OW
; 267  : #if 0
; 268  :     if( MPRBlt( ( UInt ) srcSurface, ( UInt ) dstSurface, &srcRectangle, &dstRectangle ) )
; 269  :         return 0;
; 270  :     else
; 271  :         return -1;
; 272  : #else
; 273  : 	IDirectDrawSurface7 *pDSSrc = (IDirectDrawSurface7 *) srcSurface;

	mov	edx, DWORD PTR _srcSurface$[ebp]
	mov	DWORD PTR _pDSSrc$[ebp], edx

; 274  : 	IDirectDrawSurface7 *pDSDst = (IDirectDrawSurface7 *) dstSurface;

	mov	eax, DWORD PTR _dstSurface$[ebp]
	mov	DWORD PTR _pDSDst$[ebp], eax

; 275  : 	HRESULT hr = pDSDst->Blt(&dstRectangle, pDSSrc, &srcRectangle, DDBLT_WAIT, NULL);

	push	0
	push	16777216				; 01000000H
	lea	ecx, DWORD PTR _srcRectangle$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pDSSrc$[ebp]
	push	edx
	lea	eax, DWORD PTR _dstRectangle$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDSDst$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pDSDst$[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+20]
	call	ecx
	mov	DWORD PTR _hr$[ebp], eax

; 276  : 	return SUCCEEDED(hr) ? 0 : -1;

	cmp	DWORD PTR _hr$[ebp], 0
	jl	SHORT $LN5@surfaceBli
	mov	DWORD PTR tv78[ebp], 0
	jmp	SHORT $LN6@surfaceBli
$LN5@surfaceBli:
	mov	DWORD PTR tv78[ebp], -1
$LN6@surfaceBli:
	mov	eax, DWORD PTR tv78[ebp]

; 277  : #endif
; 278  : 
; 279  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_surfaceBlit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\movie\surface.cpp
_TEXT	SEGMENT
_pDS$ = -4						; size = 4
_surface$ = 8						; size = 4
_surfaceRelease PROC

; 217  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 218  : // OW
; 219  : #if 0
; 220  :    MPRReleaseSurface( ( UInt ) surface );
; 221  : #else
; 222  : 	IDirectDrawSurface7 *pDS = (IDirectDrawSurface7 *) surface;

	mov	eax, DWORD PTR _surface$[ebp]
	mov	DWORD PTR _pDS$[ebp], eax

; 223  : 	if(pDS) pDS->Release();

	cmp	DWORD PTR _pDS$[ebp], 0
	je	SHORT $LN2@surfaceRel
	mov	ecx, DWORD PTR _pDS$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pDS$[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+8]
	call	ecx
$LN2@surfaceRel:

; 224  : #endif
; 225  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_surfaceRelease ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\movie\surface.cpp
_TEXT	SEGMENT
_hr$ = -264						; size = 4
_pDS$ = -260						; size = 4
_pDD$ = -256						; size = 4
_ddsdMode$ = -252					; size = 124
_ddsd$1 = -128						; size = 124
__$ArrayPad$ = -4					; size = 4
_ddPointer$ = 8						; size = 4
_dibWidth$ = 12						; size = 4
_dibHeight$ = 16					; size = 4
_surfaceCreate PROC

; 170  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 171  : // OW 
; 172  : #if 0
; 173  :     return ( LPVOID ) MPRCreateSurface( ( UInt ) ddPointer, dibWidth, dibHeight,
; 174  :                                         SystemMem, None, NULL, 0, 0 );
; 175  : #else
; 176  : 	IDirectDraw7 *pDD = (IDirectDraw7 *) ddPointer;

	mov	eax, DWORD PTR _ddPointer$[ebp]
	mov	DWORD PTR _pDD$[ebp], eax

; 177  : 	IDirectDrawSurface7 *pDS = NULL;

	mov	DWORD PTR _pDS$[ebp], 0

; 178  : 
; 179  : 	// Get mode caps
; 180  : 	DDSURFACEDESC2 ddsdMode;
; 181  : 	ZeroMemory(&ddsdMode, sizeof(ddsdMode));

	push	124					; 0000007cH
	push	0
	lea	ecx, DWORD PTR _ddsdMode$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 182  : 	ddsdMode.dwSize = sizeof(ddsdMode);

	mov	DWORD PTR _ddsdMode$[ebp], 124		; 0000007cH

; 183  : 	HRESULT hr = pDD->GetDisplayMode(&ddsdMode);

	lea	edx, DWORD PTR _ddsdMode$[ebp]
	push	edx
	mov	eax, DWORD PTR _pDD$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pDD$[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+48]
	call	eax
	mov	DWORD PTR _hr$[ebp], eax

; 184  : 
; 185  : 	if(SUCCEEDED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jl	SHORT $LN1@surfaceCre

; 186  : 	{
; 187  : 		DDSURFACEDESC2 ddsd;
; 188  : 		ZeroMemory(&ddsd, sizeof(ddsd));

	push	124					; 0000007cH
	push	0
	lea	ecx, DWORD PTR _ddsd$1[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 189  : 		ddsd.dwFlags = DDSD_CAPS | DDSD_PIXELFORMAT;

	mov	DWORD PTR _ddsd$1[ebp+4], 4097		; 00001001H

; 190  : 		ddsd.dwSize = sizeof(ddsd);

	mov	DWORD PTR _ddsd$1[ebp], 124		; 0000007cH

; 191  : 		ddsd.ddpfPixelFormat = ddsdMode.ddpfPixelFormat;

	mov	ecx, 8
	lea	esi, DWORD PTR _ddsdMode$[ebp+72]
	lea	edi, DWORD PTR _ddsd$1[ebp+72]
	rep movsd

; 192  : 		
; 193  : 		ddsd.dwFlags |= DDSD_WIDTH | DDSD_HEIGHT;

	mov	edx, DWORD PTR _ddsd$1[ebp+4]
	or	edx, 6
	mov	DWORD PTR _ddsd$1[ebp+4], edx

; 194  : 		ddsd.dwWidth  = dibWidth;

	mov	eax, DWORD PTR _dibWidth$[ebp]
	mov	DWORD PTR _ddsd$1[ebp+12], eax

; 195  : 		ddsd.dwHeight = dibHeight; 

	mov	ecx, DWORD PTR _dibHeight$[ebp]
	mov	DWORD PTR _ddsd$1[ebp+8], ecx

; 196  : 		ddsd.ddsCaps.dwCaps = DDSCAPS_SYSTEMMEMORY | DDSCAPS_OFFSCREENPLAIN; 

	mov	DWORD PTR _ddsd$1[ebp+104], 2112	; 00000840H

; 197  : 		hr = pDD->CreateSurface(&ddsd, &pDS, NULL);

	push	0
	lea	edx, DWORD PTR _pDS$[ebp]
	push	edx
	lea	eax, DWORD PTR _ddsd$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDD$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pDD$[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+24]
	call	ecx
	mov	DWORD PTR _hr$[ebp], eax
$LN1@surfaceCre:

; 198  : 	}
; 199  : 
; 200  : 	return pDS;

	mov	eax, DWORD PTR _pDS$[ebp]

; 201  : #endif
; 202  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_surfaceCreate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\movie\surface.cpp
_TEXT	SEGMENT
_hr$ = -136						; size = 4
_pDS$ = -132						; size = 4
_ddsd$ = -128						; size = 124
__$ArrayPad$ = -4					; size = 4
_surface$ = 8						; size = 4
_sd$ = 12						; size = 4
_surfaceGetDescription PROC

; 118  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 136				; 00000088H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 119  : #if 0
; 120  :     MPRSurfaceDescription   mprsd;
; 121  : 
; 122  :     MPRGetSurfaceDescription( ( UInt ) surface, &mprsd );
; 123  : 
; 124  :     sd->dwWidth     = mprsd.width;
; 125  :     sd->dwHeight    = mprsd.height;
; 126  :     sd->lPitch      = mprsd.pitch;
; 127  :     sd->bitCount    = mprsd.RGBBitCount;
; 128  :     sd->redMask     = mprsd.RBitMask;
; 129  :     sd->greenMask   = mprsd.GBitMask;
; 130  :     sd->blueMask    = mprsd.BBitMask;
; 131  : #else
; 132  : 	IDirectDrawSurface7 *pDS = (IDirectDrawSurface7 *) surface;

	mov	eax, DWORD PTR _surface$[ebp]
	mov	DWORD PTR _pDS$[ebp], eax

; 133  : 
; 134  : 	DDSURFACEDESC2 ddsd;
; 135  : 	ZeroMemory(&ddsd, sizeof(ddsd));

	push	124					; 0000007cH
	push	0
	lea	ecx, DWORD PTR _ddsd$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 136  : 	ddsd.dwSize = sizeof(DDSURFACEDESC2);

	mov	DWORD PTR _ddsd$[ebp], 124		; 0000007cH

; 137  : 	HRESULT hr = -1; // JB 010220 CTD

	mov	DWORD PTR _hr$[ebp], -1

; 138  : 	if (pDS && !F4IsBadReadPtr(pDS, sizeof(IDirectDrawSurface7))) // JB 010220 CTD

	cmp	DWORD PTR _pDS$[ebp], 0
	je	SHORT $LN2@surfaceGet
	push	4
	mov	edx, DWORD PTR _pDS$[ebp]
	push	edx
	call	?F4IsBadReadPtr@@YA_NPBXI@Z		; F4IsBadReadPtr
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@surfaceGet

; 139  : 		hr = pDS->GetSurfaceDesc(&ddsd);

	lea	ecx, DWORD PTR _ddsd$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pDS$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pDS$[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax+88]
	call	edx
	mov	DWORD PTR _hr$[ebp], eax
$LN2@surfaceGet:

; 140  : 
; 141  : 	if(SUCCEEDED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jl	SHORT $LN3@surfaceGet

; 142  : 	{
; 143  : 		sd->dwWidth     = ddsd.dwWidth;

	mov	eax, DWORD PTR _sd$[ebp]
	mov	ecx, DWORD PTR _ddsd$[ebp+12]
	mov	DWORD PTR [eax+16], ecx

; 144  : 		sd->dwHeight    = ddsd.dwHeight;

	mov	edx, DWORD PTR _sd$[ebp]
	mov	eax, DWORD PTR _ddsd$[ebp+8]
	mov	DWORD PTR [edx+20], eax

; 145  : 		sd->lPitch      = ddsd.lPitch;

	mov	ecx, DWORD PTR _sd$[ebp]
	mov	edx, DWORD PTR _ddsd$[ebp+16]
	mov	DWORD PTR [ecx+24], edx

; 146  : 		sd->bitCount    = ddsd.ddpfPixelFormat.dwRGBBitCount;

	mov	eax, DWORD PTR _sd$[ebp]
	mov	ecx, DWORD PTR _ddsd$[ebp+84]
	mov	DWORD PTR [eax], ecx

; 147  : 		sd->redMask     = ddsd.ddpfPixelFormat.dwRBitMask;

	mov	edx, DWORD PTR _sd$[ebp]
	mov	eax, DWORD PTR _ddsd$[ebp+88]
	mov	DWORD PTR [edx+4], eax

; 148  : 		sd->greenMask   = ddsd.ddpfPixelFormat.dwGBitMask;

	mov	ecx, DWORD PTR _sd$[ebp]
	mov	edx, DWORD PTR _ddsd$[ebp+92]
	mov	DWORD PTR [ecx+8], edx

; 149  : 		sd->blueMask    = ddsd.ddpfPixelFormat.dwBBitMask;

	mov	eax, DWORD PTR _sd$[ebp]
	mov	ecx, DWORD PTR _ddsd$[ebp+96]
	mov	DWORD PTR [eax+12], ecx
$LN3@surfaceGet:

; 150  : 	}
; 151  : #endif
; 152  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_surfaceGetDescription ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\movie\surface.cpp
_TEXT	SEGMENT
_hr$ = -8						; size = 4
_pDS$ = -4						; size = 4
_surface$ = 8						; size = 4
_sa$ = 12						; size = 4
_surfaceReleasePointer PROC

; 90   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 91   : // OW 
; 92   : #if 0
; 93   :     MPRUnlockSurface( ( UInt ) surface );
; 94   :     sa->lockStatus = SURFACE_IS_UNLOCKED;
; 95   : #else
; 96   : 	IDirectDrawSurface7 *pDS = (IDirectDrawSurface7 *) surface;

	mov	eax, DWORD PTR _surface$[ebp]
	mov	DWORD PTR _pDS$[ebp], eax

; 97   : 
; 98   : 	HRESULT hr = pDS->Unlock(NULL);

	push	0
	mov	ecx, DWORD PTR _pDS$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pDS$[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+128]
	call	ecx
	mov	DWORD PTR _hr$[ebp], eax

; 99   : 	if(SUCCEEDED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jl	SHORT $LN2@surfaceRel

; 100  : 	    sa->lockStatus = SURFACE_IS_UNLOCKED;

	mov	edx, DWORD PTR _sa$[ebp]
	mov	DWORD PTR [edx+8], 0
$LN2@surfaceRel:

; 101  : #endif
; 102  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_surfaceReleasePointer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\movie\surface.cpp
_TEXT	SEGMENT
_hr$ = -136						; size = 4
_pDS$ = -132						; size = 4
_ddsd$ = -128						; size = 124
__$ArrayPad$ = -4					; size = 4
_surface$ = 8						; size = 4
_sa$ = 12						; size = 4
_surfaceGetPointer PROC

; 37   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 136				; 00000088H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 38   : // OW 
; 39   : #if 0
; 40   :     MPRSurfaceDescription   sd;
; 41   : 
; 42   :     MPRGetSurfaceDescription( ( UInt ) surface, &sd );
; 43   :     sa->surfacePtr = ( LPVOID ) MPRLockSurface( ( UInt ) surface );
; 44   :     if( sa->surfacePtr )
; 45   :         sa->lockStatus = SURFACE_IS_LOCKED;
; 46   :     else
; 47   :         sa->lockStatus = SURFACE_IS_UNLOCKED;
; 48   : 
; 49   :     sa->lPitch = sd.pitch;
; 50   : #else
; 51   : 	IDirectDrawSurface7 *pDS = (IDirectDrawSurface7 *) surface;

	mov	eax, DWORD PTR _surface$[ebp]
	mov	DWORD PTR _pDS$[ebp], eax

; 52   : 
; 53   : 	DDSURFACEDESC2 ddsd;
; 54   : 	ZeroMemory(&ddsd, sizeof(ddsd));

	push	124					; 0000007cH
	push	0
	lea	ecx, DWORD PTR _ddsd$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 55   : 	ddsd.dwSize = sizeof(ddsd);

	mov	DWORD PTR _ddsd$[ebp], 124		; 0000007cH

; 56   : 
; 57   : 	HRESULT hr = pDS->Lock(NULL, &ddsd, DDLOCK_WAIT | DDLOCK_WRITEONLY | DDLOCK_SURFACEMEMORYPTR, NULL);

	push	0
	push	33					; 00000021H
	lea	edx, DWORD PTR _ddsd$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _pDS$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pDS$[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+100]
	call	eax
	mov	DWORD PTR _hr$[ebp], eax

; 58   : 
; 59   : 	if(SUCCEEDED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jl	SHORT $LN2@surfaceGet

; 60   : 	{
; 61   : 		sa->surfacePtr = ddsd.lpSurface;

	mov	ecx, DWORD PTR _sa$[ebp]
	mov	edx, DWORD PTR _ddsd$[ebp+36]
	mov	DWORD PTR [ecx], edx

; 62   :         sa->lockStatus = SURFACE_IS_LOCKED;

	mov	eax, DWORD PTR _sa$[ebp]
	mov	DWORD PTR [eax+8], 1

; 63   : 	    sa->lPitch = ddsd.lPitch;

	mov	ecx, DWORD PTR _sa$[ebp]
	mov	edx, DWORD PTR _ddsd$[ebp+16]
	mov	DWORD PTR [ecx+4], edx

; 64   : 	}
; 65   : 
; 66   : 	else

	jmp	SHORT $LN3@surfaceGet
$LN2@surfaceGet:

; 67   : 	{
; 68   : 		sa->surfacePtr = NULL;

	mov	eax, DWORD PTR _sa$[ebp]
	mov	DWORD PTR [eax], 0

; 69   : 		sa->lockStatus = SURFACE_IS_UNLOCKED;

	mov	ecx, DWORD PTR _sa$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 70   : 	    sa->lPitch = 0;

	mov	edx, DWORD PTR _sa$[ebp]
	mov	DWORD PTR [edx+4], 0
$LN3@surfaceGet:

; 71   : 	}
; 72   : #endif
; 73   : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_surfaceGetPointer ENDP
_TEXT	ENDS
END
