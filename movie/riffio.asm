; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\movie\riffio.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
PUBLIC	_aviOpen
PUBLIC	_aviClose
PUBLIC	_aviReadRecord
PUBLIC	_waveReadBlock
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_memset:PROC
EXTRN	__imp__EnterCriticalSection@4:PROC
EXTRN	__imp__LeaveCriticalSection@4:PROC
EXTRN	__close:PROC
EXTRN	__lseek:PROC
EXTRN	__read:PROC
EXTRN	?_open@@YAHPBDHH@Z:PROC				; _open
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___security_cookie:DWORD
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\movie\riffio.cpp
_TEXT	SEGMENT
_newPtr$ = -20						; size = 4
_ptr$ = -16						; size = 4
_len$ = -12						; size = 4
_size$ = -8						; size = 4
_blockLen$ = -4						; size = 4
_streams$ = 8						; size = 4
_waveReadBlock PROC

; 743  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 744  :    long           ptr, newPtr, len, size;
; 745  :    long           blockLen;
; 746  : 
; 747  :    if ( !( streams->audioFlag & STREAM_AUDIO_ON ) )

	mov	eax, DWORD PTR _streams$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 1
	jne	SHORT $LN9@waveReadBl

; 748  :       return RIFF_OK;

	xor	eax, eax
	jmp	$LN10@waveReadBl
$LN9@waveReadBl:

; 749  : 
; 750  :    blockLen = streams->audioToReadPerFrame;

	mov	edx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR _blockLen$[ebp], eax

; 751  : 
; 752  :    if ( streams->totalAudioRemaining < blockLen )

	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	cmp	edx, DWORD PTR _blockLen$[ebp]
	jge	SHORT $LN8@waveReadBl

; 753  :       blockLen = streams->totalAudioRemaining;

	mov	eax, DWORD PTR _streams$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR _blockLen$[ebp], ecx
$LN8@waveReadBl:

; 754  : 
; 755  :    if ( !blockLen )

	cmp	DWORD PTR _blockLen$[ebp], 0
	jne	SHORT $LN7@waveReadBl

; 756  :       return RIFF_AUDIO_END_FILE;

	mov	eax, 2
	jmp	$LN10@waveReadBl
$LN7@waveReadBl:

; 757  : 
; 758  :    streams->totalAudioRemaining -= blockLen;

	mov	edx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR [edx+28]
	sub	eax, DWORD PTR _blockLen$[ebp]
	mov	ecx, DWORD PTR _streams$[ebp]
	mov	DWORD PTR [ecx+28], eax

; 759  : 
; 760  :    ptr = ( long ) streams->waveBuffer;

	mov	edx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR [edx+284]
	mov	DWORD PTR _ptr$[ebp], eax

; 761  :    newPtr = streams->waveBufferWrite + blockLen -
; 762  :                streams->waveBufferLen;

	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	add	edx, DWORD PTR _blockLen$[ebp]
	mov	eax, DWORD PTR _streams$[ebp]
	sub	edx, DWORD PTR [eax+292]
	mov	DWORD PTR _newPtr$[ebp], edx

; 763  : 
; 764  :    if ( newPtr <= 0 )

	cmp	DWORD PTR _newPtr$[ebp], 0
	jg	$LN6@waveReadBl

; 765  :    {
; 766  :       len = AVI_READ( streams->externalSoundHandle,
; 767  :                ( ( char * ) ( ptr + \
; 768  :                streams->waveBufferWrite ) ), \
; 769  :                blockLen );

	mov	ecx, DWORD PTR _blockLen$[ebp]
	push	ecx
	mov	edx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, DWORD PTR [edx+296]
	push	eax
	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	__read
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _len$[ebp], eax

; 770  :       if ( len != blockLen )

	mov	eax, DWORD PTR _len$[ebp]
	cmp	eax, DWORD PTR _blockLen$[ebp]
	je	SHORT $LN5@waveReadBl

; 771  :          return RIFF_BAD_AUDIO_FORMAT;

	mov	eax, -7					; fffffff9H
	jmp	$LN10@waveReadBl
$LN5@waveReadBl:

; 772  : 
; 773  :       streams->waveBufferWrite += blockLen;

	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	add	edx, DWORD PTR _blockLen$[ebp]
	mov	eax, DWORD PTR _streams$[ebp]
	mov	DWORD PTR [eax+296], edx

; 774  :       if ( streams->waveBufferWrite == streams->waveBufferLen )

	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR [ecx+296]
	cmp	eax, DWORD PTR [edx+292]
	jne	SHORT $LN4@waveReadBl

; 775  :          streams->waveBufferWrite = 0;

	mov	ecx, DWORD PTR _streams$[ebp]
	mov	DWORD PTR [ecx+296], 0
$LN4@waveReadBl:

; 776  : 
; 777  :       EnterCriticalSection ( &( streams->criticalSection ) );

	mov	edx, DWORD PTR _streams$[ebp]
	add	edx, 704				; 000002c0H
	push	edx
	call	DWORD PTR __imp__EnterCriticalSection@4

; 778  : 
; 779  :       streams->dataInWaveBuffer += blockLen;

	mov	eax, DWORD PTR _streams$[ebp]
	mov	ecx, DWORD PTR [eax+288]
	add	ecx, DWORD PTR _blockLen$[ebp]
	mov	edx, DWORD PTR _streams$[ebp]
	mov	DWORD PTR [edx+288], ecx

; 780  : 
; 781  :       LeaveCriticalSection ( &( streams->criticalSection ) );

	mov	eax, DWORD PTR _streams$[ebp]
	add	eax, 704				; 000002c0H
	push	eax
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 782  :    }
; 783  :    else

	jmp	$LN3@waveReadBl
$LN6@waveReadBl:

; 784  :    {
; 785  :       size = streams->waveBufferLen - streams->waveBufferWrite;

	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR [ecx+292]
	sub	eax, DWORD PTR [edx+296]
	mov	DWORD PTR _size$[ebp], eax

; 786  :       len = AVI_READ( streams->externalSoundHandle,
; 787  :                      ( ( char * ) ( ptr + \
; 788  :                      streams->waveBufferWrite ) ), \
; 789  :                      size );

	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, DWORD PTR [edx+296]
	push	eax
	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	__read
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _len$[ebp], eax

; 790  : 
; 791  :       if ( len != size )

	mov	eax, DWORD PTR _len$[ebp]
	cmp	eax, DWORD PTR _size$[ebp]
	je	SHORT $LN2@waveReadBl

; 792  :          return RIFF_BAD_AUDIO_FORMAT;

	mov	eax, -7					; fffffff9H
	jmp	$LN10@waveReadBl
$LN2@waveReadBl:

; 793  : 
; 794  :       streams->waveBufferWrite = 0;

	mov	ecx, DWORD PTR _streams$[ebp]
	mov	DWORD PTR [ecx+296], 0

; 795  : 
; 796  :       size = blockLen - size;

	mov	edx, DWORD PTR _blockLen$[ebp]
	sub	edx, DWORD PTR _size$[ebp]
	mov	DWORD PTR _size$[ebp], edx

; 797  :       len = AVI_READ( streams->externalSoundHandle,
; 798  :                      ( ( char * ) ( ptr + \
; 799  :                      streams->waveBufferWrite ) ), \
; 800  :                      size );

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR _ptr$[ebp]
	add	edx, DWORD PTR [ecx+296]
	push	edx
	mov	eax, DWORD PTR _streams$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	__read
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _len$[ebp], eax

; 801  : 
; 802  :       if ( len != size )

	mov	edx, DWORD PTR _len$[ebp]
	cmp	edx, DWORD PTR _size$[ebp]
	je	SHORT $LN1@waveReadBl

; 803  :          return RIFF_BAD_AUDIO_FORMAT;

	mov	eax, -7					; fffffff9H
	jmp	SHORT $LN10@waveReadBl
$LN1@waveReadBl:

; 804  : 
; 805  :       streams->waveBufferWrite += size;

	mov	eax, DWORD PTR _streams$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	add	ecx, DWORD PTR _size$[ebp]
	mov	edx, DWORD PTR _streams$[ebp]
	mov	DWORD PTR [edx+296], ecx

; 806  : 
; 807  :       EnterCriticalSection ( &( streams->criticalSection ) );

	mov	eax, DWORD PTR _streams$[ebp]
	add	eax, 704				; 000002c0H
	push	eax
	call	DWORD PTR __imp__EnterCriticalSection@4

; 808  : 
; 809  :       streams->dataInWaveBuffer += blockLen;

	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR [ecx+288]
	add	edx, DWORD PTR _blockLen$[ebp]
	mov	eax, DWORD PTR _streams$[ebp]
	mov	DWORD PTR [eax+288], edx

; 810  : 
; 811  :       LeaveCriticalSection ( &( streams->criticalSection ) );

	mov	ecx, DWORD PTR _streams$[ebp]
	add	ecx, 704				; 000002c0H
	push	ecx
	call	DWORD PTR __imp__LeaveCriticalSection@4
$LN3@waveReadBl:

; 812  :    }
; 813  : 
; 814  :    return RIFF_OK;

	xor	eax, eax
$LN10@waveReadBl:

; 815  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_waveReadBlock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\movie\riffio.cpp
_TEXT	SEGMENT
_subChunk$ = -64					; size = 8
$T1 = -56						; size = 4
$T2 = -52						; size = 4
_newPtr$ = -48						; size = 4
tv140 = -44						; size = 4
$T3 = -40						; size = 4
$T4 = -36						; size = 4
_ptr$ = -32						; size = 4
_streamCount$ = -28					; size = 4
_size$ = -24						; size = 4
_token$ = -20						; size = 4
_recordLen$ = -16					; size = 4
_len$ = -12						; size = 4
_nextBlock$ = -8					; size = 4
_chunkLength$ = -4					; size = 4
_streams$ = 8						; size = 4
_aviReadRecord PROC

; 490  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H

; 491  :    RIFFSUBCHUNK      subChunk;
; 492  :    long              token;
; 493  :    DWORD             streamCount;
; 494  :    long              len, newPtr, size;
; 495  :    long              ptr;
; 496  :    long              recordLen;
; 497  :    long              chunkLength;
; 498  :    PVIDBLOCK         nextBlock;
; 499  : 
; 500  :    streamCount = streams->mainAVIHeader.dwStreams;

	mov	eax, DWORD PTR _streams$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	DWORD PTR _streamCount$[ebp], ecx

; 501  : 
; 502  :    if ( streamCount == 1 )

	cmp	DWORD PTR _streamCount$[ebp], 1
	jne	$LN38@aviReadRec

; 503  :    {
; 504  :       /*
; 505  :          No 'rec ' header if single stream.
; 506  :       */
; 507  : 
; 508  :       if ( AVI_READ( streams->handle, &subChunk, RIFF_SUB_CHUNK ) !=
; 509  :                      RIFF_SUB_CHUNK )

	push	8
	lea	edx, DWORD PTR _subChunk$[ebp]
	push	edx
	mov	eax, DWORD PTR _streams$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	__read
	add	esp, 12					; 0000000cH
	cmp	eax, 8
	je	SHORT $LN37@aviReadRec

; 510  :          return RIFF_BAD_FORMAT;

	mov	eax, -2					; fffffffeH
	jmp	$LN39@aviReadRec
$LN37@aviReadRec:

; 511  : 
; 512  :       /*
; 513  :          End of video stream.
; 514  :       */
; 515  : 
; 516  :       if ( subChunk.subChunkID == RIFFCODE( 'i', 'd', 'x', '1' ) )

	cmp	DWORD PTR _subChunk$[ebp], 829973609	; 31786469H
	jne	SHORT $LN36@aviReadRec

; 517  :          return RIFF_END_FILE;

	mov	eax, 1
	jmp	$LN39@aviReadRec
$LN36@aviReadRec:

; 518  : 
; 519  :       nextBlock = streams->nextBlockToFill;

	mov	edx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR [edx+692]
	mov	DWORD PTR _nextBlock$[ebp], eax

; 520  : 
; 521  :       if ( nextBlock->bufferSize < ( DWORD ) subChunk.subChunkLength )

	mov	ecx, DWORD PTR _nextBlock$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR _subChunk$[ebp+4]
	jae	SHORT $LN35@aviReadRec

; 522  :       {
; 523  :          delete [] nextBlock->buffer;

	mov	eax, DWORD PTR _nextBlock$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T4[ebp], ecx
	mov	edx, DWORD PTR $T4[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 524  : //         nextBlock->buffer = AVI_MALLOC( subChunk.subChunkLength );
; 525  :          nextBlock->buffer = new char[subChunk.subChunkLength];

	mov	eax, DWORD PTR _subChunk$[ebp+4]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	ecx, DWORD PTR _nextBlock$[ebp]
	mov	edx, DWORD PTR $T3[ebp]
	mov	DWORD PTR [ecx+8], edx

; 526  : 
; 527  :          if ( !( nextBlock->buffer ) )

	mov	eax, DWORD PTR _nextBlock$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN34@aviReadRec

; 528  :             return RIFF_REALLOC_FAILED;

	mov	eax, -5					; fffffffbH
	jmp	$LN39@aviReadRec
$LN34@aviReadRec:

; 529  : 
; 530  :          nextBlock->bufferSize = subChunk.subChunkLength;

	mov	ecx, DWORD PTR _nextBlock$[ebp]
	mov	edx, DWORD PTR _subChunk$[ebp+4]
	mov	DWORD PTR [ecx], edx
$LN35@aviReadRec:

; 531  :       }
; 532  : 
; 533  :       len = AVI_READ( streams->handle, \
; 534  :                         nextBlock->buffer, \
; 535  :                         subChunk.subChunkLength );

	mov	eax, DWORD PTR _subChunk$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _nextBlock$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _streams$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	__read
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _len$[ebp], eax

; 536  : 
; 537  :       if ( len != subChunk.subChunkLength )

	mov	edx, DWORD PTR _len$[ebp]
	cmp	edx, DWORD PTR _subChunk$[ebp+4]
	je	SHORT $LN33@aviReadRec

; 538  :          return RIFF_BAD_FORMAT;

	mov	eax, -2					; fffffffeH
	jmp	$LN39@aviReadRec
$LN33@aviReadRec:

; 539  :       nextBlock->currentBlockSize = len;

	mov	eax, DWORD PTR _nextBlock$[ebp]
	mov	ecx, DWORD PTR _len$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 540  :       streams->nextBlockToFill = streams->nextBlockToFill->next;

	mov	edx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR [edx+692]
	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+692], edx

; 541  :    }
; 542  :    else

	jmp	$LN32@aviReadRec
$LN38@aviReadRec:

; 543  :    {
; 544  :       /*
; 545  :          LIST (   'rec '
; 546  :                   '00id'   ( <Video> )
; 547  :                   '01wb'   ( <Audio> )
; 548  :          LIST (   'rec '
; 549  :                   .
; 550  :                   .
; 551  :                   .
; 552  : 
; 553  :          LIST and size should be in 'preRECSubChunk'.
; 554  :          Adjust length to exclude 'rec'.
; 555  :       */
; 556  : 
; 557  :       recordLen = streams->preRECSubChunk.subChunkLength - 4;

	mov	eax, DWORD PTR _streams$[ebp]
	mov	ecx, DWORD PTR [eax+700]
	sub	ecx, 4
	mov	DWORD PTR _recordLen$[ebp], ecx

; 558  : 
; 559  :       if ( AVI_READ( streams->handle, &token,
; 560  :                      RIFF_TOKEN_SIZE ) != RIFF_TOKEN_SIZE )

	push	4
	lea	edx, DWORD PTR _token$[ebp]
	push	edx
	mov	eax, DWORD PTR _streams$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	__read
	add	esp, 12					; 0000000cH
	cmp	eax, 4
	je	SHORT $LN31@aviReadRec

; 561  :          return RIFF_BAD_FORMAT;

	mov	eax, -2					; fffffffeH
	jmp	$LN39@aviReadRec
$LN31@aviReadRec:

; 562  : 
; 563  :       if ( token != RIFFCODE( 'r', 'e', 'c', ' ' ) )

	cmp	DWORD PTR _token$[ebp], 543384946	; 20636572H
	je	SHORT $LN29@aviReadRec

; 564  :          return RIFF_BAD_FORMAT;

	mov	eax, -2					; fffffffeH
	jmp	$LN39@aviReadRec
$LN29@aviReadRec:

; 565  : 
; 566  :       while ( streamCount-- )

	mov	edx, DWORD PTR _streamCount$[ebp]
	mov	DWORD PTR tv140[ebp], edx
	mov	eax, DWORD PTR _streamCount$[ebp]
	sub	eax, 1
	mov	DWORD PTR _streamCount$[ebp], eax
	cmp	DWORD PTR tv140[ebp], 0
	je	$LN28@aviReadRec

; 567  :       {
; 568  :          if ( recordLen > RIFF_SUB_CHUNK )

	cmp	DWORD PTR _recordLen$[ebp], 8
	jbe	SHORT $LN27@aviReadRec

; 569  :          {
; 570  :             if ( AVI_READ( streams->handle, &subChunk, \
; 571  :                         RIFF_SUB_CHUNK ) != RIFF_SUB_CHUNK )

	push	8
	lea	ecx, DWORD PTR _subChunk$[ebp]
	push	ecx
	mov	edx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	__read
	add	esp, 12					; 0000000cH
	cmp	eax, 8
	je	SHORT $LN26@aviReadRec

; 572  :                return RIFF_BAD_FORMAT;

	mov	eax, -2					; fffffffeH
	jmp	$LN39@aviReadRec
$LN26@aviReadRec:

; 573  :             token = subChunk.subChunkID;

	mov	ecx, DWORD PTR _subChunk$[ebp]
	mov	DWORD PTR _token$[ebp], ecx

; 574  :             chunkLength = subChunk.subChunkLength;

	mov	edx, DWORD PTR _subChunk$[ebp+4]
	mov	DWORD PTR _chunkLength$[ebp], edx

; 575  :          }
; 576  :          else

	jmp	SHORT $LN25@aviReadRec
$LN27@aviReadRec:

; 577  :          {
; 578  :             AVI_SEEK( streams->handle, recordLen, SEEK_CUR );

	push	1
	mov	eax, DWORD PTR _recordLen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	__lseek
	add	esp, 12					; 0000000cH

; 579  :             if ( AVI_READ( streams->handle, \
; 580  :                         &( streams->preRECSubChunk ), \
; 581  :                         RIFF_SUB_CHUNK ) != RIFF_SUB_CHUNK )

	push	8
	mov	eax, DWORD PTR _streams$[ebp]
	add	eax, 696				; 000002b8H
	push	eax
	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	__read
	add	esp, 12					; 0000000cH
	cmp	eax, 8
	je	SHORT $LN24@aviReadRec

; 582  :                return RIFF_BAD_FORMAT;

	mov	eax, -2					; fffffffeH
	jmp	$LN39@aviReadRec
$LN24@aviReadRec:

; 583  : 
; 584  :             token = streams->preRECSubChunk.subChunkID;

	mov	eax, DWORD PTR _streams$[ebp]
	mov	ecx, DWORD PTR [eax+696]
	mov	DWORD PTR _token$[ebp], ecx

; 585  :             chunkLength = streams->preRECSubChunk.subChunkLength;

	mov	edx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR [edx+700]
	mov	DWORD PTR _chunkLength$[ebp], eax
$LN25@aviReadRec:

; 586  :          }
; 587  : 
; 588  :          if ( token == RIFFCODE( 'L', 'I', 'S', 'T' ) )

	cmp	DWORD PTR _token$[ebp], 1414744396	; 5453494cH
	jne	SHORT $LN23@aviReadRec

; 589  :             return RIFF_OK;

	xor	eax, eax
	jmp	$LN39@aviReadRec

; 590  :          else

	jmp	SHORT $LN22@aviReadRec
$LN23@aviReadRec:

; 591  :          {
; 592  :             if ( token == RIFFCODE( 'i', 'd', 'x', '1' ) )

	cmp	DWORD PTR _token$[ebp], 829973609	; 31786469H
	jne	SHORT $LN21@aviReadRec

; 593  :                return RIFF_END_FILE;

	mov	eax, 1
	jmp	$LN39@aviReadRec

; 594  :             else

	jmp	SHORT $LN22@aviReadRec
$LN21@aviReadRec:

; 595  :             {
; 596  :                token &= 0xffff;

	mov	ecx, DWORD PTR _token$[ebp]
	and	ecx, 65535				; 0000ffffH
	mov	DWORD PTR _token$[ebp], ecx
$LN22@aviReadRec:

; 597  :             }
; 598  :          }
; 599  : 
; 600  :          if ( token == RIFFCODE( '0', '1', 0, 0 ) )

	cmp	DWORD PTR _token$[ebp], 12592		; 00003130H
	jne	$LN19@aviReadRec

; 601  :          {
; 602  :             /*
; 603  :                Wave chunk.
; 604  :             */
; 605  : 
; 606  :             recordLen -= ( chunkLength + 8 );

	mov	edx, DWORD PTR _chunkLength$[ebp]
	add	edx, 8
	mov	eax, DWORD PTR _recordLen$[ebp]
	sub	eax, edx
	mov	DWORD PTR _recordLen$[ebp], eax

; 607  : 
; 608  :             if ( ( streams->audioFlag & STREAM_AUDIO_EXTERNAL ) ||
; 609  :                   !( streams->audioFlag & STREAM_AUDIO_ON ) )

	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	and	edx, 2
	jne	SHORT $LN17@aviReadRec
	mov	eax, DWORD PTR _streams$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 1
	jne	SHORT $LN18@aviReadRec
$LN17@aviReadRec:

; 610  :                AVI_SEEK( streams->handle, chunkLength, \
; 611  :                            SEEK_CUR );

	push	1
	mov	edx, DWORD PTR _chunkLength$[ebp]
	push	edx
	mov	eax, DWORD PTR _streams$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	__lseek
	add	esp, 12					; 0000000cH

; 612  :             else

	jmp	$LN16@aviReadRec
$LN18@aviReadRec:

; 613  :             {
; 614  :                ptr = ( long ) streams->waveBuffer;

	mov	edx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR [edx+284]
	mov	DWORD PTR _ptr$[ebp], eax

; 615  :                newPtr = streams->waveBufferWrite + chunkLength -
; 616  :                         streams->waveBufferLen;

	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	add	edx, DWORD PTR _chunkLength$[ebp]
	mov	eax, DWORD PTR _streams$[ebp]
	sub	edx, DWORD PTR [eax+292]
	mov	DWORD PTR _newPtr$[ebp], edx

; 617  : 
; 618  :                if ( newPtr <= 0 )

	cmp	DWORD PTR _newPtr$[ebp], 0
	jg	$LN15@aviReadRec

; 619  :                {
; 620  :                   len = AVI_READ( streams->handle,
; 621  :                            ( ( char * ) ( ptr + \
; 622  :                            streams->waveBufferWrite ) ), \
; 623  :                            chunkLength );

	mov	ecx, DWORD PTR _chunkLength$[ebp]
	push	ecx
	mov	edx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, DWORD PTR [edx+296]
	push	eax
	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	__read
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _len$[ebp], eax

; 624  : 
; 625  :                   if ( len != chunkLength )

	mov	eax, DWORD PTR _len$[ebp]
	cmp	eax, DWORD PTR _chunkLength$[ebp]
	je	SHORT $LN14@aviReadRec

; 626  :                      return RIFF_BAD_FORMAT;

	mov	eax, -2					; fffffffeH
	jmp	$LN39@aviReadRec
$LN14@aviReadRec:

; 627  : 
; 628  :                   streams->waveBufferWrite += chunkLength;

	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	add	edx, DWORD PTR _chunkLength$[ebp]
	mov	eax, DWORD PTR _streams$[ebp]
	mov	DWORD PTR [eax+296], edx

; 629  :                   if ( streams->waveBufferWrite == streams->waveBufferLen )

	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR [ecx+296]
	cmp	eax, DWORD PTR [edx+292]
	jne	SHORT $LN13@aviReadRec

; 630  :                      streams->waveBufferWrite = 0;

	mov	ecx, DWORD PTR _streams$[ebp]
	mov	DWORD PTR [ecx+296], 0
$LN13@aviReadRec:

; 631  : 
; 632  :                   EnterCriticalSection ( &( streams->criticalSection ) );

	mov	edx, DWORD PTR _streams$[ebp]
	add	edx, 704				; 000002c0H
	push	edx
	call	DWORD PTR __imp__EnterCriticalSection@4

; 633  : 
; 634  :                   streams->dataInWaveBuffer += chunkLength;

	mov	eax, DWORD PTR _streams$[ebp]
	mov	ecx, DWORD PTR [eax+288]
	add	ecx, DWORD PTR _chunkLength$[ebp]
	mov	edx, DWORD PTR _streams$[ebp]
	mov	DWORD PTR [edx+288], ecx

; 635  : 
; 636  :                   LeaveCriticalSection ( &( streams->criticalSection ) );

	mov	eax, DWORD PTR _streams$[ebp]
	add	eax, 704				; 000002c0H
	push	eax
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 637  :                }
; 638  :                else

	jmp	$LN16@aviReadRec
$LN15@aviReadRec:

; 639  :                {
; 640  :                   size = streams->waveBufferLen - streams->waveBufferWrite;

	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR [ecx+292]
	sub	eax, DWORD PTR [edx+296]
	mov	DWORD PTR _size$[ebp], eax

; 641  :                   len = AVI_READ( streams->handle,
; 642  :                                  ( ( char * ) ( ptr + \
; 643  :                                  streams->waveBufferWrite ) ), \
; 644  :                                  size );

	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, DWORD PTR [edx+296]
	push	eax
	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	__read
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _len$[ebp], eax

; 645  : 
; 646  :                   if ( len != size )

	mov	eax, DWORD PTR _len$[ebp]
	cmp	eax, DWORD PTR _size$[ebp]
	je	SHORT $LN11@aviReadRec

; 647  :                      return RIFF_BAD_FORMAT;

	mov	eax, -2					; fffffffeH
	jmp	$LN39@aviReadRec
$LN11@aviReadRec:

; 648  : 
; 649  :                   streams->waveBufferWrite = 0;

	mov	ecx, DWORD PTR _streams$[ebp]
	mov	DWORD PTR [ecx+296], 0

; 650  : 
; 651  :                   size = chunkLength - size;

	mov	edx, DWORD PTR _chunkLength$[ebp]
	sub	edx, DWORD PTR _size$[ebp]
	mov	DWORD PTR _size$[ebp], edx

; 652  :                   len = AVI_READ( streams->handle,
; 653  :                                  ( ( char * ) ( ptr + \
; 654  :                                  streams->waveBufferWrite ) ), \
; 655  :                                  size );

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR _ptr$[ebp]
	add	edx, DWORD PTR [ecx+296]
	push	edx
	mov	eax, DWORD PTR _streams$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	__read
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _len$[ebp], eax

; 656  : 
; 657  :                   if ( len != size )

	mov	edx, DWORD PTR _len$[ebp]
	cmp	edx, DWORD PTR _size$[ebp]
	je	SHORT $LN10@aviReadRec

; 658  :                      return RIFF_BAD_FORMAT;

	mov	eax, -2					; fffffffeH
	jmp	$LN39@aviReadRec
$LN10@aviReadRec:

; 659  : 
; 660  :                   streams->waveBufferWrite += size;

	mov	eax, DWORD PTR _streams$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	add	ecx, DWORD PTR _size$[ebp]
	mov	edx, DWORD PTR _streams$[ebp]
	mov	DWORD PTR [edx+296], ecx

; 661  : 
; 662  :                   EnterCriticalSection ( &( streams->criticalSection ) );

	mov	eax, DWORD PTR _streams$[ebp]
	add	eax, 704				; 000002c0H
	push	eax
	call	DWORD PTR __imp__EnterCriticalSection@4

; 663  : 
; 664  :                   streams->dataInWaveBuffer += chunkLength;

	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR [ecx+288]
	add	edx, DWORD PTR _chunkLength$[ebp]
	mov	eax, DWORD PTR _streams$[ebp]
	mov	DWORD PTR [eax+288], edx

; 665  : 
; 666  :                   LeaveCriticalSection ( &( streams->criticalSection ) );

	mov	ecx, DWORD PTR _streams$[ebp]
	add	ecx, 704				; 000002c0H
	push	ecx
	call	DWORD PTR __imp__LeaveCriticalSection@4
$LN16@aviReadRec:

; 667  :                }
; 668  :             }
; 669  :          }
; 670  :          else

	jmp	$LN9@aviReadRec
$LN19@aviReadRec:

; 671  :          {
; 672  :             if ( token == RIFFCODE( '0', '0', 0, 0 ) )

	cmp	DWORD PTR _token$[ebp], 12336		; 00003030H
	jne	$LN8@aviReadRec

; 673  :             {
; 674  :                /*
; 675  :                   Video chunk.
; 676  :                */
; 677  :                recordLen -= ( chunkLength + 8 );

	mov	edx, DWORD PTR _chunkLength$[ebp]
	add	edx, 8
	mov	eax, DWORD PTR _recordLen$[ebp]
	sub	eax, edx
	mov	DWORD PTR _recordLen$[ebp], eax

; 678  : 
; 679  :                nextBlock = streams->nextBlockToFill;

	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	mov	DWORD PTR _nextBlock$[ebp], edx

; 680  : 
; 681  :                if ( nextBlock->bufferSize < ( DWORD ) chunkLength )

	mov	eax, DWORD PTR _nextBlock$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _chunkLength$[ebp]
	jae	SHORT $LN7@aviReadRec

; 682  :                {
; 683  :                   delete [] nextBlock->buffer;

	mov	edx, DWORD PTR _nextBlock$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 684  : //                  nextBlock->buffer = AVI_MALLOC( chunkLength );
; 685  :                   nextBlock->buffer = new char[chunkLength];

	mov	edx, DWORD PTR _chunkLength$[ebp]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR _nextBlock$[ebp]
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [eax+8], ecx

; 686  : 
; 687  :                   if ( !( nextBlock->buffer ) )

	mov	edx, DWORD PTR _nextBlock$[ebp]
	cmp	DWORD PTR [edx+8], 0
	jne	SHORT $LN6@aviReadRec

; 688  :                      return RIFF_REALLOC_FAILED;

	mov	eax, -5					; fffffffbH
	jmp	$LN39@aviReadRec
$LN6@aviReadRec:

; 689  : 
; 690  :                   nextBlock->bufferSize = chunkLength;

	mov	eax, DWORD PTR _nextBlock$[ebp]
	mov	ecx, DWORD PTR _chunkLength$[ebp]
	mov	DWORD PTR [eax], ecx
$LN7@aviReadRec:

; 691  :                }
; 692  : 
; 693  :                len = AVI_READ( streams->handle, \
; 694  :                               nextBlock->buffer, \
; 695  :                               chunkLength );

	mov	edx, DWORD PTR _chunkLength$[ebp]
	push	edx
	mov	eax, DWORD PTR _nextBlock$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	__read
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _len$[ebp], eax

; 696  : 
; 697  :                if ( len != chunkLength )

	mov	ecx, DWORD PTR _len$[ebp]
	cmp	ecx, DWORD PTR _chunkLength$[ebp]
	je	SHORT $LN5@aviReadRec

; 698  :                   return RIFF_BAD_FORMAT;

	mov	eax, -2					; fffffffeH
	jmp	$LN39@aviReadRec
$LN5@aviReadRec:

; 699  : 
; 700  :                nextBlock->currentBlockSize = len;

	mov	edx, DWORD PTR _nextBlock$[ebp]
	mov	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR [edx+4], eax

; 701  :                streams->nextBlockToFill =
; 702  :                         streams->nextBlockToFill->next;

	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	mov	eax, DWORD PTR _streams$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+692], ecx

; 703  :             }
; 704  :             else

	jmp	SHORT $LN9@aviReadRec
$LN8@aviReadRec:

; 705  :             {
; 706  :                recordLen -= ( chunkLength + 8 );

	mov	edx, DWORD PTR _chunkLength$[ebp]
	add	edx, 8
	mov	eax, DWORD PTR _recordLen$[ebp]
	sub	eax, edx
	mov	DWORD PTR _recordLen$[ebp], eax

; 707  : 
; 708  :                AVI_SEEK( streams->handle, chunkLength, SEEK_CUR );

	push	1
	mov	ecx, DWORD PTR _chunkLength$[ebp]
	push	ecx
	mov	edx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	__lseek
	add	esp, 12					; 0000000cH
$LN9@aviReadRec:

; 709  :             }
; 710  :          }
; 711  :       }

	jmp	$LN29@aviReadRec
$LN28@aviReadRec:

; 712  : 
; 713  :       if ( recordLen )

	cmp	DWORD PTR _recordLen$[ebp], 0
	je	SHORT $LN3@aviReadRec

; 714  :          AVI_SEEK( streams->handle, recordLen, \
; 715  :                      SEEK_CUR );

	push	1
	mov	ecx, DWORD PTR _recordLen$[ebp]
	push	ecx
	mov	edx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	__lseek
	add	esp, 12					; 0000000cH
$LN3@aviReadRec:

; 716  : 
; 717  :       if ( AVI_READ( streams->handle, &( streams->preRECSubChunk ),
; 718  :                      RIFF_SUB_CHUNK ) != RIFF_SUB_CHUNK )

	push	8
	mov	ecx, DWORD PTR _streams$[ebp]
	add	ecx, 696				; 000002b8H
	push	ecx
	mov	edx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	__read
	add	esp, 12					; 0000000cH
	cmp	eax, 8
	je	SHORT $LN2@aviReadRec

; 719  :          return RIFF_BAD_FORMAT;

	mov	eax, -2					; fffffffeH
	jmp	SHORT $LN39@aviReadRec
$LN2@aviReadRec:

; 720  : 
; 721  :       if ( streams->preRECSubChunk.subChunkID !=
; 722  :                      RIFFCODE( 'L', 'I', 'S', 'T' ) )

	mov	ecx, DWORD PTR _streams$[ebp]
	cmp	DWORD PTR [ecx+696], 1414744396		; 5453494cH
	je	SHORT $LN32@aviReadRec

; 723  :          return RIFF_BAD_FORMAT;

	mov	eax, -2					; fffffffeH
	jmp	SHORT $LN39@aviReadRec
$LN32@aviReadRec:

; 724  :    }
; 725  : 
; 726  :    return RIFF_OK;

	xor	eax, eax
$LN39@aviReadRec:

; 727  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_aviReadRecord ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\movie\riffio.cpp
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_i$ = -4						; size = 4
_streams$ = 8						; size = 4
_aviClose PROC

; 455  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 456  :    int   i;
; 457  : 
; 458  :    if ( streams->handle )

	mov	eax, DWORD PTR _streams$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN7@aviClose

; 459  :       AVI_CLOSE( streams->handle );

	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	__close
	add	esp, 4
$LN7@aviClose:

; 460  : 
; 461  :    if ( streams->externalSoundHandle )

	mov	eax, DWORD PTR _streams$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN6@aviClose

; 462  :       AVI_CLOSE( streams->externalSoundHandle );

	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	__close
	add	esp, 4
$LN6@aviClose:

; 463  : 
; 464  :    if ( streams->waveBuffer )

	mov	eax, DWORD PTR _streams$[ebp]
	cmp	DWORD PTR [eax+284], 0
	je	SHORT $LN5@aviClose

; 465  :       delete [] streams->waveBuffer;

	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR [ecx+284]
	mov	DWORD PTR $T2[ebp], edx
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@aviClose:

; 466  : 
; 467  :    for ( i = 0; i < streams->numOfVidBlocks; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@aviClose
$LN3@aviClose:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@aviClose:
	mov	edx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+32]
	jge	SHORT $LN2@aviClose

; 468  :    {
; 469  :       if ( streams->videoBlock[i].buffer )

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _streams$[ebp]
	cmp	DWORD PTR [edx+ecx+312], 0
	je	SHORT $LN1@aviClose

; 470  :          delete [] streams->videoBlock[i].buffer;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR [ecx+eax+312]
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@aviClose:

; 471  :    }

	jmp	SHORT $LN3@aviClose
$LN2@aviClose:

; 472  : 
; 473  :    memset ( streams, 0, sizeof( AVISTREAMS ) );

	push	728					; 000002d8H
	push	0
	mov	ecx, DWORD PTR _streams$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 474  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_aviClose ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\movie\riffio.cpp
_TEXT	SEGMENT
$T1 = -88						; size = 4
_currentFilePointer$ = -84				; size = 4
$T2 = -80						; size = 4
_token$ = -76						; size = 4
_blockSize$ = -72					; size = 4
_remainder$ = -68					; size = 4
_videoBlock$ = -64					; size = 4
_subChunk$ = -60					; size = 8
_i$ = -52						; size = 4
_aviHeader$ = -48					; size = 32
_chunk$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_aviFileName$ = 8					; size = 4
_audioFileName$ = 12					; size = 4
_streams$ = 16						; size = 4
_aviOpen PROC

; 52   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 53   :    RIFFAVIHEADER     aviHeader;
; 54   :    RIFFCHUNK         chunk;
; 55   :    RIFFSUBCHUNK      subChunk;
; 56   :    PVIDBLOCK         videoBlock;
; 57   :    int               currentFilePointer;
; 58   :    int               blockSize, i, remainder;
; 59   :    long              token;
; 60   : 
; 61   :    if ( !aviFileName )

	cmp	DWORD PTR _aviFileName$[ebp], 0
	jne	SHORT $LN69@aviOpen

; 62   :       return RIFF_BAD_FILENAME;

	mov	eax, -3					; fffffffdH
	jmp	$LN70@aviOpen
$LN69@aviOpen:

; 63   : 
; 64   :    streams->handle = AVI_OPEN( aviFileName, _O_RDONLY | _O_BINARY );

	push	0
	push	32768					; 00008000H
	mov	eax, DWORD PTR _aviFileName$[ebp]
	push	eax
	call	?_open@@YAHPBDHH@Z			; _open
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _streams$[ebp]
	mov	DWORD PTR [ecx], eax

; 65   :    if ( streams->handle == -1 )

	mov	edx, DWORD PTR _streams$[ebp]
	cmp	DWORD PTR [edx], -1
	jne	SHORT $LN68@aviOpen

; 66   :       return RIFF_OPEN_FAILED;

	or	eax, -1
	jmp	$LN70@aviOpen
$LN68@aviOpen:

; 67   : 
; 68   :    /*
; 69   :       Read and verify AVI header.
; 70   : 
; 71   :       RIFF (   'AVI '
; 72   :                LIST (   'hdrl'
; 73   :                         'avih' ( <MainAVIHeader> )
; 74   :    */
; 75   : 
; 76   :    if ( AVI_READ( streams->handle, &aviHeader,
; 77   :                   RIFF_AVI_HEADER ) != RIFF_AVI_HEADER )

	push	32					; 00000020H
	lea	eax, DWORD PTR _aviHeader$[ebp]
	push	eax
	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	__read
	add	esp, 12					; 0000000cH
	cmp	eax, 32					; 00000020H
	je	SHORT $LN67@aviOpen

; 78   :       return RIFF_BAD_FORMAT;

	mov	eax, -2					; fffffffeH
	jmp	$LN70@aviOpen
$LN67@aviOpen:

; 79   : 
; 80   :    if ( aviHeader.avi.chunkID != RIFFCODE( 'R', 'I', 'F', 'F' ) )

	cmp	DWORD PTR _aviHeader$[ebp], 1179011410	; 46464952H
	je	SHORT $LN66@aviOpen

; 81   :       return RIFF_BAD_FORMAT;

	mov	eax, -2					; fffffffeH
	jmp	$LN70@aviOpen
$LN66@aviOpen:

; 82   : 
; 83   :    if ( aviHeader.avi.chunkType != RIFFCODE( 'A', 'V', 'I', ' ' ) )

	cmp	DWORD PTR _aviHeader$[ebp+8], 541677121	; 20495641H
	je	SHORT $LN65@aviOpen

; 84   :       return RIFF_BAD_FORMAT;

	mov	eax, -2					; fffffffeH
	jmp	$LN70@aviOpen
$LN65@aviOpen:

; 85   : 
; 86   :    if ( aviHeader.hdrl.chunkID != RIFFCODE( 'L', 'I', 'S', 'T' ) )

	cmp	DWORD PTR _aviHeader$[ebp+12], 1414744396 ; 5453494cH
	je	SHORT $LN64@aviOpen

; 87   :       return RIFF_BAD_FORMAT;

	mov	eax, -2					; fffffffeH
	jmp	$LN70@aviOpen
$LN64@aviOpen:

; 88   : 
; 89   :    if ( aviHeader.hdrl.chunkType != RIFFCODE( 'h', 'd', 'r', 'l' ) )

	cmp	DWORD PTR _aviHeader$[ebp+20], 1819436136 ; 6c726468H
	je	SHORT $LN63@aviOpen

; 90   :       return RIFF_BAD_FORMAT;

	mov	eax, -2					; fffffffeH
	jmp	$LN70@aviOpen
$LN63@aviOpen:

; 91   : 
; 92   :    if ( aviHeader.avih.subChunkID != RIFFCODE( 'a', 'v', 'i', 'h' ) )

	cmp	DWORD PTR _aviHeader$[ebp+24], 1751742049 ; 68697661H
	je	SHORT $LN62@aviOpen

; 93   :       return RIFF_BAD_FORMAT;

	mov	eax, -2					; fffffffeH
	jmp	$LN70@aviOpen
$LN62@aviOpen:

; 94   : 
; 95   :    if ( AVI_READ( streams->handle, &( streams->mainAVIHeader ),
; 96   :                   aviHeader.avih.subChunkLength ) !=
; 97   :                   aviHeader.avih.subChunkLength )

	mov	eax, DWORD PTR _aviHeader$[ebp+28]
	push	eax
	mov	ecx, DWORD PTR _streams$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	edx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	__read
	add	esp, 12					; 0000000cH
	cmp	eax, DWORD PTR _aviHeader$[ebp+28]
	je	SHORT $LN61@aviOpen

; 98   :       return RIFF_BAD_FORMAT;

	mov	eax, -2					; fffffffeH
	jmp	$LN70@aviOpen
$LN61@aviOpen:

; 99   : 
; 100  :    /*
; 101  :       Read and verify a stream header.
; 102  : 
; 103  :       LIST (   'strl'
; 104  :                'strh' ( <AVIStreamHeader> )
; 105  :                'strf' ( <BIMAPINFOHEADER> )
; 106  :    */
; 107  : 
; 108  :    currentFilePointer = AVI_SEEK( streams->handle, 0, SEEK_CUR );

	push	1
	push	0
	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	__lseek
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _currentFilePointer$[ebp], eax

; 109  : 
; 110  :    if ( AVI_READ( streams->handle, &chunk, RIFF_CHUNK ) !=
; 111  :                   RIFF_CHUNK )

	push	12					; 0000000cH
	lea	eax, DWORD PTR _chunk$[ebp]
	push	eax
	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	__read
	add	esp, 12					; 0000000cH
	cmp	eax, 12					; 0000000cH
	je	SHORT $LN60@aviOpen

; 112  :       return RIFF_BAD_FORMAT;

	mov	eax, -2					; fffffffeH
	jmp	$LN70@aviOpen
$LN60@aviOpen:

; 113  : 
; 114  :    if ( chunk.chunkID != RIFFCODE( 'L', 'I', 'S', 'T' ) )

	cmp	DWORD PTR _chunk$[ebp], 1414744396	; 5453494cH
	je	SHORT $LN59@aviOpen

; 115  :       return RIFF_BAD_FORMAT;

	mov	eax, -2					; fffffffeH
	jmp	$LN70@aviOpen
$LN59@aviOpen:

; 116  : 
; 117  :    if ( chunk.chunkType != RIFFCODE( 's', 't', 'r', 'l' ) )

	cmp	DWORD PTR _chunk$[ebp+8], 1819440243	; 6c727473H
	je	SHORT $LN58@aviOpen

; 118  :       return RIFF_BAD_FORMAT;

	mov	eax, -2					; fffffffeH
	jmp	$LN70@aviOpen
$LN58@aviOpen:

; 119  : 
; 120  :    if ( AVI_READ( streams->handle, &subChunk, RIFF_SUB_CHUNK ) !=
; 121  :                   RIFF_SUB_CHUNK )

	push	8
	lea	eax, DWORD PTR _subChunk$[ebp]
	push	eax
	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	__read
	add	esp, 12					; 0000000cH
	cmp	eax, 8
	je	SHORT $LN57@aviOpen

; 122  :       return RIFF_BAD_FORMAT;

	mov	eax, -2					; fffffffeH
	jmp	$LN70@aviOpen
$LN57@aviOpen:

; 123  : 
; 124  :    if ( subChunk.subChunkID != RIFFCODE( 's', 't', 'r', 'h' ) )

	cmp	DWORD PTR _subChunk$[ebp], 1752331379	; 68727473H
	je	SHORT $LN56@aviOpen

; 125  :       return RIFF_BAD_FORMAT;

	mov	eax, -2					; fffffffeH
	jmp	$LN70@aviOpen
$LN56@aviOpen:

; 126  : 
; 127  :    if ( AVI_READ ( streams->handle, &( streams->strh1 ),
; 128  :                      subChunk.subChunkLength ) !=
; 129  :                      subChunk.subChunkLength )

	mov	eax, DWORD PTR _subChunk$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _streams$[ebp]
	add	ecx, 96					; 00000060H
	push	ecx
	mov	edx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	__read
	add	esp, 12					; 0000000cH
	cmp	eax, DWORD PTR _subChunk$[ebp+4]
	je	SHORT $LN55@aviOpen

; 130  :       return RIFF_BAD_FORMAT;

	mov	eax, -2					; fffffffeH
	jmp	$LN70@aviOpen
$LN55@aviOpen:

; 131  : 
; 132  :    if ( AVI_READ( streams->handle, &subChunk,
; 133  :                   RIFF_SUB_CHUNK ) != RIFF_SUB_CHUNK )

	push	8
	lea	ecx, DWORD PTR _subChunk$[ebp]
	push	ecx
	mov	edx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	__read
	add	esp, 12					; 0000000cH
	cmp	eax, 8
	je	SHORT $LN54@aviOpen

; 134  :       return RIFF_BAD_FORMAT;

	mov	eax, -2					; fffffffeH
	jmp	$LN70@aviOpen
$LN54@aviOpen:

; 135  : 
; 136  :    if ( subChunk.subChunkID != RIFFCODE( 's', 't', 'r', 'f' ) )

	cmp	DWORD PTR _subChunk$[ebp], 1718776947	; 66727473H
	je	SHORT $LN53@aviOpen

; 137  :       return RIFF_BAD_FORMAT;

	mov	eax, -2					; fffffffeH
	jmp	$LN70@aviOpen
$LN53@aviOpen:

; 138  : 
; 139  :    if ( AVI_READ ( streams->handle, &( streams->bihIn ),
; 140  :                   subChunk.subChunkLength ) !=
; 141  :                   subChunk.subChunkLength )

	mov	ecx, DWORD PTR _subChunk$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _streams$[ebp]
	add	edx, 160				; 000000a0H
	push	edx
	mov	eax, DWORD PTR _streams$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	__read
	add	esp, 12					; 0000000cH
	cmp	eax, DWORD PTR _subChunk$[ebp+4]
	je	SHORT $LN52@aviOpen

; 142  :       return RIFF_BAD_FORMAT;

	mov	eax, -2					; fffffffeH
	jmp	$LN70@aviOpen
$LN52@aviOpen:

; 143  : 
; 144  :    /*
; 145  :       Read audio stream header.
; 146  :    */
; 147  : 
; 148  :    if ( streams->audioFlag & STREAM_AUDIO_ON )

	mov	edx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 1
	je	$LN51@aviOpen

; 149  :    {
; 150  :       if (  streams->audioFlag & STREAM_AUDIO_EXTERNAL  )

	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	and	edx, 2
	je	$LN50@aviOpen

; 151  :       {
; 152  : 
; 153  :          /*
; 154  :             External sound file...
; 155  : 
; 156  :             RIFF (   'WAVE'
; 157  :                      'fmt ' ( <WaveFormat> )
; 158  :                      'data' ( <audio data> )
; 159  :          */
; 160  : 
; 161  :          streams->externalSoundHandle =
; 162  :             AVI_OPEN ( audioFileName, _O_RDONLY | _O_BINARY );

	push	0
	push	32768					; 00008000H
	mov	eax, DWORD PTR _audioFileName$[ebp]
	push	eax
	call	?_open@@YAHPBDHH@Z			; _open
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _streams$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 163  :          if ( streams->externalSoundHandle == -1 )

	mov	edx, DWORD PTR _streams$[ebp]
	cmp	DWORD PTR [edx+4], -1
	jne	SHORT $LN49@aviOpen

; 164  :             return RIFF_OPEN_AUDIO_FAILED;

	mov	eax, -8					; fffffff8H
	jmp	$LN70@aviOpen
$LN49@aviOpen:

; 165  : 
; 166  :          if ( AVI_READ( streams->externalSoundHandle, &chunk, RIFF_CHUNK ) !=
; 167  :                         RIFF_CHUNK )

	push	12					; 0000000cH
	lea	eax, DWORD PTR _chunk$[ebp]
	push	eax
	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	__read
	add	esp, 12					; 0000000cH
	cmp	eax, 12					; 0000000cH
	je	SHORT $LN48@aviOpen

; 168  :             return RIFF_BAD_AUDIO_FORMAT;

	mov	eax, -7					; fffffff9H
	jmp	$LN70@aviOpen
$LN48@aviOpen:

; 169  : 
; 170  :          if ( chunk.chunkID != RIFFCODE( 'R', 'I', 'F', 'F' ) )

	cmp	DWORD PTR _chunk$[ebp], 1179011410	; 46464952H
	je	SHORT $LN47@aviOpen

; 171  :             return RIFF_BAD_AUDIO_FORMAT;

	mov	eax, -7					; fffffff9H
	jmp	$LN70@aviOpen
$LN47@aviOpen:

; 172  : 
; 173  :          if ( chunk.chunkType != RIFFCODE( 'W', 'A', 'V', 'E' ) )

	cmp	DWORD PTR _chunk$[ebp+8], 1163280727	; 45564157H
	je	SHORT $LN46@aviOpen

; 174  :             return RIFF_BAD_AUDIO_FORMAT;

	mov	eax, -7					; fffffff9H
	jmp	$LN70@aviOpen
$LN46@aviOpen:

; 175  : 
; 176  :          if ( AVI_READ( streams->externalSoundHandle, &subChunk, \
; 177  :                         RIFF_SUB_CHUNK ) != RIFF_SUB_CHUNK )

	push	8
	lea	eax, DWORD PTR _subChunk$[ebp]
	push	eax
	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	__read
	add	esp, 12					; 0000000cH
	cmp	eax, 8
	je	SHORT $LN45@aviOpen

; 178  :             return RIFF_BAD_AUDIO_FORMAT;

	mov	eax, -7					; fffffff9H
	jmp	$LN70@aviOpen
$LN45@aviOpen:

; 179  : 
; 180  :          if ( subChunk.subChunkID != RIFFCODE( 'f', 'm', 't', ' ' ) )

	cmp	DWORD PTR _subChunk$[ebp], 544501094	; 20746d66H
	je	SHORT $LN44@aviOpen

; 181  :             return RIFF_BAD_AUDIO_FORMAT;

	mov	eax, -7					; fffffff9H
	jmp	$LN70@aviOpen
$LN44@aviOpen:

; 182  : 
; 183  :          if ( AVI_READ( streams->externalSoundHandle, \
; 184  :                         &( streams->waveFormat ), subChunk.subChunkLength )
; 185  :                         != subChunk.subChunkLength )

	mov	eax, DWORD PTR _subChunk$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _streams$[ebp]
	add	ecx, 264				; 00000108H
	push	ecx
	mov	edx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	__read
	add	esp, 12					; 0000000cH
	cmp	eax, DWORD PTR _subChunk$[ebp+4]
	je	SHORT $LN43@aviOpen

; 186  :             return RIFF_BAD_AUDIO_FORMAT;

	mov	eax, -7					; fffffff9H
	jmp	$LN70@aviOpen
$LN43@aviOpen:

; 187  : 
; 188  :          if ( AVI_READ( streams->externalSoundHandle, &subChunk, \
; 189  :                         RIFF_SUB_CHUNK ) != RIFF_SUB_CHUNK )

	push	8
	lea	ecx, DWORD PTR _subChunk$[ebp]
	push	ecx
	mov	edx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	__read
	add	esp, 12					; 0000000cH
	cmp	eax, 8
	je	SHORT $LN42@aviOpen

; 190  :             return RIFF_BAD_AUDIO_FORMAT;

	mov	eax, -7					; fffffff9H
	jmp	$LN70@aviOpen
$LN42@aviOpen:

; 191  : 
; 192  :          if ( subChunk.subChunkID != RIFFCODE( 'd', 'a', 't', 'a' ) )

	cmp	DWORD PTR _subChunk$[ebp], 1635017060	; 61746164H
	je	SHORT $LN41@aviOpen

; 193  :             return RIFF_BAD_AUDIO_FORMAT;

	mov	eax, -7					; fffffff9H
	jmp	$LN70@aviOpen
$LN41@aviOpen:

; 194  : 
; 195  :          streams->totalAudioRemaining = subChunk.subChunkLength;

	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR _subChunk$[ebp+4]
	mov	DWORD PTR [ecx+28], edx

; 196  :       }
; 197  :       else

	jmp	$LN51@aviOpen
$LN50@aviOpen:

; 198  :       {
; 199  :          /*
; 200  :             Check if the file contains multiple streams.
; 201  :          */
; 202  : 
; 203  :          if ( streams->mainAVIHeader.dwStreams == 1 )

	mov	eax, DWORD PTR _streams$[ebp]
	cmp	DWORD PTR [eax+64], 1
	jne	SHORT $LN39@aviOpen

; 204  :                streams->audioFlag &= ~STREAM_AUDIO_ON;

	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	and	edx, -2					; fffffffeH
	mov	eax, DWORD PTR _streams$[ebp]
	mov	DWORD PTR [eax+8], edx

; 205  :          else

	jmp	$LN51@aviOpen
$LN39@aviOpen:

; 206  :          {
; 207  :             /*
; 208  :                Back to the beginning of stream header ( 'strl' ).
; 209  :             */
; 210  : 
; 211  :             AVI_SEEK( streams->handle, currentFilePointer, SEEK_SET );

	push	0
	mov	ecx, DWORD PTR _currentFilePointer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	__lseek
	add	esp, 12					; 0000000cH

; 212  : 
; 213  :             /*
; 214  :                Go to the beginning of the next stream.
; 215  :             */
; 216  : 
; 217  :             AVI_SEEK( streams->handle, ( chunk.chunkLength + \
; 218  :                      RIFF_SUB_CHUNK ), SEEK_CUR );

	push	1
	mov	ecx, DWORD PTR _chunk$[ebp+4]
	add	ecx, 8
	push	ecx
	mov	edx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	__lseek
	add	esp, 12					; 0000000cH

; 219  : 
; 220  :             /*
; 221  :                LIST (   'strl'
; 222  :                         'strh' ( <AVIStreamHeader> )
; 223  :                         'strf' ( <WAVEFORMATEX> )
; 224  :             */
; 225  : 
; 226  :             if ( AVI_READ( streams->handle, &chunk, RIFF_CHUNK ) !=
; 227  :                            RIFF_CHUNK )

	push	12					; 0000000cH
	lea	ecx, DWORD PTR _chunk$[ebp]
	push	ecx
	mov	edx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	__read
	add	esp, 12					; 0000000cH
	cmp	eax, 12					; 0000000cH
	je	SHORT $LN37@aviOpen

; 228  :                return RIFF_BAD_FORMAT;

	mov	eax, -2					; fffffffeH
	jmp	$LN70@aviOpen
$LN37@aviOpen:

; 229  : 
; 230  :             if ( chunk.chunkID != RIFFCODE( 'L', 'I', 'S', 'T' ) )

	cmp	DWORD PTR _chunk$[ebp], 1414744396	; 5453494cH
	je	SHORT $LN36@aviOpen

; 231  :                return RIFF_BAD_FORMAT;

	mov	eax, -2					; fffffffeH
	jmp	$LN70@aviOpen
$LN36@aviOpen:

; 232  : 
; 233  :             if ( chunk.chunkType != RIFFCODE( 's', 't', 'r', 'l' ) )

	cmp	DWORD PTR _chunk$[ebp+8], 1819440243	; 6c727473H
	je	SHORT $LN35@aviOpen

; 234  :                return RIFF_BAD_FORMAT;

	mov	eax, -2					; fffffffeH
	jmp	$LN70@aviOpen
$LN35@aviOpen:

; 235  : 
; 236  :             if ( AVI_READ( streams->handle, &subChunk, RIFF_SUB_CHUNK ) !=
; 237  :                         RIFF_SUB_CHUNK )

	push	8
	lea	ecx, DWORD PTR _subChunk$[ebp]
	push	ecx
	mov	edx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	__read
	add	esp, 12					; 0000000cH
	cmp	eax, 8
	je	SHORT $LN34@aviOpen

; 238  :                return RIFF_BAD_FORMAT;

	mov	eax, -2					; fffffffeH
	jmp	$LN70@aviOpen
$LN34@aviOpen:

; 239  : 
; 240  :             if ( subChunk.subChunkID != RIFFCODE( 's', 't', 'r', 'h' ) )

	cmp	DWORD PTR _subChunk$[ebp], 1752331379	; 68727473H
	je	SHORT $LN33@aviOpen

; 241  :                return RIFF_BAD_FORMAT;

	mov	eax, -2					; fffffffeH
	jmp	$LN70@aviOpen
$LN33@aviOpen:

; 242  : 
; 243  :             if ( AVI_READ ( streams->handle, &( streams->strh2 ),
; 244  :                         subChunk.subChunkLength ) !=
; 245  :                         subChunk.subChunkLength )

	mov	ecx, DWORD PTR _subChunk$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _streams$[ebp]
	add	edx, 200				; 000000c8H
	push	edx
	mov	eax, DWORD PTR _streams$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	__read
	add	esp, 12					; 0000000cH
	cmp	eax, DWORD PTR _subChunk$[ebp+4]
	je	SHORT $LN32@aviOpen

; 246  :                return RIFF_BAD_FORMAT;

	mov	eax, -2					; fffffffeH
	jmp	$LN70@aviOpen
$LN32@aviOpen:

; 247  : 
; 248  :             if ( AVI_READ( streams->handle, &subChunk,
; 249  :                         RIFF_SUB_CHUNK ) != RIFF_SUB_CHUNK )

	push	8
	lea	edx, DWORD PTR _subChunk$[ebp]
	push	edx
	mov	eax, DWORD PTR _streams$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	__read
	add	esp, 12					; 0000000cH
	cmp	eax, 8
	je	SHORT $LN31@aviOpen

; 250  :                return RIFF_BAD_FORMAT;

	mov	eax, -2					; fffffffeH
	jmp	$LN70@aviOpen
$LN31@aviOpen:

; 251  : 
; 252  :             if ( subChunk.subChunkID != RIFFCODE( 's', 't', 'r', 'f' ) )

	cmp	DWORD PTR _subChunk$[ebp], 1718776947	; 66727473H
	je	SHORT $LN30@aviOpen

; 253  :                return RIFF_BAD_FORMAT;

	mov	eax, -2					; fffffffeH
	jmp	$LN70@aviOpen
$LN30@aviOpen:

; 254  : 
; 255  :             if ( AVI_READ ( streams->handle, &( streams->waveFormat ),
; 256  :                            subChunk.subChunkLength ) !=
; 257  :                            subChunk.subChunkLength )

	mov	edx, DWORD PTR _subChunk$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _streams$[ebp]
	add	eax, 264				; 00000108H
	push	eax
	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	__read
	add	esp, 12					; 0000000cH
	cmp	eax, DWORD PTR _subChunk$[ebp+4]
	je	SHORT $LN51@aviOpen

; 258  :                return RIFF_BAD_FORMAT;

	mov	eax, -2					; fffffffeH
	jmp	$LN70@aviOpen
$LN51@aviOpen:

; 259  :          }
; 260  :       }
; 261  :    }
; 262  : 
; 263  :    /*
; 264  :       Back to the beginning of the file.
; 265  :    */
; 266  : 
; 267  :    AVI_SEEK( streams->handle, 0, SEEK_SET );

	push	0
	push	0
	mov	eax, DWORD PTR _streams$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	__lseek
	add	esp, 12					; 0000000cH

; 268  : 
; 269  :    /*
; 270  :       Look for the beginning of 'movi' chunk.
; 271  :    */
; 272  : 
; 273  :    AVI_SEEK( streams->handle, \
; 274  :                ( aviHeader.hdrl.chunkLength + RIFF_CHUNK +
; 275  :                RIFF_SUB_CHUNK ), \
; 276  :                SEEK_CUR );

	push	1
	mov	edx, DWORD PTR _aviHeader$[ebp+16]
	add	edx, 20					; 00000014H
	push	edx
	mov	eax, DWORD PTR _streams$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	__lseek
	add	esp, 12					; 0000000cH

; 277  : 
; 278  :    /*
; 279  :       The next chunk can either be a LIST chunk or a JUNK chunk.
; 280  : 
; 281  :       JUNK
; 282  :       LIST (   'movi'
; 283  : 
; 284  :       or
; 285  : 
; 286  :       LIST (   'movi'
; 287  :                LIST (   'rec '
; 288  :                            SubChunk1
; 289  :    */
; 290  : 
; 291  :    if ( AVI_READ( streams->handle, &subChunk, RIFF_SUB_CHUNK ) !=
; 292  :                   RIFF_SUB_CHUNK )

	push	8
	lea	edx, DWORD PTR _subChunk$[ebp]
	push	edx
	mov	eax, DWORD PTR _streams$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	__read
	add	esp, 12					; 0000000cH
	cmp	eax, 8
	je	SHORT $LN27@aviOpen

; 293  :       return RIFF_BAD_FORMAT;

	mov	eax, -2					; fffffffeH
	jmp	$LN70@aviOpen
$LN27@aviOpen:

; 294  : 
; 295  :    while ( subChunk.subChunkID != RIFFCODE( 'L', 'I', 'S', 'T' ) )

	cmp	DWORD PTR _subChunk$[ebp], 1414744396	; 5453494cH
	je	SHORT $LN26@aviOpen

; 296  :    {
; 297  :       if ( subChunk.subChunkID == RIFFCODE( 'J', 'U', 'N', 'K' ) )

	cmp	DWORD PTR _subChunk$[ebp], 1263424842	; 4b4e554aH
	jne	SHORT $LN25@aviOpen

; 298  :       {
; 299  :          AVI_SEEK( streams->handle, subChunk.subChunkLength, \
; 300  :                      SEEK_CUR );

	push	1
	mov	edx, DWORD PTR _subChunk$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _streams$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	__lseek
	add	esp, 12					; 0000000cH

; 301  :          if ( AVI_READ( streams->handle, &subChunk, \
; 302  :                         RIFF_SUB_CHUNK ) != RIFF_SUB_CHUNK )

	push	8
	lea	edx, DWORD PTR _subChunk$[ebp]
	push	edx
	mov	eax, DWORD PTR _streams$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	__read
	add	esp, 12					; 0000000cH
	cmp	eax, 8
	je	SHORT $LN24@aviOpen

; 303  :             return RIFF_BAD_FORMAT;

	mov	eax, -2					; fffffffeH
	jmp	$LN70@aviOpen
$LN24@aviOpen:

; 304  :       }
; 305  :       else

	jmp	SHORT $LN23@aviOpen
$LN25@aviOpen:

; 306  :          return RIFF_BAD_FORMAT;

	mov	eax, -2					; fffffffeH
	jmp	$LN70@aviOpen
$LN23@aviOpen:

; 307  :    }

	jmp	SHORT $LN27@aviOpen
$LN26@aviOpen:

; 308  : 
; 309  :    if ( AVI_READ( streams->handle, &token, RIFF_TOKEN_SIZE ) !=
; 310  :                   RIFF_TOKEN_SIZE )

	push	4
	lea	edx, DWORD PTR _token$[ebp]
	push	edx
	mov	eax, DWORD PTR _streams$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	__read
	add	esp, 12					; 0000000cH
	cmp	eax, 4
	je	SHORT $LN22@aviOpen

; 311  :          return RIFF_BAD_FORMAT;

	mov	eax, -2					; fffffffeH
	jmp	$LN70@aviOpen
$LN22@aviOpen:

; 312  : 
; 313  :    if ( token != RIFFCODE( 'm', 'o', 'v', 'i' ) )

	cmp	DWORD PTR _token$[ebp], 1769369453	; 69766f6dH
	je	SHORT $LN21@aviOpen

; 314  :       return RIFF_BAD_FORMAT;

	mov	eax, -2					; fffffffeH
	jmp	$LN70@aviOpen
$LN21@aviOpen:

; 315  : 
; 316  :    /*
; 317  :       Get rid of 'LIST' and chunk size if there are multiple streams.
; 318  :    */
; 319  : 
; 320  :    if ( streams->mainAVIHeader.dwStreams > 1 )

	mov	edx, DWORD PTR _streams$[ebp]
	cmp	DWORD PTR [edx+64], 1
	jbe	SHORT $LN20@aviOpen

; 321  :    {
; 322  :       if ( AVI_READ( streams->handle, &( streams->preRECSubChunk ),
; 323  :                      RIFF_SUB_CHUNK ) != RIFF_SUB_CHUNK )

	push	8
	mov	eax, DWORD PTR _streams$[ebp]
	add	eax, 696				; 000002b8H
	push	eax
	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	__read
	add	esp, 12					; 0000000cH
	cmp	eax, 8
	je	SHORT $LN19@aviOpen

; 324  :          return RIFF_BAD_FORMAT;

	mov	eax, -2					; fffffffeH
	jmp	$LN70@aviOpen
$LN19@aviOpen:

; 325  : 
; 326  :       if ( streams->preRECSubChunk.subChunkID !=
; 327  :                      RIFFCODE( 'L', 'I', 'S', 'T' ) )

	mov	eax, DWORD PTR _streams$[ebp]
	cmp	DWORD PTR [eax+696], 1414744396		; 5453494cH
	je	SHORT $LN20@aviOpen

; 328  :          return RIFF_BAD_FORMAT;

	mov	eax, -2					; fffffffeH
	jmp	$LN70@aviOpen
$LN20@aviOpen:

; 329  :    }
; 330  : 
; 331  :    /*
; 332  :       Allocate memory for video blocks.
; 333  :    */
; 334  : 
; 335  :    videoBlock = &( streams->videoBlock[0] );

	mov	ecx, 16					; 00000010H
	imul	ecx, 0
	mov	edx, DWORD PTR _streams$[ebp]
	lea	eax, DWORD PTR [edx+ecx+304]
	mov	DWORD PTR _videoBlock$[ebp], eax

; 336  :    blockSize = streams->strh1.dwSuggestedBufferSize;

	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR [ecx+132]
	mov	DWORD PTR _blockSize$[ebp], edx

; 337  : 
; 338  :    if ( !blockSize )

	cmp	DWORD PTR _blockSize$[ebp], 0
	jne	SHORT $LN17@aviOpen

; 339  :       blockSize = DEFAULT_BLOCK_SIZE;

	mov	DWORD PTR _blockSize$[ebp], 16384	; 00004000H
$LN17@aviOpen:

; 340  : 
; 341  :    if ( streams->mainAVIHeader.dwTotalFrames > MAX_VIDBLOCKS )

	mov	eax, DWORD PTR _streams$[ebp]
	cmp	DWORD PTR [eax+56], 24			; 00000018H
	jbe	SHORT $LN16@aviOpen

; 342  :       streams->numOfVidBlocks = MAX_VIDBLOCKS;

	mov	ecx, DWORD PTR _streams$[ebp]
	mov	DWORD PTR [ecx+32], 24			; 00000018H

; 343  :    else

	jmp	SHORT $LN15@aviOpen
$LN16@aviOpen:

; 344  :       streams->numOfVidBlocks = streams->mainAVIHeader.dwTotalFrames;

	mov	edx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR _streams$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	DWORD PTR [edx+32], ecx
$LN15@aviOpen:

; 345  : 
; 346  :    for ( i = 0; i < streams->numOfVidBlocks; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN14@aviOpen
$LN13@aviOpen:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN14@aviOpen:
	mov	eax, DWORD PTR _streams$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+32]
	jge	$LN12@aviOpen

; 347  :    {
; 348  :       videoBlock[i].bufferSize = blockSize;

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _videoBlock$[ebp]
	mov	ecx, DWORD PTR _blockSize$[ebp]
	mov	DWORD PTR [eax+edx], ecx

; 349  : //      videoBlock[i].buffer = AVI_MALLOC( blockSize );
; 350  :       videoBlock[i].buffer = new char[blockSize];

	mov	edx, DWORD PTR _blockSize$[ebp]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _videoBlock$[ebp]
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR [ecx+eax+8], edx

; 351  :       if ( !videoBlock[i].buffer )

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _videoBlock$[ebp]
	cmp	DWORD PTR [ecx+eax+8], 0
	jne	SHORT $LN11@aviOpen

; 352  :          return RIFF_MALLOC_FAILED;

	mov	eax, -4					; fffffffcH
	jmp	$LN70@aviOpen
$LN11@aviOpen:

; 353  : 
; 354  :       if ( i < ( streams->numOfVidBlocks - 1 ) )

	mov	edx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR [edx+32]
	sub	eax, 1
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $LN10@aviOpen

; 355  :          videoBlock[i].next = &videoBlock[i+1];

	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	shl	ecx, 4
	add	ecx, DWORD PTR _videoBlock$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _videoBlock$[ebp]
	mov	DWORD PTR [eax+edx+12], ecx

; 356  :       else

	jmp	SHORT $LN9@aviOpen
$LN10@aviOpen:

; 357  :          videoBlock[i].next = &videoBlock[0];

	mov	ecx, 16					; 00000010H
	imul	ecx, 0
	add	ecx, DWORD PTR _videoBlock$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _videoBlock$[ebp]
	mov	DWORD PTR [eax+edx+12], ecx
$LN9@aviOpen:

; 358  :    }

	jmp	$LN13@aviOpen
$LN12@aviOpen:

; 359  : 
; 360  :    streams->currentBlock = videoBlock;

	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR _videoBlock$[ebp]
	mov	DWORD PTR [ecx+688], edx

; 361  :    streams->nextBlockToFill = videoBlock;

	mov	eax, DWORD PTR _streams$[ebp]
	mov	ecx, DWORD PTR _videoBlock$[ebp]
	mov	DWORD PTR [eax+692], ecx

; 362  : 
; 363  :    streams->frameRate = ( streams->strh1.dwRate + streams->strh1.dwScale / 2 ) /
; 364  :                         streams->strh1.dwScale;

	mov	edx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR [edx+116]
	shr	eax, 1
	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR [ecx+120]
	add	edx, eax
	mov	ecx, DWORD PTR _streams$[ebp]
	mov	eax, edx
	xor	edx, edx
	div	DWORD PTR [ecx+116]
	mov	edx, DWORD PTR _streams$[ebp]
	mov	DWORD PTR [edx+16], eax

; 365  : 
; 366  :    streams->timePerFrame = ( ONE_SECOND + streams->frameRate - 1 ) / streams->frameRate;

	mov	eax, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR [eax+16]
	add	eax, 999				; 000003e7H
	mov	ecx, DWORD PTR _streams$[ebp]
	cdq
	idiv	DWORD PTR [ecx+16]
	mov	edx, DWORD PTR _streams$[ebp]
	mov	DWORD PTR [edx+20], eax

; 367  :    streams->initialFrames = streams->mainAVIHeader.dwInitialFrames ;

	mov	eax, DWORD PTR _streams$[ebp]
	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	DWORD PTR [eax+12], edx

; 368  : 
; 369  :    if ( streams->audioFlag & STREAM_AUDIO_ON )

	mov	eax, DWORD PTR _streams$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 1
	je	$LN8@aviOpen

; 370  :    {
; 371  :       if ( streams->audioFlag & STREAM_AUDIO_PRELOAD )

	mov	edx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 4
	je	SHORT $LN7@aviOpen

; 372  :       {
; 373  :          i = streams->audioToReadPerFrame = streams->totalAudioRemaining;

	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR [ecx+36], eax
	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR _i$[ebp], edx

; 374  : 
; 375  :          streams->audioSizePerFrame = ( streams->waveFormat.nAvgBytesPerSec +
; 376  :                                         streams->frameRate - 1 ) /
; 377  :                                         streams->frameRate;

	mov	eax, DWORD PTR _streams$[ebp]
	mov	ecx, DWORD PTR [eax+272]
	mov	edx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR [edx+16]
	lea	eax, DWORD PTR [ecx+eax-1]
	mov	ecx, DWORD PTR _streams$[ebp]
	xor	edx, edx
	div	DWORD PTR [ecx+16]
	mov	edx, DWORD PTR _streams$[ebp]
	mov	DWORD PTR [edx+24], eax

; 378  : 
; 379  :          /*
; 380  :             Make audioSizePerFrame a multiple of sample size.
; 381  :          */
; 382  : 
; 383  :          remainder = streams->audioSizePerFrame %
; 384  :                      streams->waveFormat.nBlockAlign;

	mov	eax, DWORD PTR _streams$[ebp]
	movzx	ecx, WORD PTR [eax+276]
	mov	edx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR [edx+24]
	cdq
	idiv	ecx
	mov	DWORD PTR _remainder$[ebp], edx

; 385  : 
; 386  :          if ( remainder )

	cmp	DWORD PTR _remainder$[ebp], 0
	je	SHORT $LN6@aviOpen

; 387  :          {
; 388  :             streams->audioSizePerFrame += ( streams->waveFormat.nBlockAlign -
; 389  :                                           remainder );

	mov	eax, DWORD PTR _streams$[ebp]
	movzx	ecx, WORD PTR [eax+276]
	sub	ecx, DWORD PTR _remainder$[ebp]
	mov	edx, DWORD PTR _streams$[ebp]
	add	ecx, DWORD PTR [edx+24]
	mov	eax, DWORD PTR _streams$[ebp]
	mov	DWORD PTR [eax+24], ecx
$LN6@aviOpen:

; 390  :          }
; 391  :       }
; 392  :       else

	jmp	$LN5@aviOpen
$LN7@aviOpen:

; 393  :       {
; 394  :          if ( ( streams->audioFlag & STREAM_AUDIO_EXTERNAL ) &&
; 395  :                !streams->initialFrames )

	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	and	edx, 2
	je	SHORT $LN4@aviOpen
	mov	eax, DWORD PTR _streams$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN4@aviOpen

; 396  :             streams->initialFrames = 1 + ( streams->frameRate * 3 / 4 );

	mov	ecx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR [ecx+16]
	imul	eax, 3
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	add	eax, 1
	mov	edx, DWORD PTR _streams$[ebp]
	mov	DWORD PTR [edx+12], eax
$LN4@aviOpen:

; 397  : 
; 398  :          streams->audioSizePerFrame = ( streams->waveFormat.nAvgBytesPerSec +
; 399  :                                         streams->frameRate - 1 ) /
; 400  :                                         streams->frameRate;

	mov	eax, DWORD PTR _streams$[ebp]
	mov	ecx, DWORD PTR [eax+272]
	mov	edx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR [edx+16]
	lea	eax, DWORD PTR [ecx+eax-1]
	mov	ecx, DWORD PTR _streams$[ebp]
	xor	edx, edx
	div	DWORD PTR [ecx+16]
	mov	edx, DWORD PTR _streams$[ebp]
	mov	DWORD PTR [edx+24], eax

; 401  : 
; 402  :          /*
; 403  :             Make audioSizePerFrame a multiple of sample size.
; 404  :          */
; 405  : 
; 406  :          remainder = streams->audioSizePerFrame %
; 407  :                      streams->waveFormat.nBlockAlign;

	mov	eax, DWORD PTR _streams$[ebp]
	movzx	ecx, WORD PTR [eax+276]
	mov	edx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR [edx+24]
	cdq
	idiv	ecx
	mov	DWORD PTR _remainder$[ebp], edx

; 408  : 
; 409  :          if ( remainder )

	cmp	DWORD PTR _remainder$[ebp], 0
	je	SHORT $LN3@aviOpen

; 410  :          {
; 411  :             streams->audioSizePerFrame += ( streams->waveFormat.nBlockAlign -
; 412  :                                           remainder );

	mov	eax, DWORD PTR _streams$[ebp]
	movzx	ecx, WORD PTR [eax+276]
	sub	ecx, DWORD PTR _remainder$[ebp]
	mov	edx, DWORD PTR _streams$[ebp]
	add	ecx, DWORD PTR [edx+24]
	mov	eax, DWORD PTR _streams$[ebp]
	mov	DWORD PTR [eax+24], ecx
$LN3@aviOpen:

; 413  :          }
; 414  : 
; 415  :          streams->audioToReadPerFrame = streams->audioSizePerFrame;

	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR [ecx+36], eax

; 416  : 
; 417  :          i = streams->audioSizePerFrame *
; 418  :                ( streams->numOfVidBlocks + streams->initialFrames +
; 419  :                AUDIO_PADDING );

	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _streams$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	lea	edx, DWORD PTR [edx+ecx+4]
	mov	eax, DWORD PTR _streams$[ebp]
	imul	edx, DWORD PTR [eax+24]
	mov	DWORD PTR _i$[ebp], edx

; 420  : 
; 421  :          if ( i < RING_BUFFER )

	cmp	DWORD PTR _i$[ebp], 65536		; 00010000H
	jge	SHORT $LN5@aviOpen

; 422  :             i = RING_BUFFER;

	mov	DWORD PTR _i$[ebp], 65536		; 00010000H
$LN5@aviOpen:

; 423  :       }
; 424  : 
; 425  : //      streams->waveBuffer = AVI_MALLOC( i );
; 426  :       streams->waveBuffer = new char[i];

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	edx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR [edx+284], eax

; 427  : 
; 428  :       if ( !streams->waveBuffer )

	mov	ecx, DWORD PTR _streams$[ebp]
	cmp	DWORD PTR [ecx+284], 0
	jne	SHORT $LN1@aviOpen

; 429  :          return RIFF_MALLOC_FAILED;

	mov	eax, -4					; fffffffcH
	jmp	SHORT $LN70@aviOpen
$LN1@aviOpen:

; 430  : 
; 431  :       streams->waveBufferLen = i;

	mov	edx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR [edx+292], eax

; 432  :       streams->waveBufferWrite = 0;

	mov	ecx, DWORD PTR _streams$[ebp]
	mov	DWORD PTR [ecx+296], 0

; 433  :       streams->waveBufferRead = 0;

	mov	edx, DWORD PTR _streams$[ebp]
	mov	DWORD PTR [edx+300], 0

; 434  :       streams->dataInWaveBuffer = 0;

	mov	eax, DWORD PTR _streams$[ebp]
	mov	DWORD PTR [eax+288], 0
$LN8@aviOpen:

; 435  :    }
; 436  : 
; 437  :    return RIFF_OK;

	xor	eax, eax
$LN70@aviOpen:

; 438  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_aviOpen ENDP
_TEXT	ENDS
END
