; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\voicecomunication\dxutil.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?DXUtil_GetDXSDKMediaPath@@YAPBDXZ		; DXUtil_GetDXSDKMediaPath
PUBLIC	?DXUtil_FindMediaFile@@YAJPAD0@Z		; DXUtil_FindMediaFile
PUBLIC	?DXUtil_WriteStringRegKey@@YAJPAUHKEY__@@PAD1@Z	; DXUtil_WriteStringRegKey
PUBLIC	?DXUtil_WriteIntRegKey@@YAJPAUHKEY__@@PADK@Z	; DXUtil_WriteIntRegKey
PUBLIC	?DXUtil_WriteGuidRegKey@@YAJPAUHKEY__@@PADU_GUID@@@Z ; DXUtil_WriteGuidRegKey
PUBLIC	?DXUtil_WriteBoolRegKey@@YAJPAUHKEY__@@PADH@Z	; DXUtil_WriteBoolRegKey
PUBLIC	?DXUtil_ReadStringRegKey@@YAJPAUHKEY__@@PAD1K1@Z ; DXUtil_ReadStringRegKey
PUBLIC	?DXUtil_ReadIntRegKey@@YAJPAUHKEY__@@PADPAKK@Z	; DXUtil_ReadIntRegKey
PUBLIC	?DXUtil_ReadGuidRegKey@@YAJPAUHKEY__@@PADPAU_GUID@@AAU2@@Z ; DXUtil_ReadGuidRegKey
PUBLIC	?DXUtil_ReadBoolRegKey@@YAJPAUHKEY__@@PADPAHH@Z	; DXUtil_ReadBoolRegKey
PUBLIC	?DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z		; DXUtil_Timer
PUBLIC	?DXUtil_ConvertAnsiStringToWide@@YAXPA_WPBDH@Z	; DXUtil_ConvertAnsiStringToWide
PUBLIC	?DXUtil_ConvertWideStringToAnsi@@YAXPADPB_WH@Z	; DXUtil_ConvertWideStringToAnsi
PUBLIC	?DXUtil_ConvertGenericStringToAnsi@@YAXPADPBDH@Z ; DXUtil_ConvertGenericStringToAnsi
PUBLIC	?DXUtil_ConvertGenericStringToWide@@YAXPA_WPBDH@Z ; DXUtil_ConvertGenericStringToWide
PUBLIC	?DXUtil_ConvertAnsiStringToGeneric@@YAXPADPBDH@Z ; DXUtil_ConvertAnsiStringToGeneric
PUBLIC	?DXUtil_ConvertWideStringToGeneric@@YAXPADPB_WH@Z ; DXUtil_ConvertWideStringToGeneric
PUBLIC	?DXUtil_ConvertGUIDToString@@YAXPBU_GUID@@PAD@Z	; DXUtil_ConvertGUIDToString
PUBLIC	?DXUtil_ConvertStringToGUID@@YAHPBDPAU_GUID@@@Z	; DXUtil_ConvertStringToGUID
PUBLIC	?DXUtil_Trace@@YAXPADZZ				; DXUtil_Trace
PUBLIC	?_DbgOut@@YAJPADKJ0@Z				; _DbgOut
PUBLIC	??_C@_0BP@HEGLIIKH@Software?2Microsoft?2DirectX?5SDK?$AA@ ; `string'
PUBLIC	??_C@_0BF@FNOEFMNI@DX81SDK?5Samples?5Path?$AA@	; `string'
PUBLIC	??_C@_07JADGJGAE@?2Media?2?$AA@			; `string'
PUBLIC	??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@		; `string'
PUBLIC	??_C@_09LJPPHFCJ@?$CFs?$CI?$CFld?$CJ?3?5?$AA@	; `string'
PUBLIC	??_C@_0M@JDCEFKLB@?$CIhr?$DN?$CF08lx?$CJ?6?$AA@	; `string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_0CI@FDANOHPD@?$HL?$CF8X?9?$CF4X?9?$CF4X?9?$CF2X?$CF2X?9?$CF2X?$CF2X?$CF2X?$CF2X@ ; `string'
PUBLIC	??_C@_0DO@OBIAHMKG@?$HL?$CF0?48X?9?$CF0?44X?9?$CF0?44X?9?$CF0?42X?$CF0?42X?9?$CF0@ ; `string'
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@3f50624dd2f1a9fc
PUBLIC	__real@3fb99999a0000000
PUBLIC	__real@bf800000
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	_memset:PROC
EXTRN	_strcpy:PROC
EXTRN	_strcat:PROC
EXTRN	_strlen:PROC
EXTRN	_strncpy:PROC
EXTRN	_wcslen:PROC
EXTRN	__imp__CreateFileA@28:PROC
EXTRN	__imp__GetFullPathNameA@16:PROC
EXTRN	__imp__OutputDebugStringA@4:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__QueryPerformanceCounter@4:PROC
EXTRN	__imp__QueryPerformanceFrequency@4:PROC
EXTRN	__imp__wsprintfA:PROC
EXTRN	__imp__MultiByteToWideChar@24:PROC
EXTRN	__imp__WideCharToMultiByte@32:PROC
EXTRN	__imp__RegCloseKey@4:PROC
EXTRN	__imp__RegOpenKeyExA@20:PROC
EXTRN	__imp__RegQueryValueExA@24:PROC
EXTRN	__imp__RegSetValueExA@24:PROC
EXTRN	__imp__timeGetTime@0:PROC
EXTRN	_sscanf:PROC
EXTRN	_sprintf:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__alldiv:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?strNull@?1??DXUtil_GetDXSDKMediaPath@@YAPBDXZ@4PADA
_BSS	SEGMENT
?strNull@?1??DXUtil_GetDXSDKMediaPath@@YAPBDXZ@4PADA DB 02H DUP (?) ; `DXUtil_GetDXSDKMediaPath'::`2'::strNull
_BSS	ENDS
;	COMDAT ?strPath@?1??DXUtil_GetDXSDKMediaPath@@YAPBDXZ@4PADA
_BSS	SEGMENT
?strPath@?1??DXUtil_GetDXSDKMediaPath@@YAPBDXZ@4PADA DB 0104H DUP (?) ; `DXUtil_GetDXSDKMediaPath'::`2'::strPath
_BSS	ENDS
;	COMDAT ?m_bTimerInitialized@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4HA
_BSS	SEGMENT
?m_bTimerInitialized@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4HA DD 01H DUP (?) ; `DXUtil_Timer'::`2'::m_bTimerInitialized
_BSS	ENDS
;	COMDAT ?m_bUsingQPF@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4HA
_BSS	SEGMENT
?m_bUsingQPF@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4HA DD 01H DUP (?) ; `DXUtil_Timer'::`2'::m_bUsingQPF
_BSS	ENDS
;	COMDAT ?m_llQPFTicksPerSec@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA
_BSS	SEGMENT
?m_llQPFTicksPerSec@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA DQ 01H DUP (?) ; `DXUtil_Timer'::`2'::m_llQPFTicksPerSec
_BSS	ENDS
;	COMDAT ?m_llStopTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA
_BSS	SEGMENT
?m_llStopTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA DQ 01H DUP (?) ; `DXUtil_Timer'::`10'::m_llStopTime
_BSS	ENDS
;	COMDAT ?m_llLastElapsedTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA
_BSS	SEGMENT
?m_llLastElapsedTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA DQ 01H DUP (?) ; `DXUtil_Timer'::`10'::m_llLastElapsedTime
_BSS	ENDS
;	COMDAT ?m_llBaseTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA
_BSS	SEGMENT
?m_llBaseTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA DQ 01H DUP (?) ; `DXUtil_Timer'::`10'::m_llBaseTime
_BSS	ENDS
;	COMDAT ?m_fLastElapsedTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA
_BSS	SEGMENT
?m_fLastElapsedTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA DQ 01H DUP (?) ; `DXUtil_Timer'::`38'::m_fLastElapsedTime
_BSS	ENDS
;	COMDAT ?m_fBaseTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA
_BSS	SEGMENT
?m_fBaseTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA DQ 01H DUP (?) ; `DXUtil_Timer'::`38'::m_fBaseTime
_BSS	ENDS
;	COMDAT ?m_fStopTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA
_BSS	SEGMENT
?m_fStopTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA DQ 01H DUP (?) ; `DXUtil_Timer'::`38'::m_fStopTime
_BSS	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@3fb99999a0000000
CONST	SEGMENT
__real@3fb99999a0000000 DQ 03fb99999a0000000r	; 0.1
CONST	ENDS
;	COMDAT __real@3f50624dd2f1a9fc
CONST	SEGMENT
__real@3f50624dd2f1a9fc DQ 03f50624dd2f1a9fcr	; 0.001
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0DO@OBIAHMKG@?$HL?$CF0?48X?9?$CF0?44X?9?$CF0?44X?9?$CF0?42X?$CF0?42X?9?$CF0@
CONST	SEGMENT
??_C@_0DO@OBIAHMKG@?$HL?$CF0?48X?9?$CF0?44X?9?$CF0?44X?9?$CF0?42X?$CF0?42X?9?$CF0@ DB '{'
	DB	'%0.8X-%0.4X-%0.4X-%0.2X%0.2X-%0.2X%0.2X%0.2X%0.2X%0.2X%0.2X}', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@FDANOHPD@?$HL?$CF8X?9?$CF4X?9?$CF4X?9?$CF2X?$CF2X?9?$CF2X?$CF2X?$CF2X?$CF2X@
CONST	SEGMENT
??_C@_0CI@FDANOHPD@?$HL?$CF8X?9?$CF4X?9?$CF4X?9?$CF2X?$CF2X?9?$CF2X?$CF2X?$CF2X?$CF2X@ DB '{'
	DB	'%8X-%4X-%4X-%2X%2X-%2X%2X%2X%2X%2X%2X}', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JDCEFKLB@?$CIhr?$DN?$CF08lx?$CJ?6?$AA@
CONST	SEGMENT
??_C@_0M@JDCEFKLB@?$CIhr?$DN?$CF08lx?$CJ?6?$AA@ DB '(hr=%08lx)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09LJPPHFCJ@?$CFs?$CI?$CFld?$CJ?3?5?$AA@
CONST	SEGMENT
??_C@_09LJPPHFCJ@?$CFs?$CI?$CFld?$CJ?3?5?$AA@ DB '%s(%ld): ', 00H ; `string'
CONST	ENDS
;	COMDAT ?m_bTimerStopped@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4HA
_DATA	SEGMENT
?m_bTimerStopped@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4HA DD 01H ; `DXUtil_Timer'::`2'::m_bTimerStopped
_DATA	ENDS
;	COMDAT ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
CONST	SEGMENT
??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@ DB '%s%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07JADGJGAE@?2Media?2?$AA@
CONST	SEGMENT
??_C@_07JADGJGAE@?2Media?2?$AA@ DB '\Media\', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FNOEFMNI@DX81SDK?5Samples?5Path?$AA@
CONST	SEGMENT
??_C@_0BF@FNOEFMNI@DX81SDK?5Samples?5Path?$AA@ DB 'DX81SDK Samples Path', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@HEGLIIKH@Software?2Microsoft?2DirectX?5SDK?$AA@
CONST	SEGMENT
??_C@_0BP@HEGLIIKH@Software?2Microsoft?2DirectX?5SDK?$AA@ DB 'Software\Mi'
	DB	'crosoft\DirectX SDK', 00H			; `string'
CONST	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\voicecomunication\dxutil.cpp
_TEXT	SEGMENT
_buffer$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_strFile$ = 8						; size = 4
_dwLine$ = 12						; size = 4
_hr$ = 16						; size = 4
_strMsg$ = 20						; size = 4
?_DbgOut@@YAJPADKJ0@Z PROC				; _DbgOut

; 625  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 260				; 00000104H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 626  :     TCHAR buffer[256];
; 627  :     wsprintf( buffer, _T("%s(%ld): "), strFile, dwLine );

	mov	eax, DWORD PTR _dwLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _strFile$[ebp]
	push	ecx
	push	OFFSET ??_C@_09LJPPHFCJ@?$CFs?$CI?$CFld?$CJ?3?5?$AA@
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	DWORD PTR __imp__wsprintfA
	add	esp, 16					; 00000010H

; 628  :     OutputDebugString( buffer );

	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	DWORD PTR __imp__OutputDebugStringA@4

; 629  :     OutputDebugString( strMsg );

	mov	ecx, DWORD PTR _strMsg$[ebp]
	push	ecx
	call	DWORD PTR __imp__OutputDebugStringA@4

; 630  : 
; 631  :     if( hr )

	cmp	DWORD PTR _hr$[ebp], 0
	je	SHORT $LN1@DbgOut

; 632  :     {
; 633  :         wsprintf( buffer, _T("(hr=%08lx)\n"), hr );

	mov	edx, DWORD PTR _hr$[ebp]
	push	edx
	push	OFFSET ??_C@_0M@JDCEFKLB@?$CIhr?$DN?$CF08lx?$CJ?6?$AA@
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	DWORD PTR __imp__wsprintfA
	add	esp, 12					; 0000000cH

; 634  :         OutputDebugString( buffer );

	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	DWORD PTR __imp__OutputDebugStringA@4
$LN1@DbgOut:

; 635  :     }
; 636  : 
; 637  :     OutputDebugString( _T("\n") );

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	DWORD PTR __imp__OutputDebugStringA@4

; 638  : 
; 639  :     return hr;

	mov	eax, DWORD PTR _hr$[ebp]

; 640  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?_DbgOut@@YAJPADKJ0@Z ENDP				; _DbgOut
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\voicecomunication\dxutil.cpp
_TEXT	SEGMENT
_strMsg$ = 8						; size = 4
?DXUtil_Trace@@YAXPADZZ PROC				; DXUtil_Trace

; 651  : {

	push	ebp
	mov	ebp, esp

; 652  : #if defined(DEBUG) | defined(_DEBUG)
; 653  :     TCHAR strBuffer[512];
; 654  :     
; 655  :     va_list args;
; 656  :     va_start(args, strMsg);
; 657  :     _vsntprintf( strBuffer, 512, strMsg, args );
; 658  :     va_end(args);
; 659  : 
; 660  :     OutputDebugString( strBuffer );
; 661  : #endif
; 662  : }

	pop	ebp
	ret	0
?DXUtil_Trace@@YAXPADZZ ENDP				; DXUtil_Trace
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\voicecomunication\dxutil.cpp
_TEXT	SEGMENT
_aiTmp$ = -44						; size = 40
__$ArrayPad$ = -4					; size = 4
_strIn$ = 8						; size = 4
_pGuidOut$ = 12						; size = 4
?DXUtil_ConvertStringToGUID@@YAHPBDPAU_GUID@@@Z PROC	; DXUtil_ConvertStringToGUID

; 672  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 673  :     UINT aiTmp[10];
; 674  : 
; 675  :     if( _stscanf( strIn, TEXT("{%8X-%4X-%4X-%2X%2X-%2X%2X%2X%2X%2X%2X}"),
; 676  :                     &pGuidOut->Data1, 
; 677  :                     &aiTmp[0], &aiTmp[1], 
; 678  :                     &aiTmp[2], &aiTmp[3],
; 679  :                     &aiTmp[4], &aiTmp[5],
; 680  :                     &aiTmp[6], &aiTmp[7],
; 681  :                     &aiTmp[8], &aiTmp[9] ) != 11 )

	mov	eax, 4
	imul	eax, 9
	lea	ecx, DWORD PTR _aiTmp$[ebp+eax]
	push	ecx
	mov	edx, 4
	shl	edx, 3
	lea	eax, DWORD PTR _aiTmp$[ebp+edx]
	push	eax
	mov	ecx, 4
	imul	ecx, 7
	lea	edx, DWORD PTR _aiTmp$[ebp+ecx]
	push	edx
	mov	eax, 4
	imul	eax, 6
	lea	ecx, DWORD PTR _aiTmp$[ebp+eax]
	push	ecx
	mov	edx, 4
	imul	edx, 5
	lea	eax, DWORD PTR _aiTmp$[ebp+edx]
	push	eax
	mov	ecx, 4
	shl	ecx, 2
	lea	edx, DWORD PTR _aiTmp$[ebp+ecx]
	push	edx
	mov	eax, 4
	imul	eax, 3
	lea	ecx, DWORD PTR _aiTmp$[ebp+eax]
	push	ecx
	mov	edx, 4
	shl	edx, 1
	lea	eax, DWORD PTR _aiTmp$[ebp+edx]
	push	eax
	mov	ecx, 4
	shl	ecx, 0
	lea	edx, DWORD PTR _aiTmp$[ebp+ecx]
	push	edx
	mov	eax, 4
	imul	eax, 0
	lea	ecx, DWORD PTR _aiTmp$[ebp+eax]
	push	ecx
	mov	edx, DWORD PTR _pGuidOut$[ebp]
	push	edx
	push	OFFSET ??_C@_0CI@FDANOHPD@?$HL?$CF8X?9?$CF4X?9?$CF4X?9?$CF2X?$CF2X?9?$CF2X?$CF2X?$CF2X?$CF2X@
	mov	eax, DWORD PTR _strIn$[ebp]
	push	eax
	call	_sscanf
	add	esp, 52					; 00000034H
	cmp	eax, 11					; 0000000bH
	je	SHORT $LN2@DXUtil_Con

; 682  :     {
; 683  :         ZeroMemory( pGuidOut, sizeof(GUID) );

	push	16					; 00000010H
	push	0
	mov	ecx, DWORD PTR _pGuidOut$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 684  :         return FALSE;

	xor	eax, eax
	jmp	$LN3@DXUtil_Con

; 685  :     }
; 686  :     else

	jmp	$LN3@DXUtil_Con
$LN2@DXUtil_Con:

; 687  :     {
; 688  :         pGuidOut->Data2       = (USHORT) aiTmp[0];

	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _pGuidOut$[ebp]
	mov	cx, WORD PTR _aiTmp$[ebp+edx]
	mov	WORD PTR [eax+4], cx

; 689  :         pGuidOut->Data3       = (USHORT) aiTmp[1];

	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pGuidOut$[ebp]
	mov	cx, WORD PTR _aiTmp$[ebp+edx]
	mov	WORD PTR [eax+6], cx

; 690  :         pGuidOut->Data4[0]    = (BYTE) aiTmp[2];

	mov	edx, 4
	shl	edx, 1
	mov	eax, 1
	imul	eax, 0
	mov	ecx, DWORD PTR _pGuidOut$[ebp]
	mov	dl, BYTE PTR _aiTmp$[ebp+edx]
	mov	BYTE PTR [ecx+eax+8], dl

; 691  :         pGuidOut->Data4[1]    = (BYTE) aiTmp[3];

	mov	eax, 4
	imul	eax, 3
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _pGuidOut$[ebp]
	mov	al, BYTE PTR _aiTmp$[ebp+eax]
	mov	BYTE PTR [edx+ecx+8], al

; 692  :         pGuidOut->Data4[2]    = (BYTE) aiTmp[4];

	mov	ecx, 4
	shl	ecx, 2
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _pGuidOut$[ebp]
	mov	cl, BYTE PTR _aiTmp$[ebp+ecx]
	mov	BYTE PTR [eax+edx+8], cl

; 693  :         pGuidOut->Data4[3]    = (BYTE) aiTmp[5];

	mov	edx, 4
	imul	edx, 5
	mov	eax, 1
	imul	eax, 3
	mov	ecx, DWORD PTR _pGuidOut$[ebp]
	mov	dl, BYTE PTR _aiTmp$[ebp+edx]
	mov	BYTE PTR [ecx+eax+8], dl

; 694  :         pGuidOut->Data4[4]    = (BYTE) aiTmp[6];

	mov	eax, 4
	imul	eax, 6
	mov	ecx, 1
	shl	ecx, 2
	mov	edx, DWORD PTR _pGuidOut$[ebp]
	mov	al, BYTE PTR _aiTmp$[ebp+eax]
	mov	BYTE PTR [edx+ecx+8], al

; 695  :         pGuidOut->Data4[5]    = (BYTE) aiTmp[7];

	mov	ecx, 4
	imul	ecx, 7
	mov	edx, 1
	imul	edx, 5
	mov	eax, DWORD PTR _pGuidOut$[ebp]
	mov	cl, BYTE PTR _aiTmp$[ebp+ecx]
	mov	BYTE PTR [eax+edx+8], cl

; 696  :         pGuidOut->Data4[6]    = (BYTE) aiTmp[8];

	mov	edx, 4
	shl	edx, 3
	mov	eax, 1
	imul	eax, 6
	mov	ecx, DWORD PTR _pGuidOut$[ebp]
	mov	dl, BYTE PTR _aiTmp$[ebp+edx]
	mov	BYTE PTR [ecx+eax+8], dl

; 697  :         pGuidOut->Data4[7]    = (BYTE) aiTmp[9];

	mov	eax, 4
	imul	eax, 9
	mov	ecx, 1
	imul	ecx, 7
	mov	edx, DWORD PTR _pGuidOut$[ebp]
	mov	al, BYTE PTR _aiTmp$[ebp+eax]
	mov	BYTE PTR [edx+ecx+8], al

; 698  :         return TRUE;

	mov	eax, 1
$LN3@DXUtil_Con:

; 699  :     }
; 700  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUtil_ConvertStringToGUID@@YAHPBDPAU_GUID@@@Z ENDP	; DXUtil_ConvertStringToGUID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\voicecomunication\dxutil.cpp
_TEXT	SEGMENT
_pGuidIn$ = 8						; size = 4
_strOut$ = 12						; size = 4
?DXUtil_ConvertGUIDToString@@YAXPBU_GUID@@PAD@Z PROC	; DXUtil_ConvertGUIDToString

; 710  : {

	push	ebp
	mov	ebp, esp

; 711  :     _stprintf( strOut, TEXT("{%0.8X-%0.4X-%0.4X-%0.2X%0.2X-%0.2X%0.2X%0.2X%0.2X%0.2X%0.2X}"),
; 712  :                pGuidIn->Data1, pGuidIn->Data2, pGuidIn->Data3,
; 713  :                pGuidIn->Data4[0], pGuidIn->Data4[1],
; 714  :                pGuidIn->Data4[2], pGuidIn->Data4[3],
; 715  :                pGuidIn->Data4[4], pGuidIn->Data4[5],
; 716  :                pGuidIn->Data4[6], pGuidIn->Data4[7] );

	mov	eax, 1
	imul	eax, 7
	mov	ecx, DWORD PTR _pGuidIn$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+8]
	push	edx
	mov	eax, 1
	imul	eax, 6
	mov	ecx, DWORD PTR _pGuidIn$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+8]
	push	edx
	mov	eax, 1
	imul	eax, 5
	mov	ecx, DWORD PTR _pGuidIn$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+8]
	push	edx
	mov	eax, 1
	shl	eax, 2
	mov	ecx, DWORD PTR _pGuidIn$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+8]
	push	edx
	mov	eax, 1
	imul	eax, 3
	mov	ecx, DWORD PTR _pGuidIn$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+8]
	push	edx
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _pGuidIn$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+8]
	push	edx
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _pGuidIn$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+8]
	push	edx
	mov	eax, 1
	imul	eax, 0
	mov	ecx, DWORD PTR _pGuidIn$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+8]
	push	edx
	mov	eax, DWORD PTR _pGuidIn$[ebp]
	movzx	ecx, WORD PTR [eax+6]
	push	ecx
	mov	edx, DWORD PTR _pGuidIn$[ebp]
	movzx	eax, WORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _pGuidIn$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	push	OFFSET ??_C@_0DO@OBIAHMKG@?$HL?$CF0?48X?9?$CF0?44X?9?$CF0?44X?9?$CF0?42X?$CF0?42X?9?$CF0@
	mov	eax, DWORD PTR _strOut$[ebp]
	push	eax
	call	_sprintf
	add	esp, 52					; 00000034H

; 717  : }

	pop	ebp
	ret	0
?DXUtil_ConvertGUIDToString@@YAXPBU_GUID@@PAD@Z ENDP	; DXUtil_ConvertGUIDToString
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\voicecomunication\dxutil.cpp
_TEXT	SEGMENT
_tstrDestination$ = 8					; size = 4
_wstrSource$ = 12					; size = 4
_cchDestChar$ = 16					; size = 4
?DXUtil_ConvertWideStringToGeneric@@YAXPADPB_WH@Z PROC	; DXUtil_ConvertWideStringToGeneric

; 598  : {

	push	ebp
	mov	ebp, esp

; 599  :     if( tstrDestination==NULL || wstrSource==NULL || cchDestChar == 0 )

	cmp	DWORD PTR _tstrDestination$[ebp], 0
	je	SHORT $LN1@DXUtil_Con
	cmp	DWORD PTR _wstrSource$[ebp], 0
	je	SHORT $LN1@DXUtil_Con
	cmp	DWORD PTR _cchDestChar$[ebp], 0
	jne	SHORT $LN2@DXUtil_Con
$LN1@DXUtil_Con:

; 600  :         return;

	jmp	SHORT $LN3@DXUtil_Con
$LN2@DXUtil_Con:

; 601  : 
; 602  : #ifdef _UNICODE
; 603  :     if( cchDestChar == -1 )
; 604  :     {
; 605  :         wcscpy( tstrDestination, wstrSource );
; 606  :     }
; 607  :     else
; 608  :     {
; 609  :         wcsncpy( tstrDestination, wstrSource, cchDestChar );
; 610  :         tstrDestination[cchDestChar-1] = L'\0';
; 611  :     }
; 612  : #else
; 613  :     DXUtil_ConvertWideStringToAnsi( tstrDestination, wstrSource, cchDestChar );

	mov	eax, DWORD PTR _cchDestChar$[ebp]
	push	eax
	mov	ecx, DWORD PTR _wstrSource$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tstrDestination$[ebp]
	push	edx
	call	?DXUtil_ConvertWideStringToAnsi@@YAXPADPB_WH@Z ; DXUtil_ConvertWideStringToAnsi
	add	esp, 12					; 0000000cH
$LN3@DXUtil_Con:

; 614  : #endif
; 615  : }

	pop	ebp
	ret	0
?DXUtil_ConvertWideStringToGeneric@@YAXPADPB_WH@Z ENDP	; DXUtil_ConvertWideStringToGeneric
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\voicecomunication\dxutil.cpp
_TEXT	SEGMENT
_tstrDestination$ = 8					; size = 4
_strSource$ = 12					; size = 4
_cchDestChar$ = 16					; size = 4
?DXUtil_ConvertAnsiStringToGeneric@@YAXPADPBDH@Z PROC	; DXUtil_ConvertAnsiStringToGeneric

; 568  : {

	push	ebp
	mov	ebp, esp

; 569  :     if( tstrDestination==NULL || strSource==NULL || cchDestChar == 0 )

	cmp	DWORD PTR _tstrDestination$[ebp], 0
	je	SHORT $LN3@DXUtil_Con
	cmp	DWORD PTR _strSource$[ebp], 0
	je	SHORT $LN3@DXUtil_Con
	cmp	DWORD PTR _cchDestChar$[ebp], 0
	jne	SHORT $LN4@DXUtil_Con
$LN3@DXUtil_Con:

; 570  :         return;

	jmp	SHORT $LN5@DXUtil_Con
$LN4@DXUtil_Con:

; 571  :         
; 572  : #ifdef _UNICODE
; 573  :     DXUtil_ConvertAnsiStringToWide( tstrDestination, strSource, cchDestChar );
; 574  : #else
; 575  :     if( cchDestChar == -1 )

	cmp	DWORD PTR _cchDestChar$[ebp], -1
	jne	SHORT $LN2@DXUtil_Con

; 576  :     {
; 577  :         strcpy( tstrDestination, strSource );

	mov	eax, DWORD PTR _strSource$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tstrDestination$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 578  :     }
; 579  :     else

	jmp	SHORT $LN5@DXUtil_Con
$LN2@DXUtil_Con:

; 580  :     {
; 581  :         strncpy( tstrDestination, strSource, cchDestChar );

	mov	edx, DWORD PTR _cchDestChar$[ebp]
	push	edx
	mov	eax, DWORD PTR _strSource$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tstrDestination$[ebp]
	push	ecx
	call	_strncpy
	add	esp, 12					; 0000000cH

; 582  :         tstrDestination[cchDestChar-1] = '\0';

	mov	edx, DWORD PTR _tstrDestination$[ebp]
	add	edx, DWORD PTR _cchDestChar$[ebp]
	mov	BYTE PTR [edx-1], 0
$LN5@DXUtil_Con:

; 583  :     }
; 584  : #endif
; 585  : }

	pop	ebp
	ret	0
?DXUtil_ConvertAnsiStringToGeneric@@YAXPADPBDH@Z ENDP	; DXUtil_ConvertAnsiStringToGeneric
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\voicecomunication\dxutil.cpp
_TEXT	SEGMENT
_wstrDestination$ = 8					; size = 4
_tstrSource$ = 12					; size = 4
_cchDestChar$ = 16					; size = 4
?DXUtil_ConvertGenericStringToWide@@YAXPA_WPBDH@Z PROC	; DXUtil_ConvertGenericStringToWide

; 538  : {

	push	ebp
	mov	ebp, esp

; 539  :     if( wstrDestination==NULL || tstrSource==NULL || cchDestChar == 0 )

	cmp	DWORD PTR _wstrDestination$[ebp], 0
	je	SHORT $LN1@DXUtil_Con
	cmp	DWORD PTR _tstrSource$[ebp], 0
	je	SHORT $LN1@DXUtil_Con
	cmp	DWORD PTR _cchDestChar$[ebp], 0
	jne	SHORT $LN2@DXUtil_Con
$LN1@DXUtil_Con:

; 540  :         return;

	jmp	SHORT $LN3@DXUtil_Con
$LN2@DXUtil_Con:

; 541  : 
; 542  : #ifdef _UNICODE
; 543  :     if( cchDestChar == -1 )
; 544  :     {
; 545  :         wcscpy( wstrDestination, tstrSource );
; 546  :     }
; 547  :     else
; 548  :     {
; 549  :         wcsncpy( wstrDestination, tstrSource, cchDestChar );
; 550  :         wstrDestination[cchDestChar-1] = L'\0';
; 551  :     }
; 552  : #else
; 553  :     DXUtil_ConvertAnsiStringToWide( wstrDestination, tstrSource, cchDestChar );

	mov	eax, DWORD PTR _cchDestChar$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tstrSource$[ebp]
	push	ecx
	mov	edx, DWORD PTR _wstrDestination$[ebp]
	push	edx
	call	?DXUtil_ConvertAnsiStringToWide@@YAXPA_WPBDH@Z ; DXUtil_ConvertAnsiStringToWide
	add	esp, 12					; 0000000cH
$LN3@DXUtil_Con:

; 554  : #endif
; 555  : }

	pop	ebp
	ret	0
?DXUtil_ConvertGenericStringToWide@@YAXPA_WPBDH@Z ENDP	; DXUtil_ConvertGenericStringToWide
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\voicecomunication\dxutil.cpp
_TEXT	SEGMENT
_strDestination$ = 8					; size = 4
_tstrSource$ = 12					; size = 4
_cchDestChar$ = 16					; size = 4
?DXUtil_ConvertGenericStringToAnsi@@YAXPADPBDH@Z PROC	; DXUtil_ConvertGenericStringToAnsi

; 508  : {

	push	ebp
	mov	ebp, esp

; 509  :     if( strDestination==NULL || tstrSource==NULL || cchDestChar == 0 )

	cmp	DWORD PTR _strDestination$[ebp], 0
	je	SHORT $LN3@DXUtil_Con
	cmp	DWORD PTR _tstrSource$[ebp], 0
	je	SHORT $LN3@DXUtil_Con
	cmp	DWORD PTR _cchDestChar$[ebp], 0
	jne	SHORT $LN4@DXUtil_Con
$LN3@DXUtil_Con:

; 510  :         return;

	jmp	SHORT $LN5@DXUtil_Con
$LN4@DXUtil_Con:

; 511  : 
; 512  : #ifdef _UNICODE
; 513  :     DXUtil_ConvertWideStringToAnsi( strDestination, tstrSource, cchDestChar );
; 514  : #else
; 515  :     if( cchDestChar == -1 )

	cmp	DWORD PTR _cchDestChar$[ebp], -1
	jne	SHORT $LN2@DXUtil_Con

; 516  :     {
; 517  :         strcpy( strDestination, tstrSource );

	mov	eax, DWORD PTR _tstrSource$[ebp]
	push	eax
	mov	ecx, DWORD PTR _strDestination$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 518  :     }
; 519  :     else

	jmp	SHORT $LN5@DXUtil_Con
$LN2@DXUtil_Con:

; 520  :     {
; 521  :         strncpy( strDestination, tstrSource, cchDestChar );

	mov	edx, DWORD PTR _cchDestChar$[ebp]
	push	edx
	mov	eax, DWORD PTR _tstrSource$[ebp]
	push	eax
	mov	ecx, DWORD PTR _strDestination$[ebp]
	push	ecx
	call	_strncpy
	add	esp, 12					; 0000000cH

; 522  :         strDestination[cchDestChar-1] = '\0';

	mov	edx, DWORD PTR _strDestination$[ebp]
	add	edx, DWORD PTR _cchDestChar$[ebp]
	mov	BYTE PTR [edx-1], 0
$LN5@DXUtil_Con:

; 523  :     }
; 524  : #endif
; 525  : }

	pop	ebp
	ret	0
?DXUtil_ConvertGenericStringToAnsi@@YAXPADPBDH@Z ENDP	; DXUtil_ConvertGenericStringToAnsi
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\voicecomunication\dxutil.cpp
_TEXT	SEGMENT
_strDestination$ = 8					; size = 4
_wstrSource$ = 12					; size = 4
_cchDestChar$ = 16					; size = 4
?DXUtil_ConvertWideStringToAnsi@@YAXPADPB_WH@Z PROC	; DXUtil_ConvertWideStringToAnsi

; 484  : {

	push	ebp
	mov	ebp, esp

; 485  :     if( strDestination==NULL || wstrSource==NULL )

	cmp	DWORD PTR _strDestination$[ebp], 0
	je	SHORT $LN2@DXUtil_Con
	cmp	DWORD PTR _wstrSource$[ebp], 0
	jne	SHORT $LN3@DXUtil_Con
$LN2@DXUtil_Con:

; 486  :         return;

	jmp	SHORT $LN4@DXUtil_Con
$LN3@DXUtil_Con:

; 487  : 
; 488  :     if( cchDestChar == -1 )

	cmp	DWORD PTR _cchDestChar$[ebp], -1
	jne	SHORT $LN1@DXUtil_Con

; 489  :         cchDestChar = wcslen(wstrSource)+1;

	mov	eax, DWORD PTR _wstrSource$[ebp]
	push	eax
	call	_wcslen
	add	esp, 4
	add	eax, 1
	mov	DWORD PTR _cchDestChar$[ebp], eax
$LN1@DXUtil_Con:

; 490  : 
; 491  :     WideCharToMultiByte( CP_ACP, 0, wstrSource, -1, strDestination, 
; 492  :                          cchDestChar-1, NULL, NULL );

	push	0
	push	0
	mov	ecx, DWORD PTR _cchDestChar$[ebp]
	sub	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _strDestination$[ebp]
	push	edx
	push	-1
	mov	eax, DWORD PTR _wstrSource$[ebp]
	push	eax
	push	0
	push	0
	call	DWORD PTR __imp__WideCharToMultiByte@32

; 493  : 
; 494  :     strDestination[cchDestChar-1] = 0;

	mov	ecx, DWORD PTR _strDestination$[ebp]
	add	ecx, DWORD PTR _cchDestChar$[ebp]
	mov	BYTE PTR [ecx-1], 0
$LN4@DXUtil_Con:

; 495  : }

	pop	ebp
	ret	0
?DXUtil_ConvertWideStringToAnsi@@YAXPADPB_WH@Z ENDP	; DXUtil_ConvertWideStringToAnsi
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\voicecomunication\dxutil.cpp
_TEXT	SEGMENT
_wstrDestination$ = 8					; size = 4
_strSource$ = 12					; size = 4
_cchDestChar$ = 16					; size = 4
?DXUtil_ConvertAnsiStringToWide@@YAXPA_WPBDH@Z PROC	; DXUtil_ConvertAnsiStringToWide

; 460  : {

	push	ebp
	mov	ebp, esp

; 461  :     if( wstrDestination==NULL || strSource==NULL )

	cmp	DWORD PTR _wstrDestination$[ebp], 0
	je	SHORT $LN2@DXUtil_Con
	cmp	DWORD PTR _strSource$[ebp], 0
	jne	SHORT $LN3@DXUtil_Con
$LN2@DXUtil_Con:

; 462  :         return;

	jmp	SHORT $LN4@DXUtil_Con
$LN3@DXUtil_Con:

; 463  : 
; 464  :     if( cchDestChar == -1 )

	cmp	DWORD PTR _cchDestChar$[ebp], -1
	jne	SHORT $LN1@DXUtil_Con

; 465  :         cchDestChar = strlen(strSource)+1;

	mov	eax, DWORD PTR _strSource$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 1
	mov	DWORD PTR _cchDestChar$[ebp], eax
$LN1@DXUtil_Con:

; 466  : 
; 467  :     MultiByteToWideChar( CP_ACP, 0, strSource, -1, 
; 468  :                          wstrDestination, cchDestChar-1 );

	mov	ecx, DWORD PTR _cchDestChar$[ebp]
	sub	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _wstrDestination$[ebp]
	push	edx
	push	-1
	mov	eax, DWORD PTR _strSource$[ebp]
	push	eax
	push	0
	push	0
	call	DWORD PTR __imp__MultiByteToWideChar@24

; 469  : 
; 470  :     wstrDestination[cchDestChar-1] = 0;

	xor	ecx, ecx
	mov	edx, DWORD PTR _cchDestChar$[ebp]
	mov	eax, DWORD PTR _wstrDestination$[ebp]
	mov	WORD PTR [eax+edx*2-2], cx
$LN4@DXUtil_Con:

; 471  : }

	pop	ebp
	ret	0
?DXUtil_ConvertAnsiStringToWide@@YAXPA_WPBDH@Z ENDP	; DXUtil_ConvertAnsiStringToWide
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\voicecomunication\dxutil.cpp
_TEXT	SEGMENT
tv281 = -204						; size = 8
tv207 = -196						; size = 8
_fElapsedTime$1 = -188					; size = 8
tv188 = -180						; size = 8
_fTime$2 = -172						; size = 8
tv202 = -164						; size = 8
tv262 = -156						; size = 8
tv183 = -148						; size = 8
tv259 = -140						; size = 8
tv205 = -132						; size = 8
tv257 = -124						; size = 8
_fElapsedTime$3 = -116					; size = 8
tv254 = -108						; size = 8
tv180 = -100						; size = 8
_fAppTime$4 = -92					; size = 8
tv210 = -84						; size = 8
tv185 = -76						; size = 8
tv199 = -68						; size = 8
tv177 = -60						; size = 8
_qwTicksPerSec$5 = -52					; size = 8
tv299 = -44						; size = 4
tv278 = -40						; size = 4
tv192 = -36						; size = 4
tv264 = -32						; size = 4
tv212 = -28						; size = 4
tv283 = -24						; size = 4
tv272 = -20						; size = 4
_fTime$6 = -16						; size = 8
_qwTime$7 = -8						; size = 8
_command$ = 8						; size = 4
?DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z PROC		; DXUtil_Timer

; 278  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH

; 279  :     static BOOL     m_bTimerInitialized = FALSE;
; 280  :     static BOOL     m_bUsingQPF         = FALSE;
; 281  :     static BOOL     m_bTimerStopped     = TRUE;
; 282  :     static LONGLONG m_llQPFTicksPerSec  = 0;
; 283  : 
; 284  :     // Initialize the timer
; 285  :     if( FALSE == m_bTimerInitialized )

	cmp	DWORD PTR ?m_bTimerInitialized@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4HA, 0
	jne	SHORT $LN23@DXUtil_Tim

; 286  :     {
; 287  :         m_bTimerInitialized = TRUE;

	mov	DWORD PTR ?m_bTimerInitialized@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4HA, 1

; 288  : 
; 289  :         // Use QueryPerformanceFrequency() to get frequency of timer.  If QPF is
; 290  :         // not supported, we will timeGetTime() which returns milliseconds.
; 291  :         LARGE_INTEGER qwTicksPerSec;
; 292  :         m_bUsingQPF = QueryPerformanceFrequency( &qwTicksPerSec );

	lea	eax, DWORD PTR _qwTicksPerSec$5[ebp]
	push	eax
	call	DWORD PTR __imp__QueryPerformanceFrequency@4
	mov	DWORD PTR ?m_bUsingQPF@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4HA, eax

; 293  :         if( m_bUsingQPF )

	cmp	DWORD PTR ?m_bUsingQPF@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4HA, 0
	je	SHORT $LN23@DXUtil_Tim

; 294  :             m_llQPFTicksPerSec = qwTicksPerSec.QuadPart;

	mov	ecx, DWORD PTR _qwTicksPerSec$5[ebp]
	mov	DWORD PTR ?m_llQPFTicksPerSec@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA, ecx
	mov	edx, DWORD PTR _qwTicksPerSec$5[ebp+4]
	mov	DWORD PTR ?m_llQPFTicksPerSec@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA+4, edx
$LN23@DXUtil_Tim:

; 295  :     }
; 296  : 
; 297  :     if( m_bUsingQPF )

	cmp	DWORD PTR ?m_bUsingQPF@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4HA, 0
	je	$LN22@DXUtil_Tim

; 298  :     {
; 299  :         static LONGLONG m_llStopTime        = 0;
; 300  :         static LONGLONG m_llLastElapsedTime = 0;
; 301  :         static LONGLONG m_llBaseTime        = 0;
; 302  :         double fTime;
; 303  :         double fElapsedTime;
; 304  :         LARGE_INTEGER qwTime;
; 305  :         
; 306  :         // Get either the current time or the stop time, depending
; 307  :         // on whether we're stopped and what command was sent
; 308  :         if( m_llStopTime != 0 && command != TIMER_START && command != TIMER_GETABSOLUTETIME)

	mov	eax, DWORD PTR ?m_llStopTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA
	or	eax, DWORD PTR ?m_llStopTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA+4
	je	SHORT $LN21@DXUtil_Tim
	cmp	DWORD PTR _command$[ebp], 1
	je	SHORT $LN21@DXUtil_Tim
	cmp	DWORD PTR _command$[ebp], 4
	je	SHORT $LN21@DXUtil_Tim

; 309  :             qwTime.QuadPart = m_llStopTime;

	mov	ecx, DWORD PTR ?m_llStopTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA
	mov	DWORD PTR _qwTime$7[ebp], ecx
	mov	edx, DWORD PTR ?m_llStopTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA+4
	mov	DWORD PTR _qwTime$7[ebp+4], edx

; 310  :         else

	jmp	SHORT $LN20@DXUtil_Tim
$LN21@DXUtil_Tim:

; 311  :             QueryPerformanceCounter( &qwTime );

	lea	eax, DWORD PTR _qwTime$7[ebp]
	push	eax
	call	DWORD PTR __imp__QueryPerformanceCounter@4
$LN20@DXUtil_Tim:

; 312  : 
; 313  :         // Return the elapsed time
; 314  :         if( command == TIMER_GETELAPSEDTIME )

	cmp	DWORD PTR _command$[ebp], 6
	jne	SHORT $LN19@DXUtil_Tim

; 315  :         {
; 316  :             fElapsedTime = (double) ( qwTime.QuadPart - m_llLastElapsedTime ) / (double) m_llQPFTicksPerSec;

	mov	ecx, DWORD PTR _qwTime$7[ebp]
	sub	ecx, DWORD PTR ?m_llLastElapsedTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA
	mov	edx, DWORD PTR _qwTime$7[ebp+4]
	sbb	edx, DWORD PTR ?m_llLastElapsedTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA+4
	mov	DWORD PTR tv177[ebp], ecx
	mov	DWORD PTR tv177[ebp+4], edx
	fild	QWORD PTR tv177[ebp]
	fstp	QWORD PTR tv180[ebp]
	fld	QWORD PTR tv180[ebp]
	fstp	QWORD PTR tv183[ebp]
	movsd	xmm0, QWORD PTR tv183[ebp]
	fild	QWORD PTR ?m_llQPFTicksPerSec@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA
	fstp	QWORD PTR tv185[ebp]
	fld	QWORD PTR tv185[ebp]
	fstp	QWORD PTR tv188[ebp]
	divsd	xmm0, QWORD PTR tv188[ebp]
	movsd	QWORD PTR _fElapsedTime$3[ebp], xmm0

; 317  :             m_llLastElapsedTime = qwTime.QuadPart;

	mov	eax, DWORD PTR _qwTime$7[ebp]
	mov	DWORD PTR ?m_llLastElapsedTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA, eax
	mov	ecx, DWORD PTR _qwTime$7[ebp+4]
	mov	DWORD PTR ?m_llLastElapsedTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA+4, ecx

; 318  :             return (FLOAT) fElapsedTime;

	fld	QWORD PTR _fElapsedTime$3[ebp]
	fstp	DWORD PTR tv192[ebp]
	fld	DWORD PTR tv192[ebp]
	jmp	$LN11@DXUtil_Tim
$LN19@DXUtil_Tim:

; 319  :         }
; 320  :     
; 321  :         // Return the current time
; 322  :         if( command == TIMER_GETAPPTIME )

	cmp	DWORD PTR _command$[ebp], 5
	jne	SHORT $LN18@DXUtil_Tim

; 323  :         {
; 324  :             double fAppTime = (double) ( qwTime.QuadPart - m_llBaseTime ) / (double) m_llQPFTicksPerSec;

	mov	edx, DWORD PTR _qwTime$7[ebp]
	sub	edx, DWORD PTR ?m_llBaseTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA
	mov	eax, DWORD PTR _qwTime$7[ebp+4]
	sbb	eax, DWORD PTR ?m_llBaseTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA+4
	mov	DWORD PTR tv199[ebp], edx
	mov	DWORD PTR tv199[ebp+4], eax
	fild	QWORD PTR tv199[ebp]
	fstp	QWORD PTR tv202[ebp]
	fld	QWORD PTR tv202[ebp]
	fstp	QWORD PTR tv205[ebp]
	movsd	xmm0, QWORD PTR tv205[ebp]
	fild	QWORD PTR ?m_llQPFTicksPerSec@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA
	fstp	QWORD PTR tv207[ebp]
	fld	QWORD PTR tv207[ebp]
	fstp	QWORD PTR tv210[ebp]
	divsd	xmm0, QWORD PTR tv210[ebp]
	movsd	QWORD PTR _fAppTime$4[ebp], xmm0

; 325  :             return (FLOAT) fAppTime;

	fld	QWORD PTR _fAppTime$4[ebp]
	fstp	DWORD PTR tv212[ebp]
	fld	DWORD PTR tv212[ebp]
	jmp	$LN11@DXUtil_Tim
$LN18@DXUtil_Tim:

; 326  :         }
; 327  :     
; 328  :         // Reset the timer
; 329  :         if( command == TIMER_RESET )

	cmp	DWORD PTR _command$[ebp], 0
	jne	SHORT $LN17@DXUtil_Tim

; 330  :         {
; 331  :             m_llBaseTime        = qwTime.QuadPart;

	mov	ecx, DWORD PTR _qwTime$7[ebp]
	mov	DWORD PTR ?m_llBaseTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA, ecx
	mov	edx, DWORD PTR _qwTime$7[ebp+4]
	mov	DWORD PTR ?m_llBaseTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA+4, edx

; 332  :             m_llLastElapsedTime = qwTime.QuadPart;

	mov	eax, DWORD PTR _qwTime$7[ebp]
	mov	DWORD PTR ?m_llLastElapsedTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA, eax
	mov	ecx, DWORD PTR _qwTime$7[ebp+4]
	mov	DWORD PTR ?m_llLastElapsedTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA+4, ecx

; 333  :             m_llStopTime        = 0;

	xorpd	xmm0, xmm0
	movlpd	QWORD PTR ?m_llStopTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA, xmm0

; 334  :             m_bTimerStopped     = FALSE;

	mov	DWORD PTR ?m_bTimerStopped@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4HA, 0

; 335  :             return 0.0f;

	fldz
	jmp	$LN11@DXUtil_Tim
$LN17@DXUtil_Tim:

; 336  :         }
; 337  :     
; 338  :         // Start the timer
; 339  :         if( command == TIMER_START )

	cmp	DWORD PTR _command$[ebp], 1
	jne	SHORT $LN16@DXUtil_Tim

; 340  :         {
; 341  :             if( m_bTimerStopped )

	cmp	DWORD PTR ?m_bTimerStopped@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4HA, 0
	je	SHORT $LN15@DXUtil_Tim

; 342  :                 m_llBaseTime += qwTime.QuadPart - m_llStopTime;

	mov	edx, DWORD PTR _qwTime$7[ebp]
	sub	edx, DWORD PTR ?m_llStopTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA
	mov	eax, DWORD PTR _qwTime$7[ebp+4]
	sbb	eax, DWORD PTR ?m_llStopTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA+4
	add	edx, DWORD PTR ?m_llBaseTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA
	adc	eax, DWORD PTR ?m_llBaseTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA+4
	mov	DWORD PTR ?m_llBaseTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA, edx
	mov	DWORD PTR ?m_llBaseTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA+4, eax
$LN15@DXUtil_Tim:

; 343  :             m_llStopTime = 0;

	xorpd	xmm0, xmm0
	movlpd	QWORD PTR ?m_llStopTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA, xmm0

; 344  :             m_llLastElapsedTime = qwTime.QuadPart;

	mov	ecx, DWORD PTR _qwTime$7[ebp]
	mov	DWORD PTR ?m_llLastElapsedTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA, ecx
	mov	edx, DWORD PTR _qwTime$7[ebp+4]
	mov	DWORD PTR ?m_llLastElapsedTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA+4, edx

; 345  :             m_bTimerStopped = FALSE;

	mov	DWORD PTR ?m_bTimerStopped@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4HA, 0

; 346  :             return 0.0f;

	fldz
	jmp	$LN11@DXUtil_Tim
$LN16@DXUtil_Tim:

; 347  :         }
; 348  :     
; 349  :         // Stop the timer
; 350  :         if( command == TIMER_STOP )

	cmp	DWORD PTR _command$[ebp], 2
	jne	SHORT $LN14@DXUtil_Tim

; 351  :         {
; 352  :             m_llStopTime = qwTime.QuadPart;

	mov	eax, DWORD PTR _qwTime$7[ebp]
	mov	DWORD PTR ?m_llStopTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA, eax
	mov	ecx, DWORD PTR _qwTime$7[ebp+4]
	mov	DWORD PTR ?m_llStopTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA+4, ecx

; 353  :             m_llLastElapsedTime = qwTime.QuadPart;

	mov	edx, DWORD PTR _qwTime$7[ebp]
	mov	DWORD PTR ?m_llLastElapsedTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA, edx
	mov	eax, DWORD PTR _qwTime$7[ebp+4]
	mov	DWORD PTR ?m_llLastElapsedTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA+4, eax

; 354  :             m_bTimerStopped = TRUE;

	mov	DWORD PTR ?m_bTimerStopped@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4HA, 1

; 355  :             return 0.0f;

	fldz
	jmp	$LN11@DXUtil_Tim
$LN14@DXUtil_Tim:

; 356  :         }
; 357  :     
; 358  :         // Advance the timer by 1/10th second
; 359  :         if( command == TIMER_ADVANCE )

	cmp	DWORD PTR _command$[ebp], 3
	jne	SHORT $LN13@DXUtil_Tim

; 360  :         {
; 361  :             m_llStopTime += m_llQPFTicksPerSec/10;

	push	0
	push	10					; 0000000aH
	mov	ecx, DWORD PTR ?m_llQPFTicksPerSec@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA+4
	push	ecx
	mov	edx, DWORD PTR ?m_llQPFTicksPerSec@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA
	push	edx
	call	__alldiv
	add	eax, DWORD PTR ?m_llStopTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA
	adc	edx, DWORD PTR ?m_llStopTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA+4
	mov	DWORD PTR ?m_llStopTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA, eax
	mov	DWORD PTR ?m_llStopTime@?9??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA+4, edx

; 362  :             return 0.0f;

	fldz
	jmp	$LN11@DXUtil_Tim
$LN13@DXUtil_Tim:

; 363  :         }
; 364  : 
; 365  :         if( command == TIMER_GETABSOLUTETIME )

	cmp	DWORD PTR _command$[ebp], 4
	jne	SHORT $LN12@DXUtil_Tim

; 366  :         {
; 367  :             fTime = qwTime.QuadPart / (double) m_llQPFTicksPerSec;

	fild	QWORD PTR _qwTime$7[ebp]
	fstp	QWORD PTR tv254[ebp]
	fld	QWORD PTR tv254[ebp]
	fstp	QWORD PTR tv257[ebp]
	movsd	xmm0, QWORD PTR tv257[ebp]
	fild	QWORD PTR ?m_llQPFTicksPerSec@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4_JA
	fstp	QWORD PTR tv259[ebp]
	fld	QWORD PTR tv259[ebp]
	fstp	QWORD PTR tv262[ebp]
	divsd	xmm0, QWORD PTR tv262[ebp]
	movsd	QWORD PTR _fTime$2[ebp], xmm0

; 368  :             return (FLOAT) fTime;

	fld	QWORD PTR _fTime$2[ebp]
	fstp	DWORD PTR tv264[ebp]
	fld	DWORD PTR tv264[ebp]
	jmp	$LN11@DXUtil_Tim
$LN12@DXUtil_Tim:

; 369  :         }
; 370  : 
; 371  :         return -1.0f; // Invalid command specified

	fld	DWORD PTR __real@bf800000
	jmp	$LN11@DXUtil_Tim

; 372  :     }
; 373  :     else

	jmp	$LN11@DXUtil_Tim
$LN22@DXUtil_Tim:

; 374  :     {
; 375  :         // Get the time using timeGetTime()
; 376  :         static double m_fLastElapsedTime  = 0.0;
; 377  :         static double m_fBaseTime         = 0.0;
; 378  :         static double m_fStopTime         = 0.0;
; 379  :         double fTime;
; 380  :         double fElapsedTime;
; 381  :         
; 382  :         // Get either the current time or the stop time, depending
; 383  :         // on whether we're stopped and what command was sent
; 384  :         if( m_fStopTime != 0.0 && command != TIMER_START && command != TIMER_GETABSOLUTETIME)

	movsd	xmm0, QWORD PTR ?m_fStopTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN10@DXUtil_Tim
	cmp	DWORD PTR _command$[ebp], 1
	je	SHORT $LN10@DXUtil_Tim
	cmp	DWORD PTR _command$[ebp], 4
	je	SHORT $LN10@DXUtil_Tim

; 385  :             fTime = m_fStopTime;

	movsd	xmm0, QWORD PTR ?m_fStopTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA
	movsd	QWORD PTR _fTime$6[ebp], xmm0

; 386  :         else

	jmp	SHORT $LN9@DXUtil_Tim
$LN10@DXUtil_Tim:

; 387  :             fTime = timeGetTime() * 0.001;

	call	DWORD PTR __imp__timeGetTime@0
	mov	DWORD PTR tv272[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv272[ebp]
	mov	eax, DWORD PTR tv272[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	mulsd	xmm0, QWORD PTR __real@3f50624dd2f1a9fc
	movsd	QWORD PTR _fTime$6[ebp], xmm0
$LN9@DXUtil_Tim:

; 388  :     
; 389  :         // Return the elapsed time
; 390  :         if( command == TIMER_GETELAPSEDTIME )

	cmp	DWORD PTR _command$[ebp], 6
	jne	SHORT $LN8@DXUtil_Tim

; 391  :         {   
; 392  :             fElapsedTime = (double) (fTime - m_fLastElapsedTime);

	movsd	xmm0, QWORD PTR _fTime$6[ebp]
	subsd	xmm0, QWORD PTR ?m_fLastElapsedTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA
	movsd	QWORD PTR _fElapsedTime$1[ebp], xmm0

; 393  :             m_fLastElapsedTime = fTime;

	movsd	xmm0, QWORD PTR _fTime$6[ebp]
	movsd	QWORD PTR ?m_fLastElapsedTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA, xmm0

; 394  :             return (FLOAT) fElapsedTime;

	fld	QWORD PTR _fElapsedTime$1[ebp]
	fstp	DWORD PTR tv278[ebp]
	fld	DWORD PTR tv278[ebp]
	jmp	$LN11@DXUtil_Tim
$LN8@DXUtil_Tim:

; 395  :         }
; 396  :     
; 397  :         // Return the current time
; 398  :         if( command == TIMER_GETAPPTIME )

	cmp	DWORD PTR _command$[ebp], 5
	jne	SHORT $LN7@DXUtil_Tim

; 399  :         {
; 400  :             return (FLOAT) (fTime - m_fBaseTime);

	movsd	xmm0, QWORD PTR _fTime$6[ebp]
	subsd	xmm0, QWORD PTR ?m_fBaseTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA
	movsd	QWORD PTR tv281[ebp], xmm0
	fld	QWORD PTR tv281[ebp]
	fstp	DWORD PTR tv283[ebp]
	fld	DWORD PTR tv283[ebp]
	jmp	$LN11@DXUtil_Tim
$LN7@DXUtil_Tim:

; 401  :         }
; 402  :     
; 403  :         // Reset the timer
; 404  :         if( command == TIMER_RESET )

	cmp	DWORD PTR _command$[ebp], 0
	jne	SHORT $LN6@DXUtil_Tim

; 405  :         {
; 406  :             m_fBaseTime         = fTime;

	movsd	xmm0, QWORD PTR _fTime$6[ebp]
	movsd	QWORD PTR ?m_fBaseTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA, xmm0

; 407  :             m_fLastElapsedTime  = fTime;

	movsd	xmm0, QWORD PTR _fTime$6[ebp]
	movsd	QWORD PTR ?m_fLastElapsedTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA, xmm0

; 408  :             m_fStopTime         = 0;

	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR ?m_fStopTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA, xmm0

; 409  :             m_bTimerStopped     = FALSE;

	mov	DWORD PTR ?m_bTimerStopped@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4HA, 0

; 410  :             return 0.0f;

	fldz
	jmp	$LN11@DXUtil_Tim
$LN6@DXUtil_Tim:

; 411  :         }
; 412  :     
; 413  :         // Start the timer
; 414  :         if( command == TIMER_START )

	cmp	DWORD PTR _command$[ebp], 1
	jne	SHORT $LN5@DXUtil_Tim

; 415  :         {
; 416  :             if( m_bTimerStopped )

	cmp	DWORD PTR ?m_bTimerStopped@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4HA, 0
	je	SHORT $LN4@DXUtil_Tim

; 417  :                 m_fBaseTime += fTime - m_fStopTime;

	movsd	xmm0, QWORD PTR _fTime$6[ebp]
	subsd	xmm0, QWORD PTR ?m_fStopTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA
	addsd	xmm0, QWORD PTR ?m_fBaseTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA
	movsd	QWORD PTR ?m_fBaseTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA, xmm0
$LN4@DXUtil_Tim:

; 418  :             m_fStopTime = 0.0f;

	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR ?m_fStopTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA, xmm0

; 419  :             m_fLastElapsedTime  = fTime;

	movsd	xmm0, QWORD PTR _fTime$6[ebp]
	movsd	QWORD PTR ?m_fLastElapsedTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA, xmm0

; 420  :             m_bTimerStopped = FALSE;

	mov	DWORD PTR ?m_bTimerStopped@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4HA, 0

; 421  :             return 0.0f;

	fldz
	jmp	SHORT $LN11@DXUtil_Tim
$LN5@DXUtil_Tim:

; 422  :         }
; 423  :     
; 424  :         // Stop the timer
; 425  :         if( command == TIMER_STOP )

	cmp	DWORD PTR _command$[ebp], 2
	jne	SHORT $LN3@DXUtil_Tim

; 426  :         {
; 427  :             m_fStopTime = fTime;

	movsd	xmm0, QWORD PTR _fTime$6[ebp]
	movsd	QWORD PTR ?m_fStopTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA, xmm0

; 428  :             m_fLastElapsedTime  = fTime;

	movsd	xmm0, QWORD PTR _fTime$6[ebp]
	movsd	QWORD PTR ?m_fLastElapsedTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA, xmm0

; 429  :             m_bTimerStopped = TRUE;

	mov	DWORD PTR ?m_bTimerStopped@?1??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4HA, 1

; 430  :             return 0.0f;

	fldz
	jmp	SHORT $LN11@DXUtil_Tim
$LN3@DXUtil_Tim:

; 431  :         }
; 432  :     
; 433  :         // Advance the timer by 1/10th second
; 434  :         if( command == TIMER_ADVANCE )

	cmp	DWORD PTR _command$[ebp], 3
	jne	SHORT $LN2@DXUtil_Tim

; 435  :         {
; 436  :             m_fStopTime += 0.1f;

	movsd	xmm0, QWORD PTR ?m_fStopTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA
	addsd	xmm0, QWORD PTR __real@3fb99999a0000000
	movsd	QWORD PTR ?m_fStopTime@?CG@??DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z@4NA, xmm0

; 437  :             return 0.0f;

	fldz
	jmp	SHORT $LN11@DXUtil_Tim
$LN2@DXUtil_Tim:

; 438  :         }
; 439  : 
; 440  :         if( command == TIMER_GETABSOLUTETIME )

	cmp	DWORD PTR _command$[ebp], 4
	jne	SHORT $LN1@DXUtil_Tim

; 441  :         {
; 442  :             return (FLOAT) fTime;

	fld	QWORD PTR _fTime$6[ebp]
	fstp	DWORD PTR tv299[ebp]
	fld	DWORD PTR tv299[ebp]
	jmp	SHORT $LN11@DXUtil_Tim
$LN1@DXUtil_Tim:

; 443  :         }
; 444  : 
; 445  :         return -1.0f; // Invalid command specified

	fld	DWORD PTR __real@bf800000
$LN11@DXUtil_Tim:

; 446  :     }
; 447  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?DXUtil_Timer@@YGMW4TIMER_COMMAND@@@Z ENDP		; DXUtil_Timer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\voicecomunication\dxutil.cpp
_TEXT	SEGMENT
_dwType$ = -8						; size = 4
_dwLength$ = -4						; size = 4
_hKey$ = 8						; size = 4
_strRegName$ = 12					; size = 4
_pbValue$ = 16						; size = 4
_bDefault$ = 20						; size = 4
?DXUtil_ReadBoolRegKey@@YAJPAUHKEY__@@PADPAHH@Z PROC	; DXUtil_ReadBoolRegKey

; 195  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 196  :     DWORD dwType;
; 197  :     DWORD dwLength = sizeof(BOOL);

	mov	DWORD PTR _dwLength$[ebp], 4

; 198  : 
; 199  :     if( ERROR_SUCCESS != RegQueryValueEx( hKey, strRegName, 0, &dwType, 
; 200  :                                           (BYTE*)pbValue, &dwLength ) )

	lea	eax, DWORD PTR _dwLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pbValue$[ebp]
	push	ecx
	lea	edx, DWORD PTR _dwType$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _strRegName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hKey$[ebp]
	push	ecx
	call	DWORD PTR __imp__RegQueryValueExA@24
	test	eax, eax
	je	SHORT $LN1@DXUtil_Rea

; 201  :     {
; 202  :         *pbValue = bDefault;

	mov	edx, DWORD PTR _pbValue$[ebp]
	mov	eax, DWORD PTR _bDefault$[ebp]
	mov	DWORD PTR [edx], eax
$LN1@DXUtil_Rea:

; 203  :     }
; 204  : 
; 205  :     return S_OK;

	xor	eax, eax

; 206  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DXUtil_ReadBoolRegKey@@YAJPAUHKEY__@@PADPAHH@Z ENDP	; DXUtil_ReadBoolRegKey
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\voicecomunication\dxutil.cpp
_TEXT	SEGMENT
_dwType$ = -8						; size = 4
_dwLength$ = -4						; size = 4
_hKey$ = 8						; size = 4
_strRegName$ = 12					; size = 4
_pGuidValue$ = 16					; size = 4
_guidDefault$ = 20					; size = 4
?DXUtil_ReadGuidRegKey@@YAJPAUHKEY__@@PADPAU_GUID@@AAU2@@Z PROC ; DXUtil_ReadGuidRegKey

; 233  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 234  :     DWORD dwType;
; 235  :     DWORD dwLength = sizeof(GUID);

	mov	DWORD PTR _dwLength$[ebp], 16		; 00000010H

; 236  : 
; 237  :     if( ERROR_SUCCESS != RegQueryValueEx( hKey, strRegName, 0, &dwType, 
; 238  :                                           (LPBYTE) pGuidValue, &dwLength ) )

	lea	eax, DWORD PTR _dwLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pGuidValue$[ebp]
	push	ecx
	lea	edx, DWORD PTR _dwType$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _strRegName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hKey$[ebp]
	push	ecx
	call	DWORD PTR __imp__RegQueryValueExA@24
	test	eax, eax
	je	SHORT $LN1@DXUtil_Rea

; 239  :     {
; 240  :         *pGuidValue = guidDefault;

	mov	edx, DWORD PTR _guidDefault$[ebp]
	mov	eax, DWORD PTR _pGuidValue$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
$LN1@DXUtil_Rea:

; 241  :     }
; 242  : 
; 243  :     return S_OK;

	xor	eax, eax

; 244  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DXUtil_ReadGuidRegKey@@YAJPAUHKEY__@@PADPAU_GUID@@AAU2@@Z ENDP ; DXUtil_ReadGuidRegKey
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\voicecomunication\dxutil.cpp
_TEXT	SEGMENT
_dwType$ = -8						; size = 4
_dwLength$ = -4						; size = 4
_hKey$ = 8						; size = 4
_strRegName$ = 12					; size = 4
_pdwValue$ = 16						; size = 4
_dwDefault$ = 20					; size = 4
?DXUtil_ReadIntRegKey@@YAJPAUHKEY__@@PADPAKK@Z PROC	; DXUtil_ReadIntRegKey

; 157  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 158  :     DWORD dwType;
; 159  :     DWORD dwLength = sizeof(DWORD);

	mov	DWORD PTR _dwLength$[ebp], 4

; 160  : 
; 161  :     if( ERROR_SUCCESS != RegQueryValueEx( hKey, strRegName, 0, &dwType, 
; 162  :                                           (BYTE*)pdwValue, &dwLength ) )

	lea	eax, DWORD PTR _dwLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pdwValue$[ebp]
	push	ecx
	lea	edx, DWORD PTR _dwType$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _strRegName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hKey$[ebp]
	push	ecx
	call	DWORD PTR __imp__RegQueryValueExA@24
	test	eax, eax
	je	SHORT $LN1@DXUtil_Rea

; 163  :     {
; 164  :         *pdwValue = dwDefault;

	mov	edx, DWORD PTR _pdwValue$[ebp]
	mov	eax, DWORD PTR _dwDefault$[ebp]
	mov	DWORD PTR [edx], eax
$LN1@DXUtil_Rea:

; 165  :     }
; 166  : 
; 167  :     return S_OK;

	xor	eax, eax

; 168  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DXUtil_ReadIntRegKey@@YAJPAUHKEY__@@PADPAKK@Z ENDP	; DXUtil_ReadIntRegKey
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\voicecomunication\dxutil.cpp
_TEXT	SEGMENT
_dwType$ = -4						; size = 4
_hKey$ = 8						; size = 4
_strRegName$ = 12					; size = 4
_strValue$ = 16						; size = 4
_dwLength$ = 20						; size = 4
_strDefault$ = 24					; size = 4
?DXUtil_ReadStringRegKey@@YAJPAUHKEY__@@PAD1K1@Z PROC	; DXUtil_ReadStringRegKey

; 118  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 119  :     DWORD dwType;
; 120  : 
; 121  :     if( ERROR_SUCCESS != RegQueryValueEx( hKey, strRegName, 0, &dwType, 
; 122  :                                           (BYTE*)strValue, &dwLength ) )

	lea	eax, DWORD PTR _dwLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _strValue$[ebp]
	push	ecx
	lea	edx, DWORD PTR _dwType$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _strRegName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hKey$[ebp]
	push	ecx
	call	DWORD PTR __imp__RegQueryValueExA@24
	test	eax, eax
	je	SHORT $LN1@DXUtil_Rea

; 123  :     {
; 124  :         _tcscpy( strValue, strDefault );

	mov	edx, DWORD PTR _strDefault$[ebp]
	push	edx
	mov	eax, DWORD PTR _strValue$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8
$LN1@DXUtil_Rea:

; 125  :     }
; 126  : 
; 127  :     return S_OK;

	xor	eax, eax

; 128  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DXUtil_ReadStringRegKey@@YAJPAUHKEY__@@PAD1K1@Z ENDP	; DXUtil_ReadStringRegKey
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\voicecomunication\dxutil.cpp
_TEXT	SEGMENT
_hKey$ = 8						; size = 4
_strRegName$ = 12					; size = 4
_bValue$ = 16						; size = 4
?DXUtil_WriteBoolRegKey@@YAJPAUHKEY__@@PADH@Z PROC	; DXUtil_WriteBoolRegKey

; 216  : {

	push	ebp
	mov	ebp, esp

; 217  :     if( ERROR_SUCCESS != RegSetValueEx( hKey, strRegName, 0, REG_DWORD, 
; 218  :                                         (BYTE*)&bValue, sizeof(BOOL) ) )

	push	4
	lea	eax, DWORD PTR _bValue$[ebp]
	push	eax
	push	4
	push	0
	mov	ecx, DWORD PTR _strRegName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hKey$[ebp]
	push	edx
	call	DWORD PTR __imp__RegSetValueExA@24
	test	eax, eax
	je	SHORT $LN1@DXUtil_Wri

; 219  :         return E_FAIL;

	mov	eax, -2147467259			; 80004005H
	jmp	SHORT $LN2@DXUtil_Wri
$LN1@DXUtil_Wri:

; 220  : 
; 221  :     return S_OK;

	xor	eax, eax
$LN2@DXUtil_Wri:

; 222  : }

	pop	ebp
	ret	0
?DXUtil_WriteBoolRegKey@@YAJPAUHKEY__@@PADH@Z ENDP	; DXUtil_WriteBoolRegKey
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\voicecomunication\dxutil.cpp
_TEXT	SEGMENT
_hKey$ = 8						; size = 4
_strRegName$ = 12					; size = 4
_guidValue$ = 16					; size = 16
?DXUtil_WriteGuidRegKey@@YAJPAUHKEY__@@PADU_GUID@@@Z PROC ; DXUtil_WriteGuidRegKey

; 254  : {

	push	ebp
	mov	ebp, esp

; 255  :     if( ERROR_SUCCESS != RegSetValueEx( hKey, strRegName, 0, REG_BINARY, 
; 256  :                                         (BYTE*)&guidValue, sizeof(GUID) ) )

	push	16					; 00000010H
	lea	eax, DWORD PTR _guidValue$[ebp]
	push	eax
	push	3
	push	0
	mov	ecx, DWORD PTR _strRegName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hKey$[ebp]
	push	edx
	call	DWORD PTR __imp__RegSetValueExA@24
	test	eax, eax
	je	SHORT $LN1@DXUtil_Wri

; 257  :         return E_FAIL;

	mov	eax, -2147467259			; 80004005H
	jmp	SHORT $LN2@DXUtil_Wri
$LN1@DXUtil_Wri:

; 258  : 
; 259  :     return S_OK;

	xor	eax, eax
$LN2@DXUtil_Wri:

; 260  : }

	pop	ebp
	ret	0
?DXUtil_WriteGuidRegKey@@YAJPAUHKEY__@@PADU_GUID@@@Z ENDP ; DXUtil_WriteGuidRegKey
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\voicecomunication\dxutil.cpp
_TEXT	SEGMENT
_hKey$ = 8						; size = 4
_strRegName$ = 12					; size = 4
_dwValue$ = 16						; size = 4
?DXUtil_WriteIntRegKey@@YAJPAUHKEY__@@PADK@Z PROC	; DXUtil_WriteIntRegKey

; 178  : {

	push	ebp
	mov	ebp, esp

; 179  :     if( ERROR_SUCCESS != RegSetValueEx( hKey, strRegName, 0, REG_DWORD, 
; 180  :                                         (BYTE*)&dwValue, sizeof(DWORD) ) )

	push	4
	lea	eax, DWORD PTR _dwValue$[ebp]
	push	eax
	push	4
	push	0
	mov	ecx, DWORD PTR _strRegName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hKey$[ebp]
	push	edx
	call	DWORD PTR __imp__RegSetValueExA@24
	test	eax, eax
	je	SHORT $LN1@DXUtil_Wri

; 181  :         return E_FAIL;

	mov	eax, -2147467259			; 80004005H
	jmp	SHORT $LN2@DXUtil_Wri
$LN1@DXUtil_Wri:

; 182  : 
; 183  :     return S_OK;

	xor	eax, eax
$LN2@DXUtil_Wri:

; 184  : }

	pop	ebp
	ret	0
?DXUtil_WriteIntRegKey@@YAJPAUHKEY__@@PADK@Z ENDP	; DXUtil_WriteIntRegKey
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\voicecomunication\dxutil.cpp
_TEXT	SEGMENT
_hKey$ = 8						; size = 4
_strRegName$ = 12					; size = 4
_strValue$ = 16						; size = 4
?DXUtil_WriteStringRegKey@@YAJPAUHKEY__@@PAD1@Z PROC	; DXUtil_WriteStringRegKey

; 139  : {

	push	ebp
	mov	ebp, esp

; 140  :     if( ERROR_SUCCESS != RegSetValueEx( hKey, strRegName, 0, REG_SZ, 
; 141  :                                         (BYTE*)strValue, 
; 142  :                                         (_tcslen(strValue)+1)*sizeof(TCHAR) ) )

	mov	eax, DWORD PTR _strValue$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _strValue$[ebp]
	push	ecx
	push	1
	push	0
	mov	edx, DWORD PTR _strRegName$[ebp]
	push	edx
	mov	eax, DWORD PTR _hKey$[ebp]
	push	eax
	call	DWORD PTR __imp__RegSetValueExA@24
	test	eax, eax
	je	SHORT $LN1@DXUtil_Wri

; 143  :         return E_FAIL;

	mov	eax, -2147467259			; 80004005H
	jmp	SHORT $LN2@DXUtil_Wri
$LN1@DXUtil_Wri:

; 144  : 
; 145  :     return S_OK;

	xor	eax, eax
$LN2@DXUtil_Wri:

; 146  : }

	pop	ebp
	ret	0
?DXUtil_WriteStringRegKey@@YAJPAUHKEY__@@PAD1@Z ENDP	; DXUtil_WriteStringRegKey
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\voicecomunication\dxutil.cpp
_TEXT	SEGMENT
_cchPath$ = -1040					; size = 4
_strShortName$ = -1036					; size = 4
_file$ = -1032						; size = 4
_strFullPath$ = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
_strPath$ = 8						; size = 4
_strFilename$ = 12					; size = 4
?DXUtil_FindMediaFile@@YAJPAD0@Z PROC			; DXUtil_FindMediaFile

; 59   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1040				; 00000410H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 60   :     HANDLE file;
; 61   :     TCHAR strFullPath[1024];
; 62   :     TCHAR *strShortName;
; 63   :     DWORD cchPath;
; 64   : 
; 65   :     if( NULL==strFilename || NULL==strPath )

	cmp	DWORD PTR _strFilename$[ebp], 0
	je	SHORT $LN6@DXUtil_Fin
	cmp	DWORD PTR _strPath$[ebp], 0
	jne	SHORT $LN7@DXUtil_Fin
$LN6@DXUtil_Fin:

; 66   :         return E_INVALIDARG;

	mov	eax, -2147024809			; 80070057H
	jmp	$LN8@DXUtil_Fin
$LN7@DXUtil_Fin:

; 67   : 
; 68   :     // Build full path name from strFileName (strShortName will be just the leaf filename)
; 69   :     cchPath = GetFullPathName(strFilename, sizeof(strFullPath)/sizeof(TCHAR), strFullPath, &strShortName);

	lea	eax, DWORD PTR _strShortName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strFullPath$[ebp]
	push	ecx
	push	1024					; 00000400H
	mov	edx, DWORD PTR _strFilename$[ebp]
	push	edx
	call	DWORD PTR __imp__GetFullPathNameA@16
	mov	DWORD PTR _cchPath$[ebp], eax

; 70   :     if ((cchPath == 0) || (sizeof(strFullPath)/sizeof(TCHAR) <= cchPath))

	cmp	DWORD PTR _cchPath$[ebp], 0
	je	SHORT $LN4@DXUtil_Fin
	cmp	DWORD PTR _cchPath$[ebp], 1024		; 00000400H
	jb	SHORT $LN5@DXUtil_Fin
$LN4@DXUtil_Fin:

; 71   :         return E_FAIL;

	mov	eax, -2147467259			; 80004005H
	jmp	$LN8@DXUtil_Fin
$LN5@DXUtil_Fin:

; 72   : 
; 73   :     // first try to find the filename given a full path
; 74   :     file = CreateFile( strFullPath, GENERIC_READ, FILE_SHARE_READ, NULL, 
; 75   :                        OPEN_EXISTING, 0, NULL );

	push	0
	push	0
	push	3
	push	0
	push	1
	push	-2147483648				; 80000000H
	lea	eax, DWORD PTR _strFullPath$[ebp]
	push	eax
	call	DWORD PTR __imp__CreateFileA@28
	mov	DWORD PTR _file$[ebp], eax

; 76   :     if( INVALID_HANDLE_VALUE != file )

	cmp	DWORD PTR _file$[ebp], -1
	je	SHORT $LN3@DXUtil_Fin

; 77   :     {
; 78   :         _tcscpy( strPath, strFullPath );

	lea	ecx, DWORD PTR _strFullPath$[ebp]
	push	ecx
	mov	edx, DWORD PTR _strPath$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 79   :         CloseHandle( file );

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	DWORD PTR __imp__CloseHandle@4

; 80   :         return S_OK;

	xor	eax, eax
	jmp	$LN8@DXUtil_Fin
$LN3@DXUtil_Fin:

; 81   :     }
; 82   :     
; 83   :     // next try to find the filename in the current working directory (path stripped)
; 84   :     file = CreateFile( strShortName, GENERIC_READ, FILE_SHARE_READ, NULL, 
; 85   :                        OPEN_EXISTING, 0, NULL );

	push	0
	push	0
	push	3
	push	0
	push	1
	push	-2147483648				; 80000000H
	mov	ecx, DWORD PTR _strShortName$[ebp]
	push	ecx
	call	DWORD PTR __imp__CreateFileA@28
	mov	DWORD PTR _file$[ebp], eax

; 86   :     if( INVALID_HANDLE_VALUE != file )

	cmp	DWORD PTR _file$[ebp], -1
	je	SHORT $LN2@DXUtil_Fin

; 87   :     {
; 88   :         _tcscpy( strPath, strShortName );

	mov	edx, DWORD PTR _strShortName$[ebp]
	push	edx
	mov	eax, DWORD PTR _strPath$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 89   :         CloseHandle( file );

	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	DWORD PTR __imp__CloseHandle@4

; 90   :         return S_OK;

	xor	eax, eax
	jmp	SHORT $LN8@DXUtil_Fin
$LN2@DXUtil_Fin:

; 91   :     }
; 92   :     
; 93   :     // last, check if the file exists in the media directory
; 94   :     _stprintf( strPath, _T("%s%s"), DXUtil_GetDXSDKMediaPath(), strShortName );

	mov	edx, DWORD PTR _strShortName$[ebp]
	push	edx
	call	?DXUtil_GetDXSDKMediaPath@@YAPBDXZ	; DXUtil_GetDXSDKMediaPath
	push	eax
	push	OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
	mov	eax, DWORD PTR _strPath$[ebp]
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H

; 95   : 
; 96   :     file = CreateFile( strPath, GENERIC_READ, FILE_SHARE_READ, NULL, 
; 97   :                        OPEN_EXISTING, 0, NULL );

	push	0
	push	0
	push	3
	push	0
	push	1
	push	-2147483648				; 80000000H
	mov	ecx, DWORD PTR _strPath$[ebp]
	push	ecx
	call	DWORD PTR __imp__CreateFileA@28
	mov	DWORD PTR _file$[ebp], eax

; 98   :     if( INVALID_HANDLE_VALUE != file )

	cmp	DWORD PTR _file$[ebp], -1
	je	SHORT $LN1@DXUtil_Fin

; 99   :     {
; 100  :         CloseHandle( file );

	mov	edx, DWORD PTR _file$[ebp]
	push	edx
	call	DWORD PTR __imp__CloseHandle@4

; 101  :         return S_OK;

	xor	eax, eax
	jmp	SHORT $LN8@DXUtil_Fin
$LN1@DXUtil_Fin:

; 102  :     }
; 103  : 
; 104  :     // On failure, just return the file as the path
; 105  :     _tcscpy( strPath, strFilename );

	mov	eax, DWORD PTR _strFilename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _strPath$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 106  :     return E_FAIL;

	mov	eax, -2147467259			; 80004005H
$LN8@DXUtil_Fin:

; 107  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUtil_FindMediaFile@@YAJPAD0@Z ENDP			; DXUtil_FindMediaFile
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\voicecomunication\dxutil.cpp
_TEXT	SEGMENT
_dwType$ = -16						; size = 4
_dwSize$ = -12						; size = 4
_hKey$ = -8						; size = 4
_lResult$ = -4						; size = 4
?DXUtil_GetDXSDKMediaPath@@YAPBDXZ PROC			; DXUtil_GetDXSDKMediaPath

; 25   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 26   :     static TCHAR strNull[2] = _T("");
; 27   :     static TCHAR strPath[MAX_PATH];
; 28   :     DWORD dwType;
; 29   :     DWORD dwSize = MAX_PATH;

	mov	DWORD PTR _dwSize$[ebp], 260		; 00000104H

; 30   :     HKEY  hKey;
; 31   : 
; 32   :     // Open the appropriate registry key
; 33   :     LONG lResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
; 34   :                                 _T("Software\\Microsoft\\DirectX SDK"),
; 35   :                                 0, KEY_READ, &hKey );

	lea	eax, DWORD PTR _hKey$[ebp]
	push	eax
	push	131097					; 00020019H
	push	0
	push	OFFSET ??_C@_0BP@HEGLIIKH@Software?2Microsoft?2DirectX?5SDK?$AA@
	push	-2147483646				; 80000002H
	call	DWORD PTR __imp__RegOpenKeyExA@20
	mov	DWORD PTR _lResult$[ebp], eax

; 36   :     if( ERROR_SUCCESS != lResult )

	cmp	DWORD PTR _lResult$[ebp], 0
	je	SHORT $LN2@DXUtil_Get

; 37   :         return strNull;

	mov	eax, OFFSET ?strNull@?1??DXUtil_GetDXSDKMediaPath@@YAPBDXZ@4PADA
	jmp	SHORT $LN3@DXUtil_Get
$LN2@DXUtil_Get:

; 38   : 
; 39   :     lResult = RegQueryValueEx( hKey, _T("DX81SDK Samples Path"), NULL,
; 40   :                               &dwType, (BYTE*)strPath, &dwSize );

	lea	ecx, DWORD PTR _dwSize$[ebp]
	push	ecx
	push	OFFSET ?strPath@?1??DXUtil_GetDXSDKMediaPath@@YAPBDXZ@4PADA
	lea	edx, DWORD PTR _dwType$[ebp]
	push	edx
	push	0
	push	OFFSET ??_C@_0BF@FNOEFMNI@DX81SDK?5Samples?5Path?$AA@
	mov	eax, DWORD PTR _hKey$[ebp]
	push	eax
	call	DWORD PTR __imp__RegQueryValueExA@24
	mov	DWORD PTR _lResult$[ebp], eax

; 41   :     RegCloseKey( hKey );

	mov	ecx, DWORD PTR _hKey$[ebp]
	push	ecx
	call	DWORD PTR __imp__RegCloseKey@4

; 42   : 
; 43   :     if( ERROR_SUCCESS != lResult )

	cmp	DWORD PTR _lResult$[ebp], 0
	je	SHORT $LN1@DXUtil_Get

; 44   :         return strNull;

	mov	eax, OFFSET ?strNull@?1??DXUtil_GetDXSDKMediaPath@@YAPBDXZ@4PADA
	jmp	SHORT $LN3@DXUtil_Get
$LN1@DXUtil_Get:

; 45   : 
; 46   :     _tcscat( strPath, _T("\\Media\\") );

	push	OFFSET ??_C@_07JADGJGAE@?2Media?2?$AA@
	push	OFFSET ?strPath@?1??DXUtil_GetDXSDKMediaPath@@YAPBDXZ@4PADA
	call	_strcat
	add	esp, 8

; 47   : 
; 48   :     return strPath;

	mov	eax, OFFSET ?strPath@?1??DXUtil_GetDXSDKMediaPath@@YAPBDXZ@4PADA
$LN3@DXUtil_Get:

; 49   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DXUtil_GetDXSDKMediaPath@@YAPBDXZ ENDP			; DXUtil_GetDXSDKMediaPath
_TEXT	ENDS
END
