; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\utils\bitio.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?OpenInputBitFile@@YAPAUbit_file@@PAD@Z		; OpenInputBitFile
PUBLIC	?OpenOutputBitFile@@YAPAUbit_file@@PAD@Z	; OpenOutputBitFile
PUBLIC	?OutputBit@@YAXPAUbit_file@@H@Z			; OutputBit
PUBLIC	?OutputBits@@YAXPAUbit_file@@KH@Z		; OutputBits
PUBLIC	?InputBit@@YAHPAUbit_file@@@Z			; InputBit
PUBLIC	?InputBits@@YAKPAUbit_file@@H@Z			; InputBits
PUBLIC	?CloseInputBitFile@@YAXPAUbit_file@@@Z		; CloseInputBitFile
PUBLIC	?CloseOutputBitFile@@YAXPAUbit_file@@@Z		; CloseOutputBitFile
PUBLIC	?FilePrintBinary@@YAXPAU_iobuf@@IH@Z		; FilePrintBinary
PUBLIC	??_C@_02GMLFBBN@wb?$AA@				; `string'
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
PUBLIC	??_C@_0BN@IIGDBICM@Fatal?5error?5in?5CloseBitFile?$CB?$AA@ ; `string'
PUBLIC	??_C@_0BK@MJIKDKBP@Fatal?5error?5in?5OutputBit?$CB?$AA@ ; `string'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	___iob_func:PROC
EXTRN	_fclose:PROC
EXTRN	_fopen:PROC
EXTRN	_fputc:PROC
EXTRN	_fread:PROC
EXTRN	_printf:PROC
EXTRN	_putc:PROC
;	COMDAT ??_C@_0BK@MJIKDKBP@Fatal?5error?5in?5OutputBit?$CB?$AA@
CONST	SEGMENT
??_C@_0BK@MJIKDKBP@Fatal?5error?5in?5OutputBit?$CB?$AA@ DB 'Fatal error i'
	DB	'n OutputBit!', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@IIGDBICM@Fatal?5error?5in?5CloseBitFile?$CB?$AA@
CONST	SEGMENT
??_C@_0BN@IIGDBICM@Fatal?5error?5in?5CloseBitFile?$CB?$AA@ DB 'Fatal erro'
	DB	'r in CloseBitFile!', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02GMLFBBN@wb?$AA@
CONST	SEGMENT
??_C@_02GMLFBBN@wb?$AA@ DB 'wb', 00H			; `string'
CONST	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\utils\bitio.cpp
_TEXT	SEGMENT
_mask$ = -4						; size = 4
_file$ = 8						; size = 4
_code$ = 12						; size = 4
_bits$ = 16						; size = 4
?FilePrintBinary@@YAXPAU_iobuf@@IH@Z PROC		; FilePrintBinary

; 174  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 175  :     unsigned int mask;
; 176  : 
; 177  :     mask = 1 << ( bits - 1 );

	mov	ecx, DWORD PTR _bits$[ebp]
	sub	ecx, 1
	mov	eax, 1
	shl	eax, cl
	mov	DWORD PTR _mask$[ebp], eax
$LN4@FilePrintB:

; 178  :     while ( mask != 0 ) {

	cmp	DWORD PTR _mask$[ebp], 0
	je	SHORT $LN5@FilePrintB

; 179  :         if ( code & mask )

	mov	ecx, DWORD PTR _code$[ebp]
	and	ecx, DWORD PTR _mask$[ebp]
	je	SHORT $LN2@FilePrintB

; 180  :             fputc( '1', file );

	mov	edx, DWORD PTR _file$[ebp]
	push	edx
	push	49					; 00000031H
	call	_fputc
	add	esp, 8

; 181  :         else

	jmp	SHORT $LN1@FilePrintB
$LN2@FilePrintB:

; 182  :             fputc( '0', file );

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	push	48					; 00000030H
	call	_fputc
	add	esp, 8
$LN1@FilePrintB:

; 183  :         mask >>= 1;

	mov	ecx, DWORD PTR _mask$[ebp]
	shr	ecx, 1
	mov	DWORD PTR _mask$[ebp], ecx

; 184  :     }

	jmp	SHORT $LN4@FilePrintB
$LN5@FilePrintB:

; 185  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FilePrintBinary@@YAXPAU_iobuf@@IH@Z ENDP		; FilePrintBinary
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\utils\bitio.cpp
_TEXT	SEGMENT
$T1 = -4						; size = 4
_bit_file$ = 8						; size = 4
?CloseOutputBitFile@@YAXPAUbit_file@@@Z PROC		; CloseOutputBitFile

; 57   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 58   :     if ( bit_file->mask != 0x80 )

	mov	eax, DWORD PTR _bit_file$[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	cmp	ecx, 128				; 00000080H
	je	SHORT $LN2@CloseOutpu

; 59   :         if ( putc( bit_file->rack, bit_file->file ) != bit_file->rack )

	mov	edx, DWORD PTR _bit_file$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _bit_file$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_putc
	add	esp, 8
	mov	ecx, DWORD PTR _bit_file$[ebp]
	cmp	eax, DWORD PTR [ecx+8]
	je	SHORT $LN2@CloseOutpu

; 60   : 			printf( "Fatal error in CloseBitFile!" );

	push	OFFSET ??_C@_0BN@IIGDBICM@Fatal?5error?5in?5CloseBitFile?$CB?$AA@
	call	_printf
	add	esp, 4
$LN2@CloseOutpu:

; 61   :     fclose( bit_file->file );

	mov	edx, DWORD PTR _bit_file$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_fclose
	add	esp, 4

; 62   :     delete [] bit_file;

	mov	ecx, DWORD PTR _bit_file$[ebp]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 63   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CloseOutputBitFile@@YAXPAUbit_file@@@Z ENDP		; CloseOutputBitFile
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\utils\bitio.cpp
_TEXT	SEGMENT
$T1 = -4						; size = 4
_bit_file$ = 8						; size = 4
?CloseInputBitFile@@YAXPAUbit_file@@@Z PROC		; CloseInputBitFile

; 66   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 67   :     fclose( bit_file->file );

	mov	eax, DWORD PTR _bit_file$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_fclose
	add	esp, 4

; 68   :     delete [] bit_file;

	mov	edx, DWORD PTR _bit_file$[ebp]
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 69   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CloseInputBitFile@@YAXPAUbit_file@@@Z ENDP		; CloseInputBitFile
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\utils\bitio.cpp
_TEXT	SEGMENT
_numRead$ = -12						; size = 4
_return_value$ = -8					; size = 4
_mask$ = -4						; size = 4
_bit_file$ = 8						; size = 4
_bit_count$ = 12					; size = 4
?InputBits@@YAKPAUbit_file@@H@Z PROC			; InputBits

; 136  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 137  :     unsigned long mask;
; 138  :     unsigned long return_value;
; 139  : 	size_t	numRead;
; 140  : 
; 141  :     mask = 1L << ( bit_count - 1 );

	mov	ecx, DWORD PTR _bit_count$[ebp]
	sub	ecx, 1
	mov	eax, 1
	shl	eax, cl
	mov	DWORD PTR _mask$[ebp], eax

; 142  :     return_value = 0;

	mov	DWORD PTR _return_value$[ebp], 0
$LN6@InputBits:

; 143  :     while ( mask != 0) 

	cmp	DWORD PTR _mask$[ebp], 0
	je	SHORT $LN5@InputBits

; 144  : 		{ 
; 145  : 		/*
; 146  : 		 * 0x80 is silence in sound files, clear or zero
; 147  : 		 * mask is cleared to 0x80 when mask for last bit read is 0
; 148  : 		 * then you read in new byte and set rack
; 149  : 		 */
; 150  : 		if ( bit_file->mask == 0x80 ) 

	mov	ecx, DWORD PTR _bit_file$[ebp]
	movzx	edx, BYTE PTR [ecx+4]
	cmp	edx, 128				; 00000080H
	jne	SHORT $LN4@InputBits

; 151  : 			{
; 152  : 			
; 153  : 			numRead = fread( &bit_file->rack, sizeof( char ), 1, bit_file->file );

	mov	eax, DWORD PTR _bit_file$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	1
	push	1
	mov	edx, DWORD PTR _bit_file$[ebp]
	add	edx, 8
	push	edx
	call	_fread
	add	esp, 16					; 00000010H
	mov	DWORD PTR _numRead$[ebp], eax

; 154  : 		//	bit_file->rack = getc( bit_file->file );
; 155  : 			if ( bit_file->rack == EOF )

	mov	eax, DWORD PTR _bit_file$[ebp]
	cmp	DWORD PTR [eax+8], -1
	jne	SHORT $LN4@InputBits

; 156  : 				return (unsigned long)EOF;

	or	eax, -1
	jmp	SHORT $LN7@InputBits
$LN4@InputBits:

; 157  : 			}
; 158  : 		if ( bit_file->rack & bit_file->mask )

	mov	ecx, DWORD PTR _bit_file$[ebp]
	movzx	edx, BYTE PTR [ecx+4]
	mov	eax, DWORD PTR _bit_file$[ebp]
	and	edx, DWORD PTR [eax+8]
	je	SHORT $LN2@InputBits

; 159  : 				return_value |= mask;

	mov	ecx, DWORD PTR _return_value$[ebp]
	or	ecx, DWORD PTR _mask$[ebp]
	mov	DWORD PTR _return_value$[ebp], ecx
$LN2@InputBits:

; 160  : 		
; 161  : 		/*
; 162  : 		 * Packs a byte and a half into one byte. A byte for me is 5 bits - On Compression.
; 163  : 		 * This is reversed for expansion.
; 164  : 		 */
; 165  : 		mask >>= 1;	

	mov	edx, DWORD PTR _mask$[ebp]
	shr	edx, 1
	mov	DWORD PTR _mask$[ebp], edx

; 166  : 		bit_file->mask >>= 1;

	mov	eax, DWORD PTR _bit_file$[ebp]
	mov	cl, BYTE PTR [eax+4]
	shr	cl, 1
	mov	edx, DWORD PTR _bit_file$[ebp]
	mov	BYTE PTR [edx+4], cl

; 167  : 		if ( bit_file->mask == 0 )

	mov	eax, DWORD PTR _bit_file$[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	test	ecx, ecx
	jne	SHORT $LN1@InputBits

; 168  : 			bit_file->mask = 0x80;

	mov	edx, DWORD PTR _bit_file$[ebp]
	mov	BYTE PTR [edx+4], 128			; 00000080H
$LN1@InputBits:

; 169  : 		}

	jmp	$LN6@InputBits
$LN5@InputBits:

; 170  :     return( return_value );

	mov	eax, DWORD PTR _return_value$[ebp]
$LN7@InputBits:

; 171  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?InputBits@@YAKPAUbit_file@@H@Z ENDP			; InputBits
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\utils\bitio.cpp
_TEXT	SEGMENT
_numRead$ = -16						; size = 4
_value$ = -12						; size = 4
tv82 = -8						; size = 4
tv132 = -4						; size = 4
_bit_file$ = 8						; size = 4
?InputBit@@YAHPAUbit_file@@@Z PROC			; InputBit

; 112  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 113  :     int value;
; 114  : 	size_t numRead;
; 115  : 
; 116  :     if ( bit_file->mask == 0x80 ) 

	mov	eax, DWORD PTR _bit_file$[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	cmp	ecx, 128				; 00000080H
	jne	SHORT $LN4@InputBit

; 117  : 		{
; 118  : 		
; 119  : 		numRead = fread( &bit_file->rack, sizeof( char ), 1, bit_file->file );

	mov	edx, DWORD PTR _bit_file$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	1
	push	1
	mov	ecx, DWORD PTR _bit_file$[ebp]
	add	ecx, 8
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H
	mov	DWORD PTR _numRead$[ebp], eax

; 120  : 
; 121  :     //    bit_file->rack = getc( bit_file->file );
; 122  :         if ( bit_file->rack == EOF )

	mov	edx, DWORD PTR _bit_file$[ebp]
	cmp	DWORD PTR [edx+8], -1
	jne	SHORT $LN3@InputBit

; 123  : 			return (unsigned long)EOF;

	or	eax, -1
	jmp	$LN5@InputBit
$LN3@InputBit:

; 124  : 
; 125  : 		if ( ( bit_file->pacifier_counter++ & PACIFIER_COUNT ) == 0 )

	mov	eax, DWORD PTR _bit_file$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	and	ecx, 2047				; 000007ffH
	mov	DWORD PTR tv82[ebp], ecx
	mov	edx, DWORD PTR _bit_file$[ebp]
	mov	eax, DWORD PTR [edx+32]
	add	eax, 1
	mov	ecx, DWORD PTR _bit_file$[ebp]
	mov	DWORD PTR [ecx+32], eax
	cmp	DWORD PTR tv82[ebp], 0
	jne	SHORT $LN4@InputBit

; 126  : 			putc( '.', stdout );

	call	___iob_func
	mov	edx, 32					; 00000020H
	shl	edx, 0
	add	eax, edx
	push	eax
	push	46					; 0000002eH
	call	_putc
	add	esp, 8
$LN4@InputBit:

; 127  : 		}
; 128  :     value = bit_file->rack & bit_file->mask;

	mov	eax, DWORD PTR _bit_file$[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	mov	edx, DWORD PTR _bit_file$[ebp]
	and	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR _value$[ebp], ecx

; 129  :     bit_file->mask >>= 1;

	mov	eax, DWORD PTR _bit_file$[ebp]
	mov	cl, BYTE PTR [eax+4]
	shr	cl, 1
	mov	edx, DWORD PTR _bit_file$[ebp]
	mov	BYTE PTR [edx+4], cl

; 130  :     if ( bit_file->mask == 0 )

	mov	eax, DWORD PTR _bit_file$[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	test	ecx, ecx
	jne	SHORT $LN1@InputBit

; 131  : 		bit_file->mask = 0x80;

	mov	edx, DWORD PTR _bit_file$[ebp]
	mov	BYTE PTR [edx+4], 128			; 00000080H
$LN1@InputBit:

; 132  :     return( value ? 1 : 0 );

	cmp	DWORD PTR _value$[ebp], 0
	je	SHORT $LN7@InputBit
	mov	DWORD PTR tv132[ebp], 1
	jmp	SHORT $LN8@InputBit
$LN7@InputBit:
	mov	DWORD PTR tv132[ebp], 0
$LN8@InputBit:
	mov	eax, DWORD PTR tv132[ebp]
$LN5@InputBit:

; 133  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?InputBit@@YAHPAUbit_file@@@Z ENDP			; InputBit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\utils\bitio.cpp
_TEXT	SEGMENT
tv94 = -8						; size = 4
_mask$ = -4						; size = 4
_bit_file$ = 8						; size = 4
_code$ = 12						; size = 4
_count$ = 16						; size = 4
?OutputBits@@YAXPAUbit_file@@KH@Z PROC			; OutputBits

; 88   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 89   :     unsigned long mask;
; 90   : 
; 91   :     mask = 1L << ( count - 1 );

	mov	ecx, DWORD PTR _count$[ebp]
	sub	ecx, 1
	mov	eax, 1
	shl	eax, cl
	mov	DWORD PTR _mask$[ebp], eax
$LN7@OutputBits:

; 92   :     while ( mask != 0) 

	cmp	DWORD PTR _mask$[ebp], 0
	je	$LN8@OutputBits

; 93   : 		{
; 94   :         if ( mask & code )

	mov	ecx, DWORD PTR _mask$[ebp]
	and	ecx, DWORD PTR _code$[ebp]
	je	SHORT $LN5@OutputBits

; 95   :             bit_file->rack |= bit_file->mask;

	mov	edx, DWORD PTR _bit_file$[ebp]
	movzx	eax, BYTE PTR [edx+4]
	mov	ecx, DWORD PTR _bit_file$[ebp]
	or	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _bit_file$[ebp]
	mov	DWORD PTR [edx+8], eax
$LN5@OutputBits:

; 96   :         bit_file->mask >>= 1;

	mov	eax, DWORD PTR _bit_file$[ebp]
	mov	cl, BYTE PTR [eax+4]
	shr	cl, 1
	mov	edx, DWORD PTR _bit_file$[ebp]
	mov	BYTE PTR [edx+4], cl

; 97   :         if ( bit_file->mask == 0 ) 

	mov	eax, DWORD PTR _bit_file$[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	test	ecx, ecx
	jne	SHORT $LN4@OutputBits

; 98   : 			{
; 99   : 			if ( putc( bit_file->rack, bit_file->file ) != bit_file->rack )

	mov	edx, DWORD PTR _bit_file$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _bit_file$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_putc
	add	esp, 8
	mov	ecx, DWORD PTR _bit_file$[ebp]
	cmp	eax, DWORD PTR [ecx+8]
	je	SHORT $LN3@OutputBits

; 100  : 				printf( "Fatal error in OutputBit!" );

	push	OFFSET ??_C@_0BK@MJIKDKBP@Fatal?5error?5in?5OutputBit?$CB?$AA@
	call	_printf
	add	esp, 4
	jmp	SHORT $LN2@OutputBits
$LN3@OutputBits:

; 101  : 			else if ( ( bit_file->pacifier_counter++ & PACIFIER_COUNT ) == 0 )

	mov	edx, DWORD PTR _bit_file$[ebp]
	mov	eax, DWORD PTR [edx+32]
	and	eax, 2047				; 000007ffH
	mov	DWORD PTR tv94[ebp], eax
	mov	ecx, DWORD PTR _bit_file$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	add	edx, 1
	mov	eax, DWORD PTR _bit_file$[ebp]
	mov	DWORD PTR [eax+32], edx
	cmp	DWORD PTR tv94[ebp], 0
	jne	SHORT $LN2@OutputBits

; 102  : 				putc( '.', stdout );

	call	___iob_func
	mov	ecx, 32					; 00000020H
	shl	ecx, 0
	add	eax, ecx
	push	eax
	push	46					; 0000002eH
	call	_putc
	add	esp, 8
$LN2@OutputBits:

; 103  : 
; 104  : 			bit_file->rack = 0;

	mov	edx, DWORD PTR _bit_file$[ebp]
	mov	DWORD PTR [edx+8], 0

; 105  :             bit_file->mask = 0x80;

	mov	eax, DWORD PTR _bit_file$[ebp]
	mov	BYTE PTR [eax+4], 128			; 00000080H
$LN4@OutputBits:

; 106  : 			}
; 107  :         mask >>= 1;

	mov	ecx, DWORD PTR _mask$[ebp]
	shr	ecx, 1
	mov	DWORD PTR _mask$[ebp], ecx

; 108  : 		}

	jmp	$LN7@OutputBits
$LN8@OutputBits:

; 109  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?OutputBits@@YAXPAUbit_file@@KH@Z ENDP			; OutputBits
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\utils\bitio.cpp
_TEXT	SEGMENT
tv90 = -4						; size = 4
_bit_file$ = 8						; size = 4
_bit$ = 12						; size = 4
?OutputBit@@YAXPAUbit_file@@H@Z PROC			; OutputBit

; 72   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 73   :     if ( bit )

	cmp	DWORD PTR _bit$[ebp], 0
	je	SHORT $LN5@OutputBit

; 74   :         bit_file->rack |= bit_file->mask;

	mov	eax, DWORD PTR _bit_file$[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	mov	edx, DWORD PTR _bit_file$[ebp]
	or	ecx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR _bit_file$[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN5@OutputBit:

; 75   :     bit_file->mask >>= 1;

	mov	ecx, DWORD PTR _bit_file$[ebp]
	mov	dl, BYTE PTR [ecx+4]
	shr	dl, 1
	mov	eax, DWORD PTR _bit_file$[ebp]
	mov	BYTE PTR [eax+4], dl

; 76   :     if ( bit_file->mask == 0 ) {

	mov	ecx, DWORD PTR _bit_file$[ebp]
	movzx	edx, BYTE PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN6@OutputBit

; 77   : 	if ( putc( bit_file->rack, bit_file->file ) != bit_file->rack )

	mov	eax, DWORD PTR _bit_file$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _bit_file$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_putc
	add	esp, 8
	mov	ecx, DWORD PTR _bit_file$[ebp]
	cmp	eax, DWORD PTR [ecx+8]
	je	SHORT $LN3@OutputBit

; 78   : 		printf( "Fatal error in OutputBit!" );

	push	OFFSET ??_C@_0BK@MJIKDKBP@Fatal?5error?5in?5OutputBit?$CB?$AA@
	call	_printf
	add	esp, 4

; 79   : 	else

	jmp	SHORT $LN2@OutputBit
$LN3@OutputBit:

; 80   :         if ( ( bit_file->pacifier_counter++ & PACIFIER_COUNT ) == 0 )

	mov	edx, DWORD PTR _bit_file$[ebp]
	mov	eax, DWORD PTR [edx+32]
	and	eax, 2047				; 000007ffH
	mov	DWORD PTR tv90[ebp], eax
	mov	ecx, DWORD PTR _bit_file$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	add	edx, 1
	mov	eax, DWORD PTR _bit_file$[ebp]
	mov	DWORD PTR [eax+32], edx
	cmp	DWORD PTR tv90[ebp], 0
	jne	SHORT $LN2@OutputBit

; 81   : 		putc( '.', stdout );

	call	___iob_func
	mov	ecx, 32					; 00000020H
	shl	ecx, 0
	add	eax, ecx
	push	eax
	push	46					; 0000002eH
	call	_putc
	add	esp, 8
$LN2@OutputBit:

; 82   : 	bit_file->rack = 0;

	mov	edx, DWORD PTR _bit_file$[ebp]
	mov	DWORD PTR [edx+8], 0

; 83   : 	bit_file->mask = 0x80;

	mov	eax, DWORD PTR _bit_file$[ebp]
	mov	BYTE PTR [eax+4], 128			; 00000080H
$LN6@OutputBit:

; 84   :     }
; 85   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?OutputBit@@YAXPAUbit_file@@H@Z ENDP			; OutputBit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\utils\bitio.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 4
_bit_file$ = -4						; size = 4
_name$ = 8						; size = 4
?OpenOutputBitFile@@YAPAUbit_file@@PAD@Z PROC		; OpenOutputBitFile

; 27   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 28   :     BIT_FILE *bit_file;
; 29   : 
; 30   : //	bit_file = (BIT_FILE *) malloc( sizeof( BIT_FILE ) );
; 31   :     bit_file = new BIT_FILE;

	push	36					; 00000024H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR _bit_file$[ebp], eax

; 32   :     if ( bit_file == NULL )

	cmp	DWORD PTR _bit_file$[ebp], 0
	jne	SHORT $LN1@OpenOutput

; 33   :         return( bit_file );

	mov	eax, DWORD PTR _bit_file$[ebp]
	jmp	SHORT $LN2@OpenOutput
$LN1@OpenOutput:

; 34   :     bit_file->file = fopen( name, "wb" );

	push	OFFSET ??_C@_02GMLFBBN@wb?$AA@
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_fopen
	add	esp, 8
	mov	edx, DWORD PTR _bit_file$[ebp]
	mov	DWORD PTR [edx], eax

; 35   :     bit_file->rack = 0;

	mov	eax, DWORD PTR _bit_file$[ebp]
	mov	DWORD PTR [eax+8], 0

; 36   :     bit_file->mask = 0x80;

	mov	ecx, DWORD PTR _bit_file$[ebp]
	mov	BYTE PTR [ecx+4], 128			; 00000080H

; 37   :     bit_file->pacifier_counter = 0;

	mov	edx, DWORD PTR _bit_file$[ebp]
	mov	DWORD PTR [edx+32], 0

; 38   :     return( bit_file );

	mov	eax, DWORD PTR _bit_file$[ebp]
$LN2@OpenOutput:

; 39   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?OpenOutputBitFile@@YAPAUbit_file@@PAD@Z ENDP		; OpenOutputBitFile
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\utils\bitio.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 4
_bit_file$ = -4						; size = 4
_name$ = 8						; size = 4
?OpenInputBitFile@@YAPAUbit_file@@PAD@Z PROC		; OpenInputBitFile

; 42   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 43   :     BIT_FILE *bit_file;
; 44   : 
; 45   : //	bit_file = (BIT_FILE *) malloc( sizeof( BIT_FILE ) );
; 46   :     bit_file = new BIT_FILE;

	push	36					; 00000024H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR _bit_file$[ebp], eax

; 47   :     if ( bit_file == NULL )

	cmp	DWORD PTR _bit_file$[ebp], 0
	jne	SHORT $LN1@OpenInputB

; 48   : 	return( bit_file );

	mov	eax, DWORD PTR _bit_file$[ebp]
	jmp	SHORT $LN2@OpenInputB
$LN1@OpenInputB:

; 49   :     bit_file->file = fopen( name, "rb" );

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_fopen
	add	esp, 8
	mov	edx, DWORD PTR _bit_file$[ebp]
	mov	DWORD PTR [edx], eax

; 50   :     bit_file->rack = 0;

	mov	eax, DWORD PTR _bit_file$[ebp]
	mov	DWORD PTR [eax+8], 0

; 51   :     bit_file->mask = 0x80;

	mov	ecx, DWORD PTR _bit_file$[ebp]
	mov	BYTE PTR [ecx+4], 128			; 00000080H

; 52   :     bit_file->pacifier_counter = 0;

	mov	edx, DWORD PTR _bit_file$[ebp]
	mov	DWORD PTR [edx+32], 0

; 53   :     return( bit_file );

	mov	eax, DWORD PTR _bit_file$[ebp]
$LN2@OpenInputB:

; 54   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?OpenInputBitFile@@YAPAUbit_file@@PAD@Z ENDP		; OpenInputBitFile
_TEXT	ENDS
END
