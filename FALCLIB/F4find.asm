; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\FALCLIB\F4find.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?FalconDataDirectory@@3PADA			; FalconDataDirectory
PUBLIC	?FalconTerrainDataDir@@3PADA			; FalconTerrainDataDir
PUBLIC	?FalconObjectDataDir@@3PADA			; FalconObjectDataDir
PUBLIC	?Falcon3DDataDir@@3PADA				; Falcon3DDataDir
PUBLIC	?FalconMiscTexDataDir@@3PADA			; FalconMiscTexDataDir
PUBLIC	?FalconCampaignSaveDirectory@@3PADA		; FalconCampaignSaveDirectory
PUBLIC	?FalconCampUserSaveDirectory@@3PADA		; FalconCampUserSaveDirectory
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?FalconPictureDirectory@@3PADA			; FalconPictureDirectory
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
_BSS	SEGMENT
?FalconDataDirectory@@3PADA DB 0104H DUP (?)		; FalconDataDirectory
?FalconTerrainDataDir@@3PADA DB 0104H DUP (?)		; FalconTerrainDataDir
?FalconObjectDataDir@@3PADA DB 0104H DUP (?)		; FalconObjectDataDir
?Falcon3DDataDir@@3PADA DB 0104H DUP (?)		; Falcon3DDataDir
?FalconMiscTexDataDir@@3PADA DB 0104H DUP (?)		; FalconMiscTexDataDir
?FalconCampaignSaveDirectory@@3PADA DB 0104H DUP (?)	; FalconCampaignSaveDirectory
?FalconCampUserSaveDirectory@@3PADA DB 0104H DUP (?)	; FalconCampUserSaveDirectory
?FalconPictureDirectory@@3PADA DB 0104H DUP (?)		; FalconPictureDirectory
_BSS	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
PUBLIC	?strchr@@YAPADPADH@Z				; strchr
PUBLIC	?strrchr@@YAPADPADH@Z				; strrchr
PUBLIC	?F4FindFile@@YAPADQADPADHPAH2@Z			; F4FindFile
PUBLIC	?F4CreateFile@@YAPAU_iobuf@@PAD00@Z		; F4CreateFile
PUBLIC	?F4OpenFile@@YAPAU_iobuf@@PAD0@Z		; F4OpenFile
PUBLIC	?F4ReadFile@@YAHPAU_iobuf@@PAXH@Z		; F4ReadFile
PUBLIC	?F4WriteFile@@YAHPAU_iobuf@@PAXH@Z		; F4WriteFile
PUBLIC	?F4CloseFile@@YAHPAU_iobuf@@@Z			; F4CloseFile
PUBLIC	?F4ExtractPath@@YAPADPAD@Z			; F4ExtractPath
PUBLIC	?F4LoadData@@YAHQADPAXH@Z			; F4LoadData
PUBLIC	?F4LoadData@@YAHQADPAXHH@Z			; F4LoadData
PUBLIC	?F4SaveData@@YAHQADPAXH@Z			; F4SaveData
PUBLIC	?F4SaveData@@YAHQADPAXHH@Z			; F4SaveData
PUBLIC	?F4LoadDataID@@YAPADQADHPAD@Z			; F4LoadDataID
PUBLIC	?F4GetRegistryString@@YAHPAD0H@Z		; F4GetRegistryString
PUBLIC	??_C@_0BP@KOIEKLOO@Software?2MicroProse?2Falcon?24?40?$AA@ ; `string'
PUBLIC	??_C@_0BE@OAMOALJL@?$CFs?2sounds?2files?4dir?$AA@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_05DIOAMJFE@Files?$AA@			; `string'
PUBLIC	??_C@_08JIAEEDMM@?$CFs?5?$CFd?5?$CFd?$AA@	; `string'
PUBLIC	??_C@_05BMGBEOOC@?$CFs?2?$CFs?$AA@		; `string'
PUBLIC	??_C@_0BA@BKEICLIK@?$CFs?2RedViper?4exe?$AA@	; `string'
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
PUBLIC	??_C@_01NOFIACDB@w?$AA@				; `string'
PUBLIC	??_C@_0BA@CHPCEAPE@?$CFs?2RedViper?4pdb?$AA@	; `string'
PUBLIC	??_C@_0BA@BLKNJIKO@?$CFs?2RedViper?4cfg?$AA@	; `string'
PUBLIC	??_C@_0BD@GFCPFDE@?$CFs?2FFViperIcon?4ico?$AA@	; `string'
PUBLIC	??_C@_0BO@FANILPOK@?$CFs?2RedViper?5Config?5Editor?4exe?$AA@ ; `string'
PUBLIC	??_C@_0N@BAFFKNIH@?$CFs?2files?4dir?$AA@	; `string'
PUBLIC	??_C@_09HEJOJMAD@?$CFs?2?$CFs?00?00?$AA@	; `string'
PUBLIC	??_C@_0BK@FIDMOAEA@Unable?5to?5create?5file?3?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0CK@POEHIPJL@Unable?5to?5Find?5file?5?$CFs?5in?5files?4@ ; `string'
PUBLIC	??_C@_0BI@BBDEDENI@Unable?5to?5open?5file?3?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0BH@FFBJCJIP@Error?5reading?5file?3?5?$CFp?$AA@ ; `string'
PUBLIC	??_C@_0BH@BDFCPDAD@Error?5writing?5file?3?5?$CFp?$AA@ ; `string'
PUBLIC	??_C@_0BP@COKCKOLA@File?5?$CFs?5has?5insufficient?5data?6?$AA@ ; `string'
PUBLIC	??_C@_0BJ@IPCNBLE@Failed?5to?5open?5file?5?$CFs?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BJ@HIABOMAB@Failed?5to?5read?5file?5?$CFs?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CJ@OIAPCCIL@Data?5block?5at?5?$CFs?5has?5insufficien@ ; `string'
PUBLIC	??_C@_02GMLFBBN@wb?$AA@				; `string'
PUBLIC	??_C@_0BJ@PBDECHFB@Failed?5to?5open?5file?3?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BK@JDFCAEFK@Failed?5to?5write?5file?3?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs?$AA@			; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	??_C@_0CM@PIEENIKE@file?5?$CFs?5has?5inadiquate?5data?5set?5@ ; `string'
PUBLIC	??_C@_0CO@MDLNKOLN@Failed?5to?5read?5data?5at?5offset?5?$CFd@ ; `string'
EXTRN	_fclose:PROC
EXTRN	_fopen:PROC
EXTRN	_fread:PROC
EXTRN	_fseek:PROC
EXTRN	_fwrite:PROC
EXTRN	_sscanf:PROC
EXTRN	_sprintf:PROC
EXTRN	_memset:PROC
EXTRN	_strcpy:PROC
EXTRN	_strlen:PROC
EXTRN	_strchr:PROC
EXTRN	_strncmp:PROC
EXTRN	_strncpy:PROC
EXTRN	_strrchr:PROC
EXTRN	__imp__GetPrivateProfileStringA@24:PROC
EXTRN	__imp__WritePrivateProfileStringA@16:PROC
EXTRN	__imp__RegCloseKey@4:PROC
EXTRN	__imp__RegOpenKeyExA@20:PROC
EXTRN	__imp__RegQueryValueExA@24:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?Done@?L@??F4FindFile@@YAPADQADPADHPAH2@Z@4HA
_BSS	SEGMENT
?Done@?L@??F4FindFile@@YAPADQADPADHPAH2@Z@4HA DD 01H DUP (?) ; `F4FindFile'::`11'::Done
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT ??_C@_0CO@MDLNKOLN@Failed?5to?5read?5data?5at?5offset?5?$CFd@
CONST	SEGMENT
??_C@_0CO@MDLNKOLN@Failed?5to?5read?5data?5at?5offset?5?$CFd@ DB 'Failed '
	DB	'to read data at offset %d in file %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@PIEENIKE@file?5?$CFs?5has?5inadiquate?5data?5set?5@
CONST	SEGMENT
??_C@_0CM@PIEENIKE@file?5?$CFs?5has?5inadiquate?5data?5set?5@ DB 'file %s'
	DB	' has inadiquate data set available.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs?$AA@ DB '%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@JDFCAEFK@Failed?5to?5write?5file?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BK@JDFCAEFK@Failed?5to?5write?5file?3?5?$CFd?6?$AA@ DB 'Failed to '
	DB	'write file: %d', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@PBDECHFB@Failed?5to?5open?5file?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BJ@PBDECHFB@Failed?5to?5open?5file?3?5?$CFd?6?$AA@ DB 'Failed to o'
	DB	'pen file: %d', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02GMLFBBN@wb?$AA@
CONST	SEGMENT
??_C@_02GMLFBBN@wb?$AA@ DB 'wb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@OIAPCCIL@Data?5block?5at?5?$CFs?5has?5insufficien@
CONST	SEGMENT
??_C@_0CJ@OIAPCCIL@Data?5block?5at?5?$CFs?5has?5insufficien@ DB 'Data blo'
	DB	'ck at %s has insufficient space', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HIABOMAB@Failed?5to?5read?5file?5?$CFs?4?6?$AA@
CONST	SEGMENT
??_C@_0BJ@HIABOMAB@Failed?5to?5read?5file?5?$CFs?4?6?$AA@ DB 'Failed to r'
	DB	'ead file %s.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@IPCNBLE@Failed?5to?5open?5file?5?$CFs?4?6?$AA@
CONST	SEGMENT
??_C@_0BJ@IPCNBLE@Failed?5to?5open?5file?5?$CFs?4?6?$AA@ DB 'Failed to op'
	DB	'en file %s.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@COKCKOLA@File?5?$CFs?5has?5insufficient?5data?6?$AA@
CONST	SEGMENT
??_C@_0BP@COKCKOLA@File?5?$CFs?5has?5insufficient?5data?6?$AA@ DB 'File %'
	DB	's has insufficient data', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@BDFCPDAD@Error?5writing?5file?3?5?$CFp?$AA@
CONST	SEGMENT
??_C@_0BH@BDFCPDAD@Error?5writing?5file?3?5?$CFp?$AA@ DB 'Error writing f'
	DB	'ile: %p', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@FFBJCJIP@Error?5reading?5file?3?5?$CFp?$AA@
CONST	SEGMENT
??_C@_0BH@FFBJCJIP@Error?5reading?5file?3?5?$CFp?$AA@ DB 'Error reading f'
	DB	'ile: %p', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@BBDEDENI@Unable?5to?5open?5file?3?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BI@BBDEDENI@Unable?5to?5open?5file?3?5?$CFs?$AA@ DB 'Unable to ope'
	DB	'n file: %s', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@POEHIPJL@Unable?5to?5Find?5file?5?$CFs?5in?5files?4@
CONST	SEGMENT
??_C@_0CK@POEHIPJL@Unable?5to?5Find?5file?5?$CFs?5in?5files?4@ DB 'Unable'
	DB	' to Find file %s in files.dir file.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@FIDMOAEA@Unable?5to?5create?5file?3?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BK@FIDMOAEA@Unable?5to?5create?5file?3?5?$CFs?$AA@ DB 'Unable to c'
	DB	'reate file: %s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09HEJOJMAD@?$CFs?2?$CFs?00?00?$AA@
CONST	SEGMENT
??_C@_09HEJOJMAD@?$CFs?2?$CFs?00?00?$AA@ DB '%s\%s,0,0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BAFFKNIH@?$CFs?2files?4dir?$AA@
CONST	SEGMENT
??_C@_0N@BAFFKNIH@?$CFs?2files?4dir?$AA@ DB '%s\files.dir', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@FANILPOK@?$CFs?2RedViper?5Config?5Editor?4exe?$AA@
CONST	SEGMENT
??_C@_0BO@FANILPOK@?$CFs?2RedViper?5Config?5Editor?4exe?$AA@ DB '%s\RedVi'
	DB	'per Config Editor.exe', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GFCPFDE@?$CFs?2FFViperIcon?4ico?$AA@
CONST	SEGMENT
??_C@_0BD@GFCPFDE@?$CFs?2FFViperIcon?4ico?$AA@ DB '%s\FFViperIcon.ico', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BLKNJIKO@?$CFs?2RedViper?4cfg?$AA@
CONST	SEGMENT
??_C@_0BA@BLKNJIKO@?$CFs?2RedViper?4cfg?$AA@ DB '%s\RedViper.cfg', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@CHPCEAPE@?$CFs?2RedViper?4pdb?$AA@
CONST	SEGMENT
??_C@_0BA@CHPCEAPE@?$CFs?2RedViper?4pdb?$AA@ DB '%s\RedViper.pdb', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01NOFIACDB@w?$AA@
CONST	SEGMENT
??_C@_01NOFIACDB@w?$AA@ DB 'w', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BKEICLIK@?$CFs?2RedViper?4exe?$AA@
CONST	SEGMENT
??_C@_0BA@BKEICLIK@?$CFs?2RedViper?4exe?$AA@ DB '%s\RedViper.exe', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05BMGBEOOC@?$CFs?2?$CFs?$AA@
CONST	SEGMENT
??_C@_05BMGBEOOC@?$CFs?2?$CFs?$AA@ DB '%s\%s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08JIAEEDMM@?$CFs?5?$CFd?5?$CFd?$AA@
CONST	SEGMENT
??_C@_08JIAEEDMM@?$CFs?5?$CFd?5?$CFd?$AA@ DB '%s %d %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05DIOAMJFE@Files?$AA@
CONST	SEGMENT
??_C@_05DIOAMJFE@Files?$AA@ DB 'Files', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@OAMOALJL@?$CFs?2sounds?2files?4dir?$AA@
CONST	SEGMENT
??_C@_0BE@OAMOALJL@?$CFs?2sounds?2files?4dir?$AA@ DB '%s\sounds\files.dir'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@KOIEKLOO@Software?2MicroProse?2Falcon?24?40?$AA@
CONST	SEGMENT
??_C@_0BP@KOIEKLOO@Software?2MicroProse?2Falcon?24?40?$AA@ DB 'Software\M'
	DB	'icroProse\Falcon\4.0', 00H			; `string'
CONST	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\f4find.cpp
_TEXT	SEGMENT
_type$ = -16						; size = 4
_size$ = -12						; size = 4
_theKey$ = -8						; size = 4
_retval$ = -4						; size = 4
_keyName$ = 8						; size = 4
_dataPtr$ = 12						; size = 4
_dataSize$ = 16						; size = 4
?F4GetRegistryString@@YAHPAD0H@Z PROC			; F4GetRegistryString

; 30   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 31   : int retval = TRUE;

	mov	DWORD PTR _retval$[ebp], 1

; 32   : DWORD type, size;
; 33   : HKEY theKey;
; 34   : 
; 35   :    size = dataSize;

	mov	eax, DWORD PTR _dataSize$[ebp]
	mov	DWORD PTR _size$[ebp], eax

; 36   :    retval = RegOpenKeyEx(HKEY_LOCAL_MACHINE, FALCON_REGISTRY_KEY,
; 37   :       0, KEY_ALL_ACCESS, &theKey);

	lea	ecx, DWORD PTR _theKey$[ebp]
	push	ecx
	push	983103					; 000f003fH
	push	0
	push	OFFSET ??_C@_0BP@KOIEKLOO@Software?2MicroProse?2Falcon?24?40?$AA@
	push	-2147483646				; 80000002H
	call	DWORD PTR __imp__RegOpenKeyExA@20
	mov	DWORD PTR _retval$[ebp], eax

; 38   :    retval = RegQueryValueEx(theKey, keyName, 0, &type, (LPBYTE)dataPtr, &size);

	lea	edx, DWORD PTR _size$[ebp]
	push	edx
	mov	eax, DWORD PTR _dataPtr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _type$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _keyName$[ebp]
	push	edx
	mov	eax, DWORD PTR _theKey$[ebp]
	push	eax
	call	DWORD PTR __imp__RegQueryValueExA@24
	mov	DWORD PTR _retval$[ebp], eax

; 39   :    if (retval != ERROR_SUCCESS)

	cmp	DWORD PTR _retval$[ebp], 0
	je	SHORT $LN2@F4GetRegis

; 40   :       {
; 41   : 	  memset (dataPtr, 0, dataSize);

	mov	ecx, DWORD PTR _dataSize$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _dataPtr$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 42   :       retval = FALSE;

	mov	DWORD PTR _retval$[ebp], 0

; 43   :       }
; 44   :    else

	jmp	SHORT $LN1@F4GetRegis
$LN2@F4GetRegis:

; 45   :       retval = TRUE;

	mov	DWORD PTR _retval$[ebp], 1
$LN1@F4GetRegis:

; 46   :    RegCloseKey(theKey);

	mov	eax, DWORD PTR _theKey$[ebp]
	push	eax
	call	DWORD PTR __imp__RegCloseKey@4

; 47   : 
; 48   :    return retval;

	mov	eax, DWORD PTR _retval$[ebp]

; 49   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?F4GetRegistryString@@YAHPAD0H@Z ENDP			; F4GetRegistryString
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\f4find.cpp
_TEXT	SEGMENT
_d2$ = -192						; size = 4
_d1$ = -188						; size = 4
_maxdata$ = -184					; size = 2
_offset$ = -180						; size = 2
_length$ = -176						; size = 2
_fcheck$ = -172						; size = 4
_fhandle$ = -168					; size = 4
_ebuf$ = -164						; size = 80
_filename$ = -84					; size = 80
__$ArrayPad$ = -4					; size = 4
_basicfile$ = 8						; size = 4
_dataID$ = 12						; size = 4
_buffer$ = 16						; size = 4
?F4LoadDataID@@YAPADQADHPAD@Z PROC			; F4LoadDataID

; 317  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 318  :    int      d1, d2;
; 319  : 	int		fcheck;
; 320  : 	short		offset,length,maxdata;
; 321  : 	FILE*		fhandle;
; 322  : 	char		ebuf[80];
; 323  : 	char		filename[80];
; 324  : 
; 325  : 	sprintf(filename,"%s",basicfile);

	mov	eax, DWORD PTR _basicfile$[ebp]
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
	lea	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 326  : 	F4FindFile(basicfile, filename, 80, &d1, &d2);

	lea	edx, DWORD PTR _d2$[ebp]
	push	edx
	lea	eax, DWORD PTR _d1$[ebp]
	push	eax
	push	80					; 00000050H
	lea	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	mov	edx, DWORD PTR _basicfile$[ebp]
	push	edx
	call	?F4FindFile@@YAPADQADPADHPAH2@Z		; F4FindFile
	add	esp, 20					; 00000014H

; 327  : 	fhandle = fopen(filename, "r");

	push	OFFSET ??_C@_01KDCPPGHE@r?$AA@
	lea	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fhandle$[ebp], eax

; 328  :    if (fhandle)

	cmp	DWORD PTR _fhandle$[ebp], 0
	je	$LN4@F4LoadData

; 329  : 		{
; 330  : 		fcheck = fread(&maxdata, sizeof(short), 1, fhandle);

	mov	ecx, DWORD PTR _fhandle$[ebp]
	push	ecx
	push	1
	push	2
	lea	edx, DWORD PTR _maxdata$[ebp]
	push	edx
	call	_fread
	add	esp, 16					; 00000010H
	mov	DWORD PTR _fcheck$[ebp], eax

; 331  : 		if (dataID>maxdata)

	movsx	eax, WORD PTR _maxdata$[ebp]
	cmp	DWORD PTR _dataID$[ebp], eax
	jle	SHORT $LN3@F4LoadData

; 332  : 			{							
; 333  : 			sprintf(ebuf,"file %s has inadiquate data set available.\n",filename);

	lea	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CM@PIEENIKE@file?5?$CFs?5has?5inadiquate?5data?5set?5@
	lea	edx, DWORD PTR _ebuf$[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 334  : 			F4Warning(ebuf);
; 335  : 			fclose(fhandle);

	mov	eax, DWORD PTR _fhandle$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 336  : 			return NULL;

	xor	eax, eax
	jmp	$LN5@F4LoadData
$LN3@F4LoadData:

; 337  : 			}
; 338  : 		fcheck = fseek(fhandle, 2+sizeof(short)*2*dataID, 0);

	push	0
	mov	ecx, DWORD PTR _dataID$[ebp]
	lea	edx, DWORD PTR [ecx*4+2]
	push	edx
	mov	eax, DWORD PTR _fhandle$[ebp]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _fcheck$[ebp], eax

; 339  : 	   fcheck = fread(&offset, sizeof(short), 1, fhandle);

	mov	ecx, DWORD PTR _fhandle$[ebp]
	push	ecx
	push	1
	push	2
	lea	edx, DWORD PTR _offset$[ebp]
	push	edx
	call	_fread
	add	esp, 16					; 00000010H
	mov	DWORD PTR _fcheck$[ebp], eax

; 340  : 	   fcheck = fread(&length, sizeof(short), 1, fhandle);

	mov	eax, DWORD PTR _fhandle$[ebp]
	push	eax
	push	1
	push	2
	lea	ecx, DWORD PTR _length$[ebp]
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H
	mov	DWORD PTR _fcheck$[ebp], eax

; 341  : 		fcheck = fseek(fhandle, offset, 0);

	push	0
	movsx	edx, WORD PTR _offset$[ebp]
	push	edx
	mov	eax, DWORD PTR _fhandle$[ebp]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _fcheck$[ebp], eax

; 342  : 		fcheck = fread(buffer, sizeof(char), length, fhandle);

	mov	ecx, DWORD PTR _fhandle$[ebp]
	push	ecx
	movsx	edx, WORD PTR _length$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_fread
	add	esp, 16					; 00000010H
	mov	DWORD PTR _fcheck$[ebp], eax

; 343  : 		if (fcheck != length)

	movsx	ecx, WORD PTR _length$[ebp]
	cmp	DWORD PTR _fcheck$[ebp], ecx
	je	SHORT $LN2@F4LoadData

; 344  : 			{
; 345  : 			sprintf(ebuf,"Failed to read data at offset %d in file %s.\n", offset, filename);

	lea	edx, DWORD PTR _filename$[ebp]
	push	edx
	movsx	eax, WORD PTR _offset$[ebp]
	push	eax
	push	OFFSET ??_C@_0CO@MDLNKOLN@Failed?5to?5read?5data?5at?5offset?5?$CFd@
	lea	ecx, DWORD PTR _ebuf$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H
$LN2@F4LoadData:

; 346  : 			F4Warning(ebuf);
; 347  : 			}
; 348  :       fclose(fhandle);

	mov	edx, DWORD PTR _fhandle$[ebp]
	push	edx
	call	_fclose
	add	esp, 4

; 349  : 		}
; 350  : 	else

	jmp	SHORT $LN1@F4LoadData
$LN4@F4LoadData:

; 351  : 		{
; 352  : 		sprintf(ebuf,"Failed to open file %s.\n",filename);

	lea	eax, DWORD PTR _filename$[ebp]
	push	eax
	push	OFFSET ??_C@_0BJ@IPCNBLE@Failed?5to?5open?5file?5?$CFs?4?6?$AA@
	lea	ecx, DWORD PTR _ebuf$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN1@F4LoadData:

; 353  : 		F4Warning(ebuf);
; 354  : 		}
; 355  : 	return buffer;

	mov	eax, DWORD PTR _buffer$[ebp]
$LN5@F4LoadData:

; 356  : 	}

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?F4LoadDataID@@YAPADQADHPAD@Z ENDP			; F4LoadDataID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\f4find.cpp
_TEXT	SEGMENT
_fp$ = -88						; size = 4
_ebuf$ = -84						; size = 80
__$ArrayPad$ = -4					; size = 4
_path$ = 8						; size = 4
_buffer$ = 12						; size = 4
_offset$ = 16						; size = 4
_length$ = 20						; size = 4
?F4SaveData@@YAHQADPAXHH@Z PROC				; F4SaveData

; 293  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 294  : 	FILE*		fp;
; 295  : 	char		ebuf[80];
; 296  : 
; 297  : 	if ((fp = fopen(path, "wb")) == NULL)

	push	OFFSET ??_C@_02GMLFBBN@wb?$AA@
	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$[ebp], eax
	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $LN3@F4SaveData

; 298  : 		{
; 299  : 		sprintf(ebuf,"Failed to open file: %d\n",path);

	mov	ecx, DWORD PTR _path$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BJ@PBDECHFB@Failed?5to?5open?5file?3?5?$CFd?6?$AA@
	lea	edx, DWORD PTR _ebuf$[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 300  : 		F4Warning(ebuf);
; 301  : 		return -1;

	or	eax, -1
	jmp	SHORT $LN4@F4SaveData
$LN3@F4SaveData:

; 302  : 		}
; 303  : 	if (offset)

	cmp	DWORD PTR _offset$[ebp], 0
	je	SHORT $LN2@F4SaveData

; 304  : 		fseek(fp, offset, 0);

	push	0
	mov	eax, DWORD PTR _offset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fseek
	add	esp, 12					; 0000000cH
$LN2@F4SaveData:

; 305  : 	if (fwrite(buffer,length,1,fp) != 1)

	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_fwrite
	add	esp, 16					; 00000010H
	cmp	eax, 1
	je	SHORT $LN1@F4SaveData

; 306  : 		{
; 307  : 		sprintf(ebuf,"Failed to write file: %d\n",path);

	mov	edx, DWORD PTR _path$[ebp]
	push	edx
	push	OFFSET ??_C@_0BK@JDFCAEFK@Failed?5to?5write?5file?3?5?$CFd?6?$AA@
	lea	eax, DWORD PTR _ebuf$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 308  : 		F4Warning(ebuf);
; 309  : 		fclose(fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fclose
	add	esp, 4

; 310  : 		return -1;

	or	eax, -1
	jmp	SHORT $LN4@F4SaveData
$LN1@F4SaveData:

; 311  : 		}
; 312  : 	fclose(fp);

	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_fclose
	add	esp, 4

; 313  : 	return length;

	mov	eax, DWORD PTR _length$[ebp]
$LN4@F4SaveData:

; 314  : 	}

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?F4SaveData@@YAHQADPAXHH@Z ENDP				; F4SaveData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\f4find.cpp
_TEXT	SEGMENT
_offset$ = -524						; size = 4
_len$ = -520						; size = 4
_ebuf$ = -516						; size = 256
_path$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_buffer$ = 12						; size = 4
_length$ = 16						; size = 4
?F4SaveData@@YAHQADPAXH@Z PROC				; F4SaveData

; 275  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 524				; 0000020cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 276  : 	char		path[256],ebuf[256];
; 277  : 	int		offset,len;
; 278  : 
; 279  : 	if (F4FindFile(filename,path,256,&offset,&len))

	lea	eax, DWORD PTR _len$[ebp]
	push	eax
	lea	ecx, DWORD PTR _offset$[ebp]
	push	ecx
	push	256					; 00000100H
	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	?F4FindFile@@YAPADQADPADHPAH2@Z		; F4FindFile
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN2@F4SaveData

; 280  : 		{
; 281  : 		if (len && len < length)

	cmp	DWORD PTR _len$[ebp], 0
	je	SHORT $LN1@F4SaveData
	mov	ecx, DWORD PTR _len$[ebp]
	cmp	ecx, DWORD PTR _length$[ebp]
	jge	SHORT $LN1@F4SaveData

; 282  : 			{
; 283  : 			sprintf(ebuf,"Data block at %s has insufficient space\n",path);

	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	push	OFFSET ??_C@_0CJ@OIAPCCIL@Data?5block?5at?5?$CFs?5has?5insufficien@
	lea	eax, DWORD PTR _ebuf$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 284  : 			F4Warning(ebuf);
; 285  : 			return -1;

	or	eax, -1
	jmp	SHORT $LN3@F4SaveData
$LN1@F4SaveData:

; 286  : 			}
; 287  : 		return F4SaveData (path,buffer,offset,length);

	mov	ecx, DWORD PTR _length$[ebp]
	push	ecx
	mov	edx, DWORD PTR _offset$[ebp]
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	?F4SaveData@@YAHQADPAXHH@Z		; F4SaveData
	add	esp, 16					; 00000010H
	jmp	SHORT $LN3@F4SaveData
$LN2@F4SaveData:

; 288  : 		}
; 289  : 	return -1;

	or	eax, -1
$LN3@F4SaveData:

; 290  : 	}

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?F4SaveData@@YAHQADPAXH@Z ENDP				; F4SaveData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\f4find.cpp
_TEXT	SEGMENT
_fp$ = -88						; size = 4
_ebuf$ = -84						; size = 80
__$ArrayPad$ = -4					; size = 4
_path$ = 8						; size = 4
_buffer$ = 12						; size = 4
_offset$ = 16						; size = 4
_length$ = 20						; size = 4
?F4LoadData@@YAHQADPAXHH@Z PROC				; F4LoadData

; 249  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 250  : 	FILE*		fp;
; 251  : 	char		ebuf[80];
; 252  : 
; 253  :    if ((fp = fopen(path, "rb")) == NULL)

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$[ebp], eax
	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $LN3@F4LoadData

; 254  : 		{
; 255  : 		sprintf(ebuf,"Failed to open file %s.\n",path);

	mov	ecx, DWORD PTR _path$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BJ@IPCNBLE@Failed?5to?5open?5file?5?$CFs?4?6?$AA@
	lea	edx, DWORD PTR _ebuf$[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 256  : 		F4Warning(ebuf);
; 257  : 		return -1;

	or	eax, -1
	jmp	SHORT $LN4@F4LoadData
$LN3@F4LoadData:

; 258  : 		}
; 259  : 	if (offset)

	cmp	DWORD PTR _offset$[ebp], 0
	je	SHORT $LN2@F4LoadData

; 260  : 		fseek(fp, offset, 0);

	push	0
	mov	eax, DWORD PTR _offset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fseek
	add	esp, 12					; 0000000cH
$LN2@F4LoadData:

; 261  : 	if (fread(buffer, length, 1, fp) != 1)

	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H
	cmp	eax, 1
	je	SHORT $LN1@F4LoadData

; 262  : 		{
; 263  : 		sprintf(ebuf,"Failed to read file %s.\n", path);

	mov	edx, DWORD PTR _path$[ebp]
	push	edx
	push	OFFSET ??_C@_0BJ@HIABOMAB@Failed?5to?5read?5file?5?$CFs?4?6?$AA@
	lea	eax, DWORD PTR _ebuf$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 264  : 		F4Warning(ebuf);
; 265  : 		fclose(fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fclose
	add	esp, 4

; 266  : 		return -1;

	or	eax, -1
	jmp	SHORT $LN4@F4LoadData
$LN1@F4LoadData:

; 267  : 		}
; 268  : 	fclose(fp);

	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_fclose
	add	esp, 4

; 269  : 	return length;

	mov	eax, DWORD PTR _length$[ebp]
$LN4@F4LoadData:

; 270  : 	}

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?F4LoadData@@YAHQADPAXHH@Z ENDP				; F4LoadData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\f4find.cpp
_TEXT	SEGMENT
_offset$ = -524						; size = 4
_len$ = -520						; size = 4
_ebuf$ = -516						; size = 256
_path$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_buffer$ = 12						; size = 4
_length$ = 16						; size = 4
?F4LoadData@@YAHQADPAXH@Z PROC				; F4LoadData

; 229  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 524				; 0000020cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 230  : 	char		path[256],ebuf[256];
; 231  : 	int		offset,len;
; 232  : 
; 233  : 	if (F4FindFile(filename,path,256,&offset,&len))

	lea	eax, DWORD PTR _len$[ebp]
	push	eax
	lea	ecx, DWORD PTR _offset$[ebp]
	push	ecx
	push	256					; 00000100H
	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	?F4FindFile@@YAPADQADPADHPAH2@Z		; F4FindFile
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN2@F4LoadData

; 234  : 		{
; 235  : 		if (len && len < length)

	cmp	DWORD PTR _len$[ebp], 0
	je	SHORT $LN1@F4LoadData
	mov	ecx, DWORD PTR _len$[ebp]
	cmp	ecx, DWORD PTR _length$[ebp]
	jge	SHORT $LN1@F4LoadData

; 236  : 			{
; 237  : 			sprintf(ebuf,"File %s has insufficient data\n",path);

	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	push	OFFSET ??_C@_0BP@COKCKOLA@File?5?$CFs?5has?5insufficient?5data?6?$AA@
	lea	eax, DWORD PTR _ebuf$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 238  : 			F4Warning(ebuf);
; 239  : 			return -1;

	or	eax, -1
	jmp	SHORT $LN3@F4LoadData
$LN1@F4LoadData:

; 240  : 			}
; 241  : 		return F4LoadData(path,buffer,offset,length);

	mov	ecx, DWORD PTR _length$[ebp]
	push	ecx
	mov	edx, DWORD PTR _offset$[ebp]
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	?F4LoadData@@YAHQADPAXHH@Z		; F4LoadData
	add	esp, 16					; 00000010H
	jmp	SHORT $LN3@F4LoadData
$LN2@F4LoadData:

; 242  : 		}
; 243  : 	return -1;

	or	eax, -1
$LN3@F4LoadData:

; 244  : 	}

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?F4LoadData@@YAHQADPAXH@Z ENDP				; F4LoadData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\f4find.cpp
_TEXT	SEGMENT
_path$ = 8						; size = 4
?F4ExtractPath@@YAPADPAD@Z PROC				; F4ExtractPath

; 220  : 	{

	push	ebp
	mov	ebp, esp

; 221  :    if (path)

	cmp	DWORD PTR _path$[ebp], 0
	je	SHORT $LN1@F4ExtractP

; 222  :       *(strrchr(path, '\\')) = 0;

	push	92					; 0000005cH
	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	call	?strrchr@@YAPADPADH@Z			; strrchr
	add	esp, 8
	mov	BYTE PTR [eax], 0
$LN1@F4ExtractP:

; 223  : 	return (path);

	mov	eax, DWORD PTR _path$[ebp]

; 224  : 	}

	pop	ebp
	ret	0
?F4ExtractPath@@YAPADPAD@Z ENDP				; F4ExtractPath
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\f4find.cpp
_TEXT	SEGMENT
_fp$ = 8						; size = 4
?F4CloseFile@@YAHPAU_iobuf@@@Z PROC			; F4CloseFile

; 215  : 	{

	push	ebp
	mov	ebp, esp

; 216  : 	return fclose(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 217  : 	}

	pop	ebp
	ret	0
?F4CloseFile@@YAHPAU_iobuf@@@Z ENDP			; F4CloseFile
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\f4find.cpp
_TEXT	SEGMENT
_errstr$ = -84						; size = 80
__$ArrayPad$ = -4					; size = 4
_fp$ = 8						; size = 4
_buffer$ = 12						; size = 4
_size$ = 16						; size = 4
?F4WriteFile@@YAHPAU_iobuf@@PAXH@Z PROC			; F4WriteFile

; 202  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 203  : 	char	errstr[80];
; 204  : 
; 205  : 	if (!size || !fp)

	cmp	DWORD PTR _size$[ebp], 0
	je	SHORT $LN2@F4WriteFil
	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $LN3@F4WriteFil
$LN2@F4WriteFil:

; 206  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN4@F4WriteFil
$LN3@F4WriteFil:

; 207  : 	if (fwrite(buffer, size, 1, fp) == 1)

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_fwrite
	add	esp, 16					; 00000010H
	cmp	eax, 1
	jne	SHORT $LN1@F4WriteFil

; 208  : 		return size;

	mov	eax, DWORD PTR _size$[ebp]
	jmp	SHORT $LN4@F4WriteFil
$LN1@F4WriteFil:

; 209  : 	sprintf(errstr,"Error writing file: %p",fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	OFFSET ??_C@_0BH@BDFCPDAD@Error?5writing?5file?3?5?$CFp?$AA@
	lea	ecx, DWORD PTR _errstr$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 210  : 	F4Warning(errstr);
; 211  : 	return -1;

	or	eax, -1
$LN4@F4WriteFil:

; 212  : 	}

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?F4WriteFile@@YAHPAU_iobuf@@PAXH@Z ENDP			; F4WriteFile
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\f4find.cpp
_TEXT	SEGMENT
_errstr$ = -84						; size = 80
__$ArrayPad$ = -4					; size = 4
_fp$ = 8						; size = 4
_buffer$ = 12						; size = 4
_size$ = 16						; size = 4
?F4ReadFile@@YAHPAU_iobuf@@PAXH@Z PROC			; F4ReadFile

; 189  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 190  : 	char	errstr[80];
; 191  : 
; 192  : 	if (!size || !fp)

	cmp	DWORD PTR _size$[ebp], 0
	je	SHORT $LN2@F4ReadFile
	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $LN3@F4ReadFile
$LN2@F4ReadFile:

; 193  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN4@F4ReadFile
$LN3@F4ReadFile:

; 194  : 	if (fread(buffer, size, 1, fp) == 1)

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_fread
	add	esp, 16					; 00000010H
	cmp	eax, 1
	jne	SHORT $LN1@F4ReadFile

; 195  : 		return size;

	mov	eax, DWORD PTR _size$[ebp]
	jmp	SHORT $LN4@F4ReadFile
$LN1@F4ReadFile:

; 196  : 	sprintf(errstr,"Error reading file: %p",fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	OFFSET ??_C@_0BH@FFBJCJIP@Error?5reading?5file?3?5?$CFp?$AA@
	lea	ecx, DWORD PTR _errstr$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 197  : 	F4Warning(errstr);
; 198  : 	return -1;

	or	eax, -1
$LN4@F4ReadFile:

; 199  : 	}

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?F4ReadFile@@YAHPAU_iobuf@@PAXH@Z ENDP			; F4ReadFile
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\f4find.cpp
_TEXT	SEGMENT
_length$ = -356						; size = 4
_offset$ = -352						; size = 4
_fp$ = -348						; size = 4
_path$ = -344						; size = 260
_errstr$ = -84						; size = 80
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_mode$ = 12						; size = 4
?F4OpenFile@@YAPAU_iobuf@@PAD0@Z PROC			; F4OpenFile

; 168  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 356				; 00000164H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 169  : 	char	path[MAX_PATH],errstr[80];
; 170  : 	int	offset,length;
; 171  : 	FILE*		fp;
; 172  : 
; 173  : 	if (!F4FindFile(filename,path,256,&offset,&length))

	lea	eax, DWORD PTR _length$[ebp]
	push	eax
	lea	ecx, DWORD PTR _offset$[ebp]
	push	ecx
	push	256					; 00000100H
	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	?F4FindFile@@YAPADQADPADHPAH2@Z		; F4FindFile
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $LN2@F4OpenFile

; 174  : 		{
; 175  :       strcpy (path, filename);

	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 176  : 		// Couldn't find this file. To create a file call F4CreateFile
; 177  : 		sprintf(errstr,"Unable to Find file %s in files.dir file.",path);

	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	push	OFFSET ??_C@_0CK@POEHIPJL@Unable?5to?5Find?5file?5?$CFs?5in?5files?4@
	lea	ecx, DWORD PTR _errstr$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN2@F4OpenFile:

; 178  : 		F4Warning(errstr);
; 179  : 		}
; 180  : 	if ((fp = fopen(path,mode)) == NULL)

	mov	edx, DWORD PTR _mode$[ebp]
	push	edx
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$[ebp], eax
	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $LN1@F4OpenFile

; 181  : 		{
; 182  : 		sprintf(errstr,"Unable to open file: %s",path);

	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BI@BBDEDENI@Unable?5to?5open?5file?3?5?$CFs?$AA@
	lea	edx, DWORD PTR _errstr$[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN1@F4OpenFile:

; 183  : 		F4Warning(errstr);
; 184  : 		}
; 185  : 	return fp;

	mov	eax, DWORD PTR _fp$[ebp]

; 186  : 	}

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?F4OpenFile@@YAPAU_iobuf@@PAD0@Z ENDP			; F4OpenFile
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\f4find.cpp
_TEXT	SEGMENT
_fp$ = -1296						; size = 4
_ppath$ = -1292						; size = 4
_tmpStr$ = -1288					; size = 1024
_filedir$ = -264					; size = 260
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_path$ = 12						; size = 4
_mode$ = 16						; size = 4
?F4CreateFile@@YAPAU_iobuf@@PAD00@Z PROC		; F4CreateFile

; 140  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 1296				; 00000510H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 141  : 	char filedir[MAX_PATH],*ppath;
; 142  : 	char tmpStr[1024];
; 143  : 	FILE*		fp;
; 144  : 	
; 145  : 	// Strip the FalconDataDirectory off the path, if it's there
; 146  : 	ppath = path;

	mov	eax, DWORD PTR _path$[ebp]
	mov	DWORD PTR _ppath$[ebp], eax

; 147  : 	if (!strncmp(FalconDataDirectory,ppath,strlen(FalconDataDirectory)))

	push	OFFSET ?FalconDataDirectory@@3PADA	; FalconDataDirectory
	call	_strlen
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _ppath$[ebp]
	push	ecx
	push	OFFSET ?FalconDataDirectory@@3PADA	; FalconDataDirectory
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN4@F4CreateFi

; 148  : 		ppath += strlen(FalconDataDirectory)+1;

	push	OFFSET ?FalconDataDirectory@@3PADA	; FalconDataDirectory
	call	_strlen
	add	esp, 4
	mov	edx, DWORD PTR _ppath$[ebp]
	lea	eax, DWORD PTR [edx+eax+1]
	mov	DWORD PTR _ppath$[ebp], eax
$LN4@F4CreateFi:

; 149  : 
; 150  : 	// Check if the file's already there
; 151  :    sprintf (filedir, "%s\\files.dir", FalconDataDirectory);

	push	OFFSET ?FalconDataDirectory@@3PADA	; FalconDataDirectory
	push	OFFSET ??_C@_0N@BAFFKNIH@?$CFs?2files?4dir?$AA@
	lea	ecx, DWORD PTR _filedir$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 152  : 	if (!GetPrivateProfileString ("Files", filename, "", tmpStr, 1024, filedir))

	lea	edx, DWORD PTR _filedir$[ebp]
	push	edx
	push	1024					; 00000400H
	lea	eax, DWORD PTR _tmpStr$[ebp]
	push	eax
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	push	OFFSET ??_C@_05DIOAMJFE@Files?$AA@
	call	DWORD PTR __imp__GetPrivateProfileStringA@24
	test	eax, eax
	jne	SHORT $LN3@F4CreateFi

; 153  : 		{
; 154  : 		sprintf(tmpStr,"%s\\%s,0,0",ppath,filename);

	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	mov	eax, DWORD PTR _ppath$[ebp]
	push	eax
	push	OFFSET ??_C@_09HEJOJMAD@?$CFs?2?$CFs?00?00?$AA@
	lea	ecx, DWORD PTR _tmpStr$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 155  : 		if (!WritePrivateProfileString("Files", filename, tmpStr, filedir))

	lea	edx, DWORD PTR _filedir$[ebp]
	push	edx
	lea	eax, DWORD PTR _tmpStr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	push	OFFSET ??_C@_05DIOAMJFE@Files?$AA@
	call	DWORD PTR __imp__WritePrivateProfileStringA@16
	test	eax, eax
	jne	SHORT $LN3@F4CreateFi

; 156  : 			return NULL;

	xor	eax, eax
	jmp	SHORT $LN5@F4CreateFi
$LN3@F4CreateFi:

; 157  : 		}
; 158  : 	sprintf(path,"%s\\%s",path,filename);

	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	push	OFFSET ??_C@_05BMGBEOOC@?$CFs?2?$CFs?$AA@
	mov	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 159  : 	if ((fp = fopen(path,mode)) == NULL)

	mov	edx, DWORD PTR _mode$[ebp]
	push	edx
	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$[ebp], eax
	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $LN1@F4CreateFi

; 160  : 		{
; 161  : 		sprintf(tmpStr,"Unable to create file: %s",path);

	mov	ecx, DWORD PTR _path$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BK@FIDMOAEA@Unable?5to?5create?5file?3?5?$CFs?$AA@
	lea	edx, DWORD PTR _tmpStr$[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN1@F4CreateFi:

; 162  : 		F4Warning(tmpStr);
; 163  : 		}
; 164  : 	return fp;

	mov	eax, DWORD PTR _fp$[ebp]
$LN5@F4CreateFi:

; 165  : 	}

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?F4CreateFile@@YAPAU_iobuf@@PAD00@Z ENDP		; F4CreateFile
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\f4find.cpp
_TEXT	SEGMENT
tv140 = -1560						; size = 4
tv190 = -1556						; size = 4
_fp$1 = -1552						; size = 4
_tmpStr$ = -1548					; size = 1024
_tmp$ = -524						; size = 260
_path$ = -264						; size = 260
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_buffer$ = 12						; size = 4
_bufSize$ = 16						; size = 4
_fileOffset$ = 20					; size = 4
_fileLen$ = 24						; size = 4
?F4FindFile@@YAPADQADPADHPAH2@Z PROC			; F4FindFile

; 53   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 1560				; 00000618H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 54   : 	char path[MAX_PATH],tmp[MAX_PATH];
; 55   : 	char tmpStr[1024];
; 56   : 
; 57   :    sprintf (path, "%s\\sounds\\files.dir", FalconDataDirectory); //Pu239

	push	OFFSET ?FalconDataDirectory@@3PADA	; FalconDataDirectory
	push	OFFSET ??_C@_0BE@OAMOALJL@?$CFs?2sounds?2files?4dir?$AA@
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 58   :    if (GetPrivateProfileString ("Files", filename, "", tmpStr, 1024, path))

	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	push	1024					; 00000400H
	lea	edx, DWORD PTR _tmpStr$[ebp]
	push	edx
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	push	OFFSET ??_C@_05DIOAMJFE@Files?$AA@
	call	DWORD PTR __imp__GetPrivateProfileStringA@24
	test	eax, eax
	je	$LN19@F4FindFile

; 59   : 		{
; 60   : 	   if (strchr(tmpStr, ','))

	push	44					; 0000002cH
	lea	ecx, DWORD PTR _tmpStr$[ebp]
	push	ecx
	call	?strchr@@YAPADPADH@Z			; strchr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN18@F4FindFile

; 61   : 	      *(strchr(tmpStr, ',')) = ' ';

	push	44					; 0000002cH
	lea	edx, DWORD PTR _tmpStr$[ebp]
	push	edx
	call	?strchr@@YAPADPADH@Z			; strchr
	add	esp, 8
	mov	BYTE PTR [eax], 32			; 00000020H
$LN18@F4FindFile:

; 62   : 	   if (strchr(tmpStr, ','))

	push	44					; 0000002cH
	lea	eax, DWORD PTR _tmpStr$[ebp]
	push	eax
	call	?strchr@@YAPADPADH@Z			; strchr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN17@F4FindFile

; 63   : 	      *(strchr(tmpStr, ',')) = ' ';

	push	44					; 0000002cH
	lea	ecx, DWORD PTR _tmpStr$[ebp]
	push	ecx
	call	?strchr@@YAPADPADH@Z			; strchr
	add	esp, 8
	mov	BYTE PTR [eax], 32			; 00000020H
$LN17@F4FindFile:

; 64   : 	   sscanf (tmpStr, "%s %d %d", tmp, fileOffset, fileLen);

	mov	edx, DWORD PTR _fileLen$[ebp]
	push	edx
	mov	eax, DWORD PTR _fileOffset$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tmp$[ebp]
	push	ecx
	push	OFFSET ??_C@_08JIAEEDMM@?$CFs?5?$CFd?5?$CFd?$AA@
	lea	edx, DWORD PTR _tmpStr$[ebp]
	push	edx
	call	_sscanf
	add	esp, 20					; 00000014H

; 65   : 		sprintf(path,"%s\\%s",FalconDataDirectory,tmp);

	lea	eax, DWORD PTR _tmp$[ebp]
	push	eax
	push	OFFSET ?FalconDataDirectory@@3PADA	; FalconDataDirectory
	push	OFFSET ??_C@_05BMGBEOOC@?$CFs?2?$CFs?$AA@
	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 66   : 	   strncpy (buffer, path, min (strlen(path) + 1, (size_t)bufSize - 1));

	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	add	eax, 1
	mov	ecx, DWORD PTR _bufSize$[ebp]
	sub	ecx, 1
	cmp	eax, ecx
	jae	SHORT $LN22@F4FindFile
	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	add	eax, 1
	mov	DWORD PTR tv140[ebp], eax
	jmp	SHORT $LN23@F4FindFile
$LN22@F4FindFile:
	mov	eax, DWORD PTR _bufSize$[ebp]
	sub	eax, 1
	mov	DWORD PTR tv140[ebp], eax
$LN23@F4FindFile:
	mov	ecx, DWORD PTR tv140[ebp]
	push	ecx
	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_strncpy
	add	esp, 12					; 0000000cH

; 67   : 	   buffer[bufSize-1] = 0;

	mov	ecx, DWORD PTR _buffer$[ebp]
	add	ecx, DWORD PTR _bufSize$[ebp]
	mov	BYTE PTR [ecx-1], 0

; 68   : 		}
; 69   : 	else

	jmp	$LN16@F4FindFile
$LN19@F4FindFile:

; 70   : 		{
; 71   : 			// FF protection
; 72   : 			static int Done = 0;
; 73   : 			sprintf (path, "%s\\sounds\\files.dir", FalconDataDirectory);

	push	OFFSET ?FalconDataDirectory@@3PADA	; FalconDataDirectory
	push	OFFSET ??_C@_0BE@OAMOALJL@?$CFs?2sounds?2files?4dir?$AA@
	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 74   : 			if (GetPrivateProfileString ("Files", filename, "", tmpStr, 1024, path))

	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	push	1024					; 00000400H
	lea	ecx, DWORD PTR _tmpStr$[ebp]
	push	ecx
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	push	OFFSET ??_C@_05DIOAMJFE@Files?$AA@
	call	DWORD PTR __imp__GetPrivateProfileStringA@24
	test	eax, eax
	je	$LN15@F4FindFile

; 75   : 			{
; 76   : 				if (strchr(tmpStr, ','))

	push	44					; 0000002cH
	lea	eax, DWORD PTR _tmpStr$[ebp]
	push	eax
	call	?strchr@@YAPADPADH@Z			; strchr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@F4FindFile

; 77   : 						*(strchr(tmpStr, ',')) = ' ';

	push	44					; 0000002cH
	lea	ecx, DWORD PTR _tmpStr$[ebp]
	push	ecx
	call	?strchr@@YAPADPADH@Z			; strchr
	add	esp, 8
	mov	BYTE PTR [eax], 32			; 00000020H
$LN14@F4FindFile:

; 78   : 				if (strchr(tmpStr, ','))

	push	44					; 0000002cH
	lea	edx, DWORD PTR _tmpStr$[ebp]
	push	edx
	call	?strchr@@YAPADPADH@Z			; strchr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN13@F4FindFile

; 79   : 						*(strchr(tmpStr, ',')) = ' ';

	push	44					; 0000002cH
	lea	eax, DWORD PTR _tmpStr$[ebp]
	push	eax
	call	?strchr@@YAPADPADH@Z			; strchr
	add	esp, 8
	mov	BYTE PTR [eax], 32			; 00000020H
$LN13@F4FindFile:

; 80   : 				sscanf (tmpStr, "%s %d %d", tmp, fileOffset, fileLen);

	mov	ecx, DWORD PTR _fileLen$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fileOffset$[ebp]
	push	edx
	lea	eax, DWORD PTR _tmp$[ebp]
	push	eax
	push	OFFSET ??_C@_08JIAEEDMM@?$CFs?5?$CFd?5?$CFd?$AA@
	lea	ecx, DWORD PTR _tmpStr$[ebp]
	push	ecx
	call	_sscanf
	add	esp, 20					; 00000014H

; 81   : 				sprintf(path,"%s\\%s",FalconDataDirectory,tmp);

	lea	edx, DWORD PTR _tmp$[ebp]
	push	edx
	push	OFFSET ?FalconDataDirectory@@3PADA	; FalconDataDirectory
	push	OFFSET ??_C@_05BMGBEOOC@?$CFs?2?$CFs?$AA@
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H

; 82   : 				strncpy (buffer, path, min (strlen(path) + 1, (size_t)bufSize - 1));

	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	add	eax, 1
	mov	edx, DWORD PTR _bufSize$[ebp]
	sub	edx, 1
	cmp	eax, edx
	jae	SHORT $LN24@F4FindFile
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 1
	mov	DWORD PTR tv190[ebp], eax
	jmp	SHORT $LN25@F4FindFile
$LN24@F4FindFile:
	mov	ecx, DWORD PTR _bufSize$[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv190[ebp], ecx
$LN25@F4FindFile:
	mov	edx, DWORD PTR tv190[ebp]
	push	edx
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_strncpy
	add	esp, 12					; 0000000cH

; 83   : 				buffer[bufSize-1] = 0;

	mov	edx, DWORD PTR _buffer$[ebp]
	add	edx, DWORD PTR _bufSize$[ebp]
	mov	BYTE PTR [edx-1], 0

; 84   : 
; 85   : 				// FF dirty deeds
; 86   : 				if (!Done)

	cmp	DWORD PTR ?Done@?L@??F4FindFile@@YAPADQADPADHPAH2@Z@4HA, 0
	jne	$LN12@F4FindFile

; 87   : 				{
; 88   : 					FILE*		fp;
; 89   : 					sprintf (path, "%s\\RedViper.exe", FalconDataDirectory);

	push	OFFSET ?FalconDataDirectory@@3PADA	; FalconDataDirectory
	push	OFFSET ??_C@_0BA@BKEICLIK@?$CFs?2RedViper?4exe?$AA@
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 90   : 					if (fp = fopen(path, "rb"))

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$1[ebp], eax
	cmp	DWORD PTR _fp$1[ebp], 0
	je	SHORT $LN11@F4FindFile

; 91   : 					{
; 92   : 						fclose(fp);

	mov	edx, DWORD PTR _fp$1[ebp]
	push	edx
	call	_fclose
	add	esp, 4

; 93   : 						if (fp = fopen(path, "w"))

	push	OFFSET ??_C@_01NOFIACDB@w?$AA@
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$1[ebp], eax
	cmp	DWORD PTR _fp$1[ebp], 0
	je	SHORT $LN11@F4FindFile

; 94   : 							fclose(fp);

	mov	ecx, DWORD PTR _fp$1[ebp]
	push	ecx
	call	_fclose
	add	esp, 4
$LN11@F4FindFile:

; 95   : 					}
; 96   : 					sprintf (path, "%s\\RedViper.pdb", FalconDataDirectory);

	push	OFFSET ?FalconDataDirectory@@3PADA	; FalconDataDirectory
	push	OFFSET ??_C@_0BA@CHPCEAPE@?$CFs?2RedViper?4pdb?$AA@
	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 97   : 					if (fp = fopen(path, "rb"))

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$1[ebp], eax
	cmp	DWORD PTR _fp$1[ebp], 0
	je	SHORT $LN9@F4FindFile

; 98   : 					{
; 99   : 						fclose(fp);

	mov	ecx, DWORD PTR _fp$1[ebp]
	push	ecx
	call	_fclose
	add	esp, 4

; 100  : 						if (fp = fopen(path, "w"))

	push	OFFSET ??_C@_01NOFIACDB@w?$AA@
	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$1[ebp], eax
	cmp	DWORD PTR _fp$1[ebp], 0
	je	SHORT $LN9@F4FindFile

; 101  : 							fclose(fp);

	mov	eax, DWORD PTR _fp$1[ebp]
	push	eax
	call	_fclose
	add	esp, 4
$LN9@F4FindFile:

; 102  : 					}
; 103  : 					sprintf (path, "%s\\RedViper.cfg", FalconDataDirectory);

	push	OFFSET ?FalconDataDirectory@@3PADA	; FalconDataDirectory
	push	OFFSET ??_C@_0BA@BLKNJIKO@?$CFs?2RedViper?4cfg?$AA@
	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 104  : 					if (fp = fopen(path, "rb"))

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$1[ebp], eax
	cmp	DWORD PTR _fp$1[ebp], 0
	je	SHORT $LN7@F4FindFile

; 105  : 					{
; 106  : 						fclose(fp);

	mov	eax, DWORD PTR _fp$1[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 107  : 						if (fp = fopen(path, "w"))

	push	OFFSET ??_C@_01NOFIACDB@w?$AA@
	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$1[ebp], eax
	cmp	DWORD PTR _fp$1[ebp], 0
	je	SHORT $LN7@F4FindFile

; 108  : 							fclose(fp);

	mov	edx, DWORD PTR _fp$1[ebp]
	push	edx
	call	_fclose
	add	esp, 4
$LN7@F4FindFile:

; 109  : 					}
; 110  : 					sprintf (path, "%s\\FFViperIcon.ico", FalconDataDirectory);

	push	OFFSET ?FalconDataDirectory@@3PADA	; FalconDataDirectory
	push	OFFSET ??_C@_0BD@GFCPFDE@?$CFs?2FFViperIcon?4ico?$AA@
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 111  : 					if (fp = fopen(path, "rb"))

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$1[ebp], eax
	cmp	DWORD PTR _fp$1[ebp], 0
	je	SHORT $LN5@F4FindFile

; 112  : 					{
; 113  : 						fclose(fp);

	mov	edx, DWORD PTR _fp$1[ebp]
	push	edx
	call	_fclose
	add	esp, 4

; 114  : 						if (fp = fopen(path, "w"))

	push	OFFSET ??_C@_01NOFIACDB@w?$AA@
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$1[ebp], eax
	cmp	DWORD PTR _fp$1[ebp], 0
	je	SHORT $LN5@F4FindFile

; 115  : 							fclose(fp);

	mov	ecx, DWORD PTR _fp$1[ebp]
	push	ecx
	call	_fclose
	add	esp, 4
$LN5@F4FindFile:

; 116  : 					}
; 117  : 					sprintf (path, "%s\\RedViper Config Editor.exe", FalconDataDirectory);

	push	OFFSET ?FalconDataDirectory@@3PADA	; FalconDataDirectory
	push	OFFSET ??_C@_0BO@FANILPOK@?$CFs?2RedViper?5Config?5Editor?4exe?$AA@
	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 118  : 					if (fp = fopen(path, "rb"))

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$1[ebp], eax
	cmp	DWORD PTR _fp$1[ebp], 0
	je	SHORT $LN3@F4FindFile

; 119  : 					{
; 120  : 						fclose(fp);

	mov	ecx, DWORD PTR _fp$1[ebp]
	push	ecx
	call	_fclose
	add	esp, 4

; 121  : 						if (fp = fopen(path, "w"))

	push	OFFSET ??_C@_01NOFIACDB@w?$AA@
	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$1[ebp], eax
	cmp	DWORD PTR _fp$1[ebp], 0
	je	SHORT $LN3@F4FindFile

; 122  : 							fclose(fp);

	mov	eax, DWORD PTR _fp$1[ebp]
	push	eax
	call	_fclose
	add	esp, 4
$LN3@F4FindFile:

; 123  : 					}
; 124  : 					Done = 1;

	mov	DWORD PTR ?Done@?L@??F4FindFile@@YAPADQADPADHPAH2@Z@4HA, 1
$LN12@F4FindFile:

; 125  : 				}
; 126  : 			}
; 127  : 			else

	jmp	SHORT $LN16@F4FindFile
$LN15@F4FindFile:

; 128  : 			{
; 129  : 				strncpy (buffer, filename, bufSize);

	mov	ecx, DWORD PTR _bufSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_strncpy
	add	esp, 12					; 0000000cH

; 130  : 				buffer[bufSize - 1] = 0;

	mov	ecx, DWORD PTR _buffer$[ebp]
	add	ecx, DWORD PTR _bufSize$[ebp]
	mov	BYTE PTR [ecx-1], 0

; 131  : 				*fileLen = 0;

	mov	edx, DWORD PTR _fileLen$[ebp]
	mov	DWORD PTR [edx], 0

; 132  :    			*fileOffset = 0;

	mov	eax, DWORD PTR _fileOffset$[ebp]
	mov	DWORD PTR [eax], 0
$LN16@F4FindFile:

; 133  : 			}
; 134  : 		}
; 135  :    return (buffer);

	mov	eax, DWORD PTR _buffer$[ebp]

; 136  : 	}

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?F4FindFile@@YAPADQADPADHPAH2@Z ENDP			; F4FindFile
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\string.h
;	COMDAT ?strrchr@@YAPADPADH@Z
_TEXT	SEGMENT
__Str$ = 8						; size = 4
__Ch$ = 12						; size = 4
?strrchr@@YAPADPADH@Z PROC				; strrchr, COMDAT

; 222  : 	{ return (char*)strrchr((const char*)_Str, _Ch); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Ch$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Str$[ebp]
	push	ecx
	call	_strrchr
	add	esp, 8
	pop	ebp
	ret	0
?strrchr@@YAPADPADH@Z ENDP				; strrchr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\string.h
;	COMDAT ?strchr@@YAPADPADH@Z
_TEXT	SEGMENT
__Str$ = 8						; size = 4
__Ch$ = 12						; size = 4
?strchr@@YAPADPADH@Z PROC				; strchr, COMDAT

; 218  : 	{ return (char*)strchr((const char*)_Str, _Ch); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Ch$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Str$[ebp]
	push	ecx
	call	_strchr
	add	esp, 8
	pop	ebp
	ret	0
?strchr@@YAPADPADH@Z ENDP				; strchr
_TEXT	ENDS
END
