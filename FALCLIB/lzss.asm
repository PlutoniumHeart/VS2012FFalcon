; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\utils\lzss.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_LZSS_Compress
PUBLIC	_LZSS_Expand
PUBLIC	?InitTree@@YAXHPAULZSS_COMP_CTXT@@@Z		; InitTree
PUBLIC	?ContractNode@@YAXHHPAULZSS_COMP_CTXT@@@Z	; ContractNode
PUBLIC	?ReplaceNode@@YAXHHPAULZSS_COMP_CTXT@@@Z	; ReplaceNode
PUBLIC	?FindNextNode@@YAHHPAULZSS_COMP_CTXT@@@Z	; FindNextNode
PUBLIC	?DeleteString@@YAXHPAULZSS_COMP_CTXT@@@Z	; DeleteString
PUBLIC	?AddString@@YAHHPAHPAULZSS_COMP_CTXT@@@Z	; AddString
PUBLIC	?InitOutputBuffer@@YAXPAULZSS_COMP_CTXT@@@Z	; InitOutputBuffer
PUBLIC	?FlushOutputBuffer@@YAHPAEPAULZSS_COMP_CTXT@@@Z	; FlushOutputBuffer
PUBLIC	?OutputChar@@YAHHPAEPAULZSS_COMP_CTXT@@@Z	; OutputChar
PUBLIC	?OutputPair@@YAHHHPAEPAULZSS_COMP_CTXT@@@Z	; OutputPair
PUBLIC	?InitInputBuffer@@YAXPAEPAULZSS_COMP_CTXT@@@Z	; InitInputBuffer
PUBLIC	?InputBit@@YAHPAEPAULZSS_COMP_CTXT@@@Z		; InputBit
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	___security_cookie:DWORD
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\utils\lzss.cpp
_TEXT	SEGMENT
_input_string$ = 8					; size = 4
_ctxt$ = 12						; size = 4
?InputBit@@YAHPAEPAULZSS_COMP_CTXT@@@Z PROC		; InputBit

; 402  : {

	push	ebp
	mov	ebp, esp

; 403  :     ctxt->inc_input_string=0;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+53300], 0

; 404  :     if ( ctxt->FlagBitMask == 0x100 ) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+53280], 256		; 00000100H
	jne	SHORT $LN1@InputBit

; 405  :         InitInputBuffer(input_string,ctxt);										/**/

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	mov	eax, DWORD PTR _input_string$[ebp]
	push	eax
	call	?InitInputBuffer@@YAXPAEPAULZSS_COMP_CTXT@@@Z ; InitInputBuffer
	add	esp, 8

; 406  :         ctxt->inc_input_string=1;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+53300], 1
$LN1@InputBit:

; 407  :         }
; 408  :     ctxt->FlagBitMask <<= 1;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+53280]
	shl	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+53280], eax

; 409  :     return( ctxt->DataBuffer[ 0 ] & ( ctxt->FlagBitMask >> 1 ) );

	mov	edx, 1
	imul	edx, 0
	mov	eax, DWORD PTR _ctxt$[ebp]
	movzx	eax, BYTE PTR [eax+edx+53260]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+53280]
	sar	edx, 1
	and	eax, edx

; 410  : }

	pop	ebp
	ret	0
?InputBit@@YAHPAEPAULZSS_COMP_CTXT@@@Z ENDP		; InputBit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\utils\lzss.cpp
_TEXT	SEGMENT
_input_string$ = 8					; size = 4
_ctxt$ = 12						; size = 4
?InitInputBuffer@@YAXPAEPAULZSS_COMP_CTXT@@@Z PROC	; InitInputBuffer

; 389  : {

	push	ebp
	mov	ebp, esp

; 390  :     ctxt->FlagBitMask = 1;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+53280], 1

; 391  :     ctxt->DataBuffer[ 0 ] = *input_string;										/**/

	mov	ecx, 1
	imul	ecx, 0
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _input_string$[ebp]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [edx+ecx+53260], al

; 392  : }

	pop	ebp
	ret	0
?InitInputBuffer@@YAXPAEPAULZSS_COMP_CTXT@@@Z ENDP	; InitInputBuffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\utils\lzss.cpp
_TEXT	SEGMENT
_position$ = 8						; size = 4
_length$ = 12						; size = 4
_output_string$ = 16					; size = 4
_ctxt$ = 20						; size = 4
?OutputPair@@YAHHHPAEPAULZSS_COMP_CTXT@@@Z PROC		; OutputPair

; 364  : {

	push	ebp
	mov	ebp, esp

; 365  :     ctxt->DataBuffer[ ctxt->BufferOffset ] = (uchar) ( length << 4 );

	mov	eax, DWORD PTR _length$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+53284]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	BYTE PTR [ecx+edx+53260], al

; 366  :     ctxt->DataBuffer[ ctxt->BufferOffset++ ] |= ( position >> 8 );

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+53284]
	mov	ecx, DWORD PTR _position$[ebp]
	sar	ecx, 8
	mov	edx, DWORD PTR _ctxt$[ebp]
	movzx	eax, BYTE PTR [edx+eax+53260]
	or	eax, ecx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+53284]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	BYTE PTR [ecx+edx+53260], al
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+53284]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+53284], eax

; 367  :     ctxt->DataBuffer[ ctxt->BufferOffset++ ] = (uchar) ( position & 0xff );

	mov	edx, DWORD PTR _position$[ebp]
	and	edx, 255				; 000000ffH
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+53284]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	BYTE PTR [eax+ecx+53260], dl
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+53284]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+53284], edx

; 368  :     ctxt->FlagBitMask <<= 1;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+53280]
	shl	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+53280], edx

; 369  :     ctxt->inc_output_string=0;                                /**/

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+53304], 0

; 370  :     if ( ctxt->FlagBitMask == 0x100 ){

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+53280], 256		; 00000100H
	jne	SHORT $LN2@OutputPair

; 371  :         ctxt->inc_output_string=1;                            /**/

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+53304], 1

; 372  :         return( FlushOutputBuffer(output_string,ctxt) );

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _output_string$[ebp]
	push	edx
	call	?FlushOutputBuffer@@YAHPAEPAULZSS_COMP_CTXT@@@Z ; FlushOutputBuffer
	add	esp, 8
	jmp	SHORT $LN3@OutputPair

; 373  :     } else

	jmp	SHORT $LN3@OutputPair
$LN2@OutputPair:

; 374  :         return( 1 );

	mov	eax, 1
$LN3@OutputPair:

; 375  : }

	pop	ebp
	ret	0
?OutputPair@@YAHHHPAEPAULZSS_COMP_CTXT@@@Z ENDP		; OutputPair
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\utils\lzss.cpp
_TEXT	SEGMENT
_data$ = 8						; size = 4
_output_string$ = 12					; size = 4
_ctxt$ = 16						; size = 4
?OutputChar@@YAHHPAEPAULZSS_COMP_CTXT@@@Z PROC		; OutputChar

; 337  : {

	push	ebp
	mov	ebp, esp

; 338  :     ctxt->DataBuffer[ ctxt->BufferOffset++ ] = (uchar) data;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+53284]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	al, BYTE PTR _data$[ebp]
	mov	BYTE PTR [edx+ecx+53260], al
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+53284]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+53284], edx

; 339  :     ctxt->DataBuffer[ 0 ] |= ctxt->FlagBitMask;

	mov	ecx, 1
	imul	ecx, 0
	mov	edx, DWORD PTR _ctxt$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+53260]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	or	eax, DWORD PTR [ecx+53280]
	mov	edx, 1
	imul	edx, 0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	BYTE PTR [ecx+edx+53260], al

; 340  :     ctxt->FlagBitMask <<= 1;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+53280]
	shl	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+53280], eax

; 341  :     ctxt->inc_output_string=0;                                /**/

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+53304], 0

; 342  :     if ( ctxt->FlagBitMask == 0x100 ){

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+53280], 256		; 00000100H
	jne	SHORT $LN2@OutputChar

; 343  :         ctxt->inc_output_string=1;                            /**/

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+53304], 1

; 344  :         return( FlushOutputBuffer(output_string,ctxt) );

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	mov	eax, DWORD PTR _output_string$[ebp]
	push	eax
	call	?FlushOutputBuffer@@YAHPAEPAULZSS_COMP_CTXT@@@Z ; FlushOutputBuffer
	add	esp, 8
	jmp	SHORT $LN3@OutputChar

; 345  :     } else

	jmp	SHORT $LN3@OutputChar
$LN2@OutputChar:

; 346  :         return( 1 );

	mov	eax, 1
$LN3@OutputChar:

; 347  : }

	pop	ebp
	ret	0
?OutputChar@@YAHHPAEPAULZSS_COMP_CTXT@@@Z ENDP		; OutputChar
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\utils\lzss.cpp
_TEXT	SEGMENT
_output_string$ = 8					; size = 4
_ctxt$ = 12						; size = 4
?FlushOutputBuffer@@YAHPAEPAULZSS_COMP_CTXT@@@Z PROC	; FlushOutputBuffer

; 316  : {

	push	ebp
	mov	ebp, esp

; 317  :     if ( ctxt->BufferOffset == 1 )

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+53284], 1
	jne	SHORT $LN1@FlushOutpu

; 318  :         return( 1 );

	mov	eax, 1
	jmp	SHORT $LN2@FlushOutpu
$LN1@FlushOutpu:

; 319  :     memcpy( output_string, ctxt->DataBuffer, ctxt->BufferOffset ) ;         /**/

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+53284]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	add	eax, 53260				; 0000d00cH
	push	eax
	mov	ecx, DWORD PTR _output_string$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 320  :     ctxt->compressed_size += ctxt->BufferOffset;                            /**/

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+53296]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	add	eax, DWORD PTR [ecx+53284]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+53296], eax

; 321  :     InitOutputBuffer(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	?InitOutputBuffer@@YAXPAULZSS_COMP_CTXT@@@Z ; InitOutputBuffer
	add	esp, 4

; 322  :     return( 1 );

	mov	eax, 1
$LN2@FlushOutpu:

; 323  : }

	pop	ebp
	ret	0
?FlushOutputBuffer@@YAHPAEPAULZSS_COMP_CTXT@@@Z ENDP	; FlushOutputBuffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\utils\lzss.cpp
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
?InitOutputBuffer@@YAXPAULZSS_COMP_CTXT@@@Z PROC	; InitOutputBuffer

; 291  : {

	push	ebp
	mov	ebp, esp

; 292  :     ctxt->DataBuffer[ 0 ] = 0;

	mov	eax, 1
	imul	eax, 0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	BYTE PTR [ecx+eax+53260], 0

; 293  :     ctxt->FlagBitMask = 1;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+53280], 1

; 294  :     ctxt->OldBufferOffset = ctxt->BufferOffset ;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+53284]
	mov	DWORD PTR [eax+53288], edx

; 295  :     ctxt->BufferOffset = 1;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+53284], 1

; 296  : }

	pop	ebp
	ret	0
?InitOutputBuffer@@YAXPAULZSS_COMP_CTXT@@@Z ENDP	; InitOutputBuffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\utils\lzss.cpp
_TEXT	SEGMENT
_delta$ = -20						; size = 4
_child$ = -16						; size = 4
_match_length$ = -12					; size = 4
_test_node$ = -8					; size = 4
_i$ = -4						; size = 4
_new_node$ = 8						; size = 4
_match_position$ = 12					; size = 4
_ctxt$ = 16						; size = 4
?AddString@@YAHHPAHPAULZSS_COMP_CTXT@@@Z PROC		; AddString

; 221  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 222  :     int i=0;

	mov	DWORD PTR _i$[ebp], 0

; 223  :     int test_node=0;

	mov	DWORD PTR _test_node$[ebp], 0

; 224  :     int delta=0;

	mov	DWORD PTR _delta$[ebp], 0

; 225  :     int match_length=0;

	mov	DWORD PTR _match_length$[ebp], 0

; 226  :     int *child=NULL;

	mov	DWORD PTR _child$[ebp], 0

; 227  : 
; 228  :     if ( new_node == END_OF_STREAM )

	cmp	DWORD PTR _new_node$[ebp], 0
	jne	SHORT $LN12@AddString

; 229  :         return( 0 );

	xor	eax, eax
	jmp	$LN13@AddString
$LN12@AddString:

; 230  :     test_node = ctxt->tree[ TREE_ROOT ].larger_child;

	mov	eax, 12					; 0000000cH
	shl	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+eax+4104]
	mov	DWORD PTR _test_node$[ebp], edx

; 231  :     match_length = 0;

	mov	DWORD PTR _match_length$[ebp], 0
$LN11@AddString:

; 232  :     for ( ; ; ) {
; 233  :         for ( i = 0 ; i < LOOK_AHEAD_SIZE ; i++ ) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN9@AddString
$LN8@AddString:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN9@AddString:
	cmp	DWORD PTR _i$[ebp], 17			; 00000011H
	jge	SHORT $LN7@AddString

; 234  :             delta = ctxt->window[ MOD_WINDOW( new_node + i ) ] -
; 235  :                     ctxt->window[ MOD_WINDOW( test_node + i ) ];

	mov	ecx, DWORD PTR _new_node$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	and	ecx, 4095				; 00000fffH
	mov	edx, DWORD PTR _ctxt$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	ecx, DWORD PTR _test_node$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	and	ecx, 4095				; 00000fffH
	mov	edx, DWORD PTR _ctxt$[ebp]
	movzx	ecx, BYTE PTR [edx+ecx]
	sub	eax, ecx
	mov	DWORD PTR _delta$[ebp], eax

; 236  :             if ( delta != 0 )

	je	SHORT $LN6@AddString

; 237  :                 break;

	jmp	SHORT $LN7@AddString
$LN6@AddString:

; 238  :         }

	jmp	SHORT $LN8@AddString
$LN7@AddString:

; 239  :         if ( i >= match_length ) {

	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _match_length$[ebp]
	jl	SHORT $LN5@AddString

; 240  :             match_length = i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _match_length$[ebp], eax

; 241  :             *match_position = test_node;

	mov	ecx, DWORD PTR _match_position$[ebp]
	mov	edx, DWORD PTR _test_node$[ebp]
	mov	DWORD PTR [ecx], edx

; 242  :             if ( match_length >= LOOK_AHEAD_SIZE ) {

	cmp	DWORD PTR _match_length$[ebp], 17	; 00000011H
	jl	SHORT $LN5@AddString

; 243  :                 ReplaceNode( test_node, new_node, ctxt );

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _new_node$[ebp]
	push	ecx
	mov	edx, DWORD PTR _test_node$[ebp]
	push	edx
	call	?ReplaceNode@@YAXHHPAULZSS_COMP_CTXT@@@Z ; ReplaceNode
	add	esp, 12					; 0000000cH

; 244  :                 return( match_length );

	mov	eax, DWORD PTR _match_length$[ebp]
	jmp	$LN13@AddString
$LN5@AddString:

; 245  :             }
; 246  :         }
; 247  :         if ( delta >= 0 )

	cmp	DWORD PTR _delta$[ebp], 0
	jl	SHORT $LN3@AddString

; 248  :             child = &ctxt->tree[ test_node ].larger_child;

	mov	eax, DWORD PTR _test_node$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	lea	edx, DWORD PTR [ecx+eax+4104]
	mov	DWORD PTR _child$[ebp], edx

; 249  :         else

	jmp	SHORT $LN2@AddString
$LN3@AddString:

; 250  :             child = &ctxt->tree[ test_node ].smaller_child;

	mov	eax, DWORD PTR _test_node$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	lea	edx, DWORD PTR [ecx+eax+4100]
	mov	DWORD PTR _child$[ebp], edx
$LN2@AddString:

; 251  :         if ( *child == UNUSED ) {

	mov	eax, DWORD PTR _child$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN1@AddString

; 252  :             *child = new_node;

	mov	ecx, DWORD PTR _child$[ebp]
	mov	edx, DWORD PTR _new_node$[ebp]
	mov	DWORD PTR [ecx], edx

; 253  :             ctxt->tree[ new_node ].parent = test_node;

	mov	eax, DWORD PTR _new_node$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _test_node$[ebp]
	mov	DWORD PTR [ecx+eax+4096], edx

; 254  :             ctxt->tree[ new_node ].larger_child = UNUSED;

	mov	eax, DWORD PTR _new_node$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+eax+4104], 0

; 255  :             ctxt->tree[ new_node ].smaller_child = UNUSED;

	mov	edx, DWORD PTR _new_node$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+edx+4100], 0

; 256  :             return( match_length );

	mov	eax, DWORD PTR _match_length$[ebp]
	jmp	SHORT $LN13@AddString
$LN1@AddString:

; 257  :         }
; 258  :         test_node = *child;

	mov	ecx, DWORD PTR _child$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _test_node$[ebp], edx

; 259  :     }

	jmp	$LN11@AddString
$LN13@AddString:

; 260  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AddString@@YAHHPAHPAULZSS_COMP_CTXT@@@Z ENDP		; AddString
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\utils\lzss.cpp
_TEXT	SEGMENT
_replacement$ = -4					; size = 4
_p$ = 8							; size = 4
_ctxt$ = 12						; size = 4
?DeleteString@@YAXHPAULZSS_COMP_CTXT@@@Z PROC		; DeleteString

; 195  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 196  :     int  replacement;
; 197  : 
; 198  :     if ( ctxt->tree[ p ].parent == UNUSED )

	mov	eax, DWORD PTR _p$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+eax+4096], 0
	jne	SHORT $LN5@DeleteStri

; 199  :         return;

	jmp	$LN6@DeleteStri
$LN5@DeleteStri:

; 200  :     if ( ctxt->tree[ p ].larger_child == UNUSED )

	mov	edx, DWORD PTR _p$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+edx+4104], 0
	jne	SHORT $LN4@DeleteStri

; 201  :         ContractNode( p, ctxt->tree[ p ].smaller_child, ctxt );

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+edx+4100]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	call	?ContractNode@@YAXHHPAULZSS_COMP_CTXT@@@Z ; ContractNode
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN6@DeleteStri
$LN4@DeleteStri:

; 202  :     else if ( ctxt->tree[ p ].smaller_child == UNUSED )

	mov	eax, DWORD PTR _p$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+eax+4100], 0
	jne	SHORT $LN2@DeleteStri

; 203  :         ContractNode( p, ctxt->tree[ p ].larger_child, ctxt );

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	mov	eax, DWORD PTR _p$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+eax+4104]
	push	edx
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	?ContractNode@@YAXHHPAULZSS_COMP_CTXT@@@Z ; ContractNode
	add	esp, 12					; 0000000cH

; 204  :     else {

	jmp	SHORT $LN6@DeleteStri
$LN2@DeleteStri:

; 205  :         replacement = FindNextNode( p, ctxt );

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	call	?FindNextNode@@YAHHPAULZSS_COMP_CTXT@@@Z ; FindNextNode
	add	esp, 8
	mov	DWORD PTR _replacement$[ebp], eax

; 206  :         DeleteString( replacement, ctxt );

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _replacement$[ebp]
	push	ecx
	call	?DeleteString@@YAXHPAULZSS_COMP_CTXT@@@Z ; DeleteString
	add	esp, 8

; 207  :         ReplaceNode( p, replacement, ctxt );

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	mov	eax, DWORD PTR _replacement$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	?ReplaceNode@@YAXHHPAULZSS_COMP_CTXT@@@Z ; ReplaceNode
	add	esp, 12					; 0000000cH
$LN6@DeleteStri:

; 208  :     }
; 209  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DeleteString@@YAXHPAULZSS_COMP_CTXT@@@Z ENDP		; DeleteString
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\utils\lzss.cpp
_TEXT	SEGMENT
_next$ = -4						; size = 4
_node$ = 8						; size = 4
_ctxt$ = 12						; size = 4
?FindNextNode@@YAHHPAULZSS_COMP_CTXT@@@Z PROC		; FindNextNode

; 177  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 178  :     int next;
; 179  : 
; 180  :     next = ctxt->tree[ node ].smaller_child;

	mov	eax, DWORD PTR _node$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+eax+4100]
	mov	DWORD PTR _next$[ebp], edx
$LN2@FindNextNo:

; 181  :     while ( ctxt->tree[ next ].larger_child != UNUSED )

	mov	eax, DWORD PTR _next$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+eax+4104], 0
	je	SHORT $LN1@FindNextNo

; 182  :         next = ctxt->tree[ next ].larger_child;

	mov	edx, DWORD PTR _next$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+edx+4104]
	mov	DWORD PTR _next$[ebp], ecx
	jmp	SHORT $LN2@FindNextNo
$LN1@FindNextNo:

; 183  :     return( next );

	mov	eax, DWORD PTR _next$[ebp]

; 184  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FindNextNode@@YAHHPAULZSS_COMP_CTXT@@@Z ENDP		; FindNextNode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\utils\lzss.cpp
_TEXT	SEGMENT
_parent$ = -4						; size = 4
_old_node$ = 8						; size = 4
_new_node$ = 12						; size = 4
_ctxt$ = 16						; size = 4
?ReplaceNode@@YAXHHPAULZSS_COMP_CTXT@@@Z PROC		; ReplaceNode

; 156  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 157  :     int parent;
; 158  : 
; 159  :     parent = ctxt->tree[ old_node ].parent;

	mov	eax, DWORD PTR _old_node$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+eax+4096]
	mov	DWORD PTR _parent$[ebp], edx

; 160  :     if ( ctxt->tree[ parent ].smaller_child == old_node )

	mov	eax, DWORD PTR _parent$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+eax+4100]
	cmp	edx, DWORD PTR _old_node$[ebp]
	jne	SHORT $LN2@ReplaceNod

; 161  :         ctxt->tree[ parent ].smaller_child = new_node;

	mov	eax, DWORD PTR _parent$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _new_node$[ebp]
	mov	DWORD PTR [ecx+eax+4100], edx

; 162  :     else

	jmp	SHORT $LN1@ReplaceNod
$LN2@ReplaceNod:

; 163  :         ctxt->tree[ parent ].larger_child = new_node;

	mov	eax, DWORD PTR _parent$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _new_node$[ebp]
	mov	DWORD PTR [ecx+eax+4104], edx
$LN1@ReplaceNod:

; 164  :     ctxt->tree[ new_node ] = ctxt->tree[ old_node ];

	mov	eax, DWORD PTR _old_node$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	lea	edx, DWORD PTR [ecx+eax+4096]
	mov	eax, DWORD PTR _new_node$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	lea	eax, DWORD PTR [ecx+eax+4096]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx

; 165  :     ctxt->tree[ ctxt->tree[ new_node ].smaller_child ].parent = new_node;

	mov	eax, DWORD PTR _new_node$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+eax+4100]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _new_node$[ebp]
	mov	DWORD PTR [eax+edx+4096], ecx

; 166  :     ctxt->tree[ ctxt->tree[ new_node ].larger_child ].parent = new_node;

	mov	edx, DWORD PTR _new_node$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+edx+4104]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _new_node$[ebp]
	mov	DWORD PTR [edx+ecx+4096], eax

; 167  :     ctxt->tree[ old_node ].parent = UNUSED;

	mov	ecx, DWORD PTR _old_node$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+ecx+4096], 0

; 168  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ReplaceNode@@YAXHHPAULZSS_COMP_CTXT@@@Z ENDP		; ReplaceNode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\utils\lzss.cpp
_TEXT	SEGMENT
_old_node$ = 8						; size = 4
_new_node$ = 12						; size = 4
_ctxt$ = 16						; size = 4
?ContractNode@@YAXHHPAULZSS_COMP_CTXT@@@Z PROC		; ContractNode

; 141  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 142  :     ctxt->tree[ new_node ].parent = ctxt->tree[ old_node ].parent;

	mov	eax, DWORD PTR _old_node$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _new_node$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [esi+eax+4096]
	mov	DWORD PTR [edx+ecx+4096], eax

; 143  :     if ( ctxt->tree[ ctxt->tree[ old_node ].parent ].larger_child == old_node )

	mov	ecx, DWORD PTR _old_node$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+ecx+4096]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+eax+4104]
	cmp	edx, DWORD PTR _old_node$[ebp]
	jne	SHORT $LN2@ContractNo

; 144  :         ctxt->tree[ ctxt->tree[ old_node ].parent ].larger_child = new_node;

	mov	eax, DWORD PTR _old_node$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+eax+4096]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _new_node$[ebp]
	mov	DWORD PTR [eax+edx+4104], ecx

; 145  :     else

	jmp	SHORT $LN1@ContractNo
$LN2@ContractNo:

; 146  :         ctxt->tree[ ctxt->tree[ old_node ].parent ].smaller_child = new_node;

	mov	edx, DWORD PTR _old_node$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+edx+4096]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _new_node$[ebp]
	mov	DWORD PTR [edx+ecx+4100], eax
$LN1@ContractNo:

; 147  :     ctxt->tree[ old_node ].parent = UNUSED;

	mov	ecx, DWORD PTR _old_node$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+ecx+4096], 0

; 148  : }

	pop	esi
	pop	ebp
	ret	0
?ContractNode@@YAXHHPAULZSS_COMP_CTXT@@@Z ENDP		; ContractNode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\utils\lzss.cpp
_TEXT	SEGMENT
_i$ = -4						; size = 4
_r$ = 8							; size = 4
_ctxt$ = 12						; size = 4
?InitTree@@YAXHPAULZSS_COMP_CTXT@@@Z PROC		; InitTree

; 121  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 122  :     int i;
; 123  : 
; 124  :     for ( i = 0 ; i < ( WINDOW_SIZE + 1 ) ; i++ ) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@InitTree
$LN2@InitTree:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@InitTree:
	cmp	DWORD PTR _i$[ebp], 4097		; 00001001H
	jge	SHORT $LN1@InitTree

; 125  :         ctxt->tree[ i ].parent = UNUSED;

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+ecx+4096], 0

; 126  :         ctxt->tree[ i ].larger_child = UNUSED;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+eax+4104], 0

; 127  :         ctxt->tree[ i ].smaller_child = UNUSED;

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+edx+4100], 0

; 128  :     }

	jmp	SHORT $LN2@InitTree
$LN1@InitTree:

; 129  :     ctxt->tree[ TREE_ROOT ].larger_child = r;

	mov	ecx, 12					; 0000000cH
	shl	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _r$[ebp]
	mov	DWORD PTR [edx+ecx+4104], eax

; 130  :     ctxt->tree[ r ].parent = TREE_ROOT;

	mov	ecx, DWORD PTR _r$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+ecx+4096], 4096		; 00001000H

; 131  :     ctxt->tree[ r ].larger_child = UNUSED;

	mov	eax, DWORD PTR _r$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+eax+4104], 0

; 132  :     ctxt->tree[ r ].smaller_child = UNUSED;

	mov	edx, DWORD PTR _r$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+edx+4100], 0

; 133  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?InitTree@@YAXHPAULZSS_COMP_CTXT@@@Z ENDP		; InitTree
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\utils\lzss.cpp
_TEXT	SEGMENT
_inputHead$ = -53340					; size = 4
_input_count$ = -53336					; size = 4
_match_position$ = -53332				; size = 4
_i$ = -53328						; size = 4
_current_position$ = -53324				; size = 4
_match_length$ = -53320					; size = 4
_c$ = -53313						; size = 1
_ctxt$ = -53312						; size = 53308
__$ArrayPad$ = -4					; size = 4
_input_string$ = 8					; size = 4
_srcSize$ = 12						; size = 4
_output_string$ = 16					; size = 4
_size$ = 20						; size = 4
_LZSS_Expand PROC

; 537  : int LZSS_Expand (uchar *input_string, int srcSize, uchar *output_string, int size) {

	push	ebp
	mov	ebp, esp
	mov	eax, 53340				; 0000d05cH
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 538  : 	int i;
; 539  : 	int current_position;
; 540  : 	uchar c;
; 541  : 	int match_length;
; 542  : 	int match_position;
; 543  : 	unsigned long input_count;
; 544  : 	uchar *inputHead;
; 545  : 	LZSS_COMP_CTXT ctxt;
; 546  : 
; 547  : 	if (size <= 0){

	cmp	DWORD PTR _size$[ebp], 0
	jg	SHORT $LN12@LZSS_Expan

; 548  : 		return -1;

	or	eax, -1
	jmp	$LN13@LZSS_Expan
$LN12@LZSS_Expan:

; 549  : 	}
; 550  : 	
; 551  : 	inputHead=input_string;

	mov	eax, DWORD PTR _input_string$[ebp]
	mov	DWORD PTR _inputHead$[ebp], eax

; 552  : 
; 553  : 	
; 554  : 	InitInputBuffer(input_string, &ctxt);               /**/

	lea	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _input_string$[ebp]
	push	edx
	call	?InitInputBuffer@@YAXPAEPAULZSS_COMP_CTXT@@@Z ; InitInputBuffer
	add	esp, 8

; 555  : 	CHSZ(srcSize, 1);	
; 556  : 	input_string++;                                     /**/

	mov	eax, DWORD PTR _input_string$[ebp]
	add	eax, 1
	mov	DWORD PTR _input_string$[ebp], eax

; 557  : 	current_position = 1;

	mov	DWORD PTR _current_position$[ebp], 1
$LN11@LZSS_Expan:

; 558  : 
; 559  : 	// While we still have room in the output buffer
; 560  : 	//sfr: added check for source also
; 561  : 	while ( size  /*&& srcSize*/) {

	cmp	DWORD PTR _size$[ebp], 0
	je	$LN10@LZSS_Expan

; 562  : 		CHSZ(srcSize, 1);
; 563  : 		if ( InputBit(input_string, &ctxt) ) {

	lea	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _input_string$[ebp]
	push	edx
	call	?InputBit@@YAHPAEPAULZSS_COMP_CTXT@@@Z	; InputBit
	add	esp, 8
	test	eax, eax
	je	SHORT $LN9@LZSS_Expan

; 564  : 			// We're going to write a single characters
; 565  : 
; 566  : 			/* InputBit if calls InitInputBuffer, 
; 567  : 			   then increment input_string */
; 568  : 			if(ctxt.inc_input_string==1){                /**/

	cmp	DWORD PTR _ctxt$[ebp+53300], 1
	jne	SHORT $LN8@LZSS_Expan

; 569  : 				CHSZ(srcSize, 1);
; 570  : 				input_string++;                         /**/

	mov	eax, DWORD PTR _input_string$[ebp]
	add	eax, 1
	mov	DWORD PTR _input_string$[ebp], eax
$LN8@LZSS_Expan:

; 571  : 			}
; 572  : 			c = *input_string;                          /**/

	mov	ecx, DWORD PTR _input_string$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _c$[ebp], dl

; 573  : 
; 574  : 			/* Exit Condition */
; 575  : 			//    if(c==0)                                  /**/
; 576  : 			//      break;                                  /**/
; 577  : 
; 578  : 			CHSZ(srcSize, 1);
; 579  : 			input_string++;                             /**/

	mov	eax, DWORD PTR _input_string$[ebp]
	add	eax, 1
	mov	DWORD PTR _input_string$[ebp], eax

; 580  : 			*output_string=c;                           /**/

	mov	ecx, DWORD PTR _output_string$[ebp]
	mov	dl, BYTE PTR _c$[ebp]
	mov	BYTE PTR [ecx], dl

; 581  : 			output_string++;                            /**/

	mov	eax, DWORD PTR _output_string$[ebp]
	add	eax, 1
	mov	DWORD PTR _output_string$[ebp], eax

; 582  : 			size--;

	mov	ecx, DWORD PTR _size$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _size$[ebp], ecx

; 583  : 			ctxt.window[ current_position ] = c;

	mov	edx, DWORD PTR _current_position$[ebp]
	mov	al, BYTE PTR _c$[ebp]
	mov	BYTE PTR _ctxt$[ebp+edx], al

; 584  : 			current_position = MOD_WINDOW( current_position + 1 );

	mov	ecx, DWORD PTR _current_position$[ebp]
	add	ecx, 1
	and	ecx, 4095				; 00000fffH
	mov	DWORD PTR _current_position$[ebp], ecx

; 585  : 		} else {

	jmp	$LN7@LZSS_Expan
$LN9@LZSS_Expan:

; 586  : 			// We're going to write a match from the code book
; 587  : 
; 588  : 			if(ctxt.inc_input_string==1){                /**/

	cmp	DWORD PTR _ctxt$[ebp+53300], 1
	jne	SHORT $LN6@LZSS_Expan

; 589  : 				CHSZ(srcSize, 1);
; 590  : 				input_string++;                         /**/

	mov	edx, DWORD PTR _input_string$[ebp]
	add	edx, 1
	mov	DWORD PTR _input_string$[ebp], edx
$LN6@LZSS_Expan:

; 591  : 			}
; 592  : 			match_length = *input_string;               /**/

	mov	eax, DWORD PTR _input_string$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _match_length$[ebp], ecx

; 593  : 			CHSZ(srcSize, 1);
; 594  : 			input_string++;                             /**/

	mov	edx, DWORD PTR _input_string$[ebp]
	add	edx, 1
	mov	DWORD PTR _input_string$[ebp], edx

; 595  : 			match_position = *input_string;             /**/

	mov	eax, DWORD PTR _input_string$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _match_position$[ebp], ecx

; 596  : 			CHSZ(srcSize, 1);
; 597  : 			input_string++;                             /**/

	mov	edx, DWORD PTR _input_string$[ebp]
	add	edx, 1
	mov	DWORD PTR _input_string$[ebp], edx

; 598  : 			match_position |= ( match_length & 0xf ) << 8;

	mov	eax, DWORD PTR _match_length$[ebp]
	and	eax, 15					; 0000000fH
	shl	eax, 8
	or	eax, DWORD PTR _match_position$[ebp]
	mov	DWORD PTR _match_position$[ebp], eax

; 599  : 			match_length >>= 4;

	mov	ecx, DWORD PTR _match_length$[ebp]
	sar	ecx, 4
	mov	DWORD PTR _match_length$[ebp], ecx

; 600  : 			match_length += BREAK_EVEN;

	mov	edx, DWORD PTR _match_length$[ebp]
	add	edx, 1
	mov	DWORD PTR _match_length$[ebp], edx

; 601  : 
; 602  : 			// This if prevents us from overrunning the output buffer if the last
; 603  : 			// match we find is longer than the remaining space in the output buffer.
; 604  : 			// This might best be fixed in the Compression routine, but it was much
; 605  : 			// easier to do here, so...  SCR 11/11/98
; 606  : 			if (match_length < size) {

	mov	eax, DWORD PTR _match_length$[ebp]
	cmp	eax, DWORD PTR _size$[ebp]
	jge	SHORT $LN5@LZSS_Expan

; 607  : 				// Normal case
; 608  : 				size -= match_length + 1;

	mov	ecx, DWORD PTR _match_length$[ebp]
	add	ecx, 1
	mov	edx, DWORD PTR _size$[ebp]
	sub	edx, ecx
	mov	DWORD PTR _size$[ebp], edx

; 609  : 			} else {

	jmp	SHORT $LN4@LZSS_Expan
$LN5@LZSS_Expan:

; 610  : 				// End case
; 611  : 				size = 0;

	mov	DWORD PTR _size$[ebp], 0

; 612  : 				match_length = size-1;

	mov	eax, DWORD PTR _size$[ebp]
	sub	eax, 1
	mov	DWORD PTR _match_length$[ebp], eax
$LN4@LZSS_Expan:

; 613  : 			}
; 614  : 
; 615  : 			// Write the code word into the output buffer
; 616  : 			for ( i = 0 ; i <= match_length ; i++ ) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@LZSS_Expan
$LN2@LZSS_Expan:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN3@LZSS_Expan:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _match_length$[ebp]
	jg	SHORT $LN7@LZSS_Expan

; 617  : 				c = ctxt.window[ MOD_WINDOW( match_position + i ) ];

	mov	eax, DWORD PTR _match_position$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	and	eax, 4095				; 00000fffH
	mov	cl, BYTE PTR _ctxt$[ebp+eax]
	mov	BYTE PTR _c$[ebp], cl

; 618  : 				*output_string=c;

	mov	edx, DWORD PTR _output_string$[ebp]
	mov	al, BYTE PTR _c$[ebp]
	mov	BYTE PTR [edx], al

; 619  : 				output_string++;

	mov	ecx, DWORD PTR _output_string$[ebp]
	add	ecx, 1
	mov	DWORD PTR _output_string$[ebp], ecx

; 620  : 				ctxt.window[ current_position ] = c;

	mov	edx, DWORD PTR _current_position$[ebp]
	mov	al, BYTE PTR _c$[ebp]
	mov	BYTE PTR _ctxt$[ebp+edx], al

; 621  : 				current_position = MOD_WINDOW( current_position + 1 );

	mov	ecx, DWORD PTR _current_position$[ebp]
	add	ecx, 1
	and	ecx, 4095				; 00000fffH
	mov	DWORD PTR _current_position$[ebp], ecx

; 622  : 			}

	jmp	SHORT $LN2@LZSS_Expan
$LN7@LZSS_Expan:

; 623  : 		}
; 624  : 	}

	jmp	$LN11@LZSS_Expan
$LN10@LZSS_Expan:

; 625  : 	input_count=input_string-inputHead;

	mov	edx, DWORD PTR _input_string$[ebp]
	sub	edx, DWORD PTR _inputHead$[ebp]
	mov	DWORD PTR _input_count$[ebp], edx

; 626  : 	return( input_count);

	mov	eax, DWORD PTR _input_count$[ebp]
$LN13@LZSS_Expan:

; 627  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_LZSS_Expand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\utils\lzss.cpp
_TEXT	SEGMENT
_replace_count$ = -53340				; size = 4
_match_position$ = -53336				; size = 4
_match_length$ = -53332					; size = 4
_look_ahead_bytes$ = -53328				; size = 4
_current_position$ = -53324				; size = 4
_i$ = -53320						; size = 4
_c$ = -53313						; size = 1
_ctxt$ = -53312						; size = 53308
__$ArrayPad$ = -4					; size = 4
_input_string$ = 8					; size = 4
_output_string$ = 12					; size = 4
_size$ = 16						; size = 4
_LZSS_Compress PROC

; 448  : {

	push	ebp
	mov	ebp, esp
	mov	eax, 53340				; 0000d05cH
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 449  :     int i;
; 450  :     uchar c;
; 451  :     int look_ahead_bytes;
; 452  :     int current_position;
; 453  :     int replace_count;
; 454  :     int match_length;
; 455  :     int match_position;
; 456  : 	LZSS_COMP_CTXT ctxt;
; 457  : 	
; 458  : 	// OW
; 459  : 	memset(&ctxt, 0, sizeof(ctxt));

	push	53308					; 0000d03cH
	push	0
	lea	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 460  : 
; 461  :     ctxt.compressed_size = 0;                                /**/

	mov	DWORD PTR _ctxt$[ebp+53296], 0

; 462  :     ctxt.original_size = size;                               /**/

	mov	ecx, DWORD PTR _size$[ebp]
	mov	DWORD PTR _ctxt$[ebp+53292], ecx

; 463  :     InitOutputBuffer(&ctxt);

	lea	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	?InitOutputBuffer@@YAXPAULZSS_COMP_CTXT@@@Z ; InitOutputBuffer
	add	esp, 4

; 464  : 
; 465  :     current_position = 1;

	mov	DWORD PTR _current_position$[ebp], 1

; 466  :     for ( i = 0 ; i < LOOK_AHEAD_SIZE ; i++ ) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN20@LZSS_Compr
$LN19@LZSS_Compr:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN20@LZSS_Compr:
	cmp	DWORD PTR _i$[ebp], 17			; 00000011H
	jge	SHORT $LN18@LZSS_Compr

; 467  :         c=*input_string;                                /**/

	mov	ecx, DWORD PTR _input_string$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _c$[ebp], dl

; 468  :         input_string++;                                 /**/

	mov	eax, DWORD PTR _input_string$[ebp]
	add	eax, 1
	mov	DWORD PTR _input_string$[ebp], eax

; 469  :         size--;                                         /**/

	mov	ecx, DWORD PTR _size$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _size$[ebp], ecx

; 470  :         if ( size<0)                                    /**/

	jns	SHORT $LN17@LZSS_Compr

; 471  :             break;

	jmp	SHORT $LN18@LZSS_Compr
$LN17@LZSS_Compr:

; 472  :         ctxt.window[ current_position + i ] = c;

	mov	edx, DWORD PTR _current_position$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	mov	al, BYTE PTR _c$[ebp]
	mov	BYTE PTR _ctxt$[ebp+edx], al

; 473  :     }

	jmp	SHORT $LN19@LZSS_Compr
$LN18@LZSS_Compr:

; 474  :     look_ahead_bytes = i;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _look_ahead_bytes$[ebp], ecx

; 475  :     InitTree( current_position, &ctxt );

	lea	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	mov	eax, DWORD PTR _current_position$[ebp]
	push	eax
	call	?InitTree@@YAXHPAULZSS_COMP_CTXT@@@Z	; InitTree
	add	esp, 8

; 476  :     match_length = 0;

	mov	DWORD PTR _match_length$[ebp], 0

; 477  :     match_position = 0;

	mov	DWORD PTR _match_position$[ebp], 0
$LN16@LZSS_Compr:

; 478  :     while ( look_ahead_bytes > 0 ) {

	cmp	DWORD PTR _look_ahead_bytes$[ebp], 0
	jle	$LN15@LZSS_Compr

; 479  :         if ( match_length > look_ahead_bytes ){

	mov	ecx, DWORD PTR _match_length$[ebp]
	cmp	ecx, DWORD PTR _look_ahead_bytes$[ebp]
	jle	SHORT $LN14@LZSS_Compr

; 480  :             match_length = look_ahead_bytes;

	mov	edx, DWORD PTR _look_ahead_bytes$[ebp]
	mov	DWORD PTR _match_length$[ebp], edx
$LN14@LZSS_Compr:

; 481  : 		}
; 482  :         if ( match_length <= BREAK_EVEN ) {

	cmp	DWORD PTR _match_length$[ebp], 1
	jg	SHORT $LN13@LZSS_Compr

; 483  :             replace_count = 1;

	mov	DWORD PTR _replace_count$[ebp], 1

; 484  :             if ( !OutputChar( ctxt.window[ current_position ], output_string, &ctxt ) ){

	lea	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _output_string$[ebp]
	push	ecx
	mov	edx, DWORD PTR _current_position$[ebp]
	movzx	eax, BYTE PTR _ctxt$[ebp+edx]
	push	eax
	call	?OutputChar@@YAHHPAEPAULZSS_COMP_CTXT@@@Z ; OutputChar
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN12@LZSS_Compr

; 485  :                 return( 0 );

	xor	eax, eax
	jmp	$LN21@LZSS_Compr
$LN12@LZSS_Compr:

; 486  : 			}
; 487  :             if(ctxt.inc_output_string){

	cmp	DWORD PTR _ctxt$[ebp+53304], 0
	je	SHORT $LN11@LZSS_Compr

; 488  :                 output_string+=ctxt.OldBufferOffset;

	mov	ecx, DWORD PTR _output_string$[ebp]
	add	ecx, DWORD PTR _ctxt$[ebp+53288]
	mov	DWORD PTR _output_string$[ebp], ecx
$LN11@LZSS_Compr:

; 489  : 			}
; 490  :         } else {

	jmp	SHORT $LN10@LZSS_Compr
$LN13@LZSS_Compr:

; 491  :             if ( !OutputPair( match_position, 
; 492  :                     match_length - ( BREAK_EVEN + 1 ), output_string, &ctxt ) ){

	lea	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	mov	eax, DWORD PTR _output_string$[ebp]
	push	eax
	mov	ecx, DWORD PTR _match_length$[ebp]
	sub	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _match_position$[ebp]
	push	edx
	call	?OutputPair@@YAHHHPAEPAULZSS_COMP_CTXT@@@Z ; OutputPair
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN9@LZSS_Compr

; 493  :                 return( 0 );

	xor	eax, eax
	jmp	$LN21@LZSS_Compr
$LN9@LZSS_Compr:

; 494  : 			}
; 495  :             if(ctxt.inc_output_string){

	cmp	DWORD PTR _ctxt$[ebp+53304], 0
	je	SHORT $LN8@LZSS_Compr

; 496  :                 output_string+=ctxt.OldBufferOffset;

	mov	eax, DWORD PTR _output_string$[ebp]
	add	eax, DWORD PTR _ctxt$[ebp+53288]
	mov	DWORD PTR _output_string$[ebp], eax
$LN8@LZSS_Compr:

; 497  : 			}
; 498  :             replace_count = match_length;

	mov	ecx, DWORD PTR _match_length$[ebp]
	mov	DWORD PTR _replace_count$[ebp], ecx
$LN10@LZSS_Compr:

; 499  :         }
; 500  :         for ( i = 0 ; i < replace_count ; i++ ) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@LZSS_Compr
$LN6@LZSS_Compr:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN7@LZSS_Compr:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _replace_count$[ebp]
	jge	$LN5@LZSS_Compr

; 501  :             DeleteString( MOD_WINDOW( current_position + LOOK_AHEAD_SIZE ), &ctxt );

	lea	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _current_position$[ebp]
	add	edx, 17					; 00000011H
	and	edx, 4095				; 00000fffH
	push	edx
	call	?DeleteString@@YAXHPAULZSS_COMP_CTXT@@@Z ; DeleteString
	add	esp, 8

; 502  :             c=*input_string;  		                    /**/

	mov	eax, DWORD PTR _input_string$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _c$[ebp], cl

; 503  :             size--;                                     /**/

	mov	edx, DWORD PTR _size$[ebp]
	sub	edx, 1
	mov	DWORD PTR _size$[ebp], edx

; 504  :             if ( size<0) {                              /**/

	jns	SHORT $LN4@LZSS_Compr

; 505  :                 look_ahead_bytes--;

	mov	eax, DWORD PTR _look_ahead_bytes$[ebp]
	sub	eax, 1
	mov	DWORD PTR _look_ahead_bytes$[ebp], eax

; 506  :             } else {

	jmp	SHORT $LN3@LZSS_Compr
$LN4@LZSS_Compr:

; 507  : 				//Only increment while the end of the input string 
; 508  : 				//hasn't been reached
; 509  : 	            input_string++;                             /**/

	mov	ecx, DWORD PTR _input_string$[ebp]
	add	ecx, 1
	mov	DWORD PTR _input_string$[ebp], ecx

; 510  : 
; 511  :                 ctxt.window[ MOD_WINDOW( current_position + LOOK_AHEAD_SIZE ) ] = c;

	mov	edx, DWORD PTR _current_position$[ebp]
	add	edx, 17					; 00000011H
	and	edx, 4095				; 00000fffH
	mov	al, BYTE PTR _c$[ebp]
	mov	BYTE PTR _ctxt$[ebp+edx], al
$LN3@LZSS_Compr:

; 512  :             }
; 513  :             current_position = MOD_WINDOW( current_position + 1 );

	mov	ecx, DWORD PTR _current_position$[ebp]
	add	ecx, 1
	and	ecx, 4095				; 00000fffH
	mov	DWORD PTR _current_position$[ebp], ecx

; 514  :             if ( look_ahead_bytes )

	cmp	DWORD PTR _look_ahead_bytes$[ebp], 0
	je	SHORT $LN2@LZSS_Compr

; 515  :                 match_length = AddString( current_position, &match_position, &ctxt );

	lea	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	lea	eax, DWORD PTR _match_position$[ebp]
	push	eax
	mov	ecx, DWORD PTR _current_position$[ebp]
	push	ecx
	call	?AddString@@YAHHPAHPAULZSS_COMP_CTXT@@@Z ; AddString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _match_length$[ebp], eax
$LN2@LZSS_Compr:

; 516  :         }

	jmp	$LN6@LZSS_Compr
$LN5@LZSS_Compr:

; 517  :     }

	jmp	$LN16@LZSS_Compr
$LN15@LZSS_Compr:

; 518  : 
; 519  : 
; 520  :     /* If the previous OutputChar or OutputPair call
; 521  :        didn't write to the output, do so now */
; 522  :     if(!ctxt.inc_output_string)

	cmp	DWORD PTR _ctxt$[ebp+53304], 0
	jne	SHORT $LN1@LZSS_Compr

; 523  :         FlushOutputBuffer(output_string, &ctxt);

	lea	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	mov	eax, DWORD PTR _output_string$[ebp]
	push	eax
	call	?FlushOutputBuffer@@YAHPAEPAULZSS_COMP_CTXT@@@Z ; FlushOutputBuffer
	add	esp, 8
$LN1@LZSS_Compr:

; 524  : 
; 525  :     return( ctxt.compressed_size );

	mov	eax, DWORD PTR _ctxt$[ebp+53296]
$LN21@LZSS_Compr:

; 526  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_LZSS_Compress ENDP
_TEXT	ENDS
END
