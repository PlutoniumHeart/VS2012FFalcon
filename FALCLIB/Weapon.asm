; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\FALCLIB\Weapon.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
PUBLIC	?GetWeaponStrength@@YAHH@Z			; GetWeaponStrength
PUBLIC	?GetWeaponRange@@YAHHH@Z			; GetWeaponRange
PUBLIC	?GetWeaponFireRate@@YAHH@Z			; GetWeaponFireRate
PUBLIC	?GetWeaponHitChance@@YAHHH@Z			; GetWeaponHitChance
PUBLIC	?GetWeaponHitChance@@YAHHHH@Z			; GetWeaponHitChance
PUBLIC	?GetWeaponHitChance@@YAHHHHH@Z			; GetWeaponHitChance
PUBLIC	?GetWeaponScore@@YAHHHH@Z			; GetWeaponScore
PUBLIC	?GetWeaponScore@@YAHHHHH@Z			; GetWeaponScore
PUBLIC	?GetWeaponScore@@YAHHPAEHH@Z			; GetWeaponScore
PUBLIC	?GetWeaponScore@@YAHHPAEHHH@Z			; GetWeaponScore
PUBLIC	?GetWeaponDamageType@@YAHH@Z			; GetWeaponDamageType
PUBLIC	?GetWeaponDescriptionIndex@@YAHH@Z		; GetWeaponDescriptionIndex
PUBLIC	?GetWeaponIdFromDescriptionIndex@@YAHH@Z	; GetWeaponIdFromDescriptionIndex
PUBLIC	?GetWeaponFlags@@YAHH@Z				; GetWeaponFlags
PUBLIC	?GetListEntryWeapon@@YAHHH@Z			; GetListEntryWeapon
PUBLIC	?GetListEntryWeapons@@YAHHH@Z			; GetListEntryWeapons
PUBLIC	?GetListName@@YAPADH@Z				; GetListName
PUBLIC	__real@3f000000
PUBLIC	__real@3f7d70a4
PUBLIC	__real@3f99999a
EXTRN	?WeaponDataTable@@3PAUWeaponClassDataType@@A:DWORD ; WeaponDataTable
EXTRN	?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A:DWORD ; Falcon4ClassTable
EXTRN	?WeaponListDataTable@@3PAUWeaponListDataType@@A:DWORD ; WeaponListDataTable
EXTRN	?LOWAIR_RANGE_MODIFIER@@3MA:DWORD		; LOWAIR_RANGE_MODIFIER
EXTRN	?NumWeaponTypes@@3FA:WORD			; NumWeaponTypes
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
_allocator_arg DB 01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __real@3f99999a
CONST	SEGMENT
__real@3f99999a DD 03f99999ar			; 1.2
CONST	ENDS
;	COMDAT __real@3f7d70a4
CONST	SEGMENT
__real@3f7d70a4 DD 03f7d70a4r			; 0.99
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\weapon.cpp
_TEXT	SEGMENT
_list$ = 8						; size = 4
?GetListName@@YAPADH@Z PROC				; GetListName

; 170  : {

	push	ebp
	mov	ebp, esp

; 171  :     ShiAssert(list>= 0 && list < NumWeaponTypes);
; 172  :     if(list< 0 || list >= NumWeaponTypes) return 0;

	cmp	DWORD PTR _list$[ebp], 0
	jl	SHORT $LN1@GetListNam
	movsx	eax, WORD PTR ?NumWeaponTypes@@3FA	; NumWeaponTypes
	cmp	DWORD PTR _list$[ebp], eax
	jl	SHORT $LN2@GetListNam
$LN1@GetListNam:
	xor	eax, eax
	jmp	SHORT $LN3@GetListNam
$LN2@GetListNam:

; 173  :     return WeaponListDataTable[list].Name;

	mov	eax, DWORD PTR _list$[ebp]
	imul	eax, 208				; 000000d0H
	add	eax, DWORD PTR ?WeaponListDataTable@@3PAUWeaponListDataType@@A ; WeaponListDataTable
$LN3@GetListNam:

; 174  : }

	pop	ebp
	ret	0
?GetListName@@YAPADH@Z ENDP				; GetListName
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\weapon.cpp
_TEXT	SEGMENT
_list$ = 8						; size = 4
_num$ = 12						; size = 4
?GetListEntryWeapons@@YAHHH@Z PROC			; GetListEntryWeapons

; 158  : {

	push	ebp
	mov	ebp, esp

; 159  :     ShiAssert(list>= 0 && list < NumWeaponTypes);
; 160  :     if(list< 0 || list >= NumWeaponTypes) return 0;

	cmp	DWORD PTR _list$[ebp], 0
	jl	SHORT $LN1@GetListEnt
	movsx	eax, WORD PTR ?NumWeaponTypes@@3FA	; NumWeaponTypes
	cmp	DWORD PTR _list$[ebp], eax
	jl	SHORT $LN2@GetListEnt
$LN1@GetListEnt:
	xor	eax, eax
	jmp	SHORT $LN3@GetListEnt
$LN2@GetListEnt:

; 161  : #ifdef DEBUG
; 162  :     // KCK HACK FOR BAD DATA
; 163  :     if (WeaponListDataTable[list].WeaponID[num] && !WeaponListDataTable[list].Quantity[num])
; 164  : 	return 1;
; 165  : #endif
; 166  :     return WeaponListDataTable[list].Quantity[num];

	mov	ecx, DWORD PTR _list$[ebp]
	imul	ecx, 208				; 000000d0H
	add	ecx, DWORD PTR ?WeaponListDataTable@@3PAUWeaponListDataType@@A ; WeaponListDataTable
	mov	edx, DWORD PTR _num$[ebp]
	movzx	eax, BYTE PTR [ecx+edx+144]
$LN3@GetListEnt:

; 167  : }

	pop	ebp
	ret	0
?GetListEntryWeapons@@YAHHH@Z ENDP			; GetListEntryWeapons
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\weapon.cpp
_TEXT	SEGMENT
_list$ = 8						; size = 4
_num$ = 12						; size = 4
?GetListEntryWeapon@@YAHHH@Z PROC			; GetListEntryWeapon

; 151  : {

	push	ebp
	mov	ebp, esp

; 152  :     ShiAssert(list>= 0 && list < NumWeaponTypes);
; 153  :     if(list< 0 || list >= NumWeaponTypes) return 0;

	cmp	DWORD PTR _list$[ebp], 0
	jl	SHORT $LN1@GetListEnt
	movsx	eax, WORD PTR ?NumWeaponTypes@@3FA	; NumWeaponTypes
	cmp	DWORD PTR _list$[ebp], eax
	jl	SHORT $LN2@GetListEnt
$LN1@GetListEnt:
	xor	eax, eax
	jmp	SHORT $LN3@GetListEnt
$LN2@GetListEnt:

; 154  :     return WeaponListDataTable[list].WeaponID[num];

	mov	ecx, DWORD PTR _list$[ebp]
	imul	ecx, 208				; 000000d0H
	add	ecx, DWORD PTR ?WeaponListDataTable@@3PAUWeaponListDataType@@A ; WeaponListDataTable
	mov	edx, DWORD PTR _num$[ebp]
	movsx	eax, WORD PTR [ecx+edx*2+16]
$LN3@GetListEnt:

; 155  : }

	pop	ebp
	ret	0
?GetListEntryWeapon@@YAHHH@Z ENDP			; GetListEntryWeapon
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\weapon.cpp
_TEXT	SEGMENT
_w$ = 8							; size = 4
?GetWeaponFlags@@YAHH@Z PROC				; GetWeaponFlags

; 140  : {

	push	ebp
	mov	ebp, esp

; 141  :     ShiAssert(w>= 0 && w < NumWeaponTypes);
; 142  :     if(w< 0 || w >= NumWeaponTypes) return 0;

	cmp	DWORD PTR _w$[ebp], 0
	jl	SHORT $LN1@GetWeaponF
	movsx	eax, WORD PTR ?NumWeaponTypes@@3FA	; NumWeaponTypes
	cmp	DWORD PTR _w$[ebp], eax
	jl	SHORT $LN2@GetWeaponF
$LN1@GetWeaponF:
	xor	eax, eax
	jmp	SHORT $LN3@GetWeaponF
$LN2@GetWeaponF:

; 143  :     return (int)(WeaponDataTable[w].Flags);

	mov	ecx, DWORD PTR _w$[ebp]
	imul	ecx, 60					; 0000003cH
	mov	edx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movzx	eax, WORD PTR [edx+ecx+10]
$LN3@GetWeaponF:

; 144  : }

	pop	ebp
	ret	0
?GetWeaponFlags@@YAHH@Z ENDP				; GetWeaponFlags
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\weapon.cpp
_TEXT	SEGMENT
_index$ = 8						; size = 4
?GetWeaponIdFromDescriptionIndex@@YAHH@Z PROC		; GetWeaponIdFromDescriptionIndex

; 135  : {

	push	ebp
	mov	ebp, esp

; 136  :     return ((int)Falcon4ClassTable[index].dataPtr - (int)WeaponDataTable) / sizeof(WeaponClassDataType);

	mov	eax, DWORD PTR _index$[ebp]
	imul	eax, 81					; 00000051H
	mov	ecx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	eax, DWORD PTR [ecx+eax+77]
	sub	eax, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	xor	edx, edx
	mov	ecx, 60					; 0000003cH
	div	ecx

; 137  : }

	pop	ebp
	ret	0
?GetWeaponIdFromDescriptionIndex@@YAHH@Z ENDP		; GetWeaponIdFromDescriptionIndex
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\weapon.cpp
_TEXT	SEGMENT
_w$ = 8							; size = 4
?GetWeaponDescriptionIndex@@YAHH@Z PROC			; GetWeaponDescriptionIndex

; 128  : {

	push	ebp
	mov	ebp, esp

; 129  :     ShiAssert(w>= 0 && w < NumWeaponTypes);
; 130  :     if(w< 0 || w >= NumWeaponTypes) return 0;

	cmp	DWORD PTR _w$[ebp], 0
	jl	SHORT $LN1@GetWeaponD
	movsx	eax, WORD PTR ?NumWeaponTypes@@3FA	; NumWeaponTypes
	cmp	DWORD PTR _w$[ebp], eax
	jl	SHORT $LN2@GetWeaponD
$LN1@GetWeaponD:
	xor	eax, eax
	jmp	SHORT $LN3@GetWeaponD
$LN2@GetWeaponD:

; 131  :     return (int)(WeaponDataTable[w].Index);

	mov	ecx, DWORD PTR _w$[ebp]
	imul	ecx, 60					; 0000003cH
	mov	edx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movsx	eax, WORD PTR [edx+ecx]
$LN3@GetWeaponD:

; 132  : }

	pop	ebp
	ret	0
?GetWeaponDescriptionIndex@@YAHH@Z ENDP			; GetWeaponDescriptionIndex
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\weapon.cpp
_TEXT	SEGMENT
_w$ = 8							; size = 4
?GetWeaponDamageType@@YAHH@Z PROC			; GetWeaponDamageType

; 121  : {

	push	ebp
	mov	ebp, esp

; 122  :     ShiAssert(w>= 0 && w < NumWeaponTypes);
; 123  :     if(w< 0 || w >= NumWeaponTypes) return 0;

	cmp	DWORD PTR _w$[ebp], 0
	jl	SHORT $LN1@GetWeaponD
	movsx	eax, WORD PTR ?NumWeaponTypes@@3FA	; NumWeaponTypes
	cmp	DWORD PTR _w$[ebp], eax
	jl	SHORT $LN2@GetWeaponD
$LN1@GetWeaponD:
	xor	eax, eax
	jmp	SHORT $LN3@GetWeaponD
$LN2@GetWeaponD:

; 124  :     return (int)(WeaponDataTable[w].DamageType);

	mov	ecx, DWORD PTR _w$[ebp]
	imul	ecx, 60					; 0000003cH
	mov	edx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	mov	eax, DWORD PTR [edx+ecx+4]
$LN3@GetWeaponD:

; 125  : }

	pop	ebp
	ret	0
?GetWeaponDamageType@@YAHH@Z ENDP			; GetWeaponDamageType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\weapon.cpp
_TEXT	SEGMENT
_w$ = 8							; size = 4
_dam$ = 12						; size = 4
_mt$ = 16						; size = 4
_range$ = 20						; size = 4
_wrange$ = 24						; size = 4
?GetWeaponScore@@YAHHPAEHHH@Z PROC			; GetWeaponScore

; 114  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 115  :     ShiAssert(w>= 0 && w < NumWeaponTypes);
; 116  :     if(w< 0 || w >= NumWeaponTypes) return 0;

	cmp	DWORD PTR _w$[ebp], 0
	jl	SHORT $LN1@GetWeaponS
	movsx	eax, WORD PTR ?NumWeaponTypes@@3FA	; NumWeaponTypes
	cmp	DWORD PTR _w$[ebp], eax
	jl	SHORT $LN2@GetWeaponS
$LN1@GetWeaponS:
	xor	eax, eax
	jmp	SHORT $LN3@GetWeaponS
$LN2@GetWeaponS:

; 117  :     return (WeaponDataTable[w].Strength * WeaponDataTable[w].FireRate * dam[WeaponDataTable[w].DamageType] * GetWeaponHitChance(w,mt,range, wrange))/100;

	mov	ecx, DWORD PTR _w$[ebp]
	imul	ecx, 60					; 0000003cH
	mov	edx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movzx	esi, WORD PTR [edx+ecx+2]
	mov	eax, DWORD PTR _w$[ebp]
	imul	eax, 60					; 0000003cH
	mov	ecx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movzx	edx, BYTE PTR [ecx+eax+40]
	imul	esi, edx
	mov	eax, DWORD PTR _w$[ebp]
	imul	eax, 60					; 0000003cH
	mov	ecx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	mov	edx, DWORD PTR [ecx+eax+4]
	mov	eax, DWORD PTR _dam$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	imul	esi, ecx
	mov	edx, DWORD PTR _wrange$[ebp]
	push	edx
	mov	eax, DWORD PTR _range$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _w$[ebp]
	push	edx
	call	?GetWeaponHitChance@@YAHHHHH@Z		; GetWeaponHitChance
	add	esp, 16					; 00000010H
	imul	eax, esi
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
$LN3@GetWeaponS:

; 118  : }

	pop	esi
	pop	ebp
	ret	0
?GetWeaponScore@@YAHHPAEHHH@Z ENDP			; GetWeaponScore
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\weapon.cpp
_TEXT	SEGMENT
_w$ = 8							; size = 4
_dam$ = 12						; size = 4
_mt$ = 16						; size = 4
_range$ = 20						; size = 4
?GetWeaponScore@@YAHHPAEHH@Z PROC			; GetWeaponScore

; 104  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 105  :     ShiAssert(w>= 0 && w < NumWeaponTypes);
; 106  :     if(w< 0 || w >= NumWeaponTypes) return 0;

	cmp	DWORD PTR _w$[ebp], 0
	jl	SHORT $LN2@GetWeaponS
	movsx	eax, WORD PTR ?NumWeaponTypes@@3FA	; NumWeaponTypes
	cmp	DWORD PTR _w$[ebp], eax
	jl	SHORT $LN3@GetWeaponS
$LN2@GetWeaponS:
	xor	eax, eax
	jmp	SHORT $LN4@GetWeaponS
$LN3@GetWeaponS:

; 107  :     if (GetWeaponRange(w, mt) < range)

	mov	ecx, DWORD PTR _mt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _w$[ebp]
	push	edx
	call	?GetWeaponRange@@YAHHH@Z		; GetWeaponRange
	add	esp, 8
	cmp	eax, DWORD PTR _range$[ebp]
	jge	SHORT $LN1@GetWeaponS

; 108  : 	return 0;

	xor	eax, eax
	jmp	SHORT $LN4@GetWeaponS
$LN1@GetWeaponS:

; 109  :     
; 110  :     return (WeaponDataTable[w].Strength * WeaponDataTable[w].FireRate * dam[WeaponDataTable[w].DamageType] * GetWeaponHitChance(w,mt,range))/100;

	mov	eax, DWORD PTR _w$[ebp]
	imul	eax, 60					; 0000003cH
	mov	ecx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movzx	esi, WORD PTR [ecx+eax+2]
	mov	edx, DWORD PTR _w$[ebp]
	imul	edx, 60					; 0000003cH
	mov	eax, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movzx	ecx, BYTE PTR [eax+edx+40]
	imul	esi, ecx
	mov	edx, DWORD PTR _w$[ebp]
	imul	edx, 60					; 0000003cH
	mov	eax, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	mov	ecx, DWORD PTR [eax+edx+4]
	mov	edx, DWORD PTR _dam$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	imul	esi, eax
	mov	ecx, DWORD PTR _range$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mt$[ebp]
	push	edx
	mov	eax, DWORD PTR _w$[ebp]
	push	eax
	call	?GetWeaponHitChance@@YAHHHH@Z		; GetWeaponHitChance
	add	esp, 12					; 0000000cH
	imul	eax, esi
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
$LN4@GetWeaponS:

; 111  : }

	pop	esi
	pop	ebp
	ret	0
?GetWeaponScore@@YAHHPAEHH@Z ENDP			; GetWeaponScore
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\weapon.cpp
_TEXT	SEGMENT
_w$ = 8							; size = 4
_mt$ = 12						; size = 4
_range$ = 16						; size = 4
_wrange$ = 20						; size = 4
?GetWeaponScore@@YAHHHHH@Z PROC				; GetWeaponScore

; 97   : {

	push	ebp
	mov	ebp, esp
	push	esi

; 98   :     ShiAssert(w>= 0 && w < NumWeaponTypes);
; 99   :     if(w< 0 || w >= NumWeaponTypes) return 0;

	cmp	DWORD PTR _w$[ebp], 0
	jl	SHORT $LN1@GetWeaponS
	movsx	eax, WORD PTR ?NumWeaponTypes@@3FA	; NumWeaponTypes
	cmp	DWORD PTR _w$[ebp], eax
	jl	SHORT $LN2@GetWeaponS
$LN1@GetWeaponS:
	xor	eax, eax
	jmp	SHORT $LN3@GetWeaponS
$LN2@GetWeaponS:

; 100  :     return (WeaponDataTable[w].Strength * WeaponDataTable[w].FireRate * GetWeaponHitChance(w,mt,range,wrange)) / 100;

	mov	ecx, DWORD PTR _w$[ebp]
	imul	ecx, 60					; 0000003cH
	mov	edx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movzx	esi, WORD PTR [edx+ecx+2]
	mov	eax, DWORD PTR _w$[ebp]
	imul	eax, 60					; 0000003cH
	mov	ecx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movzx	edx, BYTE PTR [ecx+eax+40]
	imul	esi, edx
	mov	eax, DWORD PTR _wrange$[ebp]
	push	eax
	mov	ecx, DWORD PTR _range$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mt$[ebp]
	push	edx
	mov	eax, DWORD PTR _w$[ebp]
	push	eax
	call	?GetWeaponHitChance@@YAHHHHH@Z		; GetWeaponHitChance
	add	esp, 16					; 00000010H
	imul	eax, esi
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
$LN3@GetWeaponS:

; 101  : }

	pop	esi
	pop	ebp
	ret	0
?GetWeaponScore@@YAHHHHH@Z ENDP				; GetWeaponScore
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\weapon.cpp
_TEXT	SEGMENT
_wr$ = -8						; size = 4
tv71 = -4						; size = 4
_w$ = 8							; size = 4
_mt$ = 12						; size = 4
_range$ = 16						; size = 4
?GetWeaponScore@@YAHHHH@Z PROC				; GetWeaponScore

; 87   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi

; 88   :     ShiAssert(w>= 0 && w < NumWeaponTypes);
; 89   :     if(w< 0 || w >= NumWeaponTypes) return 0;

	cmp	DWORD PTR _w$[ebp], 0
	jl	SHORT $LN2@GetWeaponS
	movsx	eax, WORD PTR ?NumWeaponTypes@@3FA	; NumWeaponTypes
	cmp	DWORD PTR _w$[ebp], eax
	jl	SHORT $LN3@GetWeaponS
$LN2@GetWeaponS:
	xor	eax, eax
	jmp	SHORT $LN4@GetWeaponS
$LN3@GetWeaponS:

; 90   :     int wr = GetWeaponRange(w, mt) < range;

	mov	ecx, DWORD PTR _mt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _w$[ebp]
	push	edx
	call	?GetWeaponRange@@YAHHH@Z		; GetWeaponRange
	add	esp, 8
	cmp	eax, DWORD PTR _range$[ebp]
	jge	SHORT $LN6@GetWeaponS
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN7@GetWeaponS
$LN6@GetWeaponS:
	mov	DWORD PTR tv71[ebp], 0
$LN7@GetWeaponS:
	mov	eax, DWORD PTR tv71[ebp]
	mov	DWORD PTR _wr$[ebp], eax

; 91   :     if (wr)

	cmp	DWORD PTR _wr$[ebp], 0
	je	SHORT $LN1@GetWeaponS

; 92   : 	return 0;

	xor	eax, eax
	jmp	SHORT $LN4@GetWeaponS
$LN1@GetWeaponS:

; 93   :     return (WeaponDataTable[w].Strength * WeaponDataTable[w].FireRate * GetWeaponHitChance(w,mt,range,wr)) / 100;

	mov	ecx, DWORD PTR _w$[ebp]
	imul	ecx, 60					; 0000003cH
	mov	edx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movzx	esi, WORD PTR [edx+ecx+2]
	mov	eax, DWORD PTR _w$[ebp]
	imul	eax, 60					; 0000003cH
	mov	ecx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movzx	edx, BYTE PTR [ecx+eax+40]
	imul	esi, edx
	mov	eax, DWORD PTR _wr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _range$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mt$[ebp]
	push	edx
	mov	eax, DWORD PTR _w$[ebp]
	push	eax
	call	?GetWeaponHitChance@@YAHHHHH@Z		; GetWeaponHitChance
	add	esp, 16					; 00000010H
	imul	eax, esi
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
$LN4@GetWeaponS:

; 94   : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?GetWeaponScore@@YAHHHH@Z ENDP				; GetWeaponScore
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\weapon.cpp
_TEXT	SEGMENT
_w$ = 8							; size = 4
_mt$ = 12						; size = 4
_range$ = 16						; size = 4
_wrange$ = 20						; size = 4
?GetWeaponHitChance@@YAHHHHH@Z PROC			; GetWeaponHitChance

; 73   : {

	push	ebp
	mov	ebp, esp

; 74   :     ShiAssert(w>= 0 && w < NumWeaponTypes);
; 75   :     if(w< 0 || w >= NumWeaponTypes) return 0;

	cmp	DWORD PTR _w$[ebp], 0
	jl	SHORT $LN1@GetWeaponH
	movsx	eax, WORD PTR ?NumWeaponTypes@@3FA	; NumWeaponTypes
	cmp	DWORD PTR _w$[ebp], eax
	jl	SHORT $LN2@GetWeaponH
$LN1@GetWeaponH:
	xor	eax, eax
	jmp	SHORT $LN3@GetWeaponH
$LN2@GetWeaponH:

; 76   :     return FloatToInt32(WeaponDataTable[w].HitChance[mt]*(1.2F - ((float)(range+1)/(wrange+1))) + 0.5F);

	mov	ecx, DWORD PTR _w$[ebp]
	imul	ecx, 60					; 0000003cH
	add	ecx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	mov	edx, DWORD PTR _mt$[ebp]
	movzx	eax, BYTE PTR [ecx+edx+32]
	cvtsi2ss xmm0, eax
	mov	ecx, DWORD PTR _range$[ebp]
	add	ecx, 1
	cvtsi2ss xmm1, ecx
	mov	edx, DWORD PTR _wrange$[ebp]
	add	edx, 1
	cvtsi2ss xmm2, edx
	divss	xmm1, xmm2
	movss	xmm2, DWORD PTR __real@3f99999a
	subss	xmm2, xmm1
	mulss	xmm0, xmm2
	addss	xmm0, DWORD PTR __real@3f000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
$LN3@GetWeaponH:

; 77   : }

	pop	ebp
	ret	0
?GetWeaponHitChance@@YAHHHHH@Z ENDP			; GetWeaponHitChance
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\weapon.cpp
_TEXT	SEGMENT
_wr$ = -4						; size = 4
_w$ = 8							; size = 4
_mt$ = 12						; size = 4
_range$ = 16						; size = 4
?GetWeaponHitChance@@YAHHHH@Z PROC			; GetWeaponHitChance

; 60   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 61   :     ShiAssert(w>= 0 && w < NumWeaponTypes);
; 62   :     ShiAssert(mt >= 0 && mt < 8);
; 63   :     if(w< 0 || w >= NumWeaponTypes) return 0;

	cmp	DWORD PTR _w$[ebp], 0
	jl	SHORT $LN2@GetWeaponH
	movsx	eax, WORD PTR ?NumWeaponTypes@@3FA	; NumWeaponTypes
	cmp	DWORD PTR _w$[ebp], eax
	jl	SHORT $LN3@GetWeaponH
$LN2@GetWeaponH:
	xor	eax, eax
	jmp	SHORT $LN4@GetWeaponH
$LN3@GetWeaponH:

; 64   :     int	wr;
; 65   :     
; 66   :     wr = GetWeaponRange(w, mt);

	mov	ecx, DWORD PTR _mt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _w$[ebp]
	push	edx
	call	?GetWeaponRange@@YAHHH@Z		; GetWeaponRange
	add	esp, 8
	mov	DWORD PTR _wr$[ebp], eax

; 67   :     if (wr < range)

	mov	eax, DWORD PTR _wr$[ebp]
	cmp	eax, DWORD PTR _range$[ebp]
	jge	SHORT $LN1@GetWeaponH

; 68   : 	return 0;

	xor	eax, eax
	jmp	SHORT $LN4@GetWeaponH
$LN1@GetWeaponH:

; 69   :     return FloatToInt32(WeaponDataTable[w].HitChance[mt]*(1.2F - ((float)(range+1)/(wr+1))) + 0.5F);

	mov	ecx, DWORD PTR _w$[ebp]
	imul	ecx, 60					; 0000003cH
	add	ecx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	mov	edx, DWORD PTR _mt$[ebp]
	movzx	eax, BYTE PTR [ecx+edx+32]
	cvtsi2ss xmm0, eax
	mov	ecx, DWORD PTR _range$[ebp]
	add	ecx, 1
	cvtsi2ss xmm1, ecx
	mov	edx, DWORD PTR _wr$[ebp]
	add	edx, 1
	cvtsi2ss xmm2, edx
	divss	xmm1, xmm2
	movss	xmm2, DWORD PTR __real@3f99999a
	subss	xmm2, xmm1
	mulss	xmm0, xmm2
	addss	xmm0, DWORD PTR __real@3f000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
$LN4@GetWeaponH:

; 70   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetWeaponHitChance@@YAHHHH@Z ENDP			; GetWeaponHitChance
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\weapon.cpp
_TEXT	SEGMENT
_w$ = 8							; size = 4
_mt$ = 12						; size = 4
?GetWeaponHitChance@@YAHHH@Z PROC			; GetWeaponHitChance

; 53   : int GetWeaponHitChance (int w, int mt){

	push	ebp
	mov	ebp, esp

; 54   :     ShiAssert(w>= 0 && w < NumWeaponTypes);
; 55   :     if(w< 0 || w >= NumWeaponTypes) return 0;

	cmp	DWORD PTR _w$[ebp], 0
	jl	SHORT $LN1@GetWeaponH
	movsx	eax, WORD PTR ?NumWeaponTypes@@3FA	; NumWeaponTypes
	cmp	DWORD PTR _w$[ebp], eax
	jl	SHORT $LN2@GetWeaponH
$LN1@GetWeaponH:
	xor	eax, eax
	jmp	SHORT $LN3@GetWeaponH
$LN2@GetWeaponH:

; 56   :     return WeaponDataTable[w].HitChance[mt];

	mov	ecx, DWORD PTR _w$[ebp]
	imul	ecx, 60					; 0000003cH
	add	ecx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	mov	edx, DWORD PTR _mt$[ebp]
	movzx	eax, BYTE PTR [ecx+edx+32]
$LN3@GetWeaponH:

; 57   : }

	pop	ebp
	ret	0
?GetWeaponHitChance@@YAHHH@Z ENDP			; GetWeaponHitChance
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\weapon.cpp
_TEXT	SEGMENT
_w$ = 8							; size = 4
?GetWeaponFireRate@@YAHH@Z PROC				; GetWeaponFireRate

; 80   : {

	push	ebp
	mov	ebp, esp

; 81   :     ShiAssert(w>= 0 && w < NumWeaponTypes);
; 82   :     if(w< 0 || w >= NumWeaponTypes) return 0;

	cmp	DWORD PTR _w$[ebp], 0
	jl	SHORT $LN1@GetWeaponF
	movsx	eax, WORD PTR ?NumWeaponTypes@@3FA	; NumWeaponTypes
	cmp	DWORD PTR _w$[ebp], eax
	jl	SHORT $LN2@GetWeaponF
$LN1@GetWeaponF:
	xor	eax, eax
	jmp	SHORT $LN3@GetWeaponF
$LN2@GetWeaponF:

; 83   :     return WeaponDataTable[w].FireRate;

	mov	ecx, DWORD PTR _w$[ebp]
	imul	ecx, 60					; 0000003cH
	mov	edx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movzx	eax, BYTE PTR [edx+ecx+40]
$LN3@GetWeaponF:

; 84   : }

	pop	ebp
	ret	0
?GetWeaponFireRate@@YAHH@Z ENDP				; GetWeaponFireRate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\weapon.cpp
_TEXT	SEGMENT
_w$ = 8							; size = 4
_mt$ = 12						; size = 4
?GetWeaponRange@@YAHHH@Z PROC				; GetWeaponRange

; 28   : int GetWeaponRange (int w, int mt){

	push	ebp
	mov	ebp, esp

; 29   :     ShiAssert(w>= 0 && w < NumWeaponTypes);
; 30   : 
; 31   : 		if ((w < 0) || (w >= NumWeaponTypes))

	cmp	DWORD PTR _w$[ebp], 0
	jl	SHORT $LN5@GetWeaponR
	movsx	eax, WORD PTR ?NumWeaponTypes@@3FA	; NumWeaponTypes
	cmp	DWORD PTR _w$[ebp], eax
	jl	SHORT $LN6@GetWeaponR
$LN5@GetWeaponR:

; 32   : 			return 0;

	xor	eax, eax
	jmp	$LN7@GetWeaponR
$LN6@GetWeaponR:

; 33   : 
; 34   :     // if (
; 35   : 	// F4IsBadReadPtr(&(WeaponDataTable[w]), sizeof(WeaponClassDataType)) ||
; 36   : 	// F4IsBadReadPtr(&(WeaponDataTable[w].HitChance[mt]), sizeof(uchar)))
; 37   : 	// JB 011205 (too much CPU) // JB 010331 CTD
; 38   : 	if (w < 0 || w >= NumWeaponTypes){

	cmp	DWORD PTR _w$[ebp], 0
	jl	SHORT $LN3@GetWeaponR
	movsx	ecx, WORD PTR ?NumWeaponTypes@@3FA	; NumWeaponTypes
	cmp	DWORD PTR _w$[ebp], ecx
	jl	SHORT $LN4@GetWeaponR
$LN3@GetWeaponR:

; 39   : 		// JB 011205
; 40   : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN7@GetWeaponR
$LN4@GetWeaponR:

; 41   : 	}
; 42   :     
; 43   :     if (WeaponDataTable[w].HitChance[mt] > 0){

	mov	edx, DWORD PTR _w$[ebp]
	imul	edx, 60					; 0000003cH
	add	edx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	mov	eax, DWORD PTR _mt$[ebp]
	movzx	ecx, BYTE PTR [edx+eax+32]
	test	ecx, ecx
	jle	SHORT $LN2@GetWeaponR

; 44   : 		// KCK Hack: If vs LowAir and weapon has an Air hit chance, scale range
; 45   : 		if (mt == LowAir && WeaponDataTable[w].HitChance[Air]){

	cmp	DWORD PTR _mt$[ebp], 4
	jne	SHORT $LN1@GetWeaponR
	mov	edx, DWORD PTR _w$[ebp]
	imul	edx, 60					; 0000003cH
	add	edx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	mov	eax, 1
	imul	eax, 5
	movzx	ecx, BYTE PTR [edx+eax+32]
	test	ecx, ecx
	je	SHORT $LN1@GetWeaponR

; 46   : 			return (int)((WeaponDataTable[w].Range * LOWAIR_RANGE_MODIFIER) + 0.99F);

	mov	edx, DWORD PTR _w$[ebp]
	imul	edx, 60					; 0000003cH
	mov	eax, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movsx	ecx, WORD PTR [eax+edx+8]
	cvtsi2ss xmm0, ecx
	mulss	xmm0, DWORD PTR ?LOWAIR_RANGE_MODIFIER@@3MA
	addss	xmm0, DWORD PTR __real@3f7d70a4
	cvttss2si eax, xmm0
	jmp	SHORT $LN7@GetWeaponR
$LN1@GetWeaponR:

; 47   : 		}
; 48   : 		return WeaponDataTable[w].Range;

	mov	edx, DWORD PTR _w$[ebp]
	imul	edx, 60					; 0000003cH
	mov	eax, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movsx	eax, WORD PTR [eax+edx+8]
	jmp	SHORT $LN7@GetWeaponR
$LN2@GetWeaponR:

; 49   :     }
; 50   :     return 0;

	xor	eax, eax
$LN7@GetWeaponR:

; 51   : }

	pop	ebp
	ret	0
?GetWeaponRange@@YAHHH@Z ENDP				; GetWeaponRange
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\weapon.cpp
_TEXT	SEGMENT
_w$ = 8							; size = 4
?GetWeaponStrength@@YAHH@Z PROC				; GetWeaponStrength

; 22   : {

	push	ebp
	mov	ebp, esp

; 23   :     ShiAssert(w>= 0 && w < NumWeaponTypes);
; 24   :     if(w< 0 || w >= NumWeaponTypes) return 0;

	cmp	DWORD PTR _w$[ebp], 0
	jl	SHORT $LN1@GetWeaponS
	movsx	eax, WORD PTR ?NumWeaponTypes@@3FA	; NumWeaponTypes
	cmp	DWORD PTR _w$[ebp], eax
	jl	SHORT $LN2@GetWeaponS
$LN1@GetWeaponS:
	xor	eax, eax
	jmp	SHORT $LN3@GetWeaponS
$LN2@GetWeaponS:

; 25   :     return WeaponDataTable[w].Strength;

	mov	ecx, DWORD PTR _w$[ebp]
	imul	ecx, 60					; 0000003cH
	mov	edx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movzx	eax, WORD PTR [edx+ecx+2]
$LN3@GetWeaponS:

; 26   : }

	pop	ebp
	ret	0
?GetWeaponStrength@@YAHH@Z ENDP				; GetWeaponStrength
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
_TEXT	SEGMENT
_x$ = 8							; size = 4
?FloatToInt32@@YAHM@Z PROC				; FloatToInt32

; 179  : {

	push	ebp
	mov	ebp, esp

; 180  : #if WIN32
; 181  :   __asm {
; 182  :     fld dword ptr [x];

	fld	DWORD PTR _x$[ebp]

; 183  :     fistp dword ptr [x];

	fistp	DWORD PTR _x$[ebp]

; 184  :     mov eax,dword ptr [x];

	mov	eax, DWORD PTR _x$[ebp]

; 185  :   }
; 186  : #else 
; 187  : 	return static_cast<int>(x);	
; 188  : #endif
; 189  : }

	pop	ebp
	ret	0
?FloatToInt32@@YAHM@Z ENDP				; FloatToInt32
_TEXT	ENDS
END
