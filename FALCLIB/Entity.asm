; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\FALCLIB\Entity.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?WeaponListDataTable@@3PAUWeaponListDataType@@A	; WeaponListDataTable
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?NumUnitEntries@@3FA				; NumUnitEntries
PUBLIC	?NumObjectiveEntries@@3FA			; NumObjectiveEntries
PUBLIC	?NumObjFeatEntries@@3FA				; NumObjFeatEntries
PUBLIC	?NumVehicleEntries@@3FA				; NumVehicleEntries
PUBLIC	?NumFeatureEntries@@3FA				; NumFeatureEntries
PUBLIC	?NumSquadTypes@@3FA				; NumSquadTypes
PUBLIC	?NumWeaponTypes@@3FA				; NumWeaponTypes
PUBLIC	?NumPtHeaders@@3FA				; NumPtHeaders
PUBLIC	?NumPts@@3FA					; NumPts
PUBLIC	?NumSimWeaponEntries@@3FA			; NumSimWeaponEntries
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?NumACDefEntries@@3FA				; NumACDefEntries
PUBLIC	?NumRocketTypes@@3FA				; NumRocketTypes
PUBLIC	?NumDirtyDataPriorities@@3FA			; NumDirtyDataPriorities
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?fedtree@@3_NA					; fedtree
PUBLIC	?SFXType@@3HA					; SFXType
PUBLIC	?F4SessionType@@3HA				; F4SessionType
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?F4GroupType@@3HA				; F4GroupType
PUBLIC	?F4GameType@@3HA				; F4GameType
PUBLIC	?F4FlyingEyeType@@3HA				; F4FlyingEyeType
PUBLIC	?gRackId_Single_Rack@@3FA			; gRackId_Single_Rack
PUBLIC	?gRackId_Triple_Rack@@3FA			; gRackId_Triple_Rack
PUBLIC	?gRackId_Quad_Rack@@3FA				; gRackId_Quad_Rack
PUBLIC	?gRackId_Six_Rack@@3FA				; gRackId_Six_Rack
PUBLIC	?gRackId_Two_Rack@@3FA				; gRackId_Two_Rack
PUBLIC	?gRackId_Single_AA_Rack@@3FA			; gRackId_Single_AA_Rack
PUBLIC	?gRackId_Mav_Rack@@3FA				; gRackId_Mav_Rack
PUBLIC	?gRocketId@@3FA					; gRocketId
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?ErrorFH@@3PAU_iobuf@@A				; ErrorFH
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?UnitDataTable@@3PAUUnitClassDataType@@A	; UnitDataTable
PUBLIC	?ObjDataTable@@3PAUObjClassDataType@@A		; ObjDataTable
PUBLIC	?FeatureEntryDataTable@@3PAUFeatureEntry@@A	; FeatureEntryDataTable
PUBLIC	?WeaponDataTable@@3PAUWeaponClassDataType@@A	; WeaponDataTable
PUBLIC	?FeatureDataTable@@3PAUFeatureClassDataType@@A	; FeatureDataTable
PUBLIC	?VehicleDataTable@@3PAUVehicleClassDataType@@A	; VehicleDataTable
PUBLIC	?SquadronStoresDataTable@@3PAUSquadronStoresDataType@@A ; SquadronStoresDataTable
PUBLIC	?PtHeaderDataTable@@3PAUPtHeaderDataType@@A	; PtHeaderDataTable
PUBLIC	?PtDataTable@@3PAUPtDataType@@A			; PtDataTable
PUBLIC	?SimWeaponDataTable@@3PAUSimWeaponDataType@@A	; SimWeaponDataTable
PUBLIC	?SimACDefTable@@3PAUSimACDefType@@A		; SimACDefTable
PUBLIC	?RocketDataTable@@3PAURocketClassDataType@@A	; RocketDataTable
PUBLIC	?DDP@@3PAUDirtyDataClassType@@A			; DDP
PUBLIC	?NumObjectiveTypes@@3FA				; NumObjectiveTypes
PUBLIC	?F4GenericTruckType@@3HA			; F4GenericTruckType
PUBLIC	?F4GenericUSTruckType@@3HA			; F4GenericUSTruckType
PUBLIC	?RackGroupTable@@3PAURackGroup@@A		; RackGroupTable
PUBLIC	?MaxRackGroups@@3HA				; MaxRackGroups
PUBLIC	?RackObjectTable@@3PAURackObject@@A		; RackObjectTable
PUBLIC	?MaxRackObjects@@3HA				; MaxRackObjects
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
_BSS	SEGMENT
?WeaponListDataTable@@3PAUWeaponListDataType@@A DD 01H DUP (?) ; WeaponListDataTable
?NumUnitEntries@@3FA DW 01H DUP (?)			; NumUnitEntries
	ALIGN	4

?NumObjectiveEntries@@3FA DW 01H DUP (?)		; NumObjectiveEntries
	ALIGN	4

?NumObjFeatEntries@@3FA DW 01H DUP (?)			; NumObjFeatEntries
	ALIGN	4

?NumVehicleEntries@@3FA DW 01H DUP (?)			; NumVehicleEntries
	ALIGN	4

?NumFeatureEntries@@3FA DW 01H DUP (?)			; NumFeatureEntries
	ALIGN	4

?NumSquadTypes@@3FA DW 01H DUP (?)			; NumSquadTypes
	ALIGN	4

?NumWeaponTypes@@3FA DW 01H DUP (?)			; NumWeaponTypes
	ALIGN	4

?NumPtHeaders@@3FA DW 01H DUP (?)			; NumPtHeaders
	ALIGN	4

?NumPts@@3FA DW	01H DUP (?)				; NumPts
	ALIGN	4

?NumSimWeaponEntries@@3FA DW 01H DUP (?)		; NumSimWeaponEntries
	ALIGN	4

?NumACDefEntries@@3FA DW 01H DUP (?)			; NumACDefEntries
	ALIGN	4

?NumRocketTypes@@3FA DW 01H DUP (?)			; NumRocketTypes
	ALIGN	4

?NumDirtyDataPriorities@@3FA DW 01H DUP (?)		; NumDirtyDataPriorities
	ALIGN	4

?fedtree@@3_NA DB 01H DUP (?)				; fedtree
	ALIGN	4

?SFXType@@3HA DD 01H DUP (?)				; SFXType
?F4SessionType@@3HA DD 01H DUP (?)			; F4SessionType
?F4GroupType@@3HA DD 01H DUP (?)			; F4GroupType
?F4GameType@@3HA DD 01H DUP (?)				; F4GameType
?F4FlyingEyeType@@3HA DD 01H DUP (?)			; F4FlyingEyeType
?gRackId_Single_Rack@@3FA DW 01H DUP (?)		; gRackId_Single_Rack
	ALIGN	4

?gRackId_Triple_Rack@@3FA DW 01H DUP (?)		; gRackId_Triple_Rack
	ALIGN	4

?gRackId_Quad_Rack@@3FA DW 01H DUP (?)			; gRackId_Quad_Rack
	ALIGN	4

?gRackId_Six_Rack@@3FA DW 01H DUP (?)			; gRackId_Six_Rack
	ALIGN	4

?gRackId_Two_Rack@@3FA DW 01H DUP (?)			; gRackId_Two_Rack
	ALIGN	4

?gRackId_Single_AA_Rack@@3FA DW 01H DUP (?)		; gRackId_Single_AA_Rack
	ALIGN	4

?gRackId_Mav_Rack@@3FA DW 01H DUP (?)			; gRackId_Mav_Rack
	ALIGN	4

?gRocketId@@3FA DW 01H DUP (?)				; gRocketId
	ALIGN	4

?ErrorFH@@3PAU_iobuf@@A DD 01H DUP (?)			; ErrorFH
?UnitDataTable@@3PAUUnitClassDataType@@A DD 01H DUP (?)	; UnitDataTable
?ObjDataTable@@3PAUObjClassDataType@@A DD 01H DUP (?)	; ObjDataTable
?FeatureEntryDataTable@@3PAUFeatureEntry@@A DD 01H DUP (?) ; FeatureEntryDataTable
?WeaponDataTable@@3PAUWeaponClassDataType@@A DD 01H DUP (?) ; WeaponDataTable
?FeatureDataTable@@3PAUFeatureClassDataType@@A DD 01H DUP (?) ; FeatureDataTable
?VehicleDataTable@@3PAUVehicleClassDataType@@A DD 01H DUP (?) ; VehicleDataTable
?SquadronStoresDataTable@@3PAUSquadronStoresDataType@@A DD 01H DUP (?) ; SquadronStoresDataTable
?PtHeaderDataTable@@3PAUPtHeaderDataType@@A DD 01H DUP (?) ; PtHeaderDataTable
?PtDataTable@@3PAUPtDataType@@A DD 01H DUP (?)		; PtDataTable
?SimWeaponDataTable@@3PAUSimWeaponDataType@@A DD 01H DUP (?) ; SimWeaponDataTable
?SimACDefTable@@3PAUSimACDefType@@A DD 01H DUP (?)	; SimACDefTable
?RocketDataTable@@3PAURocketClassDataType@@A DD 01H DUP (?) ; RocketDataTable
?DDP@@3PAUDirtyDataClassType@@A DD 01H DUP (?)		; DDP
?NumObjectiveTypes@@3FA DW 01H DUP (?)			; NumObjectiveTypes
	ALIGN	4

?F4GenericTruckType@@3HA DD 01H DUP (?)			; F4GenericTruckType
?F4GenericUSTruckType@@3HA DD 01H DUP (?)		; F4GenericUSTruckType
?RackGroupTable@@3PAURackGroup@@A DD 01H DUP (?)	; RackGroupTable
?MaxRackGroups@@3HA DD 01H DUP (?)			; MaxRackGroups
?RackObjectTable@@3PAURackObject@@A DD 01H DUP (?)	; RackObjectTable
?MaxRackObjects@@3HA DD 01H DUP (?)			; MaxRackObjects
_BSS	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
PUBLIC	?strchr@@YAPADPADH@Z				; strchr
PUBLIC	?LoadClassTable@@YAHPAD@Z			; LoadClassTable
PUBLIC	?UnloadClassTable@@YAHXZ			; UnloadClassTable
PUBLIC	?LoadUnitData@@YAHPAD@Z				; LoadUnitData
PUBLIC	?LoadObjectiveData@@YAHPAD@Z			; LoadObjectiveData
PUBLIC	?LoadWeaponData@@YAHPAD@Z			; LoadWeaponData
PUBLIC	?LoadRocketData@@YAHPAD@Z			; LoadRocketData
PUBLIC	?LoadDirtyData@@YAHPAD@Z			; LoadDirtyData
PUBLIC	?LoadFeatureData@@YAHPAD@Z			; LoadFeatureData
PUBLIC	?LoadVehicleData@@YAHPAD@Z			; LoadVehicleData
PUBLIC	?LoadWeaponListData@@YAHPAD@Z			; LoadWeaponListData
PUBLIC	?LoadPtHeaderData@@YAHPAD@Z			; LoadPtHeaderData
PUBLIC	?LoadPtData@@YAHPAD@Z				; LoadPtData
PUBLIC	?LoadFeatureEntryData@@YAHPAD@Z			; LoadFeatureEntryData
PUBLIC	?LoadRadarData@@YAHPAD@Z			; LoadRadarData
PUBLIC	?LoadIRSTData@@YAHPAD@Z				; LoadIRSTData
PUBLIC	?LoadRwrData@@YAHPAD@Z				; LoadRwrData
PUBLIC	?LoadVisualData@@YAHPAD@Z			; LoadVisualData
PUBLIC	?LoadSimWeaponData@@YAHPAD@Z			; LoadSimWeaponData
PUBLIC	?GetClassID@@YAHEEEEEEEE@Z			; GetClassID
PUBLIC	?GetClassNameA@@YAPADH@Z			; GetClassNameA
PUBLIC	?MapVisId@@YAKK@Z				; MapVisId
PUBLIC	?LoadRackTables@@YAXXZ				; LoadRackTables
PUBLIC	?FindBestRackID@@YAHHH@Z			; FindBestRackID
PUBLIC	?FindBestRackIDByPlaneAndWeapon@@YAHHHH@Z	; FindBestRackIDByPlaneAndWeapon
PUBLIC	?RDLoadRackData@@YAXXZ				; RDLoadRackData
PUBLIC	?RDUnloadRackData@@YAXXZ			; RDUnloadRackData
PUBLIC	?RDFindBestRack@@YAHHHHPAURDRackData@@@Z	; RDFindBestRack
PUBLIC	?RDFindBestRackWID@@YAHHHHPAURDRackData@@@Z	; RDFindBestRackWID
PUBLIC	?RDFindBestRackSWD@@YAHHHHPAURDRackData@@@Z	; RDFindBestRackSWD
PUBLIC	?CompareWith@ANode@@UAEHPAV1@@Z			; ANode::CompareWith
PUBLIC	??1AList@@QAE@XZ				; AList::~AList
PUBLIC	?LoadACDefData@@YAHPAD@Z			; LoadACDefData
PUBLIC	?LoadSquadronStoresData@@YAHPAD@Z		; LoadSquadronStoresData
PUBLIC	?WriteClassTable@@YAXXZ				; WriteClassTable
PUBLIC	?ReadClassTable@@YAXXZ				; ReadClassTable
PUBLIC	?LoadVisIdMap@@YAXXZ				; LoadVisIdMap
PUBLIC	?CheckClassEntry@@YAHHQAE@Z			; CheckClassEntry
PUBLIC	??0RDRackNode@@QAE@XZ				; RDRackNode::RDRackNode
PUBLIC	??1RDRackNode@@QAE@XZ				; RDRackNode::~RDRackNode
PUBLIC	??0RDLoadOrderNode@@QAE@H@Z			; RDLoadOrderNode::RDLoadOrderNode
PUBLIC	??1RDLoadOrderNode@@QAE@XZ			; RDLoadOrderNode::~RDLoadOrderNode
PUBLIC	??_GRDLoadOrderNode@@QAEPAXI@Z			; RDLoadOrderNode::`scalar deleting destructor'
PUBLIC	??0RDRackNameNode@@QAE@XZ			; RDRackNameNode::RDRackNameNode
PUBLIC	??1RDRackNameNode@@QAE@XZ			; RDRackNameNode::~RDRackNameNode
PUBLIC	??_GRDRackNameNode@@QAEPAXI@Z			; RDRackNameNode::`scalar deleting destructor'
PUBLIC	??0RDPylonNode@@QAE@XZ				; RDPylonNode::RDPylonNode
PUBLIC	??1RDPylonNode@@QAE@XZ				; RDPylonNode::~RDPylonNode
PUBLIC	??_GRDPylonNode@@QAEPAXI@Z			; RDPylonNode::`scalar deleting destructor'
PUBLIC	??1RDHardpointNode@@QAE@XZ			; RDHardpointNode::~RDHardpointNode
PUBLIC	??0RDHardpointNode@@QAE@XZ			; RDHardpointNode::RDHardpointNode
PUBLIC	??_GRDHardpointNode@@QAEPAXI@Z			; RDHardpointNode::`scalar deleting destructor'
PUBLIC	?RDFindBestRackWClass@@YAHHHHPAURDRackData@@@Z	; RDFindBestRackWClass
PUBLIC	?RDCopyRackData@@YAXHPAVRDPylonNode@@PAVRDRackNode@@PAURDRackData@@@Z ; RDCopyRackData
PUBLIC	??_C@_01NOFIACDB@w?$AA@				; `string'
PUBLIC	??_C@_0BI@GFGDACML@C?3?2Objective?9Errors?4txt?$AA@ ; `string'
PUBLIC	??_C@_0M@CFLADCE@Feb?518?52013?$AA@		; `string'
PUBLIC	??_C@_0L@IGAEJGCL@Entity?4cpp?$AA@		; `string'
PUBLIC	??_C@_0BE@FGKKLFGH@Error?3?5?5?$CF0d?5?5?$CFs?5?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0BJ@FKDHIIHL@Failed?5to?5load?5unit?5data?$AA@ ; `string'
PUBLIC	??_C@_0BP@EKGKJCFC@Failed?5to?5load?5feature?5entries?$AA@ ; `string'
PUBLIC	??_C@_0BO@EGFMBGCP@Failed?5to?5load?5objective?5data?$AA@ ; `string'
PUBLIC	??_C@_0BL@HBLOKCBF@Failed?5to?5load?5weapon?5data?$AA@ ; `string'
PUBLIC	??_C@_0BM@FEPKGIOD@Failed?5to?5load?5feature?5data?$AA@ ; `string'
PUBLIC	??_C@_0BM@PPALOCAG@Failed?5to?5load?5vehicle?5data?$AA@ ; `string'
PUBLIC	??_C@_0BL@LGIADBKK@Failed?5to?5load?5weapon?5list?$AA@ ; `string'
PUBLIC	??_C@_0BN@IDIHOGAD@Failed?5to?5load?5point?5headers?$AA@ ; `string'
PUBLIC	??_C@_0BK@DOBMODNN@Failed?5to?5load?5point?5data?$AA@ ; `string'
PUBLIC	??_C@_0BK@DDAGKKGO@Failed?5to?5load?5radar?5data?$AA@ ; `string'
PUBLIC	??_C@_0BJ@DLENKPCC@Failed?5to?5load?5IRST?5data?$AA@ ; `string'
PUBLIC	??_C@_0BI@MILFPPLL@Failed?5to?5load?5Rwr?5data?$AA@ ; `string'
PUBLIC	??_C@_0BL@BDOJLAME@Failed?5to?5load?5Visual?5data?$AA@ ; `string'
PUBLIC	??_C@_0BO@ENPFIBAL@Failed?5to?5load?5SimWeapon?5data?$AA@ ; `string'
PUBLIC	??_C@_0CC@IJBFJPCM@Failed?5to?5load?5AC?5Definition?5dat@ ; `string'
PUBLIC	??_C@_0CE@KBILOMDH@Failed?5to?5load?5Squadron?5stores?5d@ ; `string'
PUBLIC	??_C@_0BL@GLINIFKA@Failed?5to?5load?5Rocket?5data?$AA@ ; `string'
PUBLIC	??_C@_0CF@LPMLGJMG@Failed?5to?5load?5Dirty?5data?5priori@ ; `string'
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
PUBLIC	??_C@_03MEKBGGOL@UCD?$AA@			; `string'
PUBLIC	??_C@_03PLAFNBBA@OCD?$AA@			; `string'
PUBLIC	??_C@_03GOKIKOGA@WCD?$AA@			; `string'
PUBLIC	??_C@_03BNKHBNLL@RKT?$AA@			; `string'
PUBLIC	??_C@_03HOFJHMB@DDP?$AA@			; `string'
PUBLIC	??_C@_03IGANJOJK@FCD?$AA@			; `string'
PUBLIC	??_C@_03NGBEMJAF@VCD?$AA@			; `string'
PUBLIC	??_C@_03GFPEOJFN@WLD?$AA@			; `string'
PUBLIC	??_C@_03PPCKHJDI@PHD?$AA@			; `string'
PUBLIC	??_C@_0EG@GNFNLJDK@PtHeaderDataTable?$FL?$CFd?$FN?4features?$FL?$CF@ ; `string'
PUBLIC	??_C@_0DK@BIGLNPMG@PtHeaderDataTable?$FL?$CFd?$FN?4objId?$DN?$CFd?5?$DO@ ; `string'
PUBLIC	??_C@_0DK@HDPDKILO@ObjDataTable?$FL?$CFd?$FN?4PtDataIndex?5?$DO?$DN?5@ ; `string'
PUBLIC	??_C@_02PIBHICFM@PD?$AA@			; `string'
PUBLIC	??_C@_04KCCPLAND@tree?$AA@			; `string'
PUBLIC	??_C@_03ICIAOCCI@FED?$AA@			; `string'
PUBLIC	??_C@_03FJHGFOFC@RCD?$AA@			; `string'
PUBLIC	??_C@_03NOGOIOMM@ICD?$AA@			; `string'
PUBLIC	??_C@_03EPKCJIIC@rwd?$AA@			; `string'
PUBLIC	??_C@_03MHMJKHAJ@vsd?$AA@			; `string'
PUBLIC	??_C@_03PKOFDCJL@SWD?$AA@			; `string'
PUBLIC	??_C@_03BLNKKGCD@ACD?$AA@			; `string'
PUBLIC	??_C@_03PNOMJKEH@SSD?$AA@			; `string'
PUBLIC	??_C@_02BMJICGCB@rt?$AA@			; `string'
PUBLIC	??_C@_03HBNNNHNM@map?$AA@			; `string'
PUBLIC	??_C@_05DIHJPEMC@visid?$AA@			; `string'
PUBLIC	??_C@_08HDFMCMGC@?$CFd?5?$DN?$DO?5?$CFd?$AA@	; `string'
PUBLIC	??_C@_03GILJFNFC@dat?$AA@			; `string'
PUBLIC	??_C@_04DEAMMDDK@Rack?$AA@			; `string'
PUBLIC	??_C@_08EJINGHLB@Rack?4dat?$AA@			; `string'
PUBLIC	??_C@_05BMGBEOOC@?$CFs?2?$CFs?$AA@		; `string'
PUBLIC	??_C@_0N@KPJEKBOE@NumGroups?5?$CFd?$AA@		; `string'
PUBLIC	??_C@_07FOMKHCGE@Group?$CFd?$AA@		; `string'
PUBLIC	??_C@_0M@EPMLFDLC@NumRacks?5?$CFd?$AA@		; `string'
PUBLIC	??_C@_0N@DNBHIEDB@Rack?$CFd?5?$CFd?5?$CFd?$AA@	; `string'
PUBLIC	??_7RDRackNode@@6B@				; RDRackNode::`vftable'
PUBLIC	??_7RDLoadOrderNode@@6B@			; RDLoadOrderNode::`vftable'
PUBLIC	??_7RDRackNameNode@@6B@				; RDRackNameNode::`vftable'
PUBLIC	??_7RDPylonNode@@6B@				; RDPylonNode::`vftable'
PUBLIC	??_7RDHardpointNode@@6B@			; RDHardpointNode::`vftable'
PUBLIC	?RDRackList@@3VAList@@A				; RDRackList
PUBLIC	?RDHardpointList@@3VAList@@A			; RDHardpointList
PUBLIC	??_C@_07FDHCEADO@BMSRack?$AA@			; `string'
PUBLIC	??_C@_0M@EHPGPFLM@BMSRack?4dat?$AA@		; `string'
PUBLIC	??_C@_03ILLHFMNI@?5?7?6?$AA@			; `string'
PUBLIC	??_C@_02NCJKDDL@?6?$AA?$AA@			; `string'
PUBLIC	??_C@_0L@OMMGGKKO@definerack?$AA@		; `string'
PUBLIC	??_C@_06OJLLIJGI@rackct?$AA@			; `string'
PUBLIC	??_C@_0N@JEJPAJOB@rackstations?$AA@		; `string'
PUBLIC	??_C@_0O@GLFHNJDN@rackjettmodes?$AA@		; `string'
PUBLIC	??_C@_09EONNKBLK@emergency?$AA@			; `string'
PUBLIC	??_C@_09MFNPLDDN@selective?$AA@			; `string'
PUBLIC	??_C@_0O@EOKBAANG@weapjettmodes?$AA@		; `string'
PUBLIC	??_C@_06JJCACEBF@addswd?$AA@			; `string'
PUBLIC	??_C@_06PKDNDI@addwid?$AA@			; `string'
PUBLIC	??_C@_0M@IBPCJFOL@racksmsname?$AA@		; `string'
PUBLIC	??_C@_07JGEAAKKP@?9?9?9?9?9?9?9?$AA@		; `string'
PUBLIC	??_C@_0N@FOOPBGPI@addloadorder?$AA@		; `string'
PUBLIC	??_C@_09FNCMODGJ@addwclass?$AA@			; `string'
PUBLIC	??_C@_03MKHEFFMA@aim?$AA@			; `string'
PUBLIC	??_C@_06NHDMJEKK@rocket?$AA@			; `string'
PUBLIC	??_C@_04KOKOJKMM@bomb?$AA@			; `string'
PUBLIC	??_C@_03NBAOADML@gun?$AA@			; `string'
PUBLIC	??_C@_03EIIBEHEB@ecm?$AA@			; `string'
PUBLIC	??_C@_04HCFFIKMN@tank?$AA@			; `string'
PUBLIC	??_C@_03MAOKHIMK@agm?$AA@			; `string'
PUBLIC	??_C@_04JECDANNM@harm?$AA@			; `string'
PUBLIC	??_C@_03DOHHJLGM@sam?$AA@			; `string'
PUBLIC	??_C@_03GBFBHNKE@gbu?$AA@			; `string'
PUBLIC	??_C@_06FNKMPIBD@camera?$AA@			; `string'
PUBLIC	??_C@_06IPKLEPOC@addany?$AA@			; `string'
PUBLIC	??_C@_0M@DGIIHOML@definegroup?$AA@		; `string'
PUBLIC	??_C@_08EPFDLFPB@addpylon?$AA@			; `string'
PUBLIC	??_C@_07KGBAEBNF@addrack?$AA@			; `string'
PUBLIC	??_C@_07PBBCECPI@pylonct?$AA@			; `string'
PUBLIC	??_C@_0N@KFAKCFEK@pylonsmsname?$AA@		; `string'
PUBLIC	??_C@_0P@BHCKMDOB@pylonjettmodes?$AA@		; `string'
PUBLIC	??_R4RDRackNode@@6B@				; RDRackNode::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVRDRackNode@@@8				; RDRackNode `RTTI Type Descriptor'
PUBLIC	??_R3RDRackNode@@8				; RDRackNode::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2RDRackNode@@8				; RDRackNode::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@RDRackNode@@8			; RDRackNode::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@ANode@@8				; ANode::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVANode@@@8				; ANode `RTTI Type Descriptor'
PUBLIC	??_R3ANode@@8					; ANode::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ANode@@8					; ANode::`RTTI Base Class Array'
PUBLIC	??_R4RDLoadOrderNode@@6B@			; RDLoadOrderNode::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVRDLoadOrderNode@@@8			; RDLoadOrderNode `RTTI Type Descriptor'
PUBLIC	??_R3RDLoadOrderNode@@8				; RDLoadOrderNode::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2RDLoadOrderNode@@8				; RDLoadOrderNode::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@RDLoadOrderNode@@8		; RDLoadOrderNode::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4RDRackNameNode@@6B@			; RDRackNameNode::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVRDRackNameNode@@@8			; RDRackNameNode `RTTI Type Descriptor'
PUBLIC	??_R3RDRackNameNode@@8				; RDRackNameNode::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2RDRackNameNode@@8				; RDRackNameNode::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@RDRackNameNode@@8			; RDRackNameNode::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4RDPylonNode@@6B@				; RDPylonNode::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVRDPylonNode@@@8				; RDPylonNode `RTTI Type Descriptor'
PUBLIC	??_R3RDPylonNode@@8				; RDPylonNode::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2RDPylonNode@@8				; RDPylonNode::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@RDPylonNode@@8			; RDPylonNode::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4RDHardpointNode@@6B@			; RDHardpointNode::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVRDHardpointNode@@@8			; RDHardpointNode `RTTI Type Descriptor'
PUBLIC	??_R3RDHardpointNode@@8				; RDHardpointNode::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2RDHardpointNode@@8				; RDHardpointNode::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@RDHardpointNode@@8		; RDHardpointNode::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@3e4ccccd
PUBLIC	__real@3f800000
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	_fclose:PROC
EXTRN	_feof:PROC
EXTRN	_fgets:PROC
EXTRN	_fopen:PROC
EXTRN	_fprintf:PROC
EXTRN	_fread:PROC
EXTRN	_fseek:PROC
EXTRN	_ftell:PROC
EXTRN	_sscanf:PROC
EXTRN	_sprintf:PROC
EXTRN	_exit:PROC
EXTRN	_atoi:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	_memset:PROC
EXTRN	_strcpy:PROC
EXTRN	_strcat:PROC
EXTRN	_strchr:PROC
EXTRN	_strncpy:PROC
EXTRN	_strtok:PROC
EXTRN	_stricmp:PROC
EXTRN	_isdigit:PROC
EXTRN	_isspace:PROC
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	?OpenCampFile@@YAPAU_iobuf@@PAD00@Z:PROC	; OpenCampFile
EXTRN	?InitClassTableAndData@@YAXPAD0@Z:PROC		; InitClassTableAndData
EXTRN	??0ANode@@QAE@XZ:PROC				; ANode::ANode
EXTRN	?GetSucc@ANode@@QAEPAXXZ:PROC			; ANode::GetSucc
EXTRN	??1ANode@@QAE@XZ:PROC				; ANode::~ANode
EXTRN	??0AList@@QAE@XZ:PROC				; AList::AList
EXTRN	?RemHead@AList@@QAEPAXXZ:PROC			; AList::RemHead
EXTRN	?AddTail@AList@@QAEXPAVANode@@@Z:PROC		; AList::AddTail
EXTRN	?GetHead@AList@@QAEPAXXZ:PROC			; AList::GetHead
EXTRN	?TokenI@@YAHH@Z:PROC				; TokenI
EXTRN	?TokenStr@@YAPADPAD@Z:PROC			; TokenStr
EXTRN	?TokenEnum@@YAHPAPADH@Z:PROC			; TokenEnum
EXTRN	?SetTokenString@@YAXPAD@Z:PROC			; SetTokenString
EXTRN	?LoadMissionData@@YAHXZ:PROC			; LoadMissionData
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__chkstk:PROC
EXTRN	?NumEntities@@3HA:DWORD				; NumEntities
EXTRN	?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A:DWORD ; Falcon4ClassTable
EXTRN	?FalconObjectDataDir@@3PADA:BYTE		; FalconObjectDataDir
EXTRN	?VisualDataTable@@3PAUVisualDataType@@A:DWORD	; VisualDataTable
EXTRN	?NumVisualEntries@@3FA:WORD			; NumVisualEntries
EXTRN	?IRSTDataTable@@3PAUIRSTDataType@@A:DWORD	; IRSTDataTable
EXTRN	?NumIRSTEntries@@3FA:WORD			; NumIRSTEntries
EXTRN	?RwrDataTable@@3PAURwrDataType@@A:DWORD		; RwrDataTable
EXTRN	?NumRwrEntries@@3FA:WORD			; NumRwrEntries
EXTRN	?RadarDataTable@@3PAURadarDataType@@A:DWORD	; RadarDataTable
EXTRN	?NumRadarEntries@@3FA:WORD			; NumRadarEntries
EXTRN	?F4SessionUpdateTime@@3HA:DWORD			; F4SessionUpdateTime
EXTRN	?F4SessionAliveTimeout@@3HA:DWORD		; F4SessionAliveTimeout
EXTRN	?g_bDisplayTrees@@3_NA:BYTE			; g_bDisplayTrees
EXTRN	?g_bFFDBC@@3_NA:BYTE				; g_bFFDBC
EXTRN	?g_bCheckFeatureIndex@@3_NA:BYTE		; g_bCheckFeatureIndex
EXTRN	?g_nSessionTimeout@@3HA:DWORD			; g_nSessionTimeout
EXTRN	?g_nSessionUpdateRate@@3HA:DWORD		; g_nSessionUpdateRate
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
	ALIGN	4

_idmap	DD	0578H DUP (?)
?RDRackList@@3VAList@@A DB 018H DUP (?)			; RDRackList
?RDHardpointList@@3VAList@@A DB 018H DUP (?)		; RDHardpointList
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3e4ccccd
CONST	SEGMENT
__real@3e4ccccd DD 03e4ccccdr			; 0.2
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@RDHardpointNode@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@RDHardpointNode@@8 DD FLAT:??_R0?AVRDHardpointNode@@@8 ; RDHardpointNode::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3RDHardpointNode@@8
rdata$r	ENDS
;	COMDAT ??_R2RDHardpointNode@@8
rdata$r	SEGMENT
??_R2RDHardpointNode@@8 DD FLAT:??_R1A@?0A@EA@RDHardpointNode@@8 ; RDHardpointNode::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ANode@@8
rdata$r	ENDS
;	COMDAT ??_R3RDHardpointNode@@8
rdata$r	SEGMENT
??_R3RDHardpointNode@@8 DD 00H				; RDHardpointNode::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2RDHardpointNode@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVRDHardpointNode@@@8
_DATA	SEGMENT
??_R0?AVRDHardpointNode@@@8 DD FLAT:??_7type_info@@6B@	; RDHardpointNode `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVRDHardpointNode@@', 00H
_DATA	ENDS
;	COMDAT ??_R4RDHardpointNode@@6B@
rdata$r	SEGMENT
??_R4RDHardpointNode@@6B@ DD 00H			; RDHardpointNode::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVRDHardpointNode@@@8
	DD	FLAT:??_R3RDHardpointNode@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@RDPylonNode@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@RDPylonNode@@8 DD FLAT:??_R0?AVRDPylonNode@@@8 ; RDPylonNode::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3RDPylonNode@@8
rdata$r	ENDS
;	COMDAT ??_R2RDPylonNode@@8
rdata$r	SEGMENT
??_R2RDPylonNode@@8 DD FLAT:??_R1A@?0A@EA@RDPylonNode@@8 ; RDPylonNode::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ANode@@8
rdata$r	ENDS
;	COMDAT ??_R3RDPylonNode@@8
rdata$r	SEGMENT
??_R3RDPylonNode@@8 DD 00H				; RDPylonNode::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2RDPylonNode@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVRDPylonNode@@@8
_DATA	SEGMENT
??_R0?AVRDPylonNode@@@8 DD FLAT:??_7type_info@@6B@	; RDPylonNode `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVRDPylonNode@@', 00H
_DATA	ENDS
;	COMDAT ??_R4RDPylonNode@@6B@
rdata$r	SEGMENT
??_R4RDPylonNode@@6B@ DD 00H				; RDPylonNode::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVRDPylonNode@@@8
	DD	FLAT:??_R3RDPylonNode@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@RDRackNameNode@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@RDRackNameNode@@8 DD FLAT:??_R0?AVRDRackNameNode@@@8 ; RDRackNameNode::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3RDRackNameNode@@8
rdata$r	ENDS
;	COMDAT ??_R2RDRackNameNode@@8
rdata$r	SEGMENT
??_R2RDRackNameNode@@8 DD FLAT:??_R1A@?0A@EA@RDRackNameNode@@8 ; RDRackNameNode::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ANode@@8
rdata$r	ENDS
;	COMDAT ??_R3RDRackNameNode@@8
rdata$r	SEGMENT
??_R3RDRackNameNode@@8 DD 00H				; RDRackNameNode::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2RDRackNameNode@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVRDRackNameNode@@@8
_DATA	SEGMENT
??_R0?AVRDRackNameNode@@@8 DD FLAT:??_7type_info@@6B@	; RDRackNameNode `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVRDRackNameNode@@', 00H
_DATA	ENDS
;	COMDAT ??_R4RDRackNameNode@@6B@
rdata$r	SEGMENT
??_R4RDRackNameNode@@6B@ DD 00H				; RDRackNameNode::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVRDRackNameNode@@@8
	DD	FLAT:??_R3RDRackNameNode@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@RDLoadOrderNode@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@RDLoadOrderNode@@8 DD FLAT:??_R0?AVRDLoadOrderNode@@@8 ; RDLoadOrderNode::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3RDLoadOrderNode@@8
rdata$r	ENDS
;	COMDAT ??_R2RDLoadOrderNode@@8
rdata$r	SEGMENT
??_R2RDLoadOrderNode@@8 DD FLAT:??_R1A@?0A@EA@RDLoadOrderNode@@8 ; RDLoadOrderNode::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ANode@@8
rdata$r	ENDS
;	COMDAT ??_R3RDLoadOrderNode@@8
rdata$r	SEGMENT
??_R3RDLoadOrderNode@@8 DD 00H				; RDLoadOrderNode::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2RDLoadOrderNode@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVRDLoadOrderNode@@@8
_DATA	SEGMENT
??_R0?AVRDLoadOrderNode@@@8 DD FLAT:??_7type_info@@6B@	; RDLoadOrderNode `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVRDLoadOrderNode@@', 00H
_DATA	ENDS
;	COMDAT ??_R4RDLoadOrderNode@@6B@
rdata$r	SEGMENT
??_R4RDLoadOrderNode@@6B@ DD 00H			; RDLoadOrderNode::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVRDLoadOrderNode@@@8
	DD	FLAT:??_R3RDLoadOrderNode@@8
rdata$r	ENDS
;	COMDAT ??_R2ANode@@8
rdata$r	SEGMENT
??_R2ANode@@8 DD FLAT:??_R1A@?0A@EA@ANode@@8		; ANode::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3ANode@@8
rdata$r	SEGMENT
??_R3ANode@@8 DD 00H					; ANode::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2ANode@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVANode@@@8
_DATA	SEGMENT
??_R0?AVANode@@@8 DD FLAT:??_7type_info@@6B@		; ANode `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVANode@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@ANode@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ANode@@8 DD FLAT:??_R0?AVANode@@@8	; ANode::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ANode@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@RDRackNode@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@RDRackNode@@8 DD FLAT:??_R0?AVRDRackNode@@@8 ; RDRackNode::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3RDRackNode@@8
rdata$r	ENDS
;	COMDAT ??_R2RDRackNode@@8
rdata$r	SEGMENT
??_R2RDRackNode@@8 DD FLAT:??_R1A@?0A@EA@RDRackNode@@8	; RDRackNode::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ANode@@8
rdata$r	ENDS
;	COMDAT ??_R3RDRackNode@@8
rdata$r	SEGMENT
??_R3RDRackNode@@8 DD 00H				; RDRackNode::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2RDRackNode@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVRDRackNode@@@8
_DATA	SEGMENT
??_R0?AVRDRackNode@@@8 DD FLAT:??_7type_info@@6B@	; RDRackNode `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVRDRackNode@@', 00H
_DATA	ENDS
;	COMDAT ??_R4RDRackNode@@6B@
rdata$r	SEGMENT
??_R4RDRackNode@@6B@ DD 00H				; RDRackNode::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVRDRackNode@@@8
	DD	FLAT:??_R3RDRackNode@@8
rdata$r	ENDS
;	COMDAT ??_C@_0P@BHCKMDOB@pylonjettmodes?$AA@
CONST	SEGMENT
??_C@_0P@BHCKMDOB@pylonjettmodes?$AA@ DB 'pylonjettmodes', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KFAKCFEK@pylonsmsname?$AA@
CONST	SEGMENT
??_C@_0N@KFAKCFEK@pylonsmsname?$AA@ DB 'pylonsmsname', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07PBBCECPI@pylonct?$AA@
CONST	SEGMENT
??_C@_07PBBCECPI@pylonct?$AA@ DB 'pylonct', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07KGBAEBNF@addrack?$AA@
CONST	SEGMENT
??_C@_07KGBAEBNF@addrack?$AA@ DB 'addrack', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08EPFDLFPB@addpylon?$AA@
CONST	SEGMENT
??_C@_08EPFDLFPB@addpylon?$AA@ DB 'addpylon', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DGIIHOML@definegroup?$AA@
CONST	SEGMENT
??_C@_0M@DGIIHOML@definegroup?$AA@ DB 'definegroup', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06IPKLEPOC@addany?$AA@
CONST	SEGMENT
??_C@_06IPKLEPOC@addany?$AA@ DB 'addany', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FNKMPIBD@camera?$AA@
CONST	SEGMENT
??_C@_06FNKMPIBD@camera?$AA@ DB 'camera', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03GBFBHNKE@gbu?$AA@
CONST	SEGMENT
??_C@_03GBFBHNKE@gbu?$AA@ DB 'gbu', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03DOHHJLGM@sam?$AA@
CONST	SEGMENT
??_C@_03DOHHJLGM@sam?$AA@ DB 'sam', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04JECDANNM@harm?$AA@
CONST	SEGMENT
??_C@_04JECDANNM@harm?$AA@ DB 'harm', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03MAOKHIMK@agm?$AA@
CONST	SEGMENT
??_C@_03MAOKHIMK@agm?$AA@ DB 'agm', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04HCFFIKMN@tank?$AA@
CONST	SEGMENT
??_C@_04HCFFIKMN@tank?$AA@ DB 'tank', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03EIIBEHEB@ecm?$AA@
CONST	SEGMENT
??_C@_03EIIBEHEB@ecm?$AA@ DB 'ecm', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03NBAOADML@gun?$AA@
CONST	SEGMENT
??_C@_03NBAOADML@gun?$AA@ DB 'gun', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04KOKOJKMM@bomb?$AA@
CONST	SEGMENT
??_C@_04KOKOJKMM@bomb?$AA@ DB 'bomb', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06NHDMJEKK@rocket?$AA@
CONST	SEGMENT
??_C@_06NHDMJEKK@rocket?$AA@ DB 'rocket', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03MKHEFFMA@aim?$AA@
CONST	SEGMENT
??_C@_03MKHEFFMA@aim?$AA@ DB 'aim', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09FNCMODGJ@addwclass?$AA@
CONST	SEGMENT
??_C@_09FNCMODGJ@addwclass?$AA@ DB 'addwclass', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FOOPBGPI@addloadorder?$AA@
CONST	SEGMENT
??_C@_0N@FOOPBGPI@addloadorder?$AA@ DB 'addloadorder', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07JGEAAKKP@?9?9?9?9?9?9?9?$AA@
CONST	SEGMENT
??_C@_07JGEAAKKP@?9?9?9?9?9?9?9?$AA@ DB '-------', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IBPCJFOL@racksmsname?$AA@
CONST	SEGMENT
??_C@_0M@IBPCJFOL@racksmsname?$AA@ DB 'racksmsname', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06PKDNDI@addwid?$AA@
CONST	SEGMENT
??_C@_06PKDNDI@addwid?$AA@ DB 'addwid', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06JJCACEBF@addswd?$AA@
CONST	SEGMENT
??_C@_06JJCACEBF@addswd?$AA@ DB 'addswd', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@EOKBAANG@weapjettmodes?$AA@
CONST	SEGMENT
??_C@_0O@EOKBAANG@weapjettmodes?$AA@ DB 'weapjettmodes', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09MFNPLDDN@selective?$AA@
CONST	SEGMENT
??_C@_09MFNPLDDN@selective?$AA@ DB 'selective', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09EONNKBLK@emergency?$AA@
CONST	SEGMENT
??_C@_09EONNKBLK@emergency?$AA@ DB 'emergency', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GLFHNJDN@rackjettmodes?$AA@
CONST	SEGMENT
??_C@_0O@GLFHNJDN@rackjettmodes?$AA@ DB 'rackjettmodes', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JEJPAJOB@rackstations?$AA@
CONST	SEGMENT
??_C@_0N@JEJPAJOB@rackstations?$AA@ DB 'rackstations', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06OJLLIJGI@rackct?$AA@
CONST	SEGMENT
??_C@_06OJLLIJGI@rackct?$AA@ DB 'rackct', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OMMGGKKO@definerack?$AA@
CONST	SEGMENT
??_C@_0L@OMMGGKKO@definerack?$AA@ DB 'definerack', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02NCJKDDL@?6?$AA?$AA@
CONST	SEGMENT
??_C@_02NCJKDDL@?6?$AA?$AA@ DB 0aH, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03ILLHFMNI@?5?7?6?$AA@
CONST	SEGMENT
??_C@_03ILLHFMNI@?5?7?6?$AA@ DB ' ', 09H, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EHPGPFLM@BMSRack?4dat?$AA@
CONST	SEGMENT
??_C@_0M@EHPGPFLM@BMSRack?4dat?$AA@ DB 'BMSRack.dat', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07FDHCEADO@BMSRack?$AA@
CONST	SEGMENT
??_C@_07FDHCEADO@BMSRack?$AA@ DB 'BMSRack', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7RDHardpointNode@@6B@
CONST	SEGMENT
??_7RDHardpointNode@@6B@ DD FLAT:??_R4RDHardpointNode@@6B@ ; RDHardpointNode::`vftable'
	DD	FLAT:?CompareWith@ANode@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT ??_7RDPylonNode@@6B@
CONST	SEGMENT
??_7RDPylonNode@@6B@ DD FLAT:??_R4RDPylonNode@@6B@	; RDPylonNode::`vftable'
	DD	FLAT:?CompareWith@ANode@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT ??_7RDRackNameNode@@6B@
CONST	SEGMENT
??_7RDRackNameNode@@6B@ DD FLAT:??_R4RDRackNameNode@@6B@ ; RDRackNameNode::`vftable'
	DD	FLAT:?CompareWith@ANode@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT ??_7RDLoadOrderNode@@6B@
CONST	SEGMENT
??_7RDLoadOrderNode@@6B@ DD FLAT:??_R4RDLoadOrderNode@@6B@ ; RDLoadOrderNode::`vftable'
	DD	FLAT:?CompareWith@ANode@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT ??_7RDRackNode@@6B@
CONST	SEGMENT
??_7RDRackNode@@6B@ DD FLAT:??_R4RDRackNode@@6B@	; RDRackNode::`vftable'
	DD	FLAT:?CompareWith@ANode@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT ??_C@_0N@DNBHIEDB@Rack?$CFd?5?$CFd?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0N@DNBHIEDB@Rack?$CFd?5?$CFd?5?$CFd?$AA@ DB 'Rack%d %d %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EPMLFDLC@NumRacks?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0M@EPMLFDLC@NumRacks?5?$CFd?$AA@ DB 'NumRacks %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07FOMKHCGE@Group?$CFd?$AA@
CONST	SEGMENT
??_C@_07FOMKHCGE@Group?$CFd?$AA@ DB 'Group%d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KPJEKBOE@NumGroups?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0N@KPJEKBOE@NumGroups?5?$CFd?$AA@ DB 'NumGroups %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05BMGBEOOC@?$CFs?2?$CFs?$AA@
CONST	SEGMENT
??_C@_05BMGBEOOC@?$CFs?2?$CFs?$AA@ DB '%s\%s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08EJINGHLB@Rack?4dat?$AA@
CONST	SEGMENT
??_C@_08EJINGHLB@Rack?4dat?$AA@ DB 'Rack.dat', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04DEAMMDDK@Rack?$AA@
CONST	SEGMENT
??_C@_04DEAMMDDK@Rack?$AA@ DB 'Rack', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03GILJFNFC@dat?$AA@
CONST	SEGMENT
??_C@_03GILJFNFC@dat?$AA@ DB 'dat', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08HDFMCMGC@?$CFd?5?$DN?$DO?5?$CFd?$AA@
CONST	SEGMENT
??_C@_08HDFMCMGC@?$CFd?5?$DN?$DO?5?$CFd?$AA@ DB '%d => %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05DIHJPEMC@visid?$AA@
CONST	SEGMENT
??_C@_05DIHJPEMC@visid?$AA@ DB 'visid', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03HBNNNHNM@map?$AA@
CONST	SEGMENT
??_C@_03HBNNNHNM@map?$AA@ DB 'map', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02BMJICGCB@rt?$AA@
CONST	SEGMENT
??_C@_02BMJICGCB@rt?$AA@ DB 'rt', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03PNOMJKEH@SSD?$AA@
CONST	SEGMENT
??_C@_03PNOMJKEH@SSD?$AA@ DB 'SSD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03BLNKKGCD@ACD?$AA@
CONST	SEGMENT
??_C@_03BLNKKGCD@ACD?$AA@ DB 'ACD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03PKOFDCJL@SWD?$AA@
CONST	SEGMENT
??_C@_03PKOFDCJL@SWD?$AA@ DB 'SWD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MHMJKHAJ@vsd?$AA@
CONST	SEGMENT
??_C@_03MHMJKHAJ@vsd?$AA@ DB 'vsd', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03EPKCJIIC@rwd?$AA@
CONST	SEGMENT
??_C@_03EPKCJIIC@rwd?$AA@ DB 'rwd', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03NOGOIOMM@ICD?$AA@
CONST	SEGMENT
??_C@_03NOGOIOMM@ICD?$AA@ DB 'ICD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03FJHGFOFC@RCD?$AA@
CONST	SEGMENT
??_C@_03FJHGFOFC@RCD?$AA@ DB 'RCD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03ICIAOCCI@FED?$AA@
CONST	SEGMENT
??_C@_03ICIAOCCI@FED?$AA@ DB 'FED', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04KCCPLAND@tree?$AA@
CONST	SEGMENT
??_C@_04KCCPLAND@tree?$AA@ DB 'tree', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02PIBHICFM@PD?$AA@
CONST	SEGMENT
??_C@_02PIBHICFM@PD?$AA@ DB 'PD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@HDPDKILO@ObjDataTable?$FL?$CFd?$FN?4PtDataIndex?5?$DO?$DN?5@
CONST	SEGMENT
??_C@_0DK@HDPDKILO@ObjDataTable?$FL?$CFd?$FN?4PtDataIndex?5?$DO?$DN?5@ DB 'O'
	DB	'bjDataTable[%d].PtDataIndex >= NumPtHeaders = %d or < 0', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@BIGLNPMG@PtHeaderDataTable?$FL?$CFd?$FN?4objId?$DN?$CFd?5?$DO@
CONST	SEGMENT
??_C@_0DK@BIGLNPMG@PtHeaderDataTable?$FL?$CFd?$FN?4objId?$DN?$CFd?5?$DO@ DB 'P'
	DB	'tHeaderDataTable[%d].objId=%d >= NumObjectiveEntries=%d', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@GNFNLJDK@PtHeaderDataTable?$FL?$CFd?$FN?4features?$FL?$CF@
CONST	SEGMENT
??_C@_0EG@GNFNLJDK@PtHeaderDataTable?$FL?$CFd?$FN?4features?$FL?$CF@ DB 'P'
	DB	'tHeaderDataTable[%d].features[%d]=%d >= Objective[%d]''s Feat'
	DB	'ures %d', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_03PPCKHJDI@PHD?$AA@
CONST	SEGMENT
??_C@_03PPCKHJDI@PHD?$AA@ DB 'PHD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03GFPEOJFN@WLD?$AA@
CONST	SEGMENT
??_C@_03GFPEOJFN@WLD?$AA@ DB 'WLD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03NGBEMJAF@VCD?$AA@
CONST	SEGMENT
??_C@_03NGBEMJAF@VCD?$AA@ DB 'VCD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03IGANJOJK@FCD?$AA@
CONST	SEGMENT
??_C@_03IGANJOJK@FCD?$AA@ DB 'FCD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03HOFJHMB@DDP?$AA@
CONST	SEGMENT
??_C@_03HOFJHMB@DDP?$AA@ DB 'DDP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03BNKHBNLL@RKT?$AA@
CONST	SEGMENT
??_C@_03BNKHBNLL@RKT?$AA@ DB 'RKT', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03GOKIKOGA@WCD?$AA@
CONST	SEGMENT
??_C@_03GOKIKOGA@WCD?$AA@ DB 'WCD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03PLAFNBBA@OCD?$AA@
CONST	SEGMENT
??_C@_03PLAFNBBA@OCD?$AA@ DB 'OCD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MEKBGGOL@UCD?$AA@
CONST	SEGMENT
??_C@_03MEKBGGOL@UCD?$AA@ DB 'UCD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@LPMLGJMG@Failed?5to?5load?5Dirty?5data?5priori@
CONST	SEGMENT
??_C@_0CF@LPMLGJMG@Failed?5to?5load?5Dirty?5data?5priori@ DB 'Failed to l'
	DB	'oad Dirty data priorities', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@GLINIFKA@Failed?5to?5load?5Rocket?5data?$AA@
CONST	SEGMENT
??_C@_0BL@GLINIFKA@Failed?5to?5load?5Rocket?5data?$AA@ DB 'Failed to load'
	DB	' Rocket data', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@KBILOMDH@Failed?5to?5load?5Squadron?5stores?5d@
CONST	SEGMENT
??_C@_0CE@KBILOMDH@Failed?5to?5load?5Squadron?5stores?5d@ DB 'Failed to l'
	DB	'oad Squadron stores data', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@IJBFJPCM@Failed?5to?5load?5AC?5Definition?5dat@
CONST	SEGMENT
??_C@_0CC@IJBFJPCM@Failed?5to?5load?5AC?5Definition?5dat@ DB 'Failed to l'
	DB	'oad AC Definition data', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@ENPFIBAL@Failed?5to?5load?5SimWeapon?5data?$AA@
CONST	SEGMENT
??_C@_0BO@ENPFIBAL@Failed?5to?5load?5SimWeapon?5data?$AA@ DB 'Failed to l'
	DB	'oad SimWeapon data', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@BDOJLAME@Failed?5to?5load?5Visual?5data?$AA@
CONST	SEGMENT
??_C@_0BL@BDOJLAME@Failed?5to?5load?5Visual?5data?$AA@ DB 'Failed to load'
	DB	' Visual data', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@MILFPPLL@Failed?5to?5load?5Rwr?5data?$AA@
CONST	SEGMENT
??_C@_0BI@MILFPPLL@Failed?5to?5load?5Rwr?5data?$AA@ DB 'Failed to load Rw'
	DB	'r data', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@DLENKPCC@Failed?5to?5load?5IRST?5data?$AA@
CONST	SEGMENT
??_C@_0BJ@DLENKPCC@Failed?5to?5load?5IRST?5data?$AA@ DB 'Failed to load I'
	DB	'RST data', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@DDAGKKGO@Failed?5to?5load?5radar?5data?$AA@
CONST	SEGMENT
??_C@_0BK@DDAGKKGO@Failed?5to?5load?5radar?5data?$AA@ DB 'Failed to load '
	DB	'radar data', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@DOBMODNN@Failed?5to?5load?5point?5data?$AA@
CONST	SEGMENT
??_C@_0BK@DOBMODNN@Failed?5to?5load?5point?5data?$AA@ DB 'Failed to load '
	DB	'point data', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@IDIHOGAD@Failed?5to?5load?5point?5headers?$AA@
CONST	SEGMENT
??_C@_0BN@IDIHOGAD@Failed?5to?5load?5point?5headers?$AA@ DB 'Failed to lo'
	DB	'ad point headers', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@LGIADBKK@Failed?5to?5load?5weapon?5list?$AA@
CONST	SEGMENT
??_C@_0BL@LGIADBKK@Failed?5to?5load?5weapon?5list?$AA@ DB 'Failed to load'
	DB	' weapon list', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@PPALOCAG@Failed?5to?5load?5vehicle?5data?$AA@
CONST	SEGMENT
??_C@_0BM@PPALOCAG@Failed?5to?5load?5vehicle?5data?$AA@ DB 'Failed to loa'
	DB	'd vehicle data', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FEPKGIOD@Failed?5to?5load?5feature?5data?$AA@
CONST	SEGMENT
??_C@_0BM@FEPKGIOD@Failed?5to?5load?5feature?5data?$AA@ DB 'Failed to loa'
	DB	'd feature data', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@HBLOKCBF@Failed?5to?5load?5weapon?5data?$AA@
CONST	SEGMENT
??_C@_0BL@HBLOKCBF@Failed?5to?5load?5weapon?5data?$AA@ DB 'Failed to load'
	DB	' weapon data', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@EGFMBGCP@Failed?5to?5load?5objective?5data?$AA@
CONST	SEGMENT
??_C@_0BO@EGFMBGCP@Failed?5to?5load?5objective?5data?$AA@ DB 'Failed to l'
	DB	'oad objective data', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@EKGKJCFC@Failed?5to?5load?5feature?5entries?$AA@
CONST	SEGMENT
??_C@_0BP@EKGKJCFC@Failed?5to?5load?5feature?5entries?$AA@ DB 'Failed to '
	DB	'load feature entries', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@FKDHIIHL@Failed?5to?5load?5unit?5data?$AA@
CONST	SEGMENT
??_C@_0BJ@FKDHIIHL@Failed?5to?5load?5unit?5data?$AA@ DB 'Failed to load u'
	DB	'nit data', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FGKKLFGH@Error?3?5?5?$CF0d?5?5?$CFs?5?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BE@FGKKLFGH@Error?3?5?5?$CF0d?5?5?$CFs?5?5?$CFs?$AA@ DB 'Error:  %'
	DB	'0d  %s  %s', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IGAEJGCL@Entity?4cpp?$AA@
CONST	SEGMENT
??_C@_0L@IGAEJGCL@Entity?4cpp?$AA@ DB 'Entity.cpp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CFLADCE@Feb?518?52013?$AA@
CONST	SEGMENT
??_C@_0M@CFLADCE@Feb?518?52013?$AA@ DB 'Feb 18 2013', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@GFGDACML@C?3?2Objective?9Errors?4txt?$AA@
CONST	SEGMENT
??_C@_0BI@GFGDACML@C?3?2Objective?9Errors?4txt?$AA@ DB 'C:\Objective-Erro'
	DB	'rs.txt', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01NOFIACDB@w?$AA@
CONST	SEGMENT
??_C@_01NOFIACDB@w?$AA@ DB 'w', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0RDHardpointNode@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0RDHardpointNode@@QAE@XZ$0
__ehfuncinfo$??0RDHardpointNode@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0RDHardpointNode@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1AList@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1AList@@QAE@XZ$0
__ehfuncinfo$??1AList@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1AList@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
xdata$x	SEGMENT
__unwindtable$??0RDPylonNode@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0RDPylonNode@@QAE@XZ$0
__unwindtable$??0RDRackNode@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0RDRackNode@@QAE@XZ$0
__unwindtable$??1RDHardpointNode@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1RDHardpointNode@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1RDHardpointNode@@QAE@XZ$1
__unwindtable$??1RDPylonNode@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1RDPylonNode@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1RDPylonNode@@QAE@XZ$1
__unwindtable$??1RDRackNode@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1RDRackNode@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1RDRackNode@@QAE@XZ$1
__ehfuncinfo$??1RDHardpointNode@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1RDHardpointNode@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??1RDPylonNode@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1RDPylonNode@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??0RDPylonNode@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0RDPylonNode@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??1RDRackNode@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1RDRackNode@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??0RDRackNode@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0RDRackNode@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?RDLoadRackData@@YAXXZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?RDLoadRackData@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?RDLoadRackData@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RDLoadRackData@@YAXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?RDLoadRackData@@YAXXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?RDLoadRackData@@YAXXZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?RDLoadRackData@@YAXXZ$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?RDLoadRackData@@YAXXZ$4
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_RDRackList$initializer$ DD FLAT:??__ERDRackList@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_RDHardpointList$initializer$ DD FLAT:??__ERDHardpointList@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\entity.cpp
_TEXT	SEGMENT
_lon$ = -4						; size = 4
_count$ = 8						; size = 4
_pn$ = 12						; size = 4
_rn$ = 16						; size = 4
_rd$ = 20						; size = 4
?RDCopyRackData@@YAXHPAVRDPylonNode@@PAVRDRackNode@@PAURDRackData@@@Z PROC ; RDCopyRackData

; 2099 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2100 : 	rd->rackCT		  = rn->rackCT;

	mov	eax, DWORD PTR _rd$[ebp]
	mov	ecx, DWORD PTR _rn$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	DWORD PTR [eax+12], edx

; 2101 : 	rd->pylonCT		  = pn->pylonCT;

	mov	eax, DWORD PTR _rd$[ebp]
	mov	ecx, DWORD PTR _pn$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+8], edx

; 2102 : 	rd->rackStations  = rn->stations;

	mov	eax, DWORD PTR _rd$[ebp]
	mov	ecx, DWORD PTR _rn$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	DWORD PTR [eax+16], edx

; 2103 : 	rd->flags         = pn->flags | rn->flags | RDF_BMSDEFINITION;

	mov	eax, DWORD PTR _pn$[ebp]
	mov	ecx, DWORD PTR _rn$[ebp]
	mov	edx, DWORD PTR [eax+28]
	or	edx, DWORD PTR [ecx+92]
	or	edx, 1
	mov	eax, DWORD PTR _rd$[ebp]
	mov	DWORD PTR [eax+20], edx

; 2104 : 	rd->pylonmnemonic = pn->mnemonic;

	mov	ecx, DWORD PTR _pn$[ebp]
	add	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _rd$[ebp]
	mov	DWORD PTR [edx], ecx

; 2105 : 	rd->rackmnemonic  = rn->mnemonic;

	mov	eax, DWORD PTR _rn$[ebp]
	add	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _rd$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 2106 : 	rd->count         = count;

	mov	edx, DWORD PTR _rd$[ebp]
	mov	eax, DWORD PTR _count$[ebp]
	mov	DWORD PTR [edx+24], eax

; 2107 : 
; 2108 : 	RDLoadOrderNode *lon;
; 2109 : 
; 2110 : 	lon=(RDLoadOrderNode *)rn->loadOrder.GetHead();

	mov	ecx, DWORD PTR _rn$[ebp]
	add	ecx, 96					; 00000060H
	call	?GetHead@AList@@QAEPAXXZ		; AList::GetHead
	mov	DWORD PTR _lon$[ebp], eax
$LN4@RDCopyRack:

; 2111 : 
; 2112 : 	while(lon)

	cmp	DWORD PTR _lon$[ebp], 0
	je	SHORT $LN5@RDCopyRack

; 2113 : 	{
; 2114 : 		if(count<=lon->count)

	mov	ecx, DWORD PTR _lon$[ebp]
	mov	edx, DWORD PTR _count$[ebp]
	cmp	edx, DWORD PTR [ecx+12]
	jg	SHORT $LN2@RDCopyRack

; 2115 : 		{
; 2116 : 			// loan the array to the HP
; 2117 : 			rd->loadOrder = lon->loadOrder;

	mov	eax, DWORD PTR _rd$[ebp]
	mov	ecx, DWORD PTR _lon$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+28], edx

; 2118 : 			lon = NULL;

	mov	DWORD PTR _lon$[ebp], 0

; 2119 : 		}
; 2120 : 		else

	jmp	SHORT $LN1@RDCopyRack
$LN2@RDCopyRack:

; 2121 : 			lon=(RDLoadOrderNode *)lon->GetSucc();

	mov	ecx, DWORD PTR _lon$[ebp]
	call	?GetSucc@ANode@@QAEPAXXZ		; ANode::GetSucc
	mov	DWORD PTR _lon$[ebp], eax
$LN1@RDCopyRack:

; 2122 : 	}

	jmp	SHORT $LN4@RDCopyRack
$LN5@RDCopyRack:

; 2123 : 
; 2124 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RDCopyRackData@@YAXHPAVRDPylonNode@@PAVRDRackNode@@PAURDRackData@@@Z ENDP ; RDCopyRackData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\entity.cpp
_TEXT	SEGMENT
_rnn$ = -20						; size = 4
_l$1 = -16						; size = 4
_hpn$ = -12						; size = 4
_pn$ = -8						; size = 4
_rn$ = -4						; size = 4
_GroupId$ = 8						; size = 4
_wClass$ = 12						; size = 4
_WeaponCount$ = 16					; size = 4
_rd$ = 20						; size = 4
?RDFindBestRackWClass@@YAHHHHPAURDRackData@@@Z PROC	; RDFindBestRackWClass

; 2178 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 2179 : 	RDHardpointNode *hpn;
; 2180 : 	RDPylonNode *pn;
; 2181 : 	RDRackNameNode *rnn;
; 2182 : 	RDRackNode *rn;
; 2183 : 
; 2184 : 	hpn=(RDHardpointNode *)RDHardpointList.GetHead();

	mov	ecx, OFFSET ?RDHardpointList@@3VAList@@A ; RDHardpointList
	call	?GetHead@AList@@QAEPAXXZ		; AList::GetHead
	mov	DWORD PTR _hpn$[ebp], eax
$LN14@RDFindBest:

; 2185 : 	while(hpn)

	cmp	DWORD PTR _hpn$[ebp], 0
	je	$LN13@RDFindBest

; 2186 : 	{
; 2187 : 		if(hpn->groupId==GroupId)

	mov	eax, DWORD PTR _hpn$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR _GroupId$[ebp]
	jne	$LN12@RDFindBest

; 2188 : 		{
; 2189 : 			pn=(RDPylonNode *)hpn->pylonList.GetHead();

	mov	ecx, DWORD PTR _hpn$[ebp]
	add	ecx, 16					; 00000010H
	call	?GetHead@AList@@QAEPAXXZ		; AList::GetHead
	mov	DWORD PTR _pn$[ebp], eax
$LN11@RDFindBest:

; 2190 : 			while(pn)

	cmp	DWORD PTR _pn$[ebp], 0
	je	$LN12@RDFindBest

; 2191 : 			{
; 2192 : 				rnn=(RDRackNameNode *)pn->rackNameList.GetHead();

	mov	ecx, DWORD PTR _pn$[ebp]
	add	ecx, 32					; 00000020H
	call	?GetHead@AList@@QAEPAXXZ		; AList::GetHead
	mov	DWORD PTR _rnn$[ebp], eax
$LN9@RDFindBest:

; 2193 : 				while(rnn)

	cmp	DWORD PTR _rnn$[ebp], 0
	je	$LN8@RDFindBest

; 2194 : 				{
; 2195 : 					rn=(RDRackNode *)RDRackList.GetHead();

	mov	ecx, OFFSET ?RDRackList@@3VAList@@A	; RDRackList
	call	?GetHead@AList@@QAEPAXXZ		; AList::GetHead
	mov	DWORD PTR _rn$[ebp], eax
$LN7@RDFindBest:

; 2196 : 					while(rn)

	cmp	DWORD PTR _rn$[ebp], 0
	je	$LN6@RDFindBest

; 2197 : 					{
; 2198 : 						if(stricmp(rn->rackName,rnn->rackName)==0 &&
; 2199 : 										rn->stations >= WeaponCount)

	mov	edx, DWORD PTR _rnn$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	eax, DWORD PTR _rn$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN5@RDFindBest
	mov	ecx, DWORD PTR _rn$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	cmp	edx, DWORD PTR _WeaponCount$[ebp]
	jl	SHORT $LN5@RDFindBest

; 2200 : 						{
; 2201 : 							int l;
; 2202 : 							for(l=0;l<rn->wClassCount;l++)

	mov	DWORD PTR _l$1[ebp], 0
	jmp	SHORT $LN4@RDFindBest
$LN3@RDFindBest:
	mov	eax, DWORD PTR _l$1[ebp]
	add	eax, 1
	mov	DWORD PTR _l$1[ebp], eax
$LN4@RDFindBest:
	mov	ecx, DWORD PTR _rn$[ebp]
	mov	edx, DWORD PTR _l$1[ebp]
	cmp	edx, DWORD PTR [ecx+80]
	jge	SHORT $LN5@RDFindBest

; 2203 : 							{
; 2204 : 								if(rn->wClass[l]==wClass)

	mov	eax, DWORD PTR _rn$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	edx, DWORD PTR _l$1[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	eax, DWORD PTR _wClass$[ebp]
	jne	SHORT $LN1@RDFindBest

; 2205 : 								{ // a match!
; 2206 : 									RDCopyRackData(WeaponCount, pn,rn,rd);

	mov	ecx, DWORD PTR _rd$[ebp]
	push	ecx
	mov	edx, DWORD PTR _rn$[ebp]
	push	edx
	mov	eax, DWORD PTR _pn$[ebp]
	push	eax
	mov	ecx, DWORD PTR _WeaponCount$[ebp]
	push	ecx
	call	?RDCopyRackData@@YAXHPAVRDPylonNode@@PAVRDRackNode@@PAURDRackData@@@Z ; RDCopyRackData
	add	esp, 16					; 00000010H

; 2207 : 									return 1;

	mov	eax, 1
	jmp	SHORT $LN15@RDFindBest
$LN1@RDFindBest:

; 2208 : 								}
; 2209 : 							}

	jmp	SHORT $LN3@RDFindBest
$LN5@RDFindBest:

; 2210 : 
; 2211 : 						}
; 2212 : 						rn=(RDRackNode *)rn->GetSucc();

	mov	ecx, DWORD PTR _rn$[ebp]
	call	?GetSucc@ANode@@QAEPAXXZ		; ANode::GetSucc
	mov	DWORD PTR _rn$[ebp], eax

; 2213 : 					}

	jmp	$LN7@RDFindBest
$LN6@RDFindBest:

; 2214 : 
; 2215 : 					rnn=(RDRackNameNode *)rnn->GetSucc();

	mov	ecx, DWORD PTR _rnn$[ebp]
	call	?GetSucc@ANode@@QAEPAXXZ		; ANode::GetSucc
	mov	DWORD PTR _rnn$[ebp], eax

; 2216 : 				}

	jmp	$LN9@RDFindBest
$LN8@RDFindBest:

; 2217 : 				pn=(RDPylonNode *)pn->GetSucc();

	mov	ecx, DWORD PTR _pn$[ebp]
	call	?GetSucc@ANode@@QAEPAXXZ		; ANode::GetSucc
	mov	DWORD PTR _pn$[ebp], eax

; 2218 : 			}

	jmp	$LN11@RDFindBest
$LN12@RDFindBest:

; 2219 : 		}
; 2220 : 		hpn=(RDHardpointNode *)hpn->GetSucc();

	mov	ecx, DWORD PTR _hpn$[ebp]
	call	?GetSucc@ANode@@QAEPAXXZ		; ANode::GetSucc
	mov	DWORD PTR _hpn$[ebp], eax

; 2221 : 
; 2222 : 	}

	jmp	$LN14@RDFindBest
$LN13@RDFindBest:

; 2223 : 	rd->pylonCT=rd->rackCT=0;

	mov	edx, DWORD PTR _rd$[ebp]
	mov	DWORD PTR [edx+12], 0
	mov	eax, DWORD PTR _rd$[ebp]
	mov	DWORD PTR [eax+8], 0

; 2224 : 	return 0;

	xor	eax, eax
$LN15@RDFindBest:

; 2225 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RDFindBestRackWClass@@YAHHHHPAURDRackData@@@Z ENDP	; RDFindBestRackWClass
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__FRDHardpointList@@YAXXZ
text$yd	SEGMENT
??__FRDHardpointList@@YAXXZ PROC			; `dynamic atexit destructor for 'RDHardpointList'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?RDHardpointList@@3VAList@@A ; RDHardpointList
	call	??1AList@@QAE@XZ
	pop	ebp
	ret	0
??__FRDHardpointList@@YAXXZ ENDP			; `dynamic atexit destructor for 'RDHardpointList''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\entity.cpp
;	COMDAT ??__ERDHardpointList@@YAXXZ
text$yc	SEGMENT
??__ERDHardpointList@@YAXXZ PROC			; `dynamic initializer for 'RDHardpointList'', COMDAT

; 1784 : AList RDHardpointList;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?RDHardpointList@@3VAList@@A ; RDHardpointList
	call	??0AList@@QAE@XZ			; AList::AList
	push	OFFSET ??__FRDHardpointList@@YAXXZ	; `dynamic atexit destructor for 'RDHardpointList''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__ERDHardpointList@@YAXXZ ENDP			; `dynamic initializer for 'RDHardpointList''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__FRDRackList@@YAXXZ
text$yd	SEGMENT
??__FRDRackList@@YAXXZ PROC				; `dynamic atexit destructor for 'RDRackList'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?RDRackList@@3VAList@@A	; RDRackList
	call	??1AList@@QAE@XZ
	pop	ebp
	ret	0
??__FRDRackList@@YAXXZ ENDP				; `dynamic atexit destructor for 'RDRackList''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\entity.cpp
;	COMDAT ??__ERDRackList@@YAXXZ
text$yc	SEGMENT
??__ERDRackList@@YAXXZ PROC				; `dynamic initializer for 'RDRackList'', COMDAT

; 1783 : AList RDRackList;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?RDRackList@@3VAList@@A	; RDRackList
	call	??0AList@@QAE@XZ			; AList::AList
	push	OFFSET ??__FRDRackList@@YAXXZ		; `dynamic atexit destructor for 'RDRackList''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__ERDRackList@@YAXXZ ENDP				; `dynamic initializer for 'RDRackList''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GRDHardpointNode@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GRDHardpointNode@@QAEPAXI@Z PROC			; RDHardpointNode::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1RDHardpointNode@@QAE@XZ		; RDHardpointNode::~RDHardpointNode
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GRDHardpointNode@@QAEPAXI@Z ENDP			; RDHardpointNode::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0RDHardpointNode@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0RDHardpointNode@@QAE@XZ PROC				; RDHardpointNode::RDHardpointNode, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0RDHardpointNode@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0ANode@@QAE@XZ			; ANode::ANode
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7RDHardpointNode@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??0AList@@QAE@XZ			; AList::AList
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0RDHardpointNode@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1ANode@@QAE@XZ			; ANode::~ANode
__ehhandler$??0RDHardpointNode@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0RDHardpointNode@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0RDHardpointNode@@QAE@XZ ENDP				; RDHardpointNode::RDHardpointNode
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\entity.cpp
_TEXT	SEGMENT
tv84 = -32						; size = 4
$T2 = -28						; size = 4
$T3 = -24						; size = 4
_pn$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1RDHardpointNode@@QAE@XZ PROC				; RDHardpointNode::~RDHardpointNode
; _this$ = ecx

; 1773 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1RDHardpointNode@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7RDHardpointNode@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 1
$LN2@RDHardpoin:

; 1774 : 	RDPylonNode *pn;
; 1775 : 	while(pn=(RDPylonNode *)pylonList.RemHead())

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?RemHead@AList@@QAEPAXXZ		; AList::RemHead
	mov	DWORD PTR _pn$[ebp], eax
	cmp	DWORD PTR _pn$[ebp], 0
	je	SHORT $LN3@RDHardpoin

; 1776 : 	{
; 1777 : 		delete pn;

	mov	ecx, DWORD PTR _pn$[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T3[ebp], edx
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN5@RDHardpoin
	push	1
	mov	ecx, DWORD PTR $T3[ebp]
	call	??_GRDPylonNode@@QAEPAXI@Z
	mov	DWORD PTR tv84[ebp], eax
	jmp	SHORT $LN6@RDHardpoin
$LN5@RDHardpoin:
	mov	DWORD PTR tv84[ebp], 0
$LN6@RDHardpoin:

; 1778 : 	}

	jmp	SHORT $LN2@RDHardpoin
$LN3@RDHardpoin:

; 1779 : }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??1AList@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ANode@@QAE@XZ			; ANode::~ANode
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??1RDHardpointNode@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1ANode@@QAE@XZ			; ANode::~ANode
__unwindfunclet$??1RDHardpointNode@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	jmp	??1AList@@QAE@XZ
__ehhandler$??1RDHardpointNode@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1RDHardpointNode@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1RDHardpointNode@@QAE@XZ ENDP				; RDHardpointNode::~RDHardpointNode
; Function compile flags: /Odtp
;	COMDAT ??_GRDPylonNode@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GRDPylonNode@@QAEPAXI@Z PROC				; RDPylonNode::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1RDPylonNode@@QAE@XZ			; RDPylonNode::~RDPylonNode
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GRDPylonNode@@QAEPAXI@Z ENDP				; RDPylonNode::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\entity.cpp
_TEXT	SEGMENT
tv84 = -32						; size = 4
$T2 = -28						; size = 4
$T3 = -24						; size = 4
_rnn$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1RDPylonNode@@QAE@XZ PROC				; RDPylonNode::~RDPylonNode
; _this$ = ecx

; 1761 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1RDPylonNode@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7RDPylonNode@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 1
$LN2@RDPylonNod:

; 1762 : 	RDRackNameNode *rnn;
; 1763 : 
; 1764 : 	while(rnn=(RDRackNameNode *)rackNameList.RemHead())

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	?RemHead@AList@@QAEPAXXZ		; AList::RemHead
	mov	DWORD PTR _rnn$[ebp], eax
	cmp	DWORD PTR _rnn$[ebp], 0
	je	SHORT $LN3@RDPylonNod

; 1765 : 	{
; 1766 : 		delete rnn;

	mov	ecx, DWORD PTR _rnn$[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T3[ebp], edx
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN5@RDPylonNod
	push	1
	mov	ecx, DWORD PTR $T3[ebp]
	call	??_GRDRackNameNode@@QAEPAXI@Z
	mov	DWORD PTR tv84[ebp], eax
	jmp	SHORT $LN6@RDPylonNod
$LN5@RDPylonNod:
	mov	DWORD PTR tv84[ebp], 0
$LN6@RDPylonNod:

; 1767 : 	}

	jmp	SHORT $LN2@RDPylonNod
$LN3@RDPylonNod:

; 1768 : }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??1AList@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ANode@@QAE@XZ			; ANode::~ANode
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??1RDPylonNode@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1ANode@@QAE@XZ			; ANode::~ANode
__unwindfunclet$??1RDPylonNode@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	jmp	??1AList@@QAE@XZ
__ehhandler$??1RDPylonNode@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1RDPylonNode@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1RDPylonNode@@QAE@XZ ENDP				; RDPylonNode::~RDPylonNode
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\entity.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0RDPylonNode@@QAE@XZ PROC				; RDPylonNode::RDPylonNode
; _this$ = ecx

; 1754 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0RDPylonNode@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0ANode@@QAE@XZ			; ANode::ANode
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7RDPylonNode@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??0AList@@QAE@XZ			; AList::AList

; 1755 : 	mnemonic[0]=0;

	mov	ecx, 1
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx+12], 0

; 1756 : 	pylonCT=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0

; 1757 : 	flags=0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+28], 0

; 1758 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0RDPylonNode@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1ANode@@QAE@XZ			; ANode::~ANode
__ehhandler$??0RDPylonNode@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0RDPylonNode@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0RDPylonNode@@QAE@XZ ENDP				; RDPylonNode::RDPylonNode
; Function compile flags: /Odtp
;	COMDAT ??_GRDRackNameNode@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GRDRackNameNode@@QAEPAXI@Z PROC			; RDRackNameNode::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1RDRackNameNode@@QAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GRDRackNameNode@@QAEPAXI@Z ENDP			; RDRackNameNode::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1RDRackNameNode@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1RDRackNameNode@@QAE@XZ PROC				; RDRackNameNode::~RDRackNameNode, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ANode@@QAE@XZ			; ANode::~ANode
	mov	esp, ebp
	pop	ebp
	ret	0
??1RDRackNameNode@@QAE@XZ ENDP				; RDRackNameNode::~RDRackNameNode
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0RDRackNameNode@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0RDRackNameNode@@QAE@XZ PROC				; RDRackNameNode::RDRackNameNode, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0ANode@@QAE@XZ			; ANode::ANode
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7RDRackNameNode@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0RDRackNameNode@@QAE@XZ ENDP				; RDRackNameNode::RDRackNameNode
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GRDLoadOrderNode@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GRDLoadOrderNode@@QAEPAXI@Z PROC			; RDLoadOrderNode::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1RDLoadOrderNode@@QAE@XZ		; RDLoadOrderNode::~RDLoadOrderNode
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GRDLoadOrderNode@@QAEPAXI@Z ENDP			; RDLoadOrderNode::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\entity.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1RDLoadOrderNode@@QAE@XZ PROC				; RDLoadOrderNode::~RDLoadOrderNode
; _this$ = ecx

; 1745 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7RDLoadOrderNode@@6B@

; 1746 : 	if(loadOrder)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	je	SHORT $LN2@RDLoadOrde

; 1747 : 		free(loadOrder);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_free
	add	esp, 4
$LN2@RDLoadOrde:

; 1748 : }

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ANode@@QAE@XZ			; ANode::~ANode
	mov	esp, ebp
	pop	ebp
	ret	0
??1RDLoadOrderNode@@QAE@XZ ENDP				; RDLoadOrderNode::~RDLoadOrderNode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\entity.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_Count$ = 8						; size = 4
??0RDLoadOrderNode@@QAE@H@Z PROC			; RDLoadOrderNode::RDLoadOrderNode
; _this$ = ecx

; 1739 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0ANode@@QAE@XZ			; ANode::ANode
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7RDLoadOrderNode@@6B@

; 1740 : 	count = Count;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _Count$[ebp]
	mov	DWORD PTR [ecx+12], edx

; 1741 : 	loadOrder = (int *)malloc(sizeof(int) * count);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	shl	ecx, 2
	push	ecx
	call	_malloc
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], eax

; 1742 : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0RDLoadOrderNode@@QAE@H@Z ENDP			; RDLoadOrderNode::RDLoadOrderNode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\entity.cpp
_TEXT	SEGMENT
tv92 = -32						; size = 4
$T2 = -28						; size = 4
$T3 = -24						; size = 4
_ron$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1RDRackNode@@QAE@XZ PROC				; RDRackNode::~RDRackNode
; _this$ = ecx

; 1726 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1RDRackNode@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7RDRackNode@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 1727 : 	if(swd)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+68], 0
	je	SHORT $LN4@RDRackNode

; 1728 : 		free(swd);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+68]
	push	eax
	call	_free
	add	esp, 4
$LN4@RDRackNode:

; 1729 : 	if(wId)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+76], 0
	je	SHORT $LN2@RDRackNode

; 1730 : 		free(wId);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+76]
	push	eax
	call	_free
	add	esp, 4
$LN2@RDRackNode:

; 1731 : 	RDLoadOrderNode *ron;
; 1732 : 	while(ron = (RDLoadOrderNode*)loadOrder.RemHead())

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 96					; 00000060H
	call	?RemHead@AList@@QAEPAXXZ		; AList::RemHead
	mov	DWORD PTR _ron$[ebp], eax
	cmp	DWORD PTR _ron$[ebp], 0
	je	SHORT $LN5@RDRackNode

; 1733 : 	{
; 1734 : 		delete ron;

	mov	ecx, DWORD PTR _ron$[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T3[ebp], edx
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN7@RDRackNode
	push	1
	mov	ecx, DWORD PTR $T3[ebp]
	call	??_GRDLoadOrderNode@@QAEPAXI@Z
	mov	DWORD PTR tv92[ebp], eax
	jmp	SHORT $LN8@RDRackNode
$LN7@RDRackNode:
	mov	DWORD PTR tv92[ebp], 0
$LN8@RDRackNode:

; 1735 : 	}

	jmp	SHORT $LN2@RDRackNode
$LN5@RDRackNode:

; 1736 : }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 96					; 00000060H
	call	??1AList@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ANode@@QAE@XZ			; ANode::~ANode
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??1RDRackNode@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1ANode@@QAE@XZ			; ANode::~ANode
__unwindfunclet$??1RDRackNode@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 96					; 00000060H
	jmp	??1AList@@QAE@XZ
__ehhandler$??1RDRackNode@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1RDRackNode@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1RDRackNode@@QAE@XZ ENDP				; RDRackNode::~RDRackNode
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\entity.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0RDRackNode@@QAE@XZ PROC				; RDRackNode::RDRackNode
; _this$ = ecx

; 1707 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0RDRackNode@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0ANode@@QAE@XZ			; ANode::ANode
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7RDRackNode@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 96					; 00000060H
	call	??0AList@@QAE@XZ			; AList::AList

; 1708 : 	rackName[0]=0;

	mov	ecx, 1
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx+12], 0

; 1709 : 	mnemonic[0]=0;

	mov	eax, 1
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+eax+44], 0

; 1710 : 
; 1711 : 	rackCT=0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+56], 0

; 1712 : 	stations=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+60], 0

; 1713 : 	swdCount=0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+64], 0

; 1714 : 	swd=0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+68], 0

; 1715 : 	wIdCount=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+72], 0

; 1716 : 	wId=0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+76], 0

; 1717 : 	any=0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+88], 0

; 1718 : 	wClassCount=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+80], 0

; 1719 : 	wClass=0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+84], 0

; 1720 : 	flags =	RDF_EMERGENCY_JETT_RACK   | RDF_SELECTIVE_JETT_RACK  |
; 1721 : 			RDF_EMERGENCY_JETT_WEAPON | RDF_SELECTIVE_JETT_WEAPON;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+92], 30			; 0000001eH

; 1722 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0RDRackNode@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1ANode@@QAE@XZ			; ANode::~ANode
__ehhandler$??0RDRackNode@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0RDRackNode@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0RDRackNode@@QAE@XZ ENDP				; RDRackNode::RDRackNode
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\entity.cpp
_TEXT	SEGMENT
_i$ = -4						; size = 4
_id$ = 8						; size = 4
_filter$ = 12						; size = 4
?CheckClassEntry@@YAHHQAE@Z PROC			; CheckClassEntry

; 1413 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1414 : 	int
; 1415 : 			i;
; 1416 : 
; 1417 : 	/* compare class bytes */
; 1418 : 	for(i=0; i<CLASS_NUM_BYTES; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@CheckClass
$LN6@CheckClass:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@CheckClass:
	cmp	DWORD PTR _i$[ebp], 8
	jge	SHORT $LN5@CheckClass

; 1419 : 	{
; 1420 : 		if(filter[i] == VU_FILTERSTOP)

	mov	ecx, DWORD PTR _filter$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN4@CheckClass

; 1421 : 		{
; 1422 : 			break;

	jmp	SHORT $LN5@CheckClass

; 1423 : 		}
; 1424 : 		else

	jmp	SHORT $LN3@CheckClass
$LN4@CheckClass:

; 1425 : 		{
; 1426 : 			if(filter[i] != VU_FILTERANY)

	mov	eax, DWORD PTR _filter$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 255				; 000000ffH
	je	SHORT $LN3@CheckClass

; 1427 : 			{
; 1428 : 				if(filter[i] != Falcon4ClassTable[id].vuClassData.classInfo_[i])

	mov	edx, DWORD PTR _filter$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _id$[ebp]
	imul	ecx, 81					; 00000051H
	add	ecx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	edx, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [ecx+edx+8]
	cmp	eax, ecx
	je	SHORT $LN3@CheckClass

; 1429 : 				{
; 1430 : 					return 0;

	xor	eax, eax
	jmp	SHORT $LN8@CheckClass
$LN3@CheckClass:

; 1431 : 				}
; 1432 : 			}
; 1433 : 		}
; 1434 : 	}

	jmp	SHORT $LN6@CheckClass
$LN5@CheckClass:

; 1435 : 
; 1436 : 	return 1;

	mov	eax, 1
$LN8@CheckClass:

; 1437 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CheckClassEntry@@YAHHQAE@Z ENDP			; CheckClassEntry
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\entity.cpp
_TEXT	SEGMENT
_id2$ = -148						; size = 4
_id1$ = -144						; size = 4
_fp$ = -140						; size = 4
_i$1 = -136						; size = 4
_buffer$ = -132						; size = 128
__$ArrayPad$ = -4					; size = 4
?LoadVisIdMap@@YAXXZ PROC				; LoadVisIdMap

; 1511 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1512 : 	FILE *fp;
; 1513 : 	char buffer[128];
; 1514 : 	int id1, id2;
; 1515 : 
; 1516 : 	for (int i = 0; i < MAXMAPID; i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN9@LoadVisIdM
$LN8@LoadVisIdM:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN9@LoadVisIdM:
	cmp	DWORD PTR _i$1[ebp], 1400		; 00000578H
	jge	SHORT $LN7@LoadVisIdM

; 1517 : 		idmap[i] = i; // identity map

	mov	ecx, DWORD PTR _i$1[ebp]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	DWORD PTR _idmap[ecx*4], edx
	jmp	SHORT $LN8@LoadVisIdM
$LN7@LoadVisIdM:

; 1518 : 	if ((fp = OpenCampFile("visid", "map", "rt")) == NULL)

	push	OFFSET ??_C@_02BMJICGCB@rt?$AA@
	push	OFFSET ??_C@_03HBNNNHNM@map?$AA@
	push	OFFSET ??_C@_05DIHJPEMC@visid?$AA@
	call	?OpenCampFile@@YAPAU_iobuf@@PAD00@Z	; OpenCampFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _fp$[ebp], eax
	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $LN5@LoadVisIdM

; 1519 : 		return;

	jmp	$LN10@LoadVisIdM
$LN5@LoadVisIdM:

; 1520 : 	while (fgets(buffer, sizeof buffer, fp)) {

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	128					; 00000080H
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_fgets
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN4@LoadVisIdM

; 1521 : 		if (buffer[0] == '/' || buffer[0] == '\n' || buffer[0] == '\r')

	mov	edx, 1
	imul	edx, 0
	movsx	eax, BYTE PTR _buffer$[ebp+edx]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN2@LoadVisIdM
	mov	ecx, 1
	imul	ecx, 0
	movsx	edx, BYTE PTR _buffer$[ebp+ecx]
	cmp	edx, 10					; 0000000aH
	je	SHORT $LN2@LoadVisIdM
	mov	eax, 1
	imul	eax, 0
	movsx	ecx, BYTE PTR _buffer$[ebp+eax]
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN3@LoadVisIdM
$LN2@LoadVisIdM:

; 1522 : 			continue;

	jmp	SHORT $LN5@LoadVisIdM
$LN3@LoadVisIdM:

; 1523 : 		if (sscanf (buffer, "%d => %d", &id1, &id2) == 2 &&
; 1524 : 						id1 >= 0 && id1 < MAXMAPID)

	lea	edx, DWORD PTR _id2$[ebp]
	push	edx
	lea	eax, DWORD PTR _id1$[ebp]
	push	eax
	push	OFFSET ??_C@_08HDFMCMGC@?$CFd?5?$DN?$DO?5?$CFd?$AA@
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_sscanf
	add	esp, 16					; 00000010H
	cmp	eax, 2
	jne	SHORT $LN1@LoadVisIdM
	cmp	DWORD PTR _id1$[ebp], 0
	jl	SHORT $LN1@LoadVisIdM
	cmp	DWORD PTR _id1$[ebp], 1400		; 00000578H
	jge	SHORT $LN1@LoadVisIdM

; 1525 : 			idmap[id1] = id2;

	mov	edx, DWORD PTR _id1$[ebp]
	mov	eax, DWORD PTR _id2$[ebp]
	mov	DWORD PTR _idmap[edx*4], eax
$LN1@LoadVisIdM:

; 1526 : 	}

	jmp	$LN5@LoadVisIdM
$LN4@LoadVisIdM:

; 1527 : 	fclose (fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fclose
	add	esp, 4
$LN10@LoadVisIdM:

; 1528 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?LoadVisIdMap@@YAXXZ ENDP				; LoadVisIdMap
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\entity.cpp
_TEXT	SEGMENT
?ReadClassTable@@YAXXZ PROC				; ReadClassTable

; 126  : {

	push	ebp
	mov	ebp, esp

; 127  : 	/*
; 128  : 	   if (!VirtualProtect (Falcon4ClassTable, NumEntities * sizeof (Falcon4EntityClassType), PAGE_READONLY, NULL))
; 129  : 	   {
; 130  : 	   ShiAssert (!"Cannot ReadOnly Protect ClassTable\n");
; 131  : 	   }
; 132  : 	 */
; 133  : }

	pop	ebp
	ret	0
?ReadClassTable@@YAXXZ ENDP				; ReadClassTable
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\entity.cpp
_TEXT	SEGMENT
?WriteClassTable@@YAXXZ PROC				; WriteClassTable

; 116  : {

	push	ebp
	mov	ebp, esp

; 117  : 	/*
; 118  : 	   if (!VirtualProtect (Falcon4ClassTable, NumEntities * sizeof (Falcon4EntityClassType), PAGE_READWRITE, NULL))
; 119  : 	   {
; 120  : 	   ShiAssert (!"Cannot Read/Write Protect ClassTable\n");
; 121  : 	   }
; 122  : 	 */
; 123  : }

	pop	ebp
	ret	0
?WriteClassTable@@YAXXZ ENDP				; WriteClassTable
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\entity.cpp
_TEXT	SEGMENT
$T1 = -20						; size = 4
_size$ = -16						; size = 4
_fp$ = -12						; size = 4
_entries$2 = -8						; size = 2
_iknt$3 = -4						; size = 2
_filename$ = 8						; size = 4
?LoadSquadronStoresData@@YAHPAD@Z PROC			; LoadSquadronStoresData

; 1138 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 1139 : 	FILE		*fp;
; 1140 : 
; 1141 : 	if ((fp = OpenCampFile(filename, "SSD", "rb")) == NULL)

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	push	OFFSET ??_C@_03PNOMJKEH@SSD?$AA@
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	?OpenCampFile@@YAPAU_iobuf@@PAD00@Z	; OpenCampFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _fp$[ebp], eax
	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $LN6@LoadSquadr

; 1142 : 		return 0;

	xor	eax, eax
	jmp	$LN7@LoadSquadr
$LN6@LoadSquadr:

; 1143 : 	fseek(fp, 0, SEEK_END); // JPO - work out if the file looks the right size.

	push	2
	push	0
	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fseek
	add	esp, 12					; 0000000cH

; 1144 : 	unsigned int size = ftell(fp);

	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_ftell
	add	esp, 4
	mov	DWORD PTR _size$[ebp], eax

; 1145 : 	// FF - DB Control
; 1146 : 	if (g_bFFDBC)

	movzx	eax, BYTE PTR ?g_bFFDBC@@3_NA		; g_bFFDBC
	test	eax, eax
	je	SHORT $LN5@LoadSquadr

; 1147 : 	{
; 1148 : 		short	iknt = 0, entries = 0;

	xor	ecx, ecx
	mov	WORD PTR _iknt$3[ebp], cx
	xor	edx, edx
	mov	WORD PTR _entries$2[ebp], dx

; 1149 : 		// FF - get real count of entries
; 1150 : 		fseek(fp, 0, SEEK_END);

	push	2
	push	0
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH

; 1151 : 		fseek(fp, -2, SEEK_CUR);

	push	1
	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fseek
	add	esp, 12					; 0000000cH

; 1152 : 		fread(&iknt,sizeof(short),1,fp);

	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	push	1
	push	2
	lea	eax, DWORD PTR _iknt$3[ebp]
	push	eax
	call	_fread
	add	esp, 16					; 00000010H

; 1153 : 		fseek(fp, 0, SEEK_SET);

	push	0
	push	0
	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fseek
	add	esp, 12					; 0000000cH

; 1154 : 		// Move pointer past the 0 entries
; 1155 : 		fread(&entries,sizeof(short),1,fp);

	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	push	1
	push	2
	lea	eax, DWORD PTR _entries$2[ebp]
	push	eax
	call	_fread
	add	esp, 16					; 00000010H

; 1156 : 		if (NumSquadTypes == 0)

	movsx	ecx, WORD PTR ?NumSquadTypes@@3FA	; NumSquadTypes
	test	ecx, ecx
	jne	SHORT $LN4@LoadSquadr

; 1157 : 			NumSquadTypes = iknt;

	mov	dx, WORD PTR _iknt$3[ebp]
	mov	WORD PTR ?NumSquadTypes@@3FA, dx	; NumSquadTypes
$LN4@LoadSquadr:

; 1158 : 	}
; 1159 : 	else

	jmp	SHORT $LN3@LoadSquadr
$LN5@LoadSquadr:

; 1160 : 	{
; 1161 : 		fseek(fp, 0, SEEK_SET);

	push	0
	push	0
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH

; 1162 : 		fread(&NumSquadTypes,sizeof(short),1,fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	push	1
	push	2
	push	OFFSET ?NumSquadTypes@@3FA		; NumSquadTypes
	call	_fread
	add	esp, 16					; 00000010H

; 1163 : 		if (NumSquadTypes < 1)

	movsx	edx, WORD PTR ?NumSquadTypes@@3FA	; NumSquadTypes
	cmp	edx, 1
	jge	SHORT $LN2@LoadSquadr

; 1164 : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN7@LoadSquadr
$LN2@LoadSquadr:

; 1165 : 		if (size != sizeof(SquadronStoresDataType) * NumSquadTypes + 2)

	movsx	eax, WORD PTR ?NumSquadTypes@@3FA	; NumSquadTypes
	imul	eax, 603				; 0000025bH
	add	eax, 2
	cmp	DWORD PTR _size$[ebp], eax
	je	SHORT $LN3@LoadSquadr

; 1166 : 		//	MAXIMUM_WEAPTYPES = 600;
; 1167 : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN7@LoadSquadr
$LN3@LoadSquadr:

; 1168 : 	}
; 1169 : 	// Check for FF new record size
; 1170 : 	//if ((size == sizeof(SquadronStoresDataType) * NumSquadTypes + 2) 
; 1171 : 	//				&& (sizeof(SquadronStoresDataType)-3 == FF_MAXIMUM_WEAPTYPES))
; 1172 : 	//	MAXIMUM_WEAPTYPES = FF_MAXIMUM_WEAPTYPES;
; 1173 : 	//else
; 1174 : 	//	MAXIMUM_WEAPTYPES = SP_MAXIMUM_WEAPTYPES;
; 1175 : 
; 1176 : 	SquadronStoresDataTable = new SquadronStoresDataType[NumSquadTypes];

	movsx	eax, WORD PTR ?NumSquadTypes@@3FA	; NumSquadTypes
	xor	ecx, ecx
	mov	edx, 603				; 0000025bH
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR ?SquadronStoresDataTable@@3PAUSquadronStoresDataType@@A, eax ; SquadronStoresDataTable

; 1177 : 	ShiAssert( SquadronStoresDataTable );
; 1178 : 	fread(SquadronStoresDataTable,sizeof(SquadronStoresDataType),NumSquadTypes,fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	movsx	edx, WORD PTR ?NumSquadTypes@@3FA	; NumSquadTypes
	push	edx
	push	603					; 0000025bH
	mov	eax, DWORD PTR ?SquadronStoresDataTable@@3PAUSquadronStoresDataType@@A ; SquadronStoresDataTable
	push	eax
	call	_fread
	add	esp, 16					; 00000010H

; 1179 : 	fclose(fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fclose
	add	esp, 4

; 1180 : 	return 1;

	mov	eax, 1
$LN7@LoadSquadr:

; 1181 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?LoadSquadronStoresData@@YAHPAD@Z ENDP			; LoadSquadronStoresData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\entity.cpp
_TEXT	SEGMENT
$T1 = -20						; size = 4
_size$ = -16						; size = 4
_fp$ = -12						; size = 4
_entries$2 = -8						; size = 2
_iknt$3 = -4						; size = 2
_filename$ = 8						; size = 4
?LoadACDefData@@YAHPAD@Z PROC				; LoadACDefData

; 1096 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 1097 : 	FILE*		fp;
; 1098 : 
; 1099 : 	if ((fp = OpenCampFile(filename, "ACD", "rb")) == NULL)

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	push	OFFSET ??_C@_03BLNKKGCD@ACD?$AA@
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	?OpenCampFile@@YAPAU_iobuf@@PAD00@Z	; OpenCampFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _fp$[ebp], eax
	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $LN6@LoadACDefD

; 1100 : 		return 0;

	xor	eax, eax
	jmp	$LN7@LoadACDefD
$LN6@LoadACDefD:

; 1101 : 	fseek(fp, 0, SEEK_END); // JPO - work out if the file looks the right size.

	push	2
	push	0
	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fseek
	add	esp, 12					; 0000000cH

; 1102 : 	unsigned int size = ftell(fp);

	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_ftell
	add	esp, 4
	mov	DWORD PTR _size$[ebp], eax

; 1103 : 	// FF - DB Control
; 1104 : 	if (g_bFFDBC)

	movzx	eax, BYTE PTR ?g_bFFDBC@@3_NA		; g_bFFDBC
	test	eax, eax
	je	SHORT $LN5@LoadACDefD

; 1105 : 	{
; 1106 : 		// FF - get real count of entries
; 1107 : 		short	iknt = 0, entries;

	xor	ecx, ecx
	mov	WORD PTR _iknt$3[ebp], cx

; 1108 : 		fseek(fp, 0, SEEK_END);

	push	2
	push	0
	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_fseek
	add	esp, 12					; 0000000cH

; 1109 : 		fseek(fp, -2, SEEK_CUR);

	push	1
	push	-2					; fffffffeH
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH

; 1110 : 		fread(&iknt,sizeof(short),1,fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	push	1
	push	2
	lea	edx, DWORD PTR _iknt$3[ebp]
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 1111 : 		fseek(fp, 0, SEEK_SET);

	push	0
	push	0
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH

; 1112 : 		// Move pointer past the 0 entries
; 1113 : 		fread(&entries,sizeof(short),1,fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	push	1
	push	2
	lea	edx, DWORD PTR _entries$2[ebp]
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 1114 : 		if (NumACDefEntries == 0)

	movsx	eax, WORD PTR ?NumACDefEntries@@3FA	; NumACDefEntries
	test	eax, eax
	jne	SHORT $LN4@LoadACDefD

; 1115 : 			NumACDefEntries = iknt;

	mov	cx, WORD PTR _iknt$3[ebp]
	mov	WORD PTR ?NumACDefEntries@@3FA, cx	; NumACDefEntries
$LN4@LoadACDefD:

; 1116 : 	}
; 1117 : 	else

	jmp	SHORT $LN3@LoadACDefD
$LN5@LoadACDefD:

; 1118 : 	{
; 1119 : 		fseek(fp, 0, SEEK_SET);

	push	0
	push	0
	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_fseek
	add	esp, 12					; 0000000cH

; 1120 : 		if (fread(&NumACDefEntries,sizeof(short),1,fp) < 1)

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	2
	push	OFFSET ?NumACDefEntries@@3FA		; NumACDefEntries
	call	_fread
	add	esp, 16					; 00000010H
	cmp	eax, 1
	jae	SHORT $LN2@LoadACDefD

; 1121 : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN7@LoadACDefD
$LN2@LoadACDefD:

; 1122 : 		if (size != sizeof(SimACDefType) * NumACDefEntries + 2)

	movsx	ecx, WORD PTR ?NumACDefEntries@@3FA	; NumACDefEntries
	imul	ecx, 52					; 00000034H
	add	ecx, 2
	cmp	DWORD PTR _size$[ebp], ecx
	je	SHORT $LN3@LoadACDefD

; 1123 : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN7@LoadACDefD
$LN3@LoadACDefD:

; 1124 : 	}
; 1125 : 	//fseek(fp, 0, SEEK_SET);
; 1126 : 	//if (fread(&NumACDefEntries,sizeof(short),1,fp) < 1)
; 1127 : 	//	return 0;
; 1128 : 	//if (size != sizeof(SimACDefType) * NumACDefEntries + 2)
; 1129 : 	//	return 0;
; 1130 : 	SimACDefTable = new SimACDefType[NumACDefEntries];

	movsx	eax, WORD PTR ?NumACDefEntries@@3FA	; NumACDefEntries
	xor	ecx, ecx
	mov	edx, 52					; 00000034H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR ?SimACDefTable@@3PAUSimACDefType@@A, eax ; SimACDefTable

; 1131 : 	ShiAssert( SimACDefTable );
; 1132 : 	fread(SimACDefTable,sizeof(SimACDefType),NumACDefEntries,fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	movsx	edx, WORD PTR ?NumACDefEntries@@3FA	; NumACDefEntries
	push	edx
	push	52					; 00000034H
	mov	eax, DWORD PTR ?SimACDefTable@@3PAUSimACDefType@@A ; SimACDefTable
	push	eax
	call	_fread
	add	esp, 16					; 00000010H

; 1133 : 	fclose(fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fclose
	add	esp, 4

; 1134 : 	return 1;

	mov	eax, 1
$LN7@LoadACDefD:

; 1135 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?LoadACDefData@@YAHPAD@Z ENDP				; LoadACDefData
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1AList@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1AList@@QAE@XZ PROC					; AList::~AList, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1AList@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??1ANode@@QAE@XZ			; ANode::~ANode
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ANode@@QAE@XZ			; ANode::~ANode
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1AList@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1ANode@@QAE@XZ			; ANode::~ANode
__ehhandler$??1AList@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1AList@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1AList@@QAE@XZ ENDP					; AList::~AList
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\alist.h
;	COMDAT ?CompareWith@ANode@@UAEHPAV1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_n$ = 8							; size = 4
?CompareWith@ANode@@UAEHPAV1@@Z PROC			; ANode::CompareWith, COMDAT
; _this$ = ecx

; 13   : 	virtual int CompareWith(ANode *n) {return 0;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	4
?CompareWith@ANode@@UAEHPAV1@@Z ENDP			; ANode::CompareWith
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\entity.cpp
_TEXT	SEGMENT
_rnn$ = -20						; size = 4
_l$1 = -16						; size = 4
_hpn$ = -12						; size = 4
_pn$ = -8						; size = 4
_rn$ = -4						; size = 4
_GroupId$ = 8						; size = 4
_SWD$ = 12						; size = 4
_WeaponCount$ = 16					; size = 4
_rd$ = 20						; size = 4
?RDFindBestRackSWD@@YAHHHHPAURDRackData@@@Z PROC	; RDFindBestRackSWD

; 2231 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 2232 : 	RDHardpointNode *hpn;
; 2233 : 	RDPylonNode *pn;
; 2234 : 	RDRackNameNode *rnn;
; 2235 : 	RDRackNode *rn;
; 2236 : 
; 2237 : 	hpn=(RDHardpointNode *)RDHardpointList.GetHead();

	mov	ecx, OFFSET ?RDHardpointList@@3VAList@@A ; RDHardpointList
	call	?GetHead@AList@@QAEPAXXZ		; AList::GetHead
	mov	DWORD PTR _hpn$[ebp], eax
$LN15@RDFindBest:

; 2238 : 	while(hpn)

	cmp	DWORD PTR _hpn$[ebp], 0
	je	$LN14@RDFindBest

; 2239 : 	{
; 2240 : 		if(hpn->groupId==GroupId)

	mov	eax, DWORD PTR _hpn$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR _GroupId$[ebp]
	jne	$LN13@RDFindBest

; 2241 : 		{
; 2242 : 			pn=(RDPylonNode *)hpn->pylonList.GetHead();

	mov	ecx, DWORD PTR _hpn$[ebp]
	add	ecx, 16					; 00000010H
	call	?GetHead@AList@@QAEPAXXZ		; AList::GetHead
	mov	DWORD PTR _pn$[ebp], eax
$LN12@RDFindBest:

; 2243 : 			while(pn)

	cmp	DWORD PTR _pn$[ebp], 0
	je	$LN13@RDFindBest

; 2244 : 			{
; 2245 : 				rnn=(RDRackNameNode *)pn->rackNameList.GetHead();

	mov	ecx, DWORD PTR _pn$[ebp]
	add	ecx, 32					; 00000020H
	call	?GetHead@AList@@QAEPAXXZ		; AList::GetHead
	mov	DWORD PTR _rnn$[ebp], eax
$LN10@RDFindBest:

; 2246 : 				while(rnn)

	cmp	DWORD PTR _rnn$[ebp], 0
	je	$LN9@RDFindBest

; 2247 : 				{
; 2248 : 					rn=(RDRackNode *)RDRackList.GetHead();

	mov	ecx, OFFSET ?RDRackList@@3VAList@@A	; RDRackList
	call	?GetHead@AList@@QAEPAXXZ		; AList::GetHead
	mov	DWORD PTR _rn$[ebp], eax
$LN8@RDFindBest:

; 2249 : 					while(rn)

	cmp	DWORD PTR _rn$[ebp], 0
	je	$LN7@RDFindBest

; 2250 : 					{
; 2251 : 						if(stricmp(rn->rackName,rnn->rackName)==0 &&
; 2252 : 										rn->stations >= WeaponCount)

	mov	edx, DWORD PTR _rnn$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	eax, DWORD PTR _rn$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	$LN6@RDFindBest
	mov	ecx, DWORD PTR _rn$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	cmp	edx, DWORD PTR _WeaponCount$[ebp]
	jl	SHORT $LN6@RDFindBest

; 2253 : 						{
; 2254 : 							int l;
; 2255 : 							for(l=0;l<rn->swdCount;l++)

	mov	DWORD PTR _l$1[ebp], 0
	jmp	SHORT $LN5@RDFindBest
$LN4@RDFindBest:
	mov	eax, DWORD PTR _l$1[ebp]
	add	eax, 1
	mov	DWORD PTR _l$1[ebp], eax
$LN5@RDFindBest:
	mov	ecx, DWORD PTR _rn$[ebp]
	mov	edx, DWORD PTR _l$1[ebp]
	cmp	edx, DWORD PTR [ecx+64]
	jge	SHORT $LN6@RDFindBest

; 2256 : 							{
; 2257 : 								if(rn->any)

	mov	eax, DWORD PTR _rn$[ebp]
	cmp	DWORD PTR [eax+88], 0
	je	SHORT $LN2@RDFindBest

; 2258 : 								{
; 2259 : 									RDCopyRackData(WeaponCount, pn,rn,rd);

	mov	ecx, DWORD PTR _rd$[ebp]
	push	ecx
	mov	edx, DWORD PTR _rn$[ebp]
	push	edx
	mov	eax, DWORD PTR _pn$[ebp]
	push	eax
	mov	ecx, DWORD PTR _WeaponCount$[ebp]
	push	ecx
	call	?RDCopyRackData@@YAXHPAVRDPylonNode@@PAVRDRackNode@@PAURDRackData@@@Z ; RDCopyRackData
	add	esp, 16					; 00000010H

; 2260 : 									return 1;

	mov	eax, 1
	jmp	$LN16@RDFindBest
$LN2@RDFindBest:

; 2261 : 								}
; 2262 : 
; 2263 : 								if(rn->swd[l]==SWD)

	mov	edx, DWORD PTR _rn$[ebp]
	mov	eax, DWORD PTR [edx+68]
	mov	ecx, DWORD PTR _l$1[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	cmp	edx, DWORD PTR _SWD$[ebp]
	jne	SHORT $LN1@RDFindBest

; 2264 : 								{ // a match!
; 2265 : 									RDCopyRackData(WeaponCount, pn,rn,rd);

	mov	eax, DWORD PTR _rd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pn$[ebp]
	push	edx
	mov	eax, DWORD PTR _WeaponCount$[ebp]
	push	eax
	call	?RDCopyRackData@@YAXHPAVRDPylonNode@@PAVRDRackNode@@PAURDRackData@@@Z ; RDCopyRackData
	add	esp, 16					; 00000010H

; 2266 : 									return 1;

	mov	eax, 1
	jmp	SHORT $LN16@RDFindBest
$LN1@RDFindBest:

; 2267 : 								}
; 2268 : 							}

	jmp	SHORT $LN4@RDFindBest
$LN6@RDFindBest:

; 2269 : 
; 2270 : 						}
; 2271 : 						rn=(RDRackNode *)rn->GetSucc();

	mov	ecx, DWORD PTR _rn$[ebp]
	call	?GetSucc@ANode@@QAEPAXXZ		; ANode::GetSucc
	mov	DWORD PTR _rn$[ebp], eax

; 2272 : 					}

	jmp	$LN8@RDFindBest
$LN7@RDFindBest:

; 2273 : 
; 2274 : 					rnn=(RDRackNameNode *)rnn->GetSucc();

	mov	ecx, DWORD PTR _rnn$[ebp]
	call	?GetSucc@ANode@@QAEPAXXZ		; ANode::GetSucc
	mov	DWORD PTR _rnn$[ebp], eax

; 2275 : 				}

	jmp	$LN10@RDFindBest
$LN9@RDFindBest:

; 2276 : 				pn=(RDPylonNode *)pn->GetSucc();

	mov	ecx, DWORD PTR _pn$[ebp]
	call	?GetSucc@ANode@@QAEPAXXZ		; ANode::GetSucc
	mov	DWORD PTR _pn$[ebp], eax

; 2277 : 			}

	jmp	$LN12@RDFindBest
$LN13@RDFindBest:

; 2278 : 		}
; 2279 : 		hpn=(RDHardpointNode *)hpn->GetSucc();

	mov	ecx, DWORD PTR _hpn$[ebp]
	call	?GetSucc@ANode@@QAEPAXXZ		; ANode::GetSucc
	mov	DWORD PTR _hpn$[ebp], eax

; 2280 : 
; 2281 : 	}

	jmp	$LN15@RDFindBest
$LN14@RDFindBest:

; 2282 : 	rd->pylonCT=rd->rackCT=0;

	mov	ecx, DWORD PTR _rd$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _rd$[ebp]
	mov	DWORD PTR [edx+8], 0

; 2283 : 	return 0;

	xor	eax, eax
$LN16@RDFindBest:

; 2284 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RDFindBestRackSWD@@YAHHHHPAURDRackData@@@Z ENDP	; RDFindBestRackSWD
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\entity.cpp
_TEXT	SEGMENT
_rnn$ = -20						; size = 4
_l$1 = -16						; size = 4
_hpn$ = -12						; size = 4
_pn$ = -8						; size = 4
_rn$ = -4						; size = 4
_GroupId$ = 8						; size = 4
_WeaponId$ = 12						; size = 4
_WeaponCount$ = 16					; size = 4
_rd$ = 20						; size = 4
?RDFindBestRackWID@@YAHHHHPAURDRackData@@@Z PROC	; RDFindBestRackWID

; 2128 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 2129 : 	RDHardpointNode *hpn;
; 2130 : 	RDPylonNode *pn;
; 2131 : 	RDRackNameNode *rnn;
; 2132 : 	RDRackNode *rn;
; 2133 : 
; 2134 : 
; 2135 : 	hpn=(RDHardpointNode *)RDHardpointList.GetHead();

	mov	ecx, OFFSET ?RDHardpointList@@3VAList@@A ; RDHardpointList
	call	?GetHead@AList@@QAEPAXXZ		; AList::GetHead
	mov	DWORD PTR _hpn$[ebp], eax
$LN14@RDFindBest:

; 2136 : 	while(hpn)

	cmp	DWORD PTR _hpn$[ebp], 0
	je	$LN13@RDFindBest

; 2137 : 	{
; 2138 : 		if(hpn->groupId==GroupId)

	mov	eax, DWORD PTR _hpn$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR _GroupId$[ebp]
	jne	$LN12@RDFindBest

; 2139 : 		{
; 2140 : 			pn=(RDPylonNode *)hpn->pylonList.GetHead();

	mov	ecx, DWORD PTR _hpn$[ebp]
	add	ecx, 16					; 00000010H
	call	?GetHead@AList@@QAEPAXXZ		; AList::GetHead
	mov	DWORD PTR _pn$[ebp], eax
$LN11@RDFindBest:

; 2141 : 			while(pn)

	cmp	DWORD PTR _pn$[ebp], 0
	je	$LN12@RDFindBest

; 2142 : 			{
; 2143 : 				rnn=(RDRackNameNode *)pn->rackNameList.GetHead();

	mov	ecx, DWORD PTR _pn$[ebp]
	add	ecx, 32					; 00000020H
	call	?GetHead@AList@@QAEPAXXZ		; AList::GetHead
	mov	DWORD PTR _rnn$[ebp], eax
$LN9@RDFindBest:

; 2144 : 				while(rnn)

	cmp	DWORD PTR _rnn$[ebp], 0
	je	$LN8@RDFindBest

; 2145 : 				{
; 2146 : 					rn=(RDRackNode *)RDRackList.GetHead();

	mov	ecx, OFFSET ?RDRackList@@3VAList@@A	; RDRackList
	call	?GetHead@AList@@QAEPAXXZ		; AList::GetHead
	mov	DWORD PTR _rn$[ebp], eax
$LN7@RDFindBest:

; 2147 : 					while(rn)

	cmp	DWORD PTR _rn$[ebp], 0
	je	$LN6@RDFindBest

; 2148 : 					{
; 2149 : 						if(stricmp(rn->rackName,rnn->rackName)==0 &&
; 2150 : 										rn->stations >= WeaponCount)

	mov	edx, DWORD PTR _rnn$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	eax, DWORD PTR _rn$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN5@RDFindBest
	mov	ecx, DWORD PTR _rn$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	cmp	edx, DWORD PTR _WeaponCount$[ebp]
	jl	SHORT $LN5@RDFindBest

; 2151 : 						{
; 2152 : 							int l;
; 2153 : 							for(l=0;l<rn->wIdCount;l++)

	mov	DWORD PTR _l$1[ebp], 0
	jmp	SHORT $LN4@RDFindBest
$LN3@RDFindBest:
	mov	eax, DWORD PTR _l$1[ebp]
	add	eax, 1
	mov	DWORD PTR _l$1[ebp], eax
$LN4@RDFindBest:
	mov	ecx, DWORD PTR _rn$[ebp]
	mov	edx, DWORD PTR _l$1[ebp]
	cmp	edx, DWORD PTR [ecx+72]
	jge	SHORT $LN5@RDFindBest

; 2154 : 							{
; 2155 : 								if(rn->wId[l]==WeaponId)

	mov	eax, DWORD PTR _rn$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR _l$1[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	eax, DWORD PTR _WeaponId$[ebp]
	jne	SHORT $LN1@RDFindBest

; 2156 : 								{ // a match!
; 2157 : 									RDCopyRackData(WeaponCount, pn,rn,rd);

	mov	ecx, DWORD PTR _rd$[ebp]
	push	ecx
	mov	edx, DWORD PTR _rn$[ebp]
	push	edx
	mov	eax, DWORD PTR _pn$[ebp]
	push	eax
	mov	ecx, DWORD PTR _WeaponCount$[ebp]
	push	ecx
	call	?RDCopyRackData@@YAXHPAVRDPylonNode@@PAVRDRackNode@@PAURDRackData@@@Z ; RDCopyRackData
	add	esp, 16					; 00000010H

; 2158 : 									return 1;

	mov	eax, 1
	jmp	SHORT $LN15@RDFindBest
$LN1@RDFindBest:

; 2159 : 								}
; 2160 : 							}

	jmp	SHORT $LN3@RDFindBest
$LN5@RDFindBest:

; 2161 : 
; 2162 : 						}
; 2163 : 						rn=(RDRackNode *)rn->GetSucc();

	mov	ecx, DWORD PTR _rn$[ebp]
	call	?GetSucc@ANode@@QAEPAXXZ		; ANode::GetSucc
	mov	DWORD PTR _rn$[ebp], eax

; 2164 : 					}

	jmp	$LN7@RDFindBest
$LN6@RDFindBest:

; 2165 : 
; 2166 : 					rnn=(RDRackNameNode *)rnn->GetSucc();

	mov	ecx, DWORD PTR _rnn$[ebp]
	call	?GetSucc@ANode@@QAEPAXXZ		; ANode::GetSucc
	mov	DWORD PTR _rnn$[ebp], eax

; 2167 : 				}

	jmp	$LN9@RDFindBest
$LN8@RDFindBest:

; 2168 : 				pn=(RDPylonNode *)pn->GetSucc();

	mov	ecx, DWORD PTR _pn$[ebp]
	call	?GetSucc@ANode@@QAEPAXXZ		; ANode::GetSucc
	mov	DWORD PTR _pn$[ebp], eax

; 2169 : 			}

	jmp	$LN11@RDFindBest
$LN12@RDFindBest:

; 2170 : 		}
; 2171 : 		hpn=(RDHardpointNode *)hpn->GetSucc();

	mov	ecx, DWORD PTR _hpn$[ebp]
	call	?GetSucc@ANode@@QAEPAXXZ		; ANode::GetSucc
	mov	DWORD PTR _hpn$[ebp], eax

; 2172 : 	}

	jmp	$LN14@RDFindBest
$LN13@RDFindBest:

; 2173 : 	rd->pylonCT=rd->rackCT=0;

	mov	edx, DWORD PTR _rd$[ebp]
	mov	DWORD PTR [edx+12], 0
	mov	eax, DWORD PTR _rd$[ebp]
	mov	DWORD PTR [eax+8], 0

; 2174 : 	return 0;

	xor	eax, eax
$LN15@RDFindBest:

; 2175 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RDFindBestRackWID@@YAHHHHPAURDRackData@@@Z ENDP	; RDFindBestRackWID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\entity.cpp
_TEXT	SEGMENT
_wclass$1 = -4						; size = 4
_GroupId$ = 8						; size = 4
_WeaponId$ = 12						; size = 4
_WeaponCount$ = 16					; size = 4
_rd$ = 20						; size = 4
?RDFindBestRack@@YAHHHHPAURDRackData@@@Z PROC		; RDFindBestRack

; 2081 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2082 : 	if(WeaponId)

	cmp	DWORD PTR _WeaponId$[ebp], 0
	je	$LN4@RDFindBest

; 2083 : 	{
; 2084 : 		if(RDFindBestRackWID(GroupId, WeaponId, WeaponCount, rd))

	mov	eax, DWORD PTR _rd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _WeaponCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR _WeaponId$[ebp]
	push	edx
	mov	eax, DWORD PTR _GroupId$[ebp]
	push	eax
	call	?RDFindBestRackWID@@YAHHHHPAURDRackData@@@Z ; RDFindBestRackWID
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN3@RDFindBest

; 2085 : 			return 1;

	mov	eax, 1
	jmp	$LN5@RDFindBest
$LN3@RDFindBest:

; 2086 : 
; 2087 : 		int wclass = SimWeaponDataTable[Falcon4ClassTable[WeaponDataTable[WeaponId].Index].vehicleDataIndex].weaponClass;

	mov	ecx, DWORD PTR _WeaponId$[ebp]
	imul	ecx, 60					; 0000003cH
	mov	edx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movsx	eax, WORD PTR [edx+ecx]
	imul	eax, 81					; 00000051H
	mov	ecx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	movsx	edx, WORD PTR [ecx+eax+74]
	imul	edx, 52					; 00000034H
	mov	eax, DWORD PTR ?SimWeaponDataTable@@3PAUSimWeaponDataType@@A ; SimWeaponDataTable
	mov	ecx, DWORD PTR [eax+edx+36]
	mov	DWORD PTR _wclass$1[ebp], ecx

; 2088 : 		if(RDFindBestRackWClass(GroupId, wclass, WeaponCount, rd))

	mov	edx, DWORD PTR _rd$[ebp]
	push	edx
	mov	eax, DWORD PTR _WeaponCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _wclass$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _GroupId$[ebp]
	push	edx
	call	?RDFindBestRackWClass@@YAHHHHPAURDRackData@@@Z ; RDFindBestRackWClass
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN2@RDFindBest

; 2089 : 			return 1;

	mov	eax, 1
	jmp	SHORT $LN5@RDFindBest
$LN2@RDFindBest:

; 2090 : 
; 2091 : 		if(RDFindBestRackSWD(GroupId, WeaponDataTable[WeaponId].SimweapIndex, WeaponCount, rd))

	mov	eax, DWORD PTR _rd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _WeaponCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR _WeaponId$[ebp]
	imul	edx, 60					; 0000003cH
	mov	eax, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movsx	ecx, WORD PTR [eax+edx+46]
	push	ecx
	mov	edx, DWORD PTR _GroupId$[ebp]
	push	edx
	call	?RDFindBestRackSWD@@YAHHHHPAURDRackData@@@Z ; RDFindBestRackSWD
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN4@RDFindBest

; 2092 : 			return 1;

	mov	eax, 1
	jmp	SHORT $LN5@RDFindBest
$LN4@RDFindBest:

; 2093 : 	}
; 2094 : 
; 2095 : 	return 0;

	xor	eax, eax
$LN5@RDFindBest:

; 2096 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RDFindBestRack@@YAHHHHPAURDRackData@@@Z ENDP		; RDFindBestRack
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\entity.cpp
_TEXT	SEGMENT
tv71 = -16						; size = 4
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_hpn$ = -4						; size = 4
?RDUnloadRackData@@YAXXZ PROC				; RDUnloadRackData

; 2067 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
$LN2@RDUnloadRa:

; 2068 : 	RDHardpointNode *hpn;
; 2069 : 
; 2070 : 	while(hpn=(RDHardpointNode *)RDHardpointList.RemHead())

	mov	ecx, OFFSET ?RDHardpointList@@3VAList@@A ; RDHardpointList
	call	?RemHead@AList@@QAEPAXXZ		; AList::RemHead
	mov	DWORD PTR _hpn$[ebp], eax
	cmp	DWORD PTR _hpn$[ebp], 0
	je	SHORT $LN3@RDUnloadRa

; 2071 : 	{
; 2072 : 		delete hpn;

	mov	eax, DWORD PTR _hpn$[ebp]
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	cmp	DWORD PTR $T2[ebp], 0
	je	SHORT $LN5@RDUnloadRa
	push	1
	mov	ecx, DWORD PTR $T2[ebp]
	call	??_GRDHardpointNode@@QAEPAXI@Z
	mov	DWORD PTR tv71[ebp], eax
	jmp	SHORT $LN6@RDUnloadRa
$LN5@RDUnloadRa:
	mov	DWORD PTR tv71[ebp], 0
$LN6@RDUnloadRa:

; 2073 : 	}

	jmp	SHORT $LN2@RDUnloadRa
$LN3@RDUnloadRa:

; 2074 : 
; 2075 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RDUnloadRackData@@YAXXZ ENDP				; RDUnloadRackData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\entity.cpp
_TEXT	SEGMENT
_enums$2 = -2880					; size = 48
_enums$3 = -2832					; size = 12
_enums$4 = -2820					; size = 12
_enums$5 = -2808					; size = 12
$T6 = -2796						; size = 4
$T7 = -2792						; size = 4
$T8 = -2788						; size = 4
$T9 = -2784						; size = 4
$T10 = -2780						; size = 4
_arg$11 = -2776						; size = 4
tv186 = -2772						; size = 4
_ok$12 = -2768						; size = 4
_i$13 = -2764						; size = 4
$T14 = -2760						; size = 4
_n$15 = -2756						; size = 4
$T16 = -2752						; size = 4
tv148 = -2748						; size = 4
tv332 = -2744						; size = 4
_ok$17 = -2740						; size = 4
tv479 = -2736						; size = 4
_ok$18 = -2732						; size = 4
tv457 = -2728						; size = 4
_i$19 = -2724						; size = 4
$T20 = -2720						; size = 4
_n$21 = -2716						; size = 4
$T22 = -2712						; size = 4
tv502 = -2708						; size = 4
_i$23 = -2704						; size = 4
$T24 = -2700						; size = 4
tv206 = -2696						; size = 4
tv542 = -2692						; size = 4
_ok$25 = -2688						; size = 4
_lon$26 = -2684						; size = 4
_rnn$27 = -2680						; size = 4
_fp$ = -2676						; size = 4
_hpn$ = -2672						; size = 4
_l$28 = -2668						; size = 4
_l$29 = -2664						; size = 4
_l$30 = -2660						; size = 4
_l$31 = -2656						; size = 4
_pn$ = -2652						; size = 4
_com$32 = -2648						; size = 4
_rn$ = -2644						; size = 4
_i$33 = -2640						; size = 400
_i$34 = -2240						; size = 400
_i$35 = -1840						; size = 400
_i$36 = -1440						; size = 400
_buffer$ = -1040					; size = 1024
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?RDLoadRackData@@YAXXZ PROC				; RDLoadRackData

; 1787 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?RDLoadRackData@@YAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 2868				; 00000b34H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1788 : 	FILE *fp;
; 1789 : 	char buffer[1024];
; 1790 : 	RDHardpointNode *hpn=0;

	mov	DWORD PTR _hpn$[ebp], 0

; 1791 : 	RDPylonNode		*pn=0;

	mov	DWORD PTR _pn$[ebp], 0

; 1792 : 	RDRackNode		*rn=0;

	mov	DWORD PTR _rn$[ebp], 0

; 1793 : 
; 1794 : 	RDUnloadRackData(); // just incase

	call	?RDUnloadRackData@@YAXXZ		; RDUnloadRackData

; 1795 : 
; 1796 : 	if ((fp = OpenCampFile("BMSRack", "dat", "rt")) == NULL) 

	push	OFFSET ??_C@_02BMJICGCB@rt?$AA@
	push	OFFSET ??_C@_03GILJFNFC@dat?$AA@
	push	OFFSET ??_C@_07FDHCEADO@BMSRack?$AA@
	call	?OpenCampFile@@YAPAU_iobuf@@PAD00@Z	; OpenCampFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _fp$[ebp], eax
	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $LN76@RDLoadRack

; 1797 : 	{
; 1798 : 		sprintf (buffer, "%s\\%s", FalconObjectDataDir, "BMSRack.dat");

	push	OFFSET ??_C@_0M@EHPGPFLM@BMSRack?4dat?$AA@
	push	OFFSET ?FalconObjectDataDir@@3PADA	; FalconObjectDataDir
	push	OFFSET ??_C@_05BMGBEOOC@?$CFs?2?$CFs?$AA@
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H

; 1799 : 		if ((fp = fopen(buffer, "rt")) == NULL) 

	push	OFFSET ??_C@_02BMJICGCB@rt?$AA@
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$[ebp], eax
	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $LN76@RDLoadRack

; 1800 : 			return;

	jmp	$LN79@RDLoadRack
$LN76@RDLoadRack:

; 1801 : 	}
; 1802 : 
; 1803 : 	while (fgets (buffer, sizeof buffer, fp)) 

	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	push	1024					; 00000400H
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_fgets
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN75@RDLoadRack

; 1804 : 	{		
; 1805 : 		char *com,*arg;
; 1806 : 
; 1807 : 		if (buffer[0] == '#' || buffer[0] == ';' ||buffer[0] == '\n')

	mov	ecx, 1
	imul	ecx, 0
	movsx	edx, BYTE PTR _buffer$[ebp+ecx]
	cmp	edx, 35					; 00000023H
	je	SHORT $LN73@RDLoadRack
	mov	eax, 1
	imul	eax, 0
	movsx	ecx, BYTE PTR _buffer$[ebp+eax]
	cmp	ecx, 59					; 0000003bH
	je	SHORT $LN73@RDLoadRack
	mov	edx, 1
	imul	edx, 0
	movsx	eax, BYTE PTR _buffer$[ebp+edx]
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN74@RDLoadRack
$LN73@RDLoadRack:

; 1808 : 			continue;

	jmp	SHORT $LN76@RDLoadRack
$LN74@RDLoadRack:

; 1809 : 
; 1810 : 		com=strtok(buffer," \t\n");

	push	OFFSET ??_C@_03ILLHFMNI@?5?7?6?$AA@
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_strtok
	add	esp, 8
	mov	DWORD PTR _com$32[ebp], eax

; 1811 : 		arg=strtok(0,"\n\0");

	push	OFFSET ??_C@_02NCJKDDL@?6?$AA?$AA@
	push	0
	call	_strtok
	add	esp, 8
	mov	DWORD PTR _arg$11[ebp], eax

; 1812 : 
; 1813 : 
; 1814 : 		/* kludge so that arg is the current string being parsed */
; 1815 : 		SetTokenString(arg);

	mov	edx, DWORD PTR _arg$11[ebp]
	push	edx
	call	?SetTokenString@@YAXPAD@Z		; SetTokenString
	add	esp, 4

; 1816 : 
; 1817 : 		if(!com)

	cmp	DWORD PTR _com$32[ebp], 0
	jne	SHORT $LN72@RDLoadRack

; 1818 : 			continue;

	jmp	$LN76@RDLoadRack
$LN72@RDLoadRack:

; 1819 : 
; 1820 : #define On(s) if(stricmp(com,s)==0)
; 1821 : 
; 1822 : 		On("definerack")

	push	OFFSET ??_C@_0L@OMMGGKKO@definerack?$AA@
	mov	eax, DWORD PTR _com$32[ebp]
	push	eax
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	$LN71@RDLoadRack

; 1823 : 		{
; 1824 : 			char *n = TokenStr(0);

	push	0
	call	?TokenStr@@YAPADPAD@Z			; TokenStr
	add	esp, 4
	mov	DWORD PTR _n$15[ebp], eax

; 1825 : 			if(n)

	cmp	DWORD PTR _n$15[ebp], 0
	je	$LN71@RDLoadRack

; 1826 : 			{
; 1827 : 				if(rn=new RDRackNode)

	push	120					; 00000078H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T20[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T20[ebp], 0
	je	SHORT $LN81@RDLoadRack
	mov	ecx, DWORD PTR $T20[ebp]
	call	??0RDRackNode@@QAE@XZ			; RDRackNode::RDRackNode
	mov	DWORD PTR tv148[ebp], eax
	jmp	SHORT $LN82@RDLoadRack
$LN81@RDLoadRack:
	mov	DWORD PTR tv148[ebp], 0
$LN82@RDLoadRack:
	mov	ecx, DWORD PTR tv148[ebp]
	mov	DWORD PTR $T10[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T10[ebp]
	mov	DWORD PTR _rn$[ebp], edx
	cmp	DWORD PTR _rn$[ebp], 0
	je	SHORT $LN71@RDLoadRack

; 1828 : 				{
; 1829 : 					RDRackList.AddTail(rn);

	mov	eax, DWORD PTR _rn$[ebp]
	push	eax
	mov	ecx, OFFSET ?RDRackList@@3VAList@@A	; RDRackList
	call	?AddTail@AList@@QAEXPAVANode@@@Z	; AList::AddTail

; 1830 : 					strncpy(rn->rackName,n,32);

	push	32					; 00000020H
	mov	ecx, DWORD PTR _n$15[ebp]
	push	ecx
	mov	edx, DWORD PTR _rn$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	call	_strncpy
	add	esp, 12					; 0000000cH

; 1831 : 					rn->any=0;

	mov	eax, DWORD PTR _rn$[ebp]
	mov	DWORD PTR [eax+88], 0
$LN71@RDLoadRack:

; 1832 : 					//strncpy(rn->mnemonic,TokenStr("-------"),11);
; 1833 : 				}
; 1834 : 			}
; 1835 : 		}
; 1836 : 
; 1837 : 		if(rn)

	cmp	DWORD PTR _rn$[ebp], 0
	je	$LN68@RDLoadRack

; 1838 : 		{
; 1839 : 			On("rackct")

	push	OFFSET ??_C@_06OJLLIJGI@rackct?$AA@
	mov	ecx, DWORD PTR _com$32[ebp]
	push	ecx
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN67@RDLoadRack

; 1840 : 			{
; 1841 : 				rn->rackCT=TokenI(0);

	push	0
	call	?TokenI@@YAHH@Z				; TokenI
	add	esp, 4
	mov	edx, DWORD PTR _rn$[ebp]
	mov	DWORD PTR [edx+56], eax
$LN67@RDLoadRack:

; 1842 : 			}
; 1843 : 
; 1844 : 			On("rackstations")

	push	OFFSET ??_C@_0N@JEJPAJOB@rackstations?$AA@
	mov	eax, DWORD PTR _com$32[ebp]
	push	eax
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN66@RDLoadRack

; 1845 : 			{
; 1846 : 				rn->stations=TokenI(0);

	push	0
	call	?TokenI@@YAHH@Z				; TokenI
	add	esp, 4
	mov	ecx, DWORD PTR _rn$[ebp]
	mov	DWORD PTR [ecx+60], eax
$LN66@RDLoadRack:

; 1847 : 			}
; 1848 : 
; 1849 : 			On("rackjettmodes")

	push	OFFSET ??_C@_0O@GLFHNJDN@rackjettmodes?$AA@
	mov	edx, DWORD PTR _com$32[ebp]
	push	edx
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	$LN65@RDLoadRack

; 1850 : 			{
; 1851 : 				int i;
; 1852 : 				rn->flags &=~(RDF_EMERGENCY_JETT_RACK | RDF_SELECTIVE_JETT_RACK); // clear flags

	mov	eax, DWORD PTR _rn$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	and	ecx, -25				; ffffffe7H
	mov	edx, DWORD PTR _rn$[ebp]
	mov	DWORD PTR [edx+92], ecx

; 1853 : 				char *enums[]={"emergency","selective",0};

	mov	DWORD PTR _enums$5[ebp], OFFSET ??_C@_09EONNKBLK@emergency?$AA@
	mov	DWORD PTR _enums$5[ebp+4], OFFSET ??_C@_09MFNPLDDN@selective?$AA@
	mov	DWORD PTR _enums$5[ebp+8], 0
$LN64@RDLoadRack:

; 1854 : 
; 1855 : 				while(-1!=(i = TokenEnum(enums, -1)))

	push	-1
	lea	eax, DWORD PTR _enums$5[ebp]
	push	eax
	call	?TokenEnum@@YAHPAPADH@Z			; TokenEnum
	add	esp, 8
	mov	DWORD PTR _i$13[ebp], eax
	cmp	DWORD PTR _i$13[ebp], -1
	je	SHORT $LN65@RDLoadRack

; 1856 : 				{
; 1857 : 					switch(i)

	mov	ecx, DWORD PTR _i$13[ebp]
	mov	DWORD PTR tv186[ebp], ecx
	cmp	DWORD PTR tv186[ebp], 0
	je	SHORT $LN60@RDLoadRack
	cmp	DWORD PTR tv186[ebp], 1
	je	SHORT $LN59@RDLoadRack
	jmp	SHORT $LN61@RDLoadRack
$LN60@RDLoadRack:

; 1858 : 					{
; 1859 : 							case 0:
; 1860 : 									rn->flags|=RDF_EMERGENCY_JETT_RACK;

	mov	edx, DWORD PTR _rn$[ebp]
	mov	eax, DWORD PTR [edx+92]
	or	eax, 8
	mov	ecx, DWORD PTR _rn$[ebp]
	mov	DWORD PTR [ecx+92], eax

; 1861 : 									break;

	jmp	SHORT $LN61@RDLoadRack
$LN59@RDLoadRack:

; 1862 : 							case 1:
; 1863 : 									rn->flags|=RDF_SELECTIVE_JETT_RACK;

	mov	edx, DWORD PTR _rn$[ebp]
	mov	eax, DWORD PTR [edx+92]
	or	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _rn$[ebp]
	mov	DWORD PTR [ecx+92], eax
$LN61@RDLoadRack:

; 1864 : 									break;
; 1865 : 					}
; 1866 : 				}

	jmp	SHORT $LN64@RDLoadRack
$LN65@RDLoadRack:

; 1867 : 			}
; 1868 : 
; 1869 : 			On("weapjettmodes")

	push	OFFSET ??_C@_0O@EOKBAANG@weapjettmodes?$AA@
	mov	edx, DWORD PTR _com$32[ebp]
	push	edx
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	$LN58@RDLoadRack

; 1870 : 			{
; 1871 : 				int i;
; 1872 : 				rn->flags &=~(RDF_EMERGENCY_JETT_WEAPON | RDF_SELECTIVE_JETT_WEAPON); // clear flags

	mov	eax, DWORD PTR _rn$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	and	ecx, -7					; fffffff9H
	mov	edx, DWORD PTR _rn$[ebp]
	mov	DWORD PTR [edx+92], ecx

; 1873 : 				char *enums[]={"emergency","selective",0};

	mov	DWORD PTR _enums$4[ebp], OFFSET ??_C@_09EONNKBLK@emergency?$AA@
	mov	DWORD PTR _enums$4[ebp+4], OFFSET ??_C@_09MFNPLDDN@selective?$AA@
	mov	DWORD PTR _enums$4[ebp+8], 0
$LN57@RDLoadRack:

; 1874 : 
; 1875 : 				while(-1!=(i = TokenEnum(enums, -1)))

	push	-1
	lea	eax, DWORD PTR _enums$4[ebp]
	push	eax
	call	?TokenEnum@@YAHPAPADH@Z			; TokenEnum
	add	esp, 8
	mov	DWORD PTR _i$23[ebp], eax
	cmp	DWORD PTR _i$23[ebp], -1
	je	SHORT $LN58@RDLoadRack

; 1876 : 				{
; 1877 : 					switch(i)

	mov	ecx, DWORD PTR _i$23[ebp]
	mov	DWORD PTR tv206[ebp], ecx
	cmp	DWORD PTR tv206[ebp], 0
	je	SHORT $LN53@RDLoadRack
	cmp	DWORD PTR tv206[ebp], 1
	je	SHORT $LN52@RDLoadRack
	jmp	SHORT $LN54@RDLoadRack
$LN53@RDLoadRack:

; 1878 : 					{
; 1879 : 							case 0:
; 1880 : 									rn->flags|=RDF_EMERGENCY_JETT_WEAPON;

	mov	edx, DWORD PTR _rn$[ebp]
	mov	eax, DWORD PTR [edx+92]
	or	eax, 2
	mov	ecx, DWORD PTR _rn$[ebp]
	mov	DWORD PTR [ecx+92], eax

; 1881 : 									break;

	jmp	SHORT $LN54@RDLoadRack
$LN52@RDLoadRack:

; 1882 : 							case 1:
; 1883 : 									rn->flags|=RDF_SELECTIVE_JETT_WEAPON;

	mov	edx, DWORD PTR _rn$[ebp]
	mov	eax, DWORD PTR [edx+92]
	or	eax, 4
	mov	ecx, DWORD PTR _rn$[ebp]
	mov	DWORD PTR [ecx+92], eax
$LN54@RDLoadRack:

; 1884 : 									break;
; 1885 : 					}
; 1886 : 				}

	jmp	SHORT $LN57@RDLoadRack
$LN58@RDLoadRack:

; 1887 : 			}
; 1888 : 
; 1889 : 
; 1890 : 			On("addswd")

	push	OFFSET ??_C@_06JJCACEBF@addswd?$AA@
	mov	edx, DWORD PTR _com$32[ebp]
	push	edx
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	$LN51@RDLoadRack

; 1891 : 			{
; 1892 : 				int l=0;

	mov	DWORD PTR _l$29[ebp], 0

; 1893 : 				int i[100];
; 1894 : 				int ok=1;

	mov	DWORD PTR _ok$18[ebp], 1
$LN50@RDLoadRack:

; 1895 : 				while(ok && l<100)

	cmp	DWORD PTR _ok$18[ebp], 0
	je	SHORT $LN49@RDLoadRack
	cmp	DWORD PTR _l$29[ebp], 100		; 00000064H
	jge	SHORT $LN49@RDLoadRack

; 1896 : 				{
; 1897 : 					i[l]=TokenI(-1);

	push	-1
	call	?TokenI@@YAHH@Z				; TokenI
	add	esp, 4
	mov	ecx, DWORD PTR _l$29[ebp]
	mov	DWORD PTR _i$34[ebp+ecx*4], eax

; 1898 : 					if(i[l]==-1)

	mov	edx, DWORD PTR _l$29[ebp]
	cmp	DWORD PTR _i$34[ebp+edx*4], -1
	jne	SHORT $LN48@RDLoadRack

; 1899 : 						ok=0;

	mov	DWORD PTR _ok$18[ebp], 0
$LN48@RDLoadRack:

; 1900 : 					l++;

	mov	eax, DWORD PTR _l$29[ebp]
	add	eax, 1
	mov	DWORD PTR _l$29[ebp], eax

; 1901 : 				}

	jmp	SHORT $LN50@RDLoadRack
$LN49@RDLoadRack:

; 1902 : 				rn->swd=(int *)malloc(sizeof(int) * l);

	mov	ecx, DWORD PTR _l$29[ebp]
	shl	ecx, 2
	push	ecx
	call	_malloc
	add	esp, 4
	mov	edx, DWORD PTR _rn$[ebp]
	mov	DWORD PTR [edx+68], eax

; 1903 : 				rn->swdCount=l;

	mov	eax, DWORD PTR _rn$[ebp]
	mov	ecx, DWORD PTR _l$29[ebp]
	mov	DWORD PTR [eax+64], ecx

; 1904 : 
; 1905 : 				for(l=0;l<rn->swdCount;l++)

	mov	DWORD PTR _l$29[ebp], 0
	jmp	SHORT $LN47@RDLoadRack
$LN46@RDLoadRack:
	mov	edx, DWORD PTR _l$29[ebp]
	add	edx, 1
	mov	DWORD PTR _l$29[ebp], edx
$LN47@RDLoadRack:
	mov	eax, DWORD PTR _rn$[ebp]
	mov	ecx, DWORD PTR _l$29[ebp]
	cmp	ecx, DWORD PTR [eax+64]
	jge	SHORT $LN51@RDLoadRack

; 1906 : 				{
; 1907 : 					rn->swd[l]=i[l];

	mov	edx, DWORD PTR _rn$[ebp]
	mov	eax, DWORD PTR [edx+68]
	mov	ecx, DWORD PTR _l$29[ebp]
	mov	edx, DWORD PTR _l$29[ebp]
	mov	edx, DWORD PTR _i$34[ebp+edx*4]
	mov	DWORD PTR [eax+ecx*4], edx

; 1908 : 				}

	jmp	SHORT $LN46@RDLoadRack
$LN51@RDLoadRack:

; 1909 : 			}
; 1910 : 
; 1911 : 			On("addwid")

	push	OFFSET ??_C@_06PKDNDI@addwid?$AA@
	mov	eax, DWORD PTR _com$32[ebp]
	push	eax
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	$LN44@RDLoadRack

; 1912 : 			{
; 1913 : 				int l=0;

	mov	DWORD PTR _l$30[ebp], 0

; 1914 : 				int i[100];
; 1915 : 				int ok=1;

	mov	DWORD PTR _ok$17[ebp], 1
$LN43@RDLoadRack:

; 1916 : 				while(ok && l<100)

	cmp	DWORD PTR _ok$17[ebp], 0
	je	SHORT $LN42@RDLoadRack
	cmp	DWORD PTR _l$30[ebp], 100		; 00000064H
	jge	SHORT $LN42@RDLoadRack

; 1917 : 				{
; 1918 : 					i[l]=TokenI(-1);

	push	-1
	call	?TokenI@@YAHH@Z				; TokenI
	add	esp, 4
	mov	ecx, DWORD PTR _l$30[ebp]
	mov	DWORD PTR _i$33[ebp+ecx*4], eax

; 1919 : 					if(i[l]==-1)

	mov	edx, DWORD PTR _l$30[ebp]
	cmp	DWORD PTR _i$33[ebp+edx*4], -1
	jne	SHORT $LN41@RDLoadRack

; 1920 : 						ok=0;

	mov	DWORD PTR _ok$17[ebp], 0
$LN41@RDLoadRack:

; 1921 : 					l++;

	mov	eax, DWORD PTR _l$30[ebp]
	add	eax, 1
	mov	DWORD PTR _l$30[ebp], eax

; 1922 : 				}

	jmp	SHORT $LN43@RDLoadRack
$LN42@RDLoadRack:

; 1923 : 				rn->wId=(int *)malloc(sizeof(int) * l);

	mov	ecx, DWORD PTR _l$30[ebp]
	shl	ecx, 2
	push	ecx
	call	_malloc
	add	esp, 4
	mov	edx, DWORD PTR _rn$[ebp]
	mov	DWORD PTR [edx+76], eax

; 1924 : 				rn->wIdCount=l;

	mov	eax, DWORD PTR _rn$[ebp]
	mov	ecx, DWORD PTR _l$30[ebp]
	mov	DWORD PTR [eax+72], ecx

; 1925 : 
; 1926 : 				for(l=0;l<rn->wIdCount;l++)

	mov	DWORD PTR _l$30[ebp], 0
	jmp	SHORT $LN40@RDLoadRack
$LN39@RDLoadRack:
	mov	edx, DWORD PTR _l$30[ebp]
	add	edx, 1
	mov	DWORD PTR _l$30[ebp], edx
$LN40@RDLoadRack:
	mov	eax, DWORD PTR _rn$[ebp]
	mov	ecx, DWORD PTR _l$30[ebp]
	cmp	ecx, DWORD PTR [eax+72]
	jge	SHORT $LN44@RDLoadRack

; 1927 : 				{
; 1928 : 					rn->wId[l]=i[l];

	mov	edx, DWORD PTR _rn$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	ecx, DWORD PTR _l$30[ebp]
	mov	edx, DWORD PTR _l$30[ebp]
	mov	edx, DWORD PTR _i$33[ebp+edx*4]
	mov	DWORD PTR [eax+ecx*4], edx

; 1929 : 				}

	jmp	SHORT $LN39@RDLoadRack
$LN44@RDLoadRack:

; 1930 : 			}
; 1931 : 
; 1932 : 			On("racksmsname")

	push	OFFSET ??_C@_0M@IBPCJFOL@racksmsname?$AA@
	mov	eax, DWORD PTR _com$32[ebp]
	push	eax
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN37@RDLoadRack

; 1933 : 			{
; 1934 : 				strncpy(rn->mnemonic,TokenStr("-------"),11);

	push	11					; 0000000bH
	push	OFFSET ??_C@_07JGEAAKKP@?9?9?9?9?9?9?9?$AA@
	call	?TokenStr@@YAPADPAD@Z			; TokenStr
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _rn$[ebp]
	add	ecx, 44					; 0000002cH
	push	ecx
	call	_strncpy
	add	esp, 12					; 0000000cH
$LN37@RDLoadRack:

; 1935 : 			}
; 1936 : 
; 1937 : 			On("addloadorder")

	push	OFFSET ??_C@_0N@FOOPBGPI@addloadorder?$AA@
	mov	edx, DWORD PTR _com$32[ebp]
	push	edx
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	$LN36@RDLoadRack

; 1938 : 			{
; 1939 : 				int l = 0;

	mov	DWORD PTR _l$28[ebp], 0

; 1940 : 				int i[100];
; 1941 : 				int ok = 1;

	mov	DWORD PTR _ok$12[ebp], 1
$LN35@RDLoadRack:

; 1942 : 				while(ok)

	cmp	DWORD PTR _ok$12[ebp], 0
	je	SHORT $LN34@RDLoadRack

; 1943 : 				{
; 1944 : 					i[l]=TokenI(-1);

	push	-1
	call	?TokenI@@YAHH@Z				; TokenI
	add	esp, 4
	mov	ecx, DWORD PTR _l$28[ebp]
	mov	DWORD PTR _i$36[ebp+ecx*4], eax

; 1945 : 
; 1946 : 					if(i[l]==-1)

	mov	edx, DWORD PTR _l$28[ebp]
	cmp	DWORD PTR _i$36[ebp+edx*4], -1
	jne	SHORT $LN33@RDLoadRack

; 1947 : 						ok=0;

	mov	DWORD PTR _ok$12[ebp], 0

; 1948 : 					else

	jmp	SHORT $LN32@RDLoadRack
$LN33@RDLoadRack:

; 1949 : 						l++;

	mov	eax, DWORD PTR _l$28[ebp]
	add	eax, 1
	mov	DWORD PTR _l$28[ebp], eax
$LN32@RDLoadRack:

; 1950 : 				}

	jmp	SHORT $LN35@RDLoadRack
$LN34@RDLoadRack:

; 1951 : 
; 1952 : 				RDLoadOrderNode *lon = new RDLoadOrderNode(l);

	push	20					; 00000014H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T22[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T22[ebp], 0
	je	SHORT $LN83@RDLoadRack
	mov	ecx, DWORD PTR _l$28[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T22[ebp]
	call	??0RDLoadOrderNode@@QAE@H@Z		; RDLoadOrderNode::RDLoadOrderNode
	mov	DWORD PTR tv332[ebp], eax
	jmp	SHORT $LN84@RDLoadRack
$LN83@RDLoadRack:
	mov	DWORD PTR tv332[ebp], 0
$LN84@RDLoadRack:
	mov	edx, DWORD PTR tv332[ebp]
	mov	DWORD PTR $T9[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T9[ebp]
	mov	DWORD PTR _lon$26[ebp], eax

; 1953 : 
; 1954 : 				if(lon)

	cmp	DWORD PTR _lon$26[ebp], 0
	je	SHORT $LN36@RDLoadRack

; 1955 : 				{
; 1956 : 					for(l=0;i[l]!=-1;l++)

	mov	DWORD PTR _l$28[ebp], 0
	jmp	SHORT $LN30@RDLoadRack
$LN29@RDLoadRack:
	mov	ecx, DWORD PTR _l$28[ebp]
	add	ecx, 1
	mov	DWORD PTR _l$28[ebp], ecx
$LN30@RDLoadRack:
	mov	edx, DWORD PTR _l$28[ebp]
	cmp	DWORD PTR _i$36[ebp+edx*4], -1
	je	SHORT $LN28@RDLoadRack

; 1957 : 					{
; 1958 : 						lon->loadOrder[l] = i[l];

	mov	eax, DWORD PTR _lon$26[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _l$28[ebp]
	mov	eax, DWORD PTR _l$28[ebp]
	mov	eax, DWORD PTR _i$36[ebp+eax*4]
	mov	DWORD PTR [ecx+edx*4], eax

; 1959 : 					}

	jmp	SHORT $LN29@RDLoadRack
$LN28@RDLoadRack:

; 1960 : 
; 1961 : 					rn->loadOrder.AddTail((ANode *)lon);

	mov	ecx, DWORD PTR _lon$26[ebp]
	push	ecx
	mov	ecx, DWORD PTR _rn$[ebp]
	add	ecx, 96					; 00000060H
	call	?AddTail@AList@@QAEXPAVANode@@@Z	; AList::AddTail
$LN36@RDLoadRack:

; 1962 : 				}
; 1963 : 			}
; 1964 : 
; 1965 : 
; 1966 : 			On("addwclass")

	push	OFFSET ??_C@_09FNCMODGJ@addwclass?$AA@
	mov	edx, DWORD PTR _com$32[ebp]
	push	edx
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	$LN27@RDLoadRack

; 1967 : 			{
; 1968 : 				char *enums[]={	"aim","rocket","bomb","gun","ecm","tank","agm","harm","sam","gbu","camera",0 };

	mov	DWORD PTR _enums$2[ebp], OFFSET ??_C@_03MKHEFFMA@aim?$AA@
	mov	DWORD PTR _enums$2[ebp+4], OFFSET ??_C@_06NHDMJEKK@rocket?$AA@
	mov	DWORD PTR _enums$2[ebp+8], OFFSET ??_C@_04KOKOJKMM@bomb?$AA@
	mov	DWORD PTR _enums$2[ebp+12], OFFSET ??_C@_03NBAOADML@gun?$AA@
	mov	DWORD PTR _enums$2[ebp+16], OFFSET ??_C@_03EIIBEHEB@ecm?$AA@
	mov	DWORD PTR _enums$2[ebp+20], OFFSET ??_C@_04HCFFIKMN@tank?$AA@
	mov	DWORD PTR _enums$2[ebp+24], OFFSET ??_C@_03MAOKHIMK@agm?$AA@
	mov	DWORD PTR _enums$2[ebp+28], OFFSET ??_C@_04JECDANNM@harm?$AA@
	mov	DWORD PTR _enums$2[ebp+32], OFFSET ??_C@_03DOHHJLGM@sam?$AA@
	mov	DWORD PTR _enums$2[ebp+36], OFFSET ??_C@_03GBFBHNKE@gbu?$AA@
	mov	DWORD PTR _enums$2[ebp+40], OFFSET ??_C@_06FNKMPIBD@camera?$AA@
	mov	DWORD PTR _enums$2[ebp+44], 0

; 1969 : 				int l=0;

	mov	DWORD PTR _l$31[ebp], 0

; 1970 : 				int i[100];
; 1971 : 				int ok=1;

	mov	DWORD PTR _ok$25[ebp], 1
$LN26@RDLoadRack:

; 1972 : 				while(ok && l<100)

	cmp	DWORD PTR _ok$25[ebp], 0
	je	SHORT $LN25@RDLoadRack
	cmp	DWORD PTR _l$31[ebp], 100		; 00000064H
	jge	SHORT $LN25@RDLoadRack

; 1973 : 				{
; 1974 : 					i[l]=TokenEnum(enums,-1);

	push	-1
	lea	eax, DWORD PTR _enums$2[ebp]
	push	eax
	call	?TokenEnum@@YAHPAPADH@Z			; TokenEnum
	add	esp, 8
	mov	ecx, DWORD PTR _l$31[ebp]
	mov	DWORD PTR _i$35[ebp+ecx*4], eax

; 1975 : 					if(i[l]==-1)

	mov	edx, DWORD PTR _l$31[ebp]
	cmp	DWORD PTR _i$35[ebp+edx*4], -1
	jne	SHORT $LN24@RDLoadRack

; 1976 : 						ok=0;

	mov	DWORD PTR _ok$25[ebp], 0
$LN24@RDLoadRack:

; 1977 : 					l++;

	mov	eax, DWORD PTR _l$31[ebp]
	add	eax, 1
	mov	DWORD PTR _l$31[ebp], eax

; 1978 : 				}

	jmp	SHORT $LN26@RDLoadRack
$LN25@RDLoadRack:

; 1979 : 				rn->wClass=(int *)malloc(sizeof(int) * l);

	mov	ecx, DWORD PTR _l$31[ebp]
	shl	ecx, 2
	push	ecx
	call	_malloc
	add	esp, 4
	mov	edx, DWORD PTR _rn$[ebp]
	mov	DWORD PTR [edx+84], eax

; 1980 : 				rn->wClassCount=l;

	mov	eax, DWORD PTR _rn$[ebp]
	mov	ecx, DWORD PTR _l$31[ebp]
	mov	DWORD PTR [eax+80], ecx

; 1981 : 
; 1982 : 				for(l=0;l<rn->wClassCount;l++)

	mov	DWORD PTR _l$31[ebp], 0
	jmp	SHORT $LN23@RDLoadRack
$LN22@RDLoadRack:
	mov	edx, DWORD PTR _l$31[ebp]
	add	edx, 1
	mov	DWORD PTR _l$31[ebp], edx
$LN23@RDLoadRack:
	mov	eax, DWORD PTR _rn$[ebp]
	mov	ecx, DWORD PTR _l$31[ebp]
	cmp	ecx, DWORD PTR [eax+80]
	jge	SHORT $LN27@RDLoadRack

; 1983 : 				{
; 1984 : 					rn->wClass[l]=i[l];

	mov	edx, DWORD PTR _rn$[ebp]
	mov	eax, DWORD PTR [edx+84]
	mov	ecx, DWORD PTR _l$31[ebp]
	mov	edx, DWORD PTR _l$31[ebp]
	mov	edx, DWORD PTR _i$35[ebp+edx*4]
	mov	DWORD PTR [eax+ecx*4], edx

; 1985 : 				}

	jmp	SHORT $LN22@RDLoadRack
$LN27@RDLoadRack:

; 1986 : 			}
; 1987 : 
; 1988 : 			On("addany")

	push	OFFSET ??_C@_06IPKLEPOC@addany?$AA@
	mov	eax, DWORD PTR _com$32[ebp]
	push	eax
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN68@RDLoadRack

; 1989 : 			{
; 1990 : 				rn->any=1;

	mov	ecx, DWORD PTR _rn$[ebp]
	mov	DWORD PTR [ecx+88], 1
$LN68@RDLoadRack:

; 1991 : 			}
; 1992 : 		}
; 1993 : 
; 1994 : 		On("definegroup")

	push	OFFSET ??_C@_0M@DGIIHOML@definegroup?$AA@
	mov	edx, DWORD PTR _com$32[ebp]
	push	edx
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	$LN19@RDLoadRack

; 1995 : 		{
; 1996 : 			if(hpn=new RDHardpointNode)

	push	40					; 00000028H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T14[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	cmp	DWORD PTR $T14[ebp], 0
	je	SHORT $LN85@RDLoadRack
	mov	ecx, DWORD PTR $T14[ebp]
	call	??0RDHardpointNode@@QAE@XZ
	mov	DWORD PTR tv457[ebp], eax
	jmp	SHORT $LN86@RDLoadRack
$LN85@RDLoadRack:
	mov	DWORD PTR tv457[ebp], 0
$LN86@RDLoadRack:
	mov	eax, DWORD PTR tv457[ebp]
	mov	DWORD PTR $T8[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T8[ebp]
	mov	DWORD PTR _hpn$[ebp], ecx
	cmp	DWORD PTR _hpn$[ebp], 0
	je	SHORT $LN19@RDLoadRack

; 1997 : 			{
; 1998 : 				hpn->groupId=TokenI(0);

	push	0
	call	?TokenI@@YAHH@Z				; TokenI
	add	esp, 4
	mov	edx, DWORD PTR _hpn$[ebp]
	mov	DWORD PTR [edx+12], eax

; 1999 : 				RDHardpointList.AddTail(hpn);

	mov	eax, DWORD PTR _hpn$[ebp]
	push	eax
	mov	ecx, OFFSET ?RDHardpointList@@3VAList@@A ; RDHardpointList
	call	?AddTail@AList@@QAEXPAVANode@@@Z	; AList::AddTail

; 2000 : 				pn=0;

	mov	DWORD PTR _pn$[ebp], 0
$LN19@RDLoadRack:

; 2001 : 			}
; 2002 : 		}
; 2003 : 
; 2004 : 		if(hpn)

	cmp	DWORD PTR _hpn$[ebp], 0
	je	$LN17@RDLoadRack

; 2005 : 		{
; 2006 : 			On("addpylon")

	push	OFFSET ??_C@_08EPFDLFPB@addpylon?$AA@
	mov	ecx, DWORD PTR _com$32[ebp]
	push	ecx
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN16@RDLoadRack

; 2007 : 			{
; 2008 : 				if(pn = new RDPylonNode)

	push	56					; 00000038H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T16[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	cmp	DWORD PTR $T16[ebp], 0
	je	SHORT $LN87@RDLoadRack
	mov	ecx, DWORD PTR $T16[ebp]
	call	??0RDPylonNode@@QAE@XZ			; RDPylonNode::RDPylonNode
	mov	DWORD PTR tv479[ebp], eax
	jmp	SHORT $LN88@RDLoadRack
$LN87@RDLoadRack:
	mov	DWORD PTR tv479[ebp], 0
$LN88@RDLoadRack:
	mov	edx, DWORD PTR tv479[ebp]
	mov	DWORD PTR $T6[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T6[ebp]
	mov	DWORD PTR _pn$[ebp], eax
	cmp	DWORD PTR _pn$[ebp], 0
	je	SHORT $LN16@RDLoadRack

; 2009 : 				{
; 2010 : 					//strncpy(pn->mnemonic,TokenStr("-------"),11);
; 2011 : 					hpn->pylonList.AddTail(pn);

	mov	ecx, DWORD PTR _pn$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _hpn$[ebp]
	add	ecx, 16					; 00000010H
	call	?AddTail@AList@@QAEXPAVANode@@@Z	; AList::AddTail
$LN16@RDLoadRack:

; 2012 : 				}
; 2013 : 			}
; 2014 : 
; 2015 : 			if(pn)

	cmp	DWORD PTR _pn$[ebp], 0
	je	$LN17@RDLoadRack

; 2016 : 			{
; 2017 : 				On("addrack")

	push	OFFSET ??_C@_07KGBAEBNF@addrack?$AA@
	mov	edx, DWORD PTR _com$32[ebp]
	push	edx
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	$LN13@RDLoadRack
$LN12@RDLoadRack:

; 2018 : 				{
; 2019 : 					char *n;
; 2020 : 					while(n=TokenStr(0))

	push	0
	call	?TokenStr@@YAPADPAD@Z			; TokenStr
	add	esp, 4
	mov	DWORD PTR _n$21[ebp], eax
	cmp	DWORD PTR _n$21[ebp], 0
	je	$LN13@RDLoadRack

; 2021 : 					{
; 2022 : 						RDRackNameNode *rnn;
; 2023 : 						if(rnn = new RDRackNameNode)

	push	44					; 0000002cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T24[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	cmp	DWORD PTR $T24[ebp], 0
	je	SHORT $LN89@RDLoadRack
	mov	ecx, DWORD PTR $T24[ebp]
	call	??0RDRackNameNode@@QAE@XZ
	mov	DWORD PTR tv502[ebp], eax
	jmp	SHORT $LN90@RDLoadRack
$LN89@RDLoadRack:
	mov	DWORD PTR tv502[ebp], 0
$LN90@RDLoadRack:
	mov	eax, DWORD PTR tv502[ebp]
	mov	DWORD PTR $T7[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T7[ebp]
	mov	DWORD PTR _rnn$27[ebp], ecx
	cmp	DWORD PTR _rnn$27[ebp], 0
	je	SHORT $LN10@RDLoadRack

; 2024 : 						{
; 2025 : 							strncpy(rnn->rackName,n,32);

	push	32					; 00000020H
	mov	edx, DWORD PTR _n$21[ebp]
	push	edx
	mov	eax, DWORD PTR _rnn$27[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	call	_strncpy
	add	esp, 12					; 0000000cH

; 2026 : 							pn->rackNameList.AddTail(rnn);

	mov	ecx, DWORD PTR _rnn$27[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pn$[ebp]
	add	ecx, 32					; 00000020H
	call	?AddTail@AList@@QAEXPAVANode@@@Z	; AList::AddTail
$LN10@RDLoadRack:

; 2027 : 						}
; 2028 : 					}

	jmp	$LN12@RDLoadRack
$LN13@RDLoadRack:

; 2029 : 				}
; 2030 : 
; 2031 : 				On("pylonct")

	push	OFFSET ??_C@_07PBBCECPI@pylonct?$AA@
	mov	edx, DWORD PTR _com$32[ebp]
	push	edx
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@RDLoadRack

; 2032 : 				{
; 2033 : 					pn->pylonCT=TokenI(0);

	push	0
	call	?TokenI@@YAHH@Z				; TokenI
	add	esp, 4
	mov	ecx, DWORD PTR _pn$[ebp]
	mov	DWORD PTR [ecx+24], eax
$LN9@RDLoadRack:

; 2034 : 				}
; 2035 : 
; 2036 : 				On("pylonsmsname")

	push	OFFSET ??_C@_0N@KFAKCFEK@pylonsmsname?$AA@
	mov	edx, DWORD PTR _com$32[ebp]
	push	edx
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN8@RDLoadRack

; 2037 : 				{
; 2038 : 					strncpy(pn->mnemonic,TokenStr("-------"),12);

	push	12					; 0000000cH
	push	OFFSET ??_C@_07JGEAAKKP@?9?9?9?9?9?9?9?$AA@
	call	?TokenStr@@YAPADPAD@Z			; TokenStr
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _pn$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	call	_strncpy
	add	esp, 12					; 0000000cH
$LN8@RDLoadRack:

; 2039 : 				}
; 2040 : 
; 2041 : 				On("pylonjettmodes")

	push	OFFSET ??_C@_0P@BHCKMDOB@pylonjettmodes?$AA@
	mov	ecx, DWORD PTR _com$32[ebp]
	push	ecx
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	$LN17@RDLoadRack

; 2042 : 				{
; 2043 : 					int i;
; 2044 : 					pn->flags &=~(RDF_EMERGENCY_JETT_PYLON | RDF_SELECTIVE_JETT_PYLON); // clear flags

	mov	edx, DWORD PTR _pn$[ebp]
	mov	eax, DWORD PTR [edx+28]
	and	eax, -97				; ffffff9fH
	mov	ecx, DWORD PTR _pn$[ebp]
	mov	DWORD PTR [ecx+28], eax

; 2045 : 					char *enums[]={"emergency","selective",0};

	mov	DWORD PTR _enums$3[ebp], OFFSET ??_C@_09EONNKBLK@emergency?$AA@
	mov	DWORD PTR _enums$3[ebp+4], OFFSET ??_C@_09MFNPLDDN@selective?$AA@
	mov	DWORD PTR _enums$3[ebp+8], 0
$LN6@RDLoadRack:

; 2046 : 
; 2047 : 					while(-1!=(i = TokenEnum(enums, -1)))

	push	-1
	lea	edx, DWORD PTR _enums$3[ebp]
	push	edx
	call	?TokenEnum@@YAHPAPADH@Z			; TokenEnum
	add	esp, 8
	mov	DWORD PTR _i$19[ebp], eax
	cmp	DWORD PTR _i$19[ebp], -1
	je	SHORT $LN17@RDLoadRack

; 2048 : 					{
; 2049 : 						switch(i)

	mov	eax, DWORD PTR _i$19[ebp]
	mov	DWORD PTR tv542[ebp], eax
	cmp	DWORD PTR tv542[ebp], 0
	je	SHORT $LN2@RDLoadRack
	cmp	DWORD PTR tv542[ebp], 1
	je	SHORT $LN1@RDLoadRack
	jmp	SHORT $LN3@RDLoadRack
$LN2@RDLoadRack:

; 2050 : 						{
; 2051 : 								case 0:
; 2052 : 										pn->flags|=RDF_EMERGENCY_JETT_PYLON;

	mov	ecx, DWORD PTR _pn$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	or	edx, 32					; 00000020H
	mov	eax, DWORD PTR _pn$[ebp]
	mov	DWORD PTR [eax+28], edx

; 2053 : 										break;

	jmp	SHORT $LN3@RDLoadRack
$LN1@RDLoadRack:

; 2054 : 								case 1:
; 2055 : 										pn->flags|=RDF_SELECTIVE_JETT_PYLON;

	mov	ecx, DWORD PTR _pn$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	or	edx, 64					; 00000040H
	mov	eax, DWORD PTR _pn$[ebp]
	mov	DWORD PTR [eax+28], edx
$LN3@RDLoadRack:

; 2056 : 										break;
; 2057 : 						}
; 2058 : 					}

	jmp	SHORT $LN6@RDLoadRack
$LN17@RDLoadRack:

; 2059 : 				}
; 2060 : 			}
; 2061 : 		}
; 2062 : 	}

	jmp	$LN76@RDLoadRack
$LN75@RDLoadRack:

; 2063 : 	fclose(fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fclose
	add	esp, 4
$LN79@RDLoadRack:

; 2064 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?RDLoadRackData@@YAXXZ$0:
	mov	eax, DWORD PTR $T20[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?RDLoadRackData@@YAXXZ$1:
	mov	eax, DWORD PTR $T22[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?RDLoadRackData@@YAXXZ$2:
	mov	eax, DWORD PTR $T14[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?RDLoadRackData@@YAXXZ$3:
	mov	eax, DWORD PTR $T16[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?RDLoadRackData@@YAXXZ$4:
	mov	eax, DWORD PTR $T24[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?RDLoadRackData@@YAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-2872]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?RDLoadRackData@@YAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?RDLoadRackData@@YAXXZ ENDP				; RDLoadRackData
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\entity.cpp
_TEXT	SEGMENT
_j$1 = -12						; size = 4
_i$2 = -8						; size = 4
_rack$3 = -4						; size = 4
_planerg$ = 8						; size = 4
_weaponrg$ = 12						; size = 4
_count$ = 16						; size = 4
?FindBestRackIDByPlaneAndWeapon@@YAHHHH@Z PROC		; FindBestRackIDByPlaneAndWeapon

; 1628 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1629 : 	if (planerg < 0 || planerg >= MaxRackGroups ||
; 1630 : 					weaponrg < 0 || weaponrg >= MaxRackGroups)

	cmp	DWORD PTR _planerg$[ebp], 0
	jl	SHORT $LN8@FindBestRa
	mov	eax, DWORD PTR _planerg$[ebp]
	cmp	eax, DWORD PTR ?MaxRackGroups@@3HA	; MaxRackGroups
	jge	SHORT $LN8@FindBestRa
	cmp	DWORD PTR _weaponrg$[ebp], 0
	jl	SHORT $LN8@FindBestRa
	mov	ecx, DWORD PTR _weaponrg$[ebp]
	cmp	ecx, DWORD PTR ?MaxRackGroups@@3HA	; MaxRackGroups
	jl	SHORT $LN9@FindBestRa
$LN8@FindBestRa:

; 1631 : 		return -1;

	or	eax, -1
	jmp	$LN10@FindBestRa
$LN9@FindBestRa:

; 1632 : 	// first find a rackgroup in common
; 1633 : 	for(int i = 0; i < RackGroupTable[planerg].nentries; i++) {

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN7@FindBestRa
$LN6@FindBestRa:
	mov	edx, DWORD PTR _i$2[ebp]
	add	edx, 1
	mov	DWORD PTR _i$2[ebp], edx
$LN7@FindBestRa:
	mov	eax, DWORD PTR _planerg$[ebp]
	mov	ecx, DWORD PTR ?RackGroupTable@@3PAURackGroup@@A ; RackGroupTable
	mov	edx, DWORD PTR _i$2[ebp]
	cmp	edx, DWORD PTR [ecx+eax*8]
	jge	$LN5@FindBestRa

; 1634 : 		for (int j = 0; j < RackGroupTable[weaponrg].nentries; j++) {

	mov	DWORD PTR _j$1[ebp], 0
	jmp	SHORT $LN4@FindBestRa
$LN3@FindBestRa:
	mov	eax, DWORD PTR _j$1[ebp]
	add	eax, 1
	mov	DWORD PTR _j$1[ebp], eax
$LN4@FindBestRa:
	mov	ecx, DWORD PTR _weaponrg$[ebp]
	mov	edx, DWORD PTR ?RackGroupTable@@3PAURackGroup@@A ; RackGroupTable
	mov	eax, DWORD PTR _j$1[ebp]
	cmp	eax, DWORD PTR [edx+ecx*8]
	jge	SHORT $LN2@FindBestRa

; 1635 : 			int rack = RackGroupTable[planerg].entries[i];

	mov	ecx, DWORD PTR _planerg$[ebp]
	mov	edx, DWORD PTR ?RackGroupTable@@3PAURackGroup@@A ; RackGroupTable
	mov	eax, DWORD PTR [edx+ecx*8+4]
	mov	ecx, DWORD PTR _i$2[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _rack$3[ebp], edx

; 1636 : 			if (rack == RackGroupTable[weaponrg].entries[j] &&
; 1637 : 							rack > 0 && rack < MaxRackObjects && 
; 1638 : 							RackObjectTable[rack].maxoccupancy >= count)

	mov	eax, DWORD PTR _weaponrg$[ebp]
	mov	ecx, DWORD PTR ?RackGroupTable@@3PAURackGroup@@A ; RackGroupTable
	mov	edx, DWORD PTR [ecx+eax*8+4]
	mov	eax, DWORD PTR _j$1[ebp]
	mov	ecx, DWORD PTR _rack$3[ebp]
	cmp	ecx, DWORD PTR [edx+eax*4]
	jne	SHORT $LN1@FindBestRa
	cmp	DWORD PTR _rack$3[ebp], 0
	jle	SHORT $LN1@FindBestRa
	mov	edx, DWORD PTR _rack$3[ebp]
	cmp	edx, DWORD PTR ?MaxRackObjects@@3HA	; MaxRackObjects
	jge	SHORT $LN1@FindBestRa
	mov	eax, DWORD PTR _rack$3[ebp]
	mov	ecx, DWORD PTR ?RackObjectTable@@3PAURackObject@@A ; RackObjectTable
	mov	edx, DWORD PTR [ecx+eax*8+4]
	cmp	edx, DWORD PTR _count$[ebp]
	jl	SHORT $LN1@FindBestRa

; 1639 : 				return rack;

	mov	eax, DWORD PTR _rack$3[ebp]
	jmp	SHORT $LN10@FindBestRa
$LN1@FindBestRa:

; 1640 : 		}

	jmp	SHORT $LN3@FindBestRa
$LN2@FindBestRa:

; 1641 : 	}

	jmp	$LN6@FindBestRa
$LN5@FindBestRa:

; 1642 : 	return -1;

	or	eax, -1
$LN10@FindBestRa:

; 1643 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FindBestRackIDByPlaneAndWeapon@@YAHHHH@Z ENDP		; FindBestRackIDByPlaneAndWeapon
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\entity.cpp
_TEXT	SEGMENT
_rack$1 = -8						; size = 4
_i$2 = -4						; size = 4
_rackgroup$ = 8						; size = 4
_count$ = 12						; size = 4
?FindBestRackID@@YAHHH@Z PROC				; FindBestRackID

; 1615 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1616 : 	if (rackgroup < 0 || rackgroup >= MaxRackGroups)

	cmp	DWORD PTR _rackgroup$[ebp], 0
	jl	SHORT $LN5@FindBestRa
	mov	eax, DWORD PTR _rackgroup$[ebp]
	cmp	eax, DWORD PTR ?MaxRackGroups@@3HA	; MaxRackGroups
	jl	SHORT $LN6@FindBestRa
$LN5@FindBestRa:

; 1617 : 		return -1;

	or	eax, -1
	jmp	SHORT $LN7@FindBestRa
$LN6@FindBestRa:

; 1618 : 	for (int i = 0; i < RackGroupTable[rackgroup].nentries; i++) {

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN4@FindBestRa
$LN3@FindBestRa:
	mov	ecx, DWORD PTR _i$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$2[ebp], ecx
$LN4@FindBestRa:
	mov	edx, DWORD PTR _rackgroup$[ebp]
	mov	eax, DWORD PTR ?RackGroupTable@@3PAURackGroup@@A ; RackGroupTable
	mov	ecx, DWORD PTR _i$2[ebp]
	cmp	ecx, DWORD PTR [eax+edx*8]
	jge	SHORT $LN2@FindBestRa

; 1619 : 		int rack = RackGroupTable[rackgroup].entries[i];

	mov	edx, DWORD PTR _rackgroup$[ebp]
	mov	eax, DWORD PTR ?RackGroupTable@@3PAURackGroup@@A ; RackGroupTable
	mov	ecx, DWORD PTR [eax+edx*8+4]
	mov	edx, DWORD PTR _i$2[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _rack$1[ebp], eax

; 1620 : 		if (rack > 0 && rack < MaxRackObjects && 
; 1621 : 						RackObjectTable[rack].maxoccupancy >= count)

	cmp	DWORD PTR _rack$1[ebp], 0
	jle	SHORT $LN1@FindBestRa
	mov	ecx, DWORD PTR _rack$1[ebp]
	cmp	ecx, DWORD PTR ?MaxRackObjects@@3HA	; MaxRackObjects
	jge	SHORT $LN1@FindBestRa
	mov	edx, DWORD PTR _rack$1[ebp]
	mov	eax, DWORD PTR ?RackObjectTable@@3PAURackObject@@A ; RackObjectTable
	mov	ecx, DWORD PTR [eax+edx*8+4]
	cmp	ecx, DWORD PTR _count$[ebp]
	jl	SHORT $LN1@FindBestRa

; 1622 : 			return rack;

	mov	eax, DWORD PTR _rack$1[ebp]
	jmp	SHORT $LN7@FindBestRa
$LN1@FindBestRa:

; 1623 : 	}

	jmp	SHORT $LN3@FindBestRa
$LN2@FindBestRa:

; 1624 : 	return -1; // not possible

	or	eax, -1
$LN7@FindBestRa:

; 1625 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FindBestRackID@@YAHHH@Z ENDP				; FindBestRackID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\entity.cpp
_TEXT	SEGMENT
$T1 = -312						; size = 4
$T2 = -308						; size = 4
_occ$3 = -304						; size = 4
_ctid$4 = -300						; size = 4
$T5 = -296						; size = 4
_grp$6 = -292						; size = 4
_rg$ = -288						; size = 4
_rack$ = -284						; size = 4
_i$7 = -280						; size = 4
_ngrp$ = -276						; size = 4
_fp$ = -272						; size = 4
_cp$8 = -268						; size = 4
_buffer$ = -264						; size = 260
__$ArrayPad$ = -4					; size = 4
?LoadRackTables@@YAXXZ PROC				; LoadRackTables

; 1538 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 312				; 00000138H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1539 : 	FILE *fp;
; 1540 : 	int ngrp;
; 1541 : 	char buffer[MAX_PATH];
; 1542 : 
; 1543 : 	if ((fp = OpenCampFile("Rack", "dat", "rt")) == NULL) {

	push	OFFSET ??_C@_02BMJICGCB@rt?$AA@
	push	OFFSET ??_C@_03GILJFNFC@dat?$AA@
	push	OFFSET ??_C@_04DEAMMDDK@Rack?$AA@
	call	?OpenCampFile@@YAPAU_iobuf@@PAD00@Z	; OpenCampFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _fp$[ebp], eax
	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $LN37@LoadRackTa

; 1544 : 		sprintf (buffer, "%s\\%s", FalconObjectDataDir, "Rack.dat");

	push	OFFSET ??_C@_08EJINGHLB@Rack?4dat?$AA@
	push	OFFSET ?FalconObjectDataDir@@3PADA	; FalconObjectDataDir
	push	OFFSET ??_C@_05BMGBEOOC@?$CFs?2?$CFs?$AA@
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H

; 1545 : 		if ((fp = fopen(buffer, "rt")) == NULL) return;

	push	OFFSET ??_C@_02BMJICGCB@rt?$AA@
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$[ebp], eax
	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $LN37@LoadRackTa
	jmp	$LN40@LoadRackTa
$LN37@LoadRackTa:

; 1546 : 	}
; 1547 : 
; 1548 : 	while (fgets (buffer, sizeof buffer, fp)) {

	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	push	260					; 00000104H
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_fgets
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN36@LoadRackTa

; 1549 : 		if (buffer[0] == '#' || buffer[0] == '\n')

	mov	ecx, 1
	imul	ecx, 0
	movsx	edx, BYTE PTR _buffer$[ebp+ecx]
	cmp	edx, 35					; 00000023H
	je	SHORT $LN34@LoadRackTa
	mov	eax, 1
	imul	eax, 0
	movsx	ecx, BYTE PTR _buffer$[ebp+eax]
	cmp	ecx, 10					; 0000000aH
	jne	SHORT $LN35@LoadRackTa
$LN34@LoadRackTa:

; 1550 : 			continue;

	jmp	SHORT $LN37@LoadRackTa
$LN35@LoadRackTa:

; 1551 : 		if (sscanf(buffer, "NumGroups %d", &ngrp) != 1)

	lea	edx, DWORD PTR _ngrp$[ebp]
	push	edx
	push	OFFSET ??_C@_0N@KPJEKBOE@NumGroups?5?$CFd?$AA@
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_sscanf
	add	esp, 12					; 0000000cH
	cmp	eax, 1
	je	SHORT $LN33@LoadRackTa

; 1552 : 			continue;

	jmp	SHORT $LN37@LoadRackTa
$LN33@LoadRackTa:

; 1553 : 		ShiAssert(ngrp >= 0 && ngrp < 1000); // arbitrary 1000
; 1554 : 		break;

	jmp	SHORT $LN36@LoadRackTa

; 1555 : 	}

	jmp	SHORT $LN37@LoadRackTa
$LN36@LoadRackTa:

; 1556 : 	if (feof(fp)) {fclose(fp); return; }

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_feof
	add	esp, 4
	test	eax, eax
	je	SHORT $LN32@LoadRackTa
	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_fclose
	add	esp, 4
	jmp	$LN40@LoadRackTa
$LN32@LoadRackTa:

; 1557 : 	// read in the groups
; 1558 : 	MaxRackGroups = ngrp;

	mov	eax, DWORD PTR _ngrp$[ebp]
	mov	DWORD PTR ?MaxRackGroups@@3HA, eax	; MaxRackGroups

; 1559 : 	RackGroupTable = new RackGroup[MaxRackGroups];

	xor	ecx, ecx
	mov	eax, DWORD PTR ?MaxRackGroups@@3HA	; MaxRackGroups
	mov	edx, 8
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR ?RackGroupTable@@3PAURackGroup@@A, eax ; RackGroupTable

; 1560 : 	int rg = 0;

	mov	DWORD PTR _rg$[ebp], 0
$LN31@LoadRackTa:

; 1561 : 	while (rg < MaxRackGroups && fgets (buffer, sizeof buffer, fp)) {

	mov	ecx, DWORD PTR _rg$[ebp]
	cmp	ecx, DWORD PTR ?MaxRackGroups@@3HA	; MaxRackGroups
	jge	$LN11@LoadRackTa
	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	push	260					; 00000104H
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_fgets
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN11@LoadRackTa

; 1562 : 		if (buffer[0] == '#' || buffer[0] == '\n')

	mov	ecx, 1
	imul	ecx, 0
	movsx	edx, BYTE PTR _buffer$[ebp+ecx]
	cmp	edx, 35					; 00000023H
	je	SHORT $LN28@LoadRackTa
	mov	eax, 1
	imul	eax, 0
	movsx	ecx, BYTE PTR _buffer$[ebp+eax]
	cmp	ecx, 10					; 0000000aH
	jne	SHORT $LN29@LoadRackTa
$LN28@LoadRackTa:

; 1563 : 			continue;

	jmp	SHORT $LN31@LoadRackTa
$LN29@LoadRackTa:

; 1564 : 		int grp;
; 1565 : 
; 1566 : 		char *cp = buffer;

	lea	edx, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _cp$8[ebp], edx

; 1567 : 		if (sscanf(cp, "Group%d", &grp) != 1)

	lea	eax, DWORD PTR _grp$6[ebp]
	push	eax
	push	OFFSET ??_C@_07FOMKHCGE@Group?$CFd?$AA@
	mov	ecx, DWORD PTR _cp$8[ebp]
	push	ecx
	call	_sscanf
	add	esp, 12					; 0000000cH
	cmp	eax, 1
	je	SHORT $LN27@LoadRackTa

; 1568 : 			continue;

	jmp	$LN31@LoadRackTa
$LN27@LoadRackTa:

; 1569 : 		cp += 5;

	mov	edx, DWORD PTR _cp$8[ebp]
	add	edx, 5
	mov	DWORD PTR _cp$8[ebp], edx
$LN26@LoadRackTa:

; 1570 : 		ShiAssert(grp < MaxRackGroups); // well it should be 
; 1571 : 		while (isdigit(*cp)) cp++;

	mov	eax, DWORD PTR _cp$8[ebp]
	movsx	ecx, BYTE PTR [eax]
	push	ecx
	call	_isdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN24@LoadRackTa
	mov	edx, DWORD PTR _cp$8[ebp]
	add	edx, 1
	mov	DWORD PTR _cp$8[ebp], edx
	jmp	SHORT $LN26@LoadRackTa
$LN24@LoadRackTa:

; 1572 : 		while (isspace(*cp)) cp++;

	mov	eax, DWORD PTR _cp$8[ebp]
	movsx	ecx, BYTE PTR [eax]
	push	ecx
	call	_isspace
	add	esp, 4
	test	eax, eax
	je	SHORT $LN23@LoadRackTa
	mov	edx, DWORD PTR _cp$8[ebp]
	add	edx, 1
	mov	DWORD PTR _cp$8[ebp], edx
	jmp	SHORT $LN24@LoadRackTa
$LN23@LoadRackTa:

; 1573 : 		ngrp = atoi(cp);

	mov	eax, DWORD PTR _cp$8[ebp]
	push	eax
	call	_atoi
	add	esp, 4
	mov	DWORD PTR _ngrp$[ebp], eax

; 1574 : 		ShiAssert(ngrp >= 0 && ngrp < 1000); // arbitrary 1000
; 1575 : 		RackGroupTable[grp].nentries = ngrp;

	mov	ecx, DWORD PTR _grp$6[ebp]
	mov	edx, DWORD PTR ?RackGroupTable@@3PAURackGroup@@A ; RackGroupTable
	mov	eax, DWORD PTR _ngrp$[ebp]
	mov	DWORD PTR [edx+ecx*8], eax

; 1576 : 		RackGroupTable[grp].entries = new int [ngrp];

	xor	ecx, ecx
	mov	eax, DWORD PTR _ngrp$[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR _grp$6[ebp]
	mov	ecx, DWORD PTR ?RackGroupTable@@3PAURackGroup@@A ; RackGroupTable
	mov	edx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [ecx+eax*8+4], edx
$LN22@LoadRackTa:

; 1577 : 		while (isdigit(*cp)) cp++;

	mov	eax, DWORD PTR _cp$8[ebp]
	movsx	ecx, BYTE PTR [eax]
	push	ecx
	call	_isdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN20@LoadRackTa
	mov	edx, DWORD PTR _cp$8[ebp]
	add	edx, 1
	mov	DWORD PTR _cp$8[ebp], edx
	jmp	SHORT $LN22@LoadRackTa
$LN20@LoadRackTa:

; 1578 : 		while (isspace(*cp)) cp++;

	mov	eax, DWORD PTR _cp$8[ebp]
	movsx	ecx, BYTE PTR [eax]
	push	ecx
	call	_isspace
	add	esp, 4
	test	eax, eax
	je	SHORT $LN19@LoadRackTa
	mov	edx, DWORD PTR _cp$8[ebp]
	add	edx, 1
	mov	DWORD PTR _cp$8[ebp], edx
	jmp	SHORT $LN20@LoadRackTa
$LN19@LoadRackTa:

; 1579 : 		for (int i = 0; *cp && i < ngrp; i++)  {

	mov	DWORD PTR _i$7[ebp], 0
	jmp	SHORT $LN18@LoadRackTa
$LN17@LoadRackTa:
	mov	eax, DWORD PTR _i$7[ebp]
	add	eax, 1
	mov	DWORD PTR _i$7[ebp], eax
$LN18@LoadRackTa:
	mov	ecx, DWORD PTR _cp$8[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	$LN16@LoadRackTa
	mov	eax, DWORD PTR _i$7[ebp]
	cmp	eax, DWORD PTR _ngrp$[ebp]
	jge	SHORT $LN16@LoadRackTa

; 1580 : 			RackGroupTable[grp].entries[i] = atoi(cp);

	mov	ecx, DWORD PTR _cp$8[ebp]
	push	ecx
	call	_atoi
	add	esp, 4
	mov	edx, DWORD PTR _grp$6[ebp]
	mov	ecx, DWORD PTR ?RackGroupTable@@3PAURackGroup@@A ; RackGroupTable
	mov	edx, DWORD PTR [ecx+edx*8+4]
	mov	ecx, DWORD PTR _i$7[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
$LN15@LoadRackTa:

; 1581 : 			while (isdigit(*cp)) cp++;

	mov	edx, DWORD PTR _cp$8[ebp]
	movsx	eax, BYTE PTR [edx]
	push	eax
	call	_isdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN13@LoadRackTa
	mov	ecx, DWORD PTR _cp$8[ebp]
	add	ecx, 1
	mov	DWORD PTR _cp$8[ebp], ecx
	jmp	SHORT $LN15@LoadRackTa
$LN13@LoadRackTa:

; 1582 : 			while (isspace(*cp)) cp++;

	mov	edx, DWORD PTR _cp$8[ebp]
	movsx	eax, BYTE PTR [edx]
	push	eax
	call	_isspace
	add	esp, 4
	test	eax, eax
	je	SHORT $LN12@LoadRackTa
	mov	ecx, DWORD PTR _cp$8[ebp]
	add	ecx, 1
	mov	DWORD PTR _cp$8[ebp], ecx
	jmp	SHORT $LN13@LoadRackTa
$LN12@LoadRackTa:

; 1583 : 		}

	jmp	$LN17@LoadRackTa
$LN16@LoadRackTa:

; 1584 : 		rg ++;

	mov	edx, DWORD PTR _rg$[ebp]
	add	edx, 1
	mov	DWORD PTR _rg$[ebp], edx

; 1585 : 	}

	jmp	$LN31@LoadRackTa
$LN11@LoadRackTa:

; 1586 : 	// now read in the entries
; 1587 : 	while (fgets (buffer, sizeof buffer, fp)) {

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	260					; 00000104H
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_fgets
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN10@LoadRackTa

; 1588 : 		if (buffer[0] == '#' || buffer[0] == '\n')

	mov	edx, 1
	imul	edx, 0
	movsx	eax, BYTE PTR _buffer$[ebp+edx]
	cmp	eax, 35					; 00000023H
	je	SHORT $LN8@LoadRackTa
	mov	ecx, 1
	imul	ecx, 0
	movsx	edx, BYTE PTR _buffer$[ebp+ecx]
	cmp	edx, 10					; 0000000aH
	jne	SHORT $LN9@LoadRackTa
$LN8@LoadRackTa:

; 1589 : 			continue;

	jmp	SHORT $LN11@LoadRackTa
$LN9@LoadRackTa:

; 1590 : 		if (sscanf(buffer, "NumRacks %d", &ngrp) != 1)

	lea	eax, DWORD PTR _ngrp$[ebp]
	push	eax
	push	OFFSET ??_C@_0M@EPMLFDLC@NumRacks?5?$CFd?$AA@
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_sscanf
	add	esp, 12					; 0000000cH
	cmp	eax, 1
	je	SHORT $LN7@LoadRackTa

; 1591 : 			continue;

	jmp	SHORT $LN11@LoadRackTa
$LN7@LoadRackTa:

; 1592 : 		ShiAssert(ngrp >= 0 && ngrp < 1000); // arbitrary 1000
; 1593 : 		break;

	jmp	SHORT $LN10@LoadRackTa

; 1594 : 	}

	jmp	SHORT $LN11@LoadRackTa
$LN10@LoadRackTa:

; 1595 : 	if (feof(fp)) {fclose(fp); return; }

	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_feof
	add	esp, 4
	test	eax, eax
	je	SHORT $LN6@LoadRackTa
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fclose
	add	esp, 4
	jmp	$LN40@LoadRackTa
$LN6@LoadRackTa:

; 1596 : 	MaxRackObjects = ngrp;

	mov	ecx, DWORD PTR _ngrp$[ebp]
	mov	DWORD PTR ?MaxRackObjects@@3HA, ecx	; MaxRackObjects

; 1597 : 	RackObjectTable = new RackObject[MaxRackObjects];

	xor	ecx, ecx
	mov	eax, DWORD PTR ?MaxRackObjects@@3HA	; MaxRackObjects
	mov	edx, 8
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T5[ebp], eax
	mov	eax, DWORD PTR $T5[ebp]
	mov	DWORD PTR ?RackObjectTable@@3PAURackObject@@A, eax ; RackObjectTable

; 1598 : 	memset(RackObjectTable, 0, sizeof(*RackObjectTable) * MaxRackObjects);

	mov	ecx, DWORD PTR ?MaxRackObjects@@3HA	; MaxRackObjects
	shl	ecx, 3
	push	ecx
	push	0
	mov	edx, DWORD PTR ?RackObjectTable@@3PAURackObject@@A ; RackObjectTable
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 1599 : 	int rack = 0;

	mov	DWORD PTR _rack$[ebp], 0
$LN5@LoadRackTa:

; 1600 : 	while (fgets (buffer, sizeof buffer, fp)) {

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	260					; 00000104H
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_fgets
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN4@LoadRackTa

; 1601 : 		if (buffer[0] == '#' || buffer[0] == '\n')

	mov	edx, 1
	imul	edx, 0
	movsx	eax, BYTE PTR _buffer$[ebp+edx]
	cmp	eax, 35					; 00000023H
	je	SHORT $LN2@LoadRackTa
	mov	ecx, 1
	imul	ecx, 0
	movsx	edx, BYTE PTR _buffer$[ebp+ecx]
	cmp	edx, 10					; 0000000aH
	jne	SHORT $LN3@LoadRackTa
$LN2@LoadRackTa:

; 1602 : 			continue;

	jmp	SHORT $LN5@LoadRackTa
$LN3@LoadRackTa:

; 1603 : 		int ctid, occ;
; 1604 : 		if (sscanf (buffer, "Rack%d %d %d", &rack, &ctid, &occ) != 3)

	lea	eax, DWORD PTR _occ$3[ebp]
	push	eax
	lea	ecx, DWORD PTR _ctid$4[ebp]
	push	ecx
	lea	edx, DWORD PTR _rack$[ebp]
	push	edx
	push	OFFSET ??_C@_0N@DNBHIEDB@Rack?$CFd?5?$CFd?5?$CFd?$AA@
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_sscanf
	add	esp, 20					; 00000014H
	cmp	eax, 3
	je	SHORT $LN1@LoadRackTa

; 1605 : 			continue;

	jmp	SHORT $LN5@LoadRackTa
$LN1@LoadRackTa:

; 1606 : 		ShiAssert(rack < MaxRackObjects);
; 1607 : 		ShiAssert(ctid >=0 && ctid < NumEntities);
; 1608 : 		RackObjectTable[rack].ctind = ctid;

	mov	ecx, DWORD PTR _rack$[ebp]
	mov	edx, DWORD PTR ?RackObjectTable@@3PAURackObject@@A ; RackObjectTable
	mov	eax, DWORD PTR _ctid$4[ebp]
	mov	DWORD PTR [edx+ecx*8], eax

; 1609 : 		RackObjectTable[rack].maxoccupancy = occ;

	mov	ecx, DWORD PTR _rack$[ebp]
	mov	edx, DWORD PTR ?RackObjectTable@@3PAURackObject@@A ; RackObjectTable
	mov	eax, DWORD PTR _occ$3[ebp]
	mov	DWORD PTR [edx+ecx*8+4], eax

; 1610 : 	}

	jmp	$LN5@LoadRackTa
$LN4@LoadRackTa:

; 1611 : 	fclose (fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fclose
	add	esp, 4
$LN40@LoadRackTa:

; 1612 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?LoadRackTables@@YAXXZ ENDP				; LoadRackTables
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\entity.cpp
_TEXT	SEGMENT
_visId$ = 8						; size = 4
?MapVisId@@YAKK@Z PROC					; MapVisId

; 1531 : {

	push	ebp
	mov	ebp, esp

; 1532 : 	if (visId >= 0 && visId < MAXMAPID)

	cmp	DWORD PTR _visId$[ebp], 0
	jb	SHORT $LN1@MapVisId
	cmp	DWORD PTR _visId$[ebp], 1400		; 00000578H
	jae	SHORT $LN1@MapVisId

; 1533 : 		return idmap[visId];

	mov	eax, DWORD PTR _visId$[ebp]
	mov	eax, DWORD PTR _idmap[eax*4]
	jmp	SHORT $LN2@MapVisId
$LN1@MapVisId:

; 1534 : 	return visId;

	mov	eax, DWORD PTR _visId$[ebp]
$LN2@MapVisId:

; 1535 : }

	pop	ebp
	ret	0
?MapVisId@@YAKK@Z ENDP					; MapVisId
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\entity.cpp
_TEXT	SEGMENT
_ptr$ = -8						; size = 4
_type$ = -4						; size = 4
_ID$ = 8						; size = 4
?GetClassNameA@@YAPADH@Z PROC				; GetClassNameA

; 1464 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1465 : 	int
; 1466 : 			type;
; 1467 : 
; 1468 : 	union
; 1469 : 	{
; 1470 : 		void					*ptr;
; 1471 : 		FeatureClassDataType	*fc;
; 1472 : 		ObjClassDataType		*oc;
; 1473 : 		UnitClassDataType		*uc;
; 1474 : 		VehicleClassDataType	*vc;
; 1475 : 		WeaponClassDataType		*wc;
; 1476 : 	}
; 1477 : 	ptr;
; 1478 : 
; 1479 : 	type = Falcon4ClassTable[ID].dataType;

	mov	eax, DWORD PTR _ID$[ebp]
	imul	eax, 81					; 00000051H
	mov	ecx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	movzx	edx, BYTE PTR [ecx+eax+76]
	mov	DWORD PTR _type$[ebp], edx

; 1480 : 
; 1481 : 	ptr.ptr = Falcon4ClassTable[ID].dataPtr;

	mov	eax, DWORD PTR _ID$[ebp]
	imul	eax, 81					; 00000051H
	mov	ecx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	edx, DWORD PTR [ecx+eax+77]
	mov	DWORD PTR _ptr$[ebp], edx

; 1482 : 
; 1483 : 	if (type == DTYPE_FEATURE)

	cmp	DWORD PTR _type$[ebp], 1
	jne	SHORT $LN9@GetClassNa

; 1484 : 	{
; 1485 : 		return ptr.fc->Name;

	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, 8
	jmp	SHORT $LN10@GetClassNa
	jmp	SHORT $LN8@GetClassNa
$LN9@GetClassNa:

; 1486 : 	}
; 1487 : 	else if (type == DTYPE_OBJECTIVE)

	cmp	DWORD PTR _type$[ebp], 3
	jne	SHORT $LN7@GetClassNa

; 1488 : 	{
; 1489 : 		return ptr.oc->Name;

	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, 2
	jmp	SHORT $LN10@GetClassNa
	jmp	SHORT $LN8@GetClassNa
$LN7@GetClassNa:

; 1490 : 	}
; 1491 : 	else if (type == DTYPE_UNIT)

	cmp	DWORD PTR _type$[ebp], 4
	jne	SHORT $LN5@GetClassNa

; 1492 : 	{
; 1493 : 		return ptr.uc->Name;

	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, 230				; 000000e6H
	jmp	SHORT $LN10@GetClassNa
	jmp	SHORT $LN8@GetClassNa
$LN5@GetClassNa:

; 1494 : 	}
; 1495 : 	else if (type == DTYPE_VEHICLE)

	cmp	DWORD PTR _type$[ebp], 5
	jne	SHORT $LN3@GetClassNa

; 1496 : 	{
; 1497 : 		return ptr.vc->Name;

	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, 8
	jmp	SHORT $LN10@GetClassNa
	jmp	SHORT $LN8@GetClassNa
$LN3@GetClassNa:

; 1498 : 	}
; 1499 : 	else if (type == DTYPE_WEAPON)

	cmp	DWORD PTR _type$[ebp], 6
	jne	SHORT $LN8@GetClassNa

; 1500 : 	{
; 1501 : 		return ptr.wc->Name;

	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, 12					; 0000000cH
	jmp	SHORT $LN10@GetClassNa
$LN8@GetClassNa:

; 1502 : 	}
; 1503 : 
; 1504 : 	return NULL;

	xor	eax, eax
$LN10@GetClassNa:

; 1505 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetClassNameA@@YAPADH@Z ENDP				; GetClassNameA
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\entity.cpp
_TEXT	SEGMENT
_id$ = -16						; size = 4
_filter$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
_domain$ = 8						; size = 1
_eclass$ = 12						; size = 1
_type$ = 16						; size = 1
_stype$ = 20						; size = 1
_sp$ = 24						; size = 1
_owner$ = 28						; size = 1
_c6$ = 32						; size = 1
_c7$ = 36						; size = 1
?GetClassID@@YAHEEEEEEEE@Z PROC				; GetClassID

; 1440 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1441 : 	int		id;
; 1442 : 	uchar		filter[CLASS_NUM_BYTES];
; 1443 : 
; 1444 : 	filter[0] = domain;

	mov	eax, 1
	imul	eax, 0
	mov	cl, BYTE PTR _domain$[ebp]
	mov	BYTE PTR _filter$[ebp+eax], cl

; 1445 : 	filter[1] = eclass;

	mov	edx, 1
	shl	edx, 0
	mov	al, BYTE PTR _eclass$[ebp]
	mov	BYTE PTR _filter$[ebp+edx], al

; 1446 : 	filter[2] = type;

	mov	ecx, 1
	shl	ecx, 1
	mov	dl, BYTE PTR _type$[ebp]
	mov	BYTE PTR _filter$[ebp+ecx], dl

; 1447 : 	filter[3] = stype;

	mov	eax, 1
	imul	eax, 3
	mov	cl, BYTE PTR _stype$[ebp]
	mov	BYTE PTR _filter$[ebp+eax], cl

; 1448 : 	filter[4] = sp;

	mov	edx, 1
	shl	edx, 2
	mov	al, BYTE PTR _sp$[ebp]
	mov	BYTE PTR _filter$[ebp+edx], al

; 1449 : 	filter[5] = owner;

	mov	ecx, 1
	imul	ecx, 5
	mov	dl, BYTE PTR _owner$[ebp]
	mov	BYTE PTR _filter$[ebp+ecx], dl

; 1450 : 	filter[6] = c6;

	mov	eax, 1
	imul	eax, 6
	mov	cl, BYTE PTR _c6$[ebp]
	mov	BYTE PTR _filter$[ebp+eax], cl

; 1451 : 	filter[7] = c7;

	mov	edx, 1
	imul	edx, 7
	mov	al, BYTE PTR _c7$[ebp]
	mov	BYTE PTR _filter$[ebp+edx], al

; 1452 : 
; 1453 : 
; 1454 : 	// This should eventually be smart enough to return the 'next best thing'
; 1455 : 	for (id = 0; id<NumEntities; id++)

	mov	DWORD PTR _id$[ebp], 0
	jmp	SHORT $LN4@GetClassID
$LN3@GetClassID:
	mov	ecx, DWORD PTR _id$[ebp]
	add	ecx, 1
	mov	DWORD PTR _id$[ebp], ecx
$LN4@GetClassID:
	mov	edx, DWORD PTR _id$[ebp]
	cmp	edx, DWORD PTR ?NumEntities@@3HA	; NumEntities
	jge	SHORT $LN2@GetClassID

; 1456 : 	{
; 1457 : 		if (CheckClassEntry(id,filter))

	lea	eax, DWORD PTR _filter$[ebp]
	push	eax
	mov	ecx, DWORD PTR _id$[ebp]
	push	ecx
	call	?CheckClassEntry@@YAHHQAE@Z		; CheckClassEntry
	add	esp, 8
	test	eax, eax
	je	SHORT $LN1@GetClassID

; 1458 : 			return id;

	mov	eax, DWORD PTR _id$[ebp]
	jmp	SHORT $LN5@GetClassID
$LN1@GetClassID:

; 1459 : 	}

	jmp	SHORT $LN3@GetClassID
$LN2@GetClassID:

; 1460 : 	return 0;

	xor	eax, eax
$LN5@GetClassID:

; 1461 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?GetClassID@@YAHEEEEEEEE@Z ENDP				; GetClassID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\entity.cpp
_TEXT	SEGMENT
$T1 = -20						; size = 4
_size$ = -16						; size = 4
_fp$ = -12						; size = 4
_entries$2 = -8						; size = 2
_iknt$3 = -4						; size = 2
_filename$ = 8						; size = 4
?LoadSimWeaponData@@YAHPAD@Z PROC			; LoadSimWeaponData

; 1054 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 1055 : 	FILE*		fp;
; 1056 : 
; 1057 : 	if ((fp = OpenCampFile(filename, "SWD", "rb")) == NULL)

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	push	OFFSET ??_C@_03PKOFDCJL@SWD?$AA@
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	?OpenCampFile@@YAPAU_iobuf@@PAD00@Z	; OpenCampFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _fp$[ebp], eax
	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $LN6@LoadSimWea

; 1058 : 		return 0;

	xor	eax, eax
	jmp	$LN7@LoadSimWea
$LN6@LoadSimWea:

; 1059 : 	fseek(fp, 0, SEEK_END); // JPO - work out if the file looks the right size.

	push	2
	push	0
	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fseek
	add	esp, 12					; 0000000cH

; 1060 : 	unsigned int size = ftell(fp);

	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_ftell
	add	esp, 4
	mov	DWORD PTR _size$[ebp], eax

; 1061 : 	// FF - DB Control
; 1062 : 	if (g_bFFDBC)

	movzx	eax, BYTE PTR ?g_bFFDBC@@3_NA		; g_bFFDBC
	test	eax, eax
	je	SHORT $LN5@LoadSimWea

; 1063 : 	{
; 1064 : 		// FF - get real count of entries
; 1065 : 		short	iknt = 0, entries;

	xor	ecx, ecx
	mov	WORD PTR _iknt$3[ebp], cx

; 1066 : 		fseek(fp, 0, SEEK_END);

	push	2
	push	0
	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_fseek
	add	esp, 12					; 0000000cH

; 1067 : 		fseek(fp, -2, SEEK_CUR);

	push	1
	push	-2					; fffffffeH
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH

; 1068 : 		fread(&iknt,sizeof(short),1,fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	push	1
	push	2
	lea	edx, DWORD PTR _iknt$3[ebp]
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 1069 : 		fseek(fp, 0, SEEK_SET);

	push	0
	push	0
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH

; 1070 : 		// Move pointer past the 0 entries
; 1071 : 		fread(&entries,sizeof(short),1,fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	push	1
	push	2
	lea	edx, DWORD PTR _entries$2[ebp]
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 1072 : 		if (NumSimWeaponEntries == 0)

	movsx	eax, WORD PTR ?NumSimWeaponEntries@@3FA	; NumSimWeaponEntries
	test	eax, eax
	jne	SHORT $LN4@LoadSimWea

; 1073 : 			NumSimWeaponEntries = iknt;

	mov	cx, WORD PTR _iknt$3[ebp]
	mov	WORD PTR ?NumSimWeaponEntries@@3FA, cx	; NumSimWeaponEntries
$LN4@LoadSimWea:

; 1074 : 	}
; 1075 : 	else

	jmp	SHORT $LN3@LoadSimWea
$LN5@LoadSimWea:

; 1076 : 	{
; 1077 : 		fseek(fp, 0, SEEK_SET);

	push	0
	push	0
	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_fseek
	add	esp, 12					; 0000000cH

; 1078 : 		if (fread(&NumSimWeaponEntries,sizeof(short),1,fp) < 1)

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	2
	push	OFFSET ?NumSimWeaponEntries@@3FA	; NumSimWeaponEntries
	call	_fread
	add	esp, 16					; 00000010H
	cmp	eax, 1
	jae	SHORT $LN2@LoadSimWea

; 1079 : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN7@LoadSimWea
$LN2@LoadSimWea:

; 1080 : 		if (size != sizeof(SimWeaponDataType) * NumSimWeaponEntries + 2)

	movsx	ecx, WORD PTR ?NumSimWeaponEntries@@3FA	; NumSimWeaponEntries
	imul	ecx, 52					; 00000034H
	add	ecx, 2
	cmp	DWORD PTR _size$[ebp], ecx
	je	SHORT $LN3@LoadSimWea

; 1081 : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN7@LoadSimWea
$LN3@LoadSimWea:

; 1082 : 	}
; 1083 : 	//fseek(fp, 0, SEEK_SET);
; 1084 : 	//if (fread(&NumSimWeaponEntries,sizeof(short),1,fp) < 1)
; 1085 : 	//	return 0;
; 1086 : 	//if (size != sizeof(SimWeaponDataType) * NumSimWeaponEntries + 2)
; 1087 : 	//	return 0;
; 1088 : 	SimWeaponDataTable = new SimWeaponDataType[NumSimWeaponEntries];

	movsx	eax, WORD PTR ?NumSimWeaponEntries@@3FA	; NumSimWeaponEntries
	xor	ecx, ecx
	mov	edx, 52					; 00000034H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR ?SimWeaponDataTable@@3PAUSimWeaponDataType@@A, eax ; SimWeaponDataTable

; 1089 : 	ShiAssert( SimWeaponDataTable );
; 1090 : 	fread(SimWeaponDataTable,sizeof(SimWeaponDataType),NumSimWeaponEntries,fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	movsx	edx, WORD PTR ?NumSimWeaponEntries@@3FA	; NumSimWeaponEntries
	push	edx
	push	52					; 00000034H
	mov	eax, DWORD PTR ?SimWeaponDataTable@@3PAUSimWeaponDataType@@A ; SimWeaponDataTable
	push	eax
	call	_fread
	add	esp, 16					; 00000010H

; 1091 : 	fclose(fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fclose
	add	esp, 4

; 1092 : 	return 1;

	mov	eax, 1
$LN7@LoadSimWea:

; 1093 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?LoadSimWeaponData@@YAHPAD@Z ENDP			; LoadSimWeaponData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\entity.cpp
_TEXT	SEGMENT
$T1 = -20						; size = 4
_size$ = -16						; size = 4
_fp$ = -12						; size = 4
_entries$2 = -8						; size = 2
_iknt$3 = -4						; size = 2
_filename$ = 8						; size = 4
?LoadVisualData@@YAHPAD@Z PROC				; LoadVisualData

; 1012 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 1013 : 	FILE*		fp;
; 1014 : 
; 1015 : 	if ((fp = OpenCampFile(filename, "vsd", "rb")) == NULL)

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	push	OFFSET ??_C@_03MHMJKHAJ@vsd?$AA@
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	?OpenCampFile@@YAPAU_iobuf@@PAD00@Z	; OpenCampFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _fp$[ebp], eax
	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $LN6@LoadVisual

; 1016 : 		return 0;

	xor	eax, eax
	jmp	$LN7@LoadVisual
$LN6@LoadVisual:

; 1017 : 	fseek(fp, 0, SEEK_END); // JPO - work out if the file looks the right size.

	push	2
	push	0
	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fseek
	add	esp, 12					; 0000000cH

; 1018 : 	unsigned int size = ftell(fp);

	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_ftell
	add	esp, 4
	mov	DWORD PTR _size$[ebp], eax

; 1019 : 	// FF - DB Control
; 1020 : 	if (g_bFFDBC)

	movzx	eax, BYTE PTR ?g_bFFDBC@@3_NA		; g_bFFDBC
	test	eax, eax
	je	SHORT $LN5@LoadVisual

; 1021 : 	{
; 1022 : 		// FF - get real count of entries
; 1023 : 		short	iknt = 0, entries;

	xor	ecx, ecx
	mov	WORD PTR _iknt$3[ebp], cx

; 1024 : 		fseek(fp, 0, SEEK_END);

	push	2
	push	0
	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_fseek
	add	esp, 12					; 0000000cH

; 1025 : 		fseek(fp, -2, SEEK_CUR);

	push	1
	push	-2					; fffffffeH
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH

; 1026 : 		fread(&iknt,sizeof(short),1,fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	push	1
	push	2
	lea	edx, DWORD PTR _iknt$3[ebp]
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 1027 : 		fseek(fp, 0, SEEK_SET);

	push	0
	push	0
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH

; 1028 : 		// Move pointer past the 0 entries
; 1029 : 		fread(&entries,sizeof(short),1,fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	push	1
	push	2
	lea	edx, DWORD PTR _entries$2[ebp]
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 1030 : 		if (NumVisualEntries == 0)

	movsx	eax, WORD PTR ?NumVisualEntries@@3FA	; NumVisualEntries
	test	eax, eax
	jne	SHORT $LN4@LoadVisual

; 1031 : 			NumVisualEntries = iknt;

	mov	cx, WORD PTR _iknt$3[ebp]
	mov	WORD PTR ?NumVisualEntries@@3FA, cx	; NumVisualEntries
$LN4@LoadVisual:

; 1032 : 	}
; 1033 : 	else

	jmp	SHORT $LN3@LoadVisual
$LN5@LoadVisual:

; 1034 : 	{
; 1035 : 		fseek(fp, 0, SEEK_SET);

	push	0
	push	0
	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_fseek
	add	esp, 12					; 0000000cH

; 1036 : 		if (fread(&NumVisualEntries,sizeof(short),1,fp) < 1)

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	2
	push	OFFSET ?NumVisualEntries@@3FA		; NumVisualEntries
	call	_fread
	add	esp, 16					; 00000010H
	cmp	eax, 1
	jae	SHORT $LN2@LoadVisual

; 1037 : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN7@LoadVisual
$LN2@LoadVisual:

; 1038 : 		if (size != sizeof(VisualDataType) * NumVisualEntries + 2)

	movsx	ecx, WORD PTR ?NumVisualEntries@@3FA	; NumVisualEntries
	imul	ecx, 20					; 00000014H
	add	ecx, 2
	cmp	DWORD PTR _size$[ebp], ecx
	je	SHORT $LN3@LoadVisual

; 1039 : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN7@LoadVisual
$LN3@LoadVisual:

; 1040 : 	}
; 1041 : 	//fseek(fp, 0, SEEK_SET);
; 1042 : 	//if (fread(&NumVisualEntries,sizeof(short),1,fp) < 1)
; 1043 : 	//	return 0;
; 1044 : 	//if (size != sizeof(VisualDataType) * NumVisualEntries + 2)
; 1045 : 	//	return 0;
; 1046 : 	VisualDataTable = new VisualDataType[NumVisualEntries];

	movsx	eax, WORD PTR ?NumVisualEntries@@3FA	; NumVisualEntries
	xor	ecx, ecx
	mov	edx, 20					; 00000014H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR ?VisualDataTable@@3PAUVisualDataType@@A, eax ; VisualDataTable

; 1047 : 	ShiAssert( VisualDataTable );
; 1048 : 	fread(VisualDataTable,sizeof(VisualDataType),NumVisualEntries,fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	movsx	edx, WORD PTR ?NumVisualEntries@@3FA	; NumVisualEntries
	push	edx
	push	20					; 00000014H
	mov	eax, DWORD PTR ?VisualDataTable@@3PAUVisualDataType@@A ; VisualDataTable
	push	eax
	call	_fread
	add	esp, 16					; 00000010H

; 1049 : 	fclose(fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fclose
	add	esp, 4

; 1050 : 	return 1;

	mov	eax, 1
$LN7@LoadVisual:

; 1051 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?LoadVisualData@@YAHPAD@Z ENDP				; LoadVisualData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\entity.cpp
_TEXT	SEGMENT
$T1 = -20						; size = 4
_size$ = -16						; size = 4
_fp$ = -12						; size = 4
_entries$2 = -8						; size = 2
_iknt$3 = -4						; size = 2
_filename$ = 8						; size = 4
?LoadRwrData@@YAHPAD@Z PROC				; LoadRwrData

; 970  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 971  : 	FILE*		fp;
; 972  : 
; 973  : 	if ((fp = OpenCampFile(filename, "rwd", "rb")) == NULL)

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	push	OFFSET ??_C@_03EPKCJIIC@rwd?$AA@
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	?OpenCampFile@@YAPAU_iobuf@@PAD00@Z	; OpenCampFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _fp$[ebp], eax
	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $LN6@LoadRwrDat

; 974  : 		return 0;

	xor	eax, eax
	jmp	$LN7@LoadRwrDat
$LN6@LoadRwrDat:

; 975  : 	fseek(fp, 0, SEEK_END); // JPO - work out if the file looks the right size.

	push	2
	push	0
	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fseek
	add	esp, 12					; 0000000cH

; 976  : 	unsigned int size = ftell(fp);

	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_ftell
	add	esp, 4
	mov	DWORD PTR _size$[ebp], eax

; 977  : 	// FF - DB Control
; 978  : 	if (g_bFFDBC)

	movzx	eax, BYTE PTR ?g_bFFDBC@@3_NA		; g_bFFDBC
	test	eax, eax
	je	SHORT $LN5@LoadRwrDat

; 979  : 	{
; 980  : 		// FF - get real count of entries
; 981  : 		short	iknt = 0, entries;

	xor	ecx, ecx
	mov	WORD PTR _iknt$3[ebp], cx

; 982  : 		fseek(fp, 0, SEEK_END);

	push	2
	push	0
	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_fseek
	add	esp, 12					; 0000000cH

; 983  : 		fseek(fp, -2, SEEK_CUR);

	push	1
	push	-2					; fffffffeH
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH

; 984  : 		fread(&iknt,sizeof(short),1,fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	push	1
	push	2
	lea	edx, DWORD PTR _iknt$3[ebp]
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 985  : 		fseek(fp, 0, SEEK_SET);

	push	0
	push	0
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH

; 986  : 		// Move pointer past the 0 entries
; 987  : 		fread(&entries,sizeof(short),1,fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	push	1
	push	2
	lea	edx, DWORD PTR _entries$2[ebp]
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 988  : 		if (NumRwrEntries == 0)

	movsx	eax, WORD PTR ?NumRwrEntries@@3FA	; NumRwrEntries
	test	eax, eax
	jne	SHORT $LN4@LoadRwrDat

; 989  : 			NumRwrEntries = iknt;

	mov	cx, WORD PTR _iknt$3[ebp]
	mov	WORD PTR ?NumRwrEntries@@3FA, cx	; NumRwrEntries
$LN4@LoadRwrDat:

; 990  : 	}
; 991  : 	else

	jmp	SHORT $LN3@LoadRwrDat
$LN5@LoadRwrDat:

; 992  : 	{
; 993  : 		fseek(fp, 0, SEEK_SET);

	push	0
	push	0
	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_fseek
	add	esp, 12					; 0000000cH

; 994  : 		if (fread(&NumRwrEntries,sizeof(short),1,fp) < 1)

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	2
	push	OFFSET ?NumRwrEntries@@3FA		; NumRwrEntries
	call	_fread
	add	esp, 16					; 00000010H
	cmp	eax, 1
	jae	SHORT $LN2@LoadRwrDat

; 995  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN7@LoadRwrDat
$LN2@LoadRwrDat:

; 996  : 		if (size != sizeof(RwrDataType) * NumRwrEntries + 2)

	movsx	ecx, WORD PTR ?NumRwrEntries@@3FA	; NumRwrEntries
	imul	ecx, 22					; 00000016H
	add	ecx, 2
	cmp	DWORD PTR _size$[ebp], ecx
	je	SHORT $LN3@LoadRwrDat

; 997  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN7@LoadRwrDat
$LN3@LoadRwrDat:

; 998  : 	}
; 999  : 	//fseek(fp, 0, SEEK_SET);
; 1000 : 	//if (fread(&NumRwrEntries,sizeof(short),1,fp) < 1)
; 1001 : 	//	return 0;
; 1002 : 	//if (size != sizeof(RwrDataType) * NumRwrEntries + 2)
; 1003 : 	//	return 0;
; 1004 : 	RwrDataTable = new RwrDataType[NumRwrEntries];

	movsx	eax, WORD PTR ?NumRwrEntries@@3FA	; NumRwrEntries
	xor	ecx, ecx
	mov	edx, 22					; 00000016H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR ?RwrDataTable@@3PAURwrDataType@@A, eax ; RwrDataTable

; 1005 : 	ShiAssert( RwrDataTable );
; 1006 : 	fread(RwrDataTable,sizeof(RwrDataType),NumRwrEntries,fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	movsx	edx, WORD PTR ?NumRwrEntries@@3FA	; NumRwrEntries
	push	edx
	push	22					; 00000016H
	mov	eax, DWORD PTR ?RwrDataTable@@3PAURwrDataType@@A ; RwrDataTable
	push	eax
	call	_fread
	add	esp, 16					; 00000010H

; 1007 : 	fclose(fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fclose
	add	esp, 4

; 1008 : 	return 1;

	mov	eax, 1
$LN7@LoadRwrDat:

; 1009 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?LoadRwrData@@YAHPAD@Z ENDP				; LoadRwrData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\entity.cpp
_TEXT	SEGMENT
$T1 = -20						; size = 4
_size$ = -16						; size = 4
_fp$ = -12						; size = 4
_entries$2 = -8						; size = 2
_iknt$3 = -4						; size = 2
_filename$ = 8						; size = 4
?LoadIRSTData@@YAHPAD@Z PROC				; LoadIRSTData

; 928  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 929  : 	FILE*		fp;
; 930  : 
; 931  : 	if ((fp = OpenCampFile(filename, "ICD", "rb")) == NULL)

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	push	OFFSET ??_C@_03NOGOIOMM@ICD?$AA@
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	?OpenCampFile@@YAPAU_iobuf@@PAD00@Z	; OpenCampFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _fp$[ebp], eax
	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $LN6@LoadIRSTDa

; 932  : 		return 0;

	xor	eax, eax
	jmp	$LN7@LoadIRSTDa
$LN6@LoadIRSTDa:

; 933  : 	fseek(fp, 0, SEEK_END); // JPO - work out if the file looks the right size.

	push	2
	push	0
	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fseek
	add	esp, 12					; 0000000cH

; 934  : 	unsigned int size = ftell(fp);

	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_ftell
	add	esp, 4
	mov	DWORD PTR _size$[ebp], eax

; 935  : 	// FF - DB Control
; 936  : 	if (g_bFFDBC)

	movzx	eax, BYTE PTR ?g_bFFDBC@@3_NA		; g_bFFDBC
	test	eax, eax
	je	SHORT $LN5@LoadIRSTDa

; 937  : 	{
; 938  : 		// FF - get real count of entries
; 939  : 		short	iknt = 0, entries;

	xor	ecx, ecx
	mov	WORD PTR _iknt$3[ebp], cx

; 940  : 		fseek(fp, 0, SEEK_END);

	push	2
	push	0
	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_fseek
	add	esp, 12					; 0000000cH

; 941  : 		fseek(fp, -2, SEEK_CUR);

	push	1
	push	-2					; fffffffeH
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH

; 942  : 		fread(&iknt,sizeof(short),1,fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	push	1
	push	2
	lea	edx, DWORD PTR _iknt$3[ebp]
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 943  : 		fseek(fp, 0, SEEK_SET);

	push	0
	push	0
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH

; 944  : 		// Move pointer past the 0 entries
; 945  : 		fread(&entries,sizeof(short),1,fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	push	1
	push	2
	lea	edx, DWORD PTR _entries$2[ebp]
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 946  : 		if (NumIRSTEntries == 0)

	movsx	eax, WORD PTR ?NumIRSTEntries@@3FA	; NumIRSTEntries
	test	eax, eax
	jne	SHORT $LN4@LoadIRSTDa

; 947  : 			NumIRSTEntries = iknt;

	mov	cx, WORD PTR _iknt$3[ebp]
	mov	WORD PTR ?NumIRSTEntries@@3FA, cx	; NumIRSTEntries
$LN4@LoadIRSTDa:

; 948  : 	}
; 949  : 	else

	jmp	SHORT $LN3@LoadIRSTDa
$LN5@LoadIRSTDa:

; 950  : 	{
; 951  : 		fseek(fp, 0, SEEK_SET);

	push	0
	push	0
	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_fseek
	add	esp, 12					; 0000000cH

; 952  : 		if (fread(&NumIRSTEntries,sizeof(short),1,fp) < 1)

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	2
	push	OFFSET ?NumIRSTEntries@@3FA		; NumIRSTEntries
	call	_fread
	add	esp, 16					; 00000010H
	cmp	eax, 1
	jae	SHORT $LN2@LoadIRSTDa

; 953  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN7@LoadIRSTDa
$LN2@LoadIRSTDa:

; 954  : 		if (size != sizeof(IRSTDataType) * NumIRSTEntries + 2)

	movsx	ecx, WORD PTR ?NumIRSTEntries@@3FA	; NumIRSTEntries
	imul	ecx, 20					; 00000014H
	add	ecx, 2
	cmp	DWORD PTR _size$[ebp], ecx
	je	SHORT $LN3@LoadIRSTDa

; 955  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN7@LoadIRSTDa
$LN3@LoadIRSTDa:

; 956  : 	}
; 957  : 	//fseek(fp, 0, SEEK_SET);
; 958  : 	//if (fread(&NumIRSTEntries,sizeof(short),1,fp) < 1)
; 959  : 	//	return 0;
; 960  : 	//if (size != sizeof(IRSTDataType) * NumIRSTEntries + 2)
; 961  : 	//	return 0;
; 962  : 	IRSTDataTable = new IRSTDataType[NumIRSTEntries];

	movsx	eax, WORD PTR ?NumIRSTEntries@@3FA	; NumIRSTEntries
	xor	ecx, ecx
	mov	edx, 20					; 00000014H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR ?IRSTDataTable@@3PAUIRSTDataType@@A, eax ; IRSTDataTable

; 963  : 	ShiAssert( IRSTDataTable );
; 964  : 	fread(IRSTDataTable,sizeof(IRSTDataType),NumIRSTEntries,fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	movsx	edx, WORD PTR ?NumIRSTEntries@@3FA	; NumIRSTEntries
	push	edx
	push	20					; 00000014H
	mov	eax, DWORD PTR ?IRSTDataTable@@3PAUIRSTDataType@@A ; IRSTDataTable
	push	eax
	call	_fread
	add	esp, 16					; 00000010H

; 965  : 	fclose(fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fclose
	add	esp, 4

; 966  : 	return 1;

	mov	eax, 1
$LN7@LoadIRSTDa:

; 967  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?LoadIRSTData@@YAHPAD@Z ENDP				; LoadIRSTData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\entity.cpp
_TEXT	SEGMENT
$T1 = -20						; size = 4
_size$ = -16						; size = 4
_fp$ = -12						; size = 4
_entries$2 = -8						; size = 2
_iknt$3 = -4						; size = 2
_filename$ = 8						; size = 4
?LoadRadarData@@YAHPAD@Z PROC				; LoadRadarData

; 886  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 887  : 	FILE*		fp;
; 888  : 
; 889  : 	if ((fp = OpenCampFile(filename, "RCD", "rb")) == NULL)

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	push	OFFSET ??_C@_03FJHGFOFC@RCD?$AA@
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	?OpenCampFile@@YAPAU_iobuf@@PAD00@Z	; OpenCampFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _fp$[ebp], eax
	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $LN6@LoadRadarD

; 890  : 		return 0;

	xor	eax, eax
	jmp	$LN7@LoadRadarD
$LN6@LoadRadarD:

; 891  : 	fseek(fp, 0, SEEK_END); // JPO - work out if the file looks the right size.

	push	2
	push	0
	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fseek
	add	esp, 12					; 0000000cH

; 892  : 	unsigned int size = ftell(fp);

	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_ftell
	add	esp, 4
	mov	DWORD PTR _size$[ebp], eax

; 893  : 	// FF - DB Control
; 894  : 	if (g_bFFDBC)

	movzx	eax, BYTE PTR ?g_bFFDBC@@3_NA		; g_bFFDBC
	test	eax, eax
	je	SHORT $LN5@LoadRadarD

; 895  : 	{
; 896  : 		// FF - get real count of entries
; 897  : 		short	iknt = 0, entries;

	xor	ecx, ecx
	mov	WORD PTR _iknt$3[ebp], cx

; 898  : 		fseek(fp, 0, SEEK_END);

	push	2
	push	0
	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_fseek
	add	esp, 12					; 0000000cH

; 899  : 		fseek(fp, -2, SEEK_CUR);

	push	1
	push	-2					; fffffffeH
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH

; 900  : 		fread(&iknt,sizeof(short),1,fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	push	1
	push	2
	lea	edx, DWORD PTR _iknt$3[ebp]
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 901  : 		fseek(fp, 0, SEEK_SET);

	push	0
	push	0
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH

; 902  : 		// Move pointer past the 0 entries
; 903  : 		fread(&entries,sizeof(short),1,fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	push	1
	push	2
	lea	edx, DWORD PTR _entries$2[ebp]
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 904  : 		if (NumRadarEntries == 0)

	movsx	eax, WORD PTR ?NumRadarEntries@@3FA	; NumRadarEntries
	test	eax, eax
	jne	SHORT $LN4@LoadRadarD

; 905  : 			NumRadarEntries = iknt;

	mov	cx, WORD PTR _iknt$3[ebp]
	mov	WORD PTR ?NumRadarEntries@@3FA, cx	; NumRadarEntries
$LN4@LoadRadarD:

; 906  : 	}
; 907  : 	else

	jmp	SHORT $LN3@LoadRadarD
$LN5@LoadRadarD:

; 908  : 	{
; 909  : 		fseek(fp, 0, SEEK_SET);

	push	0
	push	0
	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_fseek
	add	esp, 12					; 0000000cH

; 910  : 		if (fread(&NumRadarEntries,sizeof(short),1,fp) < 1)

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	2
	push	OFFSET ?NumRadarEntries@@3FA		; NumRadarEntries
	call	_fread
	add	esp, 16					; 00000010H
	cmp	eax, 1
	jae	SHORT $LN2@LoadRadarD

; 911  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN7@LoadRadarD
$LN2@LoadRadarD:

; 912  : 		if (size != sizeof(RadarDataType) * NumRadarEntries + 2)

	movsx	ecx, WORD PTR ?NumRadarEntries@@3FA	; NumRadarEntries
	imul	ecx, 58					; 0000003aH
	add	ecx, 2
	cmp	DWORD PTR _size$[ebp], ecx
	je	SHORT $LN3@LoadRadarD

; 913  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN7@LoadRadarD
$LN3@LoadRadarD:

; 914  : 	}
; 915  : 	//fseek(fp, 0, SEEK_SET);
; 916  : 	//if (fread(&NumRadarEntries,sizeof(short),1,fp) < 1)
; 917  : 	//	return 0;
; 918  : 	//if (size != sizeof(RadarDataType) * NumRadarEntries + 2)
; 919  : 	//	return 0;
; 920  : 	RadarDataTable = new RadarDataType[NumRadarEntries];

	movsx	eax, WORD PTR ?NumRadarEntries@@3FA	; NumRadarEntries
	xor	ecx, ecx
	mov	edx, 58					; 0000003aH
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR ?RadarDataTable@@3PAURadarDataType@@A, eax ; RadarDataTable

; 921  : 	ShiAssert( RadarDataTable );
; 922  : 	fread(RadarDataTable,sizeof(RadarDataType),NumRadarEntries,fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	movsx	edx, WORD PTR ?NumRadarEntries@@3FA	; NumRadarEntries
	push	edx
	push	58					; 0000003aH
	mov	eax, DWORD PTR ?RadarDataTable@@3PAURadarDataType@@A ; RadarDataTable
	push	eax
	call	_fread
	add	esp, 16					; 00000010H

; 923  : 	fclose(fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fclose
	add	esp, 4

; 924  : 	return 1;

	mov	eax, 1
$LN7@LoadRadarD:

; 925  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?LoadRadarData@@YAHPAD@Z ENDP				; LoadRadarData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\entity.cpp
_TEXT	SEGMENT
$T1 = -84						; size = 4
_size$ = -80						; size = 4
_iknt$2 = -76						; size = 2
_fp$ = -72						; size = 4
_fname$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
?LoadFeatureEntryData@@YAHPAD@Z PROC			; LoadFeatureEntryData

; 832  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 833  : 	FILE*		fp;
; 834  : 	char	fname[64];
; 835  : 
; 836  : 	fedtree = false;

	mov	BYTE PTR ?fedtree@@3_NA, 0		; fedtree

; 837  : 	strcpy (fname, filename);	// M.N. switch between objectives with and without trees

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	lea	ecx, DWORD PTR _fname$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 838  : 	if (g_bDisplayTrees)

	movzx	edx, BYTE PTR ?g_bDisplayTrees@@3_NA	; g_bDisplayTrees
	test	edx, edx
	je	SHORT $LN8@LoadFeatur

; 839  : 	{
; 840  : 		strcat(fname,"tree");

	push	OFFSET ??_C@_04KCCPLAND@tree?$AA@
	lea	eax, DWORD PTR _fname$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 841  : 		fedtree=true;

	mov	BYTE PTR ?fedtree@@3_NA, 1		; fedtree
$LN8@LoadFeatur:

; 842  : 	}
; 843  : 
; 844  : 	if ((fp = OpenCampFile(fname, "FED", "rb")) == NULL)

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	push	OFFSET ??_C@_03ICIAOCCI@FED?$AA@
	lea	ecx, DWORD PTR _fname$[ebp]
	push	ecx
	call	?OpenCampFile@@YAPAU_iobuf@@PAD00@Z	; OpenCampFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _fp$[ebp], eax
	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $LN7@LoadFeatur

; 845  : 	{
; 846  : 		fedtree = false;

	mov	BYTE PTR ?fedtree@@3_NA, 0		; fedtree

; 847  : 		if ((fp = OpenCampFile(filename, "FED", "rb")) == NULL)	// if we have no "tree" version, just load the standard one

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	push	OFFSET ??_C@_03ICIAOCCI@FED?$AA@
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	?OpenCampFile@@YAPAU_iobuf@@PAD00@Z	; OpenCampFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _fp$[ebp], eax
	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $LN7@LoadFeatur

; 848  : 			return 0;

	xor	eax, eax
	jmp	$LN9@LoadFeatur
$LN7@LoadFeatur:

; 849  : 	}
; 850  : 	fseek(fp, 0, SEEK_END); // JPO - work out if the file looks the right size.

	push	2
	push	0
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH

; 851  : 	unsigned int size = ftell(fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_ftell
	add	esp, 4
	mov	DWORD PTR _size$[ebp], eax

; 852  : 	// FF - DB Control
; 853  : 	if (g_bFFDBC)

	movzx	edx, BYTE PTR ?g_bFFDBC@@3_NA		; g_bFFDBC
	test	edx, edx
	je	SHORT $LN5@LoadFeatur

; 854  : 	{
; 855  : 		// FF - get real count of entries
; 856  : 		short	iknt = 0;

	xor	eax, eax
	mov	WORD PTR _iknt$2[ebp], ax

; 857  : 		fseek(fp, 0, SEEK_END);

	push	2
	push	0
	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fseek
	add	esp, 12					; 0000000cH

; 858  : 		fseek(fp, -2, SEEK_CUR);

	push	1
	push	-2					; fffffffeH
	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_fseek
	add	esp, 12					; 0000000cH

; 859  : 		fread(&iknt,sizeof(short),1,fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	2
	lea	ecx, DWORD PTR _iknt$2[ebp]
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H

; 860  : 		fseek(fp, 0, SEEK_SET);

	push	0
	push	0
	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_fseek
	add	esp, 12					; 0000000cH

; 861  : 		// Move pointer past the 0 entries
; 862  : 		fread(&NumObjFeatEntries,sizeof(short),1,fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	2
	push	OFFSET ?NumObjFeatEntries@@3FA		; NumObjFeatEntries
	call	_fread
	add	esp, 16					; 00000010H

; 863  : 		if (NumObjFeatEntries == 0)

	movsx	ecx, WORD PTR ?NumObjFeatEntries@@3FA	; NumObjFeatEntries
	test	ecx, ecx
	jne	SHORT $LN4@LoadFeatur

; 864  : 			NumObjFeatEntries = iknt;

	mov	dx, WORD PTR _iknt$2[ebp]
	mov	WORD PTR ?NumObjFeatEntries@@3FA, dx	; NumObjFeatEntries
$LN4@LoadFeatur:

; 865  : 	}
; 866  : 	else

	jmp	SHORT $LN3@LoadFeatur
$LN5@LoadFeatur:

; 867  : 	{
; 868  : 		fseek(fp, 0, SEEK_SET);

	push	0
	push	0
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH

; 869  : 		if (fread(&NumObjFeatEntries,sizeof(short),1,fp) < 1)

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	push	1
	push	2
	push	OFFSET ?NumObjFeatEntries@@3FA		; NumObjFeatEntries
	call	_fread
	add	esp, 16					; 00000010H
	cmp	eax, 1
	jae	SHORT $LN2@LoadFeatur

; 870  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN9@LoadFeatur
$LN2@LoadFeatur:

; 871  : 		if (size != sizeof(FeatureEntry) * NumObjFeatEntries + 2)

	movsx	edx, WORD PTR ?NumObjFeatEntries@@3FA	; NumObjFeatEntries
	shl	edx, 5
	add	edx, 2
	cmp	DWORD PTR _size$[ebp], edx
	je	SHORT $LN3@LoadFeatur

; 872  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN9@LoadFeatur
$LN3@LoadFeatur:

; 873  : 	}
; 874  : 	//fseek(fp, 0, SEEK_SET);
; 875  : 	//if (fread(&NumObjFeatEntries,sizeof(short),1,fp) < 1)
; 876  : 	//	return 0;
; 877  : 	//if (size != sizeof(FeatureEntry) * NumObjFeatEntries + 2)
; 878  : 	//	return 0;
; 879  : 	FeatureEntryDataTable = new FeatureEntry[NumObjFeatEntries];

	movsx	eax, WORD PTR ?NumObjFeatEntries@@3FA	; NumObjFeatEntries
	xor	ecx, ecx
	mov	edx, 32					; 00000020H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR ?FeatureEntryDataTable@@3PAUFeatureEntry@@A, eax ; FeatureEntryDataTable

; 880  : 	fread(FeatureEntryDataTable,sizeof(FeatureEntry),NumObjFeatEntries,fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	movsx	edx, WORD PTR ?NumObjFeatEntries@@3FA	; NumObjFeatEntries
	push	edx
	push	32					; 00000020H
	mov	eax, DWORD PTR ?FeatureEntryDataTable@@3PAUFeatureEntry@@A ; FeatureEntryDataTable
	push	eax
	call	_fread
	add	esp, 16					; 00000010H

; 881  : 	fclose(fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fclose
	add	esp, 4

; 882  : 	return 1;

	mov	eax, 1
$LN9@LoadFeatur:

; 883  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?LoadFeatureEntryData@@YAHPAD@Z ENDP			; LoadFeatureEntryData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\entity.cpp
_TEXT	SEGMENT
$T1 = -12						; size = 4
_size$ = -8						; size = 4
_fp$ = -4						; size = 4
_filename$ = 8						; size = 4
?LoadPtData@@YAHPAD@Z PROC				; LoadPtData

; 810  : int LoadPtData(char *filename){

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 811  : 	FILE*		fp;
; 812  : 
; 813  : 	if ((fp = OpenCampFile(filename, "PD", "rb")) == NULL){

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	push	OFFSET ??_C@_02PIBHICFM@PD?$AA@
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	?OpenCampFile@@YAPAU_iobuf@@PAD00@Z	; OpenCampFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _fp$[ebp], eax
	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $LN3@LoadPtData

; 814  : 		return 0;

	xor	eax, eax
	jmp	$LN4@LoadPtData
$LN3@LoadPtData:

; 815  : 	}
; 816  : 	fseek(fp, 0, SEEK_END); // JPO - work out if the file looks the right size.

	push	2
	push	0
	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fseek
	add	esp, 12					; 0000000cH

; 817  : 	unsigned int size = ftell(fp);

	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_ftell
	add	esp, 4
	mov	DWORD PTR _size$[ebp], eax

; 818  : 	fseek(fp, 0, SEEK_SET);

	push	0
	push	0
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH

; 819  : 	if (fread(&NumPts, sizeof(short), 1, fp) < 1){

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	push	1
	push	2
	push	OFFSET ?NumPts@@3FA			; NumPts
	call	_fread
	add	esp, 16					; 00000010H
	cmp	eax, 1
	jae	SHORT $LN2@LoadPtData

; 820  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN4@LoadPtData
$LN2@LoadPtData:

; 821  : 	}
; 822  : 	if (size != sizeof(PtDataType) * NumPts + 2){

	movsx	edx, WORD PTR ?NumPts@@3FA		; NumPts
	imul	edx, 12					; 0000000cH
	add	edx, 2
	cmp	DWORD PTR _size$[ebp], edx
	je	SHORT $LN1@LoadPtData

; 823  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN4@LoadPtData
$LN1@LoadPtData:

; 824  : 	}
; 825  : 	PtDataTable = new PtDataType[NumPts];

	movsx	eax, WORD PTR ?NumPts@@3FA		; NumPts
	xor	ecx, ecx
	mov	edx, 12					; 0000000cH
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR ?PtDataTable@@3PAUPtDataType@@A, eax ; PtDataTable

; 826  : 	fread(PtDataTable, sizeof(PtDataType), NumPts, fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	movsx	edx, WORD PTR ?NumPts@@3FA		; NumPts
	push	edx
	push	12					; 0000000cH
	mov	eax, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	push	eax
	call	_fread
	add	esp, 16					; 00000010H

; 827  : 	fclose(fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fclose
	add	esp, 4

; 828  : 	return 1;

	mov	eax, 1
$LN4@LoadPtData:

; 829  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?LoadPtData@@YAHPAD@Z ENDP				; LoadPtData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\entity.cpp
_TEXT	SEGMENT
$T1 = -28						; size = 4
_size$ = -24						; size = 4
_featureCount$2 = -20					; size = 4
_fp$ = -16						; size = 4
_l$ = -12						; size = 4
_t$3 = -8						; size = 4
_l$4 = -4						; size = 4
_filename$ = 8						; size = 4
?LoadPtHeaderData@@YAHPAD@Z PROC			; LoadPtHeaderData

; 746  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 747  : 	FILE*		fp;
; 748  : 
; 749  : 	if ((fp = OpenCampFile(filename, "PHD", "rb")) == NULL){

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	push	OFFSET ??_C@_03PPCKHJDI@PHD?$AA@
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	?OpenCampFile@@YAPAU_iobuf@@PAD00@Z	; OpenCampFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _fp$[ebp], eax
	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $LN21@LoadPtHead

; 750  : 		return 0;

	xor	eax, eax
	jmp	$LN22@LoadPtHead
$LN21@LoadPtHead:

; 751  : 	}
; 752  : 	fseek(fp, 0, SEEK_END); // JPO - work out if the file looks the right size.

	push	2
	push	0
	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fseek
	add	esp, 12					; 0000000cH

; 753  : 	unsigned int size = ftell(fp);

	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_ftell
	add	esp, 4
	mov	DWORD PTR _size$[ebp], eax

; 754  : 	fseek(fp, 0, SEEK_SET);

	push	0
	push	0
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH

; 755  : 	if (fread(&NumPtHeaders,sizeof(short),1,fp) < 1){

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	push	1
	push	2
	push	OFFSET ?NumPtHeaders@@3FA		; NumPtHeaders
	call	_fread
	add	esp, 16					; 00000010H
	cmp	eax, 1
	jae	SHORT $LN20@LoadPtHead

; 756  : 		return 0;

	xor	eax, eax
	jmp	$LN22@LoadPtHead
$LN20@LoadPtHead:

; 757  : 	}
; 758  : 	if (size != sizeof(PtHeaderDataType) * NumPtHeaders + 2){

	movsx	edx, WORD PTR ?NumPtHeaders@@3FA	; NumPtHeaders
	imul	edx, 28					; 0000001cH
	add	edx, 2
	cmp	DWORD PTR _size$[ebp], edx
	je	SHORT $LN19@LoadPtHead

; 759  : 		return 0;

	xor	eax, eax
	jmp	$LN22@LoadPtHead
$LN19@LoadPtHead:

; 760  : 	}
; 761  : 	PtHeaderDataTable = new PtHeaderDataType[NumPtHeaders];

	movsx	eax, WORD PTR ?NumPtHeaders@@3FA	; NumPtHeaders
	xor	ecx, ecx
	mov	edx, 28					; 0000001cH
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A, eax ; PtHeaderDataTable

; 762  : 	fread(PtHeaderDataTable, sizeof(PtHeaderDataType), NumPtHeaders, fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	movsx	edx, WORD PTR ?NumPtHeaders@@3FA	; NumPtHeaders
	push	edx
	push	28					; 0000001cH
	mov	eax, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	push	eax
	call	_fread
	add	esp, 16					; 00000010H

; 763  : 	fclose(fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fclose
	add	esp, 4

; 764  : 	PtHeaderDataTable[0].cosHeading = 1.0F;

	mov	edx, 28					; 0000001cH
	imul	edx, 0
	mov	eax, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+edx+16], xmm0

; 765  : 
; 766  : 	if (g_bCheckFeatureIndex)

	movzx	ecx, BYTE PTR ?g_bCheckFeatureIndex@@3_NA ; g_bCheckFeatureIndex
	test	ecx, ecx
	je	$LN15@LoadPtHead

; 767  : 	{
; 768  : 		int l,t; // MLR 5/15/2004 - Sanity check
; 769  : 		for (l=0;l<NumPtHeaders;l++)

	mov	DWORD PTR _l$4[ebp], 0
	jmp	SHORT $LN17@LoadPtHead
$LN16@LoadPtHead:
	mov	edx, DWORD PTR _l$4[ebp]
	add	edx, 1
	mov	DWORD PTR _l$4[ebp], edx
$LN17@LoadPtHead:
	movsx	eax, WORD PTR ?NumPtHeaders@@3FA	; NumPtHeaders
	cmp	DWORD PTR _l$4[ebp], eax
	jge	$LN15@LoadPtHead

; 770  : 		{
; 771  : 			if (PtHeaderDataTable[l].objID < NumObjectiveEntries)

	mov	ecx, DWORD PTR _l$4[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	eax, WORD PTR [edx+ecx]
	movsx	ecx, WORD PTR ?NumObjectiveEntries@@3FA	; NumObjectiveEntries
	cmp	eax, ecx
	jge	$LN14@LoadPtHead

; 772  : 			{
; 773  : 				int featureCount = ObjDataTable[PtHeaderDataTable[l].objID].Features; 

	mov	edx, DWORD PTR _l$4[ebp]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	ecx, WORD PTR [eax+edx]
	imul	ecx, 54					; 00000036H
	mov	edx, DWORD PTR ?ObjDataTable@@3PAUObjClassDataType@@A ; ObjDataTable
	movzx	eax, BYTE PTR [edx+ecx+50]
	mov	DWORD PTR _featureCount$2[ebp], eax

; 774  : 				for(t=0; t<MAX_FEAT_DEPEND; t++)

	mov	DWORD PTR _t$3[ebp], 0
	jmp	SHORT $LN13@LoadPtHead
$LN12@LoadPtHead:
	mov	ecx, DWORD PTR _t$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _t$3[ebp], ecx
$LN13@LoadPtHead:
	cmp	DWORD PTR _t$3[ebp], 5
	jge	$LN11@LoadPtHead

; 775  : 				{
; 776  : 					if (PtHeaderDataTable[l].features[t] != 255 && PtHeaderDataTable[l].features[t] >= featureCount)

	mov	edx, DWORD PTR _l$4[ebp]
	imul	edx, 28					; 0000001cH
	add	edx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	mov	eax, DWORD PTR _t$3[ebp]
	movzx	ecx, BYTE PTR [edx+eax+4]
	cmp	ecx, 255				; 000000ffH
	je	SHORT $LN10@LoadPtHead
	mov	edx, DWORD PTR _l$4[ebp]
	imul	edx, 28					; 0000001cH
	add	edx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	mov	eax, DWORD PTR _t$3[ebp]
	movzx	ecx, BYTE PTR [edx+eax+4]
	cmp	ecx, DWORD PTR _featureCount$2[ebp]
	jl	SHORT $LN10@LoadPtHead

; 777  : 					{
; 778  : 						if (ErrorFH)

	cmp	DWORD PTR ?ErrorFH@@3PAU_iobuf@@A, 0	; ErrorFH
	je	SHORT $LN9@LoadPtHead

; 779  : 							fprintf(ErrorFH,"PtHeaderDataTable[%d].features[%d]=%d >= Objective[%d]'s Features %d\n", 
; 780  : 							l, t, PtHeaderDataTable[l].features[t], PtHeaderDataTable[l].objID, featureCount);

	mov	edx, DWORD PTR _featureCount$2[ebp]
	push	edx
	mov	eax, DWORD PTR _l$4[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	edx, WORD PTR [ecx+eax]
	push	edx
	mov	eax, DWORD PTR _l$4[ebp]
	imul	eax, 28					; 0000001cH
	add	eax, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	mov	ecx, DWORD PTR _t$3[ebp]
	movzx	edx, BYTE PTR [eax+ecx+4]
	push	edx
	mov	eax, DWORD PTR _t$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _l$4[ebp]
	push	ecx
	push	OFFSET ??_C@_0EG@GNFNLJDK@PtHeaderDataTable?$FL?$CFd?$FN?4features?$FL?$CF@
	mov	edx, DWORD PTR ?ErrorFH@@3PAU_iobuf@@A	; ErrorFH
	push	edx
	call	_fprintf
	add	esp, 28					; 0000001cH
$LN9@LoadPtHead:

; 781  : 						PtHeaderDataTable[l].features[t]=255;

	mov	eax, DWORD PTR _l$4[ebp]
	imul	eax, 28					; 0000001cH
	add	eax, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	mov	ecx, DWORD PTR _t$3[ebp]
	mov	BYTE PTR [eax+ecx+4], 255		; 000000ffH
$LN10@LoadPtHead:

; 782  : 					}
; 783  : 				}

	jmp	$LN12@LoadPtHead
$LN11@LoadPtHead:

; 784  : 			}
; 785  : 			else 

	jmp	SHORT $LN7@LoadPtHead
$LN14@LoadPtHead:

; 786  : 			{
; 787  : 				if (ErrorFH)

	cmp	DWORD PTR ?ErrorFH@@3PAU_iobuf@@A, 0	; ErrorFH
	je	SHORT $LN7@LoadPtHead

; 788  : 					fprintf(ErrorFH,"PtHeaderDataTable[%d].objId=%d >= NumObjectiveEntries=%d\n", 
; 789  : 					l, PtHeaderDataTable[l].objID, NumObjectiveEntries);

	movsx	edx, WORD PTR ?NumObjectiveEntries@@3FA	; NumObjectiveEntries
	push	edx
	mov	eax, DWORD PTR _l$4[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	edx, WORD PTR [ecx+eax]
	push	edx
	mov	eax, DWORD PTR _l$4[ebp]
	push	eax
	push	OFFSET ??_C@_0DK@BIGLNPMG@PtHeaderDataTable?$FL?$CFd?$FN?4objId?$DN?$CFd?5?$DO@
	mov	ecx, DWORD PTR ?ErrorFH@@3PAU_iobuf@@A	; ErrorFH
	push	ecx
	call	_fprintf
	add	esp, 20					; 00000014H
$LN7@LoadPtHead:

; 790  : 			}
; 791  : 		}

	jmp	$LN16@LoadPtHead
$LN15@LoadPtHead:

; 792  : 	}
; 793  : 		// org int l,t; // FRB - Sanity check
; 794  : 		int l; // FRB - Sanity check
; 795  : 		for (l=0;l<NumObjectiveEntries;l++)

	mov	DWORD PTR _l$[ebp], 0
	jmp	SHORT $LN6@LoadPtHead
$LN5@LoadPtHead:
	mov	edx, DWORD PTR _l$[ebp]
	add	edx, 1
	mov	DWORD PTR _l$[ebp], edx
$LN6@LoadPtHead:
	movsx	eax, WORD PTR ?NumObjectiveEntries@@3FA	; NumObjectiveEntries
	cmp	DWORD PTR _l$[ebp], eax
	jge	$LN4@LoadPtHead

; 796  : 		{
; 797  : 			if ((ObjDataTable[l].PtDataIndex >= NumPtHeaders) || (ObjDataTable[l].PtDataIndex < 0))

	mov	ecx, DWORD PTR _l$[ebp]
	imul	ecx, 54					; 00000036H
	mov	edx, DWORD PTR ?ObjDataTable@@3PAUObjClassDataType@@A ; ObjDataTable
	movsx	eax, WORD PTR [edx+ecx+26]
	movsx	ecx, WORD PTR ?NumPtHeaders@@3FA	; NumPtHeaders
	cmp	eax, ecx
	jge	SHORT $LN2@LoadPtHead
	mov	edx, DWORD PTR _l$[ebp]
	imul	edx, 54					; 00000036H
	mov	eax, DWORD PTR ?ObjDataTable@@3PAUObjClassDataType@@A ; ObjDataTable
	movsx	ecx, WORD PTR [eax+edx+26]
	test	ecx, ecx
	jge	SHORT $LN3@LoadPtHead
$LN2@LoadPtHead:

; 798  : 			{
; 799  : 				if (ErrorFH)

	cmp	DWORD PTR ?ErrorFH@@3PAU_iobuf@@A, 0	; ErrorFH
	je	SHORT $LN1@LoadPtHead

; 800  : 					fprintf(ErrorFH,"ObjDataTable[%d].PtDataIndex >= NumPtHeaders = %d or < 0\n", 
; 801  : 					l, ObjDataTable[l].PtDataIndex, NumPtHeaders);

	movsx	edx, WORD PTR ?NumPtHeaders@@3FA	; NumPtHeaders
	push	edx
	mov	eax, DWORD PTR _l$[ebp]
	imul	eax, 54					; 00000036H
	mov	ecx, DWORD PTR ?ObjDataTable@@3PAUObjClassDataType@@A ; ObjDataTable
	movsx	edx, WORD PTR [ecx+eax+26]
	push	edx
	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	push	OFFSET ??_C@_0DK@HDPDKILO@ObjDataTable?$FL?$CFd?$FN?4PtDataIndex?5?$DO?$DN?5@
	mov	ecx, DWORD PTR ?ErrorFH@@3PAU_iobuf@@A	; ErrorFH
	push	ecx
	call	_fprintf
	add	esp, 20					; 00000014H
$LN1@LoadPtHead:

; 802  : 
; 803  : 				ObjDataTable[l].PtDataIndex = 0;

	mov	edx, DWORD PTR _l$[ebp]
	imul	edx, 54					; 00000036H
	xor	eax, eax
	mov	ecx, DWORD PTR ?ObjDataTable@@3PAUObjClassDataType@@A ; ObjDataTable
	mov	WORD PTR [ecx+edx+26], ax
$LN3@LoadPtHead:

; 804  : 			}
; 805  : 		}

	jmp	$LN5@LoadPtHead
$LN4@LoadPtHead:

; 806  : 
; 807  : 	return 1;

	mov	eax, 1
$LN22@LoadPtHead:

; 808  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?LoadPtHeaderData@@YAHPAD@Z ENDP			; LoadPtHeaderData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\entity.cpp
_TEXT	SEGMENT
$T1 = -20						; size = 4
_size$ = -16						; size = 4
_fp$ = -12						; size = 4
_iknt$2 = -8						; size = 2
_entries$ = -4						; size = 2
_filename$ = 8						; size = 4
?LoadWeaponListData@@YAHPAD@Z PROC			; LoadWeaponListData

; 704  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 705  : 	FILE*			fp;
; 706  : 	short			entries;
; 707  : 
; 708  : 	if ((fp = OpenCampFile(filename, "WLD", "rb")) == NULL)

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	push	OFFSET ??_C@_03GFPEOJFN@WLD?$AA@
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	?OpenCampFile@@YAPAU_iobuf@@PAD00@Z	; OpenCampFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _fp$[ebp], eax
	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $LN6@LoadWeapon

; 709  : 		return 0;

	xor	eax, eax
	jmp	$LN7@LoadWeapon
$LN6@LoadWeapon:

; 710  : 	fseek(fp, 0, SEEK_END); // JPO - work out if the file looks the right size.

	push	2
	push	0
	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fseek
	add	esp, 12					; 0000000cH

; 711  : 	unsigned int size = ftell(fp);

	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_ftell
	add	esp, 4
	mov	DWORD PTR _size$[ebp], eax

; 712  : 	// FF - DB Control
; 713  : 	if (g_bFFDBC)

	movzx	eax, BYTE PTR ?g_bFFDBC@@3_NA		; g_bFFDBC
	test	eax, eax
	je	SHORT $LN5@LoadWeapon

; 714  : 	{
; 715  : 		// FF - get real count of entries
; 716  : 		short	iknt = 0;

	xor	ecx, ecx
	mov	WORD PTR _iknt$2[ebp], cx

; 717  : 		fseek(fp, 0, SEEK_END);

	push	2
	push	0
	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_fseek
	add	esp, 12					; 0000000cH

; 718  : 		fseek(fp, -2, SEEK_CUR);

	push	1
	push	-2					; fffffffeH
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH

; 719  : 		fread(&iknt,sizeof(short),1,fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	push	1
	push	2
	lea	edx, DWORD PTR _iknt$2[ebp]
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 720  : 		fseek(fp, 0, SEEK_SET);

	push	0
	push	0
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH

; 721  : 		// Move pointer past the 0 entries
; 722  : 		fread(&entries,sizeof(short),1,fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	push	1
	push	2
	lea	edx, DWORD PTR _entries$[ebp]
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 723  : 		if (entries == 0)

	movsx	eax, WORD PTR _entries$[ebp]
	test	eax, eax
	jne	SHORT $LN4@LoadWeapon

; 724  : 			entries = iknt;

	mov	cx, WORD PTR _iknt$2[ebp]
	mov	WORD PTR _entries$[ebp], cx
$LN4@LoadWeapon:

; 725  : 	}
; 726  : 	else

	jmp	SHORT $LN3@LoadWeapon
$LN5@LoadWeapon:

; 727  : 	{
; 728  : 		fseek(fp, 0, SEEK_SET);

	push	0
	push	0
	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_fseek
	add	esp, 12					; 0000000cH

; 729  : 		if (fread(&entries,sizeof(short),1,fp) < 1)

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	2
	lea	ecx, DWORD PTR _entries$[ebp]
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H
	cmp	eax, 1
	jae	SHORT $LN2@LoadWeapon

; 730  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN7@LoadWeapon
$LN2@LoadWeapon:

; 731  : 		if (size != sizeof(WeaponListDataType) * entries + 2)

	movsx	edx, WORD PTR _entries$[ebp]
	imul	edx, 208				; 000000d0H
	add	edx, 2
	cmp	DWORD PTR _size$[ebp], edx
	je	SHORT $LN3@LoadWeapon

; 732  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN7@LoadWeapon
$LN3@LoadWeapon:

; 733  : 	}
; 734  : 	//fseek(fp, 0, SEEK_SET);
; 735  : 	//if (fread(&entries,sizeof(short),1,fp) < 1)
; 736  : 	//	return 0;
; 737  : 	//if (size != sizeof(WeaponListDataType) * entries + 2)
; 738  : 	//	return 0;
; 739  : 	WeaponListDataTable = new WeaponListDataType[entries];

	movsx	eax, WORD PTR _entries$[ebp]
	xor	ecx, ecx
	mov	edx, 208				; 000000d0H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR ?WeaponListDataTable@@3PAUWeaponListDataType@@A, eax ; WeaponListDataTable

; 740  : 	fread(WeaponListDataTable,sizeof(WeaponListDataType),entries,fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	movsx	edx, WORD PTR _entries$[ebp]
	push	edx
	push	208					; 000000d0H
	mov	eax, DWORD PTR ?WeaponListDataTable@@3PAUWeaponListDataType@@A ; WeaponListDataTable
	push	eax
	call	_fread
	add	esp, 16					; 00000010H

; 741  : 	fclose(fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fclose
	add	esp, 4

; 742  : 	return 1;

	mov	eax, 1
$LN7@LoadWeapon:

; 743  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?LoadWeaponListData@@YAHPAD@Z ENDP			; LoadWeaponListData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\entity.cpp
_TEXT	SEGMENT
$T1 = -20						; size = 4
_size$ = -16						; size = 4
_fp$ = -12						; size = 4
_iknt$2 = -8						; size = 2
_entries$ = -4						; size = 2
_filename$ = 8						; size = 4
?LoadVehicleData@@YAHPAD@Z PROC				; LoadVehicleData

; 661  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 662  : 	FILE*			fp;
; 663  : 	short			entries;
; 664  : 
; 665  : 	if ((fp = OpenCampFile(filename, "VCD", "rb")) == NULL)

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	push	OFFSET ??_C@_03NGBEMJAF@VCD?$AA@
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	?OpenCampFile@@YAPAU_iobuf@@PAD00@Z	; OpenCampFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _fp$[ebp], eax
	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $LN6@LoadVehicl

; 666  : 		return 0;

	xor	eax, eax
	jmp	$LN7@LoadVehicl
$LN6@LoadVehicl:

; 667  : 	fseek(fp, 0, SEEK_END); // JPO - work out if the file looks the right size.

	push	2
	push	0
	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fseek
	add	esp, 12					; 0000000cH

; 668  : 	unsigned int size = ftell(fp);

	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_ftell
	add	esp, 4
	mov	DWORD PTR _size$[ebp], eax

; 669  : 	// FF - DB Control
; 670  : 	if (g_bFFDBC)

	movzx	eax, BYTE PTR ?g_bFFDBC@@3_NA		; g_bFFDBC
	test	eax, eax
	je	SHORT $LN5@LoadVehicl

; 671  : 	{
; 672  : 		// FF - get real count of entries
; 673  : 		short	iknt = 0;

	xor	ecx, ecx
	mov	WORD PTR _iknt$2[ebp], cx

; 674  : 		fseek(fp, 0, SEEK_END);

	push	2
	push	0
	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_fseek
	add	esp, 12					; 0000000cH

; 675  : 		fseek(fp, -2, SEEK_CUR);

	push	1
	push	-2					; fffffffeH
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH

; 676  : 		fread(&iknt,sizeof(short),1,fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	push	1
	push	2
	lea	edx, DWORD PTR _iknt$2[ebp]
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 677  : 		fseek(fp, 0, SEEK_SET);

	push	0
	push	0
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH

; 678  : 		// Move pointer past the 0 entries
; 679  : 		fread(&entries,sizeof(short),1,fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	push	1
	push	2
	lea	edx, DWORD PTR _entries$[ebp]
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 680  : 		if (entries == 0)

	movsx	eax, WORD PTR _entries$[ebp]
	test	eax, eax
	jne	SHORT $LN4@LoadVehicl

; 681  : 			entries = iknt;

	mov	cx, WORD PTR _iknt$2[ebp]
	mov	WORD PTR _entries$[ebp], cx
$LN4@LoadVehicl:

; 682  : 	}
; 683  : 	else

	jmp	SHORT $LN3@LoadVehicl
$LN5@LoadVehicl:

; 684  : 	{
; 685  : 		fseek(fp, 0, SEEK_SET);

	push	0
	push	0
	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_fseek
	add	esp, 12					; 0000000cH

; 686  : 		if (fread(&entries,sizeof(short),1,fp) < 1)

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	2
	lea	ecx, DWORD PTR _entries$[ebp]
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H
	cmp	eax, 1
	jae	SHORT $LN2@LoadVehicl

; 687  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN7@LoadVehicl
$LN2@LoadVehicl:

; 688  : 		if (size != sizeof(VehicleClassDataType) * entries + 2)

	movsx	edx, WORD PTR _entries$[ebp]
	imul	edx, 160				; 000000a0H
	add	edx, 2
	cmp	DWORD PTR _size$[ebp], edx
	je	SHORT $LN3@LoadVehicl

; 689  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN7@LoadVehicl
$LN3@LoadVehicl:

; 690  : 	}
; 691  : 	//fseek(fp, 0, SEEK_SET);
; 692  : 	//if (fread(&entries,sizeof(short),1,fp) < 1)
; 693  : 	//	return 0;
; 694  : 	//if (size != sizeof(VehicleClassDataType) * entries + 2)
; 695  : 	//	return 0;
; 696  : 	VehicleDataTable = new VehicleClassDataType[entries];

	movsx	eax, WORD PTR _entries$[ebp]
	xor	ecx, ecx
	mov	edx, 160				; 000000a0H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR ?VehicleDataTable@@3PAUVehicleClassDataType@@A, eax ; VehicleDataTable

; 697  : 	fread(VehicleDataTable,sizeof(VehicleClassDataType),entries,fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	movsx	edx, WORD PTR _entries$[ebp]
	push	edx
	push	160					; 000000a0H
	mov	eax, DWORD PTR ?VehicleDataTable@@3PAUVehicleClassDataType@@A ; VehicleDataTable
	push	eax
	call	_fread
	add	esp, 16					; 00000010H

; 698  : 	fclose(fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fclose
	add	esp, 4

; 699  : 	NumVehicleEntries = entries;

	mov	dx, WORD PTR _entries$[ebp]
	mov	WORD PTR ?NumVehicleEntries@@3FA, dx	; NumVehicleEntries

; 700  : 	return 1;

	mov	eax, 1
$LN7@LoadVehicl:

; 701  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?LoadVehicleData@@YAHPAD@Z ENDP				; LoadVehicleData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\entity.cpp
_TEXT	SEGMENT
$T1 = -20						; size = 4
_size$ = -16						; size = 4
_fp$ = -12						; size = 4
_iknt$2 = -8						; size = 2
_entries$ = -4						; size = 2
_filename$ = 8						; size = 4
?LoadFeatureData@@YAHPAD@Z PROC				; LoadFeatureData

; 618  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 619  : 	FILE*			fp;
; 620  : 	short			entries;
; 621  : 
; 622  : 	if ((fp = OpenCampFile(filename, "FCD", "rb")) == NULL)

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	push	OFFSET ??_C@_03IGANJOJK@FCD?$AA@
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	?OpenCampFile@@YAPAU_iobuf@@PAD00@Z	; OpenCampFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _fp$[ebp], eax
	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $LN6@LoadFeatur

; 623  : 		return 0;

	xor	eax, eax
	jmp	$LN7@LoadFeatur
$LN6@LoadFeatur:

; 624  : 	fseek(fp, 0, SEEK_END); // JPO - work out if the file looks the right size.

	push	2
	push	0
	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fseek
	add	esp, 12					; 0000000cH

; 625  : 	unsigned int size = ftell(fp);

	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_ftell
	add	esp, 4
	mov	DWORD PTR _size$[ebp], eax

; 626  : 	// FF - DB Control
; 627  : 	if (g_bFFDBC)

	movzx	eax, BYTE PTR ?g_bFFDBC@@3_NA		; g_bFFDBC
	test	eax, eax
	je	SHORT $LN5@LoadFeatur

; 628  : 	{
; 629  : 		// FF - get real count of entries
; 630  : 		short	iknt = 0;

	xor	ecx, ecx
	mov	WORD PTR _iknt$2[ebp], cx

; 631  : 		fseek(fp, 0, SEEK_END);

	push	2
	push	0
	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_fseek
	add	esp, 12					; 0000000cH

; 632  : 		fseek(fp, -2, SEEK_CUR);

	push	1
	push	-2					; fffffffeH
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH

; 633  : 		fread(&iknt,sizeof(short),1,fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	push	1
	push	2
	lea	edx, DWORD PTR _iknt$2[ebp]
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 634  : 		fseek(fp, 0, SEEK_SET);

	push	0
	push	0
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH

; 635  : 		// Move pointer past the 0 entries
; 636  : 		fread(&entries,sizeof(short),1,fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	push	1
	push	2
	lea	edx, DWORD PTR _entries$[ebp]
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 637  : 		if (entries == 0)

	movsx	eax, WORD PTR _entries$[ebp]
	test	eax, eax
	jne	SHORT $LN4@LoadFeatur

; 638  : 			entries = iknt;

	mov	cx, WORD PTR _iknt$2[ebp]
	mov	WORD PTR _entries$[ebp], cx
$LN4@LoadFeatur:

; 639  : 	}
; 640  : 	else

	jmp	SHORT $LN3@LoadFeatur
$LN5@LoadFeatur:

; 641  : 	{
; 642  : 		fseek(fp, 0, SEEK_SET);

	push	0
	push	0
	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_fseek
	add	esp, 12					; 0000000cH

; 643  : 		if (fread(&entries,sizeof(short),1,fp) < 1)

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	2
	lea	ecx, DWORD PTR _entries$[ebp]
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H
	cmp	eax, 1
	jae	SHORT $LN2@LoadFeatur

; 644  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN7@LoadFeatur
$LN2@LoadFeatur:

; 645  : 		if (size != sizeof(FeatureClassDataType) * entries + 2)

	movsx	edx, WORD PTR _entries$[ebp]
	imul	edx, 60					; 0000003cH
	add	edx, 2
	cmp	DWORD PTR _size$[ebp], edx
	je	SHORT $LN3@LoadFeatur

; 646  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN7@LoadFeatur
$LN3@LoadFeatur:

; 647  : 	}
; 648  : 	//fseek(fp, 0, SEEK_SET);
; 649  : 	//if (fread(&entries,sizeof(short),1,fp) < 1)
; 650  : 	//	return 0;
; 651  : 	//if (size != sizeof(FeatureClassDataType) * entries + 2)
; 652  : 	//	return 0;
; 653  : 	FeatureDataTable = new FeatureClassDataType[entries];

	movsx	eax, WORD PTR _entries$[ebp]
	xor	ecx, ecx
	mov	edx, 60					; 0000003cH
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR ?FeatureDataTable@@3PAUFeatureClassDataType@@A, eax ; FeatureDataTable

; 654  : 	fread(FeatureDataTable,sizeof(FeatureClassDataType),entries,fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	movsx	edx, WORD PTR _entries$[ebp]
	push	edx
	push	60					; 0000003cH
	mov	eax, DWORD PTR ?FeatureDataTable@@3PAUFeatureClassDataType@@A ; FeatureDataTable
	push	eax
	call	_fread
	add	esp, 16					; 00000010H

; 655  : 	fclose(fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fclose
	add	esp, 4

; 656  : 	NumFeatureEntries = entries;

	mov	dx, WORD PTR _entries$[ebp]
	mov	WORD PTR ?NumFeatureEntries@@3FA, dx	; NumFeatureEntries

; 657  : 	return 1;

	mov	eax, 1
$LN7@LoadFeatur:

; 658  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?LoadFeatureData@@YAHPAD@Z ENDP				; LoadFeatureData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\entity.cpp
_TEXT	SEGMENT
$T1 = -20						; size = 4
_size$ = -16						; size = 4
_fp$ = -12						; size = 4
_iknt$2 = -8						; size = 2
_entries$ = -4						; size = 2
_filename$ = 8						; size = 4
?LoadDirtyData@@YAHPAD@Z PROC				; LoadDirtyData

; 570  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 571  : 	FILE*			fp;
; 572  : 	short			entries;
; 573  : 
; 574  : 	if ((fp = OpenCampFile(filename, "DDP", "rb")) == NULL)

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	push	OFFSET ??_C@_03HOFJHMB@DDP?$AA@
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	?OpenCampFile@@YAPAU_iobuf@@PAD00@Z	; OpenCampFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _fp$[ebp], eax
	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $LN6@LoadDirtyD

; 575  : 		return 0;

	xor	eax, eax
	jmp	$LN7@LoadDirtyD
$LN6@LoadDirtyD:

; 576  : 	fseek(fp, 0, SEEK_END); // JPO - work out if the file looks the right size.

	push	2
	push	0
	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fseek
	add	esp, 12					; 0000000cH

; 577  : 	unsigned int size = ftell(fp);

	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_ftell
	add	esp, 4
	mov	DWORD PTR _size$[ebp], eax

; 578  : 	// FF - DB Control
; 579  : 	if (g_bFFDBC)

	movzx	eax, BYTE PTR ?g_bFFDBC@@3_NA		; g_bFFDBC
	test	eax, eax
	je	SHORT $LN5@LoadDirtyD

; 580  : 	{
; 581  : 		// FF - get real count of entries
; 582  : 		short	iknt = 0;

	xor	ecx, ecx
	mov	WORD PTR _iknt$2[ebp], cx

; 583  : 		fseek(fp, 0, SEEK_END);

	push	2
	push	0
	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_fseek
	add	esp, 12					; 0000000cH

; 584  : 		fseek(fp, -2, SEEK_CUR);

	push	1
	push	-2					; fffffffeH
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH

; 585  : 		fread(&iknt,sizeof(short),1,fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	push	1
	push	2
	lea	edx, DWORD PTR _iknt$2[ebp]
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 586  : 		fseek(fp, 0, SEEK_SET);

	push	0
	push	0
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH

; 587  : 		// Move pointer past the 0 entries
; 588  : 		fread(&entries,sizeof(short),1,fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	push	1
	push	2
	lea	edx, DWORD PTR _entries$[ebp]
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 589  : 		if (entries == 0)

	movsx	eax, WORD PTR _entries$[ebp]
	test	eax, eax
	jne	SHORT $LN4@LoadDirtyD

; 590  : 			entries = iknt;

	mov	cx, WORD PTR _iknt$2[ebp]
	mov	WORD PTR _entries$[ebp], cx
$LN4@LoadDirtyD:

; 591  : 	}
; 592  : 	else

	jmp	SHORT $LN3@LoadDirtyD
$LN5@LoadDirtyD:

; 593  : 	{
; 594  : 		fseek(fp, 0, SEEK_SET);

	push	0
	push	0
	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_fseek
	add	esp, 12					; 0000000cH

; 595  : 		if (fread(&entries,sizeof(short),1,fp) < 1)

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	2
	lea	ecx, DWORD PTR _entries$[ebp]
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H
	cmp	eax, 1
	jae	SHORT $LN2@LoadDirtyD

; 596  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN7@LoadDirtyD
$LN2@LoadDirtyD:

; 597  : 		if (size != sizeof(DirtyDataClassType) * entries + 2)

	movsx	edx, WORD PTR _entries$[ebp]
	lea	eax, DWORD PTR [edx*4+2]
	cmp	DWORD PTR _size$[ebp], eax
	je	SHORT $LN3@LoadDirtyD

; 598  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN7@LoadDirtyD
$LN3@LoadDirtyD:

; 599  : 	}
; 600  : 	//fseek(fp, 0, SEEK_SET);
; 601  : 	//if (fread(&entries,sizeof(short),1,fp) < 1)
; 602  : 	//	return 0;
; 603  : 	//if (size != sizeof(DirtyDataClassType) * entries + 2)
; 604  : 	//	return 0;
; 605  : 	DDP = new DirtyDataClassType[entries];

	movsx	eax, WORD PTR _entries$[ebp]
	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR ?DDP@@3PAUDirtyDataClassType@@A, eax ; DDP

; 606  : 	fread(DDP,sizeof(DirtyDataClassType),entries,fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	movsx	edx, WORD PTR _entries$[ebp]
	push	edx
	push	4
	mov	eax, DWORD PTR ?DDP@@3PAUDirtyDataClassType@@A ; DDP
	push	eax
	call	_fread
	add	esp, 16					; 00000010H

; 607  : 	fclose(fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fclose
	add	esp, 4

; 608  : 	NumDirtyDataPriorities = entries;

	mov	dx, WORD PTR _entries$[ebp]
	mov	WORD PTR ?NumDirtyDataPriorities@@3FA, dx ; NumDirtyDataPriorities

; 609  : 	return 1;

	mov	eax, 1
$LN7@LoadDirtyD:

; 610  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?LoadDirtyData@@YAHPAD@Z ENDP				; LoadDirtyData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\entity.cpp
_TEXT	SEGMENT
$T1 = -20						; size = 4
_size$ = -16						; size = 4
_fp$ = -12						; size = 4
_iknt$2 = -8						; size = 2
_entries$ = -4						; size = 2
_filename$ = 8						; size = 4
?LoadRocketData@@YAHPAD@Z PROC				; LoadRocketData

; 523  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 524  : 	FILE*			fp;
; 525  : 	short			entries;
; 526  : 
; 527  : 	if ((fp = OpenCampFile(filename, "RKT", "rb")) == NULL)

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	push	OFFSET ??_C@_03BNKHBNLL@RKT?$AA@
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	?OpenCampFile@@YAPAU_iobuf@@PAD00@Z	; OpenCampFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _fp$[ebp], eax
	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $LN6@LoadRocket

; 528  : 		return 0;

	xor	eax, eax
	jmp	$LN7@LoadRocket
$LN6@LoadRocket:

; 529  : 	fseek(fp, 0, SEEK_END); // JPO - work out if the file looks the right size.

	push	2
	push	0
	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fseek
	add	esp, 12					; 0000000cH

; 530  : 	unsigned int size = ftell(fp);

	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_ftell
	add	esp, 4
	mov	DWORD PTR _size$[ebp], eax

; 531  : 	// FF - DB Control
; 532  : 	if (g_bFFDBC)

	movzx	eax, BYTE PTR ?g_bFFDBC@@3_NA		; g_bFFDBC
	test	eax, eax
	je	SHORT $LN5@LoadRocket

; 533  : 	{
; 534  : 		// FF - get real count of entries
; 535  : 		short	iknt = 0;

	xor	ecx, ecx
	mov	WORD PTR _iknt$2[ebp], cx

; 536  : 		fseek(fp, 0, SEEK_END);

	push	2
	push	0
	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_fseek
	add	esp, 12					; 0000000cH

; 537  : 		fseek(fp, -2, SEEK_CUR);

	push	1
	push	-2					; fffffffeH
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH

; 538  : 		fread(&iknt,sizeof(short),1,fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	push	1
	push	2
	lea	edx, DWORD PTR _iknt$2[ebp]
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 539  : 		fseek(fp, 0, SEEK_SET);

	push	0
	push	0
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH

; 540  : 		// Move pointer past the 0 entries
; 541  : 		fread(&entries,sizeof(short),1,fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	push	1
	push	2
	lea	edx, DWORD PTR _entries$[ebp]
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 542  : 		if (entries == 0)

	movsx	eax, WORD PTR _entries$[ebp]
	test	eax, eax
	jne	SHORT $LN4@LoadRocket

; 543  : 			entries = iknt;

	mov	cx, WORD PTR _iknt$2[ebp]
	mov	WORD PTR _entries$[ebp], cx
$LN4@LoadRocket:

; 544  : 	}
; 545  : 	else

	jmp	SHORT $LN3@LoadRocket
$LN5@LoadRocket:

; 546  : 	{
; 547  : 		fseek(fp, 0, SEEK_SET);

	push	0
	push	0
	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_fseek
	add	esp, 12					; 0000000cH

; 548  : 		if (fread(&entries,sizeof(short),1,fp) < 1)

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	2
	lea	ecx, DWORD PTR _entries$[ebp]
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H
	cmp	eax, 1
	jae	SHORT $LN2@LoadRocket

; 549  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN7@LoadRocket
$LN2@LoadRocket:

; 550  : 		if (size != sizeof(RocketClassDataType) * entries + 2)

	movsx	edx, WORD PTR _entries$[ebp]
	imul	edx, 6
	add	edx, 2
	cmp	DWORD PTR _size$[ebp], edx
	je	SHORT $LN3@LoadRocket

; 551  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN7@LoadRocket
$LN3@LoadRocket:

; 552  : 	}
; 553  : 	//fseek(fp, 0, SEEK_SET);
; 554  : 	//if (fread(&entries,sizeof(short),1,fp) < 1)
; 555  : 	//	return 0;
; 556  : 	//if (size != sizeof(RocketClassDataType) * entries + 2)
; 557  : 	//	return 0;
; 558  : 	RocketDataTable = new RocketClassDataType[entries];

	movsx	eax, WORD PTR _entries$[ebp]
	xor	ecx, ecx
	mov	edx, 6
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR ?RocketDataTable@@3PAURocketClassDataType@@A, eax ; RocketDataTable

; 559  : 	fread(RocketDataTable,sizeof(RocketClassDataType),entries,fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	movsx	edx, WORD PTR _entries$[ebp]
	push	edx
	push	6
	mov	eax, DWORD PTR ?RocketDataTable@@3PAURocketClassDataType@@A ; RocketDataTable
	push	eax
	call	_fread
	add	esp, 16					; 00000010H

; 560  : 	fclose(fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fclose
	add	esp, 4

; 561  : 	NumRocketTypes = entries;

	mov	dx, WORD PTR _entries$[ebp]
	mov	WORD PTR ?NumRocketTypes@@3FA, dx	; NumRocketTypes

; 562  : 	return 1;

	mov	eax, 1
$LN7@LoadRocket:

; 563  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?LoadRocketData@@YAHPAD@Z ENDP				; LoadRocketData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\entity.cpp
_TEXT	SEGMENT
$T1 = -20						; size = 4
_size$ = -16						; size = 4
_fp$ = -12						; size = 4
_iknt$2 = -8						; size = 2
_entries$ = -4						; size = 2
_filename$ = 8						; size = 4
?LoadWeaponData@@YAHPAD@Z PROC				; LoadWeaponData

; 478  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 479  : 	FILE*			fp;
; 480  : 	short			entries;
; 481  : 
; 482  : 	if ((fp = OpenCampFile(filename, "WCD", "rb")) == NULL)

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	push	OFFSET ??_C@_03GOKIKOGA@WCD?$AA@
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	?OpenCampFile@@YAPAU_iobuf@@PAD00@Z	; OpenCampFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _fp$[ebp], eax
	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $LN6@LoadWeapon

; 483  : 		return 0;

	xor	eax, eax
	jmp	$LN7@LoadWeapon
$LN6@LoadWeapon:

; 484  : 	fseek(fp, 0, SEEK_END); // JPO - work out if the file looks the right size.

	push	2
	push	0
	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fseek
	add	esp, 12					; 0000000cH

; 485  : 	unsigned int size = ftell(fp);

	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_ftell
	add	esp, 4
	mov	DWORD PTR _size$[ebp], eax

; 486  : 	// FF - DB Control
; 487  : 	if (g_bFFDBC)

	movzx	eax, BYTE PTR ?g_bFFDBC@@3_NA		; g_bFFDBC
	test	eax, eax
	je	SHORT $LN5@LoadWeapon

; 488  : 	{
; 489  : 		// FF - get real count of entries
; 490  : 		short	iknt = 0;

	xor	ecx, ecx
	mov	WORD PTR _iknt$2[ebp], cx

; 491  : 		fseek(fp, 0, SEEK_END);

	push	2
	push	0
	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_fseek
	add	esp, 12					; 0000000cH

; 492  : 		fseek(fp, -2, SEEK_CUR);

	push	1
	push	-2					; fffffffeH
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH

; 493  : 		fread(&iknt,sizeof(short),1,fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	push	1
	push	2
	lea	edx, DWORD PTR _iknt$2[ebp]
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 494  : 		fseek(fp, 0, SEEK_SET);

	push	0
	push	0
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH

; 495  : 		// Move pointer past the 0 entries
; 496  : 		fread(&entries,sizeof(short),1,fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	push	1
	push	2
	lea	edx, DWORD PTR _entries$[ebp]
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 497  : 		if (entries == 0)

	movsx	eax, WORD PTR _entries$[ebp]
	test	eax, eax
	jne	SHORT $LN4@LoadWeapon

; 498  : 			entries = iknt;

	mov	cx, WORD PTR _iknt$2[ebp]
	mov	WORD PTR _entries$[ebp], cx
$LN4@LoadWeapon:

; 499  : 	}
; 500  : 	else

	jmp	SHORT $LN3@LoadWeapon
$LN5@LoadWeapon:

; 501  : 	{
; 502  : 		fseek(fp, 0, SEEK_SET);

	push	0
	push	0
	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_fseek
	add	esp, 12					; 0000000cH

; 503  : 		if (fread(&entries,sizeof(short),1,fp) < 1)

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	2
	lea	ecx, DWORD PTR _entries$[ebp]
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H
	cmp	eax, 1
	jae	SHORT $LN2@LoadWeapon

; 504  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN7@LoadWeapon
$LN2@LoadWeapon:

; 505  : 		if (size != sizeof(WeaponClassDataType) * entries + 2)

	movsx	edx, WORD PTR _entries$[ebp]
	imul	edx, 60					; 0000003cH
	add	edx, 2
	cmp	DWORD PTR _size$[ebp], edx
	je	SHORT $LN3@LoadWeapon

; 506  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN7@LoadWeapon
$LN3@LoadWeapon:

; 507  : 	}
; 508  : 	//fseek(fp, 0, SEEK_SET);
; 509  : 	//if (fread(&entries,sizeof(short),1,fp) < 1)
; 510  : 	//	return 0;
; 511  : 	//if (size != sizeof(WeaponClassDataType) * entries + 2)
; 512  : 	//	return 0;
; 513  : 	WeaponDataTable = new WeaponClassDataType[entries];

	movsx	eax, WORD PTR _entries$[ebp]
	xor	ecx, ecx
	mov	edx, 60					; 0000003cH
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A, eax ; WeaponDataTable

; 514  : 	fread(WeaponDataTable,sizeof(WeaponClassDataType),entries,fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	movsx	edx, WORD PTR _entries$[ebp]
	push	edx
	push	60					; 0000003cH
	mov	eax, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	push	eax
	call	_fread
	add	esp, 16					; 00000010H

; 515  : 	fclose(fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fclose
	add	esp, 4

; 516  : 	NumWeaponTypes = entries;

	mov	dx, WORD PTR _entries$[ebp]
	mov	WORD PTR ?NumWeaponTypes@@3FA, dx	; NumWeaponTypes

; 517  : 	return 1;

	mov	eax, 1
$LN7@LoadWeapon:

; 518  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?LoadWeaponData@@YAHPAD@Z ENDP				; LoadWeaponData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\entity.cpp
_TEXT	SEGMENT
$T1 = -20						; size = 4
_size$ = -16						; size = 4
_fp$ = -12						; size = 4
_iknt$2 = -8						; size = 2
_entries$ = -4						; size = 2
_filename$ = 8						; size = 4
?LoadObjectiveData@@YAHPAD@Z PROC			; LoadObjectiveData

; 403  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 404  : 	FILE*		fp;
; 405  : 	//	int			i,j,fid;
; 406  : 	short		entries;
; 407  : 	//char	fname[64];
; 408  : 
; 409  : 
; 410  : 
; 411  : 	//strcpy (fname, filename);	// M.N. switch between objectives with and without trees
; 412  : 	//if (g_bDisplayTrees)
; 413  : 	//	strcat(fname,"tree");
; 414  : 
; 415  : 	//if ((fp = OpenCampFile(fname, "OCD", "rb")) == NULL)
; 416  : 	//{
; 417  : 	//	if (g_bDisplayTrees && fedtree)	// we've loaded a fedtree previously, so we also need a ocdtree version
; 418  : 	//	{
; 419  : 	//		ShiError( "Failed to load objective data" );	
; 420  : 	//		return 0;
; 421  : 	//	}
; 422  : 		if ((fp = OpenCampFile(filename, "OCD", "rb")) == NULL)	// if we have no "tree" version, just load the standard one

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	push	OFFSET ??_C@_03PLAFNBBA@OCD?$AA@
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	?OpenCampFile@@YAPAU_iobuf@@PAD00@Z	; OpenCampFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _fp$[ebp], eax
	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $LN6@LoadObject

; 423  : 			return 0;

	xor	eax, eax
	jmp	$LN7@LoadObject
$LN6@LoadObject:

; 424  : 	//}
; 425  : 	fseek(fp, 0, SEEK_END); // JPO - work out if the file looks the right size.

	push	2
	push	0
	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fseek
	add	esp, 12					; 0000000cH

; 426  : 	unsigned int size = ftell(fp);

	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_ftell
	add	esp, 4
	mov	DWORD PTR _size$[ebp], eax

; 427  : 	// FF - DB Control
; 428  : 	if (g_bFFDBC)

	movzx	eax, BYTE PTR ?g_bFFDBC@@3_NA		; g_bFFDBC
	test	eax, eax
	je	SHORT $LN5@LoadObject

; 429  : 	{
; 430  : 		// FF - get real count of entries
; 431  : 		short	iknt = 0;

	xor	ecx, ecx
	mov	WORD PTR _iknt$2[ebp], cx

; 432  : 		fseek(fp, 0, SEEK_END);

	push	2
	push	0
	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_fseek
	add	esp, 12					; 0000000cH

; 433  : 		fseek(fp, -2, SEEK_CUR);

	push	1
	push	-2					; fffffffeH
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH

; 434  : 		fread(&iknt,sizeof(short),1,fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	push	1
	push	2
	lea	edx, DWORD PTR _iknt$2[ebp]
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 435  : 		fseek(fp, 0, SEEK_SET);

	push	0
	push	0
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH

; 436  : 		// Move pointer past the 0 entries
; 437  : 		fread(&entries,sizeof(short),1,fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	push	1
	push	2
	lea	edx, DWORD PTR _entries$[ebp]
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 438  : 		if (entries == 0)

	movsx	eax, WORD PTR _entries$[ebp]
	test	eax, eax
	jne	SHORT $LN4@LoadObject

; 439  : 			entries = iknt;

	mov	cx, WORD PTR _iknt$2[ebp]
	mov	WORD PTR _entries$[ebp], cx
$LN4@LoadObject:

; 440  : 	}
; 441  : 	else

	jmp	SHORT $LN3@LoadObject
$LN5@LoadObject:

; 442  : 	{
; 443  : 		fseek(fp, 0, SEEK_SET);

	push	0
	push	0
	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_fseek
	add	esp, 12					; 0000000cH

; 444  : 		if (fread(&entries,sizeof(short),1,fp) < 1)

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	2
	lea	ecx, DWORD PTR _entries$[ebp]
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H
	cmp	eax, 1
	jae	SHORT $LN2@LoadObject

; 445  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN7@LoadObject
$LN2@LoadObject:

; 446  : 		if (size != sizeof(ObjClassDataType) * entries + 2)

	movsx	edx, WORD PTR _entries$[ebp]
	imul	edx, 54					; 00000036H
	add	edx, 2
	cmp	DWORD PTR _size$[ebp], edx
	je	SHORT $LN3@LoadObject

; 447  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN7@LoadObject
$LN3@LoadObject:

; 448  : 	}
; 449  : 	//fseek(fp, 0, SEEK_SET);
; 450  : 	//if (fread(&entries,sizeof(short),1,fp) < 1)
; 451  : 	//	return 0;
; 452  : 	//if (size != sizeof(ObjClassDataType) * entries + 2)
; 453  : 	//	return 0;
; 454  : 	ObjDataTable = new ObjClassDataType[entries];

	movsx	eax, WORD PTR _entries$[ebp]
	xor	ecx, ecx
	mov	edx, 54					; 00000036H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR ?ObjDataTable@@3PAUObjClassDataType@@A, eax ; ObjDataTable

; 455  : 	fread(ObjDataTable,sizeof(ObjClassDataType),entries,fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	movsx	edx, WORD PTR _entries$[ebp]
	push	edx
	push	54					; 00000036H
	mov	eax, DWORD PTR ?ObjDataTable@@3PAUObjClassDataType@@A ; ObjDataTable
	push	eax
	call	_fread
	add	esp, 16					; 00000010H

; 456  : 	fclose(fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fclose
	add	esp, 4

; 457  : 	/*
; 458  : 	// Build feature ids
; 459  : 	for (i=0; i<entries; i++)
; 460  : 	{
; 461  : 	fid = ObjDataTable[i].FirstFeature;
; 462  : 	for (j=0; j<ObjDataTable[i].Features; j++)
; 463  : 	{
; 464  : 	FeatureEntryDataTable[fid].Index = GetClassID(FeatureEntryDataTable[fid].eClass[0],
; 465  : 	FeatureEntryDataTable[fid].eClass[1],FeatureEntryDataTable[fid].eClass[2],
; 466  : 	FeatureEntryDataTable[fid].eClass[3],FeatureEntryDataTable[fid].eClass[4],
; 467  : 	FeatureEntryDataTable[fid].eClass[5],FeatureEntryDataTable[fid].eClass[6],
; 468  : 	FeatureEntryDataTable[fid].eClass[7]);
; 469  : 	fid++;
; 470  : 	}
; 471  : 	}
; 472  : 	 */
; 473  : 	NumObjectiveEntries = entries;

	mov	dx, WORD PTR _entries$[ebp]
	mov	WORD PTR ?NumObjectiveEntries@@3FA, dx	; NumObjectiveEntries

; 474  : 	return 1;

	mov	eax, 1
$LN7@LoadObject:

; 475  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?LoadObjectiveData@@YAHPAD@Z ENDP			; LoadObjectiveData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\entity.cpp
_TEXT	SEGMENT
$T1 = -20						; size = 4
_size$ = -16						; size = 4
_fp$ = -12						; size = 4
_iknt$2 = -8						; size = 2
_entries$ = -4						; size = 2
_filename$ = 8						; size = 4
?LoadUnitData@@YAHPAD@Z PROC				; LoadUnitData

; 357  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 358  : 	FILE*		fp;
; 359  : 	short		entries;
; 360  : 
; 361  : 	if ((fp = OpenCampFile(filename, "UCD", "rb")) == NULL)

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	push	OFFSET ??_C@_03MEKBGGOL@UCD?$AA@
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	?OpenCampFile@@YAPAU_iobuf@@PAD00@Z	; OpenCampFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _fp$[ebp], eax
	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $LN7@LoadUnitDa

; 362  : 		return 0;

	xor	eax, eax
	jmp	$LN8@LoadUnitDa
$LN7@LoadUnitDa:

; 363  : 	fseek(fp, 0, SEEK_END); // JPO - work out if the file looks the right size.

	push	2
	push	0
	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fseek
	add	esp, 12					; 0000000cH

; 364  : 	unsigned int size = ftell(fp);

	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_ftell
	add	esp, 4
	mov	DWORD PTR _size$[ebp], eax

; 365  : 	// FF - DB Control
; 366  : 	//fseek(fp, 0, SEEK_SET);
; 367  : 	//fread(&entries,sizeof(short),1,fp);
; 368  : 	//fseek(fp, 0, SEEK_SET);
; 369  : 	//if (entries == 0)
; 370  : 	//	g_bFFDBC = true;
; 371  : 	if (g_bFFDBC)

	movzx	eax, BYTE PTR ?g_bFFDBC@@3_NA		; g_bFFDBC
	test	eax, eax
	je	SHORT $LN6@LoadUnitDa

; 372  : 	{
; 373  : 		// FF - get real count of entries
; 374  : 		short	iknt = 0;

	xor	ecx, ecx
	mov	WORD PTR _iknt$2[ebp], cx

; 375  : 		fseek(fp, 0, SEEK_END);

	push	2
	push	0
	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_fseek
	add	esp, 12					; 0000000cH

; 376  : 		fseek(fp, -2, SEEK_CUR);

	push	1
	push	-2					; fffffffeH
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH

; 377  : 		fread(&iknt,sizeof(short),1,fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	push	1
	push	2
	lea	edx, DWORD PTR _iknt$2[ebp]
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 378  : 		fseek(fp, 0, SEEK_SET);

	push	0
	push	0
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH

; 379  : 		// Move pointer past the 0 entries
; 380  : 		fread(&entries,sizeof(short),1,fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	push	1
	push	2
	lea	edx, DWORD PTR _entries$[ebp]
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 381  : 		if (entries > 0)

	movsx	eax, WORD PTR _entries$[ebp]
	test	eax, eax
	jle	SHORT $LN5@LoadUnitDa

; 382  : 			g_bFFDBC = false;

	mov	BYTE PTR ?g_bFFDBC@@3_NA, 0		; g_bFFDBC

; 383  : 		else

	jmp	SHORT $LN4@LoadUnitDa
$LN5@LoadUnitDa:

; 384  : 			entries = iknt;

	mov	cx, WORD PTR _iknt$2[ebp]
	mov	WORD PTR _entries$[ebp], cx
$LN4@LoadUnitDa:

; 385  : 	}
; 386  : 	else

	jmp	SHORT $LN3@LoadUnitDa
$LN6@LoadUnitDa:

; 387  : 	{
; 388  : 		fseek(fp, 0, SEEK_SET);

	push	0
	push	0
	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_fseek
	add	esp, 12					; 0000000cH

; 389  : 		if (fread(&entries,sizeof(short),1,fp) < 1)

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	2
	lea	ecx, DWORD PTR _entries$[ebp]
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H
	cmp	eax, 1
	jae	SHORT $LN2@LoadUnitDa

; 390  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN8@LoadUnitDa
$LN2@LoadUnitDa:

; 391  : 		if (size != sizeof(UnitClassDataType) * entries + 2)

	movsx	edx, WORD PTR _entries$[ebp]
	imul	edx, 336				; 00000150H
	add	edx, 2
	cmp	DWORD PTR _size$[ebp], edx
	je	SHORT $LN3@LoadUnitDa

; 392  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN8@LoadUnitDa
$LN3@LoadUnitDa:

; 393  : 	}
; 394  : 	UnitDataTable = new UnitClassDataType[entries];

	movsx	eax, WORD PTR _entries$[ebp]
	xor	ecx, ecx
	mov	edx, 336				; 00000150H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR ?UnitDataTable@@3PAUUnitClassDataType@@A, eax ; UnitDataTable

; 395  : 	fread(UnitDataTable,sizeof(UnitClassDataType),entries,fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	movsx	edx, WORD PTR _entries$[ebp]
	push	edx
	push	336					; 00000150H
	mov	eax, DWORD PTR ?UnitDataTable@@3PAUUnitClassDataType@@A ; UnitDataTable
	push	eax
	call	_fread
	add	esp, 16					; 00000010H

; 396  : 	fclose(fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fclose
	add	esp, 4

; 397  : 	NumUnitEntries = entries;

	mov	dx, WORD PTR _entries$[ebp]
	mov	WORD PTR ?NumUnitEntries@@3FA, dx	; NumUnitEntries

; 398  : 
; 399  : 	return 1;

	mov	eax, 1
$LN8@LoadUnitDa:

; 400  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?LoadUnitData@@YAHPAD@Z ENDP				; LoadUnitData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\entity.cpp
_TEXT	SEGMENT
$T1 = -84						; size = 4
$T2 = -80						; size = 4
$T3 = -76						; size = 4
$T4 = -72						; size = 4
$T5 = -68						; size = 4
$T6 = -64						; size = 4
$T7 = -60						; size = 4
$T8 = -56						; size = 4
$T9 = -52						; size = 4
$T10 = -48						; size = 4
$T11 = -44						; size = 4
$T12 = -40						; size = 4
$T13 = -36						; size = 4
$T14 = -32						; size = 4
$T15 = -28						; size = 4
$T16 = -24						; size = 4
$T17 = -20						; size = 4
$T18 = -16						; size = 4
$T19 = -12						; size = 4
$T20 = -8						; size = 4
$T21 = -4						; size = 4
?UnloadClassTable@@YAHXZ PROC				; UnloadClassTable

; 325  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H

; 326  : 	delete [] UnitDataTable;

	mov	eax, DWORD PTR ?UnitDataTable@@3PAUUnitClassDataType@@A ; UnitDataTable
	mov	DWORD PTR $T21[ebp], eax
	mov	ecx, DWORD PTR $T21[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 327  : 	delete [] ObjDataTable;

	mov	edx, DWORD PTR ?ObjDataTable@@3PAUObjClassDataType@@A ; ObjDataTable
	mov	DWORD PTR $T20[ebp], edx
	mov	eax, DWORD PTR $T20[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 328  : 	delete [] WeaponDataTable;

	mov	ecx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	mov	DWORD PTR $T19[ebp], ecx
	mov	edx, DWORD PTR $T19[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 329  : 	delete [] FeatureDataTable;	

	mov	eax, DWORD PTR ?FeatureDataTable@@3PAUFeatureClassDataType@@A ; FeatureDataTable
	mov	DWORD PTR $T18[ebp], eax
	mov	ecx, DWORD PTR $T18[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 330  : 	delete [] VehicleDataTable;

	mov	edx, DWORD PTR ?VehicleDataTable@@3PAUVehicleClassDataType@@A ; VehicleDataTable
	mov	DWORD PTR $T17[ebp], edx
	mov	eax, DWORD PTR $T17[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 331  : 	delete [] WeaponListDataTable;

	mov	ecx, DWORD PTR ?WeaponListDataTable@@3PAUWeaponListDataType@@A ; WeaponListDataTable
	mov	DWORD PTR $T16[ebp], ecx
	mov	edx, DWORD PTR $T16[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 332  : 	delete [] SquadronStoresDataTable;

	mov	eax, DWORD PTR ?SquadronStoresDataTable@@3PAUSquadronStoresDataType@@A ; SquadronStoresDataTable
	mov	DWORD PTR $T15[ebp], eax
	mov	ecx, DWORD PTR $T15[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 333  : 	delete [] Falcon4ClassTable;

	mov	edx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	DWORD PTR $T14[ebp], edx
	mov	eax, DWORD PTR $T14[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 334  : 	delete [] PtHeaderDataTable;

	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	mov	DWORD PTR $T13[ebp], ecx
	mov	edx, DWORD PTR $T13[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 335  : 	delete [] PtDataTable;

	mov	eax, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	mov	DWORD PTR $T12[ebp], eax
	mov	ecx, DWORD PTR $T12[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 336  : 	delete [] FeatureEntryDataTable;

	mov	edx, DWORD PTR ?FeatureEntryDataTable@@3PAUFeatureEntry@@A ; FeatureEntryDataTable
	mov	DWORD PTR $T11[ebp], edx
	mov	eax, DWORD PTR $T11[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 337  : 	delete [] RadarDataTable;

	mov	ecx, DWORD PTR ?RadarDataTable@@3PAURadarDataType@@A ; RadarDataTable
	mov	DWORD PTR $T10[ebp], ecx
	mov	edx, DWORD PTR $T10[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 338  : 	delete [] IRSTDataTable;

	mov	eax, DWORD PTR ?IRSTDataTable@@3PAUIRSTDataType@@A ; IRSTDataTable
	mov	DWORD PTR $T9[ebp], eax
	mov	ecx, DWORD PTR $T9[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 339  : 	delete [] RwrDataTable;

	mov	edx, DWORD PTR ?RwrDataTable@@3PAURwrDataType@@A ; RwrDataTable
	mov	DWORD PTR $T8[ebp], edx
	mov	eax, DWORD PTR $T8[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 340  : 	delete [] VisualDataTable;

	mov	ecx, DWORD PTR ?VisualDataTable@@3PAUVisualDataType@@A ; VisualDataTable
	mov	DWORD PTR $T7[ebp], ecx
	mov	edx, DWORD PTR $T7[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 341  : 	delete [] SimWeaponDataTable;

	mov	eax, DWORD PTR ?SimWeaponDataTable@@3PAUSimWeaponDataType@@A ; SimWeaponDataTable
	mov	DWORD PTR $T6[ebp], eax
	mov	ecx, DWORD PTR $T6[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 342  : 	delete [] SimACDefTable;

	mov	edx, DWORD PTR ?SimACDefTable@@3PAUSimACDefType@@A ; SimACDefTable
	mov	DWORD PTR $T5[ebp], edx
	mov	eax, DWORD PTR $T5[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 343  : 	delete [] RocketDataTable;			// Added by M.N.

	mov	ecx, DWORD PTR ?RocketDataTable@@3PAURocketClassDataType@@A ; RocketDataTable
	mov	DWORD PTR $T4[ebp], ecx
	mov	edx, DWORD PTR $T4[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 344  : 	delete [] DDP;						// Added by M.N.

	mov	eax, DWORD PTR ?DDP@@3PAUDirtyDataClassType@@A ; DDP
	mov	DWORD PTR $T3[ebp], eax
	mov	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 345  : 	delete [] RackGroupTable;

	mov	edx, DWORD PTR ?RackGroupTable@@3PAURackGroup@@A ; RackGroupTable
	mov	DWORD PTR $T2[ebp], edx
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 346  : 	delete [] RackObjectTable;

	mov	ecx, DWORD PTR ?RackObjectTable@@3PAURackObject@@A ; RackObjectTable
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 347  : 	MaxRackObjects = 0;

	mov	DWORD PTR ?MaxRackObjects@@3HA, 0	; MaxRackObjects

; 348  : 	MaxRackGroups = 0;

	mov	DWORD PTR ?MaxRackGroups@@3HA, 0	; MaxRackGroups

; 349  : 	RDUnloadRackData();

	call	?RDUnloadRackData@@YAXXZ		; RDUnloadRackData

; 350  : 	return (TRUE);

	mov	eax, 1

; 351  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?UnloadClassTable@@YAHXZ ENDP				; UnloadClassTable
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\entity.cpp
_TEXT	SEGMENT
_objSet$ = -10456					; size = 4
_newstr$ = -10452					; size = 4
_i$ = -10448						; size = 4
_buffer$1 = -10444					; size = 580
_buffer$2 = -9864					; size = 580
_buffer$3 = -9284					; size = 580
_buffer$4 = -8704					; size = 580
_buffer$5 = -8124					; size = 580
_buffer$6 = -7544					; size = 580
_buffer$7 = -6964					; size = 580
_buffer$8 = -6384					; size = 580
_buffer$9 = -5804					; size = 580
_buffer$10 = -5224					; size = 580
_buffer$11 = -4644					; size = 580
_buffer$12 = -4064					; size = 580
_buffer$13 = -3484					; size = 580
_buffer$14 = -2904					; size = 580
_buffer$15 = -2324					; size = 580
_buffer$16 = -1744					; size = 580
_buffer$17 = -1164					; size = 580
_buffer$18 = -584					; size = 580
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
?LoadClassTable@@YAHPAD@Z PROC				; LoadClassTable

; 138  : {

	push	ebp
	mov	ebp, esp
	mov	eax, 10456				; 000028d8H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 139  : 	int		i;
; 140  : 	char	*objSet;
; 141  : 	char	*newstr;
; 142  : 
; 143  : 	ErrorFH = 0L;

	mov	DWORD PTR ?ErrorFH@@3PAU_iobuf@@A, 0	; ErrorFH

; 144  : 	if (g_bCheckFeatureIndex)

	movzx	eax, BYTE PTR ?g_bCheckFeatureIndex@@3_NA ; g_bCheckFeatureIndex
	test	eax, eax
	je	SHORT $LN41@LoadClassT

; 145  : 		ErrorFH = fopen("C:\\Objective-Errors.txt","w"); // MLR 5/15/2004 - 

	push	OFFSET ??_C@_01NOFIACDB@w?$AA@
	push	OFFSET ??_C@_0BI@GFGDACML@C?3?2Objective?9Errors?4txt?$AA@
	call	_fopen
	add	esp, 8
	mov	DWORD PTR ?ErrorFH@@3PAU_iobuf@@A, eax	; ErrorFH
$LN41@LoadClassT:

; 146  : 
; 147  : #if 0 // not required JPO?
; 148  : 	HKEY	theKey;
; 149  : 	DWORD	size,type;
; 150  : 	// Get the path data from the registry
; 151  : 	RegOpenKeyEx(HKEY_LOCAL_MACHINE, FALCON_REGISTRY_KEY, 0, KEY_ALL_ACCESS, &theKey);
; 152  : 
; 153  : 	size = sizeof (FalconObjectDataDir);
; 154  : 	RegQueryValueEx(theKey, "objectdir", 0, &type, (LPBYTE)FalconObjectDataDir, &size);
; 155  : 	RegCloseKey(theKey);
; 156  : #endif
; 157  : 	objSet = newstr = strchr(FalconObjectDataDir,'\\');

	push	92					; 0000005cH
	push	OFFSET ?FalconObjectDataDir@@3PADA	; FalconObjectDataDir
	call	?strchr@@YAPADPADH@Z			; strchr
	add	esp, 8
	mov	DWORD PTR _newstr$[ebp], eax
	mov	ecx, DWORD PTR _newstr$[ebp]
	mov	DWORD PTR _objSet$[ebp], ecx
$LN40@LoadClassT:

; 158  : 	while(newstr)

	cmp	DWORD PTR _newstr$[ebp], 0
	je	SHORT $LN39@LoadClassT

; 159  : 	{
; 160  : 		objSet = newstr + 1;

	mov	edx, DWORD PTR _newstr$[ebp]
	add	edx, 1
	mov	DWORD PTR _objSet$[ebp], edx

; 161  : 		newstr = strchr(objSet,'\\');

	push	92					; 0000005cH
	mov	eax, DWORD PTR _objSet$[ebp]
	push	eax
	call	?strchr@@YAPADPADH@Z			; strchr
	add	esp, 8
	mov	DWORD PTR _newstr$[ebp], eax

; 162  : 	}

	jmp	SHORT $LN40@LoadClassT
$LN39@LoadClassT:

; 163  : 
; 164  : 	// Check file integrity
; 165  : 	//	FileVerify();
; 166  : 
; 167  : 	InitClassTableAndData(filename,objSet);

	mov	ecx, DWORD PTR _objSet$[ebp]
	push	ecx
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	?InitClassTableAndData@@YAXPAD0@Z	; InitClassTableAndData
	add	esp, 8

; 168  : 	ReadClassTable();

	call	?ReadClassTable@@YAXXZ			; ReadClassTable

; 169  : #ifndef MISSILE_TEST_PROG
; 170  : #ifndef ACMI
; 171  : #ifndef IACONVERT
; 172  : 
; 173  : 	if (!LoadUnitData(filename))			ShiError( "Failed to load unit data" );

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	?LoadUnitData@@YAHPAD@Z			; LoadUnitData
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN38@LoadClassT
	push	OFFSET ??_C@_0M@CFLADCE@Feb?518?52013?$AA@
	push	OFFSET ??_C@_0L@IGAEJGCL@Entity?4cpp?$AA@
	push	173					; 000000adH
	push	OFFSET ??_C@_0BE@FGKKLFGH@Error?3?5?5?$CF0d?5?5?$CFs?5?5?$CFs?$AA@
	lea	ecx, DWORD PTR _buffer$8[ebp]
	push	ecx
	call	_sprintf
	add	esp, 20					; 00000014H
	push	0
	push	OFFSET ??_C@_0BJ@FKDHIIHL@Failed?5to?5load?5unit?5data?$AA@
	lea	edx, DWORD PTR _buffer$8[ebp]
	push	edx
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	push	-1
	call	_exit
$LN38@LoadClassT:

; 174  : 	if (!LoadFeatureEntryData(filename))	ShiError( "Failed to load feature entries" );

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	?LoadFeatureEntryData@@YAHPAD@Z		; LoadFeatureEntryData
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN37@LoadClassT
	push	OFFSET ??_C@_0M@CFLADCE@Feb?518?52013?$AA@
	push	OFFSET ??_C@_0L@IGAEJGCL@Entity?4cpp?$AA@
	push	174					; 000000aeH
	push	OFFSET ??_C@_0BE@FGKKLFGH@Error?3?5?5?$CF0d?5?5?$CFs?5?5?$CFs?$AA@
	lea	ecx, DWORD PTR _buffer$14[ebp]
	push	ecx
	call	_sprintf
	add	esp, 20					; 00000014H
	push	0
	push	OFFSET ??_C@_0BP@EKGKJCFC@Failed?5to?5load?5feature?5entries?$AA@
	lea	edx, DWORD PTR _buffer$14[ebp]
	push	edx
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	push	-1
	call	_exit
$LN37@LoadClassT:

; 175  : 	if (!LoadObjectiveData(filename))		ShiError( "Failed to load objective data" );	

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	?LoadObjectiveData@@YAHPAD@Z		; LoadObjectiveData
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN36@LoadClassT
	push	OFFSET ??_C@_0M@CFLADCE@Feb?518?52013?$AA@
	push	OFFSET ??_C@_0L@IGAEJGCL@Entity?4cpp?$AA@
	push	175					; 000000afH
	push	OFFSET ??_C@_0BE@FGKKLFGH@Error?3?5?5?$CF0d?5?5?$CFs?5?5?$CFs?$AA@
	lea	ecx, DWORD PTR _buffer$4[ebp]
	push	ecx
	call	_sprintf
	add	esp, 20					; 00000014H
	push	0
	push	OFFSET ??_C@_0BO@EGFMBGCP@Failed?5to?5load?5objective?5data?$AA@
	lea	edx, DWORD PTR _buffer$4[ebp]
	push	edx
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	push	-1
	call	_exit
$LN36@LoadClassT:

; 176  : 	if (!LoadWeaponData(filename))			ShiError( "Failed to load weapon data" );	

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	?LoadWeaponData@@YAHPAD@Z		; LoadWeaponData
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN35@LoadClassT
	push	OFFSET ??_C@_0M@CFLADCE@Feb?518?52013?$AA@
	push	OFFSET ??_C@_0L@IGAEJGCL@Entity?4cpp?$AA@
	push	176					; 000000b0H
	push	OFFSET ??_C@_0BE@FGKKLFGH@Error?3?5?5?$CF0d?5?5?$CFs?5?5?$CFs?$AA@
	lea	ecx, DWORD PTR _buffer$12[ebp]
	push	ecx
	call	_sprintf
	add	esp, 20					; 00000014H
	push	0
	push	OFFSET ??_C@_0BL@HBLOKCBF@Failed?5to?5load?5weapon?5data?$AA@
	lea	edx, DWORD PTR _buffer$12[ebp]
	push	edx
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	push	-1
	call	_exit
$LN35@LoadClassT:

; 177  : 	if (!LoadFeatureData(filename))			ShiError( "Failed to load feature data" );	

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	?LoadFeatureData@@YAHPAD@Z		; LoadFeatureData
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN34@LoadClassT
	push	OFFSET ??_C@_0M@CFLADCE@Feb?518?52013?$AA@
	push	OFFSET ??_C@_0L@IGAEJGCL@Entity?4cpp?$AA@
	push	177					; 000000b1H
	push	OFFSET ??_C@_0BE@FGKKLFGH@Error?3?5?5?$CF0d?5?5?$CFs?5?5?$CFs?$AA@
	lea	ecx, DWORD PTR _buffer$6[ebp]
	push	ecx
	call	_sprintf
	add	esp, 20					; 00000014H
	push	0
	push	OFFSET ??_C@_0BM@FEPKGIOD@Failed?5to?5load?5feature?5data?$AA@
	lea	edx, DWORD PTR _buffer$6[ebp]
	push	edx
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	push	-1
	call	_exit
$LN34@LoadClassT:

; 178  : 	if (!LoadVehicleData(filename))			ShiError( "Failed to load vehicle data" );	

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	?LoadVehicleData@@YAHPAD@Z		; LoadVehicleData
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN33@LoadClassT
	push	OFFSET ??_C@_0M@CFLADCE@Feb?518?52013?$AA@
	push	OFFSET ??_C@_0L@IGAEJGCL@Entity?4cpp?$AA@
	push	178					; 000000b2H
	push	OFFSET ??_C@_0BE@FGKKLFGH@Error?3?5?5?$CF0d?5?5?$CFs?5?5?$CFs?$AA@
	lea	ecx, DWORD PTR _buffer$10[ebp]
	push	ecx
	call	_sprintf
	add	esp, 20					; 00000014H
	push	0
	push	OFFSET ??_C@_0BM@PPALOCAG@Failed?5to?5load?5vehicle?5data?$AA@
	lea	edx, DWORD PTR _buffer$10[ebp]
	push	edx
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	push	-1
	call	_exit
$LN33@LoadClassT:

; 179  : 	if (!LoadWeaponListData(filename))		ShiError( "Failed to load weapon list" );	

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	?LoadWeaponListData@@YAHPAD@Z		; LoadWeaponListData
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN32@LoadClassT
	push	OFFSET ??_C@_0M@CFLADCE@Feb?518?52013?$AA@
	push	OFFSET ??_C@_0L@IGAEJGCL@Entity?4cpp?$AA@
	push	179					; 000000b3H
	push	OFFSET ??_C@_0BE@FGKKLFGH@Error?3?5?5?$CF0d?5?5?$CFs?5?5?$CFs?$AA@
	lea	ecx, DWORD PTR _buffer$2[ebp]
	push	ecx
	call	_sprintf
	add	esp, 20					; 00000014H
	push	0
	push	OFFSET ??_C@_0BL@LGIADBKK@Failed?5to?5load?5weapon?5list?$AA@
	lea	edx, DWORD PTR _buffer$2[ebp]
	push	edx
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	push	-1
	call	_exit
$LN32@LoadClassT:

; 180  : 	if (!LoadPtHeaderData(filename))		ShiError( "Failed to load point headers" );	

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	?LoadPtHeaderData@@YAHPAD@Z		; LoadPtHeaderData
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN31@LoadClassT
	push	OFFSET ??_C@_0M@CFLADCE@Feb?518?52013?$AA@
	push	OFFSET ??_C@_0L@IGAEJGCL@Entity?4cpp?$AA@
	push	180					; 000000b4H
	push	OFFSET ??_C@_0BE@FGKKLFGH@Error?3?5?5?$CF0d?5?5?$CFs?5?5?$CFs?$AA@
	lea	ecx, DWORD PTR _buffer$18[ebp]
	push	ecx
	call	_sprintf
	add	esp, 20					; 00000014H
	push	0
	push	OFFSET ??_C@_0BN@IDIHOGAD@Failed?5to?5load?5point?5headers?$AA@
	lea	edx, DWORD PTR _buffer$18[ebp]
	push	edx
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	push	-1
	call	_exit
$LN31@LoadClassT:

; 181  : 	if (!LoadPtData(filename))				ShiError( "Failed to load point data" );

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	?LoadPtData@@YAHPAD@Z			; LoadPtData
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN30@LoadClassT
	push	OFFSET ??_C@_0M@CFLADCE@Feb?518?52013?$AA@
	push	OFFSET ??_C@_0L@IGAEJGCL@Entity?4cpp?$AA@
	push	181					; 000000b5H
	push	OFFSET ??_C@_0BE@FGKKLFGH@Error?3?5?5?$CF0d?5?5?$CFs?5?5?$CFs?$AA@
	lea	ecx, DWORD PTR _buffer$17[ebp]
	push	ecx
	call	_sprintf
	add	esp, 20					; 00000014H
	push	0
	push	OFFSET ??_C@_0BK@DOBMODNN@Failed?5to?5load?5point?5data?$AA@
	lea	edx, DWORD PTR _buffer$17[ebp]
	push	edx
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	push	-1
	call	_exit
$LN30@LoadClassT:

; 182  : 	if (!LoadRadarData(filename))			ShiError( "Failed to load radar data" );

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	?LoadRadarData@@YAHPAD@Z		; LoadRadarData
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN29@LoadClassT
	push	OFFSET ??_C@_0M@CFLADCE@Feb?518?52013?$AA@
	push	OFFSET ??_C@_0L@IGAEJGCL@Entity?4cpp?$AA@
	push	182					; 000000b6H
	push	OFFSET ??_C@_0BE@FGKKLFGH@Error?3?5?5?$CF0d?5?5?$CFs?5?5?$CFs?$AA@
	lea	ecx, DWORD PTR _buffer$15[ebp]
	push	ecx
	call	_sprintf
	add	esp, 20					; 00000014H
	push	0
	push	OFFSET ??_C@_0BK@DDAGKKGO@Failed?5to?5load?5radar?5data?$AA@
	lea	edx, DWORD PTR _buffer$15[ebp]
	push	edx
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	push	-1
	call	_exit
$LN29@LoadClassT:

; 183  : 	if (!LoadIRSTData(filename))			ShiError( "Failed to load IRST data" );

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	?LoadIRSTData@@YAHPAD@Z			; LoadIRSTData
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN28@LoadClassT
	push	OFFSET ??_C@_0M@CFLADCE@Feb?518?52013?$AA@
	push	OFFSET ??_C@_0L@IGAEJGCL@Entity?4cpp?$AA@
	push	183					; 000000b7H
	push	OFFSET ??_C@_0BE@FGKKLFGH@Error?3?5?5?$CF0d?5?5?$CFs?5?5?$CFs?$AA@
	lea	ecx, DWORD PTR _buffer$13[ebp]
	push	ecx
	call	_sprintf
	add	esp, 20					; 00000014H
	push	0
	push	OFFSET ??_C@_0BJ@DLENKPCC@Failed?5to?5load?5IRST?5data?$AA@
	lea	edx, DWORD PTR _buffer$13[ebp]
	push	edx
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	push	-1
	call	_exit
$LN28@LoadClassT:

; 184  : 	if (!LoadRwrData(filename))				ShiError( "Failed to load Rwr data" );

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	?LoadRwrData@@YAHPAD@Z			; LoadRwrData
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN27@LoadClassT
	push	OFFSET ??_C@_0M@CFLADCE@Feb?518?52013?$AA@
	push	OFFSET ??_C@_0L@IGAEJGCL@Entity?4cpp?$AA@
	push	184					; 000000b8H
	push	OFFSET ??_C@_0BE@FGKKLFGH@Error?3?5?5?$CF0d?5?5?$CFs?5?5?$CFs?$AA@
	lea	ecx, DWORD PTR _buffer$11[ebp]
	push	ecx
	call	_sprintf
	add	esp, 20					; 00000014H
	push	0
	push	OFFSET ??_C@_0BI@MILFPPLL@Failed?5to?5load?5Rwr?5data?$AA@
	lea	edx, DWORD PTR _buffer$11[ebp]
	push	edx
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	push	-1
	call	_exit
$LN27@LoadClassT:

; 185  : 	if (!LoadVisualData(filename))			ShiError( "Failed to load Visual data" );

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	?LoadVisualData@@YAHPAD@Z		; LoadVisualData
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN26@LoadClassT
	push	OFFSET ??_C@_0M@CFLADCE@Feb?518?52013?$AA@
	push	OFFSET ??_C@_0L@IGAEJGCL@Entity?4cpp?$AA@
	push	185					; 000000b9H
	push	OFFSET ??_C@_0BE@FGKKLFGH@Error?3?5?5?$CF0d?5?5?$CFs?5?5?$CFs?$AA@
	lea	ecx, DWORD PTR _buffer$9[ebp]
	push	ecx
	call	_sprintf
	add	esp, 20					; 00000014H
	push	0
	push	OFFSET ??_C@_0BL@BDOJLAME@Failed?5to?5load?5Visual?5data?$AA@
	lea	edx, DWORD PTR _buffer$9[ebp]
	push	edx
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	push	-1
	call	_exit
$LN26@LoadClassT:

; 186  : 	if (!LoadSimWeaponData(filename))		ShiError( "Failed to load SimWeapon data" );

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	?LoadSimWeaponData@@YAHPAD@Z		; LoadSimWeaponData
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN25@LoadClassT
	push	OFFSET ??_C@_0M@CFLADCE@Feb?518?52013?$AA@
	push	OFFSET ??_C@_0L@IGAEJGCL@Entity?4cpp?$AA@
	push	186					; 000000baH
	push	OFFSET ??_C@_0BE@FGKKLFGH@Error?3?5?5?$CF0d?5?5?$CFs?5?5?$CFs?$AA@
	lea	ecx, DWORD PTR _buffer$7[ebp]
	push	ecx
	call	_sprintf
	add	esp, 20					; 00000014H
	push	0
	push	OFFSET ??_C@_0BO@ENPFIBAL@Failed?5to?5load?5SimWeapon?5data?$AA@
	lea	edx, DWORD PTR _buffer$7[ebp]
	push	edx
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	push	-1
	call	_exit
$LN25@LoadClassT:

; 187  : 	if (!LoadACDefData(filename))			ShiError( "Failed to load AC Definition data" );

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	?LoadACDefData@@YAHPAD@Z		; LoadACDefData
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN24@LoadClassT
	push	OFFSET ??_C@_0M@CFLADCE@Feb?518?52013?$AA@
	push	OFFSET ??_C@_0L@IGAEJGCL@Entity?4cpp?$AA@
	push	187					; 000000bbH
	push	OFFSET ??_C@_0BE@FGKKLFGH@Error?3?5?5?$CF0d?5?5?$CFs?5?5?$CFs?$AA@
	lea	ecx, DWORD PTR _buffer$5[ebp]
	push	ecx
	call	_sprintf
	add	esp, 20					; 00000014H
	push	0
	push	OFFSET ??_C@_0CC@IJBFJPCM@Failed?5to?5load?5AC?5Definition?5dat@
	lea	edx, DWORD PTR _buffer$5[ebp]
	push	edx
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	push	-1
	call	_exit
$LN24@LoadClassT:

; 188  : 	if (!LoadSquadronStoresData(filename))	ShiError( "Failed to load Squadron stores data" );

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	?LoadSquadronStoresData@@YAHPAD@Z	; LoadSquadronStoresData
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN23@LoadClassT
	push	OFFSET ??_C@_0M@CFLADCE@Feb?518?52013?$AA@
	push	OFFSET ??_C@_0L@IGAEJGCL@Entity?4cpp?$AA@
	push	188					; 000000bcH
	push	OFFSET ??_C@_0BE@FGKKLFGH@Error?3?5?5?$CF0d?5?5?$CFs?5?5?$CFs?$AA@
	lea	ecx, DWORD PTR _buffer$3[ebp]
	push	ecx
	call	_sprintf
	add	esp, 20					; 00000014H
	push	0
	push	OFFSET ??_C@_0CE@KBILOMDH@Failed?5to?5load?5Squadron?5stores?5d@
	lea	edx, DWORD PTR _buffer$3[ebp]
	push	edx
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	push	-1
	call	_exit
$LN23@LoadClassT:

; 189  : 	if (!LoadRocketData(filename))			ShiError( "Failed to load Rocket data" );	// added by M.N.

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	?LoadRocketData@@YAHPAD@Z		; LoadRocketData
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN22@LoadClassT
	push	OFFSET ??_C@_0M@CFLADCE@Feb?518?52013?$AA@
	push	OFFSET ??_C@_0L@IGAEJGCL@Entity?4cpp?$AA@
	push	189					; 000000bdH
	push	OFFSET ??_C@_0BE@FGKKLFGH@Error?3?5?5?$CF0d?5?5?$CFs?5?5?$CFs?$AA@
	lea	ecx, DWORD PTR _buffer$1[ebp]
	push	ecx
	call	_sprintf
	add	esp, 20					; 00000014H
	push	0
	push	OFFSET ??_C@_0BL@GLINIFKA@Failed?5to?5load?5Rocket?5data?$AA@
	lea	edx, DWORD PTR _buffer$1[ebp]
	push	edx
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	push	-1
	call	_exit
$LN22@LoadClassT:

; 190  : 	if (!LoadDirtyData(filename))			ShiError( "Failed to load Dirty data priorities" ); // added by M.N.

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	?LoadDirtyData@@YAHPAD@Z		; LoadDirtyData
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN21@LoadClassT
	push	OFFSET ??_C@_0M@CFLADCE@Feb?518?52013?$AA@
	push	OFFSET ??_C@_0L@IGAEJGCL@Entity?4cpp?$AA@
	push	190					; 000000beH
	push	OFFSET ??_C@_0BE@FGKKLFGH@Error?3?5?5?$CF0d?5?5?$CFs?5?5?$CFs?$AA@
	lea	ecx, DWORD PTR _buffer$16[ebp]
	push	ecx
	call	_sprintf
	add	esp, 20					; 00000014H
	push	0
	push	OFFSET ??_C@_0CF@LPMLGJMG@Failed?5to?5load?5Dirty?5data?5priori@
	lea	edx, DWORD PTR _buffer$16[ebp]
	push	edx
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	push	-1
	call	_exit
$LN21@LoadClassT:

; 191  : 	LoadMissionData();

	call	?LoadMissionData@@YAHXZ			; LoadMissionData

; 192  : 	LoadVisIdMap();

	call	?LoadVisIdMap@@YAXXZ			; LoadVisIdMap

; 193  : 	LoadRackTables();

	call	?LoadRackTables@@YAXXZ			; LoadRackTables

; 194  : 	RDLoadRackData();

	call	?RDLoadRackData@@YAXXZ			; RDLoadRackData

; 195  : 
; 196  : 	F4Assert (Falcon4ClassTable);
; 197  : 	WriteClassTable();

	call	?WriteClassTable@@YAXXZ			; WriteClassTable

; 198  : 	// Build ptr data
; 199  : 	for (i=0; i<NumEntities; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN20@LoadClassT
$LN19@LoadClassT:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN20@LoadClassT:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR ?NumEntities@@3HA	; NumEntities
	jge	$LN18@LoadClassT

; 200  : 	{
; 201  : 		if (Falcon4ClassTable[i].dataPtr != NULL)

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 81					; 00000051H
	mov	eax, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	cmp	DWORD PTR [eax+edx+77], 0
	je	$LN6@LoadClassT

; 202  : 		{
; 203  : 			if (Falcon4ClassTable[i].dataType == DTYPE_UNIT)

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 81					; 00000051H
	mov	edx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	movzx	eax, BYTE PTR [edx+ecx+76]
	cmp	eax, 4
	jne	SHORT $LN16@LoadClassT

; 204  : 			{
; 205  : 				//				if (Falcon4ClassTable[i].vuClassData.classInfo_[VU_DOMAIN] == DOMAIN_AIR && Falcon4ClassTable[i].vuClassData.classInfo_[VU_TYPE] == TYPE_SQUADRON)
; 206  : 				//					NumSquadTypes++;
; 207  : 				ShiAssert((int)Falcon4ClassTable[i].dataPtr < NumUnitEntries);
; 208  : 				UnitDataTable[(int)Falcon4ClassTable[i].dataPtr].Index = i;

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 81					; 00000051H
	mov	edx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	eax, DWORD PTR [edx+ecx+77]
	imul	eax, 336				; 00000150H
	mov	ecx, DWORD PTR ?UnitDataTable@@3PAUUnitClassDataType@@A ; UnitDataTable
	mov	dx, WORD PTR _i$[ebp]
	mov	WORD PTR [ecx+eax], dx

; 209  : 				Falcon4ClassTable[i].dataPtr = (void*) &UnitDataTable[(int)Falcon4ClassTable[i].dataPtr];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 81					; 00000051H
	mov	ecx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	edx, DWORD PTR [ecx+eax+77]
	imul	edx, 336				; 00000150H
	add	edx, DWORD PTR ?UnitDataTable@@3PAUUnitClassDataType@@A ; UnitDataTable
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 81					; 00000051H
	mov	ecx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	DWORD PTR [ecx+eax+77], edx
	jmp	$LN6@LoadClassT
$LN16@LoadClassT:

; 210  : 			}
; 211  : 			else if (Falcon4ClassTable[i].dataType == DTYPE_OBJECTIVE)

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 81					; 00000051H
	mov	eax, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	movzx	ecx, BYTE PTR [eax+edx+76]
	cmp	ecx, 3
	jne	$LN14@LoadClassT

; 212  : 			{
; 213  : 				if (Falcon4ClassTable[i].vuClassData.classInfo_[VU_TYPE] >= NumObjectiveTypes)

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 81					; 00000051H
	add	edx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	eax, 1
	shl	eax, 1
	movzx	ecx, BYTE PTR [edx+eax+8]
	movsx	edx, WORD PTR ?NumObjectiveTypes@@3FA	; NumObjectiveTypes
	cmp	ecx, edx
	jl	SHORT $LN13@LoadClassT

; 214  : 					NumObjectiveTypes = Falcon4ClassTable[i].vuClassData.classInfo_[VU_TYPE];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 81					; 00000051H
	add	eax, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	ecx, 1
	shl	ecx, 1
	movzx	dx, BYTE PTR [eax+ecx+8]
	mov	WORD PTR ?NumObjectiveTypes@@3FA, dx	; NumObjectiveTypes
$LN13@LoadClassT:

; 215  : 				ShiAssert((int)Falcon4ClassTable[i].dataPtr < NumObjectiveEntries);
; 216  : 				ObjDataTable[(int)Falcon4ClassTable[i].dataPtr].Index = i;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 81					; 00000051H
	mov	ecx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	edx, DWORD PTR [ecx+eax+77]
	imul	edx, 54					; 00000036H
	mov	eax, DWORD PTR ?ObjDataTable@@3PAUObjClassDataType@@A ; ObjDataTable
	mov	cx, WORD PTR _i$[ebp]
	mov	WORD PTR [eax+edx], cx

; 217  : 				Falcon4ClassTable[i].dataPtr = (void*) &ObjDataTable[(int)Falcon4ClassTable[i].dataPtr];

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 81					; 00000051H
	mov	eax, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	ecx, DWORD PTR [eax+edx+77]
	imul	ecx, 54					; 00000036H
	add	ecx, DWORD PTR ?ObjDataTable@@3PAUObjClassDataType@@A ; ObjDataTable
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 81					; 00000051H
	mov	eax, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	DWORD PTR [eax+edx+77], ecx
	jmp	$LN6@LoadClassT
$LN14@LoadClassT:

; 218  : 			}
; 219  : 			else if (Falcon4ClassTable[i].dataType == DTYPE_WEAPON)

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 81					; 00000051H
	mov	edx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	movzx	eax, BYTE PTR [edx+ecx+76]
	cmp	eax, 6
	jne	SHORT $LN11@LoadClassT

; 220  : 			{
; 221  : 				ShiAssert((int)Falcon4ClassTable[i].dataPtr < NumWeaponTypes);
; 222  : 				WeaponDataTable[(int)Falcon4ClassTable[i].dataPtr].Index = i;

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 81					; 00000051H
	mov	edx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	eax, DWORD PTR [edx+ecx+77]
	imul	eax, 60					; 0000003cH
	mov	ecx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	mov	dx, WORD PTR _i$[ebp]
	mov	WORD PTR [ecx+eax], dx

; 223  : 				Falcon4ClassTable[i].dataPtr = (void*) &WeaponDataTable[(int)Falcon4ClassTable[i].dataPtr];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 81					; 00000051H
	mov	ecx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	edx, DWORD PTR [ecx+eax+77]
	imul	edx, 60					; 0000003cH
	add	edx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 81					; 00000051H
	mov	ecx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	DWORD PTR [ecx+eax+77], edx
	jmp	$LN6@LoadClassT
$LN11@LoadClassT:

; 224  : 			}
; 225  : 			else if (Falcon4ClassTable[i].dataType == DTYPE_FEATURE)

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 81					; 00000051H
	mov	eax, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	movzx	ecx, BYTE PTR [eax+edx+76]
	cmp	ecx, 1
	jne	SHORT $LN9@LoadClassT

; 226  : 			{
; 227  : 				ShiAssert((int)Falcon4ClassTable[i].dataPtr < NumFeatureEntries);
; 228  : 				FeatureDataTable[(int)Falcon4ClassTable[i].dataPtr].Index = i;

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 81					; 00000051H
	mov	eax, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	ecx, DWORD PTR [eax+edx+77]
	imul	ecx, 60					; 0000003cH
	mov	edx, DWORD PTR ?FeatureDataTable@@3PAUFeatureClassDataType@@A ; FeatureDataTable
	mov	ax, WORD PTR _i$[ebp]
	mov	WORD PTR [edx+ecx], ax

; 229  : 				Falcon4ClassTable[i].dataPtr = (void*) &FeatureDataTable[(int)Falcon4ClassTable[i].dataPtr];

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 81					; 00000051H
	mov	edx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	eax, DWORD PTR [edx+ecx+77]
	imul	eax, 60					; 0000003cH
	add	eax, DWORD PTR ?FeatureDataTable@@3PAUFeatureClassDataType@@A ; FeatureDataTable
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 81					; 00000051H
	mov	edx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	DWORD PTR [edx+ecx+77], eax
	jmp	$LN6@LoadClassT
$LN9@LoadClassT:

; 230  : 			}
; 231  : 			else if (Falcon4ClassTable[i].dataType == DTYPE_VEHICLE)

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 81					; 00000051H
	mov	ecx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	movzx	edx, BYTE PTR [ecx+eax+76]
	cmp	edx, 5
	jne	SHORT $LN7@LoadClassT

; 232  : 			{
; 233  : 				ShiAssert((int)Falcon4ClassTable[i].dataPtr < NumVehicleEntries);
; 234  : 				VehicleDataTable[(int)Falcon4ClassTable[i].dataPtr].Index = i;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 81					; 00000051H
	mov	ecx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	edx, DWORD PTR [ecx+eax+77]
	imul	edx, 160				; 000000a0H
	mov	eax, DWORD PTR ?VehicleDataTable@@3PAUVehicleClassDataType@@A ; VehicleDataTable
	mov	cx, WORD PTR _i$[ebp]
	mov	WORD PTR [eax+edx], cx

; 235  : 				Falcon4ClassTable[i].dataPtr = (void*) &VehicleDataTable[(int)Falcon4ClassTable[i].dataPtr];

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 81					; 00000051H
	mov	eax, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	ecx, DWORD PTR [eax+edx+77]
	imul	ecx, 160				; 000000a0H
	add	ecx, DWORD PTR ?VehicleDataTable@@3PAUVehicleClassDataType@@A ; VehicleDataTable
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 81					; 00000051H
	mov	eax, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	DWORD PTR [eax+edx+77], ecx

; 236  : 			}
; 237  : 			else

	jmp	SHORT $LN6@LoadClassT
$LN7@LoadClassT:

; 238  : 				Falcon4ClassTable[i].dataPtr = NULL;

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 81					; 00000051H
	mov	edx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	DWORD PTR [edx+ecx+77], 0
$LN6@LoadClassT:

; 239  : 		}
; 240  : 	}

	jmp	$LN19@LoadClassT
$LN18@LoadClassT:

; 241  : 	ReadClassTable();

	call	?ReadClassTable@@YAXXZ			; ReadClassTable

; 242  : 	// Update some precalculated statistics
; 243  : 	// KCK: I do these precalculations in the classtable builder now.. 
; 244  : 	//	UpdateVehicleCombatStatistics();
; 245  : 	//	UpdateFeatureCombatStatistics();
; 246  : 	//	UpdateUnitCombatStatistics();
; 247  : 	//	UpdateObjectiveCombatStatistics();
; 248  : 	// Set our special indices;
; 249  : 	SFXType = GetClassID(DOMAIN_ABSTRACT,CLASS_SFX,TYPE_ANY,STYPE_ANY,SPTYPE_ANY,VU_ANY,VU_ANY,VU_ANY);

	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	5
	push	1
	call	?GetClassID@@YAHEEEEEEEE@Z		; GetClassID
	add	esp, 32					; 00000020H
	mov	DWORD PTR ?SFXType@@3HA, eax		; SFXType

; 250  : 	F4SessionType = GetClassID(DOMAIN_ABSTRACT,CLASS_SESSION,TYPE_ANY,STYPE_ANY,SPTYPE_ANY,VU_ANY,VU_ANY,VU_ANY);

	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	10					; 0000000aH
	push	1
	call	?GetClassID@@YAHEEEEEEEE@Z		; GetClassID
	add	esp, 32					; 00000020H
	mov	DWORD PTR ?F4SessionType@@3HA, eax	; F4SessionType

; 251  : 	F4GroupType = GetClassID(DOMAIN_ABSTRACT,CLASS_GROUP,TYPE_ANY,STYPE_ANY,SPTYPE_ANY,VU_ANY,VU_ANY,VU_ANY);

	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	12					; 0000000cH
	push	1
	call	?GetClassID@@YAHEEEEEEEE@Z		; GetClassID
	add	esp, 32					; 00000020H
	mov	DWORD PTR ?F4GroupType@@3HA, eax	; F4GroupType

; 252  : 	F4GameType = GetClassID(DOMAIN_ABSTRACT,CLASS_GAME,TYPE_ANY,STYPE_ANY,SPTYPE_ANY,VU_ANY,VU_ANY,VU_ANY);

	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	11					; 0000000bH
	push	1
	call	?GetClassID@@YAHEEEEEEEE@Z		; GetClassID
	add	esp, 32					; 00000020H
	mov	DWORD PTR ?F4GameType@@3HA, eax		; F4GameType

; 253  : 	F4FlyingEyeType = GetClassID(DOMAIN_ABSTRACT,CLASS_ABSTRACT,TYPE_FLYING_EYE,STYPE_ANY,SPTYPE_ANY,VU_ANY,VU_ANY,VU_ANY);

	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	1
	push	0
	push	1
	call	?GetClassID@@YAHEEEEEEEE@Z		; GetClassID
	add	esp, 32					; 00000020H
	mov	DWORD PTR ?F4FlyingEyeType@@3HA, eax	; F4FlyingEyeType

; 254  : 	F4GenericTruckType = GetClassID(DOMAIN_LAND,CLASS_VEHICLE,TYPE_WHEELED,STYPE_WHEELED_TRANSPORT,SPTYPE_KrAz255B,VU_ANY,VU_ANY,VU_ANY);

	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	6
	push	8
	push	4
	push	7
	push	3
	call	?GetClassID@@YAHEEEEEEEE@Z		; GetClassID
	add	esp, 32					; 00000020H
	mov	DWORD PTR ?F4GenericTruckType@@3HA, eax	; F4GenericTruckType

; 255  : 	//	KCK: Temporary until the classtable gets rebuilt - then replace with the commented out line
; 256  : 	// F4GenericUSTruckType = GetClassID(DOMAIN_LAND,CLASS_VEHICLE,TYPE_WHEELED,STYPE_WHEELED_TRANSPORT,SPTYPE_HUMMVCARGO,VU_ANY,VU_ANY,VU_ANY);
; 257  : 	F4GenericUSTruckType = 534;

	mov	DWORD PTR ?F4GenericUSTruckType@@3HA, 534 ; F4GenericUSTruckType, 00000216H

; 258  : 	//	F4GenericCrewType = GetClassID(DOMAIN_LAND,CLASS_VEHICLE,TYPE_FOOT,STYPE_FOOT_SQUAD,SPTYPE_DPRKARTSQD,VU_ANY,VU_ANY,VU_ANY);
; 259  : 	// Set our special rack Ids
; 260  : 	i = GetClassID(DOMAIN_ABSTRACT, CLASS_WEAPON, TYPE_RACK, STYPE_RACK, SPTYPE_SINGLE, VU_ANY, VU_ANY, VU_ANY);

	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	1
	push	1
	push	4
	push	8
	push	1
	call	?GetClassID@@YAHEEEEEEEE@Z		; GetClassID
	add	esp, 32					; 00000020H
	mov	DWORD PTR _i$[ebp], eax

; 261  : 	gRackId_Single_Rack = (short)(((int)Falcon4ClassTable[i].dataPtr - (int)WeaponDataTable) / sizeof(WeaponClassDataType));

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 81					; 00000051H
	mov	ecx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	eax, DWORD PTR [ecx+eax+77]
	sub	eax, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	xor	edx, edx
	mov	ecx, 60					; 0000003cH
	div	ecx
	mov	WORD PTR ?gRackId_Single_Rack@@3FA, ax	; gRackId_Single_Rack

; 262  : 	i = GetClassID(DOMAIN_ABSTRACT, CLASS_WEAPON, TYPE_RACK, STYPE_RACK, SPTYPE_TRIPLE, VU_ANY, VU_ANY, VU_ANY);

	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	2
	push	1
	push	4
	push	8
	push	1
	call	?GetClassID@@YAHEEEEEEEE@Z		; GetClassID
	add	esp, 32					; 00000020H
	mov	DWORD PTR _i$[ebp], eax

; 263  : 	gRackId_Triple_Rack = (short)(((int)Falcon4ClassTable[i].dataPtr - (int)WeaponDataTable) / sizeof(WeaponClassDataType));

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 81					; 00000051H
	mov	eax, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	eax, DWORD PTR [eax+edx+77]
	sub	eax, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	xor	edx, edx
	mov	ecx, 60					; 0000003cH
	div	ecx
	mov	WORD PTR ?gRackId_Triple_Rack@@3FA, ax	; gRackId_Triple_Rack

; 264  : 	i = GetClassID(DOMAIN_ABSTRACT, CLASS_WEAPON, TYPE_RACK, STYPE_RACK, SPTYPE_QUAD, VU_ANY, VU_ANY, VU_ANY);

	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	4
	push	1
	push	4
	push	8
	push	1
	call	?GetClassID@@YAHEEEEEEEE@Z		; GetClassID
	add	esp, 32					; 00000020H
	mov	DWORD PTR _i$[ebp], eax

; 265  : 	gRackId_Quad_Rack = (short)(((int)Falcon4ClassTable[i].dataPtr - (int)WeaponDataTable) / sizeof(WeaponClassDataType));

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 81					; 00000051H
	mov	eax, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	eax, DWORD PTR [eax+edx+77]
	sub	eax, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	xor	edx, edx
	mov	ecx, 60					; 0000003cH
	div	ecx
	mov	WORD PTR ?gRackId_Quad_Rack@@3FA, ax	; gRackId_Quad_Rack

; 266  : 	i = GetClassID(DOMAIN_ABSTRACT, CLASS_WEAPON, TYPE_RACK, STYPE_RACK, SPTYPE_SIX, VU_ANY, VU_ANY, VU_ANY);

	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	3
	push	1
	push	4
	push	8
	push	1
	call	?GetClassID@@YAHEEEEEEEE@Z		; GetClassID
	add	esp, 32					; 00000020H
	mov	DWORD PTR _i$[ebp], eax

; 267  : 	gRackId_Six_Rack = (short)(((int)Falcon4ClassTable[i].dataPtr - (int)WeaponDataTable) / sizeof(WeaponClassDataType));

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 81					; 00000051H
	mov	eax, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	eax, DWORD PTR [eax+edx+77]
	sub	eax, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	xor	edx, edx
	mov	ecx, 60					; 0000003cH
	div	ecx
	mov	WORD PTR ?gRackId_Six_Rack@@3FA, ax	; gRackId_Six_Rack

; 268  : 	i = GetClassID(DOMAIN_ABSTRACT, CLASS_WEAPON, TYPE_RACK, STYPE_RACK, SPTYPE_2RAIL, VU_ANY, VU_ANY, VU_ANY);

	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	6
	push	1
	push	4
	push	8
	push	1
	call	?GetClassID@@YAHEEEEEEEE@Z		; GetClassID
	add	esp, 32					; 00000020H
	mov	DWORD PTR _i$[ebp], eax

; 269  : 	gRackId_Two_Rack = (short)(((int)Falcon4ClassTable[i].dataPtr - (int)WeaponDataTable) / sizeof(WeaponClassDataType));

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 81					; 00000051H
	mov	eax, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	eax, DWORD PTR [eax+edx+77]
	sub	eax, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	xor	edx, edx
	mov	ecx, 60					; 0000003cH
	div	ecx
	mov	WORD PTR ?gRackId_Two_Rack@@3FA, ax	; gRackId_Two_Rack

; 270  : 	i = GetClassID(DOMAIN_ABSTRACT, CLASS_WEAPON, TYPE_RACK, STYPE_RACK, SPTYPE_SINGLE_AA, VU_ANY, VU_ANY, VU_ANY);

	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	5
	push	1
	push	4
	push	8
	push	1
	call	?GetClassID@@YAHEEEEEEEE@Z		; GetClassID
	add	esp, 32					; 00000020H
	mov	DWORD PTR _i$[ebp], eax

; 271  : 	gRackId_Single_AA_Rack = (short)(((int)Falcon4ClassTable[i].dataPtr - (int)WeaponDataTable) / sizeof(WeaponClassDataType));

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 81					; 00000051H
	mov	eax, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	eax, DWORD PTR [eax+edx+77]
	sub	eax, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	xor	edx, edx
	mov	ecx, 60					; 0000003cH
	div	ecx
	mov	WORD PTR ?gRackId_Single_AA_Rack@@3FA, ax ; gRackId_Single_AA_Rack

; 272  : 	i = GetClassID(DOMAIN_ABSTRACT, CLASS_WEAPON, TYPE_RACK, STYPE_RACK, SPTYPE_MAVRACK, VU_ANY, VU_ANY, VU_ANY);

	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	7
	push	1
	push	4
	push	8
	push	1
	call	?GetClassID@@YAHEEEEEEEE@Z		; GetClassID
	add	esp, 32					; 00000020H
	mov	DWORD PTR _i$[ebp], eax

; 273  : 	gRackId_Mav_Rack = (short)(((int)Falcon4ClassTable[i].dataPtr - (int)WeaponDataTable) / sizeof(WeaponClassDataType));

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 81					; 00000051H
	mov	eax, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	eax, DWORD PTR [eax+edx+77]
	sub	eax, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	xor	edx, edx
	mov	ecx, 60					; 0000003cH
	div	ecx
	mov	WORD PTR ?gRackId_Mav_Rack@@3FA, ax	; gRackId_Mav_Rack

; 274  : 	// Find our "Rocket Type". That is, the rocket all aircraft rocket pods will fire.
; 275  : 	i = GetClassID (DOMAIN_AIR, CLASS_VEHICLE, TYPE_ROCKET, STYPE_ROCKET, SPTYPE_2_75mm, VU_ANY, VU_ANY, VU_ANY);

	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	4
	push	2
	push	8
	push	7
	push	2
	call	?GetClassID@@YAHEEEEEEEE@Z		; GetClassID
	add	esp, 32					; 00000020H
	mov	DWORD PTR _i$[ebp], eax

; 276  : 	gRocketId = (short)(((int)Falcon4ClassTable[i].dataPtr - (int)WeaponDataTable) / sizeof(WeaponClassDataType));

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 81					; 00000051H
	mov	eax, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	eax, DWORD PTR [eax+edx+77]
	sub	eax, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	xor	edx, edx
	mov	ecx, 60					; 0000003cH
	div	ecx
	mov	WORD PTR ?gRocketId@@3FA, ax		; gRocketId

; 277  : 	// Special hardcoded class data for sessions/groups/games
; 278  : 	WriteClassTable();

	call	?WriteClassTable@@YAXXZ			; WriteClassTable

; 279  : 	Falcon4ClassTable[F4SessionType].vuClassData.managementDomain_ = VU_GLOBAL_DOMAIN;

	mov	edx, DWORD PTR ?F4SessionType@@3HA	; F4SessionType
	imul	edx, 81					; 00000051H
	mov	eax, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	BYTE PTR [eax+edx+50], 0

; 280  : 	Falcon4ClassTable[F4SessionType].vuClassData.global_ = TRUE;

	mov	ecx, DWORD PTR ?F4SessionType@@3HA	; F4SessionType
	imul	ecx, 81					; 00000051H
	mov	edx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	BYTE PTR [edx+ecx+55], 1

; 281  : 	Falcon4ClassTable[F4SessionType].vuClassData.persistent_ = TRUE;

	mov	eax, DWORD PTR ?F4SessionType@@3HA	; F4SessionType
	imul	eax, 81					; 00000051H
	mov	ecx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	BYTE PTR [ecx+eax+56], 1

; 282  : 	// KCK: High disconnect time for comms debugging
; 283  : 	if (F4SessionAliveTimeout)

	cmp	DWORD PTR ?F4SessionAliveTimeout@@3HA, 0 ; F4SessionAliveTimeout
	je	SHORT $LN5@LoadClassT

; 284  : 	{
; 285  : 		Falcon4ClassTable[F4SessionType].vuClassData.updateTolerance_ = F4SessionAliveTimeout * 1000;

	mov	edx, DWORD PTR ?F4SessionAliveTimeout@@3HA ; F4SessionAliveTimeout
	imul	edx, 1000				; 000003e8H
	mov	eax, DWORD PTR ?F4SessionType@@3HA	; F4SessionType
	imul	eax, 81					; 00000051H
	mov	ecx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	DWORD PTR [ecx+eax+20], edx

; 286  : 	}
; 287  : 	else

	jmp	SHORT $LN4@LoadClassT
$LN5@LoadClassT:

; 288  : 	{
; 289  : #ifdef DEBUG
; 290  : 		Falcon4ClassTable[F4SessionType].vuClassData.updateTolerance_ = 30000;			// MS before a session times out
; 291  : #else
; 292  : 		Falcon4ClassTable[F4SessionType].vuClassData.updateTolerance_ = g_nSessionTimeout*1000;			// MS before a session times out

	mov	edx, DWORD PTR ?g_nSessionTimeout@@3HA	; g_nSessionTimeout
	imul	edx, 1000				; 000003e8H
	mov	eax, DWORD PTR ?F4SessionType@@3HA	; F4SessionType
	imul	eax, 81					; 00000051H
	mov	ecx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	DWORD PTR [ecx+eax+20], edx
$LN4@LoadClassT:

; 293  : #endif
; 294  : 	}
; 295  : 
; 296  : 	if (F4SessionUpdateTime)

	cmp	DWORD PTR ?F4SessionUpdateTime@@3HA, 0	; F4SessionUpdateTime
	je	SHORT $LN3@LoadClassT

; 297  : 	{
; 298  : 		Falcon4ClassTable[F4SessionType].vuClassData.updateRate_ = F4SessionUpdateTime * 1000;

	mov	edx, DWORD PTR ?F4SessionUpdateTime@@3HA ; F4SessionUpdateTime
	imul	edx, 1000				; 000003e8H
	mov	eax, DWORD PTR ?F4SessionType@@3HA	; F4SessionType
	imul	eax, 81					; 00000051H
	mov	ecx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	DWORD PTR [ecx+eax+16], edx

; 299  : 	}
; 300  : 	else

	jmp	SHORT $LN2@LoadClassT
$LN3@LoadClassT:

; 301  : 	{
; 302  : 		Falcon4ClassTable[F4SessionType].vuClassData.updateRate_ = g_nSessionUpdateRate * 1000;				// MS before a session update

	mov	edx, DWORD PTR ?g_nSessionUpdateRate@@3HA ; g_nSessionUpdateRate
	imul	edx, 1000				; 000003e8H
	mov	eax, DWORD PTR ?F4SessionType@@3HA	; F4SessionType
	imul	eax, 81					; 00000051H
	mov	ecx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	DWORD PTR [ecx+eax+16], edx
$LN2@LoadClassT:

; 303  : 	}
; 304  : 	Falcon4ClassTable[F4GroupType].vuClassData.updateRate_ = Falcon4ClassTable[F4SessionType].vuClassData.updateRate_;

	mov	edx, DWORD PTR ?F4SessionType@@3HA	; F4SessionType
	imul	edx, 81					; 00000051H
	mov	eax, DWORD PTR ?F4GroupType@@3HA	; F4GroupType
	imul	eax, 81					; 00000051H
	mov	ecx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	esi, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	edx, DWORD PTR [esi+edx+16]
	mov	DWORD PTR [ecx+eax+16], edx

; 305  : 
; 306  : 	Falcon4ClassTable[F4GroupType].vuClassData.managementDomain_ = VU_GLOBAL_DOMAIN;

	mov	eax, DWORD PTR ?F4GroupType@@3HA	; F4GroupType
	imul	eax, 81					; 00000051H
	mov	ecx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	BYTE PTR [ecx+eax+50], 0

; 307  : 	Falcon4ClassTable[F4GroupType].vuClassData.global_ = TRUE;

	mov	edx, DWORD PTR ?F4GroupType@@3HA	; F4GroupType
	imul	edx, 81					; 00000051H
	mov	eax, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	BYTE PTR [eax+edx+55], 1

; 308  : 	Falcon4ClassTable[F4GroupType].vuClassData.persistent_ = FALSE;

	mov	ecx, DWORD PTR ?F4GroupType@@3HA	; F4GroupType
	imul	ecx, 81					; 00000051H
	mov	edx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	BYTE PTR [edx+ecx+56], 0

; 309  : 	Falcon4ClassTable[F4GameType].vuClassData.managementDomain_ = VU_GLOBAL_DOMAIN;

	mov	eax, DWORD PTR ?F4GameType@@3HA		; F4GameType
	imul	eax, 81					; 00000051H
	mov	ecx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	BYTE PTR [ecx+eax+50], 0

; 310  : 	Falcon4ClassTable[F4GameType].vuClassData.global_ = TRUE;

	mov	edx, DWORD PTR ?F4GameType@@3HA		; F4GameType
	imul	edx, 81					; 00000051H
	mov	eax, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	BYTE PTR [eax+edx+55], 1

; 311  : 	Falcon4ClassTable[F4GameType].vuClassData.persistent_ = FALSE;

	mov	ecx, DWORD PTR ?F4GameType@@3HA		; F4GameType
	imul	ecx, 81					; 00000051H
	mov	edx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	BYTE PTR [edx+ecx+56], 0

; 312  : 
; 313  : 	Falcon4ClassTable[F4FlyingEyeType].vuClassData.fineUpdateMultiplier_ = 0.2F;

	mov	eax, DWORD PTR ?F4FlyingEyeType@@3HA	; F4FlyingEyeType
	imul	eax, 81					; 00000051H
	mov	ecx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	movss	xmm0, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR [ecx+eax+32], xmm0

; 314  : #endif
; 315  : #endif
; 316  : #endif
; 317  : 	ReadClassTable();

	call	?ReadClassTable@@YAXXZ			; ReadClassTable

; 318  : 
; 319  : 	if (ErrorFH)

	cmp	DWORD PTR ?ErrorFH@@3PAU_iobuf@@A, 0	; ErrorFH
	je	SHORT $LN1@LoadClassT

; 320  : 		fclose(ErrorFH); // MLR 5/15/2004 - 

	mov	edx, DWORD PTR ?ErrorFH@@3PAU_iobuf@@A	; ErrorFH
	push	edx
	call	_fclose
	add	esp, 4
$LN1@LoadClassT:

; 321  : 	return 1;

	mov	eax, 1
$LN42@LoadClassT:

; 322  : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?LoadClassTable@@YAHPAD@Z ENDP				; LoadClassTable
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\string.h
;	COMDAT ?strchr@@YAPADPADH@Z
_TEXT	SEGMENT
__Str$ = 8						; size = 4
__Ch$ = 12						; size = 4
?strchr@@YAPADPADH@Z PROC				; strchr, COMDAT

; 218  : 	{ return (char*)strchr((const char*)_Str, _Ch); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Ch$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Str$[ebp]
	push	ecx
	call	_strchr
	add	esp, 8
	pop	ebp
	ret	0
?strchr@@YAPADPADH@Z ENDP				; strchr
_TEXT	ENDS
END
