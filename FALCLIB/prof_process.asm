; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\FALCLIB\prof_process.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_SPEEDSTEP_DETECTION_RATIO
_DATA	SEGMENT
COMM	_Prof_zones:DWORD:0200H
_DATA	ENDS
_BSS	SEGMENT
_expand	DD	01H DUP (?)
_recurse DD	01H DUP (?)
_BSS	ENDS
CONST	SEGMENT
_SPEEDSTEP_DETECTION_RATIO DQ 03fb47ae147ae147br ; 0.08
CONST	ENDS
_DATA	SEGMENT
_slot	DD	01H
_DATA	ENDS
PUBLIC	_Prof_update
PUBLIC	_Prof_set_report_mode
PUBLIC	_Prof_get_cursor
PUBLIC	_Prof_move_cursor
PUBLIC	_Prof_select
PUBLIC	_Prof_select_parent
PUBLIC	_Prof_move_frame
PUBLIC	_Prof_set_smoothing
PUBLIC	_Prof_set_frame
PUBLIC	_Prof_set_cursor
PUBLIC	_Prof_dumpFile
PUBLIC	_Prof_dumpOverlay
PUBLIC	_Prof_set_recursion
PUBLIC	_Prof_free_report
PUBLIC	_Prof_create_report
PUBLIC	_Prof_graph
PUBLIC	_Prof_init_highlevel
PUBLIC	??_C@_07LFEGLFGM@?$CKerror?$CK?$AA@		; `string'
PUBLIC	??_C@_09LDMPODMP@sort?5self?$AA@		; `string'
PUBLIC	??_C@_09MPFGBGDO@sort?5hier?$AA@		; `string'
PUBLIC	??_C@_0BA@HDDAHLEG@sort?5call?5graph?$AA@	; `string'
PUBLIC	??_C@_0CC@LBDOLJGI@?$CF3?43lf?5ms?1frame?5?$CIfps?3?5?$CF3?42lf?$CJ?5?5?$CF@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_01LKDEMHDF@s?$AA@				; `string'
PUBLIC	??_C@_0BC@OEHLFAIG@?5?9?5?$CFd?5frame?$CFs?5ago?$AA@ ; `string'
PUBLIC	??_C@_0BB@HFDDJBNF@?5?9?5current?5frame?$AA@	; `string'
PUBLIC	??_C@_0FB@HPHDLFKA@WARNING?3?5SpeedStep?9like?5timer?5in@ ; `string'
PUBLIC	??_C@_04LDDJGOBB@zone?$AA@			; `string'
PUBLIC	??_C@_04IFKEJOFI@hier?$AA@			; `string'
PUBLIC	??_C@_04PJDNGLKJ@self?$AA@			; `string'
PUBLIC	??_C@_05IOMEMJEC@count?$AA@			; `string'
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@3eb0c6f7a0b5ed8d
PUBLIC	__real@3f000000
PUBLIC	__real@3f50624dd2f1a9fc
PUBLIC	__real@3f800000
PUBLIC	__real@3f847ae140000000
PUBLIC	__real@3fb99999a0000000
PUBLIC	__real@3fd0000000000000
PUBLIC	__real@3fe99999a0000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@40000000
PUBLIC	__real@4000000000000000
PUBLIC	__real@4004000000000000
PUBLIC	__real@408f400000000000
PUBLIC	__real@412e848000000000
EXTRN	_fabs:PROC
EXTRN	_sqrt:PROC
EXTRN	_qsort:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	_sprintf:PROC
EXTRN	_strcat:PROC
EXTRN	_strlen:PROC
EXTRN	__strdup:PROC
EXTRN	_Prof_traverse:PROC
EXTRN	_Prof_num_zones:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_zone_history DD 010000H DUP (?)
_frame_time DB	0230H DUP (?)
_times_to_reach_90_percent DQ 03H DUP (?)
_update_index DD 01H DUP (?)
	ALIGN	8

_last_update_time DQ 01H DUP (?)
_displayed_quantity DD 01H DUP (?)
_history_index DD 01H DUP (?)
_display_frame DD 01H DUP (?)
_speedstep_warning DD 01H DUP (?)
_uncounted DD	01H DUP (?)
_cursor	DD	01H DUP (?)
_update_cursor DD 01H DUP (?)
_BSS	ENDS
;	COMDAT __real@412e848000000000
CONST	SEGMENT
__real@412e848000000000 DQ 0412e848000000000r	; 1e+006
CONST	ENDS
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
;	COMDAT __real@4004000000000000
CONST	SEGMENT
__real@4004000000000000 DQ 04004000000000000r	; 2.5
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fe99999a0000000
CONST	SEGMENT
__real@3fe99999a0000000 DQ 03fe99999a0000000r	; 0.8
CONST	ENDS
;	COMDAT __real@3fd0000000000000
CONST	SEGMENT
__real@3fd0000000000000 DQ 03fd0000000000000r	; 0.25
CONST	ENDS
;	COMDAT __real@3fb99999a0000000
CONST	SEGMENT
__real@3fb99999a0000000 DQ 03fb99999a0000000r	; 0.1
CONST	ENDS
;	COMDAT __real@3f847ae140000000
CONST	SEGMENT
__real@3f847ae140000000 DQ 03f847ae140000000r	; 0.01
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f50624dd2f1a9fc
CONST	SEGMENT
__real@3f50624dd2f1a9fc DQ 03f50624dd2f1a9fcr	; 0.001
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3eb0c6f7a0b5ed8d
CONST	SEGMENT
__real@3eb0c6f7a0b5ed8d DQ 03eb0c6f7a0b5ed8dr	; 1e-006
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_05IOMEMJEC@count?$AA@
CONST	SEGMENT
??_C@_05IOMEMJEC@count?$AA@ DB 'count', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PJDNGLKJ@self?$AA@
CONST	SEGMENT
??_C@_04PJDNGLKJ@self?$AA@ DB 'self', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04IFKEJOFI@hier?$AA@
CONST	SEGMENT
??_C@_04IFKEJOFI@hier?$AA@ DB 'hier', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LDDJGOBB@zone?$AA@
CONST	SEGMENT
??_C@_04LDDJGOBB@zone?$AA@ DB 'zone', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FB@HPHDLFKA@WARNING?3?5SpeedStep?9like?5timer?5in@
CONST	SEGMENT
??_C@_0FB@HPHDLFKA@WARNING?3?5SpeedStep?9like?5timer?5in@ DB 'WARNING: Sp'
	DB	'eedStep-like timer inconsistencies detected.  Results are unr'
	DB	'eliable!', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HFDDJBNF@?5?9?5current?5frame?$AA@
CONST	SEGMENT
??_C@_0BB@HFDDJBNF@?5?9?5current?5frame?$AA@ DB ' - current frame', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@OEHLFAIG@?5?9?5?$CFd?5frame?$CFs?5ago?$AA@
CONST	SEGMENT
??_C@_0BC@OEHLFAIG@?5?9?5?$CFd?5frame?$CFs?5ago?$AA@ DB ' - %d frame%s ag'
	DB	'o', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_01LKDEMHDF@s?$AA@
CONST	SEGMENT
??_C@_01LKDEMHDF@s?$AA@ DB 's', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@LBDOLJGI@?$CF3?43lf?5ms?1frame?5?$CIfps?3?5?$CF3?42lf?$CJ?5?5?$CF@
CONST	SEGMENT
??_C@_0CC@LBDOLJGI@?$CF3?43lf?5ms?1frame?5?$CIfps?3?5?$CF3?42lf?$CJ?5?5?$CF@ DB '%'
	DB	'3.3lf ms/frame (fps: %3.2lf)  %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HDDAHLEG@sort?5call?5graph?$AA@
CONST	SEGMENT
??_C@_0BA@HDDAHLEG@sort?5call?5graph?$AA@ DB 'sort call graph', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09MPFGBGDO@sort?5hier?$AA@
CONST	SEGMENT
??_C@_09MPFGBGDO@sort?5hier?$AA@ DB 'sort hier', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09LDMPODMP@sort?5self?$AA@
CONST	SEGMENT
??_C@_09LDMPODMP@sort?5self?$AA@ DB 'sort self', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07LFEGLFGM@?$CKerror?$CK?$AA@
CONST	SEGMENT
??_C@_07LFEGLFGM@?$CKerror?$CK?$AA@ DB '*error*', 00H	; `string'
CONST	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\prof_process.c
_TEXT	SEGMENT
_h$ = -8						; size = 4
_n$ = -4						; size = 4
_z$ = 8							; size = 4
_id	PROC

; 1042 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1043 :    // hash the string so that the id is consistent from
; 1044 :    // run to run (rather than using the pointer itself which isn't)
; 1045 :    // @TODO: only compute this at zone init time?
; 1046 : 
; 1047 :    unsigned int h = 0x55555555;

	mov	DWORD PTR _h$[ebp], 1431655765		; 55555555H

; 1048 :    char *n = z->name;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _n$[ebp], ecx
$LN2@id:

; 1049 : 
; 1050 :    while (*n)

	mov	edx, DWORD PTR _n$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN1@id

; 1051 :       h = (h << 5) + (h >> 27) + *n++;

	mov	ecx, DWORD PTR _h$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _h$[ebp]
	shr	edx, 27					; 0000001bH
	add	ecx, edx
	mov	eax, DWORD PTR _n$[ebp]
	movsx	edx, BYTE PTR [eax]
	add	ecx, edx
	mov	DWORD PTR _h$[ebp], ecx
	mov	eax, DWORD PTR _n$[ebp]
	add	eax, 1
	mov	DWORD PTR _n$[ebp], eax
	jmp	SHORT $LN2@id
$LN1@id:

; 1052 : 
; 1053 :    return h;

	mov	eax, DWORD PTR _h$[ebp]

; 1054 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_id	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\prof_process.c
_TEXT	SEGMENT
_b$ = -8						; size = 4
_a$ = -4						; size = 4
_p$ = 8							; size = 4
_q$ = 12						; size = 4
_pob_expand_compare PROC

; 738  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi

; 739  :    Prof_Report_Record * a = (Prof_Report_Record *) p;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR _a$[ebp], eax

; 740  :    Prof_Report_Record * b = (Prof_Report_Record *) q;

	mov	ecx, DWORD PTR _q$[ebp]
	mov	DWORD PTR _b$[ebp], ecx

; 741  : 
; 742  :    if (a->indent != b->indent) {

	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax]
	je	SHORT $LN9@pob_expand

; 743  :       if (a->indent == 5) return -1;

	mov	edx, DWORD PTR _a$[ebp]
	cmp	DWORD PTR [edx], 5
	jne	SHORT $LN8@pob_expand
	or	eax, -1
	jmp	$LN10@pob_expand
$LN8@pob_expand:

; 744  :       if (b->indent == 5) return 1;

	mov	eax, DWORD PTR _b$[ebp]
	cmp	DWORD PTR [eax], 5
	jne	SHORT $LN7@pob_expand
	mov	eax, 1
	jmp	$LN10@pob_expand
$LN7@pob_expand:

; 745  :       if (a->indent == 3) return 1;

	mov	ecx, DWORD PTR _a$[ebp]
	cmp	DWORD PTR [ecx], 3
	jne	SHORT $LN6@pob_expand
	mov	eax, 1
	jmp	$LN10@pob_expand
$LN6@pob_expand:

; 746  :       if (b->indent == 3) return -1;

	mov	edx, DWORD PTR _b$[ebp]
	cmp	DWORD PTR [edx], 3
	jne	SHORT $LN5@pob_expand
	or	eax, -1
	jmp	SHORT $LN10@pob_expand
$LN5@pob_expand:

; 747  :       return 0;

	xor	eax, eax
	jmp	SHORT $LN10@pob_expand
$LN9@pob_expand:

; 748  :    }
; 749  :    if (a->values[1] == b->values[1])

	mov	eax, 8
	shl	eax, 0
	mov	ecx, 8
	shl	ecx, 0
	mov	edx, DWORD PTR _a$[ebp]
	mov	esi, DWORD PTR _b$[ebp]
	movsd	xmm0, QWORD PTR [edx+eax+20]
	ucomisd	xmm0, QWORD PTR [esi+ecx+20]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN4@pob_expand

; 750  :       return 0;

	xor	eax, eax
	jmp	SHORT $LN10@pob_expand
$LN4@pob_expand:

; 751  : 
; 752  :    if (a->values[1] < b->values[1]) {

	mov	eax, 8
	shl	eax, 0
	mov	ecx, 8
	shl	ecx, 0
	mov	edx, DWORD PTR _b$[ebp]
	mov	esi, DWORD PTR _a$[ebp]
	movsd	xmm0, QWORD PTR [edx+ecx+20]
	comisd	xmm0, QWORD PTR [esi+eax+20]
	jbe	SHORT $LN3@pob_expand

; 753  :       if (a->indent == 5) return -1;

	mov	eax, DWORD PTR _a$[ebp]
	cmp	DWORD PTR [eax], 5
	jne	SHORT $LN2@pob_expand
	or	eax, -1
	jmp	SHORT $LN10@pob_expand
$LN2@pob_expand:

; 754  :       return 1;

	mov	eax, 1
	jmp	SHORT $LN10@pob_expand
$LN3@pob_expand:

; 755  :    }
; 756  : 
; 757  :    if (a->indent == 5) return 1;

	mov	ecx, DWORD PTR _a$[ebp]
	cmp	DWORD PTR [ecx], 5
	jne	SHORT $LN1@pob_expand
	mov	eax, 1
	jmp	SHORT $LN10@pob_expand
$LN1@pob_expand:

; 758  :    return -1;

	or	eax, -1
$LN10@pob_expand:

; 759  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_pob_expand_compare ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\prof_process.c
_TEXT	SEGMENT
_a$ = -24						; size = 8
_b$ = -16						; size = 8
tv73 = -8						; size = 4
tv72 = -4						; size = 4
_p$ = 8							; size = 4
_q$ = 12						; size = 4
_pob_compare PROC

; 725  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 726  :    double a = ((Prof_Report_Record *) p)->values[0];

	mov	eax, 8
	imul	eax, 0
	mov	ecx, DWORD PTR _p$[ebp]
	movsd	xmm0, QWORD PTR [ecx+eax+20]
	movsd	QWORD PTR _a$[ebp], xmm0

; 727  :    double b = ((Prof_Report_Record *) q)->values[0];

	mov	edx, 8
	imul	edx, 0
	mov	eax, DWORD PTR _q$[ebp]
	movsd	xmm0, QWORD PTR [eax+edx+20]
	movsd	QWORD PTR _b$[ebp], xmm0

; 728  : 
; 729  :    return (b < a) ? -1 : (b > a);

	movsd	xmm0, QWORD PTR _a$[ebp]
	comisd	xmm0, QWORD PTR _b$[ebp]
	jbe	SHORT $LN5@pob_compar
	mov	DWORD PTR tv73[ebp], -1
	jmp	SHORT $LN6@pob_compar
$LN5@pob_compar:
	movsd	xmm0, QWORD PTR _b$[ebp]
	comisd	xmm0, QWORD PTR _a$[ebp]
	jbe	SHORT $LN3@pob_compar
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN4@pob_compar
$LN3@pob_compar:
	mov	DWORD PTR tv72[ebp], 0
$LN4@pob_compar:
	mov	ecx, DWORD PTR tv72[ebp]
	mov	DWORD PTR tv73[ebp], ecx
$LN6@pob_compar:
	mov	eax, DWORD PTR tv73[ebp]

; 730  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_pob_compare ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\prof_process.c
_TEXT	SEGMENT
_stdev$ = -28						; size = 8
_fabs_value$ = -20					; size = 8
_factor$ = -12						; size = 8
_VARIANCE_TOLERANCE_FACTOR$ = -4			; size = 4
_variance$ = 8						; size = 8
_value$ = 16						; size = 8
_compute_heat PROC

; 699  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 700  :    double factor, stdev;
; 701  :    double fabs_value = fabs(value);

	sub	esp, 8
	movsd	xmm0, QWORD PTR _value$[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR _fabs_value$[ebp]

; 702  :    const float VARIANCE_TOLERANCE_FACTOR = 0.5f;

	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _VARIANCE_TOLERANCE_FACTOR$[ebp], xmm0

; 703  : 
; 704  :    variance = variance - value*value;

	movsd	xmm0, QWORD PTR _value$[ebp]
	mulsd	xmm0, QWORD PTR _value$[ebp]
	movsd	xmm1, QWORD PTR _variance$[ebp]
	subsd	xmm1, xmm0
	movsd	QWORD PTR _variance$[ebp], xmm1

; 705  :    if (variance < 0) variance = 0;

	movsd	xmm0, QWORD PTR __real@0000000000000000
	comisd	xmm0, QWORD PTR _variance$[ebp]
	jbe	SHORT $LN5@compute_he
	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR _variance$[ebp], xmm0
$LN5@compute_he:

; 706  :    stdev = sqrt(variance);

	sub	esp, 8
	movsd	xmm0, QWORD PTR _variance$[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	QWORD PTR _stdev$[ebp]

; 707  : 
; 708  :    if (fabs_value < 0.000001) {

	movsd	xmm0, QWORD PTR __real@3eb0c6f7a0b5ed8d
	comisd	xmm0, QWORD PTR _fabs_value$[ebp]
	jbe	SHORT $LN4@compute_he

; 709  :       return 0;

	fldz
	jmp	SHORT $LN6@compute_he

; 710  :    } else {

	jmp	SHORT $LN3@compute_he
$LN4@compute_he:

; 711  :       factor = (stdev / fabs_value) * (1.0f / VARIANCE_TOLERANCE_FACTOR);

	movsd	xmm0, QWORD PTR _stdev$[ebp]
	divsd	xmm0, QWORD PTR _fabs_value$[ebp]
	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, DWORD PTR _VARIANCE_TOLERANCE_FACTOR$[ebp]
	cvtss2sd xmm1, xmm1
	mulsd	xmm0, xmm1
	movsd	QWORD PTR _factor$[ebp], xmm0
$LN3@compute_he:

; 712  :    }
; 713  : 
; 714  :    if (factor < 0) return 0;

	movsd	xmm0, QWORD PTR __real@0000000000000000
	comisd	xmm0, QWORD PTR _factor$[ebp]
	jbe	SHORT $LN2@compute_he
	fldz
	jmp	SHORT $LN6@compute_he
$LN2@compute_he:

; 715  :    if (factor > 1) return 1;

	movsd	xmm0, QWORD PTR _factor$[ebp]
	comisd	xmm0, QWORD PTR __real@3ff0000000000000
	jbe	SHORT $LN1@compute_he
	fld1
	jmp	SHORT $LN6@compute_he
$LN1@compute_he:

; 716  :    return factor;

	fld	QWORD PTR _factor$[ebp]
$LN6@compute_he:

; 717  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_compute_heat ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\prof_process.c
_TEXT	SEGMENT
tv494 = -116						; size = 8
tv482 = -108						; size = 8
tv471 = -100						; size = 8
tv460 = -92						; size = 8
tv446 = -84						; size = 8
tv432 = -76						; size = 8
tv421 = -68						; size = 8
tv410 = -60						; size = 8
tv397 = -52						; size = 8
tv385 = -44						; size = 8
tv374 = -36						; size = 8
tv363 = -28						; size = 8
tv347 = -20						; size = 8
_r$1 = -12						; size = 4
_r$2 = -8						; size = 4
_d$ = -4						; size = 4
_c$ = 8							; size = 4
_propogate_expanded PROC

; 651  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	push	esi
	push	edi

; 652  :    Profile_Tracker_Data_Record *d = (Profile_Tracker_Data_Record *) c->highlevel;

	mov	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR _d$[ebp], ecx

; 653  :    if (d == NULL) {

	cmp	DWORD PTR _d$[ebp], 0
	jne	SHORT $LN8@propogate_

; 654  :       ++uncounted;

	mov	edx, DWORD PTR _uncounted
	add	edx, 1
	mov	DWORD PTR _uncounted, edx

; 655  :       return;

	jmp	$LN1@propogate_
$LN8@propogate_:

; 656  :    }
; 657  :    if (c->parent->zone && get_value(&d->entry_count) > INT_ZERO_THRESHHOLD) {

	mov	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	cmp	DWORD PTR [ecx+32], 0
	je	SHORT $LN7@propogate_
	mov	edx, DWORD PTR _d$[ebp]
	add	edx, 1120				; 00000460H
	push	edx
	call	_get_value
	add	esp, 4
	fstp	QWORD PTR tv347[ebp]
	movsd	xmm0, QWORD PTR tv347[ebp]
	comisd	xmm0, QWORD PTR __real@3fd0000000000000
	jbe	SHORT $LN7@propogate_

; 658  :       ((Prof_Report_Record *) c->parent->zone->highlevel)[0].prefix = '+';

	mov	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, 64					; 00000040H
	imul	eax, 0
	mov	ecx, DWORD PTR [edx+4]
	mov	BYTE PTR [ecx+eax+12], 43		; 0000002bH

; 659  :       ((Prof_Report_Record *) c->parent->zone->highlevel)[1].prefix = '+';

	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, 64					; 00000040H
	shl	edx, 0
	mov	eax, DWORD PTR [ecx+4]
	mov	BYTE PTR [eax+edx+12], 43		; 0000002bH

; 660  :       ((Prof_Report_Record *) c->parent->zone->highlevel)[2].prefix = '+';

	mov	ecx, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, 64					; 00000040H
	shl	ecx, 1
	mov	edx, DWORD PTR [eax+4]
	mov	BYTE PTR [edx+ecx+12], 43		; 0000002bH
$LN7@propogate_:

; 661  :    }
; 662  : 
; 663  :    if (c->zone == expand) {

	mov	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	cmp	ecx, DWORD PTR _expand
	jne	$LN3@propogate_

; 664  :       Prof_Report_Record *r = (Prof_Report_Record *) expand->highlevel;

	mov	edx, DWORD PTR _expand
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _r$2[ebp], eax

; 665  :       // accumulate this time to ourselves
; 666  :       r[2].values[0] += 1000 * get_value(&d->self_time);

	mov	esi, 64					; 00000040H
	shl	esi, 1
	add	esi, DWORD PTR _r$2[ebp]
	mov	edi, 8
	imul	edi, 0
	mov	ecx, DWORD PTR _d$[ebp]
	push	ecx
	call	_get_value
	add	esp, 4
	fstp	QWORD PTR tv363[ebp]
	movsd	xmm0, QWORD PTR tv363[ebp]
	mulsd	xmm0, QWORD PTR __real@408f400000000000
	addsd	xmm0, QWORD PTR [esi+edi+20]
	mov	edx, 8
	imul	edx, 0
	mov	eax, 64					; 00000040H
	shl	eax, 1
	add	eax, DWORD PTR _r$2[ebp]
	movsd	QWORD PTR [eax+edx+20], xmm0

; 667  :       r[2].values[1] += 1000 * get_value(&d->hierarchical_time);

	mov	esi, 64					; 00000040H
	shl	esi, 1
	add	esi, DWORD PTR _r$2[ebp]
	mov	edi, 8
	shl	edi, 0
	mov	ecx, DWORD PTR _d$[ebp]
	add	ecx, 560				; 00000230H
	push	ecx
	call	_get_value
	add	esp, 4
	fstp	QWORD PTR tv374[ebp]
	movsd	xmm0, QWORD PTR tv374[ebp]
	mulsd	xmm0, QWORD PTR __real@408f400000000000
	addsd	xmm0, QWORD PTR [esi+edi+20]
	mov	edx, 8
	shl	edx, 0
	mov	eax, 64					; 00000040H
	shl	eax, 1
	add	eax, DWORD PTR _r$2[ebp]
	movsd	QWORD PTR [eax+edx+20], xmm0

; 668  :       r[2].values[2] += get_value(&d->entry_count);

	mov	esi, 64					; 00000040H
	shl	esi, 1
	add	esi, DWORD PTR _r$2[ebp]
	mov	edi, 8
	shl	edi, 1
	mov	ecx, DWORD PTR _d$[ebp]
	add	ecx, 1120				; 00000460H
	push	ecx
	call	_get_value
	add	esp, 4
	fstp	QWORD PTR tv385[ebp]
	movsd	xmm0, QWORD PTR tv385[ebp]
	addsd	xmm0, QWORD PTR [esi+edi+20]
	mov	edx, 8
	shl	edx, 1
	mov	eax, 64					; 00000040H
	shl	eax, 1
	add	eax, DWORD PTR _r$2[ebp]
	movsd	QWORD PTR [eax+edx+20], xmm0

; 669  :       if (d->max_recursion > r[2].number && get_value(&d->entry_count) > INT_ZERO_THRESHHOLD)

	mov	ecx, 64					; 00000040H
	shl	ecx, 1
	mov	edx, DWORD PTR _d$[ebp]
	mov	eax, DWORD PTR _r$2[ebp]
	mov	edx, DWORD PTR [edx+1680]
	cmp	edx, DWORD PTR [eax+ecx+8]
	jle	SHORT $LN5@propogate_
	mov	eax, DWORD PTR _d$[ebp]
	add	eax, 1120				; 00000460H
	push	eax
	call	_get_value
	add	esp, 4
	fstp	QWORD PTR tv397[ebp]
	movsd	xmm0, QWORD PTR tv397[ebp]
	comisd	xmm0, QWORD PTR __real@3fd0000000000000
	jbe	SHORT $LN5@propogate_

; 670  :          r[2].number = d->max_recursion;

	mov	ecx, 64					; 00000040H
	shl	ecx, 1
	mov	edx, DWORD PTR _r$2[ebp]
	mov	eax, DWORD PTR _d$[ebp]
	mov	eax, DWORD PTR [eax+1680]
	mov	DWORD PTR [edx+ecx+8], eax
$LN5@propogate_:

; 671  :       // propogate it to the parents
; 672  :       if (c->parent->zone) {

	mov	ecx, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	cmp	DWORD PTR [edx+32], 0
	je	$LN3@propogate_

; 673  :          r = (Prof_Report_Record *) c->parent->zone->highlevel;

	mov	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _r$2[ebp], eax

; 674  :          r[1].values[0] += 1000 * get_value(&d->self_time);

	mov	esi, 64					; 00000040H
	shl	esi, 0
	add	esi, DWORD PTR _r$2[ebp]
	mov	edi, 8
	imul	edi, 0
	mov	ecx, DWORD PTR _d$[ebp]
	push	ecx
	call	_get_value
	add	esp, 4
	fstp	QWORD PTR tv410[ebp]
	movsd	xmm0, QWORD PTR tv410[ebp]
	mulsd	xmm0, QWORD PTR __real@408f400000000000
	addsd	xmm0, QWORD PTR [esi+edi+20]
	mov	edx, 8
	imul	edx, 0
	mov	eax, 64					; 00000040H
	shl	eax, 0
	add	eax, DWORD PTR _r$2[ebp]
	movsd	QWORD PTR [eax+edx+20], xmm0

; 675  :          r[1].values[1] += 1000 * get_value(&d->hierarchical_time);

	mov	esi, 64					; 00000040H
	shl	esi, 0
	add	esi, DWORD PTR _r$2[ebp]
	mov	edi, 8
	shl	edi, 0
	mov	ecx, DWORD PTR _d$[ebp]
	add	ecx, 560				; 00000230H
	push	ecx
	call	_get_value
	add	esp, 4
	fstp	QWORD PTR tv421[ebp]
	movsd	xmm0, QWORD PTR tv421[ebp]
	mulsd	xmm0, QWORD PTR __real@408f400000000000
	addsd	xmm0, QWORD PTR [esi+edi+20]
	mov	edx, 8
	shl	edx, 0
	mov	eax, 64					; 00000040H
	shl	eax, 0
	add	eax, DWORD PTR _r$2[ebp]
	movsd	QWORD PTR [eax+edx+20], xmm0

; 676  :          r[1].values[2] += get_value(&d->entry_count);

	mov	esi, 64					; 00000040H
	shl	esi, 0
	add	esi, DWORD PTR _r$2[ebp]
	mov	edi, 8
	shl	edi, 1
	mov	ecx, DWORD PTR _d$[ebp]
	add	ecx, 1120				; 00000460H
	push	ecx
	call	_get_value
	add	esp, 4
	fstp	QWORD PTR tv432[ebp]
	movsd	xmm0, QWORD PTR tv432[ebp]
	addsd	xmm0, QWORD PTR [esi+edi+20]
	mov	edx, 8
	shl	edx, 1
	mov	eax, 64					; 00000040H
	shl	eax, 0
	add	eax, DWORD PTR _r$2[ebp]
	movsd	QWORD PTR [eax+edx+20], xmm0

; 677  :          d = (Profile_Tracker_Data_Record *) c->parent->highlevel;

	mov	ecx, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR _d$[ebp], eax

; 678  :          if (d->max_recursion > r[1].number && get_value(&d->entry_count) > INT_ZERO_THRESHHOLD)

	mov	ecx, 64					; 00000040H
	shl	ecx, 0
	mov	edx, DWORD PTR _d$[ebp]
	mov	eax, DWORD PTR _r$2[ebp]
	mov	edx, DWORD PTR [edx+1680]
	cmp	edx, DWORD PTR [eax+ecx+8]
	jle	SHORT $LN3@propogate_
	mov	eax, DWORD PTR _d$[ebp]
	add	eax, 1120				; 00000460H
	push	eax
	call	_get_value
	add	esp, 4
	fstp	QWORD PTR tv446[ebp]
	movsd	xmm0, QWORD PTR tv446[ebp]
	comisd	xmm0, QWORD PTR __real@3fd0000000000000
	jbe	SHORT $LN3@propogate_

; 679  :             r[1].number = d->max_recursion;

	mov	ecx, 64					; 00000040H
	shl	ecx, 0
	mov	edx, DWORD PTR _r$2[ebp]
	mov	eax, DWORD PTR _d$[ebp]
	mov	eax, DWORD PTR [eax+1680]
	mov	DWORD PTR [edx+ecx+8], eax
$LN3@propogate_:

; 680  :       }
; 681  :    }
; 682  :    
; 683  :    if (c->parent->zone == expand) {

	mov	ecx, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+32]
	cmp	eax, DWORD PTR _expand
	jne	$LN1@propogate_

; 684  :       Prof_Report_Record *r = (Prof_Report_Record *) c->zone->highlevel;

	mov	ecx, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _r$1[ebp], eax

; 685  :       r[0].values[0] += 1000 * get_value(&d->self_time);

	mov	esi, 64					; 00000040H
	imul	esi, 0
	add	esi, DWORD PTR _r$1[ebp]
	mov	edi, 8
	imul	edi, 0
	mov	ecx, DWORD PTR _d$[ebp]
	push	ecx
	call	_get_value
	add	esp, 4
	fstp	QWORD PTR tv460[ebp]
	movsd	xmm0, QWORD PTR tv460[ebp]
	mulsd	xmm0, QWORD PTR __real@408f400000000000
	addsd	xmm0, QWORD PTR [esi+edi+20]
	mov	edx, 8
	imul	edx, 0
	mov	eax, 64					; 00000040H
	imul	eax, 0
	add	eax, DWORD PTR _r$1[ebp]
	movsd	QWORD PTR [eax+edx+20], xmm0

; 686  :       r[0].values[1] += 1000 * get_value(&d->hierarchical_time);

	mov	esi, 64					; 00000040H
	imul	esi, 0
	add	esi, DWORD PTR _r$1[ebp]
	mov	edi, 8
	shl	edi, 0
	mov	ecx, DWORD PTR _d$[ebp]
	add	ecx, 560				; 00000230H
	push	ecx
	call	_get_value
	add	esp, 4
	fstp	QWORD PTR tv471[ebp]
	movsd	xmm0, QWORD PTR tv471[ebp]
	mulsd	xmm0, QWORD PTR __real@408f400000000000
	addsd	xmm0, QWORD PTR [esi+edi+20]
	mov	edx, 8
	shl	edx, 0
	mov	eax, 64					; 00000040H
	imul	eax, 0
	add	eax, DWORD PTR _r$1[ebp]
	movsd	QWORD PTR [eax+edx+20], xmm0

; 687  :       r[0].values[2] += get_value(&d->entry_count);

	mov	esi, 64					; 00000040H
	imul	esi, 0
	add	esi, DWORD PTR _r$1[ebp]
	mov	edi, 8
	shl	edi, 1
	mov	ecx, DWORD PTR _d$[ebp]
	add	ecx, 1120				; 00000460H
	push	ecx
	call	_get_value
	add	esp, 4
	fstp	QWORD PTR tv482[ebp]
	movsd	xmm0, QWORD PTR tv482[ebp]
	addsd	xmm0, QWORD PTR [esi+edi+20]
	mov	edx, 8
	shl	edx, 1
	mov	eax, 64					; 00000040H
	imul	eax, 0
	add	eax, DWORD PTR _r$1[ebp]
	movsd	QWORD PTR [eax+edx+20], xmm0

; 688  :       if (d->max_recursion > r[0].number && get_value(&d->entry_count) > INT_ZERO_THRESHHOLD)

	mov	ecx, 64					; 00000040H
	imul	ecx, 0
	mov	edx, DWORD PTR _d$[ebp]
	mov	eax, DWORD PTR _r$1[ebp]
	mov	edx, DWORD PTR [edx+1680]
	cmp	edx, DWORD PTR [eax+ecx+8]
	jle	SHORT $LN1@propogate_
	mov	eax, DWORD PTR _d$[ebp]
	add	eax, 1120				; 00000460H
	push	eax
	call	_get_value
	add	esp, 4
	fstp	QWORD PTR tv494[ebp]
	movsd	xmm0, QWORD PTR tv494[ebp]
	comisd	xmm0, QWORD PTR __real@3fd0000000000000
	jbe	SHORT $LN1@propogate_

; 689  :          r[0].number = d->max_recursion;

	mov	ecx, 64					; 00000040H
	imul	ecx, 0
	mov	edx, DWORD PTR _r$1[ebp]
	mov	eax, DWORD PTR _d$[ebp]
	mov	eax, DWORD PTR [eax+1680]
	mov	DWORD PTR [edx+ecx+8], eax
$LN1@propogate_:

; 690  :    }
; 691  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_propogate_expanded ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\prof_process.c
_TEXT	SEGMENT
tv254 = -68						; size = 8
tv249 = -60						; size = 8
tv219 = -52						; size = 8
tv210 = -44						; size = 8
tv199 = -36						; size = 8
tv188 = -28						; size = 8
_t$1 = -20						; size = 8
_z$ = -12						; size = 4
_d$ = -8						; size = 4
_r$ = -4						; size = 4
_c$ = 8							; size = 4
_propogate_to_zone PROC

; 595  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	esi

; 596  :    Prof_Zone *z = c->zone;

	mov	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _z$[ebp], ecx

; 597  :    Profile_Tracker_Data_Record *d = (Profile_Tracker_Data_Record *) c->highlevel;

	mov	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR _d$[ebp], eax

; 598  :    Prof_Report_Record *r;
; 599  : 
; 600  : #if 1
; 601  :    r = (Prof_Report_Record *) z->highlevel;

	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _r$[ebp], edx

; 602  : #else   
; 603  :    if (recurse == Prof_FLATTEN_RECURSION)
; 604  :       r = (Prof_Report_Record *) z->highlevel;
; 605  :    else
; 606  :       r = ((Prof_Report_Record **) z->highlevel)[c->recursion_depth];
; 607  : #endif
; 608  : 
; 609  :    if (d) {

	cmp	DWORD PTR _d$[ebp], 0
	je	$LN10@propogate_

; 610  :       double t;
; 611  : 
; 612  :       r->values[0] += 1000 * get_value(&d->self_time);

	mov	esi, 8
	imul	esi, 0
	mov	eax, DWORD PTR _d$[ebp]
	push	eax
	call	_get_value
	add	esp, 4
	fstp	QWORD PTR tv188[ebp]
	movsd	xmm0, QWORD PTR tv188[ebp]
	mulsd	xmm0, QWORD PTR __real@408f400000000000
	mov	ecx, DWORD PTR _r$[ebp]
	addsd	xmm0, QWORD PTR [ecx+esi+20]
	mov	edx, 8
	imul	edx, 0
	mov	eax, DWORD PTR _r$[ebp]
	movsd	QWORD PTR [eax+edx+20], xmm0

; 613  :       r->values[1] += 1000 * get_value(&d->hierarchical_time);

	mov	esi, 8
	shl	esi, 0
	mov	ecx, DWORD PTR _d$[ebp]
	add	ecx, 560				; 00000230H
	push	ecx
	call	_get_value
	add	esp, 4
	fstp	QWORD PTR tv199[ebp]
	movsd	xmm0, QWORD PTR tv199[ebp]
	mulsd	xmm0, QWORD PTR __real@408f400000000000
	mov	edx, DWORD PTR _r$[ebp]
	addsd	xmm0, QWORD PTR [edx+esi+20]
	mov	eax, 8
	shl	eax, 0
	mov	ecx, DWORD PTR _r$[ebp]
	movsd	QWORD PTR [ecx+eax+20], xmm0

; 614  :       r->values[2] += get_value(&d->entry_count);

	mov	esi, 8
	shl	esi, 1
	mov	edx, DWORD PTR _d$[ebp]
	add	edx, 1120				; 00000460H
	push	edx
	call	_get_value
	add	esp, 4
	fstp	QWORD PTR tv210[ebp]
	mov	eax, DWORD PTR _r$[ebp]
	movsd	xmm0, QWORD PTR tv210[ebp]
	addsd	xmm0, QWORD PTR [eax+esi+20]
	mov	ecx, 8
	shl	ecx, 1
	mov	edx, DWORD PTR _r$[ebp]
	movsd	QWORD PTR [edx+ecx+20], xmm0

; 615  : 
; 616  :       // arbitrary determination for how low a moving average
; 617  :       // has to go to reach 0
; 618  :       if (get_value(&d->entry_count) > INT_ZERO_THRESHHOLD) {

	mov	eax, DWORD PTR _d$[ebp]
	add	eax, 1120				; 00000460H
	push	eax
	call	_get_value
	add	esp, 4
	fstp	QWORD PTR tv219[ebp]
	movsd	xmm0, QWORD PTR tv219[ebp]
	comisd	xmm0, QWORD PTR __real@3fd0000000000000
	jbe	SHORT $LN7@propogate_

; 619  :          if (d->max_recursion > r->number)

	mov	ecx, DWORD PTR _d$[ebp]
	mov	edx, DWORD PTR _r$[ebp]
	mov	eax, DWORD PTR [ecx+1680]
	cmp	eax, DWORD PTR [edx+8]
	jle	SHORT $LN8@propogate_

; 620  :             r->number = d->max_recursion;

	mov	ecx, DWORD PTR _r$[ebp]
	mov	edx, DWORD PTR _d$[ebp]
	mov	eax, DWORD PTR [edx+1680]
	mov	DWORD PTR [ecx+8], eax
$LN8@propogate_:

; 621  :          if (c->parent->zone)

	mov	ecx, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	cmp	DWORD PTR [edx+32], 0
	je	SHORT $LN7@propogate_

; 622  :             ((Prof_Report_Record *) c->parent->zone->highlevel)->prefix = '+';

	mov	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [edx+4]
	mov	BYTE PTR [eax+12], 43			; 0000002bH
$LN7@propogate_:

; 623  :       }
; 624  : 
; 625  : #ifdef Prof_CALL_HISTORY
; 626  :       if (display_frame) return;  // no variances when examining history

	cmp	DWORD PTR _display_frame, 0
	je	SHORT $LN6@propogate_
	jmp	$LN1@propogate_
$LN6@propogate_:

; 627  : #endif
; 628  :       if (displayed_quantity == Prof_HIERARCHICAL_TIME) {

	cmp	DWORD PTR _displayed_quantity, 1
	jne	SHORT $LN5@propogate_

; 629  :          t = d->hierarchical_time.variances[slot];

	mov	ecx, DWORD PTR _slot
	mov	edx, DWORD PTR _d$[ebp]
	movsd	xmm0, QWORD PTR [edx+ecx*8+584]
	movsd	QWORD PTR _t$1[ebp], xmm0

; 630  :       } else {

	jmp	SHORT $LN4@propogate_
$LN5@propogate_:

; 631  :          t = d->self_time.variances[slot];

	mov	eax, DWORD PTR _slot
	mov	ecx, DWORD PTR _d$[ebp]
	movsd	xmm0, QWORD PTR [ecx+eax*8+24]
	movsd	QWORD PTR _t$1[ebp], xmm0
$LN4@propogate_:

; 632  :       }
; 633  : 
; 634  :       t = 1000 * 1000 * t;

	movsd	xmm0, QWORD PTR __real@412e848000000000
	mulsd	xmm0, QWORD PTR _t$1[ebp]
	movsd	QWORD PTR _t$1[ebp], xmm0

; 635  : 
; 636  :       if (r->heat == 0)

	mov	edx, DWORD PTR _r$[ebp]
	movsd	xmm0, QWORD PTR [edx+52]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@propogate_

; 637  :          r->heat = t;

	mov	eax, DWORD PTR _r$[ebp]
	movsd	xmm0, QWORD PTR _t$1[ebp]
	movsd	QWORD PTR [eax+52], xmm0

; 638  :       else

	jmp	SHORT $LN2@propogate_
$LN3@propogate_:

; 639  :          r->heat = r->heat + t + 2 * sqrt(r->heat * t);

	mov	ecx, DWORD PTR _r$[ebp]
	movsd	xmm0, QWORD PTR [ecx+52]
	addsd	xmm0, QWORD PTR _t$1[ebp]
	mov	edx, DWORD PTR _r$[ebp]
	movsd	xmm1, QWORD PTR [edx+52]
	mulsd	xmm1, QWORD PTR _t$1[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm1
	movsd	QWORD PTR tv254[ebp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	QWORD PTR tv249[ebp]
	movsd	xmm0, QWORD PTR tv249[ebp]
	mulsd	xmm0, QWORD PTR __real@4000000000000000
	movsd	xmm1, QWORD PTR tv254[ebp]
	addsd	xmm1, xmm0
	mov	eax, DWORD PTR _r$[ebp]
	movsd	QWORD PTR [eax+52], xmm1
$LN2@propogate_:

; 640  :    } else {

	jmp	SHORT $LN1@propogate_
$LN10@propogate_:

; 641  :       ++uncounted;

	mov	ecx, DWORD PTR _uncounted
	add	ecx, 1
	mov	DWORD PTR _uncounted, ecx
$LN1@propogate_:

; 642  :    }
; 643  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_propogate_to_zone ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\prof_process.c
_TEXT	SEGMENT
_pob$ = -8						; size = 4
_i$ = -4						; size = 4
_n$ = 8							; size = 4
_allocate_buffer PROC

; 563  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 564  :    int i;
; 565  :    Prof_Report *pob = (Prof_Report *) malloc(sizeof(*pob));

	push	40					; 00000028H
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _pob$[ebp], eax

; 566  :    pob->num_record = n;

	mov	eax, DWORD PTR _pob$[ebp]
	mov	ecx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [eax+28], ecx

; 567  :    pob->record = (Prof_Report_Record *) malloc(sizeof(*pob->record) * pob->num_record);

	mov	edx, DWORD PTR _pob$[ebp]
	mov	eax, DWORD PTR [edx+28]
	shl	eax, 6
	push	eax
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _pob$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 568  :    pob->title[0] = pob->title[1] = NULL;

	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pob$[ebp]
	mov	DWORD PTR [eax+edx], 0
	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _pob$[ebp]
	mov	DWORD PTR [edx+ecx], 0

; 569  :    for (i=0; i < NUM_TITLE; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN9@allocate_b
$LN8@allocate_b:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN9@allocate_b:
	cmp	DWORD PTR _i$[ebp], 2
	jge	SHORT $LN7@allocate_b

; 570  :       pob->title[i] = NULL;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _pob$[ebp]
	mov	DWORD PTR [edx+ecx*4], 0
	jmp	SHORT $LN8@allocate_b
$LN7@allocate_b:

; 571  :    for (i=0; i < NUM_HEADER; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@allocate_b
$LN5@allocate_b:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN6@allocate_b:
	cmp	DWORD PTR _i$[ebp], 5
	jge	SHORT $LN4@allocate_b

; 572  :       pob->header[i] = NULL;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _pob$[ebp]
	mov	DWORD PTR [edx+ecx*4+8], 0
	jmp	SHORT $LN5@allocate_b
$LN4@allocate_b:

; 573  :    for (i=0; i < n; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@allocate_b
$LN2@allocate_b:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@allocate_b:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _n$[ebp]
	jge	$LN1@allocate_b

; 574  :       pob->record[i].values[0] = 0;

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 6
	mov	eax, DWORD PTR _pob$[ebp]
	add	edx, DWORD PTR [eax+36]
	mov	ecx, 8
	imul	ecx, 0
	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR [edx+ecx+20], xmm0

; 575  :       pob->record[i].values[1] = 0;

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 6
	mov	eax, DWORD PTR _pob$[ebp]
	add	edx, DWORD PTR [eax+36]
	mov	ecx, 8
	shl	ecx, 0
	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR [edx+ecx+20], xmm0

; 576  :       pob->record[i].values[2] = 0;

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 6
	mov	eax, DWORD PTR _pob$[ebp]
	add	edx, DWORD PTR [eax+36]
	mov	ecx, 8
	shl	ecx, 1
	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR [edx+ecx+20], xmm0

; 577  :       pob->record[i].values[3] = 0;

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 6
	mov	eax, DWORD PTR _pob$[ebp]
	add	edx, DWORD PTR [eax+36]
	mov	ecx, 8
	imul	ecx, 3
	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR [edx+ecx+20], xmm0

; 578  :       pob->record[i].value_flag = 0;

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 6
	mov	eax, DWORD PTR _pob$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+edx+16], 0

; 579  :       pob->record[i].heat = 0;

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 6
	mov	eax, DWORD PTR _pob$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR [ecx+edx+52], xmm0

; 580  :       pob->record[i].indent = 0;

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 6
	mov	eax, DWORD PTR _pob$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+edx], 0

; 581  :       pob->record[i].number = 0;

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 6
	mov	eax, DWORD PTR _pob$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+edx+8], 0

; 582  :    }

	jmp	$LN2@allocate_b
$LN1@allocate_b:

; 583  :    return pob;

	mov	eax, DWORD PTR _pob$[ebp]

; 584  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_allocate_buffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\prof_process.c
_TEXT	SEGMENT
_s$ = 8							; size = 4
_get_value PROC

; 129  : {

	push	ebp
	mov	ebp, esp

; 130  : #ifdef Prof_CALL_HISTORY
; 131  :    if (display_frame) {

	cmp	DWORD PTR _display_frame, 0
	je	SHORT $LN1@get_value

; 132  :       return s->history[(history_index - display_frame + NUM_FRAME_SLOTS) % NUM_FRAME_SLOTS];

	mov	eax, DWORD PTR _history_index
	sub	eax, DWORD PTR _display_frame
	add	eax, 128				; 00000080H
	and	eax, -2147483521			; 8000007fH
	jns	SHORT $LN4@get_value
	dec	eax
	or	eax, -128				; ffffff80H
	inc	eax
$LN4@get_value:
	mov	ecx, DWORD PTR _s$[ebp]
	fld	DWORD PTR [ecx+eax*4+48]
	jmp	SHORT $LN2@get_value
$LN1@get_value:

; 133  :    }
; 134  : #endif
; 135  :    return s->values[slot];

	mov	edx, DWORD PTR _slot
	mov	eax, DWORD PTR _s$[ebp]
	fld	QWORD PTR [eax+edx*8]
$LN2@get_value:

; 136  : }

	pop	ebp
	ret	0
_get_value ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\prof_process.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_s$ = 8							; size = 4
_clear	PROC

; 75   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 76   :    int i;
; 77   :    for (i = 0; i < NUM_PROFILE_TRACKER_HISTORY_SLOTS; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@clear
$LN2@clear:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@clear:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $LN1@clear

; 78   :       s->values[i] = 0;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _s$[ebp]
	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR [edx+ecx*8], xmm0

; 79   :       s->variances[i] = 0;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR [ecx+eax*8+24], xmm0

; 80   :    }

	jmp	SHORT $LN2@clear
$LN1@clear:

; 81   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_clear	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\prof_process.c
_TEXT	SEGMENT
_j$ = -4						; size = 4
_Prof_init_highlevel PROC

; 144  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 145  :    int j;
; 146  : 
; 147  :    update_index = 0;

	mov	DWORD PTR _update_index, 0

; 148  :    last_update_time = 0;

	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR _last_update_time, xmm0

; 149  : 
; 150  :    times_to_reach_90_percent[0] = 0.1f;

	mov	eax, 8
	imul	eax, 0
	movsd	xmm0, QWORD PTR __real@3fb99999a0000000
	movsd	QWORD PTR _times_to_reach_90_percent[eax], xmm0

; 151  :    times_to_reach_90_percent[1] = 0.8f;

	mov	ecx, 8
	shl	ecx, 0
	movsd	xmm0, QWORD PTR __real@3fe99999a0000000
	movsd	QWORD PTR _times_to_reach_90_percent[ecx], xmm0

; 152  :    times_to_reach_90_percent[2] = 2.5f;

	mov	edx, 8
	shl	edx, 1
	movsd	xmm0, QWORD PTR __real@4004000000000000
	movsd	QWORD PTR _times_to_reach_90_percent[edx], xmm0

; 153  : 
; 154  :    displayed_quantity = Prof_SELF_TIME;

	mov	DWORD PTR _displayed_quantity, 0

; 155  : 
; 156  :    clear(&frame_time);

	push	OFFSET _frame_time
	call	_clear
	add	esp, 4

; 157  : 
; 158  :    for (j = 0; j < NUM_PROFILE_TRACKER_HISTORY_SLOTS; j++) {

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN3@Prof_init_
$LN2@Prof_init_:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN3@Prof_init_:
	cmp	DWORD PTR _j$[ebp], 3
	jge	SHORT $LN1@Prof_init_

; 159  :       frame_time.values[j] = FRAME_TIME_INITIAL;

	mov	ecx, DWORD PTR _j$[ebp]
	movsd	xmm0, QWORD PTR __real@3f50624dd2f1a9fc
	movsd	QWORD PTR _frame_time[ecx*8], xmm0

; 160  :    }

	jmp	SHORT $LN2@Prof_init_
$LN1@Prof_init_:

; 161  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Prof_init_highlevel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\prof_process.c
_TEXT	SEGMENT
_value$1 = -16						; size = 8
_h$ = -8						; size = 4
_i$ = -4						; size = 4
_num_frames$ = 8					; size = 4
_callback$ = 12						; size = 4
_data$ = 16						; size = 4
_Prof_graph PROC

; 1062 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 1063 : #ifdef Prof_ZONE_HISTORY
; 1064 :    int i,h = history_index;

	mov	eax, DWORD PTR _history_index
	mov	DWORD PTR _h$[ebp], eax

; 1065 :    if (num_frames > NUM_FRAME_SLOTS)

	cmp	DWORD PTR _num_frames$[ebp], 128	; 00000080H
	jle	SHORT $LN7@Prof_graph

; 1066 :       num_frames = NUM_FRAME_SLOTS;

	mov	DWORD PTR _num_frames$[ebp], 128	; 00000080H
$LN7@Prof_graph:

; 1067 : 
; 1068 :    for (i=0; i < Prof_num_zones; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@Prof_graph
$LN5@Prof_graph:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN6@Prof_graph:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _Prof_num_zones
	jge	$LN4@Prof_graph

; 1069 :       if (h >= num_frames) {

	mov	eax, DWORD PTR _h$[ebp]
	cmp	eax, DWORD PTR _num_frames$[ebp]
	jl	SHORT $LN3@Prof_graph

; 1070 :          callback(id(Prof_zones[i]), 0, num_frames, &zone_history[i][h-num_frames], data);

	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 9
	mov	eax, DWORD PTR _h$[ebp]
	sub	eax, DWORD PTR _num_frames$[ebp]
	lea	ecx, DWORD PTR _zone_history[edx+eax*4]
	push	ecx
	mov	edx, DWORD PTR _num_frames$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _Prof_zones[eax*4]
	push	ecx
	call	_id
	add	esp, 4
	push	eax
	call	DWORD PTR _callback$[ebp]
	add	esp, 20					; 00000014H

; 1071 :       } else {

	jmp	$LN2@Prof_graph
$LN3@Prof_graph:

; 1072 :          callback(id(Prof_zones[i]), num_frames - h, num_frames, &zone_history[i][0], data);

	mov	edx, DWORD PTR _data$[ebp]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 9
	mov	ecx, 4
	imul	ecx, 0
	lea	edx, DWORD PTR _zone_history[eax+ecx]
	push	edx
	mov	eax, DWORD PTR _num_frames$[ebp]
	push	eax
	mov	ecx, DWORD PTR _num_frames$[ebp]
	sub	ecx, DWORD PTR _h$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _Prof_zones[edx*4]
	push	eax
	call	_id
	add	esp, 4
	push	eax
	call	DWORD PTR _callback$[ebp]
	add	esp, 20					; 00000014H

; 1073 :          callback(id(Prof_zones[i]), 0, num_frames-h, &zone_history[i][NUM_FRAME_SLOTS-(num_frames-h)], data);

	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 9
	mov	eax, DWORD PTR _num_frames$[ebp]
	sub	eax, DWORD PTR _h$[ebp]
	mov	ecx, 128				; 00000080H
	sub	ecx, eax
	lea	edx, DWORD PTR _zone_history[edx+ecx*4]
	push	edx
	mov	eax, DWORD PTR _num_frames$[ebp]
	sub	eax, DWORD PTR _h$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _Prof_zones[ecx*4]
	push	edx
	call	_id
	add	esp, 4
	push	eax
	call	DWORD PTR _callback$[ebp]
	add	esp, 20					; 00000014H
$LN2@Prof_graph:

; 1074 :       }
; 1075 :    }

	jmp	$LN5@Prof_graph
$LN4@Prof_graph:

; 1076 : 
; 1077 :    // display frame "cursor"
; 1078 :    if (display_frame != 0) {

	cmp	DWORD PTR _display_frame, 0
	je	SHORT $LN1@Prof_graph

; 1079 :       float value[2] = { 2.0, 0 };

	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR _value$1[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _value$1[ebp+4], xmm0

; 1080 :       callback(0, NUM_FRAME_SLOTS-1-display_frame, NUM_FRAME_SLOTS-1-display_frame, value, data);

	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	lea	ecx, DWORD PTR _value$1[ebp]
	push	ecx
	mov	edx, 127				; 0000007fH
	sub	edx, DWORD PTR _display_frame
	push	edx
	mov	eax, 127				; 0000007fH
	sub	eax, DWORD PTR _display_frame
	push	eax
	push	0
	call	DWORD PTR _callback$[ebp]
	add	esp, 20					; 00000014H
$LN1@Prof_graph:

; 1081 :    }
; 1082 : #endif
; 1083 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Prof_graph ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\prof_process.c
_TEXT	SEGMENT
_t$1 = -64						; size = 8
_fps$ = -56						; size = 8
_avg_frame_time$ = -48					; size = 8
_r$2 = -40						; size = 4
tv193 = -36						; size = 4
tv172 = -32						; size = 4
_s$ = -28						; size = 4
_j$3 = -24						; size = 4
_displayed_quantity_name$ = -20				; size = 4
_z$4 = -16						; size = 4
_r$5 = -12						; size = 4
_i$ = -8						; size = 4
_pob$ = -4						; size = 4
_Prof_create_report PROC

; 770  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	esi
	push	edi

; 771  :    double avg_frame_time,fps;
; 772  :    char *displayed_quantity_name;
; 773  :    int i,s;
; 774  :    Prof_Report *pob;
; 775  : 
; 776  :    if (displayed_quantity == Prof_CALL_GRAPH)

	cmp	DWORD PTR _displayed_quantity, 2
	jne	SHORT $LN40@Prof_creat

; 777  :       s = 3;

	mov	DWORD PTR _s$[ebp], 3

; 778  :    else

	jmp	SHORT $LN39@Prof_creat
$LN40@Prof_creat:

; 779  :       s = 1;

	mov	DWORD PTR _s$[ebp], 1
$LN39@Prof_creat:

; 780  :    
; 781  :    pob = allocate_buffer(Prof_num_zones * s);

	mov	eax, DWORD PTR _Prof_num_zones
	imul	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_allocate_buffer
	add	esp, 4
	mov	DWORD PTR _pob$[ebp], eax

; 782  :    for (i=0; i < Prof_num_zones; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN38@Prof_creat
$LN37@Prof_creat:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN38@Prof_creat:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _Prof_num_zones
	jge	$LN36@Prof_creat

; 783  :       Prof_Zone *z = Prof_zones[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _Prof_zones[eax*4]
	mov	DWORD PTR _z$4[ebp], ecx

; 784  :       Prof_Report_Record *r = &pob->record[i*s];

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, DWORD PTR _s$[ebp]
	shl	edx, 6
	mov	eax, DWORD PTR _pob$[ebp]
	add	edx, DWORD PTR [eax+36]
	mov	DWORD PTR _r$5[ebp], edx

; 785  :       z->highlevel = (void *) r;

	mov	ecx, DWORD PTR _z$4[ebp]
	mov	edx, DWORD PTR _r$5[ebp]
	mov	DWORD PTR [ecx+4], edx

; 786  :       if (displayed_quantity == Prof_CALL_GRAPH) {

	cmp	DWORD PTR _displayed_quantity, 2
	jne	$LN35@Prof_creat

; 787  :          r[0].name = r[1].name = r[2].name = z->name;

	mov	eax, 64					; 00000040H
	shl	eax, 1
	mov	ecx, DWORD PTR _r$5[ebp]
	mov	edx, DWORD PTR _z$4[ebp]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx+eax+4], edx
	mov	eax, 64					; 00000040H
	shl	eax, 1
	mov	ecx, 64					; 00000040H
	shl	ecx, 0
	mov	edx, DWORD PTR _r$5[ebp]
	mov	esi, DWORD PTR _r$5[ebp]
	mov	eax, DWORD PTR [esi+eax+4]
	mov	DWORD PTR [edx+ecx+4], eax
	mov	ecx, 64					; 00000040H
	shl	ecx, 0
	mov	edx, 64					; 00000040H
	imul	edx, 0
	mov	eax, DWORD PTR _r$5[ebp]
	mov	esi, DWORD PTR _r$5[ebp]
	mov	ecx, DWORD PTR [esi+ecx+4]
	mov	DWORD PTR [eax+edx+4], ecx

; 788  :          r[0].value_flag = 1 | 2 | 4;

	mov	edx, 64					; 00000040H
	imul	edx, 0
	mov	eax, DWORD PTR _r$5[ebp]
	mov	DWORD PTR [eax+edx+16], 7

; 789  :          r[1].value_flag = 1 | 2 | 4;

	mov	ecx, 64					; 00000040H
	shl	ecx, 0
	mov	edx, DWORD PTR _r$5[ebp]
	mov	DWORD PTR [edx+ecx+16], 7

; 790  :          r[2].value_flag = 1 | 2 | 4;

	mov	eax, 64					; 00000040H
	shl	eax, 1
	mov	ecx, DWORD PTR _r$5[ebp]
	mov	DWORD PTR [ecx+eax+16], 7

; 791  :          r[0].indent = 3;

	mov	edx, 64					; 00000040H
	imul	edx, 0
	mov	eax, DWORD PTR _r$5[ebp]
	mov	DWORD PTR [eax+edx], 3

; 792  :          r[1].indent = 5;

	mov	ecx, 64					; 00000040H
	shl	ecx, 0
	mov	edx, DWORD PTR _r$5[ebp]
	mov	DWORD PTR [edx+ecx], 5

; 793  :          r[2].indent = 0;

	mov	eax, 64					; 00000040H
	shl	eax, 1
	mov	ecx, DWORD PTR _r$5[ebp]
	mov	DWORD PTR [ecx+eax], 0

; 794  :          r[0].zone = r[1].zone = r[2].zone = (void *) z;

	mov	edx, 64					; 00000040H
	shl	edx, 1
	mov	eax, DWORD PTR _r$5[ebp]
	mov	ecx, DWORD PTR _z$4[ebp]
	mov	DWORD PTR [eax+edx+60], ecx
	mov	edx, 64					; 00000040H
	shl	edx, 0
	mov	eax, DWORD PTR _r$5[ebp]
	mov	ecx, DWORD PTR _z$4[ebp]
	mov	DWORD PTR [eax+edx+60], ecx
	mov	edx, 64					; 00000040H
	imul	edx, 0
	mov	eax, DWORD PTR _r$5[ebp]
	mov	ecx, DWORD PTR _z$4[ebp]
	mov	DWORD PTR [eax+edx+60], ecx

; 795  :          r[0].prefix = r[1].prefix = r[2].prefix = 0;

	mov	edx, 64					; 00000040H
	shl	edx, 1
	mov	eax, DWORD PTR _r$5[ebp]
	mov	BYTE PTR [eax+edx+12], 0
	mov	ecx, 64					; 00000040H
	shl	ecx, 0
	mov	edx, DWORD PTR _r$5[ebp]
	mov	BYTE PTR [edx+ecx+12], 0
	mov	eax, 64					; 00000040H
	imul	eax, 0
	mov	ecx, DWORD PTR _r$5[ebp]
	mov	BYTE PTR [ecx+eax+12], 0

; 796  :       } else {

	jmp	SHORT $LN34@Prof_creat
$LN35@Prof_creat:

; 797  :          r->value_flag = 1 | 2 | 4;

	mov	edx, DWORD PTR _r$5[ebp]
	mov	DWORD PTR [edx+16], 7

; 798  :          r->name = z->name;

	mov	eax, DWORD PTR _r$5[ebp]
	mov	ecx, DWORD PTR _z$4[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 799  :          r->zone = (void *) z;

	mov	eax, DWORD PTR _r$5[ebp]
	mov	ecx, DWORD PTR _z$4[ebp]
	mov	DWORD PTR [eax+60], ecx

; 800  :          r->indent = 0;

	mov	edx, DWORD PTR _r$5[ebp]
	mov	DWORD PTR [edx], 0

; 801  :          r->prefix = 0;

	mov	eax, DWORD PTR _r$5[ebp]
	mov	BYTE PTR [eax+12], 0
$LN34@Prof_creat:

; 802  :       }
; 803  :    }

	jmp	$LN37@Prof_creat
$LN36@Prof_creat:

; 804  : 
; 805  :    avg_frame_time = frame_time.values[slot];

	mov	ecx, DWORD PTR _slot
	movsd	xmm0, QWORD PTR _frame_time[ecx*8]
	movsd	QWORD PTR _avg_frame_time$[ebp], xmm0

; 806  :    if (avg_frame_time == 0) avg_frame_time = 0.01f;

	movsd	xmm0, QWORD PTR _avg_frame_time$[ebp]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN33@Prof_creat
	movsd	xmm0, QWORD PTR __real@3f847ae140000000
	movsd	QWORD PTR _avg_frame_time$[ebp], xmm0
$LN33@Prof_creat:

; 807  :    fps = 1.0f / avg_frame_time;

	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	divsd	xmm0, QWORD PTR _avg_frame_time$[ebp]
	movsd	QWORD PTR _fps$[ebp], xmm0

; 808  : 
; 809  :    displayed_quantity_name = "*error*";

	mov	DWORD PTR _displayed_quantity_name$[ebp], OFFSET ??_C@_07LFEGLFGM@?$CKerror?$CK?$AA@

; 810  :    switch (displayed_quantity) {

	mov	edx, DWORD PTR _displayed_quantity
	mov	DWORD PTR tv172[ebp], edx
	cmp	DWORD PTR tv172[ebp], 0
	je	SHORT $LN30@Prof_creat
	cmp	DWORD PTR tv172[ebp], 1
	je	SHORT $LN29@Prof_creat
	cmp	DWORD PTR tv172[ebp], 2
	je	SHORT $LN28@Prof_creat
	jmp	SHORT $LN31@Prof_creat
$LN30@Prof_creat:

; 811  :       case Prof_SELF_TIME:
; 812  :          displayed_quantity_name = "sort self";

	mov	DWORD PTR _displayed_quantity_name$[ebp], OFFSET ??_C@_09LDMPODMP@sort?5self?$AA@

; 813  :          break;

	jmp	SHORT $LN31@Prof_creat
$LN29@Prof_creat:

; 814  :       case Prof_HIERARCHICAL_TIME:
; 815  :          displayed_quantity_name = "sort hier";

	mov	DWORD PTR _displayed_quantity_name$[ebp], OFFSET ??_C@_09MPFGBGDO@sort?5hier?$AA@

; 816  :          break;

	jmp	SHORT $LN31@Prof_creat
$LN28@Prof_creat:

; 817  :       case Prof_CALL_GRAPH:
; 818  :          displayed_quantity_name = "sort call graph";

	mov	DWORD PTR _displayed_quantity_name$[ebp], OFFSET ??_C@_0BA@HDDAHLEG@sort?5call?5graph?$AA@
$LN31@Prof_creat:

; 819  :          break;
; 820  :    }
; 821  : 
; 822  :    pob->title[0] = (char *)  malloc(BUFSIZ);

	push	512					; 00000200H
	call	_malloc
	add	esp, 4
	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _pob$[ebp]
	mov	DWORD PTR [edx+ecx], eax

; 823  :    sprintf(pob->title[0],
; 824  :           "%3.3lf ms/frame (fps: %3.2lf)  %s",
; 825  :            avg_frame_time * 1000, fps, displayed_quantity_name);

	mov	eax, DWORD PTR _displayed_quantity_name$[ebp]
	push	eax
	sub	esp, 8
	movsd	xmm0, QWORD PTR _fps$[ebp]
	movsd	QWORD PTR [esp], xmm0
	movsd	xmm0, QWORD PTR _avg_frame_time$[ebp]
	mulsd	xmm0, QWORD PTR __real@408f400000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0CC@LBDOLJGI@?$CF3?43lf?5ms?1frame?5?$CIfps?3?5?$CF3?42lf?$CJ?5?5?$CF@
	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _pob$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	call	_sprintf
	add	esp, 28					; 0000001cH

; 826  : 
; 827  : #ifdef Prof_CALL_HISTORY
; 828  :    if (display_frame) {

	cmp	DWORD PTR _display_frame, 0
	je	SHORT $LN27@Prof_creat

; 829  :       sprintf(pob->title[0] + strlen(pob->title[0]), " - %d frame%s ago",
; 830  :           display_frame, display_frame == 1 ? "" : "s");

	cmp	DWORD PTR _display_frame, 1
	jne	SHORT $LN43@Prof_creat
	mov	DWORD PTR tv193[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
	jmp	SHORT $LN44@Prof_creat
$LN43@Prof_creat:
	mov	DWORD PTR tv193[ebp], OFFSET ??_C@_01LKDEMHDF@s?$AA@
$LN44@Prof_creat:
	mov	ecx, DWORD PTR tv193[ebp]
	push	ecx
	mov	edx, DWORD PTR _display_frame
	push	edx
	push	OFFSET ??_C@_0BC@OEHLFAIG@?5?9?5?$CFd?5frame?$CFs?5ago?$AA@
	mov	esi, 4
	imul	esi, 0
	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _pob$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _pob$[ebp]
	add	eax, DWORD PTR [ecx+esi]
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H

; 831  :    } else {

	jmp	SHORT $LN26@Prof_creat
$LN27@Prof_creat:

; 832  :       strcat(pob->title[0], " - current frame");

	push	OFFSET ??_C@_0BB@HFDDJBNF@?5?9?5current?5frame?$AA@
	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _pob$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	call	_strcat
	add	esp, 8
$LN26@Prof_creat:

; 833  :    }
; 834  : #endif
; 835  : 
; 836  :    if (speedstep_warning)

	cmp	DWORD PTR _speedstep_warning, 0
	je	SHORT $LN25@Prof_creat

; 837  :       pob->title[1] = _strdup("WARNING: SpeedStep-like timer inconsistencies detected.  Results are unreliable!");

	push	OFFSET ??_C@_0FB@HPHDLFKA@WARNING?3?5SpeedStep?9like?5timer?5in@
	call	__strdup
	add	esp, 4
	mov	edx, 4
	shl	edx, 0
	mov	ecx, DWORD PTR _pob$[ebp]
	mov	DWORD PTR [ecx+edx], eax
$LN25@Prof_creat:

; 838  : 
; 839  :    if (displayed_quantity == Prof_CALL_GRAPH) {

	cmp	DWORD PTR _displayed_quantity, 2
	jne	$LN24@Prof_creat

; 840  :       Prof_Report_Record *r = (Prof_Report_Record *) expand->highlevel;

	mov	edx, DWORD PTR _expand
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _r$2[ebp], eax

; 841  :       int j=0;

	mov	DWORD PTR _j$3[ebp], 0

; 842  : 
; 843  :       Prof_traverse(propogate_expanded);

	push	OFFSET _propogate_expanded
	call	_Prof_traverse
	add	esp, 4

; 844  : 
; 845  :       r[2].prefix = '-';

	mov	ecx, 64					; 00000040H
	shl	ecx, 1
	mov	edx, DWORD PTR _r$2[ebp]
	mov	BYTE PTR [edx+ecx+12], 45		; 0000002dH

; 846  : 
; 847  :       for (i=0; i < pob->num_record; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN23@Prof_creat
$LN22@Prof_creat:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN23@Prof_creat:
	mov	ecx, DWORD PTR _pob$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+28]
	jge	$LN21@Prof_creat

; 848  :          if (pob->record[i].values[0] || pob->record[i].values[1] || pob->record[i].values[2]) {

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _pob$[ebp]
	add	eax, DWORD PTR [ecx+36]
	mov	edx, 8
	imul	edx, 0
	movsd	xmm0, QWORD PTR [eax+edx+20]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN19@Prof_creat
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _pob$[ebp]
	add	eax, DWORD PTR [ecx+36]
	mov	edx, 8
	shl	edx, 0
	movsd	xmm0, QWORD PTR [eax+edx+20]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN19@Prof_creat
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _pob$[ebp]
	add	eax, DWORD PTR [ecx+36]
	mov	edx, 8
	shl	edx, 1
	movsd	xmm0, QWORD PTR [eax+edx+20]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN20@Prof_creat
$LN19@Prof_creat:

; 849  :             pob->record[j] = pob->record[i];

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _pob$[ebp]
	mov	esi, DWORD PTR [ecx+36]
	add	esi, eax
	mov	edx, DWORD PTR _j$3[ebp]
	shl	edx, 6
	mov	eax, DWORD PTR _pob$[ebp]
	mov	edi, DWORD PTR [eax+36]
	add	edi, edx
	mov	ecx, 16					; 00000010H
	rep movsd

; 850  :             ++j;

	mov	ecx, DWORD PTR _j$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$3[ebp], ecx
$LN20@Prof_creat:

; 851  :          }
; 852  :       }

	jmp	$LN22@Prof_creat
$LN21@Prof_creat:

; 853  :       pob->num_record = j;

	mov	edx, DWORD PTR _pob$[ebp]
	mov	eax, DWORD PTR _j$3[ebp]
	mov	DWORD PTR [edx+28], eax

; 854  : 
; 855  :       qsort(pob->record, pob->num_record, sizeof(pob->record[0]), pob_expand_compare);

	push	OFFSET _pob_expand_compare
	push	64					; 00000040H
	mov	ecx, DWORD PTR _pob$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	mov	eax, DWORD PTR _pob$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	_qsort
	add	esp, 16					; 00000010H

; 856  : 
; 857  :       for (i=0; i < pob->num_record; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN18@Prof_creat
$LN17@Prof_creat:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN18@Prof_creat:
	mov	eax, DWORD PTR _pob$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+28]
	jge	SHORT $LN16@Prof_creat

; 858  :          if (pob->record[i].indent == 5)

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 6
	mov	eax, DWORD PTR _pob$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	cmp	DWORD PTR [ecx+edx], 5
	jne	SHORT $LN15@Prof_creat

; 859  :              pob->record[i].indent = 3;

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 6
	mov	eax, DWORD PTR _pob$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+edx], 3
$LN15@Prof_creat:

; 860  :    } else {

	jmp	SHORT $LN17@Prof_creat
$LN16@Prof_creat:
	jmp	$LN14@Prof_creat
$LN24@Prof_creat:

; 861  : 
; 862  :       uncounted = 0;

	mov	DWORD PTR _uncounted, 0

; 863  :       Prof_traverse(propogate_to_zone);

	push	OFFSET _propogate_to_zone
	call	_Prof_traverse
	add	esp, 4

; 864  : 
; 865  :       for (i=0; i < Prof_num_zones; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN13@Prof_creat
$LN12@Prof_creat:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN13@Prof_creat:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _Prof_num_zones
	jge	$LN11@Prof_creat

; 866  :          if (displayed_quantity == Prof_HIERARCHICAL_TIME) {

	cmp	DWORD PTR _displayed_quantity, 1
	jne	SHORT $LN10@Prof_creat

; 867  :             double t = pob->record[i].values[0];

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 6
	mov	edx, DWORD PTR _pob$[ebp]
	add	ecx, DWORD PTR [edx+36]
	mov	eax, 8
	imul	eax, 0
	movsd	xmm0, QWORD PTR [ecx+eax+20]
	movsd	QWORD PTR _t$1[ebp], xmm0

; 868  :             pob->record[i].values[0] = pob->record[i].values[1];

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 6
	mov	edx, DWORD PTR _pob$[ebp]
	add	ecx, DWORD PTR [edx+36]
	mov	eax, 8
	shl	eax, 0
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 6
	mov	esi, DWORD PTR _pob$[ebp]
	add	edx, DWORD PTR [esi+36]
	mov	esi, 8
	imul	esi, 0
	movsd	xmm0, QWORD PTR [ecx+eax+20]
	movsd	QWORD PTR [edx+esi+20], xmm0

; 869  :             pob->record[i].values[1] = t;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _pob$[ebp]
	add	eax, DWORD PTR [ecx+36]
	mov	edx, 8
	shl	edx, 0
	movsd	xmm0, QWORD PTR _t$1[ebp]
	movsd	QWORD PTR [eax+edx+20], xmm0
$LN10@Prof_creat:

; 870  :          }
; 871  : 
; 872  :          pob->record[i].heat = compute_heat(pob->record[i].heat, pob->record[i].values[0]);

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _pob$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	add	edx, eax
	mov	eax, 8
	imul	eax, 0
	sub	esp, 8
	movsd	xmm0, QWORD PTR [edx+eax+20]
	movsd	QWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 6
	mov	edx, DWORD PTR _pob$[ebp]
	mov	eax, DWORD PTR [edx+36]
	sub	esp, 8
	movsd	xmm0, QWORD PTR [eax+ecx+52]
	movsd	QWORD PTR [esp], xmm0
	call	_compute_heat
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 6
	mov	edx, DWORD PTR _pob$[ebp]
	mov	eax, DWORD PTR [edx+36]
	fstp	QWORD PTR [eax+ecx+52]

; 873  :       }

	jmp	$LN12@Prof_creat
$LN11@Prof_creat:

; 874  :          
; 875  :       qsort(pob->record, pob->num_record, sizeof(pob->record[0]), pob_compare);

	push	OFFSET _pob_compare
	push	64					; 00000040H
	mov	ecx, DWORD PTR _pob$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	mov	eax, DWORD PTR _pob$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	_qsort
	add	esp, 16					; 00000010H
$LN14@Prof_creat:

; 876  : 
; 877  :    }
; 878  : 
; 879  :    if (update_cursor) {

	cmp	DWORD PTR _update_cursor, 0
	je	SHORT $LN9@Prof_creat

; 880  :       for (i=0; i < pob->num_record; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN8@Prof_creat
$LN7@Prof_creat:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN8@Prof_creat:
	mov	eax, DWORD PTR _pob$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+28]
	jge	SHORT $LN6@Prof_creat

; 881  :          if (pob->record[i].zone == expand) {

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 6
	mov	eax, DWORD PTR _pob$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+edx+60]
	cmp	edx, DWORD PTR _expand
	jne	SHORT $LN5@Prof_creat

; 882  :             cursor = i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _cursor, eax

; 883  :             break;

	jmp	SHORT $LN6@Prof_creat
$LN5@Prof_creat:

; 884  :          }
; 885  :       }

	jmp	SHORT $LN7@Prof_creat
$LN6@Prof_creat:

; 886  :       update_cursor = 0;

	mov	DWORD PTR _update_cursor, 0
$LN9@Prof_creat:

; 887  :    }
; 888  : 
; 889  :    pob->header[0] = _strdup("zone");

	push	OFFSET ??_C@_04LDDJGOBB@zone?$AA@
	call	__strdup
	add	esp, 4
	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _pob$[ebp]
	mov	DWORD PTR [edx+ecx+8], eax

; 890  :    if (displayed_quantity == Prof_HIERARCHICAL_TIME) {

	cmp	DWORD PTR _displayed_quantity, 1
	jne	SHORT $LN4@Prof_creat

; 891  :       pob->header[1] = _strdup("hier");

	push	OFFSET ??_C@_04IFKEJOFI@hier?$AA@
	call	__strdup
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pob$[ebp]
	mov	DWORD PTR [edx+ecx+8], eax

; 892  :       pob->header[2] = _strdup("self");

	push	OFFSET ??_C@_04PJDNGLKJ@self?$AA@
	call	__strdup
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pob$[ebp]
	mov	DWORD PTR [edx+ecx+8], eax

; 893  :    } else {

	jmp	SHORT $LN3@Prof_creat
$LN4@Prof_creat:

; 894  :       pob->header[1] = _strdup("self");

	push	OFFSET ??_C@_04PJDNGLKJ@self?$AA@
	call	__strdup
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pob$[ebp]
	mov	DWORD PTR [edx+ecx+8], eax

; 895  :       pob->header[2] = _strdup("hier");

	push	OFFSET ??_C@_04IFKEJOFI@hier?$AA@
	call	__strdup
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pob$[ebp]
	mov	DWORD PTR [edx+ecx+8], eax
$LN3@Prof_creat:

; 896  :    }
; 897  :    pob->header[3] = _strdup("count");

	push	OFFSET ??_C@_05IOMEMJEC@count?$AA@
	call	__strdup
	add	esp, 4
	mov	ecx, 4
	imul	ecx, 3
	mov	edx, DWORD PTR _pob$[ebp]
	mov	DWORD PTR [edx+ecx+8], eax

; 898  : 
; 899  :    if (cursor < 0) cursor = 0;

	cmp	DWORD PTR _cursor, 0
	jge	SHORT $LN2@Prof_creat
	mov	DWORD PTR _cursor, 0
$LN2@Prof_creat:

; 900  :    if (cursor >= pob->num_record) cursor = pob->num_record-1;

	mov	eax, DWORD PTR _pob$[ebp]
	mov	ecx, DWORD PTR _cursor
	cmp	ecx, DWORD PTR [eax+28]
	jl	SHORT $LN1@Prof_creat
	mov	edx, DWORD PTR _pob$[ebp]
	mov	eax, DWORD PTR [edx+28]
	sub	eax, 1
	mov	DWORD PTR _cursor, eax
$LN1@Prof_creat:

; 901  :    pob->hilight = cursor;

	mov	ecx, DWORD PTR _pob$[ebp]
	mov	edx, DWORD PTR _cursor
	mov	DWORD PTR [ecx+32], edx

; 902  : 
; 903  :    return pob;

	mov	eax, DWORD PTR _pob$[ebp]

; 904  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_Prof_create_report ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\prof_process.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_z$ = 8							; size = 4
_Prof_free_report PROC

; 912  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 913  :    int i;
; 914  :    for (i=0; i < NUM_TITLE; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN8@Prof_free_
$LN7@Prof_free_:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN8@Prof_free_:
	cmp	DWORD PTR _i$[ebp], 2
	jge	SHORT $LN6@Prof_free_

; 915  :       if (z->title[i])

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [edx+ecx*4], 0
	je	SHORT $LN5@Prof_free_

; 916  :          free(z->title[i]);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_free
	add	esp, 4
$LN5@Prof_free_:

; 917  :    for (i=0; i < NUM_HEADER; ++i)

	jmp	SHORT $LN7@Prof_free_
$LN6@Prof_free_:
	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Prof_free_
$LN3@Prof_free_:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Prof_free_:
	cmp	DWORD PTR _i$[ebp], 5
	jge	SHORT $LN2@Prof_free_

; 918  :       if (z->header[i])

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _z$[ebp]
	cmp	DWORD PTR [edx+ecx*4+8], 0
	je	SHORT $LN1@Prof_free_

; 919  :          free(z->header[i]);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+8]
	push	edx
	call	_free
	add	esp, 4
$LN1@Prof_free_:

; 920  :    free(z->record);

	jmp	SHORT $LN3@Prof_free_
$LN2@Prof_free_:
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	_free
	add	esp, 4

; 921  :    free(z);

	mov	edx, DWORD PTR _z$[ebp]
	push	edx
	call	_free
	add	esp, 4

; 922  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Prof_free_report ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\prof_process.c
_TEXT	SEGMENT
_e$ = 8							; size = 4
_Prof_set_recursion PROC

; 1032 : {

	push	ebp
	mov	ebp, esp

; 1033 :    recurse = e;

	mov	eax, DWORD PTR _e$[ebp]
	mov	DWORD PTR _recurse, eax

; 1034 : }

	pop	ebp
	ret	0
_Prof_set_recursion ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\prof_process.c
_TEXT	SEGMENT
_Prof_dumpOverlay PROC

; 257  : {

	push	ebp
	mov	ebp, esp

; 258  : #ifdef Prof_ENABLED
; 259  : 	Prof_Report* pob = Prof_create_report();
; 260  : 
; 261  : #define MAX_LINE_NUM 35
; 262  : #define MAX_LINE_LENGTH 100
; 263  : 
; 264  : 	char** line = (char**)calloc((MAX_LINE_NUM*4)+2,sizeof(char*)); // the '+2' is for the 2 title char*
; 265  : 
; 266  : 	int i = 0;
; 267  : 	int j;
; 268  : 	int in = 0;
; 269  : 	int linecount = 0;
; 270  : 
; 271  : #if 0
; 272  : 	for (i=0; i < NUM_TITLE; ++i)
; 273  : 	{
; 274  : 		if (pob->title[i])
; 275  : 		{
; 276  : 			line[linecount] = (char*)malloc(MAX_LINE_LENGTH);
; 277  : 			strcpy(line[linecount],pob->title[i]);
; 278  : 			linecount++;
; 279  : 		}
; 280  : 	}
; 281  : #else
; 282  : 	int index = 0;
; 283  : 	// pob->title[0] holds info bout frametime, avg fps etc - shoud be there everytime
; 284  : 	// pob->title[1] (may) hold the speedstep-like timer warning thingie..
; 285  : 	for (index = 0; index < 2; index++)
; 286  : 	{
; 287  : 		if (pob->title[index])
; 288  : 		{
; 289  : 			line[linecount] = (char*)malloc(MAX_LINE_LENGTH);
; 290  : 			strcpy(line[linecount],pob->title[index]);
; 291  : 		}
; 292  : 		else
; 293  : 			line[linecount] = (char*)0;
; 294  : 		linecount++;
; 295  : 	}
; 296  : 
; 297  : #endif
; 298  : 
; 299  : 	for (i = 0; i < pob->num_record; i++)
; 300  : 	{
; 301  : 		char buf[256], *b = buf;
; 302  : 		Prof_Report_Record *r = &pob->record[i];
; 303  : 
; 304  : 		if (i >= (MAX_LINE_NUM*4))
; 305  : 		{
; 306  : 			break;
; 307  : 		}
; 308  : 
; 309  : 		// first we create a char* with the name of the scope
; 310  : 		line[linecount] = (char*)malloc(MAX_LINE_LENGTH);
; 311  : 
; 312  : 		if (r->indent > 0)
; 313  : 		{
; 314  : 			strcpy(line[linecount]," ");
; 315  : 			for (in = 1; in < r->indent; in++)
; 316  : 				strcat(line[linecount]," ");
; 317  : 			if (r->prefix)
; 318  : 				strcat(line[linecount],"+");
; 319  : 			else
; 320  : 				strcat(line[linecount]," ");
; 321  : 			strcat(line[linecount],r->name);
; 322  : 		}
; 323  : 		else
; 324  : 		{
; 325  : 			if (r->prefix)
; 326  : 			{
; 327  : 				strcpy(line[linecount],"+");
; 328  : 			}
; 329  : 			else
; 330  : 				strcpy(line[linecount]," ");
; 331  : 
; 332  : 			strcat(line[linecount],r->name);
; 333  : 		}
; 334  : 		linecount++;
; 335  : 
; 336  : 		// now we create 3 char* with the self, hier and count values
; 337  : 		for (j = 0; j < NUM_VALUES; ++j)
; 338  : 		{
; 339  : 			if (r->value_flag & (1 << j))
; 340  : 			{
; 341  : 				char tmp[80];
; 342  : 				sprintf(tmp,"%.6f",r->values[j]);
; 343  : 				line[linecount] = (char*)malloc(MAX_LINE_LENGTH);
; 344  : 				strcpy(line[linecount],tmp);
; 345  : 				linecount++;
; 346  : 			}
; 347  : 		}
; 348  : 	}
; 349  : 
; 350  : 	Prof_free_report(pob);
; 351  : 	return line;
; 352  : #else	// #ifdef Prof_ENABLED
; 353  : 	return 0;

	xor	eax, eax

; 354  : #endif	// #ifdef Prof_ENABLED
; 355  : }

	pop	ebp
	ret	0
_Prof_dumpOverlay ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\prof_process.c
_TEXT	SEGMENT
_Prof_dumpFile PROC

; 195  : {

	push	ebp
	mov	ebp, esp

; 196  : #ifdef Prof_ENABLED
; 197  : 	FILE* fp = fopen("report.txt","at");
; 198  : 	Prof_Report* pob = Prof_create_report();
; 199  : 
; 200  : 	int i,j;
; 201  : 	int max_records = 500;
; 202  : 	int in = 0;
; 203  : 
; 204  : 
; 205  : 	for (i=0; i < NUM_TITLE; ++i)
; 206  : 	{
; 207  : 		if (pob->title[i])
; 208  : 		{
; 209  : 			fprintf(fp,"%s,",pob->title[i]);
; 210  : 		}
; 211  : 	}
; 212  : 
; 213  : 	fprintf(fp,"\n");
; 214  : 
; 215  : 
; 216  : 	for (j=0; j < NUM_HEADER; ++j)
; 217  : 		if (pob->header[j])
; 218  : 			fprintf(fp,"%s,",pob->header[j]);
; 219  : 
; 220  : 	fprintf(fp,"\n");
; 221  : 
; 222  : 	for (i = 0; i < pob->num_record; i++)
; 223  : 	{
; 224  : 		char buf[256], *b = buf;
; 225  : 		Prof_Report_Record *r = &pob->record[i];
; 226  : 
; 227  : 		for (in = 0; in < r->indent; in++)
; 228  : 			fprintf(fp," ");
; 229  : 		
; 230  : 		fprintf(fp,"%s,",r->name);
; 231  : 
; 232  : 		for (j=0; j < NUM_VALUES; ++j)
; 233  : 		{
; 234  : 			if (r->value_flag & (1 << j))
; 235  : 			{
; 236  : 				fprintf(fp,"%.4f,",r->values[j]);
; 237  : 			}
; 238  : 		}
; 239  : 		fprintf(fp,"\n");
; 240  : 	}
; 241  : 
; 242  : 	Prof_free_report(pob);
; 243  : 	fclose(fp);
; 244  : #endif	// #ifdef Prof_ENABLED
; 245  : }

	pop	ebp
	ret	0
_Prof_dumpFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\prof_process.c
_TEXT	SEGMENT
_num$ = 8						; size = 4
_Prof_set_cursor PROC

; 950  : {

	push	ebp
	mov	ebp, esp

; 951  :    cursor = num;

	mov	eax, DWORD PTR _num$[ebp]
	mov	DWORD PTR _cursor, eax

; 952  : }

	pop	ebp
	ret	0
_Prof_set_cursor ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\prof_process.c
_TEXT	SEGMENT
_num$ = 8						; size = 4
_Prof_set_frame PROC

; 998  : {

	push	ebp
	mov	ebp, esp

; 999  :    if (num < 0) num = 0;

	cmp	DWORD PTR _num$[ebp], 0
	jge	SHORT $LN2@Prof_set_f
	mov	DWORD PTR _num$[ebp], 0
$LN2@Prof_set_f:

; 1000 :    if (num >= NUM_FRAME_SLOTS) num = NUM_FRAME_SLOTS-1;

	cmp	DWORD PTR _num$[ebp], 128		; 00000080H
	jl	SHORT $LN1@Prof_set_f
	mov	DWORD PTR _num$[ebp], 127		; 0000007fH
$LN1@Prof_set_f:

; 1001 : 
; 1002 :    display_frame = num;

	mov	eax, DWORD PTR _num$[ebp]
	mov	DWORD PTR _display_frame, eax

; 1003 : }

	pop	ebp
	ret	0
_Prof_set_frame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\prof_process.c
_TEXT	SEGMENT
_x$ = 8							; size = 4
_Prof_set_smoothing PROC

; 1022 : {

	push	ebp
	mov	ebp, esp

; 1023 :    if (x <= 0) x = 0;

	cmp	DWORD PTR _x$[ebp], 0
	jg	SHORT $LN2@Prof_set_s
	mov	DWORD PTR _x$[ebp], 0
$LN2@Prof_set_s:

; 1024 :    if (x >= NUM_PROFILE_TRACKER_HISTORY_SLOTS)

	cmp	DWORD PTR _x$[ebp], 3
	jl	SHORT $LN1@Prof_set_s

; 1025 :       x = NUM_PROFILE_TRACKER_HISTORY_SLOTS-1;

	mov	DWORD PTR _x$[ebp], 2
$LN1@Prof_set_s:

; 1026 : 
; 1027 :    slot = x;

	mov	eax, DWORD PTR _x$[ebp]
	mov	DWORD PTR _slot, eax

; 1028 : }

	pop	ebp
	ret	0
_Prof_set_smoothing ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\prof_process.c
_TEXT	SEGMENT
_delta$ = 8						; size = 4
_Prof_move_frame PROC

; 1011 : {

	push	ebp
	mov	ebp, esp

; 1012 :    // convert so negative delta = "into the past"
; 1013 :    Prof_set_frame(display_frame - delta);

	mov	eax, DWORD PTR _display_frame
	sub	eax, DWORD PTR _delta$[ebp]
	push	eax
	call	_Prof_set_frame
	add	esp, 4

; 1014 : }

	pop	ebp
	ret	0
_Prof_move_frame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\prof_process.c
_TEXT	SEGMENT
_old$ = -12						; size = 4
_b$ = -8						; size = 4
_i$ = -4						; size = 4
_Prof_select_parent PROC

; 979  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 980  :    int i;
; 981  :    void *old = (void *) expand;

	mov	eax, DWORD PTR _expand
	mov	DWORD PTR _old$[ebp], eax

; 982  :    Prof_Report *b = Prof_create_report();

	call	_Prof_create_report
	mov	DWORD PTR _b$[ebp], eax

; 983  :    for (i=0; i < b->num_record; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN5@Prof_selec
$LN4@Prof_selec:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN5@Prof_selec:
	mov	edx, DWORD PTR _b$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+28]
	jge	SHORT $LN3@Prof_selec

; 984  :       if (b->record[i].indent == 0) break;

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 6
	mov	edx, DWORD PTR _b$[ebp]
	mov	eax, DWORD PTR [edx+36]
	cmp	DWORD PTR [eax+ecx], 0
	jne	SHORT $LN2@Prof_selec
	jmp	SHORT $LN3@Prof_selec
$LN2@Prof_selec:

; 985  :       if (b->record[i].zone == old) continue;

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 6
	mov	edx, DWORD PTR _b$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx+60]
	cmp	ecx, DWORD PTR _old$[ebp]
	jne	SHORT $LN1@Prof_selec
	jmp	SHORT $LN4@Prof_selec
$LN1@Prof_selec:

; 986  :       expand = (Prof_Zone *) b->record[i].zone;

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 6
	mov	eax, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+edx+60]
	mov	DWORD PTR _expand, edx

; 987  :    }

	jmp	SHORT $LN4@Prof_selec
$LN3@Prof_selec:

; 988  :    Prof_free_report(b);

	mov	eax, DWORD PTR _b$[ebp]
	push	eax
	call	_Prof_free_report
	add	esp, 4

; 989  :    update_cursor = 1;

	mov	DWORD PTR _update_cursor, 1

; 990  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Prof_select_parent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\prof_process.c
_TEXT	SEGMENT
_z$1 = -8						; size = 4
_b$ = -4						; size = 4
_Prof_select PROC

; 960  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 961  :    Prof_Report *b = Prof_create_report();

	call	_Prof_create_report
	mov	DWORD PTR _b$[ebp], eax

; 962  :    if (b->hilight >= 0) {

	mov	eax, DWORD PTR _b$[ebp]
	cmp	DWORD PTR [eax+32], 0
	jl	SHORT $LN2@Prof_selec

; 963  :       void *z = b->record[b->hilight].zone;

	mov	ecx, DWORD PTR _b$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	shl	edx, 6
	mov	eax, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+edx+60]
	mov	DWORD PTR _z$1[ebp], edx

; 964  :       if (z != NULL) {

	cmp	DWORD PTR _z$1[ebp], 0
	je	SHORT $LN2@Prof_selec

; 965  :          expand = (Prof_Zone *) z;

	mov	eax, DWORD PTR _z$1[ebp]
	mov	DWORD PTR _expand, eax

; 966  :          displayed_quantity = Prof_CALL_GRAPH;

	mov	DWORD PTR _displayed_quantity, 2
$LN2@Prof_selec:

; 967  :       }
; 968  :    }
; 969  :    Prof_free_report(b);

	mov	ecx, DWORD PTR _b$[ebp]
	push	ecx
	call	_Prof_free_report
	add	esp, 4

; 970  :    update_cursor = 1;

	mov	DWORD PTR _update_cursor, 1

; 971  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Prof_select ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\prof_process.c
_TEXT	SEGMENT
_num$ = 8						; size = 4
_Prof_move_cursor PROC

; 940  : {

	push	ebp
	mov	ebp, esp

; 941  :    cursor += num;

	mov	eax, DWORD PTR _cursor
	add	eax, DWORD PTR _num$[ebp]
	mov	DWORD PTR _cursor, eax

; 942  : }

	pop	ebp
	ret	0
_Prof_move_cursor ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\prof_process.c
_TEXT	SEGMENT
_Prof_get_cursor PROC

; 930  : {

	push	ebp
	mov	ebp, esp

; 931  : 	return cursor;

	mov	eax, DWORD PTR _cursor

; 932  : }

	pop	ebp
	ret	0
_Prof_get_cursor ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\prof_process.c
_TEXT	SEGMENT
_desired$ = 8						; size = 4
_Prof_set_report_mode PROC

; 176  : {

	push	ebp
	mov	ebp, esp

; 177  :    displayed_quantity = desired;

	mov	eax, DWORD PTR _desired$[ebp]
	mov	DWORD PTR _displayed_quantity, eax

; 178  : }

	pop	ebp
	ret	0
_Prof_set_report_mode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\prof_process.c
_TEXT	SEGMENT
_record_data$ = 8					; size = 4
_Prof_update PROC

; 452  : {

	push	ebp
	mov	ebp, esp

; 453  : #ifdef Prof_ENABLED
; 454  :    Prof_Begin(iprof_update)
; 455  : 
; 456  :    static History_Scalar integer_timestamps_per_second;
; 457  :    static Prof_Int64 last_integer_timestamp;
; 458  :    static Prof_Int64 current_integer_timestamp;
; 459  : 
; 460  :    int i;
; 461  :    double now, dt;
; 462  :    Prof_Int64 timestamp_delta;
; 463  :    double timestamps_per_second;
; 464  : 
; 465  :    assert(Prof_num_zones <= MAX_PROFILING_ZONES);
; 466  : 
; 467  :    Prof_traverse(propogate_stack);
; 468  : 
; 469  :    // Precompute the time factors
; 470  : 
; 471  :    now = Prof_get_time();
; 472  : 
; 473  :    if (update_index == 0) {
; 474  :       dt = FRAME_TIME_INITIAL;
; 475  :    } else {
; 476  :       dt = now - last_update_time;
; 477  :       if (dt == 0) dt = FRAME_TIME_INITIAL;
; 478  :    }
; 479  : 
; 480  :    last_update_time = now;
; 481  : 
; 482  :    for (i = 0; i < NUM_PROFILE_TRACKER_HISTORY_SLOTS; i++) {
; 483  :       precomputed_factors[i] = pow(0.1f, dt / times_to_reach_90_percent[i]);
; 484  :    }
; 485  : 
; 486  :    precomputed_factors[0] = 0; // instantaneous.
; 487  : 
; 488  :    Prof_get_timestamp(&current_integer_timestamp);
; 489  :    if (update_index == 0) {
; 490  :       sum = 0;
; 491  :       Prof_traverse(sum_times);
; 492  :       if (sum == 0) sum = 1;
; 493  :       timestamp_delta = (Prof_Int64) sum;
; 494  :    } else {
; 495  :       timestamp_delta = current_integer_timestamp - last_integer_timestamp;
; 496  :       if (timestamp_delta == 0) timestamp_delta = 1;
; 497  :    }
; 498  : 
; 499  :    last_integer_timestamp = current_integer_timestamp;
; 500  :    timestamps_per_second = (double) timestamp_delta / dt;
; 501  : 
; 502  :    if (update_index < NUM_THROWAWAY_UPDATES) {
; 503  :       eternity_set(&integer_timestamps_per_second, timestamps_per_second);
; 504  :    } else {
; 505  :       update(&integer_timestamps_per_second, timestamps_per_second, precomputed_factors);
; 506  :    }
; 507  : 
; 508  :    {
; 509  :       const int ss_slot = 1;
; 510  :       double ss_val, ss_variance, ss_stdev, ss_ratio;
; 511  : 
; 512  :       ss_val = integer_timestamps_per_second.values[ss_slot];
; 513  :       ss_variance = integer_timestamps_per_second.variances[ss_slot] - ss_val*ss_val;
; 514  :       ss_stdev = sqrt(fabs(ss_variance));
; 515  :       ss_ratio;
; 516  :       if (ss_val) {
; 517  :          ss_ratio = ss_stdev / fabs(ss_val);
; 518  :       } else {
; 519  :          ss_ratio = 0;
; 520  :       }
; 521  : 
; 522  :       speedstep_warning = (ss_ratio > SPEEDSTEP_DETECTION_RATIO);
; 523  :    }
; 524  : 
; 525  :    if (!record_data) {
; 526  :       Prof_traverse(clear_stack);
; 527  :       Prof_End
; 528  :       return;
; 529  :    }
; 530  :    
; 531  :    if (timestamps_per_second) {
; 532  :       timestamps_to_seconds = 1.0 / timestamps_per_second;
; 533  :    } else {
; 534  :       timestamps_to_seconds = 0;
; 535  :    }
; 536  : 
; 537  : #ifdef Prof_ZONE_HISTORY
; 538  :    for (i=0; i < Prof_num_zones; ++i) {
; 539  :       Prof_zones[i]->highlevel = (void *) &zone_history[i][history_index];
; 540  :       zone_history[i][history_index] = 0;
; 541  :    }
; 542  : #endif
; 543  : 
; 544  :    Prof_traverse(update_history);
; 545  : 
; 546  :    update(&frame_time, dt, precomputed_factors);
; 547  : 
; 548  :    ++update_index;
; 549  :    history_index = (history_index + 1) % NUM_FRAME_SLOTS;
; 550  : 
; 551  :    Prof_traverse(clear_stack);
; 552  : 
; 553  :    Prof_End
; 554  : #endif // Prof_ENABLED
; 555  : }

	pop	ebp
	ret	0
_Prof_update ENDP
_TEXT	ENDS
END
