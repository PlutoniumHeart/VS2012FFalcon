; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\FALCLIB\prof_gather.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_Prof_stack
_DATA	SEGMENT
COMM	_Prof_dummy:BYTE:02cH
COMM	_Prof_num_zones:DWORD
COMM	_Prof_dummy2:BYTE:02cH
_DATA	ENDS
_BSS	SEGMENT
_zone_hash_mask DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
_Prof_stack DD	FLAT:_Prof_dummy2
_init_hash DD	FLAT:_Prof_dummy
_zone_hash DD	FLAT:_init_hash
_zone_hash_count DD 01H
_zone_hash_max DD 01H
_DATA	ENDS
PUBLIC	_Prof_StackAppend
PUBLIC	_Prof_traverse
EXTRN	_malloc:PROC
EXTRN	_Prof_init_highlevel:PROC
EXTRN	_Prof_zones:BYTE
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\prof_gather.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_func$ = 8						; size = 4
_Prof_traverse PROC

; 148  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 149  :    int i;
; 150  :    for (i=0; i < zone_hash_max; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Prof_trave
$LN3@Prof_trave:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Prof_trave:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _zone_hash_max
	jge	SHORT $LN5@Prof_trave

; 151  :       if (zone_hash[i] != &Prof_dummy)

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _zone_hash
	cmp	DWORD PTR [eax+edx*4], OFFSET _Prof_dummy
	je	SHORT $LN1@Prof_trave

; 152  :          func(zone_hash[i]);

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _zone_hash
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	DWORD PTR _func$[ebp]
	add	esp, 4
$LN1@Prof_trave:

; 153  : }

	jmp	SHORT $LN3@Prof_trave
$LN5@Prof_trave:
	mov	esp, ebp
	pop	ebp
	ret	0
_Prof_traverse ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\prof_gather.c
_TEXT	SEGMENT
_Prof_init_lowlevel PROC

; 156  : {

	push	ebp
	mov	ebp, esp

; 157  :    init_zone_hash(INIT_HASH_SIZE);

	push	256					; 00000100H
	call	_init_zone_hash
	add	esp, 4

; 158  : 
; 159  :    Prof_init_highlevel();

	call	_Prof_init_highlevel

; 160  : 
; 161  :    // intentionally unbalanced, this wraps everything else
; 162  :    {
; 163  :       Prof_Region(_global)
; 164  :    }
; 165  : }

	pop	ebp
	ret	0
_Prof_init_lowlevel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\prof_gather.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_size$ = 8						; size = 4
_init_zone_hash PROC

; 79   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 80   :    int i;
; 81   :    assert(size <= MAX_HASH_SIZE);
; 82   :    zone_hash_max   = size;

	mov	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _zone_hash_max, eax

; 83   :    zone_hash_count = 0;

	mov	DWORD PTR _zone_hash_count, 0

; 84   :    zone_hash       = (Prof_Zone_Stack **) malloc(sizeof(*zone_hash) * zone_hash_max);

	mov	ecx, DWORD PTR _zone_hash_max
	shl	ecx, 2
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _zone_hash, eax

; 85   :    zone_hash_mask  = size-1;

	mov	edx, DWORD PTR _size$[ebp]
	sub	edx, 1
	mov	DWORD PTR _zone_hash_mask, edx

; 86   :    for (i=0; i < zone_hash_max; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@init_zone_
$LN2@init_zone_:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@init_zone_:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _zone_hash_max
	jge	SHORT $LN4@init_zone_

; 87   :       zone_hash[i] = &Prof_dummy;

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _zone_hash
	mov	DWORD PTR [eax+edx*4], OFFSET _Prof_dummy
	jmp	SHORT $LN2@init_zone_
$LN4@init_zone_:

; 88   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_init_zone_hash ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\prof_gather.c
_TEXT	SEGMENT
_z$ = -4						; size = 4
_zone$ = 8						; size = 4
_parent$ = 12						; size = 4
_createStackNode PROC

; 64   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 65   :    // create a new node
; 66   :    Prof_Zone_Stack *z = (Prof_Zone_Stack *) malloc(sizeof(*z));

	push	44					; 0000002cH
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _z$[ebp], eax

; 67   :    z->zone = zone;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR _zone$[ebp]
	mov	DWORD PTR [eax+32], ecx

; 68   :    z->parent = parent;

	mov	edx, DWORD PTR _z$[ebp]
	mov	eax, DWORD PTR _parent$[ebp]
	mov	DWORD PTR [edx+28], eax

; 69   :    z->total_entry_count = 0;

	mov	ecx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [ecx+24], 0

; 70   :    z->total_hier_ticks = 0;

	mov	edx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	DWORD PTR [edx+20], 0

; 71   :    z->total_self_ticks = 0;

	mov	eax, DWORD PTR _z$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax+12], 0

; 72   :    z->t_self_start = 0;

	mov	ecx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+4], 0

; 73   :    z->highlevel = NULL;

	mov	edx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [edx+40], 0

; 74   :    z->recursion_depth = count_recursion_depth(parent, zone);

	mov	eax, DWORD PTR _zone$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_count_recursion_depth
	add	esp, 8
	mov	edx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [edx+36], eax

; 75   :    return z;

	mov	eax, DWORD PTR _z$[ebp]

; 76   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_createStackNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\prof_gather.c
_TEXT	SEGMENT
_n$ = -4						; size = 4
_stack$ = 8						; size = 4
_zone$ = 12						; size = 4
_count_recursion_depth PROC

; 53   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 54   :    int n=0;

	mov	DWORD PTR _n$[ebp], 0
$LN3@count_recu:

; 55   :    while (stack) {

	cmp	DWORD PTR _stack$[ebp], 0
	je	SHORT $LN2@count_recu

; 56   :       if (stack->zone == zone)

	mov	eax, DWORD PTR _stack$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	cmp	ecx, DWORD PTR _zone$[ebp]
	jne	SHORT $LN1@count_recu

; 57   :          ++n;

	mov	edx, DWORD PTR _n$[ebp]
	add	edx, 1
	mov	DWORD PTR _n$[ebp], edx
$LN1@count_recu:

; 58   :       stack = stack->parent;

	mov	eax, DWORD PTR _stack$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR _stack$[ebp], ecx

; 59   :    }

	jmp	SHORT $LN3@count_recu
$LN2@count_recu:

; 60   :    return n;

	mov	eax, DWORD PTR _n$[ebp]

; 61   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_count_recursion_depth ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\prof_gather.c
_TEXT	SEGMENT
_zone$ = 8						; size = 4
_init_zone PROC

; 46   : {

	push	ebp
	mov	ebp, esp

; 47   :    Prof_zones[Prof_num_zones++] = zone;

	mov	eax, DWORD PTR _Prof_num_zones
	mov	ecx, DWORD PTR _zone$[ebp]
	mov	DWORD PTR _Prof_zones[eax*4], ecx
	mov	edx, DWORD PTR _Prof_num_zones
	add	edx, 1
	mov	DWORD PTR _Prof_num_zones, edx

; 48   : 
; 49   :    zone->initialized = 1;

	mov	eax, DWORD PTR _zone$[ebp]
	mov	BYTE PTR [eax+8], 1

; 50   : }

	pop	ebp
	ret	0
_init_zone ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\prof_gather.c
_TEXT	SEGMENT
_s$ = -12						; size = 4
_h$ = -8						; size = 4
_x$ = -4						; size = 4
_q$ = 8							; size = 4
_insert_node PROC

; 32   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 33   :    int h = hash(q->zone, q->parent);

	mov	eax, DWORD PTR _q$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	edx, DWORD PTR _q$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	call	_hash
	add	esp, 8
	mov	DWORD PTR _h$[ebp], eax

; 34   :    int x = h & zone_hash_mask;

	mov	ecx, DWORD PTR _h$[ebp]
	and	ecx, DWORD PTR _zone_hash_mask
	mov	DWORD PTR _x$[ebp], ecx

; 35   :    int s = ((h << 4) + (h >> 4)) | 1;

	mov	edx, DWORD PTR _h$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _h$[ebp]
	sar	eax, 4
	add	edx, eax
	or	edx, 1
	mov	DWORD PTR _s$[ebp], edx
$LN2@insert_nod:

; 36   : 
; 37   :    while (zone_hash[x] != &Prof_dummy)

	mov	ecx, DWORD PTR _x$[ebp]
	mov	edx, DWORD PTR _zone_hash
	cmp	DWORD PTR [edx+ecx*4], OFFSET _Prof_dummy
	je	SHORT $LN1@insert_nod

; 38   :       x = (x + s) & zone_hash_mask;

	mov	eax, DWORD PTR _x$[ebp]
	add	eax, DWORD PTR _s$[ebp]
	and	eax, DWORD PTR _zone_hash_mask
	mov	DWORD PTR _x$[ebp], eax
	jmp	SHORT $LN2@insert_nod
$LN1@insert_nod:

; 39   : 
; 40   :    zone_hash[x] = q;

	mov	ecx, DWORD PTR _x$[ebp]
	mov	edx, DWORD PTR _zone_hash
	mov	eax, DWORD PTR _q$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 41   : 
; 42   :    ++zone_hash_count;

	mov	ecx, DWORD PTR _zone_hash_count
	add	ecx, 1
	mov	DWORD PTR _zone_hash_count, ecx

; 43   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_insert_node ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\prof_gather.c
_TEXT	SEGMENT
_n$ = -4						; size = 4
_z$ = 8							; size = 4
_s$ = 12						; size = 4
_hash	PROC

; 26   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 27   :    int n = (int) z + (int) s;

	mov	eax, DWORD PTR _z$[ebp]
	add	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR _n$[ebp], eax

; 28   :    return n + (n >> 8);

	mov	eax, DWORD PTR _n$[ebp]
	sar	eax, 8
	add	eax, DWORD PTR _n$[ebp]

; 29   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_hash	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\prof_gather.c
_TEXT	SEGMENT
_n$1 = -36						; size = 4
_s$ = -32						; size = 4
tv146 = -28						; size = 4
_z$2 = -24						; size = 4
_old_hash$3 = -20					; size = 4
_h$ = -16						; size = 4
_x$ = -12						; size = 4
_i$4 = -8						; size = 4
_z$ = -4						; size = 4
_zone$ = 8						; size = 4
_Prof_StackAppend PROC

; 95   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 96   :    int h = hash(zone, Prof_stack), s;

	mov	eax, DWORD PTR _Prof_stack
	push	eax
	mov	ecx, DWORD PTR _zone$[ebp]
	push	ecx
	call	_hash
	add	esp, 8
	mov	DWORD PTR _h$[ebp], eax

; 97   :    int x = h & zone_hash_mask;

	mov	edx, DWORD PTR _h$[ebp]
	and	edx, DWORD PTR _zone_hash_mask
	mov	DWORD PTR _x$[ebp], edx

; 98   :    Prof_Zone_Stack *z = zone_hash[x];

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _zone_hash
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _z$[ebp], edx

; 99   :    if (z->parent == Prof_stack && z->zone == zone) return z;

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	cmp	ecx, DWORD PTR _Prof_stack
	jne	SHORT $LN13@Prof_Stack
	mov	edx, DWORD PTR _z$[ebp]
	mov	eax, DWORD PTR [edx+32]
	cmp	eax, DWORD PTR _zone$[ebp]
	jne	SHORT $LN13@Prof_Stack
	mov	eax, DWORD PTR _z$[ebp]
	jmp	$LN14@Prof_Stack
$LN13@Prof_Stack:

; 100  :    if (z != &Prof_dummy) {

	cmp	DWORD PTR _z$[ebp], OFFSET _Prof_dummy
	je	SHORT $LN12@Prof_Stack

; 101  : 
; 102  :       // compute a secondary hash function; force it to be odd
; 103  :       // so it's relatively prime to the power-of-two table size
; 104  :       s = ((h << 4) + (h >> 4)) | 1;

	mov	ecx, DWORD PTR _h$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _h$[ebp]
	sar	edx, 4
	add	ecx, edx
	or	ecx, 1
	mov	DWORD PTR _s$[ebp], ecx
$LN11@Prof_Stack:

; 105  :       for(;;) {
; 106  :          x = (x + s) & zone_hash_mask;

	mov	eax, DWORD PTR _x$[ebp]
	add	eax, DWORD PTR _s$[ebp]
	and	eax, DWORD PTR _zone_hash_mask
	mov	DWORD PTR _x$[ebp], eax

; 107  :          z = zone_hash[x];

	mov	ecx, DWORD PTR _x$[ebp]
	mov	edx, DWORD PTR _zone_hash
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _z$[ebp], eax

; 108  :          if (z->parent == Prof_stack && z->zone == zone) return z;

	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	cmp	edx, DWORD PTR _Prof_stack
	jne	SHORT $LN9@Prof_Stack
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	cmp	ecx, DWORD PTR _zone$[ebp]
	jne	SHORT $LN9@Prof_Stack
	mov	eax, DWORD PTR _z$[ebp]
	jmp	$LN14@Prof_Stack
$LN9@Prof_Stack:

; 109  :          if (z == &Prof_dummy) break;

	cmp	DWORD PTR _z$[ebp], OFFSET _Prof_dummy
	jne	SHORT $LN8@Prof_Stack
	jmp	SHORT $LN12@Prof_Stack
$LN8@Prof_Stack:

; 110  :       }

	jmp	SHORT $LN11@Prof_Stack
$LN12@Prof_Stack:

; 111  :       // loop is guaranteed to terminate because the hash table is never full
; 112  :    }
; 113  : 
; 114  :    // now's as good a time as any to initialize this zone
; 115  :    if (!zone->initialized) {

	mov	edx, DWORD PTR _zone$[ebp]
	movsx	eax, BYTE PTR [edx+8]
	test	eax, eax
	jne	SHORT $LN7@Prof_Stack

; 116  :       if (zone_hash_max == 1) {

	cmp	DWORD PTR _zone_hash_max, 1
	jne	SHORT $LN6@Prof_Stack

; 117  :          Prof_init_lowlevel();

	call	_Prof_init_lowlevel

; 118  :          // the above is reentrant since it initializes _global
; 119  :          // so now invariants are broken, so start over
; 120  :          return Prof_StackAppend(zone);

	mov	ecx, DWORD PTR _zone$[ebp]
	push	ecx
	call	_Prof_StackAppend
	add	esp, 4
	jmp	$LN14@Prof_Stack
$LN6@Prof_Stack:

; 121  :       }
; 122  :       init_zone(zone);

	mov	edx, DWORD PTR _zone$[ebp]
	push	edx
	call	_init_zone
	add	esp, 4
$LN7@Prof_Stack:

; 123  :    }
; 124  : 
; 125  :    // check if we need to grow the table
; 126  :    // we keep it at most 1/2 full to be very fast
; 127  :    if (zone_hash_count*2 > zone_hash_max) {

	mov	eax, DWORD PTR _zone_hash_count
	shl	eax, 1
	cmp	eax, DWORD PTR _zone_hash_max
	jle	$LN5@Prof_Stack

; 128  :       Prof_Zone_Stack **old_hash = zone_hash, *z;

	mov	ecx, DWORD PTR _zone_hash
	mov	DWORD PTR _old_hash$3[ebp], ecx

; 129  :       int i,n = zone_hash_max;

	mov	edx, DWORD PTR _zone_hash_max
	mov	DWORD PTR _n$1[ebp], edx

; 130  : 
; 131  :       init_zone_hash(zone_hash_max*2);

	mov	eax, DWORD PTR _zone_hash_max
	shl	eax, 1
	push	eax
	call	_init_zone_hash
	add	esp, 4

; 132  : 
; 133  :       for (i=0; i < n; ++i)

	mov	DWORD PTR _i$4[ebp], 0
	jmp	SHORT $LN4@Prof_Stack
$LN3@Prof_Stack:
	mov	ecx, DWORD PTR _i$4[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$4[ebp], ecx
$LN4@Prof_Stack:
	mov	edx, DWORD PTR _i$4[ebp]
	cmp	edx, DWORD PTR _n$1[ebp]
	jge	SHORT $LN2@Prof_Stack

; 134  :          if (old_hash[i] != &Prof_dummy)

	mov	eax, DWORD PTR _i$4[ebp]
	mov	ecx, DWORD PTR _old_hash$3[ebp]
	cmp	DWORD PTR [ecx+eax*4], OFFSET _Prof_dummy
	je	SHORT $LN1@Prof_Stack

; 135  :             insert_node(old_hash[i]);

	mov	edx, DWORD PTR _i$4[ebp]
	mov	eax, DWORD PTR _old_hash$3[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	_insert_node
	add	esp, 4
$LN1@Prof_Stack:

; 136  : 
; 137  :       z = createStackNode(zone, Prof_stack);

	jmp	SHORT $LN3@Prof_Stack
$LN2@Prof_Stack:
	mov	edx, DWORD PTR _Prof_stack
	push	edx
	mov	eax, DWORD PTR _zone$[ebp]
	push	eax
	call	_createStackNode
	add	esp, 8
	mov	DWORD PTR _z$2[ebp], eax

; 138  :       insert_node(z);

	mov	ecx, DWORD PTR _z$2[ebp]
	push	ecx
	call	_insert_node
	add	esp, 4

; 139  :       return z;

	mov	eax, DWORD PTR _z$2[ebp]
	jmp	SHORT $LN14@Prof_Stack
$LN5@Prof_Stack:

; 140  :    }
; 141  : 
; 142  :    // insert new entry in hash table
; 143  :    ++zone_hash_count;

	mov	edx, DWORD PTR _zone_hash_count
	add	edx, 1
	mov	DWORD PTR _zone_hash_count, edx

; 144  :    return zone_hash[x] = createStackNode(zone, Prof_stack);

	mov	eax, DWORD PTR _Prof_stack
	push	eax
	mov	ecx, DWORD PTR _zone$[ebp]
	push	ecx
	call	_createStackNode
	add	esp, 8
	mov	DWORD PTR tv146[ebp], eax
	mov	edx, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR _zone_hash
	mov	ecx, DWORD PTR tv146[ebp]
	mov	DWORD PTR [eax+edx*4], ecx
	mov	eax, DWORD PTR tv146[ebp]
$LN14@Prof_Stack:

; 145  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Prof_StackAppend ENDP
_TEXT	ENDS
END
