; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\FALCLIB\ehandler.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?g_CardDetails@@3PADA				; g_CardDetails
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
_BSS	SEGMENT
?g_CardDetails@@3PADA DB 0400H DUP (?)			; g_CardDetails
_BSS	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
PUBLIC	?strrchr@@YAPADPADH@Z				; strrchr
PUBLIC	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ		; VuBin<VuSessionEntity>::operator bool
PUBLIC	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
PUBLIC	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
PUBLIC	?Online@UIComms@@QAEHXZ				; UIComms::Online
PUBLIC	?RecordExceptionInfo@@YAHPAU_EXCEPTION_POINTERS@@PBD@Z ; RecordExceptionInfo
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_0BI@HKCLIKLE@?$CFd?1?$CFd?1?$CFd?5?$CF02d?3?$CF02d?3?$CF02d?$AA@ ; `string'
PUBLIC	??_C@_0BB@CJPAEIHC@?5?9?5file?5date?5is?5?$AA@	; `string'
PUBLIC	??_C@_0CL@CGOIOKCD@?$CFs?0?5loaded?5at?50x?$CF08x?5?9?5?$CFd?5bytes?5@ ; `string'
PUBLIC	??_C@_0EH@IAGPJNKE@?$AN?6?7Module?5list?3?5names?0?5addresses@ ; `string'
PUBLIC	??_C@_0BI@JNCPBKJH@Error?5occurred?5at?5?$CFs?4?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_07NBCGADJA@Unknown?$AA@			; `string'
PUBLIC	??_C@_0BB@GEKHAOPD@?$CFs?0?5run?5by?5?$CFs?4?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BM@CGPALIEL@?$CFd?5processor?$CIs?$CJ?0?5type?5?$CFd?4?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BN@PBHEHCOH@?$CFd?5MBytes?5physical?5memory?4?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0CE@DFDMPIDM@OS?3?5?$CFd?4?$CFd?5build?5?$CFd?5platform?5?$CFd?5?$CF@ ; `string'
PUBLIC	??_C@_0DC@OKFBJPKB@Version?3?5Falcon?54?40?5?9?5Version?5?$CF1@ ; `string'
PUBLIC	??_C@_04LLEBNMDN@?$CFs?$AN?6?$AA@		; `string'
PUBLIC	??_C@_0L@OGCADAFE@Card?3?5?$CFs?$AN?6?$AA@	; `string'
PUBLIC	??_C@_0P@GHEJFKFN@Instant?5Action?$AA@		; `string'
PUBLIC	??_C@_08DLBHGMLL@DogFight?$AA@			; `string'
PUBLIC	??_C@_0BE@NJKPNHIC@Tactical?5Engagement?$AA@	; `string'
PUBLIC	??_C@_08FHHBCJKK@Campaign?$AA@			; `string'
PUBLIC	??_C@_09EEKGDCPH@?$DMunknown?$DO?$AA@		; `string'
PUBLIC	??_C@_09FCDNMMPE@Networked?$AA@			; `string'
PUBLIC	??_C@_05IEALKJIG@Local?$AA@			; `string'
PUBLIC	??_C@_0BF@OIBLHPO@Game?5is?5?$CFs?5type?5?$CFs?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0O@HOMEGICE@Not?5in?5game?$AN?6?$AA@	; `string'
PUBLIC	??_C@_0BD@HGCFCCOL@DX?5Model?5ID?5?3?5?$CFx?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BD@DCNBFGFP@Texture?5ID?5?5?3?5?$CFx?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0M@FNOJOPNP@a?5Control?9C?$AA@		; `string'
PUBLIC	??_C@_0BA@MNEFCPPO@a?5Control?9Break?$AA@	; `string'
PUBLIC	??_C@_0BI@IPDDFHBH@a?5Datatype?5Misalignment?$AA@ ; `string'
PUBLIC	??_C@_0N@JLDHOHAI@a?5Breakpoint?$AA@		; `string'
PUBLIC	??_C@_0BE@GLOKLDAN@an?5Access?5Violation?$AA@	; `string'
PUBLIC	??_C@_0BB@DKICMMFA@an?5In?5Page?5Error?$AA@	; `string'
PUBLIC	??_C@_0M@JNBECNGI@a?5No?5Memory?$AA@		; `string'
PUBLIC	??_C@_0BH@CMGOADMI@an?5Illegal?5Instruction?$AA@ ; `string'
PUBLIC	??_C@_0BL@DFCKDLHL@a?5Noncontinuable?5Exception?$AA@ ; `string'
PUBLIC	??_C@_0BH@HOHCDFKK@an?5Invalid?5Disposition?$AA@ ; `string'
PUBLIC	??_C@_0BI@DFIFOIBG@a?5Array?5Bounds?5Exceeded?$AA@ ; `string'
PUBLIC	??_C@_0BJ@LCJBHHL@a?5Float?5Denormal?5Operand?$AA@ ; `string'
PUBLIC	??_C@_0BH@PIHGMMNI@a?5Float?5Divide?5by?5Zero?$AA@ ; `string'
PUBLIC	??_C@_0BH@HGODNPMP@a?5Float?5Inexact?5Result?$AA@ ; `string'
PUBLIC	??_C@_0BK@NACDCIPD@a?5Float?5Invalid?5Operation?$AA@ ; `string'
PUBLIC	??_C@_0BB@LAJAGHGH@a?5Float?5Overflow?$AA@	; `string'
PUBLIC	??_C@_0BE@DOBFFDCD@a?5Float?5Stack?5Check?$AA@	; `string'
PUBLIC	??_C@_0BC@CICINNDB@a?5Float?5Underflow?$AA@	; `string'
PUBLIC	??_C@_0BK@FNOEEFCK@an?5Integer?5Divide?5by?5Zero?$AA@ ; `string'
PUBLIC	??_C@_0BE@CDPGECPC@an?5Integer?5Overflow?$AA@	; `string'
PUBLIC	??_C@_0BJ@HMGNLHOK@a?5Privileged?5Instruction?$AA@ ; `string'
PUBLIC	??_C@_0BB@LJENMGNL@a?5Stack?5Overflow?$AA@	; `string'
PUBLIC	??_C@_0BM@LDHCKNKI@a?5DLL?5Initialization?5Failed?$AA@ ; `string'
PUBLIC	??_C@_0BK@HOJFPEEB@a?5Microsoft?5C?$CL?$CL?5Exception?$AA@ ; `string'
PUBLIC	??_C@_0BH@GMMOLJLG@Unknown?5exception?5type?$AA@ ; `string'
PUBLIC	??_C@_0M@OOEJBPPK@dbghelp?4dll?$AA@		; `string'
PUBLIC	??_C@_0N@MDJJJHMB@kernel32?4dll?$AA@		; `string'
PUBLIC	??_C@_0BC@KNBMEBEO@IsDebuggerPresent?$AA@	; `string'
PUBLIC	??_C@_0N@IEAKNBPH@crashlog?4txt?$AA@		; `string'
PUBLIC	??_C@_0CA@MGJAALIN@Error?5creating?5exception?5report?$AA@ ; `string'
PUBLIC	??_C@_08NMCPANGE@?$AN?6?$AN?6?$AN?6?$AN?6?$AA@	; `string'
PUBLIC	??_C@_0CI@OHBNADGK@?$CFs?5caused?5?$CFs?5in?5module?5?$CFs?5at?5?$CF04@ ; `string'
PUBLIC	??_C@_0CC@FLHHKNPN@Exception?5handler?5called?5in?5?$CFs?4?$AN@ ; `string'
PUBLIC	??_C@_09JHOILLPP@Read?5from?$AA@		; `string'
PUBLIC	??_C@_08CPFAPHAF@Write?5to?$AA@			; `string'
PUBLIC	??_C@_0CP@PADPOHII@?$CFs?5location?5?$CF08x?5caused?5an?5acces@ ; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs?$AA@			; `string'
PUBLIC	??_C@_06DCOAGALC@Code?3?5?$AA@			; `string'
PUBLIC	??_C@_05CNDJFPDP@?$CF02x?5?$AA@			; `string'
PUBLIC	??_C@_03MMEAEOBL@?$DP?$DP?5?$AA@		; `string'
PUBLIC	??_C@_02PCIJFNDE@?$AN?6?$AA@			; `string'
PUBLIC	??_C@_0O@BELMBNIM@Stack?5dump?3?$AN?6?$AA@	; `string'
PUBLIC	??_C@_0M@NOFNNFCK@Stack?3?5?$CFs?$AN?6?$AA@	; `string'
PUBLIC	??_C@_0BN@OCJFDHL@?$AN?6Stack?5dump?5?$CIold?5format?$CJ?3?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_06HIMOAOMH@?$CF08x?3?5?$AA@		; `string'
PUBLIC	??_C@_01CLKCMJKC@?5?$AA@			; `string'
PUBLIC	??_C@_06POCCOEBN@?$CF08x?$CFs?$AA@		; `string'
PUBLIC	??_C@_0DI@HNIHMEGJ@Exception?5encountered?5during?5sta@ ; `string'
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_strrchr:PROC
EXTRN	__imp__CreateFileA@28:PROC
EXTRN	__imp__FileTimeToLocalFileTime@8:PROC
EXTRN	__imp__GetFileSize@8:PROC
EXTRN	__imp__GetFileTime@16:PROC
EXTRN	__imp__SetFilePointer@16:PROC
EXTRN	__imp__WriteFile@20:PROC
EXTRN	__imp__OutputDebugStringA@4:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__GetSystemTimeAsFileTime@4:PROC
EXTRN	__imp__GetSystemInfo@4:PROC
EXTRN	__imp__GetVersionExA@4:PROC
EXTRN	__imp__VirtualQuery@12:PROC
EXTRN	__imp__GetModuleFileNameA@12:PROC
EXTRN	__imp__GetProcAddress@8:PROC
EXTRN	__imp__GlobalMemoryStatus@4:PROC
EXTRN	__imp__FileTimeToDosDateTime@12:PROC
EXTRN	__imp__lstrcpyA@8:PROC
EXTRN	__imp__lstrlenA@4:PROC
EXTRN	__imp__LoadLibraryA@4:PROC
EXTRN	__imp__GetUserNameA@8:PROC
EXTRN	__imp__wvsprintfA@12:PROC
EXTRN	__imp__wsprintfA:PROC
EXTRN	?GetFaultReason@@YGPBDPAU_EXCEPTION_POINTERS@@@Z:PROC ; GetFaultReason
EXTRN	?GetFirstStackTraceString@@YGPBDKPAU_EXCEPTION_POINTERS@@@Z:PROC ; GetFirstStackTraceString
EXTRN	?GetNextStackTraceString@@YGPBDKPAU_EXCEPTION_POINTERS@@@Z:PROC ; GetNextStackTraceString
EXTRN	?GetRegisterString@@YGPBDPAU_EXCEPTION_POINTERS@@@Z:PROC ; GetRegisterString
EXTRN	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ:PROC ; VuSessionEntity::Game
EXTRN	?GetGameType@FalconGameEntity@@QAE?AW4FalconGameType@@XZ:PROC ; FalconGameEntity::GetGameType
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__except_handler4:PROC
EXTRN	_memset:PROC
EXTRN	?gLangIDNum@@3HA:DWORD				; gLangIDNum
EXTRN	?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A:DWORD ; vuLocalSessionEntity
EXTRN	?gCommsMgr@@3PAVUIComms@@A:DWORD		; gCommsMgr
EXTRN	?gDebugLodID@@3KA:DWORD				; gDebugLodID
EXTRN	?gDebugTextureID@@3KA:DWORD			; gDebugTextureID
EXTRN	?g_sVersion@@3PADA:BYTE				; g_sVersion
EXTRN	?g_bModuleList@@3_NA:BYTE			; g_bModuleList
EXTRN	?MajorVersion@@3HA:DWORD			; MajorVersion
EXTRN	?MinorVersion@@3HA:DWORD			; MinorVersion
EXTRN	?BuildNumber@@3HA:DWORD				; BuildNumber
EXTRN	?g_bOldStackDump@@3_NA:BYTE			; g_bOldStackDump
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?BeenHere@?1??RecordExceptionInfo@@YAHPAU_EXCEPTION_POINTERS@@PBD@Z@4HA
_BSS	SEGMENT
?BeenHere@?1??RecordExceptionInfo@@YAHPAU_EXCEPTION_POINTERS@@PBD@Z@4HA DD 01H DUP (?) ; `RecordExceptionInfo'::`2'::BeenHere
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT ??_C@_0DI@HNIHMEGJ@Exception?5encountered?5during?5sta@
CONST	SEGMENT
??_C@_0DI@HNIHMEGJ@Exception?5encountered?5during?5sta@ DB 'Exception enc'
	DB	'ountered during stack dump (old format).', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06POCCOEBN@?$CF08x?$CFs?$AA@
CONST	SEGMENT
??_C@_06POCCOEBN@?$CF08x?$CFs?$AA@ DB '%08x%s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5?$AA@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5?$AA@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06HIMOAOMH@?$CF08x?3?5?$AA@
CONST	SEGMENT
??_C@_06HIMOAOMH@?$CF08x?3?5?$AA@ DB '%08x: ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@OCJFDHL@?$AN?6Stack?5dump?5?$CIold?5format?$CJ?3?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BN@OCJFDHL@?$AN?6Stack?5dump?5?$CIold?5format?$CJ?3?$AN?6?$AA@ DB 0dH
	DB	0aH, 'Stack dump (old format):', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NOFNNFCK@Stack?3?5?$CFs?$AN?6?$AA@
CONST	SEGMENT
??_C@_0M@NOFNNFCK@Stack?3?5?$CFs?$AN?6?$AA@ DB 'Stack: %s', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BELMBNIM@Stack?5dump?3?$AN?6?$AA@
CONST	SEGMENT
??_C@_0O@BELMBNIM@Stack?5dump?3?$AN?6?$AA@ DB 'Stack dump:', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02PCIJFNDE@?$AN?6?$AA@
CONST	SEGMENT
??_C@_02PCIJFNDE@?$AN?6?$AA@ DB 0dH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03MMEAEOBL@?$DP?$DP?5?$AA@
CONST	SEGMENT
??_C@_03MMEAEOBL@?$DP?$DP?5?$AA@ DB '?? ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CNDJFPDP@?$CF02x?5?$AA@
CONST	SEGMENT
??_C@_05CNDJFPDP@?$CF02x?5?$AA@ DB '%02x ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DCOAGALC@Code?3?5?$AA@
CONST	SEGMENT
??_C@_06DCOAGALC@Code?3?5?$AA@ DB 'Code: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs?$AA@ DB '%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@PADPOHII@?$CFs?5location?5?$CF08x?5caused?5an?5acces@
CONST	SEGMENT
??_C@_0CP@PADPOHII@?$CFs?5location?5?$CF08x?5caused?5an?5acces@ DB '%s lo'
	DB	'cation %08x caused an access violation.', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08CPFAPHAF@Write?5to?$AA@
CONST	SEGMENT
??_C@_08CPFAPHAF@Write?5to?$AA@ DB 'Write to', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09JHOILLPP@Read?5from?$AA@
CONST	SEGMENT
??_C@_09JHOILLPP@Read?5from?$AA@ DB 'Read from', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@FLHHKNPN@Exception?5handler?5called?5in?5?$CFs?4?$AN@
CONST	SEGMENT
??_C@_0CC@FLHHKNPN@Exception?5handler?5called?5in?5?$CFs?4?$AN@ DB 'Excep'
	DB	'tion handler called in %s.', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@OHBNADGK@?$CFs?5caused?5?$CFs?5in?5module?5?$CFs?5at?5?$CF04@
CONST	SEGMENT
??_C@_0CI@OHBNADGK@?$CFs?5caused?5?$CFs?5in?5module?5?$CFs?5at?5?$CF04@ DB '%'
	DB	's caused %s in module %s at %04x:%08x.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08NMCPANGE@?$AN?6?$AN?6?$AN?6?$AN?6?$AA@
CONST	SEGMENT
??_C@_08NMCPANGE@?$AN?6?$AN?6?$AN?6?$AN?6?$AA@ DB 0dH, 0aH, 0dH, 0aH, 0dH
	DB	0aH, 0dH, 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@MGJAALIN@Error?5creating?5exception?5report?$AA@
CONST	SEGMENT
??_C@_0CA@MGJAALIN@Error?5creating?5exception?5report?$AA@ DB 'Error crea'
	DB	'ting exception report', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IEAKNBPH@crashlog?4txt?$AA@
CONST	SEGMENT
??_C@_0N@IEAKNBPH@crashlog?4txt?$AA@ DB 'crashlog.txt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KNBMEBEO@IsDebuggerPresent?$AA@
CONST	SEGMENT
??_C@_0BC@KNBMEBEO@IsDebuggerPresent?$AA@ DB 'IsDebuggerPresent', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MDJJJHMB@kernel32?4dll?$AA@
CONST	SEGMENT
??_C@_0N@MDJJJHMB@kernel32?4dll?$AA@ DB 'kernel32.dll', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OOEJBPPK@dbghelp?4dll?$AA@
CONST	SEGMENT
??_C@_0M@OOEJBPPK@dbghelp?4dll?$AA@ DB 'dbghelp.dll', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@GMMOLJLG@Unknown?5exception?5type?$AA@
CONST	SEGMENT
??_C@_0BH@GMMOLJLG@Unknown?5exception?5type?$AA@ DB 'Unknown exception ty'
	DB	'pe', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@HOJFPEEB@a?5Microsoft?5C?$CL?$CL?5Exception?$AA@
CONST	SEGMENT
??_C@_0BK@HOJFPEEB@a?5Microsoft?5C?$CL?$CL?5Exception?$AA@ DB 'a Microsof'
	DB	't C++ Exception', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@LDHCKNKI@a?5DLL?5Initialization?5Failed?$AA@
CONST	SEGMENT
??_C@_0BM@LDHCKNKI@a?5DLL?5Initialization?5Failed?$AA@ DB 'a DLL Initiali'
	DB	'zation Failed', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LJENMGNL@a?5Stack?5Overflow?$AA@
CONST	SEGMENT
??_C@_0BB@LJENMGNL@a?5Stack?5Overflow?$AA@ DB 'a Stack Overflow', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HMGNLHOK@a?5Privileged?5Instruction?$AA@
CONST	SEGMENT
??_C@_0BJ@HMGNLHOK@a?5Privileged?5Instruction?$AA@ DB 'a Privileged Instr'
	DB	'uction', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CDPGECPC@an?5Integer?5Overflow?$AA@
CONST	SEGMENT
??_C@_0BE@CDPGECPC@an?5Integer?5Overflow?$AA@ DB 'an Integer Overflow', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@FNOEEFCK@an?5Integer?5Divide?5by?5Zero?$AA@
CONST	SEGMENT
??_C@_0BK@FNOEEFCK@an?5Integer?5Divide?5by?5Zero?$AA@ DB 'an Integer Divi'
	DB	'de by Zero', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CICINNDB@a?5Float?5Underflow?$AA@
CONST	SEGMENT
??_C@_0BC@CICINNDB@a?5Float?5Underflow?$AA@ DB 'a Float Underflow', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@DOBFFDCD@a?5Float?5Stack?5Check?$AA@
CONST	SEGMENT
??_C@_0BE@DOBFFDCD@a?5Float?5Stack?5Check?$AA@ DB 'a Float Stack Check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LAJAGHGH@a?5Float?5Overflow?$AA@
CONST	SEGMENT
??_C@_0BB@LAJAGHGH@a?5Float?5Overflow?$AA@ DB 'a Float Overflow', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@NACDCIPD@a?5Float?5Invalid?5Operation?$AA@
CONST	SEGMENT
??_C@_0BK@NACDCIPD@a?5Float?5Invalid?5Operation?$AA@ DB 'a Float Invalid '
	DB	'Operation', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@HGODNPMP@a?5Float?5Inexact?5Result?$AA@
CONST	SEGMENT
??_C@_0BH@HGODNPMP@a?5Float?5Inexact?5Result?$AA@ DB 'a Float Inexact Res'
	DB	'ult', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PIHGMMNI@a?5Float?5Divide?5by?5Zero?$AA@
CONST	SEGMENT
??_C@_0BH@PIHGMMNI@a?5Float?5Divide?5by?5Zero?$AA@ DB 'a Float Divide by '
	DB	'Zero', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@LCJBHHL@a?5Float?5Denormal?5Operand?$AA@
CONST	SEGMENT
??_C@_0BJ@LCJBHHL@a?5Float?5Denormal?5Operand?$AA@ DB 'a Float Denormal O'
	DB	'perand', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DFIFOIBG@a?5Array?5Bounds?5Exceeded?$AA@
CONST	SEGMENT
??_C@_0BI@DFIFOIBG@a?5Array?5Bounds?5Exceeded?$AA@ DB 'a Array Bounds Exc'
	DB	'eeded', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@HOHCDFKK@an?5Invalid?5Disposition?$AA@
CONST	SEGMENT
??_C@_0BH@HOHCDFKK@an?5Invalid?5Disposition?$AA@ DB 'an Invalid Dispositi'
	DB	'on', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@DFCKDLHL@a?5Noncontinuable?5Exception?$AA@
CONST	SEGMENT
??_C@_0BL@DFCKDLHL@a?5Noncontinuable?5Exception?$AA@ DB 'a Noncontinuable'
	DB	' Exception', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CMGOADMI@an?5Illegal?5Instruction?$AA@
CONST	SEGMENT
??_C@_0BH@CMGOADMI@an?5Illegal?5Instruction?$AA@ DB 'an Illegal Instructi'
	DB	'on', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JNBECNGI@a?5No?5Memory?$AA@
CONST	SEGMENT
??_C@_0M@JNBECNGI@a?5No?5Memory?$AA@ DB 'a No Memory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DKICMMFA@an?5In?5Page?5Error?$AA@
CONST	SEGMENT
??_C@_0BB@DKICMMFA@an?5In?5Page?5Error?$AA@ DB 'an In Page Error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GLOKLDAN@an?5Access?5Violation?$AA@
CONST	SEGMENT
??_C@_0BE@GLOKLDAN@an?5Access?5Violation?$AA@ DB 'an Access Violation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JLDHOHAI@a?5Breakpoint?$AA@
CONST	SEGMENT
??_C@_0N@JLDHOHAI@a?5Breakpoint?$AA@ DB 'a Breakpoint', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@IPDDFHBH@a?5Datatype?5Misalignment?$AA@
CONST	SEGMENT
??_C@_0BI@IPDDFHBH@a?5Datatype?5Misalignment?$AA@ DB 'a Datatype Misalign'
	DB	'ment', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MNEFCPPO@a?5Control?9Break?$AA@
CONST	SEGMENT
??_C@_0BA@MNEFCPPO@a?5Control?9Break?$AA@ DB 'a Control-Break', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FNOJOPNP@a?5Control?9C?$AA@
CONST	SEGMENT
??_C@_0M@FNOJOPNP@a?5Control?9C?$AA@ DB 'a Control-C', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DCNBFGFP@Texture?5ID?5?5?3?5?$CFx?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BD@DCNBFGFP@Texture?5ID?5?5?3?5?$CFx?$AN?6?$AA@ DB 'Texture ID  : '
	DB	'%x', 0dH, 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HGCFCCOL@DX?5Model?5ID?5?3?5?$CFx?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BD@HGCFCCOL@DX?5Model?5ID?5?3?5?$CFx?$AN?6?$AA@ DB 'DX Model ID : '
	DB	'%x', 0dH, 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HOMEGICE@Not?5in?5game?$AN?6?$AA@
CONST	SEGMENT
??_C@_0O@HOMEGICE@Not?5in?5game?$AN?6?$AA@ DB 'Not in game', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@OIBLHPO@Game?5is?5?$CFs?5type?5?$CFs?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BF@OIBLHPO@Game?5is?5?$CFs?5type?5?$CFs?$AN?6?$AA@ DB 'Game is %s '
	DB	'type %s', 0dH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05IEALKJIG@Local?$AA@
CONST	SEGMENT
??_C@_05IEALKJIG@Local?$AA@ DB 'Local', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09FCDNMMPE@Networked?$AA@
CONST	SEGMENT
??_C@_09FCDNMMPE@Networked?$AA@ DB 'Networked', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09EEKGDCPH@?$DMunknown?$DO?$AA@
CONST	SEGMENT
??_C@_09EEKGDCPH@?$DMunknown?$DO?$AA@ DB '<unknown>', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08FHHBCJKK@Campaign?$AA@
CONST	SEGMENT
??_C@_08FHHBCJKK@Campaign?$AA@ DB 'Campaign', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NJKPNHIC@Tactical?5Engagement?$AA@
CONST	SEGMENT
??_C@_0BE@NJKPNHIC@Tactical?5Engagement?$AA@ DB 'Tactical Engagement', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08DLBHGMLL@DogFight?$AA@
CONST	SEGMENT
??_C@_08DLBHGMLL@DogFight?$AA@ DB 'DogFight', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GHEJFKFN@Instant?5Action?$AA@
CONST	SEGMENT
??_C@_0P@GHEJFKFN@Instant?5Action?$AA@ DB 'Instant Action', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OGCADAFE@Card?3?5?$CFs?$AN?6?$AA@
CONST	SEGMENT
??_C@_0L@OGCADAFE@Card?3?5?$CFs?$AN?6?$AA@ DB 'Card: %s', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04LLEBNMDN@?$CFs?$AN?6?$AA@
CONST	SEGMENT
??_C@_04LLEBNMDN@?$CFs?$AN?6?$AA@ DB '%s', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@OKFBJPKB@Version?3?5Falcon?54?40?5?9?5Version?5?$CF1@
CONST	SEGMENT
??_C@_0DC@OKFBJPKB@Version?3?5Falcon?54?40?5?9?5Version?5?$CF1@ DB 'Versi'
	DB	'on: Falcon 4.0 - Version %1d.%02d.%1d.%05d', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@DFDMPIDM@OS?3?5?$CFd?4?$CFd?5build?5?$CFd?5platform?5?$CFd?5?$CF@
CONST	SEGMENT
??_C@_0CE@DFDMPIDM@OS?3?5?$CFd?4?$CFd?5build?5?$CFd?5platform?5?$CFd?5?$CF@ DB 'O'
	DB	'S: %d.%d build %d platform %d %s', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@PBHEHCOH@?$CFd?5MBytes?5physical?5memory?4?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BN@PBHEHCOH@?$CFd?5MBytes?5physical?5memory?4?$AN?6?$AA@ DB '%d MB'
	DB	'ytes physical memory.', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@CGPALIEL@?$CFd?5processor?$CIs?$CJ?0?5type?5?$CFd?4?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BM@CGPALIEL@?$CFd?5processor?$CIs?$CJ?0?5type?5?$CFd?4?$AN?6?$AA@ DB '%'
	DB	'd processor(s), type %d.', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GEKHAOPD@?$CFs?0?5run?5by?5?$CFs?4?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BB@GEKHAOPD@?$CFs?0?5run?5by?5?$CFs?4?$AN?6?$AA@ DB '%s, run by %s'
	DB	'.', 0dH, 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07NBCGADJA@Unknown?$AA@
CONST	SEGMENT
??_C@_07NBCGADJA@Unknown?$AA@ DB 'Unknown', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@JNCPBKJH@Error?5occurred?5at?5?$CFs?4?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BI@JNCPBKJH@Error?5occurred?5at?5?$CFs?4?$AN?6?$AA@ DB 'Error occu'
	DB	'rred at %s.', 0dH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@IAGPJNKE@?$AN?6?7Module?5list?3?5names?0?5addresses@
CONST	SEGMENT
??_C@_0EH@IAGPJNKE@?$AN?6?7Module?5list?3?5names?0?5addresses@ DB 0dH, 0aH
	DB	09H, 'Module list: names, addresses, sizes, time stamps and fi'
	DB	'le times:', 0dH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@CGOIOKCD@?$CFs?0?5loaded?5at?50x?$CF08x?5?9?5?$CFd?5bytes?5@
CONST	SEGMENT
??_C@_0CL@CGOIOKCD@?$CFs?0?5loaded?5at?50x?$CF08x?5?9?5?$CFd?5bytes?5@ DB '%'
	DB	's, loaded at 0x%08x - %d bytes - %08x%s', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CJPAEIHC@?5?9?5file?5date?5is?5?$AA@
CONST	SEGMENT
??_C@_0BB@CJPAEIHC@?5?9?5file?5date?5is?5?$AA@ DB ' - file date is ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@HKCLIKLE@?$CFd?1?$CFd?1?$CFd?5?$CF02d?3?$CF02d?3?$CF02d?$AA@
CONST	SEGMENT
??_C@_0BI@HKCLIKLE@?$CFd?1?$CFd?1?$CFd?5?$CF02d?3?$CF02d?3?$CF02d?$AA@ DB '%'
	DB	'd/%d/%d %02d:%02d:%02d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
xdata$x	SEGMENT
__sehtable$?RecordSystemInformation@@YAXPAX@Z DD 0ffffffe4H
	DD	00H
	DD	0fffffcacH
	DD	00H
	DD	0fffffffeH
	DD	FLAT:$LN29@RecordSyst
	DD	FLAT:$LN24@RecordSyst
	ORG $+4
__sehtable$?ShowModuleInfo@@YAXPAXPAUHINSTANCE__@@@Z DD 0ffffffe4H
	DD	00H
	DD	0fffffe54H
	DD	00H
	DD	0fffffffeH
	DD	FLAT:$LN15@ShowModule
	DD	FLAT:$LN11@ShowModule
	ORG $+4
__sehtable$?RecordExceptionInfo@@YAHPAU_EXCEPTION_POINTERS@@PBD@Z DD 0ffffffe4H
	DD	00H
	DD	0fffff480H
	DD	00H
	DD	0fffffffeH
	DD	FLAT:$LN47@RecordExce
	DD	FLAT:$LN36@RecordExce
	DD	0fffffffeH
	DD	FLAT:$LN48@RecordExce
	DD	FLAT:$LN40@RecordExce
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\ehandler.cpp
_TEXT	SEGMENT
_MemInfo$2 = -2928					; size = 28
_safetyzone$3 = -2900					; size = 4
_code$ = -2896						; size = 4
_nearend$4 = -2892					; size = 4
_FilePart$ = -2888					; size = 4
_hInst$ = -2884						; size = 4
_lastperiod$ = -2880					; size = 4
_options$5 = -2876					; size = 4
$T6 = -2872						; size = 4
_Suffix$7 = -2868					; size = 4
_pIsDebuggerPresent$8 = -2864				; size = 4
_hinstDbgHelp$ = -2860					; size = 4
_readwrite$9 = -2856					; size = 4
$T10 = -2852						; size = 4
_CrashModuleFileName$11 = -2848				; size = 4
_stackmsg$12 = -2844					; size = 4
_pStackTop$13 = -2840					; size = 4
_codebyte$14 = -2836					; size = 4
_Count$15 = -2832					; size = 4
_Exception$ = -2828					; size = 4
_Context$ = -2824					; size = 4
_output$16 = -2820					; size = 4
_pStack$17 = -2816					; size = 4
_LogFile$ = -2812					; size = 4
_DebugMessage$18 = -2808				; size = 1000
_CrashModulePathName$19 = -1808				; size = 260
_buffer$20 = -1548					; size = 1000
_ModuleName$ = -548					; size = 260
_FileName$ = -288					; size = 260
__$ArrayPad$ = -28					; size = 4
__$SEHRec$ = -24					; size = 24
_data$ = 8						; size = 4
_Message$ = 12						; size = 4
?RecordExceptionInfo@@YAHPAU_EXCEPTION_POINTERS@@PBD@Z PROC ; RecordExceptionInfo

; 326  : {

	push	ebp
	mov	ebp, esp
	push	-2					; fffffffeH
	push	OFFSET __sehtable$?RecordExceptionInfo@@YAHPAU_EXCEPTION_POINTERS@@PBD@Z
	push	OFFSET __except_handler4
	mov	eax, DWORD PTR fs:0
	push	eax
	add	esp, -2912				; fffff4a0H
	mov	eax, DWORD PTR ___security_cookie
	xor	DWORD PTR __$SEHRec$[ebp+16], eax
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$SEHRec$[ebp], esp

; 327  : #ifdef _DEBUG_SG
; 328  : 	// OW: pass control to the debugger instead of generating a silly crashlog
; 329  : 	return EXCEPTION_CONTINUE_SEARCH;
; 330  : 	// JPO not worth while - it always traps it I found... and now we can
; 331  : 	// get some good info out of this anyway.
; 332  : 	// JB JPO, JPO, JPO...
; 333  : #endif
; 334  : 	 static int BeenHere;
; 335  : 	if (BeenHere)	// Going recursive! That must mean this routine crashed!

	cmp	DWORD PTR ?BeenHere@?1??RecordExceptionInfo@@YAHPAU_EXCEPTION_POINTERS@@PBD@Z@4HA, 0
	je	SHORT $LN27@RecordExce

; 336  : 		return EXCEPTION_CONTINUE_SEARCH;

	xor	eax, eax
	jmp	$LN34@RecordExce
$LN27@RecordExce:

; 337  : 	BeenHere = TRUE;

	mov	DWORD PTR ?BeenHere@?1??RecordExceptionInfo@@YAHPAU_EXCEPTION_POINTERS@@PBD@Z@4HA, 1

; 338  : 
; 339  : 	
; 340  : 	HINSTANCE hinstDbgHelp;
; 341  : 	hinstDbgHelp = LoadLibrary("dbghelp.dll");

	push	OFFSET ??_C@_0M@OOEJBPPK@dbghelp?4dll?$AA@
	call	DWORD PTR __imp__LoadLibraryA@4
	mov	DWORD PTR _hinstDbgHelp$[ebp], eax

; 342  : 
; 343  :  
; 344  : 	//Wombat778 5-01-04 Create a Minidump
; 345  : 	//Cobra 12/05/04  Let's remove this for now.  
; 346  : 	/*if (g_nMiniDump >= 0)
; 347  : 		CreateCurrentProcessMiniDumpW ( (MINIDUMP_TYPE) g_nMiniDump			,
; 348  :                                              L"dumplog.dmp"         ,
; 349  :                                              GetCurrentThreadId ( )    ,
; 350  :                                              data              ) ;*/
; 351  : 
; 352  : 	//Wombat778 5-02-04 Check if we are being debugged.  If so, dont write the crashlog
; 353  : 	HINSTANCE hInst = LoadLibrary("kernel32.dll");

	push	OFFSET ??_C@_0N@MDJJJHMB@kernel32?4dll?$AA@
	call	DWORD PTR __imp__LoadLibraryA@4
	mov	DWORD PTR _hInst$[ebp], eax

; 354  :     if (hInst)

	cmp	DWORD PTR _hInst$[ebp], 0
	je	SHORT $LN26@RecordExce

; 355  :     {            
; 356  : 		FARPROC pIsDebuggerPresent = GetProcAddress(hInst, "IsDebuggerPresent");

	push	OFFSET ??_C@_0BC@KNBMEBEO@IsDebuggerPresent?$AA@
	mov	eax, DWORD PTR _hInst$[ebp]
	push	eax
	call	DWORD PTR __imp__GetProcAddress@8
	mov	DWORD PTR _pIsDebuggerPresent$8[ebp], eax

; 357  : 		if (pIsDebuggerPresent)				

	cmp	DWORD PTR _pIsDebuggerPresent$8[ebp], 0
	je	SHORT $LN26@RecordExce

; 358  : 			if (pIsDebuggerPresent())

	call	DWORD PTR _pIsDebuggerPresent$8[ebp]
	test	eax, eax
	je	SHORT $LN26@RecordExce

; 359  : 				return EXCEPTION_CONTINUE_SEARCH;	        

	xor	eax, eax
	jmp	$LN34@RecordExce
$LN26@RecordExce:

; 360  :     }
; 361  :     
; 362  : 	char	ModuleName[MAX_PATH];
; 363  : 	char	FileName[MAX_PATH] = "Unknown";

	mov	ecx, DWORD PTR ??_C@_07NBCGADJA@Unknown?$AA@
	mov	DWORD PTR _FileName$[ebp], ecx
	mov	edx, DWORD PTR ??_C@_07NBCGADJA@Unknown?$AA@+4
	mov	DWORD PTR _FileName$[ebp+4], edx
	push	252					; 000000fcH
	push	0
	lea	eax, DWORD PTR _FileName$[ebp+8]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 364  : 	// Create a filename to record the error information to.
; 365  : 	// Storing it in the executable directory works well.
; 366  : 	if (GetModuleFileName(0, ModuleName, sizeof(ModuleName)) <= 0)

	push	260					; 00000104H
	lea	ecx, DWORD PTR _ModuleName$[ebp]
	push	ecx
	push	0
	call	DWORD PTR __imp__GetModuleFileNameA@12
	test	eax, eax
	ja	SHORT $LN23@RecordExce

; 367  : 		ModuleName[0] = 0;

	mov	edx, 1
	imul	edx, 0
	mov	DWORD PTR $T6[ebp], edx
	cmp	DWORD PTR $T6[ebp], 260			; 00000104H
	jae	SHORT $LN30@RecordExce
	jmp	SHORT $LN31@RecordExce
$LN30@RecordExce:
	call	___report_rangecheckfailure
$LN31@RecordExce:
	mov	eax, DWORD PTR $T6[ebp]
	mov	BYTE PTR _ModuleName$[ebp+eax], 0
$LN23@RecordExce:

; 368  : 	char *FilePart = GetFilePart(ModuleName);

	lea	ecx, DWORD PTR _ModuleName$[ebp]
	push	ecx
	call	?GetFilePart@@YAPADPAD@Z		; GetFilePart
	add	esp, 4
	mov	DWORD PTR _FilePart$[ebp], eax

; 369  : 
; 370  : 	// Extract the file name portion and remove it's file extension. We'll
; 371  : 	// use that name shortly.
; 372  : 	lstrcpy(FileName, FilePart);

	mov	edx, DWORD PTR _FilePart$[ebp]
	push	edx
	lea	eax, DWORD PTR _FileName$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcpyA@8

; 373  : 	char *lastperiod = strrchr(FileName, '.');

	push	46					; 0000002eH
	lea	ecx, DWORD PTR _FileName$[ebp]
	push	ecx
	call	?strrchr@@YAPADPADH@Z			; strrchr
	add	esp, 8
	mov	DWORD PTR _lastperiod$[ebp], eax

; 374  : 	if (lastperiod)

	cmp	DWORD PTR _lastperiod$[ebp], 0
	je	SHORT $LN22@RecordExce

; 375  : 		lastperiod[0] = 0;

	mov	edx, 1
	imul	edx, 0
	mov	eax, DWORD PTR _lastperiod$[ebp]
	mov	BYTE PTR [eax+edx], 0
$LN22@RecordExce:

; 376  : 	// Replace the executable filename with our error log file name.
; 377  : 	lstrcpy(FilePart, "crashlog.txt");

	push	OFFSET ??_C@_0N@IEAKNBPH@crashlog?4txt?$AA@
	mov	ecx, DWORD PTR _FilePart$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrcpyA@8

; 378  : 	HANDLE LogFile = CreateFile(ModuleName, GENERIC_WRITE, 0, 0,
; 379  : 				OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH, 0);

	push	0
	push	-2147483520				; 80000080H
	push	4
	push	0
	push	0
	push	1073741824				; 40000000H
	lea	edx, DWORD PTR _ModuleName$[ebp]
	push	edx
	call	DWORD PTR __imp__CreateFileA@28
	mov	DWORD PTR _LogFile$[ebp], eax

; 380  : 	if (LogFile == INVALID_HANDLE_VALUE)

	cmp	DWORD PTR _LogFile$[ebp], -1
	jne	SHORT $LN21@RecordExce

; 381  : 	{
; 382  : 		OutputDebugString("Error creating exception report");

	push	OFFSET ??_C@_0CA@MGJAALIN@Error?5creating?5exception?5report?$AA@
	call	DWORD PTR __imp__OutputDebugStringA@4

; 383  : 		return EXCEPTION_CONTINUE_SEARCH;

	xor	eax, eax
	jmp	$LN34@RecordExce
$LN21@RecordExce:

; 384  : 	}
; 385  : 	// Append to the error log.
; 386  : 	SetFilePointer(LogFile, 0, 0, FILE_END);

	push	2
	push	0
	push	0
	mov	eax, DWORD PTR _LogFile$[ebp]
	push	eax
	call	DWORD PTR __imp__SetFilePointer@16

; 387  : 	// Print out some blank lines to separate this error log from any previous ones.
; 388  : 	hprintf(LogFile, "\r\n\r\n\r\n\r\n");

	push	OFFSET ??_C@_08NMCPANGE@?$AN?6?$AN?6?$AN?6?$AN?6?$AA@
	mov	ecx, DWORD PTR _LogFile$[ebp]
	push	ecx
	call	?hprintf@@YAXPAXPADZZ			; hprintf
	add	esp, 8

; 389  : 	PEXCEPTION_RECORD	Exception = data->ExceptionRecord;

	mov	edx, DWORD PTR _data$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _Exception$[ebp], eax

; 390  : 	PCONTEXT			Context = data->ContextRecord;

	mov	ecx, DWORD PTR _data$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _Context$[ebp], edx

; 391  : 	
; 392  : 	if (!hinstDbgHelp)

	cmp	DWORD PTR _hinstDbgHelp$[ebp], 0
	jne	$LN20@RecordExce

; 393  : 	{
; 394  : 		char	CrashModulePathName[MAX_PATH];
; 395  : 		char	*CrashModuleFileName = "Unknown";

	mov	DWORD PTR _CrashModuleFileName$11[ebp], OFFSET ??_C@_07NBCGADJA@Unknown?$AA@

; 396  : 		MEMORY_BASIC_INFORMATION	MemInfo;
; 397  : 		// VirtualQuery can be used to get the allocation base associated with a
; 398  : 		// code address, which is the same as the ModuleHandle. This can be used
; 399  : 		// to get the filename of the module that the crash happened in.
; 400  : 		if (VirtualQuery((void*)Context->Eip, &MemInfo, sizeof(MemInfo)) &&
; 401  : 					GetModuleFileName((HINSTANCE)MemInfo.AllocationBase,
; 402  : 								CrashModulePathName,
; 403  : 					sizeof(CrashModulePathName)) > 0)

	push	28					; 0000001cH
	lea	eax, DWORD PTR _MemInfo$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _Context$[ebp]
	mov	edx, DWORD PTR [ecx+184]
	push	edx
	call	DWORD PTR __imp__VirtualQuery@12
	test	eax, eax
	je	SHORT $LN19@RecordExce
	push	260					; 00000104H
	lea	eax, DWORD PTR _CrashModulePathName$19[ebp]
	push	eax
	mov	ecx, DWORD PTR _MemInfo$2[ebp+4]
	push	ecx
	call	DWORD PTR __imp__GetModuleFileNameA@12
	test	eax, eax
	jbe	SHORT $LN19@RecordExce

; 404  : 			CrashModuleFileName = GetFilePart(CrashModulePathName);

	lea	edx, DWORD PTR _CrashModulePathName$19[ebp]
	push	edx
	call	?GetFilePart@@YAPADPAD@Z		; GetFilePart
	add	esp, 4
	mov	DWORD PTR _CrashModuleFileName$11[ebp], eax
$LN19@RecordExce:

; 405  : 
; 406  : 		hprintf(LogFile, "%s caused %s in module %s at %04x:%08x.",
; 407  : 				FileName, GetExceptionDescription(Exception->ExceptionCode),
; 408  : 				CrashModuleFileName, Context->SegCs, Context->Eip);

	mov	eax, DWORD PTR _Context$[ebp]
	mov	ecx, DWORD PTR [eax+184]
	push	ecx
	mov	edx, DWORD PTR _Context$[ebp]
	mov	eax, DWORD PTR [edx+188]
	push	eax
	mov	ecx, DWORD PTR _CrashModuleFileName$11[ebp]
	push	ecx
	mov	edx, DWORD PTR _Exception$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	?GetExceptionDescription@@YAPBDK@Z	; GetExceptionDescription
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR _FileName$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CI@OHBNADGK@?$CFs?5caused?5?$CFs?5in?5module?5?$CFs?5at?5?$CF04@
	mov	edx, DWORD PTR _LogFile$[ebp]
	push	edx
	call	?hprintf@@YAXPAXPADZZ			; hprintf
	add	esp, 28					; 0000001cH
$LN20@RecordExce:

; 409  : 	}
; 410  : 
; 411  : 	hprintf(LogFile, "%s\r\n", GetFaultReason(data));

	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	call	?GetFaultReason@@YGPBDPAU_EXCEPTION_POINTERS@@@Z ; GetFaultReason
	push	eax
	push	OFFSET ??_C@_04LLEBNMDN@?$CFs?$AN?6?$AA@
	mov	ecx, DWORD PTR _LogFile$[ebp]
	push	ecx
	call	?hprintf@@YAXPAXPADZZ			; hprintf
	add	esp, 12					; 0000000cH

; 412  : 	hprintf (LogFile, "Exception handler called in %s.\r\n", Message);

	mov	edx, DWORD PTR _Message$[ebp]
	push	edx
	push	OFFSET ??_C@_0CC@FLHHKNPN@Exception?5handler?5called?5in?5?$CFs?4?$AN@
	mov	eax, DWORD PTR _LogFile$[ebp]
	push	eax
	call	?hprintf@@YAXPAXPADZZ			; hprintf
	add	esp, 12					; 0000000cH

; 413  : 
; 414  : 	if (Exception->ExceptionCode == STATUS_ACCESS_VIOLATION &&
; 415  : 				Exception->NumberParameters >= 2)

	mov	ecx, DWORD PTR _Exception$[ebp]
	cmp	DWORD PTR [ecx], -1073741819		; c0000005H
	jne	SHORT $LN18@RecordExce
	mov	edx, DWORD PTR _Exception$[ebp]
	cmp	DWORD PTR [edx+16], 2
	jb	SHORT $LN18@RecordExce

; 416  : 	{
; 417  : 		char DebugMessage[1000];
; 418  : 		const char* readwrite = "Read from";

	mov	DWORD PTR _readwrite$9[ebp], OFFSET ??_C@_09JHOILLPP@Read?5from?$AA@

; 419  : 		if (Exception->ExceptionInformation[0])

	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _Exception$[ebp]
	cmp	DWORD PTR [ecx+eax+20], 0
	je	SHORT $LN17@RecordExce

; 420  : 			readwrite = "Write to";

	mov	DWORD PTR _readwrite$9[ebp], OFFSET ??_C@_08CPFAPHAF@Write?5to?$AA@
$LN17@RecordExce:

; 421  : 		wsprintf(DebugMessage, "%s location %08x caused an access violation.\r\n",
; 422  : 					readwrite, Exception->ExceptionInformation[1]);

	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _Exception$[ebp]
	mov	ecx, DWORD PTR [eax+edx+20]
	push	ecx
	mov	edx, DWORD PTR _readwrite$9[ebp]
	push	edx
	push	OFFSET ??_C@_0CP@PADPOHII@?$CFs?5location?5?$CF08x?5caused?5an?5acces@
	lea	eax, DWORD PTR _DebugMessage$18[ebp]
	push	eax
	call	DWORD PTR __imp__wsprintfA
	add	esp, 16					; 00000010H

; 423  : 		#ifdef	_DEBUG
; 424  : 		// The VisualC++ debugger doesn't actually tell you whether a read
; 425  : 		// or a write caused the access violation, nor does it tell what
; 426  : 		// address was being read or written. So I fixed that.
; 427  : 		OutputDebugString("Exception handler: ");
; 428  : 		OutputDebugString(DebugMessage);
; 429  : 		#endif
; 430  : 		hprintf(LogFile, "%s", DebugMessage);

	lea	ecx, DWORD PTR _DebugMessage$18[ebp]
	push	ecx
	push	OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
	mov	edx, DWORD PTR _LogFile$[ebp]
	push	edx
	call	?hprintf@@YAXPAXPADZZ			; hprintf
	add	esp, 12					; 0000000cH
$LN18@RecordExce:

; 431  : 	}
; 432  : 
; 433  : 	// Print out the bytes of code at the instruction pointer. Since the
; 434  : 	// crash may have been caused by an instruction pointer that was bad,
; 435  : 	// this code needs to be wrapped in an exception handler, in case there
; 436  : 	// is no memory to read. If the dereferencing of code[] fails, the
; 437  : 	// exception handler will print '??'.
; 438  : 	hprintf (LogFile, "Code: ");

	push	OFFSET ??_C@_06DCOAGALC@Code?3?5?$AA@
	mov	eax, DWORD PTR _LogFile$[ebp]
	push	eax
	call	?hprintf@@YAXPAXPADZZ			; hprintf
	add	esp, 8

; 439  : 	unsigned char *code = (unsigned char*)Context->Eip;

	mov	ecx, DWORD PTR _Context$[ebp]
	mov	edx, DWORD PTR [ecx+184]
	mov	DWORD PTR _code$[ebp], edx

; 440  : 	for (int codebyte = 0; codebyte < NumCodeBytes; codebyte++)

	mov	DWORD PTR _codebyte$14[ebp], 0
	jmp	SHORT $LN16@RecordExce
$LN15@RecordExce:
	mov	eax, DWORD PTR _codebyte$14[ebp]
	add	eax, 1
	mov	DWORD PTR _codebyte$14[ebp], eax
$LN16@RecordExce:
	cmp	DWORD PTR _codebyte$14[ebp], 16		; 00000010H
	jge	SHORT $LN14@RecordExce

; 441  : 	{
; 442  : 		__try

	mov	DWORD PTR __$SEHRec$[ebp+20], 0

; 443  : 		{
; 444  : 			hprintf(LogFile, "%02x ", code[codebyte]);

	mov	ecx, DWORD PTR _code$[ebp]
	add	ecx, DWORD PTR _codebyte$14[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	push	OFFSET ??_C@_05CNDJFPDP@?$CF02x?5?$AA@
	mov	eax, DWORD PTR _LogFile$[ebp]
	push	eax
	call	?hprintf@@YAXPAXPADZZ			; hprintf
	add	esp, 12					; 0000000cH

; 445  : 
; 446  : 		}

	mov	DWORD PTR __$SEHRec$[ebp+20], -2	; fffffffeH
	jmp	SHORT $LN38@RecordExce
$LN35@RecordExce:
$LN47@RecordExce:

; 447  : 		__except(EXCEPTION_EXECUTE_HANDLER)

	mov	eax, 1
$LN37@RecordExce:
$LN43@RecordExce:
	ret	0
$LN36@RecordExce:
	mov	esp, DWORD PTR __$SEHRec$[ebp]

; 448  : 		{
; 449  : 			hprintf(LogFile, "?? ");

	push	OFFSET ??_C@_03MMEAEOBL@?$DP?$DP?5?$AA@
	mov	ecx, DWORD PTR _LogFile$[ebp]
	push	ecx
	call	?hprintf@@YAXPAXPADZZ			; hprintf
	add	esp, 8

; 450  : 		}

	mov	DWORD PTR __$SEHRec$[ebp+20], -2	; fffffffeH
$LN38@RecordExce:

; 451  : 	}

	jmp	SHORT $LN15@RecordExce
$LN14@RecordExce:

; 452  : 
; 453  : 	hprintf(LogFile, "\r\n");

	push	OFFSET ??_C@_02PCIJFNDE@?$AN?6?$AA@
	mov	edx, DWORD PTR _LogFile$[ebp]
	push	edx
	call	?hprintf@@YAXPAXPADZZ			; hprintf
	add	esp, 8

; 454  : 
; 455  : 	if (hinstDbgHelp)

	cmp	DWORD PTR _hinstDbgHelp$[ebp], 0
	je	$LN12@RecordExce

; 456  : 	{
; 457  : 		// Time to print part or all of the stack to the error log. This allows
; 458  : 		// us to figure out the call stack, parameters, local variables, etc.
; 459  : 		hprintf(LogFile, "Stack dump:\r\n");

	push	OFFSET ??_C@_0O@BELMBNIM@Stack?5dump?3?$AN?6?$AA@
	mov	eax, DWORD PTR _LogFile$[ebp]
	push	eax
	call	?hprintf@@YAXPAXPADZZ			; hprintf
	add	esp, 8

; 460  : 		// lets try for everything
; 461  : 		DWORD options = GSTSO_PARAMS | GSTSO_MODULE | GSTSO_SYMBOL | GSTSO_SRCLINE;

	mov	DWORD PTR _options$5[ebp], 15		; 0000000fH

; 462  : 		
; 463  : 		const char *stackmsg = GetFirstStackTraceString (options, data);

	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _options$5[ebp]
	push	edx
	call	?GetFirstStackTraceString@@YGPBDKPAU_EXCEPTION_POINTERS@@@Z ; GetFirstStackTraceString
	mov	DWORD PTR _stackmsg$12[ebp], eax
$LN11@RecordExce:

; 464  : 		while (stackmsg) {

	cmp	DWORD PTR _stackmsg$12[ebp], 0
	je	SHORT $LN10@RecordExce

; 465  : 			hprintf(LogFile, "Stack: %s\r\n", 	stackmsg);

	mov	eax, DWORD PTR _stackmsg$12[ebp]
	push	eax
	push	OFFSET ??_C@_0M@NOFNNFCK@Stack?3?5?$CFs?$AN?6?$AA@
	mov	ecx, DWORD PTR _LogFile$[ebp]
	push	ecx
	call	?hprintf@@YAXPAXPADZZ			; hprintf
	add	esp, 12					; 0000000cH

; 466  : 			stackmsg = GetNextStackTraceString (options, data);

	mov	edx, DWORD PTR _data$[ebp]
	push	edx
	mov	eax, DWORD PTR _options$5[ebp]
	push	eax
	call	?GetNextStackTraceString@@YGPBDKPAU_EXCEPTION_POINTERS@@@Z ; GetNextStackTraceString
	mov	DWORD PTR _stackmsg$12[ebp], eax

; 467  : 		}

	jmp	SHORT $LN11@RecordExce
$LN10@RecordExce:

; 468  : 
; 469  : 		// 2002-04-01 ADDED BY S.G. Original stack from 1.07 added back. New code as trouble parsing the stack sometime (ie, stack not deep enough). By having both, we can always fall back to the old one if needed be.
; 470  : 		// Time to print part or all of the stack to the error log. This allows
; 471  : 		// us to figure out the call stack, parameters, local variables, etc.
; 472  : 		if (g_bOldStackDump) {

	movzx	ecx, BYTE PTR ?g_bOldStackDump@@3_NA	; g_bOldStackDump
	test	ecx, ecx
	je	$LN9@RecordExce

; 473  : 			hprintf(LogFile, "\r\nStack dump (old format):\r\n");

	push	OFFSET ??_C@_0BN@OCJFDHL@?$AN?6Stack?5dump?5?$CIold?5format?$CJ?3?$AN?6?$AA@
	mov	edx, DWORD PTR _LogFile$[ebp]
	push	edx
	call	?hprintf@@YAXPAXPADZZ			; hprintf
	add	esp, 8

; 474  : 			__try

	mov	DWORD PTR __$SEHRec$[ebp+20], 1

; 475  : 			{
; 476  : 				// Esp contains the bottom of the stack, or at least the bottom of
; 477  : 				// the currently used area.
; 478  : 				DWORD* pStack = (DWORD *)Context->Esp;

	mov	eax, DWORD PTR _Context$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	mov	DWORD PTR _pStack$17[ebp], ecx

; 479  : 				DWORD* pStackTop;
; 480  : 				__asm
; 481  : 				{
; 482  : 					// Load the top (highest address) of the stack from the
; 483  : 					// thread information block. It will be found there in
; 484  : 					// Win9x and Windows NT.
; 485  : 					mov	eax, fs:[4]

	mov	eax, DWORD PTR fs:4

; 486  : 					mov pStackTop, eax

	mov	DWORD PTR _pStackTop$13[ebp], eax

; 487  : 				}
; 488  : 				if (pStackTop > pStack + MaxStackDump)

	mov	edx, DWORD PTR _pStack$17[ebp]
	add	edx, 8192				; 00002000H
	cmp	DWORD PTR _pStackTop$13[ebp], edx
	jbe	SHORT $LN7@RecordExce

; 489  : 					pStackTop = pStack + MaxStackDump;

	mov	eax, DWORD PTR _pStack$17[ebp]
	add	eax, 8192				; 00002000H
	mov	DWORD PTR _pStackTop$13[ebp], eax
$LN7@RecordExce:

; 490  : 				int Count = 0;

	mov	DWORD PTR _Count$15[ebp], 0

; 491  : 				// Too many calls to WriteFile can take a long time, causing
; 492  : 				// confusing delays when programs crash. Therefore I implemented
; 493  : 				// simple buffering for the stack dumping code instead of calling
; 494  : 				// hprintf directly.
; 495  : 				char	buffer[1000] = "";

	mov	cl, BYTE PTR ??_C@_00CNPNBAHC@?$AA@
	mov	BYTE PTR _buffer$20[ebp], cl
	push	999					; 000003e7H
	push	0
	lea	edx, DWORD PTR _buffer$20[ebp+1]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 496  : 				const int safetyzone = 50;

	mov	DWORD PTR _safetyzone$3[ebp], 50	; 00000032H

; 497  : 				char*	nearend = buffer + sizeof(buffer) - safetyzone;

	lea	eax, DWORD PTR _buffer$20[ebp+950]
	mov	DWORD PTR _nearend$4[ebp], eax

; 498  : 				char*	output = buffer;

	lea	ecx, DWORD PTR _buffer$20[ebp]
	mov	DWORD PTR _output$16[ebp], ecx
$LN6@RecordExce:

; 499  : 				while (pStack + 1 <= pStackTop)

	mov	edx, DWORD PTR _pStack$17[ebp]
	add	edx, 4
	cmp	edx, DWORD PTR _pStackTop$13[ebp]
	ja	$LN5@RecordExce

; 500  : 				{
; 501  : 					if ((Count % StackColumns) == 0)

	mov	eax, DWORD PTR _Count$15[ebp]
	and	eax, -2147483641			; 80000007H
	jns	SHORT $LN44@RecordExce
	dec	eax
	or	eax, -8					; fffffff8H
	inc	eax
$LN44@RecordExce:
	test	eax, eax
	jne	SHORT $LN4@RecordExce

; 502  : 						output += wsprintf(output, "%08x: ", *pStack);//Pu239

	mov	ecx, DWORD PTR _pStack$17[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	push	OFFSET ??_C@_06HIMOAOMH@?$CF08x?3?5?$AA@
	mov	eax, DWORD PTR _output$16[ebp]
	push	eax
	call	DWORD PTR __imp__wsprintfA
	add	esp, 12					; 0000000cH
	add	eax, DWORD PTR _output$16[ebp]
	mov	DWORD PTR _output$16[ebp], eax
$LN4@RecordExce:

; 503  : 					char *Suffix = " ";

	mov	DWORD PTR _Suffix$7[ebp], OFFSET ??_C@_01CLKCMJKC@?5?$AA@

; 504  : 					if ((++Count % StackColumns) == 0 || pStack + 2 > pStackTop)

	mov	ecx, DWORD PTR _Count$15[ebp]
	add	ecx, 1
	mov	DWORD PTR _Count$15[ebp], ecx
	mov	edx, DWORD PTR _Count$15[ebp]
	and	edx, -2147483641			; 80000007H
	jns	SHORT $LN45@RecordExce
	dec	edx
	or	edx, -8					; fffffff8H
	inc	edx
$LN45@RecordExce:
	test	edx, edx
	je	SHORT $LN2@RecordExce
	mov	eax, DWORD PTR _pStack$17[ebp]
	add	eax, 8
	cmp	eax, DWORD PTR _pStackTop$13[ebp]
	jbe	SHORT $LN3@RecordExce
$LN2@RecordExce:

; 505  : 						Suffix = "\r\n";

	mov	DWORD PTR _Suffix$7[ebp], OFFSET ??_C@_02PCIJFNDE@?$AN?6?$AA@
$LN3@RecordExce:

; 506  : 					output += wsprintf(output, "%08x%s", *pStack, Suffix);

	mov	ecx, DWORD PTR _Suffix$7[ebp]
	push	ecx
	mov	edx, DWORD PTR _pStack$17[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	OFFSET ??_C@_06POCCOEBN@?$CF08x?$CFs?$AA@
	mov	ecx, DWORD PTR _output$16[ebp]
	push	ecx
	call	DWORD PTR __imp__wsprintfA
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _output$16[ebp]
	mov	DWORD PTR _output$16[ebp], eax

; 507  : 					pStack++;

	mov	edx, DWORD PTR _pStack$17[ebp]
	add	edx, 4
	mov	DWORD PTR _pStack$17[ebp], edx

; 508  : 					// Check for when the buffer is almost full, and flush it to disk.
; 509  : 					if (output > nearend)

	mov	eax, DWORD PTR _output$16[ebp]
	cmp	eax, DWORD PTR _nearend$4[ebp]
	jbe	SHORT $LN1@RecordExce

; 510  : 					{
; 511  : 						hprintf(LogFile, "%s", buffer);

	lea	ecx, DWORD PTR _buffer$20[ebp]
	push	ecx
	push	OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
	mov	edx, DWORD PTR _LogFile$[ebp]
	push	edx
	call	?hprintf@@YAXPAXPADZZ			; hprintf
	add	esp, 12					; 0000000cH

; 512  : 						buffer[0] = 0;

	mov	eax, 1
	imul	eax, 0
	mov	DWORD PTR $T10[ebp], eax
	cmp	DWORD PTR $T10[ebp], 1000		; 000003e8H
	jae	SHORT $LN32@RecordExce
	jmp	SHORT $LN33@RecordExce
$LN32@RecordExce:
	call	___report_rangecheckfailure
$LN33@RecordExce:
	mov	ecx, DWORD PTR $T10[ebp]
	mov	BYTE PTR _buffer$20[ebp+ecx], 0

; 513  : 						output = buffer;

	lea	edx, DWORD PTR _buffer$20[ebp]
	mov	DWORD PTR _output$16[ebp], edx
$LN1@RecordExce:

; 514  : 					}
; 515  : 				}

	jmp	$LN6@RecordExce
$LN5@RecordExce:

; 516  : 				// Print out any final characters from the cache.
; 517  : 				hprintf(LogFile, "%s\r\n", buffer);

	lea	eax, DWORD PTR _buffer$20[ebp]
	push	eax
	push	OFFSET ??_C@_04LLEBNMDN@?$CFs?$AN?6?$AA@
	mov	ecx, DWORD PTR _LogFile$[ebp]
	push	ecx
	call	?hprintf@@YAXPAXPADZZ			; hprintf
	add	esp, 12					; 0000000cH

; 518  : 			}

	mov	DWORD PTR __$SEHRec$[ebp+20], -2	; fffffffeH
	jmp	SHORT $LN9@RecordExce
$LN39@RecordExce:
$LN48@RecordExce:

; 519  : 			__except(EXCEPTION_EXECUTE_HANDLER)

	mov	eax, 1
$LN41@RecordExce:
$LN46@RecordExce:
	ret	0
$LN40@RecordExce:
	mov	esp, DWORD PTR __$SEHRec$[ebp]

; 520  : 			{
; 521  : 				hprintf(LogFile, "Exception encountered during stack dump (old format).\r\n");

	push	OFFSET ??_C@_0DI@HNIHMEGJ@Exception?5encountered?5during?5sta@
	mov	edx, DWORD PTR _LogFile$[ebp]
	push	edx
	call	?hprintf@@YAXPAXPADZZ			; hprintf
	add	esp, 8

; 522  : 			}

	mov	DWORD PTR __$SEHRec$[ebp+20], -2	; fffffffeH
$LN9@RecordExce:

; 523  : 		}
; 524  : 		// END OF ADDED SECTION 2002-04-01
; 525  : 
; 526  : 		hprintf (LogFile, "%s\r\n", GetRegisterString(data));

	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	call	?GetRegisterString@@YGPBDPAU_EXCEPTION_POINTERS@@@Z ; GetRegisterString
	push	eax
	push	OFFSET ??_C@_04LLEBNMDN@?$CFs?$AN?6?$AA@
	mov	ecx, DWORD PTR _LogFile$[ebp]
	push	ecx
	call	?hprintf@@YAXPAXPADZZ			; hprintf
	add	esp, 12					; 0000000cH
$LN12@RecordExce:

; 527  : 	}
; 528  : 
; 529  : 	RecordSystemInformation (LogFile);

	mov	edx, DWORD PTR _LogFile$[ebp]
	push	edx
	call	?RecordSystemInformation@@YAXPAX@Z	; RecordSystemInformation
	add	esp, 4

; 530  : 	RecordModuleList(LogFile);

	mov	eax, DWORD PTR _LogFile$[ebp]
	push	eax
	call	?RecordModuleList@@YAXPAX@Z		; RecordModuleList
	add	esp, 4

; 531  : 	CloseHandle(LogFile);

	mov	ecx, DWORD PTR _LogFile$[ebp]
	push	ecx
	call	DWORD PTR __imp__CloseHandle@4

; 532  : 	// Return the magic value which tells Win32 that this handler didn't
; 533  : 	// actually handle the exception - so that things will proceed as per
; 534  : 	// normal.
; 535  : 	return EXCEPTION_CONTINUE_SEARCH;

	xor	eax, eax
$LN34@RecordExce:

; 536  : }

	mov	ecx, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?RecordExceptionInfo@@YAHPAU_EXCEPTION_POINTERS@@PBD@Z ENDP ; RecordExceptionInfo
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\ehandler.cpp
_TEXT	SEGMENT
_result$ = -4						; size = 4
_source$ = 8						; size = 4
?GetFilePart@@YAPADPAD@Z PROC				; GetFilePart

; 316  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 317  : 	char *result = strrchr(source, '\\');

	push	92					; 0000005cH
	mov	eax, DWORD PTR _source$[ebp]
	push	eax
	call	?strrchr@@YAPADPADH@Z			; strrchr
	add	esp, 8
	mov	DWORD PTR _result$[ebp], eax

; 318  : 	if (result)

	cmp	DWORD PTR _result$[ebp], 0
	je	SHORT $LN2@GetFilePar

; 319  : 		result++;

	mov	ecx, DWORD PTR _result$[ebp]
	add	ecx, 1
	mov	DWORD PTR _result$[ebp], ecx

; 320  : 	else

	jmp	SHORT $LN1@GetFilePar
$LN2@GetFilePar:

; 321  : 		result = source;

	mov	edx, DWORD PTR _source$[ebp]
	mov	DWORD PTR _result$[ebp], edx
$LN1@GetFilePar:

; 322  : 	return result;

	mov	eax, DWORD PTR _result$[ebp]

; 323  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFilePart@@YAPADPAD@Z ENDP				; GetFilePart
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\ehandler.cpp
_TEXT	SEGMENT
_i$1 = -200						; size = 4
_ExceptionMap$ = -196					; size = 192
__$ArrayPad$ = -4					; size = 4
_ExceptionCode$ = 8					; size = 4
?GetExceptionDescription@@YAPBDK@Z PROC			; GetExceptionDescription

; 273  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 200				; 000000c8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 274  : 	struct ExceptionNames
; 275  : 	{
; 276  : 		DWORD	ExceptionCode;
; 277  : 		char*	ExceptionName;
; 278  : 	};
; 279  : 
; 280  : 	ExceptionNames ExceptionMap[] =
; 281  : 	{
; 282  : 		{0x40010005, "a Control-C"},

	mov	DWORD PTR _ExceptionMap$[ebp], 1073807365 ; 40010005H
	mov	DWORD PTR _ExceptionMap$[ebp+4], OFFSET ??_C@_0M@FNOJOPNP@a?5Control?9C?$AA@

; 283  : 		{0x40010008, "a Control-Break"},

	mov	DWORD PTR _ExceptionMap$[ebp+8], 1073807368 ; 40010008H
	mov	DWORD PTR _ExceptionMap$[ebp+12], OFFSET ??_C@_0BA@MNEFCPPO@a?5Control?9Break?$AA@

; 284  : 		{0x80000002, "a Datatype Misalignment"},

	mov	DWORD PTR _ExceptionMap$[ebp+16], -2147483646 ; 80000002H
	mov	DWORD PTR _ExceptionMap$[ebp+20], OFFSET ??_C@_0BI@IPDDFHBH@a?5Datatype?5Misalignment?$AA@

; 285  : 		{0x80000003, "a Breakpoint"},

	mov	DWORD PTR _ExceptionMap$[ebp+24], -2147483645 ; 80000003H
	mov	DWORD PTR _ExceptionMap$[ebp+28], OFFSET ??_C@_0N@JLDHOHAI@a?5Breakpoint?$AA@

; 286  : 		{0xc0000005, "an Access Violation"},

	mov	DWORD PTR _ExceptionMap$[ebp+32], -1073741819 ; c0000005H
	mov	DWORD PTR _ExceptionMap$[ebp+36], OFFSET ??_C@_0BE@GLOKLDAN@an?5Access?5Violation?$AA@

; 287  : 		{0xc0000006, "an In Page Error"},

	mov	DWORD PTR _ExceptionMap$[ebp+40], -1073741818 ; c0000006H
	mov	DWORD PTR _ExceptionMap$[ebp+44], OFFSET ??_C@_0BB@DKICMMFA@an?5In?5Page?5Error?$AA@

; 288  : 		{0xc0000017, "a No Memory"},

	mov	DWORD PTR _ExceptionMap$[ebp+48], -1073741801 ; c0000017H
	mov	DWORD PTR _ExceptionMap$[ebp+52], OFFSET ??_C@_0M@JNBECNGI@a?5No?5Memory?$AA@

; 289  : 		{0xc000001d, "an Illegal Instruction"},

	mov	DWORD PTR _ExceptionMap$[ebp+56], -1073741795 ; c000001dH
	mov	DWORD PTR _ExceptionMap$[ebp+60], OFFSET ??_C@_0BH@CMGOADMI@an?5Illegal?5Instruction?$AA@

; 290  : 		{0xc0000025, "a Noncontinuable Exception"},

	mov	DWORD PTR _ExceptionMap$[ebp+64], -1073741787 ; c0000025H
	mov	DWORD PTR _ExceptionMap$[ebp+68], OFFSET ??_C@_0BL@DFCKDLHL@a?5Noncontinuable?5Exception?$AA@

; 291  : 		{0xc0000026, "an Invalid Disposition"},

	mov	DWORD PTR _ExceptionMap$[ebp+72], -1073741786 ; c0000026H
	mov	DWORD PTR _ExceptionMap$[ebp+76], OFFSET ??_C@_0BH@HOHCDFKK@an?5Invalid?5Disposition?$AA@

; 292  : 		{0xc000008c, "a Array Bounds Exceeded"},

	mov	DWORD PTR _ExceptionMap$[ebp+80], -1073741684 ; c000008cH
	mov	DWORD PTR _ExceptionMap$[ebp+84], OFFSET ??_C@_0BI@DFIFOIBG@a?5Array?5Bounds?5Exceeded?$AA@

; 293  : 		{0xc000008d, "a Float Denormal Operand"},

	mov	DWORD PTR _ExceptionMap$[ebp+88], -1073741683 ; c000008dH
	mov	DWORD PTR _ExceptionMap$[ebp+92], OFFSET ??_C@_0BJ@LCJBHHL@a?5Float?5Denormal?5Operand?$AA@

; 294  : 		{0xc000008e, "a Float Divide by Zero"},

	mov	DWORD PTR _ExceptionMap$[ebp+96], -1073741682 ; c000008eH
	mov	DWORD PTR _ExceptionMap$[ebp+100], OFFSET ??_C@_0BH@PIHGMMNI@a?5Float?5Divide?5by?5Zero?$AA@

; 295  : 		{0xc000008f, "a Float Inexact Result"},

	mov	DWORD PTR _ExceptionMap$[ebp+104], -1073741681 ; c000008fH
	mov	DWORD PTR _ExceptionMap$[ebp+108], OFFSET ??_C@_0BH@HGODNPMP@a?5Float?5Inexact?5Result?$AA@

; 296  : 		{0xc0000090, "a Float Invalid Operation"},

	mov	DWORD PTR _ExceptionMap$[ebp+112], -1073741680 ; c0000090H
	mov	DWORD PTR _ExceptionMap$[ebp+116], OFFSET ??_C@_0BK@NACDCIPD@a?5Float?5Invalid?5Operation?$AA@

; 297  : 		{0xc0000091, "a Float Overflow"},

	mov	DWORD PTR _ExceptionMap$[ebp+120], -1073741679 ; c0000091H
	mov	DWORD PTR _ExceptionMap$[ebp+124], OFFSET ??_C@_0BB@LAJAGHGH@a?5Float?5Overflow?$AA@

; 298  : 		{0xc0000092, "a Float Stack Check"},

	mov	DWORD PTR _ExceptionMap$[ebp+128], -1073741678 ; c0000092H
	mov	DWORD PTR _ExceptionMap$[ebp+132], OFFSET ??_C@_0BE@DOBFFDCD@a?5Float?5Stack?5Check?$AA@

; 299  : 		{0xc0000093, "a Float Underflow"},

	mov	DWORD PTR _ExceptionMap$[ebp+136], -1073741677 ; c0000093H
	mov	DWORD PTR _ExceptionMap$[ebp+140], OFFSET ??_C@_0BC@CICINNDB@a?5Float?5Underflow?$AA@

; 300  : 		{0xc0000094, "an Integer Divide by Zero"},

	mov	DWORD PTR _ExceptionMap$[ebp+144], -1073741676 ; c0000094H
	mov	DWORD PTR _ExceptionMap$[ebp+148], OFFSET ??_C@_0BK@FNOEEFCK@an?5Integer?5Divide?5by?5Zero?$AA@

; 301  : 		{0xc0000095, "an Integer Overflow"},

	mov	DWORD PTR _ExceptionMap$[ebp+152], -1073741675 ; c0000095H
	mov	DWORD PTR _ExceptionMap$[ebp+156], OFFSET ??_C@_0BE@CDPGECPC@an?5Integer?5Overflow?$AA@

; 302  : 		{0xc0000096, "a Privileged Instruction"},

	mov	DWORD PTR _ExceptionMap$[ebp+160], -1073741674 ; c0000096H
	mov	DWORD PTR _ExceptionMap$[ebp+164], OFFSET ??_C@_0BJ@HMGNLHOK@a?5Privileged?5Instruction?$AA@

; 303  : 		{0xc00000fD, "a Stack Overflow"},

	mov	DWORD PTR _ExceptionMap$[ebp+168], -1073741571 ; c00000fdH
	mov	DWORD PTR _ExceptionMap$[ebp+172], OFFSET ??_C@_0BB@LJENMGNL@a?5Stack?5Overflow?$AA@

; 304  : 		{0xc0000142, "a DLL Initialization Failed"},

	mov	DWORD PTR _ExceptionMap$[ebp+176], -1073741502 ; c0000142H
	mov	DWORD PTR _ExceptionMap$[ebp+180], OFFSET ??_C@_0BM@LDHCKNKI@a?5DLL?5Initialization?5Failed?$AA@

; 305  : 		{0xe06d7363, "a Microsoft C++ Exception"},

	mov	DWORD PTR _ExceptionMap$[ebp+184], -529697949 ; e06d7363H
	mov	DWORD PTR _ExceptionMap$[ebp+188], OFFSET ??_C@_0BK@HOJFPEEB@a?5Microsoft?5C?$CL?$CL?5Exception?$AA@

; 306  : 	};
; 307  : 
; 308  : 	for (int i = 0; i < sizeof(ExceptionMap) / sizeof(ExceptionMap[0]); i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@GetExcepti
$LN3@GetExcepti:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@GetExcepti:
	cmp	DWORD PTR _i$1[ebp], 24			; 00000018H
	jae	SHORT $LN2@GetExcepti

; 309  : 		if (ExceptionCode == ExceptionMap[i].ExceptionCode)

	mov	ecx, DWORD PTR _i$1[ebp]
	mov	edx, DWORD PTR _ExceptionCode$[ebp]
	cmp	edx, DWORD PTR _ExceptionMap$[ebp+ecx*8]
	jne	SHORT $LN1@GetExcepti

; 310  : 			return ExceptionMap[i].ExceptionName;

	mov	eax, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR _ExceptionMap$[ebp+eax*8+4]
	jmp	SHORT $LN5@GetExcepti
$LN1@GetExcepti:

; 311  : 
; 312  : 	return "Unknown exception type";

	jmp	SHORT $LN3@GetExcepti
$LN2@GetExcepti:
	mov	eax, OFFSET ??_C@_0BH@GMMOLJLG@Unknown?5exception?5type?$AA@
$LN5@GetExcepti:

; 313  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?GetExceptionDescription@@YAPBDK@Z ENDP			; GetExceptionDescription
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\ehandler.cpp
_TEXT	SEGMENT
_SystemInfo$ = -836					; size = 36
_CurrentTime$ = -800					; size = 8
_UserNameSize$ = -792					; size = 4
tv185 = -788						; size = 4
tv171 = -784						; size = 4
tv195 = -780						; size = 4
tv188 = -776						; size = 4
_gtype$2 = -772						; size = 4
_VersionInfo$ = -768					; size = 148
_MemInfo$ = -620					; size = 32
_ModuleName$ = -588					; size = 260
_UserName$ = -328					; size = 200
_TimeBuffer$ = -128					; size = 100
__$ArrayPad$ = -28					; size = 4
__$SEHRec$ = -24					; size = 24
_LogFile$ = 8						; size = 4
?RecordSystemInformation@@YAXPAX@Z PROC			; RecordSystemInformation

; 193  : {

	push	ebp
	mov	ebp, esp
	push	-2					; fffffffeH
	push	OFFSET __sehtable$?RecordSystemInformation@@YAXPAX@Z
	push	OFFSET __except_handler4
	mov	eax, DWORD PTR fs:0
	push	eax
	add	esp, -820				; fffffcccH
	mov	eax, DWORD PTR ___security_cookie
	xor	DWORD PTR __$SEHRec$[ebp+16], eax
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$SEHRec$[ebp], esp

; 194  : 	FILETIME	CurrentTime;
; 195  : 	GetSystemTimeAsFileTime(&CurrentTime);

	lea	eax, DWORD PTR _CurrentTime$[ebp]
	push	eax
	call	DWORD PTR __imp__GetSystemTimeAsFileTime@4

; 196  : 	char TimeBuffer[100];
; 197  : 	PrintTime(TimeBuffer, CurrentTime);

	mov	ecx, DWORD PTR _CurrentTime$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _CurrentTime$[ebp]
	push	edx
	lea	eax, DWORD PTR _TimeBuffer$[ebp]
	push	eax
	call	?PrintTime@@YAXPADU_FILETIME@@@Z	; PrintTime
	add	esp, 12					; 0000000cH

; 198  : 	hprintf(LogFile, "Error occurred at %s.\r\n", TimeBuffer);

	lea	ecx, DWORD PTR _TimeBuffer$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BI@JNCPBKJH@Error?5occurred?5at?5?$CFs?4?$AN?6?$AA@
	mov	edx, DWORD PTR _LogFile$[ebp]
	push	edx
	call	?hprintf@@YAXPAXPADZZ			; hprintf
	add	esp, 12					; 0000000cH

; 199  : 	char	ModuleName[MAX_PATH];
; 200  : 	if (GetModuleFileName(0, ModuleName, sizeof(ModuleName)) <= 0)

	push	260					; 00000104H
	lea	eax, DWORD PTR _ModuleName$[ebp]
	push	eax
	push	0
	call	DWORD PTR __imp__GetModuleFileNameA@12
	test	eax, eax
	ja	SHORT $LN13@RecordSyst

; 201  : 		lstrcpy(ModuleName, "Unknown");

	push	OFFSET ??_C@_07NBCGADJA@Unknown?$AA@
	lea	ecx, DWORD PTR _ModuleName$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrcpyA@8
$LN13@RecordSyst:

; 202  : 	char	UserName[200];
; 203  : 	DWORD UserNameSize = sizeof(UserName);

	mov	DWORD PTR _UserNameSize$[ebp], 200	; 000000c8H

; 204  : 	if (!GetUserName(UserName, &UserNameSize))

	lea	edx, DWORD PTR _UserNameSize$[ebp]
	push	edx
	lea	eax, DWORD PTR _UserName$[ebp]
	push	eax
	call	DWORD PTR __imp__GetUserNameA@8
	test	eax, eax
	jne	SHORT $LN12@RecordSyst

; 205  : 		lstrcpy(UserName, "Unknown");

	push	OFFSET ??_C@_07NBCGADJA@Unknown?$AA@
	lea	ecx, DWORD PTR _UserName$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrcpyA@8
$LN12@RecordSyst:

; 206  : 	hprintf(LogFile, "%s, run by %s.\r\n", ModuleName, UserName);

	lea	edx, DWORD PTR _UserName$[ebp]
	push	edx
	lea	eax, DWORD PTR _ModuleName$[ebp]
	push	eax
	push	OFFSET ??_C@_0BB@GEKHAOPD@?$CFs?0?5run?5by?5?$CFs?4?$AN?6?$AA@
	mov	ecx, DWORD PTR _LogFile$[ebp]
	push	ecx
	call	?hprintf@@YAXPAXPADZZ			; hprintf
	add	esp, 16					; 00000010H

; 207  : 
; 208  : 	SYSTEM_INFO	SystemInfo;
; 209  : 	GetSystemInfo(&SystemInfo);

	lea	edx, DWORD PTR _SystemInfo$[ebp]
	push	edx
	call	DWORD PTR __imp__GetSystemInfo@4

; 210  : 	hprintf(LogFile, "%d processor(s), type %d.\r\n",
; 211  : 				SystemInfo.dwNumberOfProcessors, SystemInfo.dwProcessorType);

	mov	eax, DWORD PTR _SystemInfo$[ebp+24]
	push	eax
	mov	ecx, DWORD PTR _SystemInfo$[ebp+20]
	push	ecx
	push	OFFSET ??_C@_0BM@CGPALIEL@?$CFd?5processor?$CIs?$CJ?0?5type?5?$CFd?4?$AN?6?$AA@
	mov	edx, DWORD PTR _LogFile$[ebp]
	push	edx
	call	?hprintf@@YAXPAXPADZZ			; hprintf
	add	esp, 16					; 00000010H

; 212  : 
; 213  : 	MEMORYSTATUS	MemInfo;
; 214  : 	MemInfo.dwLength = sizeof(MemInfo);

	mov	DWORD PTR _MemInfo$[ebp], 32		; 00000020H

; 215  : 	GlobalMemoryStatus(&MemInfo);

	lea	eax, DWORD PTR _MemInfo$[ebp]
	push	eax
	call	DWORD PTR __imp__GlobalMemoryStatus@4

; 216  : 	// Print out the amount of physical memory, rounded up.
; 217  : 	hprintf(LogFile, "%d MBytes physical memory.\r\n", (MemInfo.dwTotalPhys +
; 218  : 				ONEM - 1) / ONEM);

	mov	ecx, DWORD PTR _MemInfo$[ebp+8]
	add	ecx, 1048575				; 000fffffH
	shr	ecx, 20					; 00000014H
	push	ecx
	push	OFFSET ??_C@_0BN@PBHEHCOH@?$CFd?5MBytes?5physical?5memory?4?$AN?6?$AA@
	mov	edx, DWORD PTR _LogFile$[ebp]
	push	edx
	call	?hprintf@@YAXPAXPADZZ			; hprintf
	add	esp, 12					; 0000000cH

; 219  : 
; 220  : 	OSVERSIONINFO VersionInfo;
; 221  : 	VersionInfo.dwOSVersionInfoSize = sizeof(VersionInfo);

	mov	DWORD PTR _VersionInfo$[ebp], 148	; 00000094H

; 222  : 	GetVersionEx(&VersionInfo);

	lea	eax, DWORD PTR _VersionInfo$[ebp]
	push	eax
	call	DWORD PTR __imp__GetVersionExA@4

; 223  : 	hprintf(LogFile, "OS: %d.%d build %d platform %d %s\r\n", 
; 224  : 	    VersionInfo.dwMajorVersion, VersionInfo.dwMinorVersion,
; 225  : 	    VersionInfo.dwBuildNumber, VersionInfo.dwPlatformId,
; 226  : 	    VersionInfo.szCSDVersion);

	lea	ecx, DWORD PTR _VersionInfo$[ebp+20]
	push	ecx
	mov	edx, DWORD PTR _VersionInfo$[ebp+16]
	push	edx
	mov	eax, DWORD PTR _VersionInfo$[ebp+12]
	push	eax
	mov	ecx, DWORD PTR _VersionInfo$[ebp+8]
	push	ecx
	mov	edx, DWORD PTR _VersionInfo$[ebp+4]
	push	edx
	push	OFFSET ??_C@_0CE@DFDMPIDM@OS?3?5?$CFd?4?$CFd?5build?5?$CFd?5platform?5?$CFd?5?$CF@
	mov	eax, DWORD PTR _LogFile$[ebp]
	push	eax
	call	?hprintf@@YAXPAXPADZZ			; hprintf
	add	esp, 28					; 0000001cH

; 227  : 
; 228  : 	hprintf(LogFile, "Version: Falcon 4.0 - Version %1d.%02d.%1d.%05d\r\n",MajorVersion,MinorVersion,gLangIDNum,BuildNumber);

	mov	ecx, DWORD PTR ?BuildNumber@@3HA	; BuildNumber
	push	ecx
	mov	edx, DWORD PTR ?gLangIDNum@@3HA		; gLangIDNum
	push	edx
	mov	eax, DWORD PTR ?MinorVersion@@3HA	; MinorVersion
	push	eax
	mov	ecx, DWORD PTR ?MajorVersion@@3HA	; MajorVersion
	push	ecx
	push	OFFSET ??_C@_0DC@OKFBJPKB@Version?3?5Falcon?54?40?5?9?5Version?5?$CF1@
	mov	edx, DWORD PTR _LogFile$[ebp]
	push	edx
	call	?hprintf@@YAXPAXPADZZ			; hprintf
	add	esp, 24					; 00000018H

; 229  : 
; 230  : 	hprintf(LogFile, "%s\r\n", g_sVersion);

	push	OFFSET ?g_sVersion@@3PADA		; g_sVersion
	push	OFFSET ??_C@_04LLEBNMDN@?$CFs?$AN?6?$AA@
	mov	eax, DWORD PTR _LogFile$[ebp]
	push	eax
	call	?hprintf@@YAXPAXPADZZ			; hprintf
	add	esp, 12					; 0000000cH

; 231  : 
; 232  : 	if (g_CardDetails[0])

	mov	ecx, 1
	imul	ecx, 0
	movsx	edx, BYTE PTR ?g_CardDetails@@3PADA[ecx]
	test	edx, edx
	je	SHORT $LN11@RecordSyst

; 233  : 		hprintf(LogFile, "Card: %s\r\n", g_CardDetails);

	push	OFFSET ?g_CardDetails@@3PADA		; g_CardDetails
	push	OFFSET ??_C@_0L@OGCADAFE@Card?3?5?$CFs?$AN?6?$AA@
	mov	eax, DWORD PTR _LogFile$[ebp]
	push	eax
	call	?hprintf@@YAXPAXPADZZ			; hprintf
	add	esp, 12					; 0000000cH
$LN11@RecordSyst:

; 234  : 	if (vuLocalSessionEntity && FalconLocalGame) {

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	$LN10@RecordSyst
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN16@RecordSyst
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv171[ebp], eax
	jmp	SHORT $LN17@RecordSyst
$LN16@RecordSyst:
	mov	DWORD PTR tv171[ebp], 0
$LN17@RecordSyst:
	cmp	DWORD PTR tv171[ebp], 0
	je	$LN10@RecordSyst

; 235  : 	    __try { // just in case this is screwd up

	mov	DWORD PTR __$SEHRec$[ebp+20], 0

; 236  : 		char *gtype;
; 237  : 		switch (FalconLocalGame->GetGameType()) {

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN18@RecordSyst
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv185[ebp], eax
	jmp	SHORT $LN19@RecordSyst
$LN18@RecordSyst:
	mov	DWORD PTR tv185[ebp], 0
$LN19@RecordSyst:
	mov	ecx, DWORD PTR tv185[ebp]
	call	?GetGameType@FalconGameEntity@@QAE?AW4FalconGameType@@XZ ; FalconGameEntity::GetGameType
	mov	DWORD PTR tv188[ebp], eax
	mov	ecx, DWORD PTR tv188[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv188[ebp], ecx
	cmp	DWORD PTR tv188[ebp], 3
	ja	SHORT $LN2@RecordSyst
	mov	edx, DWORD PTR tv188[ebp]
	jmp	DWORD PTR $LN28@RecordSyst[edx*4]
$LN6@RecordSyst:

; 238  : 		case 	game_InstantAction:
; 239  : 		    gtype = "Instant Action";

	mov	DWORD PTR _gtype$2[ebp], OFFSET ??_C@_0P@GHEJFKFN@Instant?5Action?$AA@

; 240  : 		    break;

	jmp	SHORT $LN7@RecordSyst
$LN5@RecordSyst:

; 241  : 		case 	game_Dogfight:
; 242  : 		    gtype = "DogFight";

	mov	DWORD PTR _gtype$2[ebp], OFFSET ??_C@_08DLBHGMLL@DogFight?$AA@

; 243  : 		    break;

	jmp	SHORT $LN7@RecordSyst
$LN4@RecordSyst:

; 244  : 		case game_TacticalEngagement:
; 245  : 		    gtype = "Tactical Engagement";

	mov	DWORD PTR _gtype$2[ebp], OFFSET ??_C@_0BE@NJKPNHIC@Tactical?5Engagement?$AA@

; 246  : 		    break;

	jmp	SHORT $LN7@RecordSyst
$LN3@RecordSyst:

; 247  : 		case game_Campaign:
; 248  : 		    gtype = "Campaign";

	mov	DWORD PTR _gtype$2[ebp], OFFSET ??_C@_08FHHBCJKK@Campaign?$AA@

; 249  : 		    break;

	jmp	SHORT $LN7@RecordSyst
$LN2@RecordSyst:

; 250  : 		default:
; 251  : 		    gtype = "<unknown>";

	mov	DWORD PTR _gtype$2[ebp], OFFSET ??_C@_09EEKGDCPH@?$DMunknown?$DO?$AA@
$LN7@RecordSyst:

; 252  : 		    break;
; 253  : 		}
; 254  : 		hprintf(LogFile, "Game is %s type %s\r\n", gtype,
; 255  : 		    gCommsMgr && gCommsMgr->Online() ? "Networked" : "Local");

	cmp	DWORD PTR ?gCommsMgr@@3PAVUIComms@@A, 0	; gCommsMgr
	je	SHORT $LN20@RecordSyst
	mov	ecx, DWORD PTR ?gCommsMgr@@3PAVUIComms@@A ; gCommsMgr
	call	?Online@UIComms@@QAEHXZ			; UIComms::Online
	test	eax, eax
	je	SHORT $LN20@RecordSyst
	mov	DWORD PTR tv195[ebp], OFFSET ??_C@_09FCDNMMPE@Networked?$AA@
	jmp	SHORT $LN21@RecordSyst
$LN20@RecordSyst:
	mov	DWORD PTR tv195[ebp], OFFSET ??_C@_05IEALKJIG@Local?$AA@
$LN21@RecordSyst:
	mov	eax, DWORD PTR tv195[ebp]
	push	eax
	mov	ecx, DWORD PTR _gtype$2[ebp]
	push	ecx
	push	OFFSET ??_C@_0BF@OIBLHPO@Game?5is?5?$CFs?5type?5?$CFs?$AN?6?$AA@
	mov	edx, DWORD PTR _LogFile$[ebp]
	push	edx
	call	?hprintf@@YAXPAXPADZZ			; hprintf
	add	esp, 16					; 00000010H

; 256  : 	    } 

	mov	DWORD PTR __$SEHRec$[ebp+20], -2	; fffffffeH
	jmp	SHORT $LN26@RecordSyst
$LN23@RecordSyst:
$LN29@RecordSyst:

; 257  : 	    __except (EXCEPTION_EXECUTE_HANDLER) {

	mov	eax, 1
$LN25@RecordSyst:
$LN27@RecordSyst:
	ret	0
$LN24@RecordSyst:
	mov	esp, DWORD PTR __$SEHRec$[ebp]

; 258  : 		// nothing here.
; 259  : 	    }

	mov	DWORD PTR __$SEHRec$[ebp+20], -2	; fffffffeH
$LN26@RecordSyst:

; 260  : 	}
; 261  : 	else hprintf(LogFile, "Not in game\r\n");

	jmp	SHORT $LN1@RecordSyst
$LN10@RecordSyst:
	push	OFFSET ??_C@_0O@HOMEGICE@Not?5in?5game?$AN?6?$AA@
	mov	eax, DWORD PTR _LogFile$[ebp]
	push	eax
	call	?hprintf@@YAXPAXPADZZ			; hprintf
	add	esp, 8
$LN1@RecordSyst:

; 262  : 
; 263  : 	// COBRA - RED - The DX of the Model ID under draw
; 264  : 	hprintf(LogFile, "DX Model ID : %x\r\n", gDebugLodID);

	mov	ecx, DWORD PTR ?gDebugLodID@@3KA	; gDebugLodID
	push	ecx
	push	OFFSET ??_C@_0BD@HGCFCCOL@DX?5Model?5ID?5?3?5?$CFx?$AN?6?$AA@
	mov	edx, DWORD PTR _LogFile$[ebp]
	push	edx
	call	?hprintf@@YAXPAXPADZZ			; hprintf
	add	esp, 12					; 0000000cH

; 265  : 	// COBRA - RED - The ID of the Texture referenced
; 266  : 	hprintf(LogFile, "Texture ID  : %x\r\n", gDebugTextureID);

	mov	eax, DWORD PTR ?gDebugTextureID@@3KA	; gDebugTextureID
	push	eax
	push	OFFSET ??_C@_0BD@DCNBFGFP@Texture?5ID?5?5?3?5?$CFx?$AN?6?$AA@
	mov	ecx, DWORD PTR _LogFile$[ebp]
	push	ecx
	call	?hprintf@@YAXPAXPADZZ			; hprintf
	add	esp, 12					; 0000000cH
$LN22@RecordSyst:

; 267  : 
; 268  : }

	mov	ecx, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN28@RecordSyst:
	DD	$LN6@RecordSyst
	DD	$LN5@RecordSyst
	DD	$LN4@RecordSyst
	DD	$LN3@RecordSyst
?RecordSystemInformation@@YAXPAX@Z ENDP			; RecordSystemInformation
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\ehandler.cpp
_TEXT	SEGMENT
_SystemInfo$ = -80					; size = 36
_MemInfo$1 = -44					; size = 28
_NumPages$ = -16					; size = 4
_LastAllocationBase$ = -12				; size = 4
_PageSize$ = -8						; size = 4
_pageNum$ = -4						; size = 4
_LogFile$ = 8						; size = 4
?RecordModuleList@@YAXPAX@Z PROC			; RecordModuleList

; 144  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H

; 145  : 	if (!g_bModuleList)

	movzx	eax, BYTE PTR ?g_bModuleList@@3_NA	; g_bModuleList
	test	eax, eax
	jne	SHORT $LN8@RecordModu

; 146  : 		return;

	jmp	$LN9@RecordModu
$LN8@RecordModu:

; 147  : 
; 148  : 	hprintf(LogFile, "\r\n"
; 149  : 					 "\tModule list: names, addresses, sizes, time stamps "
; 150  : 			"and file times:\r\n");

	push	OFFSET ??_C@_0EH@IAGPJNKE@?$AN?6?7Module?5list?3?5names?0?5addresses@
	mov	ecx, DWORD PTR _LogFile$[ebp]
	push	ecx
	call	?hprintf@@YAXPAXPADZZ			; hprintf
	add	esp, 8

; 151  : 	SYSTEM_INFO	SystemInfo;
; 152  : 	GetSystemInfo(&SystemInfo);

	lea	edx, DWORD PTR _SystemInfo$[ebp]
	push	edx
	call	DWORD PTR __imp__GetSystemInfo@4

; 153  : 	const size_t PageSize = SystemInfo.dwPageSize;

	mov	eax, DWORD PTR _SystemInfo$[ebp+4]
	mov	DWORD PTR _PageSize$[ebp], eax

; 154  : 	// Set NumPages to the number of pages in the 4GByte address space,
; 155  : 	// while being careful to avoid overflowing ints.
; 156  : 	const size_t NumPages = 4 * size_t(ONEG / PageSize);

	mov	eax, 1073741824				; 40000000H
	xor	edx, edx
	div	DWORD PTR _PageSize$[ebp]
	shl	eax, 2
	mov	DWORD PTR _NumPages$[ebp], eax

; 157  : 	size_t pageNum = 0;

	mov	DWORD PTR _pageNum$[ebp], 0

; 158  : 	void *LastAllocationBase = 0;

	mov	DWORD PTR _LastAllocationBase$[ebp], 0
$LN7@RecordModu:

; 159  : 	while (pageNum < NumPages)

	mov	ecx, DWORD PTR _pageNum$[ebp]
	cmp	ecx, DWORD PTR _NumPages$[ebp]
	jae	SHORT $LN9@RecordModu

; 160  : 	{
; 161  : 		MEMORY_BASIC_INFORMATION	MemInfo;
; 162  : 		if (VirtualQuery((void *)(pageNum * PageSize), &MemInfo,
; 163  : 					sizeof(MemInfo)))

	push	28					; 0000001cH
	lea	edx, DWORD PTR _MemInfo$1[ebp]
	push	edx
	mov	eax, DWORD PTR _pageNum$[ebp]
	imul	eax, DWORD PTR _PageSize$[ebp]
	push	eax
	call	DWORD PTR __imp__VirtualQuery@12
	test	eax, eax
	je	SHORT $LN5@RecordModu

; 164  : 		{
; 165  : 			if (MemInfo.RegionSize > 0)

	cmp	DWORD PTR _MemInfo$1[ebp+12], 0
	jbe	SHORT $LN4@RecordModu

; 166  : 			{
; 167  : 				// Adjust the page number to skip over this block of memory.
; 168  : 				pageNum += MemInfo.RegionSize / PageSize;

	mov	eax, DWORD PTR _MemInfo$1[ebp+12]
	xor	edx, edx
	div	DWORD PTR _PageSize$[ebp]
	add	eax, DWORD PTR _pageNum$[ebp]
	mov	DWORD PTR _pageNum$[ebp], eax

; 169  : 				if (MemInfo.State == MEM_COMMIT && MemInfo.AllocationBase >
; 170  : 							LastAllocationBase)

	cmp	DWORD PTR _MemInfo$1[ebp+16], 4096	; 00001000H
	jne	SHORT $LN3@RecordModu
	mov	ecx, DWORD PTR _MemInfo$1[ebp+4]
	cmp	ecx, DWORD PTR _LastAllocationBase$[ebp]
	jbe	SHORT $LN3@RecordModu

; 171  : 				{
; 172  : 					// Look for new blocks of committed memory, and try
; 173  : 					// recording their module names - this will fail
; 174  : 					// gracefully if they aren't code modules.
; 175  : 					LastAllocationBase = MemInfo.AllocationBase;

	mov	edx, DWORD PTR _MemInfo$1[ebp+4]
	mov	DWORD PTR _LastAllocationBase$[ebp], edx

; 176  : 					ShowModuleInfo(LogFile, (HINSTANCE)LastAllocationBase);

	mov	eax, DWORD PTR _LastAllocationBase$[ebp]
	push	eax
	mov	ecx, DWORD PTR _LogFile$[ebp]
	push	ecx
	call	?ShowModuleInfo@@YAXPAXPAUHINSTANCE__@@@Z ; ShowModuleInfo
	add	esp, 8
$LN3@RecordModu:

; 177  : 				}
; 178  : 			}
; 179  : 			else

	jmp	SHORT $LN2@RecordModu
$LN4@RecordModu:

; 180  : 				pageNum += SIXTYFOURK / PageSize;

	mov	eax, 65536				; 00010000H
	xor	edx, edx
	div	DWORD PTR _PageSize$[ebp]
	add	eax, DWORD PTR _pageNum$[ebp]
	mov	DWORD PTR _pageNum$[ebp], eax
$LN2@RecordModu:

; 181  : 		}
; 182  : 		else

	jmp	SHORT $LN1@RecordModu
$LN5@RecordModu:

; 183  : 			pageNum += SIXTYFOURK / PageSize;

	mov	eax, 65536				; 00010000H
	xor	edx, edx
	div	DWORD PTR _PageSize$[ebp]
	add	eax, DWORD PTR _pageNum$[ebp]
	mov	DWORD PTR _pageNum$[ebp], eax
$LN1@RecordModu:

; 184  : 		// If VirtualQuery fails we advance by 64K because that is the
; 185  : 		// granularity of address space doled out by VirtualAlloc().
; 186  : 	}

	jmp	$LN7@RecordModu
$LN9@RecordModu:

; 187  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RecordModuleList@@YAXPAX@Z ENDP			; RecordModuleList
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\ehandler.cpp
_TEXT	SEGMENT
_LastWriteTime$2 = -412					; size = 8
_NTHeader$3 = -404					; size = 4
_FileSize$4 = -400					; size = 4
_DosHeader$5 = -396					; size = 4
_ModuleFile$6 = -392					; size = 4
_ModName$ = -388					; size = 260
_TimeBuffer$7 = -128					; size = 100
__$ArrayPad$ = -28					; size = 4
__$SEHRec$ = -24					; size = 24
_LogFile$ = 8						; size = 4
_ModuleHandle$ = 12					; size = 4
?ShowModuleInfo@@YAXPAXPAUHINSTANCE__@@@Z PROC		; ShowModuleInfo

; 93   : {

	push	ebp
	mov	ebp, esp
	push	-2					; fffffffeH
	push	OFFSET __sehtable$?ShowModuleInfo@@YAXPAXPAUHINSTANCE__@@@Z
	push	OFFSET __except_handler4
	mov	eax, DWORD PTR fs:0
	push	eax
	add	esp, -396				; fffffe74H
	mov	eax, DWORD PTR ___security_cookie
	xor	DWORD PTR __$SEHRec$[ebp+16], eax
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$SEHRec$[ebp], esp

; 94   : 	char ModName[MAX_PATH];
; 95   : 	__try

	mov	DWORD PTR __$SEHRec$[ebp+20], 0

; 96   : 	{
; 97   : 		if (GetModuleFileName(ModuleHandle, ModName, sizeof(ModName)) > 0)

	push	260					; 00000104H
	lea	eax, DWORD PTR _ModName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ModuleHandle$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetModuleFileNameA@12
	test	eax, eax
	jbe	$LN6@ShowModule

; 98   : 		{
; 99   : 			// If GetModuleFileName returns greater than zero then this must
; 100  : 			// be a valid code module address. Therefore we can try to walk
; 101  : 			// our way through its structures to find the link time stamp.
; 102  : 			IMAGE_DOS_HEADER *DosHeader = (IMAGE_DOS_HEADER*)ModuleHandle;

	mov	edx, DWORD PTR _ModuleHandle$[ebp]
	mov	DWORD PTR _DosHeader$5[ebp], edx

; 103  : 		    if (IMAGE_DOS_SIGNATURE != DosHeader->e_magic)

	mov	eax, DWORD PTR _DosHeader$5[ebp]
	movzx	ecx, WORD PTR [eax]
	cmp	ecx, 23117				; 00005a4dH
	je	SHORT $LN4@ShowModule

; 104  : 	    	    return;

	mov	DWORD PTR __$SEHRec$[ebp+20], -2	; fffffffeH
	jmp	$LN9@ShowModule
$LN4@ShowModule:

; 105  : 			IMAGE_NT_HEADERS *NTHeader = (IMAGE_NT_HEADERS*)((char *)DosHeader
; 106  : 						+ DosHeader->e_lfanew);

	mov	edx, DWORD PTR _DosHeader$5[ebp]
	mov	eax, DWORD PTR _DosHeader$5[ebp]
	add	eax, DWORD PTR [edx+60]
	mov	DWORD PTR _NTHeader$3[ebp], eax

; 107  : 		    if (IMAGE_NT_SIGNATURE != NTHeader->Signature)

	mov	ecx, DWORD PTR _NTHeader$3[ebp]
	cmp	DWORD PTR [ecx], 17744			; 00004550H
	je	SHORT $LN3@ShowModule

; 108  : 	    	    return;

	mov	DWORD PTR __$SEHRec$[ebp+20], -2	; fffffffeH
	jmp	$LN9@ShowModule
$LN3@ShowModule:

; 109  : 			// Open the code module file so that we can get its file date
; 110  : 			// and size.
; 111  : 			HANDLE ModuleFile = CreateFile(ModName, GENERIC_READ,
; 112  : 						FILE_SHARE_READ, 0, OPEN_EXISTING,
; 113  : 						FILE_ATTRIBUTE_NORMAL, 0);

	push	0
	push	128					; 00000080H
	push	3
	push	0
	push	1
	push	-2147483648				; 80000000H
	lea	edx, DWORD PTR _ModName$[ebp]
	push	edx
	call	DWORD PTR __imp__CreateFileA@28
	mov	DWORD PTR _ModuleFile$6[ebp], eax

; 114  : 			char TimeBuffer[100] = "";

	mov	al, BYTE PTR ??_C@_00CNPNBAHC@?$AA@
	mov	BYTE PTR _TimeBuffer$7[ebp], al
	push	99					; 00000063H
	push	0
	lea	ecx, DWORD PTR _TimeBuffer$7[ebp+1]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 115  : 			DWORD FileSize = 0;

	mov	DWORD PTR _FileSize$4[ebp], 0

; 116  : 			if (ModuleFile != INVALID_HANDLE_VALUE)

	cmp	DWORD PTR _ModuleFile$6[ebp], -1
	je	SHORT $LN2@ShowModule

; 117  : 			{
; 118  : 				FileSize = GetFileSize(ModuleFile, 0);

	push	0
	mov	edx, DWORD PTR _ModuleFile$6[ebp]
	push	edx
	call	DWORD PTR __imp__GetFileSize@8
	mov	DWORD PTR _FileSize$4[ebp], eax

; 119  : 				FILETIME	LastWriteTime;
; 120  : 				if (GetFileTime(ModuleFile, 0, 0, &LastWriteTime))

	lea	eax, DWORD PTR _LastWriteTime$2[ebp]
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _ModuleFile$6[ebp]
	push	ecx
	call	DWORD PTR __imp__GetFileTime@16
	test	eax, eax
	je	SHORT $LN1@ShowModule

; 121  : 				{
; 122  : 					wsprintf(TimeBuffer, " - file date is ");

	push	OFFSET ??_C@_0BB@CJPAEIHC@?5?9?5file?5date?5is?5?$AA@
	lea	edx, DWORD PTR _TimeBuffer$7[ebp]
	push	edx
	call	DWORD PTR __imp__wsprintfA
	add	esp, 8

; 123  : 					PrintTime(TimeBuffer + lstrlen(TimeBuffer), LastWriteTime);

	mov	eax, DWORD PTR _LastWriteTime$2[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _LastWriteTime$2[ebp]
	push	ecx
	lea	edx, DWORD PTR _TimeBuffer$7[ebp]
	push	edx
	call	DWORD PTR __imp__lstrlenA@4
	lea	eax, DWORD PTR _TimeBuffer$7[ebp+eax]
	push	eax
	call	?PrintTime@@YAXPADU_FILETIME@@@Z	; PrintTime
	add	esp, 12					; 0000000cH
$LN1@ShowModule:

; 124  : 				}
; 125  : 				CloseHandle(ModuleFile);

	mov	ecx, DWORD PTR _ModuleFile$6[ebp]
	push	ecx
	call	DWORD PTR __imp__CloseHandle@4
$LN2@ShowModule:

; 126  : 			}
; 127  : 			hprintf(LogFile, "%s, loaded at 0x%08x - %d bytes - %08x%s\r\n",
; 128  : 						ModName, ModuleHandle, FileSize,
; 129  : 						NTHeader->FileHeader.TimeDateStamp, TimeBuffer);

	lea	edx, DWORD PTR _TimeBuffer$7[ebp]
	push	edx
	mov	eax, DWORD PTR _NTHeader$3[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _FileSize$4[ebp]
	push	edx
	mov	eax, DWORD PTR _ModuleHandle$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ModName$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CL@CGOIOKCD@?$CFs?0?5loaded?5at?50x?$CF08x?5?9?5?$CFd?5bytes?5@
	mov	edx, DWORD PTR _LogFile$[ebp]
	push	edx
	call	?hprintf@@YAXPAXPADZZ			; hprintf
	add	esp, 28					; 0000001cH
$LN6@ShowModule:

; 130  : 		}
; 131  : 	}

	mov	DWORD PTR __$SEHRec$[ebp+20], -2	; fffffffeH
	jmp	SHORT $LN9@ShowModule
$LN10@ShowModule:
$LN15@ShowModule:

; 132  : 	// Handle any exceptions by continuing from this point.
; 133  : 	__except(EXCEPTION_EXECUTE_HANDLER)

	mov	eax, 1
$LN12@ShowModule:
$LN14@ShowModule:
	ret	0
$LN11@ShowModule:
	mov	esp, DWORD PTR __$SEHRec$[ebp]

; 134  : 	{
; 135  : 	}

	mov	DWORD PTR __$SEHRec$[ebp+20], -2	; fffffffeH
$LN9@ShowModule:

; 136  : }

	mov	ecx, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?ShowModuleInfo@@YAXPAXPAUHINSTANCE__@@@Z ENDP		; ShowModuleInfo
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\ehandler.cpp
_TEXT	SEGMENT
_Date$ = -8						; size = 2
_Time$ = -4						; size = 2
_output$ = 8						; size = 4
_TimeToPrint$ = 12					; size = 8
?PrintTime@@YAXPADU_FILETIME@@@Z PROC			; PrintTime

; 74   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 75   : 	WORD Date, Time;
; 76   : 	if (FileTimeToLocalFileTime(&TimeToPrint, &TimeToPrint) &&
; 77   : 				FileTimeToDosDateTime(&TimeToPrint, &Date, &Time))

	lea	eax, DWORD PTR _TimeToPrint$[ebp]
	push	eax
	lea	ecx, DWORD PTR _TimeToPrint$[ebp]
	push	ecx
	call	DWORD PTR __imp__FileTimeToLocalFileTime@8
	test	eax, eax
	je	$LN2@PrintTime
	lea	edx, DWORD PTR _Time$[ebp]
	push	edx
	lea	eax, DWORD PTR _Date$[ebp]
	push	eax
	lea	ecx, DWORD PTR _TimeToPrint$[ebp]
	push	ecx
	call	DWORD PTR __imp__FileTimeToDosDateTime@12
	test	eax, eax
	je	SHORT $LN2@PrintTime

; 78   : 	{
; 79   : 		// What a silly way to print out the file date/time. Oh well,
; 80   : 		// it works, and I'm not aware of a cleaner way to do it.
; 81   : 		wsprintf(output, "%d/%d/%d %02d:%02d:%02d",
; 82   : 					(Date / 32) & 15, Date & 31, (Date / 512) + 1980,
; 83   : 					(Time / 2048), (Time / 32) & 63, (Time & 31) * 2);

	movzx	edx, WORD PTR _Time$[ebp]
	and	edx, 31					; 0000001fH
	shl	edx, 1
	push	edx
	movzx	eax, WORD PTR _Time$[ebp]
	cdq
	and	edx, 31					; 0000001fH
	add	eax, edx
	sar	eax, 5
	and	eax, 63					; 0000003fH
	push	eax
	movzx	eax, WORD PTR _Time$[ebp]
	cdq
	and	edx, 2047				; 000007ffH
	add	eax, edx
	sar	eax, 11					; 0000000bH
	push	eax
	movzx	eax, WORD PTR _Date$[ebp]
	cdq
	and	edx, 511				; 000001ffH
	add	eax, edx
	sar	eax, 9
	add	eax, 1980				; 000007bcH
	push	eax
	movzx	eax, WORD PTR _Date$[ebp]
	and	eax, 31					; 0000001fH
	push	eax
	movzx	eax, WORD PTR _Date$[ebp]
	cdq
	and	edx, 31					; 0000001fH
	add	eax, edx
	sar	eax, 5
	and	eax, 15					; 0000000fH
	push	eax
	push	OFFSET ??_C@_0BI@HKCLIKLE@?$CFd?1?$CFd?1?$CFd?5?$CF02d?3?$CF02d?3?$CF02d?$AA@
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	call	DWORD PTR __imp__wsprintfA
	add	esp, 32					; 00000020H

; 84   : 	}
; 85   : 	else

	jmp	SHORT $LN3@PrintTime
$LN2@PrintTime:

; 86   : 		output[0] = 0;

	mov	edx, 1
	imul	edx, 0
	mov	eax, DWORD PTR _output$[ebp]
	mov	BYTE PTR [eax+edx], 0
$LN3@PrintTime:

; 87   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PrintTime@@YAXPADU_FILETIME@@@Z ENDP			; PrintTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\ehandler.cpp
_TEXT	SEGMENT
_NumBytes$ = -4012					; size = 4
_arglist$ = -4008					; size = 4
_buffer$ = -4004					; size = 4000
__$ArrayPad$ = -4					; size = 4
_LogFile$ = 8						; size = 4
_Format$ = 12						; size = 4
?hprintf@@YAXPAXPADZZ PROC				; hprintf

; 57   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 4012				; 00000facH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 58   : 	char buffer[4000];	// wvsprintf never prints more than one K. 
; 59   : 	// JPO increased - we may do more now.
; 60   : 
; 61   : 	va_list arglist;
; 62   : 	va_start( arglist, Format);

	lea	eax, DWORD PTR _Format$[ebp+4]
	mov	DWORD PTR _arglist$[ebp], eax

; 63   : 	wvsprintf(buffer, Format, arglist);

	mov	ecx, DWORD PTR _arglist$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Format$[ebp]
	push	edx
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	DWORD PTR __imp__wvsprintfA@12

; 64   : 	va_end( arglist);

	mov	DWORD PTR _arglist$[ebp], 0

; 65   : 
; 66   : 	DWORD NumBytes;
; 67   : 	WriteFile(LogFile, buffer, lstrlen(buffer), &NumBytes, 0);

	push	0
	lea	ecx, DWORD PTR _NumBytes$[ebp]
	push	ecx
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	DWORD PTR __imp__lstrlenA@4
	push	eax
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _LogFile$[ebp]
	push	ecx
	call	DWORD PTR __imp__WriteFile@20

; 68   : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?hprintf@@YAXPAXPADZZ ENDP				; hprintf
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\include\uicomms.h
;	COMDAT ?Online@UIComms@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Online@UIComms@@QAEHXZ PROC				; UIComms::Online, COMDAT
; _this$ = ecx

; 118  : 		BOOL Online()					{ return(Online_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+64]
	mov	esp, ebp
	pop	ebp
	ret	0
?Online@UIComms@@QAEHXZ ENDP				; UIComms::Online
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcsess.h
;	COMDAT ?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ PROC ; FalconSessionEntity::GetGame, COMDAT
; _this$ = ecx

; 154  : 	FalconGameEntity* GetGame (void)              { return (FalconGameEntity*)VuSessionEntity::Game(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ ; VuSessionEntity::Game
	mov	esp, ebp
	pop	ebp
	ret	0
?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ENDP ; FalconSessionEntity::GetGame
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ PROC ; VuBin<VuSessionEntity>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ENDP ; VuBin<VuSessionEntity>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ PROC		; VuBin<VuSessionEntity>::operator bool, COMDAT
; _this$ = ecx

; 40   : 	operator bool() const{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 		return e != NULL;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@operator
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv66[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv66[ebp]

; 42   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ ENDP		; VuBin<VuSessionEntity>::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\string.h
;	COMDAT ?strrchr@@YAPADPADH@Z
_TEXT	SEGMENT
__Str$ = 8						; size = 4
__Ch$ = 12						; size = 4
?strrchr@@YAPADPADH@Z PROC				; strrchr, COMDAT

; 222  : 	{ return (char*)strrchr((const char*)_Str, _Ch); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Ch$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Str$[ebp]
	push	ecx
	call	_strrchr
	add	esp, 8
	pop	ebp
	ret	0
?strrchr@@YAPADPADH@Z ENDP				; strrchr
_TEXT	ENDS
END
