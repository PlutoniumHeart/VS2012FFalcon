; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\FalcSnd\FalcVoice.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
PUBLIC	??0FalcVoice@@QAE@XZ				; FalcVoice::FalcVoice
PUBLIC	??1FalcVoice@@QAE@XZ				; FalcVoice::~FalcVoice
PUBLIC	?CreateVoice@FalcVoice@@QAEXXZ			; FalcVoice::CreateVoice
PUBLIC	?InitCompressionData@FalcVoice@@QAEXXZ		; FalcVoice::InitCompressionData
PUBLIC	?PlayVoices@FalcVoice@@QAEXXZ			; FalcVoice::PlayVoices
PUBLIC	?SilenceVoices@FalcVoice@@QAEXXZ		; FalcVoice::SilenceVoices
PUBLIC	?UnsilenceVoices@FalcVoice@@QAEXH@Z		; FalcVoice::UnsilenceVoices
PUBLIC	?FVResumeVoiceStreams@FalcVoice@@QAEXXZ		; FalcVoice::FVResumeVoiceStreams
PUBLIC	?SetMesgNum@FalcVoice@@QAEXHH@Z			; FalcVoice::SetMesgNum
PUBLIC	?InitializeVoiceBuffers@FalcVoice@@QAEXXZ	; FalcVoice::InitializeVoiceBuffers
PUBLIC	?InitializeVoiceStruct@FalcVoice@@QAEXH@Z	; FalcVoice::InitializeVoiceStruct
PUBLIC	?InitWaveFormatEXData@FalcVoice@@QAEXPAUtWAVEFORMATEX@@@Z ; FalcVoice::InitWaveFormatEXData
PUBLIC	?CleanupVoice@FalcVoice@@QAEXXZ			; FalcVoice::CleanupVoice
PUBLIC	?SetVoiceChannel@FalcVoice@@QAEXH@Z		; FalcVoice::SetVoiceChannel
PUBLIC	?PopVCAddQueue@FalcVoice@@QAEXXZ		; FalcVoice::PopVCAddQueue
PUBLIC	?GetVoiceBuffer@FalcVoice@@QAEPAUVOICE_STREAM_BUFFER@@H@Z ; FalcVoice::GetVoiceBuffer
PUBLIC	?AllocateCompInfo@FalcVoice@@QAEXXZ		; FalcVoice::AllocateCompInfo
PUBLIC	?InitCompressionFile@FalcVoice@@QAEXXZ		; FalcVoice::InitCompressionFile
PUBLIC	?CleanupCompressionBuffer@FalcVoice@@QAEXXZ	; FalcVoice::CleanupCompressionBuffer
PUBLIC	?BufferManager@FalcVoice@@QAEXH@Z		; FalcVoice::BufferManager
PUBLIC	?BufferEmpty@FalcVoice@@QAEXH@Z			; FalcVoice::BufferEmpty
PUBLIC	?ResetBufferStatus@FalcVoice@@QAEXXZ		; FalcVoice::ResetBufferStatus
PUBLIC	?DebugStatus@FalcVoice@@QAEXXZ			; FalcVoice::DebugStatus
PUBLIC	?SetVoiceVolumes@@YAXXZ				; SetVoiceVolumes
PUBLIC	?SetVoiceVolume@@YAXH@Z				; SetVoiceVolume
PUBLIC	?fillVoiceBuffer@@YAKPAXPADK@Z			; fillVoiceBuffer
PUBLIC	??_C@_0M@JHAGFICJ@VoiceBuffer?$AA@		; `string'
PUBLIC	__real@3f800000
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__imp__SetEvent@4:PROC
EXTRN	_F4CreateCriticalSection:PROC
EXTRN	_F4DestroyCriticalSection:PROC
EXTRN	_F4EnterCriticalSection:PROC
EXTRN	_F4LeaveCriticalSection:PROC
EXTRN	_F4IsSoundPlaying:PROC
EXTRN	_F4CreateStream:PROC
EXTRN	_F4StartCallbackStream:PROC
EXTRN	_F4SetStreamVolume:PROC
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	?VMAddBuffToQueue@VoiceManager@@QAEXHH@Z:PROC	; VoiceManager::VMAddBuffToQueue
EXTRN	?VM@@3PAVVoiceManager@@A:DWORD			; VM
EXTRN	?PlayerOptions@@3VPlayerOptionsClass@@A:BYTE	; PlayerOptions
EXTRN	?VMWakeEventHandle@@3PAXA:DWORD			; VMWakeEventHandle
EXTRN	?mono_16bit_8k@@3UtWAVEFORMATEX@@A:BYTE		; mono_16bit_8k
EXTRN	?killThread@@3HA:DWORD				; killThread
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
_allocator_arg DB 01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT ??_C@_0M@JHAGFICJ@VoiceBuffer?$AA@
CONST	SEGMENT
??_C@_0M@JHAGFICJ@VoiceBuffer?$AA@ DB 'VoiceBuffer', 00H ; `string'
CONST	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\falcvoice.cpp
_TEXT	SEGMENT
_filler$ = -28						; size = 4
_dsb$ = -24						; size = 4
_ptr$ = -20						; size = 4
_fillerSize$ = -16					; size = 4
_dataToCopy$ = -12					; size = 4
_streams$ = -8						; size = 4
_thisFV$ = -4						; size = 4
_me$ = 8						; size = 4
_soundBuffer$ = 12					; size = 4
_length$ = 16						; size = 4
?fillVoiceBuffer@@YAKPAXPADK@Z PROC			; fillVoiceBuffer

; 277  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 278  : 	int					fillerSize, dataToCopy, filler;
; 279  : 	VOICE_STREAM_BUFFER	*streams;
; 280  : 	unsigned char		*ptr, *dsb;
; 281  : 	FalcVoice			*thisFV;
; 282  : 		
; 283  : 	thisFV = ( FalcVoice * )me;

	mov	eax, DWORD PTR _me$[ebp]
	mov	DWORD PTR _thisFV$[ebp], eax

; 284  : 	if ( thisFV == NULL || killThread || thisFV->exitChannel)

	cmp	DWORD PTR _thisFV$[ebp], 0
	je	SHORT $LN16@fillVoiceB
	cmp	DWORD PTR ?killThread@@3HA, 0		; killThread
	jne	SHORT $LN16@fillVoiceB
	mov	ecx, DWORD PTR _thisFV$[ebp]
	cmp	DWORD PTR [ecx+84], 0
	je	SHORT $LN17@fillVoiceB
$LN16@fillVoiceB:

; 285  : 	{	
; 286  : 		memset( soundBuffer, SILENCE_KEY, length );

	mov	edx, DWORD PTR _length$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _soundBuffer$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 287  : 		return length;

	mov	eax, DWORD PTR _length$[ebp]
	jmp	$LN18@fillVoiceB
$LN17@fillVoiceB:

; 288  : 	}
; 289  : 	
; 290  : 	if ( thisFV->voiceBuffers[thisFV->voiceStruct->streamBuffer].status != BUFFER_FILLED )

	mov	ecx, DWORD PTR _thisFV$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+4]
	shl	eax, 5
	mov	ecx, DWORD PTR _thisFV$[ebp]
	cmp	DWORD PTR [ecx+eax+8], 2
	je	SHORT $LN15@fillVoiceB

; 291  : 	{
; 292  : 		//don't want to change buffer pointed to unless there is data in the other buffer but not
; 293  : 		//this one. (This way I can make sure I grab the right buffer first)
; 294  : 		if ( thisFV->voiceBuffers[1 - thisFV->voiceStruct->streamBuffer].status != BUFFER_FILLED ){

	mov	edx, DWORD PTR _thisFV$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, 1
	sub	ecx, DWORD PTR [eax+4]
	shl	ecx, 5
	mov	edx, DWORD PTR _thisFV$[ebp]
	cmp	DWORD PTR [edx+ecx+8], 2
	je	SHORT $LN14@fillVoiceB

; 295  : 			// sfr: i think this is causing the buffer to stop being consumed
; 296  : 			/*if(gSoundDriver && (thisFV->silenceWritten > 16000) )
; 297  : 			{
; 298  : 				gSoundDriver->PauseStream(thisFV->FalcVoiceHandle);
; 299  : 			}*/
; 300  : 			memset( soundBuffer, SILENCE_KEY, length );

	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _soundBuffer$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 301  : 			thisFV->silenceWritten += length;

	mov	edx, DWORD PTR _thisFV$[ebp]
	mov	eax, DWORD PTR [edx+72]
	add	eax, DWORD PTR _length$[ebp]
	mov	ecx, DWORD PTR _thisFV$[ebp]
	mov	DWORD PTR [ecx+72], eax

; 302  : 			return length;

	mov	eax, DWORD PTR _length$[ebp]
	jmp	$LN18@fillVoiceB

; 303  : 			//return 0;
; 304  : 		}
; 305  : 		else{

	jmp	SHORT $LN15@fillVoiceB
$LN14@fillVoiceB:

; 306  : 			thisFV->voiceStruct->streamBuffer = 1 - thisFV->voiceStruct->streamBuffer;

	mov	edx, DWORD PTR _thisFV$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, 1
	sub	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _thisFV$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [eax+4], ecx
$LN15@fillVoiceB:

; 307  : 		}
; 308  : 	}
; 309  : 
; 310  : 	streams = &(thisFV->voiceBuffers[thisFV->voiceStruct->streamBuffer]);

	mov	ecx, DWORD PTR _thisFV$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+4]
	shl	eax, 5
	mov	ecx, DWORD PTR _thisFV$[ebp]
	lea	edx, DWORD PTR [ecx+eax+4]
	mov	DWORD PTR _streams$[ebp], edx

; 311  : 	
; 312  : 	ptr = streams->waveBuffer + streams->waveBufferRead;

	mov	eax, DWORD PTR _streams$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _streams$[ebp]
	add	ecx, DWORD PTR [edx+24]
	mov	DWORD PTR _ptr$[ebp], ecx

; 313  : 	dsb = ( unsigned char * ) soundBuffer;

	mov	eax, DWORD PTR _soundBuffer$[ebp]
	mov	DWORD PTR _dsb$[ebp], eax

; 314  : 	
; 315  : 	F4EnterCriticalSection( streams->criticalSection );

	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	call	_F4EnterCriticalSection
	add	esp, 4

; 316  : 	
; 317  : 	if ( streams->dataInWaveBuffer > ( DWORD ) length )

	mov	eax, DWORD PTR _streams$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR _length$[ebp]
	jbe	SHORT $LN12@fillVoiceB

; 318  : 	{
; 319  : 		fillerSize = 0;

	mov	DWORD PTR _fillerSize$[ebp], 0

; 320  : 		dataToCopy = length;

	mov	edx, DWORD PTR _length$[ebp]
	mov	DWORD PTR _dataToCopy$[ebp], edx

; 321  : 	}
; 322  : 	else

	jmp	SHORT $LN11@fillVoiceB
$LN12@fillVoiceB:

; 323  : 	{
; 324  : 		fillerSize = length - streams->dataInWaveBuffer;

	mov	eax, DWORD PTR _streams$[ebp]
	mov	ecx, DWORD PTR _length$[ebp]
	sub	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _fillerSize$[ebp], ecx

; 325  : 		dataToCopy = streams->dataInWaveBuffer;

	mov	edx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _dataToCopy$[ebp], eax
$LN11@fillVoiceB:

; 326  : 	}
; 327  : 	
; 328  : 	
; 329  : 	if ( dataToCopy )

	cmp	DWORD PTR _dataToCopy$[ebp], 0
	je	SHORT $LN10@fillVoiceB

; 330  : 	{
; 331  : 		streams->dataInWaveBuffer -= dataToCopy;

	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	sub	edx, DWORD PTR _dataToCopy$[ebp]
	mov	eax, DWORD PTR _streams$[ebp]
	mov	DWORD PTR [eax+12], edx

; 332  : 		memcpy( dsb, ptr, dataToCopy );

	mov	ecx, DWORD PTR _dataToCopy$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _dsb$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 333  : 		ptr += dataToCopy;

	mov	ecx, DWORD PTR _ptr$[ebp]
	add	ecx, DWORD PTR _dataToCopy$[ebp]
	mov	DWORD PTR _ptr$[ebp], ecx

; 334  : 		dsb += dataToCopy;

	mov	edx, DWORD PTR _dsb$[ebp]
	add	edx, DWORD PTR _dataToCopy$[ebp]
	mov	DWORD PTR _dsb$[ebp], edx

; 335  : 		streams->waveBufferRead += dataToCopy;

	mov	eax, DWORD PTR _streams$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, DWORD PTR _dataToCopy$[ebp]
	mov	edx, DWORD PTR _streams$[ebp]
	mov	DWORD PTR [edx+24], ecx
$LN10@fillVoiceB:

; 336  : 	}
; 337  : 	
; 338  : 	if ( !streams->dataInWaveBuffer )

	mov	eax, DWORD PTR _streams$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN9@fillVoiceB

; 339  : 	{
; 340  : 		thisFV->BufferEmpty( thisFV->voiceStruct->streamBuffer );

	mov	ecx, DWORD PTR _thisFV$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _thisFV$[ebp]
	call	?BufferEmpty@FalcVoice@@QAEXH@Z		; FalcVoice::BufferEmpty

; 341  : 		thisFV->PopVCAddQueue();

	mov	ecx, DWORD PTR _thisFV$[ebp]
	call	?PopVCAddQueue@FalcVoice@@QAEXXZ	; FalcVoice::PopVCAddQueue

; 342  : 		thisFV->voiceStruct->streamBuffer = 1 - thisFV->voiceStruct->streamBuffer;

	mov	ecx, DWORD PTR _thisFV$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, 1
	sub	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _thisFV$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [edx+4], eax

; 343  : 		SetEvent( VMWakeEventHandle );

	mov	eax, DWORD PTR ?VMWakeEventHandle@@3PAXA ; VMWakeEventHandle
	push	eax
	call	DWORD PTR __imp__SetEvent@4
$LN9@fillVoiceB:

; 344  : 	}
; 345  : 	
; 346  : 	F4LeaveCriticalSection(streams->criticalSection);

	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	call	_F4LeaveCriticalSection
	add	esp, 4

; 347  : 	
; 348  : 	if ( fillerSize )

	cmp	DWORD PTR _fillerSize$[ebp], 0
	je	$LN8@fillVoiceB

; 349  : 	{
; 350  : 		if ( thisFV->voiceBuffers[thisFV->voiceStruct->streamBuffer].status == BUFFER_FILLED )

	mov	eax, DWORD PTR _thisFV$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 5
	mov	eax, DWORD PTR _thisFV$[ebp]
	cmp	DWORD PTR [eax+edx+8], 2
	jne	$LN8@fillVoiceB

; 351  : 		{
; 352  : 			streams = &(thisFV->voiceBuffers[thisFV->voiceStruct->streamBuffer]);

	mov	ecx, DWORD PTR _thisFV$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+4]
	shl	eax, 5
	mov	ecx, DWORD PTR _thisFV$[ebp]
	lea	edx, DWORD PTR [ecx+eax+4]
	mov	DWORD PTR _streams$[ebp], edx

; 353  : 			ptr = streams->waveBuffer + streams->waveBufferRead;

	mov	eax, DWORD PTR _streams$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _streams$[ebp]
	add	ecx, DWORD PTR [edx+24]
	mov	DWORD PTR _ptr$[ebp], ecx

; 354  : 
; 355  : 			F4EnterCriticalSection( streams->criticalSection );

	mov	eax, DWORD PTR _streams$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	call	_F4EnterCriticalSection
	add	esp, 4

; 356  : 
; 357  : 			if ( streams->dataInWaveBuffer > ( DWORD ) fillerSize )

	mov	edx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR [edx+12]
	cmp	eax, DWORD PTR _fillerSize$[ebp]
	jbe	SHORT $LN6@fillVoiceB

; 358  : 			{
; 359  : 				dataToCopy = fillerSize;

	mov	ecx, DWORD PTR _fillerSize$[ebp]
	mov	DWORD PTR _dataToCopy$[ebp], ecx

; 360  : 				fillerSize = 0;

	mov	DWORD PTR _fillerSize$[ebp], 0

; 361  : 			}
; 362  : 			else

	jmp	SHORT $LN5@fillVoiceB
$LN6@fillVoiceB:

; 363  : 			{
; 364  : 				fillerSize = fillerSize - streams->dataInWaveBuffer;

	mov	edx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR _fillerSize$[ebp]
	sub	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _fillerSize$[ebp], eax

; 365  : 				dataToCopy = streams->dataInWaveBuffer;

	mov	ecx, DWORD PTR _streams$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _dataToCopy$[ebp], edx
$LN5@fillVoiceB:

; 366  : 			}
; 367  : 			
; 368  : 			if ( dataToCopy )

	cmp	DWORD PTR _dataToCopy$[ebp], 0
	je	SHORT $LN4@fillVoiceB

; 369  : 			{
; 370  : 				streams->dataInWaveBuffer -= dataToCopy;

	mov	eax, DWORD PTR _streams$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sub	ecx, DWORD PTR _dataToCopy$[ebp]
	mov	edx, DWORD PTR _streams$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 371  : 				memcpy( dsb, ptr, dataToCopy );

	mov	eax, DWORD PTR _dataToCopy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dsb$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 372  : 				ptr += dataToCopy;

	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, DWORD PTR _dataToCopy$[ebp]
	mov	DWORD PTR _ptr$[ebp], eax

; 373  : 				dsb += dataToCopy;

	mov	ecx, DWORD PTR _dsb$[ebp]
	add	ecx, DWORD PTR _dataToCopy$[ebp]
	mov	DWORD PTR _dsb$[ebp], ecx

; 374  : 				streams->waveBufferRead += dataToCopy;

	mov	edx, DWORD PTR _streams$[ebp]
	mov	eax, DWORD PTR [edx+24]
	add	eax, DWORD PTR _dataToCopy$[ebp]
	mov	ecx, DWORD PTR _streams$[ebp]
	mov	DWORD PTR [ecx+24], eax
$LN4@fillVoiceB:

; 375  : 			}
; 376  : 			
; 377  : 			if ( !streams->dataInWaveBuffer )

	mov	edx, DWORD PTR _streams$[ebp]
	cmp	DWORD PTR [edx+12], 0
	jne	SHORT $LN3@fillVoiceB

; 378  : 			{
; 379  : 				thisFV->BufferEmpty( thisFV->voiceStruct->streamBuffer );

	mov	eax, DWORD PTR _thisFV$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _thisFV$[ebp]
	call	?BufferEmpty@FalcVoice@@QAEXH@Z		; FalcVoice::BufferEmpty

; 380  : 				thisFV->PopVCAddQueue();

	mov	ecx, DWORD PTR _thisFV$[ebp]
	call	?PopVCAddQueue@FalcVoice@@QAEXXZ	; FalcVoice::PopVCAddQueue

; 381  : 				thisFV->voiceStruct->streamBuffer = 1 - thisFV->voiceStruct->streamBuffer;

	mov	eax, DWORD PTR _thisFV$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, 1
	sub	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _thisFV$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], edx

; 382  : 				SetEvent( VMWakeEventHandle );

	mov	edx, DWORD PTR ?VMWakeEventHandle@@3PAXA ; VMWakeEventHandle
	push	edx
	call	DWORD PTR __imp__SetEvent@4
$LN3@fillVoiceB:

; 383  : 			}
; 384  : 			F4LeaveCriticalSection(streams->criticalSection);

	mov	eax, DWORD PTR _streams$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	call	_F4LeaveCriticalSection
	add	esp, 4
$LN8@fillVoiceB:

; 385  : 		}
; 386  : 	}
; 387  : 			
; 388  : 					
; 389  : 	if ( fillerSize )

	cmp	DWORD PTR _fillerSize$[ebp], 0
	je	SHORT $LN2@fillVoiceB

; 390  : 	{
; 391  : 		filler = SILENCE_KEY; 

	mov	DWORD PTR _filler$[ebp], 0

; 392  : 		
; 393  : 		if ( thisFV->voiceStruct->waveFormat.wBitsPerSample != 8 )

	mov	edx, DWORD PTR _thisFV$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, WORD PTR [eax+22]
	cmp	ecx, 8
	je	SHORT $LN1@fillVoiceB

; 394  : 			filler = 0;

	mov	DWORD PTR _filler$[ebp], 0
$LN1@fillVoiceB:

; 395  : 		
; 396  : 		memset( dsb, filler, fillerSize );

	mov	edx, DWORD PTR _fillerSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _filler$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dsb$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 397  : 		thisFV->silenceWritten += fillerSize;

	mov	edx, DWORD PTR _thisFV$[ebp]
	mov	eax, DWORD PTR [edx+72]
	add	eax, DWORD PTR _fillerSize$[ebp]
	mov	ecx, DWORD PTR _thisFV$[ebp]
	mov	DWORD PTR [ecx+72], eax
$LN2@fillVoiceB:

; 398  : 	}
; 399  : 	
; 400  : 	return length;

	mov	eax, DWORD PTR _length$[ebp]
$LN18@fillVoiceB:

; 401  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?fillVoiceBuffer@@YAKPAXPADK@Z ENDP			; fillVoiceBuffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\falcvoice.cpp
_TEXT	SEGMENT
_channel$ = 8						; size = 4
?SetVoiceVolume@@YAXH@Z PROC				; SetVoiceVolume

; 98   : {

	push	ebp
	mov	ebp, esp

; 99   : 	if (VM && channel >= 0 && channel < NUM_VOICE_CHANNELS && !VM->falconVoices[channel].exitChannel )

	cmp	DWORD PTR ?VM@@3PAVVoiceManager@@A, 0	; VM
	je	SHORT $LN2@SetVoiceVo
	cmp	DWORD PTR _channel$[ebp], 0
	jl	SHORT $LN2@SetVoiceVo
	cmp	DWORD PTR _channel$[ebp], 2
	jge	SHORT $LN2@SetVoiceVo
	mov	eax, DWORD PTR _channel$[ebp]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR ?VM@@3PAVVoiceManager@@A	; VM
	mov	edx, DWORD PTR [ecx+52]
	cmp	DWORD PTR [edx+eax+84], 0
	jne	SHORT $LN2@SetVoiceVo

; 100  : 	{
; 101  : 		F4SetStreamVolume(	VM->falconVoices[channel].FalcVoiceHandle,
; 102  : 							PlayerOptions.GroupVol[COM1_SOUND_GROUP + channel] );

	mov	eax, DWORD PTR _channel$[ebp]
	mov	ecx, DWORD PTR ?PlayerOptions@@3VPlayerOptionsClass@@A[eax*4+132]
	push	ecx
	mov	edx, DWORD PTR _channel$[ebp]
	imul	edx, 88					; 00000058H
	mov	eax, DWORD PTR ?VM@@3PAVVoiceManager@@A	; VM
	mov	ecx, DWORD PTR [eax+52]
	mov	edx, DWORD PTR [ecx+edx+68]
	push	edx
	call	_F4SetStreamVolume
	add	esp, 8
$LN2@SetVoiceVo:

; 103  : 	}
; 104  : }

	pop	ebp
	ret	0
?SetVoiceVolume@@YAXH@Z ENDP				; SetVoiceVolume
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\falcvoice.cpp
_TEXT	SEGMENT
_i$1 = -4						; size = 4
?SetVoiceVolumes@@YAXXZ PROC				; SetVoiceVolumes

; 86   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 87   : 	if (VM)

	cmp	DWORD PTR ?VM@@3PAVVoiceManager@@A, 0	; VM
	je	SHORT $LN5@SetVoiceVo

; 88   : 	{
; 89   : 		for(int i=0; i < NUM_VOICE_CHANNELS; i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN3@SetVoiceVo
$LN2@SetVoiceVo:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN3@SetVoiceVo:
	cmp	DWORD PTR _i$1[ebp], 2
	jge	SHORT $LN5@SetVoiceVo

; 90   : 		{
; 91   : 			F4SetStreamVolume(	VM->falconVoices[i].FalcVoiceHandle,
; 92   : 								PlayerOptions.GroupVol[COM1_SOUND_GROUP + i] );

	mov	ecx, DWORD PTR _i$1[ebp]
	mov	edx, DWORD PTR ?PlayerOptions@@3VPlayerOptionsClass@@A[ecx*4+132]
	push	edx
	mov	eax, DWORD PTR _i$1[ebp]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR ?VM@@3PAVVoiceManager@@A	; VM
	mov	edx, DWORD PTR [ecx+52]
	mov	eax, DWORD PTR [edx+eax+68]
	push	eax
	call	_F4SetStreamVolume
	add	esp, 8

; 93   : 		}

	jmp	SHORT $LN2@SetVoiceVo
$LN5@SetVoiceVo:

; 94   : 	}
; 95   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SetVoiceVolumes@@YAXXZ ENDP				; SetVoiceVolumes
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\falcvoice.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$ = -4						; size = 4
?DebugStatus@FalcVoice@@QAEXXZ PROC			; FalcVoice::DebugStatus
; _this$ = ecx

; 230  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 231  : 	int i;
; 232  : 	
; 233  : 	for( i = 0; i < MAX_VOICE_BUFFERS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@DebugStatu
$LN2@DebugStatu:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@DebugStatu:
	cmp	DWORD PTR _i$[ebp], 2
	jge	SHORT $LN4@DebugStatu

; 234  : 	{
; 235  : 		//		fprintf( dbgSndFile, "Status:: buffer%d: %d\n", i, voiceBuffers[i].status );
; 236  : 	}

	jmp	SHORT $LN2@DebugStatu
$LN4@DebugStatu:

; 237  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DebugStatus@FalcVoice@@QAEXXZ ENDP			; FalcVoice::DebugStatus
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\falcvoice.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$ = -4						; size = 4
?ResetBufferStatus@FalcVoice@@QAEXXZ PROC		; FalcVoice::ResetBufferStatus
; _this$ = ecx

; 269  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 270  : 	int	i;
; 271  : 	
; 272  : 	for ( i = 0; i < MAX_VOICE_BUFFERS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@ResetBuffe
$LN2@ResetBuffe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@ResetBuffe:
	cmp	DWORD PTR _i$[ebp], 2
	jge	SHORT $LN4@ResetBuffe

; 273  : 		voiceBuffers[i].status = BUFFER_NOT_IN_QUEUE;

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+8], 0
	jmp	SHORT $LN2@ResetBuffe
$LN4@ResetBuffe:

; 274  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ResetBufferStatus@FalcVoice@@QAEXXZ ENDP		; FalcVoice::ResetBufferStatus
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\falcvoice.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_buffer$ = 8						; size = 4
?BufferEmpty@FalcVoice@@QAEXH@Z PROC			; FalcVoice::BufferEmpty
; _this$ = ecx

; 264  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 265  : 	voiceBuffers[buffer].status = BUFFER_NOT_IN_QUEUE;

	mov	eax, DWORD PTR _buffer$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+8], 0

; 266  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?BufferEmpty@FalcVoice@@QAEXH@Z ENDP			; FalcVoice::BufferEmpty
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\falcvoice.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_buffer$ = 8						; size = 4
?BufferManager@FalcVoice@@QAEXH@Z PROC			; FalcVoice::BufferManager
; _this$ = ecx

; 259  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 260  : 	voiceBuffers[buffer].status = BUFFER_FILLED;

	mov	eax, DWORD PTR _buffer$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+8], 2

; 261  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?BufferManager@FalcVoice@@QAEXH@Z ENDP			; FalcVoice::BufferManager
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\falcvoice.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?CleanupCompressionBuffer@FalcVoice@@QAEXXZ PROC	; FalcVoice::CleanupCompressionBuffer
; _this$ = ecx

; 254  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 255  :     delete  voiceCompInfo;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 256  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CleanupCompressionBuffer@FalcVoice@@QAEXXZ ENDP	; FalcVoice::CleanupCompressionBuffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\falcvoice.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?InitCompressionFile@FalcVoice@@QAEXXZ PROC		; FalcVoice::InitCompressionFile
; _this$ = ecx

; 246  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 247  :     voiceCompInfo->bytesDecoded = 0L;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	DWORD PTR [ecx], 0

; 248  :     voiceCompInfo->bytesRead = 0L;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+80]
	mov	DWORD PTR [eax+4], 0

; 249  :     voiceCompInfo->fileLength = 0L;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	mov	DWORD PTR [edx+8], 0

; 250  :     voiceCompInfo->compFileLength = 0L;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	DWORD PTR [ecx+12], 0

; 251  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?InitCompressionFile@FalcVoice@@QAEXXZ ENDP		; FalcVoice::InitCompressionFile
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\falcvoice.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?AllocateCompInfo@FalcVoice@@QAEXXZ PROC		; FalcVoice::AllocateCompInfo
; _this$ = ecx

; 241  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 242  : 	voiceCompInfo = new COMPRESSION_DATA;

	push	20					; 00000014H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [eax+80], ecx

; 243  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AllocateCompInfo@FalcVoice@@QAEXXZ ENDP		; FalcVoice::AllocateCompInfo
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\falcvoice.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bufferNum$ = 8						; size = 4
?GetVoiceBuffer@FalcVoice@@QAEPAUVOICE_STREAM_BUFFER@@H@Z PROC ; FalcVoice::GetVoiceBuffer
; _this$ = ecx

; 197  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 198  : 	return( &( voiceBuffers[bufferNum] ) );

	mov	eax, DWORD PTR _bufferNum$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [ecx+eax+4]

; 199  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetVoiceBuffer@FalcVoice@@QAEPAUVOICE_STREAM_BUFFER@@H@Z ENDP ; FalcVoice::GetVoiceBuffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\falcvoice.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?PopVCAddQueue@FalcVoice@@QAEXXZ PROC			; FalcVoice::PopVCAddQueue
; _this$ = ecx

; 209  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 210  : 	//add the buffer that streambuffer currently points to first
; 211  : 	F4EnterCriticalSection( VM->vmCriticalSection );

	mov	eax, DWORD PTR ?VM@@3PAVVoiceManager@@A	; VM
	mov	ecx, DWORD PTR [eax+148]
	push	ecx
	call	_F4EnterCriticalSection
	add	esp, 4

; 212  : 	
; 213  : 	if ( voiceBuffers[voiceStruct->streamBuffer].status == BUFFER_NOT_IN_QUEUE )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+ecx+8], 0
	jne	SHORT $LN2@PopVCAddQu

; 214  : 	{
; 215  : 		InitializeVoiceStruct( voiceStruct->streamBuffer );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InitializeVoiceStruct@FalcVoice@@QAEXH@Z ; FalcVoice::InitializeVoiceStruct

; 216  : 		VM->VMAddBuffToQueue( channel, voiceStruct->streamBuffer );//note: each falcvoice knows what channel it is

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	push	ecx
	mov	ecx, DWORD PTR ?VM@@3PAVVoiceManager@@A	; VM
	call	?VMAddBuffToQueue@VoiceManager@@QAEXHH@Z ; VoiceManager::VMAddBuffToQueue

; 217  : 		voiceBuffers[voiceStruct->streamBuffer].status = BUFFER_IN_QUEUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+8], 1
$LN2@PopVCAddQu:

; 218  : 	}
; 219  : 	
; 220  : 	if ( voiceBuffers[1 - voiceStruct->streamBuffer].status == BUFFER_NOT_IN_QUEUE )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, 1
	sub	edx, DWORD PTR [ecx+4]
	shl	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+edx+8], 0
	jne	SHORT $LN1@PopVCAddQu

; 221  : 	{
; 222  : 		InitializeVoiceStruct( 1 - voiceStruct->streamBuffer );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, 1
	sub	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InitializeVoiceStruct@FalcVoice@@QAEXH@Z ; FalcVoice::InitializeVoiceStruct

; 223  : 		VM->VMAddBuffToQueue( channel, 1 - voiceStruct->streamBuffer );//note: each falcvoice knows what channel it is

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, 1
	sub	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	push	edx
	mov	ecx, DWORD PTR ?VM@@3PAVVoiceManager@@A	; VM
	call	?VMAddBuffToQueue@VoiceManager@@QAEXHH@Z ; VoiceManager::VMAddBuffToQueue

; 224  : 		voiceBuffers[1 - voiceStruct->streamBuffer].status = BUFFER_IN_QUEUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, 1
	sub	edx, DWORD PTR [ecx+4]
	shl	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+8], 1
$LN1@PopVCAddQu:

; 225  : 	}
; 226  : 	F4LeaveCriticalSection( VM->vmCriticalSection );

	mov	ecx, DWORD PTR ?VM@@3PAVVoiceManager@@A	; VM
	mov	edx, DWORD PTR [ecx+148]
	push	edx
	call	_F4LeaveCriticalSection
	add	esp, 4

; 227  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PopVCAddQueue@FalcVoice@@QAEXXZ ENDP			; FalcVoice::PopVCAddQueue
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\falcvoice.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_channelNo$ = 8						; size = 4
?SetVoiceChannel@FalcVoice@@QAEXH@Z PROC		; FalcVoice::SetVoiceChannel
; _this$ = ecx

; 202  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 203  : 	channel = channelNo;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _channelNo$[ebp]
	mov	DWORD PTR [eax+76], ecx

; 204  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetVoiceChannel@FalcVoice@@QAEXH@Z ENDP		; FalcVoice::SetVoiceChannel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\falcvoice.cpp
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
_i$ = -8						; size = 4
_this$ = -4						; size = 4
?CleanupVoice@FalcVoice@@QAEXXZ PROC			; FalcVoice::CleanupVoice
; _this$ = ecx

; 177  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 178  : 	int i;
; 179  : 	
; 180  : 	exitChannel = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+84], 1

; 181  : 	
; 182  : 	CleanupCompressionBuffer();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CleanupCompressionBuffer@FalcVoice@@QAEXXZ ; FalcVoice::CleanupCompressionBuffer

; 183  : 	
; 184  : 	for (i=0; i < MAX_VOICE_BUFFERS; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@CleanupVoi
$LN2@CleanupVoi:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN3@CleanupVoi:
	cmp	DWORD PTR _i$[ebp], 2
	jge	SHORT $LN1@CleanupVoi

; 185  : 	{
; 186  : 		F4DestroyCriticalSection( voiceBuffers[i].criticalSection );

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+32]
	push	ecx
	call	_F4DestroyCriticalSection
	add	esp, 4

; 187  : 		voiceBuffers[i].criticalSection = NULL;

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+32], 0

; 188  : 		delete [] voiceBuffers[i].waveBuffer;

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+12]
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 189  : 	}

	jmp	SHORT $LN2@CleanupVoi
$LN1@CleanupVoi:

; 190  : 	
; 191  : 	delete voiceStruct;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 192  : 	
; 193  : 	voiceStruct = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], 0

; 194  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CleanupVoice@FalcVoice@@QAEXXZ ENDP			; FalcVoice::CleanupVoice
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\falcvoice.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_waveFormat$ = 8					; size = 4
?InitWaveFormatEXData@FalcVoice@@QAEXPAUtWAVEFORMATEX@@@Z PROC ; FalcVoice::InitWaveFormatEXData
; _this$ = ecx

; 166  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 167  : 	waveFormat->wFormatTag = 0x0001;

	mov	eax, 1
	mov	ecx, DWORD PTR _waveFormat$[ebp]
	mov	WORD PTR [ecx], ax

; 168  : 	waveFormat->nChannels = 0x0001;

	mov	edx, 1
	mov	eax, DWORD PTR _waveFormat$[ebp]
	mov	WORD PTR [eax+2], dx

; 169  : 	waveFormat->nSamplesPerSec = 0x00005622;

	mov	ecx, DWORD PTR _waveFormat$[ebp]
	mov	DWORD PTR [ecx+4], 22050		; 00005622H

; 170  : 	waveFormat->nAvgBytesPerSec = 0x00005622;

	mov	edx, DWORD PTR _waveFormat$[ebp]
	mov	DWORD PTR [edx+8], 22050		; 00005622H

; 171  : 	waveFormat->nBlockAlign = 0x0001;

	mov	eax, 1
	mov	ecx, DWORD PTR _waveFormat$[ebp]
	mov	WORD PTR [ecx+12], ax

; 172  : 	waveFormat->wBitsPerSample = 0x0008;

	mov	edx, 8
	mov	eax, DWORD PTR _waveFormat$[ebp]
	mov	WORD PTR [eax+14], dx

; 173  : 	waveFormat->cbSize = 0x0000;

	xor	ecx, ecx
	mov	edx, DWORD PTR _waveFormat$[ebp]
	mov	WORD PTR [edx+16], cx

; 174  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?InitWaveFormatEXData@FalcVoice@@QAEXPAUtWAVEFORMATEX@@@Z ENDP ; FalcVoice::InitWaveFormatEXData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\falcvoice.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bufferNum$ = 8						; size = 4
?InitializeVoiceStruct@FalcVoice@@QAEXH@Z PROC		; FalcVoice::InitializeVoiceStruct
; _this$ = ecx

; 158  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 159  : 	voiceBuffers[bufferNum].dataInWaveBuffer = 0;

	mov	eax, DWORD PTR _bufferNum$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+16], 0

; 160  : 	voiceBuffers[bufferNum].waveBufferLen = 0;

	mov	edx, DWORD PTR _bufferNum$[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+20], 0

; 161  : 	voiceBuffers[bufferNum].waveBufferWrite = 0;

	mov	ecx, DWORD PTR _bufferNum$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+24], 0

; 162  : 	voiceBuffers[bufferNum].waveBufferRead = 0;

	mov	eax, DWORD PTR _bufferNum$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+28], 0

; 163  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?InitializeVoiceStruct@FalcVoice@@QAEXH@Z ENDP		; FalcVoice::InitializeVoiceStruct
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\falcvoice.cpp
_TEXT	SEGMENT
$T1 = -12						; size = 4
_this$ = -8						; size = 4
_i$ = -4						; size = 4
?InitializeVoiceBuffers@FalcVoice@@QAEXXZ PROC		; FalcVoice::InitializeVoiceBuffers
; _this$ = ecx

; 128  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 	int	i;
; 130  : 	
; 131  : 	for ( i = 0; i < MAX_VOICE_BUFFERS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Initialize
$LN3@Initialize:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Initialize:
	cmp	DWORD PTR _i$[ebp], 2
	jge	SHORT $LN5@Initialize

; 132  : 	{
; 133  : 		/* Allocate the audion buffers */
; 134  : 		voiceBuffers[i].waveBuffer = new unsigned char[MAX_OUTDECODE_SIZE];

	push	80960					; 00013c40H
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR [edx+ecx+12], eax

; 135  : 		if ( voiceBuffers[i].waveBuffer == NULL )

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+ecx+12], 0
	jne	SHORT $LN1@Initialize

; 136  : 			return;

	jmp	SHORT $LN5@Initialize
$LN1@Initialize:

; 137  : 		
; 138  : 		/* Initialize Wave Format Header Information */
; 139  : 		InitializeVoiceStruct( i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InitializeVoiceStruct@FalcVoice@@QAEXH@Z ; FalcVoice::InitializeVoiceStruct

; 140  : 		
; 141  : 		
; 142  : 		voiceBuffers[i].mesgNum = 0;

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+4], 0

; 143  : 		
; 144  : 		
; 145  : 		voiceBuffers[i].criticalSection = F4CreateCriticalSection("VoiceBuffer");

	push	OFFSET ??_C@_0M@JHAGFICJ@VoiceBuffer?$AA@
	call	_F4CreateCriticalSection
	add	esp, 4
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+32], eax

; 146  : 		voiceBuffers[i].status = BUFFER_NOT_IN_QUEUE;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+8], 0

; 147  : 	}

	jmp	$LN3@Initialize
$LN5@Initialize:

; 148  : 	
; 149  : 	/* initalize audioBuffer flags */
; 150  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?InitializeVoiceBuffers@FalcVoice@@QAEXXZ ENDP		; FalcVoice::InitializeVoiceBuffers
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\falcvoice.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bufferNum$ = 8						; size = 4
_mesgNum$ = 12						; size = 4
?SetMesgNum@FalcVoice@@QAEXHH@Z PROC			; FalcVoice::SetMesgNum
; _this$ = ecx

; 153  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 154  : 	voiceBuffers[bufferNum].mesgNum = mesgNum;

	mov	eax, DWORD PTR _bufferNum$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _mesgNum$[ebp]
	mov	DWORD PTR [ecx+eax+4], edx

; 155  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetMesgNum@FalcVoice@@QAEXHH@Z ENDP			; FalcVoice::SetMesgNum
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\falcvoice.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?FVResumeVoiceStreams@FalcVoice@@QAEXXZ PROC		; FalcVoice::FVResumeVoiceStreams
; _this$ = ecx

; 119  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 	if ( !F4IsSoundPlaying( FalcVoiceHandle ) )

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	push	ecx
	call	_F4IsSoundPlaying
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN2@FVResumeVo

; 121  : 	{
; 122  : 		F4StartCallbackStream(FalcVoiceHandle,(void *)this,fillVoiceBuffer);

	push	OFFSET ?fillVoiceBuffer@@YAKPAXPADK@Z	; fillVoiceBuffer
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	push	ecx
	call	_F4StartCallbackStream
	add	esp, 12					; 0000000cH

; 123  : 		exitChannel = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+84], 0
$LN2@FVResumeVo:

; 124  : 	}
; 125  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FVResumeVoiceStreams@FalcVoice@@QAEXXZ ENDP		; FalcVoice::FVResumeVoiceStreams
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\falcvoice.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_SoundGroup$ = 8					; size = 4
?UnsilenceVoices@FalcVoice@@QAEXH@Z PROC		; FalcVoice::UnsilenceVoices
; _this$ = ecx

; 113  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 114  : 	F4SetStreamVolume(FalcVoiceHandle,PlayerOptions.GroupVol[SoundGroup]);

	mov	eax, DWORD PTR _SoundGroup$[ebp]
	mov	ecx, DWORD PTR ?PlayerOptions@@3VPlayerOptionsClass@@A[eax*4+120]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+68]
	push	eax
	call	_F4SetStreamVolume
	add	esp, 8

; 115  : 	exitChannel = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+84], 0

; 116  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?UnsilenceVoices@FalcVoice@@QAEXH@Z ENDP		; FalcVoice::UnsilenceVoices
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\falcvoice.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SilenceVoices@FalcVoice@@QAEXXZ PROC			; FalcVoice::SilenceVoices
; _this$ = ecx

; 107  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 108  : 	F4SetStreamVolume(FalcVoiceHandle,-10000);

	push	-10000					; ffffd8f0H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	push	ecx
	call	_F4SetStreamVolume
	add	esp, 8

; 109  : 	exitChannel = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+84], 1

; 110  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SilenceVoices@FalcVoice@@QAEXXZ ENDP			; FalcVoice::SilenceVoices
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\falcvoice.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?PlayVoices@FalcVoice@@QAEXXZ PROC			; FalcVoice::PlayVoices
; _this$ = ecx

; 75   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 76   : 	FalcVoiceHandle = F4CreateStream(&mono_16bit_8k,1.0f);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ?mono_16bit_8k@@3UtWAVEFORMATEX@@A ; mono_16bit_8k
	call	_F4CreateStream
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+68], eax

; 77   : 	
; 78   : 	F4SetStreamVolume(FalcVoiceHandle,0);

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+68]
	push	eax
	call	_F4SetStreamVolume
	add	esp, 8

; 79   : 
; 80   : 	F4StartCallbackStream(FalcVoiceHandle,(void *)this,fillVoiceBuffer);

	push	OFFSET ?fillVoiceBuffer@@YAKPAXPADK@Z	; fillVoiceBuffer
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+68]
	push	eax
	call	_F4StartCallbackStream
	add	esp, 12					; 0000000cH

; 81   : 
; 82   : 	exitChannel = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+84], 0

; 83   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PlayVoices@FalcVoice@@QAEXXZ ENDP			; FalcVoice::PlayVoices
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\falcvoice.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?InitCompressionData@FalcVoice@@QAEXXZ PROC		; FalcVoice::InitCompressionData
; _this$ = ecx

; 68   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 69   : 	AllocateCompInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AllocateCompInfo@FalcVoice@@QAEXXZ	; FalcVoice::AllocateCompInfo

; 70   : 	
; 71   : 	InitCompressionFile();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?InitCompressionFile@FalcVoice@@QAEXXZ	; FalcVoice::InitCompressionFile

; 72   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?InitCompressionData@FalcVoice@@QAEXXZ ENDP		; FalcVoice::InitCompressionData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\falcvoice.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?CreateVoice@FalcVoice@@QAEXXZ PROC			; FalcVoice::CreateVoice
; _this$ = ecx

; 48   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 49   : 	voiceStruct = new VOICE;

	push	32					; 00000020H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [eax], ecx

; 50   : 	if ( voiceStruct == NULL )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN1@CreateVoic

; 51   : 	{
; 52   : 		return;

	jmp	SHORT $LN2@CreateVoic
$LN1@CreateVoic:

; 53   : 	}
; 54   : 	
; 55   : 	silenceWritten = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+72], 0

; 56   : 
; 57   : 	/* Setup Audio Playback Buffers */
; 58   : 	InitializeVoiceBuffers();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?InitializeVoiceBuffers@FalcVoice@@QAEXXZ ; FalcVoice::InitializeVoiceBuffers

; 59   : 	
; 60   : 	/* Initialize Flag Sets */
; 61   : 	voiceStruct->streamBuffer = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [edx+4], 0

; 62   : 	voiceStruct->status = QUEUE_CONV;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], 1
$LN2@CreateVoic:

; 63   : 	//	voiceStruct->currConv = 0;
; 64   : 	//	voiceStruct->convQCount = 0;
; 65   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CreateVoice@FalcVoice@@QAEXXZ ENDP			; FalcVoice::CreateVoice
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\falcvoice.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1FalcVoice@@QAE@XZ PROC				; FalcVoice::~FalcVoice
; _this$ = ecx

; 43   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 44   : 	CleanupVoice();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CleanupVoice@FalcVoice@@QAEXXZ		; FalcVoice::CleanupVoice

; 45   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??1FalcVoice@@QAE@XZ ENDP				; FalcVoice::~FalcVoice
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\falcvoice.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0FalcVoice@@QAE@XZ PROC				; FalcVoice::FalcVoice
; _this$ = ecx

; 38   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 39   : 	exitChannel = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+84], 0

; 40   : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0FalcVoice@@QAE@XZ ENDP				; FalcVoice::FalcVoice
_TEXT	ENDS
END
