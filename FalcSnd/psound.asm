; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\FalcSnd\psound.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?StreamCSection@@3PAUF4CSECTIONHANDLE@@A	; StreamCSection
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?gSoundDriver@@3PAVCSoundMgr@@A			; gSoundDriver
PUBLIC	?sofp@@3PAU_iobuf@@A				; sofp
PUBLIC	?sofp_ref@@3HA					; sofp_ref
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
_BSS	SEGMENT
?StreamCSection@@3PAUF4CSECTIONHANDLE@@A DD 01H DUP (?)	; StreamCSection
_StreamThreadID DD 01H DUP (?)
_PSoundThreadID DD 01H DUP (?)
_BootVolume DD	01H DUP (?)
?gSoundDriver@@3PAVCSoundMgr@@A DD 01H DUP (?)		; gSoundDriver
?sofp@@3PAU_iobuf@@A DD 01H DUP (?)			; sofp
?sofp_ref@@3HA DD 01H DUP (?)				; sofp_ref
_BSS	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
PUBLIC	_log10f
PUBLIC	?log10@@YAMM@Z					; log10
PUBLIC	??0SoundList@@QAE@XZ				; SoundList::SoundList
PUBLIC	??0SoundList@@QAE@PAV0@PAUIDirectSound@@@Z	; SoundList::SoundList
PUBLIC	??1SoundList@@QAE@XZ				; SoundList::~SoundList
PUBLIC	??_GSoundList@@QAEPAXI@Z			; SoundList::`scalar deleting destructor'
PUBLIC	??0SoundStream@@QAE@XZ				; SoundStream::SoundStream
PUBLIC	??1SoundStream@@QAE@XZ				; SoundStream::~SoundStream
PUBLIC	??_GSoundStream@@QAEPAXI@Z			; SoundStream::`scalar deleting destructor'
PUBLIC	??0CSoundMgr@@QAE@XZ				; CSoundMgr::CSoundMgr
PUBLIC	??1CSoundMgr@@QAE@XZ				; CSoundMgr::~CSoundMgr
PUBLIC	?InstallDSound@CSoundMgr@@QAEHPAUHWND__@@KPAUtWAVEFORMATEX@@@Z ; CSoundMgr::InstallDSound
PUBLIC	?RemoveDSound@CSoundMgr@@QAEXXZ			; CSoundMgr::RemoveDSound
PUBLIC	?SetMasterVolume@CSoundMgr@@QAEJJ@Z		; CSoundMgr::SetMasterVolume
PUBLIC	?GetMasterVolume@CSoundMgr@@QAEJXZ		; CSoundMgr::GetMasterVolume
PUBLIC	?LoadWaveFile@CSoundMgr@@QAEJPADJPAUSfxDef@@@Z	; CSoundMgr::LoadWaveFile
PUBLIC	?LoadWaveFile@CSoundMgr@@QAEPAUIDirectSoundBuffer@@PADPAUSfxDef@@@Z ; CSoundMgr::LoadWaveFile
PUBLIC	?AddRawSample@CSoundMgr@@QAEJPAUtWAVEFORMATEX@@PADJJ@Z ; CSoundMgr::AddRawSample
PUBLIC	?RemoveSample@CSoundMgr@@QAEXJ@Z		; CSoundMgr::RemoveSample
PUBLIC	?RemoveDuplicateSample@CSoundMgr@@QAEXJ@Z	; CSoundMgr::RemoveDuplicateSample
PUBLIC	?RemoveAllSamples@CSoundMgr@@QAEXXZ		; CSoundMgr::RemoveAllSamples
PUBLIC	?PlaySample@CSoundMgr@@QAEHJJ@Z			; CSoundMgr::PlaySample
PUBLIC	?StopSample@CSoundMgr@@QAEHJ@Z			; CSoundMgr::StopSample
PUBLIC	?StopAllSamples@CSoundMgr@@QAEHXZ		; CSoundMgr::StopAllSamples
PUBLIC	?SetSamplePitch@CSoundMgr@@QAEHJM@Z		; CSoundMgr::SetSamplePitch
PUBLIC	?SetSampleVolume@CSoundMgr@@QAEHJJ@Z		; CSoundMgr::SetSampleVolume
PUBLIC	?SetSamplePan@CSoundMgr@@QAEHJJ@Z		; CSoundMgr::SetSamplePan
PUBLIC	?SetSamplePosition@CSoundMgr@@QAEHJMMMMMMMMMHH@Z ; CSoundMgr::SetSamplePosition
PUBLIC	?Disable3dSample@CSoundMgr@@QAEHJ@Z		; CSoundMgr::Disable3dSample
PUBLIC	?AssignSamples@CSoundMgr@@QAEXXZ		; CSoundMgr::AssignSamples
PUBLIC	?GetSampleVolume@CSoundMgr@@QAEHJ@Z		; CSoundMgr::GetSampleVolume
PUBLIC	?IsSamplePlaying@CSoundMgr@@QAEHJH@Z		; CSoundMgr::IsSamplePlaying
PUBLIC	?SampleStatus@CSoundMgr@@QAEKPAVSoundList@@@Z	; CSoundMgr::SampleStatus
PUBLIC	?CreateStream@CSoundMgr@@QAEJPAUtWAVEFORMATEX@@M@Z ; CSoundMgr::CreateStream
PUBLIC	?SetMessageCallback@CSoundMgr@@QAEXHP6AXPAVSoundStream@@H@Z@Z ; CSoundMgr::SetMessageCallback
PUBLIC	?RemoveStream@CSoundMgr@@QAEXJ@Z		; CSoundMgr::RemoveStream
PUBLIC	?RemoveAllStreams@CSoundMgr@@QAEXXZ		; CSoundMgr::RemoveAllStreams
PUBLIC	?SilenceStream@CSoundMgr@@QAEXPAVSoundStream@@KK@Z ; CSoundMgr::SilenceStream
PUBLIC	?StartFileStream@CSoundMgr@@QAEHJPADJJ@Z	; CSoundMgr::StartFileStream
PUBLIC	?StartMemoryStream@CSoundMgr@@QAEHJPADJ@Z	; CSoundMgr::StartMemoryStream
PUBLIC	?StartMemoryStream@CSoundMgr@@QAEHJPAURIFF_FILE@@J@Z ; CSoundMgr::StartMemoryStream
PUBLIC	?StartCallbackStream@CSoundMgr@@QAEHJPAXP6AK0PADK@Z@Z ; CSoundMgr::StartCallbackStream
PUBLIC	?SetStreamVolume@CSoundMgr@@QAEJJJ@Z		; CSoundMgr::SetStreamVolume
PUBLIC	?ResumeStream@CSoundMgr@@QAEXJ@Z		; CSoundMgr::ResumeStream
PUBLIC	?ResumeStreamFadeIn@CSoundMgr@@QAEXJ@Z		; CSoundMgr::ResumeStreamFadeIn
PUBLIC	?StopStream@CSoundMgr@@QAEXJ@Z			; CSoundMgr::StopStream
PUBLIC	?StopStreamWithFade@CSoundMgr@@QAEXJ@Z		; CSoundMgr::StopStreamWithFade
PUBLIC	?StopAllStreams@CSoundMgr@@QAEXXZ		; CSoundMgr::StopAllStreams
PUBLIC	?PauseStream@CSoundMgr@@QAEXJ@Z			; CSoundMgr::PauseStream
PUBLIC	?FadeOutStream@CSoundMgr@@QAEXJ@Z		; CSoundMgr::FadeOutStream
PUBLIC	?GetStreamPlayTime@CSoundMgr@@QAEJJ@Z		; CSoundMgr::GetStreamPlayTime
PUBLIC	?IsStreamPlaying@CSoundMgr@@QAEHJ@Z		; CSoundMgr::IsStreamPlaying
PUBLIC	?StreamStatus@CSoundMgr@@QAEKPAVSoundStream@@@Z	; CSoundMgr::StreamStatus
PUBLIC	?SetFadeIn@CSoundMgr@@QAEXJJ@Z			; CSoundMgr::SetFadeIn
PUBLIC	?SetFadeOut@CSoundMgr@@QAEXJJ@Z			; CSoundMgr::SetFadeOut
PUBLIC	?SetLoopCounter@CSoundMgr@@QAEXJJ@Z		; CSoundMgr::SetLoopCounter
PUBLIC	?SetLoopOffset@CSoundMgr@@QAEXJK@Z		; CSoundMgr::SetLoopOffset
PUBLIC	?StreamStop@CSoundMgr@@QAEXPAVSoundStream@@@Z	; CSoundMgr::StreamStop
PUBLIC	?StreamStopWithFade@CSoundMgr@@QAEXPAVSoundStream@@@Z ; CSoundMgr::StreamStopWithFade
PUBLIC	?StreamPause@CSoundMgr@@QAEXPAVSoundStream@@@Z	; CSoundMgr::StreamPause
PUBLIC	?StreamFadeOut@CSoundMgr@@QAEXPAVSoundStream@@@Z ; CSoundMgr::StreamFadeOut
PUBLIC	?StreamResume@CSoundMgr@@QAEXPAVSoundStream@@@Z	; CSoundMgr::StreamResume
PUBLIC	?StreamResumeFadeIn@CSoundMgr@@QAEXPAVSoundStream@@@Z ; CSoundMgr::StreamResumeFadeIn
PUBLIC	?ReadStream@CSoundMgr@@QAEKPAVSoundStream@@KK@Z	; CSoundMgr::ReadStream
PUBLIC	?RestartStream@CSoundMgr@@QAEXPAVSoundStream@@@Z ; CSoundMgr::RestartStream
PUBLIC	?SetCameraPostion@CSoundMgr@@QAEXPAUTpoint@@PAUTrotation@@0_N@Z ; CSoundMgr::SetCameraPostion
PUBLIC	?FindSample@CSoundMgr@@QAEPAVSoundList@@J@Z	; CSoundMgr::FindSample
PUBLIC	?FindStream@CSoundMgr@@QAEPAVSoundStream@@J@Z	; CSoundMgr::FindStream
PUBLIC	?SkipRiffHeader@CSoundMgr@@QAEJPAU_iobuf@@@Z	; CSoundMgr::SkipRiffHeader
PUBLIC	?SkipRiffHeader@CSoundMgr@@QAEJPAX@Z		; CSoundMgr::SkipRiffHeader
PUBLIC	?LoadRiffFormat@CSoundMgr@@QAEJPADPAUtWAVEFORMATEX@@PAJ2@Z ; CSoundMgr::LoadRiffFormat
PUBLIC	?LoadRiffFormat@CSoundMgr@@QAEJPAXPAUtWAVEFORMATEX@@PAJ2@Z ; CSoundMgr::LoadRiffFormat
PUBLIC	?FillRiffInfo@CSoundMgr@@QAEJPADPAURIFF_FILE@@@Z ; CSoundMgr::FillRiffInfo
PUBLIC	?LoadRiff@CSoundMgr@@QAEPAURIFF_FILE@@PAD@Z	; CSoundMgr::LoadRiff
PUBLIC	?DSoundCheck@CSoundMgr@@SAXJ@Z			; CSoundMgr::DSoundCheck
PUBLIC	?ConvertVolumeToDB@CSoundMgr@@AAEJJ@Z		; CSoundMgr::ConvertVolumeToDB
PUBLIC	?ConvertPanToDB@CSoundMgr@@AAEJJ@Z		; CSoundMgr::ConvertPanToDB
PUBLIC	?AddSampleToMgr@CSoundMgr@@AAEJJJJPAUIDirectSoundBuffer@@JPAUSfxDef@@@Z ; CSoundMgr::AddSampleToMgr
PUBLIC	?AddStreamToMgr@CSoundMgr@@AAEJJPAUtWAVEFORMATEX@@JPAUIDirectSoundBuffer@@@Z ; CSoundMgr::AddStreamToMgr
PUBLIC	?AddDuplicateSample@CSoundMgr@@AAEPAVSoundList@@PAV2@@Z ; CSoundMgr::AddDuplicateSample
PUBLIC	?StreamThread@CSoundMgr@@CGIPAX@Z		; CSoundMgr::StreamThread
PUBLIC	?ThreadHandler@CSoundMgr@@AAEXXZ		; CSoundMgr::ThreadHandler
PUBLIC	?BuildObjectList@CSoundMgr@@AAEHQAPAXPAHQAPAVSoundStream@@@Z ; CSoundMgr::BuildObjectList
PUBLIC	?ProcessStream@CSoundMgr@@AAEXPAVSoundStream@@@Z ; CSoundMgr::ProcessStream
PUBLIC	?NotifyThread@CSoundMgr@@AAEXXZ			; CSoundMgr::NotifyThread
PUBLIC	?SetNotification@CSoundMgr@@AAEXPAVSoundStream@@@Z ; CSoundMgr::SetNotification
PUBLIC	??_C@_08ICBBCCOP@SoundMgr?$AA@			; `string'
PUBLIC	??_C@_04EPCGJKAP@RIFF?$AA@			; `string'
PUBLIC	??_C@_04HFHJMNCD@WAVE?$AA@			; `string'
PUBLIC	??_C@_04CAJPEBPP@fmt?5?$AA@			; `string'
PUBLIC	??_C@_04KNPHNDOC@fact?$AA@			; `string'
PUBLIC	??_C@_04PJOLNDGD@data?$AA@			; `string'
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
PUBLIC	??_C@_0BJ@BJAEAMK@Unsupported?5file?5format?6?$AA@ ; `string'
PUBLIC	??_C@_0CI@LAKGHGCG@Wait?5failed?5in?5CSoundMgr?3?3TheadH@ ; `string'
PUBLIC	__real@00000000
PUBLIC	__real@3e9c0ebf
PUBLIC	__real@40000000
PUBLIC	__real@457a0000
PUBLIC	__real@bf800000
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_strcmp:PROC
EXTRN	_strncmp:PROC
EXTRN	__imp__CreateFileA@28:PROC
EXTRN	__imp__ReadFile@20:PROC
EXTRN	__imp__SetFilePointer@16:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__SetEvent@4:PROC
EXTRN	__imp__CreateEventA@16:PROC
EXTRN	__imp__Sleep@4:PROC
EXTRN	__imp__WaitForMultipleObjects@16:PROC
EXTRN	__beginthreadex:PROC
EXTRN	__endthreadex:PROC
EXTRN	_F4CreateCriticalSection:PROC
EXTRN	_F4DestroyCriticalSection:PROC
EXTRN	_F4EnterCriticalSection:PROC
EXTRN	_F4LeaveCriticalSection:PROC
EXTRN	_fclose:PROC
EXTRN	_fopen:PROC
EXTRN	_fread:PROC
EXTRN	_log10:PROC
EXTRN	_MonoPrint:PROC
EXTRN	?F4IsBadCodePtr@@YA_NPAX@Z:PROC			; F4IsBadCodePtr
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	_DirectSoundCreate@12:PROC
EXTRN	?StreamIMAADPCM@CSoundMgr@@QAEJPAVSoundStream@@PADJ@Z:PROC ; CSoundMgr::StreamIMAADPCM
EXTRN	?MemStreamIMAADPCM@CSoundMgr@@QAEJPAVSoundStream@@PADJ@Z:PROC ; CSoundMgr::MemStreamIMAADPCM
EXTRN	?MatrixMult@@YAXPBUTrotation@@PBUTpoint@@PAU2@@Z:PROC ; MatrixMult
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_IID_IDirectSound3DListener:BYTE
EXTRN	_IID_IDirectSoundNotify:BYTE
EXTRN	?g_bUse3dSound@@3_NA:BYTE			; g_bUse3dSound
EXTRN	?g_bOldSoundAlg@@3_NA:BYTE			; g_bOldSoundAlg
EXTRN	?g_bEnableDopplerSound@@3_NA:BYTE		; g_bEnableDopplerSound
EXTRN	?g_fSoundRolloffFactor@@3MA:DWORD		; g_fSoundRolloffFactor
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?oldrolloff@?1??SetCameraPostion@CSoundMgr@@QAEXPAUTpoint@@PAUTrotation@@0_N@Z@4MA
_BSS	SEGMENT
?oldrolloff@?1??SetCameraPostion@CSoundMgr@@QAEXPAUTpoint@@PAUTrotation@@0_N@Z@4MA DD 01H DUP (?) ; `CSoundMgr::SetCameraPostion'::`2'::oldrolloff
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@457a0000
CONST	SEGMENT
__real@457a0000 DD 0457a0000r			; 4000
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3e9c0ebf
CONST	SEGMENT
__real@3e9c0ebf DD 03e9c0ebfr			; 0.3048
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0CI@LAKGHGCG@Wait?5failed?5in?5CSoundMgr?3?3TheadH@
CONST	SEGMENT
??_C@_0CI@LAKGHGCG@Wait?5failed?5in?5CSoundMgr?3?3TheadH@ DB 'Wait failed'
	DB	' in CSoundMgr::TheadHandler', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ?dtime@?1??ThreadHandler@CSoundMgr@@AAEXXZ@4HA
_DATA	SEGMENT
?dtime@?1??ThreadHandler@CSoundMgr@@AAEXXZ@4HA DD 0aH	; `CSoundMgr::ThreadHandler'::`2'::dtime
_DATA	ENDS
;	COMDAT ?fwd@?5??SetCameraPostion@CSoundMgr@@QAEXPAUTpoint@@PAUTrotation@@0_N@Z@4U3@B
CONST	SEGMENT
?fwd@?5??SetCameraPostion@CSoundMgr@@QAEXPAUTpoint@@PAUTrotation@@0_N@Z@4U3@B DD 03f800000r ; 1 ; `CSoundMgr::SetCameraPostion'::`6'::fwd
	DD	000000000r			; 0
	DD	000000000r			; 0
CONST	ENDS
;	COMDAT ?upv@?5??SetCameraPostion@CSoundMgr@@QAEXPAUTpoint@@PAUTrotation@@0_N@Z@4U3@B
CONST	SEGMENT
?upv@?5??SetCameraPostion@CSoundMgr@@QAEXPAUTpoint@@PAUTrotation@@0_N@Z@4U3@B DD 000000000r ; 0 ; `CSoundMgr::SetCameraPostion'::`6'::upv
	DD	000000000r			; 0
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ??_C@_0BJ@BJAEAMK@Unsupported?5file?5format?6?$AA@
CONST	SEGMENT
??_C@_0BJ@BJAEAMK@Unsupported?5file?5format?6?$AA@ DB 'Unsupported file f'
	DB	'ormat', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PJOLNDGD@data?$AA@
CONST	SEGMENT
??_C@_04PJOLNDGD@data?$AA@ DB 'data', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04KNPHNDOC@fact?$AA@
CONST	SEGMENT
??_C@_04KNPHNDOC@fact?$AA@ DB 'fact', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04CAJPEBPP@fmt?5?$AA@
CONST	SEGMENT
??_C@_04CAJPEBPP@fmt?5?$AA@ DB 'fmt ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HFHJMNCD@WAVE?$AA@
CONST	SEGMENT
??_C@_04HFHJMNCD@WAVE?$AA@ DB 'WAVE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04EPCGJKAP@RIFF?$AA@
CONST	SEGMENT
??_C@_04EPCGJKAP@RIFF?$AA@ DB 'RIFF', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08ICBBCCOP@SoundMgr?$AA@
CONST	SEGMENT
??_C@_08ICBBCCOP@SoundMgr?$AA@ DB 'SoundMgr', 00H	; `string'
CONST	ENDS
xdata$x	SEGMENT
__unwindtable$?AddStreamToMgr@CSoundMgr@@AAEJJPAUtWAVEFORMATEX@@JPAUIDirectSoundBuffer@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddStreamToMgr@CSoundMgr@@AAEJJPAUtWAVEFORMATEX@@JPAUIDirectSoundBuffer@@@Z$0
__unwindtable$?AddSampleToMgr@CSoundMgr@@AAEJJJJPAUIDirectSoundBuffer@@JPAUSfxDef@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddSampleToMgr@CSoundMgr@@AAEJJJJPAUIDirectSoundBuffer@@JPAUSfxDef@@@Z$0
__unwindtable$?AddDuplicateSample@CSoundMgr@@AAEPAVSoundList@@PAV2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddDuplicateSample@CSoundMgr@@AAEPAVSoundList@@PAV2@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AddDuplicateSample@CSoundMgr@@AAEPAVSoundList@@PAV2@@Z$1
__ehfuncinfo$?AddDuplicateSample@CSoundMgr@@AAEPAVSoundList@@PAV2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?AddDuplicateSample@CSoundMgr@@AAEPAVSoundList@@PAV2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?AddStreamToMgr@CSoundMgr@@AAEJJPAUtWAVEFORMATEX@@JPAUIDirectSoundBuffer@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AddStreamToMgr@CSoundMgr@@AAEJJPAUtWAVEFORMATEX@@JPAUIDirectSoundBuffer@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?AddSampleToMgr@CSoundMgr@@AAEJJJJPAUIDirectSoundBuffer@@JPAUSfxDef@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AddSampleToMgr@CSoundMgr@@AAEJJJJPAUIDirectSoundBuffer@@JPAUSfxDef@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_PositionNotify$ = -32					; size = 16
_this$ = -16						; size = 4
_dist$ = -12						; size = 4
_hr$ = -8						; size = 4
_i$1 = -4						; size = 4
_Stream$ = 8						; size = 4
?SetNotification@CSoundMgr@@AAEXPAVSoundStream@@@Z PROC	; CSoundMgr::SetNotification
; _this$ = ecx

; 2109 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 2110 :     if (g_bOldSoundAlg) return;

	movzx	eax, BYTE PTR ?g_bOldSoundAlg@@3_NA	; g_bOldSoundAlg
	test	eax, eax
	je	SHORT $LN7@SetNotific
	jmp	$LN8@SetNotific
$LN7@SetNotific:

; 2111 :     ShiAssert(Stream->notif != NULL);
; 2112 :     ShiAssert(Stream->lpDsNotify != NULL);
; 2113 :     ShiAssert((Stream->Status & SND_USE_THREAD) != 0);
; 2114 :     
; 2115 :     if ((Stream->Status & SND_USE_THREAD) == 0 || 
; 2116 : 	Stream->notif == NULL || 
; 2117 : 	Stream->lpDsNotify == NULL) return;

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	and	edx, 1073741824				; 40000000H
	je	SHORT $LN5@SetNotific
	mov	eax, DWORD PTR _Stream$[ebp]
	cmp	DWORD PTR [eax+108], 0
	je	SHORT $LN5@SetNotific
	mov	ecx, DWORD PTR _Stream$[ebp]
	cmp	DWORD PTR [ecx+104], 0
	jne	SHORT $LN6@SetNotific
$LN5@SetNotific:
	jmp	SHORT $LN8@SetNotific
$LN6@SetNotific:

; 2118 : 
; 2119 :     // set up notifications so we can refill buffers - we'll use the same event for now
; 2120 :     DSBPOSITIONNOTIFY PositionNotify[2];
; 2121 :     DWORD dist = Stream->HalfSize;

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	DWORD PTR _dist$[ebp], eax

; 2122 :     for (int i = 0; i < 2; i++) {

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@SetNotific
$LN3@SetNotific:
	mov	ecx, DWORD PTR _i$1[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$1[ebp], ecx
$LN4@SetNotific:
	cmp	DWORD PTR _i$1[ebp], 2
	jge	SHORT $LN2@SetNotific

; 2123 : 	PositionNotify[i].hEventNotify = Stream->notif;

	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	mov	DWORD PTR _PositionNotify$[ebp+edx*8+4], ecx

; 2124 : 	PositionNotify[i].dwOffset = i * dist;

	mov	edx, DWORD PTR _i$1[ebp]
	imul	edx, DWORD PTR _dist$[ebp]
	mov	eax, DWORD PTR _i$1[ebp]
	mov	DWORD PTR _PositionNotify$[ebp+eax*8], edx

; 2125 :     }    

	jmp	SHORT $LN3@SetNotific
$LN2@SetNotific:

; 2126 :     HRESULT hr = Stream->lpDsNotify->SetNotificationPositions(2, PositionNotify);

	lea	ecx, DWORD PTR _PositionNotify$[ebp]
	push	ecx
	push	2
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+104]
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+12]
	call	ecx
	mov	DWORD PTR _hr$[ebp], eax

; 2127 :     if (hr != S_OK)

	cmp	DWORD PTR _hr$[ebp], 0
	je	SHORT $LN8@SetNotific

; 2128 : 	DSoundCheck(hr);

	mov	edx, DWORD PTR _hr$[ebp]
	push	edx
	call	?DSoundCheck@CSoundMgr@@SAXJ@Z		; CSoundMgr::DSoundCheck
	add	esp, 4
$LN8@SetNotific:

; 2129 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetNotification@CSoundMgr@@AAEXPAVSoundStream@@@Z ENDP	; CSoundMgr::SetNotification
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.h
;	COMDAT ?NotifyThread@CSoundMgr@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?NotifyThread@CSoundMgr@@AAEXXZ PROC			; CSoundMgr::NotifyThread, COMDAT
; _this$ = ecx

; 334  : 	void NotifyThread() { SetEvent(signalEvent); }; // poke the thread

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	call	DWORD PTR __imp__SetEvent@4
	mov	esp, ebp
	pop	ebp
	ret	0
?NotifyThread@CSoundMgr@@AAEXXZ ENDP			; CSoundMgr::NotifyThread
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_hr$ = -20						; size = 4
_Dummy$ = -16						; size = 4
_this$ = -12						; size = 4
_bytesread$ = -8					; size = 4
_Pos$ = -4						; size = 4
_Stream$ = 8						; size = 4
?ProcessStream@CSoundMgr@@AAEXPAVSoundStream@@@Z PROC	; CSoundMgr::ProcessStream
; _this$ = ecx

; 3068 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 3069 :     DWORD Pos,Dummy,bytesread;
; 3070 :     // either we are in the 1st or 2nd half of the buffer.
; 3071 :     HRESULT hr=Stream->DSoundBuffer->GetCurrentPosition(&Pos,&Dummy);

	lea	eax, DWORD PTR _Dummy$[ebp]
	push	eax
	lea	ecx, DWORD PTR _Pos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+16]
	call	ecx
	mov	DWORD PTR _hr$[ebp], eax

; 3072 :     if(!(Stream->Status & SND_STREAM_PART2)){

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+32]
	and	eax, 2
	jne	SHORT $LN30@ProcessStr

; 3073 : 		// if we have moved beyond the half way stage, we fill up
; 3074 : 		// the first half of the buffer.
; 3075 : 		// sfr: added =, was only >
; 3076 : 		if(Pos >= Stream->HalfSize){

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR _Pos$[ebp]
	cmp	edx, DWORD PTR [ecx+48]
	jb	SHORT $LN29@ProcessStr

; 3077 : 			bytesread=ReadStream(Stream,0,Stream->HalfSize);

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	push	ecx
	push	0
	mov	edx, DWORD PTR _Stream$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadStream@CSoundMgr@@QAEKPAVSoundStream@@KK@Z ; CSoundMgr::ReadStream
	mov	DWORD PTR _bytesread$[ebp], eax

; 3078 : 			if(!bytesread){

	cmp	DWORD PTR _bytesread$[ebp], 0
	jne	SHORT $LN28@ProcessStr

; 3079 : 				if(Stream->Status & SND_STREAM_FINAL)

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	and	ecx, 8
	je	SHORT $LN27@ProcessStr

; 3080 : 				{
; 3081 : 					Stream->Status &= ~SND_STREAM_FINAL;

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+32]
	and	eax, -9					; fffffff7H
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [ecx+32], eax

; 3082 : 					Stream->Status |= SND_STREAM_DONE;

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+32]
	or	eax, 4
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [ecx+32], eax

; 3083 : 				}
; 3084 : 				else{

	jmp	SHORT $LN28@ProcessStr
$LN27@ProcessStr:

; 3085 : 					Stream->Status |= SND_STREAM_FINAL;

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+32]
	or	eax, 8
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [ecx+32], eax
$LN28@ProcessStr:

; 3086 : 				}
; 3087 : 			}
; 3088 : 			Stream->Status ^= SND_STREAM_PART2;

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+32]
	xor	eax, 2
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [ecx+32], eax
$LN29@ProcessStr:

; 3089 : 		}
; 3090 :     }
; 3091 :     else{

	jmp	SHORT $LN25@ProcessStr
$LN30@ProcessStr:

; 3092 : 		//MonoPrint("ProcessStream in pt2, pos %d half %d\n", Pos, Stream->HalfSize);
; 3093 : 		if(Pos < Stream->HalfSize){

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR _Pos$[ebp]
	cmp	eax, DWORD PTR [edx+48]
	jae	SHORT $LN25@ProcessStr

; 3094 : 			bytesread=ReadStream(Stream,Stream->HalfSize,Stream->HalfSize);

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	push	edx
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	push	ecx
	mov	edx, DWORD PTR _Stream$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadStream@CSoundMgr@@QAEKPAVSoundStream@@KK@Z ; CSoundMgr::ReadStream
	mov	DWORD PTR _bytesread$[ebp], eax

; 3095 : 			if(!bytesread){

	cmp	DWORD PTR _bytesread$[ebp], 0
	jne	SHORT $LN23@ProcessStr

; 3096 : 				if(Stream->Status & SND_STREAM_FINAL){

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	and	ecx, 8
	je	SHORT $LN22@ProcessStr

; 3097 : 					Stream->Status &= ~SND_STREAM_FINAL;

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+32]
	and	eax, -9					; fffffff7H
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [ecx+32], eax

; 3098 : 					Stream->Status |= SND_STREAM_DONE;

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+32]
	or	eax, 4
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [ecx+32], eax

; 3099 : 				}
; 3100 : 				else{

	jmp	SHORT $LN23@ProcessStr
$LN22@ProcessStr:

; 3101 : 					Stream->Status |= SND_STREAM_FINAL;

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+32]
	or	eax, 8
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [ecx+32], eax
$LN23@ProcessStr:

; 3102 : 				}
; 3103 : 			}
; 3104 : 			Stream->Status ^= SND_STREAM_PART2;

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+32]
	xor	eax, 2
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [ecx+32], eax
$LN25@ProcessStr:

; 3105 : 		}
; 3106 :     }
; 3107 :     
; 3108 : 	if( Stream->LastPos <= Pos ){

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+64]
	cmp	eax, DWORD PTR _Pos$[ebp]
	ja	SHORT $LN20@ProcessStr

; 3109 : 		Stream->BytesProcessed += ( Pos - Stream->LastPos );

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR _Pos$[ebp]
	sub	edx, DWORD PTR [ecx+64]
	mov	eax, DWORD PTR _Stream$[ebp]
	add	edx, DWORD PTR [eax+60]
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [ecx+60], edx

; 3110 : 	}
; 3111 : 	else{

	jmp	SHORT $LN19@ProcessStr
$LN20@ProcessStr:

; 3112 : 		Stream->BytesProcessed += ( Pos + ( Stream->Size - Stream->LastPos ) );

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [edx+44]
	sub	ecx, DWORD PTR [eax+64]
	add	ecx, DWORD PTR _Pos$[ebp]
	mov	edx, DWORD PTR _Stream$[ebp]
	add	ecx, DWORD PTR [edx+60]
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [eax+60], ecx
$LN19@ProcessStr:

; 3113 : 	}
; 3114 :     Stream->LastPos = Pos;

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR _Pos$[ebp]
	mov	DWORD PTR [ecx+64], edx

; 3115 :     
; 3116 :     
; 3117 :     if(Stream->Status & SND_STREAM_PAN_LT)

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	and	ecx, 2097152				; 00200000H
	je	SHORT $LN18@ProcessStr

; 3118 :     {
; 3119 : 	Stream->Direction-=FADE_OUT_STEP;

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+24]
	sub	eax, 15					; 0000000fH
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 3120 : 	if(Stream->Direction <= -10000)

	mov	edx, DWORD PTR _Stream$[ebp]
	cmp	DWORD PTR [edx+24], -10000		; ffffd8f0H
	jg	SHORT $LN17@ProcessStr

; 3121 : 	{
; 3122 : 	    Stream->Direction=-10000;

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [eax+24], -10000		; ffffd8f0H

; 3123 : 	    Stream->Status ^= SND_STREAM_PAN_LT;

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	xor	edx, 2097152				; 00200000H
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [eax+32], edx

; 3124 : 	    if(Stream->Status & SND_STREAM_PAN_CIR)

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	and	edx, 4194304				; 00400000H
	je	SHORT $LN17@ProcessStr

; 3125 : 		Stream->Status |= SND_STREAM_PAN_RT;

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	or	ecx, 1048576				; 00100000H
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [edx+32], ecx
$LN17@ProcessStr:

; 3126 : 	}
; 3127 : 	Stream->DSoundBuffer->SetPan(Stream->Direction);

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+64]
	call	ecx
	jmp	SHORT $LN15@ProcessStr
$LN18@ProcessStr:

; 3128 :     }
; 3129 :     else if(Stream->Status & SND_STREAM_PAN_RT)

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+32]
	and	eax, 1048576				; 00100000H
	je	SHORT $LN15@ProcessStr

; 3130 :     {
; 3131 : 	Stream->Direction+=FADE_OUT_STEP;

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	add	edx, 15					; 0000000fH
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [eax+24], edx

; 3132 : 	if(Stream->Direction >= 10000)

	mov	ecx, DWORD PTR _Stream$[ebp]
	cmp	DWORD PTR [ecx+24], 10000		; 00002710H
	jl	SHORT $LN13@ProcessStr

; 3133 : 	{
; 3134 : 	    Stream->Direction=10000;

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [edx+24], 10000		; 00002710H

; 3135 : 	    Stream->Status ^= SND_STREAM_PAN_RT;

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	xor	ecx, 1048576				; 00100000H
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [edx+32], ecx

; 3136 : 	    if(Stream->Status & SND_STREAM_PAN_CIR)

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	and	ecx, 4194304				; 00400000H
	je	SHORT $LN13@ProcessStr

; 3137 : 		Stream->Status |= SND_STREAM_PAN_LT;

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+32]
	or	eax, 2097152				; 00200000H
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [ecx+32], eax
$LN13@ProcessStr:

; 3138 : 	}
; 3139 : 	Stream->DSoundBuffer->SetPan(Stream->Direction);

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+64]
	call	eax
$LN15@ProcessStr:

; 3140 :     }
; 3141 :     
; 3142 :     if(Stream->Status & SND_STREAM_FADE_IN)

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	and	edx, 131072				; 00020000H
	je	$LN11@ProcessStr

; 3143 :     {
; 3144 : 	if(Stream->CurFade < SND_MIN_VOLUME)

	mov	eax, DWORD PTR _Stream$[ebp]
	cmp	DWORD PTR [eax+8], -3000		; fffff448H
	jge	SHORT $LN10@ProcessStr

; 3145 : 	    Stream->CurFade=SND_MIN_VOLUME;

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [ecx+8], -3000		; fffff448H

; 3146 : 	else

	jmp	SHORT $LN9@ProcessStr
$LN10@ProcessStr:

; 3147 : 	    Stream->CurFade += FADE_IN_STEP;

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, 25					; 00000019H
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [ecx+8], eax
$LN9@ProcessStr:

; 3148 : 	if(Stream->CurFade >= Stream->Volume)

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	cmp	ecx, DWORD PTR [eax+4]
	jl	SHORT $LN8@ProcessStr

; 3149 : 	{
; 3150 : 	    Stream->CurFade=Stream->Volume;

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 3151 : 	    Stream->Status ^= SND_STREAM_FADE_IN;

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+32]
	xor	eax, 131072				; 00020000H
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [ecx+32], eax

; 3152 : 	    if(Stream->StreamMessage)

	mov	edx, DWORD PTR _Stream$[ebp]
	cmp	DWORD PTR [edx+92], 0
	je	SHORT $LN8@ProcessStr

; 3153 : 		(*Stream->StreamMessage)(Stream,SND_MSG_FADE_IN_DONE);

	push	2
	mov	eax, DWORD PTR _Stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	call	edx
	add	esp, 8
$LN8@ProcessStr:

; 3154 : 	}
; 3155 : 	Stream->DSoundBuffer->SetVolume(Stream->CurFade);

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+60]
	call	ecx
	jmp	$LN31@ProcessStr
$LN11@ProcessStr:

; 3156 :     }
; 3157 :     else if(Stream->Status & SND_STREAM_FADE_OUT)

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+32]
	and	eax, 65536				; 00010000H
	je	$LN31@ProcessStr

; 3158 :     {
; 3159 : 	if(Stream->CurFade > SND_MIN_VOLUME)

	mov	ecx, DWORD PTR _Stream$[ebp]
	cmp	DWORD PTR [ecx+8], -3000		; fffff448H
	jle	SHORT $LN4@ProcessStr

; 3160 : 	    Stream->CurFade -= FADE_OUT_STEP;

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, 15					; 0000000fH
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 3161 : 	else

	jmp	SHORT $LN3@ProcessStr
$LN4@ProcessStr:

; 3162 : 	    Stream->CurFade=DSBVOLUME_MIN;

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [edx+8], -10000		; ffffd8f0H
$LN3@ProcessStr:

; 3163 : 	if(Stream->CurFade <= Stream->FadeOut)

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+16]
	jg	SHORT $LN2@ProcessStr

; 3164 : 	{
; 3165 : 	    Stream->CurFade=Stream->FadeOut;

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+8], edx

; 3166 : 	    Stream->Status ^= SND_STREAM_FADE_OUT;

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	xor	ecx, 65536				; 00010000H
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [edx+32], ecx

; 3167 : 	    if(Stream->StreamMessage)

	mov	eax, DWORD PTR _Stream$[ebp]
	cmp	DWORD PTR [eax+92], 0
	je	SHORT $LN2@ProcessStr

; 3168 : 		(*Stream->StreamMessage)(Stream,SND_MSG_FADE_OUT_DONE);

	push	3
	mov	ecx, DWORD PTR _Stream$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+92]
	call	eax
	add	esp, 8
$LN2@ProcessStr:

; 3169 : 	}
; 3170 : 	Stream->DSoundBuffer->SetVolume(Stream->CurFade);

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+60]
	call	edx
$LN31@ProcessStr:

; 3171 :     }
; 3172 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ProcessStream@CSoundMgr@@AAEXPAVSoundStream@@@Z ENDP	; CSoundMgr::ProcessStream
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
tv93 = -16						; size = 4
_this$ = -12						; size = 4
_Stream$ = -8						; size = 4
_count$ = -4						; size = 4
_hArray$ = 8						; size = 4
_nHandles$ = 12						; size = 4
_slist$ = 16						; size = 4
?BuildObjectList@CSoundMgr@@AAEHQAPAXPAHQAPAVSoundStream@@@Z PROC ; CSoundMgr::BuildObjectList
; _this$ = ecx

; 2955 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 2956 :     ShiAssert(signalEvent != NULL);
; 2957 :     SoundStream *Stream;
; 2958 :     int count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 2959 :     slist[count] = NULL;

	mov	eax, DWORD PTR _count$[ebp]
	mov	ecx, DWORD PTR _slist$[ebp]
	mov	DWORD PTR [ecx+eax*4], 0

; 2960 :     hArray[count++] = signalEvent;

	mov	edx, DWORD PTR _count$[ebp]
	mov	eax, DWORD PTR _hArray$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+40]
	mov	DWORD PTR [eax+edx*4], ecx
	mov	edx, DWORD PTR _count$[ebp]
	add	edx, 1
	mov	DWORD PTR _count$[ebp], edx

; 2961 :     *nHandles = 1; // set here in case we have to exit in a rush

	mov	eax, DWORD PTR _nHandles$[ebp]
	mov	DWORD PTR [eax], 1

; 2962 :     for (Stream=StreamList; Stream != NULL; Stream=Stream->Next) {

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR _Stream$[ebp], edx
	jmp	SHORT $LN8@BuildObjec
$LN7@BuildObjec:
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	mov	DWORD PTR _Stream$[ebp], ecx
$LN8@BuildObjec:
	cmp	DWORD PTR _Stream$[ebp], 0
	je	SHORT $LN6@BuildObjec

; 2963 : 		if((Stream->Status & SND_USE_THREAD) == 0){

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+32]
	and	eax, 1073741824				; 40000000H
	jne	SHORT $LN5@BuildObjec

; 2964 : 			// not played on a thread
; 2965 : 			continue;

	jmp	SHORT $LN7@BuildObjec
$LN5@BuildObjec:

; 2966 : 		}
; 2967 : 		if(Stream->Status & SND_STREAM_DONE){

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	and	edx, 4
	je	SHORT $LN4@BuildObjec

; 2968 : 			// we just don't care
; 2969 : 			continue;

	jmp	SHORT $LN7@BuildObjec
$LN4@BuildObjec:

; 2970 : 		}
; 2971 : 		// any of the following we have to do more carefully.
; 2972 : 		if(Stream->Status & (SND_STREAM_PAN_LT|SND_STREAM_PAN_RT|SND_STREAM_FADE_IN|SND_STREAM_FADE_OUT)){

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	and	ecx, 3342336				; 00330000H
	je	SHORT $LN3@BuildObjec

; 2973 : 			return FALSE;

	xor	eax, eax
	jmp	SHORT $LN9@BuildObjec
$LN3@BuildObjec:

; 2974 : 		}
; 2975 : 		if (Stream->notif == NULL){

	mov	edx, DWORD PTR _Stream$[ebp]
	cmp	DWORD PTR [edx+108], 0
	jne	SHORT $LN2@BuildObjec

; 2976 : 			return FALSE; // how did this slip through??

	xor	eax, eax
	jmp	SHORT $LN9@BuildObjec
$LN2@BuildObjec:

; 2977 : 		}
; 2978 : 		hArray[count] = Stream->notif;

	mov	eax, DWORD PTR _count$[ebp]
	mov	ecx, DWORD PTR _hArray$[ebp]
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [edx+108]
	mov	DWORD PTR [ecx+eax*4], edx

; 2979 : 		slist[count] = Stream;

	mov	eax, DWORD PTR _count$[ebp]
	mov	ecx, DWORD PTR _slist$[ebp]
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 2980 : 		++count;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax

; 2981 : 		if (count >= MAXIMUM_WAIT_OBJECTS){

	cmp	DWORD PTR _count$[ebp], 64		; 00000040H
	jl	SHORT $LN1@BuildObjec

; 2982 : 			// too much going on
; 2983 : 			return FALSE;

	xor	eax, eax
	jmp	SHORT $LN9@BuildObjec
$LN1@BuildObjec:

; 2984 : 		}
; 2985 :     }

	jmp	SHORT $LN7@BuildObjec
$LN6@BuildObjec:

; 2986 :     *nHandles = count;

	mov	ecx, DWORD PTR _nHandles$[ebp]
	mov	edx, DWORD PTR _count$[ebp]
	mov	DWORD PTR [ecx], edx

; 2987 : 	return g_bOldSoundAlg ? FALSE : TRUE;

	movzx	eax, BYTE PTR ?g_bOldSoundAlg@@3_NA	; g_bOldSoundAlg
	test	eax, eax
	je	SHORT $LN11@BuildObjec
	mov	DWORD PTR tv93[ebp], 0
	jmp	SHORT $LN12@BuildObjec
$LN11@BuildObjec:
	mov	DWORD PTR tv93[ebp], 1
$LN12@BuildObjec:
	mov	eax, DWORD PTR tv93[ebp]
$LN9@BuildObjec:

; 2988 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?BuildObjectList@CSoundMgr@@AAEHQAPAXPAHQAPAVSoundStream@@@Z ENDP ; CSoundMgr::BuildObjectList
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_sstreams$ = -544					; size = 256
_hArray$ = -288						; size = 256
_nHandles$ = -32					; size = 4
_timer$ = -28						; size = 4
tv80 = -24						; size = 4
_result$1 = -20						; size = 4
_sp$2 = -16						; size = 4
_this$ = -12						; size = 4
_Stream$ = -8						; size = 4
_scanall$ = -1						; size = 1
?ThreadHandler@CSoundMgr@@AAEXXZ PROC			; CSoundMgr::ThreadHandler
; _this$ = ecx

; 2992 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 544				; 00000220H
	mov	DWORD PTR _this$[ebp], ecx

; 2993 :     SoundStream *Stream;
; 2994 :     static int dtime = 10;
; 2995 :     DWORD timer;
; 2996 :     HANDLE hArray[MAXIMUM_WAIT_OBJECTS];
; 2997 :     SoundStream *sstreams[MAXIMUM_WAIT_OBJECTS];
; 2998 :     int nHandles;
; 2999 :     bool scanall = false;

	mov	BYTE PTR _scanall$[ebp], 0
$LN25@ThreadHand:

; 3000 : 
; 3001 : 	// JPO basically there are 3 things we need to do in this loop.
; 3002 :     // 1. Check for buffers getting empty, and refill them
; 3003 :     // 2. Check for panning effects
; 3004 :     // 3. Check for fade effects.
; 3005 :     do{
; 3006 : 		scanall = true;

	mov	BYTE PTR _scanall$[ebp], 1

; 3007 : 		// RV - RED - Recoded in a decent way... with SLEEP() alwasy done
; 3008 : 		//if (g_bOldSoundAlg) Sleep(dtime);
; 3009 : 		//else {
; 3010 : 		Sleep(dtime);

	mov	eax, DWORD PTR ?dtime@?1??ThreadHandler@CSoundMgr@@AAEXXZ@4HA
	push	eax
	call	DWORD PTR __imp__Sleep@4

; 3011 : 		if (!g_bOldSoundAlg){

	movzx	ecx, BYTE PTR ?g_bOldSoundAlg@@3_NA	; g_bOldSoundAlg
	test	ecx, ecx
	jne	$LN22@ThreadHand

; 3012 : 			F4EnterCriticalSection(StreamCSection);

	mov	edx, DWORD PTR ?StreamCSection@@3PAUF4CSECTIONHANDLE@@A ; StreamCSection
	push	edx
	call	_F4EnterCriticalSection
	add	esp, 4

; 3013 : 			if (BuildObjectList(hArray, &nHandles, sstreams) == FALSE) timer = dtime; // we have to go the slow route

	lea	eax, DWORD PTR _sstreams$[ebp]
	push	eax
	lea	ecx, DWORD PTR _nHandles$[ebp]
	push	ecx
	lea	edx, DWORD PTR _hArray$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuildObjectList@CSoundMgr@@AAEHQAPAXPAHQAPAVSoundStream@@@Z ; CSoundMgr::BuildObjectList
	test	eax, eax
	jne	SHORT $LN21@ThreadHand
	mov	eax, DWORD PTR ?dtime@?1??ThreadHandler@CSoundMgr@@AAEXXZ@4HA
	mov	DWORD PTR _timer$[ebp], eax
	jmp	SHORT $LN20@ThreadHand
$LN21@ThreadHand:

; 3014 : 			// we could set this to like 5 mins maybe to keep things going
; 3015 : 			else timer = INFINITE; 

	mov	DWORD PTR _timer$[ebp], -1
$LN20@ThreadHand:

; 3016 : 
; 3017 : 			F4LeaveCriticalSection(StreamCSection);

	mov	ecx, DWORD PTR ?StreamCSection@@3PAUF4CSECTIONHANDLE@@A ; StreamCSection
	push	ecx
	call	_F4LeaveCriticalSection
	add	esp, 4

; 3018 : 			DWORD result = WaitForMultipleObjects(nHandles, hArray, FALSE, timer);

	mov	edx, DWORD PTR _timer$[ebp]
	push	edx
	push	0
	lea	eax, DWORD PTR _hArray$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nHandles$[ebp]
	push	ecx
	call	DWORD PTR __imp__WaitForMultipleObjects@16
	mov	DWORD PTR _result$1[ebp], eax

; 3019 : 			switch(result) {

	mov	edx, DWORD PTR _result$1[ebp]
	mov	DWORD PTR tv80[ebp], edx
	cmp	DWORD PTR tv80[ebp], 0
	je	SHORT $LN17@ThreadHand
	cmp	DWORD PTR tv80[ebp], 258		; 00000102H
	je	SHORT $LN15@ThreadHand
	cmp	DWORD PTR tv80[ebp], -1
	je	SHORT $LN16@ThreadHand
	jmp	SHORT $LN14@ThreadHand
$LN17@ThreadHand:

; 3020 : 				case WAIT_OBJECT_0: // something new has happened, rescan
; 3021 : 									break;

	jmp	SHORT $LN22@ThreadHand
$LN16@ThreadHand:

; 3022 : 				
; 3023 : 				case WAIT_FAILED:	MonoPrint("Wait failed in CSoundMgr::TheadHandler\n");

	push	OFFSET ??_C@_0CI@LAKGHGCG@Wait?5failed?5in?5CSoundMgr?3?3TheadH@
	call	_MonoPrint
	add	esp, 4

; 3024 : 									break;

	jmp	SHORT $LN22@ThreadHand
$LN15@ThreadHand:

; 3025 : 				
; 3026 : 				case WAIT_TIMEOUT:	break;

	jmp	SHORT $LN22@ThreadHand
$LN14@ThreadHand:

; 3027 : 
; 3028 : 				default:			if (result > WAIT_OBJECT_0 && result < (WAIT_OBJECT_0 + nHandles)) {

	cmp	DWORD PTR _result$1[ebp], 0
	jbe	SHORT $LN22@ThreadHand
	mov	eax, DWORD PTR _result$1[ebp]
	cmp	eax, DWORD PTR _nHandles$[ebp]
	jae	SHORT $LN22@ThreadHand

; 3029 : 										Stream = sstreams[result-WAIT_OBJECT_0];

	mov	ecx, DWORD PTR _result$1[ebp]
	mov	edx, DWORD PTR _sstreams$[ebp+ecx*4]
	mov	DWORD PTR _Stream$[ebp], edx

; 3030 : 										//MonoPrint("Sound triggered on stream %x\n", Stream);
; 3031 : 										F4EnterCriticalSection(StreamCSection);

	mov	eax, DWORD PTR ?StreamCSection@@3PAUF4CSECTIONHANDLE@@A ; StreamCSection
	push	eax
	call	_F4EnterCriticalSection
	add	esp, 4

; 3032 : 										// check it is still valid
; 3033 : 										for (SoundStream *sp=StreamList; sp; sp=sp->Next) if (Stream == sp)ProcessStream(Stream);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR _sp$2[ebp], edx
	jmp	SHORT $LN12@ThreadHand
$LN11@ThreadHand:
	mov	eax, DWORD PTR _sp$2[ebp]
	mov	ecx, DWORD PTR [eax+112]
	mov	DWORD PTR _sp$2[ebp], ecx
$LN12@ThreadHand:
	cmp	DWORD PTR _sp$2[ebp], 0
	je	SHORT $LN10@ThreadHand
	mov	edx, DWORD PTR _Stream$[ebp]
	cmp	edx, DWORD PTR _sp$2[ebp]
	jne	SHORT $LN9@ThreadHand
	mov	eax, DWORD PTR _Stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ProcessStream@CSoundMgr@@AAEXPAVSoundStream@@@Z ; CSoundMgr::ProcessStream
$LN9@ThreadHand:

; 3034 : 										F4LeaveCriticalSection(StreamCSection);

	jmp	SHORT $LN11@ThreadHand
$LN10@ThreadHand:
	mov	ecx, DWORD PTR ?StreamCSection@@3PAUF4CSECTIONHANDLE@@A ; StreamCSection
	push	ecx
	call	_F4LeaveCriticalSection
	add	esp, 4

; 3035 : 										scanall = false;

	mov	BYTE PTR _scanall$[ebp], 0
$LN22@ThreadHand:

; 3036 : 									}
; 3037 : 									break;
; 3038 : 			}
; 3039 : 		}
; 3040 : 
; 3041 : 		// RV - RED - Thread no more valid....
; 3042 : 		if(this == NULL)_endthreadex(0);

	cmp	DWORD PTR _this$[ebp], 0
	jne	SHORT $LN8@ThreadHand
	push	0
	call	__endthreadex
	add	esp, 4
$LN8@ThreadHand:

; 3043 : 
; 3044 : 		if (scanall) {

	movzx	edx, BYTE PTR _scanall$[ebp]
	test	edx, edx
	je	$LN24@ThreadHand

; 3045 : #ifdef _DEBUG
; 3046 : 		    //loopcount ++;
; 3047 : #endif
; 3048 : 			F4EnterCriticalSection(StreamCSection);

	mov	eax, DWORD PTR ?StreamCSection@@3PAUF4CSECTIONHANDLE@@A ; StreamCSection
	push	eax
	call	_F4EnterCriticalSection
	add	esp, 4

; 3049 : 			// ok - so we loop through all streams, looking for things to do.
; 3050 : 			for (Stream=StreamList; Stream != NULL; Stream=Stream->Next){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR _Stream$[ebp], edx
	jmp	SHORT $LN6@ThreadHand
$LN5@ThreadHand:
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	mov	DWORD PTR _Stream$[ebp], ecx
$LN6@ThreadHand:
	cmp	DWORD PTR _Stream$[ebp], 0
	je	SHORT $LN4@ThreadHand

; 3051 : 				if((Stream->Status & SND_USE_THREAD) == 0) continue;			// not played on a thread

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+32]
	and	eax, 1073741824				; 40000000H
	jne	SHORT $LN3@ThreadHand
	jmp	SHORT $LN5@ThreadHand
$LN3@ThreadHand:

; 3052 : 				if(Stream->Status & SND_STREAM_DONE){

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	and	edx, 4
	je	SHORT $LN2@ThreadHand

; 3053 : 					StreamStop(Stream);

	mov	eax, DWORD PTR _Stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StreamStop@CSoundMgr@@QAEXPAVSoundStream@@@Z ; CSoundMgr::StreamStop

; 3054 : 					if(Stream->StreamMessage)

	mov	ecx, DWORD PTR _Stream$[ebp]
	cmp	DWORD PTR [ecx+92], 0
	je	SHORT $LN1@ThreadHand

; 3055 : 					(*Stream->StreamMessage)(Stream,SND_MSG_STREAM_DONE);

	push	4
	mov	edx, DWORD PTR _Stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	call	ecx
	add	esp, 8
$LN1@ThreadHand:

; 3056 : 					continue;

	jmp	SHORT $LN5@ThreadHand
$LN2@ThreadHand:

; 3057 : 				}
; 3058 : 				ProcessStream(Stream);

	mov	edx, DWORD PTR _Stream$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ProcessStream@CSoundMgr@@AAEXPAVSoundStream@@@Z ; CSoundMgr::ProcessStream

; 3059 : 			}

	jmp	SHORT $LN5@ThreadHand
$LN4@ThreadHand:

; 3060 : 			F4LeaveCriticalSection(StreamCSection);

	mov	eax, DWORD PTR ?StreamCSection@@3PAUF4CSECTIONHANDLE@@A ; StreamCSection
	push	eax
	call	_F4LeaveCriticalSection
	add	esp, 4
$LN24@ThreadHand:

; 3061 : 		}
; 3062 :     } while(StreamRunning);

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	jne	$LN25@ThreadHand

; 3063 :     StreamThreadID=0;

	mov	DWORD PTR _StreamThreadID, 0

; 3064 :     _endthreadex(0);

	push	0
	call	__endthreadex
	add	esp, 4

; 3065 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ThreadHandler@CSoundMgr@@AAEXXZ ENDP			; CSoundMgr::ThreadHandler
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_myself$ = 8						; size = 4
?StreamThread@CSoundMgr@@CGIPAX@Z PROC			; CSoundMgr::StreamThread

; 2944 : {

	push	ebp
	mov	ebp, esp

; 2945 :    ((CSoundMgr *)myself)->ThreadHandler();

	mov	ecx, DWORD PTR _myself$[ebp]
	call	?ThreadHandler@CSoundMgr@@AAEXXZ	; CSoundMgr::ThreadHandler

; 2946 :    return (0);

	xor	eax, eax

; 2947 : }

	pop	ebp
	ret	4
?StreamThread@CSoundMgr@@CGIPAX@Z ENDP			; CSoundMgr::StreamThread
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
$T2 = -48						; size = 4
$T3 = -44						; size = 4
tv142 = -40						; size = 4
$T4 = -36						; size = 4
tv76 = -32						; size = 4
$T5 = -28						; size = 4
_New$ = -24						; size = 4
_this$ = -20						; size = 4
_Cur$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_Sample$ = 8						; size = 4
?AddDuplicateSample@CSoundMgr@@AAEPAVSoundList@@PAV2@@Z PROC ; CSoundMgr::AddDuplicateSample
; _this$ = ecx

; 1720 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AddDuplicateSample@CSoundMgr@@AAEPAVSoundList@@PAV2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1721 : 	SoundList *Cur,*New;
; 1722 : #ifdef USE_SH_POOLS
; 1723 : 	HRESULT res;
; 1724 : #endif
; 1725 : 
; 1726 : 	if(DuplicateList == NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+32], 0
	jne	SHORT $LN8@AddDuplica

; 1727 : 	{
; 1728 : 		#ifdef USE_SH_POOLS
; 1729 : 		New= (SoundList *)MemAllocPtr( gSoundMemPool, sizeof(SoundList), 0 );
; 1730 : 		memcpy(New,Sample,sizeof(SoundList));
; 1731 : 		New->Next=NULL;
; 1732 : 		for(int i=0;i<<Sample->DS3DBufferCount;i++)
; 1733 : 		{
; 1734 : 			res=DSound->DuplicateSoundBuffer(Sample->Buf[0].DSoundBuffer,&New->Buf[i].DSoundBuffer);
; 1735 : 		}
; 1736 : 
; 1737 : 		#else
; 1738 : 		New=new SoundList(Sample, DSound);

	push	104					; 00000068H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T5[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T5[ebp], 0
	je	SHORT $LN11@AddDuplica
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _Sample$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T5[ebp]
	call	??0SoundList@@QAE@PAV0@PAUIDirectSound@@@Z ; SoundList::SoundList
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN12@AddDuplica
$LN11@AddDuplica:
	mov	DWORD PTR tv76[ebp], 0
$LN12@AddDuplica:
	mov	ecx, DWORD PTR tv76[ebp]
	mov	DWORD PTR $T3[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T3[ebp]
	mov	DWORD PTR _New$[ebp], edx

; 1739 : 		#endif
; 1740 : 		DuplicateList=New;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _New$[ebp]
	mov	DWORD PTR [eax+32], ecx

; 1741 : 	}
; 1742 : 	else

	jmp	$LN7@AddDuplica
$LN8@AddDuplica:

; 1743 : 	{
; 1744 : 		Cur=DuplicateList;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR _Cur$[ebp], eax

; 1745 : 
; 1746 : 		if(Cur->ID == Sample->ID)

	mov	ecx, DWORD PTR _Cur$[ebp]
	mov	edx, DWORD PTR _Sample$[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN4@AddDuplica

; 1747 : 			if(!(SampleStatus(Cur) & DSBSTATUS_PLAYING))

	mov	ecx, DWORD PTR _Cur$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SampleStatus@CSoundMgr@@QAEKPAVSoundList@@@Z ; CSoundMgr::SampleStatus
	and	eax, 1
	jne	SHORT $LN4@AddDuplica

; 1748 : 				return(Cur);

	mov	eax, DWORD PTR _Cur$[ebp]
	jmp	$LN9@AddDuplica
$LN4@AddDuplica:

; 1749 : 
; 1750 : 		while(Cur->Next != NULL)

	mov	edx, DWORD PTR _Cur$[ebp]
	cmp	DWORD PTR [edx+100], 0
	je	SHORT $LN3@AddDuplica

; 1751 : 		{
; 1752 : 			if(Cur->Next->ID == Sample->ID)

	mov	eax, DWORD PTR _Cur$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR _Sample$[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN2@AddDuplica

; 1753 : 			{
; 1754 : 				if(!(SampleStatus(Cur->Next) & DSBSTATUS_PLAYING))

	mov	ecx, DWORD PTR _Cur$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SampleStatus@CSoundMgr@@QAEKPAVSoundList@@@Z ; CSoundMgr::SampleStatus
	and	eax, 1
	jne	SHORT $LN2@AddDuplica

; 1755 : 					return(Cur->Next);

	mov	eax, DWORD PTR _Cur$[ebp]
	mov	eax, DWORD PTR [eax+100]
	jmp	SHORT $LN9@AddDuplica
$LN2@AddDuplica:

; 1756 : 			}
; 1757 : 			Cur=Cur->Next;

	mov	ecx, DWORD PTR _Cur$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR _Cur$[ebp], edx

; 1758 : 		}

	jmp	SHORT $LN4@AddDuplica
$LN3@AddDuplica:

; 1759 : 
; 1760 : //		New=(SoundList *)malloc(sizeof(SoundList));
; 1761 : 		#ifdef USE_SH_POOLS
; 1762 : 		New= (SoundList *)MemAllocPtr( gSoundMemPool, sizeof(SoundList), 0 );
; 1763 : 		memcpy(New,Sample,sizeof(SoundList));
; 1764 : 		New->Next=NULL;
; 1765 : 		for(int i=0;i<Sample->DS3DBufferCount;i++)
; 1766 : 		{
; 1767 : 			res=DSound->DuplicateSoundBuffer(Sample->Buf[0].DSoundBuffer,&New->Buf[i].DSoundBuffer);
; 1768 : 		}
; 1769 : 		#else
; 1770 : 		New=new SoundList(Sample, DSound);

	push	104					; 00000068H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T4[ebp], 0
	je	SHORT $LN13@AddDuplica
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _Sample$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T4[ebp]
	call	??0SoundList@@QAE@PAV0@PAUIDirectSound@@@Z ; SoundList::SoundList
	mov	DWORD PTR tv142[ebp], eax
	jmp	SHORT $LN14@AddDuplica
$LN13@AddDuplica:
	mov	DWORD PTR tv142[ebp], 0
$LN14@AddDuplica:
	mov	eax, DWORD PTR tv142[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR _New$[ebp], ecx

; 1771 : 		#endif
; 1772 : 		Cur->Next=New;

	mov	edx, DWORD PTR _Cur$[ebp]
	mov	eax, DWORD PTR _New$[ebp]
	mov	DWORD PTR [edx+100], eax
$LN7@AddDuplica:

; 1773 : 	}
; 1774 : 	return(New);

	mov	eax, DWORD PTR _New$[ebp]
$LN9@AddDuplica:

; 1775 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?AddDuplicateSample@CSoundMgr@@AAEPAVSoundList@@PAV2@@Z$0:
	mov	eax, DWORD PTR $T5[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?AddDuplicateSample@CSoundMgr@@AAEPAVSoundList@@PAV2@@Z$1:
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?AddDuplicateSample@CSoundMgr@@AAEPAVSoundList@@PAV2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AddDuplicateSample@CSoundMgr@@AAEPAVSoundList@@PAV2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AddDuplicateSample@CSoundMgr@@AAEPAVSoundList@@PAV2@@Z ENDP ; CSoundMgr::AddDuplicateSample
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_ps$ = -60						; size = 12
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
_hr$5 = -36						; size = 4
tv71 = -32						; size = 4
$T6 = -28						; size = 4
_Cur$ = -24						; size = 4
_this$ = -20						; size = 4
_New$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_Volume$ = 8						; size = 4
_Header$ = 12						; size = 4
_StreamSize$ = 16					; size = 4
_NewSound$ = 20						; size = 4
?AddStreamToMgr@CSoundMgr@@AAEJJPAUtWAVEFORMATEX@@JPAUIDirectSoundBuffer@@@Z PROC ; CSoundMgr::AddStreamToMgr
; _this$ = ecx

; 2132 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AddStreamToMgr@CSoundMgr@@AAEJJPAUtWAVEFORMATEX@@JPAUIDirectSoundBuffer@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 48					; 00000030H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2133 :     SoundStream *Cur,*New;
; 2134 :     SECURITY_ATTRIBUTES ps;
; 2135 :     ShiAssert(NewSound != NULL);
; 2136 :     
; 2137 : #ifdef USE_SH_POOLS
; 2138 :     New= (SoundStream *)MemAllocPtr( gSoundMemPool, sizeof(SoundStream), 0 );
; 2139 : #else
; 2140 :     New=new SoundStream;

	push	116					; 00000074H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T6[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T6[ebp], 0
	je	SHORT $LN10@AddStreamT
	mov	ecx, DWORD PTR $T6[ebp]
	call	??0SoundStream@@QAE@XZ			; SoundStream::SoundStream
	mov	DWORD PTR tv71[ebp], eax
	jmp	SHORT $LN11@AddStreamT
$LN10@AddStreamT:
	mov	DWORD PTR tv71[ebp], 0
$LN11@AddStreamT:
	mov	eax, DWORD PTR tv71[ebp]
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T4[ebp]
	mov	DWORD PTR _New$[ebp], ecx

; 2141 : #endif
; 2142 :     if(New == NULL)

	cmp	DWORD PTR _New$[ebp], 0
	jne	SHORT $LN7@AddStreamT

; 2143 : 	return(SND_NO_HANDLE);

	xor	eax, eax
	jmp	$LN8@AddStreamT
$LN7@AddStreamT:

; 2144 :     
; 2145 : 	New->ID=TotalStreams+50;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, 50					; 00000032H
	mov	ecx, DWORD PTR _New$[ebp]
	mov	DWORD PTR [ecx], eax

; 2146 : 	New->Volume=Volume;

	mov	edx, DWORD PTR _New$[ebp]
	mov	eax, DWORD PTR _Volume$[ebp]
	mov	DWORD PTR [edx+4], eax

; 2147 : 	New->CurFade=DSBVOLUME_MIN;

	mov	ecx, DWORD PTR _New$[ebp]
	mov	DWORD PTR [ecx+8], -10000		; ffffd8f0H

; 2148 : 	New->FadeIn=DSBVOLUME_MIN;

	mov	edx, DWORD PTR _New$[ebp]
	mov	DWORD PTR [edx+12], -10000		; ffffd8f0H

; 2149 : 	New->FadeOut=DSBVOLUME_MIN;

	mov	eax, DWORD PTR _New$[ebp]
	mov	DWORD PTR [eax+16], -10000		; ffffd8f0H

; 2150 : 	New->Frequency=Header->nSamplesPerSec;

	mov	ecx, DWORD PTR _New$[ebp]
	mov	edx, DWORD PTR _Header$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+20], eax

; 2151 : 	New->BytesPerSecond=Header->nAvgBytesPerSec;

	mov	ecx, DWORD PTR _New$[ebp]
	mov	edx, DWORD PTR _Header$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+28], eax

; 2152 : 	New->Direction=0;//Direction;

	mov	ecx, DWORD PTR _New$[ebp]
	mov	DWORD PTR [ecx+24], 0

; 2153 : 	New->OriginalSize=StreamSize;

	mov	edx, DWORD PTR _New$[ebp]
	mov	eax, DWORD PTR _StreamSize$[ebp]
	mov	DWORD PTR [edx+56], eax

; 2154 : 	New->BytesProcessed=0;

	mov	ecx, DWORD PTR _New$[ebp]
	mov	DWORD PTR [ecx+60], 0

; 2155 : 	New->LastPos=0;

	mov	edx, DWORD PTR _New$[ebp]
	mov	DWORD PTR [edx+64], 0

; 2156 : 	New->LoopOffset=0;

	mov	eax, DWORD PTR _New$[ebp]
	mov	DWORD PTR [eax+68], 0

; 2157 : 	New->LoopCount=-1;

	or	ecx, -1
	mov	edx, DWORD PTR _New$[ebp]
	mov	WORD PTR [edx+36], cx

; 2158 : 	New->HalfSize=StreamSize/2;

	mov	eax, DWORD PTR _StreamSize$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _New$[ebp]
	mov	DWORD PTR [ecx+48], eax

; 2159 : 	New->Size=New->HalfSize*2;

	mov	edx, DWORD PTR _New$[ebp]
	mov	eax, DWORD PTR [edx+48]
	shl	eax, 1
	mov	ecx, DWORD PTR _New$[ebp]
	mov	DWORD PTR [ecx+44], eax

; 2160 : 	New->Status=0;

	mov	edx, DWORD PTR _New$[ebp]
	mov	DWORD PTR [edx+32], 0

; 2161 : 	New->DSoundBuffer=NewSound;

	mov	eax, DWORD PTR _New$[ebp]
	mov	ecx, DWORD PTR _NewSound$[ebp]
	mov	DWORD PTR [eax+100], ecx

; 2162 : 	if (g_bOldSoundAlg == false) {

	movzx	edx, BYTE PTR ?g_bOldSoundAlg@@3_NA	; g_bOldSoundAlg
	test	edx, edx
	jne	SHORT $LN6@AddStreamT

; 2163 : 	    HRESULT hr = New->DSoundBuffer->QueryInterface(IID_IDirectSoundNotify, 
; 2164 : 		(LPVOID *)&New->lpDsNotify); 

	mov	eax, DWORD PTR _New$[ebp]
	add	eax, 104				; 00000068H
	push	eax
	push	OFFSET _IID_IDirectSoundNotify
	mov	ecx, DWORD PTR _New$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	eax, DWORD PTR _New$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR _hr$5[ebp], eax

; 2165 : 	    if (FAILED(hr) )

	cmp	DWORD PTR _hr$5[ebp], 0
	jge	SHORT $LN5@AddStreamT

; 2166 : 	    { 
; 2167 : 		DSoundCheck(hr);

	mov	ecx, DWORD PTR _hr$5[ebp]
	push	ecx
	call	?DSoundCheck@CSoundMgr@@SAXJ@Z		; CSoundMgr::DSoundCheck
	add	esp, 4

; 2168 : 		New->lpDsNotify = NULL;

	mov	edx, DWORD PTR _New$[ebp]
	mov	DWORD PTR [edx+104], 0
$LN5@AddStreamT:

; 2169 : 	    }
; 2170 : 	    New->notif = CreateEvent(NULL, FALSE, FALSE, NULL);

	push	0
	push	0
	push	0
	push	0
	call	DWORD PTR __imp__CreateEventA@16
	mov	ecx, DWORD PTR _New$[ebp]
	mov	DWORD PTR [ecx+108], eax
$LN6@AddStreamT:

; 2171 : 	}
; 2172 : 	New->fp=INVALID_HANDLE_VALUE;

	mov	edx, DWORD PTR _New$[ebp]
	mov	DWORD PTR [edx+40], -1

; 2173 : 	New->StreamSize=0;

	mov	eax, DWORD PTR _New$[ebp]
	mov	DWORD PTR [eax+52], 0

; 2174 : 	#ifdef USE_SH_POOLS
; 2175 : 	New->ImaInfo= (IMA_STREAM *)MemAllocPtr( gSoundMemPool, sizeof(IMA_STREAM), 0 );
; 2176 : 	#else
; 2177 : 	New->ImaInfo=new IMA_STREAM;

	push	64					; 00000040H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	ecx, DWORD PTR _New$[ebp]
	mov	edx, DWORD PTR $T3[ebp]
	mov	DWORD PTR [ecx+76], edx

; 2178 : 	#endif
; 2179 : 	memset(New->ImaInfo,0,sizeof(IMA_STREAM));

	push	64					; 00000040H
	push	0
	mov	eax, DWORD PTR _New$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 2180 : 	New->ImaInfo->type=Header->nChannels;

	mov	edx, DWORD PTR _New$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	ecx, DWORD PTR _Header$[ebp]
	mov	dx, WORD PTR [ecx+2]
	mov	WORD PTR [eax+36], dx

; 2181 : 	New->ImaInfo->bufsize=Header->nBlockAlign * (StreamSize / (Header->nBlockAlign * 2));

	mov	eax, DWORD PTR _Header$[ebp]
	movzx	ecx, WORD PTR [eax+12]
	mov	edx, DWORD PTR _Header$[ebp]
	movzx	esi, WORD PTR [edx+12]
	shl	esi, 1
	mov	eax, DWORD PTR _StreamSize$[ebp]
	cdq
	idiv	esi
	imul	ecx, eax
	mov	eax, DWORD PTR _New$[ebp]
	mov	edx, DWORD PTR [eax+76]
	mov	DWORD PTR [edx+8], ecx

; 2182 : 	New->ImaInfo->srcbuffer=new char[New->ImaInfo->bufsize];

	mov	eax, DWORD PTR _New$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR _New$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR [ecx+4], edx

; 2183 : 	// I do this, so I can use same stream for memory streaming (without losing buffer)
; 2184 : 	New->ImaInfo->srcsize=New->ImaInfo->bufsize;

	mov	eax, DWORD PTR _New$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR _New$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+24], ecx

; 2185 : 	New->ImaInfo->src=New->ImaInfo->srcbuffer;

	mov	edx, DWORD PTR _New$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	ecx, DWORD PTR _New$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [edx], eax

; 2186 : 
; 2187 : 	New->ImaInfo->sreadidx=0;

	mov	ecx, DWORD PTR _New$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR [edx+20], 0

; 2188 : 	New->ImaInfo->slen=0;

	mov	eax, DWORD PTR _New$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR [ecx+16], 0

; 2189 : 	New->ImaInfo->dlen=0;

	mov	edx, DWORD PTR _New$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	DWORD PTR [eax+32], 0

; 2190 : 	New->Callback=NULL;

	mov	ecx, DWORD PTR _New$[ebp]
	mov	DWORD PTR [ecx+88], 0

; 2191 : 	New->StreamMessage=NULL;

	mov	edx, DWORD PTR _New$[ebp]
	mov	DWORD PTR [edx+92], 0

; 2192 : 	New->me=NULL;

	mov	eax, DWORD PTR _New$[ebp]
	mov	DWORD PTR [eax+96], 0

; 2193 : 	New->Next=NULL;

	mov	ecx, DWORD PTR _New$[ebp]
	mov	DWORD PTR [ecx+112], 0

; 2194 : 
; 2195 : 	F4EnterCriticalSection(StreamCSection);

	mov	edx, DWORD PTR ?StreamCSection@@3PAUF4CSECTIONHANDLE@@A ; StreamCSection
	push	edx
	call	_F4EnterCriticalSection
	add	esp, 4

; 2196 : 	if(StreamList == NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+36], 0
	jne	SHORT $LN4@AddStreamT

; 2197 : 	{
; 2198 : 		StreamList=New;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _New$[ebp]
	mov	DWORD PTR [ecx+36], edx

; 2199 : 		TotalStreams++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 2200 : 		memset(&ps,0,sizeof(SECURITY_ATTRIBUTES));

	push	12					; 0000000cH
	push	0
	lea	eax, DWORD PTR _ps$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 2201 : 		ps.nLength=sizeof(ps);

	mov	DWORD PTR _ps$[ebp], 12			; 0000000cH

; 2202 : 		ps.bInheritHandle=TRUE;

	mov	DWORD PTR _ps$[ebp+8], 1

; 2203 : 
; 2204 : 		StreamRunning=TRUE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 1

; 2205 : 		StreamThreadID = (HANDLE)_beginthreadex( NULL, 0, StreamThread, this, 0, &PSoundThreadID );

	push	OFFSET _PSoundThreadID
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	push	OFFSET ?StreamThread@CSoundMgr@@CGIPAX@Z ; CSoundMgr::StreamThread
	push	0
	push	0
	call	__beginthreadex
	add	esp, 24					; 00000018H
	mov	DWORD PTR _StreamThreadID, eax

; 2206 : 		//SetThreadPriority(StreamThreadID,THREAD_PRIORITY_ABOVE_NORMAL);
; 2207 : 	}
; 2208 : 	else

	jmp	SHORT $LN3@AddStreamT
$LN4@AddStreamT:

; 2209 : 	{
; 2210 : 		Cur=StreamList;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR _Cur$[ebp], ecx
$LN2@AddStreamT:

; 2211 : 
; 2212 : 		while(Cur->Next != NULL)

	mov	edx, DWORD PTR _Cur$[ebp]
	cmp	DWORD PTR [edx+112], 0
	je	SHORT $LN1@AddStreamT

; 2213 : 			Cur=Cur->Next;

	mov	eax, DWORD PTR _Cur$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	mov	DWORD PTR _Cur$[ebp], ecx
	jmp	SHORT $LN2@AddStreamT
$LN1@AddStreamT:

; 2214 : 
; 2215 : 		Cur->Next=New;

	mov	edx, DWORD PTR _Cur$[ebp]
	mov	eax, DWORD PTR _New$[ebp]
	mov	DWORD PTR [edx+112], eax

; 2216 : 		TotalStreams++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx
$LN3@AddStreamT:

; 2217 : 	}
; 2218 : 	F4LeaveCriticalSection(StreamCSection);

	mov	ecx, DWORD PTR ?StreamCSection@@3PAUF4CSECTIONHANDLE@@A ; StreamCSection
	push	ecx
	call	_F4LeaveCriticalSection
	add	esp, 4

; 2219 : 	return(New->ID);

	mov	edx, DWORD PTR _New$[ebp]
	mov	eax, DWORD PTR [edx]
$LN8@AddStreamT:

; 2220 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?AddStreamToMgr@CSoundMgr@@AAEJJPAUtWAVEFORMATEX@@JPAUIDirectSoundBuffer@@@Z$0:
	mov	eax, DWORD PTR $T6[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?AddStreamToMgr@CSoundMgr@@AAEJJPAUtWAVEFORMATEX@@JPAUIDirectSoundBuffer@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AddStreamToMgr@CSoundMgr@@AAEJJPAUtWAVEFORMATEX@@JPAUIDirectSoundBuffer@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AddStreamToMgr@CSoundMgr@@AAEJJPAUtWAVEFORMATEX@@JPAUIDirectSoundBuffer@@@Z ENDP ; CSoundMgr::AddStreamToMgr
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_hr$2 = -44						; size = 4
$T3 = -40						; size = 4
tv71 = -36						; size = 4
$T4 = -32						; size = 4
_Cur$ = -28						; size = 4
_i$ = -24						; size = 4
_this$ = -20						; size = 4
_New$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_Volume$ = 8						; size = 4
_Frequency$ = 12					; size = 4
_Direction$ = 16					; size = 4
_NewSound$ = 20						; size = 4
_Flags$ = 24						; size = 4
_sfx$ = 28						; size = 4
?AddSampleToMgr@CSoundMgr@@AAEJJJJPAUIDirectSoundBuffer@@JPAUSfxDef@@@Z PROC ; CSoundMgr::AddSampleToMgr
; _this$ = ecx

; 1778 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AddSampleToMgr@CSoundMgr@@AAEJJJJPAUIDirectSoundBuffer@@JPAUSfxDef@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1779 : 	SoundList *Cur,*New;
; 1780 : 
; 1781 : //	New=(SoundList *)malloc(sizeof(SoundList));
; 1782 : 	#ifdef USE_SH_POOLS
; 1783 : 	New= (SoundList *)MemAllocPtr( gSoundMemPool, sizeof(SoundList), 0 );
; 1784 : 	#else
; 1785 : 	New=new SoundList;

	push	104					; 00000068H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T4[ebp], 0
	je	SHORT $LN13@AddSampleT
	mov	ecx, DWORD PTR $T4[ebp]
	call	??0SoundList@@QAE@XZ			; SoundList::SoundList
	mov	DWORD PTR tv71[ebp], eax
	jmp	SHORT $LN14@AddSampleT
$LN13@AddSampleT:
	mov	DWORD PTR tv71[ebp], 0
$LN14@AddSampleT:
	mov	eax, DWORD PTR tv71[ebp]
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR _New$[ebp], ecx

; 1786 : 	#endif
; 1787 : 	if(New == NULL)

	cmp	DWORD PTR _New$[ebp], 0
	jne	SHORT $LN10@AddSampleT

; 1788 : 		return(SND_NO_HANDLE);

	xor	eax, eax
	jmp	$LN11@AddSampleT
$LN10@AddSampleT:

; 1789 : 
; 1790 : 	New->ID=TotalSamples+100;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 100				; 00000064H
	mov	ecx, DWORD PTR _New$[ebp]
	mov	DWORD PTR [ecx], eax

; 1791 : 
; 1792 : 	New->Volume=Volume;

	mov	edx, DWORD PTR _New$[ebp]
	mov	eax, DWORD PTR _Volume$[ebp]
	mov	DWORD PTR [edx+4], eax

; 1793 : 	New->Frequency=Frequency;

	mov	ecx, DWORD PTR _New$[ebp]
	mov	edx, DWORD PTR _Frequency$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 1794 : 	New->Direction=Direction;

	mov	eax, DWORD PTR _New$[ebp]
	mov	ecx, DWORD PTR _Direction$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 1795 : 	New->MaxDist=(float)sqrt(sfx->maxDistSq);

	mov	edx, DWORD PTR _sfx$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+76]
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	mov	eax, DWORD PTR _New$[ebp]
	fstp	DWORD PTR [eax+20]

; 1796 : 	New->MinDist=(float)sqrt(sfx->min3ddist);

	mov	ecx, DWORD PTR _sfx$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+124]
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	mov	edx, DWORD PTR _New$[ebp]
	fstp	DWORD PTR [edx+24]

; 1797 : 	New->is3d = FALSE;

	mov	eax, DWORD PTR _New$[ebp]
	mov	DWORD PTR [eax+36], 0

; 1798 : 	New->Buf[0].DSoundBuffer=NewSound;

	mov	ecx, 56					; 00000038H
	imul	ecx, 0
	mov	edx, DWORD PTR _New$[ebp]
	mov	eax, DWORD PTR _NewSound$[ebp]
	mov	DWORD PTR [edx+ecx+44], eax

; 1799 : 	New->Sfx   = sfx;

	mov	ecx, DWORD PTR _New$[ebp]
	mov	edx, DWORD PTR _sfx$[ebp]
	mov	DWORD PTR [ecx+40], edx

; 1800 : 	New->Flags = sfx->flags;

	mov	eax, DWORD PTR _New$[ebp]
	mov	ecx, DWORD PTR _sfx$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR [eax+16], edx

; 1801 : 
; 1802 : 	if(New->Flags & (SFX_FLAGS_VMS|SFX_POS_INSIDE)) // only allocate 1 soundobject for these types

	mov	eax, DWORD PTR _New$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, 2056				; 00000808H
	je	SHORT $LN9@AddSampleT

; 1803 : 	{
; 1804 : 		New->DS3DBufferCount=1;

	mov	edx, DWORD PTR _New$[ebp]
	mov	DWORD PTR [edx+28], 1
$LN9@AddSampleT:

; 1805 : 	}
; 1806 : 
; 1807 : 	int i;
; 1808 : 	for(i=0;i<New->DS3DBufferCount;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN8@AddSampleT
$LN7@AddSampleT:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN8@AddSampleT:
	mov	ecx, DWORD PTR _New$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+28]
	jge	SHORT $LN6@AddSampleT

; 1809 : 	{
; 1810 : 		HRESULT hr = S_OK;

	mov	DWORD PTR _hr$2[ebp], 0

; 1811 : 
; 1812 : 		if(i>0)

	cmp	DWORD PTR _i$[ebp], 0
	jle	SHORT $LN5@AddSampleT

; 1813 : 			hr=DSound->DuplicateSoundBuffer(NewSound, &New->Buf[i].DSoundBuffer);

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 56					; 00000038H
	mov	ecx, DWORD PTR _New$[ebp]
	lea	edx, DWORD PTR [ecx+eax+44]
	push	edx
	mov	eax, DWORD PTR _NewSound$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+20]
	call	eax
	mov	DWORD PTR _hr$2[ebp], eax
$LN5@AddSampleT:

; 1814 : 
; 1815 : 		/*  MLR 5/6/2004 - No need to allocate a 3D buffer 
; 1816 : 		if (g_bUse3dSound && 
; 1817 : 			New->Flags & SFX_FLAGS_3D)
; 1818 : 		{
; 1819 : 			// create buffer here
; 1820 : 			//if (FAILED(hr))
; 1821 : 			//	DSoundCheck(hr);
; 1822 : 			hr = New->Buf[i].DSoundBuffer->QueryInterface(IID_IDirectSound3DBuffer, 
; 1823 : 				(LPVOID *)&New->Buf[i].DSound3dBuffer); 
; 1824 : 			if (FAILED(hr))
; 1825 : 				DSoundCheck(hr);
; 1826 : 			else 
; 1827 : 			{
; 1828 : 				d3dcount ++;
; 1829 : 				
; 1830 : 				hr = New->Buf[i].DSound3dBuffer->SetMode(DS3DMODE_DISABLE, DS3D_DEFERRED);
; 1831 : 				if (FAILED(hr))
; 1832 : 					DSoundCheck(hr);
; 1833 : 				if ( sfx && 
; 1834 : 					(sfx->flags & SFX_POS_EXTERN) && 
; 1835 : 					(sfx->flags & SFX_FLAGS_3D)) // only make external 3d sounds 3d
; 1836 : 				{
; 1837 : 					float maxdist = (float)  sqrt(sfx->maxDistSq); 
; 1838 : 					hr = New->Buf[i].DSound3dBuffer->SetMaxDistance(maxdist, DS3D_DEFERRED);
; 1839 : 					if (FAILED(hr))
; 1840 : 						DSoundCheck(hr);
; 1841 : 					float mindist = sfx->min3ddist;
; 1842 : 					if (mindist == 0)
; 1843 : 						mindist = maxdist/20.0f;
; 1844 : 					hr = New->Buf[i].DSound3dBuffer->SetMinDistance(mindist, DS3D_DEFERRED);
; 1845 : 					if (FAILED(hr))
; 1846 : 						DSoundCheck(hr);
; 1847 : 
; 1848 : 
; 1849 : 					if(New->Flags & SFX_FLAGS_3D)
; 1850 : 					{
; 1851 : 						New->Buf[i].DSound3dBuffer->SetMode(DS3DMODE_NORMAL, DS3D_DEFERRED);
; 1852 : 					}
; 1853 : 				}
; 1854 : 			}
; 1855 : 		} 
; 1856 : 		*/
; 1857 : 	}

	jmp	SHORT $LN7@AddSampleT
$LN6@AddSampleT:

; 1858 : 
; 1859 : 	New->Next=NULL;

	mov	ecx, DWORD PTR _New$[ebp]
	mov	DWORD PTR [ecx+100], 0

; 1860 : //	if(Flags & SND_EXCLUSIVE)
; 1861 : //		New->Flags |= SND_EXCLUSIVE;
; 1862 : //	if(Flags & SFX_POSITIONAL)
; 1863 : //		New->Flags |= SND_USE_3D;
; 1864 : //	if(Flags & SFX_POS_LOOPED) // MLR 12/6/2003 - commented out
; 1865 : //		New->Flags |= SND_LOOP_SAMPLE; // MLR 12/6/2003 - 
; 1866 : 
; 1867 : 
; 1868 : 
; 1869 : 	if(SampleList == NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+28], 0
	jne	SHORT $LN4@AddSampleT

; 1870 : 	{
; 1871 : 		SampleList=New;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _New$[ebp]
	mov	DWORD PTR [eax+28], ecx

; 1872 : 		TotalSamples++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1873 : 	}
; 1874 : 	else

	jmp	SHORT $LN3@AddSampleT
$LN4@AddSampleT:

; 1875 : 	{
; 1876 : 		Cur=SampleList;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR _Cur$[ebp], eax
$LN2@AddSampleT:

; 1877 : 
; 1878 : 		while(Cur->Next != NULL)

	mov	ecx, DWORD PTR _Cur$[ebp]
	cmp	DWORD PTR [ecx+100], 0
	je	SHORT $LN1@AddSampleT

; 1879 : 			Cur=Cur->Next;

	mov	edx, DWORD PTR _Cur$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR _Cur$[ebp], eax
	jmp	SHORT $LN2@AddSampleT
$LN1@AddSampleT:

; 1880 : 
; 1881 : 		Cur->Next=New;

	mov	ecx, DWORD PTR _Cur$[ebp]
	mov	edx, DWORD PTR _New$[ebp]
	mov	DWORD PTR [ecx+100], edx

; 1882 : 		TotalSamples++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx
$LN3@AddSampleT:

; 1883 : 	}
; 1884 : 	return(New->ID);

	mov	eax, DWORD PTR _New$[ebp]
	mov	eax, DWORD PTR [eax]
$LN11@AddSampleT:

; 1885 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?AddSampleToMgr@CSoundMgr@@AAEJJJJPAUIDirectSoundBuffer@@JPAUSfxDef@@@Z$0:
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?AddSampleToMgr@CSoundMgr@@AAEJJJJPAUIDirectSoundBuffer@@JPAUSfxDef@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AddSampleToMgr@CSoundMgr@@AAEJJJJPAUIDirectSoundBuffer@@JPAUSfxDef@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AddSampleToMgr@CSoundMgr@@AAEJJJJPAUIDirectSoundBuffer@@JPAUSfxDef@@@Z ENDP ; CSoundMgr::AddSampleToMgr
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
_Result$ = -12						; size = 4
tv79 = -8						; size = 4
_WorkDir$ = -4						; size = 4
_Direction$ = 8						; size = 4
?ConvertPanToDB@CSoundMgr@@AAEJJ@Z PROC			; CSoundMgr::ConvertPanToDB
; _this$ = ecx

; 1688 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1689 : 	long Result;
; 1690 : 	float WorkDir;
; 1691 : 
; 1692 : 	if(Direction < -80)

	cmp	DWORD PTR _Direction$[ebp], -80		; ffffffb0H
	jge	SHORT $LN2@ConvertPan

; 1693 : 		return(-10000);

	mov	eax, -10000				; ffffd8f0H
	jmp	SHORT $LN3@ConvertPan
$LN2@ConvertPan:

; 1694 : 	if(Direction > 80)

	cmp	DWORD PTR _Direction$[ebp], 80		; 00000050H
	jle	SHORT $LN1@ConvertPan

; 1695 : 		return(10000);

	mov	eax, 10000				; 00002710H
	jmp	SHORT $LN3@ConvertPan
$LN1@ConvertPan:

; 1696 : 
; 1697 : 	WorkDir=(float)Direction;

	cvtsi2ss xmm0, DWORD PTR _Direction$[ebp]
	movss	DWORD PTR _WorkDir$[ebp], xmm0

; 1698 : 	Result=(long)(4000.0f * log10(WorkDir));

	push	ecx
	movss	xmm0, DWORD PTR _WorkDir$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?log10@@YAMM@Z				; log10
	add	esp, 4
	fstp	DWORD PTR tv79[ebp]
	movss	xmm0, DWORD PTR tv79[ebp]
	mulss	xmm0, DWORD PTR __real@457a0000
	cvttss2si eax, xmm0
	mov	DWORD PTR _Result$[ebp], eax

; 1699 : 
; 1700 : 	return(Result);

	mov	eax, DWORD PTR _Result$[ebp]
$LN3@ConvertPan:

; 1701 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ConvertPanToDB@CSoundMgr@@AAEJJ@Z ENDP			; CSoundMgr::ConvertPanToDB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
_Result$ = -12						; size = 4
tv82 = -8						; size = 4
_WorkPerc$ = -4						; size = 4
_Percentage$ = 8					; size = 4
?ConvertVolumeToDB@CSoundMgr@@AAEJJ@Z PROC		; CSoundMgr::ConvertVolumeToDB
; _this$ = ecx

; 1672 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1673 : 	long Result;
; 1674 : 	float WorkPerc;
; 1675 : 
; 1676 : 	if(Percentage < 20)

	cmp	DWORD PTR _Percentage$[ebp], 20		; 00000014H
	jge	SHORT $LN2@ConvertVol

; 1677 : 		return(DSBVOLUME_MIN);

	mov	eax, -10000				; ffffd8f0H
	jmp	SHORT $LN3@ConvertVol
$LN2@ConvertVol:

; 1678 : 	if(Percentage >= 100)

	cmp	DWORD PTR _Percentage$[ebp], 100	; 00000064H
	jl	SHORT $LN1@ConvertVol

; 1679 : 		return(0);

	xor	eax, eax
	jmp	SHORT $LN3@ConvertVol
$LN1@ConvertVol:

; 1680 : 
; 1681 : 	WorkPerc = (float)Percentage;

	cvtsi2ss xmm0, DWORD PTR _Percentage$[ebp]
	movss	DWORD PTR _WorkPerc$[ebp], xmm0

; 1682 : 	Result=-(long)(4000.0f * (2-log10(WorkPerc)));

	push	ecx
	movss	xmm0, DWORD PTR _WorkPerc$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?log10@@YAMM@Z				; log10
	add	esp, 4
	fstp	DWORD PTR tv82[ebp]
	movss	xmm0, DWORD PTR __real@40000000
	subss	xmm0, DWORD PTR tv82[ebp]
	mulss	xmm0, DWORD PTR __real@457a0000
	cvttss2si eax, xmm0
	neg	eax
	mov	DWORD PTR _Result$[ebp], eax

; 1683 : 
; 1684 : 	return(Result);

	mov	eax, DWORD PTR _Result$[ebp]
$LN3@ConvertVol:

; 1685 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ConvertVolumeToDB@CSoundMgr@@AAEJJ@Z ENDP		; CSoundMgr::ConvertVolumeToDB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_hr$ = 8						; size = 4
?DSoundCheck@CSoundMgr@@SAXJ@Z PROC			; CSoundMgr::DSoundCheck

; 3175 : {

	push	ebp
	mov	ebp, esp

; 3176 : #if 0 // MLR 2003-10-21 Nothing like reporting cryptic messages that the user can't do a thing about.
; 3177 : 	switch(hr)
; 3178 : 	{
; 3179 : 		case DS_OK:
; 3180 : 			break;
; 3181 : // The call failed because resources (such as a priority level)
; 3182 : // were already being used by another caller.
; 3183 : 		case DSERR_ALLOCATED:
; 3184 : //			MessageBox(NULL,"DSERR_ALLOCATED","CSoundMgr",MB_OK);
; 3185 : 			MonoPrint("DSERR_ALLOCATED");
; 3186 : 			break;
; 3187 : // The control (vol,pan,etc.) requested by the caller is not available.
; 3188 : 		case DSERR_CONTROLUNAVAIL:
; 3189 : //			MessageBox(NULL,"DSERR_CONTROLUNAVAIL","CSoundMgr",MB_OK);
; 3190 : 			MonoPrint("DSERR_CONTROLUNAVAIL");
; 3191 : 			break;
; 3192 : // An invalid parameter was passed to the returning function
; 3193 : 		case DSERR_INVALIDPARAM:
; 3194 : //			MessageBox(NULL,"DSERR_INVALIDPARAM","CSoundMgr",MB_OK);
; 3195 : 			MonoPrint("DSERR_INVALIDPARAM");
; 3196 : 			break;
; 3197 : // This call is not valid for the current state of this object
; 3198 : 		case DSERR_INVALIDCALL:
; 3199 : //			MessageBox(NULL,"DSERR_INVALIDCALL","CSoundMgr",MB_OK);
; 3200 : 			MonoPrint("DSERR_INVALIDCALL");
; 3201 : 			break;
; 3202 : // An undetermined error occured inside the DirectSound subsystem
; 3203 : 		case DSERR_GENERIC:
; 3204 : //			MessageBox(NULL,"DSERR_GENERIC","CSoundMgr",MB_OK);
; 3205 : 			MonoPrint("DSERR_GENERIC");
; 3206 : 			break;
; 3207 : // The caller does not have the priority level required for the function to
; 3208 : // succeed.
; 3209 : 		case DSERR_PRIOLEVELNEEDED:
; 3210 : 			MonoPrint("DSERR_PRIOLEVELNEEDED");
; 3211 : //			MessageBox(NULL,"DSERR_PRIOLEVELNEEDED","CSoundMgr",MB_OK);
; 3212 : 			break;
; 3213 : // Not enough free memory is available to complete the operation
; 3214 : 		case DSERR_OUTOFMEMORY:
; 3215 : //			MessageBox(NULL,"DSERR_OUTOFMEMORY","CSoundMgr",MB_OK);
; 3216 : 			MonoPrint("DSERR_OUTOFMEMORY");
; 3217 : 			break;
; 3218 : // The specified WAVE format is not supported
; 3219 : 		case DSERR_BADFORMAT:
; 3220 : //			MessageBox(NULL,"DSERR_BADFORMAT","CSoundMgr",MB_OK);
; 3221 : 			MonoPrint("DSERR_BADFORMAT");
; 3222 : 			break;
; 3223 : // The function called is not supported at this time
; 3224 : 		case DSERR_UNSUPPORTED:
; 3225 : //			MessageBox(NULL,"DSERR_UNSUPPORTED","CSoundMgr",MB_OK);
; 3226 : 			MonoPrint("DSERR_UNSUPPORTED");
; 3227 : 			break;
; 3228 : // No sound driver is available for use
; 3229 : 		case DSERR_NODRIVER:
; 3230 : //			MessageBox(NULL,"DSERR_NODRIVER","CSoundMgr",MB_OK);
; 3231 : 			MonoPrint("DSERR_NODRIVER");
; 3232 : 			break;
; 3233 : // This object is already initialized
; 3234 : 		case DSERR_ALREADYINITIALIZED:
; 3235 : //			MessageBox(NULL,"DSERR_ALREADYINITIALIZED","CSoundMgr",MB_OK);
; 3236 : 			MonoPrint("DSERR_ALREADYINITIALIZED");
; 3237 : 			break;
; 3238 : // This object does not support aggregation
; 3239 : 		case DSERR_NOAGGREGATION:
; 3240 : //			MessageBox(NULL,"DSERR_NOAGGREGATION","CSoundMgr",MB_OK);
; 3241 : 			MonoPrint("DSERR_NOAGGREGATION");
; 3242 : 			break;
; 3243 : // The buffer memory has been lost, and must be restored.
; 3244 : 		case DSERR_BUFFERLOST:
; 3245 : //			MessageBox(NULL,"DSERR_BUFFERLOST","CSoundMgr",MB_OK);
; 3246 : 			MonoPrint("DSERR_BUFFERLOST");
; 3247 : 			break;
; 3248 : // Another app has a higher priority level, preventing this call from
; 3249 : // succeeding.
; 3250 : 		case DSERR_OTHERAPPHASPRIO:
; 3251 : 			MessageBox(NULL,"DSERR_OTHERAPPHASPRIO","CSoundMgr",MB_OK);
; 3252 : 			MonoPrint("DSERR_OTHERAPPHASPRIO");
; 3253 : 			break;
; 3254 : // This object has not been initialized
; 3255 : 		case DSERR_UNINITIALIZED:
; 3256 : //			MessageBox(NULL,"DSERR_UNINITIALIZED","CSoundMgr",MB_OK);
; 3257 : 			MonoPrint("DSERR_UNINITIALIZED");
; 3258 : 			break;
; 3259 : 
; 3260 : // The requested COM interface is not available
; 3261 : 		case DSERR_NOINTERFACE:
; 3262 : 			MessageBox(NULL,"DSERR_NOINTERFACE","CSoundMgr",MB_OK);
; 3263 : 			MonoPrint("DSERR_NOINTERFACE");
; 3264 : 			break;
; 3265 : 	}
; 3266 : #endif
; 3267 : }

	pop	ebp
	ret	0
?DSoundCheck@CSoundMgr@@SAXJ@Z ENDP			; CSoundMgr::DSoundCheck
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_this$ = -60						; size = 4
$T1 = -56						; size = 4
$T2 = -52						; size = 4
$T3 = -48						; size = 4
$T4 = -44						; size = 4
$T5 = -40						; size = 4
_size$ = -36						; size = 4
_datasize$ = -32					; size = 4
_hdr$ = -28						; size = 4
_fp$ = -24						; size = 4
_filedata$ = -20					; size = 4
_ptr$ = -16						; size = 4
_buffer$ = -12						; size = 5
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
?LoadRiff@CSoundMgr@@QAEPAURIFF_FILE@@PAD@Z PROC	; CSoundMgr::LoadRiff
; _this$ = ecx

; 356  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 357  : 	RIFF_FILE *filedata;
; 358  : 	FILE *fp;
; 359  : 	char buffer[5];
; 360  : 	char *ptr,*hdr;
; 361  : 	long size,datasize;
; 362  : 
; 363  : 	fp=fopen(filename,"rb");

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$[ebp], eax

; 364  : 	if(!fp)

	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $LN12@LoadRiff

; 365  : 		return(NULL);

	xor	eax, eax
	jmp	$LN14@LoadRiff
$LN12@LoadRiff:

; 366  : 
; 367  : 	fread(buffer,4,1,fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	push	1
	push	4
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 368  : 	buffer[4]=0;

	mov	eax, 1
	shl	eax, 2
	mov	DWORD PTR $T5[ebp], eax
	cmp	DWORD PTR $T5[ebp], 5
	jae	SHORT $LN15@LoadRiff
	jmp	SHORT $LN16@LoadRiff
$LN15@LoadRiff:
	call	___report_rangecheckfailure
$LN16@LoadRiff:
	mov	ecx, DWORD PTR $T5[ebp]
	mov	BYTE PTR _buffer$[ebp+ecx], 0

; 369  : 	if(strcmp(buffer,"RIFF"))

	push	OFFSET ??_C@_04EPCGJKAP@RIFF?$AA@
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN11@LoadRiff

; 370  : 		return(NULL); // Unknown file type

	xor	eax, eax
	jmp	$LN14@LoadRiff
$LN11@LoadRiff:

; 371  : 
; 372  : 	fread(&datasize,sizeof(long),1,fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	4
	lea	ecx, DWORD PTR _datasize$[ebp]
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H

; 373  : 
; 374  : 	#ifdef USE_SH_POOLS
; 375  : 	filedata= (RIFF_FILE *)MemAllocPtr( gSoundMemPool, sizeof(RIFF_FILE), 0 );
; 376  : 	#else
; 377  : 	filedata=new RIFF_FILE;

	push	20					; 00000014H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	edx, DWORD PTR $T1[ebp]
	mov	DWORD PTR _filedata$[ebp], edx

; 378  : 	#endif
; 379  : 	memset(filedata,0,sizeof(RIFF_FILE));

	push	20					; 00000014H
	push	0
	mov	eax, DWORD PTR _filedata$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 380  : 
; 381  : 	#ifdef USE_SH_POOLS
; 382  : 	filedata->data= (char *)MemAllocPtr( gSoundMemPool, sizeof(char)*datasize, 0 );
; 383  : 	#else
; 384  : 	filedata->data=new char[datasize];

	mov	ecx, DWORD PTR _datasize$[ebp]
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	edx, DWORD PTR _filedata$[ebp]
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR [edx], eax

; 385  : 	#endif
; 386  : 	fread(filedata->data,datasize,1,fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _datasize$[ebp]
	push	edx
	mov	eax, DWORD PTR _filedata$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H

; 387  : 	fclose(fp);

	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_fclose
	add	esp, 4

; 388  : 
; 389  : 	ptr=filedata->data;

	mov	eax, DWORD PTR _filedata$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _ptr$[ebp], ecx

; 390  : 	if(ptr && !strncmp(ptr,"WAVE",4))

	cmp	DWORD PTR _ptr$[ebp], 0
	je	$LN10@LoadRiff
	push	4
	push	OFFSET ??_C@_04HFHJMNCD@WAVE?$AA@
	mov	edx, DWORD PTR _ptr$[ebp]
	push	edx
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN10@LoadRiff

; 391  : 	{
; 392  : 		ptr+=4;

	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, 4
	mov	DWORD PTR _ptr$[ebp], eax
$LN9@LoadRiff:

; 393  : 		while(ptr && !filedata->Start && ptr < (filedata->data + datasize))

	cmp	DWORD PTR _ptr$[ebp], 0
	je	$LN8@LoadRiff
	mov	ecx, DWORD PTR _filedata$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	jne	$LN8@LoadRiff
	mov	edx, DWORD PTR _filedata$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, DWORD PTR _datasize$[ebp]
	cmp	DWORD PTR _ptr$[ebp], eax
	jae	$LN8@LoadRiff

; 394  : 		{
; 395  : 			hdr=ptr;

	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR _hdr$[ebp], ecx

; 396  : 			ptr+=4;

	mov	edx, DWORD PTR _ptr$[ebp]
	add	edx, 4
	mov	DWORD PTR _ptr$[ebp], edx

; 397  : 			size=*(long*)ptr;

	mov	eax, DWORD PTR _ptr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _size$[ebp], ecx

; 398  : 			ptr+=4;

	mov	edx, DWORD PTR _ptr$[ebp]
	add	edx, 4
	mov	DWORD PTR _ptr$[ebp], edx

; 399  : 			if(!strncmp(hdr,"fmt ",4))

	push	4
	push	OFFSET ??_C@_04CAJPEBPP@fmt?5?$AA@
	mov	eax, DWORD PTR _hdr$[ebp]
	push	eax
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN7@LoadRiff

; 400  : 				filedata->Format=(WAVEFORMATEX*)ptr;

	mov	ecx, DWORD PTR _filedata$[ebp]
	mov	edx, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR [ecx+4], edx
	jmp	SHORT $LN6@LoadRiff
$LN7@LoadRiff:

; 401  : 			else if(!strncmp(hdr,"fact",4))

	push	4
	push	OFFSET ??_C@_04KNPHNDOC@fact?$AA@
	mov	eax, DWORD PTR _hdr$[ebp]
	push	eax
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN5@LoadRiff

; 402  : 				filedata->NumSamples=*(long*)ptr;

	mov	ecx, DWORD PTR _filedata$[ebp]
	mov	edx, DWORD PTR _ptr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+8], eax
	jmp	SHORT $LN6@LoadRiff
$LN5@LoadRiff:

; 403  : 			else if(!strncmp(hdr,"data",4))

	push	4
	push	OFFSET ??_C@_04PJOLNDGD@data?$AA@
	mov	ecx, DWORD PTR _hdr$[ebp]
	push	ecx
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@LoadRiff

; 404  : 			{
; 405  : 				filedata->Start=ptr;

	mov	edx, DWORD PTR _filedata$[ebp]
	mov	eax, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR [edx+12], eax

; 406  : 				filedata->SampleLen=size;

	mov	ecx, DWORD PTR _filedata$[ebp]
	mov	edx, DWORD PTR _size$[ebp]
	mov	DWORD PTR [ecx+16], edx
$LN6@LoadRiff:

; 407  : 			}
; 408  : 			ptr+=size;

	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _ptr$[ebp], eax

; 409  : 		}

	jmp	$LN9@LoadRiff
$LN8@LoadRiff:

; 410  : 	}
; 411  : 	else

	jmp	SHORT $LN2@LoadRiff
$LN10@LoadRiff:

; 412  : 	{
; 413  : 		if(filedata->data)

	mov	ecx, DWORD PTR _filedata$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN1@LoadRiff

; 414  : 			delete filedata->data;

	mov	edx, DWORD PTR _filedata$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T4[ebp], eax
	mov	ecx, DWORD PTR $T4[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@LoadRiff:

; 415  : 		delete filedata;

	mov	edx, DWORD PTR _filedata$[ebp]
	mov	DWORD PTR $T3[ebp], edx
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 416  : 		filedata=NULL;

	mov	DWORD PTR _filedata$[ebp], 0
$LN2@LoadRiff:

; 417  : 	}
; 418  : 	return(filedata);

	mov	eax, DWORD PTR _filedata$[ebp]
$LN14@LoadRiff:

; 419  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?LoadRiff@CSoundMgr@@QAEPAURIFF_FILE@@PAD@Z ENDP	; CSoundMgr::LoadRiff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_this$ = -20						; size = 4
_datasize$ = -16					; size = 4
_size$ = -12						; size = 4
_hdr$ = -8						; size = 4
_ptr$ = -4						; size = 4
_memory$ = 8						; size = 4
_riff$ = 12						; size = 4
?FillRiffInfo@CSoundMgr@@QAEJPADPAURIFF_FILE@@@Z PROC	; CSoundMgr::FillRiffInfo
; _this$ = ecx

; 303  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 304  : 	char *ptr,*hdr;
; 305  : 	long size,datasize;
; 306  : 
; 307  : 	if(!memory)

	cmp	DWORD PTR _memory$[ebp], 0
	jne	SHORT $LN11@FillRiffIn

; 308  : 		return(0);

	xor	eax, eax
	jmp	$LN12@FillRiffIn
$LN11@FillRiffIn:

; 309  : 
; 310  : 	ptr=memory;

	mov	eax, DWORD PTR _memory$[ebp]
	mov	DWORD PTR _ptr$[ebp], eax

; 311  : 	if(strncmp(ptr,"RIFF",4))

	push	4
	push	OFFSET ??_C@_04EPCGJKAP@RIFF?$AA@
	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN10@FillRiffIn

; 312  : 		return(0); // Unknown file type

	xor	eax, eax
	jmp	$LN12@FillRiffIn
$LN10@FillRiffIn:

; 313  : 
; 314  : 	ptr+=4;

	mov	edx, DWORD PTR _ptr$[ebp]
	add	edx, 4
	mov	DWORD PTR _ptr$[ebp], edx

; 315  : 
; 316  : 	datasize=*(long*)ptr;

	mov	eax, DWORD PTR _ptr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _datasize$[ebp], ecx

; 317  : 	ptr+=sizeof(long);

	mov	edx, DWORD PTR _ptr$[ebp]
	add	edx, 4
	mov	DWORD PTR _ptr$[ebp], edx

; 318  : 
; 319  : 	memset(riff,0,sizeof(RIFF_FILE));

	push	20					; 00000014H
	push	0
	mov	eax, DWORD PTR _riff$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 320  : 
; 321  : 	riff->data=ptr;

	mov	ecx, DWORD PTR _riff$[ebp]
	mov	edx, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR [ecx], edx

; 322  : 
; 323  : 	if(ptr && !strncmp(ptr,"WAVE",4))

	cmp	DWORD PTR _ptr$[ebp], 0
	je	$LN9@FillRiffIn
	push	4
	push	OFFSET ??_C@_04HFHJMNCD@WAVE?$AA@
	mov	eax, DWORD PTR _ptr$[ebp]
	push	eax
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN9@FillRiffIn

; 324  : 	{
; 325  : 		ptr+=4;

	mov	ecx, DWORD PTR _ptr$[ebp]
	add	ecx, 4
	mov	DWORD PTR _ptr$[ebp], ecx
$LN8@FillRiffIn:

; 326  : 		while(ptr && !riff->Start && ptr < (riff->data + datasize))

	cmp	DWORD PTR _ptr$[ebp], 0
	je	$LN7@FillRiffIn
	mov	edx, DWORD PTR _riff$[ebp]
	cmp	DWORD PTR [edx+12], 0
	jne	$LN7@FillRiffIn
	mov	eax, DWORD PTR _riff$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _datasize$[ebp]
	cmp	DWORD PTR _ptr$[ebp], ecx
	jae	$LN7@FillRiffIn

; 327  : 		{
; 328  : 			hdr=ptr;

	mov	edx, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR _hdr$[ebp], edx

; 329  : 			ptr+=4;

	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, 4
	mov	DWORD PTR _ptr$[ebp], eax

; 330  : 			size=*(long*)ptr;

	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _size$[ebp], edx

; 331  : 			ptr+=4;

	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, 4
	mov	DWORD PTR _ptr$[ebp], eax

; 332  : 			if(!strncmp(hdr,"fmt ",4))

	push	4
	push	OFFSET ??_C@_04CAJPEBPP@fmt?5?$AA@
	mov	ecx, DWORD PTR _hdr$[ebp]
	push	ecx
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@FillRiffIn

; 333  : 				riff->Format=(WAVEFORMATEX*)ptr;

	mov	edx, DWORD PTR _riff$[ebp]
	mov	eax, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR [edx+4], eax
	jmp	SHORT $LN5@FillRiffIn
$LN6@FillRiffIn:

; 334  : 			else if(!strncmp(hdr,"fact",4))

	push	4
	push	OFFSET ??_C@_04KNPHNDOC@fact?$AA@
	mov	ecx, DWORD PTR _hdr$[ebp]
	push	ecx
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN4@FillRiffIn

; 335  : 				riff->NumSamples=*(long*)ptr;

	mov	edx, DWORD PTR _riff$[ebp]
	mov	eax, DWORD PTR _ptr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+8], ecx
	jmp	SHORT $LN5@FillRiffIn
$LN4@FillRiffIn:

; 336  : 			else if(!strncmp(hdr,"data",4))

	push	4
	push	OFFSET ??_C@_04PJOLNDGD@data?$AA@
	mov	edx, DWORD PTR _hdr$[ebp]
	push	edx
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN5@FillRiffIn

; 337  : 			{
; 338  : 				riff->Start=ptr;

	mov	eax, DWORD PTR _riff$[ebp]
	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 339  : 				riff->SampleLen=size;

	mov	edx, DWORD PTR _riff$[ebp]
	mov	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR [edx+16], eax
$LN5@FillRiffIn:

; 340  : 			}
; 341  : 			ptr+=size;

	mov	ecx, DWORD PTR _ptr$[ebp]
	add	ecx, DWORD PTR _size$[ebp]
	mov	DWORD PTR _ptr$[ebp], ecx

; 342  : 		}

	jmp	$LN8@FillRiffIn
$LN7@FillRiffIn:

; 343  : 		if(riff->Start)

	mov	edx, DWORD PTR _riff$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN9@FillRiffIn

; 344  : 			return(riff->SampleLen);

	mov	eax, DWORD PTR _riff$[ebp]
	mov	eax, DWORD PTR [eax+16]
	jmp	SHORT $LN12@FillRiffIn
$LN9@FillRiffIn:

; 345  : 	}
; 346  : 	return(0);

	xor	eax, eax
$LN12@FillRiffIn:

; 347  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?FillRiffInfo@CSoundMgr@@QAEJPADPAURIFF_FILE@@@Z ENDP	; CSoundMgr::FillRiffInfo
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_this$ = -284						; size = 4
_totalsize$ = -280					; size = 4
tv150 = -276						; size = 4
_size$ = -272						; size = 4
_bytesread$ = -268					; size = 4
_br$ = -264						; size = 4
_buffer$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_fp$ = 8						; size = 4
_Format$ = 12						; size = 4
_HeaderSize$ = 16					; size = 4
_SampleCount$ = 20					; size = 4
?LoadRiffFormat@CSoundMgr@@QAEJPAXPAUtWAVEFORMATEX@@PAJ2@Z PROC ; CSoundMgr::LoadRiffFormat
; _this$ = ecx

; 534  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 284				; 0000011cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 535  : 	char buffer[256];
; 536  : 	long size,totalsize,bytesread;
; 537  : 	DWORD br;
; 538  : 
; 539  : 	(*SampleCount)=0;

	mov	eax, DWORD PTR _SampleCount$[ebp]
	mov	DWORD PTR [eax], 0

; 540  : 	ReadFile(fp,buffer,4,&br,NULL);

	push	0
	lea	ecx, DWORD PTR _br$[ebp]
	push	ecx
	push	4
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	DWORD PTR __imp__ReadFile@20

; 541  : 	bytesread=br;

	mov	ecx, DWORD PTR _br$[ebp]
	mov	DWORD PTR _bytesread$[ebp], ecx

; 542  : 	if(strncmp(buffer,"RIFF",4))

	push	4
	push	OFFSET ??_C@_04EPCGJKAP@RIFF?$AA@
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN10@LoadRiffFo

; 543  : 		return(0);

	xor	eax, eax
	jmp	$LN11@LoadRiffFo
$LN10@LoadRiffFo:

; 544  : 
; 545  : 	ReadFile(fp,&totalsize,sizeof(long),&br,NULL);

	push	0
	lea	eax, DWORD PTR _br$[ebp]
	push	eax
	push	4
	lea	ecx, DWORD PTR _totalsize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	DWORD PTR __imp__ReadFile@20

; 546  : 	bytesread+=br;

	mov	eax, DWORD PTR _bytesread$[ebp]
	add	eax, DWORD PTR _br$[ebp]
	mov	DWORD PTR _bytesread$[ebp], eax

; 547  : 
; 548  : 	ReadFile(fp,buffer,4,&br,NULL);

	push	0
	lea	ecx, DWORD PTR _br$[ebp]
	push	ecx
	push	4
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	DWORD PTR __imp__ReadFile@20

; 549  : 	bytesread+=br;

	mov	ecx, DWORD PTR _bytesread$[ebp]
	add	ecx, DWORD PTR _br$[ebp]
	mov	DWORD PTR _bytesread$[ebp], ecx

; 550  : 	if(strncmp(buffer,"WAVE",4))

	push	4
	push	OFFSET ??_C@_04HFHJMNCD@WAVE?$AA@
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN9@LoadRiffFo

; 551  : 		return(0); // unsupported format

	xor	eax, eax
	jmp	$LN11@LoadRiffFo
$LN9@LoadRiffFo:

; 552  : 
; 553  : 	ReadFile(fp,buffer,4,&br,NULL);

	push	0
	lea	eax, DWORD PTR _br$[ebp]
	push	eax
	push	4
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	DWORD PTR __imp__ReadFile@20

; 554  : 	bytesread+=br;

	mov	eax, DWORD PTR _bytesread$[ebp]
	add	eax, DWORD PTR _br$[ebp]
	mov	DWORD PTR _bytesread$[ebp], eax

; 555  : 	ReadFile(fp,&size,sizeof(long),&br,NULL);

	push	0
	lea	ecx, DWORD PTR _br$[ebp]
	push	ecx
	push	4
	lea	edx, DWORD PTR _size$[ebp]
	push	edx
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	DWORD PTR __imp__ReadFile@20

; 556  : 	bytesread+=br;

	mov	ecx, DWORD PTR _bytesread$[ebp]
	add	ecx, DWORD PTR _br$[ebp]
	mov	DWORD PTR _bytesread$[ebp], ecx
$LN8@LoadRiffFo:

; 557  : 	while(bytesread < totalsize && strncmp(buffer,"data",4))

	mov	edx, DWORD PTR _bytesread$[ebp]
	cmp	edx, DWORD PTR _totalsize$[ebp]
	jge	$LN7@LoadRiffFo
	push	4
	push	OFFSET ??_C@_04PJOLNDGD@data?$AA@
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN7@LoadRiffFo

; 558  : 	{
; 559  : 		if(!strncmp(buffer,"fmt ",4))

	push	4
	push	OFFSET ??_C@_04CAJPEBPP@fmt?5?$AA@
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@LoadRiffFo

; 560  : 		{
; 561  : 			ReadFile(fp,Format,min(sizeof(WAVEFORMATEX),size),&br,NULL);

	cmp	DWORD PTR _size$[ebp], 18		; 00000012H
	jbe	SHORT $LN13@LoadRiffFo
	mov	DWORD PTR tv150[ebp], 18		; 00000012H
	jmp	SHORT $LN14@LoadRiffFo
$LN13@LoadRiffFo:
	mov	edx, DWORD PTR _size$[ebp]
	mov	DWORD PTR tv150[ebp], edx
$LN14@LoadRiffFo:
	push	0
	lea	eax, DWORD PTR _br$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv150[ebp]
	push	ecx
	mov	edx, DWORD PTR _Format$[ebp]
	push	edx
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	DWORD PTR __imp__ReadFile@20

; 562  : 			size-=br;

	mov	ecx, DWORD PTR _size$[ebp]
	sub	ecx, DWORD PTR _br$[ebp]
	mov	DWORD PTR _size$[ebp], ecx

; 563  : 			bytesread+=br;

	mov	edx, DWORD PTR _bytesread$[ebp]
	add	edx, DWORD PTR _br$[ebp]
	mov	DWORD PTR _bytesread$[ebp], edx
$LN6@LoadRiffFo:

; 564  : 		}
; 565  : 		if(!strncmp(buffer,"fact",4))

	push	4
	push	OFFSET ??_C@_04KNPHNDOC@fact?$AA@
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN4@LoadRiffFo

; 566  : 		{
; 567  : 			ReadFile(fp,SampleCount,sizeof(long),&br,NULL);

	push	0
	lea	ecx, DWORD PTR _br$[ebp]
	push	ecx
	push	4
	mov	edx, DWORD PTR _SampleCount$[ebp]
	push	edx
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	DWORD PTR __imp__ReadFile@20

; 568  : 			size-=br;

	mov	ecx, DWORD PTR _size$[ebp]
	sub	ecx, DWORD PTR _br$[ebp]
	mov	DWORD PTR _size$[ebp], ecx

; 569  : 			bytesread+=br;

	mov	edx, DWORD PTR _bytesread$[ebp]
	add	edx, DWORD PTR _br$[ebp]
	mov	DWORD PTR _bytesread$[ebp], edx
$LN4@LoadRiffFo:

; 570  : 		}
; 571  : 		while(size > 256)

	cmp	DWORD PTR _size$[ebp], 256		; 00000100H
	jle	SHORT $LN3@LoadRiffFo

; 572  : 		{
; 573  : 			ReadFile(fp,buffer,256,&br,NULL);

	push	0
	lea	eax, DWORD PTR _br$[ebp]
	push	eax
	push	256					; 00000100H
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	DWORD PTR __imp__ReadFile@20

; 574  : 			size-=br;

	mov	eax, DWORD PTR _size$[ebp]
	sub	eax, DWORD PTR _br$[ebp]
	mov	DWORD PTR _size$[ebp], eax

; 575  : 			bytesread+=br;

	mov	ecx, DWORD PTR _bytesread$[ebp]
	add	ecx, DWORD PTR _br$[ebp]
	mov	DWORD PTR _bytesread$[ebp], ecx

; 576  : 		}

	jmp	SHORT $LN4@LoadRiffFo
$LN3@LoadRiffFo:

; 577  : 		if(size)

	cmp	DWORD PTR _size$[ebp], 0
	je	SHORT $LN2@LoadRiffFo

; 578  : 		{
; 579  : 			ReadFile(fp,buffer,size,&br,NULL);

	push	0
	lea	edx, DWORD PTR _br$[ebp]
	push	edx
	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	DWORD PTR __imp__ReadFile@20

; 580  : 			bytesread+=br;

	mov	eax, DWORD PTR _bytesread$[ebp]
	add	eax, DWORD PTR _br$[ebp]
	mov	DWORD PTR _bytesread$[ebp], eax
$LN2@LoadRiffFo:

; 581  : 		}
; 582  : 		ReadFile(fp,buffer,4,&br,NULL);

	push	0
	lea	ecx, DWORD PTR _br$[ebp]
	push	ecx
	push	4
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	DWORD PTR __imp__ReadFile@20

; 583  : 		bytesread+=br;

	mov	ecx, DWORD PTR _bytesread$[ebp]
	add	ecx, DWORD PTR _br$[ebp]
	mov	DWORD PTR _bytesread$[ebp], ecx

; 584  : 		ReadFile(fp,&size,sizeof(long),&br,NULL);

	push	0
	lea	edx, DWORD PTR _br$[ebp]
	push	edx
	push	4
	lea	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	DWORD PTR __imp__ReadFile@20

; 585  : 		bytesread+=br;

	mov	edx, DWORD PTR _bytesread$[ebp]
	add	edx, DWORD PTR _br$[ebp]
	mov	DWORD PTR _bytesread$[ebp], edx

; 586  : 	}

	jmp	$LN8@LoadRiffFo
$LN7@LoadRiffFo:

; 587  : 	if(bytesread < totalsize)

	mov	eax, DWORD PTR _bytesread$[ebp]
	cmp	eax, DWORD PTR _totalsize$[ebp]
	jge	SHORT $LN1@LoadRiffFo

; 588  : 	{
; 589  : 		*HeaderSize=bytesread;

	mov	ecx, DWORD PTR _HeaderSize$[ebp]
	mov	edx, DWORD PTR _bytesread$[ebp]
	mov	DWORD PTR [ecx], edx

; 590  : //		if(Format->wFormatTag == WAVE_FORMAT_IMA_ADPCM)
; 591  : //			return((*SampleCount) * Format->nChannels * Format->wBitsPerSample/8);
; 592  : //		else
; 593  : 		return(size);

	mov	eax, DWORD PTR _size$[ebp]
	jmp	SHORT $LN11@LoadRiffFo
$LN1@LoadRiffFo:

; 594  : 	}
; 595  : 	return(0);

	xor	eax, eax
$LN11@LoadRiffFo:

; 596  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?LoadRiffFormat@CSoundMgr@@QAEJPAXPAUtWAVEFORMATEX@@PAJ2@Z ENDP ; CSoundMgr::LoadRiffFormat
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_samplesize$ = -12					; size = 4
_this$ = -8						; size = 4
_fp$ = -4						; size = 4
_filename$ = 8						; size = 4
_Format$ = 12						; size = 4
_HeaderSize$ = 16					; size = 4
_SampleCount$ = 20					; size = 4
?LoadRiffFormat@CSoundMgr@@QAEJPADPAUtWAVEFORMATEX@@PAJ2@Z PROC ; CSoundMgr::LoadRiffFormat
; _this$ = ecx

; 515  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 516  : 	HANDLE fp;
; 517  : 	long samplesize;
; 518  : 
; 519  : 	fp=CreateFile(filename,GENERIC_READ,FILE_SHARE_READ,NULL,
; 520  : 						  OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL, NULL);

	push	0
	push	128					; 00000080H
	push	3
	push	0
	push	1
	push	-2147483648				; 80000000H
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	DWORD PTR __imp__CreateFileA@28
	mov	DWORD PTR _fp$[ebp], eax

; 521  : 
; 522  : 	if(fp == INVALID_HANDLE_VALUE)

	cmp	DWORD PTR _fp$[ebp], -1
	jne	SHORT $LN1@LoadRiffFo

; 523  : 		return(0);

	xor	eax, eax
	jmp	SHORT $LN2@LoadRiffFo
$LN1@LoadRiffFo:

; 524  : 
; 525  : 	samplesize=LoadRiffFormat(fp,Format,HeaderSize,SampleCount);

	mov	ecx, DWORD PTR _SampleCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR _HeaderSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _Format$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LoadRiffFormat@CSoundMgr@@QAEJPAXPAUtWAVEFORMATEX@@PAJ2@Z ; CSoundMgr::LoadRiffFormat
	mov	DWORD PTR _samplesize$[ebp], eax

; 526  : 	CloseHandle(fp);

	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	DWORD PTR __imp__CloseHandle@4

; 527  : 
; 528  : 	return(samplesize);

	mov	eax, DWORD PTR _samplesize$[ebp]
$LN2@LoadRiffFo:

; 529  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?LoadRiffFormat@CSoundMgr@@QAEJPADPAUtWAVEFORMATEX@@PAJ2@Z ENDP ; CSoundMgr::LoadRiffFormat
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_this$ = -280						; size = 4
_size$ = -276						; size = 4
_br$ = -272						; size = 4
_totalsize$ = -268					; size = 4
_bytesread$ = -264					; size = 4
_buffer$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_fp$ = 8						; size = 4
?SkipRiffHeader@CSoundMgr@@QAEJPAX@Z PROC		; CSoundMgr::SkipRiffHeader
; _this$ = ecx

; 470  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 280				; 00000118H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 471  : 	char buffer[256];
; 472  : 	long size,totalsize,bytesread;
; 473  : 	DWORD br;
; 474  : 
; 475  : 	ReadFile(fp,buffer,4,&br,NULL);

	push	0
	lea	eax, DWORD PTR _br$[ebp]
	push	eax
	push	4
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	DWORD PTR __imp__ReadFile@20

; 476  : 	if(strncmp(buffer,"RIFF",4))

	push	4
	push	OFFSET ??_C@_04EPCGJKAP@RIFF?$AA@
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN7@SkipRiffHe

; 477  : 		return(0);

	xor	eax, eax
	jmp	$LN8@SkipRiffHe
$LN7@SkipRiffHe:

; 478  : 
; 479  : 	bytesread=4;

	mov	DWORD PTR _bytesread$[ebp], 4

; 480  : 	ReadFile(fp,&totalsize,sizeof(long),&br,NULL);

	push	0
	lea	ecx, DWORD PTR _br$[ebp]
	push	ecx
	push	4
	lea	edx, DWORD PTR _totalsize$[ebp]
	push	edx
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	DWORD PTR __imp__ReadFile@20

; 481  : 	bytesread+=sizeof(long);

	mov	ecx, DWORD PTR _bytesread$[ebp]
	add	ecx, 4
	mov	DWORD PTR _bytesread$[ebp], ecx

; 482  : 	ReadFile(fp,buffer,4,&br,NULL);

	push	0
	lea	edx, DWORD PTR _br$[ebp]
	push	edx
	push	4
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	DWORD PTR __imp__ReadFile@20

; 483  : 	if(strncmp(buffer,"WAVE",4))

	push	4
	push	OFFSET ??_C@_04HFHJMNCD@WAVE?$AA@
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@SkipRiffHe

; 484  : 		return(0); // unsupported format

	xor	eax, eax
	jmp	$LN8@SkipRiffHe
$LN6@SkipRiffHe:

; 485  : 
; 486  : 	bytesread+=4;

	mov	eax, DWORD PTR _bytesread$[ebp]
	add	eax, 4
	mov	DWORD PTR _bytesread$[ebp], eax

; 487  : 	totalsize-=4;

	mov	ecx, DWORD PTR _totalsize$[ebp]
	sub	ecx, 4
	mov	DWORD PTR _totalsize$[ebp], ecx

; 488  : 	ReadFile(fp,buffer,4,&br,NULL);

	push	0
	lea	edx, DWORD PTR _br$[ebp]
	push	edx
	push	4
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	DWORD PTR __imp__ReadFile@20

; 489  : 	ReadFile(fp,&size,sizeof(long),&br,NULL);

	push	0
	lea	edx, DWORD PTR _br$[ebp]
	push	edx
	push	4
	lea	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	DWORD PTR __imp__ReadFile@20

; 490  : 	bytesread+=4+sizeof(long);

	mov	edx, DWORD PTR _bytesread$[ebp]
	add	edx, 8
	mov	DWORD PTR _bytesread$[ebp], edx

; 491  : 	totalsize-=8;

	mov	eax, DWORD PTR _totalsize$[ebp]
	sub	eax, 8
	mov	DWORD PTR _totalsize$[ebp], eax
$LN5@SkipRiffHe:

; 492  : 	while(totalsize > 0 && strncmp(buffer,"data",4))

	cmp	DWORD PTR _totalsize$[ebp], 0
	jle	$LN4@SkipRiffHe
	push	4
	push	OFFSET ??_C@_04PJOLNDGD@data?$AA@
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN4@SkipRiffHe
$LN3@SkipRiffHe:

; 493  : 	{
; 494  : 		while(size > 256)

	cmp	DWORD PTR _size$[ebp], 256		; 00000100H
	jle	SHORT $LN2@SkipRiffHe

; 495  : 		{
; 496  : 			ReadFile(fp,buffer,256,&br,NULL);

	push	0
	lea	edx, DWORD PTR _br$[ebp]
	push	edx
	push	256					; 00000100H
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	DWORD PTR __imp__ReadFile@20

; 497  : 			bytesread+=256;

	mov	edx, DWORD PTR _bytesread$[ebp]
	add	edx, 256				; 00000100H
	mov	DWORD PTR _bytesread$[ebp], edx

; 498  : 			size-=256;

	mov	eax, DWORD PTR _size$[ebp]
	sub	eax, 256				; 00000100H
	mov	DWORD PTR _size$[ebp], eax

; 499  : 			totalsize-=256;

	mov	ecx, DWORD PTR _totalsize$[ebp]
	sub	ecx, 256				; 00000100H
	mov	DWORD PTR _totalsize$[ebp], ecx

; 500  : 		}

	jmp	SHORT $LN3@SkipRiffHe
$LN2@SkipRiffHe:

; 501  : 		ReadFile(fp,buffer,size,&br,NULL);

	push	0
	lea	edx, DWORD PTR _br$[ebp]
	push	edx
	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	DWORD PTR __imp__ReadFile@20

; 502  : 		bytesread+=size;

	mov	eax, DWORD PTR _bytesread$[ebp]
	add	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _bytesread$[ebp], eax

; 503  : 		totalsize-=size;

	mov	ecx, DWORD PTR _totalsize$[ebp]
	sub	ecx, DWORD PTR _size$[ebp]
	mov	DWORD PTR _totalsize$[ebp], ecx

; 504  : 		ReadFile(fp,buffer,4,&br,NULL);

	push	0
	lea	edx, DWORD PTR _br$[ebp]
	push	edx
	push	4
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	DWORD PTR __imp__ReadFile@20

; 505  : 		ReadFile(fp,&size,sizeof(long),&br,NULL);

	push	0
	lea	edx, DWORD PTR _br$[ebp]
	push	edx
	push	4
	lea	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	DWORD PTR __imp__ReadFile@20

; 506  : 		bytesread+=4+sizeof(long);

	mov	edx, DWORD PTR _bytesread$[ebp]
	add	edx, 8
	mov	DWORD PTR _bytesread$[ebp], edx

; 507  : 		totalsize-=8;

	mov	eax, DWORD PTR _totalsize$[ebp]
	sub	eax, 8
	mov	DWORD PTR _totalsize$[ebp], eax

; 508  : 	}

	jmp	$LN5@SkipRiffHe
$LN4@SkipRiffHe:

; 509  : 	if(!strncmp(buffer,"data",4))

	push	4
	push	OFFSET ??_C@_04PJOLNDGD@data?$AA@
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN1@SkipRiffHe

; 510  : 		return(bytesread);

	mov	eax, DWORD PTR _bytesread$[ebp]
	jmp	SHORT $LN8@SkipRiffHe
$LN1@SkipRiffHe:

; 511  : 	return(0);

	xor	eax, eax
$LN8@SkipRiffHe:

; 512  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?SkipRiffHeader@CSoundMgr@@QAEJPAX@Z ENDP		; CSoundMgr::SkipRiffHeader
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_this$ = -276						; size = 4
_size$ = -272						; size = 4
_totalsize$ = -268					; size = 4
_bytesread$ = -264					; size = 4
_buffer$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_fp$ = 8						; size = 4
?SkipRiffHeader@CSoundMgr@@QAEJPAU_iobuf@@@Z PROC	; CSoundMgr::SkipRiffHeader
; _this$ = ecx

; 424  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 276				; 00000114H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 425  : 	char buffer[256];
; 426  : 	long size,totalsize,bytesread;
; 427  : 
; 428  : 	fread(buffer,4,1,fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	4
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H

; 429  : 	if(strncmp(buffer,"RIFF",4))

	push	4
	push	OFFSET ??_C@_04EPCGJKAP@RIFF?$AA@
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN7@SkipRiffHe

; 430  : 		return(0);

	xor	eax, eax
	jmp	$LN8@SkipRiffHe
$LN7@SkipRiffHe:

; 431  : 
; 432  : 	bytesread=4;

	mov	DWORD PTR _bytesread$[ebp], 4

; 433  : 	fread(&totalsize,sizeof(long),1,fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	4
	lea	ecx, DWORD PTR _totalsize$[ebp]
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H

; 434  : 	bytesread+=sizeof(long);

	mov	edx, DWORD PTR _bytesread$[ebp]
	add	edx, 4
	mov	DWORD PTR _bytesread$[ebp], edx

; 435  : 	fread(buffer,4,1,fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	4
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H

; 436  : 	bytesread+=4;

	mov	edx, DWORD PTR _bytesread$[ebp]
	add	edx, 4
	mov	DWORD PTR _bytesread$[ebp], edx

; 437  : 	if(strncmp(buffer,"WAVE",4))

	push	4
	push	OFFSET ??_C@_04HFHJMNCD@WAVE?$AA@
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@SkipRiffHe

; 438  : 		return(0); // unsupported format

	xor	eax, eax
	jmp	$LN8@SkipRiffHe
$LN6@SkipRiffHe:

; 439  : 
; 440  : 	totalsize-=4;

	mov	ecx, DWORD PTR _totalsize$[ebp]
	sub	ecx, 4
	mov	DWORD PTR _totalsize$[ebp], ecx

; 441  : 	fread(buffer,4,1,fp);

	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	push	1
	push	4
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_fread
	add	esp, 16					; 00000010H

; 442  : 	fread(&size,sizeof(long),1,fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	push	1
	push	4
	lea	edx, DWORD PTR _size$[ebp]
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 443  : 	bytesread+=4+sizeof(long);

	mov	eax, DWORD PTR _bytesread$[ebp]
	add	eax, 8
	mov	DWORD PTR _bytesread$[ebp], eax

; 444  : 	totalsize-=8;

	mov	ecx, DWORD PTR _totalsize$[ebp]
	sub	ecx, 8
	mov	DWORD PTR _totalsize$[ebp], ecx
$LN5@SkipRiffHe:

; 445  : 	while(totalsize > 0 && strncmp(buffer,"data",4))

	cmp	DWORD PTR _totalsize$[ebp], 0
	jle	$LN4@SkipRiffHe
	push	4
	push	OFFSET ??_C@_04PJOLNDGD@data?$AA@
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN4@SkipRiffHe
$LN3@SkipRiffHe:

; 446  : 	{
; 447  : 		while(size > 256)

	cmp	DWORD PTR _size$[ebp], 256		; 00000100H
	jle	SHORT $LN2@SkipRiffHe

; 448  : 		{
; 449  : 			fread(buffer,256,1,fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	256					; 00000100H
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H

; 450  : 			bytesread+=256;

	mov	edx, DWORD PTR _bytesread$[ebp]
	add	edx, 256				; 00000100H
	mov	DWORD PTR _bytesread$[ebp], edx

; 451  : 			size-=256;

	mov	eax, DWORD PTR _size$[ebp]
	sub	eax, 256				; 00000100H
	mov	DWORD PTR _size$[ebp], eax

; 452  : 			totalsize-=256;

	mov	ecx, DWORD PTR _totalsize$[ebp]
	sub	ecx, 256				; 00000100H
	mov	DWORD PTR _totalsize$[ebp], ecx

; 453  : 		}

	jmp	SHORT $LN3@SkipRiffHe
$LN2@SkipRiffHe:

; 454  : 		fread(buffer,size,1,fp);

	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H

; 455  : 		bytesread+=size;

	mov	edx, DWORD PTR _bytesread$[ebp]
	add	edx, DWORD PTR _size$[ebp]
	mov	DWORD PTR _bytesread$[ebp], edx

; 456  : 		totalsize-=size;

	mov	eax, DWORD PTR _totalsize$[ebp]
	sub	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _totalsize$[ebp], eax

; 457  : 		fread(buffer,4,1,fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	push	1
	push	4
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 458  : 		fread(&size,sizeof(long),1,fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	4
	lea	ecx, DWORD PTR _size$[ebp]
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H

; 459  : 		bytesread+=4+sizeof(long);

	mov	edx, DWORD PTR _bytesread$[ebp]
	add	edx, 8
	mov	DWORD PTR _bytesread$[ebp], edx

; 460  : 		totalsize-=8;

	mov	eax, DWORD PTR _totalsize$[ebp]
	sub	eax, 8
	mov	DWORD PTR _totalsize$[ebp], eax

; 461  : 	}

	jmp	$LN5@SkipRiffHe
$LN4@SkipRiffHe:

; 462  : 	if(!strncmp(buffer,"data",4))

	push	4
	push	OFFSET ??_C@_04PJOLNDGD@data?$AA@
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN1@SkipRiffHe

; 463  : 		return(bytesread);

	mov	eax, DWORD PTR _bytesread$[ebp]
	jmp	SHORT $LN8@SkipRiffHe
$LN1@SkipRiffHe:

; 464  : 	return(0);

	xor	eax, eax
$LN8@SkipRiffHe:

; 465  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?SkipRiffHeader@CSoundMgr@@QAEJPAU_iobuf@@@Z ENDP	; CSoundMgr::SkipRiffHeader
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_Cur$ = -4						; size = 4
_ID$ = 8						; size = 4
?FindStream@CSoundMgr@@QAEPAVSoundStream@@J@Z PROC	; CSoundMgr::FindStream
; _this$ = ecx

; 2268 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2269 : 	SoundStream *Cur;
; 2270 : 
; 2271 : 	if(gSoundDriver)

	cmp	DWORD PTR ?gSoundDriver@@3PAVCSoundMgr@@A, 0 ; gSoundDriver
	je	SHORT $LN4@FindStream

; 2272 : 	{
; 2273 : 		Cur=StreamList;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR _Cur$[ebp], ecx
$LN3@FindStream:

; 2274 : 
; 2275 : 		while(Cur != NULL)

	cmp	DWORD PTR _Cur$[ebp], 0
	je	SHORT $LN4@FindStream

; 2276 : 		{
; 2277 : 			if(Cur->ID == ID)

	mov	edx, DWORD PTR _Cur$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _ID$[ebp]
	jne	SHORT $LN1@FindStream

; 2278 : 				return(Cur);

	mov	eax, DWORD PTR _Cur$[ebp]
	jmp	SHORT $LN5@FindStream
$LN1@FindStream:

; 2279 : 			Cur=Cur->Next;

	mov	ecx, DWORD PTR _Cur$[ebp]
	mov	edx, DWORD PTR [ecx+112]
	mov	DWORD PTR _Cur$[ebp], edx

; 2280 : 		}

	jmp	SHORT $LN3@FindStream
$LN4@FindStream:

; 2281 : 	}
; 2282 : 	return(NULL);

	xor	eax, eax
$LN5@FindStream:

; 2283 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?FindStream@CSoundMgr@@QAEPAVSoundStream@@J@Z ENDP	; CSoundMgr::FindStream
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_Cur$ = -4						; size = 4
_ID$ = 8						; size = 4
?FindSample@CSoundMgr@@QAEPAVSoundList@@J@Z PROC	; CSoundMgr::FindSample
; _this$ = ecx

; 1888 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1889 : 	SoundList *Cur;
; 1890 : 
; 1891 : 	if(gSoundDriver)

	cmp	DWORD PTR ?gSoundDriver@@3PAVCSoundMgr@@A, 0 ; gSoundDriver
	je	SHORT $LN4@FindSample

; 1892 : 	{
; 1893 : 		Cur=SampleList;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR _Cur$[ebp], ecx
$LN3@FindSample:

; 1894 : 
; 1895 : 		while(Cur != NULL)

	cmp	DWORD PTR _Cur$[ebp], 0
	je	SHORT $LN4@FindSample

; 1896 : 		{
; 1897 : 			if(Cur->ID == ID)

	mov	edx, DWORD PTR _Cur$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _ID$[ebp]
	jne	SHORT $LN1@FindSample

; 1898 : 				return(Cur);

	mov	eax, DWORD PTR _Cur$[ebp]
	jmp	SHORT $LN5@FindSample
$LN1@FindSample:

; 1899 : 			Cur=Cur->Next;

	mov	ecx, DWORD PTR _Cur$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR _Cur$[ebp], edx

; 1900 : 		}

	jmp	SHORT $LN3@FindSample
$LN4@FindSample:

; 1901 : 	}
; 1902 : 	return(NULL);

	xor	eax, eax
$LN5@FindSample:

; 1903 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?FindSample@CSoundMgr@@QAEPAVSoundList@@J@Z ENDP	; CSoundMgr::FindSample
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_hr$ = -36						; size = 4
_this$ = -32						; size = 4
_front$ = -28						; size = 12
_up$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_campos$ = 8						; size = 4
_camrot$ = 12						; size = 4
_camvel$ = 16						; size = 4
_Reset$ = 20						; size = 1
?SetCameraPostion@CSoundMgr@@QAEXPAUTpoint@@PAUTrotation@@0_N@Z PROC ; CSoundMgr::SetCameraPostion
; _this$ = ecx

; 2031 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 2032 : 	static int reset=1;
; 2033 : 	static float olddoppler=-1,oldrolloff;
; 2034 : 
; 2035 : 	CamPos.x=campos->x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _campos$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+48], edx

; 2036 : 	CamPos.y=campos->y;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _campos$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+52], edx

; 2037 : 	CamPos.z=campos->z;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _campos$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+56], edx

; 2038 : 
; 2039 : 	CamVelocity.x=camvel->x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _camvel$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+60], edx

; 2040 : 	CamVelocity.y=camvel->y;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _camvel$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+64], edx

; 2041 : 	CamVelocity.z=camvel->z;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _camvel$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+68], edx

; 2042 : 
; 2043 : 
; 2044 :     if (use3d == FALSE || Ds3dListener == NULL || StreamCSection == NULL || campos == NULL || camrot == NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+44], 0
	je	SHORT $LN6@SetCameraP
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	je	SHORT $LN6@SetCameraP
	cmp	DWORD PTR ?StreamCSection@@3PAUF4CSECTIONHANDLE@@A, 0 ; StreamCSection
	je	SHORT $LN6@SetCameraP
	cmp	DWORD PTR _campos$[ebp], 0
	je	SHORT $LN6@SetCameraP
	cmp	DWORD PTR _camrot$[ebp], 0
	jne	SHORT $LN7@SetCameraP
$LN6@SetCameraP:

; 2045 : 		return;

	jmp	$LN8@SetCameraP
$LN7@SetCameraP:

; 2046 : 
; 2047 :     F4EnterCriticalSection(StreamCSection);

	mov	edx, DWORD PTR ?StreamCSection@@3PAUF4CSECTIONHANDLE@@A ; StreamCSection
	push	edx
	call	_F4EnterCriticalSection
	add	esp, 4

; 2048 : 
; 2049 :     HRESULT hr = Ds3dListener->SetPosition(campos->x, campos->y, campos->z, DS3D_DEFERRED);

	push	1
	mov	eax, DWORD PTR _campos$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+8]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _campos$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+4]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _campos$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+56]
	call	edx
	mov	DWORD PTR _hr$[ebp], eax

; 2050 :     if (FAILED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN5@SetCameraP

; 2051 : 	DSoundCheck(hr);

	mov	eax, DWORD PTR _hr$[ebp]
	push	eax
	call	?DSoundCheck@CSoundMgr@@SAXJ@Z		; CSoundMgr::DSoundCheck
	add	esp, 4
$LN5@SetCameraP:

; 2052 :     static const Tpoint upv = { 0, 0, 1 };
; 2053 :     static const Tpoint fwd = { 1, 0, 0 };
; 2054 : 
; 2055 : 
; 2056 : 	Tpoint front, up;
; 2057 :     MatrixMult(camrot, &upv, &up);

	lea	ecx, DWORD PTR _up$[ebp]
	push	ecx
	push	OFFSET ?upv@?5??SetCameraPostion@CSoundMgr@@QAEXPAUTpoint@@PAUTrotation@@0_N@Z@4U3@B
	mov	edx, DWORD PTR _camrot$[ebp]
	push	edx
	call	?MatrixMult@@YAXPBUTrotation@@PBUTpoint@@PAU2@@Z ; MatrixMult
	add	esp, 12					; 0000000cH

; 2058 :     MatrixMult(camrot, &fwd, &front);

	lea	eax, DWORD PTR _front$[ebp]
	push	eax
	push	OFFSET ?fwd@?5??SetCameraPostion@CSoundMgr@@QAEXPAUTpoint@@PAUTrotation@@0_N@Z@4U3@B
	mov	ecx, DWORD PTR _camrot$[ebp]
	push	ecx
	call	?MatrixMult@@YAXPBUTrotation@@PBUTpoint@@PAU2@@Z ; MatrixMult
	add	esp, 12					; 0000000cH

; 2059 :     // compute up vector
; 2060 :     // compute front vector;
; 2061 : 
; 2062 :     hr= Ds3dListener->SetOrientation(front.x, front.y, front.z, up.x, up.y, up.z, DS3D_DEFERRED);

	push	1
	push	ecx
	movss	xmm0, DWORD PTR _up$[ebp+8]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _up$[ebp+4]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _up$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _front$[ebp+8]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _front$[ebp+4]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _front$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+52]
	call	ecx
	mov	DWORD PTR _hr$[ebp], eax

; 2063 : 
; 2064 : 	if(g_bEnableDopplerSound) // MLR 2003-10-17 ear candy

	movzx	edx, BYTE PTR ?g_bEnableDopplerSound@@3_NA ; g_bEnableDopplerSound
	test	edx, edx
	je	SHORT $LN3@SetCameraP

; 2065 : 	{
; 2066 : 
; 2067 : 
; 2068 : #ifndef CUSTOM_DOPPLER
; 2069 : 	    // we don't need this with the custom doppler code.
; 2070 : 		Ds3dListener->SetVelocity(CamVelocity.x,CamVelocity.y,CamVelocity.z,DS3D_DEFERRED);
; 2071 : 
; 2072 : 		if(g_fSoundDopplerFactor!=olddoppler)
; 2073 : 		{
; 2074 : 			Ds3dListener->SetDopplerFactor(g_fSoundDopplerFactor,DS3D_DEFERRED);
; 2075 : 			olddoppler=g_fSoundDopplerFactor;
; 2076 : 		}
; 2077 : #endif
; 2078 : 
; 2079 : 		if(g_fSoundRolloffFactor!=oldrolloff)

	movss	xmm0, DWORD PTR ?g_fSoundRolloffFactor@@3MA
	ucomiss	xmm0, DWORD PTR ?oldrolloff@?1??SetCameraPostion@CSoundMgr@@QAEXPAUTpoint@@PAUTrotation@@0_N@Z@4MA
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN3@SetCameraP

; 2080 : 		{
; 2081 : 			Ds3dListener->SetRolloffFactor(g_fSoundRolloffFactor,DS3D_DEFERRED);

	push	1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fSoundRolloffFactor@@3MA
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+60]
	call	edx

; 2082 : 			oldrolloff=g_fSoundRolloffFactor;

	movss	xmm0, DWORD PTR ?g_fSoundRolloffFactor@@3MA
	movss	DWORD PTR ?oldrolloff@?1??SetCameraPostion@CSoundMgr@@QAEXPAUTpoint@@PAUTrotation@@0_N@Z@4MA, xmm0
$LN3@SetCameraP:

; 2083 : 		}
; 2084 : 	}
; 2085 : //#define SNDLOG
; 2086 : 
; 2087 : #ifdef SNDLOG
; 2088 : 	FILE *fp;
; 2089 : 
; 2090 : 	if(fp=fopen("sndlog.txt","a+"))
; 2091 : 	{
; 2092 : 		fprintf(fp,"SetCameraPosition() Pos(%.2f,%.2f,%.2f) Vel(%.2f,%.2f,%.2f)\n",
; 2093 : 			CamPos.x,CamPos.y,CamPos.z,CamVelocity.x,CamVelocity.y,CamVelocity.z);
; 2094 : 		fclose(fp);
; 2095 : 	}
; 2096 : #endif
; 2097 : 
; 2098 : 
; 2099 : 
; 2100 :     if (FAILED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN2@SetCameraP

; 2101 : 	DSoundCheck(hr);

	mov	eax, DWORD PTR _hr$[ebp]
	push	eax
	call	?DSoundCheck@CSoundMgr@@SAXJ@Z		; CSoundMgr::DSoundCheck
	add	esp, 4
$LN2@SetCameraP:

; 2102 :     hr = Ds3dListener->CommitDeferredSettings();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+68]
	call	eax
	mov	DWORD PTR _hr$[ebp], eax

; 2103 :     if (FAILED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN1@SetCameraP

; 2104 : 	DSoundCheck(hr);

	mov	ecx, DWORD PTR _hr$[ebp]
	push	ecx
	call	?DSoundCheck@CSoundMgr@@SAXJ@Z		; CSoundMgr::DSoundCheck
	add	esp, 4
$LN1@SetCameraP:

; 2105 :     F4LeaveCriticalSection(StreamCSection);

	mov	edx, DWORD PTR ?StreamCSection@@3PAUF4CSECTIONHANDLE@@A ; StreamCSection
	push	edx
	call	_F4LeaveCriticalSection
	add	esp, 4
$LN8@SetCameraP:

; 2106 : }   

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?SetCameraPostion@CSoundMgr@@QAEXPAUTpoint@@PAUTrotation@@0_N@Z ENDP ; CSoundMgr::SetCameraPostion
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_Stream$ = 8						; size = 4
?RestartStream@CSoundMgr@@QAEXPAVSoundStream@@@Z PROC	; CSoundMgr::RestartStream
; _this$ = ecx

; 2286 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2287 : 	if(Stream->Status & SND_STREAM_FILE)

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	and	ecx, 4096				; 00001000H
	je	$LN7@RestartStr

; 2288 : 	{
; 2289 : 		if(Stream->LoopOffset && Stream->LoopOffset < Stream->OriginalSize) // NOT supported for IMA_ADPCM

	mov	edx, DWORD PTR _Stream$[ebp]
	cmp	DWORD PTR [edx+68], 0
	je	SHORT $LN6@RestartStr
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [eax+68]
	cmp	edx, DWORD PTR [ecx+56]
	jae	SHORT $LN6@RestartStr

; 2290 : 		{
; 2291 : 			SetFilePointer(Stream->fp,Stream->HeaderOffset+Stream->LoopOffset,NULL,FILE_BEGIN);

	push	0
	push	0
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR _Stream$[ebp]
	add	ecx, DWORD PTR [edx+68]
	push	ecx
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	call	DWORD PTR __imp__SetFilePointer@16

; 2292 : 			Stream->StreamSize=Stream->LoopOffset;

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	mov	DWORD PTR [edx+52], ecx

; 2293 : 		}
; 2294 : 		else

	jmp	SHORT $LN5@RestartStr
$LN6@RestartStr:

; 2295 : 		{
; 2296 : 			SetFilePointer(Stream->fp,Stream->HeaderOffset,NULL,FILE_BEGIN);

	push	0
	push	0
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+72]
	push	eax
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	call	DWORD PTR __imp__SetFilePointer@16

; 2297 : 			if(Stream->ImaInfo)

	mov	eax, DWORD PTR _Stream$[ebp]
	cmp	DWORD PTR [eax+76], 0
	je	SHORT $LN4@RestartStr

; 2298 : 			{
; 2299 : 				Stream->ImaInfo->sidx=0;

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR [edx+12], 0

; 2300 : 				Stream->ImaInfo->sreadidx=-1;

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR [ecx+20], -1

; 2301 : 				Stream->ImaInfo->count=0;

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+76]
	xor	ecx, ecx
	mov	WORD PTR [eax+44], cx

; 2302 : 				Stream->ImaInfo->blockLength=0;

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	DWORD PTR [eax+40], 0

; 2303 : 				Stream->ImaInfo->didx=0;

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR [edx+28], 0
$LN4@RestartStr:

; 2304 : 			}
; 2305 : 			Stream->StreamSize=0;

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [eax+52], 0
$LN5@RestartStr:

; 2306 : 		}

	jmp	SHORT $LN8@RestartStr
$LN7@RestartStr:

; 2307 : 	}
; 2308 : 	else if(Stream->Status & SND_STREAM_MEMORY)

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	and	edx, 8192				; 00002000H
	je	SHORT $LN8@RestartStr

; 2309 : 	{
; 2310 : 		Stream->memptr=Stream->startptr;

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	mov	DWORD PTR [eax+84], edx

; 2311 : 		Stream->StreamSize=0;

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [eax+52], 0

; 2312 : 		if(Stream->ImaInfo)

	mov	ecx, DWORD PTR _Stream$[ebp]
	cmp	DWORD PTR [ecx+76], 0
	je	SHORT $LN8@RestartStr

; 2313 : 		{
; 2314 : 			Stream->ImaInfo->sidx=0;

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	DWORD PTR [eax+12], 0

; 2315 : 			Stream->ImaInfo->sreadidx=-1;

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR [edx+20], -1

; 2316 : 			Stream->ImaInfo->count=0;

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	xor	edx, edx
	mov	WORD PTR [ecx+44], dx

; 2317 : 			Stream->ImaInfo->blockLength=0;

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR [ecx+40], 0

; 2318 : 			Stream->ImaInfo->didx=0;

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	DWORD PTR [eax+28], 0
$LN8@RestartStr:

; 2319 : 		}
; 2320 : 	}
; 2321 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?RestartStream@CSoundMgr@@QAEXPAVSoundStream@@@Z ENDP	; CSoundMgr::RestartStream
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_hr$ = -20						; size = 4
_this$ = -16						; size = 4
_Len$ = -12						; size = 4
_mem$ = -8						; size = 4
_bytesread$ = -4					; size = 4
_Stream$ = 8						; size = 4
_Buffer$ = 12						; size = 4
_Length$ = 16						; size = 4
?ReadStream@CSoundMgr@@QAEKPAVSoundStream@@KK@Z PROC	; CSoundMgr::ReadStream
; _this$ = ecx

; 2352 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 2353 : 	char *mem;
; 2354 : 	DWORD Len;
; 2355 : 	DWORD bytesread = 0;

	mov	DWORD PTR _bytesread$[ebp], 0

; 2356 : 	HRESULT hr;
; 2357 : 
; 2358 : 	if(gSoundDriver)

	cmp	DWORD PTR ?gSoundDriver@@3PAVCSoundMgr@@A, 0 ; gSoundDriver
	je	$LN44@ReadStream

; 2359 : 	{
; 2360 : 		if(Stream == NULL)

	cmp	DWORD PTR _Stream$[ebp], 0
	jne	SHORT $LN43@ReadStream

; 2361 : 			return(0);

	xor	eax, eax
	jmp	$LN45@ReadStream
$LN43@ReadStream:

; 2362 : 
; 2363 : 		if(Stream->DSoundBuffer)

	mov	eax, DWORD PTR _Stream$[ebp]
	cmp	DWORD PTR [eax+100], 0
	je	$LN44@ReadStream

; 2364 : 		{
; 2365 : 			hr=Stream->DSoundBuffer->Lock(Buffer,Length,(void**)&mem,&Len,NULL,NULL,NULL);

	push	0
	push	0
	push	0
	lea	ecx, DWORD PTR _Len$[ebp]
	push	ecx
	lea	edx, DWORD PTR _mem$[ebp]
	push	edx
	mov	eax, DWORD PTR _Length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+44]
	call	ecx
	mov	DWORD PTR _hr$[ebp], eax

; 2366 : 			if(hr == DSERR_BUFFERLOST)

	cmp	DWORD PTR _hr$[ebp], -2005401450	; 88780096H
	jne	SHORT $LN41@ReadStream

; 2367 : 			{
; 2368 : 				Stream->DSoundBuffer->Restore();

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+80]
	call	ecx

; 2369 : 				Stream->DSoundBuffer->Lock(Buffer,Length,(void**)&mem,&Len,NULL,NULL,NULL);

	push	0
	push	0
	push	0
	lea	edx, DWORD PTR _Len$[ebp]
	push	edx
	lea	eax, DWORD PTR _mem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Length$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Buffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+44]
	call	edx
$LN41@ReadStream:

; 2370 : 			}
; 2371 : 			if(Len && hr == DS_OK)

	cmp	DWORD PTR _Len$[ebp], 0
	je	$LN40@ReadStream
	cmp	DWORD PTR _hr$[ebp], 0
	jne	$LN40@ReadStream

; 2372 : 			{
; 2373 : 				if(Stream->Status & SND_STREAM_FILE)

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	and	ecx, 4096				; 00001000H
	je	$LN39@ReadStream

; 2374 : 				{
; 2375 : 					if(Stream->Status & SND_IS_IMAADPCM)

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+32]
	and	eax, 268435456				; 10000000H
	je	SHORT $LN38@ReadStream

; 2376 : 					{
; 2377 : 						bytesread=StreamIMAADPCM(Stream,mem,Len);

	mov	ecx, DWORD PTR _Len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mem$[ebp]
	push	edx
	mov	eax, DWORD PTR _Stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StreamIMAADPCM@CSoundMgr@@QAEJPAVSoundStream@@PADJ@Z ; CSoundMgr::StreamIMAADPCM
	mov	DWORD PTR _bytesread$[ebp], eax

; 2378 : 					}
; 2379 : 					else

	jmp	SHORT $LN37@ReadStream
$LN38@ReadStream:

; 2380 : 						ReadFile(Stream->fp,mem,Len,&bytesread,NULL);

	push	0
	lea	ecx, DWORD PTR _bytesread$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Len$[ebp]
	push	edx
	mov	eax, DWORD PTR _mem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	call	DWORD PTR __imp__ReadFile@20
$LN37@ReadStream:

; 2381 : 					Stream->StreamSize += bytesread;

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	add	ecx, DWORD PTR _bytesread$[ebp]
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [edx+52], ecx

; 2382 : 
; 2383 : 					if(bytesread < Length)

	mov	eax, DWORD PTR _bytesread$[ebp]
	cmp	eax, DWORD PTR _Length$[ebp]
	jae	$LN36@ReadStream

; 2384 : 					{
; 2385 : 						if(Stream->Status & SND_STREAM_LOOP && (Stream->LoopCount > 0 || Stream->LoopCount == -1))

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	and	edx, 32768				; 00008000H
	je	$LN35@ReadStream
	mov	eax, DWORD PTR _Stream$[ebp]
	movsx	ecx, WORD PTR [eax+36]
	test	ecx, ecx
	jg	SHORT $LN34@ReadStream
	mov	edx, DWORD PTR _Stream$[ebp]
	movsx	eax, WORD PTR [edx+36]
	cmp	eax, -1
	jne	$LN35@ReadStream
$LN34@ReadStream:

; 2386 : 						{
; 2387 : 							RestartStream(Stream);

	mov	ecx, DWORD PTR _Stream$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RestartStream@CSoundMgr@@QAEXPAVSoundStream@@@Z ; CSoundMgr::RestartStream

; 2388 : 							if(Stream->Status & SND_IS_IMAADPCM)

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+32]
	and	eax, 268435456				; 10000000H
	je	SHORT $LN33@ReadStream

; 2389 : 							{
; 2390 : 								bytesread=StreamIMAADPCM(Stream,((char *)(mem) + bytesread),Length-bytesread);

	mov	ecx, DWORD PTR _Length$[ebp]
	sub	ecx, DWORD PTR _bytesread$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mem$[ebp]
	add	edx, DWORD PTR _bytesread$[ebp]
	push	edx
	mov	eax, DWORD PTR _Stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StreamIMAADPCM@CSoundMgr@@QAEJPAVSoundStream@@PADJ@Z ; CSoundMgr::StreamIMAADPCM
	mov	DWORD PTR _bytesread$[ebp], eax

; 2391 : 							}
; 2392 : 							else

	jmp	SHORT $LN32@ReadStream
$LN33@ReadStream:

; 2393 : 								ReadFile(Stream->fp,((char *)(mem) + bytesread),Length-bytesread,&bytesread,NULL);

	push	0
	lea	ecx, DWORD PTR _bytesread$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Length$[ebp]
	sub	edx, DWORD PTR _bytesread$[ebp]
	push	edx
	mov	eax, DWORD PTR _mem$[ebp]
	add	eax, DWORD PTR _bytesread$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	call	DWORD PTR __imp__ReadFile@20
$LN32@ReadStream:

; 2394 : 							Stream->StreamSize+=bytesread;

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	add	ecx, DWORD PTR _bytesread$[ebp]
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [edx+52], ecx

; 2395 : 							if(Stream->LoopCount > 0)

	mov	eax, DWORD PTR _Stream$[ebp]
	movsx	ecx, WORD PTR [eax+36]
	test	ecx, ecx
	jle	SHORT $LN31@ReadStream

; 2396 : 								Stream->LoopCount--;

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	ax, WORD PTR [edx+36]
	sub	ax, 1
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	WORD PTR [ecx+36], ax
$LN31@ReadStream:

; 2397 : 							if(!Stream->LoopCount && Stream->FadeOut < Stream->Volume) // Do fade out

	mov	edx, DWORD PTR _Stream$[ebp]
	movsx	eax, WORD PTR [edx+36]
	test	eax, eax
	jne	SHORT $LN30@ReadStream
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR [edx+4]
	jge	SHORT $LN30@ReadStream

; 2398 : 							{
; 2399 : 								if(Stream->StreamMessage)

	mov	ecx, DWORD PTR _Stream$[ebp]
	cmp	DWORD PTR [ecx+92], 0
	je	SHORT $LN29@ReadStream

; 2400 : 									(*Stream->StreamMessage)(Stream,SND_MSG_START_FADE);

	push	1
	mov	edx, DWORD PTR _Stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	call	ecx
	add	esp, 8
$LN29@ReadStream:

; 2401 : 								Stream->Status |= SND_STREAM_FADE_OUT;

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+32]
	or	eax, 65536				; 00010000H
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [ecx+32], eax
$LN30@ReadStream:

; 2402 : 							}
; 2403 : 						}
; 2404 : 						else

	jmp	$LN36@ReadStream
$LN35@ReadStream:

; 2405 : 						{
; 2406 : 							if(Stream->StreamMessage)

	mov	edx, DWORD PTR _Stream$[ebp]
	cmp	DWORD PTR [edx+92], 0
	je	SHORT $LN27@ReadStream

; 2407 : 								(*Stream->StreamMessage)(Stream,SND_MSG_STREAM_EOF);

	push	5
	mov	eax, DWORD PTR _Stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	call	edx
	add	esp, 8
$LN27@ReadStream:

; 2408 : 							if(Stream->Status & SND_STREAM_CONTINUE) // Set in callback to pass another stream

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	and	ecx, 262144				; 00040000H
	je	SHORT $LN26@ReadStream

; 2409 : 							{ // Kludge code used to string multiple files together
; 2410 : 								Stream->Status ^= SND_STREAM_CONTINUE;

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+32]
	xor	eax, 262144				; 00040000H
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [ecx+32], eax

; 2411 : 								RestartStream(Stream);

	mov	edx, DWORD PTR _Stream$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RestartStream@CSoundMgr@@QAEXPAVSoundStream@@@Z ; CSoundMgr::RestartStream

; 2412 : 								if(Stream->Status & SND_IS_IMAADPCM)

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	and	ecx, 268435456				; 10000000H
	je	SHORT $LN25@ReadStream

; 2413 : 								{
; 2414 : 									bytesread=StreamIMAADPCM(Stream,((char *)(mem) + bytesread),Length-bytesread);

	mov	edx, DWORD PTR _Length$[ebp]
	sub	edx, DWORD PTR _bytesread$[ebp]
	push	edx
	mov	eax, DWORD PTR _mem$[ebp]
	add	eax, DWORD PTR _bytesread$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Stream$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StreamIMAADPCM@CSoundMgr@@QAEJPAVSoundStream@@PADJ@Z ; CSoundMgr::StreamIMAADPCM
	mov	DWORD PTR _bytesread$[ebp], eax

; 2415 : 								}
; 2416 : 								else

	jmp	SHORT $LN24@ReadStream
$LN25@ReadStream:

; 2417 : 									ReadFile(Stream->fp,((char *)(mem) + bytesread),Length-bytesread,&bytesread,NULL);

	push	0
	lea	edx, DWORD PTR _bytesread$[ebp]
	push	edx
	mov	eax, DWORD PTR _Length$[ebp]
	sub	eax, DWORD PTR _bytesread$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mem$[ebp]
	add	ecx, DWORD PTR _bytesread$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+40]
	push	eax
	call	DWORD PTR __imp__ReadFile@20
$LN24@ReadStream:

; 2418 : 								Stream->StreamSize+=bytesread;

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	add	edx, DWORD PTR _bytesread$[ebp]
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [eax+52], edx

; 2419 : 							}
; 2420 : 							else

	jmp	SHORT $LN36@ReadStream
$LN26@ReadStream:

; 2421 : 								memset(((char *) (mem)+bytesread),0,Length-bytesread);

	mov	ecx, DWORD PTR _Length$[ebp]
	sub	ecx, DWORD PTR _bytesread$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _mem$[ebp]
	add	edx, DWORD PTR _bytesread$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH
$LN36@ReadStream:

; 2422 : 						}
; 2423 : 					}
; 2424 : 				}

	jmp	$LN40@ReadStream
$LN39@ReadStream:

; 2425 : 				else if(Stream->Status & SND_STREAM_MEMORY)

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	and	ecx, 8192				; 00002000H
	je	$LN21@ReadStream

; 2426 : 				{
; 2427 : 					if(Stream->Status & SND_IS_IMAADPCM)

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+32]
	and	eax, 268435456				; 10000000H
	je	SHORT $LN20@ReadStream

; 2428 : 					{
; 2429 : 						bytesread=MemStreamIMAADPCM(Stream,mem,Len);

	mov	ecx, DWORD PTR _Len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mem$[ebp]
	push	edx
	mov	eax, DWORD PTR _Stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MemStreamIMAADPCM@CSoundMgr@@QAEJPAVSoundStream@@PADJ@Z ; CSoundMgr::MemStreamIMAADPCM
	mov	DWORD PTR _bytesread$[ebp], eax

; 2430 : 					}
; 2431 : 					else

	jmp	SHORT $LN19@ReadStream
$LN20@ReadStream:

; 2432 : 					{
; 2433 : 						if((Stream->OriginalSize - Stream->StreamSize) >= Len)

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [ecx+56]
	sub	eax, DWORD PTR [edx+52]
	cmp	eax, DWORD PTR _Len$[ebp]
	jb	SHORT $LN18@ReadStream

; 2434 : 						{
; 2435 : 							memcpy(mem,Stream->memptr,Len);

	mov	ecx, DWORD PTR _Len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+84]
	push	eax
	mov	ecx, DWORD PTR _mem$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2436 : 							bytesread=Len;

	mov	edx, DWORD PTR _Len$[ebp]
	mov	DWORD PTR _bytesread$[ebp], edx

; 2437 : 							Stream->memptr = ((char *) (Stream->memptr) + bytesread);

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	add	ecx, DWORD PTR _bytesread$[ebp]
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [edx+84], ecx

; 2438 : 						}
; 2439 : 						else

	jmp	SHORT $LN19@ReadStream
$LN18@ReadStream:

; 2440 : 						{
; 2441 : 							memcpy(mem,Stream->memptr,Stream->OriginalSize - Stream->StreamSize);

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [eax+56]
	sub	edx, DWORD PTR [ecx+52]
	push	edx
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	push	ecx
	mov	edx, DWORD PTR _mem$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2442 : 							bytesread=Stream->OriginalSize - Stream->StreamSize;

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [eax+56]
	sub	edx, DWORD PTR [ecx+52]
	mov	DWORD PTR _bytesread$[ebp], edx

; 2443 : 							Stream->memptr = ((char *) (Stream->memptr) + bytesread);

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	add	ecx, DWORD PTR _bytesread$[ebp]
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [edx+84], ecx
$LN19@ReadStream:

; 2444 : 						}
; 2445 : 					}
; 2446 : 
; 2447 : 					if(bytesread < 0)

	cmp	DWORD PTR _bytesread$[ebp], 0
	jae	SHORT $LN16@ReadStream

; 2448 : 						bytesread=0;

	mov	DWORD PTR _bytesread$[ebp], 0
$LN16@ReadStream:

; 2449 : 
; 2450 : 					Stream->StreamSize += bytesread;

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	add	ecx, DWORD PTR _bytesread$[ebp]
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [edx+52], ecx

; 2451 : 
; 2452 : 					if(bytesread < Length)

	mov	eax, DWORD PTR _bytesread$[ebp]
	cmp	eax, DWORD PTR _Length$[ebp]
	jae	$LN15@ReadStream

; 2453 : 					{
; 2454 : 						if(Stream->Status & SND_STREAM_LOOP && (Stream->LoopCount > 0 || Stream->LoopCount == -1))

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	and	edx, 32768				; 00008000H
	je	$LN14@ReadStream
	mov	eax, DWORD PTR _Stream$[ebp]
	movsx	ecx, WORD PTR [eax+36]
	test	ecx, ecx
	jg	SHORT $LN13@ReadStream
	mov	edx, DWORD PTR _Stream$[ebp]
	movsx	eax, WORD PTR [edx+36]
	cmp	eax, -1
	jne	$LN14@ReadStream
$LN13@ReadStream:

; 2455 : 						{
; 2456 : 							RestartStream(Stream);

	mov	ecx, DWORD PTR _Stream$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RestartStream@CSoundMgr@@QAEXPAVSoundStream@@@Z ; CSoundMgr::RestartStream

; 2457 : 							if(Stream->Status & SND_IS_IMAADPCM)

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+32]
	and	eax, 268435456				; 10000000H
	je	SHORT $LN12@ReadStream

; 2458 : 							{
; 2459 : 								bytesread=MemStreamIMAADPCM(Stream,((char *)(mem) + bytesread),Length-bytesread);

	mov	ecx, DWORD PTR _Length$[ebp]
	sub	ecx, DWORD PTR _bytesread$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mem$[ebp]
	add	edx, DWORD PTR _bytesread$[ebp]
	push	edx
	mov	eax, DWORD PTR _Stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MemStreamIMAADPCM@CSoundMgr@@QAEJPAVSoundStream@@PADJ@Z ; CSoundMgr::MemStreamIMAADPCM
	mov	DWORD PTR _bytesread$[ebp], eax

; 2460 : 							}
; 2461 : 							else

	jmp	$LN11@ReadStream
$LN12@ReadStream:

; 2462 : 							{
; 2463 : 								if((Stream->OriginalSize - Stream->StreamSize) >= (Length - bytesread))

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [ecx+56]
	sub	eax, DWORD PTR [edx+52]
	mov	ecx, DWORD PTR _Length$[ebp]
	sub	ecx, DWORD PTR _bytesread$[ebp]
	cmp	eax, ecx
	jb	SHORT $LN10@ReadStream

; 2464 : 								{
; 2465 : 									memcpy(mem,Stream->memptr,(Length - bytesread));

	mov	edx, DWORD PTR _Length$[ebp]
	sub	edx, DWORD PTR _bytesread$[ebp]
	push	edx
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	push	ecx
	mov	edx, DWORD PTR _mem$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2466 : 									Stream->memptr = ((char *) (Stream->memptr) + (Length - bytesread));

	mov	eax, DWORD PTR _Length$[ebp]
	sub	eax, DWORD PTR _bytesread$[ebp]
	mov	ecx, DWORD PTR _Stream$[ebp]
	add	eax, DWORD PTR [ecx+84]
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [edx+84], eax

; 2467 : 									bytesread=(Length - bytesread);

	mov	eax, DWORD PTR _Length$[ebp]
	sub	eax, DWORD PTR _bytesread$[ebp]
	mov	DWORD PTR _bytesread$[ebp], eax

; 2468 : 								}
; 2469 : 								else

	jmp	SHORT $LN11@ReadStream
$LN10@ReadStream:

; 2470 : 								{
; 2471 : 									memcpy(mem,Stream->memptr,Stream->OriginalSize - Stream->StreamSize);

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [ecx+56]
	sub	eax, DWORD PTR [edx+52]
	push	eax
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	push	edx
	mov	eax, DWORD PTR _mem$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2472 : 									Stream->memptr = ((char *) (Stream->memptr) + bytesread);

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	add	edx, DWORD PTR _bytesread$[ebp]
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [eax+84], edx

; 2473 : 									bytesread=Stream->OriginalSize - Stream->StreamSize;

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [ecx+56]
	sub	eax, DWORD PTR [edx+52]
	mov	DWORD PTR _bytesread$[ebp], eax
$LN11@ReadStream:

; 2474 : 								}
; 2475 : 							}
; 2476 : 							Stream->StreamSize+=bytesread;

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	add	edx, DWORD PTR _bytesread$[ebp]
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [eax+52], edx

; 2477 : 							if(Stream->LoopCount > 0)

	mov	ecx, DWORD PTR _Stream$[ebp]
	movsx	edx, WORD PTR [ecx+36]
	test	edx, edx
	jle	SHORT $LN8@ReadStream

; 2478 : 								Stream->LoopCount--;

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	cx, WORD PTR [eax+36]
	sub	cx, 1
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	WORD PTR [edx+36], cx
$LN8@ReadStream:

; 2479 : 							if(!Stream->LoopCount && Stream->FadeOut < Stream->Volume) // Do fade out

	mov	eax, DWORD PTR _Stream$[ebp]
	movsx	ecx, WORD PTR [eax+36]
	test	ecx, ecx
	jne	SHORT $LN7@ReadStream
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [edx+16]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $LN7@ReadStream

; 2480 : 							{
; 2481 : 								if(Stream->StreamMessage)

	mov	edx, DWORD PTR _Stream$[ebp]
	cmp	DWORD PTR [edx+92], 0
	je	SHORT $LN6@ReadStream

; 2482 : 									(*Stream->StreamMessage)(Stream,SND_MSG_START_FADE);

	push	1
	mov	eax, DWORD PTR _Stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	call	edx
	add	esp, 8
$LN6@ReadStream:

; 2483 : 								Stream->Status |= SND_STREAM_FADE_OUT;

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	or	ecx, 65536				; 00010000H
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [edx+32], ecx
$LN7@ReadStream:

; 2484 : 							}
; 2485 : 						}
; 2486 : 						else

	jmp	SHORT $LN15@ReadStream
$LN14@ReadStream:

; 2487 : 							memset(((char *) (mem)+bytesread),0,Length-bytesread);

	mov	eax, DWORD PTR _Length$[ebp]
	sub	eax, DWORD PTR _bytesread$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _mem$[ebp]
	add	ecx, DWORD PTR _bytesread$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
$LN15@ReadStream:

; 2488 : 					}
; 2489 : 					if(!(Stream->Status & SND_IS_IMAADPCM))

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+32]
	and	eax, 268435456				; 10000000H
	jne	SHORT $LN4@ReadStream

; 2490 : 						Stream->memptr = ((char *)(Stream->startptr) + Stream->StreamSize);

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	mov	eax, DWORD PTR _Stream$[ebp]
	add	edx, DWORD PTR [eax+52]
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [ecx+84], edx
$LN4@ReadStream:

; 2491 : 				}

	jmp	SHORT $LN40@ReadStream
$LN21@ReadStream:

; 2492 : 				else if(Stream->Status & SND_STREAM_CALLBACK)

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+32]
	and	eax, 16384				; 00004000H
	je	SHORT $LN40@ReadStream

; 2493 : 				{
; 2494 : 					bytesread=Stream->Callback(Stream->me,mem,Length);

	mov	ecx, DWORD PTR _Length$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mem$[ebp]
	push	edx
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	push	ecx
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+88]
	call	eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _bytesread$[ebp], eax

; 2495 : 					Stream->StreamSize+=bytesread;

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	add	edx, DWORD PTR _bytesread$[ebp]
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [eax+52], edx

; 2496 : 					if(bytesread < Length)

	mov	ecx, DWORD PTR _bytesread$[ebp]
	cmp	ecx, DWORD PTR _Length$[ebp]
	jae	SHORT $LN40@ReadStream

; 2497 :                         memset(((char *) (mem)+bytesread),0,Length-bytesread);

	mov	edx, DWORD PTR _Length$[ebp]
	sub	edx, DWORD PTR _bytesread$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _mem$[ebp]
	add	eax, DWORD PTR _bytesread$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
$LN40@ReadStream:

; 2498 : 				}
; 2499 : 			}
; 2500 : 			Stream->DSoundBuffer->Unlock(mem,Len,NULL,NULL);

	push	0
	push	0
	mov	ecx, DWORD PTR _Len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mem$[ebp]
	push	edx
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+76]
	call	edx
$LN44@ReadStream:

; 2501 : 		}
; 2502 : 	}
; 2503 : 	return(bytesread);

	mov	eax, DWORD PTR _bytesread$[ebp]
$LN45@ReadStream:

; 2504 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?ReadStream@CSoundMgr@@QAEKPAVSoundStream@@KK@Z ENDP	; CSoundMgr::ReadStream
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_Stream$ = 8						; size = 4
?StreamResumeFadeIn@CSoundMgr@@QAEXPAVSoundStream@@@Z PROC ; CSoundMgr::StreamResumeFadeIn
; _this$ = ecx

; 2603 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2604 : 	if(!Stream)

	cmp	DWORD PTR _Stream$[ebp], 0
	jne	SHORT $LN1@StreamResu

; 2605 : 		return;

	jmp	SHORT $LN2@StreamResu
$LN1@StreamResu:

; 2606 : 
; 2607 : 	Stream->Status |= SND_STREAM_FADE_IN;

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	or	ecx, 131072				; 00020000H
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [edx+32], ecx

; 2608 : 	Stream->Status &= ~(SND_STREAM_FADEDOUT|SND_STREAM_FADE_OUT);

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	and	ecx, -589825				; fff6ffffH
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [edx+32], ecx

; 2609 : 	StreamResume(Stream);

	mov	eax, DWORD PTR _Stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StreamResume@CSoundMgr@@QAEXPAVSoundStream@@@Z ; CSoundMgr::StreamResume
$LN2@StreamResu:

; 2610 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?StreamResumeFadeIn@CSoundMgr@@QAEXPAVSoundStream@@@Z ENDP ; CSoundMgr::StreamResumeFadeIn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_hr$1 = -4						; size = 4
_Stream$ = 8						; size = 4
?StreamResume@CSoundMgr@@QAEXPAVSoundStream@@@Z PROC	; CSoundMgr::StreamResume
; _this$ = ecx

; 2584 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2585 : 	if(!Stream)

	cmp	DWORD PTR _Stream$[ebp], 0
	jne	SHORT $LN3@StreamResu

; 2586 : 		return;

	jmp	SHORT $LN4@StreamResu
$LN3@StreamResu:

; 2587 : 
; 2588 : 	if(gSoundDriver)

	cmp	DWORD PTR ?gSoundDriver@@3PAVCSoundMgr@@A, 0 ; gSoundDriver
	je	SHORT $LN4@StreamResu

; 2589 : 	{
; 2590 : 	    HRESULT hr;
; 2591 : 		Stream->Status |= SND_USE_THREAD;

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	or	ecx, 1073741824				; 40000000H
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [edx+32], ecx

; 2592 : 		SetNotification(Stream);

	mov	eax, DWORD PTR _Stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetNotification@CSoundMgr@@AAEXPAVSoundStream@@@Z ; CSoundMgr::SetNotification

; 2593 : 		hr = Stream->DSoundBuffer->Play(0,0,DSBPLAY_LOOPING);

	push	1
	push	0
	push	0
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+48]
	call	eax
	mov	DWORD PTR _hr$1[ebp], eax

; 2594 : 		if (FAILED(hr))

	cmp	DWORD PTR _hr$1[ebp], 0
	jge	SHORT $LN1@StreamResu

; 2595 : 		    DSoundCheck(hr);

	mov	ecx, DWORD PTR _hr$1[ebp]
	push	ecx
	call	?DSoundCheck@CSoundMgr@@SAXJ@Z		; CSoundMgr::DSoundCheck
	add	esp, 4
$LN1@StreamResu:

; 2596 : 
; 2597 : 		Stream->Status &= ~SND_STREAM_FADEDOUT;

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+32]
	and	eax, -524289				; fff7ffffH
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [ecx+32], eax

; 2598 : 		NotifyThread();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?NotifyThread@CSoundMgr@@AAEXXZ		; CSoundMgr::NotifyThread
$LN4@StreamResu:

; 2599 : 	}
; 2600 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?StreamResume@CSoundMgr@@QAEXPAVSoundStream@@@Z ENDP	; CSoundMgr::StreamResume
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_Stream$ = 8						; size = 4
?StreamFadeOut@CSoundMgr@@QAEXPAVSoundStream@@@Z PROC	; CSoundMgr::StreamFadeOut
; _this$ = ecx

; 2570 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2571 : 	if(!Stream)

	cmp	DWORD PTR _Stream$[ebp], 0
	jne	SHORT $LN2@StreamFade

; 2572 : 		return;

	jmp	SHORT $LN3@StreamFade
$LN2@StreamFade:

; 2573 : 
; 2574 : 	if(gSoundDriver)

	cmp	DWORD PTR ?gSoundDriver@@3PAVCSoundMgr@@A, 0 ; gSoundDriver
	je	SHORT $LN3@StreamFade

; 2575 : 	{
; 2576 : 		Stream->FadeOut=DSBVOLUME_MIN;

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [eax+16], -10000		; ffffd8f0H

; 2577 : 		Stream->Status |= SND_STREAM_FADE_OUT;

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	or	edx, 65536				; 00010000H
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [eax+32], edx

; 2578 : 		Stream->Status &= ~SND_STREAM_FADE_IN;

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	and	edx, -131073				; fffdffffH
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [eax+32], edx

; 2579 : 		NotifyThread();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?NotifyThread@CSoundMgr@@AAEXXZ		; CSoundMgr::NotifyThread
$LN3@StreamFade:

; 2580 : 	}
; 2581 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?StreamFadeOut@CSoundMgr@@QAEXPAVSoundStream@@@Z ENDP	; CSoundMgr::StreamFadeOut
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_Stream$ = 8						; size = 4
?StreamPause@CSoundMgr@@QAEXPAVSoundStream@@@Z PROC	; CSoundMgr::StreamPause
; _this$ = ecx

; 2557 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2558 : 	if(!Stream)

	cmp	DWORD PTR _Stream$[ebp], 0
	jne	SHORT $LN2@StreamPaus

; 2559 : 		return;

	jmp	SHORT $LN3@StreamPaus
$LN2@StreamPaus:

; 2560 : 
; 2561 : 	if(gSoundDriver)

	cmp	DWORD PTR ?gSoundDriver@@3PAVCSoundMgr@@A, 0 ; gSoundDriver
	je	SHORT $LN3@StreamPaus

; 2562 : 	{
; 2563 : 		Stream->DSoundBuffer->Stop();

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+72]
	call	edx

; 2564 : 		Stream->Status &= ~SND_USE_THREAD;

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	and	ecx, -1073741825			; bfffffffH
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [edx+32], ecx

; 2565 : 		NotifyThread();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?NotifyThread@CSoundMgr@@AAEXXZ		; CSoundMgr::NotifyThread
$LN3@StreamPaus:

; 2566 : 	}
; 2567 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?StreamPause@CSoundMgr@@QAEXPAVSoundStream@@@Z ENDP	; CSoundMgr::StreamPause
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_Stream$ = 8						; size = 4
?StreamStopWithFade@CSoundMgr@@QAEXPAVSoundStream@@@Z PROC ; CSoundMgr::StreamStopWithFade
; _this$ = ecx

; 2632 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2633 : 	if(!Stream)

	cmp	DWORD PTR _Stream$[ebp], 0
	jne	SHORT $LN3@StreamStop

; 2634 : 		return;

	jmp	SHORT $LN4@StreamStop
$LN3@StreamStop:

; 2635 : 
; 2636 : 	if(gSoundDriver)

	cmp	DWORD PTR ?gSoundDriver@@3PAVCSoundMgr@@A, 0 ; gSoundDriver
	je	SHORT $LN4@StreamStop

; 2637 : 	{
; 2638 : 		if(Stream->Status & SND_STREAM_FILE)

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	and	ecx, 4096				; 00001000H
	je	SHORT $LN4@StreamStop

; 2639 : 		{
; 2640 : 			Stream->Status |= SND_STREAM_FADE_OUT;

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+32]
	or	eax, 65536				; 00010000H
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [ecx+32], eax

; 2641 : 			Stream->FadeOut=DSBVOLUME_MIN;

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [edx+16], -10000		; ffffd8f0H

; 2642 : 			NotifyThread();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?NotifyThread@CSoundMgr@@AAEXXZ		; CSoundMgr::NotifyThread
$LN4@StreamStop:

; 2643 : 		}
; 2644 : 	}
; 2645 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?StreamStopWithFade@CSoundMgr@@QAEXPAVSoundStream@@@Z ENDP ; CSoundMgr::StreamStopWithFade
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_Stream$ = 8						; size = 4
?StreamStop@CSoundMgr@@QAEXPAVSoundStream@@@Z PROC	; CSoundMgr::StreamStop
; _this$ = ecx

; 2613 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2614 : 	if(!Stream)

	cmp	DWORD PTR _Stream$[ebp], 0
	jne	SHORT $LN4@StreamStop

; 2615 : 		return;

	jmp	SHORT $LN5@StreamStop
$LN4@StreamStop:

; 2616 : 
; 2617 : 	if(gSoundDriver)

	cmp	DWORD PTR ?gSoundDriver@@3PAVCSoundMgr@@A, 0 ; gSoundDriver
	je	SHORT $LN5@StreamStop

; 2618 : 	{
; 2619 : 		if(Stream->Status & SND_STREAM_FILE)

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	and	ecx, 4096				; 00001000H
	je	SHORT $LN2@StreamStop

; 2620 : 		{
; 2621 : 			if(Stream->fp != INVALID_HANDLE_VALUE)

	mov	edx, DWORD PTR _Stream$[ebp]
	cmp	DWORD PTR [edx+40], -1
	je	SHORT $LN1@StreamStop

; 2622 : 				CloseHandle(Stream->fp);

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	call	DWORD PTR __imp__CloseHandle@4
$LN1@StreamStop:

; 2623 : 			Stream->fp = INVALID_HANDLE_VALUE;

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [edx+40], -1
$LN2@StreamStop:

; 2624 : 		}
; 2625 : 		Stream->Status &= ~SND_USE_THREAD;

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	and	ecx, -1073741825			; bfffffffH
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [edx+32], ecx

; 2626 : 		Stream->DSoundBuffer->Stop();

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+72]
	call	edx

; 2627 : 		NotifyThread();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?NotifyThread@CSoundMgr@@AAEXXZ		; CSoundMgr::NotifyThread
$LN5@StreamStop:

; 2628 : 	}
; 2629 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?StreamStop@CSoundMgr@@QAEXPAVSoundStream@@@Z ENDP	; CSoundMgr::StreamStop
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_cur$ = -4						; size = 4
_ID$ = 8						; size = 4
_offset$ = 12						; size = 4
?SetLoopOffset@CSoundMgr@@QAEXJK@Z PROC			; CSoundMgr::SetLoopOffset
; _this$ = ecx

; 2259 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2260 : 	SoundStream *cur;
; 2261 : 
; 2262 : 	cur=FindStream(ID);

	mov	eax, DWORD PTR _ID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindStream@CSoundMgr@@QAEPAVSoundStream@@J@Z ; CSoundMgr::FindStream
	mov	DWORD PTR _cur$[ebp], eax

; 2263 : 	if(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN2@SetLoopOff

; 2264 : 		cur->LoopOffset=offset;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _offset$[ebp]
	mov	DWORD PTR [ecx+68], edx
$LN2@SetLoopOff:

; 2265 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetLoopOffset@CSoundMgr@@QAEXJK@Z ENDP			; CSoundMgr::SetLoopOffset
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_cur$ = -4						; size = 4
_ID$ = 8						; size = 4
_count$ = 12						; size = 4
?SetLoopCounter@CSoundMgr@@QAEXJJ@Z PROC		; CSoundMgr::SetLoopCounter
; _this$ = ecx

; 2250 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2251 : 	SoundStream *cur;
; 2252 : 
; 2253 : 	cur=FindStream(ID);

	mov	eax, DWORD PTR _ID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindStream@CSoundMgr@@QAEPAVSoundStream@@J@Z ; CSoundMgr::FindStream
	mov	DWORD PTR _cur$[ebp], eax

; 2254 : 	if(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN2@SetLoopCou

; 2255 : 		cur->LoopCount= static_cast<short>(count);

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	dx, WORD PTR _count$[ebp]
	mov	WORD PTR [ecx+36], dx
$LN2@SetLoopCou:

; 2256 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetLoopCounter@CSoundMgr@@QAEXJJ@Z ENDP		; CSoundMgr::SetLoopCounter
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_cur$ = -4						; size = 4
_ID$ = 8						; size = 4
_volume$ = 12						; size = 4
?SetFadeOut@CSoundMgr@@QAEXJJ@Z PROC			; CSoundMgr::SetFadeOut
; _this$ = ecx

; 2241 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2242 : 	SoundStream *cur;
; 2243 : 
; 2244 : 	cur=FindStream(ID);

	mov	eax, DWORD PTR _ID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindStream@CSoundMgr@@QAEPAVSoundStream@@J@Z ; CSoundMgr::FindStream
	mov	DWORD PTR _cur$[ebp], eax

; 2245 : 	if(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN2@SetFadeOut

; 2246 : 		cur->FadeOut=volume;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _volume$[ebp]
	mov	DWORD PTR [ecx+16], edx
$LN2@SetFadeOut:

; 2247 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetFadeOut@CSoundMgr@@QAEXJJ@Z ENDP			; CSoundMgr::SetFadeOut
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_cur$ = -4						; size = 4
_ID$ = 8						; size = 4
_volume$ = 12						; size = 4
?SetFadeIn@CSoundMgr@@QAEXJJ@Z PROC			; CSoundMgr::SetFadeIn
; _this$ = ecx

; 2232 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2233 : 	SoundStream *cur;
; 2234 : 
; 2235 : 	cur=FindStream(ID);

	mov	eax, DWORD PTR _ID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindStream@CSoundMgr@@QAEPAVSoundStream@@J@Z ; CSoundMgr::FindStream
	mov	DWORD PTR _cur$[ebp], eax

; 2236 : 	if(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN2@SetFadeIn

; 2237 : 		cur->FadeIn=volume;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _volume$[ebp]
	mov	DWORD PTR [ecx+12], edx
$LN2@SetFadeIn:

; 2238 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetFadeIn@CSoundMgr@@QAEXJJ@Z ENDP			; CSoundMgr::SetFadeIn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_status$ = -4						; size = 4
_Stream$ = 8						; size = 4
?StreamStatus@CSoundMgr@@QAEKPAVSoundStream@@@Z PROC	; CSoundMgr::StreamStatus
; _this$ = ecx

; 1953 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1954 : 	DWORD status;
; 1955 : 
; 1956 : 	if(gSoundDriver)

	cmp	DWORD PTR ?gSoundDriver@@3PAVCSoundMgr@@A, 0 ; gSoundDriver
	je	SHORT $LN2@StreamStat

; 1957 : 	{
; 1958 : 		if(Stream != NULL)

	cmp	DWORD PTR _Stream$[ebp], 0
	je	SHORT $LN2@StreamStat

; 1959 : 		{
; 1960 : 			Stream->DSoundBuffer->GetStatus(&status);

	lea	eax, DWORD PTR _status$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+36]
	call	eax

; 1961 : 			return(status);

	mov	eax, DWORD PTR _status$[ebp]
	jmp	SHORT $LN3@StreamStat
$LN2@StreamStat:

; 1962 : 		}
; 1963 : 	}
; 1964 : 	return(0);

	xor	eax, eax
$LN3@StreamStat:

; 1965 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?StreamStatus@CSoundMgr@@QAEKPAVSoundStream@@@Z ENDP	; CSoundMgr::StreamStatus
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_status$ = -12						; size = 4
_Stream$ = -8						; size = 4
_this$ = -4						; size = 4
_ID$ = 8						; size = 4
?IsStreamPlaying@CSoundMgr@@QAEHJ@Z PROC		; CSoundMgr::IsStreamPlaying
; _this$ = ecx

; 1980 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1981 : 	SoundStream * Stream;
; 1982 : 	DWORD status;
; 1983 : 
; 1984 : 	if(gSoundDriver)

	cmp	DWORD PTR ?gSoundDriver@@3PAVCSoundMgr@@A, 0 ; gSoundDriver
	je	SHORT $LN4@IsStreamPl

; 1985 : 	{
; 1986 : 		if(DSound)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN4@IsStreamPl

; 1987 : 		{
; 1988 : 			Stream=FindStream(ID);

	mov	ecx, DWORD PTR _ID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindStream@CSoundMgr@@QAEPAVSoundStream@@J@Z ; CSoundMgr::FindStream
	mov	DWORD PTR _Stream$[ebp], eax

; 1989 : 			if(Stream != NULL)

	cmp	DWORD PTR _Stream$[ebp], 0
	je	SHORT $LN4@IsStreamPl

; 1990 : 			{
; 1991 : 				status=StreamStatus(Stream);

	mov	edx, DWORD PTR _Stream$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StreamStatus@CSoundMgr@@QAEKPAVSoundStream@@@Z ; CSoundMgr::StreamStatus
	mov	DWORD PTR _status$[ebp], eax

; 1992 : 				if(status & DSBSTATUS_PLAYING)

	mov	eax, DWORD PTR _status$[ebp]
	and	eax, 1
	je	SHORT $LN4@IsStreamPl

; 1993 : 					return(TRUE);

	mov	eax, 1
	jmp	SHORT $LN5@IsStreamPl
$LN4@IsStreamPl:

; 1994 : 			}
; 1995 : 		}
; 1996 : 	}
; 1997 : 	return(FALSE);

	xor	eax, eax
$LN5@IsStreamPl:

; 1998 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IsStreamPlaying@CSoundMgr@@QAEHJ@Z ENDP		; CSoundMgr::IsStreamPlaying
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_Stream$ = -4						; size = 4
_ID$ = 8						; size = 4
?GetStreamPlayTime@CSoundMgr@@QAEJJ@Z PROC		; CSoundMgr::GetStreamPlayTime
; _this$ = ecx

; 1968 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1969 : 	SoundStream *Stream;
; 1970 : 	if(gSoundDriver)

	cmp	DWORD PTR ?gSoundDriver@@3PAVCSoundMgr@@A, 0 ; gSoundDriver
	je	SHORT $LN2@GetStreamP

; 1971 : 	{
; 1972 : 		Stream=FindStream(ID);

	mov	eax, DWORD PTR _ID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindStream@CSoundMgr@@QAEPAVSoundStream@@J@Z ; CSoundMgr::FindStream
	mov	DWORD PTR _Stream$[ebp], eax

; 1973 : 		if(Stream != NULL)

	cmp	DWORD PTR _Stream$[ebp], 0
	je	SHORT $LN2@GetStreamP

; 1974 : 			return(Stream->BytesProcessed);//*1000/Stream->BytesPerSecond);

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [ecx+60]
	jmp	SHORT $LN3@GetStreamP
$LN2@GetStreamP:

; 1975 : 	}
; 1976 : 	return(0);

	xor	eax, eax
$LN3@GetStreamP:

; 1977 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetStreamPlayTime@CSoundMgr@@QAEJJ@Z ENDP		; CSoundMgr::GetStreamPlayTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_StreamID$ = 8						; size = 4
?FadeOutStream@CSoundMgr@@QAEXJ@Z PROC			; CSoundMgr::FadeOutStream
; _this$ = ecx

; 2513 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2514 : 	if(gSoundDriver)

	cmp	DWORD PTR ?gSoundDriver@@3PAVCSoundMgr@@A, 0 ; gSoundDriver
	je	SHORT $LN2@FadeOutStr

; 2515 : 		StreamFadeOut(FindStream(StreamID));

	mov	eax, DWORD PTR _StreamID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindStream@CSoundMgr@@QAEPAVSoundStream@@J@Z ; CSoundMgr::FindStream
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StreamFadeOut@CSoundMgr@@QAEXPAVSoundStream@@@Z ; CSoundMgr::StreamFadeOut
$LN2@FadeOutStr:

; 2516 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?FadeOutStream@CSoundMgr@@QAEXJ@Z ENDP			; CSoundMgr::FadeOutStream
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_StreamID$ = 8						; size = 4
?PauseStream@CSoundMgr@@QAEXJ@Z PROC			; CSoundMgr::PauseStream
; _this$ = ecx

; 2507 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2508 : 	if(gSoundDriver)

	cmp	DWORD PTR ?gSoundDriver@@3PAVCSoundMgr@@A, 0 ; gSoundDriver
	je	SHORT $LN2@PauseStrea

; 2509 : 		StreamPause(FindStream(StreamID));

	mov	eax, DWORD PTR _StreamID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindStream@CSoundMgr@@QAEPAVSoundStream@@J@Z ; CSoundMgr::FindStream
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StreamPause@CSoundMgr@@QAEXPAVSoundStream@@@Z ; CSoundMgr::StreamPause
$LN2@PauseStrea:

; 2510 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?PauseStream@CSoundMgr@@QAEXJ@Z ENDP			; CSoundMgr::PauseStream
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_cur$ = -4						; size = 4
?StopAllStreams@CSoundMgr@@QAEXXZ PROC			; CSoundMgr::StopAllStreams
; _this$ = ecx

; 2543 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2544 : 	SoundStream *cur;
; 2545 : 	if(gSoundDriver)

	cmp	DWORD PTR ?gSoundDriver@@3PAVCSoundMgr@@A, 0 ; gSoundDriver
	je	SHORT $LN4@StopAllStr

; 2546 : 	{
; 2547 : 		cur=StreamList;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR _cur$[ebp], ecx
$LN2@StopAllStr:

; 2548 : 		while(cur != NULL)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN4@StopAllStr

; 2549 : 		{
; 2550 : 			StreamStop(cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StreamStop@CSoundMgr@@QAEXPAVSoundStream@@@Z ; CSoundMgr::StreamStop

; 2551 : 			cur=cur->Next;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	mov	DWORD PTR _cur$[ebp], ecx

; 2552 : 		}

	jmp	SHORT $LN2@StopAllStr
$LN4@StopAllStr:

; 2553 : 	}
; 2554 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?StopAllStreams@CSoundMgr@@QAEXXZ ENDP			; CSoundMgr::StopAllStreams
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_StreamID$ = 8						; size = 4
?StopStreamWithFade@CSoundMgr@@QAEXJ@Z PROC		; CSoundMgr::StopStreamWithFade
; _this$ = ecx

; 2525 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2526 : 	if(gSoundDriver)

	cmp	DWORD PTR ?gSoundDriver@@3PAVCSoundMgr@@A, 0 ; gSoundDriver
	je	SHORT $LN2@StopStream

; 2527 : 		StreamStopWithFade(FindStream(StreamID));

	mov	eax, DWORD PTR _StreamID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindStream@CSoundMgr@@QAEPAVSoundStream@@J@Z ; CSoundMgr::FindStream
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StreamStopWithFade@CSoundMgr@@QAEXPAVSoundStream@@@Z ; CSoundMgr::StreamStopWithFade
$LN2@StopStream:

; 2528 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?StopStreamWithFade@CSoundMgr@@QAEXJ@Z ENDP		; CSoundMgr::StopStreamWithFade
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_StreamID$ = 8						; size = 4
?StopStream@CSoundMgr@@QAEXJ@Z PROC			; CSoundMgr::StopStream
; _this$ = ecx

; 2519 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2520 : 	if(gSoundDriver)

	cmp	DWORD PTR ?gSoundDriver@@3PAVCSoundMgr@@A, 0 ; gSoundDriver
	je	SHORT $LN2@StopStream

; 2521 : 		StreamStop(FindStream(StreamID));

	mov	eax, DWORD PTR _StreamID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindStream@CSoundMgr@@QAEPAVSoundStream@@J@Z ; CSoundMgr::FindStream
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StreamStop@CSoundMgr@@QAEXPAVSoundStream@@@Z ; CSoundMgr::StreamStop
$LN2@StopStream:

; 2522 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?StopStream@CSoundMgr@@QAEXJ@Z ENDP			; CSoundMgr::StopStream
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_StreamID$ = 8						; size = 4
?ResumeStreamFadeIn@CSoundMgr@@QAEXJ@Z PROC		; CSoundMgr::ResumeStreamFadeIn
; _this$ = ecx

; 2531 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2532 : 	if(gSoundDriver)

	cmp	DWORD PTR ?gSoundDriver@@3PAVCSoundMgr@@A, 0 ; gSoundDriver
	je	SHORT $LN2@ResumeStre

; 2533 : 		StreamResumeFadeIn(FindStream(StreamID));

	mov	eax, DWORD PTR _StreamID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindStream@CSoundMgr@@QAEPAVSoundStream@@J@Z ; CSoundMgr::FindStream
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StreamResumeFadeIn@CSoundMgr@@QAEXPAVSoundStream@@@Z ; CSoundMgr::StreamResumeFadeIn
$LN2@ResumeStre:

; 2534 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ResumeStreamFadeIn@CSoundMgr@@QAEXJ@Z ENDP		; CSoundMgr::ResumeStreamFadeIn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_StreamID$ = 8						; size = 4
?ResumeStream@CSoundMgr@@QAEXJ@Z PROC			; CSoundMgr::ResumeStream
; _this$ = ecx

; 2537 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2538 : 	if(gSoundDriver)

	cmp	DWORD PTR ?gSoundDriver@@3PAVCSoundMgr@@A, 0 ; gSoundDriver
	je	SHORT $LN2@ResumeStre

; 2539 : 		StreamResume(FindStream(StreamID));

	mov	eax, DWORD PTR _StreamID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindStream@CSoundMgr@@QAEPAVSoundStream@@J@Z ; CSoundMgr::FindStream
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StreamResume@CSoundMgr@@QAEXPAVSoundStream@@@Z ; CSoundMgr::StreamResume
$LN2@ResumeStre:

; 2540 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ResumeStream@CSoundMgr@@QAEXJ@Z ENDP			; CSoundMgr::ResumeStream
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_oldvol$ = -16						; size = 4
_hr$ = -12						; size = 4
_this$ = -8						; size = 4
_Stream$ = -4						; size = 4
_ID$ = 8						; size = 4
_Volume$ = 12						; size = 4
?SetStreamVolume@CSoundMgr@@QAEJJJ@Z PROC		; CSoundMgr::SetStreamVolume
; _this$ = ecx

; 2002 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 2003 : 	SoundStream * Stream;
; 2004 : 	HRESULT hr;
; 2005 : 	long oldvol;
; 2006 : 
; 2007 : 	if(gSoundDriver)

	cmp	DWORD PTR ?gSoundDriver@@3PAVCSoundMgr@@A, 0 ; gSoundDriver
	je	SHORT $LN5@SetStreamV

; 2008 : 	{
; 2009 : 		if(DSound)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN5@SetStreamV

; 2010 : 		{
; 2011 : 			Stream=FindStream(ID);

	mov	ecx, DWORD PTR _ID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindStream@CSoundMgr@@QAEPAVSoundStream@@J@Z ; CSoundMgr::FindStream
	mov	DWORD PTR _Stream$[ebp], eax

; 2012 : 			if(Stream != NULL)

	cmp	DWORD PTR _Stream$[ebp], 0
	je	SHORT $LN5@SetStreamV

; 2013 : 			{
; 2014 : 				oldvol=Stream->Volume;

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _oldvol$[ebp], eax

; 2015 : 				Stream->Volume=Volume;

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR _Volume$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 2016 : 				if(!(Stream->Status & (SND_STREAM_FADE_IN|SND_STREAM_FADE_OUT|SND_STREAM_FADEDOUT))){

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	and	ecx, 720896				; 000b0000H
	jne	SHORT $LN2@SetStreamV

; 2017 : 					hr=Stream->DSoundBuffer->SetVolume(Volume);

	mov	edx, DWORD PTR _Volume$[ebp]
	push	edx
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+60]
	call	edx
	mov	DWORD PTR _hr$[ebp], eax

; 2018 : 					if(hr != DS_OK)

	cmp	DWORD PTR _hr$[ebp], 0
	je	SHORT $LN2@SetStreamV

; 2019 : 						DSoundCheck(hr);

	mov	eax, DWORD PTR _hr$[ebp]
	push	eax
	call	?DSoundCheck@CSoundMgr@@SAXJ@Z		; CSoundMgr::DSoundCheck
	add	esp, 4
$LN2@SetStreamV:

; 2020 : 				}
; 2021 : 				return(oldvol);

	mov	eax, DWORD PTR _oldvol$[ebp]
	jmp	SHORT $LN6@SetStreamV
$LN5@SetStreamV:

; 2022 : 			}
; 2023 : 		}
; 2024 : 	}
; 2025 : 	return(DSBVOLUME_MIN);

	mov	eax, -10000				; ffffd8f0H
$LN6@SetStreamV:

; 2026 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetStreamVolume@CSoundMgr@@QAEJJJ@Z ENDP		; CSoundMgr::SetStreamVolume
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_Stream$ = -4						; size = 4
_StreamID$ = 8						; size = 4
_classptr$ = 12						; size = 4
_cb$ = 16						; size = 4
?StartCallbackStream@CSoundMgr@@QAEHJPAXP6AK0PADK@Z@Z PROC ; CSoundMgr::StartCallbackStream
; _this$ = ecx

; 2846 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2847 : 	SoundStream *Stream;
; 2848 : 
; 2849 : 	Stream=FindStream(StreamID);

	mov	eax, DWORD PTR _StreamID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindStream@CSoundMgr@@QAEPAVSoundStream@@J@Z ; CSoundMgr::FindStream
	mov	DWORD PTR _Stream$[ebp], eax

; 2850 : 
; 2851 : 	if(Stream == NULL)

	cmp	DWORD PTR _Stream$[ebp], 0
	jne	SHORT $LN2@StartCallb

; 2852 : 		return(FALSE);

	xor	eax, eax
	jmp	$LN3@StartCallb
$LN2@StartCallb:

; 2853 : 
; 2854 : // Stop previous Stream in Stream
; 2855 : 	if(StreamStatus(Stream) & DSBSTATUS_PLAYING)

	mov	ecx, DWORD PTR _Stream$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StreamStatus@CSoundMgr@@QAEKPAVSoundStream@@@Z ; CSoundMgr::StreamStatus
	and	eax, 1
	je	SHORT $LN1@StartCallb

; 2856 : 	{
; 2857 : 		StreamStop(Stream);

	mov	edx, DWORD PTR _Stream$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StreamStop@CSoundMgr@@QAEXPAVSoundStream@@@Z ; CSoundMgr::StreamStop
$LN1@StartCallb:

; 2858 : 	}
; 2859 : 
; 2860 :     Stream->StreamSize=0;

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [eax+52], 0

; 2861 : 	Stream->OriginalSize=0;

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [ecx+56], 0

; 2862 : 	Stream->BytesProcessed=0;

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [edx+60], 0

; 2863 : 	Stream->LastPos=0;

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [eax+64], 0

; 2864 : 	Stream->memptr=NULL;

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [ecx+84], 0

; 2865 : 	Stream->startptr=NULL;

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [edx+80], 0

; 2866 : 	Stream->me=classptr;

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR _classptr$[ebp]
	mov	DWORD PTR [eax+96], ecx

; 2867 : 	Stream->Callback=cb;

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR _cb$[ebp]
	mov	DWORD PTR [edx+88], eax

; 2868 : 	Stream->Status=1 | SND_STREAM_CALLBACK;

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [ecx+32], 16385		; 00004001H

; 2869 : 	ReadStream(Stream,0,Stream->Size);

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	push	0
	mov	ecx, DWORD PTR _Stream$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadStream@CSoundMgr@@QAEKPAVSoundStream@@KK@Z ; CSoundMgr::ReadStream

; 2870 : 	Stream->DSoundBuffer->SetCurrentPosition(0);

	push	0
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+52]
	call	ecx

; 2871 : 	Stream->Status |= SND_USE_THREAD;

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+32]
	or	eax, 1073741824				; 40000000H
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [ecx+32], eax

; 2872 : 	SetNotification(Stream);

	mov	edx, DWORD PTR _Stream$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetNotification@CSoundMgr@@AAEXPAVSoundStream@@@Z ; CSoundMgr::SetNotification

; 2873 : 	Stream->DSoundBuffer->Play(0,0,DSBPLAY_LOOPING);

	push	1
	push	0
	push	0
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+48]
	call	edx

; 2874 : 	NotifyThread();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?NotifyThread@CSoundMgr@@AAEXXZ		; CSoundMgr::NotifyThread

; 2875 : 
; 2876 : 	return(TRUE);

	mov	eax, 1
$LN3@StartCallb:

; 2877 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?StartCallbackStream@CSoundMgr@@QAEHJPAXP6AK0PADK@Z@Z ENDP ; CSoundMgr::StartCallbackStream
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_size$ = -16						; size = 4
_this$ = -12						; size = 4
_hr$ = -8						; size = 4
_Stream$ = -4						; size = 4
_StreamID$ = 8						; size = 4
_wave$ = 12						; size = 4
_Flags$ = 16						; size = 4
?StartMemoryStream@CSoundMgr@@QAEHJPAURIFF_FILE@@J@Z PROC ; CSoundMgr::StartMemoryStream
; _this$ = ecx

; 2740 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 2741 : 	SoundStream *Stream;
; 2742 : 	HRESULT hr;
; 2743 : 	long size;
; 2744 : 
; 2745 : 	Stream=FindStream(StreamID);

	mov	eax, DWORD PTR _StreamID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindStream@CSoundMgr@@QAEPAVSoundStream@@J@Z ; CSoundMgr::FindStream
	mov	DWORD PTR _Stream$[ebp], eax

; 2746 : 	if(Stream == NULL)

	cmp	DWORD PTR _Stream$[ebp], 0
	jne	SHORT $LN12@StartMemor

; 2747 : 		return(FALSE);

	xor	eax, eax
	jmp	$LN13@StartMemor
$LN12@StartMemor:

; 2748 : 
; 2749 : // Stop previous Stream in Stream
; 2750 : 	if(StreamStatus(Stream) & DSBSTATUS_PLAYING)

	mov	ecx, DWORD PTR _Stream$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StreamStatus@CSoundMgr@@QAEKPAVSoundStream@@@Z ; CSoundMgr::StreamStatus
	and	eax, 1
	je	SHORT $LN11@StartMemor

; 2751 : 	{
; 2752 : 		StreamStop(Stream);

	mov	edx, DWORD PTR _Stream$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StreamStop@CSoundMgr@@QAEXPAVSoundStream@@@Z ; CSoundMgr::StreamStop
$LN11@StartMemor:

; 2753 : 	}
; 2754 : 
; 2755 : 	size=wave->SampleLen;

	mov	eax, DWORD PTR _wave$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _size$[ebp], ecx

; 2756 : 
; 2757 : 	Stream->fp=NULL; // should be closed (if open) by StreamStop()

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [edx+40], 0

; 2758 : 	Stream->StreamSize=0;

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [eax+52], 0

; 2759 : 	Stream->OriginalSize=size;

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR _size$[ebp]
	mov	DWORD PTR [ecx+56], edx

; 2760 : 	Stream->BytesProcessed=0;

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [eax+60], 0

; 2761 : 	Stream->LastPos=0;

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [ecx+64], 0

; 2762 : 	Stream->memptr=NULL;

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [edx+84], 0

; 2763 : 	Stream->startptr=NULL;

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [eax+80], 0

; 2764 : 	Stream->Status=1 | SND_STREAM_MEMORY;

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [ecx+32], 8193		; 00002001H

; 2765 : 	if(wave->Format->wFormatTag == WAVE_FORMAT_IMA_ADPCM)

	mov	edx, DWORD PTR _wave$[ebp]
	mov	eax, DWORD PTR [edx+4]
	movzx	ecx, WORD PTR [eax]
	cmp	ecx, 17					; 00000011H
	jne	$LN10@StartMemor

; 2766 : 	{
; 2767 : 		Stream->Status |= SND_IS_IMAADPCM;

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+32]
	or	eax, 268435456				; 10000000H
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [ecx+32], eax

; 2768 : 		Stream->ImaInfo->sidx=0;

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	DWORD PTR [eax+12], 0

; 2769 : 		Stream->ImaInfo->count=0;

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	xor	eax, eax
	mov	WORD PTR [edx+44], ax

; 2770 : 		Stream->ImaInfo->blockLength=0;

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR [edx+40], 0

; 2771 : 		Stream->ImaInfo->didx=0;

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR [ecx+28], 0

; 2772 : 		Stream->ImaInfo->sreadidx=0; // When ReadStream gets called... read entire buffer size (if -1)

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	DWORD PTR [eax+20], 0

; 2773 : 		Stream->ImaInfo->slen=size;

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR [edx+16], eax

; 2774 : 		Stream->ImaInfo->dlen=wave->NumSamples; // (2 bytes) since we only handle 16bit

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	eax, DWORD PTR _wave$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+32], ecx

; 2775 : 		Stream->ImaInfo->src=wave->Start;

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	ecx, DWORD PTR _wave$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax], edx

; 2776 : 		Stream->ImaInfo->srcsize=size;

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR _size$[ebp]
	mov	DWORD PTR [ecx+24], edx

; 2777 : 	}
; 2778 : 	else

	jmp	SHORT $LN9@StartMemor
$LN10@StartMemor:

; 2779 : 		Stream->Status &= ~SND_IS_IMAADPCM;

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	and	ecx, -268435457				; efffffffH
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [edx+32], ecx
$LN9@StartMemor:

; 2780 : 	if(Flags & SND_STREAM_LOOP)

	mov	eax, DWORD PTR _Flags$[ebp]
	and	eax, 32768				; 00008000H
	je	SHORT $LN8@StartMemor

; 2781 : 		Stream->Status |= SND_STREAM_LOOP;

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	or	edx, 32768				; 00008000H
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [eax+32], edx
$LN8@StartMemor:

; 2782 : 	if(Flags & SND_STREAM_FADE_IN)

	mov	ecx, DWORD PTR _Flags$[ebp]
	and	ecx, 131072				; 00020000H
	je	SHORT $LN7@StartMemor

; 2783 : 	{
; 2784 : 		Stream->Status |= SND_STREAM_FADE_IN;

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+32]
	or	eax, 131072				; 00020000H
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [ecx+32], eax

; 2785 : 		Stream->CurFade=Stream->FadeIn;

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+8], ecx

; 2786 : 	}
; 2787 : 	else

	jmp	SHORT $LN6@StartMemor
$LN7@StartMemor:

; 2788 : 		Stream->CurFade=Stream->Volume;

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx
$LN6@StartMemor:

; 2789 : 	if(Flags & SND_STREAM_FADE_OUT)

	mov	edx, DWORD PTR _Flags$[ebp]
	and	edx, 65536				; 00010000H
	je	SHORT $LN5@StartMemor

; 2790 : 		Stream->FadeOut=DSBVOLUME_MIN;

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [eax+16], -10000		; ffffd8f0H

; 2791 : 	else

	jmp	SHORT $LN4@StartMemor
$LN5@StartMemor:

; 2792 : 		Stream->FadeOut=DSBVOLUME_MAX;

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [ecx+16], 0
$LN4@StartMemor:

; 2793 : 
; 2794 : 	hr=Stream->DSoundBuffer->SetCurrentPosition(0);

	push	0
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+52]
	call	ecx
	mov	DWORD PTR _hr$[ebp], eax

; 2795 : 	if(hr != DS_OK)

	cmp	DWORD PTR _hr$[ebp], 0
	je	SHORT $LN3@StartMemor

; 2796 : 		DSoundCheck(hr);

	mov	edx, DWORD PTR _hr$[ebp]
	push	edx
	call	?DSoundCheck@CSoundMgr@@SAXJ@Z		; CSoundMgr::DSoundCheck
	add	esp, 4
$LN3@StartMemor:

; 2797 : 	SilenceStream(Stream,0,Stream->Size);

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	push	0
	mov	edx, DWORD PTR _Stream$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SilenceStream@CSoundMgr@@QAEXPAVSoundStream@@KK@Z ; CSoundMgr::SilenceStream

; 2798 : 	hr=Stream->DSoundBuffer->SetVolume(Stream->CurFade);

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+60]
	call	ecx
	mov	DWORD PTR _hr$[ebp], eax

; 2799 : 	if(hr != DS_OK)

	cmp	DWORD PTR _hr$[ebp], 0
	je	SHORT $LN2@StartMemor

; 2800 : 		DSoundCheck(hr);

	mov	edx, DWORD PTR _hr$[ebp]
	push	edx
	call	?DSoundCheck@CSoundMgr@@SAXJ@Z		; CSoundMgr::DSoundCheck
	add	esp, 4
$LN2@StartMemor:

; 2801 : 	Stream->StreamSize=0;

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [eax+52], 0

; 2802 : 	ReadStream(Stream,0,Stream->Size);

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	push	0
	mov	eax, DWORD PTR _Stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadStream@CSoundMgr@@QAEKPAVSoundStream@@KK@Z ; CSoundMgr::ReadStream

; 2803 : 	Stream->Status |= SND_USE_THREAD;

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	or	edx, 1073741824				; 40000000H
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [eax+32], edx

; 2804 : 	SetNotification(Stream);

	mov	ecx, DWORD PTR _Stream$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetNotification@CSoundMgr@@AAEXPAVSoundStream@@@Z ; CSoundMgr::SetNotification

; 2805 : 	hr=Stream->DSoundBuffer->Play(0,0,DSBPLAY_LOOPING);

	push	1
	push	0
	push	0
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+48]
	call	ecx
	mov	DWORD PTR _hr$[ebp], eax

; 2806 : 	if(hr != DS_OK)

	cmp	DWORD PTR _hr$[ebp], 0
	je	SHORT $LN1@StartMemor

; 2807 : 		DSoundCheck(hr);

	mov	edx, DWORD PTR _hr$[ebp]
	push	edx
	call	?DSoundCheck@CSoundMgr@@SAXJ@Z		; CSoundMgr::DSoundCheck
	add	esp, 4
$LN1@StartMemor:

; 2808 : 	NotifyThread();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?NotifyThread@CSoundMgr@@AAEXXZ		; CSoundMgr::NotifyThread

; 2809 : 
; 2810 : 	return(TRUE);

	mov	eax, 1
$LN13@StartMemor:

; 2811 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?StartMemoryStream@CSoundMgr@@QAEHJPAURIFF_FILE@@J@Z ENDP ; CSoundMgr::StartMemoryStream
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_Stream$ = -4						; size = 4
_StreamID$ = 8						; size = 4
_Data$ = 12						; size = 4
_size$ = 16						; size = 4
?StartMemoryStream@CSoundMgr@@QAEHJPADJ@Z PROC		; CSoundMgr::StartMemoryStream
; _this$ = ecx

; 2814 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2815 : 	SoundStream *Stream;
; 2816 : 
; 2817 : 	Stream=FindStream(StreamID);

	mov	eax, DWORD PTR _StreamID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindStream@CSoundMgr@@QAEPAVSoundStream@@J@Z ; CSoundMgr::FindStream
	mov	DWORD PTR _Stream$[ebp], eax

; 2818 : 
; 2819 : 	if(Stream == NULL)

	cmp	DWORD PTR _Stream$[ebp], 0
	jne	SHORT $LN2@StartMemor

; 2820 : 		return(FALSE);

	xor	eax, eax
	jmp	$LN3@StartMemor
$LN2@StartMemor:

; 2821 : 
; 2822 : // Stop previous Stream in Stream
; 2823 : 	if(StreamStatus(Stream) & DSBSTATUS_PLAYING)

	mov	ecx, DWORD PTR _Stream$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StreamStatus@CSoundMgr@@QAEKPAVSoundStream@@@Z ; CSoundMgr::StreamStatus
	and	eax, 1
	je	SHORT $LN1@StartMemor

; 2824 : 	{
; 2825 : 		StreamStop(Stream);

	mov	edx, DWORD PTR _Stream$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StreamStop@CSoundMgr@@QAEXPAVSoundStream@@@Z ; CSoundMgr::StreamStop
$LN1@StartMemor:

; 2826 : 	}
; 2827 : 
; 2828 : 	Stream->StreamSize=0;

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [eax+52], 0

; 2829 : 	Stream->OriginalSize=size;

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR _size$[ebp]
	mov	DWORD PTR [ecx+56], edx

; 2830 : 	Stream->BytesProcessed=0;

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [eax+60], 0

; 2831 : 	Stream->LastPos=0;

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [ecx+64], 0

; 2832 : 	Stream->memptr=Data;

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR _Data$[ebp]
	mov	DWORD PTR [edx+84], eax

; 2833 : 	Stream->startptr=Data;

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR _Data$[ebp]
	mov	DWORD PTR [ecx+80], edx

; 2834 : 	Stream->Status=1 | SND_STREAM_MEMORY;

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [eax+32], 8193		; 00002001H

; 2835 : 	ReadStream(Stream,0,Stream->Size);

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	push	0
	mov	eax, DWORD PTR _Stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadStream@CSoundMgr@@QAEKPAVSoundStream@@KK@Z ; CSoundMgr::ReadStream

; 2836 : 	Stream->DSoundBuffer->SetCurrentPosition(0);

	push	0
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+52]
	call	eax

; 2837 : 	Stream->Status |= SND_USE_THREAD;

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	or	edx, 1073741824				; 40000000H
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [eax+32], edx

; 2838 : 	SetNotification(Stream);

	mov	ecx, DWORD PTR _Stream$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetNotification@CSoundMgr@@AAEXPAVSoundStream@@@Z ; CSoundMgr::SetNotification

; 2839 : 	Stream->DSoundBuffer->Play(0,0,DSBPLAY_LOOPING);

	push	1
	push	0
	push	0
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+48]
	call	ecx

; 2840 : 	NotifyThread();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?NotifyThread@CSoundMgr@@AAEXXZ		; CSoundMgr::NotifyThread

; 2841 : 
; 2842 : 	return(TRUE);

	mov	eax, 1
$LN3@StartMemor:

; 2843 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?StartMemoryStream@CSoundMgr@@QAEHJPADJ@Z ENDP		; CSoundMgr::StartMemoryStream
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_NumSamples$ = -44					; size = 4
_size$ = -40						; size = 4
_hr$ = -36						; size = 4
_this$ = -32						; size = 4
_Stream$ = -28						; size = 4
_Header$ = -24						; size = 18
__$ArrayPad$ = -4					; size = 4
_StreamID$ = 8						; size = 4
_filename$ = 12						; size = 4
_Flags$ = 16						; size = 4
_startoffset$ = 20					; size = 4
?StartFileStream@CSoundMgr@@QAEHJPADJJ@Z PROC		; CSoundMgr::StartFileStream
; _this$ = ecx

; 2648 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 2649 : 	SoundStream *Stream;
; 2650 : 	WAVEFORMATEX Header;
; 2651 : 	HRESULT hr;
; 2652 : 	long size,NumSamples;
; 2653 : 
; 2654 : 	Stream=FindStream(StreamID);

	mov	eax, DWORD PTR _StreamID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindStream@CSoundMgr@@QAEPAVSoundStream@@J@Z ; CSoundMgr::FindStream
	mov	DWORD PTR _Stream$[ebp], eax

; 2655 : 	if(Stream == NULL)

	cmp	DWORD PTR _Stream$[ebp], 0
	jne	SHORT $LN15@StartFileS

; 2656 : 		return(FALSE);

	xor	eax, eax
	jmp	$LN16@StartFileS
$LN15@StartFileS:

; 2657 : 
; 2658 : // Stop previous Stream in Stream
; 2659 : 	if(StreamStatus(Stream) & DSBSTATUS_PLAYING)

	mov	ecx, DWORD PTR _Stream$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StreamStatus@CSoundMgr@@QAEKPAVSoundStream@@@Z ; CSoundMgr::StreamStatus
	and	eax, 1
	je	SHORT $LN14@StartFileS

; 2660 : 	{
; 2661 : 		StreamStop(Stream);

	mov	edx, DWORD PTR _Stream$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StreamStop@CSoundMgr@@QAEXPAVSoundStream@@@Z ; CSoundMgr::StreamStop
$LN14@StartFileS:

; 2662 : 	}
; 2663 : 
; 2664 : 	Stream->fp=CreateFile(filename,GENERIC_READ,FILE_SHARE_READ,NULL,
; 2665 : 						  OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL, NULL);

	push	0
	push	128					; 00000080H
	push	3
	push	0
	push	1
	push	-2147483648				; 80000000H
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	DWORD PTR __imp__CreateFileA@28
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [ecx+40], eax

; 2666 : 
; 2667 : 	if(Stream->fp == INVALID_HANDLE_VALUE)

	mov	edx, DWORD PTR _Stream$[ebp]
	cmp	DWORD PTR [edx+40], -1
	jne	SHORT $LN13@StartFileS

; 2668 : 		return(FALSE);

	xor	eax, eax
	jmp	$LN16@StartFileS
$LN13@StartFileS:

; 2669 : 
; 2670 : 	SetFilePointer(Stream->fp,startoffset,NULL,FILE_BEGIN);

	push	0
	push	0
	mov	eax, DWORD PTR _startoffset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	call	DWORD PTR __imp__SetFilePointer@16

; 2671 : 	size=LoadRiffFormat(Stream->fp,&Header,&Stream->HeaderOffset,&NumSamples);

	lea	eax, DWORD PTR _NumSamples$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Stream$[ebp]
	add	ecx, 72					; 00000048H
	push	ecx
	lea	edx, DWORD PTR _Header$[ebp]
	push	edx
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LoadRiffFormat@CSoundMgr@@QAEJPAXPAUtWAVEFORMATEX@@PAJ2@Z ; CSoundMgr::LoadRiffFormat
	mov	DWORD PTR _size$[ebp], eax

; 2672 : 	Stream->HeaderOffset+=startoffset;

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+72]
	add	eax, DWORD PTR _startoffset$[ebp]
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [ecx+72], eax

; 2673 : 
; 2674 : 	if(!size)

	cmp	DWORD PTR _size$[ebp], 0
	jne	SHORT $LN12@StartFileS

; 2675 : 	{
; 2676 : 		CloseHandle(Stream->fp);

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+40]
	push	eax
	call	DWORD PTR __imp__CloseHandle@4

; 2677 : 		Stream->fp=INVALID_HANDLE_VALUE;

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [ecx+40], -1

; 2678 : 		return(FALSE);

	xor	eax, eax
	jmp	$LN16@StartFileS
$LN12@StartFileS:

; 2679 : 	}
; 2680 : 
; 2681 : 	Stream->StreamSize=0;

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [edx+52], 0

; 2682 : 	Stream->OriginalSize=size;

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR _size$[ebp]
	mov	DWORD PTR [eax+56], ecx

; 2683 : 	Stream->BytesProcessed=0;

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [edx+60], 0

; 2684 : 	Stream->LastPos=0;

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [eax+64], 0

; 2685 : 	Stream->memptr=NULL;

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [ecx+84], 0

; 2686 : 	Stream->startptr=NULL;

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [edx+80], 0

; 2687 : 	Stream->Status=1 | SND_STREAM_FILE;

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [eax+32], 4097		; 00001001H

; 2688 : 	if(Header.wFormatTag == WAVE_FORMAT_IMA_ADPCM)

	movzx	ecx, WORD PTR _Header$[ebp]
	cmp	ecx, 17					; 00000011H
	jne	$LN11@StartFileS

; 2689 : 	{
; 2690 : 		Stream->Status |= SND_IS_IMAADPCM;

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+32]
	or	eax, 268435456				; 10000000H
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [ecx+32], eax

; 2691 : 		if(!Stream->ImaInfo)

	mov	edx, DWORD PTR _Stream$[ebp]
	cmp	DWORD PTR [edx+76], 0
	jne	SHORT $LN10@StartFileS

; 2692 : 			return(FALSE);

	xor	eax, eax
	jmp	$LN16@StartFileS
$LN10@StartFileS:

; 2693 : 		Stream->ImaInfo->sidx=0;

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR [ecx+12], 0

; 2694 : 		Stream->ImaInfo->count=0;

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+76]
	xor	ecx, ecx
	mov	WORD PTR [eax+44], cx

; 2695 : 		Stream->ImaInfo->blockLength=0;

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	DWORD PTR [eax+40], 0

; 2696 : 		Stream->ImaInfo->didx=0;

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR [edx+28], 0

; 2697 : 		Stream->ImaInfo->sreadidx=-1; // When ReadStream gets called... read entire buffer size (if -1)

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR [ecx+20], -1

; 2698 : 		Stream->ImaInfo->slen=size;

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	ecx, DWORD PTR _size$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 2699 : 		Stream->ImaInfo->dlen=NumSamples; // (2 bytes) since we only handle 16bit

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	ecx, DWORD PTR _NumSamples$[ebp]
	mov	DWORD PTR [eax+32], ecx

; 2700 : 		Stream->ImaInfo->src=Stream->ImaInfo->srcbuffer;

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [edx], eax

; 2701 : 		Stream->ImaInfo->srcsize=Stream->ImaInfo->bufsize;

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+24], edx

; 2702 : 	}
; 2703 : 	else

	jmp	SHORT $LN9@StartFileS
$LN11@StartFileS:

; 2704 : 		Stream->Status &= ~SND_IS_IMAADPCM;

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	and	ecx, -268435457				; efffffffH
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [edx+32], ecx
$LN9@StartFileS:

; 2705 : 
; 2706 : 	if(Flags & SND_STREAM_LOOP)

	mov	eax, DWORD PTR _Flags$[ebp]
	and	eax, 32768				; 00008000H
	je	SHORT $LN8@StartFileS

; 2707 : 		Stream->Status |= SND_STREAM_LOOP;

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	or	edx, 32768				; 00008000H
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [eax+32], edx
$LN8@StartFileS:

; 2708 : 	if(Flags & SND_STREAM_FADE_IN)

	mov	ecx, DWORD PTR _Flags$[ebp]
	and	ecx, 131072				; 00020000H
	je	SHORT $LN7@StartFileS

; 2709 : 	{
; 2710 : 		Stream->Status |= SND_STREAM_FADE_IN;

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+32]
	or	eax, 131072				; 00020000H
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [ecx+32], eax

; 2711 : 		Stream->CurFade=Stream->FadeIn;

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+8], ecx

; 2712 : 	}
; 2713 : 	else

	jmp	SHORT $LN6@StartFileS
$LN7@StartFileS:

; 2714 : 		Stream->CurFade=Stream->Volume;

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx
$LN6@StartFileS:

; 2715 : 	if(Flags & SND_STREAM_FADE_OUT)

	mov	edx, DWORD PTR _Flags$[ebp]
	and	edx, 65536				; 00010000H
	je	SHORT $LN5@StartFileS

; 2716 : 		Stream->FadeOut=DSBVOLUME_MIN;

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [eax+16], -10000		; ffffd8f0H

; 2717 : 	else

	jmp	SHORT $LN4@StartFileS
$LN5@StartFileS:

; 2718 : 		Stream->FadeOut=Stream->Volume;

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+16], eax
$LN4@StartFileS:

; 2719 : 
; 2720 : 	hr=Stream->DSoundBuffer->SetCurrentPosition(0);

	push	0
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+52]
	call	eax
	mov	DWORD PTR _hr$[ebp], eax

; 2721 : 	if(hr != DS_OK)

	cmp	DWORD PTR _hr$[ebp], 0
	je	SHORT $LN3@StartFileS

; 2722 : 		DSoundCheck(hr);

	mov	ecx, DWORD PTR _hr$[ebp]
	push	ecx
	call	?DSoundCheck@CSoundMgr@@SAXJ@Z		; CSoundMgr::DSoundCheck
	add	esp, 4
$LN3@StartFileS:

; 2723 : 	SilenceStream(Stream,0,Stream->Size);

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	push	0
	mov	ecx, DWORD PTR _Stream$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SilenceStream@CSoundMgr@@QAEXPAVSoundStream@@KK@Z ; CSoundMgr::SilenceStream

; 2724 : 	hr=Stream->DSoundBuffer->SetVolume(Stream->CurFade);

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+60]
	call	eax
	mov	DWORD PTR _hr$[ebp], eax

; 2725 : 	if(hr != DS_OK)

	cmp	DWORD PTR _hr$[ebp], 0
	je	SHORT $LN2@StartFileS

; 2726 : 		DSoundCheck(hr);

	mov	ecx, DWORD PTR _hr$[ebp]
	push	ecx
	call	?DSoundCheck@CSoundMgr@@SAXJ@Z		; CSoundMgr::DSoundCheck
	add	esp, 4
$LN2@StartFileS:

; 2727 : 	Stream->StreamSize=0;

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [edx+52], 0

; 2728 : 	ReadStream(Stream,0,Stream->Size);

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	push	0
	mov	edx, DWORD PTR _Stream$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadStream@CSoundMgr@@QAEKPAVSoundStream@@KK@Z ; CSoundMgr::ReadStream

; 2729 : 	Stream->Status |= SND_USE_THREAD;

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	or	ecx, 1073741824				; 40000000H
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	DWORD PTR [edx+32], ecx

; 2730 : 	SetNotification(Stream);

	mov	eax, DWORD PTR _Stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetNotification@CSoundMgr@@AAEXPAVSoundStream@@@Z ; CSoundMgr::SetNotification

; 2731 : 	hr=Stream->DSoundBuffer->Play(0,0,DSBPLAY_LOOPING);

	push	1
	push	0
	push	0
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+48]
	call	eax
	mov	DWORD PTR _hr$[ebp], eax

; 2732 : 	if(hr != DS_OK)

	cmp	DWORD PTR _hr$[ebp], 0
	je	SHORT $LN1@StartFileS

; 2733 : 		DSoundCheck(hr);

	mov	ecx, DWORD PTR _hr$[ebp]
	push	ecx
	call	?DSoundCheck@CSoundMgr@@SAXJ@Z		; CSoundMgr::DSoundCheck
	add	esp, 4
$LN1@StartFileS:

; 2734 : 	NotifyThread();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?NotifyThread@CSoundMgr@@AAEXXZ		; CSoundMgr::NotifyThread

; 2735 : 
; 2736 : 	return(TRUE);

	mov	eax, 1
$LN16@StartFileS:

; 2737 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?StartFileStream@CSoundMgr@@QAEHJPADJJ@Z ENDP		; CSoundMgr::StartFileStream
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
_Len$ = -12						; size = 4
_mem$ = -8						; size = 4
_hr$ = -4						; size = 4
_Stream$ = 8						; size = 4
_Buffer$ = 12						; size = 4
_Length$ = 16						; size = 4
?SilenceStream@CSoundMgr@@QAEXPAVSoundStream@@KK@Z PROC	; CSoundMgr::SilenceStream
; _this$ = ecx

; 2324 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 2325 : 	char *mem;
; 2326 : 	DWORD Len;
; 2327 : 	HRESULT hr;
; 2328 : 
; 2329 : 	if(gSoundDriver)

	cmp	DWORD PTR ?gSoundDriver@@3PAVCSoundMgr@@A, 0 ; gSoundDriver
	je	$LN6@SilenceStr

; 2330 : 	{
; 2331 : 		if(Stream == NULL)

	cmp	DWORD PTR _Stream$[ebp], 0
	jne	SHORT $LN4@SilenceStr

; 2332 : 			return;

	jmp	$LN6@SilenceStr
$LN4@SilenceStr:

; 2333 : 
; 2334 : 		if(Stream->DSoundBuffer)

	mov	eax, DWORD PTR _Stream$[ebp]
	cmp	DWORD PTR [eax+100], 0
	je	$LN6@SilenceStr

; 2335 : 		{
; 2336 : 			hr=Stream->DSoundBuffer->Lock(Buffer,Length,(void**)&mem,&Len,NULL,NULL,NULL);

	push	0
	push	0
	push	0
	lea	ecx, DWORD PTR _Len$[ebp]
	push	ecx
	lea	edx, DWORD PTR _mem$[ebp]
	push	edx
	mov	eax, DWORD PTR _Length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+44]
	call	ecx
	mov	DWORD PTR _hr$[ebp], eax

; 2337 : 			if(hr == DSERR_BUFFERLOST)

	cmp	DWORD PTR _hr$[ebp], -2005401450	; 88780096H
	jne	SHORT $LN2@SilenceStr

; 2338 : 			{
; 2339 : 				Stream->DSoundBuffer->Restore();

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+80]
	call	ecx

; 2340 : 				hr=Stream->DSoundBuffer->Lock(Buffer,Length,(void**)&mem,&Len,NULL,NULL,NULL);

	push	0
	push	0
	push	0
	lea	edx, DWORD PTR _Len$[ebp]
	push	edx
	lea	eax, DWORD PTR _mem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Length$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Buffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+44]
	call	edx
	mov	DWORD PTR _hr$[ebp], eax
$LN2@SilenceStr:

; 2341 : 			}
; 2342 : 			if(Len && hr == DS_OK)

	cmp	DWORD PTR _Len$[ebp], 0
	je	SHORT $LN6@SilenceStr
	cmp	DWORD PTR _hr$[ebp], 0
	jne	SHORT $LN6@SilenceStr

; 2343 : 			{
; 2344 : 				memset((char *)mem,0,Length);

	mov	eax, DWORD PTR _Length$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _mem$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 2345 : 				Stream->DSoundBuffer->Unlock(mem,Length,NULL,NULL);

	push	0
	push	0
	mov	edx, DWORD PTR _Length$[ebp]
	push	edx
	mov	eax, DWORD PTR _mem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+76]
	call	eax
$LN6@SilenceStr:

; 2346 : 			}
; 2347 : 		}
; 2348 : 	}
; 2349 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SilenceStream@CSoundMgr@@QAEXPAVSoundStream@@KK@Z ENDP	; CSoundMgr::SilenceStream
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
tv75 = -24						; size = 4
$T1 = -20						; size = 4
_Last$ = -16						; size = 4
$T2 = -12						; size = 4
_this$ = -8						; size = 4
_Cur$ = -4						; size = 4
?RemoveAllStreams@CSoundMgr@@QAEXXZ PROC		; CSoundMgr::RemoveAllStreams
; _this$ = ecx

; 2919 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 2920 : 	SoundStream *Cur,*Last;
; 2921 : 
; 2922 : 	if(gSoundDriver == NULL)

	cmp	DWORD PTR ?gSoundDriver@@3PAVCSoundMgr@@A, 0 ; gSoundDriver
	jne	SHORT $LN4@RemoveAllS

; 2923 : 		return;

	jmp	$LN5@RemoveAllS
$LN4@RemoveAllS:

; 2924 : 
; 2925 : 	if(StreamList == NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+36], 0
	jne	SHORT $LN3@RemoveAllS

; 2926 : 		return;

	jmp	SHORT $LN5@RemoveAllS
$LN3@RemoveAllS:

; 2927 : 
; 2928 : 	F4EnterCriticalSection(StreamCSection);

	mov	ecx, DWORD PTR ?StreamCSection@@3PAUF4CSECTIONHANDLE@@A ; StreamCSection
	push	ecx
	call	_F4EnterCriticalSection
	add	esp, 4

; 2929 : 
; 2930 : 	Cur=StreamList;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR _Cur$[ebp], eax
$LN2@RemoveAllS:

; 2931 : 
; 2932 : 	while(Cur != NULL)

	cmp	DWORD PTR _Cur$[ebp], 0
	je	SHORT $LN1@RemoveAllS

; 2933 : 	{
; 2934 : 		Last=Cur;

	mov	ecx, DWORD PTR _Cur$[ebp]
	mov	DWORD PTR _Last$[ebp], ecx

; 2935 : 		Cur=Cur->Next;

	mov	edx, DWORD PTR _Cur$[ebp]
	mov	eax, DWORD PTR [edx+112]
	mov	DWORD PTR _Cur$[ebp], eax

; 2936 : 		delete Last;

	mov	ecx, DWORD PTR _Last$[ebp]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	mov	DWORD PTR $T2[ebp], edx
	cmp	DWORD PTR $T2[ebp], 0
	je	SHORT $LN7@RemoveAllS
	push	1
	mov	ecx, DWORD PTR $T2[ebp]
	call	??_GSoundStream@@QAEPAXI@Z
	mov	DWORD PTR tv75[ebp], eax
	jmp	SHORT $LN8@RemoveAllS
$LN7@RemoveAllS:
	mov	DWORD PTR tv75[ebp], 0
$LN8@RemoveAllS:

; 2937 : 	}

	jmp	SHORT $LN2@RemoveAllS
$LN1@RemoveAllS:

; 2938 : 	StreamList=NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+36], 0

; 2939 : 	F4LeaveCriticalSection(StreamCSection);

	mov	ecx, DWORD PTR ?StreamCSection@@3PAUF4CSECTIONHANDLE@@A ; StreamCSection
	push	ecx
	call	_F4LeaveCriticalSection
	add	esp, 4

; 2940 : 	NotifyThread();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?NotifyThread@CSoundMgr@@AAEXXZ		; CSoundMgr::NotifyThread
$LN5@RemoveAllS:

; 2941 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAllStreams@CSoundMgr@@QAEXXZ ENDP		; CSoundMgr::RemoveAllStreams
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
tv95 = -36						; size = 4
$T1 = -32						; size = 4
tv80 = -28						; size = 4
$T2 = -24						; size = 4
$T3 = -20						; size = 4
$T4 = -16						; size = 4
_Last$ = -12						; size = 4
_this$ = -8						; size = 4
_Cur$ = -4						; size = 4
_ID$ = 8						; size = 4
?RemoveStream@CSoundMgr@@QAEXJ@Z PROC			; CSoundMgr::RemoveStream
; _this$ = ecx

; 2880 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 2881 : 	SoundStream *Cur,*Last;
; 2882 : 
; 2883 : 	if(gSoundDriver == NULL)

	cmp	DWORD PTR ?gSoundDriver@@3PAVCSoundMgr@@A, 0 ; gSoundDriver
	jne	SHORT $LN8@RemoveStre

; 2884 : 		return;

	jmp	$LN9@RemoveStre
$LN8@RemoveStre:

; 2885 : 
; 2886 : 	F4EnterCriticalSection(StreamCSection); // JPO - lock before test!

	mov	eax, DWORD PTR ?StreamCSection@@3PAUF4CSECTIONHANDLE@@A ; StreamCSection
	push	eax
	call	_F4EnterCriticalSection
	add	esp, 4

; 2887 : 	if(StreamList == NULL) {

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+36], 0
	jne	SHORT $LN7@RemoveStre

; 2888 : 	    F4LeaveCriticalSection(StreamCSection);

	mov	edx, DWORD PTR ?StreamCSection@@3PAUF4CSECTIONHANDLE@@A ; StreamCSection
	push	edx
	call	_F4LeaveCriticalSection
	add	esp, 4

; 2889 : 	    return;

	jmp	$LN9@RemoveStre
$LN7@RemoveStre:

; 2890 : 	}
; 2891 : 
; 2892 : 
; 2893 : 	if(StreamList->ID == ID)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR _ID$[ebp]
	jne	SHORT $LN6@RemoveStre

; 2894 : 	{
; 2895 : 		Last=StreamList;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR _Last$[ebp], ecx

; 2896 : 		StreamList=StreamList->Next;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+112]
	mov	DWORD PTR [ecx+36], edx

; 2897 : 		delete Last;

	mov	eax, DWORD PTR _Last$[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T4[ebp], ecx
	cmp	DWORD PTR $T4[ebp], 0
	je	SHORT $LN11@RemoveStre
	push	1
	mov	ecx, DWORD PTR $T4[ebp]
	call	??_GSoundStream@@QAEPAXI@Z
	mov	DWORD PTR tv80[ebp], eax
	jmp	SHORT $LN12@RemoveStre
$LN11@RemoveStre:
	mov	DWORD PTR tv80[ebp], 0
$LN12@RemoveStre:

; 2898 : 	}
; 2899 : 	else

	jmp	SHORT $LN5@RemoveStre
$LN6@RemoveStre:

; 2900 : 	{
; 2901 : 		Cur=StreamList;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR _Cur$[ebp], eax
$LN4@RemoveStre:

; 2902 : 		while(Cur->Next)

	mov	ecx, DWORD PTR _Cur$[ebp]
	cmp	DWORD PTR [ecx+112], 0
	je	SHORT $LN5@RemoveStre

; 2903 : 		{
; 2904 : 			if(Cur->Next->ID == ID)

	mov	edx, DWORD PTR _Cur$[ebp]
	mov	eax, DWORD PTR [edx+112]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _ID$[ebp]
	jne	SHORT $LN2@RemoveStre

; 2905 : 			{
; 2906 : 				Last=Cur->Next;

	mov	edx, DWORD PTR _Cur$[ebp]
	mov	eax, DWORD PTR [edx+112]
	mov	DWORD PTR _Last$[ebp], eax

; 2907 : 				Cur->Next=Cur->Next->Next;

	mov	ecx, DWORD PTR _Cur$[ebp]
	mov	edx, DWORD PTR [ecx+112]
	mov	eax, DWORD PTR _Cur$[ebp]
	mov	ecx, DWORD PTR [edx+112]
	mov	DWORD PTR [eax+112], ecx

; 2908 : 				delete Last;

	mov	edx, DWORD PTR _Last$[ebp]
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR $T3[ebp], eax
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN13@RemoveStre
	push	1
	mov	ecx, DWORD PTR $T3[ebp]
	call	??_GSoundStream@@QAEPAXI@Z
	mov	DWORD PTR tv95[ebp], eax
	jmp	SHORT $LN14@RemoveStre
$LN13@RemoveStre:
	mov	DWORD PTR tv95[ebp], 0
$LN14@RemoveStre:

; 2909 : 			}
; 2910 : 			else

	jmp	SHORT $LN1@RemoveStre
$LN2@RemoveStre:

; 2911 : 				Cur=Cur->Next;

	mov	ecx, DWORD PTR _Cur$[ebp]
	mov	edx, DWORD PTR [ecx+112]
	mov	DWORD PTR _Cur$[ebp], edx
$LN1@RemoveStre:

; 2912 : 		}

	jmp	SHORT $LN4@RemoveStre
$LN5@RemoveStre:

; 2913 : 	}
; 2914 : 	F4LeaveCriticalSection(StreamCSection);

	mov	eax, DWORD PTR ?StreamCSection@@3PAUF4CSECTIONHANDLE@@A ; StreamCSection
	push	eax
	call	_F4LeaveCriticalSection
	add	esp, 4

; 2915 : 	NotifyThread();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?NotifyThread@CSoundMgr@@AAEXXZ		; CSoundMgr::NotifyThread
$LN9@RemoveStre:

; 2916 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?RemoveStream@CSoundMgr@@QAEXJ@Z ENDP			; CSoundMgr::RemoveStream
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_cur$ = -4						; size = 4
_ID$ = 8						; size = 4
_cb$ = 12						; size = 4
?SetMessageCallback@CSoundMgr@@QAEXHP6AXPAVSoundStream@@H@Z@Z PROC ; CSoundMgr::SetMessageCallback
; _this$ = ecx

; 2223 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2224 : 	SoundStream *cur;
; 2225 : 
; 2226 : 	cur=FindStream(ID);

	mov	eax, DWORD PTR _ID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindStream@CSoundMgr@@QAEPAVSoundStream@@J@Z ; CSoundMgr::FindStream
	mov	DWORD PTR _cur$[ebp], eax

; 2227 : 	if(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN2@SetMessage

; 2228 : 		cur->StreamMessage=cb;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _cb$[ebp]
	mov	DWORD PTR [ecx+92], edx
$LN2@SetMessage:

; 2229 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetMessageCallback@CSoundMgr@@QAEXHP6AXPAVSoundStream@@H@Z@Z ENDP ; CSoundMgr::SetMessageCallback
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
tv162 = -72						; size = 8
_NewID$ = -64						; size = 4
tv159 = -60						; size = 4
_lpNewDSBuf$ = -56					; size = 4
_this$ = -52						; size = 4
_Size$ = -48						; size = 4
_hr$ = -44						; size = 4
_dsbdesc$ = -40						; size = 36
__$ArrayPad$ = -4					; size = 4
_Format$ = 8						; size = 4
_StreamSeconds$ = 12					; size = 4
?CreateStream@CSoundMgr@@QAEJPAUtWAVEFORMATEX@@M@Z PROC	; CSoundMgr::CreateStream
; _this$ = ecx

; 1907 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1908 : 	long NewID = SND_NO_HANDLE;

	mov	DWORD PTR _NewID$[ebp], 0

; 1909 : 	DSBUFFERDESC dsbdesc;
; 1910 : 	LPDIRECTSOUNDBUFFER lpNewDSBuf;
; 1911 : 	HRESULT hr;
; 1912 : 	long Size;
; 1913 : 
; 1914 : 	if(gSoundDriver && DSound)

	cmp	DWORD PTR ?gSoundDriver@@3PAVCSoundMgr@@A, 0 ; gSoundDriver
	je	$LN5@CreateStre
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	$LN5@CreateStre

; 1915 : 	{
; 1916 : 		Size = (long)(StreamSeconds * (float)(Format->nSamplesPerSec * (Format->wBitsPerSample / 8) * Format->nChannels));

	mov	ecx, DWORD PTR _Format$[ebp]
	movzx	eax, WORD PTR [ecx+14]
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	mov	edx, DWORD PTR _Format$[ebp]
	imul	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _Format$[ebp]
	movzx	edx, WORD PTR [ecx+2]
	imul	eax, edx
	mov	DWORD PTR tv159[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv159[ebp]
	mov	eax, DWORD PTR tv159[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	movsd	QWORD PTR tv162[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv162[ebp]
	mulss	xmm0, DWORD PTR _StreamSeconds$[ebp]
	cvttss2si ecx, xmm0
	mov	DWORD PTR _Size$[ebp], ecx

; 1917 : 
; 1918 : 		Size=(Size/8)*8;

	mov	eax, DWORD PTR _Size$[ebp]
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	shl	eax, 3
	mov	DWORD PTR _Size$[ebp], eax

; 1919 : 
; 1920 : // Set up DSBUFFERDESC structure.
; 1921 : 		memset(&dsbdesc, 0, sizeof(DSBUFFERDESC)); // Zero it out.

	push	36					; 00000024H
	push	0
	lea	edx, DWORD PTR _dsbdesc$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 1922 : 		dsbdesc.dwSize = sizeof(DSBUFFERDESC);

	mov	DWORD PTR _dsbdesc$[ebp], 36		; 00000024H

; 1923 : 		dsbdesc.dwFlags = DSBCAPS_CTRLPAN | DSBCAPS_CTRLVOLUME | 
; 1924 : 		    DSBCAPS_CTRLFREQUENCY | 
; 1925 : 		    DSBCAPS_GETCURRENTPOSITION2 ; // Need default controls (pan, volume, frequency).

	mov	DWORD PTR _dsbdesc$[ebp+4], 65760	; 000100e0H

; 1926 : 		if (g_bOldSoundAlg == false)

	movzx	eax, BYTE PTR ?g_bOldSoundAlg@@3_NA	; g_bOldSoundAlg
	test	eax, eax
	jne	SHORT $LN4@CreateStre

; 1927 : 		    dsbdesc.dwFlags |= DSBCAPS_CTRLPOSITIONNOTIFY;

	mov	ecx, DWORD PTR _dsbdesc$[ebp+4]
	or	ecx, 256				; 00000100H
	mov	DWORD PTR _dsbdesc$[ebp+4], ecx
$LN4@CreateStre:

; 1928 : 		dsbdesc.dwBufferBytes = Size;

	mov	edx, DWORD PTR _Size$[ebp]
	mov	DWORD PTR _dsbdesc$[ebp+8], edx

; 1929 : 		dsbdesc.lpwfxFormat = Format;

	mov	eax, DWORD PTR _Format$[ebp]
	mov	DWORD PTR _dsbdesc$[ebp+16], eax

; 1930 : 
; 1931 : // OW just to have some music during debugging hehe
; 1932 : #ifdef _DEBUG
; 1933 : 	dsbdesc.dwFlags |= DSBCAPS_GLOBALFOCUS;
; 1934 : #endif
; 1935 : 
; 1936 :     // Create buffer.
; 1937 : 		hr = DSound->CreateSoundBuffer(&dsbdesc, &lpNewDSBuf, NULL);

	push	0
	lea	ecx, DWORD PTR _lpNewDSBuf$[ebp]
	push	ecx
	lea	edx, DWORD PTR _dsbdesc$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+12]
	call	edx
	mov	DWORD PTR _hr$[ebp], eax

; 1938 : 		if(hr != DS_OK)

	cmp	DWORD PTR _hr$[ebp], 0
	je	SHORT $LN3@CreateStre

; 1939 : 			DSoundCheck(hr);

	mov	eax, DWORD PTR _hr$[ebp]
	push	eax
	call	?DSoundCheck@CSoundMgr@@SAXJ@Z		; CSoundMgr::DSoundCheck
	add	esp, 4
$LN3@CreateStre:

; 1940 : 		if(hr == DS_OK)

	cmp	DWORD PTR _hr$[ebp], 0
	jne	SHORT $LN1@CreateStre

; 1941 : 		{
; 1942 : 			NewID=AddStreamToMgr(0,Format,Size,lpNewDSBuf);

	mov	ecx, DWORD PTR _lpNewDSBuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Size$[ebp]
	push	edx
	mov	eax, DWORD PTR _Format$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddStreamToMgr@CSoundMgr@@AAEJJPAUtWAVEFORMATEX@@JPAUIDirectSoundBuffer@@@Z ; CSoundMgr::AddStreamToMgr
	mov	DWORD PTR _NewID$[ebp], eax

; 1943 : 			hr=lpNewDSBuf->SetVolume(DSBVOLUME_MIN);

	push	-10000					; ffffd8f0H
	mov	ecx, DWORD PTR _lpNewDSBuf$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _lpNewDSBuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+60]
	call	ecx
	mov	DWORD PTR _hr$[ebp], eax

; 1944 : 			if(hr != DS_OK)

	cmp	DWORD PTR _hr$[ebp], 0
	je	SHORT $LN1@CreateStre

; 1945 : 				DSoundCheck(hr);

	mov	edx, DWORD PTR _hr$[ebp]
	push	edx
	call	?DSoundCheck@CSoundMgr@@SAXJ@Z		; CSoundMgr::DSoundCheck
	add	esp, 4
$LN1@CreateStre:

; 1946 : 		}
; 1947 : 		return(NewID);

	mov	eax, DWORD PTR _NewID$[ebp]
	jmp	SHORT $LN6@CreateStre
$LN5@CreateStre:

; 1948 : 	}
; 1949 : 	return(SND_NO_HANDLE);

	xor	eax, eax
$LN6@CreateStre:

; 1950 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
?CreateStream@CSoundMgr@@QAEJPAUtWAVEFORMATEX@@M@Z ENDP	; CSoundMgr::CreateStream
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_status$ = -4						; size = 4
_Sample$ = 8						; size = 4
?SampleStatus@CSoundMgr@@QAEKPAVSoundList@@@Z PROC	; CSoundMgr::SampleStatus
; _this$ = ecx

; 1704 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1705 : 	DWORD status;
; 1706 : 
; 1707 : 	if(gSoundDriver)

	cmp	DWORD PTR ?gSoundDriver@@3PAVCSoundMgr@@A, 0 ; gSoundDriver
	je	SHORT $LN2@SampleStat

; 1708 : 	{
; 1709 : 		if(Sample != NULL)

	cmp	DWORD PTR _Sample$[ebp], 0
	je	SHORT $LN2@SampleStat

; 1710 : 		{
; 1711 : 			// if [0] aint playing, then none of them are playing.
; 1712 : 			Sample->Buf[0].DSoundBuffer->GetStatus(&status);

	lea	eax, DWORD PTR _status$[ebp]
	push	eax
	mov	ecx, 56					; 00000038H
	imul	ecx, 0
	mov	edx, DWORD PTR _Sample$[ebp]
	mov	eax, DWORD PTR [edx+ecx+44]
	mov	ecx, 56					; 00000038H
	imul	ecx, 0
	mov	edx, DWORD PTR _Sample$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+44]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	eax, DWORD PTR [edx+36]
	call	eax

; 1713 : 			return(status);

	mov	eax, DWORD PTR _status$[ebp]
	jmp	SHORT $LN3@SampleStat
$LN2@SampleStat:

; 1714 : 		}
; 1715 : 	}
; 1716 : 	return(0);

	xor	eax, eax
$LN3@SampleStat:

; 1717 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SampleStatus@CSoundMgr@@QAEKPAVSoundList@@@Z ENDP	; CSoundMgr::SampleStatus
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_status$ = -16						; size = 4
_this$ = -12						; size = 4
_Sample$ = -8						; size = 4
_i$1 = -4						; size = 4
_ID$ = 8						; size = 4
_UID$ = 12						; size = 4
?IsSamplePlaying@CSoundMgr@@QAEHJH@Z PROC		; CSoundMgr::IsSamplePlaying
; _this$ = ecx

; 969  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 970  : 	SoundList * Sample;
; 971  : 	DWORD status;
; 972  : 
; 973  : 	if(gSoundDriver)

	cmp	DWORD PTR ?gSoundDriver@@3PAVCSoundMgr@@A, 0 ; gSoundDriver
	je	$LN8@IsSamplePl

; 974  : 	{
; 975  : 		if(DSound)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN8@IsSamplePl

; 976  : 		{
; 977  : 			Sample=FindSample(ID);

	mov	ecx, DWORD PTR _ID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindSample@CSoundMgr@@QAEPAVSoundList@@J@Z ; CSoundMgr::FindSample
	mov	DWORD PTR _Sample$[ebp], eax

; 978  : 			
; 979  : 			if(Sample != NULL)

	cmp	DWORD PTR _Sample$[ebp], 0
	je	SHORT $LN8@IsSamplePl

; 980  : 			{
; 981  : 				int i;
; 982  : 
; 983  : 				for(i=0;i<Sample->DS3DBufferCount;i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN5@IsSamplePl
$LN4@IsSamplePl:
	mov	edx, DWORD PTR _i$1[ebp]
	add	edx, 1
	mov	DWORD PTR _i$1[ebp], edx
$LN5@IsSamplePl:
	mov	eax, DWORD PTR _Sample$[ebp]
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR [eax+28]
	jge	SHORT $LN8@IsSamplePl

; 984  : 				{
; 985  : 					if(Sample->Buf[i].uid == UID)

	mov	edx, DWORD PTR _i$1[ebp]
	imul	edx, 56					; 00000038H
	mov	eax, DWORD PTR _Sample$[ebp]
	mov	ecx, DWORD PTR [eax+edx+88]
	cmp	ecx, DWORD PTR _UID$[ebp]
	jne	SHORT $LN2@IsSamplePl

; 986  : 					{
; 987  : 						Sample->Buf[i].DSoundBuffer->GetStatus(&status);

	lea	edx, DWORD PTR _status$[ebp]
	push	edx
	mov	eax, DWORD PTR _i$1[ebp]
	imul	eax, 56					; 00000038H
	mov	ecx, DWORD PTR _Sample$[ebp]
	mov	edx, DWORD PTR [ecx+eax+44]
	mov	eax, DWORD PTR _i$1[ebp]
	imul	eax, 56					; 00000038H
	mov	ecx, DWORD PTR _Sample$[ebp]
	mov	eax, DWORD PTR [ecx+eax+44]
	mov	ecx, DWORD PTR [edx]
	push	eax
	mov	edx, DWORD PTR [ecx+36]
	call	edx

; 988  : 						if(status & DSBSTATUS_PLAYING)

	mov	eax, DWORD PTR _status$[ebp]
	and	eax, 1
	je	SHORT $LN2@IsSamplePl

; 989  : 		 					return(TRUE);

	mov	eax, 1
	jmp	SHORT $LN9@IsSamplePl
$LN2@IsSamplePl:

; 990  : 					}
; 991  : 				}

	jmp	SHORT $LN4@IsSamplePl
$LN8@IsSamplePl:

; 992  : 			}
; 993  : 		}
; 994  : 	}
; 995  : 	return(FALSE);

	xor	eax, eax
$LN9@IsSamplePl:

; 996  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?IsSamplePlaying@CSoundMgr@@QAEHJH@Z ENDP		; CSoundMgr::IsSamplePlaying
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_Volume$ = -12						; size = 4
_this$ = -8						; size = 4
_Sample$ = -4						; size = 4
_ID$ = 8						; size = 4
?GetSampleVolume@CSoundMgr@@QAEHJ@Z PROC		; CSoundMgr::GetSampleVolume
; _this$ = ecx

; 998  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 999  : 	SoundList * Sample;
; 1000 : 	long Volume=DSBVOLUME_MIN;

	mov	DWORD PTR _Volume$[ebp], -10000		; ffffd8f0H

; 1001 : 
; 1002 : 	if(gSoundDriver)

	cmp	DWORD PTR ?gSoundDriver@@3PAVCSoundMgr@@A, 0 ; gSoundDriver
	je	SHORT $LN3@GetSampleV

; 1003 : 	{
; 1004 : 		if(DSound)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN3@GetSampleV

; 1005 : 		{
; 1006 : 			Sample=FindSample(ID);

	mov	ecx, DWORD PTR _ID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindSample@CSoundMgr@@QAEPAVSoundList@@J@Z ; CSoundMgr::FindSample
	mov	DWORD PTR _Sample$[ebp], eax

; 1007 : 			if(Sample != NULL)

	cmp	DWORD PTR _Sample$[ebp], 0
	je	SHORT $LN3@GetSampleV

; 1008 : 				Sample->Buf[0].DSoundBuffer->GetVolume(&Volume);

	lea	edx, DWORD PTR _Volume$[ebp]
	push	edx
	mov	eax, 56					; 00000038H
	imul	eax, 0
	mov	ecx, DWORD PTR _Sample$[ebp]
	mov	edx, DWORD PTR [ecx+eax+44]
	mov	eax, 56					; 00000038H
	imul	eax, 0
	mov	ecx, DWORD PTR _Sample$[ebp]
	mov	eax, DWORD PTR [ecx+eax+44]
	mov	ecx, DWORD PTR [edx]
	push	eax
	mov	edx, DWORD PTR [ecx+24]
	call	edx
$LN3@GetSampleV:

; 1009 : 		}
; 1010 : 	}
; 1011 : 	return(Volume);

	mov	eax, DWORD PTR _Volume$[ebp]

; 1012 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetSampleVolume@CSoundMgr@@QAEHJ@Z ENDP		; CSoundMgr::GetSampleVolume
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AssignSamples@CSoundMgr@@QAEXXZ PROC			; CSoundMgr::AssignSamples
; _this$ = ecx

; 1268 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1269 : #if 0
; 1270 :     SoundList *S;
; 1271 : //    HRESULT hr; // We could check for errors, but wtf would I do?  Pop up a error dialog behind the 3d display like normal?
; 1272 : 
; 1273 : //#define SNDLOG
; 1274 : 
; 1275 : #ifdef SNDLOG
; 1276 : 	FILE *fp;
; 1277 : 
; 1278 : 	if(fp=fopen("sndlog.txt","a+"))
; 1279 : 	{
; 1280 : 		fprintf(fp,"AssignSamples()=========================================\n");
; 1281 : #endif
; 1282 : 
; 1283 : 	
; 1284 : //#define _SNDDBG
; 1285 : 
; 1286 : #ifdef _SNDDBG
; 1287 : 	MonoPrint("AssignSamples()=========================================\n");
; 1288 : #endif
; 1289 : 
; 1290 :     if(gSoundDriver && DSound)
; 1291 :     {
; 1292 : 		S=SampleList;
; 1293 : 		while(S)
; 1294 : 		{
; 1295 : 			{
; 1296 : 				int i;
; 1297 : 
; 1298 : 				for(i=0;i<S->DS3DBufferCount;i++)
; 1299 : 				{
; 1300 : 					if(S->Buf[i].DSoundBuffer)
; 1301 : 					{
; 1302 : 						if(S->Buf[i].distsq>=0)
; 1303 : 						{
; 1304 : #ifdef SNDLOG
; 1305 : 							fprintf(fp,"  Sample ID(%d %s) Buf[%d]  xyz(%.4f %.4f %.4f) | vxyz(%.4f %.4f %.4f) | Pitch(%f) | Vol(%.4f) | UID(%d) | Flags(%08x)\n",
; 1306 : 								S->ID, 
; 1307 : 								(S->Sfx ? S->Sfx->fileName:"none"),
; 1308 : 								i,
; 1309 : 								S->Buf[i].x, S->Buf[i].y, S->Buf[i].z,
; 1310 : 								S->Buf[i].vx, S->Buf[i].vy, S->Buf[i].vz,
; 1311 : 								S->Buf[i].pitch,
; 1312 : 								S->Buf[i].vol,
; 1313 : 								S->Buf[i].uid,
; 1314 : 								S->Flags);
; 1315 : #endif
; 1316 : #ifdef _SNDDBG
; 1317 : 							MonoPrint("%s - %d  Dist(%f)  Pitch(%f)  Vol(%.4f)  UID(%d)  Flags(%08x)\n",
; 1318 : 								(S->Sfx ? S->Sfx->fileName:"none"),
; 1319 : 								i,
; 1320 : 								sqrt(S->Buf[i].distsq),
; 1321 : 								S->Buf[i].pitch,
; 1322 : 								S->Buf[i].vol,
; 1323 : 								S->Buf[i].uid,
; 1324 : 								S->Flags);
; 1325 : #endif
; 1326 : 
; 1327 : 
; 1328 : #ifdef CUSTOM_DOPPLER
; 1329 : 							if(g_bEnableDopplerSound && 
; 1330 : 							   S->Flags & SFX_POS_EXTERN) 
; 1331 : 							{
; 1332 : 								float d1,d2,xx,yy,zz,m;
; 1333 : 								
; 1334 : 								xx=S->Buf[i].x-CamPos.x;
; 1335 : 								yy=S->Buf[i].y-CamPos.y;
; 1336 : 								zz=S->Buf[i].z-CamPos.z;
; 1337 : 								
; 1338 : 								d1=(float)sqrt(xx*xx + yy*yy + zz*zz);
; 1339 : 								
; 1340 : 								xx=(S->Buf[i].x + S->Buf[i].vx) - (CamPos.x + CamVelocity.x);
; 1341 : 								yy=(S->Buf[i].y + S->Buf[i].vy) - (CamPos.y + CamVelocity.y);
; 1342 : 								zz=(S->Buf[i].z + S->Buf[i].vz) - (CamPos.z + CamVelocity.z);
; 1343 : 								
; 1344 : 								d2=(float)sqrt(xx*xx + yy*yy + zz*zz);
; 1345 : 								
; 1346 : 								m = ((d1 - d2) / (1100) ) * g_fSoundDopplerFactor;
; 1347 : 								
; 1348 : 								if(S->Flags & SFX_FLAGS_REVDOP)
; 1349 : 									m=-m;
; 1350 : 								
; 1351 : 								// constrain to +/- mach 1
; 1352 : 								if(m < -1.f)
; 1353 : 								{  
; 1354 : 									m=-1.f;
; 1355 : 								}
; 1356 : 								if(m > 1.f)
; 1357 : 									m = 1.f;
; 1358 : 								m+=1; // range is 0 to 2
; 1359 : 								
; 1360 : 								S->Buf[i].pitch *= m;
; 1361 : 								
; 1362 : 								// lower volume on sounds moving away
; 1363 : 								if(m < 0)
; 1364 : 									S->Buf[i].vol += m * 1000; // m is already negative
; 1365 : 								
; 1366 : 								
; 1367 : 								// prevent the pitch from going below 0
; 1368 : 								if(S->Buf[i].pitch < 0)
; 1369 : 								{
; 1370 : 									S->Buf[i].pitch = 0;
; 1371 : 									S->Buf[i].vol = -10000; // MLR 12/3/2003 - Fixed, to -10000 not 0
; 1372 : 								}	
; 1373 : 							}
; 1374 : #endif
; 1375 : 
; 1376 : 
; 1377 : 							if(S->Buf[i].DSound3dBuffer && S->Buf[i].Is3d)
; 1378 : 							{   // sound is 3d
; 1379 : 								S->Buf[i].DSound3dBuffer->SetMode( DS3DMODE_NORMAL, DS3D_DEFERRED );
; 1380 : #define DISTEFF_THRESHOLD (100 * 100)
; 1381 : 								if(  g_bSoundDistanceEffect                && 
; 1382 : 									S->Buf[i].distsq > DISTEFF_THRESHOLD   &&
; 1383 : 									S->Flags & SFX_POS_LOOPED ) // MLR 12/3/2003 - Only applied to looping sounds
; 1384 : 								{   // sounds lag behind high speed objects
; 1385 : 									// only applied to external sounds
; 1386 : 									float x,y,z;
; 1387 : 									float s;
; 1388 : 									
; 1389 : 									s=(float)((S->Buf[i].distsq - DISTEFF_THRESHOLD) / (1100 * 1100)); // seconds it takes for the sound to get from the object, to the camera.
; 1390 : 									// this had to be fudged a little so that objects real close wouldn't have the effect applied.
; 1391 : 									
; 1392 : 									x=S->Buf[i].x - S->Buf[i].vx * s;
; 1393 : 									y=S->Buf[i].y - S->Buf[i].vy * s;
; 1394 : 									z=S->Buf[i].z - S->Buf[i].vz * s;
; 1395 : 									S->Buf[i].DSound3dBuffer->SetPosition(x, y, z, DS3D_DEFERRED );
; 1396 : 									
; 1397 : 								}
; 1398 : 								else
; 1399 : 								{
; 1400 : 									S->Buf[i].DSound3dBuffer->SetPosition(S->Buf[i].x, S->Buf[i].y, S->Buf[i].z, DS3D_DEFERRED );
; 1401 : 								}
; 1402 : 								
; 1403 : #ifndef CUSTOM_DOPPLER
; 1404 : 								if(g_bEnableDopplerSound)
; 1405 : 								{
; 1406 : 									if(S->Flags & SFX_FLAGS_REVDOP)
; 1407 : 									{
; 1408 : 										S->Buf[i].DSound3dBuffer->SetVelocity(-S->Buf[i].vx, -S->Buf[i].vy, -S->Buf[i].vz, DS3D_DEFERRED );
; 1409 : 									}
; 1410 : 									else
; 1411 : 									{
; 1412 : 										S->Buf[i].DSound3dBuffer->SetVelocity(S->Buf[i].vx, S->Buf[i].vy, S->Buf[i].vz, DS3D_DEFERRED );
; 1413 : 									}
; 1414 : 								}
; 1415 : #endif
; 1416 : 								
; 1417 : 							}
; 1418 : 							else // non-external or non-3d sounds
; 1419 : 							{ 
; 1420 : 								// no 3d buffer == no 3d sound
; 1421 : 								// we have to do volume and panning by hand.
; 1422 : 
; 1423 : 								if(S->Buf[i].DSound3dBuffer)
; 1424 : 								{
; 1425 : 								  S->Buf[i].DSound3dBuffer->SetMode(DS3DMODE_DISABLE, DS3D_DEFERRED);
; 1426 : 								}
; 1427 : 
; 1428 : 								// MLR 12/4/2003 - We shouldn't be messing with internal volume sounds
; 1429 : 								if(S->Flags & SFX_POS_EXTERN &&
; 1430 : 								   S->Buf[i].Is3d )
; 1431 : 								{   // we're here because there's on 3d buffer allocated.
; 1432 : 									// we need to compute the volume by hand to simulate
; 1433 : 									// attenuation over distance.
; 1434 : 
; 1435 : 									float v;
; 1436 : 
; 1437 : 									// scale v from 0 to 1 between min & max dist
; 1438 : 									v=(S->Buf[i].distsq - S->Sfx->min3ddist) / (S->Sfx->maxDistSq - S->Sfx->min3ddist);
; 1439 : 
; 1440 : 									// clamp result
; 1441 : 									if(v<0) v=0; else if(v>1) v=1;
; 1442 : 
; 1443 : #ifdef SNDLOG
; 1444 : 	  							    fprintf(fp,"  v %f  ",v);
; 1445 : #endif
; 1446 : 
; 1447 : 
; 1448 : 
; 1449 : 									// this prolly ain't quite scientifically correct. :)
; 1450 : 									// log(1)  = 0
; 1451 : 									// log(10) = 1
; 1452 :                                     v=(float)log(v*9+1);
; 1453 : 
; 1454 : 									// map v to maxVol -> minVol
; 1455 : 									v=S->Sfx->maxVol - (S->Sfx->maxVol - S->Sfx->minVol) * v;
; 1456 : 									S->Buf[i].vol+=v;
; 1457 : 									if(S->Buf[i].vol<-10000)
; 1458 : 									{
; 1459 : 										S->Buf[i].distsq=-1; // Set to -1 so the sound will be not played/stoped
; 1460 : 										//S->Buf[i].vol=-10000;
; 1461 : 									}
; 1462 : 
; 1463 : 
; 1464 : #ifdef SNDLOG
; 1465 : 	  							    fprintf(fp,"  Computed Vol %f - distsq %f  min3ddist %f  maxDistSq %f\n",S->Buf[i].vol,
; 1466 : 										S->Buf[i].distsq, S->Sfx->min3ddist,S->Sfx->maxDistSq);
; 1467 : #endif
; 1468 : 								}
; 1469 : 								
; 1470 : 							}
; 1471 : 						}
; 1472 : 
; 1473 : 						if(S->Buf[i].distsq>=0) // MLR 12/7/2003 - No need to play sounds that can't be heard
; 1474 : 						{
; 1475 : 							long Frequency;
; 1476 : 							// set up dsoundbuffer
; 1477 : 							if(S->Flags & SFX_FLAGS_FREQ)
; 1478 : 							{
; 1479 : 								Frequency=(long)(S->Frequency * S->Buf[i].pitch);
; 1480 : 
; 1481 : 								Frequency = min ( Frequency, DSBFREQUENCY_MAX);
; 1482 : 								Frequency = max ( DSBFREQUENCY_MIN, Frequency);
; 1483 : 							}
; 1484 : 							else
; 1485 : 							{
; 1486 : 								Frequency=(long)(S->Frequency);
; 1487 : 							}
; 1488 : 
; 1489 : 							// Play the sample
; 1490 : 							if(S->Flags & SFX_POS_LOOPED)
; 1491 : 							{
; 1492 : #ifdef SNDLOG
; 1493 : 								fprintf(fp,"  Playing Looped\n");
; 1494 : #endif
; 1495 : 								// loopy sounds
; 1496 : #ifdef _SNDDBG
; 1497 : 	  							    MonoPrint("    Playing Looped - Vol:%f  Freq:%f", S->Buf[i].vol, Frequency);
; 1498 : #endif
; 1499 : 
; 1500 : 								S->Buf[i].DSoundBuffer->SetFrequency(Frequency); // MLR 12/7/2003 - The freq & vol code was moved here
; 1501 : 								S->Buf[i].DSoundBuffer->SetVolume((long)S->Buf[i].vol);
; 1502 : 								S->Buf[i].DSoundBuffer->Play(0,0,DSBPLAY_LOOPING);
; 1503 : 								S->Buf[i].distsq=-1; // mark buffer as unused for the next go around.
; 1504 : 							}
; 1505 : 							else
; 1506 : 							{   // NON Looped sounds
; 1507 : 								if(g_bSoundDistanceEffect && (S->Flags & SFX_POS_EXTERN))
; 1508 : 								{   // delay external sounds 
; 1509 : 									float time,     // Elapsed time since sound was created.
; 1510 : 										  radiussq; // MLR 12/2/2003 - The radius from the sounds origin that the soundwave is currently at.
; 1511 : 
; 1512 : 									// since sound radiates out in a sphere from the origin, we'll calculate the radius
; 1513 : 									// that the sound has traveled, and see if the camera is inside the sphere.
; 1514 : 									// if the camera is inside, the sound is played.
; 1515 : 									// if not, the sound is delayed.
; 1516 : 
; 1517 : 									time     = (float)((vuxGameTime - S->Buf[i].Timer) / 1000.0 + 1.0); // when time = 1 = 1sec
; 1518 : 									radiussq = (1100 * 1100 * time * time);  // MLR 12/2/2003 - The radius from the sounds origin that the soundwave is currently at.
; 1519 : 
; 1520 : 									float dx,dy,dz;
; 1521 : 									
; 1522 : 									dx=S->Buf[i].x-CamPos.x;
; 1523 : 									dy=S->Buf[i].y-CamPos.y;
; 1524 : 									dz=S->Buf[i].z-CamPos.z;
; 1525 : 
; 1526 : 									S->Buf[i].distsq=dx*dx+dy*dy+dz*dz; // distance from camera to sounds origin
; 1527 : 
; 1528 : 									// it would be more correct to only play the sound if the camera is very 
; 1529 : 									// close to the radius.
; 1530 : 									if(S->Buf[i].distsq < radiussq) // note comparing squared values
; 1531 : 									{
; 1532 : #ifdef _SNDDBG
; 1533 : 	  							    MonoPrint("    Playing NonLooped - Vol:%f  Freq:%f", S->Buf[i].vol, Frequency);
; 1534 : #endif
; 1535 : 
; 1536 : 										S->Buf[i].DSoundBuffer->SetFrequency(Frequency); // MLR 12/7/2003 - The freq & vol code was moved here
; 1537 : 										S->Buf[i].DSoundBuffer->SetVolume((long)S->Buf[i].vol);
; 1538 : 										S->Buf[i].DSoundBuffer->SetCurrentPosition(0);
; 1539 : 										S->Buf[i].DSoundBuffer->Play(0,0,0);
; 1540 : 										S->Buf[i].distsq=-1;
; 1541 : #ifdef SNDLOG
; 1542 : 										fprintf(fp,"  Playing Once\n");
; 1543 : #endif
; 1544 : 									}
; 1545 : 									else
; 1546 : 									{
; 1547 : 										if(S->Buf[i].distsq > S->Sfx->maxDistSq) // MLR 12/2/2003 - Terminate sounds that can't be heard because they've traveled to far.
; 1548 : 										{
; 1549 : 											// the sound has outlasted it's lifespan and could not be heard anymore.
; 1550 : 											S->Buf[i].distsq=-1;
; 1551 : #ifdef SNDLOG
; 1552 : 											fprintf(fp,"  Attenuated to death\n");
; 1553 : #endif
; 1554 : #ifdef _SNDDBG
; 1555 : 	  										MonoPrint("    Killed");
; 1556 : #endif
; 1557 : 
; 1558 : 										}
; 1559 : 										else
; 1560 : 										{
; 1561 : #ifdef _SNDDBG
; 1562 : 	  										MonoPrint("    Playing Delayed");
; 1563 : #endif
; 1564 : 
; 1565 : 											
; 1566 : #ifdef SNDLOG
; 1567 : 											fprintf(fp,"  Delayed Play (distance effect - distsq=%f.4 time=%f.4)\n",	S->Buf[i].distsq ,  time * (1100 * 1100));
; 1568 : #endif
; 1569 : 										}
; 1570 : 									}
; 1571 : 								}
; 1572 : 								else
; 1573 : 								{
; 1574 : #ifdef SNDLOG
; 1575 : 									fprintf(fp,"  Playing Once\n");
; 1576 : #endif
; 1577 : #ifdef _SNDDBG
; 1578 : 	  							    MonoPrint("    Playing Looped - Vol:%f  Freq:%f", S->Buf[i].vol, Frequency);
; 1579 : #endif
; 1580 : 
; 1581 : 									S->Buf[i].DSoundBuffer->SetFrequency(Frequency);		 // MLR 12/22/2003 - added
; 1582 : 									S->Buf[i].DSoundBuffer->SetVolume((long)S->Buf[i].vol);	 // MLR 12/18/2003 - Added this
; 1583 : 									S->Buf[i].DSoundBuffer->SetCurrentPosition(0);
; 1584 : 									S->Buf[i].DSoundBuffer->Play(0,0,0);
; 1585 : 									S->Buf[i].distsq=-1;
; 1586 : 								}
; 1587 : 							}
; 1588 : 						}
; 1589 : 						else
; 1590 : 						{
; 1591 : 							if(S->Flags & SFX_POS_LOOPED && S->Buf[i].distsq==-1) // don't stop non-looping sounds, let them finish on thier own.
; 1592 : 							{
; 1593 : 								// MLR 1/21/2004 - Changed so that the sound is Stop()ed only if distsq is -1
; 1594 : 								//                 which may have been causeing trouble with Direct Sound.
; 1595 : 								//S->Buf[i].DSoundBuffer->SetVolume(-10000);
; 1596 : 								S->Buf[i].DSoundBuffer->Stop();
; 1597 : 								S->Buf[i].distsq=-2; 
; 1598 : 							}
; 1599 : 							else
; 1600 : 							{
; 1601 : 								S->Buf[i].distsq-=1.0;
; 1602 : 							}
; 1603 : 
; 1604 : 						}
; 1605 : 
; 1606 : 					}
; 1607 : 
; 1608 : 				}
; 1609 : 			}
; 1610 : 			S=S->Next;
; 1611 : 		}
; 1612 : 	}
; 1613 : 	
; 1614 : #ifdef SNDLOG
; 1615 : 	fclose(fp);
; 1616 : 	}
; 1617 : #endif
; 1618 : #endif
; 1619 : 	//return(TRUE);
; 1620 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AssignSamples@CSoundMgr@@QAEXXZ ENDP			; CSoundMgr::AssignSamples
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_this$ = -12						; size = 4
_i$1 = -8						; size = 4
_Sample$ = -4						; size = 4
_ID$ = 8						; size = 4
?Disable3dSample@CSoundMgr@@QAEHJ@Z PROC		; CSoundMgr::Disable3dSample
; _this$ = ecx

; 1626 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1627 :     SoundList * Sample;
; 1628 :     if(gSoundDriver && DSound)

	cmp	DWORD PTR ?gSoundDriver@@3PAVCSoundMgr@@A, 0 ; gSoundDriver
	je	SHORT $LN6@Disable3dS
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN6@Disable3dS

; 1629 :     {
; 1630 : 		Sample=FindSample(ID);

	mov	ecx, DWORD PTR _ID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindSample@CSoundMgr@@QAEPAVSoundList@@J@Z ; CSoundMgr::FindSample
	mov	DWORD PTR _Sample$[ebp], eax

; 1631 : 		if(Sample != NULL)

	cmp	DWORD PTR _Sample$[ebp], 0
	je	SHORT $LN6@Disable3dS

; 1632 : 		{
; 1633 : 			if (Sample->is3d == TRUE)

	mov	edx, DWORD PTR _Sample$[ebp]
	cmp	DWORD PTR [edx+36], 1
	jne	SHORT $LN4@Disable3dS

; 1634 : 			{
; 1635 : 				int i;
; 1636 : 
; 1637 : 				for(i=0;i<Sample->DS3DBufferCount;i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN3@Disable3dS
$LN2@Disable3dS:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN3@Disable3dS:
	mov	ecx, DWORD PTR _Sample$[ebp]
	mov	edx, DWORD PTR _i$1[ebp]
	cmp	edx, DWORD PTR [ecx+28]
	jge	SHORT $LN4@Disable3dS

; 1638 : 				{
; 1639 : 					// 
; 1640 : 					//Sample->Buf[i].DSound3dBuffer->SetMode(DS3DMODE_DISABLE, DS3D_DEFERRED);
; 1641 : 				}

	jmp	SHORT $LN2@Disable3dS
$LN4@Disable3dS:

; 1642 : 			}
; 1643 : 			return TRUE;

	mov	eax, 1
	jmp	SHORT $LN7@Disable3dS
$LN6@Disable3dS:

; 1644 : 		}
; 1645 :     }
; 1646 :     return FALSE;

	xor	eax, eax
$LN7@Disable3dS:

; 1647 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Disable3dSample@CSoundMgr@@QAEHJ@Z ENDP		; CSoundMgr::Disable3dSample
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ID$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_z$ = 20						; size = 4
_pitch$ = 24						; size = 4
_vol$ = 28						; size = 4
_vx$ = 32						; size = 4
_vy$ = 36						; size = 4
_vz$ = 40						; size = 4
_dsq$ = 44						; size = 4
_uid$ = 48						; size = 4
_is3d$ = 52						; size = 4
?SetSamplePosition@CSoundMgr@@QAEHJMMMMMMMMMHH@Z PROC	; CSoundMgr::SetSamplePosition
; _this$ = ecx

; 1109 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1110 : 	return 0;

	xor	eax, eax

; 1111 : #if 0
; 1112 :     SoundList * Sample;
; 1113 : 	BOOL rv=FALSE;
; 1114 : 
; 1115 : //#define SNDLOG
; 1116 : #ifdef SNDLOG
; 1117 : 	FILE *fp;
; 1118 : 
; 1119 : 	if(fp=fopen("sndlog.txt","a+"))
; 1120 : 	{
; 1121 : #endif
; 1122 :     if(gSoundDriver && DSound)
; 1123 :     {
; 1124 : 		if(Sample=FindSample(ID))
; 1125 : 		{			
; 1126 : 			int i;
; 1127 : #ifdef SNDLOG
; 1128 : 			fprintf(fp,"SSP - ID(%d %s) xyz(%.2f,%.2f,%.2f) dxyz(%.2f,%.2f,%.2f) pit(%.2f) vol(%.2f) dist(%.2f) uid(%d)\n",
; 1129 : 			ID,
; 1130 : 			(Sample->Sfx ? Sample->Sfx->fileName:"none"),
; 1131 : 			x,y,z,vx,vy,vz,pitch,vol,dsq,uid);
; 1132 : #endif
; 1133 : 
; 1134 : 
; 1135 : 			// we have to handle looped and non looped sounds a little differently
; 1136 : 			//if(Sample->Flags & SND_LOOP_SAMPLE)
; 1137 : 			if(Sample->Flags & SFX_POS_LOOPED)
; 1138 : 			{
; 1139 : 				for(i=0;i<Sample->DS3DBufferCount;i++)
; 1140 : 				{
; 1141 : 					if(Sample->Buf[i].uid==uid)
; 1142 : 					{
; 1143 : 						Sample->Buf[i].x=x;
; 1144 : 						Sample->Buf[i].y=y;
; 1145 : 						Sample->Buf[i].z=z;
; 1146 : 						Sample->Buf[i].vx=vx;
; 1147 : 						Sample->Buf[i].vy=vy;
; 1148 : 						Sample->Buf[i].vz=vz;
; 1149 : 						Sample->Buf[i].distsq=dsq;
; 1150 : 						Sample->Buf[i].vol=vol;
; 1151 : 						Sample->Buf[i].pitch=pitch;
; 1152 : 						// Sample->Buf[best].uid=uid; // not needed
; 1153 : 						Sample->Buf[i].Timer=vuxGameTime;
; 1154 : 						Sample->Buf[i].Is3d=is3d;
; 1155 : 
; 1156 : 						rv=TRUE;
; 1157 : 						
; 1158 : #ifdef SNDLOG
; 1159 : 						fprintf(fp,"  updated buffer %d (dsq=%f)\n",i,dsq);
; 1160 : #endif
; 1161 : 						break;
; 1162 : 						
; 1163 : 					}
; 1164 : 				}
; 1165 : 
; 1166 : 				if(!rv) // didn't match a uid
; 1167 : 				{
; 1168 : 					int i, best=-1;
; 1169 : 					float  bestdist=(float)0;
; 1170 : 					
; 1171 : 					// run thru the Positional data, if the new sound is closer than one of the others,
; 1172 : 					// then replace one of them 
; 1173 : 					// replace the one that's farthest out.
; 1174 : 					for(i=0;i<Sample->DS3DBufferCount;i++)
; 1175 : 					{
; 1176 : 						//float dist=Sample->Buf[i].distsq - dsq;
; 1177 : 						// if the buffers distance is farther, dist will be positive
; 1178 : 
; 1179 : 						if(Sample->Buf[i].distsq < 0)
; 1180 : 						{	// unused buffer found
; 1181 : 							best=i;
; 1182 : 							break; // leave now
; 1183 : 						}
; 1184 : 
; 1185 : 						if(Sample->Buf[i].distsq > dsq) 
; 1186 : 						{	// new sound call is closer
; 1187 : 							if(Sample->Buf[i].distsq > bestdist)
; 1188 : 							{   // this Buf[i] is that farthest away, canidate for replacement.
; 1189 : 								best=i;
; 1190 : 								bestdist=Sample->Buf[i].distsq;
; 1191 : 							}
; 1192 : 						}
; 1193 : 
; 1194 : 					}
; 1195 : 					if(best>=0)
; 1196 : 					{
; 1197 : 	#ifdef SNDLOG
; 1198 : 						fprintf(fp,"  assigned to buffer %d (dsq=%f)\n",best,dsq);
; 1199 : 	#endif
; 1200 : 						Sample->Buf[best].x=x;
; 1201 : 						Sample->Buf[best].y=y;
; 1202 : 						Sample->Buf[best].z=z;
; 1203 : 						Sample->Buf[best].vx=vx;
; 1204 : 						Sample->Buf[best].vy=vy;
; 1205 : 						Sample->Buf[best].vz=vz;
; 1206 : 						Sample->Buf[best].distsq=dsq;
; 1207 : 						Sample->Buf[best].vol=vol;
; 1208 : 						Sample->Buf[best].pitch=pitch;
; 1209 : 						Sample->Buf[best].uid=uid;
; 1210 : 						Sample->Buf[best].Timer=vuxGameTime;
; 1211 : 						Sample->Buf[best].Is3d=is3d;
; 1212 : 
; 1213 : 						rv=TRUE;
; 1214 : 						//return(TRUE);	
; 1215 : 					}
; 1216 : 				}
; 1217 : 			}
; 1218 : 			else 
; 1219 : 			{ // non looped
; 1220 : 				// move to next buffer
; 1221 : 
; 1222 : 				Sample->Cur3dBuffer=0;
; 1223 : 
; 1224 : 				if(Sample->Cur3dBuffer>Sample->DS3DBufferCount)
; 1225 : 				{
; 1226 : 					Sample->Cur3dBuffer=0;
; 1227 : 				}
; 1228 : 
; 1229 : #ifdef SNDLOG
; 1230 : 						fprintf(fp,"  NONLOOPED - assigned to buffer %d (dsq=%f)\n",Sample->Cur3dBuffer,dsq);
; 1231 : #endif
; 1232 : 
; 1233 : 				Sample->Buf[Sample->Cur3dBuffer].x=x;
; 1234 : 				Sample->Buf[Sample->Cur3dBuffer].y=y;
; 1235 : 				Sample->Buf[Sample->Cur3dBuffer].z=z;
; 1236 : 				Sample->Buf[Sample->Cur3dBuffer].vx=vx;
; 1237 : 				Sample->Buf[Sample->Cur3dBuffer].vy=vy;
; 1238 : 				Sample->Buf[Sample->Cur3dBuffer].vz=vz;
; 1239 : 				Sample->Buf[Sample->Cur3dBuffer].distsq=dsq;
; 1240 : 				Sample->Buf[Sample->Cur3dBuffer].vol=vol;
; 1241 : 				Sample->Buf[Sample->Cur3dBuffer].pitch=pitch;
; 1242 : 				Sample->Buf[Sample->Cur3dBuffer].uid=uid;
; 1243 : 				Sample->Buf[Sample->Cur3dBuffer].Timer=vuxGameTime;
; 1244 : 				Sample->Buf[Sample->Cur3dBuffer].Is3d=is3d;
; 1245 : 
; 1246 : 				rv=TRUE;
; 1247 : 			}
; 1248 : 		}
; 1249 :     }
; 1250 : 	
; 1251 : #ifdef SNDLOG
; 1252 : 	fclose(fp);
; 1253 : 	}
; 1254 : #endif
; 1255 : 
; 1256 : 
; 1257 :     return(rv);
; 1258 : #endif
; 1259 : }

	mov	esp, ebp
	pop	ebp
	ret	48					; 00000030H
?SetSamplePosition@CSoundMgr@@QAEHJMMMMMMMMMHH@Z ENDP	; CSoundMgr::SetSamplePosition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_hr$ = -12						; size = 4
_this$ = -8						; size = 4
_Sample$ = -4						; size = 4
_ID$ = 8						; size = 4
_Direction$ = 12					; size = 4
?SetSamplePan@CSoundMgr@@QAEHJJ@Z PROC			; CSoundMgr::SetSamplePan
; _this$ = ecx

; 1650 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1651 : 	SoundList * Sample;
; 1652 : 	HRESULT hr;
; 1653 : 
; 1654 : 	if(gSoundDriver)

	cmp	DWORD PTR ?gSoundDriver@@3PAVCSoundMgr@@A, 0 ; gSoundDriver
	je	SHORT $LN4@SetSampleP

; 1655 : 	{
; 1656 : 		if(DSound)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN4@SetSampleP

; 1657 : 		{
; 1658 : 			Sample=FindSample(ID);

	mov	ecx, DWORD PTR _ID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindSample@CSoundMgr@@QAEPAVSoundList@@J@Z ; CSoundMgr::FindSample
	mov	DWORD PTR _Sample$[ebp], eax

; 1659 : 			if(Sample != NULL)

	cmp	DWORD PTR _Sample$[ebp], 0
	je	SHORT $LN4@SetSampleP

; 1660 : 			{
; 1661 : 				hr=Sample->Buf[0].DSoundBuffer->SetPan(Direction);

	mov	edx, DWORD PTR _Direction$[ebp]
	push	edx
	mov	eax, 56					; 00000038H
	imul	eax, 0
	mov	ecx, DWORD PTR _Sample$[ebp]
	mov	edx, DWORD PTR [ecx+eax+44]
	mov	eax, 56					; 00000038H
	imul	eax, 0
	mov	ecx, DWORD PTR _Sample$[ebp]
	mov	eax, DWORD PTR [ecx+eax+44]
	mov	ecx, DWORD PTR [edx]
	push	eax
	mov	edx, DWORD PTR [ecx+64]
	call	edx
	mov	DWORD PTR _hr$[ebp], eax

; 1662 : 				if(hr != DS_OK)

	cmp	DWORD PTR _hr$[ebp], 0
	je	SHORT $LN1@SetSampleP

; 1663 : 					DSoundCheck(hr);

	mov	eax, DWORD PTR _hr$[ebp]
	push	eax
	call	?DSoundCheck@CSoundMgr@@SAXJ@Z		; CSoundMgr::DSoundCheck
	add	esp, 4
$LN1@SetSampleP:

; 1664 : 				return(TRUE);

	mov	eax, 1
	jmp	SHORT $LN5@SetSampleP
$LN4@SetSampleP:

; 1665 : 			}
; 1666 : 		}
; 1667 : 	}
; 1668 : 	return(FALSE);

	xor	eax, eax
$LN5@SetSampleP:

; 1669 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetSamplePan@CSoundMgr@@QAEHJJ@Z ENDP			; CSoundMgr::SetSamplePan
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_hr$ = -12						; size = 4
_this$ = -8						; size = 4
_Sample$ = -4						; size = 4
_ID$ = 8						; size = 4
_Volume$ = 12						; size = 4
?SetSampleVolume@CSoundMgr@@QAEHJJ@Z PROC		; CSoundMgr::SetSampleVolume
; _this$ = ecx

; 1015 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1016 : 	SoundList * Sample;
; 1017 : 	HRESULT hr;
; 1018 : 
; 1019 : 	if(gSoundDriver)

	cmp	DWORD PTR ?gSoundDriver@@3PAVCSoundMgr@@A, 0 ; gSoundDriver
	je	SHORT $LN4@SetSampleV

; 1020 : 	{
; 1021 : 		if(DSound)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN4@SetSampleV

; 1022 : 		{
; 1023 : 			Sample=FindSample(ID);

	mov	ecx, DWORD PTR _ID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindSample@CSoundMgr@@QAEPAVSoundList@@J@Z ; CSoundMgr::FindSample
	mov	DWORD PTR _Sample$[ebp], eax

; 1024 : 			if(Sample != NULL)

	cmp	DWORD PTR _Sample$[ebp], 0
	je	SHORT $LN4@SetSampleV

; 1025 : 			{
; 1026 : 				//Sample->Volume=Volume;
; 1027 : 				//if (Sample->is3d == FALSE) {
; 1028 : 				    hr=Sample->Buf[0].DSoundBuffer->SetVolume(Volume);

	mov	edx, DWORD PTR _Volume$[ebp]
	push	edx
	mov	eax, 56					; 00000038H
	imul	eax, 0
	mov	ecx, DWORD PTR _Sample$[ebp]
	mov	edx, DWORD PTR [ecx+eax+44]
	mov	eax, 56					; 00000038H
	imul	eax, 0
	mov	ecx, DWORD PTR _Sample$[ebp]
	mov	eax, DWORD PTR [ecx+eax+44]
	mov	ecx, DWORD PTR [edx]
	push	eax
	mov	edx, DWORD PTR [ecx+60]
	call	edx
	mov	DWORD PTR _hr$[ebp], eax

; 1029 : 				    if(hr != DS_OK)

	cmp	DWORD PTR _hr$[ebp], 0
	je	SHORT $LN1@SetSampleV

; 1030 : 					DSoundCheck(hr);

	mov	eax, DWORD PTR _hr$[ebp]
	push	eax
	call	?DSoundCheck@CSoundMgr@@SAXJ@Z		; CSoundMgr::DSoundCheck
	add	esp, 4
$LN1@SetSampleV:

; 1031 : 				//}
; 1032 : 				return(TRUE);

	mov	eax, 1
	jmp	SHORT $LN5@SetSampleV
$LN4@SetSampleV:

; 1033 : 			}
; 1034 : 		}
; 1035 : 	}
; 1036 : 	return(FALSE);

	xor	eax, eax
$LN5@SetSampleV:

; 1037 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetSampleVolume@CSoundMgr@@QAEHJJ@Z ENDP		; CSoundMgr::SetSampleVolume
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ID$ = 8						; size = 4
_NewPitch$ = 12						; size = 4
?SetSamplePitch@CSoundMgr@@QAEHJM@Z PROC		; CSoundMgr::SetSamplePitch
; _this$ = ecx

; 944  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 945  : 	/*
; 946  : 	SoundList * Sample;
; 947  : 	long Frequency;
; 948  : 
; 949  : 	if(gSoundDriver)
; 950  : 	{
; 951  : 		if(DSound)
; 952  : 		{
; 953  : 			Sample=FindSample(ID);
; 954  : 			if(Sample != NULL)
; 955  : 			{
; 956  : 				Frequency=(long)(Sample->Frequency * NewPitch);
; 957  :             Frequency = min ( max (DSBFREQUENCY_MIN, Frequency), DSBFREQUENCY_MAX);
; 958  : 				Sample->Buf[0].DSoundBuffer->SetFrequency(Frequency);
; 959  : 				return(TRUE);
; 960  : 			}
; 961  : 		}
; 962  : 	}
; 963  : 	return(FALSE);
; 964  : 	*/
; 965  : 	return(TRUE);

	mov	eax, 1

; 966  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetSamplePitch@CSoundMgr@@QAEHJM@Z ENDP		; CSoundMgr::SetSamplePitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_Cur$ = -4						; size = 4
?StopAllSamples@CSoundMgr@@QAEHXZ PROC			; CSoundMgr::StopAllSamples
; _this$ = ecx

; 921  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 922  : SoundList *Cur;
; 923  : 
; 924  : 	Cur=SampleList;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR _Cur$[ebp], ecx
$LN4@StopAllSam:

; 925  : 
; 926  : 	while(Cur != NULL)

	cmp	DWORD PTR _Cur$[ebp], 0
	je	SHORT $LN3@StopAllSam

; 927  : 	{
; 928  : 		StopSample (Cur->ID);

	mov	edx, DWORD PTR _Cur$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StopSample@CSoundMgr@@QAEHJ@Z		; CSoundMgr::StopSample

; 929  : 		Cur=Cur->Next;

	mov	ecx, DWORD PTR _Cur$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR _Cur$[ebp], edx

; 930  : 	}

	jmp	SHORT $LN4@StopAllSam
$LN3@StopAllSam:

; 931  : 
; 932  : 	Cur=DuplicateList;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _Cur$[ebp], ecx
$LN2@StopAllSam:

; 933  : 
; 934  : 	while(Cur != NULL)

	cmp	DWORD PTR _Cur$[ebp], 0
	je	SHORT $LN1@StopAllSam

; 935  : 	{
; 936  : 		StopSample (Cur->ID);

	mov	edx, DWORD PTR _Cur$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StopSample@CSoundMgr@@QAEHJ@Z		; CSoundMgr::StopSample

; 937  : 		Cur=Cur->Next;

	mov	ecx, DWORD PTR _Cur$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR _Cur$[ebp], edx

; 938  : 	}

	jmp	SHORT $LN2@StopAllSam
$LN1@StopAllSam:

; 939  : 
; 940  : 	return(TRUE);

	mov	eax, 1

; 941  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?StopAllSamples@CSoundMgr@@QAEHXZ ENDP			; CSoundMgr::StopAllSamples
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_this$ = -12						; size = 4
_Sample$ = -8						; size = 4
_i$1 = -4						; size = 4
_ID$ = 8						; size = 4
?StopSample@CSoundMgr@@QAEHJ@Z PROC			; CSoundMgr::StopSample
; _this$ = ecx

; 898  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 899  : 	SoundList * Sample;
; 900  : 
; 901  : 	if(gSoundDriver)

	cmp	DWORD PTR ?gSoundDriver@@3PAVCSoundMgr@@A, 0 ; gSoundDriver
	je	SHORT $LN7@StopSample

; 902  : 	{
; 903  : 		if(DSound)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN7@StopSample

; 904  : 		{
; 905  : 			Sample=FindSample(ID);

	mov	ecx, DWORD PTR _ID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindSample@CSoundMgr@@QAEPAVSoundList@@J@Z ; CSoundMgr::FindSample
	mov	DWORD PTR _Sample$[ebp], eax

; 906  : 			if(Sample != NULL)

	cmp	DWORD PTR _Sample$[ebp], 0
	je	SHORT $LN7@StopSample

; 907  : 			{
; 908  : 				for(int i=0;i<Sample->DS3DBufferCount;i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@StopSample
$LN3@StopSample:
	mov	edx, DWORD PTR _i$1[ebp]
	add	edx, 1
	mov	DWORD PTR _i$1[ebp], edx
$LN4@StopSample:
	mov	eax, DWORD PTR _Sample$[ebp]
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR [eax+28]
	jge	SHORT $LN2@StopSample

; 909  : 				{
; 910  : 					if(Sample->Buf[i].DSoundBuffer)

	mov	edx, DWORD PTR _i$1[ebp]
	imul	edx, 56					; 00000038H
	mov	eax, DWORD PTR _Sample$[ebp]
	cmp	DWORD PTR [eax+edx+44], 0
	je	SHORT $LN1@StopSample

; 911  : 						Sample->Buf[i].DSoundBuffer->Stop();

	mov	ecx, DWORD PTR _i$1[ebp]
	imul	ecx, 56					; 00000038H
	mov	edx, DWORD PTR _Sample$[ebp]
	mov	eax, DWORD PTR [edx+ecx+44]
	mov	ecx, DWORD PTR _i$1[ebp]
	imul	ecx, 56					; 00000038H
	mov	edx, DWORD PTR _Sample$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+44]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	eax, DWORD PTR [edx+72]
	call	eax
$LN1@StopSample:

; 912  : 				}

	jmp	SHORT $LN3@StopSample
$LN2@StopSample:

; 913  : 				return(TRUE);

	mov	eax, 1
	jmp	SHORT $LN8@StopSample
$LN7@StopSample:

; 914  : 			}
; 915  : 		}
; 916  : 	}
; 917  : 	return(FALSE);

	xor	eax, eax
$LN8@StopSample:

; 918  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?StopSample@CSoundMgr@@QAEHJ@Z ENDP			; CSoundMgr::StopSample
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
_hr$ = -12						; size = 4
_i$1 = -8						; size = 4
_Sample$ = -4						; size = 4
_ID$ = 8						; size = 4
_Flags$ = 12						; size = 4
?PlaySample@CSoundMgr@@QAEHJJ@Z PROC			; CSoundMgr::PlaySample
; _this$ = ecx

; 833  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 834  : 	SoundList * Sample;
; 835  : 	HRESULT hr;
; 836  : 	if(gSoundDriver)

	cmp	DWORD PTR ?gSoundDriver@@3PAVCSoundMgr@@A, 0 ; gSoundDriver
	je	$LN7@PlaySample

; 837  : 	{
; 838  : 		if(DSound)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	$LN7@PlaySample

; 839  : 		{
; 840  : 			Sample=FindSample(ID);

	mov	ecx, DWORD PTR _ID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindSample@CSoundMgr@@QAEPAVSoundList@@J@Z ; CSoundMgr::FindSample
	mov	DWORD PTR _Sample$[ebp], eax

; 841  : 			if(Sample != NULL)

	cmp	DWORD PTR _Sample$[ebp], 0
	je	$LN7@PlaySample

; 842  : 			{
; 843  : 				/*
; 844  : 				if(IsSamplePlaying(ID,0) && !(Flags & SND_OVERRIDE))
; 845  : 				{
; 846  : 					if(Sample->Flags & SND_EXCLUSIVE)
; 847  : 						return(FALSE);
; 848  : 
; 849  : 					//Sample=AddDuplicateSample(Sample);
; 850  : 
; 851  : 					// only play first sample;
; 852  : 					int i=0; //for(int i=0;i<Sample->DS3DBufferCount;i++)
; 853  : 					{
; 854  : 						if(Sample->Buf[i].DSoundBuffer)
; 855  : 						{
; 856  : 							Sample->Buf[i].DSoundBuffer->SetCurrentPosition(0);
; 857  : 							
; 858  : 							if(Flags & SND_LOOP_SAMPLE)
; 859  : 								hr = Sample->Buf[i].DSoundBuffer->Play(0,0,DSBPLAY_LOOPING);
; 860  : 							else
; 861  : 								hr = Sample->Buf[i].DSoundBuffer->Play(0,0,0);
; 862  : 							if (FAILED(hr))
; 863  : 							DSoundCheck(hr);
; 864  : 						}
; 865  : 					}
; 866  : 
; 867  : 					return(TRUE);
; 868  : 				}
; 869  : 				else */
; 870  : 				{
; 871  : 					//if(Flags & SND_EXCLUSIVE)
; 872  : 					//	Sample->Flags = SND_EXCLUSIVE;
; 873  : 					// only play 1st sample
; 874  : 					int i=0; //for(int i=0;i<Sample->DS3DBufferCount;i++)

	mov	DWORD PTR _i$1[ebp], 0

; 875  : 					{
; 876  : 						if(Sample->Buf[i].DSoundBuffer)

	mov	edx, DWORD PTR _i$1[ebp]
	imul	edx, 56					; 00000038H
	mov	eax, DWORD PTR _Sample$[ebp]
	cmp	DWORD PTR [eax+edx+44], 0
	je	$LN4@PlaySample

; 877  : 						{
; 878  : 							Sample->Buf[i].DSoundBuffer->SetCurrentPosition(0);

	push	0
	mov	ecx, DWORD PTR _i$1[ebp]
	imul	ecx, 56					; 00000038H
	mov	edx, DWORD PTR _Sample$[ebp]
	mov	eax, DWORD PTR [edx+ecx+44]
	mov	ecx, DWORD PTR _i$1[ebp]
	imul	ecx, 56					; 00000038H
	mov	edx, DWORD PTR _Sample$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+44]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	eax, DWORD PTR [edx+52]
	call	eax

; 879  : 							//if(Flags & SND_LOOP_SAMPLE)
; 880  : 							if(Flags & SFX_POS_LOOPED)

	mov	ecx, DWORD PTR _Flags$[ebp]
	and	ecx, 2
	je	SHORT $LN3@PlaySample

; 881  : 								hr = Sample->Buf[i].DSoundBuffer->Play(0,0,DSBPLAY_LOOPING);

	push	1
	push	0
	push	0
	mov	edx, DWORD PTR _i$1[ebp]
	imul	edx, 56					; 00000038H
	mov	eax, DWORD PTR _Sample$[ebp]
	mov	ecx, DWORD PTR [eax+edx+44]
	mov	edx, DWORD PTR _i$1[ebp]
	imul	edx, 56					; 00000038H
	mov	eax, DWORD PTR _Sample$[ebp]
	mov	edx, DWORD PTR [eax+edx+44]
	mov	eax, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR [eax+48]
	call	ecx
	mov	DWORD PTR _hr$[ebp], eax

; 882  : 							else

	jmp	SHORT $LN2@PlaySample
$LN3@PlaySample:

; 883  : 								hr = Sample->Buf[i].DSoundBuffer->Play(0,0,0);

	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _i$1[ebp]
	imul	edx, 56					; 00000038H
	mov	eax, DWORD PTR _Sample$[ebp]
	mov	ecx, DWORD PTR [eax+edx+44]
	mov	edx, DWORD PTR _i$1[ebp]
	imul	edx, 56					; 00000038H
	mov	eax, DWORD PTR _Sample$[ebp]
	mov	edx, DWORD PTR [eax+edx+44]
	mov	eax, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR [eax+48]
	call	ecx
	mov	DWORD PTR _hr$[ebp], eax
$LN2@PlaySample:

; 884  : 							if (FAILED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN4@PlaySample

; 885  : 								DSoundCheck(hr);

	mov	edx, DWORD PTR _hr$[ebp]
	push	edx
	call	?DSoundCheck@CSoundMgr@@SAXJ@Z		; CSoundMgr::DSoundCheck
	add	esp, 4
$LN4@PlaySample:

; 886  : 						}
; 887  : 					}
; 888  : 					return(TRUE);

	mov	eax, 1
	jmp	SHORT $LN8@PlaySample
$LN7@PlaySample:

; 889  : 				}
; 890  : 			}
; 891  : 		}
; 892  : 	}
; 893  : 	return(FALSE);

	xor	eax, eax
$LN8@PlaySample:

; 894  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?PlaySample@CSoundMgr@@QAEHJJ@Z ENDP			; CSoundMgr::PlaySample
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
tv84 = -36						; size = 4
$T1 = -32						; size = 4
tv73 = -28						; size = 4
$T2 = -24						; size = 4
$T3 = -20						; size = 4
$T4 = -16						; size = 4
_Last$ = -12						; size = 4
_this$ = -8						; size = 4
_Cur$ = -4						; size = 4
?RemoveAllSamples@CSoundMgr@@QAEXXZ PROC		; CSoundMgr::RemoveAllSamples
; _this$ = ecx

; 804  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 805  : 	SoundList *Cur, *Last;
; 806  : 	if (SampleList == NULL){

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+28], 0
	jne	SHORT $LN6@RemoveAllS

; 807  : 		return;

	jmp	$LN7@RemoveAllS
$LN6@RemoveAllS:

; 808  : 	}
; 809  : 
; 810  : 	Cur=SampleList;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR _Cur$[ebp], edx
$LN5@RemoveAllS:

; 811  : 	while (Cur != NULL){

	cmp	DWORD PTR _Cur$[ebp], 0
	je	SHORT $LN4@RemoveAllS

; 812  : 		Last=Cur;

	mov	eax, DWORD PTR _Cur$[ebp]
	mov	DWORD PTR _Last$[ebp], eax

; 813  : 		Cur=Cur->Next;

	mov	ecx, DWORD PTR _Cur$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR _Cur$[ebp], edx

; 814  : 		delete Last;

	mov	eax, DWORD PTR _Last$[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T4[ebp], ecx
	cmp	DWORD PTR $T4[ebp], 0
	je	SHORT $LN9@RemoveAllS
	push	1
	mov	ecx, DWORD PTR $T4[ebp]
	call	??_GSoundList@@QAEPAXI@Z
	mov	DWORD PTR tv73[ebp], eax
	jmp	SHORT $LN10@RemoveAllS
$LN9@RemoveAllS:
	mov	DWORD PTR tv73[ebp], 0
$LN10@RemoveAllS:

; 815  : 	}

	jmp	SHORT $LN5@RemoveAllS
$LN4@RemoveAllS:

; 816  : 	SampleList=NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+28], 0

; 817  : 	if (DuplicateList == NULL){

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+32], 0
	jne	SHORT $LN3@RemoveAllS

; 818  : 		return;

	jmp	SHORT $LN7@RemoveAllS
$LN3@RemoveAllS:

; 819  : 	}
; 820  : 
; 821  : 	Cur=DuplicateList;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR _Cur$[ebp], edx
$LN2@RemoveAllS:

; 822  : 	while (Cur != NULL){

	cmp	DWORD PTR _Cur$[ebp], 0
	je	SHORT $LN1@RemoveAllS

; 823  : 		Last=Cur;

	mov	eax, DWORD PTR _Cur$[ebp]
	mov	DWORD PTR _Last$[ebp], eax

; 824  : 		Cur=Cur->Next;

	mov	ecx, DWORD PTR _Cur$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR _Cur$[ebp], edx

; 825  : 		delete Last;

	mov	eax, DWORD PTR _Last$[ebp]
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR $T3[ebp], ecx
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN11@RemoveAllS
	push	1
	mov	ecx, DWORD PTR $T3[ebp]
	call	??_GSoundList@@QAEPAXI@Z
	mov	DWORD PTR tv84[ebp], eax
	jmp	SHORT $LN12@RemoveAllS
$LN11@RemoveAllS:
	mov	DWORD PTR tv84[ebp], 0
$LN12@RemoveAllS:

; 826  : 	}

	jmp	SHORT $LN2@RemoveAllS
$LN1@RemoveAllS:

; 827  : 	DuplicateList=NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32], 0
$LN7@RemoveAllS:

; 828  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAllSamples@CSoundMgr@@QAEXXZ ENDP		; CSoundMgr::RemoveAllSamples
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
tv88 = -36						; size = 4
$T1 = -32						; size = 4
tv77 = -28						; size = 4
$T2 = -24						; size = 4
$T3 = -20						; size = 4
$T4 = -16						; size = 4
_Last$ = -12						; size = 4
_this$ = -8						; size = 4
_Cur$ = -4						; size = 4
_ID$ = 8						; size = 4
?RemoveDuplicateSample@CSoundMgr@@QAEXJ@Z PROC		; CSoundMgr::RemoveDuplicateSample
; _this$ = ecx

; 766  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 767  : 	SoundList *Cur,*Last;
; 768  : 
; 769  : 	if(gSoundDriver)

	cmp	DWORD PTR ?gSoundDriver@@3PAVCSoundMgr@@A, 0 ; gSoundDriver
	je	$LN10@RemoveDupl

; 770  : 	{
; 771  : 		if(DuplicateList == NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+32], 0
	jne	SHORT $LN8@RemoveDupl

; 772  : 			return;

	jmp	$LN10@RemoveDupl
$LN8@RemoveDupl:

; 773  : 
; 774  : 		Cur=DuplicateList;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR _Cur$[ebp], edx
$LN7@RemoveDupl:

; 775  : 
; 776  : 		while(Cur != NULL)

	cmp	DWORD PTR _Cur$[ebp], 0
	je	SHORT $LN6@RemoveDupl

; 777  : 		{
; 778  : 			if(Cur->ID == ID)

	mov	eax, DWORD PTR _Cur$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _ID$[ebp]
	jne	SHORT $LN5@RemoveDupl

; 779  : 			{
; 780  : 				DuplicateList=Cur->Next;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _Cur$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR [edx+32], ecx

; 781  : 				delete Cur;

	mov	edx, DWORD PTR _Cur$[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T4[ebp], eax
	cmp	DWORD PTR $T4[ebp], 0
	je	SHORT $LN12@RemoveDupl
	push	1
	mov	ecx, DWORD PTR $T4[ebp]
	call	??_GSoundList@@QAEPAXI@Z
	mov	DWORD PTR tv77[ebp], eax
	jmp	SHORT $LN13@RemoveDupl
$LN12@RemoveDupl:
	mov	DWORD PTR tv77[ebp], 0
$LN13@RemoveDupl:

; 782  : 				Cur=DuplicateList;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR _Cur$[ebp], edx

; 783  : 			}
; 784  : 			else

	jmp	SHORT $LN4@RemoveDupl
$LN5@RemoveDupl:

; 785  : 				break;

	jmp	SHORT $LN6@RemoveDupl
$LN4@RemoveDupl:

; 786  : 		}

	jmp	SHORT $LN7@RemoveDupl
$LN6@RemoveDupl:

; 787  : 
; 788  : 		Last=Cur;

	mov	eax, DWORD PTR _Cur$[ebp]
	mov	DWORD PTR _Last$[ebp], eax
$LN3@RemoveDupl:

; 789  : 		while(Cur != NULL)

	cmp	DWORD PTR _Cur$[ebp], 0
	je	SHORT $LN10@RemoveDupl

; 790  : 		{
; 791  : 			if(Cur->ID == ID)

	mov	ecx, DWORD PTR _Cur$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR _ID$[ebp]
	jne	SHORT $LN1@RemoveDupl

; 792  : 			{
; 793  : 				Last->Next=Cur->Next;

	mov	eax, DWORD PTR _Last$[ebp]
	mov	ecx, DWORD PTR _Cur$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR [eax+100], edx

; 794  : 				delete Cur;

	mov	eax, DWORD PTR _Cur$[ebp]
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR $T3[ebp], ecx
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN14@RemoveDupl
	push	1
	mov	ecx, DWORD PTR $T3[ebp]
	call	??_GSoundList@@QAEPAXI@Z
	mov	DWORD PTR tv88[ebp], eax
	jmp	SHORT $LN15@RemoveDupl
$LN14@RemoveDupl:
	mov	DWORD PTR tv88[ebp], 0
$LN15@RemoveDupl:

; 795  : 				Cur=Last;

	mov	edx, DWORD PTR _Last$[ebp]
	mov	DWORD PTR _Cur$[ebp], edx
$LN1@RemoveDupl:

; 796  : 			}
; 797  : 			Last=Cur;

	mov	eax, DWORD PTR _Cur$[ebp]
	mov	DWORD PTR _Last$[ebp], eax

; 798  : 			Cur=Cur->Next;

	mov	ecx, DWORD PTR _Cur$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR _Cur$[ebp], edx

; 799  : 		}

	jmp	SHORT $LN3@RemoveDupl
$LN10@RemoveDupl:

; 800  : 	}
; 801  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?RemoveDuplicateSample@CSoundMgr@@QAEXJ@Z ENDP		; CSoundMgr::RemoveDuplicateSample
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
tv88 = -36						; size = 4
$T1 = -32						; size = 4
tv77 = -28						; size = 4
$T2 = -24						; size = 4
$T3 = -20						; size = 4
$T4 = -16						; size = 4
_Last$ = -12						; size = 4
_this$ = -8						; size = 4
_Cur$ = -4						; size = 4
_ID$ = 8						; size = 4
?RemoveSample@CSoundMgr@@QAEXJ@Z PROC			; CSoundMgr::RemoveSample
; _this$ = ecx

; 728  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 729  : 	SoundList *Cur,*Last;
; 730  : 
; 731  : 	if(gSoundDriver)

	cmp	DWORD PTR ?gSoundDriver@@3PAVCSoundMgr@@A, 0 ; gSoundDriver
	je	$LN10@RemoveSamp

; 732  : 	{
; 733  : 		if(SampleList == NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+28], 0
	jne	SHORT $LN8@RemoveSamp

; 734  : 			return;

	jmp	$LN10@RemoveSamp
$LN8@RemoveSamp:

; 735  : 
; 736  : 		Cur=SampleList;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR _Cur$[ebp], edx
$LN7@RemoveSamp:

; 737  : 
; 738  : 		while(Cur != NULL)

	cmp	DWORD PTR _Cur$[ebp], 0
	je	SHORT $LN6@RemoveSamp

; 739  : 		{
; 740  : 			if(Cur->ID == ID)

	mov	eax, DWORD PTR _Cur$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _ID$[ebp]
	jne	SHORT $LN5@RemoveSamp

; 741  : 			{
; 742  : 				SampleList=Cur->Next;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _Cur$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR [edx+28], ecx

; 743  : 				delete Cur;

	mov	edx, DWORD PTR _Cur$[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T4[ebp], eax
	cmp	DWORD PTR $T4[ebp], 0
	je	SHORT $LN12@RemoveSamp
	push	1
	mov	ecx, DWORD PTR $T4[ebp]
	call	??_GSoundList@@QAEPAXI@Z
	mov	DWORD PTR tv77[ebp], eax
	jmp	SHORT $LN13@RemoveSamp
$LN12@RemoveSamp:
	mov	DWORD PTR tv77[ebp], 0
$LN13@RemoveSamp:

; 744  : 				Cur=SampleList;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR _Cur$[ebp], edx

; 745  : 			}
; 746  : 			else

	jmp	SHORT $LN4@RemoveSamp
$LN5@RemoveSamp:

; 747  : 				break;

	jmp	SHORT $LN6@RemoveSamp
$LN4@RemoveSamp:

; 748  : 		}

	jmp	SHORT $LN7@RemoveSamp
$LN6@RemoveSamp:

; 749  : 
; 750  : 		Last=Cur;

	mov	eax, DWORD PTR _Cur$[ebp]
	mov	DWORD PTR _Last$[ebp], eax
$LN3@RemoveSamp:

; 751  : 		while(Cur != NULL)

	cmp	DWORD PTR _Cur$[ebp], 0
	je	SHORT $LN10@RemoveSamp

; 752  : 		{
; 753  : 			if(Cur->ID == ID)

	mov	ecx, DWORD PTR _Cur$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR _ID$[ebp]
	jne	SHORT $LN1@RemoveSamp

; 754  : 			{
; 755  : 				Last->Next=Cur->Next;

	mov	eax, DWORD PTR _Last$[ebp]
	mov	ecx, DWORD PTR _Cur$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR [eax+100], edx

; 756  : 				delete Cur;

	mov	eax, DWORD PTR _Cur$[ebp]
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR $T3[ebp], ecx
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN14@RemoveSamp
	push	1
	mov	ecx, DWORD PTR $T3[ebp]
	call	??_GSoundList@@QAEPAXI@Z
	mov	DWORD PTR tv88[ebp], eax
	jmp	SHORT $LN15@RemoveSamp
$LN14@RemoveSamp:
	mov	DWORD PTR tv88[ebp], 0
$LN15@RemoveSamp:

; 757  : 				Cur=Last;

	mov	edx, DWORD PTR _Last$[ebp]
	mov	DWORD PTR _Cur$[ebp], edx
$LN1@RemoveSamp:

; 758  : 			}
; 759  : 			Last=Cur;

	mov	eax, DWORD PTR _Cur$[ebp]
	mov	DWORD PTR _Last$[ebp], eax

; 760  : 			Cur=Cur->Next;

	mov	ecx, DWORD PTR _Cur$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR _Cur$[ebp], edx

; 761  : 		}

	jmp	SHORT $LN3@RemoveSamp
$LN10@RemoveSamp:

; 762  : 	}
; 763  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?RemoveSample@CSoundMgr@@QAEXJ@Z ENDP			; CSoundMgr::RemoveSample
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_hr$ = -64						; size = 4
_Len$ = -60						; size = 4
_mem$ = -56						; size = 4
_NewID$ = -52						; size = 4
_this$ = -48						; size = 4
_lpNewDSBuf$ = -44					; size = 4
_dsbdesc$ = -40						; size = 36
__$ArrayPad$ = -4					; size = 4
_Header$ = 8						; size = 4
_Data$ = 12						; size = 4
_size$ = 16						; size = 4
_Flags$ = 20						; size = 4
?AddRawSample@CSoundMgr@@QAEJPAUtWAVEFORMATEX@@PADJJ@Z PROC ; CSoundMgr::AddRawSample
; _this$ = ecx

; 692  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 693  : 	long NewID = SND_NO_HANDLE;

	mov	DWORD PTR _NewID$[ebp], 0

; 694  : 	DWORD Len;
; 695  : 	char *mem;
; 696  : 	DSBUFFERDESC dsbdesc;
; 697  : 	LPDIRECTSOUNDBUFFER lpNewDSBuf;
; 698  : 	HRESULT hr;
; 699  : 
; 700  : 	if(gSoundDriver)

	cmp	DWORD PTR ?gSoundDriver@@3PAVCSoundMgr@@A, 0 ; gSoundDriver
	je	$LN3@AddRawSamp

; 701  : 	{
; 702  : // Set up DSBUFFERDESC structure.
; 703  : 		memset(&dsbdesc, 0, sizeof(DSBUFFERDESC)); // Zero it out.

	push	36					; 00000024H
	push	0
	lea	eax, DWORD PTR _dsbdesc$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 704  : 		dsbdesc.dwSize = sizeof(DSBUFFERDESC);

	mov	DWORD PTR _dsbdesc$[ebp], 36		; 00000024H

; 705  : 		dsbdesc.dwFlags = DSBCAPS_CTRLPAN | DSBCAPS_CTRLVOLUME | 
; 706  : 		    DSBCAPS_CTRLFREQUENCY | 
; 707  : 		    DSBCAPS_GETCURRENTPOSITION2 ; // Need default controls (pan, volume, frequency).

	mov	DWORD PTR _dsbdesc$[ebp+4], 65760	; 000100e0H

; 708  : 		if (g_bOldSoundAlg == false)

	movzx	ecx, BYTE PTR ?g_bOldSoundAlg@@3_NA	; g_bOldSoundAlg
	test	ecx, ecx
	jne	SHORT $LN2@AddRawSamp

; 709  : 		    dsbdesc.dwFlags |= DSBCAPS_CTRLPOSITIONNOTIFY;

	mov	edx, DWORD PTR _dsbdesc$[ebp+4]
	or	edx, 256				; 00000100H
	mov	DWORD PTR _dsbdesc$[ebp+4], edx
$LN2@AddRawSamp:

; 710  : 		dsbdesc.dwBufferBytes = size;

	mov	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _dsbdesc$[ebp+8], eax

; 711  : 		dsbdesc.lpwfxFormat = Header;

	mov	ecx, DWORD PTR _Header$[ebp]
	mov	DWORD PTR _dsbdesc$[ebp+16], ecx

; 712  : 
; 713  : 	// Create buffer.
; 714  : 		hr = DSound->CreateSoundBuffer(&dsbdesc, &lpNewDSBuf, NULL);

	push	0
	lea	edx, DWORD PTR _lpNewDSBuf$[ebp]
	push	edx
	lea	eax, DWORD PTR _dsbdesc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _hr$[ebp], eax

; 715  : 		if(hr == DS_OK)

	cmp	DWORD PTR _hr$[ebp], 0
	jne	SHORT $LN1@AddRawSamp

; 716  : 		{
; 717  : 			lpNewDSBuf->Lock(0,size,(void**)&mem,&Len,NULL,NULL,NULL);

	push	0
	push	0
	push	0
	lea	ecx, DWORD PTR _Len$[ebp]
	push	ecx
	lea	edx, DWORD PTR _mem$[ebp]
	push	edx
	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpNewDSBuf$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _lpNewDSBuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+44]
	call	ecx

; 718  : 			memcpy(mem,Data,size);

	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	mov	eax, DWORD PTR _Data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mem$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 719  : 			lpNewDSBuf->Unlock(mem,Len,NULL,NULL);

	push	0
	push	0
	mov	edx, DWORD PTR _Len$[ebp]
	push	edx
	mov	eax, DWORD PTR _mem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNewDSBuf$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _lpNewDSBuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+76]
	call	ecx

; 720  : 			NewID=AddSampleToMgr(100,Header->nSamplesPerSec,0,lpNewDSBuf,Flags, NULL);

	push	0
	mov	edx, DWORD PTR _Flags$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNewDSBuf$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _Header$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	push	100					; 00000064H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddSampleToMgr@CSoundMgr@@AAEJJJJPAUIDirectSoundBuffer@@JPAUSfxDef@@@Z ; CSoundMgr::AddSampleToMgr
	mov	DWORD PTR _NewID$[ebp], eax
$LN1@AddRawSamp:

; 721  : 		}
; 722  : 		return(NewID);

	mov	eax, DWORD PTR _NewID$[ebp]
	jmp	SHORT $LN4@AddRawSamp
$LN3@AddRawSamp:

; 723  : 	}
; 724  : 	return(SND_NO_HANDLE);

	xor	eax, eax
$LN4@AddRawSamp:

; 725  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?AddRawSample@CSoundMgr@@QAEJPAUtWAVEFORMATEX@@PADJJ@Z ENDP ; CSoundMgr::AddRawSample
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_NewID$ = -92						; size = 4
$T1 = -88						; size = 4
$T2 = -84						; size = 4
$T3 = -80						; size = 4
$T4 = -76						; size = 4
$T5 = -72						; size = 4
$T6 = -68						; size = 4
_mem$ = -64						; size = 4
_hr$ = -60						; size = 4
_Len$ = -56						; size = 4
_this$ = -52						; size = 4
_lpNewDSBuf$ = -48					; size = 4
_newsnd$ = -44						; size = 4
_dsbdesc$ = -40						; size = 36
__$ArrayPad$ = -4					; size = 4
_Filename$ = 8						; size = 4
_sfx$ = 12						; size = 4
?LoadWaveFile@CSoundMgr@@QAEPAUIDirectSoundBuffer@@PADPAUSfxDef@@@Z PROC ; CSoundMgr::LoadWaveFile
; _this$ = ecx

; 3364 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 3365 : 	char *mem;
; 3366 : 	RIFF_FILE *newsnd;
; 3367 : 	long NewID = SND_NO_HANDLE;

	mov	DWORD PTR _NewID$[ebp], 0

; 3368 : 	DSBUFFERDESC dsbdesc;
; 3369 : 	LPDIRECTSOUNDBUFFER lpNewDSBuf;
; 3370 : 	DWORD Len;
; 3371 : 	HRESULT hr;
; 3372 : 
; 3373 : 	if(gSoundDriver)

	cmp	DWORD PTR ?gSoundDriver@@3PAVCSoundMgr@@A, 0 ; gSoundDriver
	je	$LN14@LoadWaveFi

; 3374 : 	{
; 3375 : 		newsnd=LoadRiff(Filename);

	mov	eax, DWORD PTR _Filename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LoadRiff@CSoundMgr@@QAEPAURIFF_FILE@@PAD@Z ; CSoundMgr::LoadRiff
	mov	DWORD PTR _newsnd$[ebp], eax

; 3376 : 		if(newsnd)

	cmp	DWORD PTR _newsnd$[ebp], 0
	je	$LN14@LoadWaveFi

; 3377 : 		{
; 3378 : 			if(!newsnd->Format)

	mov	ecx, DWORD PTR _newsnd$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN12@LoadWaveFi

; 3379 : 			{
; 3380 : 				if(newsnd->data)

	mov	edx, DWORD PTR _newsnd$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN11@LoadWaveFi

; 3381 : 					delete newsnd->data;

	mov	eax, DWORD PTR _newsnd$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T6[ebp], ecx
	mov	edx, DWORD PTR $T6[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN11@LoadWaveFi:

; 3382 : 				delete newsnd;

	mov	eax, DWORD PTR _newsnd$[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 3383 : 				return(0);

	xor	eax, eax
	jmp	$LN15@LoadWaveFi
$LN12@LoadWaveFi:

; 3384 : 			}
; 3385 : 			if(newsnd->Format->wFormatTag == WAVE_FORMAT_PCM)

	mov	edx, DWORD PTR _newsnd$[ebp]
	mov	eax, DWORD PTR [edx+4]
	movzx	ecx, WORD PTR [eax]
	cmp	ecx, 1
	jne	$LN10@LoadWaveFi

; 3386 : 			{
; 3387 : 				memset(&dsbdesc, 0, sizeof(DSBUFFERDESC)); // Zero it out.

	push	36					; 00000024H
	push	0
	lea	edx, DWORD PTR _dsbdesc$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 3388 : 				dsbdesc.dwSize = sizeof(DSBUFFERDESC);

	mov	DWORD PTR _dsbdesc$[ebp], 36		; 00000024H

; 3389 : 				
; 3390 : 				dsbdesc.dwFlags = DSBCAPS_CTRLVOLUME | 
; 3391 : 									DSBCAPS_GETCURRENTPOSITION2;

	mov	DWORD PTR _dsbdesc$[ebp+4], 65664	; 00010080H

; 3392 : 										
; 3393 : 				//if (g_bOldSoundAlg == false)
; 3394 : 				// 	dsbdesc.dwFlags |= DSBCAPS_CTRLPOSITIONNOTIFY;
; 3395 : 				
; 3396 : 				if(g_bUse3dSound && (sfx->flags & SFX_FLAGS_3D)) 

	movzx	eax, BYTE PTR ?g_bUse3dSound@@3_NA	; g_bUse3dSound
	test	eax, eax
	je	SHORT $LN9@LoadWaveFi
	mov	ecx, DWORD PTR _sfx$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	and	edx, 16					; 00000010H
	je	SHORT $LN9@LoadWaveFi

; 3397 : 				{
; 3398 : 					dsbdesc.dwFlags |= DSBCAPS_CTRL3D | DSBCAPS_MUTE3DATMAXDISTANCE;

	mov	eax, DWORD PTR _dsbdesc$[ebp+4]
	or	eax, 131088				; 00020010H
	mov	DWORD PTR _dsbdesc$[ebp+4], eax

; 3399 : 				}
; 3400 : 				else

	jmp	SHORT $LN8@LoadWaveFi
$LN9@LoadWaveFi:

; 3401 : 				{
; 3402 : 					if (sfx->flags & SFX_FLAGS_PAN) 

	mov	ecx, DWORD PTR _sfx$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	and	edx, 64					; 00000040H
	je	SHORT $LN8@LoadWaveFi

; 3403 : 						dsbdesc.dwFlags |= DSBCAPS_CTRLPAN;

	mov	eax, DWORD PTR _dsbdesc$[ebp+4]
	or	eax, 64					; 00000040H
	mov	DWORD PTR _dsbdesc$[ebp+4], eax
$LN8@LoadWaveFi:

; 3404 : 				}
; 3405 : 				
; 3406 : 				if (sfx->flags & SFX_FLAGS_FREQ) 

	mov	ecx, DWORD PTR _sfx$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	and	edx, 32					; 00000020H
	je	SHORT $LN6@LoadWaveFi

; 3407 : 					dsbdesc.dwFlags |= DSBCAPS_CTRLFREQUENCY;

	mov	eax, DWORD PTR _dsbdesc$[ebp+4]
	or	eax, 32					; 00000020H
	mov	DWORD PTR _dsbdesc$[ebp+4], eax
$LN6@LoadWaveFi:

; 3408 : 				
; 3409 : 				if ((sfx->flags & SFX_FLAGS_HIGH) == 0) // low priority sound

	mov	ecx, DWORD PTR _sfx$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	and	edx, 128				; 00000080H
	jne	SHORT $LN5@LoadWaveFi

; 3410 : 					dsbdesc.dwFlags |= DSBCAPS_LOCDEFER;

	mov	eax, DWORD PTR _dsbdesc$[ebp+4]
	or	eax, 262144				; 00040000H
	mov	DWORD PTR _dsbdesc$[ebp+4], eax
$LN5@LoadWaveFi:

; 3411 : 					
; 3412 : 				dsbdesc.dwBufferBytes = newsnd->SampleLen;

	mov	ecx, DWORD PTR _newsnd$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _dsbdesc$[ebp+8], edx

; 3413 : 				dsbdesc.lpwfxFormat = newsnd->Format;

	mov	eax, DWORD PTR _newsnd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _dsbdesc$[ebp+16], ecx

; 3414 : 
; 3415 : 			// Create buffer.
; 3416 : 				hr = DSound->CreateSoundBuffer(&dsbdesc, &lpNewDSBuf, NULL);

	push	0
	lea	edx, DWORD PTR _lpNewDSBuf$[ebp]
	push	edx
	lea	eax, DWORD PTR _dsbdesc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _hr$[ebp], eax

; 3417 : 				if(hr == DS_OK)

	cmp	DWORD PTR _hr$[ebp], 0
	jne	SHORT $LN4@LoadWaveFi

; 3418 : 				{
; 3419 : 					lpNewDSBuf->Lock(0,newsnd->SampleLen,(void**)&mem,&Len,NULL,NULL,NULL);

	push	0
	push	0
	push	0
	lea	ecx, DWORD PTR _Len$[ebp]
	push	ecx
	lea	edx, DWORD PTR _mem$[ebp]
	push	edx
	mov	eax, DWORD PTR _newsnd$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpNewDSBuf$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _lpNewDSBuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax+44]
	call	edx

; 3420 : 					memcpy(mem,newsnd->Start,Len);

	mov	eax, DWORD PTR _Len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _newsnd$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _mem$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 3421 : 					lpNewDSBuf->Unlock(mem,Len,NULL,NULL);

	push	0
	push	0
	mov	ecx, DWORD PTR _Len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mem$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNewDSBuf$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _lpNewDSBuf$[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+76]
	call	eax

; 3422 : 				}
; 3423 : 				else

	jmp	SHORT $LN3@LoadWaveFi
$LN4@LoadWaveFi:

; 3424 : 					DSoundCheck(hr);

	mov	ecx, DWORD PTR _hr$[ebp]
	push	ecx
	call	?DSoundCheck@CSoundMgr@@SAXJ@Z		; CSoundMgr::DSoundCheck
	add	esp, 4
$LN3@LoadWaveFi:

; 3425 : 				delete newsnd->data;

	mov	edx, DWORD PTR _newsnd$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 3426 : 				delete newsnd;

	mov	edx, DWORD PTR _newsnd$[ebp]
	mov	DWORD PTR $T3[ebp], edx
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 3427 : 				return(lpNewDSBuf);

	mov	eax, DWORD PTR _lpNewDSBuf$[ebp]
	jmp	SHORT $LN15@LoadWaveFi

; 3428 : 			}
; 3429 : 			else

	jmp	SHORT $LN14@LoadWaveFi
$LN10@LoadWaveFi:

; 3430 : 			{
; 3431 : 				MonoPrint("Unsupported file format\n");

	push	OFFSET ??_C@_0BJ@BJAEAMK@Unsupported?5file?5format?6?$AA@
	call	_MonoPrint
	add	esp, 4

; 3432 : 				if(newsnd->data)

	mov	ecx, DWORD PTR _newsnd$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN1@LoadWaveFi

; 3433 : 					delete newsnd->data;

	mov	edx, DWORD PTR _newsnd$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T5[ebp], eax
	mov	ecx, DWORD PTR $T5[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@LoadWaveFi:

; 3434 : 				delete newsnd;

	mov	edx, DWORD PTR _newsnd$[ebp]
	mov	DWORD PTR $T4[ebp], edx
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN14@LoadWaveFi:

; 3435 : 			}
; 3436 : 		}
; 3437 : 	}
; 3438 : 	return(0);

	xor	eax, eax
$LN15@LoadWaveFi:

; 3439 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
?LoadWaveFile@CSoundMgr@@QAEPAUIDirectSoundBuffer@@PADPAUSfxDef@@@Z ENDP ; CSoundMgr::LoadWaveFile
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
$T1 = -92						; size = 4
$T2 = -88						; size = 4
$T3 = -84						; size = 4
$T4 = -80						; size = 4
$T5 = -76						; size = 4
$T6 = -72						; size = 4
_hr$ = -68						; size = 4
_mem$ = -64						; size = 4
_Len$ = -60						; size = 4
_NewID$ = -56						; size = 4
_this$ = -52						; size = 4
_lpNewDSBuf$ = -48					; size = 4
_newsnd$ = -44						; size = 4
_dsbdesc$ = -40						; size = 36
__$ArrayPad$ = -4					; size = 4
_Filename$ = 8						; size = 4
_Flags$ = 12						; size = 4
_sfx$ = 16						; size = 4
?LoadWaveFile@CSoundMgr@@QAEJPADJPAUSfxDef@@@Z PROC	; CSoundMgr::LoadWaveFile
; _this$ = ecx

; 602  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 603  : 	char *mem;
; 604  : 	RIFF_FILE *newsnd;
; 605  : 	long NewID = SND_NO_HANDLE;

	mov	DWORD PTR _NewID$[ebp], 0

; 606  : 	DSBUFFERDESC dsbdesc;
; 607  : 	LPDIRECTSOUNDBUFFER lpNewDSBuf;
; 608  : 	DWORD Len;
; 609  : 	HRESULT hr;
; 610  : 
; 611  : 	if(gSoundDriver)

	cmp	DWORD PTR ?gSoundDriver@@3PAVCSoundMgr@@A, 0 ; gSoundDriver
	je	$LN18@LoadWaveFi

; 612  : 	{
; 613  : 		newsnd=LoadRiff(Filename);

	mov	eax, DWORD PTR _Filename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LoadRiff@CSoundMgr@@QAEPAURIFF_FILE@@PAD@Z ; CSoundMgr::LoadRiff
	mov	DWORD PTR _newsnd$[ebp], eax

; 614  : 		if(newsnd)

	cmp	DWORD PTR _newsnd$[ebp], 0
	je	$LN18@LoadWaveFi

; 615  : 		{
; 616  : 			if(!newsnd->Format)

	mov	ecx, DWORD PTR _newsnd$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN16@LoadWaveFi

; 617  : 			{
; 618  : 				if(newsnd->data)

	mov	edx, DWORD PTR _newsnd$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN15@LoadWaveFi

; 619  : 					delete newsnd->data;

	mov	eax, DWORD PTR _newsnd$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T4[ebp], ecx
	mov	edx, DWORD PTR $T4[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN15@LoadWaveFi:

; 620  : 				delete newsnd;

	mov	eax, DWORD PTR _newsnd$[ebp]
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 621  : 				return(SND_NO_HANDLE);

	xor	eax, eax
	jmp	$LN19@LoadWaveFi
$LN16@LoadWaveFi:

; 622  : 			}
; 623  : 			if(newsnd->Format->wFormatTag == WAVE_FORMAT_PCM)

	mov	edx, DWORD PTR _newsnd$[ebp]
	mov	eax, DWORD PTR [edx+4]
	movzx	ecx, WORD PTR [eax]
	cmp	ecx, 1
	jne	$LN14@LoadWaveFi

; 624  : 			{
; 625  : 				memset(&dsbdesc, 0, sizeof(DSBUFFERDESC)); // Zero it out.

	push	36					; 00000024H
	push	0
	lea	edx, DWORD PTR _dsbdesc$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 626  : 				dsbdesc.dwSize = sizeof(DSBUFFERDESC);

	mov	DWORD PTR _dsbdesc$[ebp], 36		; 00000024H

; 627  : 				if (sfx) 

	cmp	DWORD PTR _sfx$[ebp], 0
	je	$LN13@LoadWaveFi

; 628  : 				{ // SFX specific - we have more control
; 629  : 					dsbdesc.dwFlags = DSBCAPS_CTRLVOLUME | 
; 630  : 						DSBCAPS_GETCURRENTPOSITION2;

	mov	DWORD PTR _dsbdesc$[ebp+4], 65664	; 00010080H

; 631  : 											
; 632  : 					if (g_bOldSoundAlg == false)

	movzx	eax, BYTE PTR ?g_bOldSoundAlg@@3_NA	; g_bOldSoundAlg
	test	eax, eax
	jne	SHORT $LN12@LoadWaveFi

; 633  : 						dsbdesc.dwFlags |= DSBCAPS_CTRLPOSITIONNOTIFY;

	mov	ecx, DWORD PTR _dsbdesc$[ebp+4]
	or	ecx, 256				; 00000100H
	mov	DWORD PTR _dsbdesc$[ebp+4], ecx
$LN12@LoadWaveFi:

; 634  : 					
; 635  : 					if (g_bUse3dSound && (sfx->flags & SFX_FLAGS_3D)) 

	movzx	edx, BYTE PTR ?g_bUse3dSound@@3_NA	; g_bUse3dSound
	test	edx, edx
	je	SHORT $LN11@LoadWaveFi
	mov	eax, DWORD PTR _sfx$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	and	ecx, 16					; 00000010H
	je	SHORT $LN11@LoadWaveFi

; 636  : 					{
; 637  : 						dsbdesc.dwFlags |= DSBCAPS_CTRL3D | DSBCAPS_MUTE3DATMAXDISTANCE;

	mov	edx, DWORD PTR _dsbdesc$[ebp+4]
	or	edx, 131088				; 00020010H
	mov	DWORD PTR _dsbdesc$[ebp+4], edx

; 638  : 					}
; 639  : 					else

	jmp	SHORT $LN10@LoadWaveFi
$LN11@LoadWaveFi:

; 640  : 					{
; 641  : 						if (sfx->flags & SFX_FLAGS_PAN) 

	mov	eax, DWORD PTR _sfx$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	and	ecx, 64					; 00000040H
	je	SHORT $LN10@LoadWaveFi

; 642  : 							dsbdesc.dwFlags |= DSBCAPS_CTRLPAN;

	mov	edx, DWORD PTR _dsbdesc$[ebp+4]
	or	edx, 64					; 00000040H
	mov	DWORD PTR _dsbdesc$[ebp+4], edx
$LN10@LoadWaveFi:

; 643  : 					}
; 644  : 					
; 645  : 					if (sfx->flags & (SFX_FLAGS_FREQ | SFX_POS_EXTERN))  // MLR 12/22/2003 - External sounds must have the Freq cap so doppler effects can be applied.

	mov	eax, DWORD PTR _sfx$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	and	ecx, 36					; 00000024H
	je	SHORT $LN8@LoadWaveFi

; 646  : 						dsbdesc.dwFlags |= DSBCAPS_CTRLFREQUENCY;

	mov	edx, DWORD PTR _dsbdesc$[ebp+4]
	or	edx, 32					; 00000020H
	mov	DWORD PTR _dsbdesc$[ebp+4], edx
$LN8@LoadWaveFi:

; 647  : 					
; 648  : 					if ((sfx->flags & SFX_FLAGS_HIGH) == 0) // low priority sound

	mov	eax, DWORD PTR _sfx$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	and	ecx, 128				; 00000080H
	jne	SHORT $LN7@LoadWaveFi

; 649  : 						dsbdesc.dwFlags |= DSBCAPS_LOCDEFER;

	mov	edx, DWORD PTR _dsbdesc$[ebp+4]
	or	edx, 262144				; 00040000H
	mov	DWORD PTR _dsbdesc$[ebp+4], edx
$LN7@LoadWaveFi:

; 650  : 					
; 651  : 					
; 652  : 				} else 

	jmp	SHORT $LN6@LoadWaveFi
$LN13@LoadWaveFi:

; 653  : 				{ // other sounds have other requirements
; 654  : 				    dsbdesc.dwFlags =	DSBCAPS_CTRLPAN | 
; 655  : 										DSBCAPS_CTRLVOLUME | 
; 656  : 										DSBCAPS_CTRLFREQUENCY |
; 657  : 										DSBCAPS_GETCURRENTPOSITION2 ; // Need default controls (pan, volume, frequency).

	mov	DWORD PTR _dsbdesc$[ebp+4], 65760	; 000100e0H

; 658  : 				    if (g_bOldSoundAlg == false)

	movzx	eax, BYTE PTR ?g_bOldSoundAlg@@3_NA	; g_bOldSoundAlg
	test	eax, eax
	jne	SHORT $LN6@LoadWaveFi

; 659  : 						dsbdesc.dwFlags |= DSBCAPS_CTRLPOSITIONNOTIFY;

	mov	ecx, DWORD PTR _dsbdesc$[ebp+4]
	or	ecx, 256				; 00000100H
	mov	DWORD PTR _dsbdesc$[ebp+4], ecx
$LN6@LoadWaveFi:

; 660  : 				}
; 661  : 				dsbdesc.dwBufferBytes = newsnd->SampleLen;

	mov	edx, DWORD PTR _newsnd$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _dsbdesc$[ebp+8], eax

; 662  : 				dsbdesc.lpwfxFormat = newsnd->Format;

	mov	ecx, DWORD PTR _newsnd$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _dsbdesc$[ebp+16], edx

; 663  : 
; 664  : 			// Create buffer.
; 665  : 				hr = DSound->CreateSoundBuffer(&dsbdesc, &lpNewDSBuf, NULL);

	push	0
	lea	eax, DWORD PTR _lpNewDSBuf$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dsbdesc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+12]
	call	ecx
	mov	DWORD PTR _hr$[ebp], eax

; 666  : 				if(hr == DS_OK)

	cmp	DWORD PTR _hr$[ebp], 0
	jne	SHORT $LN4@LoadWaveFi

; 667  : 				{
; 668  : 					lpNewDSBuf->Lock(0,newsnd->SampleLen,(void**)&mem,&Len,NULL,NULL,NULL);

	push	0
	push	0
	push	0
	lea	edx, DWORD PTR _Len$[ebp]
	push	edx
	lea	eax, DWORD PTR _mem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _newsnd$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpNewDSBuf$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _lpNewDSBuf$[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+44]
	call	eax

; 669  : 					memcpy(mem,newsnd->Start,Len);

	mov	ecx, DWORD PTR _Len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _newsnd$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _mem$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 670  : 					lpNewDSBuf->Unlock(mem,Len,NULL,NULL);

	push	0
	push	0
	mov	edx, DWORD PTR _Len$[ebp]
	push	edx
	mov	eax, DWORD PTR _mem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNewDSBuf$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _lpNewDSBuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+76]
	call	ecx

; 671  : 					NewID=AddSampleToMgr(100,newsnd->Format->nSamplesPerSec,0,lpNewDSBuf,Flags, sfx);

	mov	edx, DWORD PTR _sfx$[ebp]
	push	edx
	mov	eax, DWORD PTR _Flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNewDSBuf$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _newsnd$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	100					; 00000064H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddSampleToMgr@CSoundMgr@@AAEJJJJPAUIDirectSoundBuffer@@JPAUSfxDef@@@Z ; CSoundMgr::AddSampleToMgr
	mov	DWORD PTR _NewID$[ebp], eax

; 672  : 				}
; 673  : 				else

	jmp	SHORT $LN3@LoadWaveFi
$LN4@LoadWaveFi:

; 674  : 					DSoundCheck(hr);

	mov	edx, DWORD PTR _hr$[ebp]
	push	edx
	call	?DSoundCheck@CSoundMgr@@SAXJ@Z		; CSoundMgr::DSoundCheck
	add	esp, 4
$LN3@LoadWaveFi:

; 675  : 				delete newsnd->data;

	mov	eax, DWORD PTR _newsnd$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T6[ebp], ecx
	mov	edx, DWORD PTR $T6[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 676  : 				delete newsnd;

	mov	eax, DWORD PTR _newsnd$[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 677  : 				return(NewID);

	mov	eax, DWORD PTR _NewID$[ebp]
	jmp	SHORT $LN19@LoadWaveFi

; 678  : 			}
; 679  : 			else

	jmp	SHORT $LN18@LoadWaveFi
$LN14@LoadWaveFi:

; 680  : 			{
; 681  : 				MonoPrint("Unsupported file format\n");

	push	OFFSET ??_C@_0BJ@BJAEAMK@Unsupported?5file?5format?6?$AA@
	call	_MonoPrint
	add	esp, 4

; 682  : 				if(newsnd->data)

	mov	edx, DWORD PTR _newsnd$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN1@LoadWaveFi

; 683  : 					delete newsnd->data;

	mov	eax, DWORD PTR _newsnd$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T5[ebp], ecx
	mov	edx, DWORD PTR $T5[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@LoadWaveFi:

; 684  : 				delete newsnd;

	mov	eax, DWORD PTR _newsnd$[ebp]
	mov	DWORD PTR $T3[ebp], eax
	mov	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN18@LoadWaveFi:

; 685  : 			}
; 686  : 		}
; 687  : 	}
; 688  : 	return(SND_NO_HANDLE);

	xor	eax, eax
$LN19@LoadWaveFi:

; 689  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?LoadWaveFile@CSoundMgr@@QAEJPADJPAUSfxDef@@@Z ENDP	; CSoundMgr::LoadWaveFile
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMasterVolume@CSoundMgr@@QAEJXZ PROC			; CSoundMgr::GetMasterVolume
; _this$ = ecx

; 296  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 297  : 	Primary->GetVolume(&MasterVolume);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+24]
	call	eax

; 298  : 	return(MasterVolume);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]

; 299  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetMasterVolume@CSoundMgr@@QAEJXZ ENDP			; CSoundMgr::GetMasterVolume
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_retval$ = -8						; size = 4
_this$ = -4						; size = 4
_NewVolume$ = 8						; size = 4
?SetMasterVolume@CSoundMgr@@QAEJJ@Z PROC		; CSoundMgr::SetMasterVolume
; _this$ = ecx

; 287  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 288  : 	long retval=MasterVolume;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _retval$[ebp], ecx

; 289  : 
; 290  : 	MasterVolume=NewVolume;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _NewVolume$[ebp]
	mov	DWORD PTR [edx], eax

; 291  : 	Primary->SetVolume(NewVolume);

	mov	ecx, DWORD PTR _NewVolume$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+60]
	call	ecx

; 292  : 	return(retval);

	mov	eax, DWORD PTR _retval$[ebp]

; 293  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetMasterVolume@CSoundMgr@@QAEJJ@Z ENDP		; CSoundMgr::SetMasterVolume
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?RemoveDSound@CSoundMgr@@QAEXXZ PROC			; CSoundMgr::RemoveDSound
; _this$ = ecx

; 245  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 246  :     if(this != NULL)

	cmp	DWORD PTR _this$[ebp], 0
	je	$LN10@RemoveDSou

; 247  :     {
; 248  : 	if(DSound == NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jne	SHORT $LN8@RemoveDSou

; 249  : 	    return;

	jmp	$LN10@RemoveDSou
$LN8@RemoveDSou:

; 250  : 	
; 251  : 	if(StreamList != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+36], 0
	je	SHORT $LN7@RemoveDSou

; 252  : 	{
; 253  : 	    RemoveAllStreams();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAllStreams@CSoundMgr@@QAEXXZ	; CSoundMgr::RemoveAllStreams
$LN7@RemoveDSou:

; 254  : 	}
; 255  : 	
; 256  : 	if(StreamThreadID)

	cmp	DWORD PTR _StreamThreadID, 0
	je	SHORT $LN6@RemoveDSou

; 257  : 	{
; 258  : 	    StreamRunning=FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 259  : 	    NotifyThread();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?NotifyThread@CSoundMgr@@AAEXXZ		; CSoundMgr::NotifyThread
$LN5@RemoveDSou:

; 260  : 	    while(StreamThreadID)

	cmp	DWORD PTR _StreamThreadID, 0
	je	SHORT $LN4@RemoveDSou

; 261  : 		Sleep(5);

	push	5
	call	DWORD PTR __imp__Sleep@4
	jmp	SHORT $LN5@RemoveDSou
$LN4@RemoveDSou:

; 262  : 	    CloseHandle(StreamThreadID);

	mov	eax, DWORD PTR _StreamThreadID
	push	eax
	call	DWORD PTR __imp__CloseHandle@4
$LN6@RemoveDSou:

; 263  : 	}
; 264  : 	
; 265  : 	if(SampleList != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	je	SHORT $LN3@RemoveDSou

; 266  : 	{
; 267  : 	    RemoveAllSamples();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAllSamples@CSoundMgr@@QAEXXZ	; CSoundMgr::RemoveAllSamples

; 268  : 	    SampleList=NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+28], 0
$LN3@RemoveDSou:

; 269  : 	}
; 270  : 	
; 271  : 	SetMasterVolume(BootVolume);

	mov	eax, DWORD PTR _BootVolume
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMasterVolume@CSoundMgr@@QAEJJ@Z	; CSoundMgr::SetMasterVolume

; 272  : 	F4EnterCriticalSection(StreamCSection);

	mov	ecx, DWORD PTR ?StreamCSection@@3PAUF4CSECTIONHANDLE@@A ; StreamCSection
	push	ecx
	call	_F4EnterCriticalSection
	add	esp, 4

; 273  : 	
; 274  : 	if (Ds3dListener)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+24], 0
	je	SHORT $LN2@RemoveDSou

; 275  : 	    Ds3dListener->Release();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+8]
	call	edx
$LN2@RemoveDSou:

; 276  : 	Ds3dListener = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0

; 277  : 	if (Primary)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], 0
	je	SHORT $LN1@RemoveDSou

; 278  : 	    Primary->Release();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+8]
	call	ecx
$LN1@RemoveDSou:

; 279  : 	Primary=NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 280  : 	DSound->Release();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+8]
	call	edx

; 281  : 	DSound = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 282  : 	F4LeaveCriticalSection(StreamCSection);

	mov	ecx, DWORD PTR ?StreamCSection@@3PAUF4CSECTIONHANDLE@@A ; StreamCSection
	push	ecx
	call	_F4LeaveCriticalSection
	add	esp, 4
$LN10@RemoveDSou:

; 283  :     }
; 284  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveDSound@CSoundMgr@@QAEXXZ ENDP			; CSoundMgr::RemoveDSound
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_res$ = -48						; size = 4
_this$ = -44						; size = 4
_dsbdesc$ = -40						; size = 36
__$ArrayPad$ = -4					; size = 4
_hwnd$ = 8						; size = 4
_Priority$ = 12						; size = 4
_fmt$ = 16						; size = 4
?InstallDSound@CSoundMgr@@QAEHPAUHWND__@@KPAUtWAVEFORMATEX@@@Z PROC ; CSoundMgr::InstallDSound
; _this$ = ecx

; 116  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 117  : 	HRESULT res;
; 118  : 	DSBUFFERDESC        dsbdesc;
; 119  : //	DWORD Speakers;
; 120  : //	DSCAPS dscaps;
; 121  : 
; 122  : 	if(gSoundDriver)

	cmp	DWORD PTR ?gSoundDriver@@3PAVCSoundMgr@@A, 0 ; gSoundDriver
	je	$LN14@InstallDSo

; 123  : 	{
; 124  : 		if(DSound != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN13@InstallDSo

; 125  : 			return(FALSE);

	xor	eax, eax
	jmp	$LN15@InstallDSo
$LN13@InstallDSo:

; 126  : 
; 127  : 		res = DirectSoundCreate(NULL, &DSound,NULL);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	push	0
	call	_DirectSoundCreate@12
	mov	DWORD PTR _res$[ebp], eax

; 128  : 		if(res != DS_OK)

	cmp	DWORD PTR _res$[ebp], 0
	je	SHORT $LN12@InstallDSo

; 129  : 		{
; 130  : 			DSoundCheck(res);

	mov	edx, DWORD PTR _res$[ebp]
	push	edx
	call	?DSoundCheck@CSoundMgr@@SAXJ@Z		; CSoundMgr::DSoundCheck
	add	esp, 4

; 131  : 			return(FALSE);

	xor	eax, eax
	jmp	$LN15@InstallDSo
$LN12@InstallDSo:

; 132  : 		}
; 133  : 
; 134  : 		res = DSound->SetCooperativeLevel(hwnd, DSSCL_EXCLUSIVE );

	push	3
	mov	eax, DWORD PTR _hwnd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+24]
	call	eax
	mov	DWORD PTR _res$[ebp], eax

; 135  : 		if(res != DS_OK)

	cmp	DWORD PTR _res$[ebp], 0
	je	SHORT $LN11@InstallDSo

; 136  : 		{
; 137  : 			DSound->Release();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 138  : 			DSound = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0

; 139  : 			DSoundCheck(res);

	mov	edx, DWORD PTR _res$[ebp]
	push	edx
	call	?DSoundCheck@CSoundMgr@@SAXJ@Z		; CSoundMgr::DSoundCheck
	add	esp, 4

; 140  : 			return(FALSE);

	xor	eax, eax
	jmp	$LN15@InstallDSo
$LN11@InstallDSo:

; 141  : 		}
; 142  :     // Set up DSBUFFERDESC structure.
; 143  : 		memset(&dsbdesc, 0, sizeof(DSBUFFERDESC)); // Zero it out.

	push	36					; 00000024H
	push	0
	lea	eax, DWORD PTR _dsbdesc$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 144  : 		dsbdesc.dwSize = sizeof(DSBUFFERDESC);

	mov	DWORD PTR _dsbdesc$[ebp], 36		; 00000024H

; 145  : 		dsbdesc.dwFlags = DSBCAPS_PRIMARYBUFFER|DSBCAPS_CTRLVOLUME|DSBCAPS_CTRLPAN;

	mov	DWORD PTR _dsbdesc$[ebp+4], 193		; 000000c1H

; 146  : 		if (g_bUse3dSound) 

	movzx	ecx, BYTE PTR ?g_bUse3dSound@@3_NA	; g_bUse3dSound
	test	ecx, ecx
	je	SHORT $LN10@InstallDSo

; 147  : 		{
; 148  : 		    dsbdesc.dwFlags |= DSBCAPS_CTRL3D | DSBCAPS_MUTE3DATMAXDISTANCE;

	mov	edx, DWORD PTR _dsbdesc$[ebp+4]
	or	edx, 131088				; 00020010H
	mov	DWORD PTR _dsbdesc$[ebp+4], edx
$LN10@InstallDSo:

; 149  : 		}
; 150  :     // Buffer size is determined by sound hardware.
; 151  : 		dsbdesc.dwBufferBytes = 0;

	mov	DWORD PTR _dsbdesc$[ebp+8], 0

; 152  : 		dsbdesc.lpwfxFormat = NULL; // Must be NULL for primary buffers.

	mov	DWORD PTR _dsbdesc$[ebp+16], 0

; 153  : 
; 154  : 		res = DSound->CreateSoundBuffer(&dsbdesc, &Primary, NULL);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	lea	ecx, DWORD PTR _dsbdesc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+12]
	call	ecx
	mov	DWORD PTR _res$[ebp], eax

; 155  : 		if(res != DS_OK) { // JPO - no primary buffer, must mean no sound

	cmp	DWORD PTR _res$[ebp], 0
	je	SHORT $LN9@InstallDSo

; 156  : 			DSoundCheck(res);

	mov	edx, DWORD PTR _res$[ebp]
	push	edx
	call	?DSoundCheck@CSoundMgr@@SAXJ@Z		; CSoundMgr::DSoundCheck
	add	esp, 4

; 157  : 			DSound->Release();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+8]
	call	edx

; 158  : 			DSound = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 159  : 			return FALSE;

	xor	eax, eax
	jmp	$LN15@InstallDSo
$LN9@InstallDSo:

; 160  : 		}
; 161  : 		// Get listener interface
; 162  : 		if (g_bUse3dSound) 

	movzx	ecx, BYTE PTR ?g_bUse3dSound@@3_NA	; g_bUse3dSound
	test	ecx, ecx
	je	$LN5@InstallDSo

; 163  : 		{
; 164  : 			if (FAILED(res = Primary->QueryInterface(IID_IDirectSound3DListener,
; 165  : 				(LPVOID *)&Ds3dListener))) 

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 24					; 00000018H
	push	edx
	push	OFFSET _IID_IDirectSound3DListener
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx]
	call	edx
	mov	DWORD PTR _res$[ebp], eax
	cmp	DWORD PTR _res$[ebp], 0
	jge	SHORT $LN7@InstallDSo

; 166  : 			{
; 167  : 				DSoundCheck(res);

	mov	eax, DWORD PTR _res$[ebp]
	push	eax
	call	?DSoundCheck@CSoundMgr@@SAXJ@Z		; CSoundMgr::DSoundCheck
	add	esp, 4

; 168  : 				use3d = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+44], 0

; 169  : 				Ds3dListener = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+24], 0

; 170  : 			}
; 171  : 			else 

	jmp	$LN5@InstallDSo
$LN7@InstallDSo:

; 172  : 			{
; 173  : 				use3d = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+44], 1

; 174  : 				res = Ds3dListener->SetDistanceFactor(0.3048f, DS3D_DEFERRED); // convert to feet

	push	1
	push	ecx
	movss	xmm0, DWORD PTR __real@3e9c0ebf
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+44]
	call	eax
	mov	DWORD PTR _res$[ebp], eax

; 175  : 				// MLR 
; 176  : #ifdef CUSTOM_DOPPLER
; 177  : 				Ds3dListener->SetDopplerFactor( 0, DS3D_DEFERRED);

	push	1
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+48]
	call	eax

; 178  : #else
; 179  : 				Ds3dListener->SetDopplerFactor( g_fSoundDopplerFactor, DS3D_DEFERRED);
; 180  : #endif
; 181  : 				Ds3dListener->SetRolloffFactor( g_fSoundRolloffFactor, DS3D_DEFERRED);

	push	1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fSoundRolloffFactor@@3MA
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+60]
	call	eax

; 182  : 				if (FAILED(res)) DSoundCheck(res);

	cmp	DWORD PTR _res$[ebp], 0
	jge	SHORT $LN5@InstallDSo
	mov	ecx, DWORD PTR _res$[ebp]
	push	ecx
	call	?DSoundCheck@CSoundMgr@@SAXJ@Z		; CSoundMgr::DSoundCheck
	add	esp, 4
$LN5@InstallDSo:

; 183  : 			}
; 184  : 		}
; 185  : 
; 186  :     
; 187  : 		if (!F4IsBadCodePtr((FARPROC) Primary)) // JB 010305 CTD

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	?F4IsBadCodePtr@@YA_NPAX@Z		; F4IsBadCodePtr
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN4@InstallDSo

; 188  : 			res=Primary->SetFormat(fmt);

	mov	edx, DWORD PTR _fmt$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+56]
	call	edx
	mov	DWORD PTR _res$[ebp], eax
$LN4@InstallDSo:

; 189  : 		
; 190  : 		if(res != DS_OK)

	cmp	DWORD PTR _res$[ebp], 0
	je	SHORT $LN3@InstallDSo

; 191  : 			DSoundCheck(res);

	mov	eax, DWORD PTR _res$[ebp]
	push	eax
	call	?DSoundCheck@CSoundMgr@@SAXJ@Z		; CSoundMgr::DSoundCheck
	add	esp, 4
$LN3@InstallDSo:

; 192  : /*
; 193  : 		memset(&dscaps,0,sizeof(DSCAPS));
; 194  : 		dscaps.dwSize=sizeof(DSCAPS);
; 195  : 		res=DSound->GetCaps(&dscaps);
; 196  : 		if(res != DS_OK)
; 197  : 			DSoundCheck(res);
; 198  : 
; 199  : 		res=lpNewDSBuf->GetFormat(fmt,sizeof(WAVEFORMATEX),&size);
; 200  : 		if(res != DS_OK)
; 201  : 			DSoundCheck(res);
; 202  : 
; 203  : 		DSound->GetSpeakerConfig(&Speakers);
; 204  : 
; 205  : 		switch(DSSPEAKER_CONFIG(Speakers))
; 206  : 		{
; 207  : 			case DSSPEAKER_HEADPHONE:
; 208  : 				res=1;
; 209  : 				break;
; 210  : 			case DSSPEAKER_MONO:
; 211  : 				res=2;
; 212  : 				break;
; 213  : 			case DSSPEAKER_QUAD:
; 214  : 				res=3;
; 215  : 				break;
; 216  : 			case DSSPEAKER_STEREO:
; 217  : 				res=4;
; 218  : 				break;
; 219  : 			case DSSPEAKER_SURROUND:
; 220  : 				res=5;
; 221  : 				break;
; 222  : 		}
; 223  : */
; 224  : 
; 225  : 		res = DSound->SetCooperativeLevel(hwnd,Priority);

	mov	ecx, DWORD PTR _Priority$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hwnd$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+24]
	call	edx
	mov	DWORD PTR _res$[ebp], eax

; 226  : 
; 227  : 		//Primary->Play(0,0,DSBPLAY_LOOPING);
; 228  : 		if(res != DS_OK)

	cmp	DWORD PTR _res$[ebp], 0
	je	SHORT $LN2@InstallDSo

; 229  : 		{
; 230  : 			if (!F4IsBadCodePtr((FARPROC) Primary)) // JB 010305 CTD

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	?F4IsBadCodePtr@@YA_NPAX@Z		; F4IsBadCodePtr
	add	esp, 4
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN1@InstallDSo

; 231  : 				Primary->Release();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+8]
	call	edx
$LN1@InstallDSo:

; 232  : 			Primary=NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 233  : 			DSound->Release();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 234  : 			DSound = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0

; 235  : 			DSoundCheck(res);

	mov	edx, DWORD PTR _res$[ebp]
	push	edx
	call	?DSoundCheck@CSoundMgr@@SAXJ@Z		; CSoundMgr::DSoundCheck
	add	esp, 4

; 236  : 			return(FALSE);

	xor	eax, eax
	jmp	SHORT $LN15@InstallDSo
$LN2@InstallDSo:

; 237  : 		}
; 238  : 		BootVolume=GetMasterVolume();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMasterVolume@CSoundMgr@@QAEJXZ	; CSoundMgr::GetMasterVolume
	mov	DWORD PTR _BootVolume, eax

; 239  : 		return(TRUE);

	mov	eax, 1
	jmp	SHORT $LN15@InstallDSo
$LN14@InstallDSo:

; 240  : 	}
; 241  : 	return(FALSE);

	xor	eax, eax
$LN15@InstallDSo:

; 242  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?InstallDSound@CSoundMgr@@QAEHPAUHWND__@@KPAUtWAVEFORMATEX@@@Z ENDP ; CSoundMgr::InstallDSound
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CSoundMgr@@QAE@XZ PROC				; CSoundMgr::~CSoundMgr
; _this$ = ecx

; 93   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 94   : 	F4DestroyCriticalSection(StreamCSection);

	mov	eax, DWORD PTR ?StreamCSection@@3PAUF4CSECTIONHANDLE@@A ; StreamCSection
	push	eax
	call	_F4DestroyCriticalSection
	add	esp, 4

; 95   : 	StreamCSection = NULL; // JB 010108

	mov	DWORD PTR ?StreamCSection@@3PAUF4CSECTIONHANDLE@@A, 0 ; StreamCSection

; 96   : 	CloseHandle (signalEvent); // JPO

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	call	DWORD PTR __imp__CloseHandle@4

; 97   : 	signalEvent = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+40], 0

; 98   : 	#ifdef USE_SH_POOLS
; 99   : 	if ( gSoundMemPool != NULL )
; 100  : 	{
; 101  : 		MemPoolFree ( gSoundMemPool );
; 102  : 		gSoundMemPool = NULL;
; 103  : 	}
; 104  : 	#endif
; 105  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??1CSoundMgr@@QAE@XZ ENDP				; CSoundMgr::~CSoundMgr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CSoundMgr@@QAE@XZ PROC				; CSoundMgr::CSoundMgr
; _this$ = ecx

; 62   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 63   : 	#ifdef USE_SH_POOLS
; 64   : 	if ( gSoundMemPool == NULL )
; 65   : 	{
; 66   : 		gSoundMemPool = MemPoolInit( 0 );
; 67   : 	}
; 68   : 	#endif
; 69   : 	StreamCSection=F4CreateCriticalSection("SoundMgr");

	push	OFFSET ??_C@_08ICBBCCOP@SoundMgr?$AA@
	call	_F4CreateCriticalSection
	add	esp, 4
	mov	DWORD PTR ?StreamCSection@@3PAUF4CSECTIONHANDLE@@A, eax ; StreamCSection

; 70   : 	MasterVolume=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 71   : 	TotalSamples=0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 72   : 	TotalStreams=0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 73   : 	DSound=NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 74   : 	Primary=NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 75   : 	SampleList=NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+28], 0

; 76   : 	DuplicateList=NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+32], 0

; 77   : 	StreamList=NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+36], 0

; 78   : 	StreamRunning=FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 79   : 	use3d = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+44], 0

; 80   : 	Ds3dListener = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], 0

; 81   : 	// to notify the thread thigns have changed
; 82   : 	signalEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

	push	0
	push	0
	push	0
	push	0
	call	DWORD PTR __imp__CreateEventA@16
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+40], eax

; 83   : 	ShiAssert(signalEvent != NULL);
; 84   : 	CamPos.x=0;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+48], xmm0

; 85   : 	CamPos.y=0;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+52], xmm0

; 86   : 	CamPos.z=0;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+56], xmm0

; 87   : 	CamVelocity.x=0;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+60], xmm0

; 88   : 	CamVelocity.y=0;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+64], xmm0

; 89   : 	CamVelocity.z=0;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+68], xmm0

; 90   : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CSoundMgr@@QAE@XZ ENDP				; CSoundMgr::CSoundMgr
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GSoundStream@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GSoundStream@@QAEPAXI@Z PROC				; SoundStream::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1SoundStream@@QAE@XZ			; SoundStream::~SoundStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GSoundStream@@QAEPAXI@Z ENDP				; SoundStream::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
??1SoundStream@@QAE@XZ PROC				; SoundStream::~SoundStream
; _this$ = ecx

; 3280 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 3281 :     if (lpDsNotify)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+104], 0
	je	SHORT $LN5@SoundStrea

; 3282 : 	lpDsNotify->Release();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+8]
	call	eax
$LN5@SoundStrea:

; 3283 :     if (DSoundBuffer)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+100], 0
	je	SHORT $LN4@SoundStrea

; 3284 : 	DSoundBuffer->Release();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+8]
	call	ecx
$LN4@SoundStrea:

; 3285 :     if (notif != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+108], 0
	je	SHORT $LN3@SoundStrea

; 3286 : 	CloseHandle(notif);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	push	ecx
	call	DWORD PTR __imp__CloseHandle@4
$LN3@SoundStrea:

; 3287 :     if (ImaInfo) {

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+76], 0
	je	SHORT $LN6@SoundStrea

; 3288 : 	if (ImaInfo->srcbuffer)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN1@SoundStrea

; 3289 : 	    delete ImaInfo->srcbuffer;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@SoundStrea:

; 3290 : 	delete ImaInfo;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@SoundStrea:

; 3291 :     }
; 3292 : }

	mov	esp, ebp
	pop	ebp
	ret	0
??1SoundStream@@QAE@XZ ENDP				; SoundStream::~SoundStream
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0SoundStream@@QAE@XZ PROC				; SoundStream::SoundStream
; _this$ = ecx

; 3272 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3273 :     DSoundBuffer = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+100], 0

; 3274 :     notif = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+108], 0

; 3275 :     lpDsNotify = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+104], 0

; 3276 :     ImaInfo = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+76], 0

; 3277 : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0SoundStream@@QAE@XZ ENDP				; SoundStream::SoundStream
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GSoundList@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GSoundList@@QAEPAXI@Z PROC				; SoundList::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1SoundList@@QAE@XZ			; SoundList::~SoundList
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GSoundList@@QAEPAXI@Z ENDP				; SoundList::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$ = -4						; size = 4
??1SoundList@@QAE@XZ PROC				; SoundList::~SoundList
; _this$ = ecx

; 3343 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 3344 :     //if (DSoundBuffer)
; 3345 : 	//DSoundBuffer->Release();
; 3346 : 	int i;
; 3347 : 
; 3348 : 	for(i=0;i<DS3DBufferCount;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN5@SoundList
$LN4@SoundList:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN5@SoundList:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+28]
	jge	SHORT $LN6@SoundList

; 3349 : 	{
; 3350 : 		if (Buf[i].DSoundBuffer)

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 56					; 00000038H
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax+44], 0
	je	SHORT $LN2@SoundList

; 3351 : 		Buf[i].DSoundBuffer->Release();

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 56					; 00000038H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+44]
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 56					; 00000038H
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+edx+44]
	mov	eax, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR [eax+8]
	call	ecx
$LN2@SoundList:

; 3352 : 		
; 3353 : 		if (Buf[i].DSound3dBuffer)

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 56					; 00000038H
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+edx+48], 0
	je	SHORT $LN1@SoundList

; 3354 : 		Buf[i].DSound3dBuffer->Release();

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 56					; 00000038H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+48]
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 56					; 00000038H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+48]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	eax, DWORD PTR [edx+8]
	call	eax
$LN1@SoundList:

; 3355 : 	}

	jmp	SHORT $LN4@SoundList
$LN6@SoundList:

; 3356 : }

	mov	esp, ebp
	pop	ebp
	ret	0
??1SoundList@@QAE@XZ ENDP				; SoundList::~SoundList
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_hr$1 = -12						; size = 4
_i$2 = -8						; size = 4
_this$ = -4						; size = 4
_copy$ = 8						; size = 4
_DSound$ = 12						; size = 4
??0SoundList@@QAE@PAV0@PAUIDirectSound@@@Z PROC		; SoundList::SoundList
; _this$ = ecx

; 3319 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3320 :     ShiAssert(FALSE == F4IsBadReadPtr(DSound, sizeof *DSound));
; 3321 :     //ShiAssert(FALSE == F4IsBadReadPtr(copy->DSoundBuffer, sizeof *copy->DSoundBuffer));
; 3322 :     ID = copy->ID;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _copy$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 3323 :     Volume = copy->Volume;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _copy$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 3324 :     Frequency = copy->Frequency;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _copy$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 3325 :     Direction = copy->Direction;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _copy$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx

; 3326 : 	DS3DBufferCount=copy->DS3DBufferCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _copy$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+28], edx

; 3327 : 	Cur3dBuffer=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+32], 0

; 3328 :     Flags = copy->Flags;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _copy$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax

; 3329 :     is3d = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+36], 0

; 3330 : 	for(int i=0;i<DS3DBufferCount;i++)

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN4@SoundList
$LN3@SoundList:
	mov	edx, DWORD PTR _i$2[ebp]
	add	edx, 1
	mov	DWORD PTR _i$2[ebp], edx
$LN4@SoundList:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$2[ebp]
	cmp	ecx, DWORD PTR [eax+28]
	jge	SHORT $LN2@SoundList

; 3331 : 	{
; 3332 : 		Buf[i]=copy->Buf[i];

	mov	edx, DWORD PTR _i$2[ebp]
	imul	edx, 56					; 00000038H
	mov	eax, DWORD PTR _copy$[ebp]
	lea	esi, DWORD PTR [eax+edx+44]
	mov	ecx, DWORD PTR _i$2[ebp]
	imul	ecx, 56					; 00000038H
	mov	edx, DWORD PTR _this$[ebp]
	lea	edi, DWORD PTR [edx+ecx+44]
	mov	ecx, 14					; 0000000eH
	rep movsd

; 3333 : 		HRESULT hr = DSound->DuplicateSoundBuffer(copy->Buf[0].DSoundBuffer, &Buf[i].DSoundBuffer);

	mov	eax, DWORD PTR _i$2[ebp]
	imul	eax, 56					; 00000038H
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+44]
	push	edx
	mov	eax, 56					; 00000038H
	imul	eax, 0
	mov	ecx, DWORD PTR _copy$[ebp]
	mov	edx, DWORD PTR [ecx+eax+44]
	push	edx
	mov	eax, DWORD PTR _DSound$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _DSound$[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+20]
	call	eax
	mov	DWORD PTR _hr$1[ebp], eax

; 3334 : 		Buf[i].DSound3dBuffer=0;

	mov	ecx, DWORD PTR _i$2[ebp]
	imul	ecx, 56					; 00000038H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+48], 0

; 3335 : 		
; 3336 : 		if (hr != S_OK)

	cmp	DWORD PTR _hr$1[ebp], 0
	je	SHORT $LN1@SoundList

; 3337 : 		CSoundMgr::DSoundCheck(hr);

	mov	eax, DWORD PTR _hr$1[ebp]
	push	eax
	call	?DSoundCheck@CSoundMgr@@SAXJ@Z		; CSoundMgr::DSoundCheck
	add	esp, 4
$LN1@SoundList:

; 3338 : 	}

	jmp	$LN3@SoundList
$LN2@SoundList:

; 3339 :     Next = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+100], 0

; 3340 : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
??0SoundList@@QAE@PAV0@PAUIDirectSound@@@Z ENDP		; SoundList::SoundList
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\psound.cpp
_TEXT	SEGMENT
_i$ = -8						; size = 4
_this$ = -4						; size = 4
??0SoundList@@QAE@XZ PROC				; SoundList::SoundList
; _this$ = ecx

; 3295 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 3296 :     	ID = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 3297 : 	Volume = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 3298 : 	Frequency = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 3299 : 	Direction = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 3300 : 	Flags = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0

; 3301 : 	DS3DBufferCount=DS3DBUFFERMAX;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+28], 1

; 3302 : 	Cur3dBuffer=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+32], 0

; 3303 : 	//DSoundBuffer = NULL;
; 3304 : 	int i;
; 3305 : 	for(i=0;i<DS3DBufferCount;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@SoundList
$LN2@SoundList:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN3@SoundList:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+28]
	jge	SHORT $LN1@SoundList

; 3306 : 	{
; 3307 : 		Buf[i].uid=0;

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 56					; 00000038H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+88], 0

; 3308 : 		Buf[i].distsq=-1; // set so that the sound doesn't get played errantly when you enter the 3d world.

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 56					; 00000038H
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [ecx+eax+76], xmm0

; 3309 : 		Buf[i].DSoundBuffer   = NULL;

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 56					; 00000038H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+44], 0

; 3310 : 		Buf[i].DSound3dBuffer = NULL;

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 56					; 00000038H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+48], 0

; 3311 : 	}

	jmp	SHORT $LN2@SoundList
$LN1@SoundList:

; 3312 : 	is3d = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+36], 0

; 3313 : 	Next = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+100], 0

; 3314 : 
; 3315 : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0SoundList@@QAE@XZ ENDP				; SoundList::SoundList
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
_TEXT	SEGMENT
_x$ = 8							; size = 4
?SqrtSSE@@YAMM@Z PROC					; SqrtSSE

; 91   : static inline float SqrtSSE(float x){ 

	push	ebp
	mov	ebp, esp

; 92   :     __asm 
; 93   :     { 
; 94   :         sqrtss xmm0,x 

	sqrtss	xmm0, DWORD PTR _x$[ebp]

; 95   :         movss x,xmm0 

	movss	XMMWORD PTR _x$[ebp], xmm0

; 96   :     } 
; 97   : 
; 98   :     return x; 

	fld	DWORD PTR _x$[ebp]

; 99   : } 

	pop	ebp
	ret	0
?SqrtSSE@@YAMM@Z ENDP					; SqrtSSE
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?log10@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?log10@@YAMM@Z PROC					; log10, COMDAT

; 529  :         {return (log10f(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_log10f
	add	esp, 4
	pop	ebp
	ret	0
?log10@@YAMM@Z ENDP					; log10
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _log10f
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_log10f	PROC						; COMDAT

; 422  :         {return ((float)log10((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_log10
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_log10f	ENDP
_TEXT	ENDS
END
