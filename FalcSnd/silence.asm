; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\FalcSnd\silence.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?expand@@3PAHA					; expand
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
_DATA	SEGMENT
?expand@@3PAHA DD 05H					; expand
	DD	0fH
	DD	019H
	DD	023H
	DD	02dH
	DD	036H
	DD	03eH
	DD	046H
	DD	04eH
	DD	056H
	DD	05dH
	DD	064H
	DD	06aH
	DD	070H
	DD	076H
	DD	07cH
	DD	083H
	DD	089H
	DD	08fH
	DD	095H
	DD	09bH
	DD	0a2H
	DD	0a9H
	DD	0b1H
	DD	0b9H
	DD	0c1H
	DD	0c9H
	DD	0d2H
	DD	0dcH
	DD	0e6H
	DD	0f0H
	DD	0faH
_DATA	ENDS
PUBLIC	?silence_run@@YAHQAHH@Z				; silence_run
PUBLIC	?end_of_silence@@YAHQAHH@Z			; end_of_silence
PUBLIC	?CompressFile@@YAXPAU_iobuf@@PAUbit_file@@HQAPAD@Z ; CompressFile
PUBLIC	?ExpandFile@@YAXPAUbit_file@@PAU_iobuf@@HQAPAD@Z ; ExpandFile
PUBLIC	?ExpandBuffer@@YAPAEPAUcompression_buf_t@@PAJ@Z	; ExpandBuffer
PUBLIC	?ExpandCompressionBuffer@@YAJJPAUcompression_buf_t@@PAPAE@Z ; ExpandCompressionBuffer
PUBLIC	?ExpandCompSilenceBuff@@YAJJPAUcompression_buf_t@@PAUVOICE_STREAM_BUFFER@@@Z ; ExpandCompSilenceBuff
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@4000000000000000
PUBLIC	__real@4060000000000000
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	_memcmp:PROC
EXTRN	_memset:PROC
EXTRN	_getc:PROC
EXTRN	_putc:PROC
EXTRN	_pow:PROC
EXTRN	?OutputBits@@YAXPAUbit_file@@KH@Z:PROC		; OutputBits
EXTRN	?InputBits@@YAKPAUbit_file@@H@Z:PROC		; InputBits
EXTRN	?InputCompBits@@YAKPAUcompression_buf_t@@H@Z:PROC ; InputCompBits
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?silence_run@?1??ExpandCompressionBuffer@@YAJJPAUcompression_buf_t@@PAPAE@Z@4FA
_BSS	SEGMENT
?silence_run@?1??ExpandCompressionBuffer@@YAJJPAUcompression_buf_t@@PAPAE@Z@4FA DW 01H DUP (?) ; `ExpandCompressionBuffer'::`2'::silence_run
_BSS	ENDS
;	COMDAT __real@4060000000000000
CONST	SEGMENT
__real@4060000000000000 DQ 04060000000000000r	; 128
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\silence.cpp
_TEXT	SEGMENT
_bits$ = -76						; size = 4
_c$ = -72						; size = 4
_run_count$ = -68					; size = 4
_count$ = -64						; size = 4
_i$ = -60						; size = 4
_ptr$ = -56						; size = 4
_inputBuff$ = -52					; size = 24
_silence_match$ = -28					; size = 24
__$ArrayPad$ = -4					; size = 4
_bytesRead$ = 8						; size = 4
_compBuf$ = 12						; size = 4
_voice$ = 16						; size = 4
?ExpandCompSilenceBuff@@YAJJPAUcompression_buf_t@@PAUVOICE_STREAM_BUFFER@@@Z PROC ; ExpandCompSilenceBuff

; 541  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 542  : 	unsigned char	*ptr;
; 543  :     int				bits,
; 544  :      				c;
; 545  :     long			count;
; 546  :     int				run_count;
; 547  : 
; 548  :     int silence_match[6] = { 31, 0, 31, 0, 30, 0 };

	mov	DWORD PTR _silence_match$[ebp], 31	; 0000001fH
	mov	DWORD PTR _silence_match$[ebp+4], 0
	mov	DWORD PTR _silence_match$[ebp+8], 31	; 0000001fH
	mov	DWORD PTR _silence_match$[ebp+12], 0
	mov	DWORD PTR _silence_match$[ebp+16], 30	; 0000001eH
	mov	DWORD PTR _silence_match$[ebp+20], 0

; 549  : 	int inputBuff[6];
; 550  : 	int i;
; 551  : 
; 552  : 	bits = 5;

	mov	DWORD PTR _bits$[ebp], 5

; 553  : 
; 554  : 	count = bytesRead;

	mov	eax, DWORD PTR _bytesRead$[ebp]
	mov	DWORD PTR _count$[ebp], eax

; 555  : 	ptr = voice->waveBuffer;

	mov	ecx, DWORD PTR _voice$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _ptr$[ebp], edx

; 556  : 	memset( ptr, 0x80, count );

	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	push	128					; 00000080H
	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
$LN12@ExpandComp:

; 557  : 
; 558  :     while ( count > 0 ) 

	cmp	DWORD PTR _count$[ebp], 0
	jle	$LN11@ExpandComp

; 559  : 		{
; 560  : 		c = (int) InputCompBits( compBuf, bits );

	mov	edx, DWORD PTR _bits$[ebp]
	push	edx
	mov	eax, DWORD PTR _compBuf$[ebp]
	push	eax
	call	?InputCompBits@@YAKPAUcompression_buf_t@@H@Z ; InputCompBits
	add	esp, 8
	mov	DWORD PTR _c$[ebp], eax

; 561  : 
; 562  : 		if ( c == 31 )

	cmp	DWORD PTR _c$[ebp], 31			; 0000001fH
	jne	$LN10@ExpandComp

; 563  : 			{
; 564  : 			inputBuff[0] = c;

	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR _inputBuff$[ebp+ecx], edx

; 565  : 
; 566  : 			for(i = 1; i < 6; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN9@ExpandComp
$LN8@ExpandComp:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN9@ExpandComp:
	cmp	DWORD PTR _i$[ebp], 6
	jge	SHORT $LN7@ExpandComp

; 567  : 				{
; 568  : 				inputBuff[i] = (int) InputCompBits( compBuf, bits );

	mov	ecx, DWORD PTR _bits$[ebp]
	push	ecx
	mov	edx, DWORD PTR _compBuf$[ebp]
	push	edx
	call	?InputCompBits@@YAKPAUcompression_buf_t@@H@Z ; InputCompBits
	add	esp, 8
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _inputBuff$[ebp+ecx*4], eax

; 569  : 				}

	jmp	SHORT $LN8@ExpandComp
$LN7@ExpandComp:

; 570  : 
; 571  : 			if( memcmp( &inputBuff, &silence_match, 6 ) )

	push	6
	lea	edx, DWORD PTR _silence_match$[ebp]
	push	edx
	lea	eax, DWORD PTR _inputBuff$[ebp]
	push	eax
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@ExpandComp

; 572  : 				{
; 573  : 				for(i = 0; i < 6; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN5@ExpandComp
$LN4@ExpandComp:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN5@ExpandComp:
	cmp	DWORD PTR _i$[ebp], 6
	jge	SHORT $LN3@ExpandComp

; 574  : 					{
; 575  : 					*ptr = ( unsigned char )expand[ inputBuff[i] ];

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _inputBuff$[ebp+edx*4]
	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	dl, BYTE PTR ?expand@@3PAHA[eax*4]
	mov	BYTE PTR [ecx], dl

; 576  : 					ptr++;

	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, 1
	mov	DWORD PTR _ptr$[ebp], eax

; 577  : 					count--;

	mov	ecx, DWORD PTR _count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _count$[ebp], ecx

; 578  : 					}

	jmp	SHORT $LN4@ExpandComp
$LN3@ExpandComp:

; 579  : 				}
; 580  : 			else

	jmp	SHORT $LN2@ExpandComp
$LN6@ExpandComp:

; 581  : 				{
; 582  : 				run_count = (int) InputCompBits( compBuf, 8 );

	push	8
	mov	edx, DWORD PTR _compBuf$[ebp]
	push	edx
	call	?InputCompBits@@YAKPAUcompression_buf_t@@H@Z ; InputCompBits
	add	esp, 8
	mov	DWORD PTR _run_count$[ebp], eax

; 583  : 				memset( ptr, 0x80, run_count );

	mov	eax, DWORD PTR _run_count$[ebp]
	push	eax
	push	128					; 00000080H
	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 584  : 				ptr+=run_count;

	mov	edx, DWORD PTR _ptr$[ebp]
	add	edx, DWORD PTR _run_count$[ebp]
	mov	DWORD PTR _ptr$[ebp], edx

; 585  : //				count-=run_count;
; 586  : 				run_count = 0;

	mov	DWORD PTR _run_count$[ebp], 0
$LN2@ExpandComp:

; 587  : 				}
; 588  : 			}
; 589  : 		else

	jmp	SHORT $LN1@ExpandComp
$LN10@ExpandComp:

; 590  : 			{
; 591  : 			*ptr = ( unsigned char )expand[ c ];

	mov	eax, DWORD PTR _ptr$[ebp]
	mov	ecx, DWORD PTR _c$[ebp]
	mov	dl, BYTE PTR ?expand@@3PAHA[ecx*4]
	mov	BYTE PTR [eax], dl

; 592  : 			ptr++;

	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, 1
	mov	DWORD PTR _ptr$[ebp], eax

; 593  : 			count--;

	mov	ecx, DWORD PTR _count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _count$[ebp], ecx
$LN1@ExpandComp:

; 594  : 			}
; 595  : 		}

	jmp	$LN12@ExpandComp
$LN11@ExpandComp:

; 596  : 
; 597  : //	voice->waveBufferRead += bytesRead;
; 598  : 	voice->dataInWaveBuffer = ptr - voice->waveBuffer;//bytesRead;

	mov	edx, DWORD PTR _voice$[ebp]
	mov	eax, DWORD PTR _ptr$[ebp]
	sub	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _voice$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 599  : 	voice->waveBufferLen = ptr - voice->waveBuffer;//bytesRead;

	mov	edx, DWORD PTR _voice$[ebp]
	mov	eax, DWORD PTR _ptr$[ebp]
	sub	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _voice$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 600  : //	voice->fill_level = ptr;
; 601  : 	return( count );

	mov	eax, DWORD PTR _count$[ebp]

; 602  : 	}

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?ExpandCompSilenceBuff@@YAJJPAUcompression_buf_t@@PAUVOICE_STREAM_BUFFER@@@Z ENDP ; ExpandCompSilenceBuff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\silence.cpp
_TEXT	SEGMENT
_bits$ = -84						; size = 4
_bytesLeft$ = -80					; size = 4
_c$ = -76						; size = 4
_byteMax$ = -72						; size = 4
_silence_used$ = -68					; size = 2
_i$ = -64						; size = 4
_ptr$ = -60						; size = 4
_count$ = -56						; size = 4
_inputBuff$ = -52					; size = 24
_silence_match$ = -28					; size = 24
__$ArrayPad$ = -4					; size = 4
_bytesToRead$ = 8					; size = 4
_compbuf$ = 12						; size = 4
_buffer$ = 16						; size = 4
?ExpandCompressionBuffer@@YAJJPAUcompression_buf_t@@PAPAE@Z PROC ; ExpandCompressionBuffer

; 347  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 348  : 	unsigned char	*ptr;
; 349  :     int				bits = COMPRESSION_BITS,

	mov	DWORD PTR _bits$[ebp], 5

; 350  :      				c;
; 351  :     long			count;
; 352  :     long			bytesLeft;
; 353  :     long			byteMax;
; 354  : 	//Update so Silence and Compand do not conflict
; 355  :     int				silence_match[6] = { 31, 0, 31, 0, 30, 0 };

	mov	DWORD PTR _silence_match$[ebp], 31	; 0000001fH
	mov	DWORD PTR _silence_match$[ebp+4], 0
	mov	DWORD PTR _silence_match$[ebp+8], 31	; 0000001fH
	mov	DWORD PTR _silence_match$[ebp+12], 0
	mov	DWORD PTR _silence_match$[ebp+16], 30	; 0000001eH
	mov	DWORD PTR _silence_match$[ebp+20], 0

; 356  : 	int				inputBuff[6];
; 357  : 	int				i;
; 358  :     short			silence_used;
; 359  :     static short	silence_run = 0;
; 360  : 
; 361  : 
; 362  :     if (compbuf->fileLength && (compbuf->fileLength == compbuf->bytesRead)) {

	mov	eax, DWORD PTR _compbuf$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN20@ExpandComp
	mov	ecx, DWORD PTR _compbuf$[ebp]
	mov	edx, DWORD PTR _compbuf$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	cmp	eax, DWORD PTR [edx+20]
	jne	SHORT $LN20@ExpandComp

; 363  :         return 0L;

	xor	eax, eax
	jmp	$LN21@ExpandComp
$LN20@ExpandComp:

; 364  :     }
; 365  : 
; 366  :     ptr = *buffer;

	mov	ecx, DWORD PTR _buffer$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _ptr$[ebp], edx

; 367  :     bytesLeft = compbuf->fileLength - compbuf->bytesRead;

	mov	eax, DWORD PTR _compbuf$[ebp]
	mov	ecx, DWORD PTR _compbuf$[ebp]
	mov	edx, DWORD PTR [eax+24]
	sub	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _bytesLeft$[ebp], edx

; 368  : 
; 369  :     /* Calculate how much of the file we can read */
; 370  :     if (bytesToRead <= bytesLeft)

	mov	eax, DWORD PTR _bytesToRead$[ebp]
	cmp	eax, DWORD PTR _bytesLeft$[ebp]
	jg	SHORT $LN19@ExpandComp

; 371  :         byteMax = bytesToRead;

	mov	ecx, DWORD PTR _bytesToRead$[ebp]
	mov	DWORD PTR _byteMax$[ebp], ecx

; 372  :     else

	jmp	SHORT $LN18@ExpandComp
$LN19@ExpandComp:

; 373  :         byteMax = bytesLeft;

	mov	edx, DWORD PTR _bytesLeft$[ebp]
	mov	DWORD PTR _byteMax$[ebp], edx
$LN18@ExpandComp:

; 374  :     
; 375  :     count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 376  : 
; 377  :     if (silence_run > 0) 

	movsx	eax, WORD PTR ?silence_run@?1??ExpandCompressionBuffer@@YAJJPAUcompression_buf_t@@PAPAE@Z@4FA
	test	eax, eax
	jle	SHORT $LN16@ExpandComp

; 378  : 		{
; 379  : 		memset( ptr, SILENCE_KEY, silence_run );

	movsx	ecx, WORD PTR ?silence_run@?1??ExpandCompressionBuffer@@YAJJPAUcompression_buf_t@@PAPAE@Z@4FA
	push	ecx
	push	0
	mov	edx, DWORD PTR _ptr$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 380  : 		ptr += silence_run;

	movsx	eax, WORD PTR ?silence_run@?1??ExpandCompressionBuffer@@YAJJPAUcompression_buf_t@@PAPAE@Z@4FA
	add	eax, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR _ptr$[ebp], eax

; 381  :         count = count + silence_run;

	movsx	ecx, WORD PTR ?silence_run@?1??ExpandCompressionBuffer@@YAJJPAUcompression_buf_t@@PAPAE@Z@4FA
	add	ecx, DWORD PTR _count$[ebp]
	mov	DWORD PTR _count$[ebp], ecx

; 382  :         silence_run = 0;

	xor	edx, edx
	mov	WORD PTR ?silence_run@?1??ExpandCompressionBuffer@@YAJJPAUcompression_buf_t@@PAPAE@Z@4FA, dx
$LN16@ExpandComp:

; 383  : 		}
; 384  : 
; 385  :     while (count < byteMax) 

	mov	eax, DWORD PTR _count$[ebp]
	cmp	eax, DWORD PTR _byteMax$[ebp]
	jge	$LN15@ExpandComp

; 386  : 		{
; 387  : 		c = (int) InputCompBits( compbuf, bits );

	mov	ecx, DWORD PTR _bits$[ebp]
	push	ecx
	mov	edx, DWORD PTR _compbuf$[ebp]
	push	edx
	call	?InputCompBits@@YAKPAUcompression_buf_t@@H@Z ; InputCompBits
	add	esp, 8
	mov	DWORD PTR _c$[ebp], eax

; 388  : 
; 389  : 		if ( c == 31 )

	cmp	DWORD PTR _c$[ebp], 31			; 0000001fH
	jne	$LN14@ExpandComp

; 390  : 			{
; 391  : 			inputBuff[0] = c;

	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR _inputBuff$[ebp+eax], ecx

; 392  : 
; 393  : 			for(i = 1; i < 6; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN13@ExpandComp
$LN12@ExpandComp:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN13@ExpandComp:
	cmp	DWORD PTR _i$[ebp], 6
	jge	SHORT $LN11@ExpandComp

; 394  : 				{
; 395  : 				inputBuff[i] = (int) InputCompBits( compbuf, bits );

	mov	eax, DWORD PTR _bits$[ebp]
	push	eax
	mov	ecx, DWORD PTR _compbuf$[ebp]
	push	ecx
	call	?InputCompBits@@YAKPAUcompression_buf_t@@H@Z ; InputCompBits
	add	esp, 8
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _inputBuff$[ebp+edx*4], eax

; 396  : 				}

	jmp	SHORT $LN12@ExpandComp
$LN11@ExpandComp:

; 397  : 
; 398  : 			if( memcmp( &inputBuff, &silence_match, 6 ) )

	push	6
	lea	eax, DWORD PTR _silence_match$[ebp]
	push	eax
	lea	ecx, DWORD PTR _inputBuff$[ebp]
	push	ecx
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN10@ExpandComp

; 399  : 				{
; 400  : 				for(i = 0; i < 6; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN9@ExpandComp
$LN8@ExpandComp:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN9@ExpandComp:
	cmp	DWORD PTR _i$[ebp], 6
	jge	SHORT $LN7@ExpandComp

; 401  : 					{
; 402  : 					c = inputBuff[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _inputBuff$[ebp+eax*4]
	mov	DWORD PTR _c$[ebp], ecx

; 403  : 					*ptr = ( unsigned char )expand[ inputBuff[i] ];

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _inputBuff$[ebp+edx*4]
	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	dl, BYTE PTR ?expand@@3PAHA[eax*4]
	mov	BYTE PTR [ecx], dl

; 404  : 					ptr++;

	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, 1
	mov	DWORD PTR _ptr$[ebp], eax

; 405  : 					count++;

	mov	ecx, DWORD PTR _count$[ebp]
	add	ecx, 1
	mov	DWORD PTR _count$[ebp], ecx

; 406  : 					}

	jmp	SHORT $LN8@ExpandComp
$LN7@ExpandComp:

; 407  : 				}
; 408  : 			else

	jmp	$LN6@ExpandComp
$LN10@ExpandComp:

; 409  : 				{
; 410  : 				silence_run = (short) InputCompBits( compbuf, 8 );

	push	8
	mov	edx, DWORD PTR _compbuf$[ebp]
	push	edx
	call	?InputCompBits@@YAKPAUcompression_buf_t@@H@Z ; InputCompBits
	add	esp, 8
	mov	WORD PTR ?silence_run@?1??ExpandCompressionBuffer@@YAJJPAUcompression_buf_t@@PAPAE@Z@4FA, ax

; 411  : 
; 412  : 				silence_run += 1;

	movsx	eax, WORD PTR ?silence_run@?1??ExpandCompressionBuffer@@YAJJPAUcompression_buf_t@@PAPAE@Z@4FA
	add	eax, 1
	mov	WORD PTR ?silence_run@?1??ExpandCompressionBuffer@@YAJJPAUcompression_buf_t@@PAPAE@Z@4FA, ax

; 413  :                 if (silence_run + count > byteMax) {

	movsx	ecx, WORD PTR ?silence_run@?1??ExpandCompressionBuffer@@YAJJPAUcompression_buf_t@@PAPAE@Z@4FA
	add	ecx, DWORD PTR _count$[ebp]
	cmp	ecx, DWORD PTR _byteMax$[ebp]
	jle	SHORT $LN5@ExpandComp

; 414  :                     silence_used = (short) (byteMax - count);

	mov	edx, DWORD PTR _byteMax$[ebp]
	sub	edx, DWORD PTR _count$[ebp]
	mov	WORD PTR _silence_used$[ebp], dx

; 415  :                     silence_run = (short) ((silence_run + count) - byteMax);

	movsx	eax, WORD PTR ?silence_run@?1??ExpandCompressionBuffer@@YAJJPAUcompression_buf_t@@PAPAE@Z@4FA
	add	eax, DWORD PTR _count$[ebp]
	sub	eax, DWORD PTR _byteMax$[ebp]
	mov	WORD PTR ?silence_run@?1??ExpandCompressionBuffer@@YAJJPAUcompression_buf_t@@PAPAE@Z@4FA, ax

; 416  :                 }
; 417  :                 else {

	jmp	SHORT $LN4@ExpandComp
$LN5@ExpandComp:

; 418  :                     silence_used = silence_run;

	mov	cx, WORD PTR ?silence_run@?1??ExpandCompressionBuffer@@YAJJPAUcompression_buf_t@@PAPAE@Z@4FA
	mov	WORD PTR _silence_used$[ebp], cx

; 419  :                     silence_run = 0;

	xor	edx, edx
	mov	WORD PTR ?silence_run@?1??ExpandCompressionBuffer@@YAJJPAUcompression_buf_t@@PAPAE@Z@4FA, dx
$LN4@ExpandComp:

; 420  :                 }
; 421  : 
; 422  : 				memset( ptr, 0x80, silence_used );

	movsx	eax, WORD PTR _silence_used$[ebp]
	push	eax
	push	128					; 00000080H
	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 423  : 				ptr+=silence_used;

	movsx	edx, WORD PTR _silence_used$[ebp]
	add	edx, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR _ptr$[ebp], edx

; 424  : 				count+=silence_used;

	movsx	eax, WORD PTR _silence_used$[ebp]
	add	eax, DWORD PTR _count$[ebp]
	mov	DWORD PTR _count$[ebp], eax
$LN6@ExpandComp:

; 425  : 				}
; 426  : 			}
; 427  : 		else

	jmp	SHORT $LN3@ExpandComp
$LN14@ExpandComp:

; 428  : 			{
; 429  : 			*ptr = ( unsigned char )expand[ c ];

	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	edx, DWORD PTR _c$[ebp]
	mov	al, BYTE PTR ?expand@@3PAHA[edx*4]
	mov	BYTE PTR [ecx], al

; 430  : 			ptr++;

	mov	ecx, DWORD PTR _ptr$[ebp]
	add	ecx, 1
	mov	DWORD PTR _ptr$[ebp], ecx

; 431  : 			count++;

	mov	edx, DWORD PTR _count$[ebp]
	add	edx, 1
	mov	DWORD PTR _count$[ebp], edx
$LN3@ExpandComp:

; 432  : 			}
; 433  : 		}

	jmp	$LN16@ExpandComp
$LN15@ExpandComp:

; 434  : 
; 435  :     compbuf->bytesRead = compbuf->bytesRead + byteMax;

	mov	eax, DWORD PTR _compbuf$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, DWORD PTR _byteMax$[ebp]
	mov	edx, DWORD PTR _compbuf$[ebp]
	mov	DWORD PTR [edx+20], ecx

; 436  : 
; 437  :     if (compbuf->fileLength == compbuf->bytesRead) 

	mov	eax, DWORD PTR _compbuf$[ebp]
	mov	ecx, DWORD PTR _compbuf$[ebp]
	mov	edx, DWORD PTR [eax+24]
	cmp	edx, DWORD PTR [ecx+20]
	jne	SHORT $LN2@ExpandComp

; 438  :         return bytesLeft;

	mov	eax, DWORD PTR _bytesLeft$[ebp]
	jmp	SHORT $LN21@ExpandComp

; 439  :     else 

	jmp	SHORT $LN21@ExpandComp
$LN2@ExpandComp:

; 440  :         return bytesToRead;

	mov	eax, DWORD PTR _bytesToRead$[ebp]
$LN21@ExpandComp:

; 441  : 	}

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?ExpandCompressionBuffer@@YAJJPAUcompression_buf_t@@PAPAE@Z ENDP ; ExpandCompressionBuffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\silence.cpp
_TEXT	SEGMENT
$T1 = -84						; size = 4
_ouputBuffer$ = -80					; size = 4
_bits$ = -76						; size = 4
_c$ = -72						; size = 4
_run_count$ = -68					; size = 4
_count$ = -64						; size = 4
_i$ = -60						; size = 4
_ptr$ = -56						; size = 4
_inputBuff$ = -52					; size = 24
_silence_match$ = -28					; size = 24
__$ArrayPad$ = -4					; size = 4
_compBuf$ = 8						; size = 4
_actSize$ = 12						; size = 4
?ExpandBuffer@@YAPAEPAUcompression_buf_t@@PAJ@Z PROC	; ExpandBuffer

; 224  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 225  : 	unsigned char	*ptr,
; 226  : 					*ouputBuffer;
; 227  :     int				bits,
; 228  :      				c;
; 229  :     long			count;
; 230  :     int				run_count;
; 231  : 
; 232  : 	//Update so Silence and Compand do not conflict
; 233  :     int silence_match[6] = { 31, 0, 31, 0, 30, 0 };

	mov	DWORD PTR _silence_match$[ebp], 31	; 0000001fH
	mov	DWORD PTR _silence_match$[ebp+4], 0
	mov	DWORD PTR _silence_match$[ebp+8], 31	; 0000001fH
	mov	DWORD PTR _silence_match$[ebp+12], 0
	mov	DWORD PTR _silence_match$[ebp+16], 30	; 0000001eH
	mov	DWORD PTR _silence_match$[ebp+20], 0

; 234  : 	int inputBuff[6];
; 235  : 	int i;
; 236  : 
; 237  : 	bits = 5;//(int) InputCompBits( compBuf, 8 );

	mov	DWORD PTR _bits$[ebp], 5

; 238  : 
; 239  : 	count = *actSize = 0x2800;//InputCompBits( compBuf, 32 );//387576

	mov	eax, DWORD PTR _actSize$[ebp]
	mov	DWORD PTR [eax], 10240			; 00002800H
	mov	DWORD PTR _count$[ebp], 10240		; 00002800H

; 240  : //	ptr = ouputBuffer = ( unsigned char * )malloc( *actSize );
; 241  : 	ptr = ouputBuffer = new unsigned char[*actSize];

	mov	ecx, DWORD PTR _actSize$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR _ouputBuffer$[ebp], eax
	mov	ecx, DWORD PTR _ouputBuffer$[ebp]
	mov	DWORD PTR _ptr$[ebp], ecx

; 242  : 	memset( ptr, 0x80, *actSize );

	mov	edx, DWORD PTR _actSize$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	128					; 00000080H
	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
$LN12@ExpandBuff:

; 243  : 
; 244  :     while ( count > 0 ) 

	cmp	DWORD PTR _count$[ebp], 0
	jle	$LN11@ExpandBuff

; 245  : 		{
; 246  : 		c = (int) InputCompBits( compBuf, bits );

	mov	edx, DWORD PTR _bits$[ebp]
	push	edx
	mov	eax, DWORD PTR _compBuf$[ebp]
	push	eax
	call	?InputCompBits@@YAKPAUcompression_buf_t@@H@Z ; InputCompBits
	add	esp, 8
	mov	DWORD PTR _c$[ebp], eax

; 247  : 
; 248  : 		if ( c == 31 )

	cmp	DWORD PTR _c$[ebp], 31			; 0000001fH
	jne	$LN10@ExpandBuff

; 249  : 			{
; 250  : 			inputBuff[0] = c;

	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR _inputBuff$[ebp+ecx], edx

; 251  : 
; 252  : 			for(i = 1; i < 6; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN9@ExpandBuff
$LN8@ExpandBuff:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN9@ExpandBuff:
	cmp	DWORD PTR _i$[ebp], 6
	jge	SHORT $LN7@ExpandBuff

; 253  : 				{
; 254  : 				inputBuff[i] = (int) InputCompBits( compBuf, bits );

	mov	ecx, DWORD PTR _bits$[ebp]
	push	ecx
	mov	edx, DWORD PTR _compBuf$[ebp]
	push	edx
	call	?InputCompBits@@YAKPAUcompression_buf_t@@H@Z ; InputCompBits
	add	esp, 8
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _inputBuff$[ebp+ecx*4], eax

; 255  : 				}

	jmp	SHORT $LN8@ExpandBuff
$LN7@ExpandBuff:

; 256  : 
; 257  : 			if( memcmp( &inputBuff, &silence_match, 6 ) )

	push	6
	lea	edx, DWORD PTR _silence_match$[ebp]
	push	edx
	lea	eax, DWORD PTR _inputBuff$[ebp]
	push	eax
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@ExpandBuff

; 258  : 				{
; 259  : 				for(i = 0; i < 6; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN5@ExpandBuff
$LN4@ExpandBuff:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN5@ExpandBuff:
	cmp	DWORD PTR _i$[ebp], 6
	jge	SHORT $LN3@ExpandBuff

; 260  : 					{
; 261  : 					*ptr = ( unsigned char )expand[ inputBuff[i] ];

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _inputBuff$[ebp+edx*4]
	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	dl, BYTE PTR ?expand@@3PAHA[eax*4]
	mov	BYTE PTR [ecx], dl

; 262  : 					ptr++;

	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, 1
	mov	DWORD PTR _ptr$[ebp], eax

; 263  : 					count--;

	mov	ecx, DWORD PTR _count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _count$[ebp], ecx

; 264  : 					}

	jmp	SHORT $LN4@ExpandBuff
$LN3@ExpandBuff:

; 265  : 				}
; 266  : 			else

	jmp	SHORT $LN2@ExpandBuff
$LN6@ExpandBuff:

; 267  : 				{
; 268  : 				run_count = (int) InputCompBits( compBuf, 8 );

	push	8
	mov	edx, DWORD PTR _compBuf$[ebp]
	push	edx
	call	?InputCompBits@@YAKPAUcompression_buf_t@@H@Z ; InputCompBits
	add	esp, 8
	mov	DWORD PTR _run_count$[ebp], eax

; 269  : 				memset( ptr, 0x80, run_count );

	mov	eax, DWORD PTR _run_count$[ebp]
	push	eax
	push	128					; 00000080H
	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 270  : 				ptr+=run_count;

	mov	edx, DWORD PTR _ptr$[ebp]
	add	edx, DWORD PTR _run_count$[ebp]
	mov	DWORD PTR _ptr$[ebp], edx

; 271  : 				count-=run_count;

	mov	eax, DWORD PTR _count$[ebp]
	sub	eax, DWORD PTR _run_count$[ebp]
	mov	DWORD PTR _count$[ebp], eax

; 272  : 				run_count = 0;

	mov	DWORD PTR _run_count$[ebp], 0
$LN2@ExpandBuff:

; 273  : 				}
; 274  : 			}
; 275  : 		else

	jmp	SHORT $LN1@ExpandBuff
$LN10@ExpandBuff:

; 276  : 			{
; 277  : 			*ptr = ( unsigned char )expand[ c ];

	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	edx, DWORD PTR _c$[ebp]
	mov	al, BYTE PTR ?expand@@3PAHA[edx*4]
	mov	BYTE PTR [ecx], al

; 278  : 			ptr++;

	mov	ecx, DWORD PTR _ptr$[ebp]
	add	ecx, 1
	mov	DWORD PTR _ptr$[ebp], ecx

; 279  : 			count--;

	mov	edx, DWORD PTR _count$[ebp]
	sub	edx, 1
	mov	DWORD PTR _count$[ebp], edx
$LN1@ExpandBuff:

; 280  : 			}
; 281  : 		}

	jmp	$LN12@ExpandBuff
$LN11@ExpandBuff:

; 282  : 
; 283  : 	return( ouputBuffer );

	mov	eax, DWORD PTR _ouputBuffer$[ebp]

; 284  : 	}

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?ExpandBuffer@@YAPAEPAUcompression_buf_t@@PAJ@Z ENDP	; ExpandBuffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\silence.cpp
_TEXT	SEGMENT
_count$ = -76						; size = 4
tv136 = -72						; size = 4
_bits$ = -68						; size = 4
_run_count$ = -64					; size = 4
_c$ = -60						; size = 4
_i$ = -56						; size = 4
_inputBuff$ = -52					; size = 24
_silence_match$ = -28					; size = 24
__$ArrayPad$ = -4					; size = 4
_input$ = 8						; size = 4
_output$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
?ExpandFile@@YAXPAUbit_file@@PAU_iobuf@@HQAPAD@Z PROC	; ExpandFile

; 176  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 177  :     int		c;
; 178  :     int		run_count;
; 179  :     int		bits;
; 180  :     long	count;
; 181  : 
; 182  : 	//Update so Silence and Compand do not conflict
; 183  :     int silence_match[6] = { 31, 0, 31, 0, 30, 0 };

	mov	DWORD PTR _silence_match$[ebp], 31	; 0000001fH
	mov	DWORD PTR _silence_match$[ebp+4], 0
	mov	DWORD PTR _silence_match$[ebp+8], 31	; 0000001fH
	mov	DWORD PTR _silence_match$[ebp+12], 0
	mov	DWORD PTR _silence_match$[ebp+16], 30	; 0000001eH
	mov	DWORD PTR _silence_match$[ebp+20], 0

; 184  : 	int inputBuff[6];
; 185  : 	int i;
; 186  : 
; 187  : 	bits = (int) InputBits( input, 8 );

	push	8
	mov	eax, DWORD PTR _input$[ebp]
	push	eax
	call	?InputBits@@YAKPAUbit_file@@H@Z		; InputBits
	add	esp, 8
	mov	DWORD PTR _bits$[ebp], eax

; 188  : 
; 189  : 	count = InputBits( input, 32 );

	push	32					; 00000020H
	mov	ecx, DWORD PTR _input$[ebp]
	push	ecx
	call	?InputBits@@YAKPAUbit_file@@H@Z		; InputBits
	add	esp, 8
	mov	DWORD PTR _count$[ebp], eax
$LN14@ExpandFile:

; 190  : 
; 191  :     while ( ( c = (int) InputBits( input, bits ) ) != EOF ) 

	mov	edx, DWORD PTR _bits$[ebp]
	push	edx
	mov	eax, DWORD PTR _input$[ebp]
	push	eax
	call	?InputBits@@YAKPAUbit_file@@H@Z		; InputBits
	add	esp, 8
	mov	DWORD PTR _c$[ebp], eax
	cmp	DWORD PTR _c$[ebp], -1
	je	$LN15@ExpandFile

; 192  : 		{
; 193  : 		if ( c == 31 )

	cmp	DWORD PTR _c$[ebp], 31			; 0000001fH
	jne	$LN12@ExpandFile

; 194  : 			{
; 195  : 			inputBuff[0] = c;

	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR _inputBuff$[ebp+ecx], edx

; 196  : 
; 197  : 			for(i = 1; i < 6; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN11@ExpandFile
$LN10@ExpandFile:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN11@ExpandFile:
	cmp	DWORD PTR _i$[ebp], 6
	jge	SHORT $LN9@ExpandFile

; 198  : 				{
; 199  : 				inputBuff[i] = (int) InputBits( input, bits );

	mov	ecx, DWORD PTR _bits$[ebp]
	push	ecx
	mov	edx, DWORD PTR _input$[ebp]
	push	edx
	call	?InputBits@@YAKPAUbit_file@@H@Z		; InputBits
	add	esp, 8
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _inputBuff$[ebp+ecx*4], eax

; 200  : 				}

	jmp	SHORT $LN10@ExpandFile
$LN9@ExpandFile:

; 201  : 
; 202  : 			if( memcmp( &inputBuff, &silence_match, 6 ) )

	push	6
	lea	edx, DWORD PTR _silence_match$[ebp]
	push	edx
	lea	eax, DWORD PTR _inputBuff$[ebp]
	push	eax
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN8@ExpandFile

; 203  : 				{
; 204  : 				for(i = 0; i < 6; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@ExpandFile
$LN6@ExpandFile:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN7@ExpandFile:
	cmp	DWORD PTR _i$[ebp], 6
	jge	SHORT $LN5@ExpandFile

; 205  : 					{
; 206  : 					c = inputBuff[i];

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _inputBuff$[ebp+edx*4]
	mov	DWORD PTR _c$[ebp], eax

; 207  : 					putc( expand[ inputBuff[i] ], output );

	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _inputBuff$[ebp+edx*4]
	mov	ecx, DWORD PTR ?expand@@3PAHA[eax*4]
	push	ecx
	call	_putc
	add	esp, 8

; 208  : 					}

	jmp	SHORT $LN6@ExpandFile
$LN5@ExpandFile:

; 209  : 				}
; 210  : 			else

	jmp	SHORT $LN4@ExpandFile
$LN8@ExpandFile:

; 211  : 				{
; 212  : 				run_count = (int) InputBits( input, 8 );

	push	8
	mov	edx, DWORD PTR _input$[ebp]
	push	edx
	call	?InputBits@@YAKPAUbit_file@@H@Z		; InputBits
	add	esp, 8
	mov	DWORD PTR _run_count$[ebp], eax
$LN3@ExpandFile:

; 213  : 				while ( run_count-- > 0 )

	mov	eax, DWORD PTR _run_count$[ebp]
	mov	DWORD PTR tv136[ebp], eax
	mov	ecx, DWORD PTR _run_count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _run_count$[ebp], ecx
	cmp	DWORD PTR tv136[ebp], 0
	jle	SHORT $LN4@ExpandFile

; 214  : 					putc( 0x80, output );

	mov	edx, DWORD PTR _output$[ebp]
	push	edx
	push	128					; 00000080H
	call	_putc
	add	esp, 8
	jmp	SHORT $LN3@ExpandFile
$LN4@ExpandFile:

; 215  : 				}
; 216  : 			}
; 217  : 		else

	jmp	SHORT $LN1@ExpandFile
$LN12@ExpandFile:

; 218  : 			putc( expand[ c ], output );

	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	mov	ecx, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR ?expand@@3PAHA[ecx*4]
	push	edx
	call	_putc
	add	esp, 8
$LN1@ExpandFile:

; 219  : 		}

	jmp	$LN14@ExpandFile
$LN15@ExpandFile:

; 220  : 
; 221  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?ExpandFile@@YAXPAUbit_file@@PAU_iobuf@@HQAPAD@Z ENDP	; ExpandFile
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\silence.cpp
_TEXT	SEGMENT
tv195 = -1124						; size = 8
_value$ = -1116						; size = 4
_bits$ = -1112						; size = 4
_steps$ = -1108						; size = 4
_j$ = -1104						; size = 4
_k$ = -1100						; size = 4
_run_length$ = -1096					; size = 4
_index$ = -1092						; size = 4
_i$ = -1088						; size = 4
_compress$ = -1084					; size = 1024
_look_ahead$ = -60					; size = 32
_silence_match$ = -28					; size = 24
__$ArrayPad$ = -4					; size = 4
_input$ = 8						; size = 4
_output$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
?CompressFile@@YAXPAU_iobuf@@PAUbit_file@@HQAPAD@Z PROC	; CompressFile

; 89   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1124				; 00000464H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 90   :     int look_ahead[ BUFFER_SIZE ];
; 91   :     int index;
; 92   :     int i;
; 93   :     int run_length;
; 94   : 
; 95   : 	//Update so Silence and Compand do not conflict
; 96   :     int silence_match[6] = { 31, 0, 31, 0, 30, 0 };

	mov	DWORD PTR _silence_match$[ebp], 31	; 0000001fH
	mov	DWORD PTR _silence_match$[ebp+4], 0
	mov	DWORD PTR _silence_match$[ebp+8], 31	; 0000001fH
	mov	DWORD PTR _silence_match$[ebp+12], 0
	mov	DWORD PTR _silence_match$[ebp+16], 30	; 0000001eH
	mov	DWORD PTR _silence_match$[ebp+20], 0

; 97   : 
; 98   : 	// Compand addition
; 99   :     int compress[ 256 ];
; 100  :     int steps;
; 101  :     int bits;
; 102  :     int value;
; 103  :     int k;
; 104  :     int j;
; 105  : 
; 106  : 	bits = 5;

	mov	DWORD PTR _bits$[ebp], 5

; 107  :     steps = ( 1 << ( bits - 1 ) );

	mov	ecx, DWORD PTR _bits$[ebp]
	sub	ecx, 1
	mov	eax, 1
	shl	eax, cl
	mov	DWORD PTR _steps$[ebp], eax

; 108  : 
; 109  :   //  OutputBits( output, (unsigned long) bits, 8 );
; 110  :   //  OutputBits( output, (unsigned long) get_file_length( input ), 32 );
; 111  : 
; 112  :     for ( k = steps ; k > 0; k-- ) {

	mov	ecx, DWORD PTR _steps$[ebp]
	mov	DWORD PTR _k$[ebp], ecx
	jmp	SHORT $LN24@CompressFi
$LN23@CompressFi:
	mov	edx, DWORD PTR _k$[ebp]
	sub	edx, 1
	mov	DWORD PTR _k$[ebp], edx
$LN24@CompressFi:
	cmp	DWORD PTR _k$[ebp], 0
	jle	$LN22@CompressFi

; 113  :         value = (int)
; 114  :            ( 128.0 * ( pow( 2.0, (double) k  /  steps ) - 1.0 ) + 0.5 );

	cvtsi2sd xmm0, DWORD PTR _k$[ebp]
	cvtsi2sd xmm1, DWORD PTR _steps$[ebp]
	divsd	xmm0, xmm1
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR __real@4000000000000000
	movsd	QWORD PTR [esp], xmm0
	call	_pow
	add	esp, 16					; 00000010H
	fstp	QWORD PTR tv195[ebp]
	movsd	xmm0, QWORD PTR tv195[ebp]
	subsd	xmm0, QWORD PTR __real@3ff0000000000000
	mulsd	xmm0, QWORD PTR __real@4060000000000000
	addsd	xmm0, QWORD PTR __real@3fe0000000000000
	cvttsd2si eax, xmm0
	mov	DWORD PTR _value$[ebp], eax

; 115  :         for ( j = value ; j > 0 ; j-- ) {

	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _j$[ebp], ecx
	jmp	SHORT $LN21@CompressFi
$LN20@CompressFi:
	mov	edx, DWORD PTR _j$[ebp]
	sub	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$LN21@CompressFi:
	cmp	DWORD PTR _j$[ebp], 0
	jle	SHORT $LN19@CompressFi

; 116  :             compress[ j + 127 ] = k + steps - 1;

	mov	eax, DWORD PTR _steps$[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	lea	edx, DWORD PTR [ecx+eax-1]
	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR _compress$[ebp+eax*4+508], edx

; 117  :             compress[ 128 - j ] = steps - k;

	mov	ecx, DWORD PTR _steps$[ebp]
	sub	ecx, DWORD PTR _k$[ebp]
	mov	edx, 128				; 00000080H
	sub	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR _compress$[ebp+edx*4], ecx

; 118  :         }

	jmp	SHORT $LN20@CompressFi
$LN19@CompressFi:

; 119  :     }

	jmp	$LN23@CompressFi
$LN22@CompressFi:

; 120  : 
; 121  :     for ( i = 0 ; i < BUFFER_SIZE ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN18@CompressFi
$LN17@CompressFi:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN18@CompressFi:
	cmp	DWORD PTR _i$[ebp], 8
	jge	SHORT $LN16@CompressFi

; 122  :         look_ahead[ i ] = getc( input );

	mov	ecx, DWORD PTR _input$[ebp]
	push	ecx
	call	_getc
	add	esp, 4
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _look_ahead$[ebp+edx*4], eax
	jmp	SHORT $LN17@CompressFi
$LN16@CompressFi:

; 123  :     index = 0;

	mov	DWORD PTR _index$[ebp], 0
$LN15@CompressFi:

; 124  :     for ( ; ; ) 
; 125  : 		{
; 126  :         if ( look_ahead[ index ] == EOF )

	mov	eax, DWORD PTR _index$[ebp]
	cmp	DWORD PTR _look_ahead$[ebp+eax*4], -1
	jne	SHORT $LN13@CompressFi

; 127  :             break;

	jmp	$LN14@CompressFi
$LN13@CompressFi:

; 128  : 		/*
; 129  : 		 * If a run has started, I handle it here.   I sit in the do loop until
; 130  : 		 * the run is complete, loading new characters all the while.
; 131  : 		 */
; 132  :         if ( silence_run( look_ahead, index ) ) 

	mov	ecx, DWORD PTR _index$[ebp]
	push	ecx
	lea	edx, DWORD PTR _look_ahead$[ebp]
	push	edx
	call	?silence_run@@YAHQAHH@Z			; silence_run
	add	esp, 8
	test	eax, eax
	je	$LN4@CompressFi

; 133  : 			{
; 134  :             run_length = 0;

	mov	DWORD PTR _run_length$[ebp], 0
$LN11@CompressFi:

; 135  : 
; 136  :             do {
; 137  :                 look_ahead[ index++ ] = getc( input );

	mov	eax, DWORD PTR _input$[ebp]
	push	eax
	call	_getc
	add	esp, 4
	mov	ecx, DWORD PTR _index$[ebp]
	mov	DWORD PTR _look_ahead$[ebp+ecx*4], eax
	mov	edx, DWORD PTR _index$[ebp]
	add	edx, 1
	mov	DWORD PTR _index$[ebp], edx

; 138  :                 index &= BUFFER_MASK;

	mov	eax, DWORD PTR _index$[ebp]
	and	eax, 7
	mov	DWORD PTR _index$[ebp], eax

; 139  :                 if ( ++run_length == 255 ) 

	mov	ecx, DWORD PTR _run_length$[ebp]
	add	ecx, 1
	mov	DWORD PTR _run_length$[ebp], ecx
	cmp	DWORD PTR _run_length$[ebp], 255	; 000000ffH
	jne	SHORT $LN8@CompressFi

; 140  : 					{
; 141  : 					for( i=0; i<6; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@CompressFi
$LN6@CompressFi:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN7@CompressFi:
	cmp	DWORD PTR _i$[ebp], 6
	jge	SHORT $LN5@CompressFi

; 142  : 						{
; 143  : 						OutputBits( output, (unsigned long) silence_match[i], bits );

	mov	eax, DWORD PTR _bits$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _silence_match$[ebp+ecx*4]
	push	edx
	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	call	?OutputBits@@YAXPAUbit_file@@KH@Z	; OutputBits
	add	esp, 12					; 0000000cH

; 144  : 						}

	jmp	SHORT $LN6@CompressFi
$LN5@CompressFi:

; 145  : 					OutputBits( output, (unsigned long) run_length, 8 );

	push	8
	mov	ecx, DWORD PTR _run_length$[ebp]
	push	ecx
	mov	edx, DWORD PTR _output$[ebp]
	push	edx
	call	?OutputBits@@YAXPAUbit_file@@KH@Z	; OutputBits
	add	esp, 12					; 0000000cH
$LN8@CompressFi:

; 146  : 					}
; 147  :             } while ( !end_of_silence( look_ahead, index ) );

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	lea	ecx, DWORD PTR _look_ahead$[ebp]
	push	ecx
	call	?end_of_silence@@YAHQAHH@Z		; end_of_silence
	add	esp, 8
	test	eax, eax
	je	$LN11@CompressFi

; 148  :             if ( run_length > 0 ) 

	cmp	DWORD PTR _run_length$[ebp], 0
	jle	SHORT $LN4@CompressFi

; 149  : 				{
; 150  : 				for( i=0; i<6;i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@CompressFi
$LN2@CompressFi:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN3@CompressFi:
	cmp	DWORD PTR _i$[ebp], 6
	jge	SHORT $LN1@CompressFi

; 151  : 					{
; 152  : 					OutputBits( output, (unsigned long) silence_match[i], bits );

	mov	eax, DWORD PTR _bits$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _silence_match$[ebp+ecx*4]
	push	edx
	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	call	?OutputBits@@YAXPAUbit_file@@KH@Z	; OutputBits
	add	esp, 12					; 0000000cH

; 153  : 					}

	jmp	SHORT $LN2@CompressFi
$LN1@CompressFi:

; 154  : 				OutputBits( output, (unsigned long) run_length, 8 );

	push	8
	mov	ecx, DWORD PTR _run_length$[ebp]
	push	ecx
	mov	edx, DWORD PTR _output$[ebp]
	push	edx
	call	?OutputBits@@YAXPAUbit_file@@KH@Z	; OutputBits
	add	esp, 12					; 0000000cH
$LN4@CompressFi:

; 155  : 				}
; 156  : 			}
; 157  : 		/*
; 158  : 		 * Eventually, any run of silence is over, and I output some plain codes.
; 159  : 		 * Any code that accidentally matches the silence code gets silently changed.
; 160  : 		 */
; 161  : 		OutputBits( output, (unsigned long) compress[ look_ahead[ index ] ], bits );

	mov	eax, DWORD PTR _bits$[ebp]
	push	eax
	mov	ecx, DWORD PTR _index$[ebp]
	mov	edx, DWORD PTR _look_ahead$[ebp+ecx*4]
	mov	eax, DWORD PTR _compress$[ebp+edx*4]
	push	eax
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	call	?OutputBits@@YAXPAUbit_file@@KH@Z	; OutputBits
	add	esp, 12					; 0000000cH

; 162  : 
; 163  :         look_ahead[ index++ ] = getc( input );

	mov	edx, DWORD PTR _input$[ebp]
	push	edx
	call	_getc
	add	esp, 4
	mov	ecx, DWORD PTR _index$[ebp]
	mov	DWORD PTR _look_ahead$[ebp+ecx*4], eax
	mov	edx, DWORD PTR _index$[ebp]
	add	edx, 1
	mov	DWORD PTR _index$[ebp], edx

; 164  :         index &= BUFFER_MASK;

	mov	eax, DWORD PTR _index$[ebp]
	and	eax, 7
	mov	DWORD PTR _index$[ebp], eax

; 165  : 		}

	jmp	$LN15@CompressFi
$LN14@CompressFi:

; 166  : 
; 167  : 	}

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?CompressFile@@YAXPAU_iobuf@@PAUbit_file@@HQAPAD@Z ENDP	; CompressFile
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\silence.cpp
_TEXT	SEGMENT
_i$ = -4						; size = 4
_buffer$ = 8						; size = 4
_index$ = 12						; size = 4
?end_of_silence@@YAHQAHH@Z PROC				; end_of_silence

; 628  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 629  :     int i;
; 630  : 
; 631  :     for ( i = 0 ; i < STOP_THRESHOLD ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@end_of_sil
$LN3@end_of_sil:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@end_of_sil:
	cmp	DWORD PTR _i$[ebp], 2
	jge	SHORT $LN2@end_of_sil

; 632  :         if ( IS_SILENCE( buffer[ ( index + i ) & BUFFER_MASK ] ) )

	mov	ecx, DWORD PTR _index$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	and	ecx, 7
	mov	edx, DWORD PTR _buffer$[ebp]
	cmp	DWORD PTR [edx+ecx*4], 123		; 0000007bH
	jle	SHORT $LN1@end_of_sil
	mov	eax, DWORD PTR _index$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	and	eax, 7
	mov	ecx, DWORD PTR _buffer$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 132		; 00000084H
	jge	SHORT $LN1@end_of_sil

; 633  :             return( 0 );

	xor	eax, eax
	jmp	SHORT $LN5@end_of_sil
$LN1@end_of_sil:

; 634  :     return( 1 );

	jmp	SHORT $LN3@end_of_sil
$LN2@end_of_sil:
	mov	eax, 1
$LN5@end_of_sil:

; 635  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?end_of_silence@@YAHQAHH@Z ENDP				; end_of_silence
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\silence.cpp
_TEXT	SEGMENT
_i$ = -4						; size = 4
_buffer$ = 8						; size = 4
_index$ = 12						; size = 4
?silence_run@@YAHQAHH@Z PROC				; silence_run

; 611  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 612  :     int i;
; 613  : 
; 614  :     for ( i = 0 ; i < START_THRESHOLD ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN5@silence_ru
$LN4@silence_ru:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN5@silence_ru:
	cmp	DWORD PTR _i$[ebp], 5
	jge	SHORT $LN3@silence_ru

; 615  :         if ( !IS_SILENCE( buffer[ ( index + i ) & BUFFER_MASK ] ) )

	mov	ecx, DWORD PTR _index$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	and	ecx, 7
	mov	edx, DWORD PTR _buffer$[ebp]
	cmp	DWORD PTR [edx+ecx*4], 123		; 0000007bH
	jle	SHORT $LN1@silence_ru
	mov	eax, DWORD PTR _index$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	and	eax, 7
	mov	ecx, DWORD PTR _buffer$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 132		; 00000084H
	jl	SHORT $LN2@silence_ru
$LN1@silence_ru:

; 616  :             return( 0 );

	xor	eax, eax
	jmp	SHORT $LN6@silence_ru
$LN2@silence_ru:

; 617  :     return( 1 );

	jmp	SHORT $LN4@silence_ru
$LN3@silence_ru:
	mov	eax, 1
$LN6@silence_ru:

; 618  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?silence_run@@YAHQAHH@Z ENDP				; silence_run
_TEXT	ENDS
END
