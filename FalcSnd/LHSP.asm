; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\FalcSnd\LHSP.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
PUBLIC	??0LHSP@@QAE@XZ					; LHSP::LHSP
PUBLIC	??1LHSP@@QAE@XZ					; LHSP::~LHSP
PUBLIC	?InitializeLHSP@LHSP@@QAEXXZ			; LHSP::InitializeLHSP
PUBLIC	?ReadLHSPFile@LHSP@@QAEJPAUCOMPRESSION_DATA@@PAPAE@Z ; LHSP::ReadLHSPFile
PUBLIC	?CleanupLHSP@LHSP@@QAEXXZ			; LHSP::CleanupLHSP
EXTRN	_ST80_Open_Decoder@4:PROC
EXTRN	_ST80_Decode@20:PROC
EXTRN	_ST80_Close_Decoder@4:PROC
EXTRN	_ST80_GetCodecInfoEx@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___security_cookie:DWORD
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\lhsp.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CleanupLHSP@LHSP@@QAEXXZ PROC				; LHSP::CleanupLHSP
; _this$ = ecx

; 130  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 131  : 	//delete lpInputUncoded;
; 132  : 	
; 133  : 	ST80_Close_Decoder( hAccess );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_ST80_Close_Decoder@4

; 134  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CleanupLHSP@LHSP@@QAEXXZ ENDP				; LHSP::CleanupLHSP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\lhsp.cpp
_TEXT	SEGMENT
_errorCode$ = -28					; size = 4
_compDecodeSize$ = -24					; size = 4
_outputCodedSize$ = -20					; size = 4
_outputPtr$ = -16					; size = 4
_this$ = -12						; size = 4
_decodeSize$ = -8					; size = 4
_loopCount$ = -4					; size = 4
_input$ = 8						; size = 4
_buffer$ = 12						; size = 4
?ReadLHSPFile@LHSP@@QAEJPAUCOMPRESSION_DATA@@PAPAE@Z PROC ; LHSP::ReadLHSPFile
; _this$ = ecx

; 71   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 72   :     unsigned char	*outputPtr;
; 73   : 	unsigned long	errorCode;
; 74   : 	long			outputCodedSize;
; 75   : 	long			loopCount, decodeSize, compDecodeSize = 0;

	mov	DWORD PTR _compDecodeSize$[ebp], 0

; 76   : 	
; 77   : 	if ( input->bytesRead >= input->compFileLength )

	mov	eax, DWORD PTR _input$[ebp]
	mov	ecx, DWORD PTR _input$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+12]
	jl	SHORT $LN7@ReadLHSPFi

; 78   : 		return 0;

	xor	eax, eax
	jmp	$LN8@ReadLHSPFi
$LN7@ReadLHSPFi:

; 79   : 	
; 80   : 	loopCount = input->compFileLength - input->bytesRead;

	mov	eax, DWORD PTR _input$[ebp]
	mov	ecx, DWORD PTR _input$[ebp]
	mov	edx, DWORD PTR [eax+12]
	sub	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _loopCount$[ebp], edx

; 81   : 	
; 82   : 	if ( loopCount > MAX_INDECODE_SIZE )

	cmp	DWORD PTR _loopCount$[ebp], 5060	; 000013c4H
	jle	SHORT $LN6@ReadLHSPFi

; 83   : 	{
; 84   : 		loopCount = MAX_INDECODE_SIZE;

	mov	DWORD PTR _loopCount$[ebp], 5060	; 000013c4H
$LN6@ReadLHSPFi:

; 85   : 	}
; 86   : 	
; 87   : 	outputCodedSize = PMSIZE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _outputCodedSize$[ebp], ecx

; 88   : 	outputPtr = *buffer;

	mov	edx, DWORD PTR _buffer$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _outputPtr$[ebp], eax
$LN5@ReadLHSPFi:

; 89   : 	
; 90   : 	while ( loopCount > 0 )

	cmp	DWORD PTR _loopCount$[ebp], 0
	jle	$LN4@ReadLHSPFi

; 91   : 	{
; 92   : 		decodeSize = loopCount;

	mov	ecx, DWORD PTR _loopCount$[ebp]
	mov	DWORD PTR _decodeSize$[ebp], ecx

; 93   : 		if ( decodeSize > CODESIZE ) 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _decodeSize$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jle	SHORT $LN3@ReadLHSPFi

; 94   : 			decodeSize = CODESIZE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _decodeSize$[ebp], edx
$LN3@ReadLHSPFi:

; 95   : 		
; 96   : 		/* I must check if Decode adjusts the output buffer size to use for channel struct */
; 97   : 		errorCode = ST80_Decode
; 98   : 		(
; 99   : 			hAccess,
; 100  : 			(unsigned char *)input->dataPtr,
; 101  : 			( LPWORD )&decodeSize,
; 102  : 			outputPtr,
; 103  : 			( LPWORD )&outputCodedSize
; 104  : 		);

	lea	eax, DWORD PTR _outputCodedSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _outputPtr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _decodeSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _input$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_ST80_Decode@20
	mov	DWORD PTR _errorCode$[ebp], eax

; 105  : 		
; 106  : 		if ( errorCode == LH_EBADARG )

	cmp	DWORD PTR _errorCode$[ebp], -2		; fffffffeH
	jne	SHORT $LN2@ReadLHSPFi

; 107  : 		{
; 108  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN8@ReadLHSPFi
$LN2@ReadLHSPFi:

; 109  : 		}
; 110  : 		if ( errorCode == LH_BADHANDLE )

	cmp	DWORD PTR _errorCode$[ebp], -3		; fffffffdH
	jne	SHORT $LN1@ReadLHSPFi

; 111  : 		{
; 112  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN8@ReadLHSPFi
$LN1@ReadLHSPFi:

; 113  : 		}
; 114  : 		
; 115  : 		input->dataPtr += decodeSize;

	mov	ecx, DWORD PTR _input$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, DWORD PTR _decodeSize$[ebp]
	mov	eax, DWORD PTR _input$[ebp]
	mov	DWORD PTR [eax+16], edx

; 116  : 		outputPtr += outputCodedSize;

	mov	ecx, DWORD PTR _outputPtr$[ebp]
	add	ecx, DWORD PTR _outputCodedSize$[ebp]
	mov	DWORD PTR _outputPtr$[ebp], ecx

; 117  : 		loopCount -= decodeSize;

	mov	edx, DWORD PTR _loopCount$[ebp]
	sub	edx, DWORD PTR _decodeSize$[ebp]
	mov	DWORD PTR _loopCount$[ebp], edx

; 118  : 		input->bytesRead += decodeSize;

	mov	eax, DWORD PTR _input$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _decodeSize$[ebp]
	mov	edx, DWORD PTR _input$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 119  : 		compDecodeSize += outputCodedSize;

	mov	eax, DWORD PTR _compDecodeSize$[ebp]
	add	eax, DWORD PTR _outputCodedSize$[ebp]
	mov	DWORD PTR _compDecodeSize$[ebp], eax

; 120  : 	}

	jmp	$LN5@ReadLHSPFi
$LN4@ReadLHSPFi:

; 121  : 	
; 122  : 	return( compDecodeSize );

	mov	eax, DWORD PTR _compDecodeSize$[ebp]
$LN8@ReadLHSPFi:

; 123  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?ReadLHSPFile@LHSP@@QAEJPAUCOMPRESSION_DATA@@PAPAE@Z ENDP ; LHSP::ReadLHSPFile
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\lhsp.cpp
_TEXT	SEGMENT
tv71 = -136						; size = 4
_this$ = -132						; size = 4
_CodecInfoExStruct$ = -128				; size = 122
__$ArrayPad$ = -4					; size = 4
?InitializeLHSP@LHSP@@QAEXXZ PROC			; LHSP::InitializeLHSP
; _this$ = ecx

; 50   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 136				; 00000088H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 51   : 	CODECINFOEX		CodecInfoExStruct;
; 52   : 	
; 53   : 	ST80_GetCodecInfoEx( &CodecInfoExStruct, sizeof( CODECINFOEX ) );

	push	122					; 0000007aH
	lea	eax, DWORD PTR _CodecInfoExStruct$[ebp]
	push	eax
	call	_ST80_GetCodecInfoEx@8

; 54   : 	PMSIZE = CodecInfoExStruct.wInputBufferSize;

	movzx	ecx, WORD PTR _CodecInfoExStruct$[ebp+110]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 55   : 	CODESIZE = CodecInfoExStruct.wCodedBufferSize;

	movzx	eax, WORD PTR _CodecInfoExStruct$[ebp+112]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 56   : 	
; 57   : 	//	lpInputUncoded = new unsigned char[ MAXCODESIZE ];
; 58   : 	//lpInputUncoded = new unsigned char[ MAX_INDECODE_SIZE ];
; 59   : 	
; 60   : 	if ( ( hAccess = ST80_Open_Decoder( LINEAR_PCM_16_BIT ) ) == NULL )

	push	1
	call	_ST80_Open_Decoder@4
	mov	DWORD PTR tv71[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv71[ebp]
	mov	DWORD PTR [edx], eax

; 61   : 	{
; 62   : 		return;
; 63   : 	}
; 64   : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?InitializeLHSP@LHSP@@QAEXXZ ENDP			; LHSP::InitializeLHSP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\lhsp.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1LHSP@@QAE@XZ PROC					; LHSP::~LHSP
; _this$ = ecx

; 41   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 42   : 	CleanupLHSP();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CleanupLHSP@LHSP@@QAEXXZ		; LHSP::CleanupLHSP

; 43   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??1LHSP@@QAE@XZ ENDP					; LHSP::~LHSP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\lhsp.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0LHSP@@QAE@XZ PROC					; LHSP::LHSP
; _this$ = ecx

; 32   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 33   : 	
; 34   : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0LHSP@@QAE@XZ ENDP					; LHSP::LHSP
_TEXT	ENDS
END
