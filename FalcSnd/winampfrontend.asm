; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\FalcSnd\winampfrontend.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
PUBLIC	??0WinAmpFrontEnd@@QAE@XZ			; WinAmpFrontEnd::WinAmpFrontEnd
PUBLIC	??1WinAmpFrontEnd@@QAE@XZ			; WinAmpFrontEnd::~WinAmpFrontEnd
PUBLIC	?InitWinAmp@WinAmpFrontEnd@@QAEXXZ		; WinAmpFrontEnd::InitWinAmp
PUBLIC	?StopAndFadeout@WinAmpFrontEnd@@QAEXXZ		; WinAmpFrontEnd::StopAndFadeout
PUBLIC	?Previous@WinAmpFrontEnd@@QAEXXZ		; WinAmpFrontEnd::Previous
PUBLIC	?Start@WinAmpFrontEnd@@QAEXXZ			; WinAmpFrontEnd::Start
PUBLIC	?Stop@WinAmpFrontEnd@@QAEXXZ			; WinAmpFrontEnd::Stop
PUBLIC	?Next@WinAmpFrontEnd@@QAEXXZ			; WinAmpFrontEnd::Next
PUBLIC	?VolUp@WinAmpFrontEnd@@QAEXXZ			; WinAmpFrontEnd::VolUp
PUBLIC	?VolDown@WinAmpFrontEnd@@QAEXXZ			; WinAmpFrontEnd::VolDown
PUBLIC	?TogglePlayback@WinAmpFrontEnd@@QAEXXZ		; WinAmpFrontEnd::TogglePlayback
PUBLIC	?getCurTitle@WinAmpFrontEnd@@QAEPADXZ		; WinAmpFrontEnd::getCurTitle
PUBLIC	?getDEDTitle@WinAmpFrontEnd@@QAEPADH@Z		; WinAmpFrontEnd::getDEDTitle
PUBLIC	?getVolume@WinAmpFrontEnd@@QAEHXZ		; WinAmpFrontEnd::getVolume
PUBLIC	?Refresh@WinAmpFrontEnd@@QAEXK@Z		; WinAmpFrontEnd::Refresh
PUBLIC	?copyCurTitle@WinAmpFrontEnd@@AAEXXZ		; WinAmpFrontEnd::copyCurTitle
PUBLIC	??_C@_0BA@DOCJNCKG@Not?5initialized?$AA@	; `string'
PUBLIC	??_C@_0M@CIHMPBEC@Winamp?5v1?4x?$AA@		; `string'
PUBLIC	??_C@_08JABPBNJH@?9?5Winamp?$AA@		; `string'
PUBLIC	??_C@_0BO@CABFFIPA@No?5WinAMP?52?4xx?5window?5found?5?$CB?$AA@ ; `string'
PUBLIC	??_C@_0BJ@JHJAGFLH@No?5WinAMP?5window?5found?5?$CB?$AA@ ; `string'
EXTRN	_sprintf:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	_strcpy:PROC
EXTRN	_strlen:PROC
EXTRN	_strncpy:PROC
EXTRN	_strnicmp:PROC
EXTRN	__imp__SendMessageA@16:PROC
EXTRN	__imp__GetWindowTextA@12:PROC
EXTRN	__imp__FindWindowA@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	?g_nWinAmpInitVolume@@3HA:DWORD			; g_nWinAmpInitVolume
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
_allocator_arg DB 01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT ??_C@_0BJ@JHJAGFLH@No?5WinAMP?5window?5found?5?$CB?$AA@
CONST	SEGMENT
??_C@_0BJ@JHJAGFLH@No?5WinAMP?5window?5found?5?$CB?$AA@ DB 'No WinAMP win'
	DB	'dow found !', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@CABFFIPA@No?5WinAMP?52?4xx?5window?5found?5?$CB?$AA@
CONST	SEGMENT
??_C@_0BO@CABFFIPA@No?5WinAMP?52?4xx?5window?5found?5?$CB?$AA@ DB 'No Win'
	DB	'AMP 2.xx window found !', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08JABPBNJH@?9?5Winamp?$AA@
CONST	SEGMENT
??_C@_08JABPBNJH@?9?5Winamp?$AA@ DB '- Winamp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CIHMPBEC@Winamp?5v1?4x?$AA@
CONST	SEGMENT
??_C@_0M@CIHMPBEC@Winamp?5v1?4x?$AA@ DB 'Winamp v1.x', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DOCJNCKG@Not?5initialized?$AA@
CONST	SEGMENT
??_C@_0BA@DOCJNCKG@Not?5initialized?$AA@ DB 'Not initialized', 00H ; `string'
CONST	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\winampfrontend.cpp
_TEXT	SEGMENT
_len$ = -528						; size = 4
_this$ = -524						; size = 4
_p$ = -520						; size = 4
_this_title$ = -516					; size = 512
__$ArrayPad$ = -4					; size = 4
?copyCurTitle@WinAmpFrontEnd@@AAEXXZ PROC		; WinAmpFrontEnd::copyCurTitle
; _this$ = ecx

; 183  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 528				; 00000210H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 184  : 	if (!ampexists)	// should really not be necessary..

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	test	ecx, ecx
	jne	SHORT $LN12@copyCurTit

; 185  : 		return;

	jmp	$LN13@copyCurTit
$LN12@copyCurTit:

; 186  : 
; 187  : 	if (currentTrackTitle)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+8], 0
	je	SHORT $LN11@copyCurTit

; 188  : 	{
; 189  : 		free(currentTrackTitle);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_free
	add	esp, 4

; 190  : 		currentTrackTitle = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
$LN11@copyCurTit:

; 191  : 	}
; 192  : 
; 193  : 	char this_title[512],*p;
; 194  : 	int len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 195  : 
; 196  : 	len = GetWindowText(winamp_win,this_title,sizeof(this_title));

	push	512					; 00000200H
	lea	eax, DWORD PTR _this_title$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR __imp__GetWindowTextA@12
	mov	DWORD PTR _len$[ebp], eax

; 197  : 	if (len == 0)

	cmp	DWORD PTR _len$[ebp], 0
	jne	SHORT $LN10@copyCurTit

; 198  : 		return;

	jmp	$LN13@copyCurTit
$LN10@copyCurTit:

; 199  : 
; 200  : 	p = this_title+strlen(this_title)-8;

	lea	eax, DWORD PTR _this_title$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	lea	ecx, DWORD PTR _this_title$[ebp+eax-8]
	mov	DWORD PTR _p$[ebp], ecx
$LN9@copyCurTit:

; 201  : 	
; 202  : 	while (p >= this_title)

	lea	edx, DWORD PTR _this_title$[ebp]
	cmp	DWORD PTR _p$[ebp], edx
	jb	SHORT $LN8@copyCurTit

; 203  : 	{
; 204  : 		if (!strnicmp(p,"- Winamp",8))

	push	8
	push	OFFSET ??_C@_08JABPBNJH@?9?5Winamp?$AA@
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN7@copyCurTit

; 205  : 		{
; 206  : 			break;

	jmp	SHORT $LN8@copyCurTit
$LN7@copyCurTit:

; 207  : 		}
; 208  : 		p--;

	mov	ecx, DWORD PTR _p$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _p$[ebp], ecx

; 209  : 	}

	jmp	SHORT $LN9@copyCurTit
$LN8@copyCurTit:

; 210  : 	if (p >= this_title)

	lea	edx, DWORD PTR _this_title$[ebp]
	cmp	DWORD PTR _p$[ebp], edx
	jb	SHORT $LN5@copyCurTit

; 211  : 	{
; 212  : 		p--;

	mov	eax, DWORD PTR _p$[ebp]
	sub	eax, 1
	mov	DWORD PTR _p$[ebp], eax
$LN5@copyCurTit:

; 213  : 	}
; 214  : 	
; 215  : 	while (p >= this_title && *p == ' ')

	lea	ecx, DWORD PTR _this_title$[ebp]
	cmp	DWORD PTR _p$[ebp], ecx
	jb	SHORT $LN4@copyCurTit
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN4@copyCurTit

; 216  : 	{
; 217  : 		p--;

	mov	ecx, DWORD PTR _p$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _p$[ebp], ecx

; 218  : 	}

	jmp	SHORT $LN5@copyCurTit
$LN4@copyCurTit:

; 219  : 	*++p=0;

	mov	edx, DWORD PTR _p$[ebp]
	add	edx, 1
	mov	DWORD PTR _p$[ebp], edx
	mov	eax, DWORD PTR _p$[ebp]
	mov	BYTE PTR [eax], 0

; 220  : 
; 221  : 	currentTrackTitle = (char*)malloc(strlen(this_title)+1);

	lea	ecx, DWORD PTR _this_title$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	add	eax, 1
	push	eax
	call	_malloc
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax

; 222  : 	if (currentTrackTitle)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN3@copyCurTit

; 223  : 		strcpy(currentTrackTitle,this_title);

	lea	ecx, DWORD PTR _this_title$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_strcpy
	add	esp, 8
$LN3@copyCurTit:

; 224  : 
; 225  : 	// copying DED String 1
; 226  : 	strncpy(&DEDString[0][0],this_title,MY_MAX_DED_LEN-1);

	push	24					; 00000018H
	lea	ecx, DWORD PTR _this_title$[ebp]
	push	ecx
	mov	edx, 25					; 00000019H
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+12]
	mov	edx, 1
	imul	edx, 0
	add	ecx, edx
	push	ecx
	call	_strncpy
	add	esp, 12					; 0000000cH

; 227  : 	DEDString[0][MY_MAX_DED_LEN-1] = '\0';

	mov	eax, 25					; 00000019H
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+12]
	mov	eax, 1
	imul	eax, 24					; 00000018H
	mov	BYTE PTR [edx+eax], 0

; 228  : 	// ..if the title is longer, fill the rest in to DEDString 2
; 229  : 	if (strlen(this_title)>MY_MAX_DED_LEN-1)

	lea	ecx, DWORD PTR _this_title$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	cmp	eax, 24					; 00000018H
	jbe	SHORT $LN2@copyCurTit

; 230  : 	{
; 231  : 		strncpy(&DEDString[1][0],&this_title[MY_MAX_DED_LEN-1],MY_MAX_DED_LEN-1);

	push	24					; 00000018H
	mov	edx, 1
	imul	edx, 24					; 00000018H
	lea	eax, DWORD PTR _this_title$[ebp+edx]
	push	eax
	mov	ecx, 25					; 00000019H
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+12]
	mov	ecx, 1
	imul	ecx, 0
	add	eax, ecx
	push	eax
	call	_strncpy
	add	esp, 12					; 0000000cH

; 232  : 		DEDString[1][MY_MAX_DED_LEN-1] = '\0';

	mov	edx, 25					; 00000019H
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+12]
	mov	edx, 1
	imul	edx, 24					; 00000018H
	mov	BYTE PTR [ecx+edx], 0

; 233  : 	}
; 234  : 	else	// else don´t print it

	jmp	SHORT $LN13@copyCurTit
$LN2@copyCurTit:

; 235  : 	{
; 236  : 		DEDString[1][0] = '\0';

	mov	eax, 25					; 00000019H
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+12]
	mov	eax, 1
	imul	eax, 0
	mov	BYTE PTR [edx+eax], 0
$LN13@copyCurTit:

; 237  : 	}
; 238  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?copyCurTitle@WinAmpFrontEnd@@AAEXXZ ENDP		; WinAmpFrontEnd::copyCurTitle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\winampfrontend.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_timer$ = 8						; size = 4
?Refresh@WinAmpFrontEnd@@QAEXK@Z PROC			; WinAmpFrontEnd::Refresh
; _this$ = ecx

; 283  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 284  : 	if (!ampexists)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	test	ecx, ecx
	jne	SHORT $LN4@Refresh

; 285  : 		return;

	jmp	SHORT $LN5@Refresh
$LN4@Refresh:

; 286  : 
; 287  : 	if (timer > myTimer)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _timer$[ebp]
	cmp	eax, DWORD PTR [edx+68]
	jbe	SHORT $LN5@Refresh

; 288  : 	{
; 289  : 		copyCurTitle();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?copyCurTitle@WinAmpFrontEnd@@AAEXXZ	; WinAmpFrontEnd::copyCurTitle

; 290  : 		myTimer = timer + REFRESH_INTERVAL;

	mov	ecx, DWORD PTR _timer$[ebp]
	add	ecx, 2000				; 000007d0H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+68], ecx

; 291  : 
; 292  : 		WinAmpAlive++;	// once every 40 secs I check if winamp was deactivated..

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+72], ecx

; 293  : 		WinAmpAlive %= 20;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+72]
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+72], edx

; 294  : 		if (WinAmpAlive == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+72], 0
	jne	SHORT $LN5@Refresh

; 295  : 		{
; 296  : 			if (FindWindow("Winamp v1.x",NULL) == NULL)

	push	0
	push	OFFSET ??_C@_0M@CIHMPBEC@Winamp?5v1?4x?$AA@
	call	DWORD PTR __imp__FindWindowA@8
	test	eax, eax
	jne	SHORT $LN5@Refresh

; 297  : 			{
; 298  : 				ampexists = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+4], 0
$LN5@Refresh:

; 299  : 			}
; 300  : 		}
; 301  : 	}
; 302  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Refresh@WinAmpFrontEnd@@QAEXK@Z ENDP			; WinAmpFrontEnd::Refresh
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\winampfrontend.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getVolume@WinAmpFrontEnd@@QAEHXZ PROC			; WinAmpFrontEnd::getVolume
; _this$ = ecx

; 271  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 272  : 	if (!ampexists)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	test	ecx, ecx
	jne	SHORT $LN1@getVolume

; 273  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN2@getVolume
$LN1@getVolume:

; 274  : 
; 275  : 	return volume;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+64]
$LN2@getVolume:

; 276  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getVolume@WinAmpFrontEnd@@QAEHXZ ENDP			; WinAmpFrontEnd::getVolume
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\winampfrontend.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_theLine$ = 8						; size = 4
?getDEDTitle@WinAmpFrontEnd@@QAEPADH@Z PROC		; WinAmpFrontEnd::getDEDTitle
; _this$ = ecx

; 258  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 259  : 	if (!ampexists)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	test	ecx, ecx
	jne	SHORT $LN2@getDEDTitl

; 260  : 		return "No WinAMP window found !";

	mov	eax, OFFSET ??_C@_0BJ@JHJAGFLH@No?5WinAMP?5window?5found?5?$CB?$AA@
	jmp	SHORT $LN3@getDEDTitl
$LN2@getDEDTitl:

; 261  : 		
; 262  : 	if ((theLine != 0)&&(theLine != 1))

	cmp	DWORD PTR _theLine$[ebp], 0
	je	SHORT $LN1@getDEDTitl
	cmp	DWORD PTR _theLine$[ebp], 1
	je	SHORT $LN1@getDEDTitl

; 263  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN3@getDEDTitl
$LN1@getDEDTitl:

; 264  : 
; 265  : 	return DEDString[theLine];

	mov	edx, DWORD PTR _theLine$[ebp]
	imul	edx, 25					; 00000019H
	mov	eax, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [eax+edx+12]
$LN3@getDEDTitl:

; 266  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getDEDTitle@WinAmpFrontEnd@@QAEPADH@Z ENDP		; WinAmpFrontEnd::getDEDTitle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\winampfrontend.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getCurTitle@WinAmpFrontEnd@@QAEPADXZ PROC		; WinAmpFrontEnd::getCurTitle
; _this$ = ecx

; 244  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 245  : 	if (!ampexists)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	test	ecx, ecx
	jne	SHORT $LN1@getCurTitl

; 246  : 		return "No WinAMP 2.xx window found !";

	mov	eax, OFFSET ??_C@_0BO@CABFFIPA@No?5WinAMP?52?4xx?5window?5found?5?$CB?$AA@
	jmp	SHORT $LN2@getCurTitl
$LN1@getCurTitl:

; 247  : 
; 248  : 	return currentTrackTitle;	

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
$LN2@getCurTitl:

; 249  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getCurTitle@WinAmpFrontEnd@@QAEPADXZ ENDP		; WinAmpFrontEnd::getCurTitle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\winampfrontend.cpp
_TEXT	SEGMENT
tv73 = -12						; size = 4
_ret$ = -8						; size = 4
_this$ = -4						; size = 4
?TogglePlayback@WinAmpFrontEnd@@QAEXXZ PROC		; WinAmpFrontEnd::TogglePlayback
; _this$ = ecx

; 158  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 159  : 	if (!ampexists)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	test	ecx, ecx
	jne	SHORT $LN5@TogglePlay

; 160  : 		return;

	jmp	SHORT $LN6@TogglePlay
$LN5@TogglePlay:

; 161  : 
; 162  : 	int ret=SendMessage(winamp_win,WM_USER, 0, 104);

	push	104					; 00000068H
	push	0
	push	1024					; 00000400H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR __imp__SendMessageA@16
	mov	DWORD PTR _ret$[ebp], eax

; 163  : 	switch (ret)

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	cmp	DWORD PTR tv73[ebp], 1
	je	SHORT $LN2@TogglePlay
	jmp	SHORT $LN1@TogglePlay
$LN2@TogglePlay:

; 164  : 	{
; 165  : 		case 1:	Stop(); break;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Stop@WinAmpFrontEnd@@QAEXXZ		; WinAmpFrontEnd::Stop
	jmp	SHORT $LN3@TogglePlay
$LN1@TogglePlay:

; 166  : 		default:
; 167  : 		case 3: Start(); break;	// actually, 3 is the 'paused' status.. but whatever..

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Start@WinAmpFrontEnd@@QAEXXZ		; WinAmpFrontEnd::Start
$LN3@TogglePlay:

; 168  : 	}
; 169  : 	copyCurTitle();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?copyCurTitle@WinAmpFrontEnd@@AAEXXZ	; WinAmpFrontEnd::copyCurTitle
$LN6@TogglePlay:

; 170  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?TogglePlayback@WinAmpFrontEnd@@QAEXXZ ENDP		; WinAmpFrontEnd::TogglePlayback
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\winampfrontend.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?VolDown@WinAmpFrontEnd@@QAEXXZ PROC			; WinAmpFrontEnd::VolDown
; _this$ = ecx

; 146  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 147  : 	if ((ampexists)&&(volume>0))

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN2@VolDown
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+64], 0
	jle	SHORT $LN2@VolDown

; 148  : 	{
; 149  : 		volume--;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+64], ecx

; 150  : 		SendMessage(winamp_win, WM_COMMAND,WINAMP_VOLUMEDOWN,0);

	push	0
	push	40059					; 00009c7bH
	push	273					; 00000111H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __imp__SendMessageA@16
$LN2@VolDown:

; 151  : 	}
; 152  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?VolDown@WinAmpFrontEnd@@QAEXXZ ENDP			; WinAmpFrontEnd::VolDown
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\winampfrontend.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?VolUp@WinAmpFrontEnd@@QAEXXZ PROC			; WinAmpFrontEnd::VolUp
; _this$ = ecx

; 135  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 136  : 	if ((ampexists)&&(volume<255))

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN2@VolUp
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+64], 255			; 000000ffH
	jge	SHORT $LN2@VolUp

; 137  : 	{
; 138  : 		volume++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+64], ecx

; 139  : 		SendMessage(winamp_win, WM_COMMAND,WINAMP_VOLUMEUP,0);

	push	0
	push	40058					; 00009c7aH
	push	273					; 00000111H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __imp__SendMessageA@16
$LN2@VolUp:

; 140  : 	}
; 141  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?VolUp@WinAmpFrontEnd@@QAEXXZ ENDP			; WinAmpFrontEnd::VolUp
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\winampfrontend.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Next@WinAmpFrontEnd@@QAEXXZ PROC			; WinAmpFrontEnd::Next
; _this$ = ecx

; 124  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 125  : 	if (!ampexists)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	test	ecx, ecx
	jne	SHORT $LN1@Next

; 126  : 		return;

	jmp	SHORT $LN2@Next
$LN1@Next:

; 127  : 
; 128  : 	copyCurTitle();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?copyCurTitle@WinAmpFrontEnd@@AAEXXZ	; WinAmpFrontEnd::copyCurTitle

; 129  : 	SendMessage(winamp_win, WM_COMMAND,WINAMP_BUTTON5,0);

	push	0
	push	40048					; 00009c70H
	push	273					; 00000111H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR __imp__SendMessageA@16
$LN2@Next:

; 130  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Next@WinAmpFrontEnd@@QAEXXZ ENDP			; WinAmpFrontEnd::Next
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\winampfrontend.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Stop@WinAmpFrontEnd@@QAEXXZ PROC			; WinAmpFrontEnd::Stop
; _this$ = ecx

; 113  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 114  : 	if (!ampexists)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	test	ecx, ecx
	jne	SHORT $LN1@Stop

; 115  : 		return;

	jmp	SHORT $LN2@Stop
$LN1@Stop:

; 116  : 
; 117  : 	copyCurTitle();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?copyCurTitle@WinAmpFrontEnd@@AAEXXZ	; WinAmpFrontEnd::copyCurTitle

; 118  : 	SendMessage(winamp_win, WM_COMMAND,WINAMP_BUTTON4,0);

	push	0
	push	40047					; 00009c6fH
	push	273					; 00000111H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR __imp__SendMessageA@16
$LN2@Stop:

; 119  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Stop@WinAmpFrontEnd@@QAEXXZ ENDP			; WinAmpFrontEnd::Stop
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\winampfrontend.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Start@WinAmpFrontEnd@@QAEXXZ PROC			; WinAmpFrontEnd::Start
; _this$ = ecx

; 102  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 103  : 	if (!ampexists)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	test	ecx, ecx
	jne	SHORT $LN1@Start

; 104  : 		return;

	jmp	SHORT $LN2@Start
$LN1@Start:

; 105  : 
; 106  : 	copyCurTitle();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?copyCurTitle@WinAmpFrontEnd@@AAEXXZ	; WinAmpFrontEnd::copyCurTitle

; 107  : 	SendMessage(winamp_win, WM_COMMAND,WINAMP_BUTTON2,0);

	push	0
	push	40045					; 00009c6dH
	push	273					; 00000111H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR __imp__SendMessageA@16
$LN2@Start:

; 108  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Start@WinAmpFrontEnd@@QAEXXZ ENDP			; WinAmpFrontEnd::Start
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\winampfrontend.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Previous@WinAmpFrontEnd@@QAEXXZ PROC			; WinAmpFrontEnd::Previous
; _this$ = ecx

; 91   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 92   : 	if (!ampexists)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	test	ecx, ecx
	jne	SHORT $LN1@Previous

; 93   : 		return;

	jmp	SHORT $LN2@Previous
$LN1@Previous:

; 94   : 
; 95   : 	copyCurTitle();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?copyCurTitle@WinAmpFrontEnd@@AAEXXZ	; WinAmpFrontEnd::copyCurTitle

; 96   : 	SendMessage(winamp_win, WM_COMMAND,WINAMP_BUTTON1,0);

	push	0
	push	40044					; 00009c6cH
	push	273					; 00000111H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR __imp__SendMessageA@16
$LN2@Previous:

; 97   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Previous@WinAmpFrontEnd@@QAEXXZ ENDP			; WinAmpFrontEnd::Previous
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\winampfrontend.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?StopAndFadeout@WinAmpFrontEnd@@QAEXXZ PROC		; WinAmpFrontEnd::StopAndFadeout
; _this$ = ecx

; 80   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 81   : 	if (!ampexists)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	test	ecx, ecx
	jne	SHORT $LN1@StopAndFad

; 82   : 		return;

	jmp	SHORT $LN2@StopAndFad
$LN1@StopAndFad:

; 83   : 
; 84   : 	copyCurTitle();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?copyCurTitle@WinAmpFrontEnd@@AAEXXZ	; WinAmpFrontEnd::copyCurTitle

; 85   : 	SendMessage(winamp_win, WM_COMMAND,WINAMP_BUTTON4_SHIFT,0);

	push	0
	push	40147					; 00009cd3H
	push	273					; 00000111H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR __imp__SendMessageA@16
$LN2@StopAndFad:

; 86   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?StopAndFadeout@WinAmpFrontEnd@@QAEXXZ ENDP		; WinAmpFrontEnd::StopAndFadeout
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\winampfrontend.cpp
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
?InitWinAmp@WinAmpFrontEnd@@QAEXXZ PROC			; WinAmpFrontEnd::InitWinAmp
; _this$ = ecx

; 54   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 55   : 	// Find a window with classname "Winamp v1.x"
; 56   : 	// Returns NULL if not found
; 57   : 	winamp_win = FindWindow("Winamp v1.x",NULL);		

	push	0
	push	OFFSET ??_C@_0M@CIHMPBEC@Winamp?5v1?4x?$AA@
	call	DWORD PTR __imp__FindWindowA@8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 58   : 	if (winamp_win == NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN5@InitWinAmp

; 59   : 		ampexists=false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+4], 0

; 60   : 	else

	jmp	SHORT $LN4@InitWinAmp
$LN5@InitWinAmp:

; 61   : 	{
; 62   : 		ampexists=true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+4], 1

; 63   : 		// preinit volume (to 80% for now), so that I can sync
; 64   : 		// that with the DED display (via the 'volume' variable
; 65   : 		SendMessage(winamp_win,WM_USER, volume, 122);	

	push	122					; 0000007aH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+64]
	push	eax
	push	1024					; 00000400H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR __imp__SendMessageA@16
$LN4@InitWinAmp:

; 66   : 	}
; 67   : 
; 68   : 	for (int i = 0; i < 2; i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN3@InitWinAmp
$LN2@InitWinAmp:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN3@InitWinAmp:
	cmp	DWORD PTR _i$1[ebp], 2
	jge	SHORT $LN1@InitWinAmp

; 69   : 		sprintf(DEDString[i],"Not initialized");

	push	OFFSET ??_C@_0BA@DOCJNCKG@Not?5initialized?$AA@
	mov	ecx, DWORD PTR _i$1[ebp]
	imul	ecx, 25					; 00000019H
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+12]
	push	eax
	call	_sprintf
	add	esp, 8
	jmp	SHORT $LN2@InitWinAmp
$LN1@InitWinAmp:

; 70   : 
; 71   : 	myTimer = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+68], 0

; 72   : 	WinAmpAlive = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+72], 0

; 73   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?InitWinAmp@WinAmpFrontEnd@@QAEXXZ ENDP			; WinAmpFrontEnd::InitWinAmp
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\winampfrontend.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1WinAmpFrontEnd@@QAE@XZ PROC				; WinAmpFrontEnd::~WinAmpFrontEnd
; _this$ = ecx

; 42   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 43   : 	free(currentTrackTitle);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_free
	add	esp, 4

; 44   : 	currentTrackTitle = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 45   : };

	mov	esp, ebp
	pop	ebp
	ret	0
??1WinAmpFrontEnd@@QAE@XZ ENDP				; WinAmpFrontEnd::~WinAmpFrontEnd
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\winampfrontend.cpp
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
??0WinAmpFrontEnd@@QAE@XZ PROC				; WinAmpFrontEnd::WinAmpFrontEnd
; _this$ = ecx

; 22   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 23   : 	winamp_win = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 24   : 	currentTrackTitle = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 25   : 
; 26   : 	for (int i = 0; i < 2; i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN5@WinAmpFron
$LN4@WinAmpFron:
	mov	edx, DWORD PTR _i$1[ebp]
	add	edx, 1
	mov	DWORD PTR _i$1[ebp], edx
$LN5@WinAmpFron:
	cmp	DWORD PTR _i$1[ebp], 2
	jge	SHORT $LN3@WinAmpFron

; 27   : 		sprintf(DEDString[i],"Not initialized");

	push	OFFSET ??_C@_0BA@DOCJNCKG@Not?5initialized?$AA@
	mov	eax, DWORD PTR _i$1[ebp]
	imul	eax, 25					; 00000019H
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+12]
	push	edx
	call	_sprintf
	add	esp, 8
	jmp	SHORT $LN4@WinAmpFron
$LN3@WinAmpFron:

; 28   : 
; 29   : 	if ((g_nWinAmpInitVolume >= 0)&&(g_nWinAmpInitVolume <= 255))

	cmp	DWORD PTR ?g_nWinAmpInitVolume@@3HA, 0	; g_nWinAmpInitVolume
	jl	SHORT $LN2@WinAmpFron
	cmp	DWORD PTR ?g_nWinAmpInitVolume@@3HA, 255 ; g_nWinAmpInitVolume, 000000ffH
	jg	SHORT $LN2@WinAmpFron

; 30   : 		volume = g_nWinAmpInitVolume;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?g_nWinAmpInitVolume@@3HA ; g_nWinAmpInitVolume
	mov	DWORD PTR [eax+64], ecx

; 31   : 	else

	jmp	SHORT $LN1@WinAmpFron
$LN2@WinAmpFron:

; 32   : 		volume = INITIAL_VOLUME;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+64], 204			; 000000ccH
$LN1@WinAmpFron:

; 33   : 
; 34   : 	myTimer = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+68], 0

; 35   : 	WinAmpAlive = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+72], 0

; 36   : };

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0WinAmpFrontEnd@@QAE@XZ ENDP				; WinAmpFrontEnd::WinAmpFrontEnd
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
END
