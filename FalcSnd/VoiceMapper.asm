; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\FalcSnd\VoiceMapper.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?default_voices@VoiceMapper@@0QBIB		; VoiceMapper::default_voices
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?max_default_voices@VoiceMapper@@0HB		; VoiceMapper::max_default_voices
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	??_C@_03EAAJEIGN@atc?$AA@			; `string'
PUBLIC	??_C@_05LHOHBFG@awacs?$AA@			; `string'
PUBLIC	??_C@_03MHDDBBEP@fac?$AA@			; `string'
PUBLIC	??_C@_05KIBFDOPF@pilot?$AA@			; `string'
PUBLIC	??_C@_03NFKEKGGK@all?$AA@			; `string'
PUBLIC	??_C@_03OBJFJEBA@any?$AA@			; `string'
PUBLIC	??_C@_01HIHLOKLC@1?$AA@				; `string'
PUBLIC	??_C@_01FDFGLJHB@2?$AA@				; `string'
PUBLIC	??_C@_01EKENIIDA@3?$AA@				; `string'
PUBLIC	??_C@_01FAMBOPH@4?$AA@				; `string'
PUBLIC	??_C@_01BMBHCPLG@5?$AA@				; `string'
PUBLIC	??_C@_01DHDKHMHF@6?$AA@				; `string'
PUBLIC	??_C@_01COCBENDE@7?$AA@				; `string'
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	??_C@_01KJLJFBPL@8?$AA@				; `string'
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ??_C@_01KJLJFBPL@8?$AA@
CONST	SEGMENT
??_C@_01KJLJFBPL@8?$AA@ DB '8', 00H			; `string'
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ??_C@_01COCBENDE@7?$AA@
CONST	SEGMENT
??_C@_01COCBENDE@7?$AA@ DB '7', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01DHDKHMHF@6?$AA@
CONST	SEGMENT
??_C@_01DHDKHMHF@6?$AA@ DB '6', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01BMBHCPLG@5?$AA@
CONST	SEGMENT
??_C@_01BMBHCPLG@5?$AA@ DB '5', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01FAMBOPH@4?$AA@
CONST	SEGMENT
??_C@_01FAMBOPH@4?$AA@ DB '4', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01EKENIIDA@3?$AA@
CONST	SEGMENT
??_C@_01EKENIIDA@3?$AA@ DB '3', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01FDFGLJHB@2?$AA@
CONST	SEGMENT
??_C@_01FDFGLJHB@2?$AA@ DB '2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01HIHLOKLC@1?$AA@
CONST	SEGMENT
??_C@_01HIHLOKLC@1?$AA@ DB '1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03OBJFJEBA@any?$AA@
CONST	SEGMENT
??_C@_03OBJFJEBA@any?$AA@ DB 'any', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03NFKEKGGK@all?$AA@
CONST	SEGMENT
??_C@_03NFKEKGGK@all?$AA@ DB 'all', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05KIBFDOPF@pilot?$AA@
CONST	SEGMENT
??_C@_05KIBFDOPF@pilot?$AA@ DB 'pilot', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03MHDDBBEP@fac?$AA@
CONST	SEGMENT
??_C@_03MHDDBBEP@fac?$AA@ DB 'fac', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05LHOHBFG@awacs?$AA@
CONST	SEGMENT
??_C@_05LHOHBFG@awacs?$AA@ DB 'awacs', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03EAAJEIGN@atc?$AA@
CONST	SEGMENT
??_C@_03EAAJEIGN@atc?$AA@ DB 'atc', 00H			; `string'
CONST	ENDS
_DATA	SEGMENT
_Names	DD	FLAT:??_C@_03EAAJEIGN@atc?$AA@
	DD	02H
	DD	FLAT:??_C@_05LHOHBFG@awacs?$AA@
	DD	08H
	DD	FLAT:??_C@_03MHDDBBEP@fac?$AA@
	DD	04H
	DD	FLAT:??_C@_05KIBFDOPF@pilot?$AA@
	DD	01H
	DD	FLAT:??_C@_03NFKEKGGK@all?$AA@
	DD	0fH
	DD	FLAT:??_C@_03OBJFJEBA@any?$AA@
	DD	07f0H
	DD	FLAT:??_C@_01HIHLOKLC@1?$AA@
	DD	010H
	DD	FLAT:??_C@_01FDFGLJHB@2?$AA@
	DD	020H
	DD	FLAT:??_C@_01EKENIIDA@3?$AA@
	DD	040H
	DD	FLAT:??_C@_01FAMBOPH@4?$AA@
	DD	080H
	DD	FLAT:??_C@_01BMBHCPLG@5?$AA@
	DD	0100H
	DD	FLAT:??_C@_01DHDKHMHF@6?$AA@
	DD	0200H
	DD	FLAT:??_C@_01COCBENDE@7?$AA@
	DD	0400H
	DD	FLAT:??_C@_01KJLJFBPL@8?$AA@
	DD	0800H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
CONST	SEGMENT
?default_voices@VoiceMapper@@0QBIB DD 07f9H		; VoiceMapper::default_voices
	DD	07f9H
	DD	07f9H
	DD	07f9H
	DD	07f9H
	DD	07f9H
	DD	07f9H
	DD	07f9H
	DD	07f9H
	DD	07f9H
	DD	07f9H
	DD	07f9H
	DD	07f2H
	DD	07f2H
?max_default_voices@VoiceMapper@@0HB DD 0eH		; VoiceMapper::max_default_voices
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
PUBLIC	?GetNextVoice@VoiceMapper@@QAEHHHH@Z		; VoiceMapper::GetNextVoice
PUBLIC	??0VoiceMapper@@QAE@XZ				; VoiceMapper::VoiceMapper
PUBLIC	??1VoiceMapper@@QAE@XZ				; VoiceMapper::~VoiceMapper
PUBLIC	?PickVoice@VoiceMapper@@QAEHHH@Z		; VoiceMapper::PickVoice
PUBLIC	?SetMyVoice@VoiceMapper@@QAEXH@Z		; VoiceMapper::SetMyVoice
PUBLIC	?SetVoiceCount@VoiceMapper@@QAEXH@Z		; VoiceMapper::SetVoiceCount
PUBLIC	?LoadVoices@VoiceMapper@@QAEXXZ			; VoiceMapper::LoadVoices
PUBLIC	?LookupName@VoiceMapper@@AAEIPBD@Z		; VoiceMapper::LookupName
PUBLIC	?GenerateFastRandom@@YAJXZ			; GenerateFastRandom
PUBLIC	?PRANDFloatPos@@YAMXZ				; PRANDFloatPos
PUBLIC	?g_voicemap@@3VVoiceMapper@@A			; g_voicemap
PUBLIC	?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA	; `GenerateFastRandom'::`2'::LastRandom
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	??_C@_03GILJFNFC@dat?$AA@			; `string'
PUBLIC	??_C@_0L@LJHKEKPL@voicerange?$AA@		; `string'
PUBLIC	??_C@_0N@DDPAEDIF@?$CFd?5?$CF99s?5?$CF99s?$AA@	; `string'
PUBLIC	__real@3f800000
PUBLIC	__real@477fff00
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	_memset:PROC
EXTRN	_stricmp:PROC
EXTRN	_fgets:PROC
EXTRN	_sscanf:PROC
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	?OpenCampFile@@YAPAU_iobuf@@PAD00@Z:PROC	; OpenCampFile
EXTRN	?CloseCampFile@@YAXPAU_iobuf@@@Z:PROC		; CloseCampFile
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?g_voicemap@@3VVoiceMapper@@A DQ 01H DUP (?)		; g_voicemap
_piecewise_construct DB 01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA
_BSS	SEGMENT
?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA DD 01H DUP (?) ; `GenerateFastRandom'::`2'::LastRandom
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __real@477fff00
CONST	SEGMENT
__real@477fff00 DD 0477fff00r			; 65535
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT ??_C@_0N@DDPAEDIF@?$CFd?5?$CF99s?5?$CF99s?$AA@
CONST	SEGMENT
??_C@_0N@DDPAEDIF@?$CFd?5?$CF99s?5?$CF99s?$AA@ DB '%d %99s %99s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LJHKEKPL@voicerange?$AA@
CONST	SEGMENT
??_C@_0L@LJHKEKPL@voicerange?$AA@ DB 'voicerange', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03GILJFNFC@dat?$AA@
CONST	SEGMENT
??_C@_03GILJFNFC@dat?$AA@ DB 'dat', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
CONST	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_g_voicemap$initializer$ DD FLAT:??__Eg_voicemap@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__Fg_voicemap@@YAXXZ
text$yd	SEGMENT
??__Fg_voicemap@@YAXXZ PROC				; `dynamic atexit destructor for 'g_voicemap'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?g_voicemap@@3VVoiceMapper@@A ; g_voicemap
	call	??1VoiceMapper@@QAE@XZ			; VoiceMapper::~VoiceMapper
	pop	ebp
	ret	0
??__Fg_voicemap@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_voicemap''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\voicemapper.cpp
;	COMDAT ??__Eg_voicemap@@YAXXZ
text$yc	SEGMENT
??__Eg_voicemap@@YAXXZ PROC				; `dynamic initializer for 'g_voicemap'', COMDAT

; 11   : VoiceMapper g_voicemap;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?g_voicemap@@3VVoiceMapper@@A ; g_voicemap
	call	??0VoiceMapper@@QAE@XZ			; VoiceMapper::VoiceMapper
	push	OFFSET ??__Fg_voicemap@@YAXXZ		; `dynamic atexit destructor for 'g_voicemap''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__Eg_voicemap@@YAXXZ ENDP				; `dynamic initializer for 'g_voicemap''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\fakerand.h
;	COMDAT ?PRANDFloatPos@@YAMXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_x$ = -4						; size = 4
?PRANDFloatPos@@YAMXZ PROC				; PRANDFloatPos, COMDAT

; 150  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 151  : //	return NRANDPOS;
; 152  : 	float	x=	(float)(GenerateFastRandom()&0xffff);

	call	?GenerateFastRandom@@YAJXZ		; GenerateFastRandom
	and	eax, 65535				; 0000ffffH
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _x$[ebp], xmm0

; 153  : 	return( x / 65535.0f);

	movss	xmm0, DWORD PTR _x$[ebp]
	divss	xmm0, DWORD PTR __real@477fff00
	movss	DWORD PTR tv72[ebp], xmm0
	fld	DWORD PTR tv72[ebp]

; 154  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PRANDFloatPos@@YAMXZ ENDP				; PRANDFloatPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\fakerand.h
;	COMDAT ?GenerateFastRandom@@YAJXZ
_TEXT	SEGMENT
_FastRandom$ = -4					; size = 4
?GenerateFastRandom@@YAJXZ PROC				; GenerateFastRandom, COMDAT

; 108  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 109  : 	static long LastRandom;
; 110  : 	long	FastRandom;														// The Random Variable
; 111  : 	_asm {	
; 112  : 			push	edx

	push	edx

; 113  : 			push	eax

	push	eax

; 114  : 			RDTSC

	rdtsc

; 115  : 			add	DWORD PTR FastRandom,edx

	add	DWORD PTR _FastRandom$[ebp], edx

; 116  : 			xor	DWORD PTR FastRandom,eax

	xor	DWORD PTR _FastRandom$[ebp], eax

; 117  : 			mov	eax, DWORD PTR LastRandom

	mov	eax, DWORD PTR ?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA ; `GenerateFastRandom'::`2'::LastRandom

; 118  : 			add	DWORD PTR FastRandom,eax

	add	DWORD PTR _FastRandom$[ebp], eax

; 119  : 			add	DWORD PTR LastRandom,edx

	add	DWORD PTR ?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA, edx ; `GenerateFastRandom'::`2'::LastRandom

; 120  : 			pop	eax

	pop	eax

; 121  : 			pop	edx

	pop	edx

; 122  : 	}
; 123  : 	return(FastRandom);

	mov	eax, DWORD PTR _FastRandom$[ebp]

; 124  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GenerateFastRandom@@YAJXZ ENDP				; GenerateFastRandom
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\voicemapper.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_mp$ = -4						; size = 4
_name$ = 8						; size = 4
?LookupName@VoiceMapper@@AAEIPBD@Z PROC			; VoiceMapper::LookupName
; _this$ = ecx

; 117  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 118  :     const struct namemap *mp;
; 119  : 
; 120  :     for (mp = Names; mp->name != NULL; mp ++) {

	mov	DWORD PTR _mp$[ebp], OFFSET _Names
	jmp	SHORT $LN4@LookupName
$LN3@LookupName:
	mov	eax, DWORD PTR _mp$[ebp]
	add	eax, 8
	mov	DWORD PTR _mp$[ebp], eax
$LN4@LookupName:
	mov	ecx, DWORD PTR _mp$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN2@LookupName

; 121  : 	if (stricmp(mp->name, name) == 0)

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _mp$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN1@LookupName

; 122  : 	    return mp->id;

	mov	edx, DWORD PTR _mp$[ebp]
	mov	eax, DWORD PTR [edx+4]
	jmp	SHORT $LN5@LookupName
$LN1@LookupName:

; 123  :     }

	jmp	SHORT $LN3@LookupName
$LN2@LookupName:

; 124  :     return 0;

	xor	eax, eax
$LN5@LookupName:

; 125  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?LookupName@VoiceMapper@@AAEIPBD@Z ENDP			; VoiceMapper::LookupName
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\voicemapper.cpp
_TEXT	SEGMENT
_vtype$1 = -1248					; size = 4
_fp$ = -1244						; size = 4
_voice$ = -1240						; size = 4
_i$2 = -1236						; size = 4
_this$ = -1232						; size = 4
_buf$ = -1228						; size = 1024
_side$ = -204						; size = 100
_type$ = -104						; size = 100
__$ArrayPad$ = -4					; size = 4
?LoadVoices@VoiceMapper@@QAEXXZ PROC			; VoiceMapper::LoadVoices
; _this$ = ecx

; 85   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1248				; 000004e0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 86   :     // default stuff
; 87   :     FILE *fp = OpenCampFile("voicerange", "dat", "r");

	push	OFFSET ??_C@_01KDCPPGHE@r?$AA@
	push	OFFSET ??_C@_03GILJFNFC@dat?$AA@
	push	OFFSET ??_C@_0L@LJHKEKPL@voicerange?$AA@
	call	?OpenCampFile@@YAPAU_iobuf@@PAD00@Z	; OpenCampFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _fp$[ebp], eax

; 88   :     if (fp == NULL) { // just load defaults

	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $LN10@LoadVoices

; 89   : 	ShiAssert(totalvoices >= max_default_voices);
; 90   : 	for (int i = 0; i < max_default_voices; i++)

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN9@LoadVoices
$LN8@LoadVoices:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN9@LoadVoices:
	cmp	DWORD PTR _i$2[ebp], 14			; 0000000eH
	jge	SHORT $LN7@LoadVoices

; 91   : 	    voiceflags[i] = default_voices[i];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$2[ebp]
	mov	ecx, DWORD PTR _i$2[ebp]
	mov	ecx, DWORD PTR ?default_voices@VoiceMapper@@0QBIB[ecx*4]
	mov	DWORD PTR [edx+eax*4], ecx
	jmp	SHORT $LN8@LoadVoices
$LN7@LoadVoices:

; 92   : 	return;

	jmp	$LN11@LoadVoices
$LN10@LoadVoices:

; 93   :     }
; 94   :     memset (voiceflags, VOICE_NONE, sizeof *voiceflags * totalvoices);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	shl	eax, 2
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH
$LN6@LoadVoices:

; 95   : 
; 96   :     char buf[1024];
; 97   :     char type[100];
; 98   :     int voice;
; 99   :     char side[100];
; 100  :     while(fgets (buf, sizeof buf, fp)) {

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1024					; 00000400H
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_fgets
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN5@LoadVoices

; 101  : 	if (buf[0] == '\n' || buf[0] == '#' || buf[0] == ';')

	mov	edx, 1
	imul	edx, 0
	movsx	eax, BYTE PTR _buf$[ebp+edx]
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN3@LoadVoices
	mov	ecx, 1
	imul	ecx, 0
	movsx	edx, BYTE PTR _buf$[ebp+ecx]
	cmp	edx, 35					; 00000023H
	je	SHORT $LN3@LoadVoices
	mov	eax, 1
	imul	eax, 0
	movsx	ecx, BYTE PTR _buf$[ebp+eax]
	cmp	ecx, 59					; 0000003bH
	jne	SHORT $LN4@LoadVoices
$LN3@LoadVoices:

; 102  : 	    continue; // comment

	jmp	SHORT $LN6@LoadVoices
$LN4@LoadVoices:

; 103  : 	if (sscanf(buf, "%d %99s %99s", &voice, &type, &side) != 3)

	lea	edx, DWORD PTR _side$[ebp]
	push	edx
	lea	eax, DWORD PTR _type$[ebp]
	push	eax
	lea	ecx, DWORD PTR _voice$[ebp]
	push	ecx
	push	OFFSET ??_C@_0N@DDPAEDIF@?$CFd?5?$CF99s?5?$CF99s?$AA@
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_sscanf
	add	esp, 20					; 00000014H
	cmp	eax, 3
	je	SHORT $LN2@LoadVoices

; 104  : 	    continue;

	jmp	$LN6@LoadVoices
$LN2@LoadVoices:

; 105  : 	ShiAssert(voice < totalvoices);
; 106  : 	if (voice >= totalvoices)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _voice$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN1@LoadVoices

; 107  : 	    continue;

	jmp	$LN6@LoadVoices
$LN1@LoadVoices:

; 108  : 	int vtype = LookupName(type);

	lea	edx, DWORD PTR _type$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LookupName@VoiceMapper@@AAEIPBD@Z	; VoiceMapper::LookupName
	mov	DWORD PTR _vtype$1[ebp], eax

; 109  : 	vtype |= LookupName(side);

	lea	eax, DWORD PTR _side$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LookupName@VoiceMapper@@AAEIPBD@Z	; VoiceMapper::LookupName
	or	eax, DWORD PTR _vtype$1[ebp]
	mov	DWORD PTR _vtype$1[ebp], eax

; 110  : 	voiceflags[voice] |= vtype;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _voice$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	or	ecx, DWORD PTR _vtype$1[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _voice$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 111  :     }

	jmp	$LN6@LoadVoices
$LN5@LoadVoices:

; 112  : 
; 113  :     CloseCampFile(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	?CloseCampFile@@YAXPAU_iobuf@@@Z	; CloseCampFile
	add	esp, 4
$LN11@LoadVoices:

; 114  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?LoadVoices@VoiceMapper@@QAEXXZ ENDP			; VoiceMapper::LoadVoices
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\voicemapper.cpp
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
_n$ = 8							; size = 4
?SetVoiceCount@VoiceMapper@@QAEXH@Z PROC		; VoiceMapper::SetVoiceCount
; _this$ = ecx

; 128  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 129  :     totalvoices = n;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [eax], ecx

; 130  :     if (voiceflags)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	SHORT $LN1@SetVoiceCo

; 131  : 	delete []voiceflags;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN1@SetVoiceCo:

; 132  :     voiceflags = new unsigned int[n];

	xor	ecx, ecx
	mov	eax, DWORD PTR _n$[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [eax+4], ecx

; 133  :     memset (voiceflags, VOICE_NONE, sizeof *voiceflags * n);

	mov	edx, DWORD PTR _n$[ebp]
	shl	edx, 2
	push	edx
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 134  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetVoiceCount@VoiceMapper@@QAEXH@Z ENDP		; VoiceMapper::SetVoiceCount
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\voicemapper.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_n$ = 8							; size = 4
?SetMyVoice@VoiceMapper@@QAEXH@Z PROC			; VoiceMapper::SetMyVoice
; _this$ = ecx

; 138  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 139  :     ShiAssert(n <= totalvoices);
; 140  :     voiceflags[n] = VOICE_SELF;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [ecx+edx*4], 524288		; 00080000H

; 141  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetMyVoice@VoiceMapper@@QAEXH@Z ENDP			; VoiceMapper::SetMyVoice
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\voicemapper.cpp
_TEXT	SEGMENT
tv128 = -28						; size = 4
_chance$ = -24						; size = 4
_selected$ = -20					; size = 4
_this$ = -16						; size = 4
_recno$ = -12						; size = 4
_match$ = -8						; size = 4
_i$1 = -4						; size = 4
_type$ = 8						; size = 4
_side$ = 12						; size = 4
?PickVoice@VoiceMapper@@QAEHHH@Z PROC			; VoiceMapper::PickVoice
; _this$ = ecx

; 145  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 146  :     ShiAssert(type > 0 && type < VOICE_SIDE_BASE);
; 147  :     ShiAssert((side >= 0 && side <= 7) || side == VOICE_SIDE_UNK);
; 148  :     unsigned int match = type;

	mov	eax, DWORD PTR _type$[ebp]
	mov	DWORD PTR _match$[ebp], eax

; 149  :     if (side != VOICE_SIDE_UNK)

	cmp	DWORD PTR _side$[ebp], -1
	je	SHORT $LN6@PickVoice

; 150  : 	match |= (VOICE_SIDE_BASE << side);

	mov	edx, 16					; 00000010H
	mov	ecx, DWORD PTR _side$[ebp]
	shl	edx, cl
	or	edx, DWORD PTR _match$[ebp]
	mov	DWORD PTR _match$[ebp], edx
$LN6@PickVoice:

; 151  :     float chance;
; 152  :     int selected = 0;

	mov	DWORD PTR _selected$[ebp], 0

; 153  :     int recno = 0;

	mov	DWORD PTR _recno$[ebp], 0

; 154  :     for (int i = 0; i < totalvoices; i++) {

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN5@PickVoice
$LN4@PickVoice:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN5@PickVoice:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$1[ebp]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN3@PickVoice

; 155  : 	if ((voiceflags[i] & match) != match)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	and	eax, DWORD PTR _match$[ebp]
	cmp	eax, DWORD PTR _match$[ebp]
	je	SHORT $LN2@PickVoice

; 156  : 	    continue;

	jmp	SHORT $LN4@PickVoice
$LN2@PickVoice:

; 157  : 	recno ++;

	mov	ecx, DWORD PTR _recno$[ebp]
	add	ecx, 1
	mov	DWORD PTR _recno$[ebp], ecx

; 158  : 	chance = 1.0f / recno;

	cvtsi2ss xmm0, DWORD PTR _recno$[ebp]
	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, xmm0
	movss	DWORD PTR _chance$[ebp], xmm1

; 159  : 	if (chance > PRANDFloatPos())

	call	?PRANDFloatPos@@YAMXZ			; PRANDFloatPos
	fstp	DWORD PTR tv128[ebp]
	movss	xmm0, DWORD PTR _chance$[ebp]
	comiss	xmm0, DWORD PTR tv128[ebp]
	jbe	SHORT $LN1@PickVoice

; 160  : 	    selected = i;

	mov	edx, DWORD PTR _i$1[ebp]
	mov	DWORD PTR _selected$[ebp], edx
$LN1@PickVoice:

; 161  :     }

	jmp	SHORT $LN4@PickVoice
$LN3@PickVoice:

; 162  :     return selected;

	mov	eax, DWORD PTR _selected$[ebp]

; 163  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?PickVoice@VoiceMapper@@QAEHHH@Z ENDP			; VoiceMapper::PickVoice
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\voicemapper.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
??1VoiceMapper@@QAE@XZ PROC				; VoiceMapper::~VoiceMapper
; _this$ = ecx

; 78   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 79   :     if (voiceflags)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN2@VoiceMappe

; 80   : 	delete voiceflags;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@VoiceMappe:

; 81   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??1VoiceMapper@@QAE@XZ ENDP				; VoiceMapper::~VoiceMapper
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\voicemapper.h
;	COMDAT ??0VoiceMapper@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0VoiceMapper@@QAE@XZ PROC				; VoiceMapper::VoiceMapper, COMDAT
; _this$ = ecx

; 27   :     VoiceMapper() : totalvoices(0), voiceflags(0) {};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0VoiceMapper@@QAE@XZ ENDP				; VoiceMapper::VoiceMapper
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\voicemapper.cpp
_TEXT	SEGMENT
_recno$ = -20						; size = 4
_selected$ = -16					; size = 4
_match$ = -12						; size = 4
_this$ = -8						; size = 4
_i$1 = -4						; size = 4
_start$ = 8						; size = 4
_type$ = 12						; size = 4
_side$ = 16						; size = 4
?GetNextVoice@VoiceMapper@@QAEHHHH@Z PROC		; VoiceMapper::GetNextVoice
; _this$ = ecx

; 166  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 167  :     ShiAssert(type > 0 && type < VOICE_SIDE_BASE);
; 168  :     ShiAssert(side >= 0 && side <= 7);
; 169  :     unsigned int match = type | (VOICE_SIDE_BASE << side);

	mov	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _side$[ebp]
	shl	eax, cl
	or	eax, DWORD PTR _type$[ebp]
	mov	DWORD PTR _match$[ebp], eax

; 170  :     int selected = 0;

	mov	DWORD PTR _selected$[ebp], 0

; 171  :     int recno = 0;

	mov	DWORD PTR _recno$[ebp], 0

; 172  :     for (int i = 0; i < totalvoices; i++) {

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@GetNextVoi
$LN3@GetNextVoi:
	mov	ecx, DWORD PTR _i$1[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$1[ebp], ecx
$LN4@GetNextVoi:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$1[ebp]
	cmp	eax, DWORD PTR [edx]
	jge	SHORT $LN2@GetNextVoi

; 173  : 	start = (start + 1) % totalvoices;

	mov	eax, DWORD PTR _start$[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	cdq
	idiv	DWORD PTR [ecx]
	mov	DWORD PTR _start$[ebp], edx

; 174  : 	if ((voiceflags[start] & match) == match)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _start$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	and	edx, DWORD PTR _match$[ebp]
	cmp	edx, DWORD PTR _match$[ebp]
	jne	SHORT $LN1@GetNextVoi

; 175  : 	    return start;

	mov	eax, DWORD PTR _start$[ebp]
	jmp	SHORT $LN5@GetNextVoi
$LN1@GetNextVoi:

; 176  :     }

	jmp	SHORT $LN3@GetNextVoi
$LN2@GetNextVoi:

; 177  :     return 0;

	xor	eax, eax
$LN5@GetNextVoi:

; 178  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetNextVoice@VoiceMapper@@QAEHHHH@Z ENDP		; VoiceMapper::GetNextVoice
_TEXT	ENDS
END
