; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\FalcSnd\adpcm.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
_next_step DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	02H
	DW	04H
	DW	06H
	DW	08H
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	0ffffH
	DW	02H
	DW	04H
	DW	06H
	DW	08H
	ORG $+4
_step	DW	07H
	DW	08H
	DW	09H
	DW	0aH
	DW	0bH
	DW	0cH
	DW	0dH
	DW	0eH
	DW	010H
	DW	011H
	DW	013H
	DW	015H
	DW	017H
	DW	019H
	DW	01cH
	DW	01fH
	DW	022H
	DW	025H
	DW	029H
	DW	02dH
	DW	032H
	DW	037H
	DW	03cH
	DW	042H
	DW	049H
	DW	050H
	DW	058H
	DW	061H
	DW	06bH
	DW	076H
	DW	082H
	DW	08fH
	DW	09dH
	DW	0adH
	DW	0beH
	DW	0d1H
	DW	0e6H
	DW	0fdH
	DW	0117H
	DW	0133H
	DW	0151H
	DW	0173H
	DW	0198H
	DW	01c1H
	DW	01eeH
	DW	0220H
	DW	0256H
	DW	0292H
	DW	02d4H
	DW	031cH
	DW	036cH
	DW	03c3H
	DW	0424H
	DW	048eH
	DW	0502H
	DW	0583H
	DW	0610H
	DW	06abH
	DW	0756H
	DW	0812H
	DW	08e0H
	DW	09c3H
	DW	0abdH
	DW	0bd0H
	DW	0cffH
	DW	0e4cH
	DW	0fbaH
	DW	0114cH
	DW	01307H
	DW	014eeH
	DW	01706H
	DW	01954H
	DW	01bdcH
	DW	01ea5H
	DW	021b6H
	DW	02515H
	DW	028caH
	DW	02cdfH
	DW	0315bH
	DW	0364bH
	DW	03bb9H
	DW	041b2H
	DW	04844H
	DW	04f7eH
	DW	05771H
	DW	0602fH
	DW	069ceH
	DW	07462H
	DW	07fffH
CONST	ENDS
PUBLIC	?StreamIMAADPCM@CSoundMgr@@QAEJPAVSoundStream@@PADJ@Z ; CSoundMgr::StreamIMAADPCM
PUBLIC	?MemStreamIMAADPCM@CSoundMgr@@QAEJPAVSoundStream@@PADJ@Z ; CSoundMgr::MemStreamIMAADPCM
PUBLIC	?StreamImaS16@CSoundMgr@@AAEJPAUIMA_STREAM@@PADJ@Z ; CSoundMgr::StreamImaS16
PUBLIC	?StreamImaM16@CSoundMgr@@AAEJPAUIMA_STREAM@@PADJ@Z ; CSoundMgr::StreamImaM16
PUBLIC	?ImaDecodeS16@CSoundMgr@@AAEJPAD0J@Z		; CSoundMgr::ImaDecodeS16
PUBLIC	?ImaDecodeM16@CSoundMgr@@AAEJPAD0J@Z		; CSoundMgr::ImaDecodeM16
PUBLIC	?IMA_SampleDecode@CSoundMgr@@AAEFFFF@Z		; CSoundMgr::IMA_SampleDecode
PUBLIC	?IMA_NextStepIndex@CSoundMgr@@AAEFFF@Z		; CSoundMgr::IMA_NextStepIndex
PUBLIC	?IMA_ValidStepIndex@CSoundMgr@@AAEHF@Z		; CSoundMgr::IMA_ValidStepIndex
PUBLIC	??_C@_0BP@IIGNJFPO@S16?3?5?5invalid?5left?5step?5index?6?$AA@ ; `string'
PUBLIC	??_C@_0DG@GBPJNDIA@S16?3?5?5buffer?5length?5is?5less?5than@ ; `string'
PUBLIC	??_C@_0BP@OKDCLCBN@S16?3?5?5invlid?5right?5step?5index?6?$AA@ ; `string'
PUBLIC	??_C@_0CL@ELDPDMFD@S16?3?5?5buffer?5length?5is?5not?5divis@ ; `string'
PUBLIC	??_C@_0BJ@EIMLDDBI@M16?3?5invalid?5step?5index?6?$AA@ ; `string'
EXTRN	__imp__ReadFile@20:PROC
EXTRN	_MonoPrint:PROC
;	COMDAT ??_C@_0BJ@EIMLDDBI@M16?3?5invalid?5step?5index?6?$AA@
CONST	SEGMENT
??_C@_0BJ@EIMLDDBI@M16?3?5invalid?5step?5index?6?$AA@ DB 'M16: invalid st'
	DB	'ep index', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@ELDPDMFD@S16?3?5?5buffer?5length?5is?5not?5divis@
CONST	SEGMENT
??_C@_0CL@ELDPDMFD@S16?3?5?5buffer?5length?5is?5not?5divis@ DB 'S16:  buf'
	DB	'fer length is not divisible by 8', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@OKDCLCBN@S16?3?5?5invlid?5right?5step?5index?6?$AA@
CONST	SEGMENT
??_C@_0BP@OKDCLCBN@S16?3?5?5invlid?5right?5step?5index?6?$AA@ DB 'S16:  i'
	DB	'nvlid right step index', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@GBPJNDIA@S16?3?5?5buffer?5length?5is?5less?5than@
CONST	SEGMENT
??_C@_0DG@GBPJNDIA@S16?3?5?5buffer?5length?5is?5less?5than@ DB 'S16:  buf'
	DB	'fer length is less than the block alignment', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@IIGNJFPO@S16?3?5?5invalid?5left?5step?5index?6?$AA@
CONST	SEGMENT
??_C@_0BP@IIGNJFPO@S16?3?5?5invalid?5left?5step?5index?6?$AA@ DB 'S16:  i'
	DB	'nvalid left step index', 0aH, 00H		; `string'
CONST	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\adpcm.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nStepIndex$ = 8					; size = 2
?IMA_ValidStepIndex@CSoundMgr@@AAEHF@Z PROC		; CSoundMgr::IMA_ValidStepIndex
; _this$ = ecx

; 584  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 585  : 
; 586  :     if( nStepIndex >= 0 && nStepIndex <= 88 )

	movsx	eax, WORD PTR _nStepIndex$[ebp]
	test	eax, eax
	jl	SHORT $LN2@IMA_ValidS
	movsx	ecx, WORD PTR _nStepIndex$[ebp]
	cmp	ecx, 88					; 00000058H
	jg	SHORT $LN2@IMA_ValidS

; 587  :         return TRUE;

	mov	eax, 1
	jmp	SHORT $LN3@IMA_ValidS

; 588  :     else

	jmp	SHORT $LN3@IMA_ValidS
$LN2@IMA_ValidS:

; 589  :         return FALSE;

	xor	eax, eax
$LN3@IMA_ValidS:

; 590  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IMA_ValidStepIndex@CSoundMgr@@AAEHF@Z ENDP		; CSoundMgr::IMA_ValidStepIndex
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\adpcm.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nEncodedSample$ = 8					; size = 2
_nStepIndex$ = 12					; size = 2
?IMA_NextStepIndex@CSoundMgr@@AAEFFF@Z PROC		; CSoundMgr::IMA_NextStepIndex
; _this$ = ecx

; 552  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 553  :     //
; 554  :     //  compute new stepsize step
; 555  :     //
; 556  :     nStepIndex = (short)(nStepIndex + next_step[nEncodedSample]); // clamped to 0 <= nStepIndex <= 88

	movsx	eax, WORD PTR _nStepIndex$[ebp]
	movsx	ecx, WORD PTR _nEncodedSample$[ebp]
	movsx	edx, WORD PTR _next_step[ecx*2]
	add	eax, edx
	mov	WORD PTR _nStepIndex$[ebp], ax

; 557  : 
; 558  :     if (nStepIndex < 0)

	movsx	eax, WORD PTR _nStepIndex$[ebp]
	test	eax, eax
	jge	SHORT $LN3@IMA_NextSt

; 559  :         nStepIndex = 0;

	xor	ecx, ecx
	mov	WORD PTR _nStepIndex$[ebp], cx
	jmp	SHORT $LN2@IMA_NextSt
$LN3@IMA_NextSt:

; 560  :     else if (nStepIndex > 88)

	movsx	edx, WORD PTR _nStepIndex$[ebp]
	cmp	edx, 88					; 00000058H
	jle	SHORT $LN2@IMA_NextSt

; 561  :         nStepIndex = 88;

	mov	eax, 88					; 00000058H
	mov	WORD PTR _nStepIndex$[ebp], ax
$LN2@IMA_NextSt:

; 562  : 
; 563  :     return (nStepIndex);

	mov	ax, WORD PTR _nStepIndex$[ebp]

; 564  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?IMA_NextStepIndex@CSoundMgr@@AAEFFF@Z ENDP		; CSoundMgr::IMA_NextStepIndex
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\adpcm.cpp
_TEXT	SEGMENT
_this$ = -12						; size = 4
_lNewSample$ = -8					; size = 4
_lDifference$ = -4					; size = 4
_nEncodedSample$ = 8					; size = 2
_nPredictedSample$ = 12					; size = 2
_nStepSize$ = 16					; size = 2
?IMA_SampleDecode@CSoundMgr@@AAEFFFF@Z PROC		; CSoundMgr::IMA_SampleDecode
; _this$ = ecx

; 484  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 485  :     LONG            lDifference;
; 486  :     LONG            lNewSample;
; 487  : 
; 488  :     //
; 489  :     //  calculate difference:
; 490  :     //
; 491  :     //      lDifference = (nEncodedSample + 1/2) * nStepSize / 4
; 492  :     //
; 493  :     lDifference = nStepSize>>3;

	movsx	eax, WORD PTR _nStepSize$[ebp]
	sar	eax, 3
	mov	DWORD PTR _lDifference$[ebp], eax

; 494  : 
; 495  :     if (nEncodedSample & 4) 

	movsx	ecx, WORD PTR _nEncodedSample$[ebp]
	and	ecx, 4
	je	SHORT $LN7@IMA_Sample

; 496  :         lDifference += nStepSize;

	movsx	edx, WORD PTR _nStepSize$[ebp]
	add	edx, DWORD PTR _lDifference$[ebp]
	mov	DWORD PTR _lDifference$[ebp], edx
$LN7@IMA_Sample:

; 497  : 
; 498  :     if (nEncodedSample & 2) 

	movsx	eax, WORD PTR _nEncodedSample$[ebp]
	and	eax, 2
	je	SHORT $LN6@IMA_Sample

; 499  :         lDifference += nStepSize>>1;

	movsx	ecx, WORD PTR _nStepSize$[ebp]
	sar	ecx, 1
	add	ecx, DWORD PTR _lDifference$[ebp]
	mov	DWORD PTR _lDifference$[ebp], ecx
$LN6@IMA_Sample:

; 500  : 
; 501  :     if (nEncodedSample & 1) 

	movsx	edx, WORD PTR _nEncodedSample$[ebp]
	and	edx, 1
	je	SHORT $LN5@IMA_Sample

; 502  :         lDifference += nStepSize>>2;

	movsx	eax, WORD PTR _nStepSize$[ebp]
	sar	eax, 2
	add	eax, DWORD PTR _lDifference$[ebp]
	mov	DWORD PTR _lDifference$[ebp], eax
$LN5@IMA_Sample:

; 503  : 
; 504  :     //
; 505  :     //  If the 'sign bit' of the encoded nibble is set, then the
; 506  :     //  difference is negative...
; 507  :     //
; 508  :     if (nEncodedSample & 8)

	movsx	ecx, WORD PTR _nEncodedSample$[ebp]
	and	ecx, 8
	je	SHORT $LN4@IMA_Sample

; 509  :         lDifference = -lDifference;

	mov	edx, DWORD PTR _lDifference$[ebp]
	neg	edx
	mov	DWORD PTR _lDifference$[ebp], edx
$LN4@IMA_Sample:

; 510  : 
; 511  :     //
; 512  :     //  adjust predicted sample based on calculated difference
; 513  :     //
; 514  :     lNewSample = nPredictedSample + lDifference;

	movsx	eax, WORD PTR _nPredictedSample$[ebp]
	add	eax, DWORD PTR _lDifference$[ebp]
	mov	DWORD PTR _lNewSample$[ebp], eax

; 515  : 
; 516  :     //
; 517  :     //  check for overflow and clamp if necessary to a 16 signed sample.
; 518  :     //  Note that this is optimized for the most common case, when we
; 519  :     //  don't have to clamp.
; 520  :     //
; 521  :     if( (long)(short)lNewSample == lNewSample )

	movsx	ecx, WORD PTR _lNewSample$[ebp]
	cmp	ecx, DWORD PTR _lNewSample$[ebp]
	jne	SHORT $LN3@IMA_Sample

; 522  :     {
; 523  :         return (short)lNewSample;

	mov	ax, WORD PTR _lNewSample$[ebp]
	jmp	SHORT $LN8@IMA_Sample
$LN3@IMA_Sample:

; 524  :     }
; 525  : 
; 526  :     //
; 527  :     //  Clamp.
; 528  :     //
; 529  :     if( lNewSample < -32768 )

	cmp	DWORD PTR _lNewSample$[ebp], -32768	; ffff8000H
	jge	SHORT $LN2@IMA_Sample

; 530  :         return (short)-32768;

	mov	eax, -32768				; ffff8000H
	jmp	SHORT $LN8@IMA_Sample

; 531  :     else

	jmp	SHORT $LN8@IMA_Sample
$LN2@IMA_Sample:

; 532  :         return (short)32767;

	mov	eax, 32767				; 00007fffH
$LN8@IMA_Sample:

; 533  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?IMA_SampleDecode@CSoundMgr@@AAEFFFF@Z ENDP		; CSoundMgr::IMA_SampleDecode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\adpcm.cpp
_TEXT	SEGMENT
_dBuffStart$ = -52					; size = 4
tv82 = -48						; size = 4
_sample$ = -44						; size = 4
_header$ = -40						; size = 4
tv67 = -36						; size = 4
_blockAlignment$ = -32					; size = 4
_this$ = -28						; size = 4
_blockLength$ = -24					; size = 4
_blockHeaderSize$ = -20					; size = 2
_stepSize$ = -16					; size = 2
_encSample$ = -12					; size = 2
_predSample$ = -8					; size = 2
_stepIndex$ = -4					; size = 2
_sBuff$ = 8						; size = 4
_dBuff$ = 12						; size = 4
_bufferLength$ = 16					; size = 4
?ImaDecodeM16@CSoundMgr@@AAEJPAD0J@Z PROC		; CSoundMgr::ImaDecodeM16
; _this$ = ecx

; 397  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 398  : 	short	blockHeaderSize;
; 399  : 	int		blockAlignment;
; 400  : 	int		blockLength;
; 401  : 	char	*dBuffStart;
; 402  : 	long	sample;
; 403  : 	short	stepSize;
; 404  : 	IMA_BLOCK	header;
; 405  : 
; 406  : 	short	predSample;
; 407  : 	short	stepIndex;
; 408  : 	short	encSample;
; 409  : 
; 410  : 	//put some commonly used info in more accessible variables and
; 411  : 	//init some variables
; 412  : 	blockHeaderSize = sizeof(IMA_BLOCK) * SND_WAV_MCHAN;

	mov	eax, 4
	mov	WORD PTR _blockHeaderSize$[ebp], ax

; 413  : 	blockAlignment 	= SND_ADPCM_MBLOCK_ALIGN;

	mov	DWORD PTR _blockAlignment$[ebp], 512	; 00000200H

; 414  : 	dBuffStart		= dBuff;

	mov	ecx, DWORD PTR _dBuff$[ebp]
	mov	DWORD PTR _dBuffStart$[ebp], ecx
$LN5@ImaDecodeM:

; 415  : 
; 416  : 	//step through each byte of IMA ADPCM and decode it to PCM
; 417  : 	while (bufferLength >= blockHeaderSize)

	movsx	edx, WORD PTR _blockHeaderSize$[ebp]
	cmp	DWORD PTR _bufferLength$[ebp], edx
	jl	$LN4@ImaDecodeM

; 418  : 		{			 
; 419  : 		blockLength 	= (UINT)min(bufferLength, blockAlignment);

	mov	eax, DWORD PTR _bufferLength$[ebp]
	cmp	eax, DWORD PTR _blockAlignment$[ebp]
	jge	SHORT $LN8@ImaDecodeM
	mov	ecx, DWORD PTR _bufferLength$[ebp]
	mov	DWORD PTR tv67[ebp], ecx
	jmp	SHORT $LN9@ImaDecodeM
$LN8@ImaDecodeM:
	mov	edx, DWORD PTR _blockAlignment$[ebp]
	mov	DWORD PTR tv67[ebp], edx
$LN9@ImaDecodeM:
	mov	eax, DWORD PTR tv67[ebp]
	mov	DWORD PTR _blockLength$[ebp], eax

; 420  : 		bufferLength   -= blockLength;

	mov	ecx, DWORD PTR _bufferLength$[ebp]
	sub	ecx, DWORD PTR _blockLength$[ebp]
	mov	DWORD PTR _bufferLength$[ebp], ecx

; 421  : 		blockLength    -= blockHeaderSize;

	movsx	edx, WORD PTR _blockHeaderSize$[ebp]
	mov	eax, DWORD PTR _blockLength$[ebp]
	sub	eax, edx
	mov	DWORD PTR _blockLength$[ebp], eax

; 422  : 		
; 423  : 		//get the block header
; 424  : 		header		= *(IMA_BLOCK *)sBuff;

	mov	ecx, DWORD PTR _sBuff$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _header$[ebp], edx

; 425  : 		sBuff		= sBuff + sizeof(IMA_BLOCK);

	mov	eax, DWORD PTR _sBuff$[ebp]
	add	eax, 4
	mov	DWORD PTR _sBuff$[ebp], eax

; 426  : 		predSample  = header.iSamp0;

	mov	cx, WORD PTR _header$[ebp]
	mov	WORD PTR _predSample$[ebp], cx

; 427  : 		stepIndex 	= (short)header.bStepTableIndex;

	movsx	dx, BYTE PTR _header$[ebp+2]
	mov	WORD PTR _stepIndex$[ebp], dx

; 428  : 		if (!IMA_ValidStepIndex(stepIndex))

	movzx	eax, WORD PTR _stepIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IMA_ValidStepIndex@CSoundMgr@@AAEHF@Z	; CSoundMgr::IMA_ValidStepIndex
	test	eax, eax
	jne	SHORT $LN3@ImaDecodeM

; 429  : 			{
; 430  : 			MonoPrint("M16: invalid step index\n");

	push	OFFSET ??_C@_0BJ@EIMLDDBI@M16?3?5invalid?5step?5index?6?$AA@
	call	_MonoPrint
	add	esp, 4

; 431  : 			return 0;

	xor	eax, eax
	jmp	$LN6@ImaDecodeM
$LN3@ImaDecodeM:

; 432  : 			}
; 433  : 			
; 434  : 		//write out the first sample
; 435  : 		*(short *)dBuff = (short)predSample;

	mov	ecx, DWORD PTR _dBuff$[ebp]
	mov	dx, WORD PTR _predSample$[ebp]
	mov	WORD PTR [ecx], dx

; 436  : 		dBuff			= dBuff + sizeof(short);

	mov	eax, DWORD PTR _dBuff$[ebp]
	add	eax, 2
	mov	DWORD PTR _dBuff$[ebp], eax
$LN2@ImaDecodeM:

; 437  : 		
; 438  : 		while (blockLength--)

	mov	ecx, DWORD PTR _blockLength$[ebp]
	mov	DWORD PTR tv82[ebp], ecx
	mov	edx, DWORD PTR _blockLength$[ebp]
	sub	edx, 1
	mov	DWORD PTR _blockLength$[ebp], edx
	cmp	DWORD PTR tv82[ebp], 0
	je	$LN1@ImaDecodeM

; 439  : 			{
; 440  : 			sample	 	= *sBuff++;

	mov	eax, DWORD PTR _sBuff$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _sample$[ebp], ecx
	mov	edx, DWORD PTR _sBuff$[ebp]
	add	edx, 1
	mov	DWORD PTR _sBuff$[ebp], edx

; 441  : 			
; 442  : 			//sample 1
; 443  : 			encSample	= (short)(sample & 0x0F);

	mov	eax, DWORD PTR _sample$[ebp]
	and	eax, 15					; 0000000fH
	mov	WORD PTR _encSample$[ebp], ax

; 444  : 			stepSize	= step[stepIndex];

	movsx	ecx, WORD PTR _stepIndex$[ebp]
	mov	dx, WORD PTR _step[ecx*2]
	mov	WORD PTR _stepSize$[ebp], dx

; 445  : 			predSample  = IMA_SampleDecode(encSample, predSample, stepSize);

	movzx	eax, WORD PTR _stepSize$[ebp]
	push	eax
	movzx	ecx, WORD PTR _predSample$[ebp]
	push	ecx
	movzx	edx, WORD PTR _encSample$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IMA_SampleDecode@CSoundMgr@@AAEFFFF@Z	; CSoundMgr::IMA_SampleDecode
	mov	WORD PTR _predSample$[ebp], ax

; 446  : 			stepIndex	= IMA_NextStepIndex(encSample, stepIndex);

	movzx	eax, WORD PTR _stepIndex$[ebp]
	push	eax
	movzx	ecx, WORD PTR _encSample$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IMA_NextStepIndex@CSoundMgr@@AAEFFF@Z	; CSoundMgr::IMA_NextStepIndex
	mov	WORD PTR _stepIndex$[ebp], ax

; 447  : 
; 448  : 			*(short *)dBuff = (short)predSample;

	mov	edx, DWORD PTR _dBuff$[ebp]
	mov	ax, WORD PTR _predSample$[ebp]
	mov	WORD PTR [edx], ax

; 449  : 			dBuff			= dBuff + sizeof(short);

	mov	ecx, DWORD PTR _dBuff$[ebp]
	add	ecx, 2
	mov	DWORD PTR _dBuff$[ebp], ecx

; 450  : 
; 451  : 			//sample 2
; 452  : 			encSample	= (short)(sample >> 4);

	mov	edx, DWORD PTR _sample$[ebp]
	sar	edx, 4
	mov	WORD PTR _encSample$[ebp], dx

; 453  : 			stepSize	= step[stepIndex];

	movsx	eax, WORD PTR _stepIndex$[ebp]
	mov	cx, WORD PTR _step[eax*2]
	mov	WORD PTR _stepSize$[ebp], cx

; 454  : 			predSample	= IMA_SampleDecode(encSample, predSample, stepSize);

	movzx	edx, WORD PTR _stepSize$[ebp]
	push	edx
	movzx	eax, WORD PTR _predSample$[ebp]
	push	eax
	movzx	ecx, WORD PTR _encSample$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IMA_SampleDecode@CSoundMgr@@AAEFFFF@Z	; CSoundMgr::IMA_SampleDecode
	mov	WORD PTR _predSample$[ebp], ax

; 455  : 			stepIndex 	= IMA_NextStepIndex(encSample, stepIndex);

	movzx	edx, WORD PTR _stepIndex$[ebp]
	push	edx
	movzx	eax, WORD PTR _encSample$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IMA_NextStepIndex@CSoundMgr@@AAEFFF@Z	; CSoundMgr::IMA_NextStepIndex
	mov	WORD PTR _stepIndex$[ebp], ax

; 456  : 
; 457  : 			*(short *)dBuff	= (short)predSample;

	mov	ecx, DWORD PTR _dBuff$[ebp]
	mov	dx, WORD PTR _predSample$[ebp]
	mov	WORD PTR [ecx], dx

; 458  : 			dBuff			= dBuff + sizeof(short);

	mov	eax, DWORD PTR _dBuff$[ebp]
	add	eax, 2
	mov	DWORD PTR _dBuff$[ebp], eax

; 459  : 			} //0 != blockLength				

	jmp	$LN2@ImaDecodeM
$LN1@ImaDecodeM:

; 460  : 		} //while bufferLength >= blockHeaderSize

	jmp	$LN5@ImaDecodeM
$LN4@ImaDecodeM:

; 461  : 
; 462  : 	//return the number of bytes written
; 463  : 	return (long)(dBuff - dBuffStart);

	mov	eax, DWORD PTR _dBuff$[ebp]
	sub	eax, DWORD PTR _dBuffStart$[ebp]
$LN6@ImaDecodeM:

; 464  : 
; 465  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?ImaDecodeM16@CSoundMgr@@AAEJPAD0J@Z ENDP		; CSoundMgr::ImaDecodeM16
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\adpcm.cpp
_TEXT	SEGMENT
_dBuffStart$ = -64					; size = 4
_blockAlignment$ = -60					; size = 4
_rightSamples$ = -56					; size = 4
_leftSamples$ = -52					; size = 4
_header$ = -48						; size = 4
_this$ = -44						; size = 4
_blockLength$ = -40					; size = 4
_blockHeaderSize$ = -36					; size = 2
_encSampleR$ = -32					; size = 2
_encSampleL$ = -28					; size = 2
_stepSize$ = -24					; size = 2
_i$ = -20						; size = 2
_predSampleR$ = -16					; size = 2
_predSampleL$ = -12					; size = 2
_stepIndexR$ = -8					; size = 2
_stepIndexL$ = -4					; size = 2
_sBuff$ = 8						; size = 4
_dBuff$ = 12						; size = 4
_bufferLength$ = 16					; size = 4
?ImaDecodeS16@CSoundMgr@@AAEJPAD0J@Z PROC		; CSoundMgr::ImaDecodeS16
; _this$ = ecx

; 281  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 282  : 	short	blockHeaderSize;
; 283  : 	int		blockAlignment;
; 284  : 	int		blockLength;
; 285  : 	char	*dBuffStart;
; 286  : 	long	leftSamples;
; 287  : 	long	rightSamples;
; 288  : 	short	stepSize;
; 289  : 	short	i;
; 290  : 	IMA_BLOCK	header;
; 291  : 
; 292  : 	short	predSampleL;
; 293  : 	short	stepIndexL;
; 294  : 	short	encSampleL;
; 295  : 
; 296  : 	short	predSampleR;
; 297  : 	short	stepIndexR;
; 298  : 	short	encSampleR;
; 299  : 
; 300  : 	//put some commonly used info in more accessible variables and
; 301  : 	//init some variables
; 302  : 	blockHeaderSize = sizeof(IMA_BLOCK) * SND_WAV_SCHAN;

	mov	eax, 8
	mov	WORD PTR _blockHeaderSize$[ebp], ax

; 303  : 	blockAlignment 	= SND_ADPCM_SBLOCK_ALIGN;

	mov	DWORD PTR _blockAlignment$[ebp], 1024	; 00000400H

; 304  : 	dBuffStart		= dBuff;

	mov	ecx, DWORD PTR _dBuff$[ebp]
	mov	DWORD PTR _dBuffStart$[ebp], ecx
$LN11@ImaDecodeS:

; 305  : 
; 306  : 	//step through each byte of IMA ADPCM and decode it to PCM
; 307  : 	while (bufferLength)

	cmp	DWORD PTR _bufferLength$[ebp], 0
	je	$LN10@ImaDecodeS

; 308  : 		{
; 309  : 		//data should always be block aligned
; 310  : 		if (bufferLength < blockAlignment)

	mov	edx, DWORD PTR _bufferLength$[ebp]
	cmp	edx, DWORD PTR _blockAlignment$[ebp]
	jge	SHORT $LN9@ImaDecodeS

; 311  : 			{
; 312  : 			MonoPrint("S16:  buffer length is less than the block alignment\n");

	push	OFFSET ??_C@_0DG@GBPJNDIA@S16?3?5?5buffer?5length?5is?5less?5than@
	call	_MonoPrint
	add	esp, 4

; 313  : 			return 0;

	xor	eax, eax
	jmp	$LN12@ImaDecodeS
$LN9@ImaDecodeS:

; 314  : 			}
; 315  : 			 
; 316  : 		blockLength 	= blockAlignment;

	mov	eax, DWORD PTR _blockAlignment$[ebp]
	mov	DWORD PTR _blockLength$[ebp], eax

; 317  : 		bufferLength   -= blockLength;

	mov	ecx, DWORD PTR _bufferLength$[ebp]
	sub	ecx, DWORD PTR _blockLength$[ebp]
	mov	DWORD PTR _bufferLength$[ebp], ecx

; 318  : 		blockLength    -= blockHeaderSize;

	movsx	edx, WORD PTR _blockHeaderSize$[ebp]
	mov	eax, DWORD PTR _blockLength$[ebp]
	sub	eax, edx
	mov	DWORD PTR _blockLength$[ebp], eax

; 319  : 		
; 320  : 		//get the left header
; 321  : 		header		= *(IMA_BLOCK *)sBuff;

	mov	ecx, DWORD PTR _sBuff$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _header$[ebp], edx

; 322  : 		sBuff		= sBuff + sizeof(IMA_BLOCK);

	mov	eax, DWORD PTR _sBuff$[ebp]
	add	eax, 4
	mov	DWORD PTR _sBuff$[ebp], eax

; 323  : 		predSampleL = header.iSamp0;

	mov	cx, WORD PTR _header$[ebp]
	mov	WORD PTR _predSampleL$[ebp], cx

; 324  : 		stepIndexL	= (short)header.bStepTableIndex;

	movsx	dx, BYTE PTR _header$[ebp+2]
	mov	WORD PTR _stepIndexL$[ebp], dx

; 325  : 		if (!IMA_ValidStepIndex(stepIndexL))

	movzx	eax, WORD PTR _stepIndexL$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IMA_ValidStepIndex@CSoundMgr@@AAEHF@Z	; CSoundMgr::IMA_ValidStepIndex
	test	eax, eax
	jne	SHORT $LN8@ImaDecodeS

; 326  : 			{
; 327  : 			MonoPrint("S16:  invalid left step index\n");

	push	OFFSET ??_C@_0BP@IIGNJFPO@S16?3?5?5invalid?5left?5step?5index?6?$AA@
	call	_MonoPrint
	add	esp, 4

; 328  : 			return 0;

	xor	eax, eax
	jmp	$LN12@ImaDecodeS
$LN8@ImaDecodeS:

; 329  : 			}
; 330  : 		
; 331  : 		//get the right header
; 332  : 		header		= *(IMA_BLOCK *)sBuff;

	mov	ecx, DWORD PTR _sBuff$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _header$[ebp], edx

; 333  : 		sBuff		= sBuff + sizeof(IMA_BLOCK);

	mov	eax, DWORD PTR _sBuff$[ebp]
	add	eax, 4
	mov	DWORD PTR _sBuff$[ebp], eax

; 334  : 		predSampleR	= header.iSamp0;

	mov	cx, WORD PTR _header$[ebp]
	mov	WORD PTR _predSampleR$[ebp], cx

; 335  : 		stepIndexR	= (short)header.bStepTableIndex; 

	movsx	dx, BYTE PTR _header$[ebp+2]
	mov	WORD PTR _stepIndexR$[ebp], dx

; 336  : 		if (!IMA_ValidStepIndex(stepIndexR))

	movzx	eax, WORD PTR _stepIndexR$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IMA_ValidStepIndex@CSoundMgr@@AAEHF@Z	; CSoundMgr::IMA_ValidStepIndex
	test	eax, eax
	jne	SHORT $LN7@ImaDecodeS

; 337  : 			{
; 338  : 			MonoPrint("S16:  invlid right step index\n");

	push	OFFSET ??_C@_0BP@OKDCLCBN@S16?3?5?5invlid?5right?5step?5index?6?$AA@
	call	_MonoPrint
	add	esp, 4

; 339  : 			return 0;

	xor	eax, eax
	jmp	$LN12@ImaDecodeS
$LN7@ImaDecodeS:

; 340  : 			}
; 341  : 			
; 342  : 		//write out the first sample
; 343  : 		*(long *)dBuff = MAKELONG(predSampleL, predSampleR);

	movsx	ecx, WORD PTR _predSampleL$[ebp]
	and	ecx, 65535				; 0000ffffH
	movzx	edx, cx
	movsx	eax, WORD PTR _predSampleR$[ebp]
	and	eax, 65535				; 0000ffffH
	movzx	ecx, ax
	shl	ecx, 16					; 00000010H
	or	edx, ecx
	mov	eax, DWORD PTR _dBuff$[ebp]
	mov	DWORD PTR [eax], edx

; 344  : 		dBuff			= dBuff + sizeof(long);

	mov	ecx, DWORD PTR _dBuff$[ebp]
	add	ecx, 4
	mov	DWORD PTR _dBuff$[ebp], ecx

; 345  : 		
; 346  : 		//the first long contains 4 left samples the second long
; 347  : 		//contains 4 right samples.  Will process the source in 8-byte
; 348  : 		//chunks to make it eay to interleave the output correctly
; 349  : 		if ((blockLength%8) != 0)

	mov	edx, DWORD PTR _blockLength$[ebp]
	and	edx, -2147483641			; 80000007H
	jns	SHORT $LN14@ImaDecodeS
	dec	edx
	or	edx, -8					; fffffff8H
	inc	edx
$LN14@ImaDecodeS:
	test	edx, edx
	je	SHORT $LN5@ImaDecodeS

; 350  : 			{
; 351  : 			MonoPrint("S16:  buffer length is not divisible by 8\n");

	push	OFFSET ??_C@_0CL@ELDPDMFD@S16?3?5?5buffer?5length?5is?5not?5divis@
	call	_MonoPrint
	add	esp, 4

; 352  : 			return 0;

	xor	eax, eax
	jmp	$LN12@ImaDecodeS
$LN5@ImaDecodeS:

; 353  : 			}
; 354  : 		while (0 != blockLength)

	cmp	DWORD PTR _blockLength$[ebp], 0
	je	$LN4@ImaDecodeS

; 355  : 			{
; 356  : 			blockLength    -= 8;

	mov	eax, DWORD PTR _blockLength$[ebp]
	sub	eax, 8
	mov	DWORD PTR _blockLength$[ebp], eax

; 357  : 
; 358  : 			leftSamples 	= *(long *)sBuff;

	mov	ecx, DWORD PTR _sBuff$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _leftSamples$[ebp], edx

; 359  : 			sBuff	  		= sBuff + sizeof(long);

	mov	eax, DWORD PTR _sBuff$[ebp]
	add	eax, 4
	mov	DWORD PTR _sBuff$[ebp], eax

; 360  : 			rightSamples 	= *(long *)sBuff;

	mov	ecx, DWORD PTR _sBuff$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _rightSamples$[ebp], edx

; 361  : 			sBuff			= sBuff + sizeof(long);

	mov	eax, DWORD PTR _sBuff$[ebp]
	add	eax, 4
	mov	DWORD PTR _sBuff$[ebp], eax

; 362  : 			
; 363  : 			for (i=8; i>0; i--)

	mov	ecx, 8
	mov	WORD PTR _i$[ebp], cx
	jmp	SHORT $LN3@ImaDecodeS
$LN2@ImaDecodeS:
	mov	dx, WORD PTR _i$[ebp]
	sub	dx, 1
	mov	WORD PTR _i$[ebp], dx
$LN3@ImaDecodeS:
	movsx	eax, WORD PTR _i$[ebp]
	test	eax, eax
	jle	$LN1@ImaDecodeS

; 364  : 				{
; 365  : 				//left channel
; 366  : 				encSampleL	= (short)(leftSamples & 0x0F);

	mov	ecx, DWORD PTR _leftSamples$[ebp]
	and	ecx, 15					; 0000000fH
	mov	WORD PTR _encSampleL$[ebp], cx

; 367  : 				stepSize	= step[stepIndexL];

	movsx	edx, WORD PTR _stepIndexL$[ebp]
	mov	ax, WORD PTR _step[edx*2]
	mov	WORD PTR _stepSize$[ebp], ax

; 368  : 				predSampleL = IMA_SampleDecode(encSampleL, predSampleL, stepSize);

	movzx	ecx, WORD PTR _stepSize$[ebp]
	push	ecx
	movzx	edx, WORD PTR _predSampleL$[ebp]
	push	edx
	movzx	eax, WORD PTR _encSampleL$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IMA_SampleDecode@CSoundMgr@@AAEFFFF@Z	; CSoundMgr::IMA_SampleDecode
	mov	WORD PTR _predSampleL$[ebp], ax

; 369  : 				stepIndexL	= IMA_NextStepIndex(encSampleL, stepIndexL);

	movzx	ecx, WORD PTR _stepIndexL$[ebp]
	push	ecx
	movzx	edx, WORD PTR _encSampleL$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IMA_NextStepIndex@CSoundMgr@@AAEFFF@Z	; CSoundMgr::IMA_NextStepIndex
	mov	WORD PTR _stepIndexL$[ebp], ax

; 370  : 
; 371  : 				//right channel
; 372  : 				encSampleR 	= (short)(rightSamples & 0x0F);

	mov	eax, DWORD PTR _rightSamples$[ebp]
	and	eax, 15					; 0000000fH
	mov	WORD PTR _encSampleR$[ebp], ax

; 373  : 				stepSize	= step[stepIndexR];

	movsx	ecx, WORD PTR _stepIndexR$[ebp]
	mov	dx, WORD PTR _step[ecx*2]
	mov	WORD PTR _stepSize$[ebp], dx

; 374  : 				predSampleR = IMA_SampleDecode(encSampleR, predSampleR, stepSize);

	movzx	eax, WORD PTR _stepSize$[ebp]
	push	eax
	movzx	ecx, WORD PTR _predSampleR$[ebp]
	push	ecx
	movzx	edx, WORD PTR _encSampleR$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IMA_SampleDecode@CSoundMgr@@AAEFFFF@Z	; CSoundMgr::IMA_SampleDecode
	mov	WORD PTR _predSampleR$[ebp], ax

; 375  : 				stepIndexR 	= IMA_NextStepIndex(encSampleR, stepIndexR);

	movzx	eax, WORD PTR _stepIndexR$[ebp]
	push	eax
	movzx	ecx, WORD PTR _encSampleR$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IMA_NextStepIndex@CSoundMgr@@AAEFFF@Z	; CSoundMgr::IMA_NextStepIndex
	mov	WORD PTR _stepIndexR$[ebp], ax

; 376  : 
; 377  : 				//write out the sample
; 378  : 				*(long *)dBuff = MAKELONG(predSampleL, predSampleR);

	movsx	edx, WORD PTR _predSampleL$[ebp]
	and	edx, 65535				; 0000ffffH
	movzx	eax, dx
	movsx	ecx, WORD PTR _predSampleR$[ebp]
	and	ecx, 65535				; 0000ffffH
	movzx	edx, cx
	shl	edx, 16					; 00000010H
	or	eax, edx
	mov	ecx, DWORD PTR _dBuff$[ebp]
	mov	DWORD PTR [ecx], eax

; 379  : 				dBuff			= dBuff + sizeof(long);

	mov	edx, DWORD PTR _dBuff$[ebp]
	add	edx, 4
	mov	DWORD PTR _dBuff$[ebp], edx

; 380  : 
; 381  : 				//shift the next input ssample into the low-order 4 bits
; 382  : 				leftSamples 	>>= 4;

	mov	eax, DWORD PTR _leftSamples$[ebp]
	sar	eax, 4
	mov	DWORD PTR _leftSamples$[ebp], eax

; 383  : 				rightSamples	>>= 4;

	mov	ecx, DWORD PTR _rightSamples$[ebp]
	sar	ecx, 4
	mov	DWORD PTR _rightSamples$[ebp], ecx

; 384  : 				} //loop of i=8 decrement to 0 	

	jmp	$LN2@ImaDecodeS
$LN1@ImaDecodeS:

; 385  : 			} //0 != blockLength				

	jmp	$LN5@ImaDecodeS
$LN4@ImaDecodeS:

; 386  : 		} //while 0 != bufferLength

	jmp	$LN11@ImaDecodeS
$LN10@ImaDecodeS:

; 387  : 
; 388  : 	//return the number of bytes written
; 389  : 	return (long)(dBuff - dBuffStart);

	mov	eax, DWORD PTR _dBuff$[ebp]
	sub	eax, DWORD PTR _dBuffStart$[ebp]
$LN12@ImaDecodeS:

; 390  : 
; 391  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?ImaDecodeS16@CSoundMgr@@AAEJPAD0J@Z ENDP		; CSoundMgr::ImaDecodeS16
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\adpcm.cpp
_TEXT	SEGMENT
_header$ = -24						; size = 4
tv77 = -20						; size = 4
_this$ = -16						; size = 4
_didx$ = -12						; size = 4
_stepSize$ = -8						; size = 2
_encSample$ = -4					; size = 2
_Info$ = 8						; size = 4
_dBuff$ = 12						; size = 4
_dlen$ = 16						; size = 4
?StreamImaM16@CSoundMgr@@AAEJPAUIMA_STREAM@@PADJ@Z PROC	; CSoundMgr::StreamImaM16
; _this$ = ecx

; 97   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 98   : 	short	stepSize;
; 99   : 	IMA_BLOCK	*header;
; 100  : 	long		didx;
; 101  : 
; 102  : 	short	encSample;
; 103  : 
; 104  : 	didx=0;

	mov	DWORD PTR _didx$[ebp], 0
$LN9@StreamImaM:

; 105  : 
; 106  : 	//step through each byte of IMA ADPCM and decode it to PCM
; 107  : 	while (Info->sidx < Info->slen && didx < dlen && Info->didx < Info->dlen)

	mov	eax, DWORD PTR _Info$[ebp]
	mov	ecx, DWORD PTR _Info$[ebp]
	mov	edx, DWORD PTR [eax+12]
	cmp	edx, DWORD PTR [ecx+16]
	jge	$LN8@StreamImaM
	mov	eax, DWORD PTR _didx$[ebp]
	cmp	eax, DWORD PTR _dlen$[ebp]
	jge	$LN8@StreamImaM
	mov	ecx, DWORD PTR _Info$[ebp]
	mov	edx, DWORD PTR _Info$[ebp]
	mov	eax, DWORD PTR [ecx+28]
	cmp	eax, DWORD PTR [edx+32]
	jge	$LN8@StreamImaM

; 108  : 	{			 
; 109  : 		if(!Info->blockLength)

	mov	ecx, DWORD PTR _Info$[ebp]
	cmp	DWORD PTR [ecx+40], 0
	jne	$LN5@StreamImaM

; 110  : 		{
; 111  : 			Info->blockLength 	= min(Info->slen, SND_ADPCM_MBLOCK_ALIGN);

	mov	edx, DWORD PTR _Info$[ebp]
	cmp	DWORD PTR [edx+16], 512			; 00000200H
	jge	SHORT $LN12@StreamImaM
	mov	eax, DWORD PTR _Info$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR tv77[ebp], ecx
	jmp	SHORT $LN13@StreamImaM
$LN12@StreamImaM:
	mov	DWORD PTR tv77[ebp], 512		; 00000200H
$LN13@StreamImaM:
	mov	edx, DWORD PTR _Info$[ebp]
	mov	eax, DWORD PTR tv77[ebp]
	mov	DWORD PTR [edx+40], eax

; 112  : 			Info->blockLength    -= sizeof(IMA_BLOCK) * SND_WAV_MCHAN;

	mov	ecx, DWORD PTR _Info$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	sub	edx, 4
	mov	eax, DWORD PTR _Info$[ebp]
	mov	DWORD PTR [eax+40], edx

; 113  : 			
; 114  : 			//get the block header
; 115  : 			header				 = (IMA_BLOCK *)&Info->src[Info->sidx % Info->srcsize];

	mov	ecx, DWORD PTR _Info$[ebp]
	mov	esi, DWORD PTR _Info$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	cdq
	idiv	DWORD PTR [esi+24]
	mov	eax, DWORD PTR _Info$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, edx
	mov	DWORD PTR _header$[ebp], ecx

; 116  : 			Info->sidx			+= sizeof(IMA_BLOCK);

	mov	edx, DWORD PTR _Info$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, 4
	mov	ecx, DWORD PTR _Info$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 117  : 			Info->predSampleL	 = header->iSamp0;

	mov	edx, DWORD PTR _Info$[ebp]
	mov	eax, DWORD PTR _header$[ebp]
	mov	cx, WORD PTR [eax]
	mov	WORD PTR [edx+46], cx

; 118  : 			Info->stepIndexL	 = (short)header->bStepTableIndex;

	mov	edx, DWORD PTR _header$[ebp]
	movsx	ax, BYTE PTR [edx+2]
	mov	ecx, DWORD PTR _Info$[ebp]
	mov	WORD PTR [ecx+52], ax

; 119  : 			if (!IMA_ValidStepIndex(Info->stepIndexL))

	mov	edx, DWORD PTR _Info$[ebp]
	movzx	eax, WORD PTR [edx+52]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IMA_ValidStepIndex@CSoundMgr@@AAEHF@Z	; CSoundMgr::IMA_ValidStepIndex
	test	eax, eax
	jne	SHORT $LN6@StreamImaM

; 120  : 			{
; 121  : 				MonoPrint("S16:  invalid left step index\n");

	push	OFFSET ??_C@_0BP@IIGNJFPO@S16?3?5?5invalid?5left?5step?5index?6?$AA@
	call	_MonoPrint
	add	esp, 4

; 122  : 				return 0;

	xor	eax, eax
	jmp	$LN10@StreamImaM
$LN6@StreamImaM:

; 123  : 			}
; 124  : 				
; 125  : 			//write out the first sample
; 126  : 			*(short *)&dBuff[didx] = (short)Info->predSampleL;

	mov	ecx, DWORD PTR _dBuff$[ebp]
	add	ecx, DWORD PTR _didx$[ebp]
	mov	edx, DWORD PTR _Info$[ebp]
	mov	ax, WORD PTR [edx+46]
	mov	WORD PTR [ecx], ax

; 127  : 			didx += sizeof(short);

	mov	ecx, DWORD PTR _didx$[ebp]
	add	ecx, 2
	mov	DWORD PTR _didx$[ebp], ecx

; 128  : 			Info->didx++;

	mov	edx, DWORD PTR _Info$[ebp]
	mov	eax, DWORD PTR [edx+28]
	add	eax, 1
	mov	ecx, DWORD PTR _Info$[ebp]
	mov	DWORD PTR [ecx+28], eax

; 129  : 
; 130  : 			Info->count=0;

	xor	edx, edx
	mov	eax, DWORD PTR _Info$[ebp]
	mov	WORD PTR [eax+44], dx
$LN5@StreamImaM:

; 131  : 		}
; 132  : 		while (Info->blockLength && didx < dlen && Info->didx < Info->dlen)

	mov	ecx, DWORD PTR _Info$[ebp]
	cmp	DWORD PTR [ecx+40], 0
	je	$LN4@StreamImaM
	mov	edx, DWORD PTR _didx$[ebp]
	cmp	edx, DWORD PTR _dlen$[ebp]
	jge	$LN4@StreamImaM
	mov	eax, DWORD PTR _Info$[ebp]
	mov	ecx, DWORD PTR _Info$[ebp]
	mov	edx, DWORD PTR [eax+28]
	cmp	edx, DWORD PTR [ecx+32]
	jge	$LN4@StreamImaM

; 133  : 		{
; 134  : 			if(!Info->count)

	mov	eax, DWORD PTR _Info$[ebp]
	movsx	ecx, WORD PTR [eax+44]
	test	ecx, ecx
	jne	SHORT $LN2@StreamImaM

; 135  : 			{
; 136  : 				Info->leftSamples 	= Info->src[Info->sidx % Info->srcsize];

	mov	edx, DWORD PTR _Info$[ebp]
	mov	ecx, DWORD PTR _Info$[ebp]
	mov	eax, DWORD PTR [edx+12]
	cdq
	idiv	DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _Info$[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+edx]
	mov	eax, DWORD PTR _Info$[ebp]
	mov	DWORD PTR [eax+48], edx

; 137  : 				Info->sidx++;

	mov	ecx, DWORD PTR _Info$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, 1
	mov	eax, DWORD PTR _Info$[ebp]
	mov	DWORD PTR [eax+12], edx

; 138  : 
; 139  : 				Info->blockLength--;

	mov	ecx, DWORD PTR _Info$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	sub	edx, 1
	mov	eax, DWORD PTR _Info$[ebp]
	mov	DWORD PTR [eax+40], edx

; 140  : 
; 141  : 				Info->count=2;

	mov	ecx, 2
	mov	edx, DWORD PTR _Info$[ebp]
	mov	WORD PTR [edx+44], cx
$LN2@StreamImaM:

; 142  : 			}
; 143  : 
; 144  : 			while(Info->count && didx < dlen && Info->didx < Info->dlen)

	mov	eax, DWORD PTR _Info$[ebp]
	movsx	ecx, WORD PTR [eax+44]
	test	ecx, ecx
	je	$LN1@StreamImaM
	mov	edx, DWORD PTR _didx$[ebp]
	cmp	edx, DWORD PTR _dlen$[ebp]
	jge	$LN1@StreamImaM
	mov	eax, DWORD PTR _Info$[ebp]
	mov	ecx, DWORD PTR _Info$[ebp]
	mov	edx, DWORD PTR [eax+28]
	cmp	edx, DWORD PTR [ecx+32]
	jge	$LN1@StreamImaM

; 145  : 			{
; 146  : 				encSample	= (short)(Info->leftSamples & 0x0F);

	mov	eax, DWORD PTR _Info$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	and	ecx, 15					; 0000000fH
	mov	WORD PTR _encSample$[ebp], cx

; 147  : 				stepSize	= step[Info->stepIndexL];

	mov	edx, DWORD PTR _Info$[ebp]
	movsx	eax, WORD PTR [edx+52]
	mov	cx, WORD PTR _step[eax*2]
	mov	WORD PTR _stepSize$[ebp], cx

; 148  : 				Info->predSampleL  = IMA_SampleDecode(encSample, Info->predSampleL, stepSize);

	movzx	edx, WORD PTR _stepSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _Info$[ebp]
	movzx	ecx, WORD PTR [eax+46]
	push	ecx
	movzx	edx, WORD PTR _encSample$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IMA_SampleDecode@CSoundMgr@@AAEFFFF@Z	; CSoundMgr::IMA_SampleDecode
	mov	ecx, DWORD PTR _Info$[ebp]
	mov	WORD PTR [ecx+46], ax

; 149  : 				Info->stepIndexL	= IMA_NextStepIndex(encSample, Info->stepIndexL);

	mov	edx, DWORD PTR _Info$[ebp]
	movzx	eax, WORD PTR [edx+52]
	push	eax
	movzx	ecx, WORD PTR _encSample$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IMA_NextStepIndex@CSoundMgr@@AAEFFF@Z	; CSoundMgr::IMA_NextStepIndex
	mov	edx, DWORD PTR _Info$[ebp]
	mov	WORD PTR [edx+52], ax

; 150  : 
; 151  : 				*(short *)&dBuff[didx] = (short)Info->predSampleL;

	mov	eax, DWORD PTR _dBuff$[ebp]
	add	eax, DWORD PTR _didx$[ebp]
	mov	ecx, DWORD PTR _Info$[ebp]
	mov	dx, WORD PTR [ecx+46]
	mov	WORD PTR [eax], dx

; 152  : 				didx += sizeof(short);

	mov	eax, DWORD PTR _didx$[ebp]
	add	eax, 2
	mov	DWORD PTR _didx$[ebp], eax

; 153  : 				Info->didx++;

	mov	ecx, DWORD PTR _Info$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	add	edx, 1
	mov	eax, DWORD PTR _Info$[ebp]
	mov	DWORD PTR [eax+28], edx

; 154  : 
; 155  : 				Info->leftSamples >>= 4;

	mov	ecx, DWORD PTR _Info$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	sar	edx, 4
	mov	eax, DWORD PTR _Info$[ebp]
	mov	DWORD PTR [eax+48], edx

; 156  : 				Info->count--;

	mov	ecx, DWORD PTR _Info$[ebp]
	mov	dx, WORD PTR [ecx+44]
	sub	dx, 1
	mov	eax, DWORD PTR _Info$[ebp]
	mov	WORD PTR [eax+44], dx

; 157  : 			}

	jmp	$LN2@StreamImaM
$LN1@StreamImaM:

; 158  : 		}			

	jmp	$LN5@StreamImaM
$LN4@StreamImaM:

; 159  : 	}

	jmp	$LN9@StreamImaM
$LN8@StreamImaM:

; 160  : 
; 161  : 	//return the number of bytes written
; 162  : 	return (long)(didx);

	mov	eax, DWORD PTR _didx$[ebp]
$LN10@StreamImaM:

; 163  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?StreamImaM16@CSoundMgr@@AAEJPAUIMA_STREAM@@PADJ@Z ENDP	; CSoundMgr::StreamImaM16
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\adpcm.cpp
_TEXT	SEGMENT
_header$ = -24						; size = 4
_this$ = -20						; size = 4
_didx$ = -16						; size = 4
_encSampleR$ = -12					; size = 2
_encSampleL$ = -8					; size = 2
_stepSize$ = -4						; size = 2
_Info$ = 8						; size = 4
_dBuff$ = 12						; size = 4
_dlen$ = 16						; size = 4
?StreamImaS16@CSoundMgr@@AAEJPAUIMA_STREAM@@PADJ@Z PROC	; CSoundMgr::StreamImaS16
; _this$ = ecx

; 173  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 174  : 	short		stepSize;
; 175  : 	IMA_BLOCK	*header;
; 176  : 	long		didx;
; 177  : 
; 178  : 	short	encSampleL;
; 179  : 	short	encSampleR;
; 180  : 
; 181  : 	didx=0;

	mov	DWORD PTR _didx$[ebp], 0
$LN12@StreamImaS:

; 182  : 
; 183  : 	//step through each byte of IMA ADPCM and decode it to PCM
; 184  : 	while (Info->sidx < Info->slen && didx < dlen && Info->didx < Info->dlen)

	mov	eax, DWORD PTR _Info$[ebp]
	mov	ecx, DWORD PTR _Info$[ebp]
	mov	edx, DWORD PTR [eax+12]
	cmp	edx, DWORD PTR [ecx+16]
	jge	$LN11@StreamImaS
	mov	eax, DWORD PTR _didx$[ebp]
	cmp	eax, DWORD PTR _dlen$[ebp]
	jge	$LN11@StreamImaS
	mov	ecx, DWORD PTR _Info$[ebp]
	mov	edx, DWORD PTR _Info$[ebp]
	mov	eax, DWORD PTR [ecx+28]
	cmp	eax, DWORD PTR [edx+32]
	jge	$LN11@StreamImaS

; 185  : 	{
; 186  : 		if(!Info->blockLength)

	mov	ecx, DWORD PTR _Info$[ebp]
	cmp	DWORD PTR [ecx+40], 0
	jne	$LN5@StreamImaS

; 187  : 		{
; 188  : 			//data should always be block aligned
; 189  : 			if (Info->slen < SND_ADPCM_SBLOCK_ALIGN)

	mov	edx, DWORD PTR _Info$[ebp]
	cmp	DWORD PTR [edx+16], 1024		; 00000400H
	jge	SHORT $LN9@StreamImaS

; 190  : 			{
; 191  : 				MonoPrint("S16:  buffer length is less than the block alignment\n");

	push	OFFSET ??_C@_0DG@GBPJNDIA@S16?3?5?5buffer?5length?5is?5less?5than@
	call	_MonoPrint
	add	esp, 4

; 192  : 				return 0;

	xor	eax, eax
	jmp	$LN13@StreamImaS
$LN9@StreamImaS:

; 193  : 			}
; 194  : 				 
; 195  : 			Info->blockLength  = SND_ADPCM_SBLOCK_ALIGN;

	mov	eax, DWORD PTR _Info$[ebp]
	mov	DWORD PTR [eax+40], 1024		; 00000400H

; 196  : 			Info->blockLength -= sizeof(IMA_BLOCK) * SND_WAV_SCHAN;

	mov	ecx, DWORD PTR _Info$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	sub	edx, 8
	mov	eax, DWORD PTR _Info$[ebp]
	mov	DWORD PTR [eax+40], edx

; 197  : 			
; 198  : 			//get the left header
; 199  : 			header				 = (IMA_BLOCK *)&Info->src[Info->sidx % Info->srcsize];

	mov	ecx, DWORD PTR _Info$[ebp]
	mov	esi, DWORD PTR _Info$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	cdq
	idiv	DWORD PTR [esi+24]
	mov	eax, DWORD PTR _Info$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, edx
	mov	DWORD PTR _header$[ebp], ecx

; 200  : 			Info->sidx			+= sizeof(IMA_BLOCK);

	mov	edx, DWORD PTR _Info$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, 4
	mov	ecx, DWORD PTR _Info$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 201  : 			Info->predSampleL	 = header->iSamp0;

	mov	edx, DWORD PTR _Info$[ebp]
	mov	eax, DWORD PTR _header$[ebp]
	mov	cx, WORD PTR [eax]
	mov	WORD PTR [edx+46], cx

; 202  : 			Info->stepIndexL	 = (short)header->bStepTableIndex;

	mov	edx, DWORD PTR _header$[ebp]
	movsx	ax, BYTE PTR [edx+2]
	mov	ecx, DWORD PTR _Info$[ebp]
	mov	WORD PTR [ecx+52], ax

; 203  : 			if (!IMA_ValidStepIndex(Info->stepIndexL))

	mov	edx, DWORD PTR _Info$[ebp]
	movzx	eax, WORD PTR [edx+52]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IMA_ValidStepIndex@CSoundMgr@@AAEHF@Z	; CSoundMgr::IMA_ValidStepIndex
	test	eax, eax
	jne	SHORT $LN8@StreamImaS

; 204  : 			{
; 205  : 				MonoPrint("S16:  invalid left step index\n");

	push	OFFSET ??_C@_0BP@IIGNJFPO@S16?3?5?5invalid?5left?5step?5index?6?$AA@
	call	_MonoPrint
	add	esp, 4

; 206  : 				return 0;

	xor	eax, eax
	jmp	$LN13@StreamImaS
$LN8@StreamImaS:

; 207  : 			}
; 208  : 			
; 209  : 			//get the right header
; 210  : 			header				 = (IMA_BLOCK *)&Info->src[Info->sidx % Info->srcsize];

	mov	ecx, DWORD PTR _Info$[ebp]
	mov	esi, DWORD PTR _Info$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	cdq
	idiv	DWORD PTR [esi+24]
	mov	eax, DWORD PTR _Info$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, edx
	mov	DWORD PTR _header$[ebp], ecx

; 211  : 			Info->sidx			+= sizeof(IMA_BLOCK);

	mov	edx, DWORD PTR _Info$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, 4
	mov	ecx, DWORD PTR _Info$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 212  : 			Info->predSampleR	 = header->iSamp0;

	mov	edx, DWORD PTR _Info$[ebp]
	mov	eax, DWORD PTR _header$[ebp]
	mov	cx, WORD PTR [eax]
	mov	WORD PTR [edx+54], cx

; 213  : 			Info->stepIndexR	 = (short)header->bStepTableIndex;

	mov	edx, DWORD PTR _header$[ebp]
	movsx	ax, BYTE PTR [edx+2]
	mov	ecx, DWORD PTR _Info$[ebp]
	mov	WORD PTR [ecx+60], ax

; 214  : 			if (!IMA_ValidStepIndex(Info->stepIndexR))

	mov	edx, DWORD PTR _Info$[ebp]
	movzx	eax, WORD PTR [edx+60]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IMA_ValidStepIndex@CSoundMgr@@AAEHF@Z	; CSoundMgr::IMA_ValidStepIndex
	test	eax, eax
	jne	SHORT $LN7@StreamImaS

; 215  : 			{
; 216  : 				MonoPrint("S16:  invlid right step index\n");

	push	OFFSET ??_C@_0BP@OKDCLCBN@S16?3?5?5invlid?5right?5step?5index?6?$AA@
	call	_MonoPrint
	add	esp, 4

; 217  : 				return 0;

	xor	eax, eax
	jmp	$LN13@StreamImaS
$LN7@StreamImaS:

; 218  : 			}
; 219  : 				
; 220  : 			//write out the first sample
; 221  : 			*(long *)&dBuff[didx] = MAKELONG(Info->predSampleL, Info->predSampleR);

	mov	ecx, DWORD PTR _Info$[ebp]
	movsx	edx, WORD PTR [ecx+46]
	and	edx, 65535				; 0000ffffH
	movzx	eax, dx
	mov	ecx, DWORD PTR _Info$[ebp]
	movsx	edx, WORD PTR [ecx+54]
	and	edx, 65535				; 0000ffffH
	movzx	ecx, dx
	shl	ecx, 16					; 00000010H
	or	eax, ecx
	mov	edx, DWORD PTR _dBuff$[ebp]
	add	edx, DWORD PTR _didx$[ebp]
	mov	DWORD PTR [edx], eax

; 222  : 			didx += sizeof(long);

	mov	eax, DWORD PTR _didx$[ebp]
	add	eax, 4
	mov	DWORD PTR _didx$[ebp], eax

; 223  : 			Info->didx++;

	mov	ecx, DWORD PTR _Info$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	add	edx, 1
	mov	eax, DWORD PTR _Info$[ebp]
	mov	DWORD PTR [eax+28], edx

; 224  : 			
; 225  : 			//the first long contains 4 left samples the second long
; 226  : 			//contains 4 right samples.  Will process the source in 8-byte
; 227  : 			//chunks to make it eay to interleave the output correctly
; 228  : 			if ((Info->blockLength%8) != 0)

	mov	ecx, DWORD PTR _Info$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	and	edx, -2147483641			; 80000007H
	jns	SHORT $LN15@StreamImaS
	dec	edx
	or	edx, -8					; fffffff8H
	inc	edx
$LN15@StreamImaS:
	test	edx, edx
	je	SHORT $LN6@StreamImaS

; 229  : 			{
; 230  : 				MonoPrint("S16:  buffer length is not divisible by 8\n");

	push	OFFSET ??_C@_0CL@ELDPDMFD@S16?3?5?5buffer?5length?5is?5not?5divis@
	call	_MonoPrint
	add	esp, 4

; 231  : 				return 0;

	xor	eax, eax
	jmp	$LN13@StreamImaS
$LN6@StreamImaS:

; 232  : 			}
; 233  : 			Info->count=0;

	xor	eax, eax
	mov	ecx, DWORD PTR _Info$[ebp]
	mov	WORD PTR [ecx+44], ax
$LN5@StreamImaS:

; 234  : 		}
; 235  : 		while (Info->blockLength && didx < dlen && Info->didx < Info->dlen)

	mov	edx, DWORD PTR _Info$[ebp]
	cmp	DWORD PTR [edx+40], 0
	je	$LN4@StreamImaS
	mov	eax, DWORD PTR _didx$[ebp]
	cmp	eax, DWORD PTR _dlen$[ebp]
	jge	$LN4@StreamImaS
	mov	ecx, DWORD PTR _Info$[ebp]
	mov	edx, DWORD PTR _Info$[ebp]
	mov	eax, DWORD PTR [ecx+28]
	cmp	eax, DWORD PTR [edx+32]
	jge	$LN4@StreamImaS

; 236  : 		{
; 237  : 			if(!Info->count)

	mov	ecx, DWORD PTR _Info$[ebp]
	movsx	edx, WORD PTR [ecx+44]
	test	edx, edx
	jne	SHORT $LN2@StreamImaS

; 238  : 			{
; 239  : 				Info->blockLength    -= 8;

	mov	eax, DWORD PTR _Info$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	sub	ecx, 8
	mov	edx, DWORD PTR _Info$[ebp]
	mov	DWORD PTR [edx+40], ecx

; 240  : 
; 241  : 				Info->leftSamples 	 = *(long *)&Info->src[Info->sidx % Info->srcsize];

	mov	eax, DWORD PTR _Info$[ebp]
	mov	ecx, DWORD PTR _Info$[ebp]
	mov	eax, DWORD PTR [eax+12]
	cdq
	idiv	DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _Info$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _Info$[ebp]
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [eax+48], ecx

; 242  : 				Info->sidx	  		+= sizeof(long);

	mov	edx, DWORD PTR _Info$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, 4
	mov	ecx, DWORD PTR _Info$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 243  : 				Info->rightSamples 	 = *(long *)&Info->src[Info->sidx % Info->srcsize];

	mov	edx, DWORD PTR _Info$[ebp]
	mov	ecx, DWORD PTR _Info$[ebp]
	mov	eax, DWORD PTR [edx+12]
	cdq
	idiv	DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _Info$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _Info$[ebp]
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [eax+56], ecx

; 244  : 				Info->sidx			+= sizeof(long);

	mov	edx, DWORD PTR _Info$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, 4
	mov	ecx, DWORD PTR _Info$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 245  : 			
; 246  : 				Info->count = 8;

	mov	edx, 8
	mov	eax, DWORD PTR _Info$[ebp]
	mov	WORD PTR [eax+44], dx
$LN2@StreamImaS:

; 247  : 			}
; 248  : 			while(Info->count && didx < dlen && Info->didx < Info->dlen)

	mov	ecx, DWORD PTR _Info$[ebp]
	movsx	edx, WORD PTR [ecx+44]
	test	edx, edx
	je	$LN1@StreamImaS
	mov	eax, DWORD PTR _didx$[ebp]
	cmp	eax, DWORD PTR _dlen$[ebp]
	jge	$LN1@StreamImaS
	mov	ecx, DWORD PTR _Info$[ebp]
	mov	edx, DWORD PTR _Info$[ebp]
	mov	eax, DWORD PTR [ecx+28]
	cmp	eax, DWORD PTR [edx+32]
	jge	$LN1@StreamImaS

; 249  : 			{
; 250  : 				//left channel
; 251  : 				encSampleL			= (short)(Info->leftSamples & 0x0F);

	mov	ecx, DWORD PTR _Info$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	and	edx, 15					; 0000000fH
	mov	WORD PTR _encSampleL$[ebp], dx

; 252  : 				stepSize			= step[Info->stepIndexL];

	mov	eax, DWORD PTR _Info$[ebp]
	movsx	ecx, WORD PTR [eax+52]
	mov	dx, WORD PTR _step[ecx*2]
	mov	WORD PTR _stepSize$[ebp], dx

; 253  : 				Info->predSampleL	= IMA_SampleDecode(encSampleL, Info->predSampleL, stepSize);

	movzx	eax, WORD PTR _stepSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Info$[ebp]
	movzx	edx, WORD PTR [ecx+46]
	push	edx
	movzx	eax, WORD PTR _encSampleL$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IMA_SampleDecode@CSoundMgr@@AAEFFFF@Z	; CSoundMgr::IMA_SampleDecode
	mov	ecx, DWORD PTR _Info$[ebp]
	mov	WORD PTR [ecx+46], ax

; 254  : 				Info->stepIndexL	= IMA_NextStepIndex(encSampleL, Info->stepIndexL);

	mov	edx, DWORD PTR _Info$[ebp]
	movzx	eax, WORD PTR [edx+52]
	push	eax
	movzx	ecx, WORD PTR _encSampleL$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IMA_NextStepIndex@CSoundMgr@@AAEFFF@Z	; CSoundMgr::IMA_NextStepIndex
	mov	edx, DWORD PTR _Info$[ebp]
	mov	WORD PTR [edx+52], ax

; 255  : 
; 256  : 				//right channel
; 257  : 				encSampleR 			= (short)(Info->rightSamples & 0x0F);

	mov	eax, DWORD PTR _Info$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	and	ecx, 15					; 0000000fH
	mov	WORD PTR _encSampleR$[ebp], cx

; 258  : 				stepSize			= step[Info->stepIndexR];

	mov	edx, DWORD PTR _Info$[ebp]
	movsx	eax, WORD PTR [edx+60]
	mov	cx, WORD PTR _step[eax*2]
	mov	WORD PTR _stepSize$[ebp], cx

; 259  : 				Info->predSampleR	= IMA_SampleDecode(encSampleR, Info->predSampleR, stepSize);

	movzx	edx, WORD PTR _stepSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _Info$[ebp]
	movzx	ecx, WORD PTR [eax+54]
	push	ecx
	movzx	edx, WORD PTR _encSampleR$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IMA_SampleDecode@CSoundMgr@@AAEFFFF@Z	; CSoundMgr::IMA_SampleDecode
	mov	ecx, DWORD PTR _Info$[ebp]
	mov	WORD PTR [ecx+54], ax

; 260  : 				Info->stepIndexR 	= IMA_NextStepIndex(encSampleR, Info->stepIndexR);

	mov	edx, DWORD PTR _Info$[ebp]
	movzx	eax, WORD PTR [edx+60]
	push	eax
	movzx	ecx, WORD PTR _encSampleR$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IMA_NextStepIndex@CSoundMgr@@AAEFFF@Z	; CSoundMgr::IMA_NextStepIndex
	mov	edx, DWORD PTR _Info$[ebp]
	mov	WORD PTR [edx+60], ax

; 261  : 
; 262  : 				//write out the sample
; 263  : 				*(long *)&dBuff[didx] = MAKELONG(Info->predSampleL, Info->predSampleR);

	mov	eax, DWORD PTR _Info$[ebp]
	movsx	ecx, WORD PTR [eax+46]
	and	ecx, 65535				; 0000ffffH
	movzx	edx, cx
	mov	eax, DWORD PTR _Info$[ebp]
	movsx	ecx, WORD PTR [eax+54]
	and	ecx, 65535				; 0000ffffH
	movzx	eax, cx
	shl	eax, 16					; 00000010H
	or	edx, eax
	mov	ecx, DWORD PTR _dBuff$[ebp]
	add	ecx, DWORD PTR _didx$[ebp]
	mov	DWORD PTR [ecx], edx

; 264  : 				didx += sizeof(long);

	mov	edx, DWORD PTR _didx$[ebp]
	add	edx, 4
	mov	DWORD PTR _didx$[ebp], edx

; 265  : 				Info->didx++;

	mov	eax, DWORD PTR _Info$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	add	ecx, 1
	mov	edx, DWORD PTR _Info$[ebp]
	mov	DWORD PTR [edx+28], ecx

; 266  : 
; 267  : 				//shift the next input ssample into the low-order 4 bits
; 268  : 				Info->leftSamples 	>>= 4;

	mov	eax, DWORD PTR _Info$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	sar	ecx, 4
	mov	edx, DWORD PTR _Info$[ebp]
	mov	DWORD PTR [edx+48], ecx

; 269  : 				Info->rightSamples	>>= 4;

	mov	eax, DWORD PTR _Info$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	sar	ecx, 4
	mov	edx, DWORD PTR _Info$[ebp]
	mov	DWORD PTR [edx+56], ecx

; 270  : 				Info->count--;

	mov	eax, DWORD PTR _Info$[ebp]
	mov	cx, WORD PTR [eax+44]
	sub	cx, 1
	mov	edx, DWORD PTR _Info$[ebp]
	mov	WORD PTR [edx+44], cx

; 271  : 			}

	jmp	$LN2@StreamImaS
$LN1@StreamImaS:

; 272  : 		}		

	jmp	$LN5@StreamImaS
$LN4@StreamImaS:

; 273  : 	}

	jmp	$LN12@StreamImaS
$LN11@StreamImaS:

; 274  : 	return (long)(didx);

	mov	eax, DWORD PTR _didx$[ebp]
$LN13@StreamImaS:

; 275  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?StreamImaS16@CSoundMgr@@AAEJPAUIMA_STREAM@@PADJ@Z ENDP	; CSoundMgr::StreamImaS16
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\adpcm.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_Stream$ = 8						; size = 4
_dest$ = 12						; size = 4
_dlen$ = 16						; size = 4
?MemStreamIMAADPCM@CSoundMgr@@QAEJPAVSoundStream@@PADJ@Z PROC ; CSoundMgr::MemStreamIMAADPCM
; _this$ = ecx

; 86   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 87   : 	// Decode requested length
; 88   : 	if(Stream->ImaInfo->type == SND_WAV_SCHAN)

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	movsx	edx, WORD PTR [ecx+36]
	cmp	edx, 2
	jne	SHORT $LN1@MemStreamI

; 89   : 		return(StreamImaS16(Stream->ImaInfo,dest,dlen));

	mov	eax, DWORD PTR _dlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+76]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StreamImaS16@CSoundMgr@@AAEJPAUIMA_STREAM@@PADJ@Z ; CSoundMgr::StreamImaS16
	jmp	SHORT $LN2@MemStreamI
$LN1@MemStreamI:

; 90   : 
; 91   : 	return(StreamImaM16(Stream->ImaInfo,dest,dlen));

	mov	ecx, DWORD PTR _dlen$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dest$[ebp]
	push	edx
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StreamImaM16@CSoundMgr@@AAEJPAUIMA_STREAM@@PADJ@Z ; CSoundMgr::StreamImaM16
$LN2@MemStreamI:

; 92   : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?MemStreamIMAADPCM@CSoundMgr@@QAEJPAVSoundStream@@PADJ@Z ENDP ; CSoundMgr::MemStreamIMAADPCM
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falcsnd\adpcm.cpp
_TEXT	SEGMENT
_this$ = -24						; size = 4
tv211 = -20						; size = 4
tv157 = -16						; size = 4
tv76 = -12						; size = 4
_bytesread$ = -8					; size = 4
_bytestoread$ = -4					; size = 4
_Stream$ = 8						; size = 4
_dest$ = 12						; size = 4
_dlen$ = 16						; size = 4
?StreamIMAADPCM@CSoundMgr@@QAEJPAVSoundStream@@PADJ@Z PROC ; CSoundMgr::StreamIMAADPCM
; _this$ = ecx

; 43   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 44   : 	DWORD bytesread;
; 45   : 	long bytestoread;
; 46   : 
; 47   : 	// Keep buffer filled
; 48   : 	if(Stream->ImaInfo->sreadidx == -1) // read into entire buffer

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	cmp	DWORD PTR [ecx+20], -1
	jne	SHORT $LN8@StreamIMAA

; 49   : 	{
; 50   : 		bytestoread=min(Stream->ImaInfo->srcsize,Stream->ImaInfo->slen);

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	eax, DWORD PTR [eax+24]
	cmp	eax, DWORD PTR [edx+16]
	jge	SHORT $LN11@StreamIMAA
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN12@StreamIMAA
$LN11@StreamIMAA:
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR tv76[ebp], eax
$LN12@StreamIMAA:
	mov	ecx, DWORD PTR tv76[ebp]
	mov	DWORD PTR _bytestoread$[ebp], ecx

; 51   : 		ReadFile(Stream->fp,Stream->ImaInfo->src,bytestoread,&bytesread,NULL);

	push	0
	lea	edx, DWORD PTR _bytesread$[ebp]
	push	edx
	mov	eax, DWORD PTR _bytestoread$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	call	DWORD PTR __imp__ReadFile@20

; 52   : 		Stream->ImaInfo->sreadidx=bytesread;

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR _bytesread$[ebp]
	mov	DWORD PTR [ecx+20], edx

; 53   : 		Stream->ImaInfo->Status=0;

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	xor	edx, edx
	mov	WORD PTR [ecx+38], dx
	jmp	$LN7@StreamIMAA
$LN8@StreamIMAA:

; 54   : 	}
; 55   : 	else if(Stream->ImaInfo->sreadidx < Stream->ImaInfo->slen)

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	ecx, DWORD PTR [ecx+20]
	cmp	ecx, DWORD PTR [eax+16]
	jge	$LN7@StreamIMAA

; 56   : 	{
; 57   : 		if(!(Stream->ImaInfo->Status & SND_STREAM_PART2))

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+76]
	movsx	ecx, WORD PTR [eax+38]
	and	ecx, 2
	jne	$LN5@StreamIMAA

; 58   : 		{
; 59   : 			if((Stream->ImaInfo->sidx % Stream->ImaInfo->srcsize) > (Stream->ImaInfo->srcsize >> 1))

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [ecx+76]
	mov	eax, DWORD PTR [eax+12]
	cdq
	idiv	DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	eax, DWORD PTR [ecx+24]
	sar	eax, 1
	cmp	edx, eax
	jle	$LN4@StreamIMAA

; 60   : 			{
; 61   : 				bytestoread=min(Stream->ImaInfo->slen-Stream->ImaInfo->sreadidx,(Stream->ImaInfo->srcsize >> 1));

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR [edx+16]
	sub	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	eax, DWORD PTR [ecx+24]
	sar	eax, 1
	cmp	edx, eax
	jge	SHORT $LN13@StreamIMAA
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR [edx+16]
	sub	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR tv157[ebp], edx
	jmp	SHORT $LN14@StreamIMAA
$LN13@StreamIMAA:
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR [ecx+24]
	sar	edx, 1
	mov	DWORD PTR tv157[ebp], edx
$LN14@StreamIMAA:
	mov	eax, DWORD PTR tv157[ebp]
	mov	DWORD PTR _bytestoread$[ebp], eax

; 62   : 				ReadFile(Stream->fp,&Stream->ImaInfo->src[Stream->ImaInfo->sreadidx % Stream->ImaInfo->srcsize],bytestoread,&bytesread,NULL);

	push	0
	lea	ecx, DWORD PTR _bytesread$[ebp]
	push	ecx
	mov	edx, DWORD PTR _bytestoread$[ebp]
	push	edx
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	esi, DWORD PTR [edx+76]
	mov	eax, DWORD PTR [eax+20]
	cdq
	idiv	DWORD PTR [esi+24]
	mov	eax, DWORD PTR [ecx]
	add	eax, edx
	push	eax
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	call	DWORD PTR __imp__ReadFile@20

; 63   : 				Stream->ImaInfo->sreadidx+=bytesread;

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR [ecx+20]
	add	edx, DWORD PTR _bytesread$[ebp]
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR [ecx+20], edx

; 64   : 				Stream->ImaInfo->Status ^= SND_STREAM_PART2;

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+76]
	movsx	ecx, WORD PTR [eax+38]
	xor	ecx, 2
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	WORD PTR [eax+38], cx
$LN4@StreamIMAA:

; 65   : 			}
; 66   : 		}
; 67   : 		else 

	jmp	$LN7@StreamIMAA
$LN5@StreamIMAA:

; 68   : 		{
; 69   : 			if((Stream->ImaInfo->sidx % Stream->ImaInfo->srcsize) < (Stream->ImaInfo->srcsize >> 1))

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	eax, DWORD PTR [edx+12]
	cdq
	idiv	DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	eax, DWORD PTR [ecx+24]
	sar	eax, 1
	cmp	edx, eax
	jge	$LN7@StreamIMAA

; 70   : 			{
; 71   : 				bytestoread=min(Stream->ImaInfo->slen-Stream->ImaInfo->sreadidx,(Stream->ImaInfo->srcsize >> 1));

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR [edx+16]
	sub	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	eax, DWORD PTR [ecx+24]
	sar	eax, 1
	cmp	edx, eax
	jge	SHORT $LN15@StreamIMAA
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR [edx+16]
	sub	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR tv211[ebp], edx
	jmp	SHORT $LN16@StreamIMAA
$LN15@StreamIMAA:
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR [ecx+24]
	sar	edx, 1
	mov	DWORD PTR tv211[ebp], edx
$LN16@StreamIMAA:
	mov	eax, DWORD PTR tv211[ebp]
	mov	DWORD PTR _bytestoread$[ebp], eax

; 72   : 				ReadFile(Stream->fp,&Stream->ImaInfo->src[Stream->ImaInfo->sreadidx % Stream->ImaInfo->srcsize],bytestoread,&bytesread,NULL);

	push	0
	lea	ecx, DWORD PTR _bytesread$[ebp]
	push	ecx
	mov	edx, DWORD PTR _bytestoread$[ebp]
	push	edx
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	esi, DWORD PTR [edx+76]
	mov	eax, DWORD PTR [eax+20]
	cdq
	idiv	DWORD PTR [esi+24]
	mov	eax, DWORD PTR [ecx]
	add	eax, edx
	push	eax
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	call	DWORD PTR __imp__ReadFile@20

; 73   : 				Stream->ImaInfo->sreadidx+=bytesread;

	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR [ecx+20]
	add	edx, DWORD PTR _bytesread$[ebp]
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR [ecx+20], edx

; 74   : 				Stream->ImaInfo->Status ^= SND_STREAM_PART2;

	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+76]
	movsx	ecx, WORD PTR [eax+38]
	xor	ecx, 2
	mov	edx, DWORD PTR _Stream$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	WORD PTR [eax+38], cx
$LN7@StreamIMAA:

; 75   : 			}
; 76   : 		}
; 77   : 	}
; 78   : 	// Decode requested length
; 79   : 	if(Stream->ImaInfo->type == SND_WAV_SCHAN)

	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	movsx	eax, WORD PTR [edx+36]
	cmp	eax, 2
	jne	SHORT $LN1@StreamIMAA

; 80   : 		return(StreamImaS16(Stream->ImaInfo,dest,dlen));

	mov	ecx, DWORD PTR _dlen$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dest$[ebp]
	push	edx
	mov	eax, DWORD PTR _Stream$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StreamImaS16@CSoundMgr@@AAEJPAUIMA_STREAM@@PADJ@Z ; CSoundMgr::StreamImaS16
	jmp	SHORT $LN9@StreamIMAA
$LN1@StreamIMAA:

; 81   : 
; 82   : 	return(StreamImaM16(Stream->ImaInfo,dest,dlen));

	mov	edx, DWORD PTR _dlen$[ebp]
	push	edx
	mov	eax, DWORD PTR _dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Stream$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StreamImaM16@CSoundMgr@@AAEJPAUIMA_STREAM@@PADJ@Z ; CSoundMgr::StreamImaM16
$LN9@StreamIMAA:

; 83   : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?StreamIMAADPCM@CSoundMgr@@QAEJPAVSoundStream@@PADJ@Z ENDP ; CSoundMgr::StreamIMAADPCM
_TEXT	ENDS
END
