; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\SIM\Helo\Helimm.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?A1@@3MA					; A1
PUBLIC	?A2@@3MA					; A2
PUBLIC	?B1@@3MA					; B1
PUBLIC	?B2@@3MA					; B2
PUBLIC	?gModelData@@3PAU_HELI_MODEL_DATA@@A		; gModelData
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B ; std::ios_base::failure::_Stream_err
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B
CONST	SEGMENT
?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B DD 01H ; std::ios_base::failure::_Stream_err
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
_DATA	SEGMENT
?A1@@3MA DD	03fc00000r			; 1.5	; A1
?A2@@3MA DD	03f000000r			; 0.5	; A2
?B1@@3MA DD	0bf000000r			; -0.5	; B1
?B2@@3MA DD	03f000000r			; 0.5	; B2
?gModelData@@3PAU_HELI_MODEL_DATA@@A DD 00H		; gModelData
	DD	00H
	DD	040800000r			; 4
	DD	04304b333r			; 132.7
	DD	0421a0000r			; 38.5
	DD	045a8c800r			; 5401
	DD	044c6c000r			; 1590
	DD	045d34000r			; 6760
	DD	045c83800r			; 6407
	DD	044480000r			; 800
	DD	043046666r			; 132.4
	DD	04218cccdr			; 38.2
	DD	0c12ccccdr			; -10.8
	DD	0c3270000r			; -167
	DD	0c2aa0000r			; -85
	DD	043046666r			; 132.4
	DD	042c46666r			; 98.2
	DD	03de147aer			; 0.11
	DD	03f000000r			; 0.5
	DD	043540000r			; 212
	DD	041900000r			; 18
	DD	040b66666r			; 5.7
	DD	043c08000r			; 385
	DD	03c23d70ar			; 0.01
	DD	040800000r			; 4
	DD	03f8ccccdr			; 1.1
	DD	0bdd70a3dr			; -0.105
	DD	000000000r			; 0
	DD	043c38000r			; 391
	DD	0428c0000r			; 70
	DD	040466666r			; 3.1
	DD	040a00000r			; 5
	DD	045020000r			; 2080
	DD	000000000r			; 0
	DD	03e09374cr			; 0.134
	DD	040000000r			; 2
	DD	03f19999ar			; 0.6
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	043a50000r			; 330
	DD	042580000r			; 54
	DD	000000000r			; 0
	DD	0c2080000r			; -34
	DD	0c1b00000r			; -22
	DD	03f800000r			; 1
	DD	043be0000r			; 380
	DD	042a00000r			; 80
	DD	000000000r			; 0
	DD	0c23c0000r			; -47
	DD	0c1880000r			; -17
	DD	0bff33333r			; -1.9
	DD	041400000r			; 12
	DD	0be4ccccdr			; -0.2
	DD	040d00000r			; 6.5
	DD	000000000r			; 0
	DD	041200000r			; 10
	DD	000000000r			; 0
	DD	041900000r			; 18
	DD	01H
	DD	00H
	DD	040800000r			; 4
	DD	043440000r			; 196
	DD	042960000r			; 75
	DD	0460ca000r			; 9000
	DD	045221000r			; 2593
	DD	0465fc000r			; 14320
	DD	04640a800r			; 12330
	DD	000000000r			; 0
	DD	043480000r			; 200
	DD	042820000r			; 65
	DD	0c1f00000r			; -30
	DD	0c3898000r			; -275
	DD	0c2240000r			; -41
	DD	043480000r			; 200
	DD	043190000r			; 153
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	044acc000r			; 1382
	DD	041b00000r			; 22
	DD	040c00000r			; 6
	DD	043a20000r			; 324
	DD	03c23d70ar			; 0.01
	DD	040000000r			; 2
	DD	040100000r			; 2.25
	DD	0be333333r			; -0.175
	DD	000000000r			; 0
	DD	044026000r			; 521.5
	DD	042ee0000r			; 119
	DD	040880000r			; 4.25
	DD	040c00000r			; 6
	DD	044cf8000r			; 1660
	DD	000000000r			; 0
	DD	03dd70a3dr			; 0.105
	DD	040000000r			; 2
	DD	03f000000r			; 0.5
	DD	043480000r			; 200
	DD	042820000r			; 65
	DD	0c21c0000r			; -39
	DD	0c3210000r			; -161
	DD	0c2820000r			; -65
	DD	0412c0000r			; 10.75
	DD	043c80000r			; 400
	DD	042820000r			; 65
	DD	000000000r			; 0
	DD	0c2a00000r			; -80
	DD	0c2000000r			; -32
	DD	03f800000r			; 1
	DD	043f50000r			; 490
	DD	042a00000r			; 80
	DD	000000000r			; 0
	DD	0c2780000r			; -62
	DD	0c2480000r			; -50
	DD	0be99999ar			; -0.3
	DD	041200000r			; 10
	DD	0be99999ar			; -0.3
	DD	041200000r			; 10
	DD	000000000r			; 0
	DD	041600000r			; 14
	DD	000000000r			; 0
	DD	041700000r			; 15
	DD	02H
	DD	00H
	DD	040800000r			; 4
	DD	042af3333r			; 87.6
	DD	042840000r			; 66
	DD	045098000r			; 2200
	DD	043838000r			; 263
	DD	04489a000r			; 1101
	DD	0447a0000r			; 1000
	DD	043480000r			; 200
	DD	042af999ar			; 87.8
	DD	042846666r			; 66.2
	DD	0c0b9999ar			; -5.8
	DD	0c2c80000r			; -100
	DD	0c2340000r			; -45
	DD	042af3333r			; 87.6
	DD	042b40000r			; 90
	DD	000000000r			; 0
	DD	03ed70a3dr			; 0.42
	DD	043160000r			; 150
	DD	041580000r			; 13.5
	DD	040c00000r			; 6
	DD	043f08000r			; 481
	DD	03c23d70ar			; 0.01
	DD	040a00000r			; 5
	DD	03f0f5c29r			; 0.56
	DD	0be20c49cr			; -0.157
	DD	000000000r			; 0
	DD	04387999ar			; 271.2
	DD	042840000r			; 66
	DD	040133333r			; 2.3
	DD	040800000r			; 4
	DD	04536c000r			; 2924
	DD	000000000r			; 0
	DD	03df3b646r			; 0.119
	DD	040000000r			; 2
	DD	03ee147aer			; 0.44
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	0438b0000r			; 278
	DD	042e80000r			; 116
	DD	000000000r			; 0
	DD	0c1a00000r			; -20
	DD	0c1400000r			; -12
	DD	03f800000r			; 1
	DD	043848000r			; 265
	DD	0428c0000r			; 70
	DD	000000000r			; 0
	DD	0c2040000r			; -33
	DD	0c1200000r			; -10
	DD	000000000r			; 0
	DD	041200000r			; 10
	DD	0bf000000r			; -0.5
	DD	040f00000r			; 7.5
	DD	000000000r			; 0
	DD	04134cccdr			; 11.3
	DD	000000000r			; 0
	DD	041700000r			; 15
	DD	03H
	DD	00H
	DD	041000000r			; 8
	DD	042af3333r			; 87.6
	DD	042840000r			; 66
	DD	045098000r			; 2200
	DD	043838000r			; 263
	DD	04489a000r			; 1101
	DD	0447a0000r			; 1000
	DD	043480000r			; 200
	DD	042af3333r			; 87.6
	DD	042840000r			; 66
	DD	0c0b9999ar			; -5.8
	DD	0c2c80000r			; -100
	DD	0c2340000r			; -45
	DD	042af3333r			; 87.6
	DD	042b40000r			; 90
	DD	000000000r			; 0
	DD	03ed70a3dr			; 0.42
	DD	043160000r			; 150
	DD	041580000r			; 13.5
	DD	040c00000r			; 6
	DD	043f08000r			; 481
	DD	03c23d70ar			; 0.01
	DD	040a00000r			; 5
	DD	03f0f5c29r			; 0.56
	DD	0be20c49cr			; -0.157
	DD	000000000r			; 0
	DD	04387999ar			; 271.2
	DD	042840000r			; 66
	DD	040133333r			; 2.3
	DD	040400000r			; 3
	DD	04536c000r			; 2924
	DD	000000000r			; 0
	DD	03df3b646r			; 0.119
	DD	040000000r			; 2
	DD	03ee147aer			; 0.44
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	0438b0000r			; 278
	DD	042e80000r			; 116
	DD	000000000r			; 0
	DD	0c1a00000r			; -20
	DD	0c1400000r			; -12
	DD	03f800000r			; 1
	DD	043848000r			; 265
	DD	042840000r			; 66
	DD	000000000r			; 0
	DD	0c2040000r			; -33
	DD	0c2480000r			; -50
	DD	000000000r			; 0
	DD	041000000r			; 8
	DD	000000000r			; 0
	DD	041840000r			; 16.5
	DD	000000000r			; 0
	DD	0418a6666r			; 17.3
	DD	000000000r			; 0
	DD	041200000r			; 10
	DD	04H
	DD	00H
	DD	041000000r			; 8
	DD	042af3333r			; 87.6
	DD	042840000r			; 66
	DD	045098000r			; 2200
	DD	043838000r			; 263
	DD	04489a000r			; 1101
	DD	0447a0000r			; 1000
	DD	043480000r			; 200
	DD	042af3333r			; 87.6
	DD	042840000r			; 66
	DD	0c0b9999ar			; -5.8
	DD	0c2c80000r			; -100
	DD	0c2340000r			; -45
	DD	042af3333r			; 87.6
	DD	042b40000r			; 90
	DD	000000000r			; 0
	DD	03ed70a3dr			; 0.42
	DD	043160000r			; 150
	DD	041580000r			; 13.5
	DD	040c00000r			; 6
	DD	043f08000r			; 481
	DD	03c23d70ar			; 0.01
	DD	040a00000r			; 5
	DD	03f0f5c29r			; 0.56
	DD	0be20c49cr			; -0.157
	DD	000000000r			; 0
	DD	04387999ar			; 271.2
	DD	042840000r			; 66
	DD	040133333r			; 2.3
	DD	040400000r			; 3
	DD	04536c000r			; 2924
	DD	000000000r			; 0
	DD	03df3b646r			; 0.119
	DD	040000000r			; 2
	DD	03ee147aer			; 0.44
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	0438b0000r			; 278
	DD	042e80000r			; 116
	DD	000000000r			; 0
	DD	0c1a00000r			; -20
	DD	0c1400000r			; -12
	DD	03f800000r			; 1
	DD	043848000r			; 265
	DD	042840000r			; 66
	DD	000000000r			; 0
	DD	0c2040000r			; -33
	DD	0c2480000r			; -50
	DD	000000000r			; 0
	DD	041000000r			; 8
	DD	000000000r			; 0
	DD	041840000r			; 16.5
	DD	000000000r			; 0
	DD	0418a6666r			; 17.3
	DD	000000000r			; 0
	DD	041200000r			; 10
_DATA	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
PUBLIC	_fabsf
PUBLIC	_asinf
PUBLIC	_cosf
PUBLIC	_tanf
PUBLIC	?asin@@YAMM@Z					; asin
PUBLIC	?cos@@YAMM@Z					; cos
PUBLIC	?fabs@@YAMM@Z					; fabs
PUBLIC	?pow@@YAMMH@Z					; pow
PUBLIC	??$_Pow_int@M@@YAMMH@Z				; _Pow_int<float>
PUBLIC	?tan@@YAMM@Z					; tan
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	??0id@locale@std@@QAE@I@Z			; std::locale::id::id
PUBLIC	?generic_category@std@@YAABVerror_category@1@XZ	; std::generic_category
PUBLIC	?system_category@std@@YAABVerror_category@1@XZ	; std::system_category
PUBLIC	??0error_category@std@@QAE@XZ			; std::error_category::error_category
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??8error_category@std@@QBE_NABV01@@Z		; std::error_category::operator==
PUBLIC	??_Gerror_category@std@@UAEPAXI@Z		; std::error_category::`scalar deleting destructor'
PUBLIC	?value@error_code@std@@QBEHXZ			; std::error_code::value
PUBLIC	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
PUBLIC	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?value@error_condition@std@@QBEHXZ		; std::error_condition::value
PUBLIC	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
PUBLIC	??8error_condition@std@@QBE_NABV01@@Z		; std::error_condition::operator==
PUBLIC	??0_Generic_error_category@std@@QAE@XZ		; std::_Generic_error_category::_Generic_error_category
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	??1_Generic_error_category@std@@UAE@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	??0_Iostream_error_category@std@@QAE@XZ		; std::_Iostream_error_category::_Iostream_error_category
PUBLIC	?name@_Iostream_error_category@std@@UBEPBDXZ	; std::_Iostream_error_category::name
PUBLIC	?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	??1_Iostream_error_category@std@@UAE@XZ		; std::_Iostream_error_category::~_Iostream_error_category
PUBLIC	??_G_Iostream_error_category@std@@UAEPAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	??0_System_error_category@std@@QAE@XZ		; std::_System_error_category::_System_error_category
PUBLIC	?name@_System_error_category@std@@UBEPBDXZ	; std::_System_error_category::name
PUBLIC	?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message
PUBLIC	?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition
PUBLIC	??1_System_error_category@std@@UAE@XZ		; std::_System_error_category::~_System_error_category
PUBLIC	??_G_System_error_category@std@@UAEPAXI@Z	; std::_System_error_category::`scalar deleting destructor'
PUBLIC	?mlSinCos@@YAXPAUmlTrig@@M@Z			; mlSinCos
PUBLIC	?checked_atan2@@YANNN@Z				; checked_atan2
PUBLIC	??0HeliMMClass@@QAE@PAVSimBaseClass@@H@Z	; HeliMMClass::HeliMMClass
PUBLIC	??1HeliMMClass@@QAE@XZ				; HeliMMClass::~HeliMMClass
PUBLIC	?Setup@HeliMMClass@@QAEXXZ			; HeliMMClass::Setup
PUBLIC	?TipPlanePath@HeliMMClass@@QAEXXZ		; HeliMMClass::TipPlanePath
PUBLIC	?MainRotor@HeliMMClass@@QAEXXZ			; HeliMMClass::MainRotor
PUBLIC	?Fuselage@HeliMMClass@@QAEXXZ			; HeliMMClass::Fuselage
PUBLIC	?TailRotor@HeliMMClass@@QAEXXZ			; HeliMMClass::TailRotor
PUBLIC	?HorizTail@HeliMMClass@@QAEXXZ			; HeliMMClass::HorizTail
PUBLIC	?VertTail@HeliMMClass@@QAEXXZ			; HeliMMClass::VertTail
PUBLIC	?Wing@HeliMMClass@@QAEXXZ			; HeliMMClass::Wing
PUBLIC	?ForceCalc@HeliMMClass@@QAEXXZ			; HeliMMClass::ForceCalc
PUBLIC	?ResetForceVars@HeliMMClass@@QAEXXZ		; HeliMMClass::ResetForceVars
PUBLIC	?PreCalc@HeliMMClass@@QAEXXZ			; HeliMMClass::PreCalc
PUBLIC	?Exec@HeliMMClass@@QAEXXZ			; HeliMMClass::Exec
PUBLIC	?Init@HeliMMClass@@QAEXMMM@Z			; HeliMMClass::Init
PUBLIC	?SetPlatformData@HeliMMClass@@QAEXXZ		; HeliMMClass::SetPlatformData
PUBLIC	?InitQuat@HeliMMClass@@QAEXXZ			; HeliMMClass::InitQuat
PUBLIC	?SimpleModel@HeliMMClass@@QAEXXZ		; HeliMMClass::SimpleModel
PUBLIC	?CalcBodyOrientation@HeliMMClass@@QAEXXZ	; HeliMMClass::CalcBodyOrientation
PUBLIC	?SetControls@HeliMMClass@@QAEXMMMM@Z		; HeliMMClass::SetControls
PUBLIC	?FABS@@YAMM@Z					; FABS
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??_7error_category@std@@6B@			; std::error_category::`vftable'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_C@_07DCLBNMLN@generic?$AA@			; `string'
PUBLIC	??_C@_0O@BFJCFAAK@unknown?5error?$AA@		; `string'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream?$AA@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	; `string'
PUBLIC	??_7_System_error_category@std@@6B@		; std::_System_error_category::`vftable'
PUBLIC	??_C@_06FHFOAHML@system?$AA@			; `string'
PUBLIC	?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
PUBLIC	?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
PUBLIC	?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
PUBLIC	?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
PUBLIC	?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	?id@?$numpunct@_W@std@@2V0locale@2@A		; std::numpunct<wchar_t>::id
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_R4error_category@std@@6B@			; std::error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error_category@std@@6B@		; std::_System_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_System_error_category@std@@@8		; std::_System_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_System_error_category@std@@8		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error_category@std@@8		; std::_System_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error_category@std@@8	; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@3b1bc5c4
PUBLIC	__real@3b83126f
PUBLIC	__real@3c8efa34
PUBLIC	__real@3c8efa35
PUBLIC	__real@3d4ccccd
PUBLIC	__real@3e19999a
PUBLIC	__real@3e4ccccd
PUBLIC	__real@3e860a91
PUBLIC	__real@3e99999a
PUBLIC	__real@3f000000
PUBLIC	__real@3f07ae14
PUBLIC	__real@3f17ac60
PUBLIC	__real@3f2aaaab
PUBLIC	__real@3f333333
PUBLIC	__real@3f400000
PUBLIC	__real@3f4ccccd
PUBLIC	__real@3f59999a
PUBLIC	__real@3f733333
PUBLIC	__real@3f800000
PUBLIC	__real@3fb2b8c1
PUBLIC	__real@3fc00000
PUBLIC	__real@3ff921fb54442d18
PUBLIC	__real@40000000
PUBLIC	__real@40060a91
PUBLIC	__real@400921fb54442d18
PUBLIC	__real@4020000000000000
PUBLIC	__real@402aaaab
PUBLIC	__real@40490fdb
PUBLIC	__real@40800000
PUBLIC	__real@40933333
PUBLIC	__real@40a00000
PUBLIC	__real@40c00000
PUBLIC	__real@40c90fd9
PUBLIC	__real@41000000
PUBLIC	__real@41400000
PUBLIC	__real@41800000
PUBLIC	__real@4200b53f
PUBLIC	__real@42652ee1
PUBLIC	__real@42700000
PUBLIC	__real@42b40000
PUBLIC	__real@42f00000
PUBLIC	__real@43020000
PUBLIC	__real@4397e7be
PUBLIC	__real@8000000000000000
PUBLIC	__real@bd4ccccd
PUBLIC	__real@be19999a
PUBLIC	__real@be860a91
PUBLIC	__real@be99999a
PUBLIC	__real@bfb2b8c1
PUBLIC	__real@bff921fb54442d18
PUBLIC	__real@c1200000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	_asin:PROC
EXTRN	_atan:PROC
EXTRN	_cos:PROC
EXTRN	_fabs:PROC
EXTRN	_tan:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_strlen:PROC
EXTRN	_memmove:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	??_Eerror_category@std@@UAEPAXI@Z:PROC		; std::error_category::`vector deleting destructor'
EXTRN	?_Syserror_map@std@@YAPBDH@Z:PROC		; std::_Syserror_map
EXTRN	?_Winerror_map@std@@YAPBDH@Z:PROC		; std::_Winerror_map
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_E_System_error_category@std@@UAEPAXI@Z:PROC	; std::_System_error_category::`vector deleting destructor'
EXTRN	?FITust@SIMLIB_MATH_CLASS@@QAEMMMQAM@Z:PROC	; SIMLIB_MATH_CLASS::FITust
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?SimLibMajorFrameTime@@3MA:DWORD		; SimLibMajorFrameTime
EXTRN	?Math@@3VSIMLIB_MATH_CLASS@@A:BYTE		; Math
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
_allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
_BSS	SEGMENT
?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Generic_object
_BSS	ENDS
;	COMDAT ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
_BSS	SEGMENT
?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Iostream_object
_BSS	ENDS
;	COMDAT ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
_BSS	SEGMENT
?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_System_object
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@_W@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@_W@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<wchar_t>::id
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@c1200000
CONST	SEGMENT
__real@c1200000 DD 0c1200000r			; -10
CONST	ENDS
;	COMDAT __real@bff921fb54442d18
CONST	SEGMENT
__real@bff921fb54442d18 DQ 0bff921fb54442d18r	; -1.5708
CONST	ENDS
;	COMDAT __real@bfb2b8c1
CONST	SEGMENT
__real@bfb2b8c1 DD 0bfb2b8c1r			; -1.39626
CONST	ENDS
;	COMDAT __real@be99999a
CONST	SEGMENT
__real@be99999a DD 0be99999ar			; -0.3
CONST	ENDS
;	COMDAT __real@be860a91
CONST	SEGMENT
__real@be860a91 DD 0be860a91r			; -0.261799
CONST	ENDS
;	COMDAT __real@be19999a
CONST	SEGMENT
__real@be19999a DD 0be19999ar			; -0.15
CONST	ENDS
;	COMDAT __real@bd4ccccd
CONST	SEGMENT
__real@bd4ccccd DD 0bd4ccccdr			; -0.05
CONST	ENDS
;	COMDAT __real@8000000000000000
CONST	SEGMENT
__real@8000000000000000 DQ 08000000000000000r	; -0
CONST	ENDS
;	COMDAT __real@4397e7be
CONST	SEGMENT
__real@4397e7be DD 04397e7ber			; 303.81
CONST	ENDS
;	COMDAT __real@43020000
CONST	SEGMENT
__real@43020000 DD 043020000r			; 130
CONST	ENDS
;	COMDAT __real@42f00000
CONST	SEGMENT
__real@42f00000 DD 042f00000r			; 120
CONST	ENDS
;	COMDAT __real@42b40000
CONST	SEGMENT
__real@42b40000 DD 042b40000r			; 90
CONST	ENDS
;	COMDAT __real@42700000
CONST	SEGMENT
__real@42700000 DD 042700000r			; 60
CONST	ENDS
;	COMDAT __real@42652ee1
CONST	SEGMENT
__real@42652ee1 DD 042652ee1r			; 57.2958
CONST	ENDS
;	COMDAT __real@4200b53f
CONST	SEGMENT
__real@4200b53f DD 04200b53fr			; 32.177
CONST	ENDS
;	COMDAT __real@41800000
CONST	SEGMENT
__real@41800000 DD 041800000r			; 16
CONST	ENDS
;	COMDAT __real@41400000
CONST	SEGMENT
__real@41400000 DD 041400000r			; 12
CONST	ENDS
;	COMDAT __real@41000000
CONST	SEGMENT
__real@41000000 DD 041000000r			; 8
CONST	ENDS
;	COMDAT __real@40c90fd9
CONST	SEGMENT
__real@40c90fd9 DD 040c90fd9r			; 6.28318
CONST	ENDS
;	COMDAT __real@40c00000
CONST	SEGMENT
__real@40c00000 DD 040c00000r			; 6
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@40933333
CONST	SEGMENT
__real@40933333 DD 040933333r			; 4.6
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@40490fdb
CONST	SEGMENT
__real@40490fdb DD 040490fdbr			; 3.14159
CONST	ENDS
;	COMDAT __real@402aaaab
CONST	SEGMENT
__real@402aaaab DD 0402aaaabr			; 2.66667
CONST	ENDS
;	COMDAT __real@4020000000000000
CONST	SEGMENT
__real@4020000000000000 DQ 04020000000000000r	; 8
CONST	ENDS
;	COMDAT __real@400921fb54442d18
CONST	SEGMENT
__real@400921fb54442d18 DQ 0400921fb54442d18r	; 3.14159
CONST	ENDS
;	COMDAT __real@40060a91
CONST	SEGMENT
__real@40060a91 DD 040060a91r			; 2.09439
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ff921fb54442d18
CONST	SEGMENT
__real@3ff921fb54442d18 DQ 03ff921fb54442d18r	; 1.5708
CONST	ENDS
;	COMDAT __real@3fc00000
CONST	SEGMENT
__real@3fc00000 DD 03fc00000r			; 1.5
CONST	ENDS
;	COMDAT __real@3fb2b8c1
CONST	SEGMENT
__real@3fb2b8c1 DD 03fb2b8c1r			; 1.39626
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f733333
CONST	SEGMENT
__real@3f733333 DD 03f733333r			; 0.95
CONST	ENDS
;	COMDAT __real@3f59999a
CONST	SEGMENT
__real@3f59999a DD 03f59999ar			; 0.85
CONST	ENDS
;	COMDAT __real@3f4ccccd
CONST	SEGMENT
__real@3f4ccccd DD 03f4ccccdr			; 0.8
CONST	ENDS
;	COMDAT __real@3f400000
CONST	SEGMENT
__real@3f400000 DD 03f400000r			; 0.75
CONST	ENDS
;	COMDAT __real@3f333333
CONST	SEGMENT
__real@3f333333 DD 03f333333r			; 0.7
CONST	ENDS
;	COMDAT __real@3f2aaaab
CONST	SEGMENT
__real@3f2aaaab DD 03f2aaaabr			; 0.666667
CONST	ENDS
;	COMDAT __real@3f17ac60
CONST	SEGMENT
__real@3f17ac60 DD 03f17ac60r			; 0.592474
CONST	ENDS
;	COMDAT __real@3f07ae14
CONST	SEGMENT
__real@3f07ae14 DD 03f07ae14r			; 0.53
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3e99999a
CONST	SEGMENT
__real@3e99999a DD 03e99999ar			; 0.3
CONST	ENDS
;	COMDAT __real@3e860a91
CONST	SEGMENT
__real@3e860a91 DD 03e860a91r			; 0.261799
CONST	ENDS
;	COMDAT __real@3e4ccccd
CONST	SEGMENT
__real@3e4ccccd DD 03e4ccccdr			; 0.2
CONST	ENDS
;	COMDAT __real@3e19999a
CONST	SEGMENT
__real@3e19999a DD 03e19999ar			; 0.15
CONST	ENDS
;	COMDAT __real@3d4ccccd
CONST	SEGMENT
__real@3d4ccccd DD 03d4ccccdr			; 0.05
CONST	ENDS
;	COMDAT __real@3c8efa35
CONST	SEGMENT
__real@3c8efa35 DD 03c8efa35r			; 0.0174533
CONST	ENDS
;	COMDAT __real@3c8efa34
CONST	SEGMENT
__real@3c8efa34 DD 03c8efa34r			; 0.0174533
CONST	ENDS
;	COMDAT __real@3b83126f
CONST	SEGMENT
__real@3b83126f DD 03b83126fr			; 0.004
CONST	ENDS
;	COMDAT __real@3b1bc5c4
CONST	SEGMENT
__real@3b1bc5c4 DD 03b1bc5c4r			; 0.0023769
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error_category@std@@8 DD FLAT:??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error_category@std@@8
rdata$r	SEGMENT
??_R2_System_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error_category@std@@8
rdata$r	SEGMENT
??_R3_System_error_category@std@@8 DD 00H		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_System_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_System_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_System_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_System_error_category@std@@6B@ DD 00H		; std::_System_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error_category@std@@@8
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD FLAT:??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 00H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category@std@@@8
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
_DATA	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4error_category@std@@6B@
rdata$r	SEGMENT
??_R4error_category@std@@6B@ DD 00H			; std::error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVerror_category@std@@@8
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system?$AA@
CONST	SEGMENT
??_C@_06FHFOAHML@system?$AA@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_System_error_category@std@@6B@
CONST	SEGMENT
??_7_System_error_category@std@@6B@ DD FLAT:??_R4_System_error_category@std@@6B@ ; std::_System_error_category::`vftable'
	DD	FLAT:??_E_System_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_System_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ DB 'iostream stream error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream?$AA@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream?$AA@ DB 'iostream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DD FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DD	FLAT:??_E_Iostream_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
CONST	SEGMENT
??_C@_0O@BFJCFAAK@unknown?5error?$AA@ DB 'unknown error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic?$AA@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic?$AA@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7error_category@std@@6B@
CONST	SEGMENT
??_7error_category@std@@6B@ DD FLAT:??_R4error_category@std@@6B@ ; std::error_category::`vftable'
	DD	FLAT:??_Eerror_category@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
__ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Generic_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Iostream_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_System_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@D@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<char>::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@_W@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<wchar_t>::id$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 621  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();
; 624  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
_this$ = -24						; size = 4
tv73 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR __V0$[ebp]
	push	ecx
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<wchar_t>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@_W@std@@2V0locale@2@A ; std::numpunct<wchar_t>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<wchar_t>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<char>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<char>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 755  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp

; 756  : 		{	// destroy object at _Ptr
; 757  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>

; 758  : 		}

	pop	ebp
	ret	0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
	pop	ebp
	ret	0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	ebp
	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??1_System_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_System_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??0_System_error_category@std@@QAE@XZ	; std::_System_error_category::_System_error_category
	push	OFFSET ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_System_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??1_Iostream_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??0_Iostream_error_category@std@@QAE@XZ	; std::_Iostream_error_category::_Iostream_error_category
	push	OFFSET ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??1_Generic_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	push	OFFSET ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], -1
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 85   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 89   : 	}

	pop	ebp
	ret	0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 907  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
	add	esp, 8

; 910  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
	add	esp, 12					; 0000000cH
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\helo\helimm.cpp
;	COMDAT ?FABS@@YAMM@Z
_TEXT	SEGMENT
tv67 = -4						; size = 4
_a$ = 8							; size = 4
?FABS@@YAMM@Z PROC					; FABS, COMDAT

; 985  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 986  : 	return (( a >= 0.0 ) ? a : -a);

	cvtss2sd xmm0, DWORD PTR _a$[ebp]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jb	SHORT $LN3@FABS
	movss	xmm0, DWORD PTR _a$[ebp]
	movss	DWORD PTR tv67[ebp], xmm0
	jmp	SHORT $LN4@FABS
$LN3@FABS:
	movss	xmm0, DWORD PTR _a$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv67[ebp], xmm0
$LN4@FABS:
	fld	DWORD PTR tv67[ebp]

; 987  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FABS@@YAMM@Z ENDP					; FABS
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\helo\helimm.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pstick$ = 8						; size = 4
_rstick$ = 12						; size = 4
_throttle$ = 16						; size = 4
_pedals$ = 20						; size = 4
?SetControls@HeliMMClass@@QAEXMMMM@Z PROC		; HeliMMClass::SetControls
; _this$ = ecx

; 1085 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1086 : 
; 1087 : 	ctlcpitch = throttle;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _throttle$[ebp]
	movss	DWORD PTR [eax+1068], xmm0

; 1088 : 
; 1089 : 	// for pedals & stick, put in a centered dead zone
; 1090 : 	// when human controlled
; 1091 : 	if ( !isDigital )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1084], 0
	jne	$LN14@SetControl

; 1092 : 	{
; 1093 : 		if ( pedals > 0.30F  )

	movss	xmm0, DWORD PTR _pedals$[ebp]
	comiss	xmm0, DWORD PTR __real@3e99999a
	jbe	SHORT $LN13@SetControl

; 1094 : 			ctltpitch = (pedals-0.30F)/0.70F  ;

	movss	xmm0, DWORD PTR _pedals$[ebp]
	subss	xmm0, DWORD PTR __real@3e99999a
	divss	xmm0, DWORD PTR __real@3f333333
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+1072], xmm0
	jmp	SHORT $LN10@SetControl
$LN13@SetControl:

; 1095 : 		else if ( pedals < -0.30F )

	movss	xmm0, DWORD PTR __real@be99999a
	comiss	xmm0, DWORD PTR _pedals$[ebp]
	jbe	SHORT $LN11@SetControl

; 1096 : 			ctltpitch = (pedals+0.30F)/0.70F;

	movss	xmm0, DWORD PTR _pedals$[ebp]
	addss	xmm0, DWORD PTR __real@3e99999a
	divss	xmm0, DWORD PTR __real@3f333333
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+1072], xmm0

; 1097 : 		else 

	jmp	SHORT $LN10@SetControl
$LN11@SetControl:

; 1098 : 			ctltpitch = 0.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+1072], xmm0
$LN10@SetControl:

; 1099 : 	
; 1100 : 		if ( pstick > 0.05F )

	movss	xmm0, DWORD PTR _pstick$[ebp]
	comiss	xmm0, DWORD PTR __real@3d4ccccd
	jbe	SHORT $LN9@SetControl

; 1101 : 			ctlroll = -(pstick-0.05F)/0.95F;

	movss	xmm0, DWORD PTR _pstick$[ebp]
	subss	xmm0, DWORD PTR __real@3d4ccccd
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	divss	xmm0, DWORD PTR __real@3f733333
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+1060], xmm0
	jmp	SHORT $LN6@SetControl
$LN9@SetControl:

; 1102 : 		else if ( pstick < -0.05F )

	movss	xmm0, DWORD PTR __real@bd4ccccd
	comiss	xmm0, DWORD PTR _pstick$[ebp]
	jbe	SHORT $LN7@SetControl

; 1103 : 			ctlroll = -(pstick+0.05F)/0.95F;

	movss	xmm0, DWORD PTR _pstick$[ebp]
	addss	xmm0, DWORD PTR __real@3d4ccccd
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	divss	xmm0, DWORD PTR __real@3f733333
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+1060], xmm0

; 1104 : 		else 

	jmp	SHORT $LN6@SetControl
$LN7@SetControl:

; 1105 : 			ctlroll = 0.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+1060], xmm0
$LN6@SetControl:

; 1106 : 	
; 1107 : 		if ( rstick > 0.15F )

	movss	xmm0, DWORD PTR _rstick$[ebp]
	comiss	xmm0, DWORD PTR __real@3e19999a
	jbe	SHORT $LN5@SetControl

; 1108 : 			ctlpitch = (rstick-0.15F)/0.85F;

	movss	xmm0, DWORD PTR _rstick$[ebp]
	subss	xmm0, DWORD PTR __real@3e19999a
	divss	xmm0, DWORD PTR __real@3f59999a
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+1064], xmm0
	jmp	SHORT $LN2@SetControl
$LN5@SetControl:

; 1109 : 		else if ( rstick < -0.15F )

	movss	xmm0, DWORD PTR __real@be19999a
	comiss	xmm0, DWORD PTR _rstick$[ebp]
	jbe	SHORT $LN3@SetControl

; 1110 : 			ctlpitch = (rstick+0.15F)/0.85F;

	movss	xmm0, DWORD PTR _rstick$[ebp]
	addss	xmm0, DWORD PTR __real@3e19999a
	divss	xmm0, DWORD PTR __real@3f59999a
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+1064], xmm0

; 1111 : 		else 

	jmp	SHORT $LN2@SetControl
$LN3@SetControl:

; 1112 : 			ctlpitch = 0.0;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+1064], xmm0
$LN2@SetControl:

; 1113 : 	}
; 1114 : 	else

	jmp	SHORT $LN1@SetControl
$LN14@SetControl:

; 1115 : 	{
; 1116 : 		ctltpitch = pedals;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _pedals$[ebp]
	movss	DWORD PTR [edx+1072], xmm0

; 1117 : 		ctlroll = -pstick;

	movss	xmm0, DWORD PTR _pstick$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+1060], xmm0

; 1118 : 		ctlpitch = rstick;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _rstick$[ebp]
	movss	DWORD PTR [ecx+1064], xmm0
$LN1@SetControl:

; 1119 : 	}
; 1120 : 
; 1121 : 	// get math model control inputs and convert to radians
; 1122 : 	cyc_roll = md->td.cyc_roll_center *
; 1123 : 							(PI/180.0F) + ctlroll *
; 1124 : 							md->td.cyc_roll_max * (PI/180.0F);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	movss	xmm0, DWORD PTR [eax+216]
	mulss	xmm0, DWORD PTR __real@3c8efa35
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+1060]
	mulss	xmm1, DWORD PTR [edx+220]
	mulss	xmm1, DWORD PTR __real@3c8efa35
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+476], xmm0

; 1125 : 	cyc_pitch = md->td.cyc_pitch_center *
; 1126 : 							(PI/180.0F) + ctlpitch *
; 1127 : 							md->td.cyc_pitch_max * (PI/180.0F);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	movss	xmm0, DWORD PTR [eax+224]
	mulss	xmm0, DWORD PTR __real@3c8efa35
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+1064]
	mulss	xmm1, DWORD PTR [edx+228]
	mulss	xmm1, DWORD PTR __real@3c8efa35
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+472], xmm0

; 1128 : 	coll_pitch = md->td.coll_pitch_center *
; 1129 : 							(PI/180.0F) + ctlcpitch *
; 1130 : 							md->td.coll_pitch_max * (PI/180.0F);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	movss	xmm0, DWORD PTR [eax+232]
	mulss	xmm0, DWORD PTR __real@3c8efa35
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+1068]
	mulss	xmm1, DWORD PTR [edx+236]
	mulss	xmm1, DWORD PTR __real@3c8efa35
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+468], xmm0

; 1131 : 	tr_pitch = md->td.tr_pitch_center *
; 1132 : 							(PI/180.0F) + ctltpitch *
; 1133 : 							md->td.tr_pitch_max * (PI/180.0F);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	movss	xmm0, DWORD PTR [eax+240]
	mulss	xmm0, DWORD PTR __real@3c8efa35
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+1072]
	mulss	xmm1, DWORD PTR [edx+244]
	mulss	xmm1, DWORD PTR __real@3c8efa35
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+480], xmm0

; 1134 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?SetControls@HeliMMClass@@QAEXMMMM@Z ENDP		; HeliMMClass::SetControls
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\helo\helimm.cpp
_TEXT	SEGMENT
tv676 = -48						; size = 8
_e4dot$ = -40						; size = 4
_e3dot$ = -36						; size = 4
_e2dot$ = -32						; size = 4
_e1dot$ = -28						; size = 4
_e4temp$ = -24						; size = 4
_e3temp$ = -20						; size = 4
_e2temp$ = -16						; size = 4
_e1temp$ = -12						; size = 4
_enorm$ = -8						; size = 4
_this$ = -4						; size = 4
?CalcBodyOrientation@HeliMMClass@@QAEXXZ PROC		; HeliMMClass::CalcBodyOrientation
; _this$ = ecx

; 2160 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 2161 : 	float e1dot, e2dot, e3dot, e4dot;
; 2162 : 	float enorm;
; 2163 : 	float e1temp, e2temp, e3temp, e4temp;
; 2164 : 
; 2165 :    /*-----------------------------------*/
; 2166 :    /* quaternion differential equations */
; 2167 :    /*-----------------------------------*/
; 2168 :    e1dot = (-e4*VB.ax - e3*VB.ay - e2*VB.az)*0.5F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1056]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [ecx+304]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+1052]
	mulss	xmm1, DWORD PTR [eax+308]
	subss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+1048]
	mulss	xmm1, DWORD PTR [edx+312]
	subss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _e1dot$[ebp], xmm0

; 2169 :    e2dot = (-e3*VB.ax + e4*VB.ay + e1*VB.az)*0.5F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1052]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [ecx+304]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+1056]
	mulss	xmm1, DWORD PTR [eax+308]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+1044]
	mulss	xmm1, DWORD PTR [edx+312]
	addss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _e2dot$[ebp], xmm0

; 2170 :    e3dot = ( e2*VB.ax + e1*VB.ay - e4*VB.az)*0.5F;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1048]
	mulss	xmm0, DWORD PTR [ecx+304]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+1044]
	mulss	xmm1, DWORD PTR [eax+308]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+1056]
	mulss	xmm1, DWORD PTR [edx+312]
	subss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _e3dot$[ebp], xmm0

; 2171 :    e4dot = ( e1*VB.ax - e2*VB.ay + e3*VB.az)*0.5F;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1044]
	mulss	xmm0, DWORD PTR [ecx+304]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+1048]
	mulss	xmm1, DWORD PTR [eax+308]
	subss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+1052]
	mulss	xmm1, DWORD PTR [edx+312]
	addss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _e4dot$[ebp], xmm0

; 2172 : 
; 2173 :    /*-----------------------*/
; 2174 :    /* integrate quaternions */
; 2175 :    /*-----------------------*/
; 2176 :    e1temp = Math.FITust(e1dot,dT,olde1);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 828				; 0000033cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+4]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _e1dot$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?FITust@SIMLIB_MATH_CLASS@@QAEMMMQAM@Z	; SIMLIB_MATH_CLASS::FITust
	fstp	DWORD PTR _e1temp$[ebp]

; 2177 :    e2temp = Math.FITust(e2dot,dT,olde2);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 852				; 00000354H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _e2dot$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?FITust@SIMLIB_MATH_CLASS@@QAEMMMQAM@Z	; SIMLIB_MATH_CLASS::FITust
	fstp	DWORD PTR _e2temp$[ebp]

; 2178 :    e3temp = Math.FITust(e3dot,dT,olde3);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 876				; 0000036cH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+4]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _e3dot$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?FITust@SIMLIB_MATH_CLASS@@QAEMMMQAM@Z	; SIMLIB_MATH_CLASS::FITust
	fstp	DWORD PTR _e3temp$[ebp]

; 2179 :    e4temp = Math.FITust(e4dot,dT,olde4);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 900				; 00000384H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+4]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _e4dot$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?FITust@SIMLIB_MATH_CLASS@@QAEMMMQAM@Z	; SIMLIB_MATH_CLASS::FITust
	fstp	DWORD PTR _e4temp$[ebp]

; 2180 : 
; 2181 :    /*--------------------------*/
; 2182 :    /* quaternion normalization */
; 2183 :    /*--------------------------*/
; 2184 :    enorm = (float)sqrt(e1temp*e1temp + e2temp*e2temp +
; 2185 :                       e3temp*e3temp + e4temp*e4temp);

	movss	xmm0, DWORD PTR _e1temp$[ebp]
	mulss	xmm0, DWORD PTR _e1temp$[ebp]
	movss	xmm1, DWORD PTR _e2temp$[ebp]
	mulss	xmm1, DWORD PTR _e2temp$[ebp]
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR _e3temp$[ebp]
	mulss	xmm1, DWORD PTR _e3temp$[ebp]
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR _e4temp$[ebp]
	mulss	xmm1, DWORD PTR _e4temp$[ebp]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR _enorm$[ebp]

; 2186 :    e1    = e1temp/enorm;

	movss	xmm0, DWORD PTR _e1temp$[ebp]
	divss	xmm0, DWORD PTR _enorm$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+1044], xmm0

; 2187 :    e2    = e2temp/enorm;

	movss	xmm0, DWORD PTR _e2temp$[ebp]
	divss	xmm0, DWORD PTR _enorm$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+1048], xmm0

; 2188 :    e3    = e3temp/enorm;

	movss	xmm0, DWORD PTR _e3temp$[ebp]
	divss	xmm0, DWORD PTR _enorm$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+1052], xmm0

; 2189 :    e4    = e4temp/enorm;

	movss	xmm0, DWORD PTR _e4temp$[ebp]
	divss	xmm0, DWORD PTR _enorm$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+1056], xmm0

; 2190 : 
; 2191 :    /*------------------------------*/
; 2192 :    /* reset quaternion integrators */
; 2193 :    /*------------------------------*/
; 2194 :    olde1[0] = e1;

	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+1044]
	mov	DWORD PTR [ecx+eax+828], edx

; 2195 :    olde2[0] = e2;

	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+1048]
	mov	DWORD PTR [ecx+eax+852], edx

; 2196 :    olde3[0] = e3;

	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+1052]
	mov	DWORD PTR [ecx+eax+876], edx

; 2197 :    olde4[0] = e4;

	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+1056]
	mov	DWORD PTR [ecx+eax+900], edx

; 2198 : 
; 2199 :    /*-------------------*/
; 2200 :    /* direction cosines */
; 2201 :    /*-------------------*/
; 2202 :    platform->dmx[0][0] = e1*e1 - e2*e2 -
; 2203 :                      e3*e3 + e4*e4;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1044]
	mulss	xmm0, DWORD PTR [ecx+1044]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+1048]
	mulss	xmm1, DWORD PTR [eax+1048]
	subss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+1052]
	mulss	xmm1, DWORD PTR [edx+1052]
	subss	xmm0, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+1056]
	mulss	xmm1, DWORD PTR [ecx+1056]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	mov	ecx, 12					; 0000000cH
	imul	ecx, 0
	lea	edx, DWORD PTR [eax+ecx+296]
	mov	eax, 4
	imul	eax, 0
	movss	DWORD PTR [edx+eax], xmm0

; 2204 :    platform->dmx[0][1] = 2.0F*(e3*e4 + e1*e2);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1052]
	mulss	xmm0, DWORD PTR [edx+1056]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+1044]
	mulss	xmm1, DWORD PTR [ecx+1048]
	addss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@40000000
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	mov	ecx, 12					; 0000000cH
	imul	ecx, 0
	lea	edx, DWORD PTR [eax+ecx+296]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR [edx+eax], xmm0

; 2205 :    platform->dmx[0][2] = 2.0F*(e2*e4 - e1*e3);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1048]
	mulss	xmm0, DWORD PTR [edx+1056]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+1044]
	mulss	xmm1, DWORD PTR [ecx+1052]
	subss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@40000000
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	mov	ecx, 12					; 0000000cH
	imul	ecx, 0
	lea	edx, DWORD PTR [eax+ecx+296]
	mov	eax, 4
	shl	eax, 1
	movss	DWORD PTR [edx+eax], xmm0

; 2206 : 
; 2207 :    platform->dmx[1][0] = 2.0F*(e3*e4 - e1*e2);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1052]
	mulss	xmm0, DWORD PTR [edx+1056]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+1044]
	mulss	xmm1, DWORD PTR [ecx+1048]
	subss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@40000000
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	lea	edx, DWORD PTR [eax+ecx+296]
	mov	eax, 4
	imul	eax, 0
	movss	DWORD PTR [edx+eax], xmm0

; 2208 :    platform->dmx[1][1] = e1*e1 - e2*e2 +
; 2209 :                      e3*e3 - e4*e4;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1044]
	mulss	xmm0, DWORD PTR [edx+1044]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+1048]
	mulss	xmm1, DWORD PTR [ecx+1048]
	subss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+1052]
	mulss	xmm1, DWORD PTR [eax+1052]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+1056]
	mulss	xmm1, DWORD PTR [edx+1056]
	subss	xmm0, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	lea	eax, DWORD PTR [ecx+edx+296]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR [eax+ecx], xmm0

; 2210 :    platform->dmx[1][2] = 2.0F*(e2*e3 + e4*e1);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1048]
	mulss	xmm0, DWORD PTR [eax+1052]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+1056]
	mulss	xmm1, DWORD PTR [edx+1044]
	addss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@40000000
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	lea	eax, DWORD PTR [ecx+edx+296]
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR [eax+ecx], xmm0

; 2211 : 
; 2212 :    platform->dmx[2][0] = 2.0F*(e1*e3 + e2*e4);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1044]
	mulss	xmm0, DWORD PTR [eax+1052]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+1048]
	mulss	xmm1, DWORD PTR [edx+1056]
	addss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@40000000
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	mov	edx, 12					; 0000000cH
	shl	edx, 1
	lea	eax, DWORD PTR [ecx+edx+296]
	mov	ecx, 4
	imul	ecx, 0
	movss	DWORD PTR [eax+ecx], xmm0

; 2213 :    platform->dmx[2][1] = 2.0F*(e2*e3 - e1*e4);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1048]
	mulss	xmm0, DWORD PTR [eax+1052]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+1044]
	mulss	xmm1, DWORD PTR [edx+1056]
	subss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@40000000
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	mov	edx, 12					; 0000000cH
	shl	edx, 1
	lea	eax, DWORD PTR [ecx+edx+296]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR [eax+ecx], xmm0

; 2214 :    platform->dmx[2][2] = e1*e1 + e2*e2 -
; 2215 :                      e3*e3 - e4*e4;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1044]
	mulss	xmm0, DWORD PTR [eax+1044]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+1048]
	mulss	xmm1, DWORD PTR [edx+1048]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+1052]
	mulss	xmm1, DWORD PTR [ecx+1052]
	subss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+1056]
	mulss	xmm1, DWORD PTR [eax+1056]
	subss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	mov	eax, 12					; 0000000cH
	shl	eax, 1
	lea	ecx, DWORD PTR [edx+eax+296]
	mov	edx, 4
	shl	edx, 1
	movss	DWORD PTR [ecx+edx], xmm0

; 2216 : 
; 2217 :    /*--------------*/
; 2218 :    /* euler angles */
; 2219 :    /*--------------*/
; 2220 : 
; 2221 :    // pitch (ay) constrained to +/- 90 deg, roll(ax) +/- 180 deg
; 2222 :    /*
; 2223 :    XE.az   =  (float)atan2(platform->dmx[0][1],platform->dmx[0][0]);
; 2224 :    XE.ay = -(float)asin(platform->dmx[0][2]);
; 2225 :    XE.ax =  (float)atan2(platform->dmx[1][2],platform->dmx[2][2]);
; 2226 :    */
; 2227 : 
; 2228 :    // roll (ax) constrained to +/- 90 deg, pitch(ay) +/- 180 deg
; 2229 :    XE.az   =  (float)atan2(platform->dmx[0][1],platform->dmx[0][0]);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	mov	edx, 12					; 0000000cH
	imul	edx, 0
	lea	eax, DWORD PTR [ecx+edx+296]
	mov	ecx, 4
	imul	ecx, 0
	cvtss2sd xmm0, DWORD PTR [eax+ecx]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	mov	ecx, 12					; 0000000cH
	imul	ecx, 0
	lea	edx, DWORD PTR [eax+ecx+296]
	mov	eax, 4
	shl	eax, 0
	cvtss2sd xmm0, DWORD PTR [edx+eax]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+440]

; 2230 :    XE.ax =  (float)asin(platform->dmx[1][2]);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	lea	edx, DWORD PTR [eax+ecx+296]
	mov	eax, 4
	shl	eax, 1
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	call	?asin@@YAMM@Z				; asin
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+432]

; 2231 :    XE.ay = -(float)atan2(platform->dmx[0][2],platform->dmx[2][2]);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	lea	edx, DWORD PTR [eax+ecx+296]
	mov	eax, 4
	shl	eax, 1
	cvtss2sd xmm0, DWORD PTR [edx+eax]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	mov	eax, 12					; 0000000cH
	imul	eax, 0
	lea	ecx, DWORD PTR [edx+eax+296]
	mov	edx, 4
	shl	edx, 1
	cvtss2sd xmm0, DWORD PTR [ecx+edx]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	fstp	QWORD PTR tv676[ebp]
	movsd	xmm0, QWORD PTR tv676[ebp]
	cvtsd2ss xmm0, xmm0
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+436], xmm0

; 2232 : 
; 2233 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CalcBodyOrientation@HeliMMClass@@QAEXXZ ENDP		; HeliMMClass::CalcBodyOrientation
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\helo\helimm.cpp
_TEXT	SEGMENT
tv1288 = -64						; size = 8
tv1279 = -56						; size = 8
_trig$ = -48						; size = 8
_alpharad$ = -40					; size = 4
_betarad$ = -36						; size = 4
_len$ = -32						; size = 4
_totspeed$ = -28					; size = 4
_tmp$ = -24						; size = 4
_t2$ = -20						; size = 4
_t1$ = -16						; size = 4
_dy$ = -12						; size = 4
_dx$ = -8						; size = 4
_this$ = -4						; size = 4
?SimpleModel@HeliMMClass@@QAEXXZ PROC			; HeliMMClass::SimpleModel
; _this$ = ecx

; 2244 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2245 : 	float  totspeed;
; 2246 : 	float dx, dy;
; 2247 : 	float len;
; 2248 : 	float tmp;
; 2249 :    mlTrig trig;
; 2250 : 
; 2251 : 
; 2252 : 	ctlroll = -ctlroll;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1060]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+1060], xmm0

; 2253 : 
; 2254 : 	// pitch rate
; 2255 : 	if ( ctlroll )

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1060]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN13@SimpleMode

; 2256 : 	{
; 2257 : 		// pitch where we want to be
; 2258 : 		tmp = ctlroll * MAX_HELI_PITCH;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1060]
	mulss	xmm0, DWORD PTR __real@3e860a91
	movss	DWORD PTR _tmp$[ebp], xmm0

; 2259 : 		VE.ay = tmp - XE.ay;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _tmp$[ebp]
	subss	xmm0, DWORD PTR [ecx+436]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+340], xmm0

; 2260 : 	}
; 2261 : 	else

	jmp	SHORT $LN12@SimpleMode
$LN13@SimpleMode:

; 2262 : 		VE.ay = -XE.ay;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+436]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+340], xmm0
$LN12@SimpleMode:

; 2263 : 
; 2264 : 	// roll rate and yawrate are tied together
; 2265 : 	if ( ctlpitch )

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1064]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN11@SimpleMode

; 2266 : 	{
; 2267 : 		tmp = ctlpitch * MAX_HELI_ROLL;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1064]
	mulss	xmm0, DWORD PTR __real@3fb2b8c1
	movss	DWORD PTR _tmp$[ebp], xmm0

; 2268 : 		VE.ax = tmp - XE.ax;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _tmp$[ebp]
	subss	xmm0, DWORD PTR [ecx+432]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+336], xmm0

; 2269 : 		VE.az = (ctlpitch * MAX_HELI_YAWRATE);

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1064]
	mulss	xmm0, DWORD PTR __real@40060a91
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+344], xmm0

; 2270 : 	}
; 2271 : 	else

	jmp	SHORT $LN10@SimpleMode
$LN11@SimpleMode:

; 2272 : 	{
; 2273 : 		VE.ax = -XE.ax;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+432]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+336], xmm0

; 2274 : 		VE.az = -VE.az;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+344]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+344], xmm0
$LN10@SimpleMode:

; 2275 : 	}
; 2276 : 
; 2277 : 	// climb rate
; 2278 : 	VE.z = -(ctlcpitch - 0.5f) * MAX_HELI_CLIMBRATE;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1068]
	subss	xmm0, DWORD PTR __real@3f000000
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR __real@42f00000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+332], xmm0

; 2279 : 
; 2280 : 	XE.ax = XE.ax + dT * TIME_CHEAT * ( A2 * VE.ax + B2 * VEprev.ax );

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+4]
	mulss	xmm0, DWORD PTR __real@3f800000
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR ?A2@@3MA
	mulss	xmm1, DWORD PTR [eax+336]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm2, DWORD PTR ?B2@@3MA
	mulss	xmm2, DWORD PTR [ecx+368]
	addss	xmm1, xmm2
	mulss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+432]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+432], xmm0

; 2281 : 	XE.ay = XE.ay + dT * TIME_CHEAT * ( A2 * VE.ay + B2 * VEprev.ay );

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+4]
	mulss	xmm0, DWORD PTR __real@3f800000
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR ?A2@@3MA
	mulss	xmm1, DWORD PTR [edx+340]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm2, DWORD PTR ?B2@@3MA
	mulss	xmm2, DWORD PTR [eax+372]
	addss	xmm1, xmm2
	mulss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+436]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+436], xmm0

; 2282 : 	XE.az = XE.az + dT * TIME_CHEAT * ( A2 * VE.az + B2 * VEprev.az );

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+4]
	mulss	xmm0, DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR ?A2@@3MA
	mulss	xmm1, DWORD PTR [ecx+344]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm2, DWORD PTR ?B2@@3MA
	mulss	xmm2, DWORD PTR [edx+376]
	addss	xmm1, xmm2
	mulss	xmm0, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+440]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+440], xmm0

; 2283 : 
; 2284 : 	if ( XE.ax > MAX_HELI_ROLL )

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+432]
	comiss	xmm0, DWORD PTR __real@3fb2b8c1
	jbe	SHORT $LN9@SimpleMode

; 2285 : 	{
; 2286 : 		XE.ax = MAX_HELI_ROLL;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fb2b8c1
	movss	DWORD PTR [eax+432], xmm0

; 2287 : 		VE.ax = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+336], xmm0
	jmp	SHORT $LN7@SimpleMode
$LN9@SimpleMode:

; 2288 : 	}
; 2289 : 	else if ( XE.ax < -MAX_HELI_ROLL )

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bfb2b8c1
	comiss	xmm0, DWORD PTR [edx+432]
	jbe	SHORT $LN7@SimpleMode

; 2290 : 	{
; 2291 : 		XE.ax = -MAX_HELI_ROLL;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bfb2b8c1
	movss	DWORD PTR [eax+432], xmm0

; 2292 : 		VE.ax = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+336], xmm0
$LN7@SimpleMode:

; 2293 : 	}
; 2294 : 
; 2295 : 	if ( XE.ay > MAX_HELI_PITCH )

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+436]
	comiss	xmm0, DWORD PTR __real@3e860a91
	jbe	SHORT $LN6@SimpleMode

; 2296 : 	{
; 2297 : 		XE.ay = MAX_HELI_PITCH;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3e860a91
	movss	DWORD PTR [eax+436], xmm0

; 2298 : 		VE.ay = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+340], xmm0
	jmp	SHORT $LN4@SimpleMode
$LN6@SimpleMode:

; 2299 : 	}
; 2300 : 	else if ( XE.ay < -MAX_HELI_PITCH )

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@be860a91
	comiss	xmm0, DWORD PTR [edx+436]
	jbe	SHORT $LN4@SimpleMode

; 2301 : 	{
; 2302 : 		XE.ay = -MAX_HELI_PITCH;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@be860a91
	movss	DWORD PTR [eax+436], xmm0

; 2303 : 		VE.ay = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+340], xmm0
$LN4@SimpleMode:

; 2304 : 	}
; 2305 : 
; 2306 : 	if ( XE.az > DTR * 360.0f )

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+440]
	comiss	xmm0, DWORD PTR __real@40c90fd9
	jbe	SHORT $LN3@SimpleMode

; 2307 : 		XE.az -= 360.0f * DTR;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+440]
	subss	xmm0, DWORD PTR __real@40c90fd9
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+440], xmm0
	jmp	SHORT $LN1@SimpleMode
$LN3@SimpleMode:

; 2308 : 	else if ( XE.az < 0.0f )

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [edx+440]
	jbe	SHORT $LN1@SimpleMode

; 2309 : 		XE.az += 360.0f * DTR;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+440]
	addss	xmm0, DWORD PTR __real@40c90fd9
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+440], xmm0
$LN1@SimpleMode:

; 2310 : 
; 2311 : 	// get sines and cosines
; 2312 :    mlSinCos (&trig, XE.ax); // Roll

	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+432]
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _trig$[ebp]
	push	eax
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 2313 :    eucos.x = trig.cos;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _trig$[ebp+4]
	movss	DWORD PTR [ecx+140], xmm0

; 2314 :    eusin.x = trig.sin;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _trig$[ebp]
	movss	DWORD PTR [edx+152], xmm0

; 2315 :    mlSinCos (&trig, XE.ay); // Pitch

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+436]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _trig$[ebp]
	push	ecx
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 2316 :    eucos.y = trig.cos;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _trig$[ebp+4]
	movss	DWORD PTR [edx+144], xmm0

; 2317 :    eusin.y = trig.sin;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _trig$[ebp]
	movss	DWORD PTR [eax+156], xmm0

; 2318 :    mlSinCos (&trig, XE.az); // Yaw

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+440]
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR _trig$[ebp]
	push	edx
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 2319 :    eucos.z = trig.cos;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _trig$[ebp+4]
	movss	DWORD PTR [eax+148], xmm0

; 2320 :    eusin.z = trig.sin;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _trig$[ebp]
	movss	DWORD PTR [ecx+160], xmm0

; 2321 : 
; 2322 :    platform->platformAngles.cospsi = (float)eucos.z;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+148]
	mov	DWORD PTR [eax+408], edx

; 2323 :    platform->platformAngles.costhe = (float)eucos.y;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+144]
	mov	DWORD PTR [ecx+392], eax

; 2324 :    platform->platformAngles.cosphi = (float)eucos.x;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	mov	DWORD PTR [edx+400], ecx

; 2325 :    platform->platformAngles.sinpsi = (float)eusin.z;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+160]
	mov	DWORD PTR [eax+404], edx

; 2326 :    platform->platformAngles.sinthe = (float)eusin.y;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+156]
	mov	DWORD PTR [ecx+388], eax

; 2327 :    platform->platformAngles.sinphi = (float)eusin.x;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+152]
	mov	DWORD PTR [edx+396], ecx

; 2328 : 
; 2329 :    // build matrix
; 2330 :    platform->dmx[0][0] = platform->platformAngles.cospsi*platform->platformAngles.costhe;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	movss	xmm0, DWORD PTR [eax+408]
	mulss	xmm0, DWORD PTR [edx+392]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	mov	edx, 12					; 0000000cH
	imul	edx, 0
	lea	eax, DWORD PTR [ecx+edx+296]
	mov	ecx, 4
	imul	ecx, 0
	movss	DWORD PTR [eax+ecx], xmm0

; 2331 :    platform->dmx[0][1] = platform->platformAngles.sinpsi*platform->platformAngles.costhe;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	movss	xmm0, DWORD PTR [eax+404]
	mulss	xmm0, DWORD PTR [edx+392]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	mov	edx, 12					; 0000000cH
	imul	edx, 0
	lea	eax, DWORD PTR [ecx+edx+296]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR [eax+ecx], xmm0

; 2332 :    platform->dmx[0][2] = -platform->platformAngles.sinthe;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	movss	xmm0, DWORD PTR [eax+388]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	mov	eax, 12					; 0000000cH
	imul	eax, 0
	lea	ecx, DWORD PTR [edx+eax+296]
	mov	edx, 4
	shl	edx, 1
	movss	DWORD PTR [ecx+edx], xmm0

; 2333 : 
; 2334 :    platform->dmx[1][0] = -platform->platformAngles.sinpsi*platform->platformAngles.cosphi + platform->platformAngles.cospsi*platform->platformAngles.sinthe*platform->platformAngles.sinphi;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	movss	xmm0, DWORD PTR [ecx+404]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	mulss	xmm0, DWORD PTR [eax+400]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	movss	xmm1, DWORD PTR [edx+408]
	mulss	xmm1, DWORD PTR [ecx+388]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	mulss	xmm1, DWORD PTR [eax+396]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	lea	ecx, DWORD PTR [edx+eax+296]
	mov	edx, 4
	imul	edx, 0
	movss	DWORD PTR [ecx+edx], xmm0

; 2335 :    platform->dmx[1][1] = platform->platformAngles.cospsi*platform->platformAngles.cosphi + platform->platformAngles.sinpsi*platform->platformAngles.sinthe*platform->platformAngles.sinphi;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	movss	xmm0, DWORD PTR [ecx+408]
	mulss	xmm0, DWORD PTR [eax+400]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	movss	xmm1, DWORD PTR [edx+404]
	mulss	xmm1, DWORD PTR [ecx+388]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	mulss	xmm1, DWORD PTR [eax+396]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	lea	ecx, DWORD PTR [edx+eax+296]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR [ecx+edx], xmm0

; 2336 :    platform->dmx[1][2] = platform->platformAngles.costhe*platform->platformAngles.sinphi;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	movss	xmm0, DWORD PTR [ecx+392]
	mulss	xmm0, DWORD PTR [eax+396]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	lea	ecx, DWORD PTR [edx+eax+296]
	mov	edx, 4
	shl	edx, 1
	movss	DWORD PTR [ecx+edx], xmm0

; 2337 : 
; 2338 :    platform->dmx[2][0] = platform->platformAngles.sinpsi*platform->platformAngles.sinphi + platform->platformAngles.cospsi*platform->platformAngles.sinthe*platform->platformAngles.cosphi;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	movss	xmm0, DWORD PTR [ecx+404]
	mulss	xmm0, DWORD PTR [eax+396]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	movss	xmm1, DWORD PTR [edx+408]
	mulss	xmm1, DWORD PTR [ecx+388]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	mulss	xmm1, DWORD PTR [eax+400]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	mov	eax, 12					; 0000000cH
	shl	eax, 1
	lea	ecx, DWORD PTR [edx+eax+296]
	mov	edx, 4
	imul	edx, 0
	movss	DWORD PTR [ecx+edx], xmm0

; 2339 :    platform->dmx[2][1] = -platform->platformAngles.cospsi*platform->platformAngles.sinphi + platform->platformAngles.sinpsi*platform->platformAngles.sinthe*platform->platformAngles.cosphi;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	movss	xmm0, DWORD PTR [ecx+408]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	mulss	xmm0, DWORD PTR [eax+396]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	movss	xmm1, DWORD PTR [edx+404]
	mulss	xmm1, DWORD PTR [ecx+388]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	mulss	xmm1, DWORD PTR [eax+400]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	mov	eax, 12					; 0000000cH
	shl	eax, 1
	lea	ecx, DWORD PTR [edx+eax+296]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR [ecx+edx], xmm0

; 2340 :    platform->dmx[2][2] = platform->platformAngles.costhe*platform->platformAngles.cosphi;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	movss	xmm0, DWORD PTR [ecx+392]
	mulss	xmm0, DWORD PTR [eax+400]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	mov	eax, 12					; 0000000cH
	shl	eax, 1
	lea	ecx, DWORD PTR [edx+eax+296]
	mov	edx, 4
	shl	edx, 1
	movss	DWORD PTR [ecx+edx], xmm0

; 2341 : 
; 2342 : 
; 2343 :    // speed is based on pitch
; 2344 :    totspeed = -( XE.ay / MAX_HELI_PITCH ) * MAX_HELI_FPS;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+436]
	divss	xmm0, DWORD PTR __real@3e860a91
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR __real@4397e7be
	movss	DWORD PTR _totspeed$[ebp], xmm0

; 2345 : 
; 2346 :    // get the x,y plane forward pointing vector components and normalize
; 2347 :    dx = platform->dmx[0][0];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	mov	eax, 12					; 0000000cH
	imul	eax, 0
	lea	ecx, DWORD PTR [edx+eax+296]
	mov	edx, 4
	imul	edx, 0
	movss	xmm0, DWORD PTR [ecx+edx]
	movss	DWORD PTR _dx$[ebp], xmm0

; 2348 :    dy = platform->dmx[0][1];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	mov	edx, 12					; 0000000cH
	imul	edx, 0
	lea	eax, DWORD PTR [ecx+edx+296]
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	movss	DWORD PTR _dy$[ebp], xmm0

; 2349 :    len = (float)sqrt( dx*dx + dy*dy );

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR _len$[ebp]

; 2350 :    dx = dx/len;

	movss	xmm0, DWORD PTR _dx$[ebp]
	divss	xmm0, DWORD PTR _len$[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0

; 2351 :    dy = dy/len;

	movss	xmm0, DWORD PTR _dy$[ebp]
	divss	xmm0, DWORD PTR _len$[ebp]
	movss	DWORD PTR _dy$[ebp], xmm0

; 2352 : 
; 2353 :    VE.x = dx * totspeed;

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _totspeed$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+324], xmm0

; 2354 :    VE.y = dy * totspeed;

	movss	xmm0, DWORD PTR _dy$[ebp]
	mulss	xmm0, DWORD PTR _totspeed$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+328], xmm0

; 2355 :    XE.x = XE.x + dT * TIME_CHEAT * ( A2 * VE.x + B2 * VEprev.x );

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+4]
	mulss	xmm0, DWORD PTR __real@3f800000
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR ?A2@@3MA
	mulss	xmm1, DWORD PTR [edx+324]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm2, DWORD PTR ?B2@@3MA
	mulss	xmm2, DWORD PTR [eax+356]
	addss	xmm1, xmm2
	mulss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+420]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+420], xmm0

; 2356 :    XE.y = XE.y + dT * TIME_CHEAT * ( A2 * VE.y + B2 * VEprev.y );

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+4]
	mulss	xmm0, DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR ?A2@@3MA
	mulss	xmm1, DWORD PTR [ecx+328]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm2, DWORD PTR ?B2@@3MA
	mulss	xmm2, DWORD PTR [edx+360]
	addss	xmm1, xmm2
	mulss	xmm0, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+424]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+424], xmm0

; 2357 :    XE.z = XE.z + dT * TIME_CHEAT * ( A2 * VE.z + B2 * VEprev.z );

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+4]
	mulss	xmm0, DWORD PTR __real@3f800000
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR ?A2@@3MA
	mulss	xmm1, DWORD PTR [eax+332]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm2, DWORD PTR ?B2@@3MA
	mulss	xmm2, DWORD PTR [ecx+364]
	addss	xmm1, xmm2
	mulss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+428]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+428], xmm0

; 2358 : 
; 2359 :    // save prev
; 2360 :    VEprev = VE;

	mov	esi, DWORD PTR _this$[ebp]
	add	esi, 324				; 00000144H
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 356				; 00000164H
	mov	ecx, 8
	rep movsd

; 2361 :    VB = VE;

	mov	esi, DWORD PTR _this$[ebp]
	add	esi, 324				; 00000144H
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 292				; 00000124H
	mov	ecx, 8
	rep movsd

; 2362 : 
; 2363 :    // get alpha and beta
; 2364 :    alpha = (float)atan2( VB.z, VB.x ) * RTD;

	mov	ecx, DWORD PTR _this$[ebp]
	cvtss2sd xmm0, DWORD PTR [ecx+292]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+300]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	fstp	QWORD PTR tv1279[ebp]
	movsd	xmm0, QWORD PTR tv1279[ebp]
	cvtsd2ss xmm0, xmm0
	mulss	xmm0, DWORD PTR __real@42652ee1
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+800], xmm0

; 2365 :    beta = (float)atan2( VB.y, VB.x ) * RTD;

	mov	ecx, DWORD PTR _this$[ebp]
	cvtss2sd xmm0, DWORD PTR [ecx+292]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+296]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	fstp	QWORD PTR tv1288[ebp]
	movsd	xmm0, QWORD PTR tv1288[ebp]
	cvtsd2ss xmm0, xmm0
	mulss	xmm0, DWORD PTR __real@42652ee1
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+804], xmm0

; 2366 : 
; 2367 :    GetKias = totspeed * FTPSEC_TO_KNOTS;

	movss	xmm0, DWORD PTR _totspeed$[ebp]
	mulss	xmm0, DWORD PTR __real@3f17ac60
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+812], xmm0

; 2368 : 
; 2369 :    // set other platform data -- may be unnecessary
; 2370 :    float t1, t2;
; 2371 :    float alpharad, betarad;
; 2372 : 
; 2373 :    alpharad = alpha * DTR;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+800]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	movss	DWORD PTR _alpharad$[ebp], xmm0

; 2374 :    betarad  = beta  * DTR;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+804]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	movss	DWORD PTR _betarad$[ebp], xmm0

; 2375 : 
; 2376 :    mlSinCos (&trig, alpharad);

	push	ecx
	movss	xmm0, DWORD PTR _alpharad$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _trig$[ebp]
	push	ecx
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 2377 :    platform->platformAngles.sinalp = trig.sin;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	movss	xmm0, DWORD PTR _trig$[ebp]
	movss	DWORD PTR [eax+340], xmm0

; 2378 :    platform->platformAngles.cosalp = trig.cos;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	movss	xmm0, DWORD PTR _trig$[ebp+4]
	movss	DWORD PTR [edx+344], xmm0

; 2379 :    mlSinCos (&trig, betarad);

	push	ecx
	movss	xmm0, DWORD PTR _betarad$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _trig$[ebp]
	push	eax
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 2380 :    platform->platformAngles.sinbet = trig.sin;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	movss	xmm0, DWORD PTR _trig$[ebp]
	movss	DWORD PTR [edx+352], xmm0

; 2381 :    platform->platformAngles.cosbet = trig.cos;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	movss	xmm0, DWORD PTR _trig$[ebp+4]
	movss	DWORD PTR [ecx+356], xmm0

; 2382 : 
; 2383 :    platform->platformAngles.tanbet = (float)tan(betarad);

	push	ecx
	movss	xmm0, DWORD PTR _betarad$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?tan@@YAMM@Z				; tan
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	fstp	DWORD PTR [eax+360]

; 2384 : 
; 2385 :    /*-----------------------------*/
; 2386 :    /* velocity vector orientation */
; 2387 :    /*-----------------------------*/
; 2388 : 
; 2389 :    /*-------*/
; 2390 :    /* gamma */
; 2391 :    /*-------*/
; 2392 :    platform->platformAngles.singam = (platform->platformAngles.sinthe *
; 2393 :       platform->platformAngles.cosalp - platform->platformAngles.costhe *
; 2394 :       platform->platformAngles.cosphi * platform->platformAngles.sinalp) *
; 2395 :       platform->platformAngles.cosbet - platform->platformAngles.costhe *
; 2396 :       platform->platformAngles.sinphi * platform->platformAngles.sinbet;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	movss	xmm0, DWORD PTR [edx+388]
	mulss	xmm0, DWORD PTR [ecx+344]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	movss	xmm1, DWORD PTR [eax+392]
	mulss	xmm1, DWORD PTR [edx+400]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	mulss	xmm1, DWORD PTR [ecx+340]
	subss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	mulss	xmm0, DWORD PTR [eax+356]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	movss	xmm1, DWORD PTR [edx+392]
	mulss	xmm1, DWORD PTR [ecx+396]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	mulss	xmm1, DWORD PTR [eax+352]
	subss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	movss	DWORD PTR [edx+364], xmm0

; 2397 : 
; 2398 :    platform->platformAngles.cosgam = (float)sqrt(1.0f -
; 2399 : 		platform->platformAngles.singam * platform->platformAngles.singam);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	movss	xmm0, DWORD PTR [ecx+364]
	mulss	xmm0, DWORD PTR [eax+364]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	fstp	DWORD PTR [edx+368]

; 2400 : 
; 2401 :    gmma  = (float)asin(platform->platformAngles.singam);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+364]
	movss	DWORD PTR [esp], xmm0
	call	?asin@@YAMM@Z				; asin
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+816]

; 2402 : 
; 2403 : 
; 2404 :    /*----*/
; 2405 :    /* mu */
; 2406 :    /*----*/
; 2407 :    t1 = platform->platformAngles.costhe * platform->platformAngles.sinphi *
; 2408 :       platform->platformAngles.cosbet + (platform->platformAngles.sinthe *
; 2409 :       platform->platformAngles.cosalp - platform->platformAngles.costhe *
; 2410 :       platform->platformAngles.cosphi * platform->platformAngles.sinalp) *
; 2411 :       platform->platformAngles.sinbet;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	movss	xmm0, DWORD PTR [ecx+392]
	mulss	xmm0, DWORD PTR [eax+396]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	mulss	xmm0, DWORD PTR [edx+356]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	movss	xmm1, DWORD PTR [ecx+388]
	mulss	xmm1, DWORD PTR [eax+344]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	movss	xmm2, DWORD PTR [edx+392]
	mulss	xmm2, DWORD PTR [ecx+400]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	mulss	xmm2, DWORD PTR [eax+340]
	subss	xmm1, xmm2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	mulss	xmm1, DWORD PTR [edx+352]
	addss	xmm0, xmm1
	movss	DWORD PTR _t1$[ebp], xmm0

; 2412 :    t2 = platform->platformAngles.costhe * platform->platformAngles.cosphi *
; 2413 :       platform->platformAngles.cosalp + platform->platformAngles.sinthe *
; 2414 :       platform->platformAngles.sinalp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	movss	xmm0, DWORD PTR [ecx+392]
	mulss	xmm0, DWORD PTR [eax+400]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	mulss	xmm0, DWORD PTR [edx+344]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	movss	xmm1, DWORD PTR [ecx+388]
	mulss	xmm1, DWORD PTR [eax+340]
	addss	xmm0, xmm1
	movss	DWORD PTR _t2$[ebp], xmm0

; 2415 : 
; 2416 :    mu     = (float)atan2(t1,t2);

	cvtss2sd xmm0, DWORD PTR _t2$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _t1$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+820]

; 2417 :    platform->platformAngles.sinmu  = mu*t1;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+820]
	mulss	xmm0, DWORD PTR _t1$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	movss	DWORD PTR [ecx+380], xmm0

; 2418 :    platform->platformAngles.cosmu  = mu*t2;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+820]
	mulss	xmm0, DWORD PTR _t2$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	movss	DWORD PTR [ecx+384], xmm0

; 2419 : 
; 2420 :    /*-------*/
; 2421 :    /* sigma */
; 2422 :    /*-------*/
; 2423 :    t1 = ( -platform->platformAngles.sinphi *
; 2424 :       platform->platformAngles.sinalp * platform->platformAngles.cosbet +
; 2425 : 		platform->platformAngles.cosphi * platform->platformAngles.sinbet ) *
; 2426 :       platform->platformAngles.cospsi + (( platform->platformAngles.costhe *
; 2427 :       platform->platformAngles.cosalp + platform->platformAngles.sinthe *
; 2428 :       platform->platformAngles.cosphi * platform->platformAngles.sinalp) *
; 2429 :       platform->platformAngles.cosbet + platform->platformAngles.sinthe *
; 2430 :       platform->platformAngles.sinphi * platform->platformAngles.sinbet) *
; 2431 :       platform->platformAngles.sinpsi;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	movss	xmm0, DWORD PTR [eax+396]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	mulss	xmm0, DWORD PTR [edx+340]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	mulss	xmm0, DWORD PTR [ecx+356]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	movss	xmm1, DWORD PTR [eax+400]
	mulss	xmm1, DWORD PTR [edx+352]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	mulss	xmm0, DWORD PTR [ecx+408]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	movss	xmm1, DWORD PTR [eax+392]
	mulss	xmm1, DWORD PTR [edx+344]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	movss	xmm2, DWORD PTR [ecx+388]
	mulss	xmm2, DWORD PTR [eax+400]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	mulss	xmm2, DWORD PTR [edx+340]
	addss	xmm1, xmm2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	mulss	xmm1, DWORD PTR [ecx+356]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	movss	xmm2, DWORD PTR [eax+388]
	mulss	xmm2, DWORD PTR [edx+396]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	mulss	xmm2, DWORD PTR [ecx+352]
	addss	xmm1, xmm2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	mulss	xmm1, DWORD PTR [eax+404]
	addss	xmm0, xmm1
	movss	DWORD PTR _t1$[ebp], xmm0

; 2432 :    t2 =  ((platform->platformAngles.costhe *
; 2433 :       platform->platformAngles.cosalp + platform->platformAngles.sinthe *
; 2434 :       platform->platformAngles.cosphi * platform->platformAngles.sinalp) *
; 2435 :       platform->platformAngles.cosbet + platform->platformAngles.sinthe *
; 2436 :       platform->platformAngles.sinphi * platform->platformAngles.sinbet) *
; 2437 :       platform->platformAngles.cospsi + (platform->platformAngles.sinphi *
; 2438 :       platform->platformAngles.sinalp * platform->platformAngles.cosbet -
; 2439 : 		platform->platformAngles.cosphi * platform->platformAngles.sinbet) *
; 2440 :       platform->platformAngles.sinpsi;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	movss	xmm0, DWORD PTR [edx+392]
	mulss	xmm0, DWORD PTR [ecx+344]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	movss	xmm1, DWORD PTR [eax+388]
	mulss	xmm1, DWORD PTR [edx+400]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	mulss	xmm1, DWORD PTR [ecx+340]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	mulss	xmm0, DWORD PTR [eax+356]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	movss	xmm1, DWORD PTR [edx+388]
	mulss	xmm1, DWORD PTR [ecx+396]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	mulss	xmm1, DWORD PTR [eax+352]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	mulss	xmm0, DWORD PTR [edx+408]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	movss	xmm1, DWORD PTR [ecx+396]
	mulss	xmm1, DWORD PTR [eax+340]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	mulss	xmm1, DWORD PTR [edx+356]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	movss	xmm2, DWORD PTR [ecx+400]
	mulss	xmm2, DWORD PTR [eax+352]
	subss	xmm1, xmm2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	mulss	xmm1, DWORD PTR [edx+404]
	addss	xmm0, xmm1
	movss	DWORD PTR _t2$[ebp], xmm0

; 2441 : 
; 2442 :    sigma  = (float)atan2(t1,t2);

	cvtss2sd xmm0, DWORD PTR _t2$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _t1$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+824]

; 2443 :    platform->platformAngles.sinsig = sigma*t1;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+824]
	mulss	xmm0, DWORD PTR _t1$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	movss	DWORD PTR [eax+372], xmm0

; 2444 :    platform->platformAngles.cossig = sigma*t2;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+824]
	mulss	xmm0, DWORD PTR _t2$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	movss	DWORD PTR [eax+376], xmm0

; 2445 : 
; 2446 :    vta = (float)sqrt(
; 2447 : 				VB.x * VB.x +
; 2448 : 				VB.y * VB.y +
; 2449 : 				VB.z * VB.z );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+292]
	mulss	xmm0, DWORD PTR [edx+292]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+296]
	mulss	xmm1, DWORD PTR [ecx+296]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+300]
	mulss	xmm1, DWORD PTR [eax+300]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+88]

; 2450 : 
; 2451 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?SimpleModel@HeliMMClass@@QAEXXZ ENDP			; HeliMMClass::SimpleModel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\helo\helimm.cpp
_TEXT	SEGMENT
_trigAX$ = -44						; size = 8
_trigAY$ = -36						; size = 8
_trigAZ$ = -28						; size = 8
_e40$ = -20						; size = 4
_e30$ = -16						; size = 4
_e20$ = -12						; size = 4
_e10$ = -8						; size = 4
_this$ = -4						; size = 4
?InitQuat@HeliMMClass@@QAEXXZ PROC			; HeliMMClass::InitQuat
; _this$ = ecx

; 2061 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 2062 : 	float e10, e20, e30, e40;
; 2063 :    mlTrig trigAZ, trigAY, trigAX;
; 2064 : 
; 2065 :    mlSinCos (&trigAX, XE.ax*0.5F);

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+432]
	mulss	xmm0, DWORD PTR __real@3f000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _trigAX$[ebp]
	push	ecx
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 2066 :    mlSinCos (&trigAY, XE.ay*0.5F);

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+436]
	mulss	xmm0, DWORD PTR __real@3f000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _trigAY$[ebp]
	push	eax
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 2067 :    mlSinCos (&trigAZ, XE.az*0.5F);

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+440]
	mulss	xmm0, DWORD PTR __real@3f000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR _trigAZ$[ebp]
	push	edx
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 2068 : 
; 2069 :    /*------------------------*/
; 2070 :    /* initialize quaternions */
; 2071 :    /*------------------------*/
; 2072 :    e10 = trigAZ.cos*trigAY.cos*trigAX.cos +
; 2073 :          trigAZ.sin*trigAY.sin*trigAX.sin;

	movss	xmm0, DWORD PTR _trigAZ$[ebp+4]
	mulss	xmm0, DWORD PTR _trigAY$[ebp+4]
	mulss	xmm0, DWORD PTR _trigAX$[ebp+4]
	movss	xmm1, DWORD PTR _trigAZ$[ebp]
	mulss	xmm1, DWORD PTR _trigAY$[ebp]
	mulss	xmm1, DWORD PTR _trigAX$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _e10$[ebp], xmm0

; 2074 : 
; 2075 :    e20 = trigAZ.sin*trigAY.cos*trigAX.cos -
; 2076 :          trigAZ.cos*trigAY.sin*trigAX.sin;

	movss	xmm0, DWORD PTR _trigAZ$[ebp]
	mulss	xmm0, DWORD PTR _trigAY$[ebp+4]
	mulss	xmm0, DWORD PTR _trigAX$[ebp+4]
	movss	xmm1, DWORD PTR _trigAZ$[ebp+4]
	mulss	xmm1, DWORD PTR _trigAY$[ebp]
	mulss	xmm1, DWORD PTR _trigAX$[ebp]
	subss	xmm0, xmm1
	movss	DWORD PTR _e20$[ebp], xmm0

; 2077 : 
; 2078 :    e30 = trigAZ.cos*trigAY.sin*trigAX.cos +
; 2079 :          trigAZ.sin*trigAY.cos*trigAX.sin;

	movss	xmm0, DWORD PTR _trigAZ$[ebp+4]
	mulss	xmm0, DWORD PTR _trigAY$[ebp]
	mulss	xmm0, DWORD PTR _trigAX$[ebp+4]
	movss	xmm1, DWORD PTR _trigAZ$[ebp]
	mulss	xmm1, DWORD PTR _trigAY$[ebp+4]
	mulss	xmm1, DWORD PTR _trigAX$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _e30$[ebp], xmm0

; 2080 : 
; 2081 :    e40 = trigAZ.cos*trigAY.cos*trigAX.sin -
; 2082 :          trigAZ.sin*trigAY.sin*trigAX.cos;

	movss	xmm0, DWORD PTR _trigAZ$[ebp+4]
	mulss	xmm0, DWORD PTR _trigAY$[ebp+4]
	mulss	xmm0, DWORD PTR _trigAX$[ebp]
	movss	xmm1, DWORD PTR _trigAZ$[ebp]
	mulss	xmm1, DWORD PTR _trigAY$[ebp]
	mulss	xmm1, DWORD PTR _trigAX$[ebp+4]
	subss	xmm0, xmm1
	movss	DWORD PTR _e40$[ebp], xmm0

; 2083 : 
; 2084 :    e1 = e10;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _e10$[ebp]
	movss	DWORD PTR [eax+1044], xmm0

; 2085 :    e2 = e20;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _e20$[ebp]
	movss	DWORD PTR [ecx+1048], xmm0

; 2086 :    e3 = e30;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _e30$[ebp]
	movss	DWORD PTR [edx+1052], xmm0

; 2087 :    e4 = e40;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _e40$[ebp]
	movss	DWORD PTR [eax+1056], xmm0

; 2088 : 
; 2089 :    olde1[0] = e10;

	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _e10$[ebp]
	movss	DWORD PTR [edx+ecx+828], xmm0

; 2090 :    olde1[1] = e10;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _e10$[ebp]
	movss	DWORD PTR [ecx+eax+828], xmm0

; 2091 :    olde1[2] = 0.0;

	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+edx+828], xmm0

; 2092 :    olde1[3] = 0.0;

	mov	ecx, 4
	imul	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+ecx+828], xmm0

; 2093 : 
; 2094 :    olde2[0] = e20;

	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _e20$[ebp]
	movss	DWORD PTR [ecx+eax+852], xmm0

; 2095 :    olde2[1] = e20;

	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _e20$[ebp]
	movss	DWORD PTR [eax+edx+852], xmm0

; 2096 :    olde2[2] = 0.0;

	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+ecx+852], xmm0

; 2097 :    olde2[3] = 0.0;

	mov	eax, 4
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+eax+852], xmm0

; 2098 : 
; 2099 :    olde3[0] = e30;

	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _e30$[ebp]
	movss	DWORD PTR [eax+edx+876], xmm0

; 2100 :    olde3[1] = e30;

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _e30$[ebp]
	movss	DWORD PTR [edx+ecx+876], xmm0

; 2101 :    olde3[2] = 0.0;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+eax+876], xmm0

; 2102 :    olde3[3] = 0.0;

	mov	edx, 4
	imul	edx, 3
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+edx+876], xmm0

; 2103 : 
; 2104 :    olde4[0] = e40;

	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _e40$[ebp]
	movss	DWORD PTR [edx+ecx+900], xmm0

; 2105 :    olde4[1] = e40;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _e40$[ebp]
	movss	DWORD PTR [ecx+eax+900], xmm0

; 2106 :    olde4[2] = 0.0;

	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+edx+900], xmm0

; 2107 :    olde4[3] = 0.0;

	mov	ecx, 4
	imul	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+ecx+900], xmm0

; 2108 : 
; 2109 :    /*---------------------------*/
; 2110 :    /* initial direction cosines */
; 2111 :    /*---------------------------*/
; 2112 :    platform->dmx[0][0] = e10*e10 - e20*e20 - e30*e30 + e40*e40;

	movss	xmm0, DWORD PTR _e10$[ebp]
	mulss	xmm0, DWORD PTR _e10$[ebp]
	movss	xmm1, DWORD PTR _e20$[ebp]
	mulss	xmm1, DWORD PTR _e20$[ebp]
	subss	xmm0, xmm1
	movss	xmm1, DWORD PTR _e30$[ebp]
	mulss	xmm1, DWORD PTR _e30$[ebp]
	subss	xmm0, xmm1
	movss	xmm1, DWORD PTR _e40$[ebp]
	mulss	xmm1, DWORD PTR _e40$[ebp]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	mov	edx, 12					; 0000000cH
	imul	edx, 0
	lea	eax, DWORD PTR [ecx+edx+296]
	mov	ecx, 4
	imul	ecx, 0
	movss	DWORD PTR [eax+ecx], xmm0

; 2113 :    platform->dmx[0][1] = 2*(e30*e40 + e10*e20);

	movss	xmm0, DWORD PTR _e30$[ebp]
	mulss	xmm0, DWORD PTR _e40$[ebp]
	movss	xmm1, DWORD PTR _e10$[ebp]
	mulss	xmm1, DWORD PTR _e20$[ebp]
	addss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@40000000
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	mov	ecx, 12					; 0000000cH
	imul	ecx, 0
	lea	edx, DWORD PTR [eax+ecx+296]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR [edx+eax], xmm0

; 2114 :    platform->dmx[0][2] = 2*(e20*e40 - e10*e30);

	movss	xmm0, DWORD PTR _e20$[ebp]
	mulss	xmm0, DWORD PTR _e40$[ebp]
	movss	xmm1, DWORD PTR _e10$[ebp]
	mulss	xmm1, DWORD PTR _e30$[ebp]
	subss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@40000000
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	mov	eax, 12					; 0000000cH
	imul	eax, 0
	lea	ecx, DWORD PTR [edx+eax+296]
	mov	edx, 4
	shl	edx, 1
	movss	DWORD PTR [ecx+edx], xmm0

; 2115 : 
; 2116 :    platform->dmx[1][0] = 2*(e30*e40 - e10*e20);

	movss	xmm0, DWORD PTR _e30$[ebp]
	mulss	xmm0, DWORD PTR _e40$[ebp]
	movss	xmm1, DWORD PTR _e10$[ebp]
	mulss	xmm1, DWORD PTR _e20$[ebp]
	subss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@40000000
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	lea	eax, DWORD PTR [ecx+edx+296]
	mov	ecx, 4
	imul	ecx, 0
	movss	DWORD PTR [eax+ecx], xmm0

; 2117 :    platform->dmx[1][1] = e10*e10 - e20*e20 + e30*e30 - e40*e40;

	movss	xmm0, DWORD PTR _e10$[ebp]
	mulss	xmm0, DWORD PTR _e10$[ebp]
	movss	xmm1, DWORD PTR _e20$[ebp]
	mulss	xmm1, DWORD PTR _e20$[ebp]
	subss	xmm0, xmm1
	movss	xmm1, DWORD PTR _e30$[ebp]
	mulss	xmm1, DWORD PTR _e30$[ebp]
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR _e40$[ebp]
	mulss	xmm1, DWORD PTR _e40$[ebp]
	subss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	lea	edx, DWORD PTR [eax+ecx+296]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR [edx+eax], xmm0

; 2118 :    platform->dmx[1][2] = 2*(e20*e30 + e40*e10);

	movss	xmm0, DWORD PTR _e20$[ebp]
	mulss	xmm0, DWORD PTR _e30$[ebp]
	movss	xmm1, DWORD PTR _e40$[ebp]
	mulss	xmm1, DWORD PTR _e10$[ebp]
	addss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@40000000
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	lea	ecx, DWORD PTR [edx+eax+296]
	mov	edx, 4
	shl	edx, 1
	movss	DWORD PTR [ecx+edx], xmm0

; 2119 : 
; 2120 :    platform->dmx[2][0] = 2*(e10*e30 + e20*e40);

	movss	xmm0, DWORD PTR _e10$[ebp]
	mulss	xmm0, DWORD PTR _e30$[ebp]
	movss	xmm1, DWORD PTR _e20$[ebp]
	mulss	xmm1, DWORD PTR _e40$[ebp]
	addss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@40000000
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	mov	edx, 12					; 0000000cH
	shl	edx, 1
	lea	eax, DWORD PTR [ecx+edx+296]
	mov	ecx, 4
	imul	ecx, 0
	movss	DWORD PTR [eax+ecx], xmm0

; 2121 :    platform->dmx[2][1] = 2*(e20*e30 - e10*e40);

	movss	xmm0, DWORD PTR _e20$[ebp]
	mulss	xmm0, DWORD PTR _e30$[ebp]
	movss	xmm1, DWORD PTR _e10$[ebp]
	mulss	xmm1, DWORD PTR _e40$[ebp]
	subss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@40000000
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	lea	edx, DWORD PTR [eax+ecx+296]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR [edx+eax], xmm0

; 2122 :    platform->dmx[2][2] = e10*e10 + e20*e20 - e30*e30 - e40*e40;

	movss	xmm0, DWORD PTR _e10$[ebp]
	mulss	xmm0, DWORD PTR _e10$[ebp]
	movss	xmm1, DWORD PTR _e20$[ebp]
	mulss	xmm1, DWORD PTR _e20$[ebp]
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR _e30$[ebp]
	mulss	xmm1, DWORD PTR _e30$[ebp]
	subss	xmm0, xmm1
	movss	xmm1, DWORD PTR _e40$[ebp]
	mulss	xmm1, DWORD PTR _e40$[ebp]
	subss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	mov	eax, 12					; 0000000cH
	shl	eax, 1
	lea	ecx, DWORD PTR [edx+eax+296]
	mov	edx, 4
	shl	edx, 1
	movss	DWORD PTR [ecx+edx], xmm0

; 2123 : 
; 2124 :    oldGRx[0] = 0.0F;

	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+eax+924], xmm0

; 2125 :    oldGRx[1] = 0.0F;

	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+edx+924], xmm0

; 2126 :    oldGRx[2] = 0.0F;

	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+ecx+924], xmm0

; 2127 :    oldGRx[3] = 0.0F;

	mov	eax, 4
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+eax+924], xmm0

; 2128 : 
; 2129 :    oldGRy[0] = 0.0F;

	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+edx+948], xmm0

; 2130 :    oldGRy[1] = 0.0F;

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+ecx+948], xmm0

; 2131 :    oldGRy[2] = 0.0F;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+eax+948], xmm0

; 2132 :    oldGRy[3] = 0.0F;

	mov	edx, 4
	imul	edx, 3
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+edx+948], xmm0

; 2133 : 
; 2134 :    oldABax[0] = 0.0F;

	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+ecx+972], xmm0

; 2135 :    oldABax[1] = 0.0F;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+eax+972], xmm0

; 2136 :    oldABax[2] = 0.0F;

	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+edx+972], xmm0

; 2137 :    oldABax[3] = 0.0F;

	mov	ecx, 4
	imul	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+ecx+972], xmm0

; 2138 : 
; 2139 :    oldABay[0] = 0.0F;

	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+eax+996], xmm0

; 2140 :    oldABay[1] = 0.0F;

	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+edx+996], xmm0

; 2141 :    oldABay[2] = 0.0F;

	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+ecx+996], xmm0

; 2142 :    oldABay[3] = 0.0F;

	mov	eax, 4
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+eax+996], xmm0

; 2143 : 
; 2144 :    oldABaz[0] = 0.0F;

	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+edx+1020], xmm0

; 2145 :    oldABaz[1] = 0.0F;

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+ecx+1020], xmm0

; 2146 :    oldABaz[2] = 0.0F;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+eax+1020], xmm0

; 2147 :    oldABaz[3] = 0.0F;

	mov	edx, 4
	imul	edx, 3
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+edx+1020], xmm0

; 2148 : 
; 2149 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?InitQuat@HeliMMClass@@QAEXXZ ENDP			; HeliMMClass::InitQuat
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\helo\helimm.cpp
_TEXT	SEGMENT
_trig$ = -32						; size = 8
tv694 = -24						; size = 4
_alpharad$ = -20					; size = 4
_betarad$ = -16						; size = 4
_t2$ = -12						; size = 4
_t1$ = -8						; size = 4
_this$ = -4						; size = 4
?SetPlatformData@HeliMMClass@@QAEXXZ PROC		; HeliMMClass::SetPlatformData
; _this$ = ecx

; 1933 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 1934 :    float t1, t2;
; 1935 :    float alpharad, betarad;
; 1936 :    mlTrig trig;
; 1937 : 
; 1938 :    alpharad = alpha * DTR;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+800]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	movss	DWORD PTR _alpharad$[ebp], xmm0

; 1939 :    betarad  = beta  * DTR;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+804]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	movss	DWORD PTR _betarad$[ebp], xmm0

; 1940 : 
; 1941 :    platform->platformAngles.cospsi = (float)eucos.z;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+148]
	mov	DWORD PTR [eax+408], edx

; 1942 :    platform->platformAngles.costhe = (float)eucos.y;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+144]
	mov	DWORD PTR [ecx+392], eax

; 1943 :    platform->platformAngles.cosphi = (float)eucos.x;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	mov	DWORD PTR [edx+400], ecx

; 1944 : 
; 1945 :    platform->platformAngles.sinpsi = (float)eusin.z;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+160]
	mov	DWORD PTR [eax+404], edx

; 1946 :    platform->platformAngles.sinthe = (float)eusin.y;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+156]
	mov	DWORD PTR [ecx+388], eax

; 1947 :    platform->platformAngles.sinphi = (float)eusin.x;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+152]
	mov	DWORD PTR [edx+396], ecx

; 1948 :    mlSinCos (&trig, alpharad);

	push	ecx
	movss	xmm0, DWORD PTR _alpharad$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR _trig$[ebp]
	push	edx
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 1949 :    platform->platformAngles.sinalp = trig.sin;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	movss	xmm0, DWORD PTR _trig$[ebp]
	movss	DWORD PTR [ecx+340], xmm0

; 1950 :    platform->platformAngles.cosalp = trig.cos;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	movss	xmm0, DWORD PTR _trig$[ebp+4]
	movss	DWORD PTR [eax+344], xmm0

; 1951 :    mlSinCos (&trig, betarad);

	push	ecx
	movss	xmm0, DWORD PTR _betarad$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _trig$[ebp]
	push	ecx
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 1952 :    platform->platformAngles.sinbet = trig.sin;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	movss	xmm0, DWORD PTR _trig$[ebp]
	movss	DWORD PTR [eax+352], xmm0

; 1953 :    platform->platformAngles.cosbet = trig.cos;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	movss	xmm0, DWORD PTR _trig$[ebp+4]
	movss	DWORD PTR [edx+356], xmm0

; 1954 : 
; 1955 :    platform->platformAngles.tanbet = (float)tan(betarad);

	push	ecx
	movss	xmm0, DWORD PTR _betarad$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?tan@@YAMM@Z				; tan
	add	esp, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	fstp	DWORD PTR [ecx+360]

; 1956 : 
; 1957 :    /*-----------------------------*/
; 1958 :    /* velocity vector orientation */
; 1959 :    /*-----------------------------*/
; 1960 : 
; 1961 :    /*-------*/
; 1962 :    /* gamma */
; 1963 :    /*-------*/
; 1964 :    platform->platformAngles.singam = (platform->platformAngles.sinthe *
; 1965 :       platform->platformAngles.cosalp - platform->platformAngles.costhe *
; 1966 :       platform->platformAngles.cosphi * platform->platformAngles.sinalp) *
; 1967 :       platform->platformAngles.cosbet - platform->platformAngles.costhe *
; 1968 :       platform->platformAngles.sinphi * platform->platformAngles.sinbet;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	movss	xmm0, DWORD PTR [eax+388]
	mulss	xmm0, DWORD PTR [edx+344]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	movss	xmm1, DWORD PTR [ecx+392]
	mulss	xmm1, DWORD PTR [eax+400]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	mulss	xmm1, DWORD PTR [edx+340]
	subss	xmm0, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	mulss	xmm0, DWORD PTR [ecx+356]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	movss	xmm1, DWORD PTR [eax+392]
	mulss	xmm1, DWORD PTR [edx+396]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	mulss	xmm1, DWORD PTR [ecx+352]
	subss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	movss	DWORD PTR [eax+364], xmm0

; 1969 : 
; 1970 :    platform->platformAngles.cosgam = (float)sqrt(1.0f -
; 1971 : 		platform->platformAngles.singam * platform->platformAngles.singam);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	movss	xmm0, DWORD PTR [edx+364]
	mulss	xmm0, DWORD PTR [ecx+364]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	fstp	DWORD PTR [eax+368]

; 1972 : 
; 1973 :    gmma = (float)atan2(platform->platformAngles.singam,platform->platformAngles.cosgam);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	cvtss2sd xmm0, DWORD PTR [edx+368]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	cvtss2sd xmm0, DWORD PTR [ecx+364]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+816]

; 1974 : 
; 1975 :    /*----*/
; 1976 :    /* mu */
; 1977 :    /*----*/
; 1978 :    t1 = platform->platformAngles.costhe * platform->platformAngles.sinphi *
; 1979 :       platform->platformAngles.cosbet + (platform->platformAngles.sinthe *
; 1980 :       platform->platformAngles.cosalp - platform->platformAngles.costhe *
; 1981 :       platform->platformAngles.cosphi * platform->platformAngles.sinalp) *
; 1982 :       platform->platformAngles.sinbet;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	movss	xmm0, DWORD PTR [ecx+392]
	mulss	xmm0, DWORD PTR [eax+396]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	mulss	xmm0, DWORD PTR [edx+356]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	movss	xmm1, DWORD PTR [ecx+388]
	mulss	xmm1, DWORD PTR [eax+344]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	movss	xmm2, DWORD PTR [edx+392]
	mulss	xmm2, DWORD PTR [ecx+400]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	mulss	xmm2, DWORD PTR [eax+340]
	subss	xmm1, xmm2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	mulss	xmm1, DWORD PTR [edx+352]
	addss	xmm0, xmm1
	movss	DWORD PTR _t1$[ebp], xmm0

; 1983 :    t2 = platform->platformAngles.costhe * platform->platformAngles.cosphi *
; 1984 :       platform->platformAngles.cosalp + platform->platformAngles.sinthe *
; 1985 :       platform->platformAngles.sinalp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	movss	xmm0, DWORD PTR [ecx+392]
	mulss	xmm0, DWORD PTR [eax+400]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	mulss	xmm0, DWORD PTR [edx+344]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	movss	xmm1, DWORD PTR [ecx+388]
	mulss	xmm1, DWORD PTR [eax+340]
	addss	xmm0, xmm1
	movss	DWORD PTR _t2$[ebp], xmm0

; 1986 : 
; 1987 :    mu     = (float)atan2(t1,t2);

	cvtss2sd xmm0, DWORD PTR _t2$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _t1$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+820]

; 1988 :    platform->platformAngles.sinmu  = t1*mu;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _t1$[ebp]
	mulss	xmm0, DWORD PTR [edx+820]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	movss	DWORD PTR [ecx+380], xmm0

; 1989 :    platform->platformAngles.cosmu  = t2*mu;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _t2$[ebp]
	mulss	xmm0, DWORD PTR [edx+820]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	movss	DWORD PTR [ecx+384], xmm0

; 1990 : 
; 1991 : 
; 1992 :    /*-------*/
; 1993 :    /* sigma */
; 1994 :    /*-------*/
; 1995 :    t1 = ( -platform->platformAngles.sinphi *
; 1996 :       platform->platformAngles.sinalp * platform->platformAngles.cosbet +
; 1997 : 		platform->platformAngles.cosphi * platform->platformAngles.sinbet ) *
; 1998 :       platform->platformAngles.cospsi + (( platform->platformAngles.costhe *
; 1999 :       platform->platformAngles.cosalp + platform->platformAngles.sinthe *
; 2000 :       platform->platformAngles.cosphi * platform->platformAngles.sinalp) *
; 2001 :       platform->platformAngles.cosbet + platform->platformAngles.sinthe *
; 2002 :       platform->platformAngles.sinphi * platform->platformAngles.sinbet) *
; 2003 :       platform->platformAngles.sinpsi;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	movss	xmm0, DWORD PTR [eax+396]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	mulss	xmm0, DWORD PTR [edx+340]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	mulss	xmm0, DWORD PTR [ecx+356]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	movss	xmm1, DWORD PTR [eax+400]
	mulss	xmm1, DWORD PTR [edx+352]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	mulss	xmm0, DWORD PTR [ecx+408]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	movss	xmm1, DWORD PTR [eax+392]
	mulss	xmm1, DWORD PTR [edx+344]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	movss	xmm2, DWORD PTR [ecx+388]
	mulss	xmm2, DWORD PTR [eax+400]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	mulss	xmm2, DWORD PTR [edx+340]
	addss	xmm1, xmm2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	mulss	xmm1, DWORD PTR [ecx+356]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	movss	xmm2, DWORD PTR [eax+388]
	mulss	xmm2, DWORD PTR [edx+396]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	mulss	xmm2, DWORD PTR [ecx+352]
	addss	xmm1, xmm2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	mulss	xmm1, DWORD PTR [eax+404]
	addss	xmm0, xmm1
	movss	DWORD PTR _t1$[ebp], xmm0

; 2004 :    t2 =  ((platform->platformAngles.costhe *
; 2005 :       platform->platformAngles.cosalp + platform->platformAngles.sinthe *
; 2006 :       platform->platformAngles.cosphi * platform->platformAngles.sinalp) *
; 2007 :       platform->platformAngles.cosbet + platform->platformAngles.sinthe *
; 2008 :       platform->platformAngles.sinphi * platform->platformAngles.sinbet) *
; 2009 :       platform->platformAngles.cospsi + (platform->platformAngles.sinphi *
; 2010 :       platform->platformAngles.sinalp * platform->platformAngles.cosbet -
; 2011 : 		platform->platformAngles.cosphi * platform->platformAngles.sinbet) *
; 2012 :       platform->platformAngles.sinpsi;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	movss	xmm0, DWORD PTR [edx+392]
	mulss	xmm0, DWORD PTR [ecx+344]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	movss	xmm1, DWORD PTR [eax+388]
	mulss	xmm1, DWORD PTR [edx+400]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	mulss	xmm1, DWORD PTR [ecx+340]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	mulss	xmm0, DWORD PTR [eax+356]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	movss	xmm1, DWORD PTR [edx+388]
	mulss	xmm1, DWORD PTR [ecx+396]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	mulss	xmm1, DWORD PTR [eax+352]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	mulss	xmm0, DWORD PTR [edx+408]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	movss	xmm1, DWORD PTR [ecx+396]
	mulss	xmm1, DWORD PTR [eax+340]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	mulss	xmm1, DWORD PTR [edx+356]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	movss	xmm2, DWORD PTR [ecx+400]
	mulss	xmm2, DWORD PTR [eax+352]
	subss	xmm1, xmm2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	mulss	xmm1, DWORD PTR [edx+404]
	addss	xmm0, xmm1
	movss	DWORD PTR _t2$[ebp], xmm0

; 2013 : 
; 2014 :    sigma  = (float)atan2(t1,t2);

	cvtss2sd xmm0, DWORD PTR _t2$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _t1$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+824]

; 2015 :    platform->platformAngles.sinsig = sigma*t1;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+824]
	mulss	xmm0, DWORD PTR _t1$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	movss	DWORD PTR [eax+372], xmm0

; 2016 :    platform->platformAngles.cossig = sigma*t2;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+824]
	mulss	xmm0, DWORD PTR _t2$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	movss	DWORD PTR [eax+376], xmm0

; 2017 : 
; 2018 :    /*
; 2019 :    platform->dmx[0][0] = platform->platformAngles.cospsi*platform->platformAngles.costhe;
; 2020 :    platform->dmx[0][1] = platform->platformAngles.sinpsi*platform->platformAngles.costhe;
; 2021 :    platform->dmx[0][2] = -platform->platformAngles.sinthe;
; 2022 : 
; 2023 :    platform->dmx[1][0] = -platform->platformAngles.sinpsi*platform->platformAngles.cosphi + platform->platformAngles.cospsi*platform->platformAngles.sinthe*platform->platformAngles.sinphi;
; 2024 :    platform->dmx[1][1] = platform->platformAngles.cospsi*platform->platformAngles.cosphi + platform->platformAngles.sinpsi*platform->platformAngles.sinthe*platform->platformAngles.sinphi;
; 2025 :    platform->dmx[1][2] = platform->platformAngles.costhe*platform->platformAngles.sinphi;
; 2026 : 
; 2027 :    platform->dmx[2][0] = platform->platformAngles.sinpsi*platform->platformAngles.sinphi + platform->platformAngles.cospsi*platform->platformAngles.sinthe*platform->platformAngles.cosphi;
; 2028 :    platform->dmx[2][1] = -platform->platformAngles.cospsi*platform->platformAngles.sinphi + platform->platformAngles.sinpsi*platform->platformAngles.sinthe*platform->platformAngles.cosphi;
; 2029 :    platform->dmx[2][2] = platform->platformAngles.costhe*platform->platformAngles.cosphi;
; 2030 :    */
; 2031 : 
; 2032 :    // indicated air speed in knots -- don't include rate of climb/descent
; 2033 :    GetKias = (float)sqrt( VB.x * VB.x + VB.y * VB.y ) * FTPSEC_TO_KNOTS;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+292]
	mulss	xmm0, DWORD PTR [edx+292]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+296]
	mulss	xmm1, DWORD PTR [ecx+296]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR tv694[ebp]
	movss	xmm0, DWORD PTR tv694[ebp]
	mulss	xmm0, DWORD PTR __real@3f17ac60
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+812], xmm0

; 2034 : 
; 2035 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SetPlatformData@HeliMMClass@@QAEXXZ ENDP		; HeliMMClass::SetPlatformData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\helo\helimm.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_z$ = 16						; size = 4
?Init@HeliMMClass@@QAEXMMM@Z PROC			; HeliMMClass::Init
; _this$ = ecx

; 2044 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2045 : 	XE.x = x;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [eax+420], xmm0

; 2046 : 	XE.y = y;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [ecx+424], xmm0

; 2047 : 	XE.z = z;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _z$[ebp]
	movss	DWORD PTR [edx+428], xmm0

; 2048 : 	VB.z = -10.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@c1200000
	movss	DWORD PTR [eax+300], xmm0

; 2049 : 
; 2050 : 	// init quaternion
; 2051 : 	InitQuat();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?InitQuat@HeliMMClass@@QAEXXZ		; HeliMMClass::InitQuat

; 2052 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?Init@HeliMMClass@@QAEXMMM@Z ENDP			; HeliMMClass::Init
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\helo\helimm.cpp
_TEXT	SEGMENT
_i$ = -8						; size = 4
_this$ = -4						; size = 4
?Exec@HeliMMClass@@QAEXXZ PROC				; HeliMMClass::Exec
; _this$ = ecx

; 1263 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1264 : 	int i;
; 1265 : 
; 1266 : 
; 1267 : 	// NOTE: slower time for frame time. the current val is too
; 1268 : 	// slow for the math.  Theoretically we should also 2 iterations
; 1269 : 	// of the math model for every sim loop
; 1270 : 
; 1271 : 	if ( md->type == SIMPLE )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx], 4
	jne	SHORT $LN5@Exec

; 1272 : 	{
; 1273 : 		dT = SimLibMajorFrameTime;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	movss	DWORD PTR [edx+4], xmm0

; 1274 : 		SimpleModel();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SimpleModel@HeliMMClass@@QAEXXZ	; HeliMMClass::SimpleModel

; 1275 : 	}
; 1276 : 	else

	jmp	$LN4@Exec
$LN5@Exec:

; 1277 : 	{
; 1278 : 		dT = SimLibMajorFrameTime/5.0f;

	movss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	divss	xmm0, DWORD PTR __real@40a00000
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+4], xmm0

; 1279 : 
; 1280 : 		for (i=0; i < 5; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@Exec
$LN2@Exec:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN3@Exec:
	cmp	DWORD PTR _i$[ebp], 5
	jge	SHORT $LN1@Exec

; 1281 : 		{
; 1282 : 			Setup( );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Setup@HeliMMClass@@QAEXXZ		; HeliMMClass::Setup

; 1283 : 			TipPlanePath( );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?TipPlanePath@HeliMMClass@@QAEXXZ	; HeliMMClass::TipPlanePath

; 1284 : 			MainRotor( );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?MainRotor@HeliMMClass@@QAEXXZ		; HeliMMClass::MainRotor

; 1285 : 			Fuselage( );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Fuselage@HeliMMClass@@QAEXXZ		; HeliMMClass::Fuselage

; 1286 : 			TailRotor( );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?TailRotor@HeliMMClass@@QAEXXZ		; HeliMMClass::TailRotor

; 1287 : 			HorizTail( );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?HorizTail@HeliMMClass@@QAEXXZ		; HeliMMClass::HorizTail

; 1288 : 			Wing( );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Wing@HeliMMClass@@QAEXXZ		; HeliMMClass::Wing

; 1289 : 			VertTail( );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?VertTail@HeliMMClass@@QAEXXZ		; HeliMMClass::VertTail

; 1290 : 			ForceCalc( );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ForceCalc@HeliMMClass@@QAEXXZ		; HeliMMClass::ForceCalc

; 1291 : 		}

	jmp	SHORT $LN2@Exec
$LN1@Exec:

; 1292 : 	
; 1293 : 		SetPlatformData();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetPlatformData@HeliMMClass@@QAEXXZ	; HeliMMClass::SetPlatformData
$LN4@Exec:

; 1294 : 	}
; 1295 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Exec@HeliMMClass@@QAEXXZ ENDP				; HeliMMClass::Exec
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\helo\helimm.cpp
_TEXT	SEGMENT
tv797 = -28						; size = 4
tv722 = -24						; size = 4
tv799 = -20						; size = 4
tv659 = -16						; size = 4
tv637 = -12						; size = 4
tv795 = -8						; size = 4
_this$ = -4						; size = 4
?PreCalc@HeliMMClass@@QAEXXZ PROC			; HeliMMClass::PreCalc
; _this$ = ecx

; 1145 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 1146 : 	// get mass based on weight and gravity
; 1147 : 	mass = md->fus.weight/GRAVITY;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movss	xmm0, DWORD PTR [ecx+20]
	divss	xmm0, DWORD PTR __real@4200b53f
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+8], xmm0

; 1148 : 
; 1149 : 	// tail and main rotor omega's (angular speed)
; 1150 : 	omega_mr = md->mr.rpm * 2.0F * PI / 60.0F;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movss	xmm0, DWORD PTR [ecx+88]
	mulss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR __real@40490fdb
	divss	xmm0, DWORD PTR __real@42700000
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+12], xmm0

; 1151 : 	omega_tr = md->tr.rpm * 2.0F * PI / 60.0F;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movss	xmm0, DWORD PTR [ecx+128]
	mulss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR __real@40490fdb
	divss	xmm0, DWORD PTR __real@42700000
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+16], xmm0

; 1152 : 
; 1153 : 	// tip speed
; 1154 : 	vtip = omega_mr * md->mr.radius;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+12]
	mulss	xmm0, DWORD PTR [ecx+80]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+20], xmm0

; 1155 : 
; 1156 : 	// effective frontal areas of rotors
; 1157 : 	fr_mr = md->mr.cD * md->mr.radius * md->mr.nb * md->mr.chord;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movss	xmm0, DWORD PTR [edx+92]
	mulss	xmm0, DWORD PTR [ecx+80]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mulss	xmm0, DWORD PTR [eax+96]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR [edx+100]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+24], xmm0

; 1158 : 	fr_tr = md->mr.cD * md->tr.radius * md->tr.nb * md->tr.chord;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movss	xmm0, DWORD PTR [edx+92]
	mulss	xmm0, DWORD PTR [ecx+120]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mulss	xmm0, DWORD PTR [eax+140]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR [edx+144]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+28], xmm0

; 1159 : 
; 1160 : 	hp_loss = 90.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@42b40000
	movss	DWORD PTR [ecx+32], xmm0

; 1161 : 
; 1162 : 	// here we could calc based on an altitude, for now just use std
; 1163 : 	// sea level density
; 1164 : 	rh0 = (float)STD_DENSITY_0;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3b1bc5c4
	movss	DWORD PTR [edx+40], xmm0

; 1165 : 	rh02 = rh0/2.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+40]
	divss	xmm0, DWORD PTR __real@40000000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+44], xmm0

; 1166 : 
; 1167 : 	// I've got no idea on this one yet -- used in other calcs
; 1168 : 	gam_om_16 =
; 1169 : 		rh0 * md->mr.lslope * md->mr.chord * (float)pow( md->mr.radius, 4 ) /
; 1170 : 		md->mr.b_mi * omega_mr /
; 1171 : 		16.0F * ( 1.0F + 8.0F/3.0F * md->mr.h_offset/md->mr.radius );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+40]
	mulss	xmm0, DWORD PTR [eax+84]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mulss	xmm0, DWORD PTR [eax+100]
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	ecx
	movss	xmm1, DWORD PTR [edx+80]
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv795[ebp], xmm0
	call	?pow@@YAMMH@Z				; pow
	add	esp, 8
	fstp	DWORD PTR tv637[ebp]
	movss	xmm0, DWORD PTR tv795[ebp]
	mulss	xmm0, DWORD PTR tv637[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	divss	xmm0, DWORD PTR [ecx+76]
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [edx+12]
	divss	xmm0, DWORD PTR __real@41800000
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movss	xmm1, DWORD PTR __real@402aaaab
	mulss	xmm1, DWORD PTR [ecx+72]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	divss	xmm1, DWORD PTR [eax+80]
	addss	xmm1, DWORD PTR __real@3f800000
	mulss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+48], xmm0

; 1172 : 
; 1173 : 	// kC is flapping aerodynamic couple
; 1174 : 	kC = ( 0.75F * omega_mr * md->mr.h_offset/md->mr.radius /
; 1175 : 			   gam_om_16 ) + md->mr.k1;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f400000
	mulss	xmm0, DWORD PTR [edx+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [ecx+72]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	divss	xmm0, DWORD PTR [eax+80]
	mov	ecx, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [ecx+48]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	addss	xmm0, DWORD PTR [eax+108]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+52], xmm0

; 1176 : 
; 1177 : 	// flapping x-couple coeff
; 1178 : 	itb2_om = omega_mr / ( 1.0F + (float)pow( omega_mr/gam_om_16, 2 ) );

	push	2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+12]
	divss	xmm0, DWORD PTR [eax+48]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?pow@@YAMMH@Z				; pow
	add	esp, 8
	fstp	DWORD PTR tv659[ebp]
	movss	xmm0, DWORD PTR tv659[ebp]
	addss	xmm0, DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+12]
	divss	xmm1, xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+56], xmm1

; 1179 : 
; 1180 : 	// flapping primary response
; 1181 : 	itb = itb2_om * omega_mr / gam_om_16;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+56]
	mulss	xmm0, DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [edx+48]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+60], xmm0

; 1182 : 
; 1183 : 
; 1184 : 
; 1185 : 	// primary flapping stiffness
; 1186 : 	dl_db1 = md->mr.nb/2.0F *
; 1187 : 				(1.5F * md->mr.b_mi * md->mr.h_offset/md->mr.radius *
; 1188 : 				 omega_mr * omega_mr );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	movss	xmm0, DWORD PTR [edx+96]
	divss	xmm0, DWORD PTR __real@40000000
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movss	xmm1, DWORD PTR __real@3fc00000
	mulss	xmm1, DWORD PTR [ecx+76]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mulss	xmm1, DWORD PTR [eax+72]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	divss	xmm1, DWORD PTR [edx+80]
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm1, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	mulss	xmm1, DWORD PTR [ecx+12]
	mulss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+64], xmm0

; 1189 : 
; 1190 : 	// cross flapping stiffness
; 1191 : 	dl_da1 = (rh02) * md->mr.lslope * md->mr.nb * md->mr.chord *
; 1192 : 				 md->mr.radius * vtip * vtip * md->mr.h_offset/6.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+44]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR [edx+84]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [ecx+96]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mulss	xmm0, DWORD PTR [eax+100]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR [edx+80]
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [ecx+20]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mulss	xmm0, DWORD PTR [eax+72]
	divss	xmm0, DWORD PTR __real@40c00000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+68], xmm0

; 1193 : 
; 1194 : 	// empirical hack for the Agusta A102
; 1195 : 	if ( md->type == A109 )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN2@PreCalc

; 1196 : 	{
; 1197 : 		itb2_om = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+56], xmm0

; 1198 : 		itb = gam_om_16;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR [edx+60], ecx

; 1199 : 		// zeroing this out (or lowering) effects roll-oscillations -- it makes
; 1200 : 		// them smaller to nonexistent for much smoother feel
; 1201 : 		dl_da1 /= 8.0;

	mov	edx, DWORD PTR _this$[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+68]
	divsd	xmm0, QWORD PTR __real@4020000000000000
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+68], xmm0
$LN2@PreCalc:

; 1202 : 	}
; 1203 : 
; 1204 : 
; 1205 : 	// thrust coefficient
; 1206 : 	cT = md->fus.weight /
; 1207 : 			 (rh0 * PI * md->mr.radius * md->mr.radius *
; 1208 : 			  vtip * vtip );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+40]
	mulss	xmm0, DWORD PTR __real@40490fdb
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR [eax+80]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR [eax+80]
	mov	ecx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [eax+20]
	movss	xmm1, DWORD PTR [edx+20]
	divss	xmm1, xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+72], xmm1

; 1209 : 
; 1210 : 	// a * sigma
; 1211 : 	a_sigma = md->mr.lslope * md->mr.nb * md->mr.chord / md->mr.radius / PI;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	movss	xmm0, DWORD PTR [eax+84]
	mulss	xmm0, DWORD PTR [edx+96]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [ecx+100]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	divss	xmm0, DWORD PTR [eax+80]
	divss	xmm0, DWORD PTR __real@40490fdb
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+76], xmm0

; 1212 : 
; 1213 : 	// tip plane path dihedral effect
; 1214 : 	db1dv = 2.0F / omega_mr / md->mr.radius *
; 1215 : 				( 8.0F * cT / a_sigma + (float)sqrt( cT/2.0F ) );

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@40000000
	divss	xmm0, DWORD PTR [edx+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	divss	xmm0, DWORD PTR [ecx+80]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR __real@41000000
	mulss	xmm1, DWORD PTR [edx+72]
	mov	eax, DWORD PTR _this$[ebp]
	divss	xmm1, DWORD PTR [eax+76]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm2, DWORD PTR [ecx+72]
	divss	xmm2, DWORD PTR __real@40000000
	push	ecx
	movss	DWORD PTR [esp], xmm2
	movss	DWORD PTR tv797[ebp], xmm0
	movss	DWORD PTR tv799[ebp], xmm1
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR tv722[ebp]
	movss	xmm0, DWORD PTR tv799[ebp]
	addss	xmm0, DWORD PTR tv722[ebp]
	movss	xmm1, DWORD PTR tv797[ebp]
	mulss	xmm1, xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+80], xmm1

; 1216 : 
; 1217 : 	// tip plane path pitchup with speed
; 1218 : 	da1du = -db1dv;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+80]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+84], xmm0

; 1219 : 
; 1220 : 	// empirical hack for the STABLE model
; 1221 : 	if ( md->type == STABLE )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax], 3
	jne	SHORT $LN1@PreCalc

; 1222 : 	{
; 1223 : 		// zeroing this out (or lowering) effects roll-oscillations -- it makes
; 1224 : 		// them smaller to nonexistent for much smoother feel
; 1225 : 		dl_da1 *= 0.8F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+68]
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+68], xmm0
$LN1@PreCalc:

; 1226 : 	}
; 1227 : 
; 1228 : 	// pre-calc some values for main rotor
; 1229 : 	mr_tmp1 = omega_mr * md->mr.radius * rh0 * md->mr.lslope *
; 1230 : 		   md->mr.nb * md->mr.chord * md->mr.radius/4.0F;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+12]
	mulss	xmm0, DWORD PTR [ecx+80]
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [eax+40]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR [edx+84]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [ecx+96]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mulss	xmm0, DWORD PTR [eax+100]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR [edx+80]
	divss	xmm0, DWORD PTR __real@40800000
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+1076], xmm0

; 1231 : 	mr_tmp2 = md->mr.radius * rh0 * md->mr.radius * PI;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+80]
	mulss	xmm0, DWORD PTR [eax+40]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR [edx+80]
	mulss	xmm0, DWORD PTR __real@40490fdb
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+1080], xmm0

; 1232 : 
; 1233 : 	// calculate the moment arms
; 1234 : 	// these are basically the relation of components to center of grav
; 1235 : 	// also conerts inches to ft
; 1236 : 	ma_hub.y = ( md->mr.wl_hub - md->fus.wl_cg )/12.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movss	xmm0, DWORD PTR [edx+64]
	subss	xmm0, DWORD PTR [ecx+16]
	divss	xmm0, DWORD PTR __real@41400000
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+96], xmm0

; 1237 : 	ma_hub.x = ( md->mr.fs_hub - md->fus.fs_cg )/12.0F;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	movss	xmm0, DWORD PTR [ecx+60]
	subss	xmm0, DWORD PTR [eax+12]
	divss	xmm0, DWORD PTR __real@41400000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+92], xmm0

; 1238 : 
; 1239 : 	ma_fus.y = ( md->fus.wl_cp - md->fus.wl_cg )/12.0F;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	movss	xmm0, DWORD PTR [eax+44]
	subss	xmm0, DWORD PTR [edx+16]
	divss	xmm0, DWORD PTR __real@41400000
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+104], xmm0

; 1240 : 	ma_fus.x = ( md->fus.fs_cp - md->fus.fs_cg )/12.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movss	xmm0, DWORD PTR [edx+40]
	subss	xmm0, DWORD PTR [ecx+12]
	divss	xmm0, DWORD PTR __real@41400000
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+100], xmm0

; 1241 : 
; 1242 : 	ma_wn.y = ( md->wn.wl - md->fus.wl_cg )/12.0F;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	movss	xmm0, DWORD PTR [ecx+152]
	subss	xmm0, DWORD PTR [eax+16]
	divss	xmm0, DWORD PTR __real@41400000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+112], xmm0

; 1243 : 	ma_wn.x = ( md->wn.fs - md->fus.fs_cg )/12.0F;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	movss	xmm0, DWORD PTR [eax+148]
	subss	xmm0, DWORD PTR [edx+12]
	divss	xmm0, DWORD PTR __real@41400000
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+108], xmm0

; 1244 : 
; 1245 : 	ma_ht.y = ( md->ht.wl - md->fus.wl_cg )/12.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movss	xmm0, DWORD PTR [edx+176]
	subss	xmm0, DWORD PTR [ecx+16]
	divss	xmm0, DWORD PTR __real@41400000
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+120], xmm0

; 1246 : 	ma_ht.x = ( md->ht.fs - md->fus.fs_cg )/12.0F;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	movss	xmm0, DWORD PTR [ecx+172]
	subss	xmm0, DWORD PTR [eax+12]
	divss	xmm0, DWORD PTR __real@41400000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+116], xmm0

; 1247 : 
; 1248 : 	ma_vt.y = ( md->vt.wl - md->fus.wl_cg )/12.0F;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	movss	xmm0, DWORD PTR [eax+200]
	subss	xmm0, DWORD PTR [edx+16]
	divss	xmm0, DWORD PTR __real@41400000
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+128], xmm0

; 1249 : 	ma_vt.x = ( md->vt.fs - md->fus.fs_cg )/12.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movss	xmm0, DWORD PTR [edx+196]
	subss	xmm0, DWORD PTR [ecx+12]
	divss	xmm0, DWORD PTR __real@41400000
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+124], xmm0

; 1250 : 
; 1251 : 	ma_tr.y = ( md->tr.wl_hub - md->fus.wl_cg )/12.0F;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	movss	xmm0, DWORD PTR [ecx+116]
	subss	xmm0, DWORD PTR [eax+16]
	divss	xmm0, DWORD PTR __real@41400000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+136], xmm0

; 1252 : 	ma_tr.x = ( md->tr.fs_hub - md->fus.fs_cg )/12.0F;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	movss	xmm0, DWORD PTR [eax+112]
	subss	xmm0, DWORD PTR [edx+12]
	divss	xmm0, DWORD PTR __real@41400000
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+132], xmm0

; 1253 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PreCalc@HeliMMClass@@QAEXXZ ENDP			; HeliMMClass::PreCalc
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\helo\helimm.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ResetForceVars@HeliMMClass@@QAEXXZ PROC		; HeliMMClass::ResetForceVars
; _this$ = ecx

; 1912 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1913 : 	memset ( &AB, 0, sizeof( D6DOF ) );

	push	32					; 00000020H
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 164				; 000000a4H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1914 : 	memset ( &ABprev, 0, sizeof( D6DOF ) );

	push	32					; 00000020H
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 196				; 000000c4H
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 1915 : 	memset ( &F, 0, sizeof( D6DOF ) );

	push	32					; 00000020H
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 228				; 000000e4H
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 1916 : 	memset ( &VA, 0, sizeof( D6DOF ) );

	push	32					; 00000020H
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 260				; 00000104H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1917 : 	memset ( &VB, 0, sizeof( D6DOF ) );

	push	32					; 00000020H
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 292				; 00000124H
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 1918 : 	memset ( &VE, 0, sizeof( D6DOF ) );

	push	32					; 00000020H
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 324				; 00000144H
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 1919 : 	memset ( &VEprev, 0, sizeof( D6DOF ) );

	push	32					; 00000020H
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 356				; 00000164H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1920 : 	memset ( &VG, 0, sizeof( D6DOF ) );

	push	32					; 00000020H
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 388				; 00000184H
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 1921 : 	memset ( &GR, 0, sizeof( D6DOF ) );

	push	32					; 00000020H
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 452				; 000001c4H
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 1922 : 	memset ( &GV, 0, sizeof( D6DOF ) );

	push	32					; 00000020H
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 460				; 000001ccH
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1923 : 	memset ( &XE, 0, sizeof( D6DOF ) );

	push	32					; 00000020H
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 420				; 000001a4H
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 1924 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ResetForceVars@HeliMMClass@@QAEXXZ ENDP		; HeliMMClass::ResetForceVars
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\helo\helimm.cpp
_TEXT	SEGMENT
tv925 = -36						; size = 8
tv916 = -28						; size = 8
_trig$ = -20						; size = 8
tv834 = -12						; size = 4
tv929 = -8						; size = 4
_this$ = -4						; size = 4
?ForceCalc@HeliMMClass@@QAEXXZ PROC			; HeliMMClass::ForceCalc
; _this$ = ecx

; 1797 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1798 :    mlTrig trig;
; 1799 : 
; 1800 : 	// gravity force
; 1801 : 	grav.x = -mass * GRAVITY * eusin.y;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR __real@4200b53f
	mov	ecx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [ecx+156]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+788], xmm0

; 1802 : 	grav.y = mass * GRAVITY * eusin.x * eucos.y;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	mulss	xmm0, DWORD PTR __real@4200b53f
	mov	ecx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [ecx+152]
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [edx+144]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+792], xmm0

; 1803 : 	grav.z = mass * GRAVITY * eucos.x * eucos.y;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+8]
	mulss	xmm0, DWORD PTR __real@4200b53f
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [edx+140]
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [eax+144]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+796], xmm0

; 1804 : 
; 1805 : 	
; 1806 : 	// Calculate Translational Forces
; 1807 : 	F.x =
; 1808 : 		grav.x +
; 1809 : 		mr6d.x +
; 1810 : 		wn6d.x +
; 1811 : 		fus6d.x;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+788]
	addss	xmm0, DWORD PTR [eax+556]
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+684]
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+524]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+228], xmm0

; 1812 : 	F.y =
; 1813 : 		grav.y +
; 1814 : 		mr6d.y +
; 1815 : 		fus6d.y +
; 1816 : 		tr6d.y +
; 1817 : 		vt6d.y;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+792]
	addss	xmm0, DWORD PTR [edx+560]
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+528]
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+592]
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+656]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+232], xmm0

; 1818 : 	F.z =
; 1819 : 		grav.z +
; 1820 : 		mr6d.z +
; 1821 : 		wn6d.z +
; 1822 : 		fus6d.z +
; 1823 : 		ht6d.z;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+796]
	addss	xmm0, DWORD PTR [edx+564]
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+692]
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+532]
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+628]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+236], xmm0

; 1824 : 
; 1825 : 	// calculate torques
; 1826 : 	F.ax =
; 1827 : 		mr6d.ax +
; 1828 : 		fus6d.ax +
; 1829 : 		tr6d.ax/md->roll_damp +
; 1830 : 		vt6d.ax/md->roll_damp;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+568]
	addss	xmm0, DWORD PTR [edx+536]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+600]
	divss	xmm1, DWORD PTR [ecx+8]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+664]
	divss	xmm1, DWORD PTR [ecx+8]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+240], xmm0

; 1831 : 	F.ay =
; 1832 : 		mr6d.ay +
; 1833 : 		fus6d.ay +
; 1834 : 		ht6d.ay;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+572]
	addss	xmm0, DWORD PTR [edx+540]
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+636]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+244], xmm0

; 1835 : 	F.az =
; 1836 : 		mr6d.az +
; 1837 : 		tr6d.az +
; 1838 : 		vt6d.az +
; 1839 : 		fus6d.az;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+576]
	addss	xmm0, DWORD PTR [eax+608]
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+672]
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+544]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+248], xmm0

; 1840 : 
; 1841 : 	// pitch and roll flap
; 1842 : 	F.a1 = GR.x/itb;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+452]
	divss	xmm0, DWORD PTR [edx+60]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+252], xmm0

; 1843 : 	F.b1 = GR.y/itb;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+456]
	divss	xmm0, DWORD PTR [edx+60]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+256], xmm0

; 1844 : 
; 1845 : 	// body accelerations
; 1846 : 	AB.x = -( VB.ay * VB.z - VB.az * VB.y ) + F.x/mass;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+308]
	mulss	xmm0, DWORD PTR [edx+300]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+312]
	mulss	xmm1, DWORD PTR [ecx+296]
	subss	xmm0, xmm1
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+228]
	divss	xmm1, DWORD PTR [eax+8]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+164], xmm0

; 1847 : 	AB.y =  ( VB.ax * VB.z - VB.az * VB.x ) + F.y/mass;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+304]
	mulss	xmm0, DWORD PTR [eax+300]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+312]
	mulss	xmm1, DWORD PTR [edx+292]
	subss	xmm0, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+232]
	divss	xmm1, DWORD PTR [ecx+8]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+168], xmm0

; 1848 : 	AB.z =  ( VB.ay * VB.x - VB.ax * VB.y ) + F.z/mass;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+308]
	mulss	xmm0, DWORD PTR [ecx+292]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+304]
	mulss	xmm1, DWORD PTR [eax+296]
	subss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+236]
	divss	xmm1, DWORD PTR [edx+8]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+172], xmm0

; 1849 : 	AB.ax = F.ax/md->fus.mi.x;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+240]
	divss	xmm0, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+176], xmm0

; 1850 : 	AB.ay = F.ay/md->fus.mi.y -
; 1851 : 				VB.ax * VB.az * ( md->fus.mi.x - md->fus.mi.z )/md->fus.mi.y +
; 1852 : 				(VB.az * VB.az - VB.ax * VB.ax ) * md->fus.mi_xz/md->fus.mi.y;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+244]
	divss	xmm0, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+304]
	mulss	xmm1, DWORD PTR [eax+312]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movss	xmm2, DWORD PTR [edx+24]
	subss	xmm2, DWORD PTR [ecx+32]
	mulss	xmm1, xmm2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	divss	xmm1, DWORD PTR [eax+28]
	subss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+312]
	mulss	xmm1, DWORD PTR [edx+312]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm2, DWORD PTR [eax+304]
	mulss	xmm2, DWORD PTR [ecx+304]
	subss	xmm1, xmm2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mulss	xmm1, DWORD PTR [eax+36]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	divss	xmm1, DWORD PTR [edx+28]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+180], xmm0

; 1853 : 	AB.az = F.az/md->fus.mi.z +
; 1854 : 				md->fus.mi_xz * AB.ax / md->fus.mi.z;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+248]
	divss	xmm0, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+36]
	mulss	xmm1, DWORD PTR [eax+176]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	divss	xmm1, DWORD PTR [edx+32]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+184], xmm0

; 1855 : 
; 1856 : 
; 1857 : 	// integrate body accelerations
; 1858 : 	VB.x = VB.x + dT * ( A1 * AB.x + B1 * ABprev.x );

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR ?A1@@3MA
	mulss	xmm0, DWORD PTR [ecx+164]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR ?B1@@3MA
	mulss	xmm1, DWORD PTR [edx+196]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+292]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+292], xmm0

; 1859 : 	VB.y = VB.y + dT * ( A1 * AB.y + B1 * ABprev.y );

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR ?A1@@3MA
	mulss	xmm0, DWORD PTR [eax+168]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR ?B1@@3MA
	mulss	xmm1, DWORD PTR [ecx+200]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+296]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+296], xmm0

; 1860 : 	VB.z = VB.z + dT * ( A1 * AB.z + B1 * ABprev.z );

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR ?A1@@3MA
	mulss	xmm0, DWORD PTR [edx+172]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR ?B1@@3MA
	mulss	xmm1, DWORD PTR [eax+204]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+300]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+300], xmm0

; 1861 : 
; 1862 : 	VB.ax = VB.ax + dT * ( A1 * AB.ax + B1 * ABprev.ax );

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR ?A1@@3MA
	mulss	xmm0, DWORD PTR [ecx+176]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR ?B1@@3MA
	mulss	xmm1, DWORD PTR [edx+208]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+304]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+304], xmm0

; 1863 : 	VB.ay = VB.ay + dT * ( A1 * AB.ay + B1 * ABprev.ay );

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR ?A1@@3MA
	mulss	xmm0, DWORD PTR [eax+180]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR ?B1@@3MA
	mulss	xmm1, DWORD PTR [ecx+212]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+308]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+308], xmm0

; 1864 : 	VB.az = VB.az + dT * ( A1 * AB.az + B1 * ABprev.az );

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR ?A1@@3MA
	mulss	xmm0, DWORD PTR [edx+184]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR ?B1@@3MA
	mulss	xmm1, DWORD PTR [eax+216]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+312]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+312], xmm0

; 1865 : 
; 1866 : 	// save previous
; 1867 : 	ABprev = AB;

	mov	esi, DWORD PTR _this$[ebp]
	add	esi, 164				; 000000a4H
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 196				; 000000c4H
	mov	ecx, 8
	rep movsd

; 1868 : 	ABprev.a1 = GR.x;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+452]
	mov	DWORD PTR [ecx+220], eax

; 1869 : 	ABprev.b1 = GR.y;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+456]
	mov	DWORD PTR [ecx+224], eax

; 1870 : 
; 1871 : 
; 1872 : 	VE.x = (VB.x * eucos.y + VB.z * eusin.y ) *
; 1873 : 				eucos.x * (float)cos( XE.az );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+292]
	mulss	xmm0, DWORD PTR [edx+144]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+300]
	mulss	xmm1, DWORD PTR [ecx+156]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [edx+140]
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm1, DWORD PTR [eax+440]
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv929[ebp], xmm0
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR tv834[ebp]
	movss	xmm0, DWORD PTR tv929[ebp]
	mulss	xmm0, DWORD PTR tv834[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+324], xmm0

; 1874 :    mlSinCos (&trig, XE.az);

	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+440]
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _trig$[ebp]
	push	eax
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 1875 : 	VE.y = VB.y * trig.cos + VB.x * trig.sin;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+296]
	mulss	xmm0, DWORD PTR _trig$[ebp+4]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+292]
	mulss	xmm1, DWORD PTR _trig$[ebp]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+328], xmm0

; 1876 : 	VE.z = -(VB.x * eusin.y - VB.z * eucos.y ) * eucos.x;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+292]
	mulss	xmm0, DWORD PTR [edx+156]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+300]
	mulss	xmm1, DWORD PTR [ecx+144]
	subss	xmm0, xmm1
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [edx+140]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+332], xmm0

; 1877 : 
; 1878 : 	CalcBodyOrientation();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalcBodyOrientation@HeliMMClass@@QAEXXZ ; HeliMMClass::CalcBodyOrientation

; 1879 : 
; 1880 : 	XE.x = XE.x + dT * TIME_CHEAT * ( A2 * VE.x + B2 * VEprev.x );

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+4]
	mulss	xmm0, DWORD PTR __real@3f800000
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR ?A2@@3MA
	mulss	xmm1, DWORD PTR [edx+324]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm2, DWORD PTR ?B2@@3MA
	mulss	xmm2, DWORD PTR [eax+356]
	addss	xmm1, xmm2
	mulss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+420]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+420], xmm0

; 1881 : 	XE.y = XE.y + dT * TIME_CHEAT * ( A2 * VE.y + B2 * VEprev.y );

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+4]
	mulss	xmm0, DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR ?A2@@3MA
	mulss	xmm1, DWORD PTR [ecx+328]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm2, DWORD PTR ?B2@@3MA
	mulss	xmm2, DWORD PTR [edx+360]
	addss	xmm1, xmm2
	mulss	xmm0, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+424]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+424], xmm0

; 1882 : 	XE.z = XE.z + dT * TIME_CHEAT * ( A2 * VE.z + B2 * VEprev.z );

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+4]
	mulss	xmm0, DWORD PTR __real@3f800000
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR ?A2@@3MA
	mulss	xmm1, DWORD PTR [eax+332]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm2, DWORD PTR ?B2@@3MA
	mulss	xmm2, DWORD PTR [ecx+364]
	addss	xmm1, xmm2
	mulss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+428]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+428], xmm0

; 1883 : 
; 1884 : 
; 1885 : 	// save previous
; 1886 : 	VEprev = VE;

	mov	esi, DWORD PTR _this$[ebp]
	add	esi, 324				; 00000144H
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 356				; 00000164H
	mov	ecx, 8
	rep movsd

; 1887 : 
; 1888 : 	// get sines and cosines
; 1889 :    mlSinCos (&trig, XE.ax); // Roll

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+432]
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR _trig$[ebp]
	push	edx
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 1890 :    eucos.x = trig.cos;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _trig$[ebp+4]
	movss	DWORD PTR [eax+140], xmm0

; 1891 :    eusin.x = trig.sin;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _trig$[ebp]
	movss	DWORD PTR [ecx+152], xmm0

; 1892 :    mlSinCos (&trig, XE.ay); // Pitch

	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+436]
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _trig$[ebp]
	push	eax
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 1893 :    eucos.y = trig.cos;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _trig$[ebp+4]
	movss	DWORD PTR [ecx+144], xmm0

; 1894 :    eusin.y = trig.sin;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _trig$[ebp]
	movss	DWORD PTR [edx+156], xmm0

; 1895 :    mlSinCos (&trig, XE.az); // Yaw

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+440]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _trig$[ebp]
	push	ecx
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 1896 :    eucos.z = trig.cos;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _trig$[ebp+4]
	movss	DWORD PTR [edx+148], xmm0

; 1897 :    eusin.z = trig.sin;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _trig$[ebp]
	movss	DWORD PTR [eax+160], xmm0

; 1898 : 
; 1899 : 	// get alpha and beta
; 1900 : 	alpha = (float)atan2( VB.z, VB.x ) * RTD;

	mov	ecx, DWORD PTR _this$[ebp]
	cvtss2sd xmm0, DWORD PTR [ecx+292]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+300]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	fstp	QWORD PTR tv916[ebp]
	movsd	xmm0, QWORD PTR tv916[ebp]
	cvtsd2ss xmm0, xmm0
	mulss	xmm0, DWORD PTR __real@42652ee1
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+800], xmm0

; 1901 : 	beta = (float)atan2( VB.y, VB.x ) * RTD;

	mov	ecx, DWORD PTR _this$[ebp]
	cvtss2sd xmm0, DWORD PTR [ecx+292]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+296]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	fstp	QWORD PTR tv925[ebp]
	movsd	xmm0, QWORD PTR tv925[ebp]
	cvtsd2ss xmm0, xmm0
	mulss	xmm0, DWORD PTR __real@42652ee1
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+804], xmm0

; 1902 : 
; 1903 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?ForceCalc@HeliMMClass@@QAEXXZ ENDP			; HeliMMClass::ForceCalc
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\helo\helimm.cpp
_TEXT	SEGMENT
tv283 = -32						; size = 4
tv297 = -28						; size = 4
tv295 = -24						; size = 4
tv274 = -20						; size = 4
tv267 = -16						; size = 4
_vta_wn$ = -12						; size = 4
_wa_wn$ = -8						; size = 4
_this$ = -4						; size = 4
?Wing@HeliMMClass@@QAEXXZ PROC				; HeliMMClass::Wing
; _this$ = ecx

; 1630 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 1631 : 	float wa_wn;
; 1632 : 	float vta_wn;
; 1633 : 
; 1634 : 	if ( md->has_wing == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN7@Wing

; 1635 : 	{
; 1636 : 		wn6d.z = 0;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+692], xmm0

; 1637 : 		wn6d.x = 0;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+684], xmm0

; 1638 : 		return;

	jmp	$LN8@Wing
$LN7@Wing:

; 1639 : 	}
; 1640 : 
; 1641 : 	// airflow (Z) velocity on ht
; 1642 : 	if ( md->type == STABLE )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx], 3
	jne	SHORT $LN6@Wing

; 1643 : 	{
; 1644 : 		wa_wn = VA.z;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+268]
	movss	DWORD PTR _wa_wn$[ebp], xmm0

; 1645 : 		vta_wn = (float)sqrt( va_x_sq + wa_wn * wa_wn );

	movss	xmm0, DWORD PTR _wa_wn$[ebp]
	mulss	xmm0, DWORD PTR _wa_wn$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+516]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR _vta_wn$[ebp]

; 1646 : 		wn6d.x = 0;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+684], xmm0

; 1647 : 	}
; 1648 : 	else

	jmp	$LN3@Wing
$LN6@Wing:

; 1649 : 	{
; 1650 : 		wa_wn = VA.z - vi_mr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+268]
	subss	xmm0, DWORD PTR [ecx+504]
	movss	DWORD PTR _wa_wn$[ebp], xmm0

; 1651 : 		vta_wn = (float)sqrt( va_x_sq + wa_wn * wa_wn );

	movss	xmm0, DWORD PTR _wa_wn$[ebp]
	mulss	xmm0, DWORD PTR _wa_wn$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+516]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR _vta_wn$[ebp]

; 1652 : 		// induced drag
; 1653 : 		if ( vta_wn != 0 )

	movss	xmm0, DWORD PTR _vta_wn$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN4@Wing

; 1654 : 			wn6d.x =
; 1655 : 				-(rh02) / PI / vta_wn / vta_wn *
; 1656 : 				( md->wn.zuu * va_x_sq +
; 1657 : 				  md->wn.zuw * ( VA.x ) * wa_wn ) *
; 1658 : 				( md->wn.zuu * va_x_sq +
; 1659 : 				  md->wn.zuw * ( VA.x ) * wa_wn ) ;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+44]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	divss	xmm0, DWORD PTR __real@40490fdb
	divss	xmm0, DWORD PTR _vta_wn$[ebp]
	divss	xmm0, DWORD PTR _vta_wn$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+156]
	mulss	xmm1, DWORD PTR [eax+516]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm2, DWORD PTR [eax+260]
	mulss	xmm2, DWORD PTR [edx+160]
	mulss	xmm2, DWORD PTR _wa_wn$[ebp]
	addss	xmm1, xmm2
	mulss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+156]
	mulss	xmm1, DWORD PTR [eax+516]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm2, DWORD PTR [eax+260]
	mulss	xmm2, DWORD PTR [edx+160]
	mulss	xmm2, DWORD PTR _wa_wn$[ebp]
	addss	xmm1, xmm2
	mulss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+684], xmm0

; 1660 : 		else

	jmp	SHORT $LN3@Wing
$LN4@Wing:

; 1661 : 			wn6d.x = 0;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+684], xmm0
$LN3@Wing:

; 1662 : 	}
; 1663 : 
; 1664 : 
; 1665 : 	// surface stalled?
; 1666 : 	if ( FABS( wa_wn ) > 0.3F * FABS( VA.x ) )

	push	ecx
	movss	xmm0, DWORD PTR _wa_wn$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?FABS@@YAMM@Z				; FABS
	add	esp, 4
	fstp	DWORD PTR tv267[ebp]
	movss	xmm0, DWORD PTR tv267[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm1, DWORD PTR [eax+260]
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv295[ebp], xmm0
	call	?FABS@@YAMM@Z				; FABS
	add	esp, 4
	fstp	DWORD PTR tv274[ebp]
	movss	xmm0, DWORD PTR tv274[ebp]
	mulss	xmm0, DWORD PTR __real@3e99999a
	movss	xmm1, DWORD PTR tv295[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN2@Wing

; 1667 : 		wn6d.z =
; 1668 : 			(rh02) *
; 1669 : 			md->wn.zmax * FABS( vta_wn ) * wa_wn;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+44]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mulss	xmm0, DWORD PTR [eax+164]
	push	ecx
	movss	xmm1, DWORD PTR _vta_wn$[ebp]
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv297[ebp], xmm0
	call	?FABS@@YAMM@Z				; FABS
	add	esp, 4
	fstp	DWORD PTR tv283[ebp]
	movss	xmm0, DWORD PTR tv297[ebp]
	mulss	xmm0, DWORD PTR tv283[ebp]
	mulss	xmm0, DWORD PTR _wa_wn$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+692], xmm0

; 1670 : 	else

	jmp	SHORT $LN1@Wing
$LN2@Wing:

; 1671 : 		// circulation lift on HT
; 1672 : 		wn6d.z =
; 1673 : 			(rh02) *
; 1674 : 			( md->wn.zuu * va_x_sq +
; 1675 : 			  md->wn.zuw * ( VA.x ) * wa_wn );

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+44]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+156]
	mulss	xmm1, DWORD PTR [edx+516]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm2, DWORD PTR [edx+260]
	mulss	xmm2, DWORD PTR [ecx+160]
	mulss	xmm2, DWORD PTR _wa_wn$[ebp]
	addss	xmm1, xmm2
	mulss	xmm0, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+692], xmm0
$LN1@Wing:
$LN8@Wing:

; 1676 : 
; 1677 : 
; 1678 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Wing@HeliMMClass@@QAEXXZ ENDP				; HeliMMClass::Wing
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\helo\helimm.cpp
_TEXT	SEGMENT
tv272 = -36						; size = 4
tv274 = -32						; size = 4
tv254 = -28						; size = 4
tv240 = -24						; size = 4
tv270 = -20						; size = 4
tv268 = -16						; size = 4
tv230 = -12						; size = 4
tv223 = -8						; size = 4
_this$ = -4						; size = 4
?VertTail@HeliMMClass@@QAEXXZ PROC			; HeliMMClass::VertTail
; _this$ = ecx

; 1755 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1756 : 	// airflow (Z) velocity on vt
; 1757 : 	if ( md->type == STABLE )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx], 3
	jne	SHORT $LN4@VertTail

; 1758 : 	{
; 1759 : 		// no tail rotor induced velocity effects on tail
; 1760 : 		va_vt = VA.y - ma_vt.x * VA.az;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+124]
	mulss	xmm0, DWORD PTR [eax+280]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+264]
	subss	xmm1, xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+780], xmm1

; 1761 : 	}
; 1762 : 	else

	jmp	SHORT $LN3@VertTail
$LN4@VertTail:

; 1763 : 	{
; 1764 : 		va_vt = VA.y + vi_tr - ma_vt.x * VA.az;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+264]
	addss	xmm0, DWORD PTR [ecx+760]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+124]
	mulss	xmm1, DWORD PTR [eax+280]
	subss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+780], xmm0
$LN3@VertTail:

; 1765 : 	}
; 1766 : 
; 1767 : 	// vta_vt = sqrt( va_x_sq + va_y_sq + va_vt * va_vt );
; 1768 : 	vta_vt = (float)sqrt( va_x_sq + va_vt * va_vt );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+780]
	mulss	xmm0, DWORD PTR [eax+780]
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+516]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+784]

; 1769 : 
; 1770 : 
; 1771 : 	// surface stalled?
; 1772 : 	if ( FABS( va_vt ) > 0.3F * FABS( VA.x ) )

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+780]
	movss	DWORD PTR [esp], xmm0
	call	?FABS@@YAMM@Z				; FABS
	add	esp, 4
	fstp	DWORD PTR tv223[ebp]
	movss	xmm0, DWORD PTR tv223[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm1, DWORD PTR [ecx+260]
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv268[ebp], xmm0
	call	?FABS@@YAMM@Z				; FABS
	add	esp, 4
	fstp	DWORD PTR tv230[ebp]
	movss	xmm0, DWORD PTR tv230[ebp]
	mulss	xmm0, DWORD PTR __real@3e99999a
	movss	xmm1, DWORD PTR tv268[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN2@VertTail

; 1773 : 		vt6d.y =
; 1774 : 			(rh02) *
; 1775 : 			md->vt.ymax * FABS( vta_vt ) * va_vt;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+44]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [ecx+212]
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm1, DWORD PTR [edx+784]
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv270[ebp], xmm0
	call	?FABS@@YAMM@Z				; FABS
	add	esp, 4
	fstp	DWORD PTR tv240[ebp]
	movss	xmm0, DWORD PTR tv270[ebp]
	mulss	xmm0, DWORD PTR tv240[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [eax+780]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+656], xmm0

; 1776 : 	else

	jmp	$LN1@VertTail
$LN2@VertTail:

; 1777 : 		// circulation lift on VT
; 1778 : 		vt6d.y =
; 1779 : 			(rh02) *
; 1780 : 			( md->vt.yuu * va_x_sq +
; 1781 : 			  md->vt.yuv * FABS( VA.x ) * va_vt );

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+44]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+204]
	mulss	xmm1, DWORD PTR [edx+516]
	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm2, DWORD PTR [ecx+260]
	movss	DWORD PTR [esp], xmm2
	movss	DWORD PTR tv272[ebp], xmm0
	movss	DWORD PTR tv274[ebp], xmm1
	call	?FABS@@YAMM@Z				; FABS
	add	esp, 4
	fstp	DWORD PTR tv254[ebp]
	movss	xmm0, DWORD PTR tv254[ebp]
	mulss	xmm0, DWORD PTR [esi+208]
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [edx+780]
	movss	xmm1, DWORD PTR tv274[ebp]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv272[ebp]
	mulss	xmm0, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+656], xmm0
$LN1@VertTail:

; 1782 : 
; 1783 : 	// rolling and yawing moment
; 1784 : 	vt6d.ax = vt6d.y * ma_vt.y;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+656]
	mulss	xmm0, DWORD PTR [edx+128]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+664], xmm0

; 1785 : 	vt6d.az = -vt6d.y * ma_vt.x;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+656]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [edx+124]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+672], xmm0

; 1786 : 
; 1787 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?VertTail@HeliMMClass@@QAEXXZ ENDP			; HeliMMClass::VertTail
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\helo\helimm.cpp
_TEXT	SEGMENT
tv353 = -40						; size = 4
tv355 = -36						; size = 4
tv339 = -32						; size = 4
tv325 = -28						; size = 4
tv351 = -24						; size = 4
tv349 = -20						; size = 4
tv315 = -16						; size = 4
tv308 = -12						; size = 4
_tmp1$ = -8						; size = 4
_this$ = -4						; size = 4
?HorizTail@HeliMMClass@@QAEXXZ PROC			; HeliMMClass::HorizTail
; _this$ = ecx

; 1687 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1688 : 	float tmp1;
; 1689 : 
; 1690 : 
; 1691 : 	// calc position of downwash on tail
; 1692 : 	if ( md->type == STABLE )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx], 3
	jne	SHORT $LN9@HorizTail

; 1693 : 	{
; 1694 : 		// airflow (Z) velocity on ht
; 1695 : 		// STABLE -- consider only rotational velocity
; 1696 : 		wa_ht = ma_ht.x * VA.ay;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+116]
	mulss	xmm0, DWORD PTR [eax+276]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+768], xmm0

; 1697 : 	}
; 1698 : 	else

	jmp	$LN8@HorizTail
$LN9@HorizTail:

; 1699 : 	{
; 1700 : 		tmp1 = vi_mr - VA.z;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+504]
	subss	xmm0, DWORD PTR [eax+268]
	movss	DWORD PTR _tmp1$[ebp], xmm0

; 1701 : 		if ( tmp1 == 0 )

	movss	xmm0, DWORD PTR _tmp1$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN7@HorizTail

; 1702 : 		{
; 1703 : 			dw_ht_pos = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+764], xmm0

; 1704 : 		}
; 1705 : 		else

	jmp	SHORT $LN5@HorizTail
$LN7@HorizTail:

; 1706 : 		{
; 1707 : 			dw_ht_pos =
; 1708 : 				( VA.x / (tmp1) * ( ma_hub.y - ma_ht.y ) ) -
; 1709 : 				( ma_ht.x - ma_hub.x - md->mr.radius );

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+260]
	divss	xmm0, DWORD PTR _tmp1$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+96]
	subss	xmm1, DWORD PTR [ecx+120]
	mulss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+116]
	subss	xmm1, DWORD PTR [eax+92]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	subss	xmm1, DWORD PTR [edx+80]
	subss	xmm0, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+764], xmm0

; 1710 : 		
; 1711 : 			// empirical hack
; 1712 : 			if ( md->type == A109 )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN5@HorizTail

; 1713 : 				dw_ht_pos += 1;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+764]
	addss	xmm0, DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+764], xmm0
$LN5@HorizTail:

; 1714 : 		}
; 1715 : 
; 1716 : 		// trianglur downwash field
; 1717 : 		if ( dw_ht_pos > 0 && dw_ht_pos < md->mr.radius )

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+764]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN4@HorizTail
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+80]
	comiss	xmm0, DWORD PTR [edx+764]
	jbe	SHORT $LN4@HorizTail

; 1718 : 			eps_ht = 2.0F * ( 1 - dw_ht_pos/md->mr.radius );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+764]
	divss	xmm0, DWORD PTR [ecx+80]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	mulss	xmm1, DWORD PTR __real@40000000
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+772], xmm1

; 1719 : 		else

	jmp	SHORT $LN3@HorizTail
$LN4@HorizTail:

; 1720 : 			eps_ht = 0.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+772], xmm0
$LN3@HorizTail:

; 1721 : 
; 1722 : 		// airflow (Z) velocity on ht
; 1723 : 		wa_ht = VA.z -
; 1724 : 					eps_ht * vi_mr +
; 1725 : 					ma_ht.x * VA.ay;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+772]
	mulss	xmm0, DWORD PTR [eax+504]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+268]
	subss	xmm1, xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+116]
	mulss	xmm0, DWORD PTR [eax+276]
	addss	xmm1, xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+768], xmm1
$LN8@HorizTail:

; 1726 : 	
; 1727 : 	}
; 1728 : 
; 1729 : 	// total tail rel air velocity
; 1730 : 	vta_ht = (float)sqrt( va_x_sq + va_y_sq + wa_ht * wa_ht );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+516]
	addss	xmm0, DWORD PTR [eax+520]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+768]
	mulss	xmm1, DWORD PTR [edx+768]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+776]

; 1731 : 
; 1732 : 
; 1733 : 	// surface stalled?
; 1734 : 	if ( FABS( wa_ht ) > 0.3F * FABS( VA.x ) )

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+768]
	movss	DWORD PTR [esp], xmm0
	call	?FABS@@YAMM@Z				; FABS
	add	esp, 4
	fstp	DWORD PTR tv308[ebp]
	movss	xmm0, DWORD PTR tv308[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm1, DWORD PTR [edx+260]
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv349[ebp], xmm0
	call	?FABS@@YAMM@Z				; FABS
	add	esp, 4
	fstp	DWORD PTR tv315[ebp]
	movss	xmm0, DWORD PTR tv315[ebp]
	mulss	xmm0, DWORD PTR __real@3e99999a
	movss	xmm1, DWORD PTR tv349[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN2@HorizTail

; 1735 : 		ht6d.z = (rh02) * md->ht.zmax * FABS( vta_ht ) * wa_ht;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+44]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR [edx+188]
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm1, DWORD PTR [eax+776]
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv351[ebp], xmm0
	call	?FABS@@YAMM@Z				; FABS
	add	esp, 4
	fstp	DWORD PTR tv325[ebp]
	movss	xmm0, DWORD PTR tv351[ebp]
	mulss	xmm0, DWORD PTR tv325[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [ecx+768]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+628], xmm0

; 1736 : 	else

	jmp	$LN1@HorizTail
$LN2@HorizTail:

; 1737 : 		// circulation lift on HT
; 1738 : 		ht6d.z =
; 1739 : 			(rh02) *
; 1740 : 			( md->ht.zuu * va_x_sq +
; 1741 : 			  md->ht.zuw * FABS( VA.x ) * wa_ht );

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+44]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+180]
	mulss	xmm1, DWORD PTR [eax+516]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm2, DWORD PTR [edx+260]
	movss	DWORD PTR [esp], xmm2
	movss	DWORD PTR tv353[ebp], xmm0
	movss	DWORD PTR tv355[ebp], xmm1
	call	?FABS@@YAMM@Z				; FABS
	add	esp, 4
	fstp	DWORD PTR tv339[ebp]
	movss	xmm0, DWORD PTR tv339[ebp]
	mulss	xmm0, DWORD PTR [esi+184]
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [eax+768]
	movss	xmm1, DWORD PTR tv355[ebp]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv353[ebp]
	mulss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+628], xmm0
$LN1@HorizTail:

; 1742 : 
; 1743 : 	// pitching moment
; 1744 : 	ht6d.ay = ht6d.z * ma_ht.x;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+628]
	mulss	xmm0, DWORD PTR [eax+116]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+636], xmm0

; 1745 : 
; 1746 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?HorizTail@HeliMMClass@@QAEXXZ ENDP			; HeliMMClass::HorizTail
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\helo\helimm.cpp
_TEXT	SEGMENT
_vi_sq$ = -36						; size = 4
tv336 = -32						; size = 4
_tmp2$ = -28						; size = 4
_tmp1$ = -24						; size = 4
_vhat_sq$ = -20						; size = 4
_i$ = -16						; size = 4
_tmp4$ = -12						; size = 4
_tmp3$ = -8						; size = 4
_this$ = -4						; size = 4
?TailRotor@HeliMMClass@@QAEXXZ PROC			; HeliMMClass::TailRotor
; _this$ = ecx

; 1551 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 1552 : 	int i;
; 1553 : 	float tmp1;
; 1554 : 	float tmp2;
; 1555 : 	float tmp3;
; 1556 : 	float tmp4;
; 1557 : 	float vhat_sq;
; 1558 : 	float vi_sq;
; 1559 : 
; 1560 : 	// get velocities relative to rotor plane and blade
; 1561 : 	// collective setting gets factored in here
; 1562 : 	if ( md->type == SIMPLE )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx], 4
	jne	$LN5@TailRotor

; 1563 : 	{
; 1564 : 		// STABLE model just calculates thrust based on some constant
; 1565 : 		// force times the +/- % of pedal settings
; 1566 : 
; 1567 : 		// no tail induced flow
; 1568 : 		vi_tr = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+760], xmm0

; 1569 : 
; 1570 : 		// thrust
; 1571 : 		thrust_tr = 130.0F * ctltpitch;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@43020000
	mulss	xmm0, DWORD PTR [eax+1072]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+756], xmm0

; 1572 : 
; 1573 : 		// no sideslip effect of tail
; 1574 : 		tr6d.y = 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+592], xmm0

; 1575 : 
; 1576 : 		// no roll effect of tail
; 1577 : 		tr6d.ax = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+600], xmm0

; 1578 : 
; 1579 : 		// yaw
; 1580 : 		tr6d.az = -thrust_tr * ma_tr.x;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+756]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [edx+132]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+608], xmm0

; 1581 : 	}
; 1582 : 	else

	jmp	$LN4@TailRotor
$LN5@TailRotor:

; 1583 : 	{
; 1584 : 		// relative wind on tail rotor
; 1585 : 		vr_tr = -(VA.y -
; 1586 : 				  VA.az * ma_tr.x +
; 1587 : 				  VA.ax * ma_tr.y );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+280]
	mulss	xmm0, DWORD PTR [edx+132]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+264]
	subss	xmm1, xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+272]
	mulss	xmm0, DWORD PTR [edx+136]
	addss	xmm1, xmm0
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+748], xmm1

; 1588 : 		vb_tr = vr_tr +
; 1589 : 				 2.0F/3.0F * omega_tr * md->tr.radius *
; 1590 : 				 (tr_pitch + 0.75F * md->tr.twist );

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f2aaaab
	mulss	xmm0, DWORD PTR [ecx+16]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mulss	xmm0, DWORD PTR [eax+120]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	movss	xmm1, DWORD PTR __real@3f400000
	mulss	xmm1, DWORD PTR [edx+132]
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm1, DWORD PTR [eax+480]
	mulss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+748]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+752], xmm0

; 1591 : 	
; 1592 : 	
; 1593 : 		// pre-calc some values
; 1594 : 		tmp1 = omega_tr * md->tr.radius * rh0 * md->tr.lslope *
; 1595 : 			   md->tr.solidity * PI * md->tr.radius * md->tr.radius/4;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+16]
	mulss	xmm0, DWORD PTR [ecx+120]
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [eax+40]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR [edx+124]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [ecx+136]
	mulss	xmm0, DWORD PTR __real@40490fdb
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mulss	xmm0, DWORD PTR [eax+120]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR [edx+120]
	divss	xmm0, DWORD PTR __real@40800000
	movss	DWORD PTR _tmp1$[ebp], xmm0

; 1596 : 		tmp2 = md->tr.radius * rh0 * md->tr.radius * PI;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+120]
	mulss	xmm0, DWORD PTR [edx+40]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [ecx+120]
	mulss	xmm0, DWORD PTR __real@40490fdb
	movss	DWORD PTR _tmp2$[ebp], xmm0

; 1597 : 		tmp4 = VA.z + VA.ay * ma_tr.x;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+276]
	mulss	xmm0, DWORD PTR [eax+132]
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+268]
	movss	DWORD PTR _tmp4$[ebp], xmm0

; 1598 : 		tmp4 *= tmp4;

	movss	xmm0, DWORD PTR _tmp4$[ebp]
	mulss	xmm0, DWORD PTR _tmp4$[ebp]
	movss	DWORD PTR _tmp4$[ebp], xmm0

; 1599 : 	
; 1600 : 		// iterative solution for thrust and induced velocity
; 1601 : 		for ( i = 0; i < numRotorIterations; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@TailRotor
$LN2@TailRotor:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN3@TailRotor:
	cmp	DWORD PTR _i$[ebp], 4
	jge	$LN1@TailRotor

; 1602 : 		{
; 1603 : 			thrust_tr = ( vb_tr - vi_tr ) * tmp1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+752]
	subss	xmm0, DWORD PTR [ecx+760]
	mulss	xmm0, DWORD PTR _tmp1$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+756], xmm0

; 1604 : 			vhat_sq = tmp4 + va_x_sq + vr_tr * ( vr_tr - 2 * vi_tr );

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _tmp4$[ebp]
	addss	xmm0, DWORD PTR [eax+516]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR __real@40000000
	mulss	xmm1, DWORD PTR [ecx+760]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm2, DWORD PTR [edx+748]
	subss	xmm2, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm2, DWORD PTR [eax+748]
	addss	xmm0, xmm2
	movss	DWORD PTR _vhat_sq$[ebp], xmm0

; 1605 : 			tmp3 = thrust_tr/2.0F/tmp2;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+756]
	divss	xmm0, DWORD PTR __real@40000000
	divss	xmm0, DWORD PTR _tmp2$[ebp]
	movss	DWORD PTR _tmp3$[ebp], xmm0

; 1606 : 			tmp3 *= tmp3;

	movss	xmm0, DWORD PTR _tmp3$[ebp]
	mulss	xmm0, DWORD PTR _tmp3$[ebp]
	movss	DWORD PTR _tmp3$[ebp], xmm0

; 1607 : 			tmp3 += (vhat_sq/2.0F) * (vhat_sq/2.0F);

	movss	xmm0, DWORD PTR _vhat_sq$[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR _vhat_sq$[ebp]
	divss	xmm1, DWORD PTR __real@40000000
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR _tmp3$[ebp]
	movss	DWORD PTR _tmp3$[ebp], xmm0

; 1608 : 			vi_sq = (float)sqrt( tmp3 ) - vhat_sq/2.0F;

	push	ecx
	movss	xmm0, DWORD PTR _tmp3$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR tv336[ebp]
	movss	xmm0, DWORD PTR tv336[ebp]
	movss	xmm1, DWORD PTR _vhat_sq$[ebp]
	divss	xmm1, DWORD PTR __real@40000000
	subss	xmm0, xmm1
	movss	DWORD PTR _vi_sq$[ebp], xmm0

; 1609 : 			vi_tr = (float)sqrt( FABS( vi_sq ) );

	push	ecx
	movss	xmm0, DWORD PTR _vi_sq$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?FABS@@YAMM@Z				; FABS
	fstp	DWORD PTR [esp]
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+760]

; 1610 : 		}

	jmp	$LN2@TailRotor
$LN1@TailRotor:

; 1611 : 	
; 1612 : 		// power calc
; 1613 : 		p_tr = thrust_tr * vi_tr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+756]
	mulss	xmm0, DWORD PTR [ecx+760]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+740], xmm0

; 1614 : 	
; 1615 : 		// force and moment calc
; 1616 : 		tr6d.y = thrust_tr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+756]
	mov	DWORD PTR [eax+592], edx

; 1617 : 		tr6d.ax = tr6d.y * ma_tr.y;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+592]
	mulss	xmm0, DWORD PTR [ecx+136]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+600], xmm0

; 1618 : 		tr6d.az = -tr6d.y * ma_tr.x;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+592]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [ecx+132]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+608], xmm0
$LN4@TailRotor:

; 1619 : 	}
; 1620 : 
; 1621 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?TailRotor@HeliMMClass@@QAEXXZ ENDP			; HeliMMClass::TailRotor
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\helo\helimm.cpp
_TEXT	SEGMENT
tv440 = -12						; size = 4
_om_radius$ = -8					; size = 4
_this$ = -4						; size = 4
?Fuselage@HeliMMClass@@QAEXXZ PROC			; HeliMMClass::Fuselage
; _this$ = ecx

; 1440 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1441 : 	float om_radius;
; 1442 : 
; 1443 : 	if ( md->type == STABLE )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx], 3
	jne	SHORT $LN8@Fuselage

; 1444 : 	{
; 1445 : 		// STABLE: no download effect on fuselage
; 1446 : 		wa_fus = 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+508], xmm0

; 1447 : 		wa_fus_pos = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+512], xmm0

; 1448 : 	}
; 1449 : 	else

	jmp	$LN5@Fuselage
$LN8@Fuselage:

; 1450 : 	{
; 1451 : 		// calc the downwash on the fuselage
; 1452 : 		wa_fus = VA.z - vi_mr;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+268]
	subss	xmm0, DWORD PTR [edx+504]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+508], xmm0

; 1453 : 	
; 1454 : 		// calc position on fuselage
; 1455 : 		if ( wa_fus != 0 )

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+508]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN6@Fuselage

; 1456 : 			wa_fus_pos =
; 1457 : 				( VA.x/ (-wa_fus) * ( ma_hub.y - ma_fus.y ) ) -
; 1458 : 				( ma_fus.x - ma_hub.x );

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+508]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+260]
	divss	xmm1, xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+96]
	subss	xmm0, DWORD PTR [edx+104]
	mulss	xmm1, xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+100]
	subss	xmm0, DWORD PTR [ecx+92]
	subss	xmm1, xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+512], xmm1

; 1459 : 		else

	jmp	SHORT $LN5@Fuselage
$LN6@Fuselage:

; 1460 : 			wa_fus_pos = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+512], xmm0
$LN5@Fuselage:

; 1461 : 	}
; 1462 : 
; 1463 : 	// empirical hack
; 1464 : 	// don't use for now
; 1465 : 	// wa_fus_pos *= 3.0;
; 1466 : 
; 1467 : 	// compute the forces and moments on the fuselage
; 1468 : 	fus6d.x = (rh02) * md->fus.fe.x * va_x_sq;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+44]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mulss	xmm0, DWORD PTR [eax+48]
	mov	ecx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [ecx+516]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+524], xmm0

; 1469 : 	fus6d.y = (rh02) * md->fus.fe.y * va_y_sq;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+44]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR [edx+52]
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [eax+520]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+528], xmm0

; 1470 : 	fus6d.z = (rh02) * md->fus.fe.z * wa_fus * wa_fus;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+44]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [ecx+56]
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [edx+508]
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [eax+508]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+532], xmm0

; 1471 : 	fus6d.ax = fus6d.y * ma_fus.y;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+528]
	mulss	xmm0, DWORD PTR [eax+104]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+536], xmm0

; 1472 : 	fus6d.ay = fus6d.z * wa_fus_pos -
; 1473 : 				   fus6d.x * ma_fus.y;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+532]
	mulss	xmm0, DWORD PTR [eax+512]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+524]
	mulss	xmm1, DWORD PTR [edx+104]
	subss	xmm0, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+540], xmm0

; 1474 : 
; 1475 : 	// drag of fuselage based on velocity^2 of rotation and mass
; 1476 : 	fus6d.az = -(float)fabs(VB.az) * VB.az * 0.004f * mass;

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+312]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv440[ebp]
	movss	xmm0, DWORD PTR tv440[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [edx+312]
	mulss	xmm0, DWORD PTR __real@3b83126f
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+544], xmm0

; 1477 : 
; 1478 : 
; 1479 : 	// compute forces and moments of the main rotor
; 1480 : 	mr6d.x = -thrust_mr * ( GV.x - md->mr.hub_is );

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+500]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+460]
	subss	xmm1, DWORD PTR [ecx+68]
	mulss	xmm0, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+556], xmm0

; 1481 : 	mr6d.y = thrust_mr * ( GV.y );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+464]
	mulss	xmm0, DWORD PTR [edx+500]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+560], xmm0

; 1482 : 	mr6d.z = -thrust_mr;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+500]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+564], xmm0

; 1483 : 	mr6d.ax = mr6d.y * ma_hub.y +
; 1484 : 				  dl_db1 * GV.y +
; 1485 : 				  dl_da1 * (GV.x + cyc_roll - md->mr.k1 * GV.y );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+560]
	mulss	xmm0, DWORD PTR [ecx+96]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+64]
	mulss	xmm1, DWORD PTR [eax+464]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+460]
	addss	xmm1, DWORD PTR [edx+476]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm2, DWORD PTR [ecx+108]
	mulss	xmm2, DWORD PTR [edx+464]
	subss	xmm1, xmm2
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm1, DWORD PTR [eax+68]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+568], xmm0

; 1486 : 	mr6d.ay = mr6d.z * ma_hub.x -
; 1487 : 				  mr6d.x * ma_hub.y +
; 1488 : 				  dl_db1 * GV.x +
; 1489 : 				  dl_da1 * (-GV.y + cyc_pitch - md->mr.k1 * GV.x );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+564]
	mulss	xmm0, DWORD PTR [eax+92]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+556]
	mulss	xmm1, DWORD PTR [edx+96]
	subss	xmm0, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+64]
	mulss	xmm1, DWORD PTR [ecx+460]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+464]
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm1, DWORD PTR [eax+472]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm2, DWORD PTR [edx+108]
	mulss	xmm2, DWORD PTR [eax+460]
	subss	xmm1, xmm2
	mov	ecx, DWORD PTR _this$[ebp]
	mulss	xmm1, DWORD PTR [ecx+68]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+572], xmm0

; 1490 : 
; 1491 : 	// power calcs
; 1492 : 	p_ind = thrust_mr * vi_mr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+500]
	mulss	xmm0, DWORD PTR [ecx+504]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+716], xmm0

; 1493 : 
; 1494 : 	// not sure about this one.  Paper calcs as WT*HDOT but HDOT is
; 1495 : 	// never defined anywhere.  I assume it's the rate of climb which
; 1496 : 	// should be VE.z
; 1497 : 	p_climb = md->fus.weight * VE.z;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+20]
	mulss	xmm0, DWORD PTR [edx+332]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+720], xmm0

; 1498 : 
; 1499 : 	p_par = - fus6d.x * VA.x -
; 1500 : 				  fus6d.y * VA.y -
; 1501 : 				  fus6d.z * wa_fus;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+524]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [edx+260]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+528]
	mulss	xmm1, DWORD PTR [ecx+264]
	subss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+532]
	mulss	xmm1, DWORD PTR [eax+508]
	subss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+724], xmm0

; 1502 : 
; 1503 : 	om_radius = omega_mr * md->mr.radius;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+12]
	mulss	xmm0, DWORD PTR [eax+80]
	movss	DWORD PTR _om_radius$[ebp], xmm0

; 1504 : 
; 1505 : 	p_prof = (rh02) *
; 1506 : 				 (fr_mr/4.0F) *
; 1507 : 				 om_radius *
; 1508 : 				 ( om_radius * om_radius + 4.6F *
; 1509 : 				 ( va_x_sq + va_y_sq ) );

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+44]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+24]
	divss	xmm1, DWORD PTR __real@40800000
	mulss	xmm0, xmm1
	mulss	xmm0, DWORD PTR _om_radius$[ebp]
	movss	xmm1, DWORD PTR _om_radius$[ebp]
	mulss	xmm1, DWORD PTR _om_radius$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm2, DWORD PTR [ecx+516]
	addss	xmm2, DWORD PTR [edx+520]
	mulss	xmm2, DWORD PTR __real@40933333
	addss	xmm1, xmm2
	mulss	xmm0, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+728], xmm0

; 1510 : 
; 1511 : 	p_tot = p_ind + p_climb + p_par + p_prof;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+716]
	addss	xmm0, DWORD PTR [edx+720]
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+724]
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+728]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+732], xmm0

; 1512 : 
; 1513 : 	p_mr = p_ind + p_prof;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+716]
	addss	xmm0, DWORD PTR [ecx+728]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+736], xmm0

; 1514 : 
; 1515 : 	// main rotor torque
; 1516 : 	torque_mr = p_tot/omega_mr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+732]
	divss	xmm0, DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+744], xmm0

; 1517 : 
; 1518 : 	// hack -- not sure what's coming out, but torque should always
; 1519 : 	// have same sign
; 1520 : 	// if ( torque_mr > 0.0f )
; 1521 : 	// 		torque_mr = -torque_mr;
; 1522 : 
; 1523 : 
; 1524 : 	mr6d.az = torque_mr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+744]
	mov	DWORD PTR [eax+576], edx

; 1525 : 
; 1526 : 	// all models reduce torque -- it's just too much
; 1527 : 	// for STABLE type, no/lessen rotor torque
; 1528 : 	if ( md->type == STABLE )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx], 3
	jne	SHORT $LN4@Fuselage

; 1529 : 	{
; 1530 : 		mr6d.az *= 0.20f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+576]
	mulss	xmm0, DWORD PTR __real@3e4ccccd
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+576], xmm0
	jmp	SHORT $LN1@Fuselage
$LN4@Fuselage:

; 1531 : 	}
; 1532 : 	else if ( md->type == COBRA )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx], 1
	jne	SHORT $LN2@Fuselage

; 1533 : 	{
; 1534 : 		mr6d.az *= 0.53f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+576]
	mulss	xmm0, DWORD PTR __real@3f07ae14
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+576], xmm0

; 1535 : 	}
; 1536 : 	else 

	jmp	SHORT $LN1@Fuselage
$LN2@Fuselage:

; 1537 : 	{
; 1538 : 		mr6d.az *= 0.53f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+576]
	mulss	xmm0, DWORD PTR __real@3f07ae14
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+576], xmm0
$LN1@Fuselage:

; 1539 : 	}
; 1540 : 
; 1541 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Fuselage@HeliMMClass@@QAEXXZ ENDP			; HeliMMClass::Fuselage
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\helo\helimm.cpp
_TEXT	SEGMENT
_vi_sq$ = -24						; size = 4
tv264 = -20						; size = 4
_vhat_sq$ = -16						; size = 4
_i$ = -12						; size = 4
_tmp3$ = -8						; size = 4
_this$ = -4						; size = 4
?MainRotor@HeliMMClass@@QAEXXZ PROC			; HeliMMClass::MainRotor
; _this$ = ecx

; 1377 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1378 : 	int i;
; 1379 : 	float tmp3;
; 1380 : 	float vhat_sq;
; 1381 : 	float vi_sq;
; 1382 : 
; 1383 : 	// STABLE model: no induced flow effects.  Just calculate thrust
; 1384 : 	// as a percent of throttle setting based on weight of fuselage
; 1385 : 	if ( md->type == SIMPLE )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx], 4
	jne	SHORT $LN5@MainRotor

; 1386 : 	{
; 1387 : 		// no induced flow
; 1388 : 		vi_mr = 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+504], xmm0

; 1389 : 		thrust_mr = (md->fus.weight * 1.5F) * ctlcpitch;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movss	xmm0, DWORD PTR [ecx+20]
	mulss	xmm0, DWORD PTR __real@3fc00000
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [edx+1068]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+500], xmm0

; 1390 : 	}
; 1391 : 	else

	jmp	$LN1@MainRotor
$LN5@MainRotor:

; 1392 : 	{
; 1393 : 		// get velocities relative to rotor plane and blade
; 1394 : 		// collective setting gets factored in here
; 1395 : 		wr = VA.z +
; 1396 : 				(GV.x - md->mr.hub_is) * VA.x -
; 1397 : 				GV.y * VA.y;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+460]
	subss	xmm0, DWORD PTR [edx+68]
	mov	ecx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [ecx+260]
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+268]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+464]
	mulss	xmm1, DWORD PTR [ecx+264]
	subss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+492], xmm0

; 1398 : 		wb = wr +
; 1399 : 				 (2.0F/3.0F) * omega_mr * md->mr.radius *
; 1400 : 				 (coll_pitch + 0.75F * md->mr.twist );

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f2aaaab
	mulss	xmm0, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR [edx+80]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movss	xmm1, DWORD PTR __real@3f400000
	mulss	xmm1, DWORD PTR [ecx+104]
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm1, DWORD PTR [edx+468]
	mulss	xmm0, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+492]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+496], xmm0

; 1401 : 	
; 1402 : 		va_x_sq = VA.x * VA.x;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+260]
	mulss	xmm0, DWORD PTR [eax+260]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+516], xmm0

; 1403 : 		va_y_sq = VA.y * VA.y;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+264]
	mulss	xmm0, DWORD PTR [eax+264]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+520], xmm0

; 1404 : 	
; 1405 : 		// iterative solution for thrust and induced velocity
; 1406 : 		for ( i = 0; i < numRotorIterations; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@MainRotor
$LN2@MainRotor:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN3@MainRotor:
	cmp	DWORD PTR _i$[ebp], 4
	jge	$LN1@MainRotor

; 1407 : 		{
; 1408 : 			thrust_mr = ( wb - vi_mr ) * mr_tmp1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+496]
	subss	xmm0, DWORD PTR [ecx+504]
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [edx+1076]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+500], xmm0

; 1409 : 			vhat_sq = va_x_sq + va_y_sq + wr * ( wr - 2 * vi_mr );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+516]
	addss	xmm0, DWORD PTR [edx+520]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR __real@40000000
	mulss	xmm1, DWORD PTR [eax+504]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm2, DWORD PTR [ecx+492]
	subss	xmm2, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm2, DWORD PTR [edx+492]
	addss	xmm0, xmm2
	movss	DWORD PTR _vhat_sq$[ebp], xmm0

; 1410 : 			tmp3 = thrust_mr/2.0F/mr_tmp2;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+500]
	divss	xmm0, DWORD PTR __real@40000000
	mov	ecx, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [ecx+1080]
	movss	DWORD PTR _tmp3$[ebp], xmm0

; 1411 : 			tmp3 *= tmp3;

	movss	xmm0, DWORD PTR _tmp3$[ebp]
	mulss	xmm0, DWORD PTR _tmp3$[ebp]
	movss	DWORD PTR _tmp3$[ebp], xmm0

; 1412 : 			tmp3 += (vhat_sq/2.0F) * (vhat_sq/2.0F);

	movss	xmm0, DWORD PTR _vhat_sq$[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR _vhat_sq$[ebp]
	divss	xmm1, DWORD PTR __real@40000000
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR _tmp3$[ebp]
	movss	DWORD PTR _tmp3$[ebp], xmm0

; 1413 : 			vi_sq = (float)sqrt( tmp3 ) - vhat_sq/2.0F;

	push	ecx
	movss	xmm0, DWORD PTR _tmp3$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR tv264[ebp]
	movss	xmm0, DWORD PTR tv264[ebp]
	movss	xmm1, DWORD PTR _vhat_sq$[ebp]
	divss	xmm1, DWORD PTR __real@40000000
	subss	xmm0, xmm1
	movss	DWORD PTR _vi_sq$[ebp], xmm0

; 1414 : 			vi_mr = (float)sqrt( FABS( vi_sq ) );

	push	ecx
	movss	xmm0, DWORD PTR _vi_sq$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?FABS@@YAMM@Z				; FABS
	fstp	DWORD PTR [esp]
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+504]

; 1415 : 		}

	jmp	$LN2@MainRotor
$LN1@MainRotor:

; 1416 : 	}
; 1417 : 
; 1418 : 	// hack for upsidedown flight
; 1419 : 	// for some reason the main rotor thrust isn't working right when
; 1420 : 	// inverted.  Check when we are inverted and reduce thrust proprtional
; 1421 : 	// to our inverted amount
; 1422 : 	/*
; 1423 : 	if ( eucos.x < 0.0f )
; 1424 : 		thrust_mr *= (1.0f + eucos.x) * 0.50f;
; 1425 : 	*/
; 1426 : 
; 1427 : 
; 1428 : 
; 1429 : 	// if ( thrust_mr < 0.0f )
; 1430 : 	//	thrust_mr = -thrust_mr;
; 1431 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?MainRotor@HeliMMClass@@QAEXXZ ENDP			; HeliMMClass::MainRotor
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\helo\helimm.cpp
_TEXT	SEGMENT
_wake_effect$ = -8					; size = 4
_this$ = -4						; size = 4
?TipPlanePath@HeliMMClass@@QAEXXZ PROC			; HeliMMClass::TipPlanePath
; _this$ = ecx

; 1326 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1327 : 	float wake_effect;
; 1328 : 
; 1329 : 	// if velocity in X is within a range, use a wake effect
; 1330 : 	if ( VA.x < vtrans )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+36]
	comiss	xmm0, DWORD PTR [ecx+260]
	jbe	SHORT $LN2@TipPlanePa

; 1331 : 		wake_effect = 1;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _wake_effect$[ebp], xmm0

; 1332 : 	else

	jmp	SHORT $LN1@TipPlanePa
$LN2@TipPlanePa:

; 1333 : 		wake_effect = 0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _wake_effect$[ebp], xmm0
$LN1@TipPlanePa:

; 1334 : 
; 1335 : 	// empirical hack not in cobra
; 1336 : 	// don't use this for either now -- it's fucked up
; 1337 : 	wake_effect = 0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _wake_effect$[ebp], xmm0

; 1338 : 
; 1339 : 
; 1340 : 	// these 2 statements read the cyclic control and
; 1341 : 	// dihedral effect based slip and aoa
; 1342 : 	a_sum = GV.y - cyc_pitch +
; 1343 : 				kC * GV.x +
; 1344 : 				db1dv * VA.y * ( 1.0F + wake_effect );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+464]
	subss	xmm0, DWORD PTR [eax+472]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+52]
	mulss	xmm1, DWORD PTR [edx+460]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+80]
	mulss	xmm1, DWORD PTR [ecx+264]
	movss	xmm2, DWORD PTR __real@3f800000
	addss	xmm2, DWORD PTR _wake_effect$[ebp]
	mulss	xmm1, xmm2
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+484], xmm0

; 1345 : 
; 1346 : 	b_sum = GV.x + cyc_roll -
; 1347 : 				kC * GV.y +
; 1348 : 				da1du * VA.x * ( 1.0F + 2.0F * wake_effect );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+460]
	addss	xmm0, DWORD PTR [ecx+476]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+52]
	mulss	xmm1, DWORD PTR [eax+464]
	subss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+84]
	mulss	xmm1, DWORD PTR [edx+260]
	movss	xmm2, DWORD PTR __real@40000000
	mulss	xmm2, DWORD PTR _wake_effect$[ebp]
	addss	xmm2, DWORD PTR __real@3f800000
	mulss	xmm1, xmm2
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+488], xmm0

; 1349 : 
; 1350 : 	GR.x = -itb * b_sum -
; 1351 : 				itb2_om * a_sum -
; 1352 : 				VA.ay;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+60]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [edx+488]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+56]
	mulss	xmm1, DWORD PTR [ecx+484]
	subss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	subss	xmm0, DWORD PTR [edx+276]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+452], xmm0

; 1353 : 	GR.y = -itb * a_sum +
; 1354 : 				itb2_om * b_sum -
; 1355 : 				VA.ax;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+60]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [edx+484]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+56]
	mulss	xmm1, DWORD PTR [ecx+488]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	subss	xmm0, DWORD PTR [edx+272]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+456], xmm0

; 1356 : 
; 1357 : 	GV.x = GV.x +
; 1358 : 			   dT * (A2 * GR.x +
; 1359 : 			   B2 * ABprev.a1);

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR ?A2@@3MA
	mulss	xmm0, DWORD PTR [ecx+452]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR ?B2@@3MA
	mulss	xmm1, DWORD PTR [edx+220]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+460]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+460], xmm0

; 1360 : 	GV.y = GV.y +
; 1361 : 			   dT * (A2 * GR.y +
; 1362 : 			   B2 * ABprev.b1);

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR ?A2@@3MA
	mulss	xmm0, DWORD PTR [eax+456]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR ?B2@@3MA
	mulss	xmm1, DWORD PTR [ecx+224]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+464]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+464], xmm0

; 1363 : 
; 1364 : 	// save past values
; 1365 : 	ABprev.a1 = GR.x;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+452]
	mov	DWORD PTR [edx+220], ecx

; 1366 : 	ABprev.b1 = GR.y;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+456]
	mov	DWORD PTR [edx+224], ecx

; 1367 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?TipPlanePath@HeliMMClass@@QAEXXZ ENDP			; HeliMMClass::TipPlanePath
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\helo\helimm.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Setup@HeliMMClass@@QAEXXZ PROC				; HeliMMClass::Setup
; _this$ = ecx

; 1304 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1305 : 
; 1306 : 	// set rel airmass velocity
; 1307 : 	// just assign VB to VA
; 1308 : 	// however, we could also do the VG (gust) assignment here too
; 1309 : 	VA = VB;

	mov	esi, DWORD PTR _this$[ebp]
	add	esi, 292				; 00000124H
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 260				; 00000104H
	mov	ecx, 8
	rep movsd

; 1310 : 
; 1311 : 	// total relative airspeed
; 1312 : 	vta = (float)sqrt(
; 1313 : 				VA.x * VA.x +
; 1314 : 				VA.y * VA.y +
; 1315 : 				VA.z * VA.z );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+260]
	mulss	xmm0, DWORD PTR [ecx+260]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+264]
	mulss	xmm1, DWORD PTR [eax+264]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+268]
	mulss	xmm1, DWORD PTR [edx+268]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+88]

; 1316 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?Setup@HeliMMClass@@QAEXXZ ENDP				; HeliMMClass::Setup
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\helo\helimm.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1HeliMMClass@@QAE@XZ PROC				; HeliMMClass::~HeliMMClass
; _this$ = ecx

; 1074 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1075 : }

	mov	esp, ebp
	pop	ebp
	ret	0
??1HeliMMClass@@QAE@XZ ENDP				; HeliMMClass::~HeliMMClass
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\helo\helimm.cpp
_TEXT	SEGMENT
_trig$ = -12						; size = 8
_this$ = -4						; size = 4
_self$ = 8						; size = 4
_helitype$ = 12						; size = 4
??0HeliMMClass@@QAE@PAVSimBaseClass@@H@Z PROC		; HeliMMClass::HeliMMClass
; _this$ = ecx

; 998  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 999  : mlTrig trig;
; 1000 : 
; 1001 : 	// sanity check type, use default if invlaid
; 1002 : 	if ( helitype >= NUM_MODELS )

	cmp	DWORD PTR _helitype$[ebp], 5
	jl	SHORT $LN1@HeliMMClas

; 1003 : 		helitype = MD500;

	mov	DWORD PTR _helitype$[ebp], 2
$LN1@HeliMMClas:

; 1004 : 
; 1005 : 	platform = self;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _self$[ebp]
	mov	DWORD PTR [eax+808], ecx

; 1006 : 
; 1007 : 	// set pointer to model data
; 1008 : 	md = &gModelData[ helitype ];

	mov	edx, DWORD PTR _helitype$[ebp]
	imul	edx, 248				; 000000f8H
	add	edx, OFFSET ?gModelData@@3PAU_HELI_MODEL_DATA@@A ; gModelData
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], edx

; 1009 : 
; 1010 : 	// reset variables
; 1011 : 	ResetForceVars();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetForceVars@HeliMMClass@@QAEXXZ	; HeliMMClass::ResetForceVars

; 1012 : 
; 1013 : 	p_ind = 0;		// induced power

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+716], xmm0

; 1014 : 	p_climb = 0;	// climb power

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+720], xmm0

; 1015 : 	p_par = 0;		// parasite power

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+724], xmm0

; 1016 : 	p_prof = 0;		// profile power

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+728], xmm0

; 1017 : 	p_tot = 0;		// total power

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+732], xmm0

; 1018 : 	p_mr = 0;		// main rotor power

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+736], xmm0

; 1019 : 	p_tr = 0;		// tail rotor power

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+740], xmm0

; 1020 : 	torque_mr = 0;	// main rotor torque

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+744], xmm0

; 1021 : 	vr_tr	 = 0;	// air vel relative to tail rotor disk

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+748], xmm0

; 1022 : 	vb_tr	 = 0;	// air vel relative to tail rotor blade

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+752], xmm0

; 1023 : 	thrust_tr = 0;	// thrust tail rotor

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+756], xmm0

; 1024 : 	vi_tr = 0;		// induced air tail rotor

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+760], xmm0

; 1025 : 	dw_ht_pos = 0;	// downwash on horizontal tail pos

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+764], xmm0

; 1026 : 	wa_ht = 0;		// airflow on ht

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+768], xmm0

; 1027 : 	eps_ht = 0;		// downwash factor on ht

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+772], xmm0

; 1028 : 	vta_ht = 0;		// total airspeed at ht

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+776], xmm0

; 1029 : 	va_vt = 0;		// airflow on vt

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+780], xmm0

; 1030 : 	vta_vt = 0;		// total airspeed at vt

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+784], xmm0

; 1031 : 	coll_pitch = 0;	// collective setting in rads (at root)

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+468], xmm0

; 1032 : 	cyc_pitch = 0;	// cyclic pitch in rads

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+472], xmm0

; 1033 : 	cyc_roll = 0;	// cyclic roll in rads

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+476], xmm0

; 1034 : 	tr_pitch = 0;	// tail rotor pitch

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+480], xmm0

; 1035 : 	a_sum = 0;		// tpp temp?

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+484], xmm0

; 1036 : 	b_sum = 0;		// tpp temp?

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+488], xmm0

; 1037 : 	wr = 0;			// Z axis air velocity relative to rotor plane

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+492], xmm0

; 1038 : 	wb = 0;			// Z axis air velocity relative to rotor blade

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+496], xmm0

; 1039 : 	thrust_mr = 0;	// main rotor thrust

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+500], xmm0

; 1040 : 	vi_mr = 0;		// main rotor induced velocity = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+504], xmm0

; 1041 : 	wa_fus = 0;		// downwash on fuselage

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+508], xmm0

; 1042 : 	wa_fus_pos = 0;	// position of downwash on fuselage

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+512], xmm0

; 1043 : 	va_x_sq = 0;	// square of VA.x

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+516], xmm0

; 1044 : 	va_y_sq = 0;	// square of VA.y

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+520], xmm0

; 1045 : 	isDigital = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1084], 0

; 1046 : 
; 1047 : 
; 1048 : 	// get sines and cosines
; 1049 :    mlSinCos (&trig, XE.ax);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+432]
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR _trig$[ebp]
	push	edx
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 1050 :    eucos.x = trig.cos;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _trig$[ebp+4]
	movss	DWORD PTR [eax+140], xmm0

; 1051 :    eusin.x = trig.sin;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _trig$[ebp]
	movss	DWORD PTR [ecx+152], xmm0

; 1052 :    mlSinCos (&trig, XE.ay);

	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+436]
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _trig$[ebp]
	push	eax
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 1053 :    eucos.y = trig.cos;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _trig$[ebp+4]
	movss	DWORD PTR [ecx+144], xmm0

; 1054 :    eusin.y = trig.sin;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _trig$[ebp]
	movss	DWORD PTR [edx+156], xmm0

; 1055 :    mlSinCos (&trig, XE.az);

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+440]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _trig$[ebp]
	push	ecx
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 1056 :    eucos.z = trig.cos;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _trig$[ebp+4]
	movss	DWORD PTR [edx+148], xmm0

; 1057 :    eusin.z = trig.sin;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _trig$[ebp]
	movss	DWORD PTR [eax+160], xmm0

; 1058 : 
; 1059 : 	// set delta time resolution for model
; 1060 : 
; 1061 : 
; 1062 : 
; 1063 : 	// run some precalcs to set variables based on the model data
; 1064 : 	PreCalc();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?PreCalc@HeliMMClass@@QAEXXZ		; HeliMMClass::PreCalc

; 1065 : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0HeliMMClass@@QAE@PAVSimBaseClass@@H@Z ENDP		; HeliMMClass::HeliMMClass
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\mltrig.h
;	COMDAT ?checked_atan2@@YANNN@Z
_TEXT	SEGMENT
_z$ = -8						; size = 8
_y$ = 8							; size = 8
_x$ = 16						; size = 8
?checked_atan2@@YANNN@Z PROC				; checked_atan2, COMDAT

; 46   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 47   : 	double z;
; 48   : 	
; 49   : 	if (x == -0.0)

	movsd	xmm0, QWORD PTR _x$[ebp]
	ucomisd	xmm0, QWORD PTR __real@8000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN8@checked_at

; 50   : 		x = 0.0;

	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR _x$[ebp], xmm0
$LN8@checked_at:

; 51   : 	
; 52   : 	if (x != 0)

	movsd	xmm0, QWORD PTR _x$[ebp]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN7@checked_at

; 53   : 		z = atan(y / x);

	movsd	xmm0, QWORD PTR _y$[ebp]
	divsd	xmm0, QWORD PTR _x$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_atan
	add	esp, 8
	fstp	QWORD PTR _z$[ebp]
	jmp	SHORT $LN4@checked_at
$LN7@checked_at:

; 54   : 	else if (y > 0)

	movsd	xmm0, QWORD PTR _y$[ebp]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jbe	SHORT $LN5@checked_at

; 55   : 		z = HALF_DPI;

	movsd	xmm0, QWORD PTR __real@3ff921fb54442d18
	movsd	QWORD PTR _z$[ebp], xmm0

; 56   : 	else

	jmp	SHORT $LN4@checked_at
$LN5@checked_at:

; 57   : 		z = -HALF_DPI;

	movsd	xmm0, QWORD PTR __real@bff921fb54442d18
	movsd	QWORD PTR _z$[ebp], xmm0
$LN4@checked_at:

; 58   : 
; 59   : 	if (x < 0)

	movsd	xmm0, QWORD PTR __real@0000000000000000
	comisd	xmm0, QWORD PTR _x$[ebp]
	jbe	SHORT $LN1@checked_at

; 60   : 	{
; 61   : 		if (y < 0)

	movsd	xmm0, QWORD PTR __real@0000000000000000
	comisd	xmm0, QWORD PTR _y$[ebp]
	jbe	SHORT $LN2@checked_at

; 62   : 			z -= DPI;

	movsd	xmm0, QWORD PTR _z$[ebp]
	subsd	xmm0, QWORD PTR __real@400921fb54442d18
	movsd	QWORD PTR _z$[ebp], xmm0

; 63   : 		else

	jmp	SHORT $LN1@checked_at
$LN2@checked_at:

; 64   : 			z += DPI;

	movsd	xmm0, QWORD PTR _z$[ebp]
	addsd	xmm0, QWORD PTR __real@400921fb54442d18
	movsd	QWORD PTR _z$[ebp], xmm0
$LN1@checked_at:

; 65   : 	}
; 66   : 
; 67   : 	return z;

	fld	QWORD PTR _z$[ebp]

; 68   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?checked_atan2@@YANNN@Z ENDP				; checked_atan2
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\mltrig.h
;	COMDAT ?mlSinCos@@YAXPAUmlTrig@@M@Z
_TEXT	SEGMENT
_trig$ = 8						; size = 4
_angle$ = 12						; size = 4
?mlSinCos@@YAXPAUmlTrig@@M@Z PROC			; mlSinCos, COMDAT

; 12   : {

	push	ebp
	mov	ebp, esp

; 13   : #if defined(_MSC_VER)
; 14   : 	__asm 
; 15   : 	{
; 16   : 		__asm	mov     ecx, trig;

	mov	ecx, DWORD PTR _trig$[ebp]

; 17   : 		__asm	fld     dword ptr [angle];

	fld	DWORD PTR _angle$[ebp]

; 18   : 		__asm	fsincos;

	fsincos

; 19   : 		__asm	fstp    dword ptr [ecx]trig.cos;

	fstp	DWORD PTR [ecx+4]

; 20   : 		__asm	fstp    dword ptr [ecx]trig.sin;

	fstp	DWORD PTR [ecx]

; 21   : 	}
; 22   : #else
; 23   : 	trig->sin = (Float32)sin(angle);
; 24   : 	trig->cos = (Float32)cos(angle);
; 25   : #endif
; 26   : }

	pop	ebp
	ret	0
?mlSinCos@@YAXPAUmlTrig@@M@Z ENDP			; mlSinCos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
_TEXT	SEGMENT
_x$ = 8							; size = 4
?SqrtSSE@@YAMM@Z PROC					; SqrtSSE

; 91   : static inline float SqrtSSE(float x){ 

	push	ebp
	mov	ebp, esp

; 92   :     __asm 
; 93   :     { 
; 94   :         sqrtss xmm0,x 

	sqrtss	xmm0, DWORD PTR _x$[ebp]

; 95   :         movss x,xmm0 

	movss	XMMWORD PTR _x$[ebp], xmm0

; 96   :     } 
; 97   : 
; 98   :     return x; 

	fld	DWORD PTR _x$[ebp]

; 99   : } 

	pop	ebp
	ret	0
?SqrtSSE@@YAMM@Z ENDP					; SqrtSSE
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_System_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_System_error_category@std@@UAEPAXI@Z PROC		; std::_System_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_System_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_System_error_category@std@@UAEPAXI@Z ENDP		; std::_System_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_System_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_System_error_category@std@@UAE@XZ PROC		; std::_System_error_category::~_System_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_System_error_category@std@@UAE@XZ ENDP		; std::_System_error_category::~_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::_System_error_category::default_error_condition, COMDAT
; _this$ = ecx

; 641  : 		{	// make error_condition for error code (generic if possible)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 642  : 		if (_Syserror_map(_Errval))

	mov	eax, DWORD PTR __Errval$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@default_er

; 643  : 			return (error_condition(_Errval, generic_category()));

	call	?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@default_er

; 644  : 		else

	jmp	SHORT $LN3@default_er
$LN2@default_er:

; 645  : 			return (error_condition(_Errval, system_category()));

	call	?system_category@std@@YAABVerror_category@1@XZ ; std::system_category
	push	eax
	mov	edx, DWORD PTR __Errval$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@default_er:

; 646  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::_System_error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_System_error_category::message, COMDAT
; _this$ = ecx

; 634  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 635  : 		const char *_Name = _Winerror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Winerror_map@std@@YAPBDH@Z		; std::_Winerror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 636  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 637  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_System_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_System_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_System_error_category@std@@UBEPBDXZ PROC		; std::_System_error_category::name, COMDAT
; _this$ = ecx

; 629  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 630  : 		return ("system");

	mov	eax, OFFSET ??_C@_06FHFOAHML@system?$AA@

; 631  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_System_error_category@std@@UBEPBDXZ ENDP		; std::_System_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_System_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_System_error_category@std@@QAE@XZ PROC		; std::_System_error_category::_System_error_category, COMDAT
; _this$ = ecx

; 624  : 	_System_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_System_error_category@std@@6B@

; 625  : 		{	// default constructor
; 626  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_System_error_category@std@@QAE@XZ ENDP		; std::_System_error_category::_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Iostream_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Iostream_error_category@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iostream_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Iostream_error_category@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Iostream_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Iostream_error_category@std@@UAE@XZ PROC		; std::_Iostream_error_category::~_Iostream_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Iostream_error_category@std@@UAE@XZ ENDP		; std::_Iostream_error_category::~_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT
; _this$ = ecx

; 611  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 612  : 		if (_Errcode == (int)io_errc::stream)

	cmp	DWORD PTR __Errcode$[ebp], 1
	jne	SHORT $LN2@message

; 613  : 			return ("iostream stream error");

	push	OFFSET ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@message

; 614  : 		else

	jmp	SHORT $LN3@message
$LN2@message:

; 615  : 			return (_Generic_error_category::message(_Errcode));

	mov	ecx, DWORD PTR __Errcode$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@message:

; 616  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Iostream_error_category@std@@UBEPBDXZ PROC	; std::_Iostream_error_category::name, COMDAT
; _this$ = ecx

; 606  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 607  : 		return ("iostream");

	mov	eax, OFFSET ??_C@_08LLGCOLLL@iostream?$AA@

; 608  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Iostream_error_category@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Iostream_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iostream_error_category@std@@QAE@XZ PROC		; std::_Iostream_error_category::_Iostream_error_category, COMDAT
; _this$ = ecx

; 601  : 	_Iostream_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Iostream_error_category@std@@6B@

; 602  : 		{	// default constructor
; 603  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iostream_error_category@std@@QAE@XZ ENDP		; std::_Iostream_error_category::_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Generic_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Generic_error_category@std@@UAE@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Generic_error_category@std@@UAE@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 590  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 591  : 		const char *_Name = _Syserror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 592  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 593  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 585  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		return ("generic");

	mov	eax, OFFSET ??_C@_07DCLBNMLN@generic?$AA@

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Generic_error_category@std@@QAE@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT
; _this$ = ecx

; 580  : 	_Generic_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0error_category@std@@QAE@XZ		; std::error_category::error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Generic_error_category@std@@6B@

; 581  : 		{	// default constructor
; 582  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Generic_error_category@std@@QAE@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_condition@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv78 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8error_condition@std@@QBE_NABV01@@Z PROC		; std::error_condition::operator==, COMDAT
; _this$ = ecx

; 376  : 		{	// test if *this == _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 377  : 		return (category() == _Right.category()
; 378  : 			&& value() == _Right.value());

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	mov	ecx, eax
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	cmp	esi, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv78[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv78[ebp]

; 379  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??8error_condition@std@@QBE_NABV01@@Z ENDP		; std::error_condition::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 354  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 356  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 349  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 350  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 351  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 316  : 		{	// construct from error code and category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Cat$[ebp]
	mov	DWORD PTR [edx+4], eax

; 317  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 256  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 257  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 258  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 251  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 252  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 253  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gerror_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gerror_category@std@@UAEPAXI@Z PROC			; std::error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gerror_category@std@@UAEPAXI@Z ENDP			; std::error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv65 = -4						; size = 4
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 184  : 		{	// compare categories for equality

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 185  : 		return (this == &_Right);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv65[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv65[ebp]

; 186  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -4						; size = 4
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 415  : 	{	// test if conditions same for this category

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 416  : 	return (*this == _Code.category() && _Code.value() == _Errval);

	mov	ecx, DWORD PTR __Code$[ebp]
	call	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@equivalent
	mov	ecx, DWORD PTR __Code$[ebp]
	call	?value@error_code@std@@QBEHXZ		; std::error_code::value
	cmp	eax, DWORD PTR __Errval$[ebp]
	jne	SHORT $LN3@equivalent
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN4@equivalent
$LN3@equivalent:
	mov	DWORD PTR tv74[ebp], 0
$LN4@equivalent:
	mov	al, BYTE PTR tv74[ebp]

; 417  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 408  : 	{	// test if error code same condition

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 409  : 	return (default_error_condition(_Errval) == _Cond);

	mov	eax, DWORD PTR __Cond$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	ecx, eax
	call	??8error_condition@std@@QBE_NABV01@@Z	; std::error_condition::operator==

; 410  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 401  : 	{	// make error_condition for error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 402  : 	return (error_condition(_Errval, *this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 403  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 167  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 168  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0error_category@std@@QAE@XZ PROC			; std::error_category::error_category, COMDAT
; _this$ = ecx

; 162  : 	error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 163  : 		{	// default constructor
; 164  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0error_category@std@@QAE@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?system_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?system_category@std@@YAABVerror_category@1@XZ PROC	; std::system_category, COMDAT

; 679  : 	{	// get system_category

	push	ebp
	mov	ebp, esp

; 680  : 	return (_Error_objects<int>::_System_object);

	mov	eax, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object

; 681  : 	}

	pop	ebp
	ret	0
?system_category@std@@YAABVerror_category@1@XZ ENDP	; std::system_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?generic_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?generic_category@std@@YAABVerror_category@1@XZ PROC	; std::generic_category, COMDAT

; 669  : 	{	// get generic_category

	push	ebp
	mov	ebp, esp

; 670  : 	return (_Error_objects<int>::_Generic_object);

	mov	eax, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object

; 671  : 	}

	pop	ebp
	ret	0
?generic_category@std@@YAABVerror_category@1@XZ ENDP	; std::generic_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocale
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC				; std::locale::id::id, COMDAT
; _this$ = ecx

; 74   : 			{	// construct with specified stamp value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx

; 75   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2275 : 		{	// report an out_of_range error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2276 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN2@Xran:

; 2277 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2270 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2271 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN2@Xlen:

; 2272 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Ptr$1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2253 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2254 : 		if (!_Built)

	movzx	eax, BYTE PTR __Built$[ebp]
	test	eax, eax
	jne	SHORT $LN4@Tidy
	jmp	SHORT $LN3@Tidy
$LN4@Tidy:

; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN3@Tidy

; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Ptr$1[ebp], eax

; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 2260 : 			if (0 < _Newsize)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN1@Tidy

; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$1[ebp]
	push	ecx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Tidy:

; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Ptr$1[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN3@Tidy:

; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2266 : 		_Eos(_Newsize);

	mov	edx, DWORD PTR __Newsize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2267 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2237 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	cmp	DWORD PTR __Ptr$[ebp], 0
	je	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	cmp	DWORD PTR __Ptr$[ebp], eax
	jb	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
$LN2@Inside:

; 2240 : 			return (false);	// don't ask

	xor	al, al
	jmp	SHORT $LN4@Inside

; 2241 : 		else

	jmp	SHORT $LN4@Inside
$LN3@Inside:

; 2242 : 			return (true);

	mov	al, 1
$LN4@Inside:

; 2243 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
tv136 = -12						; size = 4
tv129 = -8						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2224 : 		if (max_size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN6@Grow

; 2225 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN6@Grow:

; 2226 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN5@Grow

; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	jmp	SHORT $LN4@Grow
$LN5@Grow:

; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	movzx	edx, BYTE PTR __Trim$[ebp]
	test	edx, edx
	je	SHORT $LN3@Grow
	cmp	DWORD PTR __Newsize$[ebp], 16		; 00000010H
	jae	SHORT $LN3@Grow

; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jae	SHORT $LN9@Grow
	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv129[ebp], edx
	jmp	SHORT $LN10@Grow
$LN9@Grow:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR tv129[ebp], ecx
$LN10@Grow:
	mov	edx, DWORD PTR tv129[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
	jmp	SHORT $LN4@Grow
$LN3@Grow:

; 2231 : 		else if (_Newsize == 0)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $LN4@Grow

; 2232 : 			_Eos(0);	// new size is zero, just null terminate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN4@Grow:

; 2233 : 		return (0 < _Newsize);	// return true only if more work to do

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN11@Grow
	mov	DWORD PTR tv136[ebp], 1
	jmp	SHORT $LN12@Grow
$LN11@Grow:
	mov	DWORD PTR tv136[ebp], 0
$LN12@Grow:
	mov	al, BYTE PTR tv136[ebp]
$LN8@Grow:

; 2234 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [eax+16], ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 2219 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
tv205 = -48						; size = 4
tv204 = -44						; size = 4
tv203 = -40						; size = 4
tv202 = -36						; size = 4
__Ptr$ = -32						; size = 4
__Newres$ = -28						; size = 4
_this$ = -24						; size = 4
$T2 = -19						; size = 1
$T3 = -18						; size = 1
$T4 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Newres$[ebp], eax

; 2184 : 		if (max_size() < _Newres)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newres$[ebp]
	jae	SHORT $LN9@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx
	jmp	SHORT $LN8@Copy
$LN9@Copy:

; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)

	mov	eax, DWORD PTR __Newres$[ebp]
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	shr	ecx, 1
	cmp	ecx, eax
	ja	SHORT $LN7@Copy
	jmp	SHORT $LN8@Copy
$LN7@Copy:

; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+20]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, esi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], eax
	ja	SHORT $LN5@Copy

; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	shr	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR __Newres$[ebp], eax

; 2191 : 		else

	jmp	SHORT $LN8@Copy
$LN5@Copy:

; 2192 : 			_Newres = max_size();	// settle for max_size()

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	DWORD PTR __Newres$[ebp], eax
$LN8@Copy:

; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv202[ebp], eax
	mov	eax, DWORD PTR __Newres$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR tv202[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv203[ebp], eax
	mov	ecx, DWORD PTR tv203[ebp]
	mov	DWORD PTR __Ptr$[ebp], ecx
	jmp	SHORT $LN12@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2197 : 		_CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], edx

; 2199 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv204[ebp], eax
	mov	ecx, DWORD PTR __Newres$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR tv204[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv205[ebp], eax
	mov	edx, DWORD PTR tv205[ebp]
	mov	DWORD PTR __Ptr$[ebp], edx
	jmp	SHORT $LN14@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2203 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 2204 : 			_CATCH_END

	mov	eax, $LN17@Copy
	ret	0
$LN14@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2
$LN17@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2:

; 2205 : 		_CATCH_END

	mov	eax, $LN19@Copy
	ret	0
$LN12@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3
$LN19@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jbe	SHORT $LN1@Copy

; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements

	mov	eax, DWORD PTR __Oldlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Copy:

; 2210 : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);

	lea	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>

; 2212 : 		this->_Myres = _Newres;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newres$[ebp]
	mov	DWORD PTR [edx+20], eax

; 2213 : 		_Eos(_Oldlen);

	mov	ecx, DWORD PTR __Oldlen$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN11@Copy:

; 2214 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv75 = -12						; size = 4
__Num$ = -8						; size = 4
$T1 = -1						; size = 1
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1737 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1738 : 		size_type _Num = this->_Getal().max_size();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
	mov	DWORD PTR __Num$[ebp], eax

; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$[ebp], 1
	ja	SHORT $LN3@max_size
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	ecx, DWORD PTR __Num$[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv75[ebp], ecx
$LN4@max_size:
	mov	eax, DWORD PTR tv75[ebp]

; 1740 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1732 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1733 : 		return (this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]

; 1734 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$1 = -12					; size = 4
__Ptr$2 = -8						; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1317 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1318 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN4@erase

; 1319 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN4@erase:

; 1320 : 		if (this->_Mysize - _Off <= _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Off$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	ja	SHORT $LN3@erase

; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)

	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
	jmp	SHORT $LN2@erase
$LN3@erase:

; 1322 : 		else if (0 < _Count)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN2@erase

; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Ptr$2[ebp], eax

; 1325 : 			size_type _Newsize = this->_Mysize - _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Newsize$1[ebp], eax

; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	sub	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$2[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$2[ebp]
	push	eax
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 1327 : 			_Eos(_Newsize);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@erase:

; 1328 : 			}
; 1329 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN6@erase:

; 1330 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1309 : 		{	// erase elements [_Off, ...)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1310 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN1@erase

; 1311 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN1@erase:

; 1312 : 		_Eos(_Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1313 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@erase:

; 1314 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1142 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1145 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@assign

; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	jmp	SHORT $LN3@assign
$LN2@assign:

; 1132 : 
; 1133 : 		if (_Grow(_Count))

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@assign

; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1136 : 			_Eos(_Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@assign:

; 1137 : 			}
; 1138 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@assign:

; 1139 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1105 : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $LN5@assign

; 1106 : 			_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN5@assign:

; 1107 : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 1108 : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Num$[ebp]
	jae	SHORT $LN4@assign

; 1109 : 			_Num = _Count;	// trim _Num to size

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
$LN4@assign:

; 1110 : 
; 1111 : 		if (this == &_Right)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@assign

; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	mov	eax, DWORD PTR __Roff$[ebp]
	add	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	mov	ecx, DWORD PTR __Roff$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	jmp	SHORT $LN2@assign
$LN3@assign:

; 1113 : 		else if (_Grow(_Num))

	push	0
	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@assign

; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);

	mov	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1117 : 			_Eos(_Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@assign:

; 1118 : 			}
; 1119 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN7@assign:

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 791  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >

; 792  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 793  : 		assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 794  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 688  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 689  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 690  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 635  : 	_String_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >

; 636  : 		{	// construct allocator from _Al
; 637  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		{	// determine current pointer to buffer for nonmutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 522  : 		return (this->_BUF_SIZE <= this->_Myres
; 523  : 			? _STD addressof(*this->_Bx._Ptr)
; 524  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 525  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		{	// determine current pointer to buffer for mutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 515  : 		return (this->_BUF_SIZE <= this->_Myres
; 516  : 			? _STD addressof(*this->_Bx._Ptr)
; 517  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 518  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 496  : 	_String_val()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 497  : 		{	// initialize values
; 498  : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 499  : 		_Myres = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 500  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 913  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 914  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
	add	esp, 4

; 915  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 886  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 887  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate

; 888  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 875  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 877  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 830  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>

; 831  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 761  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp

; 762  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@D@std@@QBEIXZ	; std::allocator<char>::max_size

; 763  : 		}

	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

	or	eax, -1

; 629  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 590  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8

; 592  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 565  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 563  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 564  : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 565  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 551  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@move
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@move
$LN3@move:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@move:
	mov	eax, DWORD PTR tv69[ebp]

; 554  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 528  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@copy
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@copy
$LN3@copy:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@copy:
	mov	eax, DWORD PTR tv69[ebp]

; 531  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 521  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp
	push	ecx

; 522  : 		return (*_First == 0 ? 0
; 523  : 			: _CSTD strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@length
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN4@length
$LN3@length:
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR tv68[ebp], eax
$LN4@length:
	mov	eax, DWORD PTR tv68[ebp]

; 524  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 65   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 60   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 61   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?tan@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?tan@@YAMM@Z PROC					; tan, COMDAT

; 543  :         {return (tanf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_tanf
	add	esp, 4
	pop	ebp
	ret	0
?tan@@YAMM@Z ENDP					; tan
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ??$_Pow_int@M@@YAMMH@Z
_TEXT	SEGMENT
tv74 = -12						; size = 4
__Z$1 = -8						; size = 4
__N$ = -4						; size = 4
__X$ = 8						; size = 4
__Y$ = 12						; size = 4
??$_Pow_int@M@@YAMMH@Z PROC				; _Pow_int<float>, COMDAT

; 483  :         {unsigned int _N;

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 484  :         if (_Y >= 0)

	cmp	DWORD PTR __Y$[ebp], 0
	jl	SHORT $LN7@Pow_int

; 485  :                 _N = (unsigned int)_Y;

	mov	eax, DWORD PTR __Y$[ebp]
	mov	DWORD PTR __N$[ebp], eax

; 486  :         else

	jmp	SHORT $LN6@Pow_int
$LN7@Pow_int:

; 487  :                 _N = (unsigned int)(-_Y);

	mov	ecx, DWORD PTR __Y$[ebp]
	neg	ecx
	mov	DWORD PTR __N$[ebp], ecx
$LN6@Pow_int:

; 488  :         for (_Ty _Z = _Ty(1); ; _X *= _X)

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR __Z$1[ebp], xmm0
	jmp	SHORT $LN5@Pow_int
$LN4@Pow_int:
	movss	xmm0, DWORD PTR __X$[ebp]
	mulss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR __X$[ebp], xmm0
$LN5@Pow_int:

; 489  :                 {if ((_N & 1) != 0)

	mov	edx, DWORD PTR __N$[ebp]
	and	edx, 1
	je	SHORT $LN2@Pow_int

; 490  :                         _Z *= _X;

	movss	xmm0, DWORD PTR __Z$1[ebp]
	mulss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR __Z$1[ebp], xmm0
$LN2@Pow_int:

; 491  :                 if ((_N >>= 1) == 0)

	mov	eax, DWORD PTR __N$[ebp]
	shr	eax, 1
	mov	DWORD PTR __N$[ebp], eax
	jne	SHORT $LN1@Pow_int

; 492  :                         return (_Y < 0 ? _Ty(1) / _Z : _Z); }}

	cmp	DWORD PTR __Y$[ebp], 0
	jge	SHORT $LN10@Pow_int
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR __Z$1[ebp]
	movss	DWORD PTR tv74[ebp], xmm0
	jmp	SHORT $LN11@Pow_int
$LN10@Pow_int:
	movss	xmm0, DWORD PTR __Z$1[ebp]
	movss	DWORD PTR tv74[ebp], xmm0
$LN11@Pow_int:
	fld	DWORD PTR tv74[ebp]
	jmp	SHORT $LN3@Pow_int
$LN1@Pow_int:
	jmp	SHORT $LN4@Pow_int
$LN3@Pow_int:
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Pow_int@M@@YAMMH@Z ENDP				; _Pow_int<float>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?pow@@YAMMH@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
__Y$ = 12						; size = 4
?pow@@YAMMH@Z PROC					; pow, COMDAT

; 535  :         {return (_Pow_int(_X, _Y)); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Y$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	??$_Pow_int@M@@YAMMH@Z			; _Pow_int<float>
	add	esp, 8
	pop	ebp
	ret	0
?pow@@YAMMH@Z ENDP					; pow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?fabs@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?fabs@@YAMM@Z PROC					; fabs, COMDAT

; 517  :         {return (fabsf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_fabsf
	add	esp, 4
	pop	ebp
	ret	0
?fabs@@YAMM@Z ENDP					; fabs
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?cos@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?cos@@YAMM@Z PROC					; cos, COMDAT

; 511  :         {return (cosf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_cosf
	add	esp, 4
	pop	ebp
	ret	0
?cos@@YAMM@Z ENDP					; cos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?asin@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?asin@@YAMM@Z PROC					; asin, COMDAT

; 503  :         {return (asinf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_asinf
	add	esp, 4
	pop	ebp
	ret	0
?asin@@YAMM@Z ENDP					; asin
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _tanf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_tanf	PROC						; COMDAT

; 436  :         {return ((float)tan((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_tan
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_tanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _cosf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_cosf	PROC						; COMDAT

; 410  :         {return ((float)cos((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_cos
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_cosf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _asinf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_asinf	PROC						; COMDAT

; 402  :         {return ((float)asin((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_asin
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_asinf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_fabsf	PROC						; COMDAT

; 392  :         {return ((float)fabs((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_fabsf	ENDP
_TEXT	ENDS
END
