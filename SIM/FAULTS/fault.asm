; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\SIM\FAULTS\fault.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_03BBKEAIF@?$DP?$DP?$DP?$AA@		; `string'
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	??_C@_04GJGHKIDJ@LAND?$AA@			; `string'
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	??_C@_03EHDBJKGI@TOF?$AA@			; `string'
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	??_C@_03BEEHFCJJ@BUS?$AA@			; `string'
PUBLIC	??_C@_04DDHPGCOG@SLNT?$AA@			; `string'
PUBLIC	??_C@_04KPFFFFNN@CHAF?$AA@			; `string'
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	??_C@_04MGHJJKKP@FLAR?$AA@			; `string'
PUBLIC	??_C@_04EFOJOOAF@DUAL?$AA@			; `string'
PUBLIC	??_C@_04BELMAJLL@SNGL?$AA@			; `string'
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	??_C@_03HELJEDDC@A?1P?$AA@			; `string'
PUBLIC	??_C@_04HIMDHBBD@RUDR?$AA@			; `string'
PUBLIC	??_C@_03NIFPGLBG@ALL?$AA@			; `string'
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	??_C@_04LLPILFLC@XMTR?$AA@			; `string'
PUBLIC	??_C@_03OPLJOKCK@A?1I?$AA@			; `string'
PUBLIC	??_C@_03MENDDOB@A?1B?$AA@			; `string'
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	??_C@_03DNGNNODK@PFL?$AA@			; `string'
PUBLIC	??_C@_04OKEEPDCC@FIRE?$AA@			; `string'
PUBLIC	??_C@_04BIEFEBII@HYDR?$AA@			; `string'
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	??_C@_03HLODIDND@M?53?$AA@			; `string'
PUBLIC	??_C@_03FENMPKCF@M?5C?$AA@			; `string'
PUBLIC	??_C@_03JCGCAONJ@SLV?$AA@			; `string'
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	??_C@_04OHEHAIHP@LFWD?$AA@			; `string'
PUBLIC	??_C@_04DIJHCBJM@RFWD?$AA@			; `string'
PUBLIC	??_C@_04LFAEMFEJ@STA1?$AA@			; `string'
PUBLIC	??_C@_04JOCJJGIK@STA2?$AA@			; `string'
PUBLIC	??_C@_04IHDCKHML@STA3?$AA@			; `string'
PUBLIC	??_C@_04MIHDDBAM@STA4?$AA@			; `string'
PUBLIC	??_C@_04NBGIAAEN@STA5?$AA@			; `string'
PUBLIC	??_C@_04PKEFFDIO@STA6?$AA@			; `string'
PUBLIC	??_C@_04ODFOGCMP@STA7?$AA@			; `string'
PUBLIC	??_C@_04GEMGHOAA@STA8?$AA@			; `string'
PUBLIC	??_C@_04HNNNEPEB@STA9?$AA@			; `string'
PUBLIC	??_C@_04ENPANGFD@LDGR?$AA@			; `string'
PUBLIC	??_C@_05HNOIDOAF@FLOUT?$AA@			; `string'
PUBLIC	??_C@_04GKDMIDBA@CNTL?$AA@			; `string'
PUBLIC	??_C@_04MFDMPKPH@DEGR?$AA@			; `string'
PUBLIC	??_C@_04OOEBCMBF@FAIL?$AA@			; `string'
PUBLIC	??_C@_03IBEFMGAI@LOW?$AA@			; `string'
PUBLIC	??_C@_03PJCOPHD@RST?$AA@			; `string'
PUBLIC	??_C@_04JKHNIKCB@TEMP?$AA@			; `string'
PUBLIC	??_C@_04JBIELMDE@WARN?$AA@			; `string'
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?mpFaultData@FaultClass@@2QBUInitFaultData@1@B	; FaultClass::mpFaultData
PUBLIC	?mpFFunctionNames@FaultClass@@2PAPBDA		; FaultClass::mpFFunctionNames
PUBLIC	?mpFSeverityNames@FaultClass@@2PAPBDA		; FaultClass::mpFSeverityNames
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	??_C@_04CNCFMCPM@AMUX?$AA@			; `string'
PUBLIC	??_C@_04DOGOLJLJ@BLKR?$AA@			; `string'
PUBLIC	??_C@_04GKIFLICM@BMUX?$AA@			; `string'
PUBLIC	??_C@_04KJOBCMPJ@CADC?$AA@			; `string'
PUBLIC	??_C@_04KJPFIBBA@CMDS?$AA@			; `string'
PUBLIC	??_C@_04CMOFCHOK@DLNK?$AA@			; `string'
PUBLIC	??_C@_04OFMFENIM@DMUX?$AA@			; `string'
PUBLIC	??_C@_03CMHGNCKF@DTE?$AA@			; `string'
PUBLIC	??_C@_03LHENPBOE@ENG?$AA@			; `string'
PUBLIC	??_C@_04EKKADPOB@ENG2?$AA@			; `string'
PUBLIC	??_C@_04INBAJAIF@EPOD?$AA@			; `string'
PUBLIC	??_C@_03MJEMAIFN@FCC?$AA@			; `string'
PUBLIC	??_C@_03JKJFCLEN@FCR?$AA@			; `string'
PUBLIC	??_C@_04NMOGHPIA@FLCS?$AA@			; `string'
PUBLIC	??_C@_03IJBADHAG@FMS?$AA@			; `string'
PUBLIC	??_C@_04IGBBPMJF@GEAR?$AA@			; `string'
PUBLIC	??_C@_03CFFCGAEA@GPS?$AA@			; `string'
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	??_C@_04FIBJOPKE@HARM?$AA@			; `string'
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	??_C@_03HOHJDGGL@HUD?$AA@			; `string'
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	??_C@_03OKJDCOKF@IFF?$AA@			; `string'
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	??_C@_03NDDFJJAJ@INS?$AA@			; `string'
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	??_C@_03LPDPNJPJ@ISA?$AA@			; `string'
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	??_C@_04MBMELIHA@MFDS?$AA@			; `string'
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	??_C@_03IFPDDAOD@MSL?$AA@			; `string'
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	??_C@_04PPPBEHOF@RALT?$AA@			; `string'
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	??_C@_03FOMBOACJ@RWR?$AA@			; `string'
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	??_C@_03OONHJAKL@SMS?$AA@			; `string'
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	??_C@_03IGPCOJAE@TCN?$AA@			; `string'
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	??_C@_03INCLDCMH@UFC?$AA@			; `string'
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ??_C@_03INCLDCMH@UFC?$AA@
CONST	SEGMENT
??_C@_03INCLDCMH@UFC?$AA@ DB 'UFC', 00H			; `string'
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ??_C@_03IGPCOJAE@TCN?$AA@
CONST	SEGMENT
??_C@_03IGPCOJAE@TCN?$AA@ DB 'TCN', 00H			; `string'
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ??_C@_03OONHJAKL@SMS?$AA@
CONST	SEGMENT
??_C@_03OONHJAKL@SMS?$AA@ DB 'SMS', 00H			; `string'
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ??_C@_03FOMBOACJ@RWR?$AA@
CONST	SEGMENT
??_C@_03FOMBOACJ@RWR?$AA@ DB 'RWR', 00H			; `string'
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ??_C@_04PPPBEHOF@RALT?$AA@
CONST	SEGMENT
??_C@_04PPPBEHOF@RALT?$AA@ DB 'RALT', 00H		; `string'
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ??_C@_03IFPDDAOD@MSL?$AA@
CONST	SEGMENT
??_C@_03IFPDDAOD@MSL?$AA@ DB 'MSL', 00H			; `string'
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ??_C@_04MBMELIHA@MFDS?$AA@
CONST	SEGMENT
??_C@_04MBMELIHA@MFDS?$AA@ DB 'MFDS', 00H		; `string'
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ??_C@_03LPDPNJPJ@ISA?$AA@
CONST	SEGMENT
??_C@_03LPDPNJPJ@ISA?$AA@ DB 'ISA', 00H			; `string'
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ??_C@_03NDDFJJAJ@INS?$AA@
CONST	SEGMENT
??_C@_03NDDFJJAJ@INS?$AA@ DB 'INS', 00H			; `string'
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ??_C@_03OKJDCOKF@IFF?$AA@
CONST	SEGMENT
??_C@_03OKJDCOKF@IFF?$AA@ DB 'IFF', 00H			; `string'
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ??_C@_03HOHJDGGL@HUD?$AA@
CONST	SEGMENT
??_C@_03HOHJDGGL@HUD?$AA@ DB 'HUD', 00H			; `string'
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ??_C@_04FIBJOPKE@HARM?$AA@
CONST	SEGMENT
??_C@_04FIBJOPKE@HARM?$AA@ DB 'HARM', 00H		; `string'
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ??_C@_03CFFCGAEA@GPS?$AA@
CONST	SEGMENT
??_C@_03CFFCGAEA@GPS?$AA@ DB 'GPS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04IGBBPMJF@GEAR?$AA@
CONST	SEGMENT
??_C@_04IGBBPMJF@GEAR?$AA@ DB 'GEAR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03IJBADHAG@FMS?$AA@
CONST	SEGMENT
??_C@_03IJBADHAG@FMS?$AA@ DB 'FMS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04NMOGHPIA@FLCS?$AA@
CONST	SEGMENT
??_C@_04NMOGHPIA@FLCS?$AA@ DB 'FLCS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03JKJFCLEN@FCR?$AA@
CONST	SEGMENT
??_C@_03JKJFCLEN@FCR?$AA@ DB 'FCR', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MJEMAIFN@FCC?$AA@
CONST	SEGMENT
??_C@_03MJEMAIFN@FCC?$AA@ DB 'FCC', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04INBAJAIF@EPOD?$AA@
CONST	SEGMENT
??_C@_04INBAJAIF@EPOD?$AA@ DB 'EPOD', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04EKKADPOB@ENG2?$AA@
CONST	SEGMENT
??_C@_04EKKADPOB@ENG2?$AA@ DB 'ENG2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03LHENPBOE@ENG?$AA@
CONST	SEGMENT
??_C@_03LHENPBOE@ENG?$AA@ DB 'ENG', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03CMHGNCKF@DTE?$AA@
CONST	SEGMENT
??_C@_03CMHGNCKF@DTE?$AA@ DB 'DTE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04OFMFENIM@DMUX?$AA@
CONST	SEGMENT
??_C@_04OFMFENIM@DMUX?$AA@ DB 'DMUX', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04CMOFCHOK@DLNK?$AA@
CONST	SEGMENT
??_C@_04CMOFCHOK@DLNK?$AA@ DB 'DLNK', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04KJPFIBBA@CMDS?$AA@
CONST	SEGMENT
??_C@_04KJPFIBBA@CMDS?$AA@ DB 'CMDS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04KJOBCMPJ@CADC?$AA@
CONST	SEGMENT
??_C@_04KJOBCMPJ@CADC?$AA@ DB 'CADC', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GKIFLICM@BMUX?$AA@
CONST	SEGMENT
??_C@_04GKIFLICM@BMUX?$AA@ DB 'BMUX', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04DOGOLJLJ@BLKR?$AA@
CONST	SEGMENT
??_C@_04DOGOLJLJ@BLKR?$AA@ DB 'BLKR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04CNCFMCPM@AMUX?$AA@
CONST	SEGMENT
??_C@_04CNCFMCPM@AMUX?$AA@ DB 'AMUX', 00H		; `string'
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
_DATA	SEGMENT
?mpFFunctionNames@FaultClass@@2PAPBDA DD FLAT:??_C@_00CNPNBAHC@?$AA@ ; FaultClass::mpFFunctionNames
	DD	FLAT:??_C@_03BEEHFCJJ@BUS?$AA@
	DD	FLAT:??_C@_04DDHPGCOG@SLNT?$AA@
	DD	FLAT:??_C@_04KPFFFFNN@CHAF?$AA@
	DD	FLAT:??_C@_04MGHJJKKP@FLAR?$AA@
	DD	FLAT:??_C@_04OFMFENIM@DMUX?$AA@
	DD	FLAT:??_C@_04EFOJOOAF@DUAL?$AA@
	DD	FLAT:??_C@_04BELMAJLL@SNGL?$AA@
	DD	FLAT:??_C@_03HELJEDDC@A?1P?$AA@
	DD	FLAT:??_C@_04HIMDHBBD@RUDR?$AA@
	DD	FLAT:??_C@_03NIFPGLBG@ALL?$AA@
	DD	FLAT:??_C@_04LLPILFLC@XMTR?$AA@
	DD	FLAT:??_C@_03OPLJOKCK@A?1I?$AA@
	DD	FLAT:??_C@_03MENDDOB@A?1B?$AA@
	DD	FLAT:??_C@_03DNGNNODK@PFL?$AA@
	DD	FLAT:??_C@_04OKEEPDCC@FIRE?$AA@
	DD	FLAT:??_C@_04BIEFEBII@HYDR?$AA@
	DD	FLAT:??_C@_03HLODIDND@M?53?$AA@
	DD	FLAT:??_C@_03FENMPKCF@M?5C?$AA@
	DD	FLAT:??_C@_03JCGCAONJ@SLV?$AA@
	DD	FLAT:??_C@_04OHEHAIHP@LFWD?$AA@
	DD	FLAT:??_C@_04DIJHCBJM@RFWD?$AA@
	DD	FLAT:??_C@_04LFAEMFEJ@STA1?$AA@
	DD	FLAT:??_C@_04JOCJJGIK@STA2?$AA@
	DD	FLAT:??_C@_04IHDCKHML@STA3?$AA@
	DD	FLAT:??_C@_04MIHDDBAM@STA4?$AA@
	DD	FLAT:??_C@_04NBGIAAEN@STA5?$AA@
	DD	FLAT:??_C@_04PKEFFDIO@STA6?$AA@
	DD	FLAT:??_C@_04ODFOGCMP@STA7?$AA@
	DD	FLAT:??_C@_04GEMGHOAA@STA8?$AA@
	DD	FLAT:??_C@_04HNNNEPEB@STA9?$AA@
	DD	FLAT:??_C@_04ENPANGFD@LDGR?$AA@
	DD	FLAT:??_C@_05HNOIDOAF@FLOUT?$AA@
?mpFSeverityNames@FaultClass@@2PAPBDA DD FLAT:??_C@_04GKDMIDBA@CNTL?$AA@ ; FaultClass::mpFSeverityNames
	DD	FLAT:??_C@_04MFDMPKPH@DEGR?$AA@
	DD	FLAT:??_C@_04OOEBCMBF@FAIL?$AA@
	DD	FLAT:??_C@_03IBEFMGAI@LOW?$AA@
	DD	FLAT:??_C@_03PJCOPHD@RST?$AA@
	DD	FLAT:??_C@_04JKHNIKCB@TEMP?$AA@
	DD	FLAT:??_C@_04JBIELMDE@WARN?$AA@
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
_parray1 DD	03f800000r			; 1
_cmds_array DD	03e4ccccdr			; 0.2
	DD	03f19999ar			; 0.6
	DD	03f800000r			; 1
_eng_array DD	03e4ccccdr			; 0.2
	DD	03ecccccdr			; 0.4
	DD	03f19999ar			; 0.6
	DD	03f333333r			; 0.7
	DD	03f4ccccdr			; 0.8
	DD	03f800000r			; 1
_eng_array2 DD	03e4ccccdr			; 0.2
	DD	03ecccccdr			; 0.4
	DD	03f19999ar			; 0.6
	DD	03f333333r			; 0.7
	DD	03f4ccccdr			; 0.8
	DD	03f800000r			; 1
_fcr_array DD	03e99999ar			; 0.3
	DD	03f266666r			; 0.65
	DD	03f800000r			; 1
_flcs_array DD	03e4ccccdr			; 0.2
	DD	03ecccccdr			; 0.4
	DD	03f4ccccdr			; 0.8
	DD	03f800000r			; 1
_rudr_array DD	03f4ccccdr			; 0.8
	DD	03f800000r			; 1
_mfds_array DD	03f000000r			; 0.5
	DD	03f800000r			; 1
_sms_array DD	000000000r			; 0
	DD	03dcccccdr			; 0.1
	DD	03e4ccccdr			; 0.2
	DD	03e99999ar			; 0.3
	DD	03ecccccdr			; 0.4
	DD	03f000000r			; 0.5
	DD	03f19999ar			; 0.6
	DD	03f333333r			; 0.7
	DD	03f666666r			; 0.9
	DD	03f800000r			; 1
_DATA	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
	ORG $+4
?mpFaultData@FaultClass@@2QBUInitFaultData@1@B DD FLAT:??_C@_04CNCFMCPM@AMUX?$AA@ ; FaultClass::mpFaultData
	DD	01H
	DD	03dcccccdr			; 0.1
	DD	FLAT:_parray1
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_04DOGOLJLJ@BLKR?$AA@
	DD	01H
	DD	03e4ccccdr			; 0.2
	DD	FLAT:_parray1
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_04GKIFLICM@BMUX?$AA@
	DD	01H
	DD	03dcccccdr			; 0.1
	DD	FLAT:_parray1
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_04KJOBCMPJ@CADC?$AA@
	DD	01H
	DD	03dcccccdr			; 0.1
	DD	FLAT:_parray1
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_04KJPFIBBA@CMDS?$AA@
	DD	0dH
	DD	03e19999ar			; 0.15
	DD	FLAT:_cmds_array
	DD	03H
	ORG $+4
	DD	FLAT:??_C@_04CMOFCHOK@DLNK?$AA@
	DD	01H
	DD	03f000000r			; 0.5
	DD	FLAT:_parray1
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_04OFMFENIM@DMUX?$AA@
	DD	01H
	DD	03d4ccccdr			; 0.05
	DD	FLAT:_parray1
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_03CMHGNCKF@DTE?$AA@
	DD	01H
	DD	03e4ccccdr			; 0.2
	DD	FLAT:_parray1
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_03LHENPBOE@ENG?$AA@
	DD	08000f800H
	DD	03ecccccdr			; 0.4
	DD	FLAT:_eng_array
	DD	06H
	ORG $+4
	DD	FLAT:??_C@_04EKKADPOB@ENG2?$AA@
	DD	08000f800H
	DD	03ecccccdr			; 0.4
	DD	FLAT:_eng_array2
	DD	06H
	ORG $+4
	DD	FLAT:??_C@_04INBAJAIF@EPOD?$AA@
	DD	02H
	DD	03e4ccccdr			; 0.2
	DD	FLAT:_parray1
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_03MJEMAIFN@FCC?$AA@
	DD	01H
	DD	03e4ccccdr			; 0.2
	DD	FLAT:_parray1
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_03JKJFCLEN@FCR?$AA@
	DD	0441H
	DD	03e4ccccdr			; 0.2
	DD	FLAT:_fcr_array
	DD	03H
	ORG $+4
	DD	FLAT:??_C@_04NMOGHPIA@FLCS?$AA@
	DD	0f0H
	DD	03e99999ar			; 0.3
	DD	FLAT:_flcs_array
	DD	04H
	ORG $+4
	DD	FLAT:??_C@_03IJBADHAG@FMS?$AA@
	DD	01H
	DD	03dcccccdr			; 0.1
	DD	FLAT:_parray1
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_04IGBBPMJF@GEAR?$AA@
	DD	040000000H
	DD	03f000000r			; 0.5
	DD	FLAT:_parray1
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_03CFFCGAEA@GPS?$AA@
	DD	01H
	DD	03f000000r			; 0.5
	DD	FLAT:_parray1
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_04FIBJOPKE@HARM?$AA@
	DD	01H
	DD	03f000000r			; 0.5
	DD	FLAT:_parray1
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_03HOHJDGGL@HUD?$AA@
	DD	01H
	DD	03ecccccdr			; 0.4
	DD	FLAT:_parray1
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_03OKJDCOKF@IFF?$AA@
	DD	01H
	DD	03e4ccccdr			; 0.2
	DD	FLAT:_parray1
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_03NDDFJJAJ@INS?$AA@
	DD	01H
	DD	03e4ccccdr			; 0.2
	DD	FLAT:_parray1
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_03LPDPNJPJ@ISA?$AA@
	DD	0300H
	DD	03e4ccccdr			; 0.2
	DD	FLAT:_rudr_array
	DD	02H
	ORG $+4
	DD	FLAT:??_C@_04MBMELIHA@MFDS?$AA@
	DD	0180000H
	DD	03e99999ar			; 0.3
	DD	FLAT:_mfds_array
	DD	02H
	ORG $+4
	DD	FLAT:??_C@_03IFPDDAOD@MSL?$AA@
	DD	01H
	DD	000000000r			; 0
	DD	FLAT:_parray1
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_04PPPBEHOF@RALT?$AA@
	DD	0400H
	DD	03e99999ar			; 0.3
	DD	FLAT:_parray1
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_03FOMBOACJ@RWR?$AA@
	DD	01H
	DD	03e4ccccdr			; 0.2
	DD	FLAT:_parray1
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_03OONHJAKL@SMS?$AA@
	DD	03fe00001H
	DD	03dcccccdr			; 0.1
	DD	FLAT:_sms_array
	DD	0aH
	ORG $+4
	DD	FLAT:??_C@_03IGPCOJAE@TCN?$AA@
	DD	01H
	DD	03e4ccccdr			; 0.2
	DD	FLAT:_parray1
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_03INCLDCMH@UFC?$AA@
	DD	01H
	DD	03e4ccccdr			; 0.2
	DD	FLAT:_parray1
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_03BBKEAIF@?$DP?$DP?$DP?$AA@
	DD	01H
	DD	000000000r			; 0
	DD	FLAT:_parray1
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_04GJGHKIDJ@LAND?$AA@
	DD	01H
	DD	000000000r			; 0
	DD	FLAT:_parray1
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_03EHDBJKGI@TOF?$AA@
	DD	01H
	DD	000000000r			; 0
	DD	FLAT:_parray1
	DD	01H
	ORG $+4
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ??_C@_04JBIELMDE@WARN?$AA@
CONST	SEGMENT
??_C@_04JBIELMDE@WARN?$AA@ DB 'WARN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04JKHNIKCB@TEMP?$AA@
CONST	SEGMENT
??_C@_04JKHNIKCB@TEMP?$AA@ DB 'TEMP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03PJCOPHD@RST?$AA@
CONST	SEGMENT
??_C@_03PJCOPHD@RST?$AA@ DB 'RST', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03IBEFMGAI@LOW?$AA@
CONST	SEGMENT
??_C@_03IBEFMGAI@LOW?$AA@ DB 'LOW', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04OOEBCMBF@FAIL?$AA@
CONST	SEGMENT
??_C@_04OOEBCMBF@FAIL?$AA@ DB 'FAIL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MFDMPKPH@DEGR?$AA@
CONST	SEGMENT
??_C@_04MFDMPKPH@DEGR?$AA@ DB 'DEGR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GKDMIDBA@CNTL?$AA@
CONST	SEGMENT
??_C@_04GKDMIDBA@CNTL?$AA@ DB 'CNTL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05HNOIDOAF@FLOUT?$AA@
CONST	SEGMENT
??_C@_05HNOIDOAF@FLOUT?$AA@ DB 'FLOUT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04ENPANGFD@LDGR?$AA@
CONST	SEGMENT
??_C@_04ENPANGFD@LDGR?$AA@ DB 'LDGR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HNNNEPEB@STA9?$AA@
CONST	SEGMENT
??_C@_04HNNNEPEB@STA9?$AA@ DB 'STA9', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GEMGHOAA@STA8?$AA@
CONST	SEGMENT
??_C@_04GEMGHOAA@STA8?$AA@ DB 'STA8', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04ODFOGCMP@STA7?$AA@
CONST	SEGMENT
??_C@_04ODFOGCMP@STA7?$AA@ DB 'STA7', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PKEFFDIO@STA6?$AA@
CONST	SEGMENT
??_C@_04PKEFFDIO@STA6?$AA@ DB 'STA6', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04NBGIAAEN@STA5?$AA@
CONST	SEGMENT
??_C@_04NBGIAAEN@STA5?$AA@ DB 'STA5', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MIHDDBAM@STA4?$AA@
CONST	SEGMENT
??_C@_04MIHDDBAM@STA4?$AA@ DB 'STA4', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04IHDCKHML@STA3?$AA@
CONST	SEGMENT
??_C@_04IHDCKHML@STA3?$AA@ DB 'STA3', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04JOCJJGIK@STA2?$AA@
CONST	SEGMENT
??_C@_04JOCJJGIK@STA2?$AA@ DB 'STA2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LFAEMFEJ@STA1?$AA@
CONST	SEGMENT
??_C@_04LFAEMFEJ@STA1?$AA@ DB 'STA1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04DIJHCBJM@RFWD?$AA@
CONST	SEGMENT
??_C@_04DIJHCBJM@RFWD?$AA@ DB 'RFWD', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04OHEHAIHP@LFWD?$AA@
CONST	SEGMENT
??_C@_04OHEHAIHP@LFWD?$AA@ DB 'LFWD', 00H		; `string'
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ??_C@_03JCGCAONJ@SLV?$AA@
CONST	SEGMENT
??_C@_03JCGCAONJ@SLV?$AA@ DB 'SLV', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03FENMPKCF@M?5C?$AA@
CONST	SEGMENT
??_C@_03FENMPKCF@M?5C?$AA@ DB 'M C', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03HLODIDND@M?53?$AA@
CONST	SEGMENT
??_C@_03HLODIDND@M?53?$AA@ DB 'M 3', 00H		; `string'
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ??_C@_04BIEFEBII@HYDR?$AA@
CONST	SEGMENT
??_C@_04BIEFEBII@HYDR?$AA@ DB 'HYDR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04OKEEPDCC@FIRE?$AA@
CONST	SEGMENT
??_C@_04OKEEPDCC@FIRE?$AA@ DB 'FIRE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03DNGNNODK@PFL?$AA@
CONST	SEGMENT
??_C@_03DNGNNODK@PFL?$AA@ DB 'PFL', 00H			; `string'
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ??_C@_03MENDDOB@A?1B?$AA@
CONST	SEGMENT
??_C@_03MENDDOB@A?1B?$AA@ DB 'A/B', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03OPLJOKCK@A?1I?$AA@
CONST	SEGMENT
??_C@_03OPLJOKCK@A?1I?$AA@ DB 'A/I', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LLPILFLC@XMTR?$AA@
CONST	SEGMENT
??_C@_04LLPILFLC@XMTR?$AA@ DB 'XMTR', 00H		; `string'
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ??_C@_03NIFPGLBG@ALL?$AA@
CONST	SEGMENT
??_C@_03NIFPGLBG@ALL?$AA@ DB 'ALL', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04HIMDHBBD@RUDR?$AA@
CONST	SEGMENT
??_C@_04HIMDHBBD@RUDR?$AA@ DB 'RUDR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03HELJEDDC@A?1P?$AA@
CONST	SEGMENT
??_C@_03HELJEDDC@A?1P?$AA@ DB 'A/P', 00H		; `string'
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ??_C@_04BELMAJLL@SNGL?$AA@
CONST	SEGMENT
??_C@_04BELMAJLL@SNGL?$AA@ DB 'SNGL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04EFOJOOAF@DUAL?$AA@
CONST	SEGMENT
??_C@_04EFOJOOAF@DUAL?$AA@ DB 'DUAL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MGHJJKKP@FLAR?$AA@
CONST	SEGMENT
??_C@_04MGHJJKKP@FLAR?$AA@ DB 'FLAR', 00H		; `string'
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ??_C@_04KPFFFFNN@CHAF?$AA@
CONST	SEGMENT
??_C@_04KPFFFFNN@CHAF?$AA@ DB 'CHAF', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04DDHPGCOG@SLNT?$AA@
CONST	SEGMENT
??_C@_04DDHPGCOG@SLNT?$AA@ DB 'SLNT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03BEEHFCJJ@BUS?$AA@
CONST	SEGMENT
??_C@_03BEEHFCJJ@BUS?$AA@ DB 'BUS', 00H			; `string'
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ??_C@_03EHDBJKGI@TOF?$AA@
CONST	SEGMENT
??_C@_03EHDBJKGI@TOF?$AA@ DB 'TOF', 00H			; `string'
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ??_C@_04GJGHKIDJ@LAND?$AA@
CONST	SEGMENT
??_C@_04GJGHKIDJ@LAND?$AA@ DB 'LAND', 00H		; `string'
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ??_C@_03BBKEAIF@?$DP?$DP?$DP?$AA@
CONST	SEGMENT
??_C@_03BBKEAIF@?$DP?$DP?$DP?$AA@ DB '???', 00H		; `string'
CONST	ENDS
PUBLIC	?PickFunction@FaultClass@@QAE?AW4type_FFunction@1@W4type_FSubSystem@1@@Z ; FaultClass::PickFunction
PUBLIC	?PickSubSystem@FaultClass@@QAE?AW4type_FSubSystem@1@H@Z ; FaultClass::PickSubSystem
PUBLIC	?IsFlagSet@FaultClass@@QAEHXZ			; FaultClass::IsFlagSet
PUBLIC	?ClearFlag@FaultClass@@QAEXXZ			; FaultClass::ClearFlag
PUBLIC	?SetFault@FaultClass@@QAEXW4type_FSubSystem@1@W4type_FFunction@1@W4type_FSeverity@1@H@Z ; FaultClass::SetFault
PUBLIC	?ClearFault@FaultClass@@QAEXW4type_FSubSystem@1@@Z ; FaultClass::ClearFault
PUBLIC	?ClearFault@FaultClass@@QAEXW4type_FSubSystem@1@W4type_FFunction@1@@Z ; FaultClass::ClearFault
PUBLIC	?GetFault@FaultClass@@QAEXW4type_FSubSystem@1@PAUstr_FEntry@1@@Z ; FaultClass::GetFault
PUBLIC	?GetFault@FaultClass@@QAEHW4type_FSubSystem@1@@Z ; FaultClass::GetFault
PUBLIC	?GetFaultNames@FaultClass@@QAEXW4type_FSubSystem@1@HPAUstr_FNames@1@@Z ; FaultClass::GetFaultNames
PUBLIC	?TotalPowerFailure@FaultClass@@QAEXXZ		; FaultClass::TotalPowerFailure
PUBLIC	?RandomFailure@FaultClass@@QAEXXZ		; FaultClass::RandomFailure
PUBLIC	?AddMflList@FaultClass@@QAEXKW4type_FSubSystem@1@H@Z ; FaultClass::AddMflList
PUBLIC	?GetMflEntry@FaultClass@@QAE_NHPAPBDPAH1QAD@Z	; FaultClass::GetMflEntry
PUBLIC	?FindFirstFunction@FaultClass@@QAEHW4type_FSubSystem@1@PAH@Z ; FaultClass::FindFirstFunction
PUBLIC	?FindNextFunction@FaultClass@@QAEHW4type_FSubSystem@1@PAH@Z ; FaultClass::FindNextFunction
PUBLIC	?GetFirstFault@FaultClass@@QAEHPAW4type_FSubSystem@1@PAH@Z ; FaultClass::GetFirstFault
PUBLIC	?GetNextFault@FaultClass@@QAEHPAW4type_FSubSystem@1@PAH@Z ; FaultClass::GetNextFault
PUBLIC	??0FaultClass@@QAE@XZ				; FaultClass::FaultClass
PUBLIC	??1FaultClass@@QAE@XZ				; FaultClass::~FaultClass
PUBLIC	??_C@_0N@BFJBHDAI@remove?5call?6?$AA@		; `string'
PUBLIC	??_C@_08NPLOPDJG@?$CF3d?3?$CF02d?$AA@		; `string'
PUBLIC	__real@00000000
PUBLIC	__real@3a83126f
PUBLIC	__real@3f800000
PUBLIC	__real@46fffe00
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	_sprintf:PROC
EXTRN	_rand:PROC
EXTRN	_memset:PROC
EXTRN	_MonoPrint:PROC
EXTRN	_F4SoundFXSetDist:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	?SimLibElapsedTime@@3KA:DWORD			; SimLibElapsedTime
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
_allocator_arg DB 01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@46fffe00
CONST	SEGMENT
__real@46fffe00 DD 046fffe00r			; 32767
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3a83126f
CONST	SEGMENT
__real@3a83126f DD 03a83126fr			; 0.001
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_08NPLOPDJG@?$CF3d?3?$CF02d?$AA@
CONST	SEGMENT
??_C@_08NPLOPDJG@?$CF3d?3?$CF02d?$AA@ DB '%3d:%02d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BFJBHDAI@remove?5call?6?$AA@
CONST	SEGMENT
??_C@_0N@BFJBHDAI@remove?5call?6?$AA@ DB 'remove call', 0aH, 00H ; `string'
CONST	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\faults\fault.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1FaultClass@@QAE@XZ PROC				; FaultClass::~FaultClass
; _this$ = ecx

; 133  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 134  : 
; 135  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??1FaultClass@@QAE@XZ ENDP				; FaultClass::~FaultClass
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\faults\fault.cpp
_TEXT	SEGMENT
_i$ = -8						; size = 4
_this$ = -4						; size = 4
??0FaultClass@@QAE@XZ PROC				; FaultClass::FaultClass
; _this$ = ecx

; 117  : FaultClass::FaultClass(void) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 118  : 	
; 119  : 	int	i;
; 120  : 
; 121  : 	for (i = 0; i < NumFaultListSubSystems; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@FaultClass
$LN2@FaultClass:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@FaultClass:
	cmp	DWORD PTR _i$[ebp], 29			; 0000001dH
	jge	SHORT $LN1@FaultClass

; 122  : 
; 123  : 		mpFaultList[i].elFunction	= nofault;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx*8], 0

; 124  : 		mpFaultList[i].elSeverity	= no_fail;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*8+4], 7

; 125  : 	}

	jmp	SHORT $LN2@FaultClass
$LN1@FaultClass:

; 126  : 	mFaultCount	= 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+256], 0

; 127  : 	ZeroMemory(mMflList, sizeof mMflList);

	push	272					; 00000110H
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 260				; 00000104H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 128  : 	mLastMfl = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+536], 0

; 129  : 	mStartTime = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+532], 0

; 130  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0FaultClass@@QAE@XZ ENDP				; FaultClass::FaultClass
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\faults\fault.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$1 = -4						; size = 4
_subsystemp$ = 8					; size = 4
_functionp$ = 12					; size = 4
?GetNextFault@FaultClass@@QAEHPAW4type_FSubSystem@1@PAH@Z PROC ; FaultClass::GetNextFault
; _this$ = ecx

; 313  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 314  :     if (FindNextFunction(*subsystemp, functionp) == TRUE)

	mov	eax, DWORD PTR _functionp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _subsystemp$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindNextFunction@FaultClass@@QAEHW4type_FSubSystem@1@PAH@Z ; FaultClass::FindNextFunction
	cmp	eax, 1
	jne	SHORT $LN5@GetNextFau

; 315  : 	return TRUE;

	mov	eax, 1
	jmp	SHORT $LN6@GetNextFau
$LN5@GetNextFau:

; 316  : 
; 317  :     for(int i = (*subsystemp) + 1; i < FaultClass::NumFaultListSubSystems; i++) {

	mov	eax, DWORD PTR _subsystemp$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	DWORD PTR _i$1[ebp], ecx
	jmp	SHORT $LN4@GetNextFau
$LN3@GetNextFau:
	mov	edx, DWORD PTR _i$1[ebp]
	add	edx, 1
	mov	DWORD PTR _i$1[ebp], edx
$LN4@GetNextFau:
	cmp	DWORD PTR _i$1[ebp], 29			; 0000001dH
	jge	SHORT $LN2@GetNextFau

; 318  : 	if (mpFaultList[i].elFunction != nofault) {

	mov	eax, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax*8], 0
	je	SHORT $LN1@GetNextFau

; 319  : 	    *subsystemp = (type_FSubSystem)i;

	mov	edx, DWORD PTR _subsystemp$[ebp]
	mov	eax, DWORD PTR _i$1[ebp]
	mov	DWORD PTR [edx], eax

; 320  : 	    return FindFirstFunction((type_FSubSystem)i, functionp);

	mov	ecx, DWORD PTR _functionp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindFirstFunction@FaultClass@@QAEHW4type_FSubSystem@1@PAH@Z ; FaultClass::FindFirstFunction
	jmp	SHORT $LN6@GetNextFau
$LN1@GetNextFau:

; 321  : 	}
; 322  :     }

	jmp	SHORT $LN3@GetNextFau
$LN2@GetNextFau:

; 323  :     return FALSE;

	xor	eax, eax
$LN6@GetNextFau:

; 324  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetNextFault@FaultClass@@QAEHPAW4type_FSubSystem@1@PAH@Z ENDP ; FaultClass::GetNextFault
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\faults\fault.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$1 = -4						; size = 4
_subsystemp$ = 8					; size = 4
_functionp$ = 12					; size = 4
?GetFirstFault@FaultClass@@QAEHPAW4type_FSubSystem@1@PAH@Z PROC ; FaultClass::GetFirstFault
; _this$ = ecx

; 301  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 302  :     for(int i = 0; i < FaultClass::NumFaultListSubSystems; i++) {

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@GetFirstFa
$LN3@GetFirstFa:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@GetFirstFa:
	cmp	DWORD PTR _i$1[ebp], 29			; 0000001dH
	jge	SHORT $LN2@GetFirstFa

; 303  : 	if (mpFaultList[i].elFunction != nofault) {

	mov	ecx, DWORD PTR _i$1[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+ecx*8], 0
	je	SHORT $LN1@GetFirstFa

; 304  : 	    *subsystemp = (type_FSubSystem)i;

	mov	eax, DWORD PTR _subsystemp$[ebp]
	mov	ecx, DWORD PTR _i$1[ebp]
	mov	DWORD PTR [eax], ecx

; 305  : 	    return FindFirstFunction((type_FSubSystem)i, functionp); // this should be true

	mov	edx, DWORD PTR _functionp$[ebp]
	push	edx
	mov	eax, DWORD PTR _i$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindFirstFunction@FaultClass@@QAEHW4type_FSubSystem@1@PAH@Z ; FaultClass::FindFirstFunction
	jmp	SHORT $LN5@GetFirstFa
$LN1@GetFirstFa:

; 306  : 	}
; 307  :     }

	jmp	SHORT $LN3@GetFirstFa
$LN2@GetFirstFa:

; 308  :     return FALSE;

	xor	eax, eax
$LN5@GetFirstFa:

; 309  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetFirstFault@FaultClass@@QAEHPAW4type_FSubSystem@1@PAH@Z ENDP ; FaultClass::GetFirstFault
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\faults\fault.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$1 = -4						; size = 4
_sys$ = 8						; size = 4
_functionp$ = 12					; size = 4
?FindNextFunction@FaultClass@@QAEHW4type_FSubSystem@1@PAH@Z PROC ; FaultClass::FindNextFunction
; _this$ = ecx

; 338  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 339  :     for (int i = *functionp; i < NumFaultFunctions-1; i++) {

	mov	eax, DWORD PTR _functionp$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _i$1[ebp], ecx
	jmp	SHORT $LN4@FindNextFu
$LN3@FindNextFu:
	mov	edx, DWORD PTR _i$1[ebp]
	add	edx, 1
	mov	DWORD PTR _i$1[ebp], edx
$LN4@FindNextFu:
	cmp	DWORD PTR _i$1[ebp], 32			; 00000020H
	jge	SHORT $LN2@FindNextFu

; 340  : 	if (mpFaultList[sys].elFunction & (1U << i)) {

	mov	eax, 1
	mov	ecx, DWORD PTR _i$1[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _sys$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [edx+ecx*8]
	je	SHORT $LN1@FindNextFu

; 341  : 	    *functionp = i+1;

	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR _functionp$[ebp]
	mov	DWORD PTR [ecx], eax

; 342  : 	    return TRUE;

	mov	eax, 1
	jmp	SHORT $LN5@FindNextFu
$LN1@FindNextFu:

; 343  : 	}
; 344  :     }

	jmp	SHORT $LN3@FindNextFu
$LN2@FindNextFu:

; 345  :     return FALSE;

	xor	eax, eax
$LN5@FindNextFu:

; 346  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?FindNextFunction@FaultClass@@QAEHW4type_FSubSystem@1@PAH@Z ENDP ; FaultClass::FindNextFunction
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\faults\fault.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$1 = -4						; size = 4
_sys$ = 8						; size = 4
_functionp$ = 12					; size = 4
?FindFirstFunction@FaultClass@@QAEHW4type_FSubSystem@1@PAH@Z PROC ; FaultClass::FindFirstFunction
; _this$ = ecx

; 327  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 328  :     for (int i = 0; i < NumFaultFunctions-1; i++) {

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@FindFirstF
$LN3@FindFirstF:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@FindFirstF:
	cmp	DWORD PTR _i$1[ebp], 32			; 00000020H
	jge	SHORT $LN2@FindFirstF

; 329  : 	if (mpFaultList[sys].elFunction & (1U << i)) {

	mov	edx, 1
	mov	ecx, DWORD PTR _i$1[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _sys$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	and	edx, DWORD PTR [ecx+eax*8]
	je	SHORT $LN1@FindFirstF

; 330  : 	    *functionp = i+1;

	mov	edx, DWORD PTR _i$1[ebp]
	add	edx, 1
	mov	eax, DWORD PTR _functionp$[ebp]
	mov	DWORD PTR [eax], edx

; 331  : 	    return TRUE;

	mov	eax, 1
	jmp	SHORT $LN5@FindFirstF
$LN1@FindFirstF:

; 332  : 	}
; 333  :     }

	jmp	SHORT $LN3@FindFirstF
$LN2@FindFirstF:

; 334  :     return FALSE;

	xor	eax, eax
$LN5@FindFirstF:

; 335  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?FindFirstFunction@FaultClass@@QAEHW4type_FSubSystem@1@PAH@Z ENDP ; FaultClass::FindFirstFunction
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\faults\fault.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_n$ = 8							; size = 4
_name$ = 12						; size = 4
_subsys$ = 16						; size = 4
_count$ = 20						; size = 4
_timestr$ = 24						; size = 4
?GetMflEntry@FaultClass@@QAE_NHPAPBDPAH1QAD@Z PROC	; FaultClass::GetMflEntry
; _this$ = ecx

; 410  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 411  :     ShiAssert(n >=0 && n < mLastMfl);
; 412  :     if (n < 0 || n >= mLastMfl)

	cmp	DWORD PTR _n$[ebp], 0
	jl	SHORT $LN1@GetMflEntr
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _n$[ebp]
	cmp	ecx, DWORD PTR [eax+536]
	jl	SHORT $LN2@GetMflEntr
$LN1@GetMflEntr:

; 413  : 	return false;

	xor	al, al
	jmp	$LN3@GetMflEntr
$LN2@GetMflEntr:

; 414  :     ShiAssert(mMflList[n].type >= 0 && mMflList[n].type < TotalFaultStrings);
; 415  :     *name = mpFaultData[mMflList[n].type].mpFSSName;

	mov	edx, DWORD PTR _n$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+260]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _name$[ebp]
	mov	eax, DWORD PTR ?mpFaultData@FaultClass@@2QBUInitFaultData@1@B[ecx]
	mov	DWORD PTR [edx], eax

; 416  :     *subsys = mMflList[n].subtype;

	mov	ecx, DWORD PTR _n$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _subsys$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+264]
	mov	DWORD PTR [edx], ecx

; 417  :     *count = mMflList[n].no;

	mov	edx, DWORD PTR _n$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _count$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+edx+268]
	mov	DWORD PTR [eax], edx

; 418  :     sprintf (timestr, "%3d:%02d", mMflList[n].time / 60, mMflList[n].time % 60);

	mov	eax, DWORD PTR _n$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+eax+272]
	cdq
	mov	ecx, 60					; 0000003cH
	idiv	ecx
	push	edx
	mov	edx, DWORD PTR _n$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+edx+272]
	cdq
	mov	ecx, 60					; 0000003cH
	idiv	ecx
	push	eax
	push	OFFSET ??_C@_08NPLOPDJG@?$CF3d?3?$CF02d?$AA@
	mov	edx, DWORD PTR _timestr$[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 419  :     return true;

	mov	al, 1
$LN3@GetMflEntr:

; 420  : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?GetMflEntry@FaultClass@@QAE_NHPAPBDPAH1QAD@Z ENDP	; FaultClass::GetMflEntry
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\faults\fault.cpp
_TEXT	SEGMENT
tv179 = -20						; size = 8
tv176 = -12						; size = 4
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_thetime$ = 8						; size = 4
_type$ = 12						; size = 4
_subtype$ = 16						; size = 4
?AddMflList@FaultClass@@QAEXKW4type_FSubSystem@1@H@Z PROC ; FaultClass::AddMflList
; _this$ = ecx

; 392  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 393  :     for (int i = 0; i < mLastMfl; i++) {

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN5@AddMflList
$LN4@AddMflList:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN5@AddMflList:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$1[ebp]
	cmp	edx, DWORD PTR [ecx+536]
	jge	SHORT $LN3@AddMflList

; 394  : 	if (mMflList[i].type == type &&
; 395  : 	    mMflList[i].subtype == subtype) {

	mov	eax, DWORD PTR _i$1[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+260]
	cmp	edx, DWORD PTR _type$[ebp]
	jne	SHORT $LN2@AddMflList
	mov	eax, DWORD PTR _i$1[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+264]
	cmp	edx, DWORD PTR _subtype$[ebp]
	jne	SHORT $LN2@AddMflList

; 396  : 	    mMflList[i].no ++;

	mov	eax, DWORD PTR _i$1[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+268]
	add	edx, 1
	mov	eax, DWORD PTR _i$1[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+268], edx

; 397  : 	    return;

	jmp	$LN6@AddMflList
$LN2@AddMflList:

; 398  : 	}
; 399  :     }

	jmp	SHORT $LN4@AddMflList
$LN3@AddMflList:

; 400  :     if (mLastMfl >= MAX_MFL) return;

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+536], 17			; 00000011H
	jl	SHORT $LN1@AddMflList
	jmp	$LN6@AddMflList
$LN1@AddMflList:

; 401  :     mMflList[mLastMfl].time = (int)((thetime - mStartTime) * MSEC_TO_SEC); // delta from start

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _thetime$[ebp]
	sub	ecx, DWORD PTR [eax+532]
	mov	DWORD PTR tv176[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv176[ebp]
	mov	edx, DWORD PTR tv176[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv179[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv179[ebp]
	mulss	xmm0, DWORD PTR __real@3a83126f
	cvttss2si eax, xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+536]
	shl	edx, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx+272], eax

; 402  :     mMflList[mLastMfl].type = type;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+536]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _type$[ebp]
	mov	DWORD PTR [ecx+eax+260], edx

; 403  :     mMflList[mLastMfl].no = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+536]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+268], 1

; 404  :     mMflList[mLastMfl].subtype = subtype;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+536]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _subtype$[ebp]
	mov	DWORD PTR [edx+ecx+264], eax

; 405  :     mLastMfl ++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+536]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+536], edx
$LN6@AddMflList:

; 406  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?AddMflList@FaultClass@@QAEXKW4type_FSubSystem@1@H@Z ENDP ; FaultClass::AddMflList
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\faults\fault.cpp
_TEXT	SEGMENT
_this$ = -12						; size = 4
_i$ = -8						; size = 4
_j$ = -4						; size = 4
?RandomFailure@FaultClass@@QAEXXZ PROC			; FaultClass::RandomFailure
; _this$ = ecx

; 369  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 370  :     int i, j;
; 371  :     // Loop through every fault known...
; 372  :     for (i = 0; i < NumFaultListSubSystems; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN8@RandomFail
$LN7@RandomFail:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN8@RandomFail:
	cmp	DWORD PTR _i$[ebp], 29			; 0000001dH
	jge	SHORT $LN9@RandomFail

; 373  : 	//if (i == ufc_fault) continue; // for debugging - so we can see whats happening
; 374  : 		if (rand() % 100 < 5) { // 5% failure chance for each system

	call	_rand
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	cmp	edx, 5
	jge	SHORT $LN5@RandomFail

; 375  : 		{
; 376  : 			for (j = 0; j < NumFaultFunctions; j++) {

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN4@RandomFail
$LN3@RandomFail:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$LN4@RandomFail:
	cmp	DWORD PTR _j$[ebp], 33			; 00000021H
	jge	SHORT $LN5@RandomFail

; 377  : 				//switch (1<<j) {
; 378  : 				//case efire: // skip engine fire
; 379  : 				//case ldgr: // skip landing gear
; 380  : 				//break;
; 381  : 				//default:
; 382  : 				if (mpFaultData[i].mBreakable & (1<<j)) {

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	edx, 1
	mov	ecx, DWORD PTR _j$[ebp]
	shl	edx, cl
	and	edx, DWORD PTR ?mpFaultData@FaultClass@@2QBUInitFaultData@1@B[eax+4]
	je	SHORT $LN1@RandomFail

; 383  : 					SetFault((type_FSubSystem)i, (type_FFunction)(1<<j), fail, TRUE);

	push	1
	push	2
	mov	eax, 1
	mov	ecx, DWORD PTR _j$[ebp]
	shl	eax, cl
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFault@FaultClass@@QAEXW4type_FSubSystem@1@W4type_FFunction@1@W4type_FSeverity@1@H@Z ; FaultClass::SetFault
$LN1@RandomFail:

; 384  : 				}
; 385  : 				}

	jmp	SHORT $LN3@RandomFail
$LN5@RandomFail:

; 386  : 			}
; 387  : 		}
; 388  : 	}

	jmp	SHORT $LN7@RandomFail
$LN9@RandomFail:

; 389  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RandomFailure@FaultClass@@QAEXXZ ENDP			; FaultClass::RandomFailure
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\faults\fault.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv69 = -12						; size = 4
_i$ = -8						; size = 4
_j$ = -4						; size = 4
?TotalPowerFailure@FaultClass@@QAEXXZ PROC		; FaultClass::TotalPowerFailure
; _this$ = ecx

; 349  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 350  :     int i, j;
; 351  :     // set practically every fault known...
; 352  :     for (i = 0; i < NumFaultListSubSystems; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN11@TotalPower
$LN10@TotalPower:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN11@TotalPower:
	cmp	DWORD PTR _i$[ebp], 29			; 0000001dH
	jge	SHORT $LN12@TotalPower

; 353  : 	//if (i == ufc_fault) continue; // for debugging - so we can see whats happening
; 354  : 	for (j = 0; j < NumFaultFunctions; j++) {

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN8@TotalPower
$LN7@TotalPower:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$LN8@TotalPower:
	cmp	DWORD PTR _j$[ebp], 33			; 00000021H
	jge	SHORT $LN6@TotalPower

; 355  : 	    switch (1<<j) {

	mov	edx, 1
	mov	ecx, DWORD PTR _j$[ebp]
	shl	edx, cl
	mov	DWORD PTR tv69[ebp], edx
	cmp	DWORD PTR tv69[ebp], 16384		; 00004000H
	je	SHORT $LN3@TotalPower
	cmp	DWORD PTR tv69[ebp], 1073741824		; 40000000H
	je	SHORT $LN3@TotalPower
	jmp	SHORT $LN2@TotalPower
$LN3@TotalPower:

; 356  : 	    case efire: // skip engine fire
; 357  : 	    case ldgr: // skip landing gear
; 358  : 		break;

	jmp	SHORT $LN4@TotalPower
$LN2@TotalPower:

; 359  : 	    default:
; 360  : 		if (mpFaultData[i].mBreakable & (1<<j)) {

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 24					; 00000018H
	mov	edx, 1
	mov	ecx, DWORD PTR _j$[ebp]
	shl	edx, cl
	and	edx, DWORD PTR ?mpFaultData@FaultClass@@2QBUInitFaultData@1@B[eax+4]
	je	SHORT $LN4@TotalPower

; 361  : 		    SetFault((type_FSubSystem)i, (type_FFunction)(1<<j), fail, TRUE);

	push	1
	push	2
	mov	eax, 1
	mov	ecx, DWORD PTR _j$[ebp]
	shl	eax, cl
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFault@FaultClass@@QAEXW4type_FSubSystem@1@W4type_FFunction@1@W4type_FSeverity@1@H@Z ; FaultClass::SetFault
$LN4@TotalPower:

; 362  : 		}
; 363  : 	    }
; 364  : 	}

	jmp	SHORT $LN7@TotalPower
$LN6@TotalPower:

; 365  :     }

	jmp	$LN10@TotalPower
$LN12@TotalPower:

; 366  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?TotalPowerFailure@FaultClass@@QAEXXZ ENDP		; FaultClass::TotalPowerFailure
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\faults\fault.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_subsystem$ = 8						; size = 4
_funcNum$ = 12						; size = 4
_names$ = 16						; size = 4
?GetFaultNames@FaultClass@@QAEXW4type_FSubSystem@1@HPAUstr_FNames@1@@Z PROC ; FaultClass::GetFaultNames
; _this$ = ecx

; 287  : 				str_FNames*		names) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 288  : 
; 289  : 	ShiAssert(FALSE == F4IsBadReadPtr(names, sizeof *names));
; 290  : 	ShiAssert(FALSE == F4IsBadReadPtr(mpFaultData, sizeof *mpFaultData));
; 291  : 	ShiAssert(FALSE == F4IsBadReadPtr(mpFFunctionNames, sizeof *mpFFunctionNames));
; 292  : 	ShiAssert(FALSE == F4IsBadReadPtr(mpFSeverityNames, sizeof *mpFSeverityNames));
; 293  : 
; 294  : 	names->elpFSubSystemNames	= mpFaultData[subsystem].mpFSSName;

	mov	eax, DWORD PTR _subsystem$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _names$[ebp]
	mov	edx, DWORD PTR ?mpFaultData@FaultClass@@2QBUInitFaultData@1@B[eax]
	mov	DWORD PTR [ecx], edx

; 295  : 	names->elpFFunctionNames	= mpFFunctionNames[funcNum];

	mov	eax, DWORD PTR _names$[ebp]
	mov	ecx, DWORD PTR _funcNum$[ebp]
	mov	edx, DWORD PTR ?mpFFunctionNames@FaultClass@@2PAPBDA[ecx*4]
	mov	DWORD PTR [eax+4], edx

; 296  : 	names->elpFSeverityNames	= mpFSeverityNames[mpFaultList[subsystem].elSeverity];

	mov	eax, DWORD PTR _subsystem$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8+4]
	mov	eax, DWORD PTR _names$[ebp]
	mov	ecx, DWORD PTR ?mpFSeverityNames@FaultClass@@2PAPBDA[edx*4]
	mov	DWORD PTR [eax+8], ecx

; 297  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetFaultNames@FaultClass@@QAEXW4type_FSubSystem@1@HPAUstr_FNames@1@@Z ENDP ; FaultClass::GetFaultNames
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\faults\fault.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_subsystem$ = 8						; size = 4
?GetFault@FaultClass@@QAEHW4type_FSubSystem@1@@Z PROC	; FaultClass::GetFault
; _this$ = ecx

; 276  : int FaultClass::GetFault(type_FSubSystem subsystem) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 277  : 
; 278  : 	return mpFaultList[subsystem].elFunction;

	mov	eax, DWORD PTR _subsystem$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+eax*8]

; 279  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetFault@FaultClass@@QAEHW4type_FSubSystem@1@@Z ENDP	; FaultClass::GetFault
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\faults\fault.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_subsystem$ = 8						; size = 4
_entry$ = 12						; size = 4
?GetFault@FaultClass@@QAEXW4type_FSubSystem@1@PAUstr_FEntry@1@@Z PROC ; FaultClass::GetFault
; _this$ = ecx

; 266  : void FaultClass::GetFault(type_FSubSystem subsystem, str_FEntry* entry) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 267  : 	
; 268  : 	entry->elFunction = mpFaultList[subsystem].elFunction;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR _subsystem$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR [eax], ecx

; 269  : 	entry->elSeverity = mpFaultList[subsystem].elSeverity;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR _subsystem$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+eax*8+4]
	mov	DWORD PTR [edx+4], eax

; 270  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetFault@FaultClass@@QAEXW4type_FSubSystem@1@PAUstr_FEntry@1@@Z ENDP ; FaultClass::GetFault
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\faults\fault.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_subsystem$ = 8						; size = 4
_function$ = 12						; size = 4
?ClearFault@FaultClass@@QAEXW4type_FSubSystem@1@W4type_FFunction@1@@Z PROC ; FaultClass::ClearFault
; _this$ = ecx

; 251  : void FaultClass::ClearFault(type_FSubSystem subsystem, type_FFunction	function) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 252  : 	mpFaultList[subsystem].elFunction &= ~ function;

	mov	eax, DWORD PTR _function$[ebp]
	not	eax
	mov	ecx, DWORD PTR _subsystem$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR _subsystem$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx*8], eax

; 253  : 
; 254  : 	if(mpFaultList[subsystem].elFunction == nofault) {

	mov	eax, DWORD PTR _subsystem$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax*8], 0
	jne	SHORT $LN3@ClearFault

; 255  : 		mFaultCount--;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+256]
	sub	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+256], eax

; 256  : 		//MI small fixup
; 257  : 		if(mFaultCount < 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+256], 0
	jge	SHORT $LN3@ClearFault

; 258  : 			mFaultCount = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+256], 0
$LN3@ClearFault:

; 259  : 	}
; 260  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?ClearFault@FaultClass@@QAEXW4type_FSubSystem@1@W4type_FFunction@1@@Z ENDP ; FaultClass::ClearFault
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\faults\fault.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_subsystem$ = 8						; size = 4
?ClearFault@FaultClass@@QAEXW4type_FSubSystem@1@@Z PROC	; FaultClass::ClearFault
; _this$ = ecx

; 239  : void FaultClass::ClearFault(type_FSubSystem subsystem) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 240  : 
; 241  : 	if(mpFaultList[subsystem].elFunction != nofault) {

	mov	eax, DWORD PTR _subsystem$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax*8], 0
	je	SHORT $LN3@ClearFault

; 242  : 		mFaultCount--;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+256]
	sub	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+256], eax

; 243  : 		//MI small fixup
; 244  : 		if(mFaultCount < 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+256], 0
	jge	SHORT $LN3@ClearFault

; 245  : 			mFaultCount = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+256], 0
$LN3@ClearFault:

; 246  : //		mpFaultList[subsystem].elFunction	= nofault;
; 247  : 	}
; 248  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ClearFault@FaultClass@@QAEXW4type_FSubSystem@1@@Z ENDP	; FaultClass::ClearFault
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\faults\fault.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_subsystem$ = 8						; size = 4
_function$ = 12						; size = 4
_severity$ = 16						; size = 4
_doWarningMsg$ = 20					; size = 4
?SetFault@FaultClass@@QAEXW4type_FSubSystem@1@W4type_FFunction@1@W4type_FSeverity@1@H@Z PROC ; FaultClass::SetFault
; _this$ = ecx

; 219  : 			  BOOL			doWarningMsg) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 220  :     
; 221  :     if(mpFaultList[subsystem].elFunction == nofault) {

	mov	eax, DWORD PTR _subsystem$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax*8], 0
	jne	SHORT $LN1@SetFault

; 222  : 	
; 223  : 	mFaultCount++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+256]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+256], eax

; 224  : 	
; 225  : 	if(doWarningMsg) {

	cmp	DWORD PTR _doWarningMsg$[ebp], 0
	je	SHORT $LN1@SetFault

; 226  : 	    // sound effect warning goes here?
; 227  : 	    F4SoundFXSetDist( SFX_BB_WARNING, FALSE, 0.0f, 1.0f );	}

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	0
	push	63					; 0000003fH
	call	_F4SoundFXSetDist
	add	esp, 16					; 00000010H
$LN1@SetFault:

; 228  :     }
; 229  :     
; 230  :     mpFaultList[subsystem].elFunction	|= function;

	mov	edx, DWORD PTR _subsystem$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8]
	or	ecx, DWORD PTR _function$[ebp]
	mov	edx, DWORD PTR _subsystem$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx*8], ecx

; 231  :     mpFaultList[subsystem].elSeverity	= severity;

	mov	ecx, DWORD PTR _subsystem$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _severity$[ebp]
	mov	DWORD PTR [edx+ecx*8+4], eax

; 232  :     AddMflList(SimLibElapsedTime, subsystem, (int)severity);

	mov	ecx, DWORD PTR _severity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _subsystem$[ebp]
	push	edx
	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddMflList@FaultClass@@QAEXKW4type_FSubSystem@1@H@Z ; FaultClass::AddMflList

; 233  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?SetFault@FaultClass@@QAEXW4type_FSubSystem@1@W4type_FFunction@1@W4type_FSeverity@1@H@Z ENDP ; FaultClass::SetFault
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\faults\fault.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ClearFlag@FaultClass@@QAEXXZ PROC			; FaultClass::ClearFlag
; _this$ = ecx

; 151  : void FaultClass::ClearFlag() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 152  : 
; 153  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ClearFlag@FaultClass@@QAEXXZ ENDP			; FaultClass::ClearFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\faults\fault.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsFlagSet@FaultClass@@QAEHXZ PROC			; FaultClass::IsFlagSet
; _this$ = ecx

; 141  : BOOL FaultClass::IsFlagSet() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 142  : 
; 143  : MonoPrint("remove call\n");

	push	OFFSET ??_C@_0N@BFJBHDAI@remove?5call?6?$AA@
	call	_MonoPrint
	add	esp, 4

; 144  : return FALSE;

	xor	eax, eax

; 145  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsFlagSet@FaultClass@@QAEHXZ ENDP			; FaultClass::IsFlagSet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\faults\fault.cpp
_TEXT	SEGMENT
_this$ = -140						; size = 4
_retval$ = -136						; size = 4
_j$ = -132						; size = 4
_failedThing$ = -128					; size = 4
_i$ = -124						; size = 4
_failedThings$ = -120					; size = 116
__$ArrayPad$ = -4					; size = 4
_subsystemBits$ = 8					; size = 4
?PickSubSystem@FaultClass@@QAE?AW4type_FSubSystem@1@H@Z PROC ; FaultClass::PickSubSystem
; _this$ = ecx

; 156  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 157  :     type_FSubSystem retval = amux_fault;

	mov	DWORD PTR _retval$[ebp], 0

; 158  :     int failedThings[NumFaultListSubSystems];
; 159  :     int failedThing;
; 160  :     int i, j = 0;

	mov	DWORD PTR _j$[ebp], 0

; 161  :     
; 162  :     for(i = 0; i < FaultClass::NumFaultListSubSystems; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN5@PickSubSys
$LN4@PickSubSys:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN5@PickSubSys:
	cmp	DWORD PTR _i$[ebp], 29			; 0000001dH
	jge	SHORT $LN3@PickSubSys

; 163  :     {
; 164  : 	if(subsystemBits & (1 << i))

	mov	edx, 1
	mov	ecx, DWORD PTR _i$[ebp]
	shl	edx, cl
	and	edx, DWORD PTR _subsystemBits$[ebp]
	je	SHORT $LN2@PickSubSys

; 165  : 	{
; 166  : 	    failedThings[j] = i;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _failedThings$[ebp+eax*4], ecx

; 167  : 	    j++;

	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$LN2@PickSubSys:

; 168  : 	}
; 169  :     }

	jmp	SHORT $LN4@PickSubSys
$LN3@PickSubSys:

; 170  :     
; 171  :     // Choose one of the available
; 172  :     failedThing = rand() % j;

	call	_rand
	cdq
	idiv	DWORD PTR _j$[ebp]
	mov	DWORD PTR _failedThing$[ebp], edx

; 173  :     failedThing = failedThings[failedThing];

	mov	eax, DWORD PTR _failedThing$[ebp]
	mov	ecx, DWORD PTR _failedThings$[ebp+eax*4]
	mov	DWORD PTR _failedThing$[ebp], ecx

; 174  :     
; 175  :     // Did it fail?
; 176  :    if (mpFaultData[failedThing].mSProb <= (float)rand() / (float)RAND_MAX)

	mov	esi, DWORD PTR _failedThing$[ebp]
	imul	esi, 24					; 00000018H
	call	_rand
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@46fffe00
	comiss	xmm0, DWORD PTR ?mpFaultData@FaultClass@@2QBUInitFaultData@1@B[esi+8]
	jb	SHORT $LN1@PickSubSys

; 177  :       retval = (type_FSubSystem)failedThing;

	mov	edx, DWORD PTR _failedThing$[ebp]
	mov	DWORD PTR _retval$[ebp], edx
$LN1@PickSubSys:

; 178  : 
; 179  :    return retval;

	mov	eax, DWORD PTR _retval$[ebp]

; 180  : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?PickSubSystem@FaultClass@@QAE?AW4type_FSubSystem@1@H@Z ENDP ; FaultClass::PickSubSystem
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\faults\fault.cpp
_TEXT	SEGMENT
_this$ = -24						; size = 4
_breakable$ = -20					; size = 4
_pFail$ = -16						; size = 4
_retval$ = -12						; size = 4
_counter$ = -8						; size = 4
_i$ = -4						; size = 4
_system$ = 8						; size = 4
?PickFunction@FaultClass@@QAE?AW4type_FFunction@1@W4type_FSubSystem@1@@Z PROC ; FaultClass::PickFunction
; _this$ = ecx

; 183  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 184  :     type_FFunction retval = nofault;

	mov	DWORD PTR _retval$[ebp], 0

; 185  :     float pFail = (float)rand() / (float)RAND_MAX;

	call	_rand
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@46fffe00
	movss	DWORD PTR _pFail$[ebp], xmm0

; 186  :     int i, counter;
; 187  :     int breakable = mpFaultData[system].mBreakable;

	mov	eax, DWORD PTR _system$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR ?mpFaultData@FaultClass@@2QBUInitFaultData@1@B[eax+4]
	mov	DWORD PTR _breakable$[ebp], ecx

; 188  :     
; 189  :     for (i=0; i<mpFaultData[system].mCount; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@PickFuncti
$LN6@PickFuncti:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN7@PickFuncti:
	mov	eax, DWORD PTR _system$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR ?mpFaultData@FaultClass@@2QBUInitFaultData@1@B[eax+16]
	jge	SHORT $LN5@PickFuncti

; 190  :     {
; 191  : 	if (mpFaultData[system].mFProb[i] >= pFail)

	mov	edx, DWORD PTR _system$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR ?mpFaultData@FaultClass@@2QBUInitFaultData@1@B[edx+12]
	mov	ecx, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx*4]
	comiss	xmm0, DWORD PTR _pFail$[ebp]
	jb	SHORT $LN4@PickFuncti

; 192  : 	{
; 193  : 	    break;

	jmp	SHORT $LN5@PickFuncti
$LN4@PickFuncti:

; 194  : 	}
; 195  :     }

	jmp	SHORT $LN6@PickFuncti
$LN5@PickFuncti:

; 196  : 
; 197  :    // Find the i'th bit in the failure
; 198  :    i++;

	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx

; 199  :    counter = -1;

	mov	DWORD PTR _counter$[ebp], -1
$LN3@PickFuncti:

; 200  :    while (i)

	cmp	DWORD PTR _i$[ebp], 0
	je	SHORT $LN2@PickFuncti

; 201  :    {
; 202  :       counter ++;

	mov	eax, DWORD PTR _counter$[ebp]
	add	eax, 1
	mov	DWORD PTR _counter$[ebp], eax

; 203  :       if (breakable & (1 << counter))

	mov	edx, 1
	mov	ecx, DWORD PTR _counter$[ebp]
	shl	edx, cl
	and	edx, DWORD PTR _breakable$[ebp]
	je	SHORT $LN1@PickFuncti

; 204  :          i --;

	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN1@PickFuncti:

; 205  :    }

	jmp	SHORT $LN3@PickFuncti
$LN2@PickFuncti:

; 206  : 
; 207  :    retval = (type_FFunction)(1 << counter);

	mov	edx, 1
	mov	ecx, DWORD PTR _counter$[ebp]
	shl	edx, cl
	mov	DWORD PTR _retval$[ebp], edx

; 208  : 
; 209  :    return retval;

	mov	eax, DWORD PTR _retval$[ebp]

; 210  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?PickFunction@FaultClass@@QAE?AW4type_FFunction@1@W4type_FSubSystem@1@@Z ENDP ; FaultClass::PickFunction
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
END
