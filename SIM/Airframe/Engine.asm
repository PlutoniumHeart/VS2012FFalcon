; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\SIM\Airframe\Engine.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B ; std::ios_base::failure::_Stream_err
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?supercruise@@3HA				; supercruise
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
_BSS	SEGMENT
_fireTimer DD	01H DUP (?)
?supercruise@@3HA DD 01H DUP (?)			; supercruise
_BSS	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B
CONST	SEGMENT
?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B DD 01H ; std::ios_base::failure::_Stream_err
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
CONST	SEGMENT
_NEAR_CLIP DD	03f800000r			; 1
_L_2	DD	03f317218r			; 0.693147
_ftitrate DD	03f333333r			; 0.7
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
_DATA	SEGMENT
_matrix33_ident DD 03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	ORG $+4
_matrix44_ident DD 03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
_DATA	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
PUBLIC	_fabsf
PUBLIC	?fabs@@YAMM@Z					; fabs
PUBLIC	?Id@VuEntity@@QBE?AVVU_ID@@XZ			; VuEntity::Id
PUBLIC	?Type@VuEntity@@QBEGXZ				; VuEntity::Type
PUBLIC	?ZPos@VuEntity@@QBEMXZ				; VuEntity::ZPos
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ		; VuBin<VuSessionEntity>::operator bool
PUBLIC	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
PUBLIC	?RequestOutOfBandTransmit@VuMessage@@QAEXXZ	; VuMessage::RequestOutOfBandTransmit
PUBLIC	?IsSetFalcFlag@FalconEntity@@QAEHH@Z		; FalconEntity::IsSetFalcFlag
PUBLIC	?IsPlayer@FalconEntity@@QAEHXZ			; FalconEntity::IsPlayer
PUBLIC	?mlSinCos@@YAXPAUmlTrig@@M@Z			; mlSinCos
PUBLIC	?GetCatapultThrustMultiplier@AirframeClass@@QAEMXZ ; AirframeClass::GetCatapultThrustMultiplier
PUBLIC	?EngineModel@AirframeClass@@QAEXM@Z		; AirframeClass::EngineModel
PUBLIC	?MultiEngineModel@AirframeClass@@QAEXM@Z	; AirframeClass::MultiEngineModel
PUBLIC	?EngineRpmMods@AirframeClass@@QAEMM@Z		; AirframeClass::EngineRpmMods
PUBLIC	?Engine1RpmMods@AirframeClass@@QAEMM@Z		; AirframeClass::Engine1RpmMods
PUBLIC	?Engine2RpmMods@AirframeClass@@QAEMM@Z		; AirframeClass::Engine2RpmMods
PUBLIC	?CalcFtit@AirframeClass@@QAEMMM@Z		; AirframeClass::CalcFtit
PUBLIC	?GetEpuSwitch@AirframeClass@@QAE?AW4EpuState@1@XZ ; AirframeClass::GetEpuSwitch
PUBLIC	?StepEpuSwitch@AirframeClass@@QAEXXZ		; AirframeClass::StepEpuSwitch
PUBLIC	?EpuSetHydrazine@AirframeClass@@QAEXXZ		; AirframeClass::EpuSetHydrazine
PUBLIC	?EpuSetAir@AirframeClass@@QAEXXZ		; AirframeClass::EpuSetAir
PUBLIC	?EpuClear@AirframeClass@@QAEXXZ			; AirframeClass::EpuClear
PUBLIC	?HydrBreak@AirframeClass@@QAEXH@Z		; AirframeClass::HydrBreak
PUBLIC	?HydrDown@AirframeClass@@QAEXH@Z		; AirframeClass::HydrDown
PUBLIC	?HydrRestore@AirframeClass@@QAEXH@Z		; AirframeClass::HydrRestore
PUBLIC	?JfsEngineStart@AirframeClass@@QAEXXZ		; AirframeClass::JfsEngineStart
PUBLIC	?QuickEngineStart@AirframeClass@@QAEXXZ		; AirframeClass::QuickEngineStart
PUBLIC	?IsEngineFlag@AirframeClass@@QAEHW4EngineFlags@1@@Z ; AirframeClass::IsEngineFlag
PUBLIC	?SetEngineFlag@AirframeClass@@QAEXW4EngineFlags@1@@Z ; AirframeClass::SetEngineFlag
PUBLIC	?ClearEngineFlag@AirframeClass@@QAEXW4EngineFlags@1@@Z ; AirframeClass::ClearEngineFlag
PUBLIC	?IncFuelSwitch@AirframeClass@@QAEXXZ		; AirframeClass::IncFuelSwitch
PUBLIC	?DecFuelSwitch@AirframeClass@@QAEXXZ		; AirframeClass::DecFuelSwitch
PUBLIC	?IncFuelPump@AirframeClass@@QAEXXZ		; AirframeClass::IncFuelPump
PUBLIC	?DecFuelPump@AirframeClass@@QAEXXZ		; AirframeClass::DecFuelPump
PUBLIC	?AvailableFuel@AirframeClass@@QAEMXZ		; AirframeClass::AvailableFuel
PUBLIC	?GetJoker@AirframeClass@@QAEMXZ			; AirframeClass::GetJoker
PUBLIC	?GetBingo@AirframeClass@@QAEMXZ			; AirframeClass::GetBingo
PUBLIC	?GetFumes@AirframeClass@@QAEMXZ			; AirframeClass::GetFumes
PUBLIC	?CheckTrapped@AirframeClass@@QAEHXZ		; AirframeClass::CheckTrapped
PUBLIC	?CheckHome@AirframeClass@@QAEHXZ		; AirframeClass::CheckHome
PUBLIC	?IncAirSource@AirframeClass@@QAEXXZ		; AirframeClass::IncAirSource
PUBLIC	?DecAirSource@AirframeClass@@QAEXXZ		; AirframeClass::DecAirSource
PUBLIC	?GeneratorRunning@AirframeClass@@QAEHW4Generator@1@@Z ; AirframeClass::GeneratorRunning
PUBLIC	?GeneratorOK@AirframeClass@@QAEHW4Generator@1@@Z ; AirframeClass::GeneratorOK
PUBLIC	?GeneratorOn@AirframeClass@@QAEXW4Generator@1@@Z ; AirframeClass::GeneratorOn
PUBLIC	?GeneratorOff@AirframeClass@@QAEXW4Generator@1@@Z ; AirframeClass::GeneratorOff
PUBLIC	?GeneratorBreak@AirframeClass@@QAEXW4Generator@1@@Z ; AirframeClass::GeneratorBreak
PUBLIC	?ClearFuel@AirframeClass@@QAEXXZ		; AirframeClass::ClearFuel
PUBLIC	?AllocateFuel@AirframeClass@@QAEXM@Z		; AirframeClass::AllocateFuel
PUBLIC	?BurnFuel@AirframeClass@@QAEHM@Z		; AirframeClass::BurnFuel
PUBLIC	?RecalculateFuel@AirframeClass@@QAEXXZ		; AirframeClass::RecalculateFuel
PUBLIC	?FeedTank@AirframeClass@@QAEXHHM@Z		; AirframeClass::FeedTank
PUBLIC	?FuelFlow@AirframeClass@@QAEMXZ			; AirframeClass::FuelFlow
PUBLIC	?FuelTransfer@AirframeClass@@QAEXM@Z		; AirframeClass::FuelTransfer
PUBLIC	?DropTank@AirframeClass@@QAEXH@Z		; AirframeClass::DropTank
PUBLIC	?GetFuel@AirframeClass@@QAEXPAM00@Z		; AirframeClass::GetFuel
PUBLIC	?GetAeroData@AirframeClass@@QBEMH@Z		; AirframeClass::GetAeroData
PUBLIC	?SetFlag@AirframeClass@@QAEXH@Z			; AirframeClass::SetFlag
PUBLIC	?ClearFlag@AirframeClass@@QAEXH@Z		; AirframeClass::ClearFlag
PUBLIC	?IsSet@AirframeClass@@QBEHH@Z			; AirframeClass::IsSet
PUBLIC	?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ ; VuBin<CampBaseClass>::get
PUBLIC	?IsSetFlag@SimBaseClass@@QBEHH@Z		; SimBaseClass::IsSetFlag
PUBLIC	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
PUBLIC	?MaxStrength@SimBaseClass@@QAEMXZ		; SimBaseClass::MaxStrength
PUBLIC	?IsF16@AircraftClass@@QAEHXZ			; AircraftClass::IsF16
PUBLIC	?MainPowerOn@AircraftClass@@QAEHXZ		; AircraftClass::MainPowerOn
PUBLIC	?ClearFault@FackClass@@QAEXW4type_FSubSystem@FaultClass@@W4type_FFunction@3@@Z ; FackClass::ClearFault
PUBLIC	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
PUBLIC	?GetOwner@CampBaseClass@@QAEEXZ			; CampBaseClass::GetOwner
PUBLIC	??0id@locale@std@@QAE@I@Z			; std::locale::id::id
PUBLIC	?generic_category@std@@YAABVerror_category@1@XZ	; std::generic_category
PUBLIC	?system_category@std@@YAABVerror_category@1@XZ	; std::system_category
PUBLIC	??0error_category@std@@QAE@XZ			; std::error_category::error_category
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??8error_category@std@@QBE_NABV01@@Z		; std::error_category::operator==
PUBLIC	??_Gerror_category@std@@UAEPAXI@Z		; std::error_category::`scalar deleting destructor'
PUBLIC	?value@error_code@std@@QBEHXZ			; std::error_code::value
PUBLIC	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
PUBLIC	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?value@error_condition@std@@QBEHXZ		; std::error_condition::value
PUBLIC	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
PUBLIC	??8error_condition@std@@QBE_NABV01@@Z		; std::error_condition::operator==
PUBLIC	??0_Generic_error_category@std@@QAE@XZ		; std::_Generic_error_category::_Generic_error_category
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	??1_Generic_error_category@std@@UAE@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	??0_Iostream_error_category@std@@QAE@XZ		; std::_Iostream_error_category::_Iostream_error_category
PUBLIC	?name@_Iostream_error_category@std@@UBEPBDXZ	; std::_Iostream_error_category::name
PUBLIC	?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	??1_Iostream_error_category@std@@UAE@XZ		; std::_Iostream_error_category::~_Iostream_error_category
PUBLIC	??_G_Iostream_error_category@std@@UAEPAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	??0_System_error_category@std@@QAE@XZ		; std::_System_error_category::_System_error_category
PUBLIC	?name@_System_error_category@std@@UBEPBDXZ	; std::_System_error_category::name
PUBLIC	?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message
PUBLIC	?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition
PUBLIC	??1_System_error_category@std@@UAE@XZ		; std::_System_error_category::~_System_error_category
PUBLIC	??_G_System_error_category@std@@UAEPAXI@Z	; std::_System_error_category::`scalar deleting destructor'
PUBLIC	?IsAxisCutOff@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z ; SIMLIB_IO_CLASS::IsAxisCutOff
PUBLIC	?getCurrentEngine@PilotInputs@@QAE?AW4Engine_t@1@XZ ; PilotInputs::getCurrentEngine
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??_7error_category@std@@6B@			; std::error_category::`vftable'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_C@_07DCLBNMLN@generic?$AA@			; `string'
PUBLIC	??_C@_0O@BFJCFAAK@unknown?5error?$AA@		; `string'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream?$AA@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	; `string'
PUBLIC	??_7_System_error_category@std@@6B@		; std::_System_error_category::`vftable'
PUBLIC	??_C@_06FHFOAHML@system?$AA@			; `string'
PUBLIC	?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
PUBLIC	?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
PUBLIC	?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
PUBLIC	?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
PUBLIC	?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	?id@?$numpunct@_W@std@@2V0locale@2@A		; std::numpunct<wchar_t>::id
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_R4error_category@std@@6B@			; std::error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error_category@std@@6B@		; std::_System_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_System_error_category@std@@@8		; std::_System_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_System_error_category@std@@8		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error_category@std@@8		; std::_System_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error_category@std@@8	; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
PUBLIC	__real@3c23d70a
PUBLIC	__real@3cf5c28f
PUBLIC	__real@3d75c28f
PUBLIC	__real@3dcccccd
PUBLIC	__real@3df5c28f
PUBLIC	__real@3e4ccccd
PUBLIC	__real@3e800000
PUBLIC	__real@3e99999a
PUBLIC	__real@3ecccccd
PUBLIC	__real@3ee66666
PUBLIC	__real@3f000000
PUBLIC	__real@3f0ccccd
PUBLIC	__real@3f19999a
PUBLIC	__real@3f2b851f
PUBLIC	__real@3f2e147b
PUBLIC	__real@3f30a3d7
PUBLIC	__real@3f333333
PUBLIC	__real@3f400000
PUBLIC	__real@3f4a3d71
PUBLIC	__real@3f4ccccd
PUBLIC	__real@3f570a3d
PUBLIC	__real@3f59999a
PUBLIC	__real@3f666666
PUBLIC	__real@3f733333
PUBLIC	__real@3f7d70a4
PUBLIC	__real@3f800000
PUBLIC	__real@3f8147ae
PUBLIC	__real@3f81eb85
PUBLIC	__real@3f833333
PUBLIC	__real@3f8ccccd
PUBLIC	__real@3f970a3d
PUBLIC	__real@3f99999a
PUBLIC	__real@3f9d70a4
PUBLIC	__real@3fb33333
PUBLIC	__real@3fc00000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@40000000
PUBLIC	__real@40800000
PUBLIC	__real@40a33333
PUBLIC	__real@40bb3333
PUBLIC	__real@40c33333
PUBLIC	__real@40e00000
PUBLIC	__real@40f33333
PUBLIC	__real@41200000
PUBLIC	__real@41700000
PUBLIC	__real@41900000
PUBLIC	__real@41a00000
PUBLIC	__real@41e00000
PUBLIC	__real@41f00000
PUBLIC	__real@4200b53f
PUBLIC	__real@42200000
PUBLIC	__real@42700000
PUBLIC	__real@42a00000
PUBLIC	__real@42b40000
PUBLIC	__real@42c80000
PUBLIC	__real@43160000
PUBLIC	__real@432f0000
PUBLIC	__real@43610000
PUBLIC	__real@43700000
PUBLIC	__real@437a0000
PUBLIC	__real@43960000
PUBLIC	__real@43c80000
PUBLIC	__real@43e10000
PUBLIC	__real@43fa0000
PUBLIC	__real@44fa0000
PUBLIC	__real@45610000
PUBLIC	__real@45bb8000
PUBLIC	__real@461c4000
PUBLIC	__real@468ca000
PUBLIC	__real@469c4000
PUBLIC	__real@46c35000
PUBLIC	__real@bf000000
PUBLIC	__real@bf800000
PUBLIC	__real@c2c80000
PUBLIC	__real@c61c4000
PUBLIC	__real@c6ea6000
PUBLIC	__real@c708b800
PUBLIC	__real@c71c4000
PUBLIC	__real@c72fc800
PUBLIC	__real@c7435000
PUBLIC	__real@c756d800
PUBLIC	__real@c76a6000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	_fabs:PROC
EXTRN	_rand:PROC
EXTRN	_memcpy:PROC
EXTRN	_strlen:PROC
EXTRN	_memmove:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ:PROC ; VuSessionEntity::Game
EXTRN	?FLTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z:PROC	; SIMLIB_MATH_CLASS::FLTust
EXTRN	?TwodInterp@SIMLIB_MATH_CLASS@@QAEMMMPBM00HHPAH1@Z:PROC ; SIMLIB_MATH_CLASS::TwodInterp
EXTRN	?Sfx@F4SoundPos@@QAEXHHMM@Z:PROC		; F4SoundPos::Sfx
EXTRN	?GetWayPointNo@SimVehicleClass@@QAEPAVWayPointClass@@H@Z:PROC ; SimVehicleClass::GetWayPointNo
EXTRN	?ClearFault@FaultClass@@QAEXW4type_FSubSystem@1@W4type_FFunction@1@@Z:PROC ; FaultClass::ClearFault
EXTRN	?SetFault@FackClass@@QAEXW4type_FSubSystem@FaultClass@@W4type_FFunction@3@W4type_FSeverity@3@H@Z:PROC ; FackClass::SetFault
EXTRN	?SetFault@FackClass@@QAEXW4type_CSubSystem@@@Z:PROC ; FackClass::SetFault
EXTRN	?ClearFault@FackClass@@QAEXW4type_CSubSystem@@@Z:PROC ; FackClass::ClearFault
EXTRN	?GetFault@FackClass@@QAEHW4type_FSubSystem@FaultClass@@@Z:PROC ; FackClass::GetFault
EXTRN	?GetFault@FackClass@@QAEHW4type_CSubSystem@@@Z:PROC ; FackClass::GetFault
EXTRN	?SetCaution@FackClass@@QAEXW4type_CSubSystem@@@Z:PROC ; FackClass::SetCaution
EXTRN	?FalconSendMessage@@YAXPAVVuMessage@@H@Z:PROC	; FalconSendMessage
EXTRN	?GetLocation@WayPointClass@@QBEXPAM00@Z:PROC	; WayPointClass::GetLocation
EXTRN	??0FalconDamageMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z:PROC ; FalconDamageMessage::FalconDamageMessage
EXTRN	??_Eerror_category@std@@UAEPAXI@Z:PROC		; std::error_category::`vector deleting destructor'
EXTRN	?_Syserror_map@std@@YAPBDH@Z:PROC		; std::_Syserror_map
EXTRN	?_Winerror_map@std@@YAPBDH@Z:PROC		; std::_Winerror_map
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_E_System_error_category@std@@UAEPAXI@Z:PROC	; std::_System_error_category::`vector deleting destructor'
EXTRN	?ChooseLimiterMode@SMSClass@@QAEXH@Z:PROC	; SMSClass::ChooseLimiterMode
EXTRN	?ToggleThrustReverseDisplay@OTWDriverClass@@QAEXXZ:PROC ; OTWDriverClass::ToggleThrustReverseDisplay
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A:DWORD ; vuLocalSessionEntity
EXTRN	?SimLibMajorFrameTime@@3MA:DWORD		; SimLibMajorFrameTime
EXTRN	?SimLibElapsedTime@@3KA:DWORD			; SimLibElapsedTime
EXTRN	?Math@@3VSIMLIB_MATH_CLASS@@A:BYTE		; Math
EXTRN	?aeroDataset@@3PAVAeroDataSet@@A:DWORD		; aeroDataset
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?IO@@3VSIMLIB_IO_CLASS@@A:BYTE			; IO
EXTRN	?UserStickInputs@@3VPilotInputs@@A:BYTE		; UserStickInputs
EXTRN	?g_bRealisticAvionics@@3_NA:BYTE		; g_bRealisticAvionics
EXTRN	?OTWDriver@@3VOTWDriverClass@@A:BYTE		; OTWDriver
EXTRN	?g_bUseAnalogIdleCutoff@@3_NA:BYTE		; g_bUseAnalogIdleCutoff
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
_BSS	SEGMENT
?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Generic_object
_BSS	ENDS
;	COMDAT ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
_BSS	SEGMENT
?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Iostream_object
_BSS	ENDS
;	COMDAT ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
_BSS	SEGMENT
?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_System_object
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
_BSS	ENDS
;	COMDAT ?doOnce@?LF@??EngineModel@AirframeClass@@QAEXM@Z@4HA
_BSS	SEGMENT
?doOnce@?LF@??EngineModel@AirframeClass@@QAEXM@Z@4HA DD 01H DUP (?) ; `AirframeClass::EngineModel'::`181'::doOnce
_BSS	ENDS
;	COMDAT ?doOnce@?BFC@??MultiEngineModel@AirframeClass@@QAEXM@Z@4HA
_BSS	SEGMENT
?doOnce@?BFC@??MultiEngineModel@AirframeClass@@QAEXM@Z@4HA DD 01H DUP (?) ; `AirframeClass::MultiEngineModel'::`338'::doOnce
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@_W@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@_W@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<wchar_t>::id
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@c76a6000
CONST	SEGMENT
__real@c76a6000 DD 0c76a6000r			; -60000
CONST	ENDS
;	COMDAT __real@c756d800
CONST	SEGMENT
__real@c756d800 DD 0c756d800r			; -55000
CONST	ENDS
;	COMDAT __real@c7435000
CONST	SEGMENT
__real@c7435000 DD 0c7435000r			; -50000
CONST	ENDS
;	COMDAT __real@c72fc800
CONST	SEGMENT
__real@c72fc800 DD 0c72fc800r			; -45000
CONST	ENDS
;	COMDAT __real@c71c4000
CONST	SEGMENT
__real@c71c4000 DD 0c71c4000r			; -40000
CONST	ENDS
;	COMDAT __real@c708b800
CONST	SEGMENT
__real@c708b800 DD 0c708b800r			; -35000
CONST	ENDS
;	COMDAT __real@c6ea6000
CONST	SEGMENT
__real@c6ea6000 DD 0c6ea6000r			; -30000
CONST	ENDS
;	COMDAT __real@c61c4000
CONST	SEGMENT
__real@c61c4000 DD 0c61c4000r			; -10000
CONST	ENDS
;	COMDAT __real@c2c80000
CONST	SEGMENT
__real@c2c80000 DD 0c2c80000r			; -100
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@bf000000
CONST	SEGMENT
__real@bf000000 DD 0bf000000r			; -0.5
CONST	ENDS
;	COMDAT __real@46c35000
CONST	SEGMENT
__real@46c35000 DD 046c35000r			; 25000
CONST	ENDS
;	COMDAT __real@469c4000
CONST	SEGMENT
__real@469c4000 DD 0469c4000r			; 20000
CONST	ENDS
;	COMDAT __real@468ca000
CONST	SEGMENT
__real@468ca000 DD 0468ca000r			; 18000
CONST	ENDS
;	COMDAT __real@461c4000
CONST	SEGMENT
__real@461c4000 DD 0461c4000r			; 10000
CONST	ENDS
;	COMDAT __real@45bb8000
CONST	SEGMENT
__real@45bb8000 DD 045bb8000r			; 6000
CONST	ENDS
;	COMDAT __real@45610000
CONST	SEGMENT
__real@45610000 DD 045610000r			; 3600
CONST	ENDS
;	COMDAT __real@44fa0000
CONST	SEGMENT
__real@44fa0000 DD 044fa0000r			; 2000
CONST	ENDS
;	COMDAT __real@43fa0000
CONST	SEGMENT
__real@43fa0000 DD 043fa0000r			; 500
CONST	ENDS
;	COMDAT __real@43e10000
CONST	SEGMENT
__real@43e10000 DD 043e10000r			; 450
CONST	ENDS
;	COMDAT __real@43c80000
CONST	SEGMENT
__real@43c80000 DD 043c80000r			; 400
CONST	ENDS
;	COMDAT __real@43960000
CONST	SEGMENT
__real@43960000 DD 043960000r			; 300
CONST	ENDS
;	COMDAT __real@437a0000
CONST	SEGMENT
__real@437a0000 DD 0437a0000r			; 250
CONST	ENDS
;	COMDAT __real@43700000
CONST	SEGMENT
__real@43700000 DD 043700000r			; 240
CONST	ENDS
;	COMDAT __real@43610000
CONST	SEGMENT
__real@43610000 DD 043610000r			; 225
CONST	ENDS
;	COMDAT __real@432f0000
CONST	SEGMENT
__real@432f0000 DD 0432f0000r			; 175
CONST	ENDS
;	COMDAT __real@43160000
CONST	SEGMENT
__real@43160000 DD 043160000r			; 150
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@42b40000
CONST	SEGMENT
__real@42b40000 DD 042b40000r			; 90
CONST	ENDS
;	COMDAT __real@42a00000
CONST	SEGMENT
__real@42a00000 DD 042a00000r			; 80
CONST	ENDS
;	COMDAT __real@42700000
CONST	SEGMENT
__real@42700000 DD 042700000r			; 60
CONST	ENDS
;	COMDAT __real@42200000
CONST	SEGMENT
__real@42200000 DD 042200000r			; 40
CONST	ENDS
;	COMDAT __real@4200b53f
CONST	SEGMENT
__real@4200b53f DD 04200b53fr			; 32.177
CONST	ENDS
;	COMDAT __real@41f00000
CONST	SEGMENT
__real@41f00000 DD 041f00000r			; 30
CONST	ENDS
;	COMDAT __real@41e00000
CONST	SEGMENT
__real@41e00000 DD 041e00000r			; 28
CONST	ENDS
;	COMDAT __real@41a00000
CONST	SEGMENT
__real@41a00000 DD 041a00000r			; 20
CONST	ENDS
;	COMDAT __real@41900000
CONST	SEGMENT
__real@41900000 DD 041900000r			; 18
CONST	ENDS
;	COMDAT __real@41700000
CONST	SEGMENT
__real@41700000 DD 041700000r			; 15
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@40f33333
CONST	SEGMENT
__real@40f33333 DD 040f33333r			; 7.6
CONST	ENDS
;	COMDAT __real@40e00000
CONST	SEGMENT
__real@40e00000 DD 040e00000r			; 7
CONST	ENDS
;	COMDAT __real@40c33333
CONST	SEGMENT
__real@40c33333 DD 040c33333r			; 6.1
CONST	ENDS
;	COMDAT __real@40bb3333
CONST	SEGMENT
__real@40bb3333 DD 040bb3333r			; 5.85
CONST	ENDS
;	COMDAT __real@40a33333
CONST	SEGMENT
__real@40a33333 DD 040a33333r			; 5.1
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fc00000
CONST	SEGMENT
__real@3fc00000 DD 03fc00000r			; 1.5
CONST	ENDS
;	COMDAT __real@3fb33333
CONST	SEGMENT
__real@3fb33333 DD 03fb33333r			; 1.4
CONST	ENDS
;	COMDAT __real@3f9d70a4
CONST	SEGMENT
__real@3f9d70a4 DD 03f9d70a4r			; 1.23
CONST	ENDS
;	COMDAT __real@3f99999a
CONST	SEGMENT
__real@3f99999a DD 03f99999ar			; 1.2
CONST	ENDS
;	COMDAT __real@3f970a3d
CONST	SEGMENT
__real@3f970a3d DD 03f970a3dr			; 1.18
CONST	ENDS
;	COMDAT __real@3f8ccccd
CONST	SEGMENT
__real@3f8ccccd DD 03f8ccccdr			; 1.1
CONST	ENDS
;	COMDAT __real@3f833333
CONST	SEGMENT
__real@3f833333 DD 03f833333r			; 1.025
CONST	ENDS
;	COMDAT __real@3f81eb85
CONST	SEGMENT
__real@3f81eb85 DD 03f81eb85r			; 1.015
CONST	ENDS
;	COMDAT __real@3f8147ae
CONST	SEGMENT
__real@3f8147ae DD 03f8147aer			; 1.01
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f7d70a4
CONST	SEGMENT
__real@3f7d70a4 DD 03f7d70a4r			; 0.99
CONST	ENDS
;	COMDAT __real@3f733333
CONST	SEGMENT
__real@3f733333 DD 03f733333r			; 0.95
CONST	ENDS
;	COMDAT __real@3f666666
CONST	SEGMENT
__real@3f666666 DD 03f666666r			; 0.9
CONST	ENDS
;	COMDAT __real@3f59999a
CONST	SEGMENT
__real@3f59999a DD 03f59999ar			; 0.85
CONST	ENDS
;	COMDAT __real@3f570a3d
CONST	SEGMENT
__real@3f570a3d DD 03f570a3dr			; 0.84
CONST	ENDS
;	COMDAT __real@3f4ccccd
CONST	SEGMENT
__real@3f4ccccd DD 03f4ccccdr			; 0.8
CONST	ENDS
;	COMDAT __real@3f4a3d71
CONST	SEGMENT
__real@3f4a3d71 DD 03f4a3d71r			; 0.79
CONST	ENDS
;	COMDAT __real@3f400000
CONST	SEGMENT
__real@3f400000 DD 03f400000r			; 0.75
CONST	ENDS
;	COMDAT __real@3f333333
CONST	SEGMENT
__real@3f333333 DD 03f333333r			; 0.7
CONST	ENDS
;	COMDAT __real@3f30a3d7
CONST	SEGMENT
__real@3f30a3d7 DD 03f30a3d7r			; 0.69
CONST	ENDS
;	COMDAT __real@3f2e147b
CONST	SEGMENT
__real@3f2e147b DD 03f2e147br			; 0.68
CONST	ENDS
;	COMDAT __real@3f2b851f
CONST	SEGMENT
__real@3f2b851f DD 03f2b851fr			; 0.67
CONST	ENDS
;	COMDAT __real@3f19999a
CONST	SEGMENT
__real@3f19999a DD 03f19999ar			; 0.6
CONST	ENDS
;	COMDAT __real@3f0ccccd
CONST	SEGMENT
__real@3f0ccccd DD 03f0ccccdr			; 0.55
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3ee66666
CONST	SEGMENT
__real@3ee66666 DD 03ee66666r			; 0.45
CONST	ENDS
;	COMDAT __real@3ecccccd
CONST	SEGMENT
__real@3ecccccd DD 03ecccccdr			; 0.4
CONST	ENDS
;	COMDAT __real@3e99999a
CONST	SEGMENT
__real@3e99999a DD 03e99999ar			; 0.3
CONST	ENDS
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT __real@3e4ccccd
CONST	SEGMENT
__real@3e4ccccd DD 03e4ccccdr			; 0.2
CONST	ENDS
;	COMDAT __real@3df5c28f
CONST	SEGMENT
__real@3df5c28f DD 03df5c28fr			; 0.12
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3d75c28f
CONST	SEGMENT
__real@3d75c28f DD 03d75c28fr			; 0.06
CONST	ENDS
;	COMDAT __real@3cf5c28f
CONST	SEGMENT
__real@3cf5c28f DD 03cf5c28fr			; 0.03
CONST	ENDS
;	COMDAT __real@3c23d70a
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error_category@std@@8 DD FLAT:??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error_category@std@@8
rdata$r	SEGMENT
??_R2_System_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error_category@std@@8
rdata$r	SEGMENT
??_R3_System_error_category@std@@8 DD 00H		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_System_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_System_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_System_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_System_error_category@std@@6B@ DD 00H		; std::_System_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error_category@std@@@8
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD FLAT:??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 00H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category@std@@@8
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
_DATA	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4error_category@std@@6B@
rdata$r	SEGMENT
??_R4error_category@std@@6B@ DD 00H			; std::error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVerror_category@std@@@8
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system?$AA@
CONST	SEGMENT
??_C@_06FHFOAHML@system?$AA@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_System_error_category@std@@6B@
CONST	SEGMENT
??_7_System_error_category@std@@6B@ DD FLAT:??_R4_System_error_category@std@@6B@ ; std::_System_error_category::`vftable'
	DD	FLAT:??_E_System_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_System_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ DB 'iostream stream error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream?$AA@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream?$AA@ DB 'iostream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DD FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DD	FLAT:??_E_Iostream_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
CONST	SEGMENT
??_C@_0O@BFJCFAAK@unknown?5error?$AA@ DB 'unknown error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic?$AA@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic?$AA@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7error_category@std@@6B@
CONST	SEGMENT
??_7error_category@std@@6B@ DD FLAT:??_R4error_category@std@@6B@ ; std::error_category::`vftable'
	DD	FLAT:??_Eerror_category@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
__ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
xdata$x	SEGMENT
__unwindtable$?EngineModel@AirframeClass@@QAEXM@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?EngineModel@AirframeClass@@QAEXM@Z$0
__unwindtable$?MultiEngineModel@AirframeClass@@QAEXM@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?MultiEngineModel@AirframeClass@@QAEXM@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?MultiEngineModel@AirframeClass@@QAEXM@Z$1
__ehfuncinfo$?MultiEngineModel@AirframeClass@@QAEXM@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?MultiEngineModel@AirframeClass@@QAEXM@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?EngineModel@AirframeClass@@QAEXM@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?EngineModel@AirframeClass@@QAEXM@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Generic_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Iostream_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_System_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@D@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<char>::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@_W@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<wchar_t>::id$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 621  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();
; 624  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
_this$ = -24						; size = 4
tv73 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR __V0$[ebp]
	push	ecx
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<wchar_t>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@_W@std@@2V0locale@2@A ; std::numpunct<wchar_t>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<wchar_t>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<char>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<char>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 755  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp

; 756  : 		{	// destroy object at _Ptr
; 757  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>

; 758  : 		}

	pop	ebp
	ret	0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
	pop	ebp
	ret	0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	ebp
	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??1_System_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_System_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??0_System_error_category@std@@QAE@XZ	; std::_System_error_category::_System_error_category
	push	OFFSET ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_System_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??1_Iostream_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??0_Iostream_error_category@std@@QAE@XZ	; std::_Iostream_error_category::_Iostream_error_category
	push	OFFSET ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??1_Generic_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	push	OFFSET ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], -1
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 85   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 89   : 	}

	pop	ebp
	ret	0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 907  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
	add	esp, 8

; 910  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
	add	esp, 12					; 0000000cH
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\pilotinputs.h
;	COMDAT ?getCurrentEngine@PilotInputs@@QAE?AW4Engine_t@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getCurrentEngine@PilotInputs@@QAE?AW4Engine_t@1@XZ PROC ; PilotInputs::getCurrentEngine, COMDAT
; _this$ = ecx

; 49   : 	  Engine_t getCurrentEngine() { return currentlyActiveEngine; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+100]
	mov	esp, ebp
	pop	ebp
	ret	0
?getCurrentEngine@PilotInputs@@QAE?AW4Engine_t@1@XZ ENDP ; PilotInputs::getCurrentEngine
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simio.h
;	COMDAT ?IsAxisCutOff@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z
_TEXT	SEGMENT
tv75 = -8						; size = 4
_this$ = -4						; size = 4
_id$ = 8						; size = 4
?IsAxisCutOff@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z PROC ; SIMLIB_IO_CLASS::IsAxisCutOff, COMDAT
; _this$ = ecx

; 244  : 	bool	IsAxisCutOff(GameAxis_t id) { return (analog[id].ioVal > (analog[id].cutoff + idleCutoffPad)); } // MD -- 20040210

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _id$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _id$[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+1660]
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+eax+8], ecx
	jle	SHORT $LN3@IsAxisCutO
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN4@IsAxisCutO
$LN3@IsAxisCutO:
	mov	DWORD PTR tv75[ebp], 0
$LN4@IsAxisCutO:
	mov	al, BYTE PTR tv75[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsAxisCutOff@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z ENDP ; SIMLIB_IO_CLASS::IsAxisCutOff
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_System_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_System_error_category@std@@UAEPAXI@Z PROC		; std::_System_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_System_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_System_error_category@std@@UAEPAXI@Z ENDP		; std::_System_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_System_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_System_error_category@std@@UAE@XZ PROC		; std::_System_error_category::~_System_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_System_error_category@std@@UAE@XZ ENDP		; std::_System_error_category::~_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::_System_error_category::default_error_condition, COMDAT
; _this$ = ecx

; 641  : 		{	// make error_condition for error code (generic if possible)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 642  : 		if (_Syserror_map(_Errval))

	mov	eax, DWORD PTR __Errval$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@default_er

; 643  : 			return (error_condition(_Errval, generic_category()));

	call	?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@default_er

; 644  : 		else

	jmp	SHORT $LN3@default_er
$LN2@default_er:

; 645  : 			return (error_condition(_Errval, system_category()));

	call	?system_category@std@@YAABVerror_category@1@XZ ; std::system_category
	push	eax
	mov	edx, DWORD PTR __Errval$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@default_er:

; 646  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::_System_error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_System_error_category::message, COMDAT
; _this$ = ecx

; 634  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 635  : 		const char *_Name = _Winerror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Winerror_map@std@@YAPBDH@Z		; std::_Winerror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 636  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 637  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_System_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_System_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_System_error_category@std@@UBEPBDXZ PROC		; std::_System_error_category::name, COMDAT
; _this$ = ecx

; 629  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 630  : 		return ("system");

	mov	eax, OFFSET ??_C@_06FHFOAHML@system?$AA@

; 631  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_System_error_category@std@@UBEPBDXZ ENDP		; std::_System_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_System_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_System_error_category@std@@QAE@XZ PROC		; std::_System_error_category::_System_error_category, COMDAT
; _this$ = ecx

; 624  : 	_System_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_System_error_category@std@@6B@

; 625  : 		{	// default constructor
; 626  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_System_error_category@std@@QAE@XZ ENDP		; std::_System_error_category::_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Iostream_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Iostream_error_category@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iostream_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Iostream_error_category@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Iostream_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Iostream_error_category@std@@UAE@XZ PROC		; std::_Iostream_error_category::~_Iostream_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Iostream_error_category@std@@UAE@XZ ENDP		; std::_Iostream_error_category::~_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT
; _this$ = ecx

; 611  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 612  : 		if (_Errcode == (int)io_errc::stream)

	cmp	DWORD PTR __Errcode$[ebp], 1
	jne	SHORT $LN2@message

; 613  : 			return ("iostream stream error");

	push	OFFSET ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@message

; 614  : 		else

	jmp	SHORT $LN3@message
$LN2@message:

; 615  : 			return (_Generic_error_category::message(_Errcode));

	mov	ecx, DWORD PTR __Errcode$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@message:

; 616  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Iostream_error_category@std@@UBEPBDXZ PROC	; std::_Iostream_error_category::name, COMDAT
; _this$ = ecx

; 606  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 607  : 		return ("iostream");

	mov	eax, OFFSET ??_C@_08LLGCOLLL@iostream?$AA@

; 608  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Iostream_error_category@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Iostream_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iostream_error_category@std@@QAE@XZ PROC		; std::_Iostream_error_category::_Iostream_error_category, COMDAT
; _this$ = ecx

; 601  : 	_Iostream_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Iostream_error_category@std@@6B@

; 602  : 		{	// default constructor
; 603  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iostream_error_category@std@@QAE@XZ ENDP		; std::_Iostream_error_category::_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Generic_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Generic_error_category@std@@UAE@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Generic_error_category@std@@UAE@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 590  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 591  : 		const char *_Name = _Syserror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 592  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 593  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 585  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		return ("generic");

	mov	eax, OFFSET ??_C@_07DCLBNMLN@generic?$AA@

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Generic_error_category@std@@QAE@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT
; _this$ = ecx

; 580  : 	_Generic_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0error_category@std@@QAE@XZ		; std::error_category::error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Generic_error_category@std@@6B@

; 581  : 		{	// default constructor
; 582  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Generic_error_category@std@@QAE@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_condition@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv78 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8error_condition@std@@QBE_NABV01@@Z PROC		; std::error_condition::operator==, COMDAT
; _this$ = ecx

; 376  : 		{	// test if *this == _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 377  : 		return (category() == _Right.category()
; 378  : 			&& value() == _Right.value());

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	mov	ecx, eax
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	cmp	esi, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv78[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv78[ebp]

; 379  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??8error_condition@std@@QBE_NABV01@@Z ENDP		; std::error_condition::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 354  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 356  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 349  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 350  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 351  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 316  : 		{	// construct from error code and category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Cat$[ebp]
	mov	DWORD PTR [edx+4], eax

; 317  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 256  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 257  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 258  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 251  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 252  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 253  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gerror_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gerror_category@std@@UAEPAXI@Z PROC			; std::error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gerror_category@std@@UAEPAXI@Z ENDP			; std::error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv65 = -4						; size = 4
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 184  : 		{	// compare categories for equality

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 185  : 		return (this == &_Right);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv65[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv65[ebp]

; 186  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -4						; size = 4
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 415  : 	{	// test if conditions same for this category

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 416  : 	return (*this == _Code.category() && _Code.value() == _Errval);

	mov	ecx, DWORD PTR __Code$[ebp]
	call	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@equivalent
	mov	ecx, DWORD PTR __Code$[ebp]
	call	?value@error_code@std@@QBEHXZ		; std::error_code::value
	cmp	eax, DWORD PTR __Errval$[ebp]
	jne	SHORT $LN3@equivalent
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN4@equivalent
$LN3@equivalent:
	mov	DWORD PTR tv74[ebp], 0
$LN4@equivalent:
	mov	al, BYTE PTR tv74[ebp]

; 417  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 408  : 	{	// test if error code same condition

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 409  : 	return (default_error_condition(_Errval) == _Cond);

	mov	eax, DWORD PTR __Cond$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	ecx, eax
	call	??8error_condition@std@@QBE_NABV01@@Z	; std::error_condition::operator==

; 410  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 401  : 	{	// make error_condition for error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 402  : 	return (error_condition(_Errval, *this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 403  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 167  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 168  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0error_category@std@@QAE@XZ PROC			; std::error_category::error_category, COMDAT
; _this$ = ecx

; 162  : 	error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 163  : 		{	// default constructor
; 164  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0error_category@std@@QAE@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?system_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?system_category@std@@YAABVerror_category@1@XZ PROC	; std::system_category, COMDAT

; 679  : 	{	// get system_category

	push	ebp
	mov	ebp, esp

; 680  : 	return (_Error_objects<int>::_System_object);

	mov	eax, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object

; 681  : 	}

	pop	ebp
	ret	0
?system_category@std@@YAABVerror_category@1@XZ ENDP	; std::system_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?generic_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?generic_category@std@@YAABVerror_category@1@XZ PROC	; std::generic_category, COMDAT

; 669  : 	{	// get generic_category

	push	ebp
	mov	ebp, esp

; 670  : 	return (_Error_objects<int>::_Generic_object);

	mov	eax, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object

; 671  : 	}

	pop	ebp
	ret	0
?generic_category@std@@YAABVerror_category@1@XZ ENDP	; std::generic_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocale
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC				; std::locale::id::id, COMDAT
; _this$ = ecx

; 74   : 			{	// construct with specified stamp value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx

; 75   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetOwner@CampBaseClass@@QAEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetOwner@CampBaseClass@@QAEEXZ PROC			; CampBaseClass::GetOwner, COMDAT
; _this$ = ecx

; 241  : 	Control GetOwner (void)										{	return owner; }			// Old form

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+154]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetOwner@CampBaseClass@@QAEEXZ ENDP			; CampBaseClass::GetOwner
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcsess.h
;	COMDAT ?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ PROC ; FalconSessionEntity::GetGame, COMDAT
; _this$ = ecx

; 154  : 	FalconGameEntity* GetGame (void)              { return (FalconGameEntity*)VuSessionEntity::Game(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ ; VuSessionEntity::Game
	mov	esp, ebp
	pop	ebp
	ret	0
?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ENDP ; FalconSessionEntity::GetGame
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fack.h
;	COMDAT ?ClearFault@FackClass@@QAEXW4type_FSubSystem@FaultClass@@W4type_FFunction@3@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ss$ = 8						; size = 4
_type$ = 12						; size = 4
?ClearFault@FackClass@@QAEXW4type_FSubSystem@FaultClass@@W4type_FFunction@3@@Z PROC ; FackClass::ClearFault, COMDAT
; _this$ = ecx

; 28   :     void	ClearFault(FaultClass::type_FSubSystem ss, FaultClass::type_FFunction type) { mFaults.ClearFault(ss, type); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ss$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?ClearFault@FaultClass@@QAEXW4type_FSubSystem@1@W4type_FFunction@1@@Z ; FaultClass::ClearFault
	mov	esp, ebp
	pop	ebp
	ret	8
?ClearFault@FackClass@@QAEXW4type_FSubSystem@FaultClass@@W4type_FFunction@3@@Z ENDP ; FackClass::ClearFault
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?MainPowerOn@AircraftClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
?MainPowerOn@AircraftClass@@QAEHXZ PROC			; AircraftClass::MainPowerOn, COMDAT
; _this$ = ecx

; 520  : 	BOOL MainPowerOn() { return mainPower == MainPowerMain; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1484], 2
	jne	SHORT $LN3@MainPowerO
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@MainPowerO
$LN3@MainPowerO:
	mov	DWORD PTR tv66[ebp], 0
$LN4@MainPowerO:
	mov	eax, DWORD PTR tv66[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?MainPowerOn@AircraftClass@@QAEHXZ ENDP			; AircraftClass::MainPowerOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?IsF16@AircraftClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
?IsF16@AircraftClass@@QAEHXZ PROC			; AircraftClass::IsF16, COMDAT
; _this$ = ecx

; 335  : 	int            IsF16 (void) {return (acFlags & isF16 ? TRUE : FALSE);}

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+964]
	and	ecx, 1
	je	SHORT $LN3@IsF16
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsF16
$LN3@IsF16:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsF16:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?IsF16@AircraftClass@@QAEHXZ ENDP			; AircraftClass::IsF16
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
;	COMDAT ?MaxStrength@SimBaseClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?MaxStrength@SimBaseClass@@QAEMXZ PROC			; SimBaseClass::MaxStrength, COMDAT
; _this$ = ecx

; 227  : 	float MaxStrength (void) {return maxStrength;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+244]
	mov	esp, ebp
	pop	ebp
	ret	0
?MaxStrength@SimBaseClass@@QAEMXZ ENDP			; SimBaseClass::MaxStrength
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
;	COMDAT ?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ PROC ; SimBaseClass::GetCampaignObject, COMDAT
; _this$ = ecx

; 212  : 	CampBaseClass *GetCampaignObject (void) { return campaignObject.get(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 144				; 00000090H
	call	?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ ; VuBin<CampBaseClass>::get
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ENDP ; SimBaseClass::GetCampaignObject
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
;	COMDAT ?IsSetFlag@SimBaseClass@@QBEHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
_flag$ = 8						; size = 4
?IsSetFlag@SimBaseClass@@QBEHH@Z PROC			; SimBaseClass::IsSetFlag, COMDAT
; _this$ = ecx

; 178  : 	int  IsSetFlag(int flag) const { return ((specialData.flags & flag) ? TRUE : FALSE); }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+172]
	and	ecx, DWORD PTR _flag$[ebp]
	je	SHORT $LN3@IsSetFlag
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@IsSetFlag
$LN3@IsSetFlag:
	mov	DWORD PTR tv68[ebp], 0
$LN4@IsSetFlag:
	mov	eax, DWORD PTR tv68[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsSetFlag@SimBaseClass@@QBEHH@Z ENDP			; SimBaseClass::IsSetFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ PROC ; VuBin<CampBaseClass>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ ENDP ; VuBin<CampBaseClass>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?IsSet@AirframeClass@@QBEHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_testFlag$ = 8						; size = 4
?IsSet@AirframeClass@@QBEHH@Z PROC			; AirframeClass::IsSet, COMDAT
; _this$ = ecx

; 1216 : 	int IsSet (int testFlag) const {return flags & testFlag ? 1 : 0;}

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	and	ecx, DWORD PTR _testFlag$[ebp]
	je	SHORT $LN3@IsSet
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsSet
$LN3@IsSet:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsSet:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsSet@AirframeClass@@QBEHH@Z ENDP			; AirframeClass::IsSet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?ClearFlag@AirframeClass@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newFlag$ = 8						; size = 4
?ClearFlag@AirframeClass@@QAEXH@Z PROC			; AirframeClass::ClearFlag, COMDAT
; _this$ = ecx

; 1215 : 	void ClearFlag (int newFlag) {flags &= ~newFlag;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _newFlag$[ebp]
	not	eax
	mov	ecx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [ecx+88]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+88], eax
	mov	esp, ebp
	pop	ebp
	ret	4
?ClearFlag@AirframeClass@@QAEXH@Z ENDP			; AirframeClass::ClearFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?SetFlag@AirframeClass@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newFlag$ = 8						; size = 4
?SetFlag@AirframeClass@@QAEXH@Z PROC			; AirframeClass::SetFlag, COMDAT
; _this$ = ecx

; 1214 : 	void SetFlag (int newFlag) {flags |= newFlag;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	or	ecx, DWORD PTR _newFlag$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+88], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetFlag@AirframeClass@@QAEXH@Z ENDP			; AirframeClass::SetFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?GetAeroData@AirframeClass@@QBEMH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_which$ = 8						; size = 4
?GetAeroData@AirframeClass@@QBEMH@Z PROC		; AirframeClass::GetAeroData, COMDAT
; _this$ = ecx

; 1207 : 	float GetAeroData(int which) const { return aeroDataset[vehicleIndex].inputData[which]; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+92]
	imul	ecx, 220				; 000000dcH
	add	ecx, DWORD PTR ?aeroDataset@@3PAVAeroDataSet@@A ; aeroDataset
	mov	edx, DWORD PTR _which$[ebp]
	fld	DWORD PTR [ecx+edx*4+16]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetAeroData@AirframeClass@@QBEMH@Z ENDP		; AirframeClass::GetAeroData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\airframe\engine.cpp
_TEXT	SEGMENT
tv82 = -12						; size = 4
_mply$1 = -8						; size = 4
_this$ = -4						; size = 4
_fwdp$ = 8						; size = 4
_aftp$ = 12						; size = 4
_total$ = 16						; size = 4
?GetFuel@AirframeClass@@QAEXPAM00@Z PROC		; AirframeClass::GetFuel
; _this$ = ecx

; 2254 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 2255 :     if (!g_bRealisticAvionics) {

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN10@GetFuel

; 2256 : 	*fwdp = fuel;

	mov	ecx, DWORD PTR _fwdp$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx], eax

; 2257 : 	*aftp = externalFuel;

	mov	ecx, DWORD PTR _aftp$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR [ecx], eax

; 2258 : 	*total = fuel + externalFuel;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+20]
	addss	xmm0, DWORD PTR [edx+32]
	mov	eax, DWORD PTR _total$[ebp]
	movss	DWORD PTR [eax], xmm0

; 2259 : 	return;

	jmp	$LN11@GetFuel

; 2260 :     }
; 2261 :     else {

	jmp	$LN7@GetFuel
$LN10@GetFuel:

; 2262 : 	float mply = 1;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _mply$1[ebp], xmm0

; 2263 : 
; 2264 : 	// MLR 2003-10-12 Fuel needles are pinned if it's not an F-16
; 2265 : 	// it defaults to 10.
; 2266 : 	mply=auxaeroData->fuelGaugeMultiplier;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movss	xmm0, DWORD PTR [edx+3212]
	movss	DWORD PTR _mply$1[ebp], xmm0

; 2267 : 		// original MPS code
; 2268 : 		//if(platform->IsF16()) mply = 10;
; 2269 : 
; 2270 : 	*total = fuel + externalFuel;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+20]
	addss	xmm0, DWORD PTR [ecx+32]
	mov	edx, DWORD PTR _total$[ebp]
	movss	DWORD PTR [edx], xmm0

; 2271 : 	//MI fuel's in 100's of lbs
; 2272 : 	*total = static_cast<float>((((int)*total + 50) / 100) * 100);

	mov	eax, DWORD PTR _total$[ebp]
	cvttss2si eax, DWORD PTR [eax]
	add	eax, 50					; 00000032H
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	imul	eax, 100				; 00000064H
	cvtsi2ss xmm0, eax
	mov	edx, DWORD PTR _total$[ebp]
	movss	DWORD PTR [edx], xmm0

; 2273 : 	switch (fuelSwitch) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1680]
	mov	DWORD PTR tv82[ebp], ecx
	mov	edx, DWORD PTR tv82[ebp]
	sub	edx, 1
	mov	DWORD PTR tv82[ebp], edx
	cmp	DWORD PTR tv82[ebp], 4
	ja	SHORT $LN5@GetFuel
	mov	eax, DWORD PTR tv82[ebp]
	jmp	DWORD PTR $LN13@GetFuel[eax*4]
$LN6@GetFuel:

; 2274 : 	case FS_TEST:
; 2275 : 	    *fwdp = *aftp = 2000*mply;

	movss	xmm0, DWORD PTR __real@44fa0000
	mulss	xmm0, DWORD PTR _mply$1[ebp]
	mov	ecx, DWORD PTR _aftp$[ebp]
	movss	DWORD PTR [ecx], xmm0
	mov	edx, DWORD PTR _fwdp$[ebp]
	mov	eax, DWORD PTR _aftp$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx

; 2276 : 	    *total = 6000;

	mov	edx, DWORD PTR _total$[ebp]
	movss	xmm0, DWORD PTR __real@45bb8000
	movss	DWORD PTR [edx], xmm0

; 2277 : 	    break;

	jmp	$LN7@GetFuel
$LN5@GetFuel:

; 2278 : 	default:
; 2279 : 	case FS_NORM:
; 2280 : 	    *fwdp = m_tanks[TANK_FWDRES] + m_tanks[TANK_F1]; // + m_tanks[TANK_WINGFR]; //JPG 7 Jan 04 - We only want FR/AL qty's per -1

	mov	eax, 4
	imul	eax, 0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+1688]
	addss	xmm0, DWORD PTR [esi+ecx+1688]
	mov	eax, DWORD PTR _fwdp$[ebp]
	movss	DWORD PTR [eax], xmm0

; 2281 : 	    *aftp = m_tanks[TANK_AFTRES] + m_tanks[TANK_A1]; // + m_tanks[TANK_WINGAL]; // Wing amounts are NOT included when knob is in NORM

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	imul	edx, 3
	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx+1688]
	addss	xmm0, DWORD PTR [esi+edx+1688]
	mov	ecx, DWORD PTR _aftp$[ebp]
	movss	DWORD PTR [ecx], xmm0

; 2282 : 	    *fwdp *= mply;

	mov	edx, DWORD PTR _fwdp$[ebp]
	movss	xmm0, DWORD PTR [edx]
	mulss	xmm0, DWORD PTR _mply$1[ebp]
	mov	eax, DWORD PTR _fwdp$[ebp]
	movss	DWORD PTR [eax], xmm0

; 2283 : 	    *aftp *= mply;

	mov	ecx, DWORD PTR _aftp$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR _mply$1[ebp]
	mov	edx, DWORD PTR _aftp$[ebp]
	movss	DWORD PTR [edx], xmm0

; 2284 : 	    break;

	jmp	$LN7@GetFuel
$LN4@GetFuel:

; 2285 : 	case FS_RESV:
; 2286 : 	    *fwdp = m_tanks[TANK_FWDRES];

	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _fwdp$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+eax+1688]
	mov	DWORD PTR [ecx], eax

; 2287 : 	    *aftp = m_tanks[TANK_AFTRES];

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _aftp$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+1688]
	mov	DWORD PTR [edx], ecx

; 2288 : 	    *fwdp *= mply;

	mov	edx, DWORD PTR _fwdp$[ebp]
	movss	xmm0, DWORD PTR [edx]
	mulss	xmm0, DWORD PTR _mply$1[ebp]
	mov	eax, DWORD PTR _fwdp$[ebp]
	movss	DWORD PTR [eax], xmm0

; 2289 : 	    *aftp *= mply;

	mov	ecx, DWORD PTR _aftp$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR _mply$1[ebp]
	mov	edx, DWORD PTR _aftp$[ebp]
	movss	DWORD PTR [edx], xmm0

; 2290 : 	    break;

	jmp	$LN7@GetFuel
$LN3@GetFuel:

; 2291 : 	case FS_WINGINT:
; 2292 : 	    *fwdp = m_tanks[TANK_WINGFR];

	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _fwdp$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+eax+1688]
	mov	DWORD PTR [ecx], eax

; 2293 : 	    *aftp = m_tanks[TANK_WINGAL];

	mov	ecx, 4
	imul	ecx, 5
	mov	edx, DWORD PTR _aftp$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+1688]
	mov	DWORD PTR [edx], ecx

; 2294 : 	    *fwdp *= mply;

	mov	edx, DWORD PTR _fwdp$[ebp]
	movss	xmm0, DWORD PTR [edx]
	mulss	xmm0, DWORD PTR _mply$1[ebp]
	mov	eax, DWORD PTR _fwdp$[ebp]
	movss	DWORD PTR [eax], xmm0

; 2295 : 	    *aftp *= mply;

	mov	ecx, DWORD PTR _aftp$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR _mply$1[ebp]
	mov	edx, DWORD PTR _aftp$[ebp]
	movss	DWORD PTR [edx], xmm0

; 2296 : 	    break;

	jmp	$LN7@GetFuel
$LN2@GetFuel:

; 2297 : 	case FS_WINGEXT:
; 2298 : 	    *fwdp = m_tanks[TANK_REXT];

	mov	eax, 4
	imul	eax, 6
	mov	ecx, DWORD PTR _fwdp$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+eax+1688]
	mov	DWORD PTR [ecx], eax

; 2299 : 	    *aftp = m_tanks[TANK_LEXT];

	mov	ecx, 4
	imul	ecx, 7
	mov	edx, DWORD PTR _aftp$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+1688]
	mov	DWORD PTR [edx], ecx

; 2300 : 	    *fwdp *= mply;

	mov	edx, DWORD PTR _fwdp$[ebp]
	movss	xmm0, DWORD PTR [edx]
	mulss	xmm0, DWORD PTR _mply$1[ebp]
	mov	eax, DWORD PTR _fwdp$[ebp]
	movss	DWORD PTR [eax], xmm0

; 2301 : 	    *aftp *= mply;

	mov	ecx, DWORD PTR _aftp$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR _mply$1[ebp]
	mov	edx, DWORD PTR _aftp$[ebp]
	movss	DWORD PTR [edx], xmm0

; 2302 : 	    break;

	jmp	SHORT $LN7@GetFuel
$LN1@GetFuel:

; 2303 : 	case FS_CENTEREXT:
; 2304 : 	    *fwdp = m_tanks[TANK_CLINE];

	mov	eax, 4
	shl	eax, 3
	mov	ecx, DWORD PTR _fwdp$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+eax+1688]
	mov	DWORD PTR [ecx], eax

; 2305 : 	    *aftp = 0.0f;

	mov	ecx, DWORD PTR _aftp$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx], xmm0

; 2306 : 	    *fwdp *= mply;

	mov	edx, DWORD PTR _fwdp$[ebp]
	movss	xmm0, DWORD PTR [edx]
	mulss	xmm0, DWORD PTR _mply$1[ebp]
	mov	eax, DWORD PTR _fwdp$[ebp]
	movss	DWORD PTR [eax], xmm0

; 2307 : 	    *aftp *= mply;

	mov	ecx, DWORD PTR _aftp$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR _mply$1[ebp]
	mov	edx, DWORD PTR _aftp$[ebp]
	movss	DWORD PTR [edx], xmm0
$LN7@GetFuel:
$LN11@GetFuel:

; 2308 : 	    break;
; 2309 : 	}
; 2310 :     }
; 2311 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	3
$LN13@GetFuel:
	DD	$LN4@GetFuel
	DD	$LN3@GetFuel
	DD	$LN2@GetFuel
	DD	$LN1@GetFuel
	DD	$LN6@GetFuel
?GetFuel@AirframeClass@@QAEXPAM00@Z ENDP		; AirframeClass::GetFuel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\airframe\engine.cpp
_TEXT	SEGMENT
_fuelDropped$ = -12					; size = 4
_fuelBefore$ = -8					; size = 4
_this$ = -4						; size = 4
_n$ = 8							; size = 4
?DropTank@AirframeClass@@QAEXH@Z PROC			; AirframeClass::DropTank
; _this$ = ecx

; 2225 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2226 :     ShiAssert(n>=0 && n < MAX_FUEL);
; 2227 :     m_tanks[n] = 0.0f;

	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+eax*4+1688], xmm0

; 2228 :     m_tankcap[n] = 0.0f;

	mov	edx, DWORD PTR _n$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+edx*4+1724], xmm0

; 2229 :     float fuelBefore = externalFuel;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+32]
	movss	DWORD PTR _fuelBefore$[ebp], xmm0

; 2230 :     RecalculateFuel();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RecalculateFuel@AirframeClass@@QAEXXZ	; AirframeClass::RecalculateFuel

; 2231 :     float fuelDropped = fuelBefore - externalFuel;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _fuelBefore$[ebp]
	subss	xmm0, DWORD PTR [edx+32]
	movss	DWORD PTR _fuelDropped$[ebp], xmm0

; 2232 :     weight -= fuelDropped;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+44]
	subss	xmm0, DWORD PTR _fuelDropped$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+44], xmm0

; 2233 :     mass    = weight / GRAVITY;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+44]
	divss	xmm0, DWORD PTR __real@4200b53f
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+40], xmm0

; 2234 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?DropTank@AirframeClass@@QAEXH@Z ENDP			; AirframeClass::DropTank
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\airframe\engine.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_dt$ = 8						; size = 4
?FuelTransfer@AirframeClass@@QAEXM@Z PROC		; AirframeClass::FuelTransfer
; _this$ = ecx

; 2167 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2168 :     FeedTank(TANK_FWDRES, TANK_F1, dt);

	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	2
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FeedTank@AirframeClass@@QAEXHHM@Z	; AirframeClass::FeedTank

; 2169 :     FeedTank(TANK_F1, TANK_WINGFR, dt);

	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	4
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FeedTank@AirframeClass@@QAEXHHM@Z	; AirframeClass::FeedTank

; 2170 : 	
; 2171 :     FeedTank(TANK_AFTRES, TANK_A1, dt);

	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	3
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FeedTank@AirframeClass@@QAEXHHM@Z	; AirframeClass::FeedTank

; 2172 :     FeedTank(TANK_A1, TANK_WINGAL, dt);

	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	5
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FeedTank@AirframeClass@@QAEXHHM@Z	; AirframeClass::FeedTank

; 2173 : 	
; 2174 :     // transfer wing externals if
; 2175 :     // switch set, or cline empty and
; 2176 :     // we have some fuel to transfer
; 2177 :     // only happens if externals are pressurized.
; 2178 :     if (airSource == AS_NORM || airSource == AS_DUMP) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1800], 1
	je	SHORT $LN18@FuelTransf
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1800], 2
	jne	$LN13@FuelTransf
$LN18@FuelTransf:

; 2179 : 		if (((engineFlags & WingFirst) ||
; 2180 : 			m_tanks[TANK_CLINE] <= 0.0f) &&
; 2181 : 			(m_tanks[TANK_REXT] > 0.0f ||
; 2182 : 			m_tanks[TANK_LEXT] > 0.0f)) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1676]
	and	eax, 1
	jne	SHORT $LN16@FuelTransf
	mov	ecx, 4
	shl	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [edx+ecx+1688]
	jb	SHORT $LN17@FuelTransf
$LN16@FuelTransf:
	mov	eax, 4
	imul	eax, 6
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+1688]
	comiss	xmm0, DWORD PTR __real@00000000
	ja	SHORT $LN15@FuelTransf
	mov	edx, 4
	imul	edx, 7
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+1688]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN17@FuelTransf
$LN15@FuelTransf:

; 2183 : 			FeedTank(TANK_WINGFR, TANK_REXT, dt);

	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	6
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FeedTank@AirframeClass@@QAEXHHM@Z	; AirframeClass::FeedTank

; 2184 : 			FeedTank(TANK_WINGAL, TANK_LEXT, dt);

	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	7
	push	5
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FeedTank@AirframeClass@@QAEXHHM@Z	; AirframeClass::FeedTank
	jmp	SHORT $LN13@FuelTransf
$LN17@FuelTransf:

; 2185 : 		}
; 2186 : 		else if (m_tanks[TANK_CLINE] > 0.0f) {

	mov	ecx, 4
	shl	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+1688]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN13@FuelTransf

; 2187 : 			FeedTank(TANK_WINGFR, TANK_CLINE, dt/2.0f);

	movss	xmm0, DWORD PTR _dt$[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	8
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FeedTank@AirframeClass@@QAEXHHM@Z	; AirframeClass::FeedTank

; 2188 : 			FeedTank(TANK_WINGAL, TANK_CLINE, dt/2.0f);

	movss	xmm0, DWORD PTR _dt$[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	8
	push	5
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FeedTank@AirframeClass@@QAEXHHM@Z	; AirframeClass::FeedTank
$LN13@FuelTransf:

; 2189 : 		}
; 2190 :     }
; 2191 :     if (!platform->isDigital) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	cmp	DWORD PTR [ecx+948], 0
	jne	$LN2@FuelTransf

; 2192 : 		if (m_tanks[TANK_FWDRES] < auxaeroData->fuelMinFwd)

	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+308]
	comiss	xmm0, DWORD PTR [eax+edx+1688]
	jbe	SHORT $LN11@FuelTransf

; 2193 : 		{
; 2194 : 			if(!g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	jne	SHORT $LN10@FuelTransf

; 2195 : 				platform->mFaults->SetFault(fwd_fuel_low_fault);

	push	22					; 00000016H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1088]
	mov	ecx, DWORD PTR [eax+928]
	call	?SetFault@FackClass@@QAEXW4type_CSubSystem@@@Z ; FackClass::SetFault

; 2196 : 			else

	jmp	SHORT $LN9@FuelTransf
$LN10@FuelTransf:

; 2197 : 				platform->mFaults->SetCaution(fwd_fuel_low_fault);

	push	22					; 00000016H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1088]
	mov	ecx, DWORD PTR [edx+928]
	call	?SetCaution@FackClass@@QAEXW4type_CSubSystem@@@Z ; FackClass::SetCaution
$LN9@FuelTransf:
	jmp	SHORT $LN7@FuelTransf
$LN11@FuelTransf:

; 2198 : 		}
; 2199 : 		else if (fuelSwitch != FS_TEST && platform->mFaults->GetFault(fwd_fuel_low_fault))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1680], 5
	je	SHORT $LN7@FuelTransf
	push	22					; 00000016H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1088]
	mov	ecx, DWORD PTR [edx+928]
	call	?GetFault@FackClass@@QAEHW4type_CSubSystem@@@Z ; FackClass::GetFault
	test	eax, eax
	je	SHORT $LN7@FuelTransf

; 2200 : 			platform->mFaults->ClearFault(fwd_fuel_low_fault);

	push	22					; 00000016H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	mov	ecx, DWORD PTR [ecx+928]
	call	?ClearFault@FackClass@@QAEXW4type_CSubSystem@@@Z ; FackClass::ClearFault
$LN7@FuelTransf:

; 2201 : 		if (m_tanks[TANK_AFTRES] < auxaeroData->fuelMinAft)

	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+312]
	comiss	xmm0, DWORD PTR [eax+edx+1688]
	jbe	SHORT $LN6@FuelTransf

; 2202 : 		{
; 2203 : 			if(!g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	jne	SHORT $LN5@FuelTransf

; 2204 : 				//platform->mFaults->SetFault(fwd_fuel_low_fault);	//MI should probably be AFT tank
; 2205 : 				platform->mFaults->SetFault(aft_fuel_low_fault);

	push	23					; 00000017H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1088]
	mov	ecx, DWORD PTR [eax+928]
	call	?SetFault@FackClass@@QAEXW4type_CSubSystem@@@Z ; FackClass::SetFault

; 2206 : 			else

	jmp	SHORT $LN4@FuelTransf
$LN5@FuelTransf:

; 2207 : 				platform->mFaults->SetCaution(aft_fuel_low_fault);

	push	23					; 00000017H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1088]
	mov	ecx, DWORD PTR [edx+928]
	call	?SetCaution@FackClass@@QAEXW4type_CSubSystem@@@Z ; FackClass::SetCaution
$LN4@FuelTransf:
	jmp	SHORT $LN2@FuelTransf
$LN6@FuelTransf:

; 2208 : 		}
; 2209 : 		else if (fuelSwitch != FS_TEST && platform->mFaults->GetFault(aft_fuel_low_fault))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1680], 5
	je	SHORT $LN2@FuelTransf
	push	23					; 00000017H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1088]
	mov	ecx, DWORD PTR [edx+928]
	call	?GetFault@FackClass@@QAEHW4type_CSubSystem@@@Z ; FackClass::GetFault
	test	eax, eax
	je	SHORT $LN2@FuelTransf

; 2210 : 			platform->mFaults->ClearFault(aft_fuel_low_fault);

	push	23					; 00000017H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	mov	ecx, DWORD PTR [ecx+928]
	call	?ClearFault@FackClass@@QAEXW4type_CSubSystem@@@Z ; FackClass::ClearFault
$LN2@FuelTransf:

; 2211 :     }
; 2212 :     // recompute internal/external ammounts
; 2213 :     RecalculateFuel ();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RecalculateFuel@AirframeClass@@QAEXXZ	; AirframeClass::RecalculateFuel

; 2214 : 
; 2215 : 	// MD -- 20040531: adding a check to see if an external tank ran dry.  When they do run dry
; 2216 : 	// there's a chance that the CAT limiter needs adjusting.  For now this only operates on the
; 2217 : 	// centerline tank but it may need to take dollies into account as well at some point.
; 2218 : 
; 2219 : 	if ((m_tankcap[TANK_CLINE] > 0.0F) && (m_tanks[TANK_CLINE] <= 0.0F))

	mov	edx, 4
	shl	edx, 3
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+1724]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN1@FuelTransf
	mov	ecx, 4
	shl	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [edx+ecx+1688]
	jb	SHORT $LN1@FuelTransf

; 2220 : 		platform->Sms->ChooseLimiterMode(1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	mov	ecx, DWORD PTR [ecx+940]
	call	?ChooseLimiterMode@SMSClass@@QAEXH@Z	; SMSClass::ChooseLimiterMode
$LN1@FuelTransf:

; 2221 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?FuelTransfer@AirframeClass@@QAEXM@Z ENDP		; AirframeClass::FuelTransfer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?FuelFlow@AirframeClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?FuelFlow@AirframeClass@@QAEMXZ PROC			; AirframeClass::FuelFlow, COMDAT
; _this$ = ecx

; 1192 : 	float FuelFlow (void) {return fuelFlow;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+24]
	mov	esp, ebp
	pop	ebp
	ret	0
?FuelFlow@AirframeClass@@QAEMXZ ENDP			; AirframeClass::FuelFlow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\airframe\engine.cpp
_TEXT	SEGMENT
tv86 = -20						; size = 4
_maxtrans$ = -16					; size = 4
tv80 = -12						; size = 4
_delta$ = -8						; size = 4
_this$ = -4						; size = 4
_t1$ = 8						; size = 4
_t2$ = 12						; size = 4
_dt$ = 16						; size = 4
?FeedTank@AirframeClass@@QAEXHHM@Z PROC			; AirframeClass::FeedTank
; _this$ = ecx

; 2149 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 2150 :     // room for some more?
; 2151 :     float delta = m_tankcap[t1] - m_tanks[t1];

	mov	eax, DWORD PTR _t1$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _t1$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4+1724]
	subss	xmm0, DWORD PTR [esi+edx*4+1688]
	movss	DWORD PTR _delta$[ebp], xmm0

; 2152 :     delta = min(delta, m_tanks[t2]); // limit to amount in tank2

	mov	eax, DWORD PTR _t2$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4+1688]
	comiss	xmm0, DWORD PTR _delta$[ebp]
	jbe	SHORT $LN5@FeedTank
	movss	xmm0, DWORD PTR _delta$[ebp]
	movss	DWORD PTR tv80[ebp], xmm0
	jmp	SHORT $LN6@FeedTank
$LN5@FeedTank:
	mov	edx, DWORD PTR _t2$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4+1688]
	movss	DWORD PTR tv80[ebp], xmm0
$LN6@FeedTank:
	movss	xmm0, DWORD PTR tv80[ebp]
	movss	DWORD PTR _delta$[ebp], xmm0

; 2153 : 
; 2154 :     float maxtrans = m_trate[t2] * dt; // limit to max trans rate

	mov	ecx, DWORD PTR _t2$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4+1760]
	mulss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR _maxtrans$[ebp], xmm0

; 2155 :     delta = min(delta, maxtrans);

	movss	xmm0, DWORD PTR _maxtrans$[ebp]
	comiss	xmm0, DWORD PTR _delta$[ebp]
	jbe	SHORT $LN7@FeedTank
	movss	xmm0, DWORD PTR _delta$[ebp]
	movss	DWORD PTR tv86[ebp], xmm0
	jmp	SHORT $LN8@FeedTank
$LN7@FeedTank:
	movss	xmm0, DWORD PTR _maxtrans$[ebp]
	movss	DWORD PTR tv86[ebp], xmm0
$LN8@FeedTank:
	movss	xmm0, DWORD PTR tv86[ebp]
	movss	DWORD PTR _delta$[ebp], xmm0

; 2156 : 
; 2157 :     if (delta > 0) { // transfer

	movss	xmm0, DWORD PTR _delta$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN2@FeedTank

; 2158 : 	m_tanks[t1] += delta;

	mov	eax, DWORD PTR _t1$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4+1688]
	addss	xmm0, DWORD PTR _delta$[ebp]
	mov	edx, DWORD PTR _t1$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+edx*4+1688], xmm0

; 2159 : 	m_tanks[t2] -= delta;

	mov	ecx, DWORD PTR _t2$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4+1688]
	subss	xmm0, DWORD PTR _delta$[ebp]
	mov	eax, DWORD PTR _t2$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+eax*4+1688], xmm0
$LN2@FeedTank:

; 2160 :     }
; 2161 :     if (m_tanks[t2] < 0.0f) // sanity check

	mov	edx, DWORD PTR _t2$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [eax+edx*4+1688]
	jbe	SHORT $LN1@FeedTank

; 2162 : 	m_tanks[t2] = 0.0f;

	mov	ecx, DWORD PTR _t2$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+ecx*4+1688], xmm0
$LN1@FeedTank:

; 2163 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?FeedTank@AirframeClass@@QAEXHHM@Z ENDP			; AirframeClass::FeedTank
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\airframe\engine.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$ = -4						; size = 4
?RecalculateFuel@AirframeClass@@QAEXXZ PROC		; AirframeClass::RecalculateFuel
; _this$ = ecx

; 2238 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2239 :     int i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 2240 : 	//MI fix for refueling not filling up tanks
; 2241 : 	if(IsSet(AirframeClass::Refueling))

	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN7@Recalculat

; 2242 : 		return;

	jmp	$LN8@Recalculat
$LN7@Recalculat:

; 2243 :     // recompute internal/external ammounts
; 2244 :     fuel = 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+20], xmm0

; 2245 :     for (i = 0; i <= TANK_MAXINTERNAL; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@Recalculat
$LN5@Recalculat:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN6@Recalculat:
	cmp	DWORD PTR _i$[ebp], 5
	jg	SHORT $LN4@Recalculat

; 2246 : 	fuel += m_tanks[i];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+20]
	addss	xmm0, DWORD PTR [ecx+eax*4+1688]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+20], xmm0
	jmp	SHORT $LN5@Recalculat
$LN4@Recalculat:

; 2247 :     externalFuel = 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+32], xmm0

; 2248 :     for (i = TANK_MAXINTERNAL+1; i < MAX_FUEL; i++)

	mov	DWORD PTR _i$[ebp], 6
	jmp	SHORT $LN3@Recalculat
$LN2@Recalculat:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN3@Recalculat:
	cmp	DWORD PTR _i$[ebp], 9
	jge	SHORT $LN1@Recalculat

; 2249 : 	externalFuel += m_tanks[i];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+32]
	addss	xmm0, DWORD PTR [ecx+eax*4+1688]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+32], xmm0
	jmp	SHORT $LN2@Recalculat
$LN1@Recalculat:
$LN8@Recalculat:

; 2250 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RecalculateFuel@AirframeClass@@QAEXXZ ENDP		; AirframeClass::RecalculateFuel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\airframe\engine.cpp
_TEXT	SEGMENT
tv74 = -12						; size = 4
_tfp$ = -8						; size = 4
_this$ = -4						; size = 4
_bfuel$ = 8						; size = 4
?BurnFuel@AirframeClass@@QAEHM@Z PROC			; AirframeClass::BurnFuel
; _this$ = ecx

; 2116 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2117 :     FuelPump tfp = fuelPump;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1684]
	mov	DWORD PTR _tfp$[ebp], ecx

; 2118 :     if (tfp == FP_NORM)  { // deal with empty tanks

	cmp	DWORD PTR _tfp$[ebp], 1
	jne	SHORT $LN8@BurnFuel

; 2119 : 	if (m_tanks[TANK_AFTRES] <= 0.0f)

	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [eax+edx+1688]
	jb	SHORT $LN10@BurnFuel

; 2120 : 	    tfp = FP_FWD;

	mov	DWORD PTR _tfp$[ebp], 3
	jmp	SHORT $LN8@BurnFuel
$LN10@BurnFuel:

; 2121 : 	else if (m_tanks[TANK_FWDRES] <= 0.0f)

	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [edx+ecx+1688]
	jb	SHORT $LN8@BurnFuel

; 2122 : 	    tfp = FP_AFT;

	mov	DWORD PTR _tfp$[ebp], 2
$LN8@BurnFuel:

; 2123 :     }
; 2124 : 
; 2125 :     // TODO: broken FFP if hydrB offline ... erratic transfer rates.
; 2126 :     // TODO C of G calculations
; 2127 :     switch (tfp) {

	mov	eax, DWORD PTR _tfp$[ebp]
	mov	DWORD PTR tv74[ebp], eax
	cmp	DWORD PTR tv74[ebp], 3
	ja	$LN6@BurnFuel
	mov	ecx, DWORD PTR tv74[ebp]
	jmp	DWORD PTR $LN14@BurnFuel[ecx*4]
$LN5@BurnFuel:

; 2128 :     case FP_OFF: // XXX or should no flow occur?
; 2129 :     case FP_NORM:
; 2130 : 	m_tanks[TANK_AFTRES] -= bfuel/2.0f;

	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR _bfuel$[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+edx+1688]
	subss	xmm1, xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+ecx+1688], xmm1

; 2131 : 	m_tanks[TANK_FWDRES] -= bfuel/2.0f;

	mov	eax, 4
	imul	eax, 0
	movss	xmm0, DWORD PTR _bfuel$[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+eax+1688]
	subss	xmm1, xmm0
	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+edx+1688], xmm1

; 2132 : 	break;

	jmp	$LN6@BurnFuel
$LN4@BurnFuel:

; 2133 :     case FP_FWD:
; 2134 : 	if (m_tanks[TANK_FWDRES] <= 0.0f)

	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [edx+ecx+1688]
	jb	SHORT $LN3@BurnFuel

; 2135 : 	    return 0;

	xor	eax, eax
	jmp	$LN12@BurnFuel
$LN3@BurnFuel:

; 2136 : 	m_tanks[TANK_FWDRES] -= bfuel;

	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+1688]
	subss	xmm0, DWORD PTR _bfuel$[ebp]
	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+edx+1688], xmm0

; 2137 : 	break;

	jmp	SHORT $LN6@BurnFuel
$LN2@BurnFuel:

; 2138 :     case FP_AFT:
; 2139 : 	if (m_tanks[TANK_AFTRES] <= 0.0f)

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [edx+ecx+1688]
	jb	SHORT $LN1@BurnFuel

; 2140 : 	    return 0;

	xor	eax, eax
	jmp	SHORT $LN12@BurnFuel
$LN1@BurnFuel:

; 2141 : 	m_tanks[TANK_AFTRES] -= bfuel;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+1688]
	subss	xmm0, DWORD PTR _bfuel$[ebp]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+edx+1688], xmm0
$LN6@BurnFuel:

; 2142 : 	break;
; 2143 :     }
; 2144 :     return 1;

	mov	eax, 1
$LN12@BurnFuel:

; 2145 : }

	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN14@BurnFuel:
	DD	$LN5@BurnFuel
	DD	$LN5@BurnFuel
	DD	$LN2@BurnFuel
	DD	$LN4@BurnFuel
?BurnFuel@AirframeClass@@QAEHM@Z ENDP			; AirframeClass::BurnFuel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\airframe\engine.cpp
_TEXT	SEGMENT
tv279 = -44						; size = 4
tv258 = -40						; size = 4
tv241 = -36						; size = 4
tv216 = -32						; size = 4
tv199 = -28						; size = 4
tv174 = -24						; size = 4
tv157 = -20						; size = 4
tv132 = -16						; size = 4
tv83 = -12						; size = 4
tv65 = -8						; size = 4
_this$ = -4						; size = 4
_totalfuel$ = 8						; size = 4
?AllocateFuel@AirframeClass@@QAEXM@Z PROC		; AirframeClass::AllocateFuel
; _this$ = ecx

; 2063 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 2064 : 		totalfuel = max(totalfuel, 0.0f);

	movss	xmm0, DWORD PTR _totalfuel$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN4@AllocateFu
	movss	xmm0, DWORD PTR _totalfuel$[ebp]
	movss	DWORD PTR tv65[ebp], xmm0
	jmp	SHORT $LN5@AllocateFu
$LN4@AllocateFu:
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv65[ebp], xmm0
$LN5@AllocateFu:
	movss	xmm0, DWORD PTR tv65[ebp]
	movss	DWORD PTR _totalfuel$[ebp], xmm0

; 2065 : 
; 2066 :     ClearFuel();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearFuel@AirframeClass@@QAEXXZ	; AirframeClass::ClearFuel

; 2067 :     m_tanks[TANK_AFTRES] = min(totalfuel/2.0f, m_tankcap[TANK_AFTRES]);

	movss	xmm0, DWORD PTR _totalfuel$[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+eax+1724]
	comiss	xmm1, xmm0
	jbe	SHORT $LN6@AllocateFu
	movss	xmm0, DWORD PTR _totalfuel$[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR tv83[ebp], xmm0
	jmp	SHORT $LN7@AllocateFu
$LN6@AllocateFu:
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+1724]
	movss	DWORD PTR tv83[ebp], xmm0
$LN7@AllocateFu:
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv83[ebp]
	movss	DWORD PTR [edx+ecx+1688], xmm0

; 2068 :     m_tanks[TANK_FWDRES] = min(totalfuel/2.0f, m_tankcap[TANK_FWDRES]);

	movss	xmm0, DWORD PTR _totalfuel$[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+eax+1724]
	comiss	xmm1, xmm0
	jbe	SHORT $LN8@AllocateFu
	movss	xmm0, DWORD PTR _totalfuel$[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR tv132[ebp], xmm0
	jmp	SHORT $LN9@AllocateFu
$LN8@AllocateFu:
	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+1724]
	movss	DWORD PTR tv132[ebp], xmm0
$LN9@AllocateFu:
	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv132[ebp]
	movss	DWORD PTR [edx+ecx+1688], xmm0

; 2069 :     totalfuel -= m_tanks[TANK_AFTRES] + m_tanks[TANK_FWDRES];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+1688]
	addss	xmm0, DWORD PTR [esi+ecx+1688]
	movss	xmm1, DWORD PTR _totalfuel$[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _totalfuel$[ebp], xmm1

; 2070 : 
; 2071 :     m_tanks[TANK_A1] = min(totalfuel/2.0f, m_tankcap[TANK_A1]);

	movss	xmm0, DWORD PTR _totalfuel$[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	mov	eax, 4
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+eax+1724]
	comiss	xmm1, xmm0
	jbe	SHORT $LN10@AllocateFu
	movss	xmm0, DWORD PTR _totalfuel$[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR tv157[ebp], xmm0
	jmp	SHORT $LN11@AllocateFu
$LN10@AllocateFu:
	mov	edx, 4
	imul	edx, 3
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+1724]
	movss	DWORD PTR tv157[ebp], xmm0
$LN11@AllocateFu:
	mov	ecx, 4
	imul	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv157[ebp]
	movss	DWORD PTR [edx+ecx+1688], xmm0

; 2072 :     m_tanks[TANK_F1] = min(totalfuel/2.0f, m_tankcap[TANK_F1]);

	movss	xmm0, DWORD PTR _totalfuel$[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+eax+1724]
	comiss	xmm1, xmm0
	jbe	SHORT $LN12@AllocateFu
	movss	xmm0, DWORD PTR _totalfuel$[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR tv174[ebp], xmm0
	jmp	SHORT $LN13@AllocateFu
$LN12@AllocateFu:
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+1724]
	movss	DWORD PTR tv174[ebp], xmm0
$LN13@AllocateFu:
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv174[ebp]
	movss	DWORD PTR [edx+ecx+1688], xmm0

; 2073 :     totalfuel -= m_tanks[TANK_F1] + m_tanks[TANK_A1];

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	imul	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+1688]
	addss	xmm0, DWORD PTR [esi+ecx+1688]
	movss	xmm1, DWORD PTR _totalfuel$[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _totalfuel$[ebp], xmm1

; 2074 : 
; 2075 :     m_tanks[TANK_WINGFR] = min(totalfuel/2.0f, m_tankcap[TANK_WINGFR]);

	movss	xmm0, DWORD PTR _totalfuel$[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+eax+1724]
	comiss	xmm1, xmm0
	jbe	SHORT $LN14@AllocateFu
	movss	xmm0, DWORD PTR _totalfuel$[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR tv199[ebp], xmm0
	jmp	SHORT $LN15@AllocateFu
$LN14@AllocateFu:
	mov	edx, 4
	shl	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+1724]
	movss	DWORD PTR tv199[ebp], xmm0
$LN15@AllocateFu:
	mov	ecx, 4
	shl	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv199[ebp]
	movss	DWORD PTR [edx+ecx+1688], xmm0

; 2076 :     m_tanks[TANK_WINGAL] = min(totalfuel/2.0f, m_tankcap[TANK_WINGAL]);

	movss	xmm0, DWORD PTR _totalfuel$[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	mov	eax, 4
	imul	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+eax+1724]
	comiss	xmm1, xmm0
	jbe	SHORT $LN16@AllocateFu
	movss	xmm0, DWORD PTR _totalfuel$[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR tv216[ebp], xmm0
	jmp	SHORT $LN17@AllocateFu
$LN16@AllocateFu:
	mov	edx, 4
	imul	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+1724]
	movss	DWORD PTR tv216[ebp], xmm0
$LN17@AllocateFu:
	mov	ecx, 4
	imul	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv216[ebp]
	movss	DWORD PTR [edx+ecx+1688], xmm0

; 2077 :     totalfuel -= m_tanks[TANK_WINGFR] + m_tanks[TANK_WINGAL];

	mov	eax, 4
	shl	eax, 2
	mov	ecx, 4
	imul	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+1688]
	addss	xmm0, DWORD PTR [esi+ecx+1688]
	movss	xmm1, DWORD PTR _totalfuel$[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _totalfuel$[ebp], xmm1

; 2078 : 
; 2079 :     // fill drop tanks now.
; 2080 :     m_tanks[TANK_LEXT] = min(m_tankcap[TANK_LEXT], totalfuel/2.0f);

	mov	eax, 4
	imul	eax, 7
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _totalfuel$[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	comiss	xmm0, DWORD PTR [ecx+eax+1724]
	jbe	SHORT $LN18@AllocateFu
	mov	edx, 4
	imul	edx, 7
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+1724]
	movss	DWORD PTR tv241[ebp], xmm0
	jmp	SHORT $LN19@AllocateFu
$LN18@AllocateFu:
	movss	xmm0, DWORD PTR _totalfuel$[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR tv241[ebp], xmm0
$LN19@AllocateFu:
	mov	ecx, 4
	imul	ecx, 7
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv241[ebp]
	movss	DWORD PTR [edx+ecx+1688], xmm0

; 2081 :     m_tanks[TANK_REXT] = min(m_tankcap[TANK_REXT], totalfuel/2.0f);

	mov	eax, 4
	imul	eax, 6
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _totalfuel$[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	comiss	xmm0, DWORD PTR [ecx+eax+1724]
	jbe	SHORT $LN20@AllocateFu
	mov	edx, 4
	imul	edx, 6
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+1724]
	movss	DWORD PTR tv258[ebp], xmm0
	jmp	SHORT $LN21@AllocateFu
$LN20@AllocateFu:
	movss	xmm0, DWORD PTR _totalfuel$[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR tv258[ebp], xmm0
$LN21@AllocateFu:
	mov	ecx, 4
	imul	ecx, 6
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv258[ebp]
	movss	DWORD PTR [edx+ecx+1688], xmm0

; 2082 :     totalfuel -= m_tanks[TANK_REXT];

	mov	eax, 4
	imul	eax, 6
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _totalfuel$[ebp]
	subss	xmm0, DWORD PTR [ecx+eax+1688]
	movss	DWORD PTR _totalfuel$[ebp], xmm0

; 2083 :     totalfuel -= m_tanks[TANK_LEXT];

	mov	edx, 4
	imul	edx, 7
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _totalfuel$[ebp]
	subss	xmm0, DWORD PTR [eax+edx+1688]
	movss	DWORD PTR _totalfuel$[ebp], xmm0

; 2084 :     m_tanks[TANK_CLINE] = min(m_tankcap[TANK_CLINE], totalfuel);

	mov	ecx, 4
	shl	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _totalfuel$[ebp]
	comiss	xmm0, DWORD PTR [edx+ecx+1724]
	jbe	SHORT $LN22@AllocateFu
	mov	eax, 4
	shl	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+1724]
	movss	DWORD PTR tv279[ebp], xmm0
	jmp	SHORT $LN23@AllocateFu
$LN22@AllocateFu:
	movss	xmm0, DWORD PTR _totalfuel$[ebp]
	movss	DWORD PTR tv279[ebp], xmm0
$LN23@AllocateFu:
	mov	edx, 4
	shl	edx, 3
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv279[ebp]
	movss	DWORD PTR [eax+edx+1688], xmm0

; 2085 :     totalfuel -= m_tanks[TANK_CLINE];

	mov	ecx, 4
	shl	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _totalfuel$[ebp]
	subss	xmm0, DWORD PTR [edx+ecx+1688]
	movss	DWORD PTR _totalfuel$[ebp], xmm0

; 2086 :     if (totalfuel > 1.0)

	cvtss2sd xmm0, DWORD PTR _totalfuel$[ebp]
	comisd	xmm0, QWORD PTR __real@3ff0000000000000
	jbe	SHORT $LN1@AllocateFu

; 2087 : 		{
; 2088 : 			totalfuel = totalfuel; // JB 010506 Do something for release build

	movss	xmm0, DWORD PTR _totalfuel$[ebp]
	movss	DWORD PTR _totalfuel$[ebp], xmm0
$LN1@AllocateFu:

; 2089 : 			//ShiWarning("Too much fuel for the plane");
; 2090 : 		}
; 2091 :     // recompute internal/external ammounts
; 2092 :     RecalculateFuel ();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RecalculateFuel@AirframeClass@@QAEXXZ	; AirframeClass::RecalculateFuel

; 2093 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?AllocateFuel@AirframeClass@@QAEXM@Z ENDP		; AirframeClass::AllocateFuel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\airframe\engine.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$1 = -4						; size = 4
?ClearFuel@AirframeClass@@QAEXXZ PROC			; AirframeClass::ClearFuel
; _this$ = ecx

; 2055 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2056 :     for (int i = 0; i < MAX_FUEL; i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN3@ClearFuel
$LN2@ClearFuel:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN3@ClearFuel:
	cmp	DWORD PTR _i$1[ebp], 9
	jge	SHORT $LN1@ClearFuel

; 2057 : 	m_tanks[i] = 0.0f;

	mov	ecx, DWORD PTR _i$1[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+ecx*4+1688], xmm0
	jmp	SHORT $LN2@ClearFuel
$LN1@ClearFuel:

; 2058 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ClearFuel@AirframeClass@@QAEXXZ ENDP			; AirframeClass::ClearFuel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?GeneratorBreak@AirframeClass@@QAEXW4Generator@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_gen$ = 8						; size = 4
?GeneratorBreak@AirframeClass@@QAEXW4Generator@1@@Z PROC ; AirframeClass::GeneratorBreak, COMDAT
; _this$ = ecx

; 1134 : 	void GeneratorBreak(Generator gen) { generators |= (gen<<1); GeneratorOff(gen);  };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _gen$[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	or	eax, DWORD PTR [ecx+1804]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1804], eax
	mov	eax, DWORD PTR _gen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GeneratorOff@AirframeClass@@QAEXW4Generator@1@@Z ; AirframeClass::GeneratorOff
	mov	esp, ebp
	pop	ebp
	ret	4
?GeneratorBreak@AirframeClass@@QAEXW4Generator@1@@Z ENDP ; AirframeClass::GeneratorBreak
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?GeneratorOff@AirframeClass@@QAEXW4Generator@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_gen$ = 8						; size = 4
?GeneratorOff@AirframeClass@@QAEXW4Generator@1@@Z PROC	; AirframeClass::GeneratorOff, COMDAT
; _this$ = ecx

; 1133 : 	void GeneratorOff (Generator gen) { generators &= ~gen; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _gen$[ebp]
	not	eax
	mov	ecx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [ecx+1804]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1804], eax
	mov	esp, ebp
	pop	ebp
	ret	4
?GeneratorOff@AirframeClass@@QAEXW4Generator@1@@Z ENDP	; AirframeClass::GeneratorOff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?GeneratorOn@AirframeClass@@QAEXW4Generator@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_gen$ = 8						; size = 4
?GeneratorOn@AirframeClass@@QAEXW4Generator@1@@Z PROC	; AirframeClass::GeneratorOn, COMDAT
; _this$ = ecx

; 1132 : 	void GeneratorOn (Generator gen) { if(GeneratorOK(gen)) generators |= gen; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _gen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GeneratorOK@AirframeClass@@QAEHW4Generator@1@@Z ; AirframeClass::GeneratorOK
	test	eax, eax
	je	SHORT $LN2@GeneratorO
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1804]
	or	edx, DWORD PTR _gen$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1804], edx
$LN2@GeneratorO:
	mov	esp, ebp
	pop	ebp
	ret	4
?GeneratorOn@AirframeClass@@QAEXW4Generator@1@@Z ENDP	; AirframeClass::GeneratorOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?GeneratorOK@AirframeClass@@QAEHW4Generator@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
_gen$ = 8						; size = 4
?GeneratorOK@AirframeClass@@QAEHW4Generator@1@@Z PROC	; AirframeClass::GeneratorOK, COMDAT
; _this$ = ecx

; 1131 : 	BOOL GeneratorOK(Generator gen) { return (generators & (gen<<1)) ? FALSE : TRUE; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _gen$[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [ecx+1804]
	je	SHORT $LN3@GeneratorO
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN4@GeneratorO
$LN3@GeneratorO:
	mov	DWORD PTR tv68[ebp], 1
$LN4@GeneratorO:
	mov	eax, DWORD PTR tv68[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GeneratorOK@AirframeClass@@QAEHW4Generator@1@@Z ENDP	; AirframeClass::GeneratorOK
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?GeneratorRunning@AirframeClass@@QAEHW4Generator@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_gen$ = 8						; size = 4
?GeneratorRunning@AirframeClass@@QAEHW4Generator@1@@Z PROC ; AirframeClass::GeneratorRunning, COMDAT
; _this$ = ecx

; 1130 : 	BOOL GeneratorRunning(Generator gen) { return (generators & gen) ? TRUE : FALSE; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1804]
	and	ecx, DWORD PTR _gen$[ebp]
	je	SHORT $LN3@GeneratorR
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@GeneratorR
$LN3@GeneratorR:
	mov	DWORD PTR tv67[ebp], 0
$LN4@GeneratorR:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GeneratorRunning@AirframeClass@@QAEHW4Generator@1@@Z ENDP ; AirframeClass::GeneratorRunning
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\airframe\engine.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DecAirSource@AirframeClass@@QAEXXZ PROC		; AirframeClass::DecAirSource
; _this$ = ecx

; 2378 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2379 :     if (airSource == AS_FIRST)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1800], 0
	jne	SHORT $LN2@DecAirSour

; 2380 : 	airSource = AS_LAST;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1800], 3
	jmp	SHORT $LN3@DecAirSour
$LN2@DecAirSour:

; 2381 :     else airSource = (AirSource)(((int)airSource)-1);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1800]
	sub	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1800], eax
$LN3@DecAirSour:

; 2382 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DecAirSource@AirframeClass@@QAEXXZ ENDP		; AirframeClass::DecAirSource
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\airframe\engine.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IncAirSource@AirframeClass@@QAEXXZ PROC		; AirframeClass::IncAirSource
; _this$ = ecx

; 2370 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2371 :     if (airSource == AS_LAST)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1800], 3
	jne	SHORT $LN2@IncAirSour

; 2372 : 	airSource = AS_FIRST;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1800], 0

; 2373 :     else 

	jmp	SHORT $LN3@IncAirSour
$LN2@IncAirSour:

; 2374 : 	airSource = (AirSource)(((int)airSource)+1);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1800]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1800], eax
$LN3@IncAirSour:

; 2375 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IncAirSource@AirframeClass@@QAEXXZ ENDP		; AirframeClass::IncAirSource
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\airframe\engine.cpp
_TEXT	SEGMENT
_wpZ$1 = -64						; size = 4
_fuelOnStation$2 = -60					; size = 4
tv263 = -56						; size = 4
tv247 = -52						; size = 4
tv279 = -48						; size = 4
tv242 = -44						; size = 4
_wpY$3 = -40						; size = 4
_wpX$4 = -36						; size = 4
tv175 = -32						; size = 4
_fuelConsumed$5 = -28					; size = 4
_deltaY$6 = -24						; size = 4
_deltaX$7 = -20						; size = 4
_wp$8 = -16						; size = 4
_fuelConsumed$9 = -12					; size = 4
_distanceToSta$10 = -8					; size = 4
_this$ = -4						; size = 4
?CheckHome@AirframeClass@@QAEHXZ PROC			; AirframeClass::CheckHome
; _this$ = ecx

; 2405 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 2406 : 	//Calc how much fuel we have at our selected homepoint
; 2407 : 	if(OTWDriver.pCockpitManager && OTWDriver.pCockpitManager->mpIcp)

	cmp	DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684, 0
	je	$LN1@CheckHome
	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	cmp	DWORD PTR [eax+688], 0
	je	$LN1@CheckHome

; 2408 : 	{
; 2409 : 		WayPointClass *wp = platform->GetWayPointNo(
; 2410 : 			OTWDriver.pCockpitManager->mpIcp->HomeWP);

	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	edx, DWORD PTR [ecx+688]
	mov	eax, DWORD PTR [edx+440]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1088]
	call	?GetWayPointNo@SimVehicleClass@@QAEPAVWayPointClass@@H@Z ; SimVehicleClass::GetWayPointNo
	mov	DWORD PTR _wp$8[ebp], eax

; 2411 : 		float wpX, wpY, wpZ;
; 2412 : 		if(wp)

	cmp	DWORD PTR _wp$8[ebp], 0
	je	$LN1@CheckHome

; 2413 : 		{
; 2414 : 			wp->GetLocation(&wpX, &wpY, &wpZ);

	lea	edx, DWORD PTR _wpZ$1[ebp]
	push	edx
	lea	eax, DWORD PTR _wpY$3[ebp]
	push	eax
	lea	ecx, DWORD PTR _wpX$4[ebp]
	push	ecx
	mov	ecx, DWORD PTR _wp$8[ebp]
	call	?GetLocation@WayPointClass@@QBEXPAM00@Z	; WayPointClass::GetLocation

; 2415 : 			//Calculate the distance to it
; 2416 : 			float deltaX = wpX - x;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _wpX$4[ebp]
	subss	xmm0, DWORD PTR [edx+1108]
	movss	DWORD PTR _deltaX$7[ebp], xmm0

; 2417 : 			float deltaY = wpY - y;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _wpY$3[ebp]
	subss	xmm0, DWORD PTR [eax+1112]
	movss	DWORD PTR _deltaY$6[ebp], xmm0

; 2418 : 			float distanceToSta	= (float)sqrt(deltaX * deltaX + deltaY * deltaY);

	movss	xmm0, DWORD PTR _deltaX$7[ebp]
	mulss	xmm0, DWORD PTR _deltaX$7[ebp]
	movss	xmm1, DWORD PTR _deltaY$6[ebp]
	mulss	xmm1, DWORD PTR _deltaY$6[ebp]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR _distanceToSta$10[ebp]

; 2419 : 			float fuelConsumed;
; 2420 : 			if (!IsSet(InAir)){

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	jne	SHORT $LN5@CheckHome

; 2421 : 				// JPO - when we're on the runway or something.
; 2422 : 				fuelConsumed = 0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _fuelConsumed$5[ebp], xmm0

; 2423 : 			}
; 2424 : 			else {

	jmp	SHORT $LN4@CheckHome
$LN5@CheckHome:

; 2425 : 				fuelConsumed = distanceToSta / platform->GetVt() * FuelFlow() / 3600.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1088]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+1088]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	fstp	DWORD PTR tv242[ebp]
	movss	xmm0, DWORD PTR _distanceToSta$10[ebp]
	divss	xmm0, DWORD PTR tv242[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv279[ebp], xmm0
	call	?FuelFlow@AirframeClass@@QAEMXZ		; AirframeClass::FuelFlow
	fstp	DWORD PTR tv247[ebp]
	movss	xmm0, DWORD PTR tv279[ebp]
	mulss	xmm0, DWORD PTR tv247[ebp]
	divss	xmm0, DWORD PTR __real@45610000
	movss	DWORD PTR _fuelConsumed$5[ebp], xmm0
$LN4@CheckHome:

; 2426 : 			}
; 2427 : 			HomeFuel =  (int)(platform->GetTotalFuel() - fuelConsumed);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1088]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+1088]
	mov	eax, DWORD PTR [edx+468]
	call	eax
	cvtsi2ss xmm0, eax
	subss	xmm0, DWORD PTR _fuelConsumed$5[ebp]
	cvttss2si ecx, xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1796], ecx

; 2428 : 
; 2429 : 			if(platform->IsF16())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	call	?IsF16@AircraftClass@@QAEHXZ		; AircraftClass::IsF16
	test	eax, eax
	je	$LN3@CheckHome

; 2430 : 			{
; 2431 : 	 			int	fuelOnStation;
; 2432 : 	 			float fuelConsumed	= distanceToSta / 6000.0f * 10.0f * 0.67f;

	movss	xmm0, DWORD PTR _distanceToSta$10[ebp]
	divss	xmm0, DWORD PTR __real@45bb8000
	mulss	xmm0, DWORD PTR __real@41200000
	mulss	xmm0, DWORD PTR __real@3f2b851f
	movss	DWORD PTR _fuelConsumed$9[ebp], xmm0

; 2433 : 				fuelConsumed += min(1,distanceToSta / 6000.0f / 80.0f) *(500.0f - (-platform->ZPos()) /40.0f*0.5f);

	movss	xmm0, DWORD PTR _distanceToSta$10[ebp]
	divss	xmm0, DWORD PTR __real@45bb8000
	divss	xmm0, DWORD PTR __real@42a00000
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN10@CheckHome
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv175[ebp], xmm0
	jmp	SHORT $LN11@CheckHome
$LN10@CheckHome:
	movss	xmm0, DWORD PTR _distanceToSta$10[ebp]
	divss	xmm0, DWORD PTR __real@45bb8000
	divss	xmm0, DWORD PTR __real@42a00000
	movss	DWORD PTR tv175[ebp], xmm0
$LN11@CheckHome:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv263[ebp]
	movss	xmm0, DWORD PTR tv263[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	divss	xmm0, DWORD PTR __real@42200000
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	xmm1, DWORD PTR __real@43fa0000
	subss	xmm1, xmm0
	mulss	xmm1, DWORD PTR tv175[ebp]
	addss	xmm1, DWORD PTR _fuelConsumed$9[ebp]
	movss	DWORD PTR _fuelConsumed$9[ebp], xmm1

; 2434 : 	 			fuelOnStation = (int)(platform->GetTotalFuel() - fuelConsumed);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1088]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+1088]
	mov	eax, DWORD PTR [edx+468]
	call	eax
	cvtsi2ss xmm0, eax
	subss	xmm0, DWORD PTR _fuelConsumed$9[ebp]
	cvttss2si ecx, xmm0
	mov	DWORD PTR _fuelOnStation$2[ebp], ecx

; 2435 : 				HomeFuel = fuelOnStation;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _fuelOnStation$2[ebp]
	mov	DWORD PTR [edx+1796], eax
$LN3@CheckHome:

; 2436 : 			}
; 2437 : 
; 2438 : 			if(HomeFuel < 800){

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1796], 800		; 00000320H
	jge	SHORT $LN2@CheckHome

; 2439 : 				return 1;	//here we get a warning

	mov	eax, 1
	jmp	SHORT $LN8@CheckHome

; 2440 : 			}
; 2441 : 			else{

	jmp	SHORT $LN1@CheckHome
$LN2@CheckHome:

; 2442 : 				return 0;	//here not

	xor	eax, eax
	jmp	SHORT $LN8@CheckHome
$LN1@CheckHome:

; 2443 : 			}
; 2444 : 		 }
; 2445 : 	}
; 2446 : 	return 0;	//dummy

	xor	eax, eax
$LN8@CheckHome:

; 2447 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CheckHome@AirframeClass@@QAEHXZ ENDP			; AirframeClass::CheckHome
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\airframe\engine.cpp
_TEXT	SEGMENT
_fuscap$ = -8						; size = 4
_this$ = -4						; size = 4
?CheckTrapped@AirframeClass@@QAEHXZ PROC		; AirframeClass::CheckTrapped
; _this$ = ecx

; 2392 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 2393 :     if (fuelSwitch != FS_NORM ) return 0; // cond 1

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1680], 0
	je	SHORT $LN4@CheckTrapp
	xor	eax, eax
	jmp	$LN5@CheckTrapp
$LN4@CheckTrapp:

; 2394 :     if (externalFuel < 500) return 0; // cond 4

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@43fa0000
	comiss	xmm0, DWORD PTR [ecx+32]
	jbe	SHORT $LN3@CheckTrapp
	xor	eax, eax
	jmp	$LN5@CheckTrapp
$LN3@CheckTrapp:

; 2395 :     if (fuelFlow > 18000) return 0; // cond 5

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+24]
	comiss	xmm0, DWORD PTR __real@468ca000
	jbe	SHORT $LN2@CheckTrapp
	xor	eax, eax
	jmp	$LN5@CheckTrapp
$LN2@CheckTrapp:

; 2396 : 
; 2397 :     float fuscap = m_tankcap[TANK_FWDRES] + m_tankcap[TANK_F1] + m_tankcap[TANK_WINGFR]
; 2398 : 	+ m_tankcap[TANK_AFTRES] + m_tankcap[TANK_A1] + m_tankcap[TANK_WINGAL];

	mov	eax, 4
	imul	eax, 0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+1724]
	addss	xmm0, DWORD PTR [esi+ecx+1724]
	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+eax+1724]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+edx+1724]
	mov	ecx, 4
	imul	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx+1724]
	mov	eax, 4
	imul	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+eax+1724]
	movss	DWORD PTR _fuscap$[ebp], xmm0

; 2399 :     if (fuel > fuscap - 500) return 0; // cond 3

	movss	xmm0, DWORD PTR _fuscap$[ebp]
	subss	xmm0, DWORD PTR __real@43fa0000
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+20]
	comiss	xmm1, xmm0
	jbe	SHORT $LN1@CheckTrapp
	xor	eax, eax
	jmp	SHORT $LN5@CheckTrapp
$LN1@CheckTrapp:

; 2400 :     // TODO 30 second timer 
; 2401 :     return 1;

	mov	eax, 1
$LN5@CheckTrapp:

; 2402 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?CheckTrapped@AirframeClass@@QAEHXZ ENDP		; AirframeClass::CheckTrapped
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\airframe\engine.cpp
_TEXT	SEGMENT
tv79 = -16						; size = 4
_fumesfactor$ = -12					; size = 4
tv77 = -8						; size = 4
_this$ = -4						; size = 4
?GetFumes@AirframeClass@@QAEMXZ PROC			; AirframeClass::GetFumes
; _this$ = ecx

; 2462 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 2463 : 	float fumesfactor = auxaeroData->fumesFactor;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movss	xmm0, DWORD PTR [ecx+2576]
	movss	DWORD PTR _fumesfactor$[ebp], xmm0

; 2464 :     return GetAeroData(AeroDataSet::InternalFuel) / fumesfactor; // default 15.0 = about 500 for F-16

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAeroData@AirframeClass@@QBEMH@Z	; AirframeClass::GetAeroData
	fstp	DWORD PTR tv77[ebp]
	movss	xmm0, DWORD PTR tv77[ebp]
	divss	xmm0, DWORD PTR _fumesfactor$[ebp]
	movss	DWORD PTR tv79[ebp], xmm0
	fld	DWORD PTR tv79[ebp]

; 2465 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFumes@AirframeClass@@QAEMXZ ENDP			; AirframeClass::GetFumes
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\airframe\engine.cpp
_TEXT	SEGMENT
tv79 = -16						; size = 4
_bingofactor$ = -12					; size = 4
tv77 = -8						; size = 4
_this$ = -4						; size = 4
?GetBingo@AirframeClass@@QAEMXZ PROC			; AirframeClass::GetBingo
; _this$ = ecx

; 2456 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 2457 : 	float bingofactor = auxaeroData->bingoFactor;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movss	xmm0, DWORD PTR [ecx+2572]
	movss	DWORD PTR _bingofactor$[ebp], xmm0

; 2458 :     return GetAeroData(AeroDataSet::InternalFuel) / bingofactor;// default 5.0 = about 1500 for F-16

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAeroData@AirframeClass@@QBEMH@Z	; AirframeClass::GetAeroData
	fstp	DWORD PTR tv77[ebp]
	movss	xmm0, DWORD PTR tv77[ebp]
	divss	xmm0, DWORD PTR _bingofactor$[ebp]
	movss	DWORD PTR tv79[ebp], xmm0
	fld	DWORD PTR tv79[ebp]

; 2459 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetBingo@AirframeClass@@QAEMXZ ENDP			; AirframeClass::GetBingo
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\airframe\engine.cpp
_TEXT	SEGMENT
tv79 = -16						; size = 4
_jokerfactor$ = -12					; size = 4
tv77 = -8						; size = 4
_this$ = -4						; size = 4
?GetJoker@AirframeClass@@QAEMXZ PROC			; AirframeClass::GetJoker
; _this$ = ecx

; 2450 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 2451 : 	float jokerfactor = auxaeroData->jokerFactor;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movss	xmm0, DWORD PTR [ecx+2568]
	movss	DWORD PTR _jokerfactor$[ebp], xmm0

; 2452 :     return GetAeroData(AeroDataSet::InternalFuel) / jokerfactor; // default 2.0 = about 3500 for F-16

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAeroData@AirframeClass@@QBEMH@Z	; AirframeClass::GetAeroData
	fstp	DWORD PTR tv77[ebp]
	movss	xmm0, DWORD PTR tv77[ebp]
	divss	xmm0, DWORD PTR _jokerfactor$[ebp]
	movss	DWORD PTR tv79[ebp], xmm0
	fld	DWORD PTR tv79[ebp]

; 2453 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetJoker@AirframeClass@@QAEMXZ ENDP			; AirframeClass::GetJoker
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\airframe\engine.cpp
_TEXT	SEGMENT
tv153 = -16						; size = 4
tv131 = -12						; size = 4
tv78 = -8						; size = 4
_this$ = -4						; size = 4
?AvailableFuel@AirframeClass@@QAEMXZ PROC		; AirframeClass::AvailableFuel
; _this$ = ecx

; 2097 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 2098 :     if (!g_bRealisticAvionics) 

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN10@AvailableF

; 2099 : 	return externalFuel + fuel;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+32]
	addss	xmm0, DWORD PTR [edx+20]
	movss	DWORD PTR tv131[ebp], xmm0
	fld	DWORD PTR tv131[ebp]
	jmp	$LN4@AvailableF
	jmp	SHORT $LN6@AvailableF
$LN10@AvailableF:

; 2100 :     else if (IsEngineFlag(MasterFuelOff))

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsEngineFlag@AirframeClass@@QAEHW4EngineFlags@1@@Z ; AirframeClass::IsEngineFlag
	test	eax, eax
	je	SHORT $LN8@AvailableF

; 2101 : 	return 0.0f;

	fldz
	jmp	$LN4@AvailableF
	jmp	SHORT $LN6@AvailableF
$LN8@AvailableF:

; 2102 :     else if (fuelPump == FP_OFF && nzcgb < -0.5f) // -ve G

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1684], 0
	jne	SHORT $LN6@AvailableF
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf000000
	comiss	xmm0, DWORD PTR [ecx+1192]
	jbe	SHORT $LN6@AvailableF

; 2103 : 	return 0.0f;

	fldz
	jmp	SHORT $LN4@AvailableF
$LN6@AvailableF:

; 2104 :     switch (fuelPump) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1684]
	mov	DWORD PTR tv78[ebp], eax
	cmp	DWORD PTR tv78[ebp], 2
	je	SHORT $LN2@AvailableF
	cmp	DWORD PTR tv78[ebp], 3
	je	SHORT $LN3@AvailableF
	jmp	SHORT $LN1@AvailableF
$LN3@AvailableF:

; 2105 :     case FP_FWD:
; 2106 : 	return m_tanks[TANK_FWDRES];

	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+ecx+1688]
	jmp	SHORT $LN4@AvailableF
$LN2@AvailableF:

; 2107 :     case FP_AFT:
; 2108 : 	return m_tanks[TANK_AFTRES];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+eax+1688]
	jmp	SHORT $LN4@AvailableF
$LN1@AvailableF:

; 2109 :     default:
; 2110 : 	return m_tanks[TANK_AFTRES] + m_tanks[TANK_FWDRES];

	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+1688]
	addss	xmm0, DWORD PTR [esi+eax+1688]
	movss	DWORD PTR tv153[ebp], xmm0
	fld	DWORD PTR tv153[ebp]
$LN4@AvailableF:

; 2111 :     }
; 2112 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?AvailableFuel@AirframeClass@@QAEMXZ ENDP		; AirframeClass::AvailableFuel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\airframe\engine.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DecFuelPump@AirframeClass@@QAEXXZ PROC			; AirframeClass::DecFuelPump
; _this$ = ecx

; 2362 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2363 :     if (fuelPump == FP_FIRST)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1684], 0
	jne	SHORT $LN2@DecFuelPum

; 2364 : 	fuelPump = FP_LAST;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1684], 3
	jmp	SHORT $LN3@DecFuelPum
$LN2@DecFuelPum:

; 2365 :     else fuelPump = (FuelPump)(((int)fuelPump)-1);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1684]
	sub	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1684], eax
$LN3@DecFuelPum:

; 2366 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DecFuelPump@AirframeClass@@QAEXXZ ENDP			; AirframeClass::DecFuelPump
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\airframe\engine.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IncFuelPump@AirframeClass@@QAEXXZ PROC			; AirframeClass::IncFuelPump
; _this$ = ecx

; 2354 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2355 :     if (fuelPump == FP_LAST)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1684], 3
	jne	SHORT $LN2@IncFuelPum

; 2356 : 	fuelPump = FP_FIRST;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1684], 0

; 2357 :     else 

	jmp	SHORT $LN3@IncFuelPum
$LN2@IncFuelPum:

; 2358 : 	fuelPump = (FuelPump)(((int)fuelPump)+1);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1684]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1684], eax
$LN3@IncFuelPum:

; 2359 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IncFuelPump@AirframeClass@@QAEXXZ ENDP			; AirframeClass::IncFuelPump
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\airframe\engine.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DecFuelSwitch@AirframeClass@@QAEXXZ PROC		; AirframeClass::DecFuelSwitch
; _this$ = ecx

; 2334 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2335 :     if (fuelSwitch == FS_FIRST)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1680], 0
	jne	SHORT $LN5@DecFuelSwi

; 2336 : 	fuelSwitch = FS_LAST;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1680], 5

; 2337 :     else 

	jmp	SHORT $LN4@DecFuelSwi
$LN5@DecFuelSwi:

; 2338 : 	fuelSwitch = (FuelSwitch)(((int)fuelSwitch)-1);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1680]
	sub	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1680], eax
$LN4@DecFuelSwi:

; 2339 :     if (fuelSwitch == FS_TEST) {

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1680], 5
	jne	SHORT $LN6@DecFuelSwi

; 2340 : 		if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN2@DecFuelSwi

; 2341 : 		{
; 2342 : 			platform->mFaults->SetFault(fwd_fuel_low_fault);

	push	22					; 00000016H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1088]
	mov	ecx, DWORD PTR [edx+928]
	call	?SetFault@FackClass@@QAEXW4type_CSubSystem@@@Z ; FackClass::SetFault

; 2343 : 			platform->mFaults->SetFault(aft_fuel_low_fault);

	push	23					; 00000017H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	mov	ecx, DWORD PTR [ecx+928]
	call	?SetFault@FackClass@@QAEXW4type_CSubSystem@@@Z ; FackClass::SetFault

; 2344 : 		}
; 2345 : 		else

	jmp	SHORT $LN6@DecFuelSwi
$LN2@DecFuelSwi:

; 2346 : 		{
; 2347 : 			platform->mFaults->SetCaution(fwd_fuel_low_fault);

	push	22					; 00000016H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1088]
	mov	ecx, DWORD PTR [eax+928]
	call	?SetCaution@FackClass@@QAEXW4type_CSubSystem@@@Z ; FackClass::SetCaution

; 2348 : 			platform->mFaults->SetCaution(aft_fuel_low_fault);

	push	23					; 00000017H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1088]
	mov	ecx, DWORD PTR [edx+928]
	call	?SetCaution@FackClass@@QAEXW4type_CSubSystem@@@Z ; FackClass::SetCaution
$LN6@DecFuelSwi:

; 2349 : 		}
; 2350 :     }
; 2351 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DecFuelSwitch@AirframeClass@@QAEXXZ ENDP		; AirframeClass::DecFuelSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\airframe\engine.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IncFuelSwitch@AirframeClass@@QAEXXZ PROC		; AirframeClass::IncFuelSwitch
; _this$ = ecx

; 2315 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2316 :     if (fuelSwitch == FS_LAST)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1680], 5
	jne	SHORT $LN5@IncFuelSwi

; 2317 : 	fuelSwitch = FS_FIRST;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1680], 0
	jmp	SHORT $LN4@IncFuelSwi
$LN5@IncFuelSwi:

; 2318 :     else fuelSwitch = (FuelSwitch)(((int)fuelSwitch)+1);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1680]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1680], eax
$LN4@IncFuelSwi:

; 2319 :     if (fuelSwitch == FS_TEST) {

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1680], 5
	jne	SHORT $LN6@IncFuelSwi

; 2320 : 		if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN2@IncFuelSwi

; 2321 : 		{
; 2322 : 			platform->mFaults->SetFault(fwd_fuel_low_fault);

	push	22					; 00000016H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1088]
	mov	ecx, DWORD PTR [edx+928]
	call	?SetFault@FackClass@@QAEXW4type_CSubSystem@@@Z ; FackClass::SetFault

; 2323 : 			platform->mFaults->SetFault(aft_fuel_low_fault);

	push	23					; 00000017H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	mov	ecx, DWORD PTR [ecx+928]
	call	?SetFault@FackClass@@QAEXW4type_CSubSystem@@@Z ; FackClass::SetFault

; 2324 : 		}
; 2325 : 		else

	jmp	SHORT $LN6@IncFuelSwi
$LN2@IncFuelSwi:

; 2326 : 		{
; 2327 : 			platform->mFaults->SetCaution(fwd_fuel_low_fault);

	push	22					; 00000016H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1088]
	mov	ecx, DWORD PTR [eax+928]
	call	?SetCaution@FackClass@@QAEXW4type_CSubSystem@@@Z ; FackClass::SetCaution

; 2328 : 			platform->mFaults->SetCaution(aft_fuel_low_fault);

	push	23					; 00000017H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1088]
	mov	ecx, DWORD PTR [edx+928]
	call	?SetCaution@FackClass@@QAEXW4type_CSubSystem@@@Z ; FackClass::SetCaution
$LN6@IncFuelSwi:

; 2329 : 		}
; 2330 :     }
; 2331 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IncFuelSwitch@AirframeClass@@QAEXXZ ENDP		; AirframeClass::IncFuelSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?ClearEngineFlag@AirframeClass@@QAEXW4EngineFlags@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ef$ = 8						; size = 4
?ClearEngineFlag@AirframeClass@@QAEXW4EngineFlags@1@@Z PROC ; AirframeClass::ClearEngineFlag, COMDAT
; _this$ = ecx

; 1072 : 	void ClearEngineFlag(EngineFlags ef) { engineFlags &= ~ ef; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _ef$[ebp]
	not	eax
	mov	ecx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [ecx+1676]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1676], eax
	mov	esp, ebp
	pop	ebp
	ret	4
?ClearEngineFlag@AirframeClass@@QAEXW4EngineFlags@1@@Z ENDP ; AirframeClass::ClearEngineFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?SetEngineFlag@AirframeClass@@QAEXW4EngineFlags@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ef$ = 8						; size = 4
?SetEngineFlag@AirframeClass@@QAEXW4EngineFlags@1@@Z PROC ; AirframeClass::SetEngineFlag, COMDAT
; _this$ = ecx

; 1071 : 	void SetEngineFlag(EngineFlags ef) { engineFlags |= ef; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1676]
	or	ecx, DWORD PTR _ef$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1676], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetEngineFlag@AirframeClass@@QAEXW4EngineFlags@1@@Z ENDP ; AirframeClass::SetEngineFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?IsEngineFlag@AirframeClass@@QAEHW4EngineFlags@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_ef$ = 8						; size = 4
?IsEngineFlag@AirframeClass@@QAEHW4EngineFlags@1@@Z PROC ; AirframeClass::IsEngineFlag, COMDAT
; _this$ = ecx

; 1070 : 	int IsEngineFlag(EngineFlags ef) { return (engineFlags & ef) ? 1 : 0; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1676]
	and	ecx, DWORD PTR _ef$[ebp]
	je	SHORT $LN3@IsEngineFl
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsEngineFl
$LN3@IsEngineFl:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsEngineFl:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsEngineFlag@AirframeClass@@QAEHW4EngineFlags@1@@Z ENDP ; AirframeClass::IsEngineFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\airframe\engine.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?QuickEngineStart@AirframeClass@@QAEXXZ PROC		; AirframeClass::QuickEngineStart
; _this$ = ecx

; 2019 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2020 :     ClearFlag (EngineStopped);

	push	134217728				; 08000000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearFlag@AirframeClass@@QAEXH@Z	; AirframeClass::ClearFlag

; 2021 : 	
; 2022 :     //ClearFlag(JfsStart); TJL 08/15/04 
; 2023 :     //GeneratorOn(GenMain);
; 2024 :     //GeneratorOn(GenStdby);
; 2025 : 	//GeneratorOff(GenEpu);  // MD -- 20040531: don't forget to ensure the EPU isn't running
; 2026 :     rpm = 0.75f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f400000
	movss	DWORD PTR [eax+1212], xmm0

; 2027 :     oldRpm[0] = rpm;

	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1212]
	mov	DWORD PTR [edx+ecx+500], eax

; 2028 :     oldRpm[1] = rpm;

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1212]
	mov	DWORD PTR [edx+ecx+500], eax

; 2029 :     oldRpm[2] = rpm;

	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1212]
	mov	DWORD PTR [edx+ecx+500], eax

; 2030 :     oldRpm[3] = rpm;

	mov	ecx, 4
	imul	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1212]
	mov	DWORD PTR [edx+ecx+500], eax

; 2031 :     HydrRestore(HYDR_ALL);

	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HydrRestore@AirframeClass@@QAEXH@Z	; AirframeClass::HydrRestore

; 2032 : 
; 2033 : 	//TJL 01/11/04 Multi-Engine Quick Start
; 2034 : 	if (auxaeroData->nEngines == 2)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+344], 2
	jne	$LN1@QuickEngin

; 2035 : 	{		
; 2036 : 		ClearEngineFlag(AirframeClass::EngineStopped2);

	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearEngineFlag@AirframeClass@@QAEXW4EngineFlags@1@@Z ; AirframeClass::ClearEngineFlag

; 2037 : 		rpm2 = 0.75f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f400000
	movss	DWORD PTR [eax+1216], xmm0

; 2038 : 		oldRpm2[0] = rpm2;

	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1216]
	mov	DWORD PTR [edx+ecx+524], eax

; 2039 : 		oldRpm2[1] = rpm2;

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1216]
	mov	DWORD PTR [edx+ecx+524], eax

; 2040 : 		oldRpm2[2] = rpm2;

	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1216]
	mov	DWORD PTR [edx+ecx+524], eax

; 2041 : 		oldRpm2[3] = rpm2;

	mov	ecx, 4
	imul	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1216]
	mov	DWORD PTR [edx+ecx+524], eax
$LN1@QuickEngin:

; 2042 : 	}
; 2043 : 	ClearFlag(JfsStart); //TJL 08/15/04 Moved here

	push	268435456				; 10000000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearFlag@AirframeClass@@QAEXH@Z	; AirframeClass::ClearFlag

; 2044 :     GeneratorOn(GenMain);

	push	1024					; 00000400H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GeneratorOn@AirframeClass@@QAEXW4Generator@1@@Z ; AirframeClass::GeneratorOn

; 2045 :     GeneratorOn(GenStdby);

	push	64					; 00000040H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GeneratorOn@AirframeClass@@QAEXW4Generator@1@@Z ; AirframeClass::GeneratorOn

; 2046 : 	GeneratorOff(GenEpu);

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GeneratorOff@AirframeClass@@QAEXW4Generator@1@@Z ; AirframeClass::GeneratorOff

; 2047 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?QuickEngineStart@AirframeClass@@QAEXXZ ENDP		; AirframeClass::QuickEngineStart
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\airframe\engine.cpp
_TEXT	SEGMENT
tv207 = -20						; size = 4
tv205 = -16						; size = 4
tv184 = -12						; size = 4
tv177 = -8						; size = 4
_this$ = -4						; size = 4
?JfsEngineStart@AirframeClass@@QAEXXZ PROC		; AirframeClass::JfsEngineStart
; _this$ = ecx

; 1990 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 1991 :     if (jfsaccumulator < 90.0f) { // not charged

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@42b40000
	comiss	xmm0, DWORD PTR [eax+1604]
	jbe	SHORT $LN6@JfsEngineS

; 1992 : 	return;

	jmp	$LN7@JfsEngineS
$LN6@JfsEngineS:

; 1993 :     }
; 1994 :     //F4SoundFXSetPos( SFX_VULEND, 0, x, y, z, 1.0f );
; 1995 : 	platform->SoundPos.Sfx(SFX_VULEND); // MLR 5/16/2004 - 

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	0
	push	27					; 0000001bH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1088]
	add	ecx, 444				; 000001bcH
	call	?Sfx@F4SoundPos@@QAEXHHMM@Z		; F4SoundPos::Sfx

; 1996 :     jfsaccumulator = 0.0f; // all used up

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+1604], xmm0

; 1997 :     if (fuel <= 0.0f) return; // nothing to run JFS off.

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [eax+20]
	jb	SHORT $LN5@JfsEngineS
	jmp	$LN7@JfsEngineS
$LN5@JfsEngineS:

; 1998 :     
; 1999 :     // attempting JFS start - only works below 400kias and 20,000ft
; 2000 :     if (platform->GetKias() > 400.0f) {

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1088]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+1088]
	mov	eax, DWORD PTR [edx+224]
	call	eax
	fstp	DWORD PTR tv177[ebp]
	movss	xmm0, DWORD PTR tv177[ebp]
	comiss	xmm0, DWORD PTR __real@43c80000
	jbe	SHORT $LN3@JfsEngineS

; 2001 : 	if (platform->GetKias() - 400.0f > rand()%100) { // one shot failed

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1088]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+1088]
	mov	eax, DWORD PTR [edx+224]
	call	eax
	fstp	DWORD PTR tv184[ebp]
	movss	xmm0, DWORD PTR tv184[ebp]
	subss	xmm0, DWORD PTR __real@43c80000
	movss	DWORD PTR tv205[ebp], xmm0
	call	_rand
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	cvtsi2ss xmm0, edx
	movss	xmm1, DWORD PTR tv205[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN3@JfsEngineS

; 2002 : 	    return;

	jmp	SHORT $LN7@JfsEngineS
$LN3@JfsEngineS:

; 2003 : 	}
; 2004 :     }
; 2005 :     if (-z > 20000.0f) { 

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1116]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	comiss	xmm0, DWORD PTR __real@469c4000
	jbe	SHORT $LN1@JfsEngineS

; 2006 : 	if ( (-z) - 20000.0f > rand() % 5000) {

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1116]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	subss	xmm0, DWORD PTR __real@469c4000
	movss	DWORD PTR tv207[ebp], xmm0
	call	_rand
	cdq
	mov	ecx, 5000				; 00001388H
	idiv	ecx
	cvtsi2ss xmm0, edx
	movss	xmm1, DWORD PTR tv207[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN1@JfsEngineS

; 2007 : 	    return;

	jmp	SHORT $LN7@JfsEngineS
$LN1@JfsEngineS:

; 2008 : 	}
; 2009 :     }
; 2010 :     SetFlag(AirframeClass::JfsStart);

	push	268435456				; 10000000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFlag@AirframeClass@@QAEXH@Z		; AirframeClass::SetFlag

; 2011 : 	//MI add in JFS spin time
; 2012 : 	JFSSpinTime = 240;	//4 minutes available

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@43700000
	movss	DWORD PTR [edx+1608], xmm0
$LN7@JfsEngineS:

; 2013 : 
; 2014 : 
; 2015 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?JfsEngineStart@AirframeClass@@QAEXXZ ENDP		; AirframeClass::JfsEngineStart
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\airframe\engine.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_sys$ = 8						; size = 4
?HydrRestore@AirframeClass@@QAEXH@Z PROC		; AirframeClass::HydrRestore
; _this$ = ecx

; 1963 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1964 :     // restore A if not broke
; 1965 : 		if ((sys & HYDR_A_SYSTEM) && (hydrAB & HYDR_A_BROKE) == 0) {

	mov	eax, DWORD PTR _sys$[ebp]
	and	eax, 1
	je	SHORT $LN2@HydrRestor
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+1601]
	and	edx, 4
	jne	SHORT $LN2@HydrRestor

; 1966 : 	hydrAB |= HYDR_A_SYSTEM;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+1601]
	or	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1601], cl
$LN2@HydrRestor:

; 1967 :     }
; 1968 :     // restore B if not broke
; 1969 :     if ((sys & HYDR_B_SYSTEM) && (hydrAB & HYDR_B_BROKE) == 0) {

	mov	eax, DWORD PTR _sys$[ebp]
	and	eax, 2
	je	SHORT $LN3@HydrRestor
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+1601]
	and	edx, 8
	jne	SHORT $LN3@HydrRestor

; 1970 : 		hydrAB |= HYDR_B_SYSTEM;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+1601]
	or	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1601], cl
$LN3@HydrRestor:

; 1971 :     }
; 1972 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?HydrRestore@AirframeClass@@QAEXH@Z ENDP		; AirframeClass::HydrRestore
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?HydrDown@AirframeClass@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_sys$ = 8						; size = 4
?HydrDown@AirframeClass@@QAEXH@Z PROC			; AirframeClass::HydrDown, COMDAT
; _this$ = ecx

; 1044 : 	void HydrDown (int sys) { hydrAB &= ~(sys & HYDR_ALL); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _sys$[ebp]
	and	eax, 3
	not	eax
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+1601]
	and	edx, eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1601], dl
	mov	esp, ebp
	pop	ebp
	ret	4
?HydrDown@AirframeClass@@QAEXH@Z ENDP			; AirframeClass::HydrDown
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\airframe\engine.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_sys$ = 8						; size = 4
?HydrBreak@AirframeClass@@QAEXH@Z PROC			; AirframeClass::HydrBreak
; _this$ = ecx

; 1951 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1952 :     if (sys & HYDR_A_SYSTEM) { // mark A system as down and broke

	mov	eax, DWORD PTR _sys$[ebp]
	and	eax, 1
	je	SHORT $LN2@HydrBreak

; 1953 : 		hydrAB &= ~ HYDR_A_SYSTEM;

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+1601]
	and	edx, -2					; fffffffeH
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1601], dl

; 1954 : 		hydrAB |= HYDR_A_BROKE;

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+1601]
	or	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1601], dl
$LN2@HydrBreak:

; 1955 :     }
; 1956 :     if (sys & HYDR_B_SYSTEM) { // mark A system as down and broke

	mov	ecx, DWORD PTR _sys$[ebp]
	and	ecx, 2
	je	SHORT $LN3@HydrBreak

; 1957 : 		hydrAB &= ~ HYDR_B_SYSTEM;

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+1601]
	and	eax, -3					; fffffffdH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1601], al

; 1958 : 		hydrAB |= HYDR_B_BROKE;

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+1601]
	or	eax, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1601], al
$LN3@HydrBreak:

; 1959 :     }
; 1960 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?HydrBreak@AirframeClass@@QAEXH@Z ENDP			; AirframeClass::HydrBreak
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?EpuClear@AirframeClass@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?EpuClear@AirframeClass@@QAEXXZ PROC			; AirframeClass::EpuClear, COMDAT
; _this$ = ecx

; 1029 : 	void EpuClear() { epuBurnState = EpuNone; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1600], 0
	mov	esp, ebp
	pop	ebp
	ret	0
?EpuClear@AirframeClass@@QAEXXZ ENDP			; AirframeClass::EpuClear
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?EpuSetAir@AirframeClass@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?EpuSetAir@AirframeClass@@QAEXXZ PROC			; AirframeClass::EpuSetAir, COMDAT
; _this$ = ecx

; 1028 : 	void EpuSetAir() { epuBurnState |= EpuAir; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+1600]
	or	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1600], cl
	mov	esp, ebp
	pop	ebp
	ret	0
?EpuSetAir@AirframeClass@@QAEXXZ ENDP			; AirframeClass::EpuSetAir
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?EpuSetHydrazine@AirframeClass@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?EpuSetHydrazine@AirframeClass@@QAEXXZ PROC		; AirframeClass::EpuSetHydrazine, COMDAT
; _this$ = ecx

; 1027 : 	void EpuSetHydrazine() { epuBurnState |= EpuHydrazine; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+1600]
	or	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1600], cl
	mov	esp, ebp
	pop	ebp
	ret	0
?EpuSetHydrazine@AirframeClass@@QAEXXZ ENDP		; AirframeClass::EpuSetHydrazine
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\airframe\engine.cpp
_TEXT	SEGMENT
tv65 = -8						; size = 4
_this$ = -4						; size = 4
?StepEpuSwitch@AirframeClass@@QAEXXZ PROC		; AirframeClass::StepEpuSwitch
; _this$ = ecx

; 1975 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1976 :     switch (epuState) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1596]
	mov	DWORD PTR tv65[ebp], ecx
	cmp	DWORD PTR tv65[ebp], 0
	je	SHORT $LN3@StepEpuSwi
	cmp	DWORD PTR tv65[ebp], 1
	je	SHORT $LN2@StepEpuSwi
	cmp	DWORD PTR tv65[ebp], 2
	je	SHORT $LN1@StepEpuSwi
	jmp	SHORT $LN6@StepEpuSwi
$LN3@StepEpuSwi:

; 1977 :     case OFF:
; 1978 : 	epuState = AUTO;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1596], 1

; 1979 : 	break;

	jmp	SHORT $LN6@StepEpuSwi
$LN2@StepEpuSwi:

; 1980 :     case AUTO:
; 1981 : 	epuState = ON;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1596], 2

; 1982 : 	break;

	jmp	SHORT $LN6@StepEpuSwi
$LN1@StepEpuSwi:

; 1983 :     case ON:
; 1984 : 	epuState = OFF;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1596], 0
$LN6@StepEpuSwi:

; 1985 : 	break;
; 1986 :     }
; 1987 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?StepEpuSwitch@AirframeClass@@QAEXXZ ENDP		; AirframeClass::StepEpuSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?GetEpuSwitch@AirframeClass@@QAE?AW4EpuState@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetEpuSwitch@AirframeClass@@QAE?AW4EpuState@1@XZ PROC	; AirframeClass::GetEpuSwitch, COMDAT
; _this$ = ecx

; 1021 : 	EpuState GetEpuSwitch () { return epuState; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1596]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetEpuSwitch@AirframeClass@@QAE?AW4EpuState@1@XZ ENDP	; AirframeClass::GetEpuSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\airframe\engine.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_tmpLeft$ = 8						; size = 4
_tmpRight$ = 12						; size = 4
?CalcFtit@AirframeClass@@QAEMMM@Z PROC			; AirframeClass::CalcFtit
; _this$ = ecx

; 3027 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3028 : 			//left
; 3029 : 			//start to idle
; 3030 : 			if (rpm < 0.69f)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f30a3d7
	comiss	xmm0, DWORD PTR [eax+1212]
	jbe	SHORT $LN8@CalcFtit

; 3031 : 				ftitLeft = rpm * auxaeroData->FTITStart;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1212]
	mulss	xmm0, DWORD PTR [edx+4008]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+104], xmm0
	jmp	SHORT $LN5@CalcFtit
$LN8@CalcFtit:

; 3032 : 			else if (rpm >=0.69f && rpm < 0.85f)

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1212]
	comiss	xmm0, DWORD PTR __real@3f30a3d7
	jb	SHORT $LN6@CalcFtit
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f59999a
	comiss	xmm0, DWORD PTR [eax+1212]
	jbe	SHORT $LN6@CalcFtit

; 3033 : 				ftitLeft = rpm * auxaeroData->FTITIdle;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1212]
	mulss	xmm0, DWORD PTR [edx+4012]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+104], xmm0

; 3034 : 			else 

	jmp	SHORT $LN5@CalcFtit
$LN6@CalcFtit:

; 3035 : 				ftitLeft = rpm * auxaeroData->FTITMax;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1212]
	mulss	xmm0, DWORD PTR [eax+4016]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+104], xmm0
$LN5@CalcFtit:

; 3036 : 
; 3037 : 			//Right
; 3038 : 			//start to idle
; 3039 : 			if (rpm2 < 0.69f)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f30a3d7
	comiss	xmm0, DWORD PTR [eax+1216]
	jbe	SHORT $LN4@CalcFtit

; 3040 : 				ftitRight = rpm2 * auxaeroData->FTITStart;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1216]
	mulss	xmm0, DWORD PTR [edx+4008]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+108], xmm0
	jmp	SHORT $LN1@CalcFtit
$LN4@CalcFtit:

; 3041 : 			else if (rpm2 >=0.69f && rpm2 < 0.85f)

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1216]
	comiss	xmm0, DWORD PTR __real@3f30a3d7
	jb	SHORT $LN2@CalcFtit
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f59999a
	comiss	xmm0, DWORD PTR [eax+1216]
	jbe	SHORT $LN2@CalcFtit

; 3042 : 				ftitRight = rpm2 * auxaeroData->FTITIdle;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1216]
	mulss	xmm0, DWORD PTR [edx+4012]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+108], xmm0

; 3043 : 			else 

	jmp	SHORT $LN1@CalcFtit
$LN2@CalcFtit:

; 3044 : 				ftitRight = rpm2 * auxaeroData->FTITMax;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1216]
	mulss	xmm0, DWORD PTR [eax+4016]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+108], xmm0
$LN1@CalcFtit:

; 3045 : 
; 3046 : 		return (tmpLeft, tmpRight);

	fld	DWORD PTR _tmpRight$[ebp]

; 3047 : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?CalcFtit@AirframeClass@@QAEMMM@Z ENDP			; AirframeClass::CalcFtit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\airframe\engine.cpp
_TEXT	SEGMENT
tv1080 = -248						; size = 4
tv787 = -244						; size = 4
tv1058 = -240						; size = 4
tv701 = -236						; size = 4
tv1040 = -232						; size = 4
tv749 = -228						; size = 4
tv1024 = -224						; size = 4
tv838 = -220						; size = 4
tv1012 = -216						; size = 4
tv768 = -212						; size = 4
tv1000 = -208						; size = 4
tv734 = -204						; size = 4
tv988 = -200						; size = 4
tv844 = -196						; size = 4
tv976 = -192						; size = 4
tv798 = -188						; size = 4
tv955 = -184						; size = 4
tv781 = -180						; size = 4
tv949 = -176						; size = 4
tv762 = -172						; size = 4
tv922 = -168						; size = 4
tv743 = -164						; size = 4
tv916 = -160						; size = 4
tv728 = -156						; size = 4
tv865 = -152						; size = 4
tv853 = -148						; size = 4
tv695 = -144						; size = 4
tv165 = -140						; size = 4
tv318 = -136						; size = 4
tv143 = -132						; size = 4
tv188 = -128						; size = 4
tv522 = -124						; size = 4
tv264 = -120						; size = 4
tv510 = -116						; size = 4
_randnum$1 = -112					; size = 4
tv84 = -108						; size = 4
tv291 = -104						; size = 4
tv486 = -100						; size = 4
tv232 = -96						; size = 4
tv474 = -92						; size = 4
tv356 = -88						; size = 4
tv456 = -84						; size = 4
tv330 = -80						; size = 4
tv433 = -76						; size = 4
tv295 = -72						; size = 4
tv429 = -68						; size = 4
tv279 = -64						; size = 4
tv411 = -60						; size = 4
tv252 = -56						; size = 4
tv388 = -52						; size = 4
tv210 = -48						; size = 4
tv384 = -44						; size = 4
tv360 = -40						; size = 4
tv161 = -36						; size = 4
tv592 = -32						; size = 4
tv88 = -28						; size = 4
tv534 = -24						; size = 4
tv498 = -20						; size = 4
_rpmRSE$ = -16						; size = 4
_rpmCmdBase$ = -12					; size = 4
_rpmCmdZ$ = -8						; size = 4
_this$ = -4						; size = 4
_rpmCmd2$ = 8						; size = 4
?Engine2RpmMods@AirframeClass@@QAEMM@Z PROC		; AirframeClass::Engine2RpmMods
; _this$ = ecx

; 2803 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 248				; 000000f8H
	mov	DWORD PTR _this$[ebp], ecx

; 2804 : 	//
; 2805 : 	//
; 2806 : 	float rpmCmdBase = 0.7F;

	movss	xmm0, DWORD PTR __real@3f333333
	movss	DWORD PTR _rpmCmdBase$[ebp], xmm0

; 2807 : 	float rpmCmdZ = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _rpmCmdZ$[ebp], xmm0

; 2808 : 	float rpmRSE = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _rpmRSE$[ebp], xmm0

; 2809 : 
; 2810 : 	//RPM effect for any of the modern engines
; 2811 : 	if (auxaeroData->typeEngine == 9 || auxaeroData->typeEngine == 10
; 2812 : 		|| auxaeroData->typeEngine == 11)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+3884], 9
	je	SHORT $LN71@Engine2Rpm
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+3884], 10		; 0000000aH
	je	SHORT $LN71@Engine2Rpm
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+3884], 11		; 0000000bH
	jne	$LN67@Engine2Rpm
$LN71@Engine2Rpm:

; 2813 : 	{
; 2814 : 		//TJL -1 says idle RPM increases from 0.84 till it is MIL power at 1.4 Mach
; 2815 : 		if (mach >= 0.84f && mach <= 1.4f)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1144]
	comiss	xmm0, DWORD PTR __real@3f570a3d
	jb	SHORT $LN70@Engine2Rpm
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fb33333
	comiss	xmm0, DWORD PTR [ecx+1144]
	jb	SHORT $LN70@Engine2Rpm

; 2816 : 			rpmCmd2 = max (mach/1.4f, rpmCmd2);

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1144]
	divss	xmm0, DWORD PTR __real@3fb33333
	comiss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	jbe	SHORT $LN75@Engine2Rpm
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1144]
	divss	xmm0, DWORD PTR __real@3fb33333
	movss	DWORD PTR tv84[ebp], xmm0
	jmp	SHORT $LN76@Engine2Rpm
$LN75@Engine2Rpm:
	movss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	movss	DWORD PTR tv84[ebp], xmm0
$LN76@Engine2Rpm:
	movss	xmm0, DWORD PTR tv84[ebp]
	movss	DWORD PTR _rpmCmd2$[ebp], xmm0
	jmp	SHORT $LN68@Engine2Rpm
$LN70@Engine2Rpm:

; 2817 : 		else if (mach > 1.4f)

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1144]
	comiss	xmm0, DWORD PTR __real@3fb33333
	jbe	SHORT $LN68@Engine2Rpm

; 2818 : 			rpmCmd2 = max (0.99f, rpmCmd2);

	movss	xmm0, DWORD PTR __real@3f7d70a4
	comiss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	jbe	SHORT $LN77@Engine2Rpm
	movss	xmm0, DWORD PTR __real@3f7d70a4
	movss	DWORD PTR tv88[ebp], xmm0
	jmp	SHORT $LN78@Engine2Rpm
$LN77@Engine2Rpm:
	movss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	movss	DWORD PTR tv88[ebp], xmm0
$LN78@Engine2Rpm:
	movss	xmm0, DWORD PTR tv88[ebp]
	movss	DWORD PTR _rpmCmd2$[ebp], xmm0
$LN68@Engine2Rpm:

; 2819 : 		//TJL -1 says that RPM increases > 10K to give sufficient stall margin
; 2820 : 		if (platform->ZPos() <= -100.0F)

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv695[ebp]
	movss	xmm0, DWORD PTR __real@c2c80000
	comiss	xmm0, DWORD PTR tv695[ebp]
	jb	SHORT $LN67@Engine2Rpm

; 2821 : 		{
; 2822 : 			rpmCmdZ = ((-platform->ZPos()/10000.0F)/30) + rpmCmdBase;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv701[ebp]
	movss	xmm0, DWORD PTR tv701[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	divss	xmm0, DWORD PTR __real@461c4000
	divss	xmm0, DWORD PTR __real@41f00000
	addss	xmm0, DWORD PTR _rpmCmdBase$[ebp]
	movss	DWORD PTR _rpmCmdZ$[ebp], xmm0

; 2823 : 			rpmCmd2 = max (rpmCmdZ, rpmCmd2);

	movss	xmm0, DWORD PTR _rpmCmdZ$[ebp]
	comiss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	jbe	SHORT $LN79@Engine2Rpm
	movss	xmm0, DWORD PTR _rpmCmdZ$[ebp]
	movss	DWORD PTR tv143[ebp], xmm0
	jmp	SHORT $LN80@Engine2Rpm
$LN79@Engine2Rpm:
	movss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	movss	DWORD PTR tv143[ebp], xmm0
$LN80@Engine2Rpm:
	movss	xmm0, DWORD PTR tv143[ebp]
	movss	DWORD PTR _rpmCmd2$[ebp], xmm0
$LN67@Engine2Rpm:

; 2824 : 		}
; 2825 : 
; 2826 : 	}
; 2827 : //PW-100/PW-220
; 2828 : 	if (auxaeroData->typeEngine == 1 || auxaeroData->typeEngine == 2)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+3884], 1
	je	SHORT $LN65@Engine2Rpm
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+3884], 2
	jne	$LN56@Engine2Rpm
$LN65@Engine2Rpm:

; 2829 : 	{
; 2830 : 		//TJL -1 says idle RPM increases from 0.84 till it is MIL power at 1.4 Mach
; 2831 : 		if (mach >= 0.84f && mach <= 1.4f)

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1144]
	comiss	xmm0, DWORD PTR __real@3f570a3d
	jb	SHORT $LN64@Engine2Rpm
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fb33333
	comiss	xmm0, DWORD PTR [eax+1144]
	jb	SHORT $LN64@Engine2Rpm

; 2832 : 			rpmCmd2 = max (mach/1.4f, rpmCmd2);

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1144]
	divss	xmm0, DWORD PTR __real@3fb33333
	comiss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	jbe	SHORT $LN81@Engine2Rpm
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1144]
	divss	xmm0, DWORD PTR __real@3fb33333
	movss	DWORD PTR tv161[ebp], xmm0
	jmp	SHORT $LN82@Engine2Rpm
$LN81@Engine2Rpm:
	movss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	movss	DWORD PTR tv161[ebp], xmm0
$LN82@Engine2Rpm:
	movss	xmm0, DWORD PTR tv161[ebp]
	movss	DWORD PTR _rpmCmd2$[ebp], xmm0
	jmp	SHORT $LN62@Engine2Rpm
$LN64@Engine2Rpm:

; 2833 : 		else if (mach > 1.4f)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1144]
	comiss	xmm0, DWORD PTR __real@3fb33333
	jbe	SHORT $LN62@Engine2Rpm

; 2834 : 			rpmCmd2 = max (0.99f, rpmCmd2);

	movss	xmm0, DWORD PTR __real@3f7d70a4
	comiss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	jbe	SHORT $LN83@Engine2Rpm
	movss	xmm0, DWORD PTR __real@3f7d70a4
	movss	DWORD PTR tv165[ebp], xmm0
	jmp	SHORT $LN84@Engine2Rpm
$LN83@Engine2Rpm:
	movss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	movss	DWORD PTR tv165[ebp], xmm0
$LN84@Engine2Rpm:
	movss	xmm0, DWORD PTR tv165[ebp]
	movss	DWORD PTR _rpmCmd2$[ebp], xmm0
$LN62@Engine2Rpm:

; 2835 : 		//TJL -1 says that RPM increases > 10K to give sufficient stall margin
; 2836 : 		if (platform->ZPos() <= -100.0F)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv728[ebp]
	movss	xmm0, DWORD PTR __real@c2c80000
	comiss	xmm0, DWORD PTR tv728[ebp]
	jb	SHORT $LN61@Engine2Rpm

; 2837 : 		{
; 2838 : 			rpmCmdZ = ((-platform->ZPos()/10000.0F)/30) + rpmCmdBase;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv734[ebp]
	movss	xmm0, DWORD PTR tv734[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	divss	xmm0, DWORD PTR __real@461c4000
	divss	xmm0, DWORD PTR __real@41f00000
	addss	xmm0, DWORD PTR _rpmCmdBase$[ebp]
	movss	DWORD PTR _rpmCmdZ$[ebp], xmm0

; 2839 : 			rpmCmd2 = max (rpmCmdZ, rpmCmd2);

	movss	xmm0, DWORD PTR _rpmCmdZ$[ebp]
	comiss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	jbe	SHORT $LN85@Engine2Rpm
	movss	xmm0, DWORD PTR _rpmCmdZ$[ebp]
	movss	DWORD PTR tv188[ebp], xmm0
	jmp	SHORT $LN86@Engine2Rpm
$LN85@Engine2Rpm:
	movss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	movss	DWORD PTR tv188[ebp], xmm0
$LN86@Engine2Rpm:
	movss	xmm0, DWORD PTR tv188[ebp]
	movss	DWORD PTR _rpmCmd2$[ebp], xmm0
$LN61@Engine2Rpm:

; 2840 : 		}
; 2841 : 
; 2842 : 		//AB Schedule per -1
; 2843 : 		//Area 3 Seg 5 no light
; 2844 : 		if ((platform->ZPos() <= -35000.0f && platform->ZPos() >= -45000.0f) &&
; 2845 : 			(mach <= 0.8f && mach >0.4f))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv743[ebp]
	movss	xmm0, DWORD PTR __real@c708b800
	comiss	xmm0, DWORD PTR tv743[ebp]
	jb	SHORT $LN60@Engine2Rpm
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv749[ebp]
	movss	xmm0, DWORD PTR tv749[ebp]
	comiss	xmm0, DWORD PTR __real@c72fc800
	jb	SHORT $LN60@Engine2Rpm
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f4ccccd
	comiss	xmm0, DWORD PTR [edx+1144]
	jb	SHORT $LN60@Engine2Rpm
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1144]
	comiss	xmm0, DWORD PTR __real@3ecccccd
	jbe	SHORT $LN60@Engine2Rpm

; 2846 : 			rpmCmd2 = min (1.025f, rpmCmd2); 

	movss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	comiss	xmm0, DWORD PTR __real@3f833333
	jbe	SHORT $LN87@Engine2Rpm
	movss	xmm0, DWORD PTR __real@3f833333
	movss	DWORD PTR tv210[ebp], xmm0
	jmp	SHORT $LN88@Engine2Rpm
$LN87@Engine2Rpm:
	movss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	movss	DWORD PTR tv210[ebp], xmm0
$LN88@Engine2Rpm:
	movss	xmm0, DWORD PTR tv210[ebp]
	movss	DWORD PTR _rpmCmd2$[ebp], xmm0
$LN60@Engine2Rpm:

; 2847 : 
; 2848 : 		//Area 2 Only Seg 1 will light
; 2849 : 		if ((platform->ZPos() <= -45000.0f && platform->ZPos() >= -55000.0f) && 
; 2850 : 			(mach <=0.95f && mach > 0.4f))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv762[ebp]
	movss	xmm0, DWORD PTR __real@c72fc800
	comiss	xmm0, DWORD PTR tv762[ebp]
	jb	SHORT $LN59@Engine2Rpm
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv768[ebp]
	movss	xmm0, DWORD PTR tv768[ebp]
	comiss	xmm0, DWORD PTR __real@c756d800
	jb	SHORT $LN59@Engine2Rpm
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f733333
	comiss	xmm0, DWORD PTR [eax+1144]
	jb	SHORT $LN59@Engine2Rpm
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1144]
	comiss	xmm0, DWORD PTR __real@3ecccccd
	jbe	SHORT $LN59@Engine2Rpm

; 2851 : 			rpmCmd2 = min (1.01f, rpmCmd2);

	movss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	comiss	xmm0, DWORD PTR __real@3f8147ae
	jbe	SHORT $LN89@Engine2Rpm
	movss	xmm0, DWORD PTR __real@3f8147ae
	movss	DWORD PTR tv232[ebp], xmm0
	jmp	SHORT $LN90@Engine2Rpm
$LN89@Engine2Rpm:
	movss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	movss	DWORD PTR tv232[ebp], xmm0
$LN90@Engine2Rpm:
	movss	xmm0, DWORD PTR tv232[ebp]
	movss	DWORD PTR _rpmCmd2$[ebp], xmm0
$LN59@Engine2Rpm:

; 2852 : 
; 2853 : 		//Area 1 No AB available
; 2854 : 		if ((platform->ZPos() <= -30000.0f && platform->ZPos() > -55000.0f) && mach <= 0.4f)

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv781[ebp]
	movss	xmm0, DWORD PTR __real@c6ea6000
	comiss	xmm0, DWORD PTR tv781[ebp]
	jb	SHORT $LN58@Engine2Rpm
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv787[ebp]
	movss	xmm0, DWORD PTR tv787[ebp]
	comiss	xmm0, DWORD PTR __real@c756d800
	jbe	SHORT $LN58@Engine2Rpm
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3ecccccd
	comiss	xmm0, DWORD PTR [ecx+1144]
	jb	SHORT $LN58@Engine2Rpm

; 2855 : 			rpmCmd2 = min (0.99f, rpmCmd2);

	movss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	comiss	xmm0, DWORD PTR __real@3f7d70a4
	jbe	SHORT $LN91@Engine2Rpm
	movss	xmm0, DWORD PTR __real@3f7d70a4
	movss	DWORD PTR tv252[ebp], xmm0
	jmp	SHORT $LN92@Engine2Rpm
$LN91@Engine2Rpm:
	movss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	movss	DWORD PTR tv252[ebp], xmm0
$LN92@Engine2Rpm:
	movss	xmm0, DWORD PTR tv252[ebp]
	movss	DWORD PTR _rpmCmd2$[ebp], xmm0
	jmp	SHORT $LN56@Engine2Rpm
$LN58@Engine2Rpm:

; 2856 : 		else if ((platform->ZPos() <= -55000.0f) && mach <= 0.95f)

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv798[ebp]
	movss	xmm0, DWORD PTR __real@c756d800
	comiss	xmm0, DWORD PTR tv798[ebp]
	jb	SHORT $LN56@Engine2Rpm
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f733333
	comiss	xmm0, DWORD PTR [eax+1144]
	jb	SHORT $LN56@Engine2Rpm

; 2857 : 			rpmCmd2 = min (0.99f, rpmCmd2);

	movss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	comiss	xmm0, DWORD PTR __real@3f7d70a4
	jbe	SHORT $LN93@Engine2Rpm
	movss	xmm0, DWORD PTR __real@3f7d70a4
	movss	DWORD PTR tv264[ebp], xmm0
	jmp	SHORT $LN94@Engine2Rpm
$LN93@Engine2Rpm:
	movss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	movss	DWORD PTR tv264[ebp], xmm0
$LN94@Engine2Rpm:
	movss	xmm0, DWORD PTR tv264[ebp]
	movss	DWORD PTR _rpmCmd2$[ebp], xmm0
$LN56@Engine2Rpm:

; 2858 : 
; 2859 : 	}//end
; 2860 : 
; 2861 : 
; 2862 : 	// PW-229/GE-110/GE-129
; 2863 : 	if (auxaeroData->typeEngine == 3 || auxaeroData->typeEngine == 4 || auxaeroData->typeEngine == 5)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+3884], 3
	je	SHORT $LN54@Engine2Rpm
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+3884], 4
	je	SHORT $LN54@Engine2Rpm
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+3884], 5
	jne	$LN37@Engine2Rpm
$LN54@Engine2Rpm:

; 2864 : 	{
; 2865 : 		//Reduced Speed Excursion Logic 0.5 - 0.6 is the switch range, we'll call it 5.5 for coding
; 2866 : 		if (mach > 0.55f && mach < 1.1f)

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1144]
	comiss	xmm0, DWORD PTR __real@3f0ccccd
	jbe	SHORT $LN53@Engine2Rpm
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f8ccccd
	comiss	xmm0, DWORD PTR [edx+1144]
	jbe	SHORT $LN53@Engine2Rpm

; 2867 : 		{
; 2868 : 			rpmRSE = 0.79f;

	movss	xmm0, DWORD PTR __real@3f4a3d71
	movss	DWORD PTR _rpmRSE$[ebp], xmm0

; 2869 : 			rpmCmd2 = max (rpmCmd2, rpmRSE);

	movss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	comiss	xmm0, DWORD PTR _rpmRSE$[ebp]
	jbe	SHORT $LN95@Engine2Rpm
	movss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	movss	DWORD PTR tv279[ebp], xmm0
	jmp	SHORT $LN96@Engine2Rpm
$LN95@Engine2Rpm:
	movss	xmm0, DWORD PTR _rpmRSE$[ebp]
	movss	DWORD PTR tv279[ebp], xmm0
$LN96@Engine2Rpm:
	movss	xmm0, DWORD PTR tv279[ebp]
	movss	DWORD PTR _rpmCmd2$[ebp], xmm0
	jmp	$LN49@Engine2Rpm
$LN53@Engine2Rpm:

; 2870 : 		}
; 2871 : 		//Idle schedule to MIL from 1.1 to 1.4 MACH
; 2872 : 		else if (mach >= 1.1f && mach <= 1.4f)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1144]
	comiss	xmm0, DWORD PTR __real@3f8ccccd
	jb	SHORT $LN51@Engine2Rpm
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fb33333
	comiss	xmm0, DWORD PTR [ecx+1144]
	jb	SHORT $LN51@Engine2Rpm

; 2873 : 			rpmCmd2 = max (mach/1.4f, rpmCmd2);

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1144]
	divss	xmm0, DWORD PTR __real@3fb33333
	comiss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	jbe	SHORT $LN97@Engine2Rpm
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1144]
	divss	xmm0, DWORD PTR __real@3fb33333
	movss	DWORD PTR tv291[ebp], xmm0
	jmp	SHORT $LN98@Engine2Rpm
$LN97@Engine2Rpm:
	movss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	movss	DWORD PTR tv291[ebp], xmm0
$LN98@Engine2Rpm:
	movss	xmm0, DWORD PTR tv291[ebp]
	movss	DWORD PTR _rpmCmd2$[ebp], xmm0
	jmp	SHORT $LN49@Engine2Rpm
$LN51@Engine2Rpm:

; 2874 : 		else if (mach > 1.4f)

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1144]
	comiss	xmm0, DWORD PTR __real@3fb33333
	jbe	SHORT $LN49@Engine2Rpm

; 2875 : 			rpmCmd2 = max (0.99f, rpmCmd2);

	movss	xmm0, DWORD PTR __real@3f7d70a4
	comiss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	jbe	SHORT $LN99@Engine2Rpm
	movss	xmm0, DWORD PTR __real@3f7d70a4
	movss	DWORD PTR tv295[ebp], xmm0
	jmp	SHORT $LN100@Engine2Rpm
$LN99@Engine2Rpm:
	movss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	movss	DWORD PTR tv295[ebp], xmm0
$LN100@Engine2Rpm:
	movss	xmm0, DWORD PTR tv295[ebp]
	movss	DWORD PTR _rpmCmd2$[ebp], xmm0
$LN49@Engine2Rpm:

; 2876 : 
; 2877 : 		//Idle schedule 
; 2878 : 		//TJL -1 says that RPM increases > 10K to give sufficient stall margin
; 2879 : 		if (platform->ZPos() <= -100.0F)

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv838[ebp]
	movss	xmm0, DWORD PTR __real@c2c80000
	comiss	xmm0, DWORD PTR tv838[ebp]
	jb	SHORT $LN48@Engine2Rpm

; 2880 : 		{
; 2881 : 			//rpmZ = (((SqrtF(-platform->ZPos()))/2000.0F) + rpmBase);
; 2882 : 			rpmCmdZ = ((-platform->ZPos()/10000.0F)/30) + rpmCmdBase;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv844[ebp]
	movss	xmm0, DWORD PTR tv844[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	divss	xmm0, DWORD PTR __real@461c4000
	divss	xmm0, DWORD PTR __real@41f00000
	addss	xmm0, DWORD PTR _rpmCmdBase$[ebp]
	movss	DWORD PTR _rpmCmdZ$[ebp], xmm0

; 2883 : 			rpmCmd2 = max (rpmCmdZ, rpmCmd2);

	movss	xmm0, DWORD PTR _rpmCmdZ$[ebp]
	comiss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	jbe	SHORT $LN101@Engine2Rpm
	movss	xmm0, DWORD PTR _rpmCmdZ$[ebp]
	movss	DWORD PTR tv318[ebp], xmm0
	jmp	SHORT $LN102@Engine2Rpm
$LN101@Engine2Rpm:
	movss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	movss	DWORD PTR tv318[ebp], xmm0
$LN102@Engine2Rpm:
	movss	xmm0, DWORD PTR tv318[ebp]
	movss	DWORD PTR _rpmCmd2$[ebp], xmm0
$LN48@Engine2Rpm:

; 2884 : 		}
; 2885 : 
; 2886 : 		//Reduce AB schedule
; 2887 : 		if ((platform->ZPos() < -50000.0F) && vcas < 250.0F)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv853[ebp]
	movss	xmm0, DWORD PTR __real@c7435000
	comiss	xmm0, DWORD PTR tv853[ebp]
	jbe	SHORT $LN47@Engine2Rpm
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@437a0000
	comiss	xmm0, DWORD PTR [edx+1124]
	jbe	SHORT $LN47@Engine2Rpm

; 2888 : 		{
; 2889 : 			rpmCmd2 = min (1.01f, rpmCmd2);

	movss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	comiss	xmm0, DWORD PTR __real@3f8147ae
	jbe	SHORT $LN103@Engine2Rpm
	movss	xmm0, DWORD PTR __real@3f8147ae
	movss	DWORD PTR tv330[ebp], xmm0
	jmp	SHORT $LN104@Engine2Rpm
$LN103@Engine2Rpm:
	movss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	movss	DWORD PTR tv330[ebp], xmm0
$LN104@Engine2Rpm:
	movss	xmm0, DWORD PTR tv330[ebp]
	movss	DWORD PTR _rpmCmd2$[ebp], xmm0
$LN47@Engine2Rpm:

; 2890 : 		}
; 2891 : 
; 2892 : 			
; 2893 : 		//Zone 2 AB no lights or delayed lights possible
; 2894 : 		if ((platform->ZPos() < -30000.0F) && vcas < 225.0F)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv865[ebp]
	movss	xmm0, DWORD PTR __real@c6ea6000
	comiss	xmm0, DWORD PTR tv865[ebp]
	jbe	SHORT $LN46@Engine2Rpm
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@43610000
	comiss	xmm0, DWORD PTR [ecx+1124]
	jbe	SHORT $LN46@Engine2Rpm

; 2895 : 		{
; 2896 : 		//	if ((SimLibElapsedTime - engEventTimer) >= 5000)
; 2897 : 			if (rpm2 <= 1.0F && engFlag2 == 0)

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR [edx+1216]
	jb	SHORT $LN41@Engine2Rpm
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+240], 0
	jne	SHORT $LN41@Engine2Rpm

; 2898 : 			{
; 2899 : 				int randnum = rand()%100;

	call	_rand
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _randnum$1[ebp], edx

; 2900 : 				if (randnum == 1)

	cmp	DWORD PTR _randnum$1[ebp], 1
	jne	SHORT $LN44@Engine2Rpm

; 2901 : 					engFlag2 = 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+240], 1
	jmp	SHORT $LN41@Engine2Rpm
$LN44@Engine2Rpm:

; 2902 : 
; 2903 : 				else if (randnum == 2)

	cmp	DWORD PTR _randnum$1[ebp], 2
	jne	SHORT $LN42@Engine2Rpm

; 2904 : 					engFlag2 = 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+240], 2

; 2905 : 				else

	jmp	SHORT $LN41@Engine2Rpm
$LN42@Engine2Rpm:

; 2906 : 					engFlag2 = 3;//this stops the loop

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+240], 3
$LN41@Engine2Rpm:

; 2907 : 
; 2908 : 			}
; 2909 : 
; 2910 : 		}
; 2911 : 		else

	jmp	SHORT $LN40@Engine2Rpm
$LN46@Engine2Rpm:

; 2912 : 			//Reset flag when out of condition
; 2913 : 			engFlag2 = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+240], 0
$LN40@Engine2Rpm:

; 2914 : 
; 2915 : 		//AB no light
; 2916 : 		if (engFlag2 == 1)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+240], 1
	jne	SHORT $LN39@Engine2Rpm

; 2917 : 			rpmCmd2 = min (0.99f, rpmCmd2);

	movss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	comiss	xmm0, DWORD PTR __real@3f7d70a4
	jbe	SHORT $LN105@Engine2Rpm
	movss	xmm0, DWORD PTR __real@3f7d70a4
	movss	DWORD PTR tv356[ebp], xmm0
	jmp	SHORT $LN106@Engine2Rpm
$LN105@Engine2Rpm:
	movss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	movss	DWORD PTR tv356[ebp], xmm0
$LN106@Engine2Rpm:
	movss	xmm0, DWORD PTR tv356[ebp]
	movss	DWORD PTR _rpmCmd2$[ebp], xmm0
	jmp	SHORT $LN37@Engine2Rpm
$LN39@Engine2Rpm:

; 2918 : 		//AB partial light
; 2919 : 		else if (engFlag2 == 2)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+240], 2
	jne	SHORT $LN37@Engine2Rpm

; 2920 : 			rpmCmd2 = min (1.01f, rpmCmd2);

	movss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	comiss	xmm0, DWORD PTR __real@3f8147ae
	jbe	SHORT $LN107@Engine2Rpm
	movss	xmm0, DWORD PTR __real@3f8147ae
	movss	DWORD PTR tv360[ebp], xmm0
	jmp	SHORT $LN108@Engine2Rpm
$LN107@Engine2Rpm:
	movss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	movss	DWORD PTR tv360[ebp], xmm0
$LN108@Engine2Rpm:
	movss	xmm0, DWORD PTR tv360[ebp]
	movss	DWORD PTR _rpmCmd2$[ebp], xmm0
$LN37@Engine2Rpm:

; 2921 : 	}
; 2922 : 
; 2923 : 
; 2924 : 	//F18A-D MIL at 1.23 mach
; 2925 : 	if (auxaeroData->typeEngine == 6 || auxaeroData->typeEngine == 7
; 2926 : 		|| auxaeroData->typeAC == 8 || auxaeroData->typeAC == 9)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+3884], 6
	je	SHORT $LN35@Engine2Rpm
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+3884], 7
	je	SHORT $LN35@Engine2Rpm
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+3880], 8
	je	SHORT $LN35@Engine2Rpm
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+3880], 9
	jne	$LN31@Engine2Rpm
$LN35@Engine2Rpm:

; 2927 : 	{
; 2928 : 		if (mach >= 0.9f && mach <= 1.23f)

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1144]
	comiss	xmm0, DWORD PTR __real@3f666666
	jb	SHORT $LN34@Engine2Rpm
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f9d70a4
	comiss	xmm0, DWORD PTR [edx+1144]
	jb	SHORT $LN34@Engine2Rpm

; 2929 : 			rpmCmd2 = max (mach/1.23f, rpmCmd2);

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1144]
	divss	xmm0, DWORD PTR __real@3f9d70a4
	comiss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	jbe	SHORT $LN109@Engine2Rpm
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1144]
	divss	xmm0, DWORD PTR __real@3f9d70a4
	movss	DWORD PTR tv384[ebp], xmm0
	jmp	SHORT $LN110@Engine2Rpm
$LN109@Engine2Rpm:
	movss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	movss	DWORD PTR tv384[ebp], xmm0
$LN110@Engine2Rpm:
	movss	xmm0, DWORD PTR tv384[ebp]
	movss	DWORD PTR _rpmCmd2$[ebp], xmm0
	jmp	SHORT $LN32@Engine2Rpm
$LN34@Engine2Rpm:

; 2930 : 		else if (mach > 1.23f)

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1144]
	comiss	xmm0, DWORD PTR __real@3f9d70a4
	jbe	SHORT $LN32@Engine2Rpm

; 2931 : 			rpmCmd2 = max (0.99f, rpmCmd2);

	movss	xmm0, DWORD PTR __real@3f7d70a4
	comiss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	jbe	SHORT $LN111@Engine2Rpm
	movss	xmm0, DWORD PTR __real@3f7d70a4
	movss	DWORD PTR tv388[ebp], xmm0
	jmp	SHORT $LN112@Engine2Rpm
$LN111@Engine2Rpm:
	movss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	movss	DWORD PTR tv388[ebp], xmm0
$LN112@Engine2Rpm:
	movss	xmm0, DWORD PTR tv388[ebp]
	movss	DWORD PTR _rpmCmd2$[ebp], xmm0
$LN32@Engine2Rpm:

; 2932 : 
; 2933 : 		//RPM increases > 10K to give sufficient stall margin
; 2934 : 		if (platform->ZPos() <= -100.0F)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv916[ebp]
	movss	xmm0, DWORD PTR __real@c2c80000
	comiss	xmm0, DWORD PTR tv916[ebp]
	jb	SHORT $LN31@Engine2Rpm

; 2935 : 		{
; 2936 : 			rpmCmdZ = ((-platform->ZPos()/10000.0F)/30) + rpmCmdBase;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv922[ebp]
	movss	xmm0, DWORD PTR tv922[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	divss	xmm0, DWORD PTR __real@461c4000
	divss	xmm0, DWORD PTR __real@41f00000
	addss	xmm0, DWORD PTR _rpmCmdBase$[ebp]
	movss	DWORD PTR _rpmCmdZ$[ebp], xmm0

; 2937 : 			rpmCmd2 = max (rpmCmdZ, rpmCmd2);

	movss	xmm0, DWORD PTR _rpmCmdZ$[ebp]
	comiss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	jbe	SHORT $LN113@Engine2Rpm
	movss	xmm0, DWORD PTR _rpmCmdZ$[ebp]
	movss	DWORD PTR tv411[ebp], xmm0
	jmp	SHORT $LN114@Engine2Rpm
$LN113@Engine2Rpm:
	movss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	movss	DWORD PTR tv411[ebp], xmm0
$LN114@Engine2Rpm:
	movss	xmm0, DWORD PTR tv411[ebp]
	movss	DWORD PTR _rpmCmd2$[ebp], xmm0
$LN31@Engine2Rpm:

; 2938 : 		}
; 2939 : 
; 2940 : 	}
; 2941 : 
; 2942 : 
; 2943 : 	//F18E/F RPM to MIL at 1.23 mach
; 2944 : 	if (auxaeroData->typeEngine == 8 || auxaeroData->typeAC == 10)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+3884], 8
	je	SHORT $LN29@Engine2Rpm
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+3880], 10		; 0000000aH
	jne	$LN25@Engine2Rpm
$LN29@Engine2Rpm:

; 2945 : 	{
; 2946 : 		if (mach >= 1.18f && mach <= 1.23f)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1144]
	comiss	xmm0, DWORD PTR __real@3f970a3d
	jb	SHORT $LN28@Engine2Rpm
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f9d70a4
	comiss	xmm0, DWORD PTR [ecx+1144]
	jb	SHORT $LN28@Engine2Rpm

; 2947 : 			rpmCmd2 = max (mach/1.23f, rpmCmd2);

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1144]
	divss	xmm0, DWORD PTR __real@3f9d70a4
	comiss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	jbe	SHORT $LN115@Engine2Rpm
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1144]
	divss	xmm0, DWORD PTR __real@3f9d70a4
	movss	DWORD PTR tv429[ebp], xmm0
	jmp	SHORT $LN116@Engine2Rpm
$LN115@Engine2Rpm:
	movss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	movss	DWORD PTR tv429[ebp], xmm0
$LN116@Engine2Rpm:
	movss	xmm0, DWORD PTR tv429[ebp]
	movss	DWORD PTR _rpmCmd2$[ebp], xmm0
	jmp	SHORT $LN26@Engine2Rpm
$LN28@Engine2Rpm:

; 2948 : 		else if (mach > 1.23f)

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1144]
	comiss	xmm0, DWORD PTR __real@3f9d70a4
	jbe	SHORT $LN26@Engine2Rpm

; 2949 : 			rpmCmd2 = max (0.99f, rpmCmd2);

	movss	xmm0, DWORD PTR __real@3f7d70a4
	comiss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	jbe	SHORT $LN117@Engine2Rpm
	movss	xmm0, DWORD PTR __real@3f7d70a4
	movss	DWORD PTR tv433[ebp], xmm0
	jmp	SHORT $LN118@Engine2Rpm
$LN117@Engine2Rpm:
	movss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	movss	DWORD PTR tv433[ebp], xmm0
$LN118@Engine2Rpm:
	movss	xmm0, DWORD PTR tv433[ebp]
	movss	DWORD PTR _rpmCmd2$[ebp], xmm0
$LN26@Engine2Rpm:

; 2950 : 
; 2951 : 		//RPM increases > 10K to give sufficient stall margin
; 2952 : 		if (platform->ZPos() <= -100.0F)

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv949[ebp]
	movss	xmm0, DWORD PTR __real@c2c80000
	comiss	xmm0, DWORD PTR tv949[ebp]
	jb	SHORT $LN25@Engine2Rpm

; 2953 : 		{
; 2954 : 			rpmCmdZ = ((-platform->ZPos()/10000.0F)/30) + rpmCmdBase;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv955[ebp]
	movss	xmm0, DWORD PTR tv955[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	divss	xmm0, DWORD PTR __real@461c4000
	divss	xmm0, DWORD PTR __real@41f00000
	addss	xmm0, DWORD PTR _rpmCmdBase$[ebp]
	movss	DWORD PTR _rpmCmdZ$[ebp], xmm0

; 2955 : 			rpmCmd2 = max (rpmCmdZ, rpmCmd2);

	movss	xmm0, DWORD PTR _rpmCmdZ$[ebp]
	comiss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	jbe	SHORT $LN119@Engine2Rpm
	movss	xmm0, DWORD PTR _rpmCmdZ$[ebp]
	movss	DWORD PTR tv456[ebp], xmm0
	jmp	SHORT $LN120@Engine2Rpm
$LN119@Engine2Rpm:
	movss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	movss	DWORD PTR tv456[ebp], xmm0
$LN120@Engine2Rpm:
	movss	xmm0, DWORD PTR tv456[ebp]
	movss	DWORD PTR _rpmCmd2$[ebp], xmm0
$LN25@Engine2Rpm:

; 2956 : 		}
; 2957 : 
; 2958 : 	}
; 2959 : 
; 2960 : 	// F-14 spools engine up when Mach < 0.9 and AOA over 18
; 2961 : 	if ((auxaeroData->typeAC == 6 || auxaeroData->typeAC == 7) || 
; 2962 : 		(auxaeroData->typeEngine == 9 || auxaeroData->typeEngine == 10))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+3880], 6
	je	SHORT $LN22@Engine2Rpm
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+3880], 7
	je	SHORT $LN22@Engine2Rpm
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+3884], 9
	je	SHORT $LN22@Engine2Rpm
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+3884], 10		; 0000000aH
	jne	$LN12@Engine2Rpm
$LN22@Engine2Rpm:

; 2963 : 	{
; 2964 : 		if (alpha >= 18.0F && mach <= 0.9F)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1152]
	comiss	xmm0, DWORD PTR __real@41900000
	jb	SHORT $LN21@Engine2Rpm
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f666666
	comiss	xmm0, DWORD PTR [ecx+1144]
	jb	SHORT $LN21@Engine2Rpm

; 2965 : 			rpmCmd2 = max (0.85f, rpmCmd2);

	movss	xmm0, DWORD PTR __real@3f59999a
	comiss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	jbe	SHORT $LN121@Engine2Rpm
	movss	xmm0, DWORD PTR __real@3f59999a
	movss	DWORD PTR tv474[ebp], xmm0
	jmp	SHORT $LN122@Engine2Rpm
$LN121@Engine2Rpm:
	movss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	movss	DWORD PTR tv474[ebp], xmm0
$LN122@Engine2Rpm:
	movss	xmm0, DWORD PTR tv474[ebp]
	movss	DWORD PTR _rpmCmd2$[ebp], xmm0
$LN21@Engine2Rpm:

; 2966 : 
; 2967 : 			//Rich Stability cutback reduced operation
; 2968 : 		if ((platform->ZPos() <= -40000.0f) && mach <= 0.45f)

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv976[ebp]
	movss	xmm0, DWORD PTR __real@c71c4000
	comiss	xmm0, DWORD PTR tv976[ebp]
	jb	SHORT $LN20@Engine2Rpm
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3ee66666
	comiss	xmm0, DWORD PTR [eax+1144]
	jb	SHORT $LN20@Engine2Rpm

; 2969 : 			rpmCmd2 = min (1.015f, rpmCmd2);

	movss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	comiss	xmm0, DWORD PTR __real@3f81eb85
	jbe	SHORT $LN123@Engine2Rpm
	movss	xmm0, DWORD PTR __real@3f81eb85
	movss	DWORD PTR tv486[ebp], xmm0
	jmp	SHORT $LN124@Engine2Rpm
$LN123@Engine2Rpm:
	movss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	movss	DWORD PTR tv486[ebp], xmm0
$LN124@Engine2Rpm:
	movss	xmm0, DWORD PTR tv486[ebp]
	movss	DWORD PTR _rpmCmd2$[ebp], xmm0
	jmp	$LN12@Engine2Rpm
$LN20@Engine2Rpm:

; 2970 : 		else if ((platform->ZPos() <= -45000.0f) && mach <= 0.6f)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv988[ebp]
	movss	xmm0, DWORD PTR __real@c72fc800
	comiss	xmm0, DWORD PTR tv988[ebp]
	jb	SHORT $LN18@Engine2Rpm
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f19999a
	comiss	xmm0, DWORD PTR [edx+1144]
	jb	SHORT $LN18@Engine2Rpm

; 2971 : 			rpmCmd2 = min (1.015f, rpmCmd2);

	movss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	comiss	xmm0, DWORD PTR __real@3f81eb85
	jbe	SHORT $LN125@Engine2Rpm
	movss	xmm0, DWORD PTR __real@3f81eb85
	movss	DWORD PTR tv498[ebp], xmm0
	jmp	SHORT $LN126@Engine2Rpm
$LN125@Engine2Rpm:
	movss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	movss	DWORD PTR tv498[ebp], xmm0
$LN126@Engine2Rpm:
	movss	xmm0, DWORD PTR tv498[ebp]
	movss	DWORD PTR _rpmCmd2$[ebp], xmm0
	jmp	$LN12@Engine2Rpm
$LN18@Engine2Rpm:

; 2972 : 		else if ((platform->ZPos() <= -50000.0f) && mach <= 1.0f)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv1000[ebp]
	movss	xmm0, DWORD PTR __real@c7435000
	comiss	xmm0, DWORD PTR tv1000[ebp]
	jb	SHORT $LN16@Engine2Rpm
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR [ecx+1144]
	jb	SHORT $LN16@Engine2Rpm

; 2973 : 			rpmCmd2 = min (1.01f, rpmCmd2);

	movss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	comiss	xmm0, DWORD PTR __real@3f8147ae
	jbe	SHORT $LN127@Engine2Rpm
	movss	xmm0, DWORD PTR __real@3f8147ae
	movss	DWORD PTR tv510[ebp], xmm0
	jmp	SHORT $LN128@Engine2Rpm
$LN127@Engine2Rpm:
	movss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	movss	DWORD PTR tv510[ebp], xmm0
$LN128@Engine2Rpm:
	movss	xmm0, DWORD PTR tv510[ebp]
	movss	DWORD PTR _rpmCmd2$[ebp], xmm0
	jmp	$LN12@Engine2Rpm
$LN16@Engine2Rpm:

; 2974 : 		else if ((platform->ZPos() <= -55000.0f) && mach <= 1.1f)

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv1012[ebp]
	movss	xmm0, DWORD PTR __real@c756d800
	comiss	xmm0, DWORD PTR tv1012[ebp]
	jb	SHORT $LN14@Engine2Rpm
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f8ccccd
	comiss	xmm0, DWORD PTR [eax+1144]
	jb	SHORT $LN14@Engine2Rpm

; 2975 : 			rpmCmd2 = min (1.01f, rpmCmd2);

	movss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	comiss	xmm0, DWORD PTR __real@3f8147ae
	jbe	SHORT $LN129@Engine2Rpm
	movss	xmm0, DWORD PTR __real@3f8147ae
	movss	DWORD PTR tv522[ebp], xmm0
	jmp	SHORT $LN130@Engine2Rpm
$LN129@Engine2Rpm:
	movss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	movss	DWORD PTR tv522[ebp], xmm0
$LN130@Engine2Rpm:
	movss	xmm0, DWORD PTR tv522[ebp]
	movss	DWORD PTR _rpmCmd2$[ebp], xmm0
	jmp	SHORT $LN12@Engine2Rpm
$LN14@Engine2Rpm:

; 2976 : 		else if ((platform->ZPos() <= -60000.0f) && mach <= 1.2f)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv1024[ebp]
	movss	xmm0, DWORD PTR __real@c76a6000
	comiss	xmm0, DWORD PTR tv1024[ebp]
	jb	SHORT $LN12@Engine2Rpm
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f99999a
	comiss	xmm0, DWORD PTR [edx+1144]
	jb	SHORT $LN12@Engine2Rpm

; 2977 : 			rpmCmd2 = min (1.01f, rpmCmd2);

	movss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	comiss	xmm0, DWORD PTR __real@3f8147ae
	jbe	SHORT $LN131@Engine2Rpm
	movss	xmm0, DWORD PTR __real@3f8147ae
	movss	DWORD PTR tv534[ebp], xmm0
	jmp	SHORT $LN132@Engine2Rpm
$LN131@Engine2Rpm:
	movss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	movss	DWORD PTR tv534[ebp], xmm0
$LN132@Engine2Rpm:
	movss	xmm0, DWORD PTR tv534[ebp]
	movss	DWORD PTR _rpmCmd2$[ebp], xmm0
$LN12@Engine2Rpm:

; 2978 : 
; 2979 : 	}
; 2980 : 
; 2981 : 		// F-4E Engine Stall Zone 
; 2982 : 	if (auxaeroData->typeEngine == 11 || auxaeroData->typeAC == 11)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+3884], 11		; 0000000bH
	je	SHORT $LN10@Engine2Rpm
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+3880], 11		; 0000000bH
	jne	$LN1@Engine2Rpm
$LN10@Engine2Rpm:

; 2983 : 	{
; 2984 : 		if ((SimLibElapsedTime - engEventTimer2) >= 1000)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	sub	edx, DWORD PTR [ecx+232]
	cmp	edx, 1000				; 000003e8H
	jb	$LN2@Engine2Rpm

; 2985 : 		{
; 2986 : 			if(platform->ZPos() < -10000.0F && vcas < 150.0F)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv1040[ebp]
	movss	xmm0, DWORD PTR __real@c61c4000
	comiss	xmm0, DWORD PTR tv1040[ebp]
	jbe	SHORT $LN6@Engine2Rpm
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@43160000
	comiss	xmm0, DWORD PTR [ecx+1124]
	jbe	SHORT $LN6@Engine2Rpm

; 2987 : 			{
; 2988 : 				if (1 == (rand() % 30))

	call	_rand
	cdq
	mov	ecx, 30					; 0000001eH
	idiv	ecx
	cmp	edx, 1
	jne	SHORT $LN7@Engine2Rpm

; 2989 : 				{
; 2990 : 					SetEngineFlag(EngineStopped2);

	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetEngineFlag@AirframeClass@@QAEXW4EngineFlags@1@@Z ; AirframeClass::SetEngineFlag

; 2991 : 					engEventTimer2 = SimLibElapsedTime;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [edx+232], eax

; 2992 : 				}
; 2993 : 				else

	jmp	SHORT $LN6@Engine2Rpm
$LN7@Engine2Rpm:

; 2994 : 					engEventTimer2 = SimLibElapsedTime;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [ecx+232], edx
$LN6@Engine2Rpm:

; 2995 : 			}
; 2996 : 
; 2997 : 			if (platform->ZPos() < -10000.0F && alpha > 28.0F && rpm2 >= 1.0f)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv1058[ebp]
	movss	xmm0, DWORD PTR __real@c61c4000
	comiss	xmm0, DWORD PTR tv1058[ebp]
	jbe	SHORT $LN5@Engine2Rpm
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1152]
	comiss	xmm0, DWORD PTR __real@41e00000
	jbe	SHORT $LN5@Engine2Rpm
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1216]
	comiss	xmm0, DWORD PTR __real@3f800000
	jb	SHORT $LN5@Engine2Rpm

; 2998 : 			{
; 2999 : 				if (1 == (rand() % 30))

	call	_rand
	cdq
	mov	ecx, 30					; 0000001eH
	idiv	ecx
	cmp	edx, 1
	jne	SHORT $LN4@Engine2Rpm

; 3000 : 				{
; 3001 : 					SetEngineFlag(EngineStopped2);

	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetEngineFlag@AirframeClass@@QAEXW4EngineFlags@1@@Z ; AirframeClass::SetEngineFlag

; 3002 : 					engEventTimer2 = SimLibElapsedTime;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [edx+232], eax

; 3003 : 				}
; 3004 : 				else

	jmp	SHORT $LN3@Engine2Rpm
$LN4@Engine2Rpm:

; 3005 : 					engEventTimer2 = SimLibElapsedTime;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [ecx+232], edx
$LN3@Engine2Rpm:

; 3006 : 			}
; 3007 : 			else

	jmp	SHORT $LN2@Engine2Rpm
$LN5@Engine2Rpm:

; 3008 : 				engEventTimer2 = SimLibElapsedTime;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [eax+232], ecx
$LN2@Engine2Rpm:

; 3009 : 		}
; 3010 : 		
; 3011 : 		if (platform->ZPos() < -50000.0F && vcas < 300.0F)

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv1080[ebp]
	movss	xmm0, DWORD PTR __real@c7435000
	comiss	xmm0, DWORD PTR tv1080[ebp]
	jbe	SHORT $LN1@Engine2Rpm
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@43960000
	comiss	xmm0, DWORD PTR [eax+1124]
	jbe	SHORT $LN1@Engine2Rpm

; 3012 : 		{
; 3013 : 			rpmCmd2 = min (0.99F, rpmCmd2);

	movss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	comiss	xmm0, DWORD PTR __real@3f7d70a4
	jbe	SHORT $LN133@Engine2Rpm
	movss	xmm0, DWORD PTR __real@3f7d70a4
	movss	DWORD PTR tv592[ebp], xmm0
	jmp	SHORT $LN134@Engine2Rpm
$LN133@Engine2Rpm:
	movss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	movss	DWORD PTR tv592[ebp], xmm0
$LN134@Engine2Rpm:
	movss	xmm0, DWORD PTR tv592[ebp]
	movss	DWORD PTR _rpmCmd2$[ebp], xmm0
$LN1@Engine2Rpm:

; 3014 : 
; 3015 : 		}
; 3016 : 	}
; 3017 : 
; 3018 : 
; 3019 : 
; 3020 : 	return rpmCmd2;

	fld	DWORD PTR _rpmCmd2$[ebp]

; 3021 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Engine2RpmMods@AirframeClass@@QAEMM@Z ENDP		; AirframeClass::Engine2RpmMods
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\airframe\engine.cpp
_TEXT	SEGMENT
tv1080 = -248						; size = 4
tv787 = -244						; size = 4
tv1058 = -240						; size = 4
tv701 = -236						; size = 4
tv1040 = -232						; size = 4
tv749 = -228						; size = 4
tv1024 = -224						; size = 4
tv838 = -220						; size = 4
tv1012 = -216						; size = 4
tv768 = -212						; size = 4
tv1000 = -208						; size = 4
tv734 = -204						; size = 4
tv988 = -200						; size = 4
tv844 = -196						; size = 4
tv976 = -192						; size = 4
tv798 = -188						; size = 4
tv955 = -184						; size = 4
tv781 = -180						; size = 4
tv949 = -176						; size = 4
tv762 = -172						; size = 4
tv922 = -168						; size = 4
tv743 = -164						; size = 4
tv916 = -160						; size = 4
tv728 = -156						; size = 4
tv865 = -152						; size = 4
tv853 = -148						; size = 4
tv695 = -144						; size = 4
tv165 = -140						; size = 4
tv318 = -136						; size = 4
tv143 = -132						; size = 4
tv188 = -128						; size = 4
tv522 = -124						; size = 4
tv264 = -120						; size = 4
tv510 = -116						; size = 4
_randnum$1 = -112					; size = 4
tv84 = -108						; size = 4
tv291 = -104						; size = 4
tv486 = -100						; size = 4
tv232 = -96						; size = 4
tv474 = -92						; size = 4
tv356 = -88						; size = 4
tv456 = -84						; size = 4
tv330 = -80						; size = 4
tv433 = -76						; size = 4
tv295 = -72						; size = 4
tv429 = -68						; size = 4
tv279 = -64						; size = 4
tv411 = -60						; size = 4
tv252 = -56						; size = 4
tv388 = -52						; size = 4
tv210 = -48						; size = 4
tv384 = -44						; size = 4
tv360 = -40						; size = 4
tv161 = -36						; size = 4
tv592 = -32						; size = 4
tv88 = -28						; size = 4
tv534 = -24						; size = 4
tv498 = -20						; size = 4
_rpmRSE$ = -16						; size = 4
_rpmCmdBase$ = -12					; size = 4
_rpmCmdZ$ = -8						; size = 4
_this$ = -4						; size = 4
_rpmCmd$ = 8						; size = 4
?Engine1RpmMods@AirframeClass@@QAEMM@Z PROC		; AirframeClass::Engine1RpmMods
; _this$ = ecx

; 2581 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 248				; 000000f8H
	mov	DWORD PTR _this$[ebp], ecx

; 2582 : 	//
; 2583 : 	float rpmCmdBase = 0.7F;

	movss	xmm0, DWORD PTR __real@3f333333
	movss	DWORD PTR _rpmCmdBase$[ebp], xmm0

; 2584 : 	float rpmCmdZ = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _rpmCmdZ$[ebp], xmm0

; 2585 : 	float rpmRSE = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _rpmRSE$[ebp], xmm0

; 2586 : 
; 2587 : 	//RPM effect for any of the modern engines
; 2588 : 	//Note, even the F-4E GE J79 schedules idle speed so keep this effect for engines
; 2589 : 	if (auxaeroData->typeEngine == 9 || auxaeroData->typeEngine == 10
; 2590 : 		|| auxaeroData->typeEngine == 11)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+3884], 9
	je	SHORT $LN71@Engine1Rpm
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+3884], 10		; 0000000aH
	je	SHORT $LN71@Engine1Rpm
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+3884], 11		; 0000000bH
	jne	$LN67@Engine1Rpm
$LN71@Engine1Rpm:

; 2591 : 	{
; 2592 : 		//TJL -1 says idle RPM increases from 0.84 till it is MIL power at 1.4 Mach
; 2593 : 		if (mach >= 0.84f && mach <= 1.4f)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1144]
	comiss	xmm0, DWORD PTR __real@3f570a3d
	jb	SHORT $LN70@Engine1Rpm
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fb33333
	comiss	xmm0, DWORD PTR [ecx+1144]
	jb	SHORT $LN70@Engine1Rpm

; 2594 : 			rpmCmd = max (mach/1.4f, rpmCmd);

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1144]
	divss	xmm0, DWORD PTR __real@3fb33333
	comiss	xmm0, DWORD PTR _rpmCmd$[ebp]
	jbe	SHORT $LN75@Engine1Rpm
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1144]
	divss	xmm0, DWORD PTR __real@3fb33333
	movss	DWORD PTR tv84[ebp], xmm0
	jmp	SHORT $LN76@Engine1Rpm
$LN75@Engine1Rpm:
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR tv84[ebp], xmm0
$LN76@Engine1Rpm:
	movss	xmm0, DWORD PTR tv84[ebp]
	movss	DWORD PTR _rpmCmd$[ebp], xmm0
	jmp	SHORT $LN68@Engine1Rpm
$LN70@Engine1Rpm:

; 2595 : 		else if (mach > 1.4f)

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1144]
	comiss	xmm0, DWORD PTR __real@3fb33333
	jbe	SHORT $LN68@Engine1Rpm

; 2596 : 			rpmCmd = max (0.99f, rpmCmd);

	movss	xmm0, DWORD PTR __real@3f7d70a4
	comiss	xmm0, DWORD PTR _rpmCmd$[ebp]
	jbe	SHORT $LN77@Engine1Rpm
	movss	xmm0, DWORD PTR __real@3f7d70a4
	movss	DWORD PTR tv88[ebp], xmm0
	jmp	SHORT $LN78@Engine1Rpm
$LN77@Engine1Rpm:
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR tv88[ebp], xmm0
$LN78@Engine1Rpm:
	movss	xmm0, DWORD PTR tv88[ebp]
	movss	DWORD PTR _rpmCmd$[ebp], xmm0
$LN68@Engine1Rpm:

; 2597 : 		//TJL -1 says that RPM increases > 10K to give sufficient stall margin
; 2598 : 		if (platform->ZPos() <= -100.0F)

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv695[ebp]
	movss	xmm0, DWORD PTR __real@c2c80000
	comiss	xmm0, DWORD PTR tv695[ebp]
	jb	SHORT $LN67@Engine1Rpm

; 2599 : 		{
; 2600 : 			rpmCmdZ = ((-platform->ZPos()/10000.0F)/30) + rpmCmdBase;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv701[ebp]
	movss	xmm0, DWORD PTR tv701[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	divss	xmm0, DWORD PTR __real@461c4000
	divss	xmm0, DWORD PTR __real@41f00000
	addss	xmm0, DWORD PTR _rpmCmdBase$[ebp]
	movss	DWORD PTR _rpmCmdZ$[ebp], xmm0

; 2601 : 			rpmCmd = max (rpmCmdZ, rpmCmd);

	movss	xmm0, DWORD PTR _rpmCmdZ$[ebp]
	comiss	xmm0, DWORD PTR _rpmCmd$[ebp]
	jbe	SHORT $LN79@Engine1Rpm
	movss	xmm0, DWORD PTR _rpmCmdZ$[ebp]
	movss	DWORD PTR tv143[ebp], xmm0
	jmp	SHORT $LN80@Engine1Rpm
$LN79@Engine1Rpm:
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR tv143[ebp], xmm0
$LN80@Engine1Rpm:
	movss	xmm0, DWORD PTR tv143[ebp]
	movss	DWORD PTR _rpmCmd$[ebp], xmm0
$LN67@Engine1Rpm:

; 2602 : 		}
; 2603 : 
; 2604 : 	}
; 2605 : 
; 2606 : //PW-100/PW-220
; 2607 : 	if (auxaeroData->typeEngine == 1 || auxaeroData->typeEngine == 2)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+3884], 1
	je	SHORT $LN65@Engine1Rpm
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+3884], 2
	jne	$LN56@Engine1Rpm
$LN65@Engine1Rpm:

; 2608 : 	{
; 2609 : 		//TJL -1 says idle RPM increases from 0.84 till it is MIL power at 1.4 Mach
; 2610 : 		if (mach >= 0.84f && mach <= 1.4f)

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1144]
	comiss	xmm0, DWORD PTR __real@3f570a3d
	jb	SHORT $LN64@Engine1Rpm
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fb33333
	comiss	xmm0, DWORD PTR [eax+1144]
	jb	SHORT $LN64@Engine1Rpm

; 2611 : 			rpmCmd = max (mach/1.4f, rpmCmd);

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1144]
	divss	xmm0, DWORD PTR __real@3fb33333
	comiss	xmm0, DWORD PTR _rpmCmd$[ebp]
	jbe	SHORT $LN81@Engine1Rpm
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1144]
	divss	xmm0, DWORD PTR __real@3fb33333
	movss	DWORD PTR tv161[ebp], xmm0
	jmp	SHORT $LN82@Engine1Rpm
$LN81@Engine1Rpm:
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR tv161[ebp], xmm0
$LN82@Engine1Rpm:
	movss	xmm0, DWORD PTR tv161[ebp]
	movss	DWORD PTR _rpmCmd$[ebp], xmm0
	jmp	SHORT $LN62@Engine1Rpm
$LN64@Engine1Rpm:

; 2612 : 		else if (mach > 1.4f)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1144]
	comiss	xmm0, DWORD PTR __real@3fb33333
	jbe	SHORT $LN62@Engine1Rpm

; 2613 : 			rpmCmd = max (0.99f, rpmCmd);

	movss	xmm0, DWORD PTR __real@3f7d70a4
	comiss	xmm0, DWORD PTR _rpmCmd$[ebp]
	jbe	SHORT $LN83@Engine1Rpm
	movss	xmm0, DWORD PTR __real@3f7d70a4
	movss	DWORD PTR tv165[ebp], xmm0
	jmp	SHORT $LN84@Engine1Rpm
$LN83@Engine1Rpm:
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR tv165[ebp], xmm0
$LN84@Engine1Rpm:
	movss	xmm0, DWORD PTR tv165[ebp]
	movss	DWORD PTR _rpmCmd$[ebp], xmm0
$LN62@Engine1Rpm:

; 2614 : 		//TJL -1 says that RPM increases > 10K to give sufficient stall margin
; 2615 : 		if (platform->ZPos() <= -100.0F)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv728[ebp]
	movss	xmm0, DWORD PTR __real@c2c80000
	comiss	xmm0, DWORD PTR tv728[ebp]
	jb	SHORT $LN61@Engine1Rpm

; 2616 : 		{
; 2617 : 			rpmCmdZ = ((-platform->ZPos()/10000.0F)/30) + rpmCmdBase;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv734[ebp]
	movss	xmm0, DWORD PTR tv734[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	divss	xmm0, DWORD PTR __real@461c4000
	divss	xmm0, DWORD PTR __real@41f00000
	addss	xmm0, DWORD PTR _rpmCmdBase$[ebp]
	movss	DWORD PTR _rpmCmdZ$[ebp], xmm0

; 2618 : 			rpmCmd = max (rpmCmdZ, rpmCmd);

	movss	xmm0, DWORD PTR _rpmCmdZ$[ebp]
	comiss	xmm0, DWORD PTR _rpmCmd$[ebp]
	jbe	SHORT $LN85@Engine1Rpm
	movss	xmm0, DWORD PTR _rpmCmdZ$[ebp]
	movss	DWORD PTR tv188[ebp], xmm0
	jmp	SHORT $LN86@Engine1Rpm
$LN85@Engine1Rpm:
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR tv188[ebp], xmm0
$LN86@Engine1Rpm:
	movss	xmm0, DWORD PTR tv188[ebp]
	movss	DWORD PTR _rpmCmd$[ebp], xmm0
$LN61@Engine1Rpm:

; 2619 : 		}
; 2620 : 
; 2621 : 		//AB Schedule per -1
; 2622 : 		//Area 3 Seg 5 no light
; 2623 : 		if ((platform->ZPos() <= -35000.0f && platform->ZPos() >= -45000.0f) &&
; 2624 : 			(mach <= 0.8f && mach >0.4f))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv743[ebp]
	movss	xmm0, DWORD PTR __real@c708b800
	comiss	xmm0, DWORD PTR tv743[ebp]
	jb	SHORT $LN60@Engine1Rpm
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv749[ebp]
	movss	xmm0, DWORD PTR tv749[ebp]
	comiss	xmm0, DWORD PTR __real@c72fc800
	jb	SHORT $LN60@Engine1Rpm
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f4ccccd
	comiss	xmm0, DWORD PTR [edx+1144]
	jb	SHORT $LN60@Engine1Rpm
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1144]
	comiss	xmm0, DWORD PTR __real@3ecccccd
	jbe	SHORT $LN60@Engine1Rpm

; 2625 : 			rpmCmd = min (1.025f, rpmCmd); 

	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	comiss	xmm0, DWORD PTR __real@3f833333
	jbe	SHORT $LN87@Engine1Rpm
	movss	xmm0, DWORD PTR __real@3f833333
	movss	DWORD PTR tv210[ebp], xmm0
	jmp	SHORT $LN88@Engine1Rpm
$LN87@Engine1Rpm:
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR tv210[ebp], xmm0
$LN88@Engine1Rpm:
	movss	xmm0, DWORD PTR tv210[ebp]
	movss	DWORD PTR _rpmCmd$[ebp], xmm0
$LN60@Engine1Rpm:

; 2626 : 
; 2627 : 		//Area 2 Only Seg 1 will light
; 2628 : 		if ((platform->ZPos() <= -45000.0f && platform->ZPos() >= -55000.0f) && 
; 2629 : 			(mach <=0.95f && mach > 0.4f))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv762[ebp]
	movss	xmm0, DWORD PTR __real@c72fc800
	comiss	xmm0, DWORD PTR tv762[ebp]
	jb	SHORT $LN59@Engine1Rpm
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv768[ebp]
	movss	xmm0, DWORD PTR tv768[ebp]
	comiss	xmm0, DWORD PTR __real@c756d800
	jb	SHORT $LN59@Engine1Rpm
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f733333
	comiss	xmm0, DWORD PTR [eax+1144]
	jb	SHORT $LN59@Engine1Rpm
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1144]
	comiss	xmm0, DWORD PTR __real@3ecccccd
	jbe	SHORT $LN59@Engine1Rpm

; 2630 : 			rpmCmd = min (1.01f, rpmCmd);

	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	comiss	xmm0, DWORD PTR __real@3f8147ae
	jbe	SHORT $LN89@Engine1Rpm
	movss	xmm0, DWORD PTR __real@3f8147ae
	movss	DWORD PTR tv232[ebp], xmm0
	jmp	SHORT $LN90@Engine1Rpm
$LN89@Engine1Rpm:
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR tv232[ebp], xmm0
$LN90@Engine1Rpm:
	movss	xmm0, DWORD PTR tv232[ebp]
	movss	DWORD PTR _rpmCmd$[ebp], xmm0
$LN59@Engine1Rpm:

; 2631 : 
; 2632 : 		//Area 1 No AB available
; 2633 : 		if ((platform->ZPos() <= -30000.0f && platform->ZPos() > -55000.0f) && mach <= 0.4f)

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv781[ebp]
	movss	xmm0, DWORD PTR __real@c6ea6000
	comiss	xmm0, DWORD PTR tv781[ebp]
	jb	SHORT $LN58@Engine1Rpm
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv787[ebp]
	movss	xmm0, DWORD PTR tv787[ebp]
	comiss	xmm0, DWORD PTR __real@c756d800
	jbe	SHORT $LN58@Engine1Rpm
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3ecccccd
	comiss	xmm0, DWORD PTR [ecx+1144]
	jb	SHORT $LN58@Engine1Rpm

; 2634 : 			rpmCmd = min (0.99f, rpmCmd);

	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	comiss	xmm0, DWORD PTR __real@3f7d70a4
	jbe	SHORT $LN91@Engine1Rpm
	movss	xmm0, DWORD PTR __real@3f7d70a4
	movss	DWORD PTR tv252[ebp], xmm0
	jmp	SHORT $LN92@Engine1Rpm
$LN91@Engine1Rpm:
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR tv252[ebp], xmm0
$LN92@Engine1Rpm:
	movss	xmm0, DWORD PTR tv252[ebp]
	movss	DWORD PTR _rpmCmd$[ebp], xmm0
	jmp	SHORT $LN56@Engine1Rpm
$LN58@Engine1Rpm:

; 2635 : 		else if ((platform->ZPos() <= -55000.0f) && mach <= 0.95f)

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv798[ebp]
	movss	xmm0, DWORD PTR __real@c756d800
	comiss	xmm0, DWORD PTR tv798[ebp]
	jb	SHORT $LN56@Engine1Rpm
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f733333
	comiss	xmm0, DWORD PTR [eax+1144]
	jb	SHORT $LN56@Engine1Rpm

; 2636 : 			rpmCmd = min (0.99f, rpmCmd);

	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	comiss	xmm0, DWORD PTR __real@3f7d70a4
	jbe	SHORT $LN93@Engine1Rpm
	movss	xmm0, DWORD PTR __real@3f7d70a4
	movss	DWORD PTR tv264[ebp], xmm0
	jmp	SHORT $LN94@Engine1Rpm
$LN93@Engine1Rpm:
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR tv264[ebp], xmm0
$LN94@Engine1Rpm:
	movss	xmm0, DWORD PTR tv264[ebp]
	movss	DWORD PTR _rpmCmd$[ebp], xmm0
$LN56@Engine1Rpm:

; 2637 : 
; 2638 : 	}//end
; 2639 : 
; 2640 : 
; 2641 : 	// PW-229/GE-110/GE-129
; 2642 : 	if (auxaeroData->typeEngine == 3 || auxaeroData->typeEngine == 4 || auxaeroData->typeEngine == 5)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+3884], 3
	je	SHORT $LN54@Engine1Rpm
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+3884], 4
	je	SHORT $LN54@Engine1Rpm
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+3884], 5
	jne	$LN37@Engine1Rpm
$LN54@Engine1Rpm:

; 2643 : 	{
; 2644 : 		//Reduced Speed Excursion Logic 0.5 - 0.6 is the switch range, we'll call it 5.5 for coding
; 2645 : 		if (mach > 0.55f && mach < 1.1f)

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1144]
	comiss	xmm0, DWORD PTR __real@3f0ccccd
	jbe	SHORT $LN53@Engine1Rpm
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f8ccccd
	comiss	xmm0, DWORD PTR [edx+1144]
	jbe	SHORT $LN53@Engine1Rpm

; 2646 : 		{
; 2647 : 			rpmRSE = 0.79f;

	movss	xmm0, DWORD PTR __real@3f4a3d71
	movss	DWORD PTR _rpmRSE$[ebp], xmm0

; 2648 : 			rpmCmd = max (rpmCmd, rpmRSE);

	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	comiss	xmm0, DWORD PTR _rpmRSE$[ebp]
	jbe	SHORT $LN95@Engine1Rpm
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR tv279[ebp], xmm0
	jmp	SHORT $LN96@Engine1Rpm
$LN95@Engine1Rpm:
	movss	xmm0, DWORD PTR _rpmRSE$[ebp]
	movss	DWORD PTR tv279[ebp], xmm0
$LN96@Engine1Rpm:
	movss	xmm0, DWORD PTR tv279[ebp]
	movss	DWORD PTR _rpmCmd$[ebp], xmm0
	jmp	$LN49@Engine1Rpm
$LN53@Engine1Rpm:

; 2649 : 		}
; 2650 : 		//Idle schedule to MIL from 1.1 to 1.4 MACH
; 2651 : 		else if (mach >= 1.1f && mach <= 1.4f)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1144]
	comiss	xmm0, DWORD PTR __real@3f8ccccd
	jb	SHORT $LN51@Engine1Rpm
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fb33333
	comiss	xmm0, DWORD PTR [ecx+1144]
	jb	SHORT $LN51@Engine1Rpm

; 2652 : 			rpmCmd = max (mach/1.4f, rpmCmd);

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1144]
	divss	xmm0, DWORD PTR __real@3fb33333
	comiss	xmm0, DWORD PTR _rpmCmd$[ebp]
	jbe	SHORT $LN97@Engine1Rpm
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1144]
	divss	xmm0, DWORD PTR __real@3fb33333
	movss	DWORD PTR tv291[ebp], xmm0
	jmp	SHORT $LN98@Engine1Rpm
$LN97@Engine1Rpm:
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR tv291[ebp], xmm0
$LN98@Engine1Rpm:
	movss	xmm0, DWORD PTR tv291[ebp]
	movss	DWORD PTR _rpmCmd$[ebp], xmm0
	jmp	SHORT $LN49@Engine1Rpm
$LN51@Engine1Rpm:

; 2653 : 		else if (mach > 1.4f)

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1144]
	comiss	xmm0, DWORD PTR __real@3fb33333
	jbe	SHORT $LN49@Engine1Rpm

; 2654 : 			rpmCmd = max (0.99f, rpmCmd);

	movss	xmm0, DWORD PTR __real@3f7d70a4
	comiss	xmm0, DWORD PTR _rpmCmd$[ebp]
	jbe	SHORT $LN99@Engine1Rpm
	movss	xmm0, DWORD PTR __real@3f7d70a4
	movss	DWORD PTR tv295[ebp], xmm0
	jmp	SHORT $LN100@Engine1Rpm
$LN99@Engine1Rpm:
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR tv295[ebp], xmm0
$LN100@Engine1Rpm:
	movss	xmm0, DWORD PTR tv295[ebp]
	movss	DWORD PTR _rpmCmd$[ebp], xmm0
$LN49@Engine1Rpm:

; 2655 : 
; 2656 : 		//Idle schedule 
; 2657 : 		//TJL -1 says that RPM increases > 10K to give sufficient stall margin
; 2658 : 		if (platform->ZPos() <= -100.0F)

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv838[ebp]
	movss	xmm0, DWORD PTR __real@c2c80000
	comiss	xmm0, DWORD PTR tv838[ebp]
	jb	SHORT $LN48@Engine1Rpm

; 2659 : 		{
; 2660 : 			//rpmZ = (((SqrtF(-platform->ZPos()))/2000.0F) + rpmBase);
; 2661 : 			rpmCmdZ = ((-platform->ZPos()/10000.0F)/30) + rpmCmdBase;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv844[ebp]
	movss	xmm0, DWORD PTR tv844[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	divss	xmm0, DWORD PTR __real@461c4000
	divss	xmm0, DWORD PTR __real@41f00000
	addss	xmm0, DWORD PTR _rpmCmdBase$[ebp]
	movss	DWORD PTR _rpmCmdZ$[ebp], xmm0

; 2662 : 			rpmCmd = max (rpmCmdZ, rpmCmd);

	movss	xmm0, DWORD PTR _rpmCmdZ$[ebp]
	comiss	xmm0, DWORD PTR _rpmCmd$[ebp]
	jbe	SHORT $LN101@Engine1Rpm
	movss	xmm0, DWORD PTR _rpmCmdZ$[ebp]
	movss	DWORD PTR tv318[ebp], xmm0
	jmp	SHORT $LN102@Engine1Rpm
$LN101@Engine1Rpm:
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR tv318[ebp], xmm0
$LN102@Engine1Rpm:
	movss	xmm0, DWORD PTR tv318[ebp]
	movss	DWORD PTR _rpmCmd$[ebp], xmm0
$LN48@Engine1Rpm:

; 2663 : 		}
; 2664 : 
; 2665 : 		//Reduce AB schedule
; 2666 : 		if ((platform->ZPos() < -50000.0F) && vcas < 250.0F)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv853[ebp]
	movss	xmm0, DWORD PTR __real@c7435000
	comiss	xmm0, DWORD PTR tv853[ebp]
	jbe	SHORT $LN47@Engine1Rpm
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@437a0000
	comiss	xmm0, DWORD PTR [edx+1124]
	jbe	SHORT $LN47@Engine1Rpm

; 2667 : 		{
; 2668 : 			rpmCmd = min (1.01f, rpmCmd);

	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	comiss	xmm0, DWORD PTR __real@3f8147ae
	jbe	SHORT $LN103@Engine1Rpm
	movss	xmm0, DWORD PTR __real@3f8147ae
	movss	DWORD PTR tv330[ebp], xmm0
	jmp	SHORT $LN104@Engine1Rpm
$LN103@Engine1Rpm:
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR tv330[ebp], xmm0
$LN104@Engine1Rpm:
	movss	xmm0, DWORD PTR tv330[ebp]
	movss	DWORD PTR _rpmCmd$[ebp], xmm0
$LN47@Engine1Rpm:

; 2669 : 		}
; 2670 : 
; 2671 : 			
; 2672 : 		//Zone 2 AB no lights or delayed lights possible
; 2673 : 		if ((platform->ZPos() < -30000.0F) && vcas < 225.0F)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv865[ebp]
	movss	xmm0, DWORD PTR __real@c6ea6000
	comiss	xmm0, DWORD PTR tv865[ebp]
	jbe	SHORT $LN46@Engine1Rpm
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@43610000
	comiss	xmm0, DWORD PTR [ecx+1124]
	jbe	SHORT $LN46@Engine1Rpm

; 2674 : 		{
; 2675 : 		//	if ((SimLibElapsedTime - engEventTimer) >= 5000)
; 2676 : 			if (rpm <= 1.0F && engFlag1 == 0)

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR [edx+1212]
	jb	SHORT $LN41@Engine1Rpm
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+236], 0
	jne	SHORT $LN41@Engine1Rpm

; 2677 : 			{
; 2678 : 				int randnum = rand()%100;

	call	_rand
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _randnum$1[ebp], edx

; 2679 : 				if (randnum == 1)

	cmp	DWORD PTR _randnum$1[ebp], 1
	jne	SHORT $LN44@Engine1Rpm

; 2680 : 					engFlag1 = 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+236], 1
	jmp	SHORT $LN41@Engine1Rpm
$LN44@Engine1Rpm:

; 2681 : 
; 2682 : 				else if (randnum == 2)

	cmp	DWORD PTR _randnum$1[ebp], 2
	jne	SHORT $LN42@Engine1Rpm

; 2683 : 					engFlag1 = 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+236], 2

; 2684 : 				else

	jmp	SHORT $LN41@Engine1Rpm
$LN42@Engine1Rpm:

; 2685 : 					engFlag1 = 3;//this stops the loop

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+236], 3
$LN41@Engine1Rpm:

; 2686 : 
; 2687 : 			}
; 2688 : 
; 2689 : 		}
; 2690 : 		else

	jmp	SHORT $LN40@Engine1Rpm
$LN46@Engine1Rpm:

; 2691 : 			//Reset flag when out of condition
; 2692 : 			engFlag1 = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+236], 0
$LN40@Engine1Rpm:

; 2693 : 
; 2694 : 		//AB no light
; 2695 : 		if (engFlag1 == 1)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+236], 1
	jne	SHORT $LN39@Engine1Rpm

; 2696 : 			rpmCmd = min (0.99f, rpmCmd);

	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	comiss	xmm0, DWORD PTR __real@3f7d70a4
	jbe	SHORT $LN105@Engine1Rpm
	movss	xmm0, DWORD PTR __real@3f7d70a4
	movss	DWORD PTR tv356[ebp], xmm0
	jmp	SHORT $LN106@Engine1Rpm
$LN105@Engine1Rpm:
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR tv356[ebp], xmm0
$LN106@Engine1Rpm:
	movss	xmm0, DWORD PTR tv356[ebp]
	movss	DWORD PTR _rpmCmd$[ebp], xmm0
	jmp	SHORT $LN37@Engine1Rpm
$LN39@Engine1Rpm:

; 2697 : 		//AB partial light
; 2698 : 		else if (engFlag1 == 2)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+236], 2
	jne	SHORT $LN37@Engine1Rpm

; 2699 : 			rpmCmd = min (1.01f, rpmCmd);

	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	comiss	xmm0, DWORD PTR __real@3f8147ae
	jbe	SHORT $LN107@Engine1Rpm
	movss	xmm0, DWORD PTR __real@3f8147ae
	movss	DWORD PTR tv360[ebp], xmm0
	jmp	SHORT $LN108@Engine1Rpm
$LN107@Engine1Rpm:
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR tv360[ebp], xmm0
$LN108@Engine1Rpm:
	movss	xmm0, DWORD PTR tv360[ebp]
	movss	DWORD PTR _rpmCmd$[ebp], xmm0
$LN37@Engine1Rpm:

; 2700 : 	}
; 2701 : 
; 2702 : 
; 2703 : 
; 2704 : 	//F18A-D MIL at 1.23 mach
; 2705 : 	if (auxaeroData->typeEngine == 6 || auxaeroData->typeEngine == 7
; 2706 : 		|| auxaeroData->typeAC == 8 || auxaeroData->typeAC == 9)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+3884], 6
	je	SHORT $LN35@Engine1Rpm
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+3884], 7
	je	SHORT $LN35@Engine1Rpm
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+3880], 8
	je	SHORT $LN35@Engine1Rpm
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+3880], 9
	jne	$LN31@Engine1Rpm
$LN35@Engine1Rpm:

; 2707 : 	{
; 2708 : 		if (mach >= 0.9f && mach <= 1.23f)

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1144]
	comiss	xmm0, DWORD PTR __real@3f666666
	jb	SHORT $LN34@Engine1Rpm
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f9d70a4
	comiss	xmm0, DWORD PTR [edx+1144]
	jb	SHORT $LN34@Engine1Rpm

; 2709 : 			rpmCmd = max (mach/1.23f, rpmCmd);

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1144]
	divss	xmm0, DWORD PTR __real@3f9d70a4
	comiss	xmm0, DWORD PTR _rpmCmd$[ebp]
	jbe	SHORT $LN109@Engine1Rpm
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1144]
	divss	xmm0, DWORD PTR __real@3f9d70a4
	movss	DWORD PTR tv384[ebp], xmm0
	jmp	SHORT $LN110@Engine1Rpm
$LN109@Engine1Rpm:
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR tv384[ebp], xmm0
$LN110@Engine1Rpm:
	movss	xmm0, DWORD PTR tv384[ebp]
	movss	DWORD PTR _rpmCmd$[ebp], xmm0
	jmp	SHORT $LN32@Engine1Rpm
$LN34@Engine1Rpm:

; 2710 : 		else if (mach > 1.23f)

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1144]
	comiss	xmm0, DWORD PTR __real@3f9d70a4
	jbe	SHORT $LN32@Engine1Rpm

; 2711 : 			rpmCmd = max (0.99f, rpmCmd);

	movss	xmm0, DWORD PTR __real@3f7d70a4
	comiss	xmm0, DWORD PTR _rpmCmd$[ebp]
	jbe	SHORT $LN111@Engine1Rpm
	movss	xmm0, DWORD PTR __real@3f7d70a4
	movss	DWORD PTR tv388[ebp], xmm0
	jmp	SHORT $LN112@Engine1Rpm
$LN111@Engine1Rpm:
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR tv388[ebp], xmm0
$LN112@Engine1Rpm:
	movss	xmm0, DWORD PTR tv388[ebp]
	movss	DWORD PTR _rpmCmd$[ebp], xmm0
$LN32@Engine1Rpm:

; 2712 : 
; 2713 : 		//RPM increases > 10K to give sufficient stall margin
; 2714 : 		if (platform->ZPos() <= -100.0F)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv916[ebp]
	movss	xmm0, DWORD PTR __real@c2c80000
	comiss	xmm0, DWORD PTR tv916[ebp]
	jb	SHORT $LN31@Engine1Rpm

; 2715 : 		{
; 2716 : 			rpmCmdZ = ((-platform->ZPos()/10000.0F)/30) + rpmCmdBase;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv922[ebp]
	movss	xmm0, DWORD PTR tv922[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	divss	xmm0, DWORD PTR __real@461c4000
	divss	xmm0, DWORD PTR __real@41f00000
	addss	xmm0, DWORD PTR _rpmCmdBase$[ebp]
	movss	DWORD PTR _rpmCmdZ$[ebp], xmm0

; 2717 : 			rpmCmd = max (rpmCmdZ, rpmCmd);

	movss	xmm0, DWORD PTR _rpmCmdZ$[ebp]
	comiss	xmm0, DWORD PTR _rpmCmd$[ebp]
	jbe	SHORT $LN113@Engine1Rpm
	movss	xmm0, DWORD PTR _rpmCmdZ$[ebp]
	movss	DWORD PTR tv411[ebp], xmm0
	jmp	SHORT $LN114@Engine1Rpm
$LN113@Engine1Rpm:
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR tv411[ebp], xmm0
$LN114@Engine1Rpm:
	movss	xmm0, DWORD PTR tv411[ebp]
	movss	DWORD PTR _rpmCmd$[ebp], xmm0
$LN31@Engine1Rpm:

; 2718 : 		}
; 2719 : 
; 2720 : 	}
; 2721 : 
; 2722 : 	//F18E/F RPM to MIL at 1.23 mach
; 2723 : 	if (auxaeroData->typeEngine == 8 || auxaeroData->typeAC == 10)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+3884], 8
	je	SHORT $LN29@Engine1Rpm
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+3880], 10		; 0000000aH
	jne	$LN25@Engine1Rpm
$LN29@Engine1Rpm:

; 2724 : 	{
; 2725 : 		if (mach >= 1.18f && mach <= 1.23f)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1144]
	comiss	xmm0, DWORD PTR __real@3f970a3d
	jb	SHORT $LN28@Engine1Rpm
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f9d70a4
	comiss	xmm0, DWORD PTR [ecx+1144]
	jb	SHORT $LN28@Engine1Rpm

; 2726 : 			rpmCmd = max (mach/1.23f, rpmCmd);

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1144]
	divss	xmm0, DWORD PTR __real@3f9d70a4
	comiss	xmm0, DWORD PTR _rpmCmd$[ebp]
	jbe	SHORT $LN115@Engine1Rpm
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1144]
	divss	xmm0, DWORD PTR __real@3f9d70a4
	movss	DWORD PTR tv429[ebp], xmm0
	jmp	SHORT $LN116@Engine1Rpm
$LN115@Engine1Rpm:
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR tv429[ebp], xmm0
$LN116@Engine1Rpm:
	movss	xmm0, DWORD PTR tv429[ebp]
	movss	DWORD PTR _rpmCmd$[ebp], xmm0
	jmp	SHORT $LN26@Engine1Rpm
$LN28@Engine1Rpm:

; 2727 : 		else if (mach > 1.23f)

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1144]
	comiss	xmm0, DWORD PTR __real@3f9d70a4
	jbe	SHORT $LN26@Engine1Rpm

; 2728 : 			rpmCmd = max (0.99f, rpmCmd);

	movss	xmm0, DWORD PTR __real@3f7d70a4
	comiss	xmm0, DWORD PTR _rpmCmd$[ebp]
	jbe	SHORT $LN117@Engine1Rpm
	movss	xmm0, DWORD PTR __real@3f7d70a4
	movss	DWORD PTR tv433[ebp], xmm0
	jmp	SHORT $LN118@Engine1Rpm
$LN117@Engine1Rpm:
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR tv433[ebp], xmm0
$LN118@Engine1Rpm:
	movss	xmm0, DWORD PTR tv433[ebp]
	movss	DWORD PTR _rpmCmd$[ebp], xmm0
$LN26@Engine1Rpm:

; 2729 : 
; 2730 : 		//RPM increases > 10K to give sufficient stall margin
; 2731 : 		if (platform->ZPos() <= -100.0F)

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv949[ebp]
	movss	xmm0, DWORD PTR __real@c2c80000
	comiss	xmm0, DWORD PTR tv949[ebp]
	jb	SHORT $LN25@Engine1Rpm

; 2732 : 		{
; 2733 : 			rpmCmdZ = ((-platform->ZPos()/10000.0F)/30) + rpmCmdBase;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv955[ebp]
	movss	xmm0, DWORD PTR tv955[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	divss	xmm0, DWORD PTR __real@461c4000
	divss	xmm0, DWORD PTR __real@41f00000
	addss	xmm0, DWORD PTR _rpmCmdBase$[ebp]
	movss	DWORD PTR _rpmCmdZ$[ebp], xmm0

; 2734 : 			rpmCmd = max (rpmCmdZ, rpmCmd);

	movss	xmm0, DWORD PTR _rpmCmdZ$[ebp]
	comiss	xmm0, DWORD PTR _rpmCmd$[ebp]
	jbe	SHORT $LN119@Engine1Rpm
	movss	xmm0, DWORD PTR _rpmCmdZ$[ebp]
	movss	DWORD PTR tv456[ebp], xmm0
	jmp	SHORT $LN120@Engine1Rpm
$LN119@Engine1Rpm:
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR tv456[ebp], xmm0
$LN120@Engine1Rpm:
	movss	xmm0, DWORD PTR tv456[ebp]
	movss	DWORD PTR _rpmCmd$[ebp], xmm0
$LN25@Engine1Rpm:

; 2735 : 		}
; 2736 : 
; 2737 : 	}
; 2738 : 
; 2739 : 
; 2740 : 	// F-14 spools engine up when Mach < 0.9 and AOA over 18
; 2741 : 	if ((auxaeroData->typeAC == 6 || auxaeroData->typeAC == 7) || 
; 2742 : 		(auxaeroData->typeEngine == 9 || auxaeroData->typeEngine == 10))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+3880], 6
	je	SHORT $LN22@Engine1Rpm
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+3880], 7
	je	SHORT $LN22@Engine1Rpm
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+3884], 9
	je	SHORT $LN22@Engine1Rpm
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+3884], 10		; 0000000aH
	jne	$LN12@Engine1Rpm
$LN22@Engine1Rpm:

; 2743 : 	{
; 2744 : 		if (alpha >= 18.0F && mach <= 0.9F)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1152]
	comiss	xmm0, DWORD PTR __real@41900000
	jb	SHORT $LN21@Engine1Rpm
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f666666
	comiss	xmm0, DWORD PTR [ecx+1144]
	jb	SHORT $LN21@Engine1Rpm

; 2745 : 			rpmCmd = max (0.85f, rpmCmd);

	movss	xmm0, DWORD PTR __real@3f59999a
	comiss	xmm0, DWORD PTR _rpmCmd$[ebp]
	jbe	SHORT $LN121@Engine1Rpm
	movss	xmm0, DWORD PTR __real@3f59999a
	movss	DWORD PTR tv474[ebp], xmm0
	jmp	SHORT $LN122@Engine1Rpm
$LN121@Engine1Rpm:
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR tv474[ebp], xmm0
$LN122@Engine1Rpm:
	movss	xmm0, DWORD PTR tv474[ebp]
	movss	DWORD PTR _rpmCmd$[ebp], xmm0
$LN21@Engine1Rpm:

; 2746 : 
; 2747 : 		//Rich Stability cutback reduced operation
; 2748 : 		if ((platform->ZPos() <= -40000.0f) && mach <= 0.45f)

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv976[ebp]
	movss	xmm0, DWORD PTR __real@c71c4000
	comiss	xmm0, DWORD PTR tv976[ebp]
	jb	SHORT $LN20@Engine1Rpm
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3ee66666
	comiss	xmm0, DWORD PTR [eax+1144]
	jb	SHORT $LN20@Engine1Rpm

; 2749 : 			rpmCmd = min (1.015f, rpmCmd);

	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	comiss	xmm0, DWORD PTR __real@3f81eb85
	jbe	SHORT $LN123@Engine1Rpm
	movss	xmm0, DWORD PTR __real@3f81eb85
	movss	DWORD PTR tv486[ebp], xmm0
	jmp	SHORT $LN124@Engine1Rpm
$LN123@Engine1Rpm:
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR tv486[ebp], xmm0
$LN124@Engine1Rpm:
	movss	xmm0, DWORD PTR tv486[ebp]
	movss	DWORD PTR _rpmCmd$[ebp], xmm0
	jmp	$LN12@Engine1Rpm
$LN20@Engine1Rpm:

; 2750 : 		else if ((platform->ZPos() <= -45000.0f) && mach <= 0.6f)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv988[ebp]
	movss	xmm0, DWORD PTR __real@c72fc800
	comiss	xmm0, DWORD PTR tv988[ebp]
	jb	SHORT $LN18@Engine1Rpm
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f19999a
	comiss	xmm0, DWORD PTR [edx+1144]
	jb	SHORT $LN18@Engine1Rpm

; 2751 : 			rpmCmd = min (1.015f, rpmCmd);

	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	comiss	xmm0, DWORD PTR __real@3f81eb85
	jbe	SHORT $LN125@Engine1Rpm
	movss	xmm0, DWORD PTR __real@3f81eb85
	movss	DWORD PTR tv498[ebp], xmm0
	jmp	SHORT $LN126@Engine1Rpm
$LN125@Engine1Rpm:
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR tv498[ebp], xmm0
$LN126@Engine1Rpm:
	movss	xmm0, DWORD PTR tv498[ebp]
	movss	DWORD PTR _rpmCmd$[ebp], xmm0
	jmp	$LN12@Engine1Rpm
$LN18@Engine1Rpm:

; 2752 : 		else if ((platform->ZPos() <= -50000.0f) && mach <= 1.0f)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv1000[ebp]
	movss	xmm0, DWORD PTR __real@c7435000
	comiss	xmm0, DWORD PTR tv1000[ebp]
	jb	SHORT $LN16@Engine1Rpm
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR [ecx+1144]
	jb	SHORT $LN16@Engine1Rpm

; 2753 : 			rpmCmd = min (1.01f, rpmCmd);

	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	comiss	xmm0, DWORD PTR __real@3f8147ae
	jbe	SHORT $LN127@Engine1Rpm
	movss	xmm0, DWORD PTR __real@3f8147ae
	movss	DWORD PTR tv510[ebp], xmm0
	jmp	SHORT $LN128@Engine1Rpm
$LN127@Engine1Rpm:
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR tv510[ebp], xmm0
$LN128@Engine1Rpm:
	movss	xmm0, DWORD PTR tv510[ebp]
	movss	DWORD PTR _rpmCmd$[ebp], xmm0
	jmp	$LN12@Engine1Rpm
$LN16@Engine1Rpm:

; 2754 : 		else if ((platform->ZPos() <= -55000.0f) && mach <= 1.1f)

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv1012[ebp]
	movss	xmm0, DWORD PTR __real@c756d800
	comiss	xmm0, DWORD PTR tv1012[ebp]
	jb	SHORT $LN14@Engine1Rpm
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f8ccccd
	comiss	xmm0, DWORD PTR [eax+1144]
	jb	SHORT $LN14@Engine1Rpm

; 2755 : 			rpmCmd = min (1.01f, rpmCmd);

	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	comiss	xmm0, DWORD PTR __real@3f8147ae
	jbe	SHORT $LN129@Engine1Rpm
	movss	xmm0, DWORD PTR __real@3f8147ae
	movss	DWORD PTR tv522[ebp], xmm0
	jmp	SHORT $LN130@Engine1Rpm
$LN129@Engine1Rpm:
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR tv522[ebp], xmm0
$LN130@Engine1Rpm:
	movss	xmm0, DWORD PTR tv522[ebp]
	movss	DWORD PTR _rpmCmd$[ebp], xmm0
	jmp	SHORT $LN12@Engine1Rpm
$LN14@Engine1Rpm:

; 2756 : 		else if ((platform->ZPos() <= -60000.0f) && mach <= 1.2f)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv1024[ebp]
	movss	xmm0, DWORD PTR __real@c76a6000
	comiss	xmm0, DWORD PTR tv1024[ebp]
	jb	SHORT $LN12@Engine1Rpm
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f99999a
	comiss	xmm0, DWORD PTR [edx+1144]
	jb	SHORT $LN12@Engine1Rpm

; 2757 : 			rpmCmd = min (1.01f, rpmCmd);

	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	comiss	xmm0, DWORD PTR __real@3f8147ae
	jbe	SHORT $LN131@Engine1Rpm
	movss	xmm0, DWORD PTR __real@3f8147ae
	movss	DWORD PTR tv534[ebp], xmm0
	jmp	SHORT $LN132@Engine1Rpm
$LN131@Engine1Rpm:
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR tv534[ebp], xmm0
$LN132@Engine1Rpm:
	movss	xmm0, DWORD PTR tv534[ebp]
	movss	DWORD PTR _rpmCmd$[ebp], xmm0
$LN12@Engine1Rpm:

; 2758 : 
; 2759 : 	}
; 2760 : 	
; 2761 : 	// F-4E Engine Stall Zone 
; 2762 : 	if (auxaeroData->typeEngine == 11 || auxaeroData->typeAC == 11)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+3884], 11		; 0000000bH
	je	SHORT $LN10@Engine1Rpm
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+3880], 11		; 0000000bH
	jne	$LN1@Engine1Rpm
$LN10@Engine1Rpm:

; 2763 : 	{
; 2764 : 		if ((SimLibElapsedTime - engEventTimer) >= 1000)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	sub	edx, DWORD PTR [ecx+228]
	cmp	edx, 1000				; 000003e8H
	jb	$LN2@Engine1Rpm

; 2765 : 		{
; 2766 : 			if(platform->ZPos() < -10000.0F && vcas < 150.0F)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv1040[ebp]
	movss	xmm0, DWORD PTR __real@c61c4000
	comiss	xmm0, DWORD PTR tv1040[ebp]
	jbe	SHORT $LN6@Engine1Rpm
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@43160000
	comiss	xmm0, DWORD PTR [ecx+1124]
	jbe	SHORT $LN6@Engine1Rpm

; 2767 : 			{
; 2768 : 				if (1 == (rand() % 30))

	call	_rand
	cdq
	mov	ecx, 30					; 0000001eH
	idiv	ecx
	cmp	edx, 1
	jne	SHORT $LN7@Engine1Rpm

; 2769 : 				{
; 2770 : 					SetFlag(EngineStopped);

	push	134217728				; 08000000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFlag@AirframeClass@@QAEXH@Z		; AirframeClass::SetFlag

; 2771 : 					engEventTimer = SimLibElapsedTime;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [edx+228], eax

; 2772 : 				}
; 2773 : 				else

	jmp	SHORT $LN6@Engine1Rpm
$LN7@Engine1Rpm:

; 2774 : 					engEventTimer = SimLibElapsedTime;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [ecx+228], edx
$LN6@Engine1Rpm:

; 2775 : 			}
; 2776 : 			
; 2777 : 			if (platform->ZPos() < -10000.0F && alpha > 28.0F && rpm >= 1.0f)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv1058[ebp]
	movss	xmm0, DWORD PTR __real@c61c4000
	comiss	xmm0, DWORD PTR tv1058[ebp]
	jbe	SHORT $LN5@Engine1Rpm
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1152]
	comiss	xmm0, DWORD PTR __real@41e00000
	jbe	SHORT $LN5@Engine1Rpm
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1212]
	comiss	xmm0, DWORD PTR __real@3f800000
	jb	SHORT $LN5@Engine1Rpm

; 2778 : 			{
; 2779 : 				if (1 == (rand() % 30))

	call	_rand
	cdq
	mov	ecx, 30					; 0000001eH
	idiv	ecx
	cmp	edx, 1
	jne	SHORT $LN4@Engine1Rpm

; 2780 : 				{
; 2781 : 					SetFlag(EngineStopped);

	push	134217728				; 08000000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFlag@AirframeClass@@QAEXH@Z		; AirframeClass::SetFlag

; 2782 : 					engEventTimer = SimLibElapsedTime;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [edx+228], eax

; 2783 : 				}
; 2784 : 				else

	jmp	SHORT $LN3@Engine1Rpm
$LN4@Engine1Rpm:

; 2785 : 					engEventTimer = SimLibElapsedTime;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [ecx+228], edx
$LN3@Engine1Rpm:

; 2786 : 			}
; 2787 : 			else

	jmp	SHORT $LN2@Engine1Rpm
$LN5@Engine1Rpm:

; 2788 : 				engEventTimer = SimLibElapsedTime;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [eax+228], ecx
$LN2@Engine1Rpm:

; 2789 : 		}
; 2790 : 		
; 2791 : 		if (platform->ZPos() < -50000.0F && vcas < 300.0F)

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv1080[ebp]
	movss	xmm0, DWORD PTR __real@c7435000
	comiss	xmm0, DWORD PTR tv1080[ebp]
	jbe	SHORT $LN1@Engine1Rpm
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@43960000
	comiss	xmm0, DWORD PTR [eax+1124]
	jbe	SHORT $LN1@Engine1Rpm

; 2792 : 		{
; 2793 : 			rpmCmd = min (0.99F, rpmCmd);

	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	comiss	xmm0, DWORD PTR __real@3f7d70a4
	jbe	SHORT $LN133@Engine1Rpm
	movss	xmm0, DWORD PTR __real@3f7d70a4
	movss	DWORD PTR tv592[ebp], xmm0
	jmp	SHORT $LN134@Engine1Rpm
$LN133@Engine1Rpm:
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR tv592[ebp], xmm0
$LN134@Engine1Rpm:
	movss	xmm0, DWORD PTR tv592[ebp]
	movss	DWORD PTR _rpmCmd$[ebp], xmm0
$LN1@Engine1Rpm:

; 2794 : 
; 2795 : 		}
; 2796 : 	}
; 2797 : 
; 2798 : 
; 2799 : 	return rpmCmd;

	fld	DWORD PTR _rpmCmd$[ebp]

; 2800 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Engine1RpmMods@AirframeClass@@QAEMM@Z ENDP		; AirframeClass::Engine1RpmMods
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\airframe\engine.cpp
_TEXT	SEGMENT
tv506 = -128						; size = 4
tv494 = -124						; size = 4
tv485 = -120						; size = 4
tv479 = -116						; size = 4
tv439 = -112						; size = 4
tv428 = -108						; size = 4
tv422 = -104						; size = 4
tv409 = -100						; size = 4
tv403 = -96						; size = 4
tv390 = -92						; size = 4
tv384 = -88						; size = 4
tv375 = -84						; size = 4
tv369 = -80						; size = 4
tv312 = -76						; size = 4
tv308 = -72						; size = 4
_randnum$1 = -68					; size = 4
tv282 = -64						; size = 4
tv270 = -60						; size = 4
_rpmCmdBase$ = -56					; size = 4
tv247 = -52						; size = 4
tv243 = -48						; size = 4
tv231 = -44						; size = 4
tv216 = -40						; size = 4
tv204 = -36						; size = 4
tv184 = -32						; size = 4
tv162 = -28						; size = 4
tv140 = -24						; size = 4
tv85 = -20						; size = 4
tv81 = -16						; size = 4
_rpmRSE$ = -12						; size = 4
_rpmCmdZ$ = -8						; size = 4
_this$ = -4						; size = 4
_rpmCmd$ = 8						; size = 4
?EngineRpmMods@AirframeClass@@QAEMM@Z PROC		; AirframeClass::EngineRpmMods
; _this$ = ecx

; 2469 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H
	mov	DWORD PTR _this$[ebp], ecx

; 2470 : 	//
; 2471 : 	float rpmCmdBase = 0.7F;

	movss	xmm0, DWORD PTR __real@3f333333
	movss	DWORD PTR _rpmCmdBase$[ebp], xmm0

; 2472 : 	float rpmCmdZ = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _rpmCmdZ$[ebp], xmm0

; 2473 : 	float rpmRSE = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _rpmRSE$[ebp], xmm0

; 2474 : 
; 2475 : 	//PW-100/PW-220
; 2476 : 	if (auxaeroData->typeEngine == 1 || auxaeroData->typeEngine == 2)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+3884], 1
	je	SHORT $LN29@EngineRpmM
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+3884], 2
	jne	$LN20@EngineRpmM
$LN29@EngineRpmM:

; 2477 : 	{
; 2478 : 		//TJL -1 says idle RPM increases from 0.84 till it is MIL power at 1.4 Mach
; 2479 : 		if (mach >= 0.84f && mach <= 1.4f)

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1144]
	comiss	xmm0, DWORD PTR __real@3f570a3d
	jb	SHORT $LN28@EngineRpmM
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fb33333
	comiss	xmm0, DWORD PTR [edx+1144]
	jb	SHORT $LN28@EngineRpmM

; 2480 : 			rpmCmd = max (mach/1.4f, rpmCmd);

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1144]
	divss	xmm0, DWORD PTR __real@3fb33333
	comiss	xmm0, DWORD PTR _rpmCmd$[ebp]
	jbe	SHORT $LN33@EngineRpmM
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1144]
	divss	xmm0, DWORD PTR __real@3fb33333
	movss	DWORD PTR tv81[ebp], xmm0
	jmp	SHORT $LN34@EngineRpmM
$LN33@EngineRpmM:
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR tv81[ebp], xmm0
$LN34@EngineRpmM:
	movss	xmm0, DWORD PTR tv81[ebp]
	movss	DWORD PTR _rpmCmd$[ebp], xmm0
	jmp	SHORT $LN26@EngineRpmM
$LN28@EngineRpmM:

; 2481 : 		else if (mach > 1.4f)

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1144]
	comiss	xmm0, DWORD PTR __real@3fb33333
	jbe	SHORT $LN26@EngineRpmM

; 2482 : 			rpmCmd = max (0.99f, rpmCmd);

	movss	xmm0, DWORD PTR __real@3f7d70a4
	comiss	xmm0, DWORD PTR _rpmCmd$[ebp]
	jbe	SHORT $LN35@EngineRpmM
	movss	xmm0, DWORD PTR __real@3f7d70a4
	movss	DWORD PTR tv85[ebp], xmm0
	jmp	SHORT $LN36@EngineRpmM
$LN35@EngineRpmM:
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR tv85[ebp], xmm0
$LN36@EngineRpmM:
	movss	xmm0, DWORD PTR tv85[ebp]
	movss	DWORD PTR _rpmCmd$[ebp], xmm0
$LN26@EngineRpmM:

; 2483 : 		//TJL -1 says that RPM increases > 10K to give sufficient stall margin
; 2484 : 		if (platform->ZPos() <= -100.0F)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv369[ebp]
	movss	xmm0, DWORD PTR __real@c2c80000
	comiss	xmm0, DWORD PTR tv369[ebp]
	jb	SHORT $LN25@EngineRpmM

; 2485 : 		{
; 2486 : 			rpmCmdZ = ((-platform->ZPos()/10000.0F)/30) + rpmCmdBase;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv375[ebp]
	movss	xmm0, DWORD PTR tv375[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	divss	xmm0, DWORD PTR __real@461c4000
	divss	xmm0, DWORD PTR __real@41f00000
	addss	xmm0, DWORD PTR _rpmCmdBase$[ebp]
	movss	DWORD PTR _rpmCmdZ$[ebp], xmm0

; 2487 : 			rpmCmd = max (rpmCmdZ, rpmCmd);

	movss	xmm0, DWORD PTR _rpmCmdZ$[ebp]
	comiss	xmm0, DWORD PTR _rpmCmd$[ebp]
	jbe	SHORT $LN37@EngineRpmM
	movss	xmm0, DWORD PTR _rpmCmdZ$[ebp]
	movss	DWORD PTR tv140[ebp], xmm0
	jmp	SHORT $LN38@EngineRpmM
$LN37@EngineRpmM:
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR tv140[ebp], xmm0
$LN38@EngineRpmM:
	movss	xmm0, DWORD PTR tv140[ebp]
	movss	DWORD PTR _rpmCmd$[ebp], xmm0
$LN25@EngineRpmM:

; 2488 : 		}
; 2489 : 
; 2490 : 		//AB Schedule per -1
; 2491 : 		//Area 3 Seg 5 no light
; 2492 : 		if ((platform->ZPos() <= -35000.0f && platform->ZPos() >= -45000.0f) &&
; 2493 : 			(mach <= 0.8f && mach >0.4f))

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv384[ebp]
	movss	xmm0, DWORD PTR __real@c708b800
	comiss	xmm0, DWORD PTR tv384[ebp]
	jb	SHORT $LN24@EngineRpmM
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv390[ebp]
	movss	xmm0, DWORD PTR tv390[ebp]
	comiss	xmm0, DWORD PTR __real@c72fc800
	jb	SHORT $LN24@EngineRpmM
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f4ccccd
	comiss	xmm0, DWORD PTR [ecx+1144]
	jb	SHORT $LN24@EngineRpmM
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1144]
	comiss	xmm0, DWORD PTR __real@3ecccccd
	jbe	SHORT $LN24@EngineRpmM

; 2494 : 			rpmCmd = min (1.025f, rpmCmd); 

	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	comiss	xmm0, DWORD PTR __real@3f833333
	jbe	SHORT $LN39@EngineRpmM
	movss	xmm0, DWORD PTR __real@3f833333
	movss	DWORD PTR tv162[ebp], xmm0
	jmp	SHORT $LN40@EngineRpmM
$LN39@EngineRpmM:
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR tv162[ebp], xmm0
$LN40@EngineRpmM:
	movss	xmm0, DWORD PTR tv162[ebp]
	movss	DWORD PTR _rpmCmd$[ebp], xmm0
$LN24@EngineRpmM:

; 2495 : 
; 2496 : 		//Area 2 Only Seg 1 will light
; 2497 : 		if ((platform->ZPos() <= -45000.0f && platform->ZPos() >= -55000.0f) && 
; 2498 : 			(mach <=0.95f && mach > 0.4f))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv403[ebp]
	movss	xmm0, DWORD PTR __real@c72fc800
	comiss	xmm0, DWORD PTR tv403[ebp]
	jb	SHORT $LN23@EngineRpmM
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv409[ebp]
	movss	xmm0, DWORD PTR tv409[ebp]
	comiss	xmm0, DWORD PTR __real@c756d800
	jb	SHORT $LN23@EngineRpmM
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f733333
	comiss	xmm0, DWORD PTR [edx+1144]
	jb	SHORT $LN23@EngineRpmM
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1144]
	comiss	xmm0, DWORD PTR __real@3ecccccd
	jbe	SHORT $LN23@EngineRpmM

; 2499 : 			rpmCmd = min (1.01f, rpmCmd);

	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	comiss	xmm0, DWORD PTR __real@3f8147ae
	jbe	SHORT $LN41@EngineRpmM
	movss	xmm0, DWORD PTR __real@3f8147ae
	movss	DWORD PTR tv184[ebp], xmm0
	jmp	SHORT $LN42@EngineRpmM
$LN41@EngineRpmM:
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR tv184[ebp], xmm0
$LN42@EngineRpmM:
	movss	xmm0, DWORD PTR tv184[ebp]
	movss	DWORD PTR _rpmCmd$[ebp], xmm0
$LN23@EngineRpmM:

; 2500 : 
; 2501 : 		//Area 1 No AB available
; 2502 : 		if ((platform->ZPos() <= -30000.0f && platform->ZPos() > -55000.0f) && mach <= 0.4f)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv422[ebp]
	movss	xmm0, DWORD PTR __real@c6ea6000
	comiss	xmm0, DWORD PTR tv422[ebp]
	jb	SHORT $LN22@EngineRpmM
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv428[ebp]
	movss	xmm0, DWORD PTR tv428[ebp]
	comiss	xmm0, DWORD PTR __real@c756d800
	jbe	SHORT $LN22@EngineRpmM
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3ecccccd
	comiss	xmm0, DWORD PTR [eax+1144]
	jb	SHORT $LN22@EngineRpmM

; 2503 : 			rpmCmd = min (0.99f, rpmCmd);

	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	comiss	xmm0, DWORD PTR __real@3f7d70a4
	jbe	SHORT $LN43@EngineRpmM
	movss	xmm0, DWORD PTR __real@3f7d70a4
	movss	DWORD PTR tv204[ebp], xmm0
	jmp	SHORT $LN44@EngineRpmM
$LN43@EngineRpmM:
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR tv204[ebp], xmm0
$LN44@EngineRpmM:
	movss	xmm0, DWORD PTR tv204[ebp]
	movss	DWORD PTR _rpmCmd$[ebp], xmm0
	jmp	SHORT $LN20@EngineRpmM
$LN22@EngineRpmM:

; 2504 : 		else if ((platform->ZPos() <= -55000.0f) && mach <= 0.95f)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv439[ebp]
	movss	xmm0, DWORD PTR __real@c756d800
	comiss	xmm0, DWORD PTR tv439[ebp]
	jb	SHORT $LN20@EngineRpmM
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f733333
	comiss	xmm0, DWORD PTR [edx+1144]
	jb	SHORT $LN20@EngineRpmM

; 2505 : 			rpmCmd = min (0.99f, rpmCmd);

	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	comiss	xmm0, DWORD PTR __real@3f7d70a4
	jbe	SHORT $LN45@EngineRpmM
	movss	xmm0, DWORD PTR __real@3f7d70a4
	movss	DWORD PTR tv216[ebp], xmm0
	jmp	SHORT $LN46@EngineRpmM
$LN45@EngineRpmM:
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR tv216[ebp], xmm0
$LN46@EngineRpmM:
	movss	xmm0, DWORD PTR tv216[ebp]
	movss	DWORD PTR _rpmCmd$[ebp], xmm0
$LN20@EngineRpmM:

; 2506 : 
; 2507 : 	}//end
; 2508 : 
; 2509 : 
; 2510 : 	// PW-229/GE-110/GE-129
; 2511 : 	if (auxaeroData->typeEngine == 3 || auxaeroData->typeEngine == 4 || auxaeroData->typeEngine == 5)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+3884], 3
	je	SHORT $LN18@EngineRpmM
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+3884], 4
	je	SHORT $LN18@EngineRpmM
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+3884], 5
	jne	$LN1@EngineRpmM
$LN18@EngineRpmM:

; 2512 : 	{
; 2513 : 		//Reduced Speed Excursion Logic 0.5 - 0.6 is the switch range, we'll call it 5.5 for coding
; 2514 : 		if (mach > 0.55f && mach < 1.1f)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1144]
	comiss	xmm0, DWORD PTR __real@3f0ccccd
	jbe	SHORT $LN17@EngineRpmM
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f8ccccd
	comiss	xmm0, DWORD PTR [ecx+1144]
	jbe	SHORT $LN17@EngineRpmM

; 2515 : 		{
; 2516 : 			rpmRSE = 0.79f;

	movss	xmm0, DWORD PTR __real@3f4a3d71
	movss	DWORD PTR _rpmRSE$[ebp], xmm0

; 2517 : 			rpmCmd = max (rpmCmd, rpmRSE);

	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	comiss	xmm0, DWORD PTR _rpmRSE$[ebp]
	jbe	SHORT $LN47@EngineRpmM
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR tv231[ebp], xmm0
	jmp	SHORT $LN48@EngineRpmM
$LN47@EngineRpmM:
	movss	xmm0, DWORD PTR _rpmRSE$[ebp]
	movss	DWORD PTR tv231[ebp], xmm0
$LN48@EngineRpmM:
	movss	xmm0, DWORD PTR tv231[ebp]
	movss	DWORD PTR _rpmCmd$[ebp], xmm0
	jmp	$LN13@EngineRpmM
$LN17@EngineRpmM:

; 2518 : 		}
; 2519 : 		//Idle schedule to MIL from 1.1 to 1.4 MACH
; 2520 : 		else if (mach >= 1.1f && mach <= 1.4f)

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1144]
	comiss	xmm0, DWORD PTR __real@3f8ccccd
	jb	SHORT $LN15@EngineRpmM
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fb33333
	comiss	xmm0, DWORD PTR [eax+1144]
	jb	SHORT $LN15@EngineRpmM

; 2521 : 			rpmCmd = max (mach/1.4f, rpmCmd);

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1144]
	divss	xmm0, DWORD PTR __real@3fb33333
	comiss	xmm0, DWORD PTR _rpmCmd$[ebp]
	jbe	SHORT $LN49@EngineRpmM
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1144]
	divss	xmm0, DWORD PTR __real@3fb33333
	movss	DWORD PTR tv243[ebp], xmm0
	jmp	SHORT $LN50@EngineRpmM
$LN49@EngineRpmM:
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR tv243[ebp], xmm0
$LN50@EngineRpmM:
	movss	xmm0, DWORD PTR tv243[ebp]
	movss	DWORD PTR _rpmCmd$[ebp], xmm0
	jmp	SHORT $LN13@EngineRpmM
$LN15@EngineRpmM:

; 2522 : 		else if (mach > 1.4f)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1144]
	comiss	xmm0, DWORD PTR __real@3fb33333
	jbe	SHORT $LN13@EngineRpmM

; 2523 : 			rpmCmd = max (0.99f, rpmCmd);

	movss	xmm0, DWORD PTR __real@3f7d70a4
	comiss	xmm0, DWORD PTR _rpmCmd$[ebp]
	jbe	SHORT $LN51@EngineRpmM
	movss	xmm0, DWORD PTR __real@3f7d70a4
	movss	DWORD PTR tv247[ebp], xmm0
	jmp	SHORT $LN52@EngineRpmM
$LN51@EngineRpmM:
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR tv247[ebp], xmm0
$LN52@EngineRpmM:
	movss	xmm0, DWORD PTR tv247[ebp]
	movss	DWORD PTR _rpmCmd$[ebp], xmm0
$LN13@EngineRpmM:

; 2524 : 
; 2525 : 		//Idle schedule 
; 2526 : 		//TJL -1 says that RPM increases > 10K to give sufficient stall margin
; 2527 : 		if (platform->ZPos() <= -100.0F)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv479[ebp]
	movss	xmm0, DWORD PTR __real@c2c80000
	comiss	xmm0, DWORD PTR tv479[ebp]
	jb	SHORT $LN12@EngineRpmM

; 2528 : 		{
; 2529 : 			//rpmZ = (((SqrtF(-platform->ZPos()))/2000.0F) + rpmBase);
; 2530 : 			rpmCmdZ = ((-platform->ZPos()/10000.0F)/30) + rpmCmdBase;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv485[ebp]
	movss	xmm0, DWORD PTR tv485[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	divss	xmm0, DWORD PTR __real@461c4000
	divss	xmm0, DWORD PTR __real@41f00000
	addss	xmm0, DWORD PTR _rpmCmdBase$[ebp]
	movss	DWORD PTR _rpmCmdZ$[ebp], xmm0

; 2531 : 			rpmCmd = max (rpmCmdZ, rpmCmd);

	movss	xmm0, DWORD PTR _rpmCmdZ$[ebp]
	comiss	xmm0, DWORD PTR _rpmCmd$[ebp]
	jbe	SHORT $LN53@EngineRpmM
	movss	xmm0, DWORD PTR _rpmCmdZ$[ebp]
	movss	DWORD PTR tv270[ebp], xmm0
	jmp	SHORT $LN54@EngineRpmM
$LN53@EngineRpmM:
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR tv270[ebp], xmm0
$LN54@EngineRpmM:
	movss	xmm0, DWORD PTR tv270[ebp]
	movss	DWORD PTR _rpmCmd$[ebp], xmm0
$LN12@EngineRpmM:

; 2532 : 		}
; 2533 : 
; 2534 : 		//Reduce AB schedule
; 2535 : 		if ((platform->ZPos() < -50000.0F) && vcas < 250.0F)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv494[ebp]
	movss	xmm0, DWORD PTR __real@c7435000
	comiss	xmm0, DWORD PTR tv494[ebp]
	jbe	SHORT $LN11@EngineRpmM
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@437a0000
	comiss	xmm0, DWORD PTR [ecx+1124]
	jbe	SHORT $LN11@EngineRpmM

; 2536 : 		{
; 2537 : 			rpmCmd = min (1.01f, rpmCmd);

	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	comiss	xmm0, DWORD PTR __real@3f8147ae
	jbe	SHORT $LN55@EngineRpmM
	movss	xmm0, DWORD PTR __real@3f8147ae
	movss	DWORD PTR tv282[ebp], xmm0
	jmp	SHORT $LN56@EngineRpmM
$LN55@EngineRpmM:
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR tv282[ebp], xmm0
$LN56@EngineRpmM:
	movss	xmm0, DWORD PTR tv282[ebp]
	movss	DWORD PTR _rpmCmd$[ebp], xmm0
$LN11@EngineRpmM:

; 2538 : 		}
; 2539 : 
; 2540 : 			
; 2541 : 		//Zone 2 AB no lights or delayed lights possible
; 2542 : 		if ((platform->ZPos() < -30000.0F) && vcas < 225.0F)

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv506[ebp]
	movss	xmm0, DWORD PTR __real@c6ea6000
	comiss	xmm0, DWORD PTR tv506[ebp]
	jbe	SHORT $LN10@EngineRpmM
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@43610000
	comiss	xmm0, DWORD PTR [eax+1124]
	jbe	SHORT $LN10@EngineRpmM

; 2543 : 		{
; 2544 : 		//	if ((SimLibElapsedTime - engEventTimer) >= 5000)
; 2545 : 			if (rpm <= 1.0F && engFlag1 == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR [ecx+1212]
	jb	SHORT $LN5@EngineRpmM
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+236], 0
	jne	SHORT $LN5@EngineRpmM

; 2546 : 			{
; 2547 : 				int randnum = rand()%100;

	call	_rand
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _randnum$1[ebp], edx

; 2548 : 				if (randnum == 1)

	cmp	DWORD PTR _randnum$1[ebp], 1
	jne	SHORT $LN8@EngineRpmM

; 2549 : 					engFlag1 = 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+236], 1
	jmp	SHORT $LN5@EngineRpmM
$LN8@EngineRpmM:

; 2550 : 
; 2551 : 				else if (randnum == 2)

	cmp	DWORD PTR _randnum$1[ebp], 2
	jne	SHORT $LN6@EngineRpmM

; 2552 : 					engFlag1 = 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+236], 2

; 2553 : 				else

	jmp	SHORT $LN5@EngineRpmM
$LN6@EngineRpmM:

; 2554 : 					engFlag1 = 3;//this stops the loop

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+236], 3
$LN5@EngineRpmM:

; 2555 : 
; 2556 : 			}
; 2557 : 
; 2558 : 		}
; 2559 : 		else

	jmp	SHORT $LN4@EngineRpmM
$LN10@EngineRpmM:

; 2560 : 			//Reset flag when out of condition
; 2561 : 			engFlag1 = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+236], 0
$LN4@EngineRpmM:

; 2562 : 
; 2563 : 		//AB no light
; 2564 : 		if (engFlag1 == 1)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+236], 1
	jne	SHORT $LN3@EngineRpmM

; 2565 : 			rpmCmd = min (0.99f, rpmCmd);

	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	comiss	xmm0, DWORD PTR __real@3f7d70a4
	jbe	SHORT $LN57@EngineRpmM
	movss	xmm0, DWORD PTR __real@3f7d70a4
	movss	DWORD PTR tv308[ebp], xmm0
	jmp	SHORT $LN58@EngineRpmM
$LN57@EngineRpmM:
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR tv308[ebp], xmm0
$LN58@EngineRpmM:
	movss	xmm0, DWORD PTR tv308[ebp]
	movss	DWORD PTR _rpmCmd$[ebp], xmm0
	jmp	SHORT $LN1@EngineRpmM
$LN3@EngineRpmM:

; 2566 : 		//AB partial light
; 2567 : 		else if (engFlag1 == 2)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+236], 2
	jne	SHORT $LN1@EngineRpmM

; 2568 : 			rpmCmd = min (1.01f, rpmCmd);

	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	comiss	xmm0, DWORD PTR __real@3f8147ae
	jbe	SHORT $LN59@EngineRpmM
	movss	xmm0, DWORD PTR __real@3f8147ae
	movss	DWORD PTR tv312[ebp], xmm0
	jmp	SHORT $LN60@EngineRpmM
$LN59@EngineRpmM:
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR tv312[ebp], xmm0
$LN60@EngineRpmM:
	movss	xmm0, DWORD PTR tv312[ebp]
	movss	DWORD PTR _rpmCmd$[ebp], xmm0
$LN1@EngineRpmM:

; 2569 : 
; 2570 : 
; 2571 : 	}
; 2572 : 
; 2573 : 
; 2574 : 
; 2575 : 
; 2576 : 	return rpmCmd;

	fld	DWORD PTR _rpmCmd$[ebp]

; 2577 : 
; 2578 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?EngineRpmMods@AirframeClass@@QAEMM@Z ENDP		; AirframeClass::EngineRpmMods
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\airframe\engine.cpp
_TEXT	SEGMENT
$T2 = -404						; size = 8
$T3 = -396						; size = 8
$T4 = -388						; size = 8
$T5 = -380						; size = 8
$T6 = -372						; size = 8
$T7 = -364						; size = 8
_noz$8 = -356						; size = 8
_fflow2$9 = -348					; size = 4
tv3378 = -344						; size = 4
$T10 = -340						; size = 4
tv3435 = -336						; size = 4
$T11 = -332						; size = 4
tv3469 = -328						; size = 4
tv3222 = -324						; size = 4
tv4250 = -320						; size = 4
tv2724 = -316						; size = 4
_fuelFlowTotal$ = -312					; size = 4
tv3528 = -308						; size = 4
tv4178 = -304						; size = 4
tv4389 = -300						; size = 4
tv4167 = -296						; size = 4
tv3424 = -292						; size = 4
tv4121 = -288						; size = 4
tv4387 = -284						; size = 4
tv4391 = -280						; size = 4
_fflow2$12 = -276					; size = 4
_fflow2$13 = -272					; size = 4
tv2912 = -268						; size = 4
_fflow2$14 = -264					; size = 4
tv2783 = -260						; size = 4
tv3965 = -256						; size = 4
tv4385 = -252						; size = 4
tv3657 = -248						; size = 4
tv2657 = -244						; size = 4
tv373 = -240						; size = 4
_fflow1$15 = -236					; size = 4
_fflow1$16 = -232					; size = 4
tv577 = -228						; size = 4
tv1867 = -224						; size = 4
tv635 = -220						; size = 4
tv1742 = -216						; size = 4
tv436 = -212						; size = 4
tv1646 = -208						; size = 4
tv856 = -204						; size = 4
tv1605 = -200						; size = 4
tv591 = -196						; size = 4
tv1604 = -192						; size = 4
tv569 = -188						; size = 4
tv1597 = -184						; size = 4
tv424 = -180						; size = 4
tv1590 = -176						; size = 4
_fflow1$17 = -172					; size = 4
tv1589 = -168						; size = 4
tv731 = -164						; size = 4
tv1582 = -160						; size = 4
tv592 = -156						; size = 4
tv212 = -152						; size = 4
tv584 = -148						; size = 4
tv1417 = -144						; size = 4
tv576 = -140						; size = 4
$T18 = -136						; size = 4
tv461 = -132						; size = 4
tv1405 = -128						; size = 4
$T19 = -124						; size = 4
tv1378 = -120						; size = 4
tv397 = -116						; size = 4
tv1354 = -112						; size = 4
_fflow1$20 = -108					; size = 4
tv1474 = -104						; size = 4
_modRpm2$21 = -100					; size = 4
_modRpm$22 = -96					; size = 4
_thrtb2$ = -92						; size = 4
_modRpm$23 = -88					; size = 4
_th22$ = -84						; size = 4
_th2$ = -80						; size = 4
_modRpm2$24 = -76					; size = 4
_thrtb1$ = -72						; size = 4
_aburnLit2$ = -68					; size = 4
_aburnLit$ = -64					; size = 4
_th12$ = -60						; size = 4
_th1$ = -56						; size = 4
_spoolAltRate$ = -52					; size = 4
_tgross2$ = -48						; size = 4
_tgross$ = -44						; size = 4
_spoolrate2$ = -40					; size = 4
_spoolrate$ = -36					; size = 4
_rpmCmd2$ = -32						; size = 4
_rpmCmd$ = -28						; size = 4
_message$25 = -24					; size = 4
_message$26 = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_dt$ = 8						; size = 4
?MultiEngineModel@AirframeClass@@QAEXM@Z PROC		; AirframeClass::MultiEngineModel
; _this$ = ecx

; 769  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?MultiEngineModel@AirframeClass@@QAEXM@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 392				; 00000188H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 770  : 	float th1, th2, th12, th22;
; 771  : 	float thrtb1, thrtb2;
; 772  : 	float tgross, tgross2;
; 773  : 	//float fuelFlowSS;
; 774  : 	//float fuelFlowSS2;//Engine 2
; 775  : 	float fuelFlowTotal;
; 776  : 	//float ta01, rpmCmd; TJL 08/21/04 ta01 and ta02 no longer used
; 777  : 	float rpmCmd;
; 778  : 	float rpmCmd2;
; 779  : 	//float ta02, rpmCmd2;//Engine 2
; 780  : 	int aburnLit = FALSE;

	mov	DWORD PTR _aburnLit$[ebp], 0

; 781  : 	int aburnLit2 = FALSE;

	mov	DWORD PTR _aburnLit2$[ebp], 0

; 782  : 	float spoolrate = auxaeroData->normSpoolRate;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movss	xmm0, DWORD PTR [ecx+12]
	movss	DWORD PTR _spoolrate$[ebp], xmm0

; 783  : 	float spoolrate2 = auxaeroData->normSpoolRate;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	movss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR _spoolrate2$[ebp], xmm0

; 784  : 	//TJL 02/22/04 
; 785  : 	float spoolAltRate = (-platform->ZPos()/25000.0f) + (-mach/2.0F);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv2657[ebp]
	movss	xmm0, DWORD PTR tv2657[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	divss	xmm0, DWORD PTR __real@46c35000
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+1144]
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	divss	xmm1, DWORD PTR __real@40000000
	addss	xmm0, xmm1
	movss	DWORD PTR _spoolAltRate$[ebp], xmm0

; 786  : 
; 787  : //***********************************************
; 788  : 	// #1
; 789  :     // JPO should we switch on the EPU ?
; 790  :     if (epuFuel > 0.0f) //only relevant if there is fuel

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+36]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN159@MultiEngin

; 791  : 	{ 
; 792  : 		if (GetEpuSwitch() == ON) 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetEpuSwitch@AirframeClass@@QAE?AW4EpuState@1@XZ ; AirframeClass::GetEpuSwitch
	cmp	eax, 2
	jne	SHORT $LN158@MultiEngin

; 793  : 		{// pilot command
; 794  : 			GeneratorOn(GenEpu);

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GeneratorOn@AirframeClass@@QAEXW4Generator@1@@Z ; AirframeClass::GeneratorOn
	jmp	SHORT $LN153@MultiEngin
$LN158@MultiEngin:

; 795  : 		} 
; 796  : 		// auto mode
; 797  : 		else if (!GeneratorRunning(GenMain) && !GeneratorRunning(GenStdby) && IsSet(InAir)) {

	push	1024					; 00000400H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GeneratorRunning@AirframeClass@@QAEHW4Generator@1@@Z ; AirframeClass::GeneratorRunning
	test	eax, eax
	jne	SHORT $LN156@MultiEngin
	push	64					; 00000040H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GeneratorRunning@AirframeClass@@QAEHW4Generator@1@@Z ; AirframeClass::GeneratorRunning
	test	eax, eax
	jne	SHORT $LN156@MultiEngin
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN156@MultiEngin

; 798  : 			GeneratorOn(GenEpu);

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GeneratorOn@AirframeClass@@QAEXW4Generator@1@@Z ; AirframeClass::GeneratorOn
	jmp	SHORT $LN153@MultiEngin
$LN156@MultiEngin:

; 799  : 		}
; 800  : 		else if (GetEpuSwitch() == OFF) 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetEpuSwitch@AirframeClass@@QAE?AW4EpuState@1@XZ ; AirframeClass::GetEpuSwitch
	test	eax, eax
	jne	SHORT $LN154@MultiEngin

; 801  : 		{
; 802  : 			GeneratorOff(GenEpu);

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GeneratorOff@AirframeClass@@QAEXW4Generator@1@@Z ; AirframeClass::GeneratorOff

; 803  : 			EpuClear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?EpuClear@AirframeClass@@QAEXXZ		; AirframeClass::EpuClear

; 804  : 		}
; 805  : 		else 

	jmp	SHORT $LN153@MultiEngin
$LN154@MultiEngin:

; 806  : 		{
; 807  : 			GeneratorOff(GenEpu);

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GeneratorOff@AirframeClass@@QAEXW4Generator@1@@Z ; AirframeClass::GeneratorOff

; 808  : 			EpuClear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?EpuClear@AirframeClass@@QAEXXZ		; AirframeClass::EpuClear
$LN153@MultiEngin:

; 809  : 		}
; 810  : 	}
; 811  : 	else 

	jmp	SHORT $LN152@MultiEngin
$LN159@MultiEngin:

; 812  : 	{
; 813  : 		GeneratorOff(GenEpu);

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GeneratorOff@AirframeClass@@QAEXW4Generator@1@@Z ; AirframeClass::GeneratorOff

; 814  : 		EpuClear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?EpuClear@AirframeClass@@QAEXXZ		; AirframeClass::EpuClear
$LN152@MultiEngin:

; 815  : 	}
; 816  : 
; 817  : //*****************************************************
; 818  : 	// #2
; 819  :     // check hydraulics and generators 
; 820  :     if (GeneratorRunning(GenMain) || GeneratorRunning(GenStdby)) {

	push	1024					; 00000400H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GeneratorRunning@AirframeClass@@QAEHW4Generator@1@@Z ; AirframeClass::GeneratorRunning
	test	eax, eax
	jne	SHORT $LN150@MultiEngin
	push	64					; 00000040H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GeneratorRunning@AirframeClass@@QAEHW4Generator@1@@Z ; AirframeClass::GeneratorRunning
	test	eax, eax
	je	SHORT $LN151@MultiEngin
$LN150@MultiEngin:

; 821  : 		HydrRestore(HYDR_ALL); // restore those systems we can

	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HydrRestore@AirframeClass@@QAEXH@Z	; AirframeClass::HydrRestore
	jmp	SHORT $LN147@MultiEngin
$LN151@MultiEngin:

; 822  :     }
; 823  :     else if (GeneratorRunning(GenEpu)) {

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GeneratorRunning@AirframeClass@@QAEHW4Generator@1@@Z ; AirframeClass::GeneratorRunning
	test	eax, eax
	je	SHORT $LN148@MultiEngin

; 824  : 		HydrDown (HYDR_B_SYSTEM); // B system now dead

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HydrDown@AirframeClass@@QAEXH@Z	; AirframeClass::HydrDown

; 825  : 		HydrRestore(HYDR_A_SYSTEM); // A still OK

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HydrRestore@AirframeClass@@QAEXH@Z	; AirframeClass::HydrRestore

; 826  :     }
; 827  :     else {

	jmp	SHORT $LN147@MultiEngin
$LN148@MultiEngin:

; 828  : 		HydrDown(HYDR_ALL); // all off

	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HydrDown@AirframeClass@@QAEXH@Z	; AirframeClass::HydrDown
$LN147@MultiEngin:

; 829  :     }
; 830  : 
; 831  : //********************************************************
; 832  : 	// #3
; 833  :     // JPO - if the epu is running - well its running!
; 834  :     // this may be independant of the engine if the pilot wants to check
; 835  :     if (GeneratorRunning(GenEpu)) {

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GeneratorRunning@AirframeClass@@QAEHW4Generator@1@@Z ; AirframeClass::GeneratorRunning
	test	eax, eax
	je	$LN146@MultiEngin

; 836  : 		EpuClear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?EpuClear@AirframeClass@@QAEXXZ		; AirframeClass::EpuClear

; 837  : 		// below 80%rpm, epu burns fuel.
; 838  : 		if (rpm < 0.80f) {

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f4ccccd
	comiss	xmm0, DWORD PTR [ecx+1212]
	jbe	SHORT $LN144@MultiEngin

; 839  : 			EpuSetHydrazine();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?EpuSetHydrazine@AirframeClass@@QAEXXZ	; AirframeClass::EpuSetHydrazine

; 840  : 			epuFuel -= 100.0f * dt / auxaeroData->epuBurnTime; // burn some hydrazine

	movss	xmm0, DWORD PTR __real@42c80000
	mulss	xmm0, DWORD PTR _dt$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	divss	xmm0, DWORD PTR [eax+52]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+36]
	subss	xmm1, xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+36], xmm1

; 841  : 			if (epuFuel <= 0.0f) {

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [eax+36]
	jb	SHORT $LN144@MultiEngin

; 842  : 				epuFuel = 0.0;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+36], xmm0

; 843  : 				GeneratorBreak(GenEpu); // well not broken, but done for.

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GeneratorBreak@AirframeClass@@QAEXW4Generator@1@@Z ; AirframeClass::GeneratorBreak

; 844  : 				GeneratorOff(GenEpu);

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GeneratorOff@AirframeClass@@QAEXW4Generator@1@@Z ; AirframeClass::GeneratorOff
$LN144@MultiEngin:

; 845  : 			}
; 846  : 		}
; 847  : 		EpuSetAir(); // always true, means running really.

	mov	ecx, DWORD PTR _this$[ebp]
	call	?EpuSetAir@AirframeClass@@QAEXXZ	; AirframeClass::EpuSetAir
$LN146@MultiEngin:

; 848  :     }
; 849  : 	
; 850  : //*****************************************************
; 851  : 	// #4
; 852  :     // JPO: charge the JFS accumulators, up to 100% 
; 853  :     if (rpm > auxaeroData->jfsMinRechargeRpm && jfsaccumulator < 100.0f /* 2002-04-11 ADDED BY S.G. If less than 0, don't recharge */ && jfsaccumulator >= 0.0f ) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1212]
	comiss	xmm0, DWORD PTR [eax+40]
	jbe	$LN143@MultiEngin
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@42c80000
	comiss	xmm0, DWORD PTR [edx+1604]
	jbe	$LN143@MultiEngin
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1604]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN143@MultiEngin

; 854  : 		jfsaccumulator += 100.0f * dt / auxaeroData->jfsRechargeTime;

	movss	xmm0, DWORD PTR __real@42c80000
	mulss	xmm0, DWORD PTR _dt$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	divss	xmm0, DWORD PTR [edx+36]
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+1604]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+1604], xmm0

; 855  : 		jfsaccumulator = min(jfsaccumulator, 100.0f);

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@42c80000
	comiss	xmm0, DWORD PTR [edx+1604]
	jbe	SHORT $LN162@MultiEngin
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1604]
	movss	DWORD PTR tv212[ebp], xmm0
	jmp	SHORT $LN163@MultiEngin
$LN162@MultiEngin:
	movss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR tv212[ebp], xmm0
$LN163@MultiEngin:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv212[ebp]
	movss	DWORD PTR [ecx+1604], xmm0
$LN143@MultiEngin:

; 856  :     }
; 857  : 
; 858  : //*****************************************************
; 859  : 	// #5
; 860  :     // transfer fuel
; 861  :     FuelTransfer(dt);

	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FuelTransfer@AirframeClass@@QAEXM@Z	; AirframeClass::FuelTransfer

; 862  : 	
; 863  : #if 0 // not ready yet.JPO, but basically it should work as normal, but ignore the throttle.
; 864  :     if (IsSet(ThrottleCheck)) {
; 865  : 		rpm      = oldRpm[0]; // just remember where we were... JPO
; 866  : 		if(throtl >= 1.5F)
; 867  : 			throtl = pwrlev;
; 868  : 		if (fabs (throtl - pwrlev) > 0.1F)
; 869  : 			ClearFlag(ThrottleCheck);
; 870  : 		pwrlev = throtl;
; 871  :     }
; 872  :     else
; 873  :     {
; 874  : 		if (fabs (throtl - pwrlev) > 0.1F)
; 875  :             ClearFlag (EngineOff);
; 876  :     }
; 877  : #endif
; 878  : 	
; 879  : //*****************************************************
; 880  : 	//#6 Engine 1 left
; 881  :     if (IsSet(EngineStopped))

	push	134217728				; 08000000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	$LN142@MultiEngin

; 882  : 	{
; 883  : 		ftit = Math.FLTust(0.0f, 20.0f, dt, oldFtit); // cool down the engine

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1620				; 00000654H
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@41a00000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?FLTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z	; SIMLIB_MATH_CLASS::FLTust
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+1668]

; 884  : 		float modRpm = (float)(rpm*rpm*rpm*rpm*sqrt(rpm));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1212]
	mulss	xmm0, DWORD PTR [edx+1212]
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [eax+1212]
	mov	ecx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [ecx+1212]
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm1, DWORD PTR [edx+1212]
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv4385[ebp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR tv2724[ebp]
	movss	xmm0, DWORD PTR tv4385[ebp]
	mulss	xmm0, DWORD PTR tv2724[ebp]
	movss	DWORD PTR _modRpm$22[ebp], xmm0

; 885  : 		
; 886  : 		// Am I increasing the rpm (but not yet in afterburner)?
; 887  : 		if (rpm > oldp01[0])

	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1212]
	comiss	xmm0, DWORD PTR [edx+eax+284]
	jbe	SHORT $LN141@MultiEngin

; 888  : 			Math.FLTust (modRpm, 4.0F, dt, oldp01);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 284				; 0000011cH
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@40800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _modRpm$22[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?FLTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z	; SIMLIB_MATH_CLASS::FLTust
	fstp	ST(0)

; 889  : 		// Must be decreasing then...
; 890  : 		else

	jmp	$LN138@MultiEngin
$LN141@MultiEngin:

; 891  : 		{
; 892  : 			// Now check if the 'heat' is still above 1.00 (100%)
; 893  : 			if (oldp01[0] > 1.0F)

	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+284]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN139@MultiEngin

; 894  : 				Math.FLTust (modRpm, 7.0F, dt, oldp01);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 284				; 0000011cH
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@40e00000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _modRpm$22[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?FLTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z	; SIMLIB_MATH_CLASS::FLTust
	fstp	ST(0)

; 895  : 			else

	jmp	SHORT $LN138@MultiEngin
$LN139@MultiEngin:

; 896  : 				Math.FLTust (modRpm, 2.0F, dt, oldp01);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 284				; 0000011cH
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _modRpm$22[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?FLTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z	; SIMLIB_MATH_CLASS::FLTust
	fstp	ST(0)
$LN138@MultiEngin:

; 897  : 		}
; 898  : 		
; 899  : 		
; 900  : 		spoolrate = auxaeroData->flameoutSpoolRate; // spool down rate

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	movss	xmm0, DWORD PTR [eax+32]
	movss	DWORD PTR _spoolrate$[ebp], xmm0

; 901  : 		fireTimer = 0.0f; // reset - engine is switched off

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _fireTimer, xmm0

; 902  : 		// switch all to 0.
; 903  : 		tgross = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _tgross$[ebp], xmm0

; 904  : 		fuelFlow = fuelFlowSS = 0.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+96], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+24], xmm0

; 905  : 		thrtab = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+184], xmm0

; 906  : 		thrust = 0.0f; //Engine 1 Left

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+188], xmm0

; 907  : 
; 908  : 		
; 909  : 		// broken engine - anything but a flame out?
; 910  : 		if((platform->mFaults->GetFault(FaultClass::eng_fault) & ~FaultClass::fl_out) != 0) {

	push	8
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1088]
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFault@FackClass@@QAEHW4type_FSubSystem@FaultClass@@@Z ; FackClass::GetFault
	and	eax, 2147483647				; 7fffffffH
	je	SHORT $LN137@MultiEngin

; 911  : 			rpmCmd = 0.0f; // engine must be seized, not going to start or windmill

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _rpmCmd$[ebp], xmm0
	jmp	$LN133@MultiEngin
$LN137@MultiEngin:

; 912  : 		}
; 913  : 		//else if (IsSet (JfsStart))
; 914  : 		else if (IsSet (JfsStart) && UserStickInputs.getCurrentEngine() == UserStickInputs.Left_Engine)

	push	268435456				; 10000000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN135@MultiEngin
	mov	ecx, OFFSET ?UserStickInputs@@3VPilotInputs@@A ; UserStickInputs
	call	?getCurrentEngine@PilotInputs@@QAE?AW4Engine_t@1@XZ ; PilotInputs::getCurrentEngine
	test	eax, eax
	jne	SHORT $LN135@MultiEngin

; 915  : 		{
; 916  : 			rpmCmd = 0.25f; // JFS should take us up to 25%

	movss	xmm0, DWORD PTR __real@3e800000
	movss	DWORD PTR _rpmCmd$[ebp], xmm0

; 917  : 			spoolrate = 15.0f;

	movss	xmm0, DWORD PTR __real@41700000
	movss	DWORD PTR _spoolrate$[ebp], xmm0

; 918  : 			//decrease spin time
; 919  : 			JFSSpinTime -= SimLibMajorFrameTime;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1608]
	subss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+1608], xmm0

; 920  : 			if(JFSSpinTime <= 0)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [eax+1608]
	jb	SHORT $LN134@MultiEngin

; 921  : 				ClearFlag(JfsStart);

	push	268435456				; 10000000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearFlag@AirframeClass@@QAEXH@Z	; AirframeClass::ClearFlag
$LN134@MultiEngin:

; 922  : 		}
; 923  : 		else { // engine windmill (~12% at 450 knts) (me123 - this works on mine)

	jmp	SHORT $LN133@MultiEngin
$LN135@MultiEngin:

; 924  : 			rpmCmd = (platform->GetKias() / 450.0f) * 0.12f;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1088]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+1088]
	mov	eax, DWORD PTR [edx+224]
	call	eax
	fstp	DWORD PTR tv2783[ebp]
	movss	xmm0, DWORD PTR tv2783[ebp]
	divss	xmm0, DWORD PTR __real@43e10000
	mulss	xmm0, DWORD PTR __real@3df5c28f
	movss	DWORD PTR _rpmCmd$[ebp], xmm0
$LN133@MultiEngin:

; 925  : 		}
; 926  : 		
; 927  : 		// attempt to spool up/down
; 928  : 		rpm = Math.FLTust (rpmCmd, spoolrate, dt, oldRpm);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 500				; 000001f4H
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _spoolrate$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?FLTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z	; SIMLIB_MATH_CLASS::FLTust
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+1212]
	jmp	$LN85@MultiEngin
$LN142@MultiEngin:

; 929  :     }
; 930  : 
; 931  : //*****************************************************
; 932  : 	//#7 More shut down conditions
; 933  :     else if (!IsSet(EngineOff))

	push	32768					; 00008000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	jne	$LN131@MultiEngin

; 934  : 	
; 935  :     {
; 936  : 		//7.1 Engine flame out, shut down
; 937  : 		if(platform->mFaults->GetFault(FaultClass::eng_fault) & FaultClass::fl_out) {

	push	8
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	mov	ecx, DWORD PTR [ecx+928]
	call	?GetFault@FackClass@@QAEHW4type_FSubSystem@FaultClass@@@Z ; FackClass::GetFault
	and	eax, -2147483648			; 80000000H
	je	SHORT $LN130@MultiEngin

; 938  : 			SetFlag(EngineStopped);

	push	134217728				; 08000000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFlag@AirframeClass@@QAEXH@Z		; AirframeClass::SetFlag

; 939  : 			engine1Throttle = 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+1520], xmm0
$LN130@MultiEngin:

; 940  : 		}
; 941  : 
; 942  : 		//need to recombine these later
; 943  : 		pwrlevEngine1 = engine1Throttle;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1520]
	mov	DWORD PTR [eax+1528], edx

; 944  : 		
; 945  : 		//7.2 Deep Stall Flameout
; 946  : 		if(auxaeroData->DeepStallEngineStall)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+60], 0
	je	SHORT $LN128@MultiEngin

; 947  : 		{
; 948  : 			//me123 if in deep stall and in ab lets stall the engine
; 949  : 			// JPO - 10% chance, each time we check...
; 950  : 			if (stallMode >= DeepStall && pwrlevEngine1 >= 1.0F && rand() % 10 == 1)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1248], 4
	jl	SHORT $LN128@MultiEngin
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1528]
	comiss	xmm0, DWORD PTR __real@3f800000
	jb	SHORT $LN128@MultiEngin
	call	_rand
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	cmp	edx, 1
	jne	SHORT $LN128@MultiEngin

; 951  : 			{ 
; 952  : 				SetFlag(EngineStopped);

	push	134217728				; 08000000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFlag@AirframeClass@@QAEXH@Z		; AirframeClass::SetFlag

; 953  : 				// mark it as a flame out
; 954  : 				platform->mFaults->SetFault(FaultClass::eng_fault, FaultClass::fl_out, FaultClass::fail, FALSE);

	push	0
	push	2
	push	-2147483648				; 80000000H
	push	8
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1088]
	mov	ecx, DWORD PTR [eax+928]
	call	?SetFault@FackClass@@QAEXW4type_FSubSystem@FaultClass@@W4type_FFunction@3@W4type_FSeverity@3@H@Z ; FackClass::SetFault
$LN128@MultiEngin:

; 955  : 			}
; 956  : 		}
; 957  : 		
; 958  : 		//7.3 Flying
; 959  : 		if (platform->IsSetFlag(MOTION_OWNSHIP))

	push	65536					; 00010000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1088]
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN122@MultiEngin

; 960  : 		{
; 961  : 			//7.3.1 Lost AB
; 962  : 			//TODO Make Engine 2 Faults
; 963  : 			if (platform->mFaults->GetFault(FaultClass::eng_fault) & FaultClass::a_b)

	push	8
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1088]
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFault@FackClass@@QAEHW4type_FSubSystem@FaultClass@@@Z ; FackClass::GetFault
	and	eax, 4096				; 00001000H
	je	SHORT $LN126@MultiEngin

; 964  : 			{
; 965  : 				pwrlevEngine1 = min (engine1Throttle, 0.99F);

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f7d70a4
	comiss	xmm0, DWORD PTR [ecx+1520]
	jbe	SHORT $LN164@MultiEngin
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1520]
	movss	DWORD PTR tv373[ebp], xmm0
	jmp	SHORT $LN165@MultiEngin
$LN164@MultiEngin:
	movss	xmm0, DWORD PTR __real@3f7d70a4
	movss	DWORD PTR tv373[ebp], xmm0
$LN165@MultiEngin:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv373[ebp]
	movss	DWORD PTR [eax+1528], xmm0
$LN126@MultiEngin:

; 966  : 			}
; 967  : 
; 968  : 			//7.3.2 Engine Fire
; 969  : 			if ((platform->mFaults->GetFault(FaultClass::eng_fault) & FaultClass::efire))

	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1088]
	mov	ecx, DWORD PTR [edx+928]
	call	?GetFault@FackClass@@QAEHW4type_FSubSystem@FaultClass@@@Z ; FackClass::GetFault
	and	eax, 16384				; 00004000H
	je	$LN122@MultiEngin

; 970  : 			{
; 971  : 				//Engine 1
; 972  : 				if (platform->mFaults->GetFault(FaultClass::eng_fault) & FaultClass::efire)

	push	8
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	mov	ecx, DWORD PTR [ecx+928]
	call	?GetFault@FackClass@@QAEHW4type_FSubSystem@FaultClass@@@Z ; FackClass::GetFault
	and	eax, 16384				; 00004000H
	je	SHORT $LN123@MultiEngin

; 973  : 				{
; 974  : 					pwrlevEngine1 *= 0.5F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1528]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+1528], xmm0

; 975  : 					if (fireTimer >= 0.0F)

	movss	xmm0, DWORD PTR _fireTimer
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN123@MultiEngin

; 976  : 						fireTimer += max (pwrlevEngine1, 0.3F) * dt;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1528]
	comiss	xmm0, DWORD PTR __real@3e99999a
	jbe	SHORT $LN166@MultiEngin
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1528]
	movss	DWORD PTR tv397[ebp], xmm0
	jmp	SHORT $LN167@MultiEngin
$LN166@MultiEngin:
	movss	xmm0, DWORD PTR __real@3e99999a
	movss	DWORD PTR tv397[ebp], xmm0
$LN167@MultiEngin:
	movss	xmm0, DWORD PTR tv397[ebp]
	mulss	xmm0, DWORD PTR _dt$[ebp]
	addss	xmm0, DWORD PTR _fireTimer
	movss	DWORD PTR _fireTimer, xmm0
$LN123@MultiEngin:

; 977  : 				}
; 978  : 				
; 979  : 				
; 980  : 				// On fire long enough, blow up
; 981  : 				if (fireTimer > 60.0F) // 60 seconds at mil power

	movss	xmm0, DWORD PTR _fireTimer
	comiss	xmm0, DWORD PTR __real@42700000
	jbe	$LN122@MultiEngin

; 982  : 				{
; 983  : 					fireTimer = -1.0F;

	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _fireTimer, xmm0

; 984  : 					FalconDamageMessage* message;
; 985  : 					message = new FalconDamageMessage (platform->Id(), FalconLocalGame );

	push	98					; 00000062H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T19[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T19[ebp], 0
	je	SHORT $LN170@MultiEngin
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN168@MultiEngin
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv424[ebp], eax
	jmp	SHORT $LN169@MultiEngin
$LN168@MultiEngin:
	mov	DWORD PTR tv424[ebp], 0
$LN169@MultiEngin:
	push	1
	mov	ecx, DWORD PTR tv424[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR $T19[ebp]
	call	??0FalconDamageMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z ; FalconDamageMessage::FalconDamageMessage
	mov	DWORD PTR tv436[ebp], eax
	jmp	SHORT $LN171@MultiEngin
$LN170@MultiEngin:
	mov	DWORD PTR tv436[ebp], 0
$LN171@MultiEngin:
	mov	eax, DWORD PTR tv436[ebp]
	mov	DWORD PTR $T10[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T10[ebp]
	mov	DWORD PTR _message$26[ebp], ecx

; 986  : 					message->dataBlock.fEntityID  = platform->Id();

	lea	edx, DWORD PTR $T5[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _message$26[ebp]
	mov	DWORD PTR [eax+74], ecx
	mov	DWORD PTR [eax+78], edx

; 987  : 					
; 988  : 					message->dataBlock.fCampID = platform->GetCampaignObject()->GetCampID();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1088]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	DWORD PTR tv461[ebp], eax
	mov	edx, DWORD PTR tv461[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv461[ebp]
	mov	edx, DWORD PTR [eax+112]
	call	edx
	mov	ecx, DWORD PTR _message$26[ebp]
	mov	WORD PTR [ecx+82], ax

; 989  : 					message->dataBlock.fSide   = platform->GetCampaignObject()->GetOwner();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1088]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetOwner@CampBaseClass@@QAEEXZ		; CampBaseClass::GetOwner
	mov	ecx, DWORD PTR _message$26[ebp]
	mov	BYTE PTR [ecx+87], al

; 990  : 					message->dataBlock.fPilotID   = ((AircraftClass*)platform)->pilotSlot;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1088]
	mov	ecx, DWORD PTR _message$26[ebp]
	mov	dl, BYTE PTR [eax+665]
	mov	BYTE PTR [ecx+84], dl

; 991  : 					message->dataBlock.fIndex     = platform->Type();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	call	?Type@VuEntity@@QBEGXZ			; VuEntity::Type
	mov	ecx, DWORD PTR _message$26[ebp]
	mov	WORD PTR [ecx+85], ax

; 992  : 					message->dataBlock.fWeaponID  = platform->Type();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1088]
	call	?Type@VuEntity@@QBEGXZ			; VuEntity::Type
	mov	ecx, DWORD PTR _message$26[ebp]
	mov	WORD PTR [ecx+88], ax

; 993  : 					message->dataBlock.fWeaponUID = platform->Id();

	lea	edx, DWORD PTR $T7[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _message$26[ebp]
	mov	DWORD PTR [eax+90], ecx
	mov	DWORD PTR [eax+94], edx

; 994  : 					message->dataBlock.dEntityID  = message->dataBlock.fEntityID;

	mov	ecx, DWORD PTR _message$26[ebp]
	mov	edx, DWORD PTR [ecx+74]
	mov	eax, DWORD PTR [ecx+78]
	mov	ecx, DWORD PTR _message$26[ebp]
	mov	DWORD PTR [ecx+60], edx
	mov	DWORD PTR [ecx+64], eax

; 995  : 					message->dataBlock.dCampID = message->dataBlock.fCampID;

	mov	edx, DWORD PTR _message$26[ebp]
	mov	eax, DWORD PTR _message$26[ebp]
	mov	cx, WORD PTR [eax+82]
	mov	WORD PTR [edx+68], cx

; 996  : 					message->dataBlock.dSide   = message->dataBlock.fSide;

	mov	edx, DWORD PTR _message$26[ebp]
	mov	eax, DWORD PTR _message$26[ebp]
	mov	cl, BYTE PTR [eax+87]
	mov	BYTE PTR [edx+73], cl

; 997  : 					message->dataBlock.dPilotID   = message->dataBlock.fPilotID;

	mov	edx, DWORD PTR _message$26[ebp]
	mov	eax, DWORD PTR _message$26[ebp]
	mov	cl, BYTE PTR [eax+84]
	mov	BYTE PTR [edx+70], cl

; 998  : 					message->dataBlock.dIndex     = message->dataBlock.fIndex;

	mov	edx, DWORD PTR _message$26[ebp]
	mov	eax, DWORD PTR _message$26[ebp]
	mov	cx, WORD PTR [eax+85]
	mov	WORD PTR [edx+71], cx

; 999  : 					message->dataBlock.damageType = FalconDamageType::CollisionDamage;

	mov	edx, DWORD PTR _message$26[ebp]
	mov	DWORD PTR [edx+48], 2

; 1000 : 					message->dataBlock.damageStrength = 2.0F * platform->MaxStrength();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	call	?MaxStrength@SimBaseClass@@QAEMXZ	; SimBaseClass::MaxStrength
	fstp	DWORD PTR tv2912[ebp]
	movss	xmm0, DWORD PTR tv2912[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	mov	ecx, DWORD PTR _message$26[ebp]
	movss	DWORD PTR [ecx+52], xmm0

; 1001 : 					message->dataBlock.damageRandomFact = 1.5F;

	mov	edx, DWORD PTR _message$26[ebp]
	movss	xmm0, DWORD PTR __real@3fc00000
	movss	DWORD PTR [edx+56], xmm0

; 1002 : 					
; 1003 : 					message->RequestOutOfBandTransmit ();

	mov	ecx, DWORD PTR _message$26[ebp]
	call	?RequestOutOfBandTransmit@VuMessage@@QAEXXZ ; VuMessage::RequestOutOfBandTransmit

; 1004 : 					FalconSendMessage (message,TRUE);

	push	1
	mov	eax, DWORD PTR _message$26[ebp]
	push	eax
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8
$LN122@MultiEngin:

; 1005 : 				}
; 1006 : 			}
; 1007 : 		}
; 1008 : 
; 1009 : 		//7.4 
; 1010 : 		if (engineData->hasAB)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	movzx	eax, BYTE PTR [edx+24]
	test	eax, eax
	je	$LN121@MultiEngin

; 1011 : 		{// JB 010706
; 1012 : 			pwrlevEngine1 = max (min (pwrlevEngine1, 1.5F), 0.0F);

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fc00000
	comiss	xmm0, DWORD PTR [ecx+1528]
	jbe	SHORT $LN172@MultiEngin
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1528]
	movss	DWORD PTR tv569[ebp], xmm0
	jmp	SHORT $LN173@MultiEngin
$LN172@MultiEngin:
	movss	xmm0, DWORD PTR __real@3fc00000
	movss	DWORD PTR tv569[ebp], xmm0
$LN173@MultiEngin:
	movss	xmm0, DWORD PTR tv569[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN176@MultiEngin
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fc00000
	comiss	xmm0, DWORD PTR [eax+1528]
	jbe	SHORT $LN174@MultiEngin
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1528]
	movss	DWORD PTR tv576[ebp], xmm0
	jmp	SHORT $LN175@MultiEngin
$LN174@MultiEngin:
	movss	xmm0, DWORD PTR __real@3fc00000
	movss	DWORD PTR tv576[ebp], xmm0
$LN175@MultiEngin:
	movss	xmm0, DWORD PTR tv576[ebp]
	movss	DWORD PTR tv577[ebp], xmm0
	jmp	SHORT $LN177@MultiEngin
$LN176@MultiEngin:
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv577[ebp], xmm0
$LN177@MultiEngin:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv577[ebp]
	movss	DWORD PTR [edx+1528], xmm0

; 1013 : 		}
; 1014 : 		else

	jmp	$LN120@MultiEngin
$LN121@MultiEngin:

; 1015 : 		{
; 1016 : 			pwrlevEngine1 = max (min (pwrlevEngine1, 1.0F), 0.0F);

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR [eax+1528]
	jbe	SHORT $LN178@MultiEngin
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1528]
	movss	DWORD PTR tv584[ebp], xmm0
	jmp	SHORT $LN179@MultiEngin
$LN178@MultiEngin:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv584[ebp], xmm0
$LN179@MultiEngin:
	movss	xmm0, DWORD PTR tv584[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN182@MultiEngin
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR [edx+1528]
	jbe	SHORT $LN180@MultiEngin
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1528]
	movss	DWORD PTR tv591[ebp], xmm0
	jmp	SHORT $LN181@MultiEngin
$LN180@MultiEngin:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv591[ebp], xmm0
$LN181@MultiEngin:
	movss	xmm0, DWORD PTR tv591[ebp]
	movss	DWORD PTR tv592[ebp], xmm0
	jmp	SHORT $LN183@MultiEngin
$LN182@MultiEngin:
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv592[ebp], xmm0
$LN183@MultiEngin:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv592[ebp]
	movss	DWORD PTR [ecx+1528], xmm0
$LN120@MultiEngin:

; 1017 : 		}
; 1018 : 
; 1019 : 		//7.5 Engine 1
; 1020 : 		// Make sure engine is on
; 1021 : 		if (rpm < 0.68f) { // below Idle

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f2e147b
	comiss	xmm0, DWORD PTR [edx+1212]
	jbe	$LN119@MultiEngin

; 1022 : 			rpmCmd = 0.7f;

	movss	xmm0, DWORD PTR __real@3f333333
	movss	DWORD PTR _rpmCmd$[ebp], xmm0

; 1023 : 			spoolrate = auxaeroData->lightupSpoolRate;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movss	xmm0, DWORD PTR [ecx+28]
	movss	DWORD PTR _spoolrate$[ebp], xmm0

; 1024 : 			thrtb1 = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _thrtb1$[ebp], xmm0

; 1025 : 			if (rpm > 0.5f)

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1212]
	comiss	xmm0, DWORD PTR __real@3f000000
	jbe	SHORT $LN118@MultiEngin

; 1026 : 				ClearFlag(JfsStart);

	push	268435456				; 10000000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearFlag@AirframeClass@@QAEXH@Z	; AirframeClass::ClearFlag
$LN118@MultiEngin:

; 1027 : 			ftit = Math.FLTust(5.1F * (rpm/0.7f), ftitrate, dt, oldFtit);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1620				; 00000654H
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _ftitrate
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1212]
	divss	xmm0, DWORD PTR __real@3f333333
	mulss	xmm0, DWORD PTR __real@40a33333
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?FLTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z	; SIMLIB_MATH_CLASS::FLTust
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+1668]

; 1028 : 
; 1029 : 			// sfr: added, rampstart fix
; 1030 : 			Engine1RpmMods(rpmCmd);

	push	ecx
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Engine1RpmMods@AirframeClass@@QAEMM@Z	; AirframeClass::Engine1RpmMods
	fstp	ST(0)

; 1031 : 			rpmCmd = Engine1RpmMods(rpmCmd);

	push	ecx
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Engine1RpmMods@AirframeClass@@QAEMM@Z	; AirframeClass::Engine1RpmMods
	fstp	DWORD PTR _rpmCmd$[ebp]

; 1032 : 			spoolrate = spoolrate + spoolAltRate;

	movss	xmm0, DWORD PTR _spoolrate$[ebp]
	addss	xmm0, DWORD PTR _spoolAltRate$[ebp]
	movss	DWORD PTR _spoolrate$[ebp], xmm0

; 1033 : 			rpm = Math.FLTust (rpmCmd, spoolrate, dt, oldRpm);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 500				; 000001f4H
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _spoolrate$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?FLTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z	; SIMLIB_MATH_CLASS::FLTust
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+1212]

; 1034 : 			if (fuel > 0.0F){

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+20]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN117@MultiEngin

; 1035 : 				rpm = max (rpm, 0.01F);

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1212]
	comiss	xmm0, DWORD PTR __real@3c23d70a
	jbe	SHORT $LN184@MultiEngin
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1212]
	movss	DWORD PTR tv635[ebp], xmm0
	jmp	SHORT $LN185@MultiEngin
$LN184@MultiEngin:
	movss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR tv635[ebp], xmm0
$LN185@MultiEngin:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv635[ebp]
	movss	DWORD PTR [edx+1212], xmm0
$LN117@MultiEngin:

; 1036 : 			}
; 1037 : 		}

	jmp	$LN108@MultiEngin
$LN119@MultiEngin:

; 1038 : 		//7.6 MIL Power Engine 1
; 1039 : 		//if (pwrlevEngine1 <= 1.0f)
; 1040 : 		else if ((pwrlevEngine1 <= 1.0f && rpm <= 1.0f) || (pwrlevEngine1 > 1.0f && rpm <= 1.0f))

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR [eax+1528]
	jb	SHORT $LN113@MultiEngin
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR [ecx+1212]
	jae	SHORT $LN114@MultiEngin
$LN113@MultiEngin:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1528]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	$LN115@MultiEngin
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR [eax+1212]
	jb	$LN115@MultiEngin
$LN114@MultiEngin:

; 1041 : 		{
; 1042 : 			/*-------------------*/
; 1043 : 			/* Mil power or less */
; 1044 : 			/*-------------------*/
; 1045 : 			th1 = Math.TwodInterp (-z, mach, engineData->alt,
; 1046 : 				engineData->mach, engineData->thrust[0], engineData->numAlt,
; 1047 : 				engineData->numMach, &curEngAltBreak, &curEngMachBreak);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 812				; 0000032cH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 816				; 00000330H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR [ecx+edx+28]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+1144]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1116]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?TwodInterp@SIMLIB_MATH_CLASS@@QAEMMMPBM00HHPAH1@Z ; SIMLIB_MATH_CLASS::TwodInterp
	fstp	DWORD PTR _th1$[ebp]

; 1048 : 			th2 = Math.TwodInterp (-z, mach, engineData->alt,
; 1049 : 				engineData->mach, engineData->thrust[1], engineData->numAlt,
; 1050 : 				engineData->numMach, &curEngAltBreak, &curEngMachBreak);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 812				; 0000032cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 816				; 00000330H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR [eax+ecx+28]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+1144]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1116]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?TwodInterp@SIMLIB_MATH_CLASS@@QAEMMMPBM00HHPAH1@Z ; SIMLIB_MATH_CLASS::TwodInterp
	fstp	DWORD PTR _th2$[ebp]

; 1051 : 			
; 1052 : 			aburnLit = FALSE;

	mov	DWORD PTR _aburnLit$[ebp], 0

; 1053 : 			// sfr: reverting back code
; 1054 : 			thrtb1 = ((th2 - th1)*pwrlevEngine1 + th1) / mass; 

	movss	xmm0, DWORD PTR _th2$[ebp]
	subss	xmm0, DWORD PTR _th1$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [edx+1528]
	addss	xmm0, DWORD PTR _th1$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [eax+40]
	movss	DWORD PTR _thrtb1$[ebp], xmm0

; 1055 : 			//thrtb1 = (3.33f*(th2 - th1)*(rpm - 0.7f) + th1)/ mass; // saints code
; 1056 : 			rpmCmd = 0.7F + 0.3F * pwrlevEngine1;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3e99999a
	mulss	xmm0, DWORD PTR [ecx+1528]
	addss	xmm0, DWORD PTR __real@3f333333
	movss	DWORD PTR _rpmCmd$[ebp], xmm0

; 1057 : 			// sfr: added per instructions
; 1058 : 			// sfr: commenting out dup line
; 1059 : 			//Engine1RpmMods(rpmCmd);
; 1060 : 			rpmCmd = Engine1RpmMods(rpmCmd);

	push	ecx
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Engine1RpmMods@AirframeClass@@QAEMM@Z	; AirframeClass::Engine1RpmMods
	fstp	DWORD PTR _rpmCmd$[ebp]

; 1061 : 			//TJL 02/22/04 Add in the alt
; 1062 : 			spoolrate = spoolAltRate + spoolrate;

	movss	xmm0, DWORD PTR _spoolAltRate$[ebp]
	addss	xmm0, DWORD PTR _spoolrate$[ebp]
	movss	DWORD PTR _spoolrate$[ebp], xmm0

; 1063 : 			rpm = Math.FLTust (rpmCmd, spoolrate, dt, oldRpm);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 500				; 000001f4H
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _spoolrate$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?FLTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z	; SIMLIB_MATH_CLASS::FLTust
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+1212]

; 1064 : 			if (fuel > 0.0F){

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+20]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN112@MultiEngin

; 1065 : 				rpm = max (rpm, 0.01F);

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1212]
	comiss	xmm0, DWORD PTR __real@3c23d70a
	jbe	SHORT $LN186@MultiEngin
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1212]
	movss	DWORD PTR tv731[ebp], xmm0
	jmp	SHORT $LN187@MultiEngin
$LN186@MultiEngin:
	movss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR tv731[ebp], xmm0
$LN187@MultiEngin:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv731[ebp]
	movss	DWORD PTR [ecx+1212], xmm0
$LN112@MultiEngin:

; 1066 : 			}
; 1067 : 			// sfr: end added
; 1068 : 
; 1069 : 			// ftit calculated
; 1070 : 			if (rpm < 0.9F)

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f666666
	comiss	xmm0, DWORD PTR [edx+1212]
	jbe	SHORT $LN111@MultiEngin

; 1071 : 			{
; 1072 : 				ftit = Math.FLTust(5.1F + (rpm - 0.7F) / 0.2F * 1.0F, ftitrate, dt, oldFtit);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1620				; 00000654H
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _ftitrate
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1212]
	subss	xmm0, DWORD PTR __real@3f333333
	divss	xmm0, DWORD PTR __real@3e4ccccd
	mulss	xmm0, DWORD PTR __real@3f800000
	addss	xmm0, DWORD PTR __real@40a33333
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?FLTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z	; SIMLIB_MATH_CLASS::FLTust
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+1668]
	jmp	SHORT $LN109@MultiEngin
$LN111@MultiEngin:

; 1073 : 			}
; 1074 : 			else if (rpm < 1.0F)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR [eax+1212]
	jbe	SHORT $LN109@MultiEngin

; 1075 : 			{
; 1076 : 				ftit = Math.FLTust(6.1F + (rpm - 0.9F) / 0.1F * 1.5F, ftitrate, dt, oldFtit);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1620				; 00000654H
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _ftitrate
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1212]
	subss	xmm0, DWORD PTR __real@3f666666
	divss	xmm0, DWORD PTR __real@3dcccccd
	mulss	xmm0, DWORD PTR __real@3fc00000
	addss	xmm0, DWORD PTR __real@40c33333
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?FLTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z	; SIMLIB_MATH_CLASS::FLTust
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+1668]
$LN109@MultiEngin:

; 1077 : 			}			
; 1078 : 		}
; 1079 : 
; 1080 : 
; 1081 : 		//7.7 AB Power Engine 1
; 1082 : 		//if (pwrlevEngine1 > 1.0f)
; 1083 : 		else

	jmp	$LN108@MultiEngin
$LN115@MultiEngin:

; 1084 : 			/*--------------------------*/
; 1085 : 			/* Some stage of afterburner */
; 1086 : 			/*--------------------------*/
; 1087 : 		{
; 1088 : 			th1 = Math.TwodInterp (-z, mach, engineData->alt,
; 1089 : 				engineData->mach, engineData->thrust[1], engineData->numAlt,
; 1090 : 				engineData->numMach, &curEngAltBreak, &curEngMachBreak);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 812				; 0000032cH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 816				; 00000330H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR [ecx+edx+28]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+1144]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1116]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?TwodInterp@SIMLIB_MATH_CLASS@@QAEMMMPBM00HHPAH1@Z ; SIMLIB_MATH_CLASS::TwodInterp
	fstp	DWORD PTR _th1$[ebp]

; 1091 : 			th2 = Math.TwodInterp (-z, mach, engineData->alt,
; 1092 : 				engineData->mach, engineData->thrust[2], engineData->numAlt,
; 1093 : 				engineData->numMach, &curEngAltBreak, &curEngMachBreak);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 812				; 0000032cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 816				; 00000330H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR [eax+ecx+28]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+1144]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1116]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?TwodInterp@SIMLIB_MATH_CLASS@@QAEMMMPBM00HHPAH1@Z ; SIMLIB_MATH_CLASS::TwodInterp
	fstp	DWORD PTR _th2$[ebp]

; 1094 : 			
; 1095 : 			aburnLit = TRUE;

	mov	DWORD PTR _aburnLit$[ebp], 1

; 1096 : 			// sfr: reverting back code
; 1097 : 			thrtb1 = (2.0F*(th2 - th1)*(pwrlevEngine1-1.0F) + th1) / mass;

	movss	xmm0, DWORD PTR _th2$[ebp]
	subss	xmm0, DWORD PTR _th1$[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+1528]
	subss	xmm1, DWORD PTR __real@3f800000
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR _th1$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [eax+40]
	movss	DWORD PTR _thrtb1$[ebp], xmm0

; 1098 : 			//thrtb1 = (3.33F*(th2 - th1)*(rpm - 0.7F) + th1) / mass; // old saints code
; 1099 : 			rpmCmd = 1.0F + 0.06F * (pwrlevEngine1 - 1.0F);

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1528]
	subss	xmm0, DWORD PTR __real@3f800000
	mulss	xmm0, DWORD PTR __real@3d75c28f
	addss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _rpmCmd$[ebp], xmm0

; 1100 : 			// sfr: added per instructions
; 1101 : 			// sfr: commenting out dup line
; 1102 : 			//Engine1RpmMods(rpmCmd);
; 1103 : 			rpmCmd = Engine1RpmMods(rpmCmd);

	push	ecx
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Engine1RpmMods@AirframeClass@@QAEMM@Z	; AirframeClass::Engine1RpmMods
	fstp	DWORD PTR _rpmCmd$[ebp]

; 1104 : 			//TJL 02/22/04 Add in the alt
; 1105 : 			spoolrate = spoolAltRate + spoolrate;

	movss	xmm0, DWORD PTR _spoolAltRate$[ebp]
	addss	xmm0, DWORD PTR _spoolrate$[ebp]
	movss	DWORD PTR _spoolrate$[ebp], xmm0

; 1106 : 			rpm = Math.FLTust (rpmCmd, spoolrate, dt, oldRpm);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 500				; 000001f4H
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _spoolrate$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?FLTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z	; SIMLIB_MATH_CLASS::FLTust
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+1212]

; 1107 : 			if (fuel > 0.0F){

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+20]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN107@MultiEngin

; 1108 : 				rpm = max (rpm, 0.01F);

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1212]
	comiss	xmm0, DWORD PTR __real@3c23d70a
	jbe	SHORT $LN188@MultiEngin
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1212]
	movss	DWORD PTR tv856[ebp], xmm0
	jmp	SHORT $LN189@MultiEngin
$LN188@MultiEngin:
	movss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR tv856[ebp], xmm0
$LN189@MultiEngin:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv856[ebp]
	movss	DWORD PTR [ecx+1212], xmm0
$LN107@MultiEngin:

; 1109 : 			}
; 1110 : 			// sfr: end added
; 1111 : 
; 1112 : 			// ftit calculated
; 1113 : 			ftit = Math.FLTust(7.6F + (rpm - 1.0F) / 0.03F * 0.1F, ftitrate, dt, oldFtit);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1620				; 00000654H
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _ftitrate
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1212]
	subss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR __real@3cf5c28f
	mulss	xmm0, DWORD PTR __real@3dcccccd
	addss	xmm0, DWORD PTR __real@40f33333
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?FLTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z	; SIMLIB_MATH_CLASS::FLTust
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+1668]
$LN108@MultiEngin:

; 1114 : 		}
; 1115 : 
; 1116 : 		/*--------------------------------*/
; 1117 : 		/* scale thrust to reference area */
; 1118 : 		/*--------------------------------*/
; 1119 : 		thrtab = thrtb1; //Engine 1

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _thrtb1$[ebp]
	movss	DWORD PTR [edx+184], xmm0

; 1120 : 
; 1121 : 		//7.8
; 1122 : 		/*-----------------*/
; 1123 : 		/* engine dynamics */
; 1124 : 		/*-----------------*/
; 1125 : 		if(IsSet(Trimming))// || simpleMode == SIMPLE_MODE_AF)

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	$LN106@MultiEngin

; 1126 : 		{
; 1127 : 			//Engine 1
; 1128 : 			ethrst = 1.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+204], xmm0

; 1129 : 			tgross = thrtab;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+184]
	movss	DWORD PTR _tgross$[ebp], xmm0

; 1130 : 			olda01[0] = tgross;

	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _tgross$[ebp]
	movss	DWORD PTR [eax+edx+476], xmm0

; 1131 : 			olda01[1] = tgross;

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _tgross$[ebp]
	movss	DWORD PTR [edx+ecx+476], xmm0

; 1132 : 			olda01[2] = tgross;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _tgross$[ebp]
	movss	DWORD PTR [ecx+eax+476], xmm0

; 1133 : 			olda01[3] = tgross;

	mov	edx, 4
	imul	edx, 3
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _tgross$[ebp]
	movss	DWORD PTR [eax+edx+476], xmm0

; 1134 : 			
; 1135 : 			rpm = rpmCmd;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR [ecx+1212], xmm0

; 1136 : 			oldRpm[0] = rpm;

	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1212]
	mov	DWORD PTR [eax+edx+500], ecx

; 1137 : 			oldRpm[1] = rpm;

	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1212]
	mov	DWORD PTR [eax+edx+500], ecx

; 1138 : 			oldRpm[2] = rpm;

	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1212]
	mov	DWORD PTR [eax+edx+500], ecx

; 1139 : 			oldRpm[3] = rpm;

	mov	edx, 4
	imul	edx, 3
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1212]
	mov	DWORD PTR [eax+edx+500], ecx

; 1140 : 		}
; 1141 : 
; 1142 : 		//7.9
; 1143 : 		else

	jmp	SHORT $LN105@MultiEngin
$LN106@MultiEngin:

; 1144 : 		{
; 1145 : 			tgross = thrtab;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+184]
	movss	DWORD PTR _tgross$[ebp], xmm0
$LN105@MultiEngin:

; 1146 : 			//TJL 08/21/04 this lag filter no longer needed.
; 1147 : 			/*
; 1148 : 			//Engine 1
; 1149 : 			if(aburnLit)
; 1150 : 			{
; 1151 : 				//AB
; 1152 : 				ta01 = auxaeroData->abSpoolRate + spoolAltRate;
; 1153 : 				tgross = Math.FLTust(thrtab,ta01,dt,olda01);
; 1154 : 			}
; 1155 : 			else
; 1156 : 			{
; 1157 : 				//MIL
; 1158 : 				if(pwrlevEngine1 <= 1.0F)
; 1159 : 					ta01 = auxaeroData->normSpoolRate + spoolAltRate;
; 1160 : 				else
; 1161 : 					ta01 = auxaeroData->abSpoolRate + spoolAltRate;
; 1162 : 				
; 1163 : 				tgross = Math.FLTust(thrtab,ta01,dt,olda01);
; 1164 : 			}*/
; 1165 : 		}
; 1166 : 		
; 1167 : 		//7.10
; 1168 : 		/*-----------*/
; 1169 : 		/* burn fuel */
; 1170 : 		/*-----------*/
; 1171 : 		if (AvailableFuel() <= 0.0f || IsEngineFlag(MasterFuelOff)) { // no fuel - dead engine.

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AvailableFuel@AirframeClass@@QAEMXZ	; AirframeClass::AvailableFuel
	fstp	DWORD PTR tv3222[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR tv3222[ebp]
	jae	SHORT $LN103@MultiEngin
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsEngineFlag@AirframeClass@@QAEHW4EngineFlags@1@@Z ; AirframeClass::IsEngineFlag
	test	eax, eax
	je	SHORT $LN104@MultiEngin
$LN103@MultiEngin:

; 1172 : 			SetFlag(EngineStopped);

	push	134217728				; 08000000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFlag@AirframeClass@@QAEXH@Z		; AirframeClass::SetFlag

; 1173 : 			// mark it as a flame out
; 1174 : 			platform->mFaults->SetFault(FaultClass::eng_fault, FaultClass::fl_out, FaultClass::fail, FALSE);

	push	0
	push	2
	push	-2147483648				; 80000000H
	push	8
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	mov	ecx, DWORD PTR [ecx+928]
	call	?SetFault@FackClass@@QAEXW4type_FSubSystem@FaultClass@@W4type_FFunction@3@W4type_FSeverity@3@H@Z ; FackClass::SetFault

; 1175 : 		}
; 1176 : 		else

	jmp	$LN94@MultiEngin
$LN104@MultiEngin:

; 1177 : 		{
; 1178 : 			// JPO - back to basics... this stuff doesn't have to be complicated surely.
; 1179 : 			// fuel flow is proportional to thrust.
; 1180 : 			// thrust factor is already in, its just that tgross is thrust/mass, 
; 1181 : 			// so we get rid of the mass component again.
; 1182 : 			if(engineData->hasFuelFlow) // MLR 5/17/2004 - 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	DWORD PTR [eax+52], 0
	je	$LN101@MultiEngin

; 1183 : 			{
; 1184 : 				// sfr: new fuel code per instructions
; 1185 : 				if(aburnLit == TRUE)

	cmp	DWORD PTR _aburnLit$[ebp], 1
	jne	$LN100@MultiEngin

; 1186 : 				{
; 1187 : 					float fflow1, fflow2;
; 1188 : 
; 1189 : 					fflow1 = Math.TwodInterp (-z, mach, engineData->alt,
; 1190 : 						engineData->mach, engineData->fuelflow[1],engineData->numAlt,
; 1191 : 						engineData->numMach, &curEngAltBreak, &curEngMachBreak);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 812				; 0000032cH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 816				; 00000330H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR [ecx+edx+40]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+1144]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1116]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?TwodInterp@SIMLIB_MATH_CLASS@@QAEMMMPBM00HHPAH1@Z ; SIMLIB_MATH_CLASS::TwodInterp
	fstp	DWORD PTR _fflow1$17[ebp]

; 1192 : 					fflow2 = Math.TwodInterp (-z, mach, engineData->alt,
; 1193 : 						engineData->mach, engineData->fuelflow[2],engineData->numAlt,
; 1194 : 						engineData->numMach, &curEngAltBreak, &curEngMachBreak);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 812				; 0000032cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 816				; 00000330H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR [eax+ecx+40]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+1144]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1116]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?TwodInterp@SIMLIB_MATH_CLASS@@QAEMMMPBM00HHPAH1@Z ; SIMLIB_MATH_CLASS::TwodInterp
	fstp	DWORD PTR _fflow2$12[ebp]

; 1195 : 					
; 1196 : 					
; 1197 : 					//fuelFlowSS = (33.3333333F*(fflow2 - fflow1)*(rpm-1.0F) + fflow1);
; 1198 : 					 fuelFlowSS = (2.0F * ( fflow2 - fflow1)* (pwrlev - 1.0F) + fflow1);

	movss	xmm0, DWORD PTR _fflow2$12[ebp]
	subss	xmm0, DWORD PTR _fflow1$17[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+1516]
	subss	xmm1, DWORD PTR __real@3f800000
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR _fflow1$17[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+96], xmm0

; 1199 : 				}
; 1200 : 				else

	jmp	$LN99@MultiEngin
$LN100@MultiEngin:

; 1201 : 				{ 
; 1202 : 					float fflow1, fflow2;
; 1203 : 
; 1204 : 					fflow1 = Math.TwodInterp (-z, mach, engineData->alt,
; 1205 : 						engineData->mach, engineData->fuelflow[0],engineData->numAlt,
; 1206 : 						engineData->numMach, &curEngAltBreak, &curEngMachBreak);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 812				; 0000032cH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 816				; 00000330H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR [ecx+edx+40]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+1144]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1116]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?TwodInterp@SIMLIB_MATH_CLASS@@QAEMMMPBM00HHPAH1@Z ; SIMLIB_MATH_CLASS::TwodInterp
	fstp	DWORD PTR _fflow1$15[ebp]

; 1207 : 					fflow2 = Math.TwodInterp (-z, mach, engineData->alt,
; 1208 : 						engineData->mach, engineData->fuelflow[1],engineData->numAlt,
; 1209 : 						engineData->numMach, &curEngAltBreak, &curEngMachBreak);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 812				; 0000032cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 816				; 00000330H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR [eax+ecx+40]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+1144]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1116]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?TwodInterp@SIMLIB_MATH_CLASS@@QAEMMMPBM00HHPAH1@Z ; SIMLIB_MATH_CLASS::TwodInterp
	fstp	DWORD PTR _fflow2$9[ebp]

; 1210 : 
; 1211 : 					//fuelFlowSS = ((fflow2 - fflow1)*(rpm-.7f)*3.33333f + fflow1);
; 1212 : 					fuelFlowSS = (fflow2 - fflow1)* pwrlev + fflow1;

	movss	xmm0, DWORD PTR _fflow2$9[ebp]
	subss	xmm0, DWORD PTR _fflow1$15[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [edx+1516]
	addss	xmm0, DWORD PTR _fflow1$15[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+96], xmm0
$LN99@MultiEngin:

; 1213 : 				}
; 1214 : 				// end fuel
; 1215 : 
; 1216 : #if 0
; 1217 : 				if(rpm>1.0)
; 1218 : 				{
; 1219 : 					float fflow1, fflow2;
; 1220 : 
; 1221 : 					fflow1 = Math.TwodInterp (-z, mach, engineData->alt,
; 1222 : 						engineData->mach, engineData->fuelflow[1],engineData->numAlt,
; 1223 : 						engineData->numMach, &curEngAltBreak, &curEngMachBreak);
; 1224 : 					fflow2 = Math.TwodInterp (-z, mach, engineData->alt,
; 1225 : 						engineData->mach, engineData->fuelflow[2],engineData->numAlt,
; 1226 : 						engineData->numMach, &curEngAltBreak, &curEngMachBreak);
; 1227 : 					
; 1228 : 					
; 1229 : 					fuelFlowSS = (33.3333333F*(fflow2 - fflow1)*(rpm-1.0F) + fflow1);
; 1230 : 				}
; 1231 : 				else
; 1232 : 				{ 
; 1233 : 					float fflow1, fflow2;
; 1234 : 
; 1235 : 					fflow1 = Math.TwodInterp (-z, mach, engineData->alt,
; 1236 : 						engineData->mach, engineData->fuelflow[0],engineData->numAlt,
; 1237 : 						engineData->numMach, &curEngAltBreak, &curEngMachBreak);
; 1238 : 					fflow2 = Math.TwodInterp (-z, mach, engineData->alt,
; 1239 : 						engineData->mach, engineData->fuelflow[1],engineData->numAlt,
; 1240 : 						engineData->numMach, &curEngAltBreak, &curEngMachBreak);
; 1241 : 
; 1242 : 					fuelFlowSS = ((fflow2 - fflow1)*(rpm-.7f)*3.33333f + fflow1);
; 1243 : 				}
; 1244 : #endif
; 1245 : 			}
; 1246 : 			else

	jmp	SHORT $LN96@MultiEngin
$LN101@MultiEngin:

; 1247 : 			{
; 1248 : 				if (aburnLit)

	cmp	DWORD PTR _aburnLit$[ebp], 0
	je	SHORT $LN97@MultiEngin

; 1249 : 				{
; 1250 : 					fuelFlowSS =  auxaeroData->fuelFlowFactorAb * tgross  * mass;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movss	xmm0, DWORD PTR [edx+4]
	mulss	xmm0, DWORD PTR _tgross$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [eax+40]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+96], xmm0

; 1251 : 				}
; 1252 : 				else

	jmp	SHORT $LN96@MultiEngin
$LN97@MultiEngin:

; 1253 : 				{ 
; 1254 : 					fuelFlowSS = auxaeroData->fuelFlowFactorNormal * tgross * mass;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR _tgross$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [ecx+40]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+96], xmm0
$LN96@MultiEngin:

; 1255 : 				}
; 1256 : 			}
; 1257 : 
; 1258 : 			fuelFlow += (fuelFlowSS - fuelFlow) / 10;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+96]
	subss	xmm0, DWORD PTR [ecx+24]
	divss	xmm0, DWORD PTR __real@41200000
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+24]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+24], xmm0

; 1259 : 
; 1260 : 			//Determine MinFuelFlow Engine 1
; 1261 : 			if (fuelFlow < auxaeroData->minFuelFlow)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+8]
	comiss	xmm0, DWORD PTR [eax+24]
	jbe	SHORT $LN95@MultiEngin

; 1262 : 				fuelFlow = auxaeroData->minFuelFlow;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+24], ecx
$LN95@MultiEngin:

; 1263 : 			if (fuelFlowSS < auxaeroData->minFuelFlow)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	comiss	xmm0, DWORD PTR [ecx+96]
	jbe	SHORT $LN94@MultiEngin

; 1264 : 				fuelFlowSS = auxaeroData->minFuelFlow;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+96], edx
$LN94@MultiEngin:

; 1265 : 			
; 1266 : 		}
; 1267 : 		/*
; 1268 : 			//Total Fuel Burn
; 1269 : 			fuelFlowTotal = fuelFlowSS + fuelFlowSS2;
; 1270 : 			// Throw CBEFuelFlow the Total so the indicator works
; 1271 : 			fuelFlow = fuelFlowTotal;
; 1272 : 			*/
; 1273 : 
; 1274 : 		if (!IsSet(NoFuelBurn))

	push	16384					; 00004000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	jne	SHORT $LN93@MultiEngin

; 1275 : 		{
; 1276 : 			// JPO - fuel is now burnt and transferred.
; 1277 : 			//Using combined total between engines
; 1278 : 			BurnFuel(fuelFlowSS * dt / 3600.0F);     

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+96]
	mulss	xmm0, DWORD PTR _dt$[ebp]
	divss	xmm0, DWORD PTR __real@45610000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BurnFuel@AirframeClass@@QAEHM@Z	; AirframeClass::BurnFuel

; 1279 : 			weight -= fuelFlowSS * dt / 3600.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+96]
	mulss	xmm0, DWORD PTR _dt$[ebp]
	divss	xmm0, DWORD PTR __real@45610000
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+44]
	subss	xmm1, xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+44], xmm1

; 1280 : 			mass    = weight / GRAVITY;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+44]
	divss	xmm0, DWORD PTR __real@4200b53f
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+40], xmm0
$LN93@MultiEngin:

; 1281 : 		}
; 1282 : 		
; 1283 : 		//TJL 02/21/04 
; 1284 : 		// sfr: commenting out these lines, dont inside ifelse
; 1285 : 		/*
; 1286 : 		Engine1RpmMods(rpmCmd);
; 1287 : 		rpmCmd = Engine1RpmMods(rpmCmd);
; 1288 : 		spoolrate = spoolrate + spoolAltRate;
; 1289 : 
; 1290 : 		rpm = Math.FLTust (rpmCmd, spoolrate, dt, oldRpm);
; 1291 : 		if (fuel > 0.0F)
; 1292 : 			rpm = max (rpm, 0.01F);
; 1293 : 			*/
; 1294 : 		
; 1295 : 		// ADDED BY S.G. TO SIMULATE THE HEAT PRODUCED BY THE ENGINE
; 1296 : 		// I'M USING A PREVIOUSLY UNUSED ARRAY CALLED oldp01 FOR ENGINE HEAT TEMPERATURE
; 1297 : 		// Afterburner lit?
; 1298 : 		//Engine 1 (does this need to be here???)
; 1299 : 		if (rpm > 100.0f){

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1212]
	comiss	xmm0, DWORD PTR __real@42c80000
	jbe	SHORT $LN92@MultiEngin

; 1300 : 			Math.FLTust (rpm + 0.5f, 0.5F, dt, oldp01);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 284				; 0000011cH
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1212]
	addss	xmm0, DWORD PTR __real@3f000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?FLTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z	; SIMLIB_MATH_CLASS::FLTust
	fstp	ST(0)

; 1301 : 		}
; 1302 : 		else 

	jmp	$LN87@MultiEngin
$LN92@MultiEngin:

; 1303 : 		{
; 1304 : 			// the 'modified rpm will be rpm^4.5
; 1305 : 			float modRpm = (float)(rpm*rpm*rpm*rpm*sqrt(rpm));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1212]
	mulss	xmm0, DWORD PTR [ecx+1212]
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [edx+1212]
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [eax+1212]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm1, DWORD PTR [ecx+1212]
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv4387[ebp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR tv3378[ebp]
	movss	xmm0, DWORD PTR tv4387[ebp]
	mulss	xmm0, DWORD PTR tv3378[ebp]
	movss	DWORD PTR _modRpm$23[ebp], xmm0

; 1306 : 			
; 1307 : 			// Am I increasing the rpm (but not yet in afterburner)?
; 1308 : 			if (rpm > oldp01[0])

	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1212]
	comiss	xmm0, DWORD PTR [ecx+edx+284]
	jbe	SHORT $LN90@MultiEngin

; 1309 : 				Math.FLTust (modRpm, 4.0F, dt, oldp01);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 284				; 0000011cH
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@40800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _modRpm$23[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?FLTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z	; SIMLIB_MATH_CLASS::FLTust
	fstp	ST(0)

; 1310 : 			// Must be decreasing then...
; 1311 : 			else {

	jmp	$LN87@MultiEngin
$LN90@MultiEngin:

; 1312 : 				// Now check if the 'heat' is still above 1.00 (100%)
; 1313 : 				if (oldp01[0] > 1.0F)

	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+284]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN88@MultiEngin

; 1314 : 					Math.FLTust (modRpm, 7.0F, dt, oldp01);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 284				; 0000011cH
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@40e00000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _modRpm$23[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?FLTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z	; SIMLIB_MATH_CLASS::FLTust
	fstp	ST(0)

; 1315 : 				else

	jmp	SHORT $LN87@MultiEngin
$LN88@MultiEngin:

; 1316 : 					Math.FLTust (modRpm, 2.0F, dt, oldp01);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 284				; 0000011cH
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _modRpm$23[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?FLTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z	; SIMLIB_MATH_CLASS::FLTust
	fstp	ST(0)
$LN87@MultiEngin:

; 1317 : 				}
; 1318 : 		}
; 1319 : 		
; 1320 : 		//There is code everywhere 
; 1321 : 		if(stallMode >= EnteringDeepStall)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1248], 3
	jl	SHORT $LN86@MultiEngin

; 1322 : 			thrust *= 0.1f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+188]
	mulss	xmm0, DWORD PTR __real@3dcccccd
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+188], xmm0
$LN86@MultiEngin:

; 1323 : 		
; 1324 :    }
; 1325 :    else

	jmp	$LN85@MultiEngin
$LN131@MultiEngin:

; 1326 :    {
; 1327 : 	   if (IsSet(ThrottleCheck))

	push	65536					; 00010000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	$LN84@MultiEngin

; 1328 : 	   {
; 1329 : 		   //Engine 1
; 1330 : 		   if(engine1Throttle >= 1.5F)

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1520]
	comiss	xmm0, DWORD PTR __real@3fc00000
	jb	SHORT $LN83@MultiEngin

; 1331 : 			   engine1Throttle = pwrlevEngine1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1528]
	mov	DWORD PTR [edx+1520], ecx
$LN83@MultiEngin:

; 1332 : 		   if (fabs (engine1Throttle - pwrlevEngine1) > 0.1F)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1520]
	subss	xmm0, DWORD PTR [eax+1528]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv3424[ebp]
	movss	xmm0, DWORD PTR tv3424[ebp]
	comiss	xmm0, DWORD PTR __real@3dcccccd
	jbe	SHORT $LN82@MultiEngin

; 1333 : 			   ClearFlag(ThrottleCheck);

	push	65536					; 00010000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearFlag@AirframeClass@@QAEXH@Z	; AirframeClass::ClearFlag
$LN82@MultiEngin:

; 1334 : 		   pwrlevEngine1 = engine1Throttle;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1520]
	mov	DWORD PTR [ecx+1528], eax

; 1335 : 
; 1336 : 	   }
; 1337 : 	   else

	jmp	SHORT $LN80@MultiEngin
$LN84@MultiEngin:

; 1338 : 	   {
; 1339 : 		   if ((fabs (engine1Throttle - pwrlevEngine1) > 0.1F))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1520]
	subss	xmm0, DWORD PTR [edx+1528]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv3435[ebp]
	movss	xmm0, DWORD PTR tv3435[ebp]
	comiss	xmm0, DWORD PTR __real@3dcccccd
	jbe	SHORT $LN80@MultiEngin

; 1340 : 		   {
; 1341 : 			   ClearFlag (EngineOff);

	push	32768					; 00008000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearFlag@AirframeClass@@QAEXH@Z	; AirframeClass::ClearFlag
$LN80@MultiEngin:

; 1342 : 		   }
; 1343 : 	   }
; 1344 : 	   
; 1345 : 	   thrust   = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+188], xmm0

; 1346 : 	   tgross   = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _tgross$[ebp], xmm0

; 1347 : 	   fuelFlow = 0.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+24], xmm0

; 1348 : 	   rpm      = oldRpm[0]; // just remember where we were... JPO

	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+edx+500]
	mov	DWORD PTR [eax+1212], edx

; 1349 : 	   // Changed so the Oil light doesn't come on :-) - RH
; 1350 : 	   ftit     = 5.85f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@40bb3333
	movss	DWORD PTR [eax+1668], xmm0
$LN85@MultiEngin:

; 1351 :    }
; 1352 :    
; 1353 :    
; 1354 : 	//#6 Engine 2
; 1355 : 	if (IsEngineFlag(EngineStopped2)) //new engine flag

	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsEngineFlag@AirframeClass@@QAEHW4EngineFlags@1@@Z ; AirframeClass::IsEngineFlag
	test	eax, eax
	je	$LN79@MultiEngin

; 1356 : 	{
; 1357 : 		ftit2 = Math.FLTust(0.0f, 20.0f, dt, oldFtit2); // cool down the engine

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1644				; 0000066cH
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@41a00000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?FLTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z	; SIMLIB_MATH_CLASS::FLTust
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+1672]

; 1358 : 		float modRpm2 = (float)(rpm2*rpm2*rpm2*rpm2*sqrt(rpm2));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1216]
	mulss	xmm0, DWORD PTR [ecx+1216]
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [edx+1216]
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [eax+1216]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm1, DWORD PTR [ecx+1216]
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv4389[ebp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR tv3469[ebp]
	movss	xmm0, DWORD PTR tv4389[ebp]
	mulss	xmm0, DWORD PTR tv3469[ebp]
	movss	DWORD PTR _modRpm2$24[ebp], xmm0

; 1359 : 		
; 1360 : 		// Am I increasing the rpm (but not yet in afterburner)?
; 1361 : 		if (rpm2 > oldp01Eng2[0])

	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1216]
	comiss	xmm0, DWORD PTR [ecx+edx+548]
	jbe	SHORT $LN78@MultiEngin

; 1362 : 			Math.FLTust (modRpm2, 4.0F, dt, oldp01Eng2);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 548				; 00000224H
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@40800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _modRpm2$24[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?FLTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z	; SIMLIB_MATH_CLASS::FLTust
	fstp	ST(0)

; 1363 : 		// Must be decreasing then...
; 1364 : 		else

	jmp	$LN75@MultiEngin
$LN78@MultiEngin:

; 1365 : 		{
; 1366 : 			// Now check if the 'heat' is still above 1.00 (100%)
; 1367 : 			if (oldp01[0] > 1.0F)

	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+284]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN76@MultiEngin

; 1368 : 				Math.FLTust (modRpm2, 7.0F, dt, oldp01Eng2);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 548				; 00000224H
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@40e00000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _modRpm2$24[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?FLTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z	; SIMLIB_MATH_CLASS::FLTust
	fstp	ST(0)

; 1369 : 			else

	jmp	SHORT $LN75@MultiEngin
$LN76@MultiEngin:

; 1370 : 				Math.FLTust (modRpm2, 2.0F, dt, oldp01Eng2);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 548				; 00000224H
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _modRpm2$24[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?FLTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z	; SIMLIB_MATH_CLASS::FLTust
	fstp	ST(0)
$LN75@MultiEngin:

; 1371 : 		}
; 1372 : 		
; 1373 : 		//Shut down
; 1374 : 		spoolrate2 = auxaeroData->flameoutSpoolRate;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movss	xmm0, DWORD PTR [edx+32]
	movss	DWORD PTR _spoolrate2$[ebp], xmm0

; 1375 : 		fireTimer = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _fireTimer, xmm0

; 1376 : 		tgross2 = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _tgross2$[ebp], xmm0

; 1377 : 		fuelFlow2 = fuelFlowSS2 = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+100], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+28], xmm0

; 1378 : 		thrtab2 = 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+208], xmm0

; 1379 : 		thrust2 = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+212], xmm0

; 1380 : 
; 1381 : 		
; 1382 : 		// broken engine - anything but a flame out?
; 1383 : 		//TODO Chase down faults to fault Engine 2
; 1384 : 		if((platform->mFaults->GetFault(FaultClass::eng_fault) & ~FaultClass::fl_out) != 0) {

	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1088]
	mov	ecx, DWORD PTR [edx+928]
	call	?GetFault@FackClass@@QAEHW4type_FSubSystem@FaultClass@@@Z ; FackClass::GetFault
	and	eax, 2147483647				; 7fffffffH
	je	SHORT $LN74@MultiEngin

; 1385 : 			rpmCmd2 = 0.0f; // engine must be seized, not going to start or windmill

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _rpmCmd2$[ebp], xmm0
	jmp	$LN70@MultiEngin
$LN74@MultiEngin:

; 1386 : 		}
; 1387 : 		//else if (IsSet (JfsStart)) 
; 1388 : 		else if (IsSet (JfsStart) && UserStickInputs.getCurrentEngine() == UserStickInputs.Right_Engine)

	push	268435456				; 10000000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN72@MultiEngin
	mov	ecx, OFFSET ?UserStickInputs@@3VPilotInputs@@A ; UserStickInputs
	call	?getCurrentEngine@PilotInputs@@QAE?AW4Engine_t@1@XZ ; PilotInputs::getCurrentEngine
	cmp	eax, 1
	jne	SHORT $LN72@MultiEngin

; 1389 : 		{
; 1390 : 			rpmCmd2 = 0.25f; // JFS should take us up to 25%

	movss	xmm0, DWORD PTR __real@3e800000
	movss	DWORD PTR _rpmCmd2$[ebp], xmm0

; 1391 : 			spoolrate2 = 15.0f;

	movss	xmm0, DWORD PTR __real@41700000
	movss	DWORD PTR _spoolrate2$[ebp], xmm0

; 1392 : 			//decrease spin time
; 1393 : 			JFSSpinTime -= SimLibMajorFrameTime;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1608]
	subss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+1608], xmm0

; 1394 : 			if(JFSSpinTime <= 0)

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [edx+1608]
	jb	SHORT $LN71@MultiEngin

; 1395 : 				ClearFlag(JfsStart);

	push	268435456				; 10000000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearFlag@AirframeClass@@QAEXH@Z	; AirframeClass::ClearFlag
$LN71@MultiEngin:

; 1396 : 		}
; 1397 : 		else { // engine windmill (~12% at 450 knts) (me123 - this works on mine)

	jmp	SHORT $LN70@MultiEngin
$LN72@MultiEngin:

; 1398 : 			rpmCmd2 = (platform->GetKias() / 450.0f) * 0.12f;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+1088]
	mov	edx, DWORD PTR [eax+224]
	call	edx
	fstp	DWORD PTR tv3528[ebp]
	movss	xmm0, DWORD PTR tv3528[ebp]
	divss	xmm0, DWORD PTR __real@43e10000
	mulss	xmm0, DWORD PTR __real@3df5c28f
	movss	DWORD PTR _rpmCmd2$[ebp], xmm0
$LN70@MultiEngin:

; 1399 : 		}
; 1400 : 		
; 1401 : 		// attempt to spool up/down
; 1402 : 		rpm2 = Math.FLTust (rpmCmd2, spoolrate2, dt, oldRpm2);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 524				; 0000020cH
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _spoolrate2$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?FLTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z	; SIMLIB_MATH_CLASS::FLTust
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+1216]
	jmp	$LN22@MultiEngin
$LN79@MultiEngin:

; 1403 :     }
; 1404 : 
; 1405 : 	//end
; 1406 : /******************************************
; 1407 : // Engine 2
; 1408 : //
; 1409 : */
; 1410 : //*****************************************************
; 1411 : 	//#7 More shut down conditions
; 1412 :     else if (!IsSet(EngineOff2))

	push	536870912				; 20000000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	jne	$LN68@MultiEngin

; 1413 : 	
; 1414 :     {
; 1415 : 		//7.1 Engine flame out, shut down
; 1416 : 		if (platform->mFaults->GetFault(FaultClass::eng2_fault) & FaultClass::fl_out)

	push	9
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1088]
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFault@FackClass@@QAEHW4type_FSubSystem@FaultClass@@@Z ; FackClass::GetFault
	and	eax, -2147483648			; 80000000H
	je	SHORT $LN67@MultiEngin

; 1417 : 		{
; 1418 : 			SetEngineFlag(EngineStopped2);

	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetEngineFlag@AirframeClass@@QAEXW4EngineFlags@1@@Z ; AirframeClass::SetEngineFlag

; 1419 : 			engine2Throttle = 0.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+1524], xmm0
$LN67@MultiEngin:

; 1420 : 		}
; 1421 : 
; 1422 : 		//need to recombine these later
; 1423 : 		pwrlevEngine2 = engine2Throttle;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1524]
	mov	DWORD PTR [edx+1532], ecx

; 1424 : 		
; 1425 : 		//7.2 Deep Stall Flameout
; 1426 : 		if(auxaeroData->DeepStallEngineStall)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+60], 0
	je	SHORT $LN65@MultiEngin

; 1427 : 		{
; 1428 : 			//me123 if in deep stall and in ab lets stall the engine
; 1429 : 			// JPO - 10% chance, each time we check...
; 1430 : 			if (stallMode >= DeepStall && pwrlevEngine2 >= 1.0F && rand() % 10 == 1)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1248], 4
	jl	SHORT $LN65@MultiEngin
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1532]
	comiss	xmm0, DWORD PTR __real@3f800000
	jb	SHORT $LN65@MultiEngin
	call	_rand
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	cmp	edx, 1
	jne	SHORT $LN65@MultiEngin

; 1431 : 			{ 
; 1432 : 				SetEngineFlag(EngineStopped2);

	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetEngineFlag@AirframeClass@@QAEXW4EngineFlags@1@@Z ; AirframeClass::SetEngineFlag

; 1433 : 				// mark it as a flame out
; 1434 : 				platform->mFaults->SetFault(FaultClass::eng2_fault, FaultClass::fl_out, FaultClass::fail, FALSE);

	push	0
	push	2
	push	-2147483648				; 80000000H
	push	9
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1088]
	mov	ecx, DWORD PTR [eax+928]
	call	?SetFault@FackClass@@QAEXW4type_FSubSystem@FaultClass@@W4type_FFunction@3@W4type_FSeverity@3@H@Z ; FackClass::SetFault
$LN65@MultiEngin:

; 1435 : 			}
; 1436 : 		}
; 1437 : 		
; 1438 : 		//7.3 Flying
; 1439 : 		if (platform->IsSetFlag(MOTION_OWNSHIP))

	push	65536					; 00010000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1088]
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN59@MultiEngin

; 1440 : 		{
; 1441 : 			//7.3.1 Lost AB
; 1442 : 			//TODO Make Engine 2 Faults
; 1443 : 			if (platform->mFaults->GetFault(FaultClass::eng2_fault) & FaultClass::a_b)

	push	9
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1088]
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFault@FackClass@@QAEHW4type_FSubSystem@FaultClass@@@Z ; FackClass::GetFault
	and	eax, 4096				; 00001000H
	je	SHORT $LN63@MultiEngin

; 1444 : 			{
; 1445 : 				pwrlevEngine2 = min (engine2Throttle, 0.99F);

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f7d70a4
	comiss	xmm0, DWORD PTR [ecx+1524]
	jbe	SHORT $LN190@MultiEngin
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1524]
	movss	DWORD PTR tv1354[ebp], xmm0
	jmp	SHORT $LN191@MultiEngin
$LN190@MultiEngin:
	movss	xmm0, DWORD PTR __real@3f7d70a4
	movss	DWORD PTR tv1354[ebp], xmm0
$LN191@MultiEngin:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv1354[ebp]
	movss	DWORD PTR [eax+1532], xmm0
$LN63@MultiEngin:

; 1446 : 			}
; 1447 : 
; 1448 : 			//7.3.2 Engine Fire
; 1449 : 			if (platform->mFaults->GetFault(FaultClass::eng2_fault) & FaultClass::efire)

	push	9
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1088]
	mov	ecx, DWORD PTR [edx+928]
	call	?GetFault@FackClass@@QAEHW4type_FSubSystem@FaultClass@@@Z ; FackClass::GetFault
	and	eax, 16384				; 00004000H
	je	$LN59@MultiEngin

; 1450 : 			{
; 1451 : 				//Engine 2
; 1452 : 				if (platform->mFaults->GetFault(FaultClass::eng2_fault) & FaultClass::efire)

	push	9
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	mov	ecx, DWORD PTR [ecx+928]
	call	?GetFault@FackClass@@QAEHW4type_FSubSystem@FaultClass@@@Z ; FackClass::GetFault
	and	eax, 16384				; 00004000H
	je	SHORT $LN60@MultiEngin

; 1453 : 				{
; 1454 : 					pwrlevEngine2 *= 0.5F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1532]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+1532], xmm0

; 1455 : 					if (fireTimer >= 0.0F)

	movss	xmm0, DWORD PTR _fireTimer
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN60@MultiEngin

; 1456 : 						fireTimer += max (pwrlevEngine2, 0.3F) * dt;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1532]
	comiss	xmm0, DWORD PTR __real@3e99999a
	jbe	SHORT $LN192@MultiEngin
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1532]
	movss	DWORD PTR tv1378[ebp], xmm0
	jmp	SHORT $LN193@MultiEngin
$LN192@MultiEngin:
	movss	xmm0, DWORD PTR __real@3e99999a
	movss	DWORD PTR tv1378[ebp], xmm0
$LN193@MultiEngin:
	movss	xmm0, DWORD PTR tv1378[ebp]
	mulss	xmm0, DWORD PTR _dt$[ebp]
	addss	xmm0, DWORD PTR _fireTimer
	movss	DWORD PTR _fireTimer, xmm0
$LN60@MultiEngin:

; 1457 : 				}
; 1458 : 				
; 1459 : 				// On fire long enough, blow up
; 1460 : 				if (fireTimer > 60.0F) // 60 seconds at mil power

	movss	xmm0, DWORD PTR _fireTimer
	comiss	xmm0, DWORD PTR __real@42700000
	jbe	$LN59@MultiEngin

; 1461 : 				{
; 1462 : 					fireTimer = -1.0F;

	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _fireTimer, xmm0

; 1463 : 					FalconDamageMessage* message;
; 1464 : 					message = new FalconDamageMessage (platform->Id(), FalconLocalGame );

	push	98					; 00000062H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T18[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T18[ebp], 0
	je	SHORT $LN196@MultiEngin
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN194@MultiEngin
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv1405[ebp], eax
	jmp	SHORT $LN195@MultiEngin
$LN194@MultiEngin:
	mov	DWORD PTR tv1405[ebp], 0
$LN195@MultiEngin:
	push	1
	mov	ecx, DWORD PTR tv1405[ebp]
	push	ecx
	lea	edx, DWORD PTR $T6[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR $T18[ebp]
	call	??0FalconDamageMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z ; FalconDamageMessage::FalconDamageMessage
	mov	DWORD PTR tv1417[ebp], eax
	jmp	SHORT $LN197@MultiEngin
$LN196@MultiEngin:
	mov	DWORD PTR tv1417[ebp], 0
$LN197@MultiEngin:
	mov	eax, DWORD PTR tv1417[ebp]
	mov	DWORD PTR $T11[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T11[ebp]
	mov	DWORD PTR _message$25[ebp], ecx

; 1465 : 					message->dataBlock.fEntityID  = platform->Id();

	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _message$25[ebp]
	mov	DWORD PTR [eax+74], ecx
	mov	DWORD PTR [eax+78], edx

; 1466 : 					
; 1467 : 					message->dataBlock.fCampID = platform->GetCampaignObject()->GetCampID();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1088]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	DWORD PTR tv1474[ebp], eax
	mov	edx, DWORD PTR tv1474[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv1474[ebp]
	mov	edx, DWORD PTR [eax+112]
	call	edx
	mov	ecx, DWORD PTR _message$25[ebp]
	mov	WORD PTR [ecx+82], ax

; 1468 : 					message->dataBlock.fSide   = platform->GetCampaignObject()->GetOwner();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1088]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetOwner@CampBaseClass@@QAEEXZ		; CampBaseClass::GetOwner
	mov	ecx, DWORD PTR _message$25[ebp]
	mov	BYTE PTR [ecx+87], al

; 1469 : 					message->dataBlock.fPilotID   = ((AircraftClass*)platform)->pilotSlot;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1088]
	mov	ecx, DWORD PTR _message$25[ebp]
	mov	dl, BYTE PTR [eax+665]
	mov	BYTE PTR [ecx+84], dl

; 1470 : 					message->dataBlock.fIndex     = platform->Type();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	call	?Type@VuEntity@@QBEGXZ			; VuEntity::Type
	mov	ecx, DWORD PTR _message$25[ebp]
	mov	WORD PTR [ecx+85], ax

; 1471 : 					message->dataBlock.fWeaponID  = platform->Type();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1088]
	call	?Type@VuEntity@@QBEGXZ			; VuEntity::Type
	mov	ecx, DWORD PTR _message$25[ebp]
	mov	WORD PTR [ecx+88], ax

; 1472 : 					message->dataBlock.fWeaponUID = platform->Id();

	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _message$25[ebp]
	mov	DWORD PTR [eax+90], ecx
	mov	DWORD PTR [eax+94], edx

; 1473 : 					message->dataBlock.dEntityID  = message->dataBlock.fEntityID;

	mov	ecx, DWORD PTR _message$25[ebp]
	mov	edx, DWORD PTR [ecx+74]
	mov	eax, DWORD PTR [ecx+78]
	mov	ecx, DWORD PTR _message$25[ebp]
	mov	DWORD PTR [ecx+60], edx
	mov	DWORD PTR [ecx+64], eax

; 1474 : 					message->dataBlock.dCampID = message->dataBlock.fCampID;

	mov	edx, DWORD PTR _message$25[ebp]
	mov	eax, DWORD PTR _message$25[ebp]
	mov	cx, WORD PTR [eax+82]
	mov	WORD PTR [edx+68], cx

; 1475 : 					message->dataBlock.dSide   = message->dataBlock.fSide;

	mov	edx, DWORD PTR _message$25[ebp]
	mov	eax, DWORD PTR _message$25[ebp]
	mov	cl, BYTE PTR [eax+87]
	mov	BYTE PTR [edx+73], cl

; 1476 : 					message->dataBlock.dPilotID   = message->dataBlock.fPilotID;

	mov	edx, DWORD PTR _message$25[ebp]
	mov	eax, DWORD PTR _message$25[ebp]
	mov	cl, BYTE PTR [eax+84]
	mov	BYTE PTR [edx+70], cl

; 1477 : 					message->dataBlock.dIndex     = message->dataBlock.fIndex;

	mov	edx, DWORD PTR _message$25[ebp]
	mov	eax, DWORD PTR _message$25[ebp]
	mov	cx, WORD PTR [eax+85]
	mov	WORD PTR [edx+71], cx

; 1478 : 					message->dataBlock.damageType = FalconDamageType::CollisionDamage;

	mov	edx, DWORD PTR _message$25[ebp]
	mov	DWORD PTR [edx+48], 2

; 1479 : 					message->dataBlock.damageStrength = 2.0F * platform->MaxStrength();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	call	?MaxStrength@SimBaseClass@@QAEMXZ	; SimBaseClass::MaxStrength
	fstp	DWORD PTR tv3657[ebp]
	movss	xmm0, DWORD PTR tv3657[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	mov	ecx, DWORD PTR _message$25[ebp]
	movss	DWORD PTR [ecx+52], xmm0

; 1480 : 					message->dataBlock.damageRandomFact = 1.5F;

	mov	edx, DWORD PTR _message$25[ebp]
	movss	xmm0, DWORD PTR __real@3fc00000
	movss	DWORD PTR [edx+56], xmm0

; 1481 : 					
; 1482 : 					message->RequestOutOfBandTransmit ();

	mov	ecx, DWORD PTR _message$25[ebp]
	call	?RequestOutOfBandTransmit@VuMessage@@QAEXXZ ; VuMessage::RequestOutOfBandTransmit

; 1483 : 					FalconSendMessage (message,TRUE);

	push	1
	mov	eax, DWORD PTR _message$25[ebp]
	push	eax
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8
$LN59@MultiEngin:

; 1484 : 				}
; 1485 : 			}
; 1486 : 		}
; 1487 : 
; 1488 : 		//7.4 
; 1489 : 		if (engineData->hasAB)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	movzx	eax, BYTE PTR [edx+24]
	test	eax, eax
	je	$LN58@MultiEngin

; 1490 : 		{// JB 010706
; 1491 : 			pwrlevEngine2 = max (min (pwrlevEngine2, 1.5F), 0.0F);

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fc00000
	comiss	xmm0, DWORD PTR [ecx+1532]
	jbe	SHORT $LN198@MultiEngin
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1532]
	movss	DWORD PTR tv1582[ebp], xmm0
	jmp	SHORT $LN199@MultiEngin
$LN198@MultiEngin:
	movss	xmm0, DWORD PTR __real@3fc00000
	movss	DWORD PTR tv1582[ebp], xmm0
$LN199@MultiEngin:
	movss	xmm0, DWORD PTR tv1582[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN202@MultiEngin
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fc00000
	comiss	xmm0, DWORD PTR [eax+1532]
	jbe	SHORT $LN200@MultiEngin
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1532]
	movss	DWORD PTR tv1589[ebp], xmm0
	jmp	SHORT $LN201@MultiEngin
$LN200@MultiEngin:
	movss	xmm0, DWORD PTR __real@3fc00000
	movss	DWORD PTR tv1589[ebp], xmm0
$LN201@MultiEngin:
	movss	xmm0, DWORD PTR tv1589[ebp]
	movss	DWORD PTR tv1590[ebp], xmm0
	jmp	SHORT $LN203@MultiEngin
$LN202@MultiEngin:
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv1590[ebp], xmm0
$LN203@MultiEngin:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv1590[ebp]
	movss	DWORD PTR [edx+1532], xmm0

; 1492 : 		}
; 1493 : 		else

	jmp	$LN57@MultiEngin
$LN58@MultiEngin:

; 1494 : 		{
; 1495 : 			pwrlevEngine2 = max (min (pwrlevEngine2, 1.0F), 0.0F);

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR [eax+1532]
	jbe	SHORT $LN204@MultiEngin
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1532]
	movss	DWORD PTR tv1597[ebp], xmm0
	jmp	SHORT $LN205@MultiEngin
$LN204@MultiEngin:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv1597[ebp], xmm0
$LN205@MultiEngin:
	movss	xmm0, DWORD PTR tv1597[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN208@MultiEngin
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR [edx+1532]
	jbe	SHORT $LN206@MultiEngin
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1532]
	movss	DWORD PTR tv1604[ebp], xmm0
	jmp	SHORT $LN207@MultiEngin
$LN206@MultiEngin:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv1604[ebp], xmm0
$LN207@MultiEngin:
	movss	xmm0, DWORD PTR tv1604[ebp]
	movss	DWORD PTR tv1605[ebp], xmm0
	jmp	SHORT $LN209@MultiEngin
$LN208@MultiEngin:
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv1605[ebp], xmm0
$LN209@MultiEngin:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv1605[ebp]
	movss	DWORD PTR [ecx+1532], xmm0
$LN57@MultiEngin:

; 1496 : 		}
; 1497 : 
; 1498 : 		//7.5 Engine 2
; 1499 : 		if (rpm2 < 0.68f) { // below Idle

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f2e147b
	comiss	xmm0, DWORD PTR [edx+1216]
	jbe	$LN56@MultiEngin

; 1500 : 			rpmCmd2 = 0.7f;

	movss	xmm0, DWORD PTR __real@3f333333
	movss	DWORD PTR _rpmCmd2$[ebp], xmm0

; 1501 : 			spoolrate2 = auxaeroData->lightupSpoolRate;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movss	xmm0, DWORD PTR [ecx+28]
	movss	DWORD PTR _spoolrate2$[ebp], xmm0

; 1502 : 			thrtb2 = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _thrtb2$[ebp], xmm0

; 1503 : 			if (rpm2 > 0.5f)

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1216]
	comiss	xmm0, DWORD PTR __real@3f000000
	jbe	SHORT $LN55@MultiEngin

; 1504 : 				ClearFlag(JfsStart);

	push	268435456				; 10000000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearFlag@AirframeClass@@QAEXH@Z	; AirframeClass::ClearFlag
$LN55@MultiEngin:

; 1505 : 			ftit2 = Math.FLTust(5.1F * (rpm2/0.7f), ftitrate, dt, oldFtit2);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1644				; 0000066cH
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _ftitrate
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1216]
	divss	xmm0, DWORD PTR __real@3f333333
	mulss	xmm0, DWORD PTR __real@40a33333
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?FLTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z	; SIMLIB_MATH_CLASS::FLTust
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+1672]

; 1506 : 			// sfr: added rampstart
; 1507 : 			rpmCmd2 = Engine2RpmMods(rpmCmd2);

	push	ecx
	movss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Engine2RpmMods@AirframeClass@@QAEMM@Z	; AirframeClass::Engine2RpmMods
	fstp	DWORD PTR _rpmCmd2$[ebp]

; 1508 : 			spoolrate2 = spoolrate2 + spoolAltRate;

	movss	xmm0, DWORD PTR _spoolrate2$[ebp]
	addss	xmm0, DWORD PTR _spoolAltRate$[ebp]
	movss	DWORD PTR _spoolrate2$[ebp], xmm0

; 1509 : 			rpm2 = Math.FLTust (rpmCmd2, spoolrate2, dt, oldRpm2);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 524				; 0000020cH
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _spoolrate2$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?FLTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z	; SIMLIB_MATH_CLASS::FLTust
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+1216]

; 1510 : 			if (fuel > 0.0F){

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+20]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN54@MultiEngin

; 1511 : 				rpm2 = max (rpm2, 0.01F);

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1216]
	comiss	xmm0, DWORD PTR __real@3c23d70a
	jbe	SHORT $LN210@MultiEngin
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1216]
	movss	DWORD PTR tv1646[ebp], xmm0
	jmp	SHORT $LN211@MultiEngin
$LN210@MultiEngin:
	movss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR tv1646[ebp], xmm0
$LN211@MultiEngin:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv1646[ebp]
	movss	DWORD PTR [edx+1216], xmm0
$LN54@MultiEngin:

; 1512 : 			}
; 1513 : 		}

	jmp	$LN45@MultiEngin
$LN56@MultiEngin:

; 1514 : 
; 1515 : 		//7.6 MIL Power Engine 2
; 1516 : 		//if (pwrlevEngine2 <= 1.0f)
; 1517 : 		else if ((pwrlevEngine2 <= 1.0f && rpm2 <= 1.0f) || (pwrlevEngine2 > 1.0f && rpm2 <= 1.0f))

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR [eax+1532]
	jb	SHORT $LN50@MultiEngin
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR [ecx+1216]
	jae	SHORT $LN51@MultiEngin
$LN50@MultiEngin:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1532]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	$LN52@MultiEngin
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR [eax+1216]
	jb	$LN52@MultiEngin
$LN51@MultiEngin:

; 1518 : 		{
; 1519 : 			/*-------------------*/
; 1520 : 			/* Mil power or less */
; 1521 : 			/*-------------------*/
; 1522 : 			th12 = Math.TwodInterp (-z, mach, engineData->alt,
; 1523 : 				engineData->mach, engineData->thrust[0], engineData->numAlt,
; 1524 : 				engineData->numMach, &curEngAltBreak, &curEngMachBreak);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 812				; 0000032cH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 816				; 00000330H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR [ecx+edx+28]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+1144]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1116]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?TwodInterp@SIMLIB_MATH_CLASS@@QAEMMMPBM00HHPAH1@Z ; SIMLIB_MATH_CLASS::TwodInterp
	fstp	DWORD PTR _th12$[ebp]

; 1525 : 			th22 = Math.TwodInterp (-z, mach, engineData->alt,
; 1526 : 				engineData->mach, engineData->thrust[1], engineData->numAlt,
; 1527 : 				engineData->numMach, &curEngAltBreak, &curEngMachBreak);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 812				; 0000032cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 816				; 00000330H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR [eax+ecx+28]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+1144]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1116]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?TwodInterp@SIMLIB_MATH_CLASS@@QAEMMMPBM00HHPAH1@Z ; SIMLIB_MATH_CLASS::TwodInterp
	fstp	DWORD PTR _th22$[ebp]

; 1528 : 			
; 1529 : 			aburnLit2 = FALSE;

	mov	DWORD PTR _aburnLit2$[ebp], 0

; 1530 : 			// sfr: reverting back code
; 1531 : 			thrtb2 = ((th22 - th12)*pwrlevEngine2 + th12) / mass;

	movss	xmm0, DWORD PTR _th22$[ebp]
	subss	xmm0, DWORD PTR _th12$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [edx+1532]
	addss	xmm0, DWORD PTR _th12$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [eax+40]
	movss	DWORD PTR _thrtb2$[ebp], xmm0

; 1532 : 			//thrtb2 = (3.33f*(th22 - th12)*(rpm2 - 0.7f) + th12)/ mass; // old saints code
; 1533 : 			rpmCmd2 = 0.7F + 0.3F * pwrlevEngine2;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3e99999a
	mulss	xmm0, DWORD PTR [ecx+1532]
	addss	xmm0, DWORD PTR __real@3f333333
	movss	DWORD PTR _rpmCmd2$[ebp], xmm0

; 1534 : 			// sfr: added per instructions
; 1535 : 			// sfr: commenting dup line
; 1536 : 			//Engine2RpmMods(rpmCmd2);
; 1537 : 			rpmCmd2 = Engine2RpmMods(rpmCmd2);

	push	ecx
	movss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Engine2RpmMods@AirframeClass@@QAEMM@Z	; AirframeClass::Engine2RpmMods
	fstp	DWORD PTR _rpmCmd2$[ebp]

; 1538 : 			//TJL 02/22/04 Add in the alt
; 1539 : 			spoolrate2 = spoolAltRate + spoolrate2;

	movss	xmm0, DWORD PTR _spoolAltRate$[ebp]
	addss	xmm0, DWORD PTR _spoolrate2$[ebp]
	movss	DWORD PTR _spoolrate2$[ebp], xmm0

; 1540 : 			rpm2 = Math.FLTust (rpmCmd2, spoolrate2, dt, oldRpm2);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 524				; 0000020cH
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _spoolrate2$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?FLTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z	; SIMLIB_MATH_CLASS::FLTust
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+1216]

; 1541 : 			if (fuel > 0.0F){

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+20]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN49@MultiEngin

; 1542 : 				rpm2 = max (rpm2, 0.01F);

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1216]
	comiss	xmm0, DWORD PTR __real@3c23d70a
	jbe	SHORT $LN212@MultiEngin
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1216]
	movss	DWORD PTR tv1742[ebp], xmm0
	jmp	SHORT $LN213@MultiEngin
$LN212@MultiEngin:
	movss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR tv1742[ebp], xmm0
$LN213@MultiEngin:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv1742[ebp]
	movss	DWORD PTR [ecx+1216], xmm0
$LN49@MultiEngin:

; 1543 : 			}
; 1544 : 			// sfr: end added
; 1545 : 
; 1546 : 			// ftit calculated
; 1547 : 			if (rpm2 < 0.9F)

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f666666
	comiss	xmm0, DWORD PTR [edx+1216]
	jbe	SHORT $LN48@MultiEngin

; 1548 : 			{
; 1549 : 				ftit2 = Math.FLTust(5.1F + (rpm2 - 0.7F) / 0.2F * 1.0F, ftitrate, dt, oldFtit2);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1644				; 0000066cH
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _ftitrate
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1216]
	subss	xmm0, DWORD PTR __real@3f333333
	divss	xmm0, DWORD PTR __real@3e4ccccd
	mulss	xmm0, DWORD PTR __real@3f800000
	addss	xmm0, DWORD PTR __real@40a33333
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?FLTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z	; SIMLIB_MATH_CLASS::FLTust
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+1672]
	jmp	SHORT $LN46@MultiEngin
$LN48@MultiEngin:

; 1550 : 			}
; 1551 : 			else if (rpm2 < 1.0F)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR [eax+1216]
	jbe	SHORT $LN46@MultiEngin

; 1552 : 			{
; 1553 : 				ftit2 = Math.FLTust(6.1F + (rpm2 - 0.9F) / 0.1F * 1.5F, ftitrate, dt, oldFtit2);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1644				; 0000066cH
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _ftitrate
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1216]
	subss	xmm0, DWORD PTR __real@3f666666
	divss	xmm0, DWORD PTR __real@3dcccccd
	mulss	xmm0, DWORD PTR __real@3fc00000
	addss	xmm0, DWORD PTR __real@40c33333
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?FLTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z	; SIMLIB_MATH_CLASS::FLTust
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+1672]
$LN46@MultiEngin:

; 1554 : 			}
; 1555 : 		}
; 1556 : 
; 1557 : 		//7.7 AB Power Engine 2
; 1558 : 		//if (pwrlevEngine2 > 1.0f)
; 1559 : 		else

	jmp	$LN45@MultiEngin
$LN52@MultiEngin:

; 1560 : 			/*--------------------------*/
; 1561 : 			/* Some stage of afterburner */
; 1562 : 			/*--------------------------*/
; 1563 : 		{
; 1564 : 			th12 = Math.TwodInterp (-z, mach, engineData->alt,
; 1565 : 				engineData->mach, engineData->thrust[1], engineData->numAlt,
; 1566 : 				engineData->numMach, &curEngAltBreak, &curEngMachBreak);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 812				; 0000032cH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 816				; 00000330H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR [ecx+edx+28]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+1144]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1116]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?TwodInterp@SIMLIB_MATH_CLASS@@QAEMMMPBM00HHPAH1@Z ; SIMLIB_MATH_CLASS::TwodInterp
	fstp	DWORD PTR _th12$[ebp]

; 1567 : 			th22 = Math.TwodInterp (-z, mach, engineData->alt,
; 1568 : 				engineData->mach, engineData->thrust[2], engineData->numAlt,
; 1569 : 				engineData->numMach, &curEngAltBreak, &curEngMachBreak);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 812				; 0000032cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 816				; 00000330H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR [eax+ecx+28]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+1144]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1116]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?TwodInterp@SIMLIB_MATH_CLASS@@QAEMMMPBM00HHPAH1@Z ; SIMLIB_MATH_CLASS::TwodInterp
	fstp	DWORD PTR _th22$[ebp]

; 1570 : 			
; 1571 : 			aburnLit2 = TRUE;

	mov	DWORD PTR _aburnLit2$[ebp], 1

; 1572 : 			// sfr: reverting back code
; 1573 : 			thrtb2 = (2.0F*(th22 - th12)*(pwrlevEngine2-1.0F) + th12) / mass;

	movss	xmm0, DWORD PTR _th22$[ebp]
	subss	xmm0, DWORD PTR _th12$[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+1532]
	subss	xmm1, DWORD PTR __real@3f800000
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR _th12$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [eax+40]
	movss	DWORD PTR _thrtb2$[ebp], xmm0

; 1574 : 			//thrtb2 = (3.33F*(th22 - th12)*(rpm2 - 0.7F) + th12) / mass; // old saints code
; 1575 : 			rpmCmd2 = 1.0F + 0.06F * (pwrlevEngine2 - 1.0F);

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1532]
	subss	xmm0, DWORD PTR __real@3f800000
	mulss	xmm0, DWORD PTR __real@3d75c28f
	addss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _rpmCmd2$[ebp], xmm0

; 1576 : 			// sfr: added per instructions
; 1577 : 			// sfr: removing dup line
; 1578 : 			//Engine2RpmMods(rpmCmd2);
; 1579 : 			rpmCmd2 = Engine2RpmMods(rpmCmd);

	push	ecx
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Engine2RpmMods@AirframeClass@@QAEMM@Z	; AirframeClass::Engine2RpmMods
	fstp	DWORD PTR _rpmCmd2$[ebp]

; 1580 : 			//TJL 02/22/04 Add in the alt
; 1581 : 			spoolrate2 = spoolAltRate + spoolrate2;

	movss	xmm0, DWORD PTR _spoolAltRate$[ebp]
	addss	xmm0, DWORD PTR _spoolrate2$[ebp]
	movss	DWORD PTR _spoolrate2$[ebp], xmm0

; 1582 : 			rpm2 = Math.FLTust (rpmCmd2, spoolrate2, dt, oldRpm2);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 524				; 0000020cH
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _spoolrate2$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?FLTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z	; SIMLIB_MATH_CLASS::FLTust
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+1216]

; 1583 : 			if (fuel > 0.0F){

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+20]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN44@MultiEngin

; 1584 : 				rpm2 = max (rpm2, 0.01F);

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1216]
	comiss	xmm0, DWORD PTR __real@3c23d70a
	jbe	SHORT $LN214@MultiEngin
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1216]
	movss	DWORD PTR tv1867[ebp], xmm0
	jmp	SHORT $LN215@MultiEngin
$LN214@MultiEngin:
	movss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR tv1867[ebp], xmm0
$LN215@MultiEngin:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv1867[ebp]
	movss	DWORD PTR [ecx+1216], xmm0
$LN44@MultiEngin:

; 1585 : 			}
; 1586 : 			// sfr: end added
; 1587 : 
; 1588 : 			// ftit calculated
; 1589 : 			ftit2 = Math.FLTust(7.6F + (rpm2 - 1.0F) / 0.03F * 0.1F, ftitrate, dt, oldFtit2);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1644				; 0000066cH
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _ftitrate
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1216]
	subss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR __real@3cf5c28f
	mulss	xmm0, DWORD PTR __real@3dcccccd
	addss	xmm0, DWORD PTR __real@40f33333
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?FLTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z	; SIMLIB_MATH_CLASS::FLTust
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+1672]
$LN45@MultiEngin:

; 1590 : 		}
; 1591 : 
; 1592 : 		/*--------------------------------*/
; 1593 : 		/* scale thrust to reference area */
; 1594 : 		/*--------------------------------*/
; 1595 : 		thrtab2 = thrtb2;//Engine 2

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _thrtb2$[ebp]
	movss	DWORD PTR [edx+208], xmm0

; 1596 : 
; 1597 : 		//7.8
; 1598 : 		/*-----------------*/
; 1599 : 		/* engine dynamics */
; 1600 : 		/*-----------------*/
; 1601 : 		if(IsSet(Trimming))// || simpleMode == SIMPLE_MODE_AF)

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	$LN43@MultiEngin

; 1602 : 		{
; 1603 : 			//Engine 2
; 1604 : 			ethrst2 = 1.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+224], xmm0

; 1605 : 			tgross2 = thrtab2;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+208]
	movss	DWORD PTR _tgross2$[ebp], xmm0

; 1606 : 			olda012[0] = tgross2;

	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _tgross2$[ebp]
	movss	DWORD PTR [eax+edx+572], xmm0

; 1607 : 			olda012[1] = tgross2;

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _tgross2$[ebp]
	movss	DWORD PTR [edx+ecx+572], xmm0

; 1608 : 			olda012[2] = tgross2;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _tgross2$[ebp]
	movss	DWORD PTR [ecx+eax+572], xmm0

; 1609 : 			olda012[3] = tgross2;

	mov	edx, 4
	imul	edx, 3
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _tgross2$[ebp]
	movss	DWORD PTR [eax+edx+572], xmm0

; 1610 : 			
; 1611 : 			rpm2 = rpmCmd2;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _rpmCmd2$[ebp]
	movss	DWORD PTR [ecx+1216], xmm0

; 1612 : 			oldRpm2[0] = rpm2;

	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1216]
	mov	DWORD PTR [eax+edx+524], ecx

; 1613 : 			oldRpm2[1] = rpm2;

	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1216]
	mov	DWORD PTR [eax+edx+524], ecx

; 1614 : 			oldRpm2[2] = rpm2;

	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1216]
	mov	DWORD PTR [eax+edx+524], ecx

; 1615 : 			oldRpm2[3] = rpm2;

	mov	edx, 4
	imul	edx, 3
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1216]
	mov	DWORD PTR [eax+edx+524], ecx

; 1616 : 		}
; 1617 : 
; 1618 : 		//7.9
; 1619 : 		else

	jmp	SHORT $LN42@MultiEngin
$LN43@MultiEngin:

; 1620 : 		{
; 1621 : 			tgross2 = thrtab2;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+208]
	movss	DWORD PTR _tgross2$[ebp], xmm0
$LN42@MultiEngin:

; 1622 : 			//TJL 08/21/04 This lag filter no longer needed
; 1623 : 			/*
; 1624 : 			//Engine 2
; 1625 : 			if(aburnLit2)
; 1626 : 			{
; 1627 : 				//AB
; 1628 : 				ta02 = auxaeroData->abSpoolRate + spoolAltRate;
; 1629 : 				tgross2 = Math.FLTust(thrtab2,ta02,dt,olda012);
; 1630 : 			}
; 1631 : 			else
; 1632 : 			{
; 1633 : 				//MIL
; 1634 : 				if(pwrlevEngine2 <= 1.0F)
; 1635 : 					ta02 = auxaeroData->normSpoolRate + spoolAltRate;
; 1636 : 				else
; 1637 : 					ta02 = auxaeroData->abSpoolRate + spoolAltRate;
; 1638 : 				
; 1639 : 				tgross2 = Math.FLTust(thrtab2,ta02,dt,olda012);
; 1640 : 			}*/
; 1641 : 
; 1642 : 		}
; 1643 : 		
; 1644 : 		//7.10
; 1645 : 		/*-----------*/
; 1646 : 		/* burn fuel */
; 1647 : 		/*-----------*/
; 1648 : 		if (AvailableFuel() <= 0.0f || IsEngineFlag(MasterFuelOff)) { // no fuel - dead engine.

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AvailableFuel@AirframeClass@@QAEMXZ	; AirframeClass::AvailableFuel
	fstp	DWORD PTR tv3965[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR tv3965[ebp]
	jae	SHORT $LN40@MultiEngin
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsEngineFlag@AirframeClass@@QAEHW4EngineFlags@1@@Z ; AirframeClass::IsEngineFlag
	test	eax, eax
	je	SHORT $LN41@MultiEngin
$LN40@MultiEngin:

; 1649 : 			SetEngineFlag(EngineStopped2);

	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetEngineFlag@AirframeClass@@QAEXW4EngineFlags@1@@Z ; AirframeClass::SetEngineFlag

; 1650 : 			// mark it as a flame out
; 1651 : 			platform->mFaults->SetFault(FaultClass::eng2_fault, FaultClass::fl_out, FaultClass::fail, FALSE);

	push	0
	push	2
	push	-2147483648				; 80000000H
	push	9
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	mov	ecx, DWORD PTR [ecx+928]
	call	?SetFault@FackClass@@QAEXW4type_FSubSystem@FaultClass@@W4type_FFunction@3@W4type_FSeverity@3@H@Z ; FackClass::SetFault

; 1652 : 		}
; 1653 : 		else

	jmp	$LN30@MultiEngin
$LN41@MultiEngin:

; 1654 : 		{
; 1655 : 			// JPO - back to basics... this stuff doesn't have to be complicated surely.
; 1656 : 			// fuel flow is proportional to thrust.
; 1657 : 			// thrust factor is already in, its just that tgross is thrust/mass, 
; 1658 : 			// so we get rid of the mass component again.
; 1659 : 			if(engineData->hasFuelFlow) // MLR 5/17/2004 - 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	DWORD PTR [eax+52], 0
	je	$LN38@MultiEngin

; 1660 : 			{
; 1661 : 				// sfr: new fuel code per instructions
; 1662 : 				if(aburnLit2 == TRUE)

	cmp	DWORD PTR _aburnLit2$[ebp], 1
	jne	$LN37@MultiEngin

; 1663 : 				{
; 1664 : 					float fflow1, fflow2;
; 1665 : 
; 1666 : 					fflow1 = Math.TwodInterp (-z, mach, engineData->alt,
; 1667 : 						engineData->mach, engineData->fuelflow[1],engineData->numAlt,
; 1668 : 						engineData->numMach, &curEngAltBreak, &curEngMachBreak);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 812				; 0000032cH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 816				; 00000330H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR [ecx+edx+40]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+1144]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1116]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?TwodInterp@SIMLIB_MATH_CLASS@@QAEMMMPBM00HHPAH1@Z ; SIMLIB_MATH_CLASS::TwodInterp
	fstp	DWORD PTR _fflow1$16[ebp]

; 1669 : 					fflow2 = Math.TwodInterp (-z, mach, engineData->alt,
; 1670 : 						engineData->mach, engineData->fuelflow[2],engineData->numAlt,
; 1671 : 						engineData->numMach, &curEngAltBreak, &curEngMachBreak);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 812				; 0000032cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 816				; 00000330H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR [eax+ecx+40]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+1144]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1116]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?TwodInterp@SIMLIB_MATH_CLASS@@QAEMMMPBM00HHPAH1@Z ; SIMLIB_MATH_CLASS::TwodInterp
	fstp	DWORD PTR _fflow2$14[ebp]

; 1672 : 					
; 1673 : 					
; 1674 : 					//fuelFlowSS = (33.3333333F*(fflow2 - fflow1)*(rpm-1.0F) + fflow1);
; 1675 : 					 fuelFlowSS = (2.0F * ( fflow2 - fflow1)* (pwrlev - 1.0F) + fflow1);

	movss	xmm0, DWORD PTR _fflow2$14[ebp]
	subss	xmm0, DWORD PTR _fflow1$16[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+1516]
	subss	xmm1, DWORD PTR __real@3f800000
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR _fflow1$16[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+96], xmm0

; 1676 : 				}
; 1677 : 				else

	jmp	$LN36@MultiEngin
$LN37@MultiEngin:

; 1678 : 				{ 
; 1679 : 					float fflow1, fflow2;
; 1680 : 
; 1681 : 					fflow1 = Math.TwodInterp (-z, mach, engineData->alt,
; 1682 : 						engineData->mach, engineData->fuelflow[0],engineData->numAlt,
; 1683 : 						engineData->numMach, &curEngAltBreak, &curEngMachBreak);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 812				; 0000032cH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 816				; 00000330H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR [ecx+edx+40]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+1144]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1116]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?TwodInterp@SIMLIB_MATH_CLASS@@QAEMMMPBM00HHPAH1@Z ; SIMLIB_MATH_CLASS::TwodInterp
	fstp	DWORD PTR _fflow1$20[ebp]

; 1684 : 					fflow2 = Math.TwodInterp (-z, mach, engineData->alt,
; 1685 : 						engineData->mach, engineData->fuelflow[1],engineData->numAlt,
; 1686 : 						engineData->numMach, &curEngAltBreak, &curEngMachBreak);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 812				; 0000032cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 816				; 00000330H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR [eax+ecx+40]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+1144]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1116]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?TwodInterp@SIMLIB_MATH_CLASS@@QAEMMMPBM00HHPAH1@Z ; SIMLIB_MATH_CLASS::TwodInterp
	fstp	DWORD PTR _fflow2$13[ebp]

; 1687 : 
; 1688 : 					//fuelFlowSS = ((fflow2 - fflow1)*(rpm-.7f)*3.33333f + fflow1);
; 1689 : 					fuelFlowSS = (fflow2 - fflow1)* pwrlev + fflow1;

	movss	xmm0, DWORD PTR _fflow2$13[ebp]
	subss	xmm0, DWORD PTR _fflow1$20[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [edx+1516]
	addss	xmm0, DWORD PTR _fflow1$20[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+96], xmm0
$LN36@MultiEngin:

; 1690 : 				}
; 1691 : 				// end fuel
; 1692 : 
; 1693 : #if 0
; 1694 : 				if(rpm2>1.0)
; 1695 : 				{
; 1696 : 					float fflow1, fflow2;
; 1697 : 
; 1698 : 					fflow1 = Math.TwodInterp (-z, mach, engineData->alt,
; 1699 : 						engineData->mach, engineData->fuelflow[1],engineData->numAlt,
; 1700 : 						engineData->numMach, &curEngAltBreak, &curEngMachBreak);
; 1701 : 					fflow2 = Math.TwodInterp (-z, mach, engineData->alt,
; 1702 : 						engineData->mach, engineData->fuelflow[2],engineData->numAlt,
; 1703 : 						engineData->numMach, &curEngAltBreak, &curEngMachBreak);
; 1704 : 					
; 1705 : 					
; 1706 : 					fuelFlowSS2 = (33.3333333F*(fflow2 - fflow1)*(rpm2-1.0F) + fflow1);
; 1707 : 				}
; 1708 : 				else
; 1709 : 				{ 
; 1710 : 					float fflow1, fflow2;
; 1711 : 
; 1712 : 					fflow1 = Math.TwodInterp (-z, mach, engineData->alt,
; 1713 : 						engineData->mach, engineData->fuelflow[0],engineData->numAlt,
; 1714 : 						engineData->numMach, &curEngAltBreak, &curEngMachBreak);
; 1715 : 					fflow2 = Math.TwodInterp (-z, mach, engineData->alt,
; 1716 : 						engineData->mach, engineData->fuelflow[1],engineData->numAlt,
; 1717 : 						engineData->numMach, &curEngAltBreak, &curEngMachBreak);
; 1718 : 
; 1719 : 					fuelFlowSS2 = ((fflow2 - fflow1)*(rpm2-.7f)*3.33333f + fflow1);
; 1720 : 				}
; 1721 : #endif
; 1722 : 			}
; 1723 : 			else

	jmp	SHORT $LN33@MultiEngin
$LN38@MultiEngin:

; 1724 : 			{
; 1725 : 				if (aburnLit2)

	cmp	DWORD PTR _aburnLit2$[ebp], 0
	je	SHORT $LN34@MultiEngin

; 1726 : 				{
; 1727 : 					fuelFlowSS2 =  auxaeroData->fuelFlowFactorAb * tgross2  * mass;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movss	xmm0, DWORD PTR [edx+4]
	mulss	xmm0, DWORD PTR _tgross2$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [eax+40]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+100], xmm0

; 1728 : 				}
; 1729 : 				else

	jmp	SHORT $LN33@MultiEngin
$LN34@MultiEngin:

; 1730 : 				{ 
; 1731 : 					fuelFlowSS2 = auxaeroData->fuelFlowFactorNormal * tgross2 * mass;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR _tgross2$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [ecx+40]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+100], xmm0
$LN33@MultiEngin:

; 1732 : 				}
; 1733 : 			}
; 1734 : 
; 1735 : 			fuelFlow2 += (fuelFlowSS2 -fuelFlow2)/10;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+100]
	subss	xmm0, DWORD PTR [ecx+28]
	divss	xmm0, DWORD PTR __real@41200000
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+28]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+28], xmm0

; 1736 : 
; 1737 : 			//Engine 2
; 1738 : 			if (fuelFlow2 < auxaeroData->minFuelFlow)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+8]
	comiss	xmm0, DWORD PTR [eax+28]
	jbe	SHORT $LN32@MultiEngin

; 1739 : 				fuelFlow2 = auxaeroData->minFuelFlow;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+28], ecx
$LN32@MultiEngin:

; 1740 : 			if (fuelFlowSS2 < auxaeroData->minFuelFlow)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	comiss	xmm0, DWORD PTR [ecx+100]
	jbe	SHORT $LN31@MultiEngin

; 1741 : 				fuelFlowSS2 = auxaeroData->minFuelFlow;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+100], edx
$LN31@MultiEngin:

; 1742 : /*
; 1743 : 			//Total Fuel Burn
; 1744 : 			fuelFlowTotal = fuelFlowSS + fuelFlowSS2;
; 1745 : 			// Throw CBEFuelFlow the Total so the indicator works
; 1746 : 			fuelFlow = fuelFlowTotal;
; 1747 : 			*/
; 1748 : 
; 1749 : 			if (!IsSet(NoFuelBurn))

	push	16384					; 00004000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	jne	SHORT $LN30@MultiEngin

; 1750 : 			{
; 1751 : 				// JPO - fuel is now burnt and transferred.
; 1752 : 				//Using combined total between engines
; 1753 : 				BurnFuel(fuelFlowSS2 * dt / 3600.0F);     

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+100]
	mulss	xmm0, DWORD PTR _dt$[ebp]
	divss	xmm0, DWORD PTR __real@45610000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BurnFuel@AirframeClass@@QAEHM@Z	; AirframeClass::BurnFuel

; 1754 : 				weight -= fuelFlowSS2 * dt / 3600.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+100]
	mulss	xmm0, DWORD PTR _dt$[ebp]
	divss	xmm0, DWORD PTR __real@45610000
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+44]
	subss	xmm1, xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+44], xmm1

; 1755 : 				mass    = weight / GRAVITY;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+44]
	divss	xmm0, DWORD PTR __real@4200b53f
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+40], xmm0
$LN30@MultiEngin:

; 1756 : 			}
; 1757 : 
; 1758 : 		}
; 1759 : 
; 1760 : 
; 1761 : 		//TJL 02/21/04 
; 1762 : 		// sfr: commenting out, done inside if else
; 1763 : 		/*Engine2RpmMods(rpmCmd2);
; 1764 : 		rpmCmd2 = Engine2RpmMods(rpmCmd2);
; 1765 : 		spoolrate2 = spoolrate2 + spoolAltRate;
; 1766 : 
; 1767 : 		rpm2 = Math.FLTust (rpmCmd2, spoolrate2, dt, oldRpm2);
; 1768 : 		if (fuel > 0.0F)
; 1769 : 			rpm2 = max (rpm2, 0.01F);
; 1770 : 			*/
; 1771 : 		
; 1772 : 		// ADDED BY S.G. TO SIMULATE THE HEAT PRODUCED BY THE ENGINE
; 1773 : 		// I'M USING A PREVIOUSLY UNUSED ARRAY CALLED oldp01 FOR ENGINE HEAT TEMPERATURE
; 1774 : 		// Afterburner lit?
; 1775 : 
; 1776 : 		//Engine 2
; 1777 : 		if (rpm2 > 100.0f)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1216]
	comiss	xmm0, DWORD PTR __real@42c80000
	jbe	SHORT $LN29@MultiEngin

; 1778 : 			Math.FLTust (rpm2 + 0.5f, 0.5F, dt, oldp01Eng2);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 548				; 00000224H
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1216]
	addss	xmm0, DWORD PTR __real@3f000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?FLTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z	; SIMLIB_MATH_CLASS::FLTust
	fstp	ST(0)

; 1779 : 		else {

	jmp	$LN24@MultiEngin
$LN29@MultiEngin:

; 1780 : 			// the 'modified rpm will be rpm^4.5
; 1781 : 			float modRpm2 = (float)(rpm2*rpm2*rpm2*rpm2*sqrt(rpm2));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1216]
	mulss	xmm0, DWORD PTR [ecx+1216]
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [edx+1216]
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [eax+1216]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm1, DWORD PTR [ecx+1216]
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv4391[ebp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR tv4121[ebp]
	movss	xmm0, DWORD PTR tv4391[ebp]
	mulss	xmm0, DWORD PTR tv4121[ebp]
	movss	DWORD PTR _modRpm2$21[ebp], xmm0

; 1782 : 			
; 1783 : 			// Am I increasing the rpm (but not yet in afterburner)?
; 1784 : 			if (rpm2 > oldp01Eng2[0])

	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1216]
	comiss	xmm0, DWORD PTR [ecx+edx+548]
	jbe	SHORT $LN27@MultiEngin

; 1785 : 				Math.FLTust (modRpm2, 4.0F, dt, oldp01Eng2);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 548				; 00000224H
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@40800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _modRpm2$21[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?FLTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z	; SIMLIB_MATH_CLASS::FLTust
	fstp	ST(0)

; 1786 : 			// Must be decreasing then...
; 1787 : 			else {

	jmp	$LN24@MultiEngin
$LN27@MultiEngin:

; 1788 : 				// Now check if the 'heat' is still above 1.00 (100%)
; 1789 : 				if (oldp01Eng2[0] > 1.0F)

	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+548]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN25@MultiEngin

; 1790 : 					Math.FLTust (modRpm2, 7.0F, dt, oldp01Eng2);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 548				; 00000224H
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@40e00000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _modRpm2$21[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?FLTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z	; SIMLIB_MATH_CLASS::FLTust
	fstp	ST(0)

; 1791 : 				else

	jmp	SHORT $LN24@MultiEngin
$LN25@MultiEngin:

; 1792 : 					Math.FLTust (modRpm2, 2.0F, dt, oldp01Eng2);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 548				; 00000224H
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _modRpm2$21[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?FLTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z	; SIMLIB_MATH_CLASS::FLTust
	fstp	ST(0)
$LN24@MultiEngin:

; 1793 : 			}
; 1794 : 
; 1795 : 		}
; 1796 : 
; 1797 : 		//Total Thrust
; 1798 : 		//thrust = ((tgross * ethrst) + (tgross2 * ethrst2));
; 1799 : 		
; 1800 : 		//There is code everywhere 
; 1801 : 		if(stallMode >= EnteringDeepStall)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1248], 3
	jl	SHORT $LN23@MultiEngin

; 1802 : 			thrust *= 0.1f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+188]
	mulss	xmm0, DWORD PTR __real@3dcccccd
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+188], xmm0
$LN23@MultiEngin:

; 1803 : 		
; 1804 :    }
; 1805 :    else

	jmp	$LN22@MultiEngin
$LN68@MultiEngin:

; 1806 :    {
; 1807 : 	   if (IsSet(ThrottleCheck))

	push	65536					; 00010000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	$LN21@MultiEngin

; 1808 : 	   {
; 1809 : 			//Engine 2
; 1810 : 		   if(engine2Throttle >= 1.5F)

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1524]
	comiss	xmm0, DWORD PTR __real@3fc00000
	jb	SHORT $LN20@MultiEngin

; 1811 : 			   engine2Throttle = pwrlevEngine2;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1532]
	mov	DWORD PTR [edx+1524], ecx
$LN20@MultiEngin:

; 1812 : 		   if (fabs (engine2Throttle - pwrlevEngine2) > 0.1F)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1524]
	subss	xmm0, DWORD PTR [eax+1532]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv4167[ebp]
	movss	xmm0, DWORD PTR tv4167[ebp]
	comiss	xmm0, DWORD PTR __real@3dcccccd
	jbe	SHORT $LN19@MultiEngin

; 1813 : 			   ClearFlag(ThrottleCheck);

	push	65536					; 00010000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearFlag@AirframeClass@@QAEXH@Z	; AirframeClass::ClearFlag
$LN19@MultiEngin:

; 1814 : 		   pwrlevEngine2 = engine2Throttle;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1524]
	mov	DWORD PTR [ecx+1532], eax

; 1815 : 
; 1816 : 	   }
; 1817 : 	   else

	jmp	SHORT $LN17@MultiEngin
$LN21@MultiEngin:

; 1818 : 	   {
; 1819 : 		   if (fabs (engine2Throttle - pwrlevEngine2) > 0.1F)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1524]
	subss	xmm0, DWORD PTR [edx+1532]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv4178[ebp]
	movss	xmm0, DWORD PTR tv4178[ebp]
	comiss	xmm0, DWORD PTR __real@3dcccccd
	jbe	SHORT $LN17@MultiEngin

; 1820 : 		   {
; 1821 : 			   ClearFlag (EngineOff2);

	push	536870912				; 20000000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearFlag@AirframeClass@@QAEXH@Z	; AirframeClass::ClearFlag
$LN17@MultiEngin:

; 1822 : 		   }
; 1823 : 	   }
; 1824 : 	   
; 1825 : 	   thrust   = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+188], xmm0

; 1826 : 	   tgross2	= 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _tgross2$[ebp], xmm0

; 1827 : 	   fuelFlow2= 0.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+28], xmm0

; 1828 : 	   rpm2		= oldRpm2[0];

	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+edx+524]
	mov	DWORD PTR [eax+1216], edx

; 1829 : 	   ftit2	= 5.85f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@40bb3333
	movss	DWORD PTR [eax+1672], xmm0
$LN22@MultiEngin:

; 1830 :    }
; 1831 : 
; 1832 : 
; 1833 : // END 
; 1834 : //****************************************
; 1835 : 
; 1836 : //Merge Engine 1 and Engine 2 Data
; 1837 :    //Total Thrust
; 1838 :    //Clamp Thrust when below idle
; 1839 :    if (rpm <= 0.7f)

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f333333
	comiss	xmm0, DWORD PTR [ecx+1212]
	jb	SHORT $LN16@MultiEngin

; 1840 : 		thrust1 = 0.01f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR [edx+192], xmm0

; 1841 :    else 

	jmp	SHORT $LN15@MultiEngin
$LN16@MultiEngin:

; 1842 : 		thrust1 = (tgross * ethrst);

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _tgross$[ebp]
	mulss	xmm0, DWORD PTR [eax+204]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+192], xmm0
$LN15@MultiEngin:

; 1843 : 
; 1844 :    if (rpm2 <= 0.7f)

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f333333
	comiss	xmm0, DWORD PTR [edx+1216]
	jb	SHORT $LN14@MultiEngin

; 1845 : 		thrust2 = 0.01f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR [eax+212], xmm0

; 1846 :    else

	jmp	SHORT $LN13@MultiEngin
$LN14@MultiEngin:

; 1847 : 		thrust2 = (tgross2 * ethrst2);

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _tgross2$[ebp]
	mulss	xmm0, DWORD PTR [ecx+224]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+212], xmm0
$LN13@MultiEngin:

; 1848 :    
; 1849 :    //combined
; 1850 : 	thrust = ( thrust1 + thrust2 );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+192]
	addss	xmm0, DWORD PTR [ecx+212]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+188], xmm0

; 1851 : 	//Cobra Thrust Reverse
; 1852 : 	if (auxaeroData->hasThrRev){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+4028], 0
	je	$LN8@MultiEngin

; 1853 : 		if (platform->OnGround() && thrustReverse == 2){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1088]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+1088]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	je	SHORT $LN11@MultiEngin
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1592], 2
	jne	SHORT $LN11@MultiEngin

; 1854 : 			thrust = (-thrust * 0.40f);

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+188]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR __real@3ecccccd
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+188], xmm0
$LN11@MultiEngin:

; 1855 : 		}
; 1856 : 		//Cobra Thrust Reverse
; 1857 : 		static int doOnce = 0;
; 1858 : 		if (platform->IsPlayer() && thrustReverse == 2 && doOnce == 0){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1088]
	call	?IsPlayer@FalconEntity@@QAEHXZ		; FalconEntity::IsPlayer
	test	eax, eax
	je	SHORT $LN10@MultiEngin
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1592], 2
	jne	SHORT $LN10@MultiEngin
	cmp	DWORD PTR ?doOnce@?BFC@??MultiEngineModel@AirframeClass@@QAEXM@Z@4HA, 0
	jne	SHORT $LN10@MultiEngin

; 1859 : 			OTWDriver.ToggleThrustReverseDisplay();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?ToggleThrustReverseDisplay@OTWDriverClass@@QAEXXZ ; OTWDriverClass::ToggleThrustReverseDisplay

; 1860 : 			doOnce = 1;

	mov	DWORD PTR ?doOnce@?BFC@??MultiEngineModel@AirframeClass@@QAEXM@Z@4HA, 1
	jmp	SHORT $LN8@MultiEngin
$LN10@MultiEngin:

; 1861 : 		}
; 1862 : 		else if (platform->IsPlayer() && thrustReverse == 0 && doOnce == 1){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	call	?IsPlayer@FalconEntity@@QAEHXZ		; FalconEntity::IsPlayer
	test	eax, eax
	je	SHORT $LN8@MultiEngin
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1592], 0
	jne	SHORT $LN8@MultiEngin
	cmp	DWORD PTR ?doOnce@?BFC@??MultiEngineModel@AirframeClass@@QAEXM@Z@4HA, 1
	jne	SHORT $LN8@MultiEngin

; 1863 : 			OTWDriver.ToggleThrustReverseDisplay();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?ToggleThrustReverseDisplay@OTWDriverClass@@QAEXXZ ; OTWDriverClass::ToggleThrustReverseDisplay

; 1864 : 			doOnce = 0;

	mov	DWORD PTR ?doOnce@?BFC@??MultiEngineModel@AirframeClass@@QAEXM@Z@4HA, 0
$LN8@MultiEngin:

; 1865 : 		}
; 1866 : 	}
; 1867 : 
; 1868 : 	//Total Fuel Burn
; 1869 : 	fuelFlowTotal = fuelFlowSS + fuelFlowSS2;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+96]
	addss	xmm0, DWORD PTR [eax+100]
	movss	DWORD PTR _fuelFlowTotal$[ebp], xmm0

; 1870 : 	// Throw CBEFuelFlow the Total so the cockpit indicator works
; 1871 : 	fuelFlow = fuelFlowTotal;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _fuelFlowTotal$[ebp]
	movss	DWORD PTR [ecx+24], xmm0

; 1872 : 
; 1873 : 	//TJL 09/11/04 
; 1874 : 	//TODO QC this
; 1875 : 	CalcFtit(ftitLeft, ftitRight);

	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+108]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+104]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalcFtit@AirframeClass@@QAEMMM@Z	; AirframeClass::CalcFtit
	fstp	ST(0)

; 1876 : 
; 1877 : 
; 1878 :    // turn on stdby generator
; 1879 :    if (rpm > auxaeroData->stbyGenRpm && platform->MainPowerOn()) {

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1212]
	comiss	xmm0, DWORD PTR [edx+48]
	jbe	SHORT $LN7@MultiEngin
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1088]
	call	?MainPowerOn@AircraftClass@@QAEHXZ	; AircraftClass::MainPowerOn
	test	eax, eax
	je	SHORT $LN7@MultiEngin

; 1880 :        GeneratorOn(GenStdby);

	push	64					; 00000040H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GeneratorOn@AirframeClass@@QAEXW4Generator@1@@Z ; AirframeClass::GeneratorOn

; 1881 :    }
; 1882 :    else

	jmp	SHORT $LN6@MultiEngin
$LN7@MultiEngin:

; 1883 : 	   GeneratorOff(GenStdby);

	push	64					; 00000040H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GeneratorOff@AirframeClass@@QAEXW4Generator@1@@Z ; AirframeClass::GeneratorOff
$LN6@MultiEngin:

; 1884 :    
; 1885 :    // tunr on main generator
; 1886 :    if (rpm > auxaeroData->mainGenRpm && platform->MainPowerOn()) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1212]
	comiss	xmm0, DWORD PTR [eax+44]
	jbe	SHORT $LN5@MultiEngin
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1088]
	call	?MainPowerOn@AircraftClass@@QAEHXZ	; AircraftClass::MainPowerOn
	test	eax, eax
	je	SHORT $LN5@MultiEngin

; 1887 :        GeneratorOn(GenMain);

	push	1024					; 00000400H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GeneratorOn@AirframeClass@@QAEXW4Generator@1@@Z ; AirframeClass::GeneratorOn

; 1888 :    }
; 1889 :    else

	jmp	SHORT $LN4@MultiEngin
$LN5@MultiEngin:

; 1890 : 	   GeneratorOff(GenMain);

	push	1024					; 00000400H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GeneratorOff@AirframeClass@@QAEXW4Generator@1@@Z ; AirframeClass::GeneratorOff
$LN4@MultiEngin:

; 1891 :    
; 1892 :    if (IsSet(OnObject) && vcas < 175) // JB carrier

	push	1073741824				; 40000000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN3@MultiEngin
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@432f0000
	comiss	xmm0, DWORD PTR [eax+1124]
	jbe	SHORT $LN3@MultiEngin

; 1893 : 	   // RV - Biker - Use catapult thrust multiplier from FMs
; 1894 : 	   //thrust *= 4;
; 1895 : 	   thrust *= GetCatapultThrustMultiplier();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCatapultThrustMultiplier@AirframeClass@@QAEMXZ ; AirframeClass::GetCatapultThrustMultiplier
	fstp	DWORD PTR tv4250[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv4250[ebp]
	mulss	xmm0, DWORD PTR [ecx+188]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+188], xmm0
$LN3@MultiEngin:

; 1896 :   
; 1897 :    /*------------------*/
; 1898 :    /* body axis accels */
; 1899 :    /*------------------*/
; 1900 :    if (nozzlePos == 0) { // normal case JPO

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1808]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN2@MultiEngin

; 1901 : 	   xprop =  thrust;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+188]
	mov	DWORD PTR [ecx+760], eax

; 1902 : 	   yprop =  0.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+764], xmm0

; 1903 : 	   zprop =  0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+768], xmm0

; 1904 : 	   /*-----------------------*/
; 1905 : 	   /* stability axis accels */
; 1906 : 	   /*-----------------------*/
; 1907 : 	   xsprop =  xprop *platform->platformAngles.cosalp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+760]
	mulss	xmm0, DWORD PTR [ecx+344]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+772], xmm0

; 1908 : 	   ysprop =  yprop;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+764]
	mov	DWORD PTR [ecx+776], eax

; 1909 : 	   //   zsprop = 0.0F;		//assume flcs cancels this out? (makes life easier)
; 1910 : 	   //   zsprop = -thrust*platform->platformAngles.sinalp * 0.001F; //why the 0.001F ?
; 1911 : 	   //	zsprop = -thrust*platform->platformAngles.sinalp; // JPO previous
; 1912 : 	   zsprop = - xprop * platform->platformAngles.sinalp;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+760]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1088]
	mulss	xmm0, DWORD PTR [eax+340]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+780], xmm0

; 1913 :    }
; 1914 :    else { // harrier fake stuff - doesn't really work.

	jmp	$LN1@MultiEngin
$LN2@MultiEngin:

; 1915 : 	   mlTrig noz;
; 1916 : 	   mlSinCos(&noz, nozzlePos);

	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+1808]
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _noz$8[ebp]
	push	eax
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 1917 : 	   xprop = thrust * noz.cos;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+188]
	mulss	xmm0, DWORD PTR _noz$8[ebp+4]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+760], xmm0

; 1918 : 	   yprop =  0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+764], xmm0

; 1919 : 	   zprop = -thrust * noz.sin;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+188]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR _noz$8[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+768], xmm0

; 1920 : 	   /*-----------------------*/
; 1921 : 	   /* stability axis accels */
; 1922 : 	   /*-----------------------*/
; 1923 : 	   xsprop =  xprop *platform->platformAngles.cosalp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+760]
	mulss	xmm0, DWORD PTR [ecx+344]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+772], xmm0

; 1924 : 	   ysprop =  yprop;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+764]
	mov	DWORD PTR [ecx+776], eax

; 1925 : 	   //   zsprop = 0.0F;		//assume flcs cancels this out? (makes life easier)
; 1926 : 	   //   zsprop = -thrust*platform->platformAngles.sinalp * 0.001F; //why the 0.001F ?
; 1927 : 	   //	zsprop = -thrust*platform->platformAngles.sinalp; // JPO previous
; 1928 : 	   zsprop = - xprop * platform->platformAngles.sinalp +
; 1929 : 		   zprop * platform->platformAngles.cosalp;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+760]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1088]
	mulss	xmm0, DWORD PTR [eax+340]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1088]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+768]
	mulss	xmm1, DWORD PTR [edx+344]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+780], xmm0
$LN1@MultiEngin:

; 1930 : 	   
; 1931 :    }
; 1932 :    
; 1933 :    ShiAssert(!_isnan(platform->platformAngles.cosalp));
; 1934 :    ShiAssert(!_isnan(platform->platformAngles.sinalp));
; 1935 :    
; 1936 :    /*------------------*/
; 1937 :    /* wind axis accels */
; 1938 :    /*------------------*/
; 1939 :    xwprop =  xsprop*platform->platformAngles.cosbet +
; 1940 : 	   ysprop*platform->platformAngles.sinbet;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1088]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+772]
	mulss	xmm0, DWORD PTR [eax+356]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1088]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+776]
	mulss	xmm1, DWORD PTR [eax+352]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+784], xmm0

; 1941 :    ywprop = -xsprop*platform->platformAngles.sinbet +
; 1942 : 	   ysprop*platform->platformAngles.cosbet;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+772]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1088]
	mulss	xmm0, DWORD PTR [edx+352]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+776]
	mulss	xmm1, DWORD PTR [ecx+356]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+788], xmm0

; 1943 :    zwprop =  zsprop;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+780]
	mov	DWORD PTR [ecx+792], eax

; 1944 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?MultiEngineModel@AirframeClass@@QAEXM@Z$0:
	mov	eax, DWORD PTR $T19[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?MultiEngineModel@AirframeClass@@QAEXM@Z$1:
	mov	eax, DWORD PTR $T18[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?MultiEngineModel@AirframeClass@@QAEXM@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-396]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?MultiEngineModel@AirframeClass@@QAEXM@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?MultiEngineModel@AirframeClass@@QAEXM@Z ENDP		; AirframeClass::MultiEngineModel
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\airframe\engine.cpp
_TEXT	SEGMENT
$T2 = -224						; size = 8
$T3 = -216						; size = 8
$T4 = -208						; size = 8
_noz$5 = -200						; size = 8
$T6 = -192						; size = 4
tv2164 = -188						; size = 4
_fflow2$7 = -184					; size = 4
tv1665 = -180						; size = 4
tv2428 = -176						; size = 4
_fflow2$8 = -172					; size = 4
tv2400 = -168						; size = 4
tv1853 = -164						; size = 4
tv2388 = -160						; size = 4
tv1721 = -156						; size = 4
tv2316 = -152						; size = 4
tv2499 = -148						; size = 4
tv2501 = -144						; size = 4
tv1564 = -140						; size = 4
_fflow1$9 = -136					; size = 4
tv593 = -132						; size = 4
_fflow1$10 = -128					; size = 4
$T11 = -124						; size = 4
tv873 = -120						; size = 4
tv478 = -116						; size = 4
tv748 = -112						; size = 4
tv414 = -108						; size = 4
tv652 = -104						; size = 4
tv586 = -100						; size = 4
tv609 = -96						; size = 4
tv453 = -92						; size = 4
tv217 = -88						; size = 4
tv441 = -84						; size = 4
tv601 = -80						; size = 4
tv397 = -76						; size = 4
tv594 = -72						; size = 4
tv608 = -68						; size = 4
_modRpm$12 = -64					; size = 4
_modRpm$13 = -60					; size = 4
_aburnLit$ = -56					; size = 4
_th2$ = -52						; size = 4
_thrtb1$ = -48						; size = 4
_spoolAltRate$ = -44					; size = 4
_th1$ = -40						; size = 4
_tgross$ = -36						; size = 4
_fuelFlowSS$ = -32					; size = 4
_spoolrate$ = -28					; size = 4
_rpmCmd$ = -24						; size = 4
_message$14 = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_dt$ = 8						; size = 4
?EngineModel@AirframeClass@@QAEXM@Z PROC		; AirframeClass::EngineModel
; _this$ = ecx

; 81   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?EngineModel@AirframeClass@@QAEXM@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 212				; 000000d4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 82   : 	float th1, th2;
; 83   : 	float thrtb1;
; 84   : 	float tgross;
; 85   : 	float fuelFlowSS;
; 86   : 	//float ta01, rpmCmd; TJL 08/21/04 ta01 no longer used
; 87   : 	float rpmCmd;
; 88   : 	int aburnLit;
; 89   : 	float spoolrate = auxaeroData->normSpoolRate;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movss	xmm0, DWORD PTR [ecx+12]
	movss	DWORD PTR _spoolrate$[ebp], xmm0

; 90   : 	//TJL 02/22/04 
; 91   : 	float spoolAltRate = (-platform->ZPos()/25000.0f) + (-mach/2.0F);

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1088]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv1564[ebp]
	movss	xmm0, DWORD PTR tv1564[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	divss	xmm0, DWORD PTR __real@46c35000
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+1144]
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	divss	xmm1, DWORD PTR __real@40000000
	addss	xmm0, xmm1
	movss	DWORD PTR _spoolAltRate$[ebp], xmm0

; 92   : 
; 93   : 	
; 94   : 			
; 95   : 	
; 96   :     // JPO should we switch on the EPU ?
; 97   :     if (epuFuel > 0.0f) //only relevant if there is fuel

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+36]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN103@EngineMode

; 98   : 	{ 
; 99   : 		// MD -- 20040531: adding test to make sure that the EPU keeps running when you land if it was
; 100  : 		// already running (previous logic shut EPU off on touchdown)
; 101  : 		if ((GetEpuSwitch() == ON) || (GeneratorRunning(GenEpu) && (GetEpuSwitch() != OFF)))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetEpuSwitch@AirframeClass@@QAE?AW4EpuState@1@XZ ; AirframeClass::GetEpuSwitch
	cmp	eax, 2
	je	SHORT $LN101@EngineMode
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GeneratorRunning@AirframeClass@@QAEHW4Generator@1@@Z ; AirframeClass::GeneratorRunning
	test	eax, eax
	je	SHORT $LN102@EngineMode
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetEpuSwitch@AirframeClass@@QAE?AW4EpuState@1@XZ ; AirframeClass::GetEpuSwitch
	test	eax, eax
	je	SHORT $LN102@EngineMode
$LN101@EngineMode:

; 102  : 		{// pilot command
; 103  : 			GeneratorOn(GenEpu);

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GeneratorOn@AirframeClass@@QAEXW4Generator@1@@Z ; AirframeClass::GeneratorOn
	jmp	SHORT $LN96@EngineMode
$LN102@EngineMode:

; 104  : 		} 
; 105  : 		// auto mode
; 106  : 		else if (!GeneratorRunning(GenMain) && !GeneratorRunning(GenStdby) && IsSet(InAir)) {

	push	1024					; 00000400H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GeneratorRunning@AirframeClass@@QAEHW4Generator@1@@Z ; AirframeClass::GeneratorRunning
	test	eax, eax
	jne	SHORT $LN99@EngineMode
	push	64					; 00000040H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GeneratorRunning@AirframeClass@@QAEHW4Generator@1@@Z ; AirframeClass::GeneratorRunning
	test	eax, eax
	jne	SHORT $LN99@EngineMode
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN99@EngineMode

; 107  : 			GeneratorOn(GenEpu);

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GeneratorOn@AirframeClass@@QAEXW4Generator@1@@Z ; AirframeClass::GeneratorOn
	jmp	SHORT $LN96@EngineMode
$LN99@EngineMode:

; 108  : 		}
; 109  : 		else if (GetEpuSwitch() == OFF) 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetEpuSwitch@AirframeClass@@QAE?AW4EpuState@1@XZ ; AirframeClass::GetEpuSwitch
	test	eax, eax
	jne	SHORT $LN97@EngineMode

; 110  : 		{
; 111  : 			GeneratorOff(GenEpu);

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GeneratorOff@AirframeClass@@QAEXW4Generator@1@@Z ; AirframeClass::GeneratorOff

; 112  : 			EpuClear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?EpuClear@AirframeClass@@QAEXXZ		; AirframeClass::EpuClear

; 113  : 		}
; 114  : 		else 

	jmp	SHORT $LN96@EngineMode
$LN97@EngineMode:

; 115  : 		{
; 116  : 			GeneratorOff(GenEpu);

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GeneratorOff@AirframeClass@@QAEXW4Generator@1@@Z ; AirframeClass::GeneratorOff

; 117  : 			EpuClear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?EpuClear@AirframeClass@@QAEXXZ		; AirframeClass::EpuClear
$LN96@EngineMode:

; 118  : 		}
; 119  : 	}
; 120  : 	else 

	jmp	SHORT $LN95@EngineMode
$LN103@EngineMode:

; 121  : 	{
; 122  : 		GeneratorOff(GenEpu);

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GeneratorOff@AirframeClass@@QAEXW4Generator@1@@Z ; AirframeClass::GeneratorOff

; 123  : 		EpuClear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?EpuClear@AirframeClass@@QAEXXZ		; AirframeClass::EpuClear
$LN95@EngineMode:

; 124  : 	}
; 125  :     // check hydraulics and generators 
; 126  :     if (GeneratorRunning(GenMain) || GeneratorRunning(GenStdby)) {

	push	1024					; 00000400H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GeneratorRunning@AirframeClass@@QAEHW4Generator@1@@Z ; AirframeClass::GeneratorRunning
	test	eax, eax
	jne	SHORT $LN93@EngineMode
	push	64					; 00000040H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GeneratorRunning@AirframeClass@@QAEHW4Generator@1@@Z ; AirframeClass::GeneratorRunning
	test	eax, eax
	je	SHORT $LN94@EngineMode
$LN93@EngineMode:

; 127  : 		HydrRestore(HYDR_ALL); // restore those systems we can

	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HydrRestore@AirframeClass@@QAEXH@Z	; AirframeClass::HydrRestore
	jmp	SHORT $LN90@EngineMode
$LN94@EngineMode:

; 128  :     }
; 129  :     else if (GeneratorRunning(GenEpu)) {

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GeneratorRunning@AirframeClass@@QAEHW4Generator@1@@Z ; AirframeClass::GeneratorRunning
	test	eax, eax
	je	SHORT $LN91@EngineMode

; 130  : 		HydrDown (HYDR_B_SYSTEM); // B system now dead

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HydrDown@AirframeClass@@QAEXH@Z	; AirframeClass::HydrDown

; 131  : 		HydrRestore(HYDR_A_SYSTEM); // A still OK

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HydrRestore@AirframeClass@@QAEXH@Z	; AirframeClass::HydrRestore

; 132  :     }
; 133  :     else {

	jmp	SHORT $LN90@EngineMode
$LN91@EngineMode:

; 134  : 		HydrDown(HYDR_ALL); // all off

	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HydrDown@AirframeClass@@QAEXH@Z	; AirframeClass::HydrDown
$LN90@EngineMode:

; 135  :     }
; 136  : 	
; 137  :     // JPO - if the epu is running - well its running!
; 138  :     // this may be independant of the engine if the pilot wants to check
; 139  :     if (GeneratorRunning(GenEpu)) {

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GeneratorRunning@AirframeClass@@QAEHW4Generator@1@@Z ; AirframeClass::GeneratorRunning
	test	eax, eax
	je	$LN89@EngineMode

; 140  : 		EpuClear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?EpuClear@AirframeClass@@QAEXXZ		; AirframeClass::EpuClear

; 141  : 		// below 80%rpm, epu burns fuel.
; 142  : 		if (rpm < 0.80f) {

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f4ccccd
	comiss	xmm0, DWORD PTR [edx+1212]
	jbe	SHORT $LN87@EngineMode

; 143  : 			EpuSetHydrazine();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?EpuSetHydrazine@AirframeClass@@QAEXXZ	; AirframeClass::EpuSetHydrazine

; 144  : 			epuFuel -= 100.0f * dt / auxaeroData->epuBurnTime; // burn some hydrazine

	movss	xmm0, DWORD PTR __real@42c80000
	mulss	xmm0, DWORD PTR _dt$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	divss	xmm0, DWORD PTR [ecx+52]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+36]
	subss	xmm1, xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+36], xmm1

; 145  : 			if (epuFuel <= 0.0f) {

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [ecx+36]
	jb	SHORT $LN87@EngineMode

; 146  : 				epuFuel = 0.0;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+36], xmm0

; 147  : 				GeneratorBreak(GenEpu); // well not broken, but done for.

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GeneratorBreak@AirframeClass@@QAEXW4Generator@1@@Z ; AirframeClass::GeneratorBreak

; 148  : 				GeneratorOff(GenEpu);

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GeneratorOff@AirframeClass@@QAEXW4Generator@1@@Z ; AirframeClass::GeneratorOff
$LN87@EngineMode:

; 149  : 			}
; 150  : 		}
; 151  : 		EpuSetAir(); // always true, means running really.

	mov	ecx, DWORD PTR _this$[ebp]
	call	?EpuSetAir@AirframeClass@@QAEXXZ	; AirframeClass::EpuSetAir
$LN89@EngineMode:

; 152  :     }
; 153  : 	
; 154  :     // JPO: charge the JFS accumulators, up to 100% 
; 155  :     if (rpm > auxaeroData->jfsMinRechargeRpm && jfsaccumulator < 100.0f /* 2002-04-11 ADDED BY S.G. If less than 0, don't recharge */ && jfsaccumulator >= 0.0f ) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1212]
	comiss	xmm0, DWORD PTR [ecx+40]
	jbe	$LN86@EngineMode
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@42c80000
	comiss	xmm0, DWORD PTR [eax+1604]
	jbe	$LN86@EngineMode
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1604]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN86@EngineMode

; 156  : 		jfsaccumulator += 100.0f * dt / auxaeroData->jfsRechargeTime;

	movss	xmm0, DWORD PTR __real@42c80000
	mulss	xmm0, DWORD PTR _dt$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	divss	xmm0, DWORD PTR [eax+36]
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+1604]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+1604], xmm0

; 157  : 		jfsaccumulator = min(jfsaccumulator, 100.0f);

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@42c80000
	comiss	xmm0, DWORD PTR [eax+1604]
	jbe	SHORT $LN106@EngineMode
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1604]
	movss	DWORD PTR tv217[ebp], xmm0
	jmp	SHORT $LN107@EngineMode
$LN106@EngineMode:
	movss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR tv217[ebp], xmm0
$LN107@EngineMode:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv217[ebp]
	movss	DWORD PTR [edx+1604], xmm0
$LN86@EngineMode:

; 158  :     }
; 159  :     // transfer fuel
; 160  :     FuelTransfer(dt);

	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FuelTransfer@AirframeClass@@QAEXM@Z	; AirframeClass::FuelTransfer

; 161  : 	
; 162  : #if 0 // not ready yet.JPO, but basically it should work as normal, but ignore the throttle.
; 163  :     if (IsSet(ThrottleCheck)) {
; 164  : 		rpm      = oldRpm[0]; // just remember where we were... JPO
; 165  : 		if(throtl >= 1.5F)
; 166  : 			throtl = pwrlev;
; 167  : 		if (fabs (throtl - pwrlev) > 0.1F)
; 168  : 			ClearFlag(ThrottleCheck);
; 169  : 		pwrlev = throtl;
; 170  :     }
; 171  :     else
; 172  :     {
; 173  : 		if (fabs (throtl - pwrlev) > 0.1F)
; 174  :             ClearFlag (EngineOff);
; 175  :     }
; 176  : #endif
; 177  : 	
; 178  :     if (IsSet(EngineStopped)) {

	push	134217728				; 08000000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	$LN85@EngineMode

; 179  : 		ftit = Math.FLTust(0.0f, 20.0f, dt, oldFtit); // cool down the engine

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1620				; 00000654H
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@41a00000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?FLTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z	; SIMLIB_MATH_CLASS::FLTust
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+1668]

; 180  : 		float modRpm = (float)(rpm*rpm*rpm*rpm*sqrt(rpm));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1212]
	mulss	xmm0, DWORD PTR [eax+1212]
	mov	ecx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [ecx+1212]
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [edx+1212]
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm1, DWORD PTR [eax+1212]
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv2499[ebp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR tv1665[ebp]
	movss	xmm0, DWORD PTR tv2499[ebp]
	mulss	xmm0, DWORD PTR tv1665[ebp]
	movss	DWORD PTR _modRpm$13[ebp], xmm0

; 181  : 		
; 182  : 		// Am I increasing the rpm (but not yet in afterburner)?
; 183  : 		if (rpm > oldp01[0])

	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1212]
	comiss	xmm0, DWORD PTR [eax+ecx+284]
	jbe	SHORT $LN84@EngineMode

; 184  : 			Math.FLTust (modRpm, 4.0F, dt, oldp01);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 284				; 0000011cH
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@40800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _modRpm$13[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?FLTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z	; SIMLIB_MATH_CLASS::FLTust
	fstp	ST(0)

; 185  : 		// Must be decreasing then...
; 186  : 		else {

	jmp	$LN81@EngineMode
$LN84@EngineMode:

; 187  : 			// Now check if the 'heat' is still above 1.00 (100%)
; 188  : 			if (oldp01[0] > 1.0F)

	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+284]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN82@EngineMode

; 189  : 				Math.FLTust (modRpm, 7.0F, dt, oldp01);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 284				; 0000011cH
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@40e00000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _modRpm$13[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?FLTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z	; SIMLIB_MATH_CLASS::FLTust
	fstp	ST(0)

; 190  : 			else

	jmp	SHORT $LN81@EngineMode
$LN82@EngineMode:

; 191  : 				Math.FLTust (modRpm, 2.0F, dt, oldp01);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 284				; 0000011cH
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _modRpm$13[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?FLTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z	; SIMLIB_MATH_CLASS::FLTust
	fstp	ST(0)
$LN81@EngineMode:

; 192  : 		}
; 193  : 		
; 194  : 		spoolrate = auxaeroData->flameoutSpoolRate; // spool down rate

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movss	xmm0, DWORD PTR [ecx+32]
	movss	DWORD PTR _spoolrate$[ebp], xmm0

; 195  : 		fireTimer = 0.0f; // reset - engine is switched off

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _fireTimer, xmm0

; 196  : 		// switch all to 0.
; 197  : 		tgross = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _tgross$[ebp], xmm0

; 198  : 		fuelFlow = 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+24], xmm0

; 199  : 		thrtab = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+184], xmm0

; 200  : 		thrust = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+188], xmm0

; 201  : 		
; 202  : 		// broken engine - anything but a flame out?
; 203  : 		if((platform->mFaults->GetFault(FaultClass::eng_fault) & ~FaultClass::fl_out) != 0) {

	push	8
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1088]
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFault@FackClass@@QAEHW4type_FSubSystem@FaultClass@@@Z ; FackClass::GetFault
	and	eax, 2147483647				; 7fffffffH
	je	SHORT $LN80@EngineMode

; 204  : 			rpmCmd = 0.0f; // engine must be seized, not going to start or windmill

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _rpmCmd$[ebp], xmm0
	jmp	$LN76@EngineMode
$LN80@EngineMode:

; 205  : 		}
; 206  : 		else if (IsSet (JfsStart)) {

	push	268435456				; 10000000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN78@EngineMode

; 207  : 			rpmCmd = 0.25f; // JFS should take us up to 25%

	movss	xmm0, DWORD PTR __real@3e800000
	movss	DWORD PTR _rpmCmd$[ebp], xmm0

; 208  : 			spoolrate = 15.0f;

	movss	xmm0, DWORD PTR __real@41700000
	movss	DWORD PTR _spoolrate$[ebp], xmm0

; 209  : 			//decrease spin time
; 210  : 			JFSSpinTime -= SimLibMajorFrameTime;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1608]
	subss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+1608], xmm0

; 211  : 			if(JFSSpinTime <= 0)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [eax+1608]
	jb	SHORT $LN77@EngineMode

; 212  : 				ClearFlag(JfsStart);

	push	268435456				; 10000000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearFlag@AirframeClass@@QAEXH@Z	; AirframeClass::ClearFlag
$LN77@EngineMode:

; 213  : 		}
; 214  : 		//TJL 01/18/04 Added parens to correct operator precedence error
; 215  : 		else { // engine windmill (~12% at 450 knts) (me123 - this works on mine)

	jmp	SHORT $LN76@EngineMode
$LN78@EngineMode:

; 216  : 			rpmCmd = (platform->GetKias() / 450.0f) * 0.12f;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1088]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+1088]
	mov	eax, DWORD PTR [edx+224]
	call	eax
	fstp	DWORD PTR tv1721[ebp]
	movss	xmm0, DWORD PTR tv1721[ebp]
	divss	xmm0, DWORD PTR __real@43e10000
	mulss	xmm0, DWORD PTR __real@3df5c28f
	movss	DWORD PTR _rpmCmd$[ebp], xmm0
$LN76@EngineMode:

; 217  : 		}
; 218  : 		
; 219  : 		// attempt to spool up/down
; 220  : 		rpm = Math.FLTust (rpmCmd, spoolrate, dt, oldRpm);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 500				; 000001f4H
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _spoolrate$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?FLTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z	; SIMLIB_MATH_CLASS::FLTust
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+1212]

; 221  : 
; 222  : 		// MD -- 20040210: add check for throttle up to idle to trigger engine light
; 223  : 		// use with caution...this was done at speed and not extensively tested.
; 224  : 		if (g_bUseAnalogIdleCutoff && (rpm >= 0.20F) && !IO.IsAxisCutOff(AXIS_THROTTLE))

	movzx	eax, BYTE PTR ?g_bUseAnalogIdleCutoff@@3_NA ; g_bUseAnalogIdleCutoff
	test	eax, eax
	je	SHORT $LN75@EngineMode
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1212]
	comiss	xmm0, DWORD PTR __real@3e4ccccd
	jb	SHORT $LN75@EngineMode
	push	3
	mov	ecx, OFFSET ?IO@@3VSIMLIB_IO_CLASS@@A	; IO
	call	?IsAxisCutOff@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z ; SIMLIB_IO_CLASS::IsAxisCutOff
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN75@EngineMode

; 225  : 		{
; 226  : 			ClearFlag(AirframeClass::EngineStopped);

	push	134217728				; 08000000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearFlag@AirframeClass@@QAEXH@Z	; AirframeClass::ClearFlag

; 227  : 			platform->mFaults->ClearFault(FaultClass::eng_fault, FaultClass::fl_out);

	push	-2147483648				; 80000000H
	push	8
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	mov	ecx, DWORD PTR [ecx+928]
	call	?ClearFault@FackClass@@QAEXW4type_FSubSystem@FaultClass@@W4type_FFunction@3@@Z ; FackClass::ClearFault
$LN75@EngineMode:

; 228  : 		}
; 229  :     }

	jmp	$LN19@EngineMode
$LN85@EngineMode:

; 230  :     else if (!IsSet(EngineOff))

	push	32768					; 00008000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	jne	$LN73@EngineMode

; 231  :     {
; 232  : 		/*------------------*/
; 233  : 		/* get gross thrust */
; 234  : 		/*------------------*/
; 235  : 		if((platform->mFaults->GetFault(FaultClass::eng_fault) & FaultClass::fl_out) ||
; 236  : 			(g_bUseAnalogIdleCutoff && IO.IsAxisCutOff(AXIS_THROTTLE)))

	push	8
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1088]
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFault@FackClass@@QAEHW4type_FSubSystem@FaultClass@@@Z ; FackClass::GetFault
	and	eax, -2147483648			; 80000000H
	jne	SHORT $LN71@EngineMode
	movzx	ecx, BYTE PTR ?g_bUseAnalogIdleCutoff@@3_NA ; g_bUseAnalogIdleCutoff
	test	ecx, ecx
	je	SHORT $LN72@EngineMode
	push	3
	mov	ecx, OFFSET ?IO@@3VSIMLIB_IO_CLASS@@A	; IO
	call	?IsAxisCutOff@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z ; SIMLIB_IO_CLASS::IsAxisCutOff
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN72@EngineMode
$LN71@EngineMode:

; 237  : 		{
; 238  : 			SetFlag(EngineStopped); //JPO - engine is now stopped!

	push	134217728				; 08000000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFlag@AirframeClass@@QAEXH@Z		; AirframeClass::SetFlag

; 239  : 			throtl = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+1512], xmm0
$LN72@EngineMode:

; 240  : 		}
; 241  : 		pwrlev = throtl;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1512]
	mov	DWORD PTR [ecx+1516], eax

; 242  : 		// AB Failure
; 243  : 		
; 244  : 		
; 245  : 		
; 246  : 		//MI
; 247  : 		if(auxaeroData->DeepStallEngineStall)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+60], 0
	je	SHORT $LN69@EngineMode

; 248  : 		{
; 249  : 			//me123 if in deep stall and in ab lets stall the engine
; 250  : 			// JPO - 10% chance, each time we check...
; 251  : 			if (stallMode >= DeepStall && pwrlev >= 1.0F && rand() % 10 == 1)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1248], 4
	jl	SHORT $LN69@EngineMode
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1516]
	comiss	xmm0, DWORD PTR __real@3f800000
	jb	SHORT $LN69@EngineMode
	call	_rand
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	cmp	edx, 1
	jne	SHORT $LN69@EngineMode

; 252  : 			{ 
; 253  : 				SetFlag(EngineStopped);

	push	134217728				; 08000000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFlag@AirframeClass@@QAEXH@Z		; AirframeClass::SetFlag

; 254  : 				// mark it as a flame out
; 255  : 				platform->mFaults->SetFault(FaultClass::eng_fault, FaultClass::fl_out, FaultClass::fail, FALSE);

	push	0
	push	2
	push	-2147483648				; 80000000H
	push	8
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1088]
	mov	ecx, DWORD PTR [eax+928]
	call	?SetFault@FackClass@@QAEXW4type_FSubSystem@FaultClass@@W4type_FFunction@3@W4type_FSeverity@3@H@Z ; FackClass::SetFault
$LN69@EngineMode:

; 256  : 			}
; 257  : 		}
; 258  : 		
; 259  : 		if (platform->IsSetFlag(MOTION_OWNSHIP))

	push	65536					; 00010000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1088]
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN64@EngineMode

; 260  : 		{
; 261  : 			if (platform->mFaults->GetFault(FaultClass::eng_fault) & FaultClass::a_b)

	push	8
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1088]
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFault@FackClass@@QAEHW4type_FSubSystem@FaultClass@@@Z ; FackClass::GetFault
	and	eax, 4096				; 00001000H
	je	SHORT $LN67@EngineMode

; 262  : 			{
; 263  : 				pwrlev = min (pwrlev, 0.99F);

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f7d70a4
	comiss	xmm0, DWORD PTR [ecx+1516]
	jbe	SHORT $LN108@EngineMode
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1516]
	movss	DWORD PTR tv397[ebp], xmm0
	jmp	SHORT $LN109@EngineMode
$LN108@EngineMode:
	movss	xmm0, DWORD PTR __real@3f7d70a4
	movss	DWORD PTR tv397[ebp], xmm0
$LN109@EngineMode:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv397[ebp]
	movss	DWORD PTR [eax+1516], xmm0
$LN67@EngineMode:

; 264  : 			}
; 265  : 			
; 266  : 			if (platform->mFaults->GetFault(FaultClass::eng_fault) & FaultClass::efire)

	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1088]
	mov	ecx, DWORD PTR [edx+928]
	call	?GetFault@FackClass@@QAEHW4type_FSubSystem@FaultClass@@@Z ; FackClass::GetFault
	and	eax, 16384				; 00004000H
	je	$LN64@EngineMode

; 267  : 			{
; 268  : 				pwrlev *= 0.5F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1516]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+1516], xmm0

; 269  : 				
; 270  : 				if (fireTimer >= 0.0F)

	movss	xmm0, DWORD PTR _fireTimer
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN65@EngineMode

; 271  : 					fireTimer += max (throtl, 0.3F) * dt;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1512]
	comiss	xmm0, DWORD PTR __real@3e99999a
	jbe	SHORT $LN110@EngineMode
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1512]
	movss	DWORD PTR tv414[ebp], xmm0
	jmp	SHORT $LN111@EngineMode
$LN110@EngineMode:
	movss	xmm0, DWORD PTR __real@3e99999a
	movss	DWORD PTR tv414[ebp], xmm0
$LN111@EngineMode:
	movss	xmm0, DWORD PTR tv414[ebp]
	mulss	xmm0, DWORD PTR _dt$[ebp]
	addss	xmm0, DWORD PTR _fireTimer
	movss	DWORD PTR _fireTimer, xmm0
$LN65@EngineMode:

; 272  : 				
; 273  : 				// On fire long enough, blow up
; 274  : 				if (fireTimer > 60.0F) // 60 seconds at mil power

	movss	xmm0, DWORD PTR _fireTimer
	comiss	xmm0, DWORD PTR __real@42700000
	jbe	$LN64@EngineMode

; 275  : 				{
; 276  : 					fireTimer = -1.0F;

	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _fireTimer, xmm0

; 277  : 					FalconDamageMessage* message;
; 278  : 					message = new FalconDamageMessage (platform->Id(), FalconLocalGame );

	push	98					; 00000062H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T11[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T11[ebp], 0
	je	SHORT $LN114@EngineMode
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN112@EngineMode
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv441[ebp], eax
	jmp	SHORT $LN113@EngineMode
$LN112@EngineMode:
	mov	DWORD PTR tv441[ebp], 0
$LN113@EngineMode:
	push	1
	mov	edx, DWORD PTR tv441[ebp]
	push	edx
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1088]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR $T11[ebp]
	call	??0FalconDamageMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z ; FalconDamageMessage::FalconDamageMessage
	mov	DWORD PTR tv453[ebp], eax
	jmp	SHORT $LN115@EngineMode
$LN114@EngineMode:
	mov	DWORD PTR tv453[ebp], 0
$LN115@EngineMode:
	mov	ecx, DWORD PTR tv453[ebp]
	mov	DWORD PTR $T6[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T6[ebp]
	mov	DWORD PTR _message$14[ebp], edx

; 279  : 					message->dataBlock.fEntityID  = platform->Id();

	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1088]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _message$14[ebp]
	mov	DWORD PTR [ecx+74], edx
	mov	DWORD PTR [ecx+78], eax

; 280  : 					
; 281  : 					message->dataBlock.fCampID = platform->GetCampaignObject()->GetCampID();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1088]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	DWORD PTR tv478[ebp], eax
	mov	eax, DWORD PTR tv478[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv478[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax
	mov	ecx, DWORD PTR _message$14[ebp]
	mov	WORD PTR [ecx+82], ax

; 282  : 					message->dataBlock.fSide   = platform->GetCampaignObject()->GetOwner();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1088]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetOwner@CampBaseClass@@QAEEXZ		; CampBaseClass::GetOwner
	mov	ecx, DWORD PTR _message$14[ebp]
	mov	BYTE PTR [ecx+87], al

; 283  : 					message->dataBlock.fPilotID   = ((AircraftClass*)platform)->pilotSlot;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1088]
	mov	ecx, DWORD PTR _message$14[ebp]
	mov	dl, BYTE PTR [eax+665]
	mov	BYTE PTR [ecx+84], dl

; 284  : 					message->dataBlock.fIndex     = platform->Type();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	call	?Type@VuEntity@@QBEGXZ			; VuEntity::Type
	mov	ecx, DWORD PTR _message$14[ebp]
	mov	WORD PTR [ecx+85], ax

; 285  : 					message->dataBlock.fWeaponID  = platform->Type();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1088]
	call	?Type@VuEntity@@QBEGXZ			; VuEntity::Type
	mov	ecx, DWORD PTR _message$14[ebp]
	mov	WORD PTR [ecx+88], ax

; 286  : 					message->dataBlock.fWeaponUID = platform->Id();

	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _message$14[ebp]
	mov	DWORD PTR [eax+90], ecx
	mov	DWORD PTR [eax+94], edx

; 287  : 					message->dataBlock.dEntityID  = message->dataBlock.fEntityID;

	mov	ecx, DWORD PTR _message$14[ebp]
	mov	edx, DWORD PTR [ecx+74]
	mov	eax, DWORD PTR [ecx+78]
	mov	ecx, DWORD PTR _message$14[ebp]
	mov	DWORD PTR [ecx+60], edx
	mov	DWORD PTR [ecx+64], eax

; 288  : 					message->dataBlock.dCampID = message->dataBlock.fCampID;

	mov	edx, DWORD PTR _message$14[ebp]
	mov	eax, DWORD PTR _message$14[ebp]
	mov	cx, WORD PTR [eax+82]
	mov	WORD PTR [edx+68], cx

; 289  : 					message->dataBlock.dSide   = message->dataBlock.fSide;

	mov	edx, DWORD PTR _message$14[ebp]
	mov	eax, DWORD PTR _message$14[ebp]
	mov	cl, BYTE PTR [eax+87]
	mov	BYTE PTR [edx+73], cl

; 290  : 					message->dataBlock.dPilotID   = message->dataBlock.fPilotID;

	mov	edx, DWORD PTR _message$14[ebp]
	mov	eax, DWORD PTR _message$14[ebp]
	mov	cl, BYTE PTR [eax+84]
	mov	BYTE PTR [edx+70], cl

; 291  : 					message->dataBlock.dIndex     = message->dataBlock.fIndex;

	mov	edx, DWORD PTR _message$14[ebp]
	mov	eax, DWORD PTR _message$14[ebp]
	mov	cx, WORD PTR [eax+85]
	mov	WORD PTR [edx+71], cx

; 292  : 					message->dataBlock.damageType = FalconDamageType::CollisionDamage;

	mov	edx, DWORD PTR _message$14[ebp]
	mov	DWORD PTR [edx+48], 2

; 293  : 					message->dataBlock.damageStrength = 2.0F * platform->MaxStrength();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	call	?MaxStrength@SimBaseClass@@QAEMXZ	; SimBaseClass::MaxStrength
	fstp	DWORD PTR tv1853[ebp]
	movss	xmm0, DWORD PTR tv1853[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	mov	ecx, DWORD PTR _message$14[ebp]
	movss	DWORD PTR [ecx+52], xmm0

; 294  : 					message->dataBlock.damageRandomFact = 1.5F;

	mov	edx, DWORD PTR _message$14[ebp]
	movss	xmm0, DWORD PTR __real@3fc00000
	movss	DWORD PTR [edx+56], xmm0

; 295  : 					
; 296  : 					message->RequestOutOfBandTransmit ();

	mov	ecx, DWORD PTR _message$14[ebp]
	call	?RequestOutOfBandTransmit@VuMessage@@QAEXXZ ; VuMessage::RequestOutOfBandTransmit

; 297  : 					FalconSendMessage (message,TRUE);

	push	1
	mov	eax, DWORD PTR _message$14[ebp]
	push	eax
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8
$LN64@EngineMode:

; 298  : 				}
; 299  : 			}
; 300  : 		}
; 301  : 		if (engineData->hasAB) // JB 010706

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	movzx	eax, BYTE PTR [edx+24]
	test	eax, eax
	je	$LN63@EngineMode

; 302  : 			pwrlev = max (min (pwrlev, 1.5F), 0.0F);

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fc00000
	comiss	xmm0, DWORD PTR [ecx+1516]
	jbe	SHORT $LN116@EngineMode
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1516]
	movss	DWORD PTR tv586[ebp], xmm0
	jmp	SHORT $LN117@EngineMode
$LN116@EngineMode:
	movss	xmm0, DWORD PTR __real@3fc00000
	movss	DWORD PTR tv586[ebp], xmm0
$LN117@EngineMode:
	movss	xmm0, DWORD PTR tv586[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN120@EngineMode
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fc00000
	comiss	xmm0, DWORD PTR [eax+1516]
	jbe	SHORT $LN118@EngineMode
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1516]
	movss	DWORD PTR tv593[ebp], xmm0
	jmp	SHORT $LN119@EngineMode
$LN118@EngineMode:
	movss	xmm0, DWORD PTR __real@3fc00000
	movss	DWORD PTR tv593[ebp], xmm0
$LN119@EngineMode:
	movss	xmm0, DWORD PTR tv593[ebp]
	movss	DWORD PTR tv594[ebp], xmm0
	jmp	SHORT $LN121@EngineMode
$LN120@EngineMode:
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv594[ebp], xmm0
$LN121@EngineMode:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv594[ebp]
	movss	DWORD PTR [edx+1516], xmm0

; 303  : 		else

	jmp	$LN62@EngineMode
$LN63@EngineMode:

; 304  : 			pwrlev = max (min (pwrlev, 1.0F), 0.0F);

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR [eax+1516]
	jbe	SHORT $LN122@EngineMode
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1516]
	movss	DWORD PTR tv601[ebp], xmm0
	jmp	SHORT $LN123@EngineMode
$LN122@EngineMode:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv601[ebp], xmm0
$LN123@EngineMode:
	movss	xmm0, DWORD PTR tv601[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN126@EngineMode
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR [edx+1516]
	jbe	SHORT $LN124@EngineMode
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1516]
	movss	DWORD PTR tv608[ebp], xmm0
	jmp	SHORT $LN125@EngineMode
$LN124@EngineMode:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv608[ebp], xmm0
$LN125@EngineMode:
	movss	xmm0, DWORD PTR tv608[ebp]
	movss	DWORD PTR tv609[ebp], xmm0
	jmp	SHORT $LN127@EngineMode
$LN126@EngineMode:
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv609[ebp], xmm0
$LN127@EngineMode:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv609[ebp]
	movss	DWORD PTR [ecx+1516], xmm0
$LN62@EngineMode:

; 305  : 		
; 306  : 		if (rpm < 0.68f) { // below Idle

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f2e147b
	comiss	xmm0, DWORD PTR [edx+1212]
	jbe	$LN59@EngineMode

; 307  : 			rpmCmd = 0.7f;

	movss	xmm0, DWORD PTR __real@3f333333
	movss	DWORD PTR _rpmCmd$[ebp], xmm0

; 308  : 			spoolrate = auxaeroData->lightupSpoolRate;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movss	xmm0, DWORD PTR [ecx+28]
	movss	DWORD PTR _spoolrate$[ebp], xmm0

; 309  : 			thrtb1 = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _thrtb1$[ebp], xmm0

; 310  : 			if (rpm > 0.5f)

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1212]
	comiss	xmm0, DWORD PTR __real@3f000000
	jbe	SHORT $LN60@EngineMode

; 311  : 				ClearFlag(JfsStart);

	push	268435456				; 10000000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearFlag@AirframeClass@@QAEXH@Z	; AirframeClass::ClearFlag
$LN60@EngineMode:

; 312  : 			ftit = Math.FLTust(5.1F * (rpm/0.7f), ftitrate, dt, oldFtit);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1620				; 00000654H
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _ftitrate
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1212]
	divss	xmm0, DWORD PTR __real@3f333333
	mulss	xmm0, DWORD PTR __real@40a33333
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?FLTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z	; SIMLIB_MATH_CLASS::FLTust
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+1668]

; 313  : 			// sfr: added rampstart fix
; 314  : 			EngineRpmMods(rpmCmd);

	push	ecx
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EngineRpmMods@AirframeClass@@QAEMM@Z	; AirframeClass::EngineRpmMods
	fstp	ST(0)

; 315  : 			rpmCmd = EngineRpmMods(rpmCmd);

	push	ecx
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EngineRpmMods@AirframeClass@@QAEMM@Z	; AirframeClass::EngineRpmMods
	fstp	DWORD PTR _rpmCmd$[ebp]

; 316  : 			spoolrate = spoolAltRate + spoolrate;

	movss	xmm0, DWORD PTR _spoolAltRate$[ebp]
	addss	xmm0, DWORD PTR _spoolrate$[ebp]
	movss	DWORD PTR _spoolrate$[ebp], xmm0

; 317  : 			rpm = Math.FLTust (rpmCmd, spoolrate, dt, oldRpm);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 500				; 000001f4H
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _spoolrate$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?FLTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z	; SIMLIB_MATH_CLASS::FLTust
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+1212]

; 318  : 			if (fuel > 0.0F){

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+20]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN59@EngineMode

; 319  : 				rpm = max (rpm, 0.01F);

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1212]
	comiss	xmm0, DWORD PTR __real@3c23d70a
	jbe	SHORT $LN128@EngineMode
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1212]
	movss	DWORD PTR tv652[ebp], xmm0
	jmp	SHORT $LN129@EngineMode
$LN128@EngineMode:
	movss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR tv652[ebp], xmm0
$LN129@EngineMode:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv652[ebp]
	movss	DWORD PTR [edx+1212], xmm0
$LN59@EngineMode:

; 320  : 			}
; 321  : 		}
; 322  : 		//else if (pwrlev <= 1.0)
; 323  : 		if ((pwrlev <= 1.0f && rpm <= 1.0f) || (pwrlev > 1.0f && rpm <= 1.0f))

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR [eax+1516]
	jb	SHORT $LN56@EngineMode
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR [ecx+1212]
	jae	SHORT $LN57@EngineMode
$LN56@EngineMode:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1516]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	$LN58@EngineMode
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR [eax+1212]
	jb	$LN58@EngineMode
$LN57@EngineMode:

; 324  : 		{
; 325  : 			/*-------------------*/
; 326  : 			/* Mil power or less */
; 327  : 			/*-------------------*/
; 328  : 			th1 = Math.TwodInterp (-z, mach, engineData->alt,
; 329  : 				engineData->mach, engineData->thrust[0], engineData->numAlt,
; 330  : 				engineData->numMach, &curEngAltBreak, &curEngMachBreak);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 812				; 0000032cH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 816				; 00000330H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR [ecx+edx+28]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+1144]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1116]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?TwodInterp@SIMLIB_MATH_CLASS@@QAEMMMPBM00HHPAH1@Z ; SIMLIB_MATH_CLASS::TwodInterp
	fstp	DWORD PTR _th1$[ebp]

; 331  : 			th2 = Math.TwodInterp (-z, mach, engineData->alt,
; 332  : 				engineData->mach, engineData->thrust[1], engineData->numAlt,
; 333  : 				engineData->numMach, &curEngAltBreak, &curEngMachBreak);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 812				; 0000032cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 816				; 00000330H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR [eax+ecx+28]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+1144]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1116]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?TwodInterp@SIMLIB_MATH_CLASS@@QAEMMMPBM00HHPAH1@Z ; SIMLIB_MATH_CLASS::TwodInterp
	fstp	DWORD PTR _th2$[ebp]

; 334  : 			
; 335  : 			aburnLit = FALSE;

	mov	DWORD PTR _aburnLit$[ebp], 0

; 336  : 			// sfr: reverting back old logic
; 337  : 			thrtb1 = ((th2 - th1)*pwrlev + th1) / mass; 

	movss	xmm0, DWORD PTR _th2$[ebp]
	subss	xmm0, DWORD PTR _th1$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [edx+1516]
	addss	xmm0, DWORD PTR _th1$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [eax+40]
	movss	DWORD PTR _thrtb1$[ebp], xmm0

; 338  : 			//thrtb1 = (3.33f*(th2 - th1)*(rpm - 0.7f) + th1)/ mass; // saints code
; 339  : 			rpmCmd = 0.7F + 0.3F * pwrlev;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3e99999a
	mulss	xmm0, DWORD PTR [ecx+1516]
	addss	xmm0, DWORD PTR __real@3f333333
	movss	DWORD PTR _rpmCmd$[ebp], xmm0

; 340  : 
; 341  : 			// sfr: added per instructions
; 342  : 			// sfr: commenting one of lines
; 343  : 			//EngineRpmMods(rpmCmd);
; 344  : 			rpmCmd = EngineRpmMods(rpmCmd);

	push	ecx
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EngineRpmMods@AirframeClass@@QAEMM@Z	; AirframeClass::EngineRpmMods
	fstp	DWORD PTR _rpmCmd$[ebp]

; 345  : 			//TJL 02/22/04 Add in the alt
; 346  : 			spoolrate = spoolAltRate + spoolrate;

	movss	xmm0, DWORD PTR _spoolAltRate$[ebp]
	addss	xmm0, DWORD PTR _spoolrate$[ebp]
	movss	DWORD PTR _spoolrate$[ebp], xmm0

; 347  : 			rpm = Math.FLTust (rpmCmd, spoolrate, dt, oldRpm);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 500				; 000001f4H
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _spoolrate$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?FLTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z	; SIMLIB_MATH_CLASS::FLTust
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+1212]

; 348  : 			if (fuel > 0.0F){

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+20]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN55@EngineMode

; 349  : 				rpm = max (rpm, 0.01F);

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1212]
	comiss	xmm0, DWORD PTR __real@3c23d70a
	jbe	SHORT $LN130@EngineMode
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1212]
	movss	DWORD PTR tv748[ebp], xmm0
	jmp	SHORT $LN131@EngineMode
$LN130@EngineMode:
	movss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR tv748[ebp], xmm0
$LN131@EngineMode:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv748[ebp]
	movss	DWORD PTR [ecx+1212], xmm0
$LN55@EngineMode:

; 350  : 			}
; 351  : 			// sfr: end added
; 352  : 
; 353  : 			// ftit calculated
; 354  : 			if (rpm < 0.9F)

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f666666
	comiss	xmm0, DWORD PTR [edx+1212]
	jbe	SHORT $LN54@EngineMode

; 355  : 			{
; 356  : 				ftit = Math.FLTust(5.1F + (rpm - 0.7F) / 0.2F * 1.0F, ftitrate, dt, oldFtit);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1620				; 00000654H
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _ftitrate
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1212]
	subss	xmm0, DWORD PTR __real@3f333333
	divss	xmm0, DWORD PTR __real@3e4ccccd
	mulss	xmm0, DWORD PTR __real@3f800000
	addss	xmm0, DWORD PTR __real@40a33333
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?FLTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z	; SIMLIB_MATH_CLASS::FLTust
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+1668]
	jmp	SHORT $LN52@EngineMode
$LN54@EngineMode:

; 357  : 			}
; 358  : 			else if (rpm < 1.0F)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR [eax+1212]
	jbe	SHORT $LN52@EngineMode

; 359  : 			{
; 360  : 				ftit = Math.FLTust(6.1F + (rpm - 0.9F) / 0.1F * 1.5F, ftitrate, dt, oldFtit);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1620				; 00000654H
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _ftitrate
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1212]
	subss	xmm0, DWORD PTR __real@3f666666
	divss	xmm0, DWORD PTR __real@3dcccccd
	mulss	xmm0, DWORD PTR __real@3fc00000
	addss	xmm0, DWORD PTR __real@40c33333
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?FLTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z	; SIMLIB_MATH_CLASS::FLTust
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+1668]
$LN52@EngineMode:

; 361  : 			}
; 362  : 		}
; 363  : 		else

	jmp	$LN51@EngineMode
$LN58@EngineMode:

; 364  : 			/*--------------------------*/
; 365  : 			/* Some stage of afterburner */
; 366  : 			/*--------------------------*/
; 367  : 		{
; 368  : 			th1 = Math.TwodInterp (-z, mach, engineData->alt,
; 369  : 				engineData->mach, engineData->thrust[1], engineData->numAlt,
; 370  : 				engineData->numMach, &curEngAltBreak, &curEngMachBreak);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 812				; 0000032cH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 816				; 00000330H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR [ecx+edx+28]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+1144]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1116]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?TwodInterp@SIMLIB_MATH_CLASS@@QAEMMMPBM00HHPAH1@Z ; SIMLIB_MATH_CLASS::TwodInterp
	fstp	DWORD PTR _th1$[ebp]

; 371  : 			th2 = Math.TwodInterp (-z, mach, engineData->alt,
; 372  : 				engineData->mach, engineData->thrust[2], engineData->numAlt,
; 373  : 				engineData->numMach, &curEngAltBreak, &curEngMachBreak);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 812				; 0000032cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 816				; 00000330H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR [eax+ecx+28]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+1144]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1116]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?TwodInterp@SIMLIB_MATH_CLASS@@QAEMMMPBM00HHPAH1@Z ; SIMLIB_MATH_CLASS::TwodInterp
	fstp	DWORD PTR _th2$[ebp]

; 374  : 			
; 375  : 			aburnLit = TRUE;

	mov	DWORD PTR _aburnLit$[ebp], 1

; 376  : 			// sfr: reverting back code 
; 377  : 			thrtb1 = (2.0F*(th2 - th1)*(pwrlev-1.0F) + th1) / mass;

	movss	xmm0, DWORD PTR _th2$[ebp]
	subss	xmm0, DWORD PTR _th1$[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+1516]
	subss	xmm1, DWORD PTR __real@3f800000
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR _th1$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [eax+40]
	movss	DWORD PTR _thrtb1$[ebp], xmm0

; 378  : 			//thrtb1 = (3.33F*(th2 - th1)*(rpm - 0.7F) + th1) / mass; // saints code
; 379  : 			rpmCmd = 1.0F + 0.06F * (pwrlev - 1.0F);

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1516]
	subss	xmm0, DWORD PTR __real@3f800000
	mulss	xmm0, DWORD PTR __real@3d75c28f
	addss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _rpmCmd$[ebp], xmm0

; 380  : 			// sfr: added per instructions
; 381  : 			// sfr: commenting one of lines
; 382  : 			//EngineRpmMods(rpmCmd);
; 383  : 			rpmCmd = EngineRpmMods(rpmCmd);

	push	ecx
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EngineRpmMods@AirframeClass@@QAEMM@Z	; AirframeClass::EngineRpmMods
	fstp	DWORD PTR _rpmCmd$[ebp]

; 384  : 			//TJL 02/22/04 Add in the alt
; 385  : 			spoolrate = spoolAltRate + spoolrate;

	movss	xmm0, DWORD PTR _spoolAltRate$[ebp]
	addss	xmm0, DWORD PTR _spoolrate$[ebp]
	movss	DWORD PTR _spoolrate$[ebp], xmm0

; 386  : 			rpm = Math.FLTust (rpmCmd, spoolrate, dt, oldRpm);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 500				; 000001f4H
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _spoolrate$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?FLTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z	; SIMLIB_MATH_CLASS::FLTust
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+1212]

; 387  : 			if (fuel > 0.0F){

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+20]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN50@EngineMode

; 388  : 				rpm = max (rpm, 0.01F);

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1212]
	comiss	xmm0, DWORD PTR __real@3c23d70a
	jbe	SHORT $LN132@EngineMode
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1212]
	movss	DWORD PTR tv873[ebp], xmm0
	jmp	SHORT $LN133@EngineMode
$LN132@EngineMode:
	movss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR tv873[ebp], xmm0
$LN133@EngineMode:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv873[ebp]
	movss	DWORD PTR [ecx+1212], xmm0
$LN50@EngineMode:

; 389  : 			}
; 390  : 			// sfr: end added
; 391  : 
; 392  : 			// ftit calculated
; 393  : 			ftit = Math.FLTust(7.6F + (rpm - 1.0F) / 0.03F * 0.1F, ftitrate, dt, oldFtit);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1620				; 00000654H
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _ftitrate
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1212]
	subss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR __real@3cf5c28f
	mulss	xmm0, DWORD PTR __real@3dcccccd
	addss	xmm0, DWORD PTR __real@40f33333
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?FLTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z	; SIMLIB_MATH_CLASS::FLTust
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+1668]
$LN51@EngineMode:

; 394  : 		}
; 395  : 		
; 396  : 		/*--------------------------------*/
; 397  : 		/* scale thrust to reference area */
; 398  : 		/*--------------------------------*/
; 399  : 		thrtab = thrtb1 * engineData->thrustFactor;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	movss	xmm0, DWORD PTR _thrtb1$[ebp]
	mulss	xmm0, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+184], xmm0

; 400  : 		
; 401  : 		
; 402  : 		/*-----------------*/
; 403  : 		/* engine dynamics */
; 404  : 		/*-----------------*/
; 405  : 		if(IsSet(Trimming))// || simpleMode == SIMPLE_MODE_AF)

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	$LN49@EngineMode

; 406  : 		{
; 407  : 			ethrst = 1.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+204], xmm0

; 408  : 			tgross = thrtab;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+184]
	movss	DWORD PTR _tgross$[ebp], xmm0

; 409  : 			olda01[0] = tgross;

	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _tgross$[ebp]
	movss	DWORD PTR [edx+ecx+476], xmm0

; 410  : 			olda01[1] = tgross;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _tgross$[ebp]
	movss	DWORD PTR [ecx+eax+476], xmm0

; 411  : 			olda01[2] = tgross;

	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _tgross$[ebp]
	movss	DWORD PTR [eax+edx+476], xmm0

; 412  : 			olda01[3] = tgross;

	mov	ecx, 4
	imul	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _tgross$[ebp]
	movss	DWORD PTR [edx+ecx+476], xmm0

; 413  : 			
; 414  : 			rpm = rpmCmd;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _rpmCmd$[ebp]
	movss	DWORD PTR [eax+1212], xmm0

; 415  : 			oldRpm[0] = rpm;

	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1212]
	mov	DWORD PTR [edx+ecx+500], eax

; 416  : 			oldRpm[1] = rpm;

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1212]
	mov	DWORD PTR [edx+ecx+500], eax

; 417  : 			oldRpm[2] = rpm;

	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1212]
	mov	DWORD PTR [edx+ecx+500], eax

; 418  : 			oldRpm[3] = rpm;

	mov	ecx, 4
	imul	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1212]
	mov	DWORD PTR [edx+ecx+500], eax

; 419  : 		}
; 420  : 		else

	jmp	SHORT $LN48@EngineMode
$LN49@EngineMode:

; 421  : 		{
; 422  : 			//TJL 08/21/04 This lag filter no longer needed.
; 423  : 			tgross = thrtab;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+184]
	movss	DWORD PTR _tgross$[ebp], xmm0
$LN48@EngineMode:

; 424  : 			/*
; 425  : 			if(aburnLit)
; 426  : 			{
; 427  : 				
; 428  : 				//AB
; 429  : 				ta01 = auxaeroData->abSpoolRate + spoolAltRate;
; 430  : 				tgross = Math.FLTust(thrtab,ta01,dt,olda01);
; 431  : 			}
; 432  : 			else
; 433  : 			{
; 434  : 				//MIL
; 435  : 				if(pwrlev <= 1.0F)
; 436  : 					ta01 = auxaeroData->normSpoolRate + spoolAltRate;
; 437  : 				else
; 438  : 					ta01 = auxaeroData->abSpoolRate + spoolAltRate;
; 439  : 				
; 440  : 				tgross = Math.FLTust(thrtab,ta01,dt,olda01);
; 441  : 			}*/
; 442  : 
; 443  : 		}
; 444  : 		
; 445  : 		/*-----------*/
; 446  : 		/*   burn fuel */
; 447  : 		/*-----------*/
; 448  : 		if (AvailableFuel() <= 0.0f || IsEngineFlag(MasterFuelOff)) { // no fuel - dead engine.

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AvailableFuel@AirframeClass@@QAEMXZ	; AirframeClass::AvailableFuel
	fstp	DWORD PTR tv2164[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR tv2164[ebp]
	jae	SHORT $LN46@EngineMode
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsEngineFlag@AirframeClass@@QAEHW4EngineFlags@1@@Z ; AirframeClass::IsEngineFlag
	test	eax, eax
	je	SHORT $LN47@EngineMode
$LN46@EngineMode:

; 449  : 			SetFlag(EngineStopped);

	push	134217728				; 08000000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFlag@AirframeClass@@QAEXH@Z		; AirframeClass::SetFlag

; 450  : 			// mark it as a flame out
; 451  : 			platform->mFaults->SetFault(FaultClass::eng_fault, FaultClass::fl_out, FaultClass::fail, FALSE);

	push	0
	push	2
	push	-2147483648				; 80000000H
	push	8
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1088]
	mov	ecx, DWORD PTR [eax+928]
	call	?SetFault@FackClass@@QAEXW4type_FSubSystem@FaultClass@@W4type_FFunction@3@W4type_FSeverity@3@H@Z ; FackClass::SetFault

; 452  : 		}
; 453  : 		else

	jmp	$LN34@EngineMode
$LN47@EngineMode:

; 454  : 		{
; 455  : 			// JPO - back to basics... this stuff doesn't have to be complicated surely.
; 456  : 			// fuel flow is proportional to thrust.
; 457  : 			// thrust factor is already in, its just that tgross is thrust/mass, 
; 458  : 			// so we get rid of the mass component again.
; 459  : 			
; 460  : 			if(engineData->hasFuelFlow) // MLR 5/17/2004 - 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx+52], 0
	je	$LN44@EngineMode

; 461  : 			{
; 462  : 				// sfr: new fuel code per instructions
; 463  : 				if(aburnLit == TRUE)

	cmp	DWORD PTR _aburnLit$[ebp], 1
	jne	$LN43@EngineMode

; 464  : 				{
; 465  : 					float fflow1, fflow2;
; 466  : 
; 467  : 					fflow1 = Math.TwodInterp (-z, mach, engineData->alt,
; 468  : 						engineData->mach, engineData->fuelflow[1],engineData->numAlt,
; 469  : 						engineData->numMach, &curEngAltBreak, &curEngMachBreak);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 812				; 0000032cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 816				; 00000330H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR [eax+ecx+40]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+1144]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1116]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?TwodInterp@SIMLIB_MATH_CLASS@@QAEMMMPBM00HHPAH1@Z ; SIMLIB_MATH_CLASS::TwodInterp
	fstp	DWORD PTR _fflow1$10[ebp]

; 470  : 					fflow2 = Math.TwodInterp (-z, mach, engineData->alt,
; 471  : 						engineData->mach, engineData->fuelflow[2],engineData->numAlt,
; 472  : 						engineData->numMach, &curEngAltBreak, &curEngMachBreak);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 812				; 0000032cH
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 816				; 00000330H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR [edx+eax+40]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+1144]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1116]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?TwodInterp@SIMLIB_MATH_CLASS@@QAEMMMPBM00HHPAH1@Z ; SIMLIB_MATH_CLASS::TwodInterp
	fstp	DWORD PTR _fflow2$8[ebp]

; 473  : 					
; 474  : 					
; 475  : 					//fuelFlowSS = (33.3333333F*(fflow2 - fflow1)*(rpm-1.0F) + fflow1);
; 476  : 					 fuelFlowSS = (2.0F * ( fflow2 - fflow1)* (pwrlev - 1.0F) + fflow1);

	movss	xmm0, DWORD PTR _fflow2$8[ebp]
	subss	xmm0, DWORD PTR _fflow1$10[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+1516]
	subss	xmm1, DWORD PTR __real@3f800000
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR _fflow1$10[ebp]
	movss	DWORD PTR _fuelFlowSS$[ebp], xmm0

; 477  : 				}
; 478  : 				else

	jmp	$LN42@EngineMode
$LN43@EngineMode:

; 479  : 				{ 
; 480  : 					float fflow1, fflow2;
; 481  : 
; 482  : 					fflow1 = Math.TwodInterp (-z, mach, engineData->alt,
; 483  : 						engineData->mach, engineData->fuelflow[0],engineData->numAlt,
; 484  : 						engineData->numMach, &curEngAltBreak, &curEngMachBreak);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 812				; 0000032cH
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 816				; 00000330H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR [edx+eax+40]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+1144]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1116]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?TwodInterp@SIMLIB_MATH_CLASS@@QAEMMMPBM00HHPAH1@Z ; SIMLIB_MATH_CLASS::TwodInterp
	fstp	DWORD PTR _fflow1$9[ebp]

; 485  : 					fflow2 = Math.TwodInterp (-z, mach, engineData->alt,
; 486  : 						engineData->mach, engineData->fuelflow[1],engineData->numAlt,
; 487  : 						engineData->numMach, &curEngAltBreak, &curEngMachBreak);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 812				; 0000032cH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 816				; 00000330H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR [ecx+edx+40]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+1144]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1116]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?TwodInterp@SIMLIB_MATH_CLASS@@QAEMMMPBM00HHPAH1@Z ; SIMLIB_MATH_CLASS::TwodInterp
	fstp	DWORD PTR _fflow2$7[ebp]

; 488  : 
; 489  : 					//fuelFlowSS = ((fflow2 - fflow1)*(rpm-.7f)*3.33333f + fflow1);
; 490  : 					fuelFlowSS = (fflow2 - fflow1)* pwrlev + fflow1;

	movss	xmm0, DWORD PTR _fflow2$7[ebp]
	subss	xmm0, DWORD PTR _fflow1$9[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [eax+1516]
	addss	xmm0, DWORD PTR _fflow1$9[ebp]
	movss	DWORD PTR _fuelFlowSS$[ebp], xmm0
$LN42@EngineMode:

; 491  : 				}
; 492  : 				// end fuel
; 493  : 
; 494  : 				// sfr: old fuel
; 495  : #if 0
; 496  : 				if(rpm>1.0)
; 497  : 				{
; 498  : 					float fflow1, fflow2;
; 499  : 
; 500  : 					fflow1 = Math.TwodInterp (-z, mach, engineData->alt,
; 501  : 						engineData->mach, engineData->fuelflow[1],engineData->numAlt,
; 502  : 						engineData->numMach, &curEngAltBreak, &curEngMachBreak);
; 503  : 					fflow2 = Math.TwodInterp (-z, mach, engineData->alt,
; 504  : 						engineData->mach, engineData->fuelflow[2],engineData->numAlt,
; 505  : 						engineData->numMach, &curEngAltBreak, &curEngMachBreak);
; 506  : 					
; 507  : 					
; 508  : 					fuelFlowSS = (33.3333333F*(fflow2 - fflow1)*(rpm-1.0F) + fflow1);
; 509  : 				}
; 510  : 				else
; 511  : 				{ 
; 512  : 					float fflow1, fflow2;
; 513  : 
; 514  : 					fflow1 = Math.TwodInterp (-z, mach, engineData->alt,
; 515  : 						engineData->mach, engineData->fuelflow[0],engineData->numAlt,
; 516  : 						engineData->numMach, &curEngAltBreak, &curEngMachBreak);
; 517  : 					fflow2 = Math.TwodInterp (-z, mach, engineData->alt,
; 518  : 						engineData->mach, engineData->fuelflow[1],engineData->numAlt,
; 519  : 						engineData->numMach, &curEngAltBreak, &curEngMachBreak);
; 520  : 
; 521  : 					fuelFlowSS = ((fflow2 - fflow1)*(rpm-.7f)*3.33333f + fflow1);
; 522  : 				}
; 523  : 				// don't want to use thrust multiplier
; 524  : 				fuelFlowSS *= auxaeroData->nEngines;
; 525  : #endif
; 526  : 			}
; 527  : 			else

	jmp	SHORT $LN39@EngineMode
$LN44@EngineMode:

; 528  : 			{
; 529  : 				if (aburnLit)

	cmp	DWORD PTR _aburnLit$[ebp], 0
	je	SHORT $LN40@EngineMode

; 530  : 				{
; 531  : 					fuelFlowSS =  auxaeroData->fuelFlowFactorAb * tgross  * mass;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movss	xmm0, DWORD PTR [edx+4]
	mulss	xmm0, DWORD PTR _tgross$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [eax+40]
	movss	DWORD PTR _fuelFlowSS$[ebp], xmm0

; 532  : 				}
; 533  : 				else

	jmp	SHORT $LN39@EngineMode
$LN40@EngineMode:

; 534  : 				{ 
; 535  : 					fuelFlowSS = auxaeroData->fuelFlowFactorNormal * tgross * mass;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movss	xmm0, DWORD PTR [edx]
	mulss	xmm0, DWORD PTR _tgross$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [eax+40]
	movss	DWORD PTR _fuelFlowSS$[ebp], xmm0
$LN39@EngineMode:

; 536  : 				}
; 537  : 			}
; 538  : 			
; 539  : 			// For simplified model, burn less fuel
; 540  : 			if (IsSet(Simplified))

	push	8192					; 00002000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN38@EngineMode

; 541  : 			{
; 542  : 				fuelFlowSS *= 0.75F;

	movss	xmm0, DWORD PTR _fuelFlowSS$[ebp]
	mulss	xmm0, DWORD PTR __real@3f400000
	movss	DWORD PTR _fuelFlowSS$[ebp], xmm0
$LN38@EngineMode:

; 543  : 			}
; 544  : 			
; 545  : 			if (!platform->IsSetFlag(MOTION_OWNSHIP))

	push	65536					; 00010000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1088]
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	jne	SHORT $LN37@EngineMode

; 546  : 			{
; 547  : 				fuelFlowSS *= 0.75F;

	movss	xmm0, DWORD PTR _fuelFlowSS$[ebp]
	mulss	xmm0, DWORD PTR __real@3f400000
	movss	DWORD PTR _fuelFlowSS$[ebp], xmm0
$LN37@EngineMode:

; 548  : 			}
; 549  : 			
; 550  : 			fuelFlow += (fuelFlowSS - fuelFlow) / 10;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _fuelFlowSS$[ebp]
	subss	xmm0, DWORD PTR [edx+24]
	divss	xmm0, DWORD PTR __real@41200000
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+24]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+24], xmm0

; 551  : 			
; 552  : 			/*----------------------------------------------------------*/
; 553  : 			/* If fuel flow less < 100 lbs/min fuel flow == 100lbs/min) */
; 554  : 			/*----------------------------------------------------------*/
; 555  : 			if (fuelFlow < auxaeroData->minFuelFlow)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	comiss	xmm0, DWORD PTR [ecx+24]
	jbe	SHORT $LN36@EngineMode

; 556  : 				fuelFlow = auxaeroData->minFuelFlow;//me123 from 1000

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+24], edx
$LN36@EngineMode:

; 557  : 			if (fuelFlowSS < auxaeroData->minFuelFlow)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movss	xmm0, DWORD PTR [ecx+8]
	comiss	xmm0, DWORD PTR _fuelFlowSS$[ebp]
	jbe	SHORT $LN35@EngineMode

; 558  : 				fuelFlowSS = auxaeroData->minFuelFlow;//me123 from 1000

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	movss	xmm0, DWORD PTR [eax+8]
	movss	DWORD PTR _fuelFlowSS$[ebp], xmm0
$LN35@EngineMode:

; 559  : 			
; 560  : 			if (!IsSet(NoFuelBurn))

	push	16384					; 00004000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	jne	SHORT $LN34@EngineMode

; 561  : 			{
; 562  : 				// JPO - fuel is now burnt and transferred.
; 563  : 				BurnFuel(fuelFlowSS * dt / 3600.0F);

	movss	xmm0, DWORD PTR _fuelFlowSS$[ebp]
	mulss	xmm0, DWORD PTR _dt$[ebp]
	divss	xmm0, DWORD PTR __real@45610000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BurnFuel@AirframeClass@@QAEHM@Z	; AirframeClass::BurnFuel

; 564  : #if 0 // old code
; 565  : 				if (externalFuel > 0.0)
; 566  : 					externalFuel -= fuelFlowSS * dt / 3600.0F;
; 567  : 				else
; 568  : 					fuel = fuel - fuelFlowSS * dt / 3600.0F ;//me123 deleted + externalFuel;
; 569  : #endif	     
; 570  : 				weight -= fuelFlowSS * dt / 3600.0F;

	movss	xmm0, DWORD PTR _fuelFlowSS$[ebp]
	mulss	xmm0, DWORD PTR _dt$[ebp]
	divss	xmm0, DWORD PTR __real@45610000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+44]
	subss	xmm1, xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+44], xmm1

; 571  : 				mass    = weight / GRAVITY;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+44]
	divss	xmm0, DWORD PTR __real@4200b53f
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+40], xmm0
$LN34@EngineMode:

; 572  : 			}
; 573  : 			
; 574  : 			/*
; 575  : 			if (IsSet(Refueling))
; 576  : 			{
; 577  : 			fuel += 3000.0F * dt;
; 578  : 			if (fuel > 12000.0F)
; 579  : 			fuel = 12000.0F;
; 580  : 			}
; 581  : 			*/
; 582  : 		}
; 583  : 		//TJL 02/21/04 
; 584  : 		// sfr: commenting this, done inside ifelse
; 585  : 		/*
; 586  : 		EngineRpmMods(rpmCmd);
; 587  : 		rpmCmd = EngineRpmMods(rpmCmd);
; 588  : 		//TJL 02/22/04 Add in the alt
; 589  : 		spoolrate = spoolAltRate + spoolrate;
; 590  : 
; 591  : 		rpm = Math.FLTust (rpmCmd, spoolrate, dt, oldRpm);
; 592  : 		if (fuel > 0.0F)
; 593  : 			rpm = max (rpm, 0.01F);
; 594  : 			*/
; 595  : 		
; 596  : 		
; 597  : 		// ADDED BY S.G. TO SIMULATE THE HEAT PRODUCED BY THE ENGINE
; 598  : 		// I'M USING A PREVIOUSLY UNUSED ARRAY CALLED oldp01 FOR ENGINE HEAT TEMPERATURE
; 599  : 		// Afterburner lit?
; 600  : 		if (rpm > 100.0f)

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1212]
	comiss	xmm0, DWORD PTR __real@42c80000
	jbe	SHORT $LN33@EngineMode

; 601  : 			Math.FLTust (rpm + 0.5f, 0.5F, dt, oldp01);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 284				; 0000011cH
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1212]
	addss	xmm0, DWORD PTR __real@3f000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?FLTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z	; SIMLIB_MATH_CLASS::FLTust
	fstp	ST(0)

; 602  : 		else {

	jmp	$LN28@EngineMode
$LN33@EngineMode:

; 603  : 			// the 'modified rpm will be rpm^4.5
; 604  : 			float modRpm = (float)(rpm*rpm*rpm*rpm*sqrt(rpm));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1212]
	mulss	xmm0, DWORD PTR [eax+1212]
	mov	ecx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [ecx+1212]
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [edx+1212]
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm1, DWORD PTR [eax+1212]
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv2501[ebp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR tv2316[ebp]
	movss	xmm0, DWORD PTR tv2501[ebp]
	mulss	xmm0, DWORD PTR tv2316[ebp]
	movss	DWORD PTR _modRpm$12[ebp], xmm0

; 605  : 			
; 606  : 			// Am I increasing the rpm (but not yet in afterburner)?
; 607  : 			if (rpm > oldp01[0])

	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1212]
	comiss	xmm0, DWORD PTR [eax+ecx+284]
	jbe	SHORT $LN31@EngineMode

; 608  : 				Math.FLTust (modRpm, 4.0F, dt, oldp01);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 284				; 0000011cH
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@40800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _modRpm$12[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?FLTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z	; SIMLIB_MATH_CLASS::FLTust
	fstp	ST(0)

; 609  : 			// Must be decreasing then...
; 610  : 			else {

	jmp	$LN28@EngineMode
$LN31@EngineMode:

; 611  : 				// Now check if the 'heat' is still above 1.00 (100%)
; 612  : 				if (oldp01[0] > 1.0F)

	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+284]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN29@EngineMode

; 613  : 					Math.FLTust (modRpm, 7.0F, dt, oldp01);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 284				; 0000011cH
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@40e00000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _modRpm$12[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?FLTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z	; SIMLIB_MATH_CLASS::FLTust
	fstp	ST(0)

; 614  : 				else

	jmp	SHORT $LN28@EngineMode
$LN29@EngineMode:

; 615  : 					Math.FLTust (modRpm, 2.0F, dt, oldp01);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 284				; 0000011cH
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _modRpm$12[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?FLTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z	; SIMLIB_MATH_CLASS::FLTust
	fstp	ST(0)
$LN28@EngineMode:

; 616  : 			}
; 617  : 		}
; 618  : 		
; 619  : 		// END OF ADDED SECTION
; 620  : 		/*------------*/
; 621  : 		/* net thrust */
; 622  : 		/*------------*/
; 623  : 		if (platform->IsPlayer() && supercruise){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	call	?IsPlayer@FalconEntity@@QAEHXZ		; FalconEntity::IsPlayer
	test	eax, eax
	je	SHORT $LN27@EngineMode
	cmp	DWORD PTR ?supercruise@@3HA, 0		; supercruise
	je	SHORT $LN27@EngineMode

; 624  : 			thrust = tgross * ethrst*1.5F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _tgross$[ebp]
	mulss	xmm0, DWORD PTR [ecx+204]
	mulss	xmm0, DWORD PTR __real@3fc00000
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+188], xmm0

; 625  : 		}
; 626  : 		else {

	jmp	SHORT $LN26@EngineMode
$LN27@EngineMode:

; 627  : 			thrust = tgross * ethrst;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _tgross$[ebp]
	mulss	xmm0, DWORD PTR [eax+204]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+188], xmm0
$LN26@EngineMode:

; 628  : 		}
; 629  : 		//Cobra Thrust Reverse
; 630  : 		if (auxaeroData->hasThrRev){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+4028], 0
	je	$LN21@EngineMode

; 631  : 			if (platform->OnGround() && thrustReverse == 2){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1088]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+1088]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	je	SHORT $LN24@EngineMode
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1592], 2
	jne	SHORT $LN24@EngineMode

; 632  : 				thrust = (-thrust * 0.40f);

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+188]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR __real@3ecccccd
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+188], xmm0
$LN24@EngineMode:

; 633  : 			}
; 634  : 			//Cobra Thrust Reverse
; 635  : 			static int doOnce = 0;
; 636  : 			if (platform->IsPlayer() && thrustReverse == 2 && doOnce == 0){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1088]
	call	?IsPlayer@FalconEntity@@QAEHXZ		; FalconEntity::IsPlayer
	test	eax, eax
	je	SHORT $LN23@EngineMode
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1592], 2
	jne	SHORT $LN23@EngineMode
	cmp	DWORD PTR ?doOnce@?LF@??EngineModel@AirframeClass@@QAEXM@Z@4HA, 0
	jne	SHORT $LN23@EngineMode

; 637  : 				OTWDriver.ToggleThrustReverseDisplay();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?ToggleThrustReverseDisplay@OTWDriverClass@@QAEXXZ ; OTWDriverClass::ToggleThrustReverseDisplay

; 638  : 				doOnce = 1;

	mov	DWORD PTR ?doOnce@?LF@??EngineModel@AirframeClass@@QAEXM@Z@4HA, 1
	jmp	SHORT $LN21@EngineMode
$LN23@EngineMode:

; 639  : 			}
; 640  : 			else if (platform->IsPlayer() && thrustReverse == 0 && doOnce == 1){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	call	?IsPlayer@FalconEntity@@QAEHXZ		; FalconEntity::IsPlayer
	test	eax, eax
	je	SHORT $LN21@EngineMode
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1592], 0
	jne	SHORT $LN21@EngineMode
	cmp	DWORD PTR ?doOnce@?LF@??EngineModel@AirframeClass@@QAEXM@Z@4HA, 1
	jne	SHORT $LN21@EngineMode

; 641  : 				OTWDriver.ToggleThrustReverseDisplay();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?ToggleThrustReverseDisplay@OTWDriverClass@@QAEXXZ ; OTWDriverClass::ToggleThrustReverseDisplay

; 642  : 				doOnce = 0;

	mov	DWORD PTR ?doOnce@?LF@??EngineModel@AirframeClass@@QAEXM@Z@4HA, 0
$LN21@EngineMode:

; 643  : 			}
; 644  : 		}
; 645  : 		
; 646  : 		if(stallMode >= EnteringDeepStall){

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1248], 3
	jl	SHORT $LN20@EngineMode

; 647  : 			thrust *= 0.1f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+188]
	mulss	xmm0, DWORD PTR __real@3dcccccd
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+188], xmm0
$LN20@EngineMode:

; 648  : 		}
; 649  : 		
; 650  :    }
; 651  :    else

	jmp	$LN19@EngineMode
$LN73@EngineMode:

; 652  :    {
; 653  : 	   if (IsSet(ThrottleCheck))

	push	65536					; 00010000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	$LN18@EngineMode

; 654  : 	   {
; 655  : 		   if(throtl >= 1.5F)

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1512]
	comiss	xmm0, DWORD PTR __real@3fc00000
	jb	SHORT $LN17@EngineMode

; 656  : 			   throtl = pwrlev;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1516]
	mov	DWORD PTR [eax+1512], edx
$LN17@EngineMode:

; 657  : 		   if (g_bUseAnalogIdleCutoff)

	movzx	eax, BYTE PTR ?g_bUseAnalogIdleCutoff@@3_NA ; g_bUseAnalogIdleCutoff
	test	eax, eax
	je	SHORT $LN16@EngineMode

; 658  : 		   {
; 659  : 			   if (!IO.IsAxisCutOff(AXIS_THROTTLE) && (rpm > 0.20F))

	push	3
	mov	ecx, OFFSET ?IO@@3VSIMLIB_IO_CLASS@@A	; IO
	call	?IsAxisCutOff@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z ; SIMLIB_IO_CLASS::IsAxisCutOff
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN15@EngineMode
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1212]
	comiss	xmm0, DWORD PTR __real@3e4ccccd
	jbe	SHORT $LN15@EngineMode

; 660  : 				   ClearFlag(ThrottleCheck);

	push	65536					; 00010000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearFlag@AirframeClass@@QAEXH@Z	; AirframeClass::ClearFlag
$LN15@EngineMode:

; 661  : 		   }
; 662  : 		   else

	jmp	SHORT $LN13@EngineMode
$LN16@EngineMode:

; 663  : 		   {
; 664  : 			   if (fabs (throtl - pwrlev) > 0.1F)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1512]
	subss	xmm0, DWORD PTR [ecx+1516]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv2388[ebp]
	movss	xmm0, DWORD PTR tv2388[ebp]
	comiss	xmm0, DWORD PTR __real@3dcccccd
	jbe	SHORT $LN13@EngineMode

; 665  : 					ClearFlag(ThrottleCheck);

	push	65536					; 00010000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearFlag@AirframeClass@@QAEXH@Z	; AirframeClass::ClearFlag
$LN13@EngineMode:

; 666  : 		   }
; 667  : 		   pwrlev = throtl;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1512]
	mov	DWORD PTR [edx+1516], ecx

; 668  : 	   }
; 669  : 	   else

	jmp	SHORT $LN8@EngineMode
$LN18@EngineMode:

; 670  : 	   {
; 671  : 		   if (g_bUseAnalogIdleCutoff)

	movzx	edx, BYTE PTR ?g_bUseAnalogIdleCutoff@@3_NA ; g_bUseAnalogIdleCutoff
	test	edx, edx
	je	SHORT $LN11@EngineMode

; 672  : 		   {
; 673  : 			   if (!IO.IsAxisCutOff(AXIS_THROTTLE))

	push	3
	mov	ecx, OFFSET ?IO@@3VSIMLIB_IO_CLASS@@A	; IO
	call	?IsAxisCutOff@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z ; SIMLIB_IO_CLASS::IsAxisCutOff
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN10@EngineMode

; 674  : 				   ClearFlag (EngineOff);

	push	32768					; 00008000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearFlag@AirframeClass@@QAEXH@Z	; AirframeClass::ClearFlag
$LN10@EngineMode:

; 675  : 		   }
; 676  : 		   else

	jmp	SHORT $LN8@EngineMode
$LN11@EngineMode:

; 677  : 		   {
; 678  : 			   if (fabs (throtl - pwrlev) > 0.1F)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1512]
	subss	xmm0, DWORD PTR [edx+1516]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv2400[ebp]
	movss	xmm0, DWORD PTR tv2400[ebp]
	comiss	xmm0, DWORD PTR __real@3dcccccd
	jbe	SHORT $LN8@EngineMode

; 679  : 					ClearFlag (EngineOff);

	push	32768					; 00008000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearFlag@AirframeClass@@QAEXH@Z	; AirframeClass::ClearFlag
$LN8@EngineMode:

; 680  : 		   }
; 681  : 	   }
; 682  : 	   
; 683  : 	   thrust   = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+188], xmm0

; 684  : 	   tgross   = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _tgross$[ebp], xmm0

; 685  : 	   fuelFlow = 0.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+24], xmm0

; 686  : 	   rpm      = oldRpm[0]; // just remember where we were... JPO

	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+edx+500]
	mov	DWORD PTR [eax+1212], edx

; 687  : 	   // Changed so the Oil light doesn't come on :-) - RH
; 688  : 	   ftit     = 5.85f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@40bb3333
	movss	DWORD PTR [eax+1668], xmm0
$LN19@EngineMode:

; 689  :    }
; 690  :    
; 691  :    // turn on stdby generator
; 692  :    if (rpm > auxaeroData->stbyGenRpm && platform->MainPowerOn()) {

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1212]
	comiss	xmm0, DWORD PTR [edx+48]
	jbe	SHORT $LN7@EngineMode
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1088]
	call	?MainPowerOn@AircraftClass@@QAEHXZ	; AircraftClass::MainPowerOn
	test	eax, eax
	je	SHORT $LN7@EngineMode

; 693  :        GeneratorOn(GenStdby);

	push	64					; 00000040H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GeneratorOn@AirframeClass@@QAEXW4Generator@1@@Z ; AirframeClass::GeneratorOn

; 694  :    }
; 695  :    else

	jmp	SHORT $LN6@EngineMode
$LN7@EngineMode:

; 696  : 	   GeneratorOff(GenStdby);

	push	64					; 00000040H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GeneratorOff@AirframeClass@@QAEXW4Generator@1@@Z ; AirframeClass::GeneratorOff
$LN6@EngineMode:

; 697  :    
; 698  :    // tunr on main generator
; 699  :    if (rpm > auxaeroData->mainGenRpm && platform->MainPowerOn()) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1212]
	comiss	xmm0, DWORD PTR [eax+44]
	jbe	SHORT $LN5@EngineMode
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1088]
	call	?MainPowerOn@AircraftClass@@QAEHXZ	; AircraftClass::MainPowerOn
	test	eax, eax
	je	SHORT $LN5@EngineMode

; 700  :        GeneratorOn(GenMain);

	push	1024					; 00000400H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GeneratorOn@AirframeClass@@QAEXW4Generator@1@@Z ; AirframeClass::GeneratorOn

; 701  :    }
; 702  :    else

	jmp	SHORT $LN4@EngineMode
$LN5@EngineMode:

; 703  : 	   GeneratorOff(GenMain);

	push	1024					; 00000400H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GeneratorOff@AirframeClass@@QAEXW4Generator@1@@Z ; AirframeClass::GeneratorOff
$LN4@EngineMode:

; 704  :    
; 705  :    if (IsSet(OnObject) && vcas < 175) // JB carrier

	push	1073741824				; 40000000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN3@EngineMode
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@432f0000
	comiss	xmm0, DWORD PTR [eax+1124]
	jbe	SHORT $LN3@EngineMode

; 706  : 	   // RV - Biker - Use catapult thrust multiplier from FMs
; 707  : 	   //thrust *= 4;
; 708  : 	   thrust *= GetCatapultThrustMultiplier();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCatapultThrustMultiplier@AirframeClass@@QAEMXZ ; AirframeClass::GetCatapultThrustMultiplier
	fstp	DWORD PTR tv2428[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv2428[ebp]
	mulss	xmm0, DWORD PTR [ecx+188]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+188], xmm0
$LN3@EngineMode:

; 709  : 
; 710  : 
; 711  :    /*------------------*/
; 712  :    /* body axis accels */
; 713  :    /*------------------*/
; 714  :    if (nozzlePos == 0) { // normal case JPO

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1808]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN2@EngineMode

; 715  : 	   xprop =  thrust;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+188]
	mov	DWORD PTR [ecx+760], eax

; 716  : 	   yprop =  0.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+764], xmm0

; 717  : 	   zprop =  0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+768], xmm0

; 718  : 	   /*-----------------------*/
; 719  : 	   /* stability axis accels */
; 720  : 	   /*-----------------------*/
; 721  : 	   xsprop =  xprop *platform->platformAngles.cosalp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+760]
	mulss	xmm0, DWORD PTR [ecx+344]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+772], xmm0

; 722  : 	   ysprop =  yprop;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+764]
	mov	DWORD PTR [ecx+776], eax

; 723  : 	   //   zsprop = 0.0F;		//assume flcs cancels this out? (makes life easier)
; 724  : 	   //   zsprop = -thrust*platform->platformAngles.sinalp * 0.001F; //why the 0.001F ?
; 725  : 	   //	zsprop = -thrust*platform->platformAngles.sinalp; // JPO previous
; 726  : 	   zsprop = - xprop * platform->platformAngles.sinalp;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+760]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1088]
	mulss	xmm0, DWORD PTR [eax+340]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+780], xmm0

; 727  :    }
; 728  :    else { // harrier fake stuff - doesn't really work.

	jmp	$LN1@EngineMode
$LN2@EngineMode:

; 729  : 	   mlTrig noz;
; 730  : 	   mlSinCos(&noz, nozzlePos);

	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+1808]
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _noz$5[ebp]
	push	eax
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 731  : 	   xprop = thrust * noz.cos;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+188]
	mulss	xmm0, DWORD PTR _noz$5[ebp+4]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+760], xmm0

; 732  : 	   yprop =  0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+764], xmm0

; 733  : 	   zprop = -thrust * noz.sin;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+188]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR _noz$5[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+768], xmm0

; 734  : 	   /*-----------------------*/
; 735  : 	   /* stability axis accels */
; 736  : 	   /*-----------------------*/
; 737  : 	   xsprop =  xprop *platform->platformAngles.cosalp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+760]
	mulss	xmm0, DWORD PTR [ecx+344]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+772], xmm0

; 738  : 	   ysprop =  yprop;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+764]
	mov	DWORD PTR [ecx+776], eax

; 739  : 	   //   zsprop = 0.0F;		//assume flcs cancels this out? (makes life easier)
; 740  : 	   //   zsprop = -thrust*platform->platformAngles.sinalp * 0.001F; //why the 0.001F ?
; 741  : 	   //	zsprop = -thrust*platform->platformAngles.sinalp; // JPO previous
; 742  : 	   zsprop = - xprop * platform->platformAngles.sinalp +
; 743  : 		   zprop * platform->platformAngles.cosalp;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+760]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1088]
	mulss	xmm0, DWORD PTR [eax+340]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1088]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+768]
	mulss	xmm1, DWORD PTR [edx+344]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+780], xmm0
$LN1@EngineMode:

; 744  : 	   
; 745  :    }
; 746  :    
; 747  :    ShiAssert(!_isnan(platform->platformAngles.cosalp));
; 748  :    ShiAssert(!_isnan(platform->platformAngles.sinalp));
; 749  :    
; 750  :    /*------------------*/
; 751  :    /* wind axis accels */
; 752  :    /*------------------*/
; 753  :    xwprop =  xsprop*platform->platformAngles.cosbet +
; 754  : 	   ysprop*platform->platformAngles.sinbet;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1088]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+772]
	mulss	xmm0, DWORD PTR [eax+356]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1088]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+776]
	mulss	xmm1, DWORD PTR [eax+352]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+784], xmm0

; 755  :    ywprop = -xsprop*platform->platformAngles.sinbet +
; 756  : 	   ysprop*platform->platformAngles.cosbet;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+772]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1088]
	mulss	xmm0, DWORD PTR [edx+352]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+776]
	mulss	xmm1, DWORD PTR [ecx+356]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+788], xmm0

; 757  :    zwprop =  zsprop;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+780]
	mov	DWORD PTR [ecx+792], eax

; 758  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?EngineModel@AirframeClass@@QAEXM@Z$0:
	mov	eax, DWORD PTR $T11[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?EngineModel@AirframeClass@@QAEXM@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-216]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?EngineModel@AirframeClass@@QAEXM@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?EngineModel@AirframeClass@@QAEXM@Z ENDP		; AirframeClass::EngineModel
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?GetCatapultThrustMultiplier@AirframeClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCatapultThrustMultiplier@AirframeClass@@QAEMXZ PROC	; AirframeClass::GetCatapultThrustMultiplier, COMDAT
; _this$ = ecx

; 745  : 	float GetCatapultThrustMultiplier() { return auxaeroData->catapultThrustMultiplier; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+2624]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCatapultThrustMultiplier@AirframeClass@@QAEMXZ ENDP	; AirframeClass::GetCatapultThrustMultiplier
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\mltrig.h
;	COMDAT ?mlSinCos@@YAXPAUmlTrig@@M@Z
_TEXT	SEGMENT
_trig$ = 8						; size = 4
_angle$ = 12						; size = 4
?mlSinCos@@YAXPAUmlTrig@@M@Z PROC			; mlSinCos, COMDAT

; 12   : {

	push	ebp
	mov	ebp, esp

; 13   : #if defined(_MSC_VER)
; 14   : 	__asm 
; 15   : 	{
; 16   : 		__asm	mov     ecx, trig;

	mov	ecx, DWORD PTR _trig$[ebp]

; 17   : 		__asm	fld     dword ptr [angle];

	fld	DWORD PTR _angle$[ebp]

; 18   : 		__asm	fsincos;

	fsincos

; 19   : 		__asm	fstp    dword ptr [ecx]trig.cos;

	fstp	DWORD PTR [ecx+4]

; 20   : 		__asm	fstp    dword ptr [ecx]trig.sin;

	fstp	DWORD PTR [ecx]

; 21   : 	}
; 22   : #else
; 23   : 	trig->sin = (Float32)sin(angle);
; 24   : 	trig->cos = (Float32)cos(angle);
; 25   : #endif
; 26   : }

	pop	ebp
	ret	0
?mlSinCos@@YAXPAUmlTrig@@M@Z ENDP			; mlSinCos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsPlayer@FalconEntity@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsPlayer@FalconEntity@@QAEHXZ PROC			; FalconEntity::IsPlayer, COMDAT
; _this$ = ecx

; 113  : 	int IsPlayer (void)							{ return IsSetFalcFlag(FEC_HASPLAYERS); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSetFalcFlag@FalconEntity@@QAEHH@Z	; FalconEntity::IsSetFalcFlag
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPlayer@FalconEntity@@QAEHXZ ENDP			; FalconEntity::IsPlayer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsSetFalcFlag@FalconEntity@@QAEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_flag$ = 8						; size = 4
?IsSetFalcFlag@FalconEntity@@QAEHH@Z PROC		; FalconEntity::IsSetFalcFlag, COMDAT
; _this$ = ecx

; 112  : 	int IsSetFalcFlag (int flag)				{ return falconFlags & flag; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+136]
	and	eax, DWORD PTR _flag$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsSetFalcFlag@FalconEntity@@QAEHH@Z ENDP		; FalconEntity::IsSetFalcFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuevent.h
;	COMDAT ?RequestOutOfBandTransmit@VuMessage@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?RequestOutOfBandTransmit@VuMessage@@QAEXXZ PROC	; VuMessage::RequestOutOfBandTransmit, COMDAT
; _this$ = ecx

; 181  : 	void RequestOutOfBandTransmit() { flags_ |= VU_OUT_OF_BAND_MSG_FLAG; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+6]
	or	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+6], cl
	mov	esp, ebp
	pop	ebp
	ret	0
?RequestOutOfBandTransmit@VuMessage@@QAEXXZ ENDP	; VuMessage::RequestOutOfBandTransmit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ PROC ; VuBin<VuSessionEntity>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ENDP ; VuBin<VuSessionEntity>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ PROC		; VuBin<VuSessionEntity>::operator bool, COMDAT
; _this$ = ecx

; 40   : 	operator bool() const{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 		return e != NULL;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@operator
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv66[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv66[ebp]

; 42   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ ENDP		; VuBin<VuSessionEntity>::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2275 : 		{	// report an out_of_range error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2276 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN2@Xran:

; 2277 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2270 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2271 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN2@Xlen:

; 2272 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Ptr$1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2253 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2254 : 		if (!_Built)

	movzx	eax, BYTE PTR __Built$[ebp]
	test	eax, eax
	jne	SHORT $LN4@Tidy
	jmp	SHORT $LN3@Tidy
$LN4@Tidy:

; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN3@Tidy

; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Ptr$1[ebp], eax

; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 2260 : 			if (0 < _Newsize)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN1@Tidy

; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$1[ebp]
	push	ecx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Tidy:

; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Ptr$1[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN3@Tidy:

; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2266 : 		_Eos(_Newsize);

	mov	edx, DWORD PTR __Newsize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2267 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2237 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	cmp	DWORD PTR __Ptr$[ebp], 0
	je	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	cmp	DWORD PTR __Ptr$[ebp], eax
	jb	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
$LN2@Inside:

; 2240 : 			return (false);	// don't ask

	xor	al, al
	jmp	SHORT $LN4@Inside

; 2241 : 		else

	jmp	SHORT $LN4@Inside
$LN3@Inside:

; 2242 : 			return (true);

	mov	al, 1
$LN4@Inside:

; 2243 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
tv136 = -12						; size = 4
tv129 = -8						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2224 : 		if (max_size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN6@Grow

; 2225 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN6@Grow:

; 2226 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN5@Grow

; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	jmp	SHORT $LN4@Grow
$LN5@Grow:

; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	movzx	edx, BYTE PTR __Trim$[ebp]
	test	edx, edx
	je	SHORT $LN3@Grow
	cmp	DWORD PTR __Newsize$[ebp], 16		; 00000010H
	jae	SHORT $LN3@Grow

; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jae	SHORT $LN9@Grow
	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv129[ebp], edx
	jmp	SHORT $LN10@Grow
$LN9@Grow:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR tv129[ebp], ecx
$LN10@Grow:
	mov	edx, DWORD PTR tv129[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
	jmp	SHORT $LN4@Grow
$LN3@Grow:

; 2231 : 		else if (_Newsize == 0)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $LN4@Grow

; 2232 : 			_Eos(0);	// new size is zero, just null terminate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN4@Grow:

; 2233 : 		return (0 < _Newsize);	// return true only if more work to do

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN11@Grow
	mov	DWORD PTR tv136[ebp], 1
	jmp	SHORT $LN12@Grow
$LN11@Grow:
	mov	DWORD PTR tv136[ebp], 0
$LN12@Grow:
	mov	al, BYTE PTR tv136[ebp]
$LN8@Grow:

; 2234 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [eax+16], ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 2219 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
tv205 = -48						; size = 4
tv204 = -44						; size = 4
tv203 = -40						; size = 4
tv202 = -36						; size = 4
__Ptr$ = -32						; size = 4
__Newres$ = -28						; size = 4
_this$ = -24						; size = 4
$T2 = -19						; size = 1
$T3 = -18						; size = 1
$T4 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Newres$[ebp], eax

; 2184 : 		if (max_size() < _Newres)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newres$[ebp]
	jae	SHORT $LN9@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx
	jmp	SHORT $LN8@Copy
$LN9@Copy:

; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)

	mov	eax, DWORD PTR __Newres$[ebp]
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	shr	ecx, 1
	cmp	ecx, eax
	ja	SHORT $LN7@Copy
	jmp	SHORT $LN8@Copy
$LN7@Copy:

; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+20]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, esi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], eax
	ja	SHORT $LN5@Copy

; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	shr	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR __Newres$[ebp], eax

; 2191 : 		else

	jmp	SHORT $LN8@Copy
$LN5@Copy:

; 2192 : 			_Newres = max_size();	// settle for max_size()

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	DWORD PTR __Newres$[ebp], eax
$LN8@Copy:

; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv202[ebp], eax
	mov	eax, DWORD PTR __Newres$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR tv202[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv203[ebp], eax
	mov	ecx, DWORD PTR tv203[ebp]
	mov	DWORD PTR __Ptr$[ebp], ecx
	jmp	SHORT $LN12@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2197 : 		_CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], edx

; 2199 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv204[ebp], eax
	mov	ecx, DWORD PTR __Newres$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR tv204[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv205[ebp], eax
	mov	edx, DWORD PTR tv205[ebp]
	mov	DWORD PTR __Ptr$[ebp], edx
	jmp	SHORT $LN14@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2203 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 2204 : 			_CATCH_END

	mov	eax, $LN17@Copy
	ret	0
$LN14@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2
$LN17@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2:

; 2205 : 		_CATCH_END

	mov	eax, $LN19@Copy
	ret	0
$LN12@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3
$LN19@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jbe	SHORT $LN1@Copy

; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements

	mov	eax, DWORD PTR __Oldlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Copy:

; 2210 : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);

	lea	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>

; 2212 : 		this->_Myres = _Newres;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newres$[ebp]
	mov	DWORD PTR [edx+20], eax

; 2213 : 		_Eos(_Oldlen);

	mov	ecx, DWORD PTR __Oldlen$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN11@Copy:

; 2214 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv75 = -12						; size = 4
__Num$ = -8						; size = 4
$T1 = -1						; size = 1
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1737 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1738 : 		size_type _Num = this->_Getal().max_size();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
	mov	DWORD PTR __Num$[ebp], eax

; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$[ebp], 1
	ja	SHORT $LN3@max_size
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	ecx, DWORD PTR __Num$[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv75[ebp], ecx
$LN4@max_size:
	mov	eax, DWORD PTR tv75[ebp]

; 1740 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1732 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1733 : 		return (this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]

; 1734 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$1 = -12					; size = 4
__Ptr$2 = -8						; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1317 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1318 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN4@erase

; 1319 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN4@erase:

; 1320 : 		if (this->_Mysize - _Off <= _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Off$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	ja	SHORT $LN3@erase

; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)

	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
	jmp	SHORT $LN2@erase
$LN3@erase:

; 1322 : 		else if (0 < _Count)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN2@erase

; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Ptr$2[ebp], eax

; 1325 : 			size_type _Newsize = this->_Mysize - _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Newsize$1[ebp], eax

; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	sub	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$2[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$2[ebp]
	push	eax
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 1327 : 			_Eos(_Newsize);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@erase:

; 1328 : 			}
; 1329 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN6@erase:

; 1330 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1309 : 		{	// erase elements [_Off, ...)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1310 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN1@erase

; 1311 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN1@erase:

; 1312 : 		_Eos(_Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1313 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@erase:

; 1314 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1142 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1145 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@assign

; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	jmp	SHORT $LN3@assign
$LN2@assign:

; 1132 : 
; 1133 : 		if (_Grow(_Count))

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@assign

; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1136 : 			_Eos(_Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@assign:

; 1137 : 			}
; 1138 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@assign:

; 1139 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1105 : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $LN5@assign

; 1106 : 			_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN5@assign:

; 1107 : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 1108 : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Num$[ebp]
	jae	SHORT $LN4@assign

; 1109 : 			_Num = _Count;	// trim _Num to size

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
$LN4@assign:

; 1110 : 
; 1111 : 		if (this == &_Right)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@assign

; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	mov	eax, DWORD PTR __Roff$[ebp]
	add	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	mov	ecx, DWORD PTR __Roff$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	jmp	SHORT $LN2@assign
$LN3@assign:

; 1113 : 		else if (_Grow(_Num))

	push	0
	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@assign

; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);

	mov	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1117 : 			_Eos(_Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@assign:

; 1118 : 			}
; 1119 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN7@assign:

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 791  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >

; 792  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 793  : 		assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 794  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 688  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 689  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 690  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 635  : 	_String_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >

; 636  : 		{	// construct allocator from _Al
; 637  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		{	// determine current pointer to buffer for nonmutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 522  : 		return (this->_BUF_SIZE <= this->_Myres
; 523  : 			? _STD addressof(*this->_Bx._Ptr)
; 524  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 525  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		{	// determine current pointer to buffer for mutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 515  : 		return (this->_BUF_SIZE <= this->_Myres
; 516  : 			? _STD addressof(*this->_Bx._Ptr)
; 517  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 518  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 496  : 	_String_val()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 497  : 		{	// initialize values
; 498  : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 499  : 		_Myres = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 500  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 913  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 914  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
	add	esp, 4

; 915  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 886  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 887  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate

; 888  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 875  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 877  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 830  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>

; 831  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 761  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp

; 762  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@D@std@@QBEIXZ	; std::allocator<char>::max_size

; 763  : 		}

	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

	or	eax, -1

; 629  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 590  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8

; 592  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 565  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 563  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 564  : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 565  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 551  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@move
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@move
$LN3@move:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@move:
	mov	eax, DWORD PTR tv69[ebp]

; 554  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 528  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@copy
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@copy
$LN3@copy:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@copy:
	mov	eax, DWORD PTR tv69[ebp]

; 531  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 521  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp
	push	ecx

; 522  : 		return (*_First == 0 ? 0
; 523  : 			: _CSTD strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@length
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN4@length
$LN3@length:
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR tv68[ebp], eax
$LN4@length:
	mov	eax, DWORD PTR tv68[ebp]

; 524  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 65   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 60   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 61   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?ZPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ZPos@VuEntity@@QBEMXZ PROC				; VuEntity::ZPos, COMDAT
; _this$ = ecx

; 160  : 	BIG_SCALAR ZPos()	const { return pos_.z_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+44]
	mov	esp, ebp
	pop	ebp
	ret	0
?ZPos@VuEntity@@QBEMXZ ENDP				; VuEntity::ZPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Type@VuEntity@@QBEGXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Type@VuEntity@@QBEGXZ PROC				; VuEntity::Type, COMDAT
; _this$ = ecx

; 154  : 	ushort Type() const       { return share_.entityType_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?Type@VuEntity@@QBEGXZ ENDP				; VuEntity::Type
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Id@VuEntity@@QBE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?Id@VuEntity@@QBE?AVVU_ID@@XZ PROC			; VuEntity::Id, COMDAT
; _this$ = ecx

; 131  : 	VU_ID Id() const	{ return share_.id_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?Id@VuEntity@@QBE?AVVU_ID@@XZ ENDP			; VuEntity::Id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
_TEXT	SEGMENT
_x$ = 8							; size = 4
?SqrtSSE@@YAMM@Z PROC					; SqrtSSE

; 91   : static inline float SqrtSSE(float x){ 

	push	ebp
	mov	ebp, esp

; 92   :     __asm 
; 93   :     { 
; 94   :         sqrtss xmm0,x 

	sqrtss	xmm0, DWORD PTR _x$[ebp]

; 95   :         movss x,xmm0 

	movss	XMMWORD PTR _x$[ebp], xmm0

; 96   :     } 
; 97   : 
; 98   :     return x; 

	fld	DWORD PTR _x$[ebp]

; 99   : } 

	pop	ebp
	ret	0
?SqrtSSE@@YAMM@Z ENDP					; SqrtSSE
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?fabs@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?fabs@@YAMM@Z PROC					; fabs, COMDAT

; 517  :         {return (fabsf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_fabsf
	add	esp, 4
	pop	ebp
	ret	0
?fabs@@YAMM@Z ENDP					; fabs
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_fabsf	PROC						; COMDAT

; 392  :         {return ((float)fabs((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_fabsf	ENDP
_TEXT	ENDS
END
