; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\SIM\Airframe\Cruise.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
_DATA	SEGMENT
_matrix33_ident DD 03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	ORG $+4
_matrix44_ident DD 03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
_DATA	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
PUBLIC	_powf
PUBLIC	?pow@@YAMMM@Z					; pow
PUBLIC	?GetOptimumCruise@AirframeClass@@QAEMXZ		; AirframeClass::GetOptimumCruise
PUBLIC	?GetOptimumAltitude@AirframeClass@@QAEMXZ	; AirframeClass::GetOptimumAltitude
PUBLIC	?GetOptKias@AirframeClass@@QAEMH@Z		; AirframeClass::GetOptKias
PUBLIC	__real@00000000
PUBLIC	__real@3b1bc5c4
PUBLIC	__real@3dcccccd
PUBLIC	__real@3e4ccccd
PUBLIC	__real@3e92491b
PUBLIC	__real@3f17ac60
PUBLIC	__real@3f333333
PUBLIC	__real@3f47ae14
PUBLIC	__real@3f59999a
PUBLIC	__real@3f5c28f6
PUBLIC	__real@3f800000
PUBLIC	__real@3fb33333
PUBLIC	__real@40000000
PUBLIC	__real@40200000
PUBLIC	__real@40400000
PUBLIC	__real@40600000
PUBLIC	__real@40e00000
PUBLIC	__real@41f00000
PUBLIC	__real@424ccb78
PUBLIC	__real@42700000
PUBLIC	__real@42c80000
PUBLIC	__real@4326e666
PUBLIC	__real@44b8e3d7
PUBLIC	__real@44ec347b
PUBLIC	__real@45044385
PUBLIC	__real@47698892
PUBLIC	__real@48d5a678
PUBLIC	__real@bf2d6a16
PUBLIC	__real@c1a0fae1
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	_pow:PROC
EXTRN	?TwodInterp@SIMLIB_MATH_CLASS@@QAEMMMPBM00HHPAH1@Z:PROC ; SIMLIB_MATH_CLASS::TwodInterp
EXTRN	?CalcMach@AirframeClass@@AAEMMM@Z:PROC		; AirframeClass::CalcMach
EXTRN	?CalcPressureRatio@AirframeClass@@AAEMMPAM0@Z:PROC ; AirframeClass::CalcPressureRatio
EXTRN	?Math@@3VSIMLIB_MATH_CLASS@@A:BYTE		; Math
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
_allocator_arg DB 01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@c1a0fae1
CONST	SEGMENT
__real@c1a0fae1 DD 0c1a0fae1r			; -20.1225
CONST	ENDS
;	COMDAT __real@bf2d6a16
CONST	SEGMENT
__real@bf2d6a16 DD 0bf2d6a16r			; -0.6774
CONST	ENDS
;	COMDAT __real@48d5a678
CONST	SEGMENT
__real@48d5a678 DD 048d5a678r			; 437556
CONST	ENDS
;	COMDAT __real@47698892
CONST	SEGMENT
__real@47698892 DD 047698892r			; 59784.6
CONST	ENDS
;	COMDAT __real@45044385
CONST	SEGMENT
__real@45044385 DD 045044385r			; 2116.22
CONST	ENDS
;	COMDAT __real@44ec347b
CONST	SEGMENT
__real@44ec347b DD 044ec347br			; 1889.64
CONST	ENDS
;	COMDAT __real@44b8e3d7
CONST	SEGMENT
__real@44b8e3d7 DD 044b8e3d7r			; 1479.12
CONST	ENDS
;	COMDAT __real@4326e666
CONST	SEGMENT
__real@4326e666 DD 04326e666r			; 166.9
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@42700000
CONST	SEGMENT
__real@42700000 DD 042700000r			; 60
CONST	ENDS
;	COMDAT __real@424ccb78
CONST	SEGMENT
__real@424ccb78 DD 0424ccb78r			; 51.1987
CONST	ENDS
;	COMDAT __real@41f00000
CONST	SEGMENT
__real@41f00000 DD 041f00000r			; 30
CONST	ENDS
;	COMDAT __real@40e00000
CONST	SEGMENT
__real@40e00000 DD 040e00000r			; 7
CONST	ENDS
;	COMDAT __real@40600000
CONST	SEGMENT
__real@40600000 DD 040600000r			; 3.5
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@40200000
CONST	SEGMENT
__real@40200000 DD 040200000r			; 2.5
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3fb33333
CONST	SEGMENT
__real@3fb33333 DD 03fb33333r			; 1.4
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f5c28f6
CONST	SEGMENT
__real@3f5c28f6 DD 03f5c28f6r			; 0.86
CONST	ENDS
;	COMDAT __real@3f59999a
CONST	SEGMENT
__real@3f59999a DD 03f59999ar			; 0.85
CONST	ENDS
;	COMDAT __real@3f47ae14
CONST	SEGMENT
__real@3f47ae14 DD 03f47ae14r			; 0.78
CONST	ENDS
;	COMDAT __real@3f333333
CONST	SEGMENT
__real@3f333333 DD 03f333333r			; 0.7
CONST	ENDS
;	COMDAT __real@3f17ac60
CONST	SEGMENT
__real@3f17ac60 DD 03f17ac60r			; 0.592474
CONST	ENDS
;	COMDAT __real@3e92491b
CONST	SEGMENT
__real@3e92491b DD 03e92491br			; 0.285714
CONST	ENDS
;	COMDAT __real@3e4ccccd
CONST	SEGMENT
__real@3e4ccccd DD 03e4ccccdr			; 0.2
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3b1bc5c4
CONST	SEGMENT
__real@3b1bc5c4 DD 03b1bc5c4r			; 0.0023769
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\airframe\cruise.cpp
_TEXT	SEGMENT
tv319 = -84						; size = 4
tv310 = -80						; size = 4
tv298 = -76						; size = 4
tv293 = -72						; size = 4
tv284 = -68						; size = 4
tv328 = -64						; size = 4
tv272 = -60						; size = 4
_rsigma$1 = -56						; size = 4
_ttheta$2 = -52						; size = 4
tv250 = -48						; size = 4
_Cl$ = -44						; size = 4
tv240 = -40						; size = 4
tv204 = -36						; size = 4
_qpasl1$3 = -32						; size = 4
_pa$4 = -28						; size = 4
_oper$5 = -24						; size = 4
_qc$6 = -20						; size = 4
_vcas$7 = -16						; size = 4
_OptimumAirspeed$ = -12					; size = 4
_mach$8 = -8						; size = 4
_this$ = -4						; size = 4
_mode$ = 8						; size = 4
?GetOptKias@AirframeClass@@QAEMH@Z PROC			; AirframeClass::GetOptKias
; _this$ = ecx

; 57   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	mov	DWORD PTR _this$[ebp], ecx

; 58   : 
; 59   : 	// mode 0 =climb 1 =end  2 =rng
; 60   : 	float Cl;
; 61   : 	float OptimumAirspeed;
; 62   : 	
; 63   : 	Cl = Math.TwodInterp(0.7F,
; 64   : 								OPTIMUM_ALPHA+(dragIndex/60-1.4f),// me123 take drag into acount 
; 65   : 								aeroData->mach,
; 66   : 								aeroData->alpha, 
; 67   : 								aeroData->clift,
; 68   : 								aeroData->numMach, 
; 69   : 								aeroData->numAlpha,
; 70   : 								&curMachBreak, 
; 71   : 								&curAlphaBreak) * aeroData->clFactor;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 800				; 00000320H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 796				; 0000031cH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+48]
	divss	xmm0, DWORD PTR __real@42700000
	subss	xmm0, DWORD PTR __real@3fb33333
	addss	xmm0, DWORD PTR __real@40e00000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f333333
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?TwodInterp@SIMLIB_MATH_CLASS@@QAEMMMPBM00HHPAH1@Z ; SIMLIB_MATH_CLASS::TwodInterp
	fstp	DWORD PTR tv240[ebp]
	movss	xmm0, DWORD PTR tv240[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [ecx+28]
	movss	DWORD PTR _Cl$[ebp], xmm0

; 72   : 													//me13 RHOASL from rho
; 73   : 	OptimumAirspeed	= (float)sqrt (2.0F * weight / (RHOASL * area * Cl)) * FTPSEC_TO_KNOTS;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR [edx+44]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR __real@3b1bc5c4
	mulss	xmm1, DWORD PTR [eax+16]
	mulss	xmm1, DWORD PTR _Cl$[ebp]
	divss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR tv250[ebp]
	movss	xmm0, DWORD PTR tv250[ebp]
	mulss	xmm0, DWORD PTR __real@3f17ac60
	movss	DWORD PTR _OptimumAirspeed$[ebp], xmm0

; 74   : 
; 75   : 	if (mode == 0) OptimumAirspeed	+= 100.0f;

	cmp	DWORD PTR _mode$[ebp], 0
	jne	SHORT $LN10@GetOptKias
	movss	xmm0, DWORD PTR _OptimumAirspeed$[ebp]
	addss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR _OptimumAirspeed$[ebp], xmm0
$LN10@GetOptKias:

; 76   : 	if (mode == 2) OptimumAirspeed	+= 30.0f;

	cmp	DWORD PTR _mode$[ebp], 2
	jne	SHORT $LN9@GetOptKias
	movss	xmm0, DWORD PTR _OptimumAirspeed$[ebp]
	addss	xmm0, DWORD PTR __real@41f00000
	movss	DWORD PTR _OptimumAirspeed$[ebp], xmm0
$LN9@GetOptKias:

; 77   : 
; 78   : 	if (1)

	mov	ecx, 1
	test	ecx, ecx
	je	$LN8@GetOptKias

; 79   : 	{
; 80   : 		float ttheta, rsigma;
; 81   : 		float mach, vcas, pa;
; 82   : 		float qpasl1, oper, qc;
; 83   : 
; 84   : 			if (mode == 0) mach = 0.86f;

	cmp	DWORD PTR _mode$[ebp], 0
	jne	SHORT $LN7@GetOptKias
	movss	xmm0, DWORD PTR __real@3f5c28f6
	movss	DWORD PTR _mach$8[ebp], xmm0
$LN7@GetOptKias:

; 85   : 			if (mode == 1) mach = 0.78f;

	cmp	DWORD PTR _mode$[ebp], 1
	jne	SHORT $LN6@GetOptKias
	movss	xmm0, DWORD PTR __real@3f47ae14
	movss	DWORD PTR _mach$8[ebp], xmm0
$LN6@GetOptKias:

; 86   : 			if (mode == 2) mach = 0.85f;

	cmp	DWORD PTR _mode$[ebp], 2
	jne	SHORT $LN5@GetOptKias
	movss	xmm0, DWORD PTR __real@3f59999a
	movss	DWORD PTR _mach$8[ebp], xmm0
$LN5@GetOptKias:

; 87   : 		   
; 88   : 			CalcPressureRatio(-z, &ttheta, &rsigma);

	lea	edx, DWORD PTR _rsigma$1[ebp]
	push	edx
	lea	eax, DWORD PTR _ttheta$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1116]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalcPressureRatio@AirframeClass@@AAEMMPAM0@Z ; AirframeClass::CalcPressureRatio
	fstp	ST(0)

; 89   : 			pa   = ttheta * rsigma * PASL;

	movss	xmm0, DWORD PTR _ttheta$2[ebp]
	mulss	xmm0, DWORD PTR _rsigma$1[ebp]
	mulss	xmm0, DWORD PTR __real@45044385
	movss	DWORD PTR _pa$4[ebp], xmm0

; 90   : 
; 91   : 		   /*-------------------------------*/
; 92   : 		   /* calculate calibrated airspeed */
; 93   : 		   /*-------------------------------*/
; 94   : 		   if (mach <= 1.0F)

	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _mach$8[ebp]
	jb	SHORT $LN4@GetOptKias

; 95   : 			  qc = ((float)pow((1.0F + 0.2F*mach*mach), 3.5F) - 1.0F)*pa;

	push	ecx
	movss	xmm0, DWORD PTR __real@40600000
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3e4ccccd
	mulss	xmm0, DWORD PTR _mach$8[ebp]
	mulss	xmm0, DWORD PTR _mach$8[ebp]
	addss	xmm0, DWORD PTR __real@3f800000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?pow@@YAMMM@Z				; pow
	add	esp, 8
	fstp	DWORD PTR tv272[ebp]
	movss	xmm0, DWORD PTR tv272[ebp]
	subss	xmm0, DWORD PTR __real@3f800000
	mulss	xmm0, DWORD PTR _pa$4[ebp]
	movss	DWORD PTR _qc$6[ebp], xmm0

; 96   : 		   else

	jmp	SHORT $LN3@GetOptKias
$LN4@GetOptKias:

; 97   : 			  qc = ((166.9F*mach*mach)/(float)(pow((7.0F - 1.0F/(mach*mach)), 2.5F)) - 1.0F)*pa;

	movss	xmm0, DWORD PTR __real@4326e666
	mulss	xmm0, DWORD PTR _mach$8[ebp]
	mulss	xmm0, DWORD PTR _mach$8[ebp]
	push	ecx
	movss	xmm1, DWORD PTR __real@40200000
	movss	DWORD PTR [esp], xmm1
	movss	xmm1, DWORD PTR _mach$8[ebp]
	mulss	xmm1, DWORD PTR _mach$8[ebp]
	movss	xmm2, DWORD PTR __real@3f800000
	divss	xmm2, xmm1
	movss	xmm1, DWORD PTR __real@40e00000
	subss	xmm1, xmm2
	push	ecx
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv328[ebp], xmm0
	call	?pow@@YAMMM@Z				; pow
	add	esp, 8
	fstp	DWORD PTR tv284[ebp]
	movss	xmm0, DWORD PTR tv328[ebp]
	divss	xmm0, DWORD PTR tv284[ebp]
	subss	xmm0, DWORD PTR __real@3f800000
	mulss	xmm0, DWORD PTR _pa$4[ebp]
	movss	DWORD PTR _qc$6[ebp], xmm0
$LN3@GetOptKias:

; 98   : 
; 99   : 		   qpasl1 = qc/PASL + 1.0F;

	movss	xmm0, DWORD PTR _qc$6[ebp]
	divss	xmm0, DWORD PTR __real@45044385
	addss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _qpasl1$3[ebp], xmm0

; 100  : 		   vcas = 1479.12F*(float)sqrt(pow(qpasl1, 0.285714F) - 1.0F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3e92491b
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _qpasl1$3[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?pow@@YAMMM@Z				; pow
	add	esp, 8
	fstp	DWORD PTR tv293[ebp]
	movss	xmm0, DWORD PTR tv293[ebp]
	subss	xmm0, DWORD PTR __real@3f800000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR tv298[ebp]
	movss	xmm0, DWORD PTR tv298[ebp]
	mulss	xmm0, DWORD PTR __real@44b8e3d7
	movss	DWORD PTR _vcas$7[ebp], xmm0

; 101  : 
; 102  : 		   if (qc > 1889.64F)

	movss	xmm0, DWORD PTR _qc$6[ebp]
	comiss	xmm0, DWORD PTR __real@44ec347b
	jbe	$LN2@GetOptKias

; 103  : 		   {
; 104  : 			  oper = qpasl1 * (float)pow((7.0F - AASLK*AASLK/(vcas*vcas)), 2.5F);

	push	ecx
	movss	xmm0, DWORD PTR __real@40200000
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _vcas$7[ebp]
	mulss	xmm0, DWORD PTR _vcas$7[ebp]
	movss	xmm1, DWORD PTR __real@48d5a678
	divss	xmm1, xmm0
	movss	xmm0, DWORD PTR __real@40e00000
	subss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?pow@@YAMMM@Z				; pow
	add	esp, 8
	fstp	DWORD PTR tv310[ebp]
	movss	xmm0, DWORD PTR tv310[ebp]
	mulss	xmm0, DWORD PTR _qpasl1$3[ebp]
	movss	DWORD PTR _oper$5[ebp], xmm0

; 105  : 			  if (oper < 0.0F) oper = 0.1F;

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _oper$5[ebp]
	jbe	SHORT $LN1@GetOptKias
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _oper$5[ebp], xmm0
$LN1@GetOptKias:

; 106  : 			  vcas = 51.1987F*(float)sqrt(oper);

	push	ecx
	movss	xmm0, DWORD PTR _oper$5[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR tv319[ebp]
	movss	xmm0, DWORD PTR tv319[ebp]
	mulss	xmm0, DWORD PTR __real@424ccb78
	movss	DWORD PTR _vcas$7[ebp], xmm0
$LN2@GetOptKias:

; 107  : 		   }
; 108  : 		   OptimumAirspeed = min (OptimumAirspeed,vcas);

	movss	xmm0, DWORD PTR _vcas$7[ebp]
	comiss	xmm0, DWORD PTR _OptimumAirspeed$[ebp]
	jbe	SHORT $LN13@GetOptKias
	movss	xmm0, DWORD PTR _OptimumAirspeed$[ebp]
	movss	DWORD PTR tv204[ebp], xmm0
	jmp	SHORT $LN14@GetOptKias
$LN13@GetOptKias:
	movss	xmm0, DWORD PTR _vcas$7[ebp]
	movss	DWORD PTR tv204[ebp], xmm0
$LN14@GetOptKias:
	movss	xmm0, DWORD PTR tv204[ebp]
	movss	DWORD PTR _OptimumAirspeed$[ebp], xmm0
$LN8@GetOptKias:

; 109  : 	}
; 110  : 
; 111  : 	return OptimumAirspeed;

	fld	DWORD PTR _OptimumAirspeed$[ebp]

; 112  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetOptKias@AirframeClass@@QAEMH@Z ENDP			; AirframeClass::GetOptKias
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\airframe\cruise.cpp
_TEXT	SEGMENT
_optimum_altitude$ = -8					; size = 4
_this$ = -4						; size = 4
?GetOptimumAltitude@AirframeClass@@QAEMXZ PROC		; AirframeClass::GetOptimumAltitude
; _this$ = ecx

; 44   : float	AirframeClass::GetOptimumAltitude(void) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 45   : 
; 46   : 	float optimum_altitude;
; 47   : 
; 48   : 	// note: must find the drag index for either aim120 or f16
; 49   : 	optimum_altitude =	OPTIMUM_ALT_M1 * dragIndex*3 +// me123 take drag into acount 
; 50   : 								OPTIMUM_ALT_M2 * weight + 
; 51   : 								OPTIMUM_ALT_B;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@c1a0fae1
	mulss	xmm0, DWORD PTR [eax+48]
	mulss	xmm0, DWORD PTR __real@40400000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR __real@bf2d6a16
	mulss	xmm1, DWORD PTR [ecx+44]
	addss	xmm0, xmm1
	addss	xmm0, DWORD PTR __real@47698892
	movss	DWORD PTR _optimum_altitude$[ebp], xmm0

; 52   : 	
; 53   : 	return optimum_altitude;

	fld	DWORD PTR _optimum_altitude$[ebp]

; 54   : }	

	mov	esp, ebp
	pop	ebp
	ret	0
?GetOptimumAltitude@AirframeClass@@QAEMXZ ENDP		; AirframeClass::GetOptimumAltitude
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\airframe\cruise.cpp
_TEXT	SEGMENT
_OptimumMach$ = -28					; size = 4
_OptimumAirspeed$ = -24					; size = 4
_pressureRatio$ = -20					; size = 4
tv181 = -16						; size = 4
_Cl$ = -12						; size = 4
tv171 = -8						; size = 4
_this$ = -4						; size = 4
?GetOptimumCruise@AirframeClass@@QAEMXZ PROC		; AirframeClass::GetOptimumCruise
; _this$ = ecx

; 20   : float AirframeClass::GetOptimumCruise(void) {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 21   : 
; 22   : 	float Cl;
; 23   : 	float OptimumAirspeed;
; 24   : 	float	OptimumMach;
; 25   : 	float pressureRatio;
; 26   : 	
; 27   : 	Cl = Math.TwodInterp(0.7F,
; 28   : 								OPTIMUM_ALPHA+(dragIndex/60-1.4f),// me123 take drag into acount 
; 29   : 								aeroData->mach,
; 30   : 								aeroData->alpha, 
; 31   : 								aeroData->clift,
; 32   : 								aeroData->numMach, 
; 33   : 								aeroData->numAlpha,
; 34   : 								&curMachBreak, 
; 35   : 								&curAlphaBreak) * aeroData->clFactor;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 800				; 00000320H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 796				; 0000031cH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+48]
	divss	xmm0, DWORD PTR __real@42700000
	subss	xmm0, DWORD PTR __real@3fb33333
	addss	xmm0, DWORD PTR __real@40e00000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f333333
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?TwodInterp@SIMLIB_MATH_CLASS@@QAEMMMPBM00HHPAH1@Z ; SIMLIB_MATH_CLASS::TwodInterp
	fstp	DWORD PTR tv171[ebp]
	movss	xmm0, DWORD PTR tv171[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [ecx+28]
	movss	DWORD PTR _Cl$[ebp], xmm0

; 36   : 													//me13 RHOASL from rho
; 37   : 	OptimumAirspeed	= (float)sqrt (2.0F * weight / (RHOASL * area * Cl)) * FTPSEC_TO_KNOTS;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR [edx+44]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR __real@3b1bc5c4
	mulss	xmm1, DWORD PTR [eax+16]
	mulss	xmm1, DWORD PTR _Cl$[ebp]
	divss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR tv181[ebp]
	movss	xmm0, DWORD PTR tv181[ebp]
	mulss	xmm0, DWORD PTR __real@3f17ac60
	movss	DWORD PTR _OptimumAirspeed$[ebp], xmm0

; 38   : 	pressureRatio		= rho / RHOASL;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1128]
	divss	xmm0, DWORD PTR __real@3b1bc5c4
	movss	DWORD PTR _pressureRatio$[ebp], xmm0

; 39   : 	OptimumMach			= CalcMach(OptimumAirspeed, pressureRatio);

	push	ecx
	movss	xmm0, DWORD PTR _pressureRatio$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _OptimumAirspeed$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalcMach@AirframeClass@@AAEMMM@Z	; AirframeClass::CalcMach
	fstp	DWORD PTR _OptimumMach$[ebp]

; 40   : 
; 41   : 	return OptimumMach;

	fld	DWORD PTR _OptimumMach$[ebp]

; 42   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetOptimumCruise@AirframeClass@@QAEMXZ ENDP		; AirframeClass::GetOptimumCruise
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
_TEXT	SEGMENT
_x$ = 8							; size = 4
?SqrtSSE@@YAMM@Z PROC					; SqrtSSE

; 91   : static inline float SqrtSSE(float x){ 

	push	ebp
	mov	ebp, esp

; 92   :     __asm 
; 93   :     { 
; 94   :         sqrtss xmm0,x 

	sqrtss	xmm0, DWORD PTR _x$[ebp]

; 95   :         movss x,xmm0 

	movss	XMMWORD PTR _x$[ebp], xmm0

; 96   :     } 
; 97   : 
; 98   :     return x; 

	fld	DWORD PTR _x$[ebp]

; 99   : } 

	pop	ebp
	ret	0
?SqrtSSE@@YAMM@Z ENDP					; SqrtSSE
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?pow@@YAMMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
__Y$ = 12						; size = 4
?pow@@YAMMM@Z PROC					; pow, COMDAT

; 533  :         {return (powf(_X, _Y)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __Y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_powf
	add	esp, 8
	pop	ebp
	ret	0
?pow@@YAMMM@Z ENDP					; pow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _powf
_TEXT	SEGMENT
tv77 = -12						; size = 8
tv79 = -4						; size = 4
__X$ = 8						; size = 4
__Y$ = 12						; size = 4
_powf	PROC						; COMDAT

; 428  :         {return ((float)pow((double)_X, (double)_Y)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __Y$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_pow
	add	esp, 16					; 00000010H
	fstp	QWORD PTR tv77[ebp]
	movsd	xmm0, QWORD PTR tv77[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv79[ebp], xmm0
	fld	DWORD PTR tv79[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_powf	ENDP
_TEXT	ENDS
END
