; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\SIM\Airframe\Yaw.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
_DATA	SEGMENT
_matrix33_ident DD 03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	ORG $+4
_matrix44_ident DD 03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
_DATA	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
PUBLIC	_fabsf
PUBLIC	?fabs@@YAMM@Z					; fabs
PUBLIC	?Yaw@AirframeClass@@AAEXXZ			; AirframeClass::Yaw
PUBLIC	?YawIt@AirframeClass@@QAEXMM@Z			; AirframeClass::YawIt
PUBLIC	?IsSet@AirframeClass@@QBEHH@Z			; AirframeClass::IsSet
PUBLIC	?IsF16@AircraftClass@@QAEHXZ			; AircraftClass::IsF16
PUBLIC	__real@00000000
PUBLIC	__real@3d4ccccd
PUBLIC	__real@3da3d70a
PUBLIC	__real@3dcccccd
PUBLIC	__real@3e4ccccd
PUBLIC	__real@3ecccccd
PUBLIC	__real@3f000000
PUBLIC	__real@3f4ccccd
PUBLIC	__real@3f800000
PUBLIC	__real@3fc00000
PUBLIC	__real@40000000
PUBLIC	__real@40a00000
PUBLIC	__real@4200b53f
PUBLIC	__real@42652ee1
PUBLIC	__real@43340000
PUBLIC	__real@43af0000
PUBLIC	__real@43b40000
PUBLIC	__real@c0000000
PUBLIC	__real@c3340000
EXTRN	_fabs:PROC
EXTRN	?FLTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z:PROC	; SIMLIB_MATH_CLASS::FLTust
EXTRN	?FIAdamsBash@SIMLIB_MATH_CLASS@@QAEMMMQAM@Z:PROC ; SIMLIB_MATH_CLASS::FIAdamsBash
EXTRN	?GetLimiter@LimiterMgrClass@@QAEPAVLimiter@@HH@Z:PROC ; LimiterMgrClass::GetLimiter
EXTRN	?SimLibMinorFrameTime@@3MA:DWORD		; SimLibMinorFrameTime
EXTRN	?Math@@3VSIMLIB_MATH_CLASS@@A:BYTE		; Math
EXTRN	?gLimiterMgr@@3PAVLimiterMgrClass@@A:DWORD	; gLimiterMgr
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
_allocator_arg DB 01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __real@c3340000
CONST	SEGMENT
__real@c3340000 DD 0c3340000r			; -180
CONST	ENDS
;	COMDAT __real@c0000000
CONST	SEGMENT
__real@c0000000 DD 0c0000000r			; -2
CONST	ENDS
;	COMDAT __real@43b40000
CONST	SEGMENT
__real@43b40000 DD 043b40000r			; 360
CONST	ENDS
;	COMDAT __real@43af0000
CONST	SEGMENT
__real@43af0000 DD 043af0000r			; 350
CONST	ENDS
;	COMDAT __real@43340000
CONST	SEGMENT
__real@43340000 DD 043340000r			; 180
CONST	ENDS
;	COMDAT __real@42652ee1
CONST	SEGMENT
__real@42652ee1 DD 042652ee1r			; 57.2958
CONST	ENDS
;	COMDAT __real@4200b53f
CONST	SEGMENT
__real@4200b53f DD 04200b53fr			; 32.177
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3fc00000
CONST	SEGMENT
__real@3fc00000 DD 03fc00000r			; 1.5
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f4ccccd
CONST	SEGMENT
__real@3f4ccccd DD 03f4ccccdr			; 0.8
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3ecccccd
CONST	SEGMENT
__real@3ecccccd DD 03ecccccdr			; 0.4
CONST	ENDS
;	COMDAT __real@3e4ccccd
CONST	SEGMENT
__real@3e4ccccd DD 03e4ccccdr			; 0.2
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3da3d70a
CONST	SEGMENT
__real@3da3d70a DD 03da3d70ar			; 0.08
CONST	ENDS
;	COMDAT __real@3d4ccccd
CONST	SEGMENT
__real@3d4ccccd DD 03d4ccccdr			; 0.05
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?IsF16@AircraftClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
?IsF16@AircraftClass@@QAEHXZ PROC			; AircraftClass::IsF16, COMDAT
; _this$ = ecx

; 335  : 	int            IsF16 (void) {return (acFlags & isF16 ? TRUE : FALSE);}

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+964]
	and	ecx, 1
	je	SHORT $LN3@IsF16
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsF16
$LN3@IsF16:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsF16:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?IsF16@AircraftClass@@QAEHXZ ENDP			; AircraftClass::IsF16
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?IsSet@AirframeClass@@QBEHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_testFlag$ = 8						; size = 4
?IsSet@AirframeClass@@QBEHH@Z PROC			; AirframeClass::IsSet, COMDAT
; _this$ = ecx

; 1216 : 	int IsSet (int testFlag) const {return flags & testFlag ? 1 : 0;}

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	and	ecx, DWORD PTR _testFlag$[ebp]
	je	SHORT $LN3@IsSet
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsSet
$LN3@IsSet:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsSet:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsSet@AirframeClass@@QBEHH@Z ENDP			; AirframeClass::IsSet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\airframe\yaw.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_betcmd$ = 8						; size = 4
_dt$ = 12						; size = 4
?YawIt@AirframeClass@@QAEXMM@Z PROC			; AirframeClass::YawIt
; _this$ = ecx

; 196  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 197  : 	// JB 010714 mult by the momentum
; 198  : 	beta   = Math.FLTust(betcmd ,ty02 * auxaeroData->yawMomentum,dt,oldy03);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 452				; 000001c4H
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1436]
	mulss	xmm0, DWORD PTR [edx+196]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _betcmd$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?FLTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z	; SIMLIB_MATH_CLASS::FLTust
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+1156]

; 199  : 
; 200  : 	if(beta < -180.0F)

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@c3340000
	comiss	xmm0, DWORD PTR [edx+1156]
	jbe	$LN3@YawIt

; 201  : 	{
; 202  : 		oldy03[0] += 360.0F;

	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+452]
	addss	xmm0, DWORD PTR __real@43b40000
	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+edx+452], xmm0

; 203  : 		oldy03[1] += 360.0F;

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+452]
	addss	xmm0, DWORD PTR __real@43b40000
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+eax+452], xmm0

; 204  : 		oldy03[2] += 360.0F;

	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+452]
	addss	xmm0, DWORD PTR __real@43b40000
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+ecx+452], xmm0

; 205  : 		oldy03[3] += 360.0F;

	mov	eax, 4
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+452]
	addss	xmm0, DWORD PTR __real@43b40000
	mov	edx, 4
	imul	edx, 3
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+edx+452], xmm0
	jmp	$LN1@YawIt
$LN3@YawIt:

; 206  : 	}
; 207  : 	else if(beta > 180.0F)

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1156]
	comiss	xmm0, DWORD PTR __real@43340000
	jbe	$LN1@YawIt

; 208  : 	{
; 209  : 		oldy03[0] -= 360.0F;

	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+452]
	subss	xmm0, DWORD PTR __real@43b40000
	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+ecx+452], xmm0

; 210  : 		oldy03[1] -= 360.0F;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+452]
	subss	xmm0, DWORD PTR __real@43b40000
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+edx+452], xmm0

; 211  : 		oldy03[2] -= 360.0F;

	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+452]
	subss	xmm0, DWORD PTR __real@43b40000
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+eax+452], xmm0

; 212  : 		oldy03[3] -= 360.0F;

	mov	edx, 4
	imul	edx, 3
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+452]
	subss	xmm0, DWORD PTR __real@43b40000
	mov	ecx, 4
	imul	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+ecx+452], xmm0
$LN1@YawIt:

; 213  : 	}
; 214  : 
; 215  : 
; 216  : 	ShiAssert(!_isnan(beta));
; 217  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?YawIt@AirframeClass@@QAEXMM@Z ENDP			; AirframeClass::YawIt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\airframe\yaw.cpp
_TEXT	SEGMENT
tv605 = -132						; size = 4
tv644 = -128						; size = 4
_eintg1$ = -124						; size = 4
tv462 = -120						; size = 4
tv518 = -116						; size = 4
tv474 = -112						; size = 4
tv505 = -108						; size = 4
tv450 = -104						; size = 4
tv496 = -100						; size = 4
tv417 = -96						; size = 4
tv486 = -92						; size = 4
tv410 = -88						; size = 4
_asymmYaw$1 = -84					; size = 4
tv89 = -80						; size = 4
tv316 = -76						; size = 4
_gsAvail$ = -72						; size = 4
tv313 = -68						; size = 4
tv133 = -64						; size = 4
tv300 = -60						; size = 4
tv90 = -56						; size = 4
tv86 = -52						; size = 4
_error1$ = -48						; size = 4
_error$ = -44						; size = 4
_asymmYpedal$2 = -40					; size = 4
_alphaError$ = -36					; size = 4
_engine2$3 = -32					; size = 4
_eprop$ = -28						; size = 4
_engine1$4 = -24					; size = 4
_betcmd$ = -20						; size = 4
_eintg$ = -16						; size = 4
_nycmd$ = -12						; size = 4
_limiter$ = -8						; size = 4
_this$ = -4						; size = 4
?Yaw@AirframeClass@@AAEXXZ PROC				; AirframeClass::Yaw
; _this$ = ecx

; 63   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 132				; 00000084H
	mov	DWORD PTR _this$[ebp], ecx

; 64   : float error, error1, eprop, eintg, eintg1;
; 65   : //float betdt1,  beta1, lastBeta;
; 66   : float betcmd, nycmd, gsAvail, alphaError;
; 67   : Limiter *limiter = NULL;

	mov	DWORD PTR _limiter$[ebp], 0

; 68   : 
; 69   : 	//if( IsSet(Planted) || (IsSet(NoseSteerOn) && !(gear[0].flags & GearData::GearStuck)) )
; 70   : 	if(!IsSet(InAir))

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	jne	SHORT $LN20@Yaw

; 71   : 		return;

	jmp	$LN21@Yaw
$LN20@Yaw:

; 72   : 
; 73   : 	if(platform->IsF16())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1088]
	call	?IsF16@AircraftClass@@QAEHXZ		; AircraftClass::IsF16
	test	eax, eax
	je	SHORT $LN19@Yaw

; 74   : 		alphaError = (float)(fabs(q) + fabs(p)*0.5F)*0.4F*RTD;

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+1136]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv410[ebp]
	movss	xmm0, DWORD PTR tv410[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm1, DWORD PTR [edx+1132]
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv644[ebp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv417[ebp]
	movss	xmm0, DWORD PTR tv417[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	xmm1, DWORD PTR tv644[ebp]
	addss	xmm1, xmm0
	mulss	xmm1, DWORD PTR __real@3ecccccd
	mulss	xmm1, DWORD PTR __real@42652ee1
	movss	DWORD PTR _alphaError$[ebp], xmm1

; 75   : 	else

	jmp	SHORT $LN18@Yaw
$LN19@Yaw:

; 76   : 		alphaError = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _alphaError$[ebp], xmm0
$LN18@Yaw:

; 77   : 
; 78   :    /*--------------*/
; 79   :    /* command path */
; 80   :    /*--------------*/
; 81   : 
; 82   :    nycmd = yshape*2.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+664]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR _nycmd$[ebp], xmm0

; 83   : 
; 84   :    nycmd = min ( max ( nycmd, -2.0F), 2.0F);

	movss	xmm0, DWORD PTR _nycmd$[ebp]
	comiss	xmm0, DWORD PTR __real@c0000000
	jbe	SHORT $LN23@Yaw
	movss	xmm0, DWORD PTR _nycmd$[ebp]
	movss	DWORD PTR tv86[ebp], xmm0
	jmp	SHORT $LN24@Yaw
$LN23@Yaw:
	movss	xmm0, DWORD PTR __real@c0000000
	movss	DWORD PTR tv86[ebp], xmm0
$LN24@Yaw:
	movss	xmm0, DWORD PTR __real@40000000
	comiss	xmm0, DWORD PTR tv86[ebp]
	jbe	SHORT $LN27@Yaw
	movss	xmm0, DWORD PTR _nycmd$[ebp]
	comiss	xmm0, DWORD PTR __real@c0000000
	jbe	SHORT $LN25@Yaw
	movss	xmm0, DWORD PTR _nycmd$[ebp]
	movss	DWORD PTR tv89[ebp], xmm0
	jmp	SHORT $LN26@Yaw
$LN25@Yaw:
	movss	xmm0, DWORD PTR __real@c0000000
	movss	DWORD PTR tv89[ebp], xmm0
$LN26@Yaw:
	movss	xmm0, DWORD PTR tv89[ebp]
	movss	DWORD PTR tv90[ebp], xmm0
	jmp	SHORT $LN28@Yaw
$LN27@Yaw:
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR tv90[ebp], xmm0
$LN28@Yaw:
	movss	xmm0, DWORD PTR tv90[ebp]
	movss	DWORD PTR _nycmd$[ebp], xmm0

; 85   :    gsAvail = betmax * 0.05F * qsom / GRAVITY;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+176]
	mulss	xmm0, DWORD PTR __real@3d4ccccd
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [edx+648]
	divss	xmm0, DWORD PTR __real@4200b53f
	movss	DWORD PTR _gsAvail$[ebp], xmm0

; 86   : 
; 87   :    nycmd *= min (gsAvail/2.0F, 1.0F);

	movss	xmm0, DWORD PTR _gsAvail$[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR __real@3f800000
	comiss	xmm1, xmm0
	jbe	SHORT $LN29@Yaw
	movss	xmm0, DWORD PTR _gsAvail$[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR tv133[ebp], xmm0
	jmp	SHORT $LN30@Yaw
$LN29@Yaw:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv133[ebp], xmm0
$LN30@Yaw:
	movss	xmm0, DWORD PTR _nycmd$[ebp]
	mulss	xmm0, DWORD PTR tv133[ebp]
	movss	DWORD PTR _nycmd$[ebp], xmm0

; 88   : 
; 89   :    if(IsSet(CATLimiterIII))

	push	2097152					; 00200000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	$LN17@Yaw

; 90   :    {
; 91   : 	   limiter = gLimiterMgr->GetLimiter(CatIIIYawAlphaLimiter,vehicleIndex);

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+92]
	push	ecx
	push	8
	mov	ecx, DWORD PTR ?gLimiterMgr@@3PAVLimiterMgrClass@@A ; gLimiterMgr
	call	?GetLimiter@LimiterMgrClass@@QAEPAVLimiter@@HH@Z ; LimiterMgrClass::GetLimiter
	mov	DWORD PTR _limiter$[ebp], eax

; 92   : 		if(limiter)

	cmp	DWORD PTR _limiter$[ebp], 0
	je	SHORT $LN16@Yaw

; 93   : 			nycmd *= limiter->Limit(alpha - alphaError);

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1152]
	subss	xmm0, DWORD PTR _alphaError$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _limiter$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _limiter$[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	fstp	DWORD PTR tv450[ebp]
	movss	xmm0, DWORD PTR tv450[ebp]
	mulss	xmm0, DWORD PTR _nycmd$[ebp]
	movss	DWORD PTR _nycmd$[ebp], xmm0
$LN16@Yaw:

; 94   : 
; 95   : 		limiter = gLimiterMgr->GetLimiter(CatIIIYawRollRateLimiter,vehicleIndex);

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+92]
	push	edx
	push	9
	mov	ecx, DWORD PTR ?gLimiterMgr@@3PAVLimiterMgrClass@@A ; gLimiterMgr
	call	?GetLimiter@LimiterMgrClass@@QAEPAVLimiter@@HH@Z ; LimiterMgrClass::GetLimiter
	mov	DWORD PTR _limiter$[ebp], eax

; 96   : 	   if(limiter)

	cmp	DWORD PTR _limiter$[ebp], 0
	je	SHORT $LN15@Yaw

; 97   : 			nycmd *= limiter->Limit(p*RTD);

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1132]
	mulss	xmm0, DWORD PTR __real@42652ee1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _limiter$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _limiter$[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	fstp	DWORD PTR tv462[ebp]
	movss	xmm0, DWORD PTR tv462[ebp]
	mulss	xmm0, DWORD PTR _nycmd$[ebp]
	movss	DWORD PTR _nycmd$[ebp], xmm0
$LN15@Yaw:

; 98   :    }
; 99   :    else

	jmp	$LN12@Yaw
$LN17@Yaw:

; 100  :    {
; 101  : 	   limiter = gLimiterMgr->GetLimiter(YawAlphaLimiter,vehicleIndex);

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+92]
	push	edx
	push	3
	mov	ecx, DWORD PTR ?gLimiterMgr@@3PAVLimiterMgrClass@@A ; gLimiterMgr
	call	?GetLimiter@LimiterMgrClass@@QAEPAVLimiter@@HH@Z ; LimiterMgrClass::GetLimiter
	mov	DWORD PTR _limiter$[ebp], eax

; 102  : 	   if(limiter)

	cmp	DWORD PTR _limiter$[ebp], 0
	je	SHORT $LN13@Yaw

; 103  : 			nycmd *= limiter->Limit(alpha - alphaError);

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1152]
	subss	xmm0, DWORD PTR _alphaError$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _limiter$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _limiter$[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	fstp	DWORD PTR tv474[ebp]
	movss	xmm0, DWORD PTR tv474[ebp]
	mulss	xmm0, DWORD PTR _nycmd$[ebp]
	movss	DWORD PTR _nycmd$[ebp], xmm0
$LN13@Yaw:

; 104  : 
; 105  : 	   limiter = gLimiterMgr->GetLimiter(YawRollRateLimiter,vehicleIndex);

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+92]
	push	edx
	push	4
	mov	ecx, DWORD PTR ?gLimiterMgr@@3PAVLimiterMgrClass@@A ; gLimiterMgr
	call	?GetLimiter@LimiterMgrClass@@QAEPAVLimiter@@HH@Z ; LimiterMgrClass::GetLimiter
	mov	DWORD PTR _limiter$[ebp], eax

; 106  : 	   if(limiter)

	cmp	DWORD PTR _limiter$[ebp], 0
	je	SHORT $LN12@Yaw

; 107  : 			nycmd *= limiter->Limit(p*RTD);

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1132]
	mulss	xmm0, DWORD PTR __real@42652ee1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _limiter$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _limiter$[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	fstp	DWORD PTR tv486[ebp]
	movss	xmm0, DWORD PTR tv486[ebp]
	mulss	xmm0, DWORD PTR _nycmd$[ebp]
	movss	DWORD PTR _nycmd$[ebp], xmm0
$LN12@Yaw:

; 108  :    }
; 109  :    
; 110  :    limiter = gLimiterMgr->GetLimiter(CatIIICommandType,vehicleIndex);

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+92]
	push	edx
	push	5
	mov	ecx, DWORD PTR ?gLimiterMgr@@3PAVLimiterMgrClass@@A ; gLimiterMgr
	call	?GetLimiter@LimiterMgrClass@@QAEPAVLimiter@@HH@Z ; LimiterMgrClass::GetLimiter
	mov	DWORD PTR _limiter$[ebp], eax

; 111  :    if( fabs(yshape) >= 0.1F && (limiter) )

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+664]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv496[ebp]
	movss	xmm0, DWORD PTR tv496[ebp]
	comiss	xmm0, DWORD PTR __real@3dcccccd
	jb	SHORT $LN11@Yaw
	cmp	DWORD PTR _limiter$[ebp], 0
	je	SHORT $LN11@Yaw

; 112  : 	   nycmd *= (5.0F/limiter->Limit(vcas*0.8F));

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1124]
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _limiter$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _limiter$[ebp]
	mov	edx, DWORD PTR [eax]
	call	edx
	fstp	DWORD PTR tv505[ebp]
	movss	xmm0, DWORD PTR __real@40a00000
	divss	xmm0, DWORD PTR tv505[ebp]
	mulss	xmm0, DWORD PTR _nycmd$[ebp]
	movss	DWORD PTR _nycmd$[ebp], xmm0
$LN11@Yaw:

; 113  : 
; 114  :    limiter = gLimiterMgr->GetLimiter(PitchYawControlDamper,vehicleIndex);

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+92]
	push	ecx
	push	10					; 0000000aH
	mov	ecx, DWORD PTR ?gLimiterMgr@@3PAVLimiterMgrClass@@A ; gLimiterMgr
	call	?GetLimiter@LimiterMgrClass@@QAEPAVLimiter@@HH@Z ; LimiterMgrClass::GetLimiter
	mov	DWORD PTR _limiter$[ebp], eax

; 115  :    if(limiter)

	cmp	DWORD PTR _limiter$[ebp], 0
	je	SHORT $LN10@Yaw

; 116  : 	   nycmd *= limiter->Limit((350.0F - vcas)*0.2F);

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@43af0000
	subss	xmm0, DWORD PTR [edx+1124]
	mulss	xmm0, DWORD PTR __real@3e4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _limiter$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _limiter$[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	fstp	DWORD PTR tv518[ebp]
	movss	xmm0, DWORD PTR tv518[ebp]
	mulss	xmm0, DWORD PTR _nycmd$[ebp]
	movss	DWORD PTR _nycmd$[ebp], xmm0
$LN10@Yaw:

; 117  :    //error1 = nycmd + nycgb;
; 118  :    //if(platform->isF16)
; 119  : //		error1 = nycmd + (nycgs + platform->platformAngles.sinmu * platform->platformAngles.cosgam);
; 120  :   // else
; 121  :    if(IsSet(InAir))

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN9@Yaw

; 122  : 		error1 = nycmd + nycgs;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _nycmd$[ebp]
	addss	xmm0, DWORD PTR [ecx+264]
	movss	DWORD PTR _error1$[ebp], xmm0

; 123  :    else

	jmp	SHORT $LN8@Yaw
$LN9@Yaw:

; 124  : 		error1 = (nycmd + nycgs)*0.8F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _nycmd$[ebp]
	addss	xmm0, DWORD PTR [edx+264]
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR _error1$[ebp], xmm0
$LN8@Yaw:

; 125  :    error  = error1*ky05;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _error1$[ebp]
	mulss	xmm0, DWORD PTR [eax+1468]
	movss	DWORD PTR _error$[ebp], xmm0

; 126  :    eprop  = ky02*error;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1456]
	mulss	xmm0, DWORD PTR _error$[ebp]
	movss	DWORD PTR _eprop$[ebp], xmm0

; 127  :    eintg1 = ky03*error;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1460]
	mulss	xmm0, DWORD PTR _error$[ebp]
	movss	DWORD PTR _eintg1$[ebp], xmm0

; 128  :    
; 129  :    //eintg  = Math.FITust(eintg1,SimLibMinorFrameTime,oldy01);
; 130  :    eintg  = Math.FIAdamsBash(eintg1,SimLibMinorFrameTime,oldy01);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 428				; 000001acH
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR ?SimLibMinorFrameTime@@3MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _eintg1$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?FIAdamsBash@SIMLIB_MATH_CLASS@@QAEMMMQAM@Z ; SIMLIB_MATH_CLASS::FIAdamsBash
	fstp	DWORD PTR _eintg$[ebp]

; 131  : 
; 132  : 
; 133  : 
; 134  :    /*--------------*/
; 135  :    /* beta limiter */
; 136  :    /*--------------*/
; 137  :    if (eintg > betmax)

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _eintg$[ebp]
	comiss	xmm0, DWORD PTR [ecx+176]
	jbe	SHORT $LN7@Yaw

; 138  :    {
; 139  :       oldy01[0]    = betmax;

	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+176]
	mov	DWORD PTR [eax+edx+428], ecx

; 140  :       oldy01[1]    = betmax;

	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+176]
	mov	DWORD PTR [eax+edx+428], ecx

; 141  :       oldy01[2]    = 0.0;

	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+edx+428], xmm0

; 142  :       oldy01[3]    = 0.0;

	mov	ecx, 4
	imul	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+ecx+428], xmm0
$LN7@Yaw:

; 143  :    }
; 144  : 
; 145  :    if (eintg < betmin)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+180]
	comiss	xmm0, DWORD PTR _eintg$[ebp]
	jbe	SHORT $LN6@Yaw

; 146  :    {
; 147  :       oldy01[0]    = betmin;

	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+180]
	mov	DWORD PTR [edx+ecx+428], eax

; 148  :       oldy01[1]    = betmin;

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+180]
	mov	DWORD PTR [edx+ecx+428], eax

; 149  :       oldy01[2]    = 0.0;

	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+ecx+428], xmm0

; 150  :       oldy01[3]    = 0.0;

	mov	eax, 4
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+eax+428], xmm0
$LN6@Yaw:

; 151  :    }
; 152  : 
; 153  :    betcmd = max(min(eprop + eintg,betmax),betmin);

	movss	xmm0, DWORD PTR _eprop$[ebp]
	addss	xmm0, DWORD PTR _eintg$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+176]
	comiss	xmm1, xmm0
	jbe	SHORT $LN31@Yaw
	movss	xmm0, DWORD PTR _eprop$[ebp]
	addss	xmm0, DWORD PTR _eintg$[ebp]
	movss	DWORD PTR tv300[ebp], xmm0
	jmp	SHORT $LN32@Yaw
$LN31@Yaw:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+176]
	movss	DWORD PTR tv300[ebp], xmm0
$LN32@Yaw:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv300[ebp]
	comiss	xmm0, DWORD PTR [ecx+180]
	jbe	SHORT $LN35@Yaw
	movss	xmm0, DWORD PTR _eprop$[ebp]
	addss	xmm0, DWORD PTR _eintg$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+176]
	comiss	xmm1, xmm0
	jbe	SHORT $LN33@Yaw
	movss	xmm0, DWORD PTR _eprop$[ebp]
	addss	xmm0, DWORD PTR _eintg$[ebp]
	movss	DWORD PTR tv313[ebp], xmm0
	jmp	SHORT $LN34@Yaw
$LN33@Yaw:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+176]
	movss	DWORD PTR tv313[ebp], xmm0
$LN34@Yaw:
	movss	xmm0, DWORD PTR tv313[ebp]
	movss	DWORD PTR tv316[ebp], xmm0
	jmp	SHORT $LN36@Yaw
$LN35@Yaw:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+180]
	movss	DWORD PTR tv316[ebp], xmm0
$LN36@Yaw:
	movss	xmm0, DWORD PTR tv316[ebp]
	movss	DWORD PTR _betcmd$[ebp], xmm0

; 154  :    betcmd *= ylsdamp;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _betcmd$[ebp]
	mulss	xmm0, DWORD PTR [edx+684]
	movss	DWORD PTR _betcmd$[ebp], xmm0

; 155  : 
; 156  :    //TJL 01/14/03 Multi-engine asymmetric thrust yaw
; 157  :    if (auxaeroData->nEngines == 2)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+344], 2
	jne	$LN2@Yaw

; 158  :    {
; 159  : 	   float asymmYaw = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _asymmYaw$1[ebp], xmm0

; 160  : 	   float asymmYpedal = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _asymmYpedal$2[ebp], xmm0

; 161  : 	   float engine1 = thrust1;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+192]
	movss	DWORD PTR _engine1$4[ebp], xmm0

; 162  : 	   float engine2 = thrust2;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+212]
	movss	DWORD PTR _engine2$3[ebp], xmm0

; 163  : 	   if (engine1 < 0.0f)

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _engine1$4[ebp]
	jbe	SHORT $LN4@Yaw

; 164  : 		   engine1 = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _engine1$4[ebp], xmm0
$LN4@Yaw:

; 165  : 	   if (engine2 < 0.0f)

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _engine2$3[ebp]
	jbe	SHORT $LN3@Yaw

; 166  : 		   engine2 = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _engine2$3[ebp], xmm0
$LN3@Yaw:

; 167  : 	   //asymmYaw = (float)Abs(thrust1 - thrust2);
; 168  : 	
; 169  : 		asymmYaw = (engine2 - engine1)*1.5f;

	movss	xmm0, DWORD PTR _engine2$3[ebp]
	subss	xmm0, DWORD PTR _engine1$4[ebp]
	mulss	xmm0, DWORD PTR __real@3fc00000
	movss	DWORD PTR _asymmYaw$1[ebp], xmm0

; 170  : 		betcmd = (betcmd + asymmYaw);

	movss	xmm0, DWORD PTR _betcmd$[ebp]
	addss	xmm0, DWORD PTR _asymmYaw$1[ebp]
	movss	DWORD PTR _betcmd$[ebp], xmm0

; 171  : 		asymmYpedal = (engine2 - engine1)*0.08f;

	movss	xmm0, DWORD PTR _engine2$3[ebp]
	subss	xmm0, DWORD PTR _engine1$4[ebp]
	mulss	xmm0, DWORD PTR __real@3da3d70a
	movss	DWORD PTR _asymmYpedal$2[ebp], xmm0

; 172  : 
; 173  : 		if ((float)fabs(asymmYpedal + ypedal) <= 1.0f)

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _asymmYpedal$2[ebp]
	addss	xmm0, DWORD PTR [ecx+1508]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv605[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR tv605[ebp]
	jb	SHORT $LN2@Yaw

; 174  : 			{
; 175  : 				ypedal = asymmYpedal + ypedal;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _asymmYpedal$2[ebp]
	addss	xmm0, DWORD PTR [edx+1508]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+1508], xmm0

; 176  : 				yshape = ypedal * ypedal; 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1508]
	mulss	xmm0, DWORD PTR [edx+1508]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+664], xmm0
$LN2@Yaw:

; 177  : 			}
; 178  : 
; 179  :    }
; 180  : 
; 181  : 
; 182  :    YawIt(betcmd, SimLibMinorFrameTime);

	push	ecx
	movss	xmm0, DWORD PTR ?SimLibMinorFrameTime@@3MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _betcmd$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?YawIt@AirframeClass@@QAEXMM@Z		; AirframeClass::YawIt

; 183  : 
; 184  :    if(!IsSet(InAir))

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	jne	$LN1@Yaw

; 185  :    {
; 186  : 	   oldy03[0] *= 0.8F;

	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+452]
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+eax+452], xmm0

; 187  : 	   oldy03[1] *= 0.8F;

	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+452]
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+ecx+452], xmm0

; 188  : 	   oldy03[2] *= 0.8F;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+452]
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+edx+452], xmm0

; 189  : 	   oldy03[3] *= 0.8F;

	mov	ecx, 4
	imul	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+452]
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	mov	eax, 4
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+eax+452], xmm0

; 190  : 	   beta *= 0.8F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1156]
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+1156], xmm0
$LN1@Yaw:
$LN21@Yaw:

; 191  :    }
; 192  : 
; 193  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Yaw@AirframeClass@@AAEXXZ ENDP				; AirframeClass::Yaw
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?fabs@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?fabs@@YAMM@Z PROC					; fabs, COMDAT

; 517  :         {return (fabsf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_fabsf
	add	esp, 4
	pop	ebp
	ret	0
?fabs@@YAMM@Z ENDP					; fabs
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_fabsf	PROC						; COMDAT

; 392  :         {return ((float)fabs((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_fabsf	ENDP
_TEXT	ENDS
END
