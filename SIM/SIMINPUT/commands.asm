; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\SIM\SIMINPUT\commands.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?ShowFrameRate@@3HA				; ShowFrameRate
PUBLIC	?testFlag@@3HA					; testFlag
PUBLIC	?narrowFOV@@3HA					; narrowFOV
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?keyboardPickleOverride@@3HA			; keyboardPickleOverride
PUBLIC	?keyboardTriggerOverride@@3HA			; keyboardTriggerOverride
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?throttleOffsetRate@@3MA			; throttleOffsetRate
PUBLIC	?throttleOffset@@3MA				; throttleOffset
PUBLIC	?rudderOffset@@3MA				; rudderOffset
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?rudderOffsetRate@@3MA				; rudderOffsetRate
PUBLIC	?pitchStickOffset@@3MA				; pitchStickOffset
PUBLIC	?rollStickOffset@@3MA				; rollStickOffset
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?pitchStickOffsetRate@@3MA			; pitchStickOffsetRate
PUBLIC	?rollStickOffsetRate@@3MA			; rollStickOffsetRate
PUBLIC	?pitchRudderTrimRate@@3MA			; pitchRudderTrimRate
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?pitchAileronTrimRate@@3MA			; pitchAileronTrimRate
PUBLIC	?pitchElevatorTrimRate@@3MA			; pitchElevatorTrimRate
PUBLIC	?pitchManualTrim@@3MA				; pitchManualTrim
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?yawManualTrim@@3MA				; yawManualTrim
PUBLIC	?rollManualTrim@@3MA				; rollManualTrim
PUBLIC	?UseKeyboardThrottle@@3HA			; UseKeyboardThrottle
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?gDoOwnshipSmoke@@3HA				; gDoOwnshipSmoke
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?VtuneNoop@@YAHXZ				; VtuneNoop
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?doVtune@@3HA					; doVtune
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?pauseFn@@3P6AHXZA				; pauseFn
PUBLIC	?resumeFn@@3P6AHXZA				; resumeFn
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hlib@@3PAUHINSTANCE__@@A			; hlib
PUBLIC	?lTestFlag1@@3HA				; lTestFlag1
PUBLIC	?lTestFlag2@@3HA				; lTestFlag2
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B ; std::ios_base::failure::_Stream_err
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
_BSS	SEGMENT
?ShowFrameRate@@3HA DD 01H DUP (?)			; ShowFrameRate
?testFlag@@3HA DD 01H DUP (?)				; testFlag
?narrowFOV@@3HA DD 01H DUP (?)				; narrowFOV
?keyboardPickleOverride@@3HA DD 01H DUP (?)		; keyboardPickleOverride
?keyboardTriggerOverride@@3HA DD 01H DUP (?)		; keyboardTriggerOverride
?throttleOffsetRate@@3MA DD 01H DUP (?)			; throttleOffsetRate
?throttleOffset@@3MA DD 01H DUP (?)			; throttleOffset
?rudderOffset@@3MA DD 01H DUP (?)			; rudderOffset
?rudderOffsetRate@@3MA DD 01H DUP (?)			; rudderOffsetRate
?pitchStickOffset@@3MA DD 01H DUP (?)			; pitchStickOffset
?rollStickOffset@@3MA DD 01H DUP (?)			; rollStickOffset
?pitchStickOffsetRate@@3MA DD 01H DUP (?)		; pitchStickOffsetRate
?rollStickOffsetRate@@3MA DD 01H DUP (?)		; rollStickOffsetRate
?pitchRudderTrimRate@@3MA DD 01H DUP (?)		; pitchRudderTrimRate
?pitchAileronTrimRate@@3MA DD 01H DUP (?)		; pitchAileronTrimRate
?pitchElevatorTrimRate@@3MA DD 01H DUP (?)		; pitchElevatorTrimRate
?pitchManualTrim@@3MA DD 01H DUP (?)			; pitchManualTrim
?yawManualTrim@@3MA DD 01H DUP (?)			; yawManualTrim
?rollManualTrim@@3MA DD 01H DUP (?)			; rollManualTrim
?UseKeyboardThrottle@@3HA DD 01H DUP (?)		; UseKeyboardThrottle
?gDoOwnshipSmoke@@3HA DD 01H DUP (?)			; gDoOwnshipSmoke
?doVtune@@3HA DD 01H DUP (?)				; doVtune
?hlib@@3PAUHINSTANCE__@@A DD 01H DUP (?)		; hlib
?lTestFlag1@@3HA DD 01H DUP (?)				; lTestFlag1
?lTestFlag2@@3HA DD 01H DUP (?)				; lTestFlag2
_BSS	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B
CONST	SEGMENT
?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B DD 01H ; std::ios_base::failure::_Stream_err
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
_NEAR_CLIP DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
_DATA	SEGMENT
_theFault DD	01H
?pauseFn@@3P6AHXZA DD FLAT:?VtuneNoop@@YAHXZ		; pauseFn
?resumeFn@@3P6AHXZA DD FLAT:?VtuneNoop@@YAHXZ		; resumeFn
_matrix33_ident DD 03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
_matrix44_ident DD 03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
_cloudPntList DD 0c5bcc000r			; -6040
	DD	0c4070000r			; -540
	DD	0c694ac00r			; -19030
	DD	0c6de1c00r			; -28430
	DD	0c4dfc000r			; -1790
	DD	046dcc800r			; 28260
	DD	047104200r			; 36930
	DD	045732000r			; 3890
	DD	04744ea00r			; 50410
	DD	045336000r			; 2870
	DD	0c4d48000r			; -1700
	DD	04736da00r			; 46810
	DD	0c763ee00r			; -58350
	DD	0c4d48000r			; -1700
	DD	0c64c1000r			; -13060
	DD	046f2bc00r			; 31070
	DD	045480000r			; 3200
	DD	0c7293800r			; -43320
	DD	0c7bdc400r			; -97160
	DD	0c4d48000r			; -1700
	DD	04576e000r			; 3950
	DD	0c792e000r			; -75200
	DD	0c4bb8000r			; -1500
	DD	047957400r			; 76520
	DD	04759ee00r			; 55790
	DD	0c5a1e000r			; -5180
	DD	0c7a24e00r			; -83100
	DD	0c7473800r			; -51000
	DD	0c3a00000r			; -320
	DD	0c7829100r			; -66850
	DD	047733400r			; 62260
	DD	0c3a00000r			; -320
	DD	047708200r			; 61570
	DD	0c7710e00r			; -61710
	DD	0c550c000r			; -3340
	DD	046fb7c00r			; 32190
	DD	0c7719a00r			; -61850
	DD	0c7483200r			; -51250
	DD	047543a00r			; 54330
	DD	0c5bcc000r			; -6040
	DD	0c7495400r			; -51540
	DD	0c694ac00r			; -19030
	DD	0c6a7a800r			; -21460
	DD	0c74b0200r			; -51970
	DD	0468e8000r			; 18240
	DD	047298800r			; 43400
	DD	0c74bf200r			; -52210
	DD	046bc7000r			; 24120
	DD	0c749f400r			; -51700
	DD	0c74bc000r			; -52160
	DD	046948400r			; 19010
	DD	0c605e800r			; -8570
	DD	0c7488200r			; -51330
	DD	0c74ca600r			; -52390
	DD	04731bc00r			; 45500
	DD	0c7509800r			; -53400
	DD	0c6725800r			; -15510
	DD	0c7719a00r			; -61850
	DD	0c7483200r			; -51250
	DD	047543a00r			; 54330
	DD	047553400r			; 54580
	DD	0c74ddc00r			; -52700
	DD	0479a5600r			; 79020
	DD	047a7e400r			; 85960
	DD	0c74c5600r			; -52310
	DD	0477d4800r			; 64840
	DD	0c7c44500r			; -100490
	DD	0c74d1400r			; -52500
	DD	047ac2600r			; 88140
	DD	0c7a1ae00r			; -82780
	DD	0c749ea00r			; -51690
	DD	0c7bce300r			; -96710
	DD	0c6126800r			; -9370
	DD	0c7495400r			; -51540
	DD	043cd0000r			; 410
	DD	0c6a7a800r			; -21460
	DD	0c74a8a00r			; -51850
	DD	0473fae00r			; 49070
	DD	0457c8000r			; 4040
	DD	0c74e4a00r			; -52810
	DD	047871e00r			; 69180
	DD	0c6cbc000r			; -26080
	DD	0c74bc000r			; -52160
	DD	046984400r			; 19490
	DD	0452fa000r			; 2810
	DD	0c7488200r			; -51330
	DD	0c7081800r			; -34840
	DD	0c7719a00r			; -61850
	DD	0c749d600r			; -51670
	DD	047b17600r			; 90860
	DD	047553400r			; 54580
	DD	0c74ddc00r			; -52700
	DD	0479a5600r			; 79020
	DD	047a7e400r			; 85960
	DD	0c74c5600r			; -52310
	DD	0477d4800r			; 64840
	DD	0c7c44500r			; -100490
	DD	0c74d1400r			; -52500
	DD	047ac2600r			; 88140
	DD	047c04e00r			; 98460
	DD	0c74d1400r			; -52500
	DD	0c732a200r			; -45730
	DD	0467b9000r			; 16100
	DD	0c7487800r			; -51320
	DD	0c749a400r			; -51620
	DD	047636c00r			; 58220
	DD	0c74e0400r			; -52740
	DD	0c760b000r			; -57520
	DD	0c6126800r			; -9370
	DD	0c4070000r			; -540
	DD	043cd0000r			; 410
	DD	0c4e60000r			; -1840
	DD	0c6a30c00r			; -20870
	DD	0470a6600r			; 35430
	DD	0c7230c00r			; -41740
	DD	046924000r			; 18720
	DD	04797d600r			; 77740
	DD	0460d9000r			; 9060
	DD	0c616c800r			; -9650
	DD	0c7921300r			; -74790
_lightningPosList DD 041300000r			; 11
	DD	000000000r			; 0
	DD	040e00000r			; 7
	DD	040a00000r			; 5
	DD	041100000r			; 9
	DD	041000000r			; 8
	DD	041000000r			; 8
	DD	041600000r			; 14
	DD	041800000r			; 16
	DD	041a00000r			; 20
	DD	041200000r			; 10
	DD	041c00000r			; 24
	DD	041300000r			; 11
	DD	041d80000r			; 27
	DD	040c00000r			; 6
	DD	041f00000r			; 30
	DD	040e00000r			; 7
	DD	042040000r			; 33
	DD	03f800000r			; 1
	DD	042180000r			; 38
	DD	040a00000r			; 5
	DD	042280000r			; 42
	DD	040a00000r			; 5
	DD	042340000r			; 45
	DD	041400000r			; 12
	DD	042400000r			; 48
	DD	041a00000r			; 20
	DD	042500000r			; 52
	DD	041a00000r			; 20
	DD	042680000r			; 58
	DD	041b80000r			; 23
	DD	042740000r			; 61
	DD	041b00000r			; 22
	DD	0427c0000r			; 63
	DD	041b00000r			; 22
	DD	042840000r			; 66
	DD	041c80000r			; 25
	DD	042880000r			; 68
	DD	041a00000r			; 20
	DD	0428c0000r			; 70
	DD	041c00000r			; 24
	DD	042960000r			; 75
	DD	041c00000r			; 24
	DD	0429a0000r			; 77
	DD	041f80000r			; 31
	DD	042a00000r			; 80
	DD	041f80000r			; 31
	DD	042a60000r			; 83
	DD	042040000r			; 33
	DD	042b00000r			; 88
	DD	041f80000r			; 31
	DD	042b80000r			; 92
	DD	0423c0000r			; 47
	DD	042ce0000r			; 103
	DD	042380000r			; 46
	DD	042d20000r			; 105
	DD	0423c0000r			; 47
	DD	042d60000r			; 107
	DD	042340000r			; 45
	DD	042e00000r			; 112
	DD	042400000r			; 48
	DD	042e40000r			; 114
	DD	042380000r			; 46
	DD	042ea0000r			; 117
	DD	0422c0000r			; 43
	DD	043000000r			; 128
_DATA	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
PUBLIC	_fabsf
PUBLIC	?fabs@@YAMM@Z					; fabs
PUBLIC	?Id@VuEntity@@QBE?AVVU_ID@@XZ			; VuEntity::Id
PUBLIC	?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ	; VuEntity::EntityType
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ		; VuBin<VuSessionEntity>::operator bool
PUBLIC	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
PUBLIC	?SetFalcFlag@FalconEntity@@QAEXH@Z		; FalconEntity::SetFalcFlag
PUBLIC	?UnSetFalcFlag@FalconEntity@@QAEXH@Z		; FalconEntity::UnSetFalcFlag
PUBLIC	?SimSetBubbleSize@@YAXKHPAX@Z			; SimSetBubbleSize
PUBLIC	?SimHookToggle@@YAXKHPAX@Z			; SimHookToggle
PUBLIC	?SimHookUp@@YAXKHPAX@Z				; SimHookUp
PUBLIC	?SimHookDown@@YAXKHPAX@Z			; SimHookDown
PUBLIC	?SimThrottleIdleDetent@@YAXKHPAX@Z		; SimThrottleIdleDetent
PUBLIC	?SimJfsStart@@YAXKHPAX@Z			; SimJfsStart
PUBLIC	?SimEpuToggle@@YAXKHPAX@Z			; SimEpuToggle
PUBLIC	?SimEpuOff@@YAXKHPAX@Z				; SimEpuOff
PUBLIC	?SimEpuAuto@@YAXKHPAX@Z				; SimEpuAuto
PUBLIC	?SimEpuOn@@YAXKHPAX@Z				; SimEpuOn
PUBLIC	?AFRudderTrimLeft@@YAXKHPAX@Z			; AFRudderTrimLeft
PUBLIC	?AFRudderTrimRight@@YAXKHPAX@Z			; AFRudderTrimRight
PUBLIC	?AFAileronTrimLeft@@YAXKHPAX@Z			; AFAileronTrimLeft
PUBLIC	?AFAileronTrimRight@@YAXKHPAX@Z			; AFAileronTrimRight
PUBLIC	?AFElevatorTrimUp@@YAXKHPAX@Z			; AFElevatorTrimUp
PUBLIC	?AFElevatorTrimDown@@YAXKHPAX@Z			; AFElevatorTrimDown
PUBLIC	?AFResetTrim@@YAXKHPAX@Z			; AFResetTrim
PUBLIC	?AFAlternateGear@@YAXKHPAX@Z			; AFAlternateGear
PUBLIC	?AFAlternateGearReset@@YAXKHPAX@Z		; AFAlternateGearReset
PUBLIC	?SimFLIRToggle@@YAXKHPAX@Z			; SimFLIRToggle
PUBLIC	?SimToggleRealisticAvionics@@YAXKHPAX@Z		; SimToggleRealisticAvionics
PUBLIC	?SimIncFuelSwitch@@YAXKHPAX@Z			; SimIncFuelSwitch
PUBLIC	?SimDecFuelSwitch@@YAXKHPAX@Z			; SimDecFuelSwitch
PUBLIC	?SimFuelSwitchTest@@YAXKHPAX@Z			; SimFuelSwitchTest
PUBLIC	?SimFuelSwitchNorm@@YAXKHPAX@Z			; SimFuelSwitchNorm
PUBLIC	?SimFuelSwitchResv@@YAXKHPAX@Z			; SimFuelSwitchResv
PUBLIC	?SimFuelSwitchWingInt@@YAXKHPAX@Z		; SimFuelSwitchWingInt
PUBLIC	?SimFuelSwitchWingExt@@YAXKHPAX@Z		; SimFuelSwitchWingExt
PUBLIC	?SimFuelSwitchCenterExt@@YAXKHPAX@Z		; SimFuelSwitchCenterExt
PUBLIC	?SimIncFuelPump@@YAXKHPAX@Z			; SimIncFuelPump
PUBLIC	?SimDecFuelPump@@YAXKHPAX@Z			; SimDecFuelPump
PUBLIC	?SimFuelPumpOff@@YAXKHPAX@Z			; SimFuelPumpOff
PUBLIC	?SimFuelPumpNorm@@YAXKHPAX@Z			; SimFuelPumpNorm
PUBLIC	?SimFuelPumpAft@@YAXKHPAX@Z			; SimFuelPumpAft
PUBLIC	?SimFuelPumpFwd@@YAXKHPAX@Z			; SimFuelPumpFwd
PUBLIC	?SimToggleMasterFuel@@YAXKHPAX@Z		; SimToggleMasterFuel
PUBLIC	?SimMasterFuelOn@@YAXKHPAX@Z			; SimMasterFuelOn
PUBLIC	?SimMasterFuelOff@@YAXKHPAX@Z			; SimMasterFuelOff
PUBLIC	?SimIncAirSource@@YAXKHPAX@Z			; SimIncAirSource
PUBLIC	?SimDecAirSource@@YAXKHPAX@Z			; SimDecAirSource
PUBLIC	?SimAirSourceOff@@YAXKHPAX@Z			; SimAirSourceOff
PUBLIC	?SimAirSourceNorm@@YAXKHPAX@Z			; SimAirSourceNorm
PUBLIC	?SimAirSourceDump@@YAXKHPAX@Z			; SimAirSourceDump
PUBLIC	?SimAirSourceRam@@YAXKHPAX@Z			; SimAirSourceRam
PUBLIC	?SimDecLeftAuxComDigit@@YAXKHPAX@Z		; SimDecLeftAuxComDigit
PUBLIC	?SimDecCenterAuxComDigit@@YAXKHPAX@Z		; SimDecCenterAuxComDigit
PUBLIC	?SimDecRightAuxComDigit@@YAXKHPAX@Z		; SimDecRightAuxComDigit
PUBLIC	?SimInteriorLight@@YAXKHPAX@Z			; SimInteriorLight
PUBLIC	?SimInstrumentLight@@YAXKHPAX@Z			; SimInstrumentLight
PUBLIC	?SimSpotLight@@YAXKHPAX@Z			; SimSpotLight
PUBLIC	?SimToggleTFR@@YAXKHPAX@Z			; SimToggleTFR
PUBLIC	?SimMainPowerDec@@YAXKHPAX@Z			; SimMainPowerDec
PUBLIC	?SimMainPowerInc@@YAXKHPAX@Z			; SimMainPowerInc
PUBLIC	?SimMainPowerOff@@YAXKHPAX@Z			; SimMainPowerOff
PUBLIC	?SimMainPowerBatt@@YAXKHPAX@Z			; SimMainPowerBatt
PUBLIC	?SimMainPowerMain@@YAXKHPAX@Z			; SimMainPowerMain
PUBLIC	?AFFullFlap@@YAXKHPAX@Z				; AFFullFlap
PUBLIC	?AFNoFlap@@YAXKHPAX@Z				; AFNoFlap
PUBLIC	?AFIncFlap@@YAXKHPAX@Z				; AFIncFlap
PUBLIC	?AFDecFlap@@YAXKHPAX@Z				; AFDecFlap
PUBLIC	?AFFullLEF@@YAXKHPAX@Z				; AFFullLEF
PUBLIC	?AFNoLEF@@YAXKHPAX@Z				; AFNoLEF
PUBLIC	?AFIncLEF@@YAXKHPAX@Z				; AFIncLEF
PUBLIC	?AFDecLEF@@YAXKHPAX@Z				; AFDecLEF
PUBLIC	?AFDragChute@@YAXKHPAX@Z			; AFDragChute
PUBLIC	?AFCanopyToggle@@YAXKHPAX@Z			; AFCanopyToggle
PUBLIC	?SimReverseThrusterOn@@YAXKHPAX@Z		; SimReverseThrusterOn
PUBLIC	?SimReverseThrusterOff@@YAXKHPAX@Z		; SimReverseThrusterOff
PUBLIC	?SimReverseThrusterToggle@@YAXKHPAX@Z		; SimReverseThrusterToggle
PUBLIC	?SimExtFuelTrans@@YAXKHPAX@Z			; SimExtFuelTrans
PUBLIC	?SimFuelTransNorm@@YAXKHPAX@Z			; SimFuelTransNorm
PUBLIC	?SimFuelTransWing@@YAXKHPAX@Z			; SimFuelTransWing
PUBLIC	?SimICPIFF@@YAXKHPAX@Z				; SimICPIFF
PUBLIC	?SimICPLIST@@YAXKHPAX@Z				; SimICPLIST
PUBLIC	?SimICPTHREE@@YAXKHPAX@Z			; SimICPTHREE
PUBLIC	?SimICPSIX@@YAXKHPAX@Z				; SimICPSIX
PUBLIC	?SimICPEIGHT@@YAXKHPAX@Z			; SimICPEIGHT
PUBLIC	?SimICPNINE@@YAXKHPAX@Z				; SimICPNINE
PUBLIC	?SimICPZERO@@YAXKHPAX@Z				; SimICPZERO
PUBLIC	?SimICPNav1@@YAXKHPAX@Z				; SimICPNav1
PUBLIC	?SimICPAA1@@YAXKHPAX@Z				; SimICPAA1
PUBLIC	?SimICPAG1@@YAXKHPAX@Z				; SimICPAG1
PUBLIC	?SimICPResetDED@@YAXKHPAX@Z			; SimICPResetDED
PUBLIC	?SimICPDEDUP@@YAXKHPAX@Z			; SimICPDEDUP
PUBLIC	?SimICPDEDDOWN@@YAXKHPAX@Z			; SimICPDEDDOWN
PUBLIC	?SimICPCLEAR@@YAXKHPAX@Z			; SimICPCLEAR
PUBLIC	?SimICPDEDSEQ@@YAXKHPAX@Z			; SimICPDEDSEQ
PUBLIC	?SimRALTSTDBY@@YAXKHPAX@Z			; SimRALTSTDBY
PUBLIC	?SimRALTON@@YAXKHPAX@Z				; SimRALTON
PUBLIC	?SimRALTOFF@@YAXKHPAX@Z				; SimRALTOFF
PUBLIC	?SimLandingLightToggle@@YAXKHPAX@Z		; SimLandingLightToggle
PUBLIC	?SimLandingLightOn@@YAXKHPAX@Z			; SimLandingLightOn
PUBLIC	?SimLandingLightOff@@YAXKHPAX@Z			; SimLandingLightOff
PUBLIC	?SimParkingBrakeToggle@@YAXKHPAX@Z		; SimParkingBrakeToggle
PUBLIC	?SimParkingBrakeOn@@YAXKHPAX@Z			; SimParkingBrakeOn
PUBLIC	?SimParkingBrakeOff@@YAXKHPAX@Z			; SimParkingBrakeOff
PUBLIC	?SimLaserArmToggle@@YAXKHPAX@Z			; SimLaserArmToggle
PUBLIC	?SimLaserArmOn@@YAXKHPAX@Z			; SimLaserArmOn
PUBLIC	?SimLaserArmOff@@YAXKHPAX@Z			; SimLaserArmOff
PUBLIC	?SimFuelDoorToggle@@YAXKHPAX@Z			; SimFuelDoorToggle
PUBLIC	?SimFuelDoorOpen@@YAXKHPAX@Z			; SimFuelDoorOpen
PUBLIC	?SimFuelDoorClose@@YAXKHPAX@Z			; SimFuelDoorClose
PUBLIC	?SimRightAPSwitch@@YAXKHPAX@Z			; SimRightAPSwitch
PUBLIC	?SimLeftAPSwitch@@YAXKHPAX@Z			; SimLeftAPSwitch
PUBLIC	?SimRightAPUp@@YAXKHPAX@Z			; SimRightAPUp
PUBLIC	?SimRightAPMid@@YAXKHPAX@Z			; SimRightAPMid
PUBLIC	?SimRightAPDown@@YAXKHPAX@Z			; SimRightAPDown
PUBLIC	?SimLeftAPUp@@YAXKHPAX@Z			; SimLeftAPUp
PUBLIC	?SimLeftAPMid@@YAXKHPAX@Z			; SimLeftAPMid
PUBLIC	?SimLeftAPDown@@YAXKHPAX@Z			; SimLeftAPDown
PUBLIC	?SimAPOverride@@YAXKHPAX@Z			; SimAPOverride
PUBLIC	?SimWarnReset@@YAXKHPAX@Z			; SimWarnReset
PUBLIC	?SimReticleSwitch@@YAXKHPAX@Z			; SimReticleSwitch
PUBLIC	?SimReticlePri@@YAXKHPAX@Z			; SimReticlePri
PUBLIC	?SimReticleStby@@YAXKHPAX@Z			; SimReticleStby
PUBLIC	?SimReticleOff@@YAXKHPAX@Z			; SimReticleOff
PUBLIC	?SimTMSUp@@YAXKHPAX@Z				; SimTMSUp
PUBLIC	?SimTMSLeft@@YAXKHPAX@Z				; SimTMSLeft
PUBLIC	?SimTMSDown@@YAXKHPAX@Z				; SimTMSDown
PUBLIC	?SimTMSRight@@YAXKHPAX@Z			; SimTMSRight
PUBLIC	?SimSeatArm@@YAXKHPAX@Z				; SimSeatArm
PUBLIC	?SimSeatOn@@YAXKHPAX@Z				; SimSeatOn
PUBLIC	?SimSeatOff@@YAXKHPAX@Z				; SimSeatOff
PUBLIC	?SimEWSRWRPower@@YAXKHPAX@Z			; SimEWSRWRPower
PUBLIC	?SimEWSRWROn@@YAXKHPAX@Z			; SimEWSRWROn
PUBLIC	?SimEWSRWROff@@YAXKHPAX@Z			; SimEWSRWROff
PUBLIC	?SimEWSJammerPower@@YAXKHPAX@Z			; SimEWSJammerPower
PUBLIC	?SimEWSJammerOn@@YAXKHPAX@Z			; SimEWSJammerOn
PUBLIC	?SimEWSJammerOff@@YAXKHPAX@Z			; SimEWSJammerOff
PUBLIC	?SimEWSChaffPower@@YAXKHPAX@Z			; SimEWSChaffPower
PUBLIC	?SimEWSChaffOn@@YAXKHPAX@Z			; SimEWSChaffOn
PUBLIC	?SimEWSChaffOff@@YAXKHPAX@Z			; SimEWSChaffOff
PUBLIC	?SimEWSFlarePower@@YAXKHPAX@Z			; SimEWSFlarePower
PUBLIC	?SimEWSFlareOn@@YAXKHPAX@Z			; SimEWSFlareOn
PUBLIC	?SimEWSFlareOff@@YAXKHPAX@Z			; SimEWSFlareOff
PUBLIC	?SimEWSPGMDec@@YAXKHPAX@Z			; SimEWSPGMDec
PUBLIC	?SimEWSPGMInc@@YAXKHPAX@Z			; SimEWSPGMInc
PUBLIC	?SimEWSModeOff@@YAXKHPAX@Z			; SimEWSModeOff
PUBLIC	?SimEWSModeStby@@YAXKHPAX@Z			; SimEWSModeStby
PUBLIC	?SimEWSModeMan@@YAXKHPAX@Z			; SimEWSModeMan
PUBLIC	?SimEWSModeSemi@@YAXKHPAX@Z			; SimEWSModeSemi
PUBLIC	?SimEWSModeAuto@@YAXKHPAX@Z			; SimEWSModeAuto
PUBLIC	?SimEWSProgDec@@YAXKHPAX@Z			; SimEWSProgDec
PUBLIC	?SimEWSProgInc@@YAXKHPAX@Z			; SimEWSProgInc
PUBLIC	?SimEWSProgOne@@YAXKHPAX@Z			; SimEWSProgOne
PUBLIC	?SimEWSProgTwo@@YAXKHPAX@Z			; SimEWSProgTwo
PUBLIC	?SimEWSProgThree@@YAXKHPAX@Z			; SimEWSProgThree
PUBLIC	?SimEWSProgFour@@YAXKHPAX@Z			; SimEWSProgFour
PUBLIC	?SimInhibitVMS@@YAXKHPAX@Z			; SimInhibitVMS
PUBLIC	?SimVMSOn@@YAXKHPAX@Z				; SimVMSOn
PUBLIC	?SimVMSOff@@YAXKHPAX@Z				; SimVMSOff
PUBLIC	?SimRFSwitch@@YAXKHPAX@Z			; SimRFSwitch
PUBLIC	?SimRFNorm@@YAXKHPAX@Z				; SimRFNorm
PUBLIC	?SimRFQuiet@@YAXKHPAX@Z				; SimRFQuiet
PUBLIC	?SimRFSilent@@YAXKHPAX@Z			; SimRFSilent
PUBLIC	?SimDropProgrammed@@YAXKHPAX@Z			; SimDropProgrammed
PUBLIC	?SimPinkySwitch@@YAXKHPAX@Z			; SimPinkySwitch
PUBLIC	?SimGndJettEnable@@YAXKHPAX@Z			; SimGndJettEnable
PUBLIC	?SimGndJettOn@@YAXKHPAX@Z			; SimGndJettOn
PUBLIC	?SimGndJettOff@@YAXKHPAX@Z			; SimGndJettOff
PUBLIC	?SimExtlPower@@YAXKHPAX@Z			; SimExtlPower
PUBLIC	?SimExtlMasterNorm@@YAXKHPAX@Z			; SimExtlMasterNorm
PUBLIC	?SimExtlMasterOff@@YAXKHPAX@Z			; SimExtlMasterOff
PUBLIC	?SimExtlAntiColl@@YAXKHPAX@Z			; SimExtlAntiColl
PUBLIC	?SimAntiCollOn@@YAXKHPAX@Z			; SimAntiCollOn
PUBLIC	?SimAntiCollOff@@YAXKHPAX@Z			; SimAntiCollOff
PUBLIC	?SimExtlSteady@@YAXKHPAX@Z			; SimExtlSteady
PUBLIC	?SimLightsSteady@@YAXKHPAX@Z			; SimLightsSteady
PUBLIC	?SimLightsFlash@@YAXKHPAX@Z			; SimLightsFlash
PUBLIC	?SimExtlWing@@YAXKHPAX@Z			; SimExtlWing
PUBLIC	?SimWingLightBrt@@YAXKHPAX@Z			; SimWingLightBrt
PUBLIC	?SimWingLightOff@@YAXKHPAX@Z			; SimWingLightOff
PUBLIC	?SimDMSUp@@YAXKHPAX@Z				; SimDMSUp
PUBLIC	?SimDMSLeft@@YAXKHPAX@Z				; SimDMSLeft
PUBLIC	?SimDMSDown@@YAXKHPAX@Z				; SimDMSDown
PUBLIC	?SimDMSRight@@YAXKHPAX@Z			; SimDMSRight
PUBLIC	?SimAVTRSwitch@@YAXKHPAX@Z			; SimAVTRSwitch
PUBLIC	?SimAVTRSwitchOff@@YAXKHPAX@Z			; SimAVTRSwitchOff
PUBLIC	?SimAVTRSwitchAuto@@YAXKHPAX@Z			; SimAVTRSwitchAuto
PUBLIC	?SimAVTRSwitchOn@@YAXKHPAX@Z			; SimAVTRSwitchOn
PUBLIC	?SimAutoAVTR@@YAXKHPAX@Z			; SimAutoAVTR
PUBLIC	?SimIFFPower@@YAXKHPAX@Z			; SimIFFPower
PUBLIC	?SimIFFIn@@YAXKHPAX@Z				; SimIFFIn
PUBLIC	?SimINSInc@@YAXKHPAX@Z				; SimINSInc
PUBLIC	?SimINSDec@@YAXKHPAX@Z				; SimINSDec
PUBLIC	?SimINSOff@@YAXKHPAX@Z				; SimINSOff
PUBLIC	?SimINSNorm@@YAXKHPAX@Z				; SimINSNorm
PUBLIC	?SimINSNav@@YAXKHPAX@Z				; SimINSNav
PUBLIC	?SimINSInFlt@@YAXKHPAX@Z			; SimINSInFlt
PUBLIC	?SimLEFLockSwitch@@YAXKHPAX@Z			; SimLEFLockSwitch
PUBLIC	?SimLEFLock@@YAXKHPAX@Z				; SimLEFLock
PUBLIC	?SimLEFAuto@@YAXKHPAX@Z				; SimLEFAuto
PUBLIC	?SimDigitalBUP@@YAXKHPAX@Z			; SimDigitalBUP
PUBLIC	?SimAltFlaps@@YAXKHPAX@Z			; SimAltFlaps
PUBLIC	?SimAltFlapsNorm@@YAXKHPAX@Z			; SimAltFlapsNorm
PUBLIC	?SimAltFlapsExtend@@YAXKHPAX@Z			; SimAltFlapsExtend
PUBLIC	?SimManualFlyup@@YAXKHPAX@Z			; SimManualFlyup
PUBLIC	?SimFLCSReset@@YAXKHPAX@Z			; SimFLCSReset
PUBLIC	?SimFLTBIT@@YAXKHPAX@Z				; SimFLTBIT
PUBLIC	?SimOBOGSBit@@YAXKHPAX@Z			; SimOBOGSBit
PUBLIC	?SimMalIndLights@@YAXKHPAX@Z			; SimMalIndLights
PUBLIC	?SimProbeHeat@@YAXKHPAX@Z			; SimProbeHeat
PUBLIC	?SimEPUGEN@@YAXKHPAX@Z				; SimEPUGEN
PUBLIC	?SimTestSwitch@@YAXKHPAX@Z			; SimTestSwitch
PUBLIC	?SimOverHeat@@YAXKHPAX@Z			; SimOverHeat
PUBLIC	?SimTrimAPDisc@@YAXKHPAX@Z			; SimTrimAPDisc
PUBLIC	?SimTrimAPDISC@@YAXKHPAX@Z			; SimTrimAPDISC
PUBLIC	?SimTrimAPNORM@@YAXKHPAX@Z			; SimTrimAPNORM
PUBLIC	?SimMaxPower@@YAXKHPAX@Z			; SimMaxPower
PUBLIC	?SimABReset@@YAXKHPAX@Z				; SimABReset
PUBLIC	?SimTrimNoseUp@@YAXKHPAX@Z			; SimTrimNoseUp
PUBLIC	?SimTrimNoseDown@@YAXKHPAX@Z			; SimTrimNoseDown
PUBLIC	?SimTrimYawLeft@@YAXKHPAX@Z			; SimTrimYawLeft
PUBLIC	?SimTrimYawRight@@YAXKHPAX@Z			; SimTrimYawRight
PUBLIC	?SimTrimRollLeft@@YAXKHPAX@Z			; SimTrimRollLeft
PUBLIC	?SimTrimRollRight@@YAXKHPAX@Z			; SimTrimRollRight
PUBLIC	?SimStepMissileVolumeDown@@YAXKHPAX@Z		; SimStepMissileVolumeDown
PUBLIC	?SimStepMissileVolumeUp@@YAXKHPAX@Z		; SimStepMissileVolumeUp
PUBLIC	?SimStepThreatVolumeDown@@YAXKHPAX@Z		; SimStepThreatVolumeDown
PUBLIC	?SimStepThreatVolumeUp@@YAXKHPAX@Z		; SimStepThreatVolumeUp
PUBLIC	?SimTriggerFirstDetent@@YAXKHPAX@Z		; SimTriggerFirstDetent
PUBLIC	?SimTriggerSecondDetent@@YAXKHPAX@Z		; SimTriggerSecondDetent
PUBLIC	?SimRetUp@@YAXKHPAX@Z				; SimRetUp
PUBLIC	?SimRetDn@@YAXKHPAX@Z				; SimRetDn
PUBLIC	?SimCursorEnable@@YAXKHPAX@Z			; SimCursorEnable
PUBLIC	?SimStepComm1VolumeUp@@YAXKHPAX@Z		; SimStepComm1VolumeUp
PUBLIC	?SimStepComm1VolumeDown@@YAXKHPAX@Z		; SimStepComm1VolumeDown
PUBLIC	?SimStepComm2VolumeUp@@YAXKHPAX@Z		; SimStepComm2VolumeUp
PUBLIC	?SimStepComm2VolumeDown@@YAXKHPAX@Z		; SimStepComm2VolumeDown
PUBLIC	?Sim3DCkptHelpOnOff@@YAXKHPAX@Z			; Sim3DCkptHelpOnOff
PUBLIC	?SimSymWheelUp@@YAXKHPAX@Z			; SimSymWheelUp
PUBLIC	?SimSymWheelDn@@YAXKHPAX@Z			; SimSymWheelDn
PUBLIC	?SimToggleCockpit@@YAXKHPAX@Z			; SimToggleCockpit
PUBLIC	?SimToggleGhostMFDs@@YAXKHPAX@Z			; SimToggleGhostMFDs
PUBLIC	?SimRangeKnobDown@@YAXKHPAX@Z			; SimRangeKnobDown
PUBLIC	?SimRangeKnobUp@@YAXKHPAX@Z			; SimRangeKnobUp
PUBLIC	?SimSMSPower@@YAXKHPAX@Z			; SimSMSPower
PUBLIC	?SimSMSOn@@YAXKHPAX@Z				; SimSMSOn
PUBLIC	?SimSMSOff@@YAXKHPAX@Z				; SimSMSOff
PUBLIC	?SimFCCPower@@YAXKHPAX@Z			; SimFCCPower
PUBLIC	?SimFCCOn@@YAXKHPAX@Z				; SimFCCOn
PUBLIC	?SimFCCOff@@YAXKHPAX@Z				; SimFCCOff
PUBLIC	?SimMFDPower@@YAXKHPAX@Z			; SimMFDPower
PUBLIC	?SimMFDOn@@YAXKHPAX@Z				; SimMFDOn
PUBLIC	?SimMFDOff@@YAXKHPAX@Z				; SimMFDOff
PUBLIC	?SimUFCPower@@YAXKHPAX@Z			; SimUFCPower
PUBLIC	?SimUFCOn@@YAXKHPAX@Z				; SimUFCOn
PUBLIC	?SimUFCOff@@YAXKHPAX@Z				; SimUFCOff
PUBLIC	?SimGPSPower@@YAXKHPAX@Z			; SimGPSPower
PUBLIC	?SimGPSOn@@YAXKHPAX@Z				; SimGPSOn
PUBLIC	?SimGPSOff@@YAXKHPAX@Z				; SimGPSOff
PUBLIC	?SimDLPower@@YAXKHPAX@Z				; SimDLPower
PUBLIC	?SimDLOn@@YAXKHPAX@Z				; SimDLOn
PUBLIC	?SimDLOff@@YAXKHPAX@Z				; SimDLOff
PUBLIC	?SimMAPPower@@YAXKHPAX@Z			; SimMAPPower
PUBLIC	?SimMAPOn@@YAXKHPAX@Z				; SimMAPOn
PUBLIC	?SimMAPOff@@YAXKHPAX@Z				; SimMAPOff
PUBLIC	?SimTISLPower@@YAXKHPAX@Z			; SimTISLPower
PUBLIC	?SimRightHptPower@@YAXKHPAX@Z			; SimRightHptPower
PUBLIC	?SimRightHptOn@@YAXKHPAX@Z			; SimRightHptOn
PUBLIC	?SimRightHptOff@@YAXKHPAX@Z			; SimRightHptOff
PUBLIC	?SimLeftHptPower@@YAXKHPAX@Z			; SimLeftHptPower
PUBLIC	?SimLeftHptOn@@YAXKHPAX@Z			; SimLeftHptOn
PUBLIC	?SimLeftHptOff@@YAXKHPAX@Z			; SimLeftHptOff
PUBLIC	?SimFCRPower@@YAXKHPAX@Z			; SimFCRPower
PUBLIC	?SimFCROn@@YAXKHPAX@Z				; SimFCROn
PUBLIC	?SimFCROff@@YAXKHPAX@Z				; SimFCROff
PUBLIC	?SimHUDPower@@YAXKHPAX@Z			; SimHUDPower
PUBLIC	?SimHUDOn@@YAXKHPAX@Z				; SimHUDOn
PUBLIC	?SimHUDOff@@YAXKHPAX@Z				; SimHUDOff
PUBLIC	?SimRwrPower@@YAXKHPAX@Z			; SimRwrPower
PUBLIC	?BreakToggle@@YAXKHPAX@Z			; BreakToggle
PUBLIC	?KneeboardTogglePage@@YAXKHPAX@Z		; KneeboardTogglePage
PUBLIC	?ToggleNVGMode@@YAXKHPAX@Z			; ToggleNVGMode
PUBLIC	?ToggleSmoke@@YAXKHPAX@Z			; ToggleSmoke
PUBLIC	?TimeAccelerate@@YAXKHPAX@Z			; TimeAccelerate
PUBLIC	?TimeAccelerateMaxToggle@@YAXKHPAX@Z		; TimeAccelerateMaxToggle
PUBLIC	?TimeAccelerateInc@@YAXKHPAX@Z			; TimeAccelerateInc
PUBLIC	?TimeAccelerateDec@@YAXKHPAX@Z			; TimeAccelerateDec
PUBLIC	?SimFuelDump@@YAXKHPAX@Z			; SimFuelDump
PUBLIC	?SimCycleDebugLabels@@YAXKHPAX@Z		; SimCycleDebugLabels
PUBLIC	?AFABFull@@YAXKHPAX@Z				; AFABFull
PUBLIC	?BombRippleIncrement@@YAXKHPAX@Z		; BombRippleIncrement
PUBLIC	?BombIntervalIncrement@@YAXKHPAX@Z		; BombIntervalIncrement
PUBLIC	?BombRippleDecrement@@YAXKHPAX@Z		; BombRippleDecrement
PUBLIC	?BombIntervalDecrement@@YAXKHPAX@Z		; BombIntervalDecrement
PUBLIC	?BombPairRelease@@YAXKHPAX@Z			; BombPairRelease
PUBLIC	?BombSGLRelease@@YAXKHPAX@Z			; BombSGLRelease
PUBLIC	?BombBurstIncrement@@YAXKHPAX@Z			; BombBurstIncrement
PUBLIC	?BombBurstDecrement@@YAXKHPAX@Z			; BombBurstDecrement
PUBLIC	?OTWToggleScoreDisplay@@YAXKHPAX@Z		; OTWToggleScoreDisplay
PUBLIC	?OTWToggleSidebar@@YAXKHPAX@Z			; OTWToggleSidebar
PUBLIC	?OTWTrackExternal@@YAXKHPAX@Z			; OTWTrackExternal
PUBLIC	?OTWTrackTargetToWeapon@@YAXKHPAX@Z		; OTWTrackTargetToWeapon
PUBLIC	?SimRadarAAModeStep@@YAXKHPAX@Z			; SimRadarAAModeStep
PUBLIC	?SimRadarAGModeStep@@YAXKHPAX@Z			; SimRadarAGModeStep
PUBLIC	?SimRadarGainUp@@YAXKHPAX@Z			; SimRadarGainUp
PUBLIC	?SimRadarGainDown@@YAXKHPAX@Z			; SimRadarGainDown
PUBLIC	?SimRadarStandby@@YAXKHPAX@Z			; SimRadarStandby
PUBLIC	?SimRadarRangeStepUp@@YAXKHPAX@Z		; SimRadarRangeStepUp
PUBLIC	?SimRadarRangeStepDown@@YAXKHPAX@Z		; SimRadarRangeStepDown
PUBLIC	?SimRadarNextTarget@@YAXKHPAX@Z			; SimRadarNextTarget
PUBLIC	?SimRadarPrevTarget@@YAXKHPAX@Z			; SimRadarPrevTarget
PUBLIC	?SimRadarBarScanChange@@YAXKHPAX@Z		; SimRadarBarScanChange
PUBLIC	?SimRadarAzimuthScanChange@@YAXKHPAX@Z		; SimRadarAzimuthScanChange
PUBLIC	?SimRadarFOVStep@@YAXKHPAX@Z			; SimRadarFOVStep
PUBLIC	?SimMaverickFOVStep@@YAXKHPAX@Z			; SimMaverickFOVStep
PUBLIC	?SimSOIFOVStep@@YAXKHPAX@Z			; SimSOIFOVStep
PUBLIC	?SimRadarFreeze@@YAXKHPAX@Z			; SimRadarFreeze
PUBLIC	?SimRadarSnowplow@@YAXKHPAX@Z			; SimRadarSnowplow
PUBLIC	?SimRadarCursorZero@@YAXKHPAX@Z			; SimRadarCursorZero
PUBLIC	?SimACMBoresight@@YAXKHPAX@Z			; SimACMBoresight
PUBLIC	?SimDesignate@@YAXKHPAX@Z			; SimDesignate
PUBLIC	?SimACMVertical@@YAXKHPAX@Z			; SimACMVertical
PUBLIC	?SimDropTrack@@YAXKHPAX@Z			; SimDropTrack
PUBLIC	?SimACMSlew@@YAXKHPAX@Z				; SimACMSlew
PUBLIC	?SimACM30x20@@YAXKHPAX@Z			; SimACM30x20
PUBLIC	?SimRadarElevationDown@@YAXKHPAX@Z		; SimRadarElevationDown
PUBLIC	?SimRadarElevationUp@@YAXKHPAX@Z		; SimRadarElevationUp
PUBLIC	?SimRadarElevationCenter@@YAXKHPAX@Z		; SimRadarElevationCenter
PUBLIC	?SimRWRSetPriority@@YAXKHPAX@Z			; SimRWRSetPriority
PUBLIC	?SimRWRSetTargetSep@@YAXKHPAX@Z			; SimRWRSetTargetSep
PUBLIC	?SimRWRSetUnknowns@@YAXKHPAX@Z			; SimRWRSetUnknowns
PUBLIC	?SimRWRSetNaval@@YAXKHPAX@Z			; SimRWRSetNaval
PUBLIC	?SimRWRSetGroundPriority@@YAXKHPAX@Z		; SimRWRSetGroundPriority
PUBLIC	?SimRWRSetSearch@@YAXKHPAX@Z			; SimRWRSetSearch
PUBLIC	?SimRWRHandoff@@YAXKHPAX@Z			; SimRWRHandoff
PUBLIC	?SimNextWaypoint@@YAXKHPAX@Z			; SimNextWaypoint
PUBLIC	?SimPrevWaypoint@@YAXKHPAX@Z			; SimPrevWaypoint
PUBLIC	?SimTogglePaused@@YAXKHPAX@Z			; SimTogglePaused
PUBLIC	?SimPickle@@YAXKHPAX@Z				; SimPickle
PUBLIC	?SimTrigger@@YAXKHPAX@Z				; SimTrigger
PUBLIC	?SimMissileStep@@YAXKHPAX@Z			; SimMissileStep
PUBLIC	?SimCursorUp@@YAXKHPAX@Z			; SimCursorUp
PUBLIC	?SimCursorDown@@YAXKHPAX@Z			; SimCursorDown
PUBLIC	?SimCursorLeft@@YAXKHPAX@Z			; SimCursorLeft
PUBLIC	?SimCursorRight@@YAXKHPAX@Z			; SimCursorRight
PUBLIC	?SimToggleAutopilot@@YAXKHPAX@Z			; SimToggleAutopilot
PUBLIC	?SimStepSMSLeft@@YAXKHPAX@Z			; SimStepSMSLeft
PUBLIC	?SimStepSMSRight@@YAXKHPAX@Z			; SimStepSMSRight
PUBLIC	?SimSelectSRMOverride@@YAXKHPAX@Z		; SimSelectSRMOverride
PUBLIC	?SimSelectMRMOverride@@YAXKHPAX@Z		; SimSelectMRMOverride
PUBLIC	?SimDeselectOverride@@YAXKHPAX@Z		; SimDeselectOverride
PUBLIC	?SimToggleMissileCage@@YAXKHPAX@Z		; SimToggleMissileCage
PUBLIC	?SimToggleMissileSpotScan@@YAXKHPAX@Z		; SimToggleMissileSpotScan
PUBLIC	?SimToggleMissileBoreSlave@@YAXKHPAX@Z		; SimToggleMissileBoreSlave
PUBLIC	?SimToggleMissileTDBPUncage@@YAXKHPAX@Z		; SimToggleMissileTDBPUncage
PUBLIC	?SimDropChaff@@YAXKHPAX@Z			; SimDropChaff
PUBLIC	?SimDropFlare@@YAXKHPAX@Z			; SimDropFlare
PUBLIC	?SimToggleDropPattern@@YAXKHPAX@Z		; SimToggleDropPattern
PUBLIC	?SimHSDRangeStepUp@@YAXKHPAX@Z			; SimHSDRangeStepUp
PUBLIC	?SimHSDRangeStepDown@@YAXKHPAX@Z		; SimHSDRangeStepDown
PUBLIC	?SimToggleInvincible@@YAXKHPAX@Z		; SimToggleInvincible
PUBLIC	?SimFCCSubModeStep@@YAXKHPAX@Z			; SimFCCSubModeStep
PUBLIC	?SimEndFlight@@YAXKHPAX@Z			; SimEndFlight
PUBLIC	?SimNextAAWeapon@@YAXKHPAX@Z			; SimNextAAWeapon
PUBLIC	?SimNextAGWeapon@@YAXKHPAX@Z			; SimNextAGWeapon
PUBLIC	?SimNextNavMode@@YAXKHPAX@Z			; SimNextNavMode
PUBLIC	?SimEject@@YAXKHPAX@Z				; SimEject
PUBLIC	?AFBrakesOut@@YAXKHPAX@Z			; AFBrakesOut
PUBLIC	?AFBrakesIn@@YAXKHPAX@Z				; AFBrakesIn
PUBLIC	?AFBrakesToggle@@YAXKHPAX@Z			; AFBrakesToggle
PUBLIC	?AFGearToggle@@YAXKHPAX@Z			; AFGearToggle
PUBLIC	?AFGearUp@@YAXKHPAX@Z				; AFGearUp
PUBLIC	?AFGearDown@@YAXKHPAX@Z				; AFGearDown
PUBLIC	?AFCoarseThrottleUp@@YAXKHPAX@Z			; AFCoarseThrottleUp
PUBLIC	?AFCoarseThrottleDown@@YAXKHPAX@Z		; AFCoarseThrottleDown
PUBLIC	?AFElevatorUp@@YAXKHPAX@Z			; AFElevatorUp
PUBLIC	?AFElevatorDown@@YAXKHPAX@Z			; AFElevatorDown
PUBLIC	?AFAileronLeft@@YAXKHPAX@Z			; AFAileronLeft
PUBLIC	?AFAileronRight@@YAXKHPAX@Z			; AFAileronRight
PUBLIC	?AFThrottleUp@@YAXKHPAX@Z			; AFThrottleUp
PUBLIC	?AFThrottleDown@@YAXKHPAX@Z			; AFThrottleDown
PUBLIC	?AFRudderLeft@@YAXKHPAX@Z			; AFRudderLeft
PUBLIC	?AFRudderRight@@YAXKHPAX@Z			; AFRudderRight
PUBLIC	?AFABOn@@YAXKHPAX@Z				; AFABOn
PUBLIC	?AFIdle@@YAXKHPAX@Z				; AFIdle
PUBLIC	?OTWTimeOfDayStep@@YAXKHPAX@Z			; OTWTimeOfDayStep
PUBLIC	?OTWStepNextAC@@YAXKHPAX@Z			; OTWStepNextAC
PUBLIC	?OTWStepPrevAC@@YAXKHPAX@Z			; OTWStepPrevAC
PUBLIC	?OTWStepNextPadlock@@YAXKHPAX@Z			; OTWStepNextPadlock
PUBLIC	?OTWStepNextPadlockAA@@YAXKHPAX@Z		; OTWStepNextPadlockAA
PUBLIC	?OTWStepNextPadlockAG@@YAXKHPAX@Z		; OTWStepNextPadlockAG
PUBLIC	?OTWStepPrevPadlock@@YAXKHPAX@Z			; OTWStepPrevPadlock
PUBLIC	?OTWStepPrevPadlockAA@@YAXKHPAX@Z		; OTWStepPrevPadlockAA
PUBLIC	?OTWStepPrevPadlockAG@@YAXKHPAX@Z		; OTWStepPrevPadlockAG
PUBLIC	?OTWToggleNames@@YAXKHPAX@Z			; OTWToggleNames
PUBLIC	?OTWToggleCampNames@@YAXKHPAX@Z			; OTWToggleCampNames
PUBLIC	?OTWSelectF3PadlockMode@@YAXKHPAX@Z		; OTWSelectF3PadlockMode
PUBLIC	?OTWSelectF3PadlockModeAA@@YAXKHPAX@Z		; OTWSelectF3PadlockModeAA
PUBLIC	?OTWSelectF3PadlockModeAG@@YAXKHPAX@Z		; OTWSelectF3PadlockModeAG
PUBLIC	?OTWSelectEFOVPadlockMode@@YAXKHPAX@Z		; OTWSelectEFOVPadlockMode
PUBLIC	?OTWSelectEFOVPadlockModeAA@@YAXKHPAX@Z		; OTWSelectEFOVPadlockModeAA
PUBLIC	?OTWSelectEFOVPadlockModeAG@@YAXKHPAX@Z		; OTWSelectEFOVPadlockModeAG
PUBLIC	?OTWStepMFD1@@YAXKHPAX@Z			; OTWStepMFD1
PUBLIC	?OTWStepMFD2@@YAXKHPAX@Z			; OTWStepMFD2
PUBLIC	?OTWStepMFD3@@YAXKHPAX@Z			; OTWStepMFD3
PUBLIC	?OTWStepMFD4@@YAXKHPAX@Z			; OTWStepMFD4
PUBLIC	?OTWToggleScales@@YAXKHPAX@Z			; OTWToggleScales
PUBLIC	?OTWTogglePitchLadder@@YAXKHPAX@Z		; OTWTogglePitchLadder
PUBLIC	?SimPitchLadderOff@@YAXKHPAX@Z			; SimPitchLadderOff
PUBLIC	?SimPitchLadderFPM@@YAXKHPAX@Z			; SimPitchLadderFPM
PUBLIC	?SimPitchLadderATTFPM@@YAXKHPAX@Z		; SimPitchLadderATTFPM
PUBLIC	?OTWStepHeadingScale@@YAXKHPAX@Z		; OTWStepHeadingScale
PUBLIC	?OTWSelectHUDMode@@YAXKHPAX@Z			; OTWSelectHUDMode
PUBLIC	?OTWToggleGLOC@@YAXKHPAX@Z			; OTWToggleGLOC
PUBLIC	?OTWSelectChaseMode@@YAXKHPAX@Z			; OTWSelectChaseMode
PUBLIC	?OTWSelectOrbitMode@@YAXKHPAX@Z			; OTWSelectOrbitMode
PUBLIC	?OTWSelectAirFriendlyMode@@YAXKHPAX@Z		; OTWSelectAirFriendlyMode
PUBLIC	?OTWSelectIncomingMode@@YAXKHPAX@Z		; OTWSelectIncomingMode
PUBLIC	?OTWSelectGroundFriendlyMode@@YAXKHPAX@Z	; OTWSelectGroundFriendlyMode
PUBLIC	?OTWSelectAirEnemyMode@@YAXKHPAX@Z		; OTWSelectAirEnemyMode
PUBLIC	?OTWSelectGroundEnemyMode@@YAXKHPAX@Z		; OTWSelectGroundEnemyMode
PUBLIC	?OTWSelectTargetMode@@YAXKHPAX@Z		; OTWSelectTargetMode
PUBLIC	?OTWSelectWeaponMode@@YAXKHPAX@Z		; OTWSelectWeaponMode
PUBLIC	?OTWSelectFlybyMode@@YAXKHPAX@Z			; OTWSelectFlybyMode
PUBLIC	?OTWSelectSatelliteMode@@YAXKHPAX@Z		; OTWSelectSatelliteMode
PUBLIC	?OTWShowTestVersion@@YAXKHPAX@Z			; OTWShowTestVersion
PUBLIC	?OTWShowVersion@@YAXKHPAX@Z			; OTWShowVersion
PUBLIC	?OTWSelect2DCockpitMode@@YAXKHPAX@Z		; OTWSelect2DCockpitMode
PUBLIC	?OTWSelect3DCockpitMode@@YAXKHPAX@Z		; OTWSelect3DCockpitMode
PUBLIC	?OTWToggleBilinearFilter@@YAXKHPAX@Z		; OTWToggleBilinearFilter
PUBLIC	?OTWToggleShading@@YAXKHPAX@Z			; OTWToggleShading
PUBLIC	?OTWToggleHaze@@YAXKHPAX@Z			; OTWToggleHaze
PUBLIC	?OTWToggleLocationDisplay@@YAXKHPAX@Z		; OTWToggleLocationDisplay
PUBLIC	?OTWToggleAeroDisplay@@YAXKHPAX@Z		; OTWToggleAeroDisplay
PUBLIC	?OTWToggleFlapDisplay@@YAXKHPAX@Z		; OTWToggleFlapDisplay
PUBLIC	?OTWToggleEngineDisplay@@YAXKHPAX@Z		; OTWToggleEngineDisplay
PUBLIC	?OTWToggleActionCamera@@YAXKHPAX@Z		; OTWToggleActionCamera
PUBLIC	?OTWScaleDown@@YAXKHPAX@Z			; OTWScaleDown
PUBLIC	?OTWScaleUp@@YAXKHPAX@Z				; OTWScaleUp
PUBLIC	?OTWSetObjDetail@@YAXKHPAX@Z			; OTWSetObjDetail
PUBLIC	?OTWObjDetailDown@@YAXKHPAX@Z			; OTWObjDetailDown
PUBLIC	?OTWObjDetailUp@@YAXKHPAX@Z			; OTWObjDetailUp
PUBLIC	?OTWToggleClouds@@YAXKHPAX@Z			; OTWToggleClouds
PUBLIC	?OTWStepHudColor@@YAXKHPAX@Z			; OTWStepHudColor
PUBLIC	?OTWToggleEyeFly@@YAXKHPAX@Z			; OTWToggleEyeFly
PUBLIC	?OTWEnterPosition@@YAXKHPAX@Z			; OTWEnterPosition
PUBLIC	?OTWToggleFrameRate@@YAXKHPAX@Z			; OTWToggleFrameRate
PUBLIC	?OTWToggleAutoScale@@YAXKHPAX@Z			; OTWToggleAutoScale
PUBLIC	?OTWSetScale@@YAXKHPAX@Z			; OTWSetScale
PUBLIC	?OTWViewLeft@@YAXKHPAX@Z			; OTWViewLeft
PUBLIC	?OTWViewRight@@YAXKHPAX@Z			; OTWViewRight
PUBLIC	?OTWViewUp@@YAXKHPAX@Z				; OTWViewUp
PUBLIC	?OTWViewDown@@YAXKHPAX@Z			; OTWViewDown
PUBLIC	?OTWViewDownLeft@@YAXKHPAX@Z			; OTWViewDownLeft
PUBLIC	?OTWViewDownRight@@YAXKHPAX@Z			; OTWViewDownRight
PUBLIC	?OTWViewUpLeft@@YAXKHPAX@Z			; OTWViewUpLeft
PUBLIC	?OTWViewUpRight@@YAXKHPAX@Z			; OTWViewUpRight
PUBLIC	?OTWViewReset@@YAXKHPAX@Z			; OTWViewReset
PUBLIC	?OTWViewZoomIn@@YAXKHPAX@Z			; OTWViewZoomIn
PUBLIC	?OTWViewZoomOut@@YAXKHPAX@Z			; OTWViewZoomOut
PUBLIC	?OTWSwapMFDS@@YAXKHPAX@Z			; OTWSwapMFDS
PUBLIC	?OTWGlanceForward@@YAXKHPAX@Z			; OTWGlanceForward
PUBLIC	?OTWCheckSix@@YAXKHPAX@Z			; OTWCheckSix
PUBLIC	?OTWStateStep@@YAXKHPAX@Z			; OTWStateStep
PUBLIC	?CommandsSetKeyCombo@@YAXKHPAX@Z		; CommandsSetKeyCombo
PUBLIC	?KevinsFistOfGod@@YAXKHPAX@Z			; KevinsFistOfGod
PUBLIC	?SuperCruise@@YAXKHPAX@Z			; SuperCruise
PUBLIC	?SimDriftCO@@YAXKHPAX@Z				; SimDriftCO
PUBLIC	?SimDriftCOOn@@YAXKHPAX@Z			; SimDriftCOOn
PUBLIC	?SimDriftCOOff@@YAXKHPAX@Z			; SimDriftCOOff
PUBLIC	?SimCATSwitch@@YAXKHPAX@Z			; SimCATSwitch
PUBLIC	?SimCATI@@YAXKHPAX@Z				; SimCATI
PUBLIC	?SimCATIII@@YAXKHPAX@Z				; SimCATIII
PUBLIC	?SimRegen@@YAXKHPAX@Z				; SimRegen
PUBLIC	?OTW1200View@@YAXKHPAX@Z			; OTW1200View
PUBLIC	?OTW1200DView@@YAXKHPAX@Z			; OTW1200DView
PUBLIC	?OTW1200HUDView@@YAXKHPAX@Z			; OTW1200HUDView
PUBLIC	?OTW1200LView@@YAXKHPAX@Z			; OTW1200LView
PUBLIC	?OTW1200RView@@YAXKHPAX@Z			; OTW1200RView
PUBLIC	?OTW1000View@@YAXKHPAX@Z			; OTW1000View
PUBLIC	?OTW200View@@YAXKHPAX@Z				; OTW200View
PUBLIC	?OTW300View@@YAXKHPAX@Z				; OTW300View
PUBLIC	?OTW400View@@YAXKHPAX@Z				; OTW400View
PUBLIC	?OTW800View@@YAXKHPAX@Z				; OTW800View
PUBLIC	?OTW900View@@YAXKHPAX@Z				; OTW900View
PUBLIC	?SimToggleChatMode@@YAXKHPAX@Z			; SimToggleChatMode
PUBLIC	?SimMotionFreeze@@YAXKHPAX@Z			; SimMotionFreeze
PUBLIC	?ScreenShot@@YAXKHPAX@Z				; ScreenShot
PUBLIC	?PrettyScreenShot@@YAXKHPAX@Z			; PrettyScreenShot
PUBLIC	?FOVToggle@@YAXKHPAX@Z				; FOVToggle
PUBLIC	?FOVDecrease@@YAXKHPAX@Z			; FOVDecrease
PUBLIC	?FOVIncrease@@YAXKHPAX@Z			; FOVIncrease
PUBLIC	?FOVDefault@@YAXKHPAX@Z				; FOVDefault
PUBLIC	?ACMIToggleRecording@@YAXKHPAX@Z		; ACMIToggleRecording
PUBLIC	?SimSelectiveJettison@@YAXKHPAX@Z		; SimSelectiveJettison
PUBLIC	?SimEmergencyJettison@@YAXKHPAX@Z		; SimEmergencyJettison
PUBLIC	?SimWheelBrakes@@YAXKHPAX@Z			; SimWheelBrakes
PUBLIC	?SimECMOn@@YAXKHPAX@Z				; SimECMOn
PUBLIC	?SimECMStandby@@YAXKHPAX@Z			; SimECMStandby
PUBLIC	?SimECMConsent@@YAXKHPAX@Z			; SimECMConsent
PUBLIC	?SimRandomError@@YAXKHPAX@Z			; SimRandomError
PUBLIC	?SoundOff@@YAXKHPAX@Z				; SoundOff
PUBLIC	?SimStepMasterArm@@YAXKHPAX@Z			; SimStepMasterArm
PUBLIC	?SimArmMasterArm@@YAXKHPAX@Z			; SimArmMasterArm
PUBLIC	?SimSafeMasterArm@@YAXKHPAX@Z			; SimSafeMasterArm
PUBLIC	?SimSimMasterArm@@YAXKHPAX@Z			; SimSimMasterArm
PUBLIC	?SimHsiCourseInc@@YAXKHPAX@Z			; SimHsiCourseInc
PUBLIC	?SimHsiCourseDec@@YAXKHPAX@Z			; SimHsiCourseDec
PUBLIC	?SimHsiHeadingInc@@YAXKHPAX@Z			; SimHsiHeadingInc
PUBLIC	?SimHsiHeadingDec@@YAXKHPAX@Z			; SimHsiHeadingDec
PUBLIC	?SimHsiCrsIncBy1@@YAXKHPAX@Z			; SimHsiCrsIncBy1
PUBLIC	?SimHsiCrsDecBy1@@YAXKHPAX@Z			; SimHsiCrsDecBy1
PUBLIC	?SimHsiHdgIncBy1@@YAXKHPAX@Z			; SimHsiHdgIncBy1
PUBLIC	?SimHsiHdgDecBy1@@YAXKHPAX@Z			; SimHsiHdgDecBy1
PUBLIC	?SimAVTRToggle@@YAXKHPAX@Z			; SimAVTRToggle
PUBLIC	?SimMPOToggle@@YAXKHPAX@Z			; SimMPOToggle
PUBLIC	?SimMPO@@YAXKHPAX@Z				; SimMPO
PUBLIC	?SimSilenceHorn@@YAXKHPAX@Z			; SimSilenceHorn
PUBLIC	?SimStepHSIMode@@YAXKHPAX@Z			; SimStepHSIMode
PUBLIC	?SimHSIIlsTcn@@YAXKHPAX@Z			; SimHSIIlsTcn
PUBLIC	?SimHSITcn@@YAXKHPAX@Z				; SimHSITcn
PUBLIC	?SimHSINav@@YAXKHPAX@Z				; SimHSINav
PUBLIC	?SimHSIIlsNav@@YAXKHPAX@Z			; SimHSIIlsNav
PUBLIC	?DecreaseAlow@@YAXKHPAX@Z			; DecreaseAlow
PUBLIC	?IncreaseAlow@@YAXKHPAX@Z			; IncreaseAlow
PUBLIC	?SimCBEOSB_1L@@YAXKHPAX@Z			; SimCBEOSB_1L
PUBLIC	?SimCBEOSB_2L@@YAXKHPAX@Z			; SimCBEOSB_2L
PUBLIC	?SimCBEOSB_3L@@YAXKHPAX@Z			; SimCBEOSB_3L
PUBLIC	?SimCBEOSB_4L@@YAXKHPAX@Z			; SimCBEOSB_4L
PUBLIC	?SimCBEOSB_5L@@YAXKHPAX@Z			; SimCBEOSB_5L
PUBLIC	?SimCBEOSB_6L@@YAXKHPAX@Z			; SimCBEOSB_6L
PUBLIC	?SimCBEOSB_7L@@YAXKHPAX@Z			; SimCBEOSB_7L
PUBLIC	?SimCBEOSB_8L@@YAXKHPAX@Z			; SimCBEOSB_8L
PUBLIC	?SimCBEOSB_9L@@YAXKHPAX@Z			; SimCBEOSB_9L
PUBLIC	?SimCBEOSB_10L@@YAXKHPAX@Z			; SimCBEOSB_10L
PUBLIC	?SimCBEOSB_11L@@YAXKHPAX@Z			; SimCBEOSB_11L
PUBLIC	?SimCBEOSB_12L@@YAXKHPAX@Z			; SimCBEOSB_12L
PUBLIC	?SimCBEOSB_13L@@YAXKHPAX@Z			; SimCBEOSB_13L
PUBLIC	?SimCBEOSB_14L@@YAXKHPAX@Z			; SimCBEOSB_14L
PUBLIC	?SimCBEOSB_15L@@YAXKHPAX@Z			; SimCBEOSB_15L
PUBLIC	?SimCBEOSB_16L@@YAXKHPAX@Z			; SimCBEOSB_16L
PUBLIC	?SimCBEOSB_17L@@YAXKHPAX@Z			; SimCBEOSB_17L
PUBLIC	?SimCBEOSB_18L@@YAXKHPAX@Z			; SimCBEOSB_18L
PUBLIC	?SimCBEOSB_19L@@YAXKHPAX@Z			; SimCBEOSB_19L
PUBLIC	?SimCBEOSB_20L@@YAXKHPAX@Z			; SimCBEOSB_20L
PUBLIC	?SimCBEOSB_1R@@YAXKHPAX@Z			; SimCBEOSB_1R
PUBLIC	?SimCBEOSB_2R@@YAXKHPAX@Z			; SimCBEOSB_2R
PUBLIC	?SimCBEOSB_3R@@YAXKHPAX@Z			; SimCBEOSB_3R
PUBLIC	?SimCBEOSB_4R@@YAXKHPAX@Z			; SimCBEOSB_4R
PUBLIC	?SimCBEOSB_5R@@YAXKHPAX@Z			; SimCBEOSB_5R
PUBLIC	?SimCBEOSB_6R@@YAXKHPAX@Z			; SimCBEOSB_6R
PUBLIC	?SimCBEOSB_7R@@YAXKHPAX@Z			; SimCBEOSB_7R
PUBLIC	?SimCBEOSB_8R@@YAXKHPAX@Z			; SimCBEOSB_8R
PUBLIC	?SimCBEOSB_9R@@YAXKHPAX@Z			; SimCBEOSB_9R
PUBLIC	?SimCBEOSB_10R@@YAXKHPAX@Z			; SimCBEOSB_10R
PUBLIC	?SimCBEOSB_11R@@YAXKHPAX@Z			; SimCBEOSB_11R
PUBLIC	?SimCBEOSB_12R@@YAXKHPAX@Z			; SimCBEOSB_12R
PUBLIC	?SimCBEOSB_13R@@YAXKHPAX@Z			; SimCBEOSB_13R
PUBLIC	?SimCBEOSB_14R@@YAXKHPAX@Z			; SimCBEOSB_14R
PUBLIC	?SimCBEOSB_15R@@YAXKHPAX@Z			; SimCBEOSB_15R
PUBLIC	?SimCBEOSB_16R@@YAXKHPAX@Z			; SimCBEOSB_16R
PUBLIC	?SimCBEOSB_17R@@YAXKHPAX@Z			; SimCBEOSB_17R
PUBLIC	?SimCBEOSB_18R@@YAXKHPAX@Z			; SimCBEOSB_18R
PUBLIC	?SimCBEOSB_19R@@YAXKHPAX@Z			; SimCBEOSB_19R
PUBLIC	?SimCBEOSB_20R@@YAXKHPAX@Z			; SimCBEOSB_20R
PUBLIC	?SimCBEOSB_1T@@YAXKHPAX@Z			; SimCBEOSB_1T
PUBLIC	?SimCBEOSB_2T@@YAXKHPAX@Z			; SimCBEOSB_2T
PUBLIC	?SimCBEOSB_3T@@YAXKHPAX@Z			; SimCBEOSB_3T
PUBLIC	?SimCBEOSB_4T@@YAXKHPAX@Z			; SimCBEOSB_4T
PUBLIC	?SimCBEOSB_5T@@YAXKHPAX@Z			; SimCBEOSB_5T
PUBLIC	?SimCBEOSB_6T@@YAXKHPAX@Z			; SimCBEOSB_6T
PUBLIC	?SimCBEOSB_7T@@YAXKHPAX@Z			; SimCBEOSB_7T
PUBLIC	?SimCBEOSB_8T@@YAXKHPAX@Z			; SimCBEOSB_8T
PUBLIC	?SimCBEOSB_9T@@YAXKHPAX@Z			; SimCBEOSB_9T
PUBLIC	?SimCBEOSB_10T@@YAXKHPAX@Z			; SimCBEOSB_10T
PUBLIC	?SimCBEOSB_11T@@YAXKHPAX@Z			; SimCBEOSB_11T
PUBLIC	?SimCBEOSB_12T@@YAXKHPAX@Z			; SimCBEOSB_12T
PUBLIC	?SimCBEOSB_13T@@YAXKHPAX@Z			; SimCBEOSB_13T
PUBLIC	?SimCBEOSB_14T@@YAXKHPAX@Z			; SimCBEOSB_14T
PUBLIC	?SimCBEOSB_15T@@YAXKHPAX@Z			; SimCBEOSB_15T
PUBLIC	?SimCBEOSB_16T@@YAXKHPAX@Z			; SimCBEOSB_16T
PUBLIC	?SimCBEOSB_17T@@YAXKHPAX@Z			; SimCBEOSB_17T
PUBLIC	?SimCBEOSB_18T@@YAXKHPAX@Z			; SimCBEOSB_18T
PUBLIC	?SimCBEOSB_19T@@YAXKHPAX@Z			; SimCBEOSB_19T
PUBLIC	?SimCBEOSB_20T@@YAXKHPAX@Z			; SimCBEOSB_20T
PUBLIC	?SimCBEOSB_1F@@YAXKHPAX@Z			; SimCBEOSB_1F
PUBLIC	?SimCBEOSB_2F@@YAXKHPAX@Z			; SimCBEOSB_2F
PUBLIC	?SimCBEOSB_3F@@YAXKHPAX@Z			; SimCBEOSB_3F
PUBLIC	?SimCBEOSB_4F@@YAXKHPAX@Z			; SimCBEOSB_4F
PUBLIC	?SimCBEOSB_5F@@YAXKHPAX@Z			; SimCBEOSB_5F
PUBLIC	?SimCBEOSB_6F@@YAXKHPAX@Z			; SimCBEOSB_6F
PUBLIC	?SimCBEOSB_7F@@YAXKHPAX@Z			; SimCBEOSB_7F
PUBLIC	?SimCBEOSB_8F@@YAXKHPAX@Z			; SimCBEOSB_8F
PUBLIC	?SimCBEOSB_9F@@YAXKHPAX@Z			; SimCBEOSB_9F
PUBLIC	?SimCBEOSB_10F@@YAXKHPAX@Z			; SimCBEOSB_10F
PUBLIC	?SimCBEOSB_11F@@YAXKHPAX@Z			; SimCBEOSB_11F
PUBLIC	?SimCBEOSB_12F@@YAXKHPAX@Z			; SimCBEOSB_12F
PUBLIC	?SimCBEOSB_13F@@YAXKHPAX@Z			; SimCBEOSB_13F
PUBLIC	?SimCBEOSB_14F@@YAXKHPAX@Z			; SimCBEOSB_14F
PUBLIC	?SimCBEOSB_15F@@YAXKHPAX@Z			; SimCBEOSB_15F
PUBLIC	?SimCBEOSB_16F@@YAXKHPAX@Z			; SimCBEOSB_16F
PUBLIC	?SimCBEOSB_17F@@YAXKHPAX@Z			; SimCBEOSB_17F
PUBLIC	?SimCBEOSB_18F@@YAXKHPAX@Z			; SimCBEOSB_18F
PUBLIC	?SimCBEOSB_19F@@YAXKHPAX@Z			; SimCBEOSB_19F
PUBLIC	?SimCBEOSB_20F@@YAXKHPAX@Z			; SimCBEOSB_20F
PUBLIC	?SimCBEOSB_GAINUP_T@@YAXKHPAX@Z			; SimCBEOSB_GAINUP_T
PUBLIC	?SimCBEOSB_GAINUP_F@@YAXKHPAX@Z			; SimCBEOSB_GAINUP_F
PUBLIC	?SimCBEOSB_GAINDOWN_T@@YAXKHPAX@Z		; SimCBEOSB_GAINDOWN_T
PUBLIC	?SimCBEOSB_GAINDOWN_F@@YAXKHPAX@Z		; SimCBEOSB_GAINDOWN_F
PUBLIC	?SimCBEOSB_GAINUP_R@@YAXKHPAX@Z			; SimCBEOSB_GAINUP_R
PUBLIC	?SimCBEOSB_GAINUP_L@@YAXKHPAX@Z			; SimCBEOSB_GAINUP_L
PUBLIC	?SimCBEOSB_GAINDOWN_R@@YAXKHPAX@Z		; SimCBEOSB_GAINDOWN_R
PUBLIC	?SimCBEOSB_GAINDOWN_L@@YAXKHPAX@Z		; SimCBEOSB_GAINDOWN_L
PUBLIC	?SimICPTILS@@YAXKHPAX@Z				; SimICPTILS
PUBLIC	?SimICPALOW@@YAXKHPAX@Z				; SimICPALOW
PUBLIC	?SimICPFAck@@YAXKHPAX@Z				; SimICPFAck
PUBLIC	?SimICPPrevious@@YAXKHPAX@Z			; SimICPPrevious
PUBLIC	?SimICPNext@@YAXKHPAX@Z				; SimICPNext
PUBLIC	?SimICPLink@@YAXKHPAX@Z				; SimICPLink
PUBLIC	?SimICPCrus@@YAXKHPAX@Z				; SimICPCrus
PUBLIC	?SimICPStpt@@YAXKHPAX@Z				; SimICPStpt
PUBLIC	?SimICPMark@@YAXKHPAX@Z				; SimICPMark
PUBLIC	?SimICPEnter@@YAXKHPAX@Z			; SimICPEnter
PUBLIC	?SimICPCom1@@YAXKHPAX@Z				; SimICPCom1
PUBLIC	?SimICPCom2@@YAXKHPAX@Z				; SimICPCom2
PUBLIC	?SimICPNav@@YAXKHPAX@Z				; SimICPNav
PUBLIC	?SimICPAA@@YAXKHPAX@Z				; SimICPAA
PUBLIC	?SimICPAG@@YAXKHPAX@Z				; SimICPAG
PUBLIC	?SimHUDScales@@YAXKHPAX@Z			; SimHUDScales
PUBLIC	?SimScalesVVVAH@@YAXKHPAX@Z			; SimScalesVVVAH
PUBLIC	?SimScalesVAH@@YAXKHPAX@Z			; SimScalesVAH
PUBLIC	?SimScalesOff@@YAXKHPAX@Z			; SimScalesOff
PUBLIC	?SimHUDFPM@@YAXKHPAX@Z				; SimHUDFPM
PUBLIC	?SimHUDDED@@YAXKHPAX@Z				; SimHUDDED
PUBLIC	?SimHUDDEDOff@@YAXKHPAX@Z			; SimHUDDEDOff
PUBLIC	?SimHUDDEDPFL@@YAXKHPAX@Z			; SimHUDDEDPFL
PUBLIC	?SimHUDDEDDED@@YAXKHPAX@Z			; SimHUDDEDDED
PUBLIC	?SimHUDVelocity@@YAXKHPAX@Z			; SimHUDVelocity
PUBLIC	?SimHUDVelocityCAS@@YAXKHPAX@Z			; SimHUDVelocityCAS
PUBLIC	?SimHUDVelocityTAS@@YAXKHPAX@Z			; SimHUDVelocityTAS
PUBLIC	?SimHUDVelocityGND@@YAXKHPAX@Z			; SimHUDVelocityGND
PUBLIC	?SimHUDRadar@@YAXKHPAX@Z			; SimHUDRadar
PUBLIC	?SimHUDAltRadar@@YAXKHPAX@Z			; SimHUDAltRadar
PUBLIC	?SimHUDAltBaro@@YAXKHPAX@Z			; SimHUDAltBaro
PUBLIC	?SimHUDAltAuto@@YAXKHPAX@Z			; SimHUDAltAuto
PUBLIC	?SimHUDBrightness@@YAXKHPAX@Z			; SimHUDBrightness
PUBLIC	?SimHUDBrtDay@@YAXKHPAX@Z			; SimHUDBrtDay
PUBLIC	?SimHUDBrtAuto@@YAXKHPAX@Z			; SimHUDBrtAuto
PUBLIC	?SimHUDBrtNight@@YAXKHPAX@Z			; SimHUDBrtNight
PUBLIC	?SimHUDBrightnessUp@@YAXKHPAX@Z			; SimHUDBrightnessUp
PUBLIC	?SimHUDBrightnessDown@@YAXKHPAX@Z		; SimHUDBrightnessDown
PUBLIC	?ExtinguishMasterCaution@@YAXKHPAX@Z		; ExtinguishMasterCaution
PUBLIC	?SimCycleLeftAuxComDigit@@YAXKHPAX@Z		; SimCycleLeftAuxComDigit
PUBLIC	?SimCycleCenterAuxComDigit@@YAXKHPAX@Z		; SimCycleCenterAuxComDigit
PUBLIC	?SimCycleRightAuxComDigit@@YAXKHPAX@Z		; SimCycleRightAuxComDigit
PUBLIC	?SimCycleBandAuxComDigit@@YAXKHPAX@Z		; SimCycleBandAuxComDigit
PUBLIC	?SimToggleAuxComMaster@@YAXKHPAX@Z		; SimToggleAuxComMaster
PUBLIC	?SimAuxComBackup@@YAXKHPAX@Z			; SimAuxComBackup
PUBLIC	?SimAuxComUFC@@YAXKHPAX@Z			; SimAuxComUFC
PUBLIC	?SimToggleAuxComAATR@@YAXKHPAX@Z		; SimToggleAuxComAATR
PUBLIC	?SimTACANTR@@YAXKHPAX@Z				; SimTACANTR
PUBLIC	?SimTACANAATR@@YAXKHPAX@Z			; SimTACANAATR
PUBLIC	?SimToggleUHFMaster@@YAXKHPAX@Z			; SimToggleUHFMaster
PUBLIC	?SimTransmitCom1@@YAXKHPAX@Z			; SimTransmitCom1
PUBLIC	?SimTransmitCom2@@YAXKHPAX@Z			; SimTransmitCom2
PUBLIC	?SimToggleExtLights@@YAXKHPAX@Z			; SimToggleExtLights
PUBLIC	?SaveCockpitDefaults@@YAXKHPAX@Z		; SaveCockpitDefaults
PUBLIC	?LoadCockpitDefaults@@YAXKHPAX@Z		; LoadCockpitDefaults
PUBLIC	?SimSpeedyGonzalesUp@@YAXKHPAX@Z		; SimSpeedyGonzalesUp
PUBLIC	?SimSpeedyGonzalesDown@@YAXKHPAX@Z		; SimSpeedyGonzalesDown
PUBLIC	?ToggleVtune@@YAXKHPAX@Z			; ToggleVtune
PUBLIC	?Profiler_CursorDown@@YAXKHPAX@Z		; Profiler_CursorDown
PUBLIC	?Profiler_CursorUp@@YAXKHPAX@Z			; Profiler_CursorUp
PUBLIC	?Profiler_Parent@@YAXKHPAX@Z			; Profiler_Parent
PUBLIC	?Profiler_Select@@YAXKHPAX@Z			; Profiler_Select
PUBLIC	?Profiler_Hier@@YAXKHPAX@Z			; Profiler_Hier
PUBLIC	?Profiler_Self@@YAXKHPAX@Z			; Profiler_Self
PUBLIC	?ToggleProfilerDisplay@@YAXKHPAX@Z		; ToggleProfilerDisplay
PUBLIC	?ToggleProfiler@@YAXKHPAX@Z			; ToggleProfiler
PUBLIC	?Profiler_HistoryBack@@YAXKHPAX@Z		; Profiler_HistoryBack
PUBLIC	?Profiler_HistoryFwd@@YAXKHPAX@Z		; Profiler_HistoryFwd
PUBLIC	?Profiler_HistoryBackFast@@YAXKHPAX@Z		; Profiler_HistoryBackFast
PUBLIC	?Profiler_HistoryFwdFast@@YAXKHPAX@Z		; Profiler_HistoryFwdFast
PUBLIC	?ToggleSubTitles@@YAXKHPAX@Z			; ToggleSubTitles
PUBLIC	?ToggleInfoBar@@YAXKHPAX@Z			; ToggleInfoBar
PUBLIC	?ToggleDisplacementCam@@YAXKHPAX@Z		; ToggleDisplacementCam
PUBLIC	?WinAmpNextTrack@@YAXKHPAX@Z			; WinAmpNextTrack
PUBLIC	?WinAmpPreviousTrack@@YAXKHPAX@Z		; WinAmpPreviousTrack
PUBLIC	?WinAmpStopPlayback@@YAXKHPAX@Z			; WinAmpStopPlayback
PUBLIC	?WinAmpStartPlayback@@YAXKHPAX@Z		; WinAmpStartPlayback
PUBLIC	?WinAmpTogglePlayback@@YAXKHPAX@Z		; WinAmpTogglePlayback
PUBLIC	?WinAmpVolumeUp@@YAXKHPAX@Z			; WinAmpVolumeUp
PUBLIC	?WinAmpVolumeDown@@YAXKHPAX@Z			; WinAmpVolumeDown
PUBLIC	?CycleEngine@@YAXKHPAX@Z			; CycleEngine
PUBLIC	?selectLeftEngine@@YAXKHPAX@Z			; selectLeftEngine
PUBLIC	?selectRightEngine@@YAXKHPAX@Z			; selectRightEngine
PUBLIC	?selectBothEngines@@YAXKHPAX@Z			; selectBothEngines
PUBLIC	?ToggleTIR@@YAXKHPAX@Z				; ToggleTIR
PUBLIC	?ToggleClickablePitMode@@YAXKHPAX@Z		; ToggleClickablePitMode
PUBLIC	?SimToggleRearView@@YAXKHPAX@Z			; SimToggleRearView
PUBLIC	?SimToggleAltView@@YAXKHPAX@Z			; SimToggleAltView
PUBLIC	?OTWStepHudContrastDn@@YAXKHPAX@Z		; OTWStepHudContrastDn
PUBLIC	?OTWStepHudContrastUp@@YAXKHPAX@Z		; OTWStepHudContrastUp
PUBLIC	?GetPadlockMode@RulesClass@@QAEHXZ		; RulesClass::GetPadlockMode
PUBLIC	?BlackoutOn@RulesClass@@QAEHXZ			; RulesClass::BlackoutOn
PUBLIC	?WeatherOn@RulesClass@@QAEHXZ			; RulesClass::WeatherOn
PUBLIC	?ExternalViewOn@RulesClass@@QAEHXZ		; RulesClass::ExternalViewOn
PUBLIC	?InvulnerableOn@RulesClass@@QAEHXZ		; RulesClass::InvulnerableOn
PUBLIC	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
PUBLIC	?SetBubbleRatio@FalconSessionEntity@@QAEXM@Z	; FalconSessionEntity::SetBubbleRatio
PUBLIC	?IsSetFlag@SimBaseClass@@QBEHH@Z		; SimBaseClass::IsSetFlag
PUBLIC	?SetSwitch@SimMoverClass@@QAEXHH@Z		; SimMoverClass::SetSwitch
PUBLIC	?GetSOI@SimVehicleClass@@QAE?AW4SOI@1@XZ	; SimVehicleClass::GetSOI
PUBLIC	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ		; VuBin<SimWeaponClass>::operator bool
PUBLIC	?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::get
PUBLIC	?SetInteriorLight@AircraftClass@@QAEXW4LightSwitch@1@@Z ; AircraftClass::SetInteriorLight
PUBLIC	?SetInstrumentLight@AircraftClass@@QAEXW4LightSwitch@1@@Z ; AircraftClass::SetInstrumentLight
PUBLIC	?SetSpotLight@AircraftClass@@QAEXW4LightSwitch@1@@Z ; AircraftClass::SetSpotLight
PUBLIC	?GetInteriorLight@AircraftClass@@QBE?AW4LightSwitch@1@XZ ; AircraftClass::GetInteriorLight
PUBLIC	?GetInstrumentLight@AircraftClass@@QBE?AW4LightSwitch@1@XZ ; AircraftClass::GetInstrumentLight
PUBLIC	?GetSpotLight@AircraftClass@@QBE?AW4LightSwitch@1@XZ ; AircraftClass::GetSpotLight
PUBLIC	?IsAcStatusBitsSet@AircraftClass@@QBE_NH@Z	; AircraftClass::IsAcStatusBitsSet
PUBLIC	?ExtlOn@AircraftClass@@QAEXW4ExtlLightFlags@1@@Z ; AircraftClass::ExtlOn
PUBLIC	?ExtlOff@AircraftClass@@QAEXW4ExtlLightFlags@1@@Z ; AircraftClass::ExtlOff
PUBLIC	?ExtlState@AircraftClass@@QBEHW4ExtlLightFlags@1@@Z ; AircraftClass::ExtlState
PUBLIC	?INSOn@AircraftClass@@QAEXW4INSAlignFlags@1@@Z	; AircraftClass::INSOn
PUBLIC	?INSOff@AircraftClass@@QAEXW4INSAlignFlags@1@@Z	; AircraftClass::INSOff
PUBLIC	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
PUBLIC	?AVTROn@AircraftClass@@QAEXW4AVTRStateFlags@1@@Z ; AircraftClass::AVTROn
PUBLIC	?AVTROff@AircraftClass@@QAEXW4AVTRStateFlags@1@@Z ; AircraftClass::AVTROff
PUBLIC	?AVTRState@AircraftClass@@QAEHW4AVTRStateFlags@1@@Z ; AircraftClass::AVTRState
PUBLIC	?LEFState@AircraftClass@@QAEHW4LEFStateFlags@1@@Z ; AircraftClass::LEFState
PUBLIC	?AutopilotType@AircraftClass@@QAE?AW4AutoPilotType@1@XZ ; AircraftClass::AutopilotType
PUBLIC	?IsF16@AircraftClass@@QAEHXZ			; AircraftClass::IsF16
PUBLIC	?IsComplex@AircraftClass@@QAEHXZ		; AircraftClass::IsComplex
PUBLIC	?RaltOn@AircraftClass@@QAEXXZ			; AircraftClass::RaltOn
PUBLIC	?RaltStdby@AircraftClass@@QAEXXZ		; AircraftClass::RaltStdby
PUBLIC	?RaltOff@AircraftClass@@QAEXXZ			; AircraftClass::RaltOff
PUBLIC	?IsOn@AircraftClass@@QAEHW4APFlags@1@@Z		; AircraftClass::IsOn
PUBLIC	?SetAPFlag@AircraftClass@@QAEXW4APFlags@1@@Z	; AircraftClass::SetAPFlag
PUBLIC	?ClearAPFlag@AircraftClass@@QAEXW4APFlags@1@@Z	; AircraftClass::ClearAPFlag
PUBLIC	?PowerOn@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerOn
PUBLIC	?PowerOff@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerOff
PUBLIC	?PowerToggle@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerToggle
PUBLIC	?MainPowerOn@AircraftClass@@QAEHXZ		; AircraftClass::MainPowerOn
PUBLIC	?SetMainPower@AircraftClass@@QAEXW4MainPowerType@1@@Z ; AircraftClass::SetMainPower
PUBLIC	?EWSPGM@AircraftClass@@QAE?AW4EWSPGMSwitch@1@XZ	; AircraftClass::EWSPGM
PUBLIC	?SetPGM@AircraftClass@@QAEXW4EWSPGMSwitch@1@@Z	; AircraftClass::SetPGM
PUBLIC	?SetEWSProg@AircraftClass@@QAEXH@Z		; AircraftClass::SetEWSProg
PUBLIC	?GetSPType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetSPType
PUBLIC	?RunningDogfight@SimulationDriver@@QBE_NXZ	; SimulationDriver::RunningDogfight
PUBLIC	?RunningTactical@SimulationDriver@@QBE_NXZ	; SimulationDriver::RunningTactical
PUBLIC	?MotionOn@SimulationDriver@@QAEHXZ		; SimulationDriver::MotionOn
PUBLIC	?SetMotion@SimulationDriver@@QAEXH@Z		; SimulationDriver::SetMotion
PUBLIC	?AVTROn@SimulationDriver@@QAEHXZ		; SimulationDriver::AVTROn
PUBLIC	?SetAVTR@SimulationDriver@@QAEXH@Z		; SimulationDriver::SetAVTR
PUBLIC	??0id@locale@std@@QAE@I@Z			; std::locale::id::id
PUBLIC	?generic_category@std@@YAABVerror_category@1@XZ	; std::generic_category
PUBLIC	?system_category@std@@YAABVerror_category@1@XZ	; std::system_category
PUBLIC	??0error_category@std@@QAE@XZ			; std::error_category::error_category
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??8error_category@std@@QBE_NABV01@@Z		; std::error_category::operator==
PUBLIC	??_Gerror_category@std@@UAEPAXI@Z		; std::error_category::`scalar deleting destructor'
PUBLIC	?value@error_code@std@@QBEHXZ			; std::error_code::value
PUBLIC	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
PUBLIC	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?value@error_condition@std@@QBEHXZ		; std::error_condition::value
PUBLIC	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
PUBLIC	??8error_condition@std@@QBE_NABV01@@Z		; std::error_condition::operator==
PUBLIC	??0_Generic_error_category@std@@QAE@XZ		; std::_Generic_error_category::_Generic_error_category
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	??1_Generic_error_category@std@@UAE@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	??0_Iostream_error_category@std@@QAE@XZ		; std::_Iostream_error_category::_Iostream_error_category
PUBLIC	?name@_Iostream_error_category@std@@UBEPBDXZ	; std::_Iostream_error_category::name
PUBLIC	?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	??1_Iostream_error_category@std@@UAE@XZ		; std::_Iostream_error_category::~_Iostream_error_category
PUBLIC	??_G_Iostream_error_category@std@@UAEPAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	??0_System_error_category@std@@QAE@XZ		; std::_System_error_category::_System_error_category
PUBLIC	?name@_System_error_category@std@@UBEPBDXZ	; std::_System_error_category::name
PUBLIC	?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message
PUBLIC	?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition
PUBLIC	??1_System_error_category@std@@UAE@XZ		; std::_System_error_category::~_System_error_category
PUBLIC	??_G_System_error_category@std@@UAEPAXI@Z	; std::_System_error_category::`scalar deleting destructor'
PUBLIC	?GetAvionicsType@PlayerOptionsClass@@QAEHXZ	; PlayerOptionsClass::GetAvionicsType
PUBLIC	?GetAutopilotMode@PlayerOptionsClass@@QAEHXZ	; PlayerOptionsClass::GetAutopilotMode
PUBLIC	?InvulnerableOn@PlayerOptionsClass@@QAEHXZ	; PlayerOptionsClass::InvulnerableOn
PUBLIC	?Get3dTrackIR@PlayerOptionsClass@@QBE_NXZ	; PlayerOptionsClass::Get3dTrackIR
PUBLIC	?SetSimFlag@PlayerOptionsClass@@QAEXH@Z		; PlayerOptionsClass::SetSimFlag
PUBLIC	?ClearSimFlag@PlayerOptionsClass@@QAEXH@Z	; PlayerOptionsClass::ClearSimFlag
PUBLIC	?SetScale@OTWDriverClass@@QAEXM@Z		; OTWDriverClass::SetScale
PUBLIC	?SetFrontTextFlags@OTWDriverClass@@QAEXJ@Z	; OTWDriverClass::SetFrontTextFlags
PUBLIC	?GetFrontTextFlags@OTWDriverClass@@QAEJXZ	; OTWDriverClass::GetFrontTextFlags
PUBLIC	?SetCameraPanTilt@OTWDriverClass@@QAEXMM@Z	; OTWDriverClass::SetCameraPanTilt
PUBLIC	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
PUBLIC	?SetHeadTracking@OTWDriverClass@@QAEXH@Z	; OTWDriverClass::SetHeadTracking
PUBLIC	?IsHeadTracking@OTWDriverClass@@QAEHXZ		; OTWDriverClass::IsHeadTracking
PUBLIC	?IsSOI@DrawableClass@@QAEHXZ			; DrawableClass::IsSOI
PUBLIC	?CurMode@MFDClass@@QAE?AW4MfdMode@1@XZ		; MFDClass::CurMode
PUBLIC	?GetCurMode@MFDClass@@QAE?AW4MfdMode@1@XZ	; MFDClass::GetCurMode
PUBLIC	?CurrentTarget@SensorClass@@QAEPAVSimObjectType@@XZ ; SensorClass::CurrentTarget
PUBLIC	?GetLastNavMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetLastNavMasterMode
PUBLIC	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
PUBLIC	?IsNavMasterMode@FireControlComputer@@QAEHXZ	; FireControlComputer::IsNavMasterMode
PUBLIC	?GetSubMode@FireControlComputer@@QAE?AW4FCCSubMode@1@XZ ; FireControlComputer::GetSubMode
PUBLIC	?SetLastDesignate@FireControlComputer@@QAEXXZ	; FireControlComputer::SetLastDesignate
PUBLIC	?MasterArm@SMSBaseClass@@QAE?AW4MasterArmState@1@XZ ; SMSBaseClass::MasterArm
PUBLIC	?SetMasterArm@SMSBaseClass@@QAEXW4MasterArmState@1@@Z ; SMSBaseClass::SetMasterArm
PUBLIC	?GetCoolState@SMSClass@@QAE?AW4Aim9Mode@1@XZ	; SMSClass::GetCoolState
PUBLIC	?SetCoolState@SMSClass@@QAEXW4Aim9Mode@1@@Z	; SMSClass::SetCoolState
PUBLIC	?SetAGBPair@SMSClass@@QAEX_N@Z			; SMSClass::SetAGBPair
PUBLIC	?DisplayMode@SmsDrawable@@QAE?AW4SmsDisplayMode@1@XZ ; SmsDrawable::DisplayMode
PUBLIC	?GetDataLinkCapLevel@AirframeClass@@QAEHXZ	; AirframeClass::GetDataLinkCapLevel
PUBLIC	?GetNumberEngines@AirframeClass@@QAEHXZ		; AirframeClass::GetNumberEngines
PUBLIC	?GetTypeAC@AirframeClass@@QAEHXZ		; AirframeClass::GetTypeAC
PUBLIC	?HasDragChute@AirframeClass@@QAE_NXZ		; AirframeClass::HasDragChute
PUBLIC	?GetEpuSwitch@AirframeClass@@QAE?AW4EpuState@1@XZ ; AirframeClass::GetEpuSwitch
PUBLIC	?SetEpuSwitch@AirframeClass@@QAEXW4EpuState@1@@Z ; AirframeClass::SetEpuSwitch
PUBLIC	?HydraulicA@AirframeClass@@QAEHXZ		; AirframeClass::HydraulicA
PUBLIC	?HydraulicB@AirframeClass@@QAEHXZ		; AirframeClass::HydraulicB
PUBLIC	?IsEngineFlag@AirframeClass@@QAEHW4EngineFlags@1@@Z ; AirframeClass::IsEngineFlag
PUBLIC	?SetEngineFlag@AirframeClass@@QAEXW4EngineFlags@1@@Z ; AirframeClass::SetEngineFlag
PUBLIC	?ClearEngineFlag@AirframeClass@@QAEXW4EngineFlags@1@@Z ; AirframeClass::ClearEngineFlag
PUBLIC	?ToggleEngineFlag@AirframeClass@@QAEXW4EngineFlags@1@@Z ; AirframeClass::ToggleEngineFlag
PUBLIC	?SetFuelSwitch@AirframeClass@@QAEXW4FuelSwitch@1@@Z ; AirframeClass::SetFuelSwitch
PUBLIC	?GetFuelSwitch@AirframeClass@@QAE?AW4FuelSwitch@1@XZ ; AirframeClass::GetFuelSwitch
PUBLIC	?SetFuelPump@AirframeClass@@QAEXW4FuelPump@1@@Z	; AirframeClass::SetFuelPump
PUBLIC	?GetFuelPump@AirframeClass@@QAE?AW4FuelPump@1@XZ ; AirframeClass::GetFuelPump
PUBLIC	?SetAirSource@AirframeClass@@QAEXW4AirSource@1@@Z ; AirframeClass::SetAirSource
PUBLIC	?GetAirSource@AirframeClass@@QAE?AW4AirSource@1@XZ ; AirframeClass::GetAirSource
PUBLIC	?GeneratorOff@AirframeClass@@QAEXW4Generator@1@@Z ; AirframeClass::GeneratorOff
PUBLIC	?GeneratorBreak@AirframeClass@@QAEXW4Generator@1@@Z ; AirframeClass::GeneratorBreak
PUBLIC	?Throtl@AirframeClass@@QAEMXZ			; AirframeClass::Throtl
PUBLIC	?Fuel@AirframeClass@@QAEMXZ			; AirframeClass::Fuel
PUBLIC	?ExternalFuel@AirframeClass@@QAEMXZ		; AirframeClass::ExternalFuel
PUBLIC	?SetFlag@AirframeClass@@QAEXH@Z			; AirframeClass::SetFlag
PUBLIC	?ClearFlag@AirframeClass@@QAEXH@Z		; AirframeClass::ClearFlag
PUBLIC	?IsSet@AirframeClass@@QBEHH@Z			; AirframeClass::IsSet
PUBLIC	?IsEmitting@RadarClass@@QAEHXZ			; RadarClass::IsEmitting
PUBLIC	?IsSet@RadarDopplerClass@@QAEHH@Z		; RadarDopplerClass::IsSet
PUBLIC	?ClearFlagBit@RadarDopplerClass@@QAEXH@Z	; RadarDopplerClass::ClearFlagBit
PUBLIC	?ToggleFlag@RadarDopplerClass@@QAEXH@Z		; RadarDopplerClass::ToggleFlag
PUBLIC	?twsTrackDirectory@RadarDopplerClass@@QAEPAVTWSTrackList@1@XZ ; RadarDopplerClass::twsTrackDirectory
PUBLIC	?GetCurrentState@CPButtonObject@@QBEHXZ		; CPButtonObject::GetCurrentState
PUBLIC	?ClearFault@FackClass@@QAEXW4type_FSubSystem@FaultClass@@W4type_FFunction@3@@Z ; FackClass::ClearFault
PUBLIC	?ClearAvioncFault@FackClass@@QAEXXZ		; FackClass::ClearAvioncFault
PUBLIC	?MasterCaution@FackClass@@QAEHXZ		; FackClass::MasterCaution
PUBLIC	?ClearMasterCaution@FackClass@@QAEXXZ		; FackClass::ClearMasterCaution
PUBLIC	?SetManWarnReset@FackClass@@QAEXXZ		; FackClass::SetManWarnReset
PUBLIC	?ClearWarnReset@FackClass@@QAEXXZ		; FackClass::ClearWarnReset
PUBLIC	?SetICPFlag@ICPClass@@QAEXH@Z			; ICPClass::SetICPFlag
PUBLIC	?ClearICPFlag@ICPClass@@QAEXH@Z			; ICPClass::ClearICPFlag
PUBLIC	?IsICPSet@ICPClass@@QAEHH@Z			; ICPClass::IsICPSet
PUBLIC	?GetICPPrimaryMode@ICPClass@@QAEJXZ		; ICPClass::GetICPPrimaryMode
PUBLIC	?GetICPSecondaryMode@ICPClass@@QAEJXZ		; ICPClass::GetICPSecondaryMode
PUBLIC	?GetActivePanel@CockpitManager@@QAEPAVCPPanel@@XZ ; CockpitManager::GetActivePanel
PUBLIC	?AltPanel@CockpitManager@@QAEHXZ		; CockpitManager::AltPanel
PUBLIC	?ResetMaxG@HudClass@@QAEXXZ			; HudClass::ResetMaxG
PUBLIC	?SetPage@KneeBoard@@QAEXW4Page@1@@Z		; KneeBoard::SetPage
PUBLIC	?GetPage@KneeBoard@@QAE?AW4Page@1@XZ		; KneeBoard::GetPage
PUBLIC	?Online@UIComms@@QAEHXZ				; UIComms::Online
PUBLIC	?ToggleFOV@MaverickDisplayClass@@QAEXXZ		; MaverickDisplayClass::ToggleFOV
PUBLIC	?TogglePolarity@LaserPodClass@@QAEXXZ		; LaserPodClass::TogglePolarity
PUBLIC	?IsPriority@PlayerRwrClass@@QAEHXZ		; PlayerRwrClass::IsPriority
PUBLIC	?TargetSep@PlayerRwrClass@@QAEHXZ		; PlayerRwrClass::TargetSep
PUBLIC	?ShowUnknowns@PlayerRwrClass@@QAEHXZ		; PlayerRwrClass::ShowUnknowns
PUBLIC	?ShowNaval@PlayerRwrClass@@QAEHXZ		; PlayerRwrClass::ShowNaval
PUBLIC	?ShowSearch@PlayerRwrClass@@QAEHXZ		; PlayerRwrClass::ShowSearch
PUBLIC	?ShowLowAltPriority@PlayerRwrClass@@QAEHXZ	; PlayerRwrClass::ShowLowAltPriority
PUBLIC	?getCurrentEngine@PilotInputs@@QAE?AW4Engine_t@1@XZ ; PilotInputs::getCurrentEngine
PUBLIC	?selectLeftEngine@PilotInputs@@QAEXXZ		; PilotInputs::selectLeftEngine
PUBLIC	?selectRightEngine@PilotInputs@@QAEXXZ		; PilotInputs::selectRightEngine
PUBLIC	?selectBothEngines@PilotInputs@@QAEXXZ		; PilotInputs::selectBothEngines
PUBLIC	?GetTFRMode@LantirnClass@@QAE?AW4TfrMode@1@XZ	; LantirnClass::GetTFRMode
PUBLIC	?SetTFRMode@LantirnClass@@QAEXW4TfrMode@1@@Z	; LantirnClass::SetTFRMode
PUBLIC	?AnalogIsUsed@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z ; SIMLIB_IO_CLASS::AnalogIsUsed
PUBLIC	?SimCursorFunc@?A0x786e660c@@YAXHHH@Z		; `anonymous namespace'::SimCursorFunc
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??_7error_category@std@@6B@			; std::error_category::`vftable'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_C@_07DCLBNMLN@generic?$AA@			; `string'
PUBLIC	??_C@_0O@BFJCFAAK@unknown?5error?$AA@		; `string'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream?$AA@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	; `string'
PUBLIC	??_7_System_error_category@std@@6B@		; std::_System_error_category::`vftable'
PUBLIC	??_C@_06FHFOAHML@system?$AA@			; `string'
PUBLIC	?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
PUBLIC	?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
PUBLIC	?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
PUBLIC	?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
PUBLIC	?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
PUBLIC	??_C@_0N@GJLGHHE@vtuneapi?4dll?$AA@		; `string'
PUBLIC	??_C@_0BA@NIOBKLHM@VtPauseSampling?$AA@		; `string'
PUBLIC	??_C@_0BB@CNJIDIOC@VtResumeSampling?$AA@	; `string'
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	?id@?$numpunct@_W@std@@2V0locale@2@A		; std::numpunct<wchar_t>::id
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_R4error_category@std@@6B@			; std::error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error_category@std@@6B@		; std::_System_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_System_error_category@std@@@8		; std::_System_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_System_error_category@std@@8		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error_category@std@@8		; std::_System_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error_category@std@@8	; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
PUBLIC	__real@3c23d70a
PUBLIC	__real@3c8efa34
PUBLIC	__real@3dcccccd
PUBLIC	__real@3e4ccccd
PUBLIC	__real@3e800000
PUBLIC	__real@3f000000
PUBLIC	__real@3f20d845
PUBLIC	__real@3f800000
PUBLIC	__real@3f8147ae
PUBLIC	__real@3fc00000
PUBLIC	__real@3fd80b03
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@3ff4000000000000
PUBLIC	__real@40000000
PUBLIC	__real@4040000000000000
PUBLIC	__real@40a00000
PUBLIC	__real@40e00000
PUBLIC	__real@41200000
PUBLIC	__real@41700000
PUBLIC	__real@42000000
PUBLIC	__real@42100000
PUBLIC	__real@42c80000
PUBLIC	__real@447a0000
PUBLIC	__real@44fa0000
PUBLIC	__real@47c34f80
PUBLIC	__real@be800000
PUBLIC	__real@bf000000
PUBLIC	__real@bf800000
PUBLIC	__real@c0000000
PUBLIC	__real@c0e00000
PUBLIC	__real@c4fa0000
PUBLIC	__xmm@41f00000000000000000000000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	_fabs:PROC
EXTRN	_rand:PROC
EXTRN	_memcpy:PROC
EXTRN	_strlen:PROC
EXTRN	_memmove:PROC
EXTRN	__imp__GetProcAddress@8:PROC
EXTRN	__imp__LoadLibraryA@4:PROC
EXTRN	?F4IsBadReadPtr@@YA_NPBXI@Z:PROC		; F4IsBadReadPtr
EXTRN	?F4IsBadCodePtr@@YA_NPAX@Z:PROC			; F4IsBadCodePtr
EXTRN	?F4IsBadWritePtr@@YA_NPAXI@Z:PROC		; F4IsBadWritePtr
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ:PROC ; VuSessionEntity::Game
EXTRN	?MakeFlagsDirty@FalconEntity@@QAEXXZ:PROC	; FalconEntity::MakeFlagsDirty
EXTRN	?GetGameType@FalconGameEntity@@QAE?AW4FalconGameType@@XZ:PROC ; FalconGameEntity::GetGameType
EXTRN	_F4HearVoices:PROC
EXTRN	?SetFlag@SimBaseClass@@QAEXH@Z:PROC		; SimBaseClass::SetFlag
EXTRN	?UnSetFlag@SimBaseClass@@QAEXH@Z:PROC		; SimBaseClass::UnSetFlag
EXTRN	?StepSOI@SimVehicleClass@@QAEXH@Z:PROC		; SimVehicleClass::StepSOI
EXTRN	?SetAcStatusBits@AircraftClass@@QAEXH@Z:PROC	; AircraftClass::SetAcStatusBits
EXTRN	?ClearAcStatusBits@AircraftClass@@QAEXH@Z:PROC	; AircraftClass::ClearAcStatusBits
EXTRN	?SwitchINSToAlign@AircraftClass@@QAEXXZ:PROC	; AircraftClass::SwitchINSToAlign
EXTRN	?SwitchINSToNav@AircraftClass@@QAEXXZ:PROC	; AircraftClass::SwitchINSToNav
EXTRN	?SwitchINSToOff@AircraftClass@@QAEXXZ:PROC	; AircraftClass::SwitchINSToOff
EXTRN	?SwitchINSToInFLT@AircraftClass@@QAEXXZ:PROC	; AircraftClass::SwitchINSToInFLT
EXTRN	?AddAVTRSeconds@AircraftClass@@QAEXXZ:PROC	; AircraftClass::AddAVTRSeconds
EXTRN	?SetAutopilot@AircraftClass@@QAEXW4AutoPilotType@1@@Z:PROC ; AircraftClass::SetAutopilot
EXTRN	?DropEWS@AircraftClass@@QAEXXZ:PROC		; AircraftClass::DropEWS
EXTRN	?SetAPParameters@AircraftClass@@QAEXXZ:PROC	; AircraftClass::SetAPParameters
EXTRN	?SetNewRoll@AircraftClass@@QAEXXZ:PROC		; AircraftClass::SetNewRoll
EXTRN	?SetNewPitch@AircraftClass@@QAEXXZ:PROC		; AircraftClass::SetNewPitch
EXTRN	?SetNewAlt@AircraftClass@@QAEXXZ:PROC		; AircraftClass::SetNewAlt
EXTRN	?StepSeatArm@AircraftClass@@QAEXXZ:PROC		; AircraftClass::StepSeatArm
EXTRN	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z:PROC ; AircraftClass::HasPower
EXTRN	?IncMainPower@AircraftClass@@QAEXXZ:PROC	; AircraftClass::IncMainPower
EXTRN	?DecMainPower@AircraftClass@@QAEXXZ:PROC	; AircraftClass::DecMainPower
EXTRN	?IncEWSPGM@AircraftClass@@QAEXXZ:PROC		; AircraftClass::IncEWSPGM
EXTRN	?DecEWSPGM@AircraftClass@@QAEXXZ:PROC		; AircraftClass::DecEWSPGM
EXTRN	?DecEWSProg@AircraftClass@@QAEXXZ:PROC		; AircraftClass::DecEWSProg
EXTRN	?IncEWSProg@AircraftClass@@QAEXXZ:PROC		; AircraftClass::IncEWSProg
EXTRN	?ToggleBetty@AircraftClass@@QAEXXZ:PROC		; AircraftClass::ToggleBetty
EXTRN	?ToggleAutopilot@AircraftClass@@QAEXXZ:PROC	; AircraftClass::ToggleAutopilot
EXTRN	?FalconSendMessage@@YAXPAVVuMessage@@H@Z:PROC	; FalconSendMessage
EXTRN	?TogglePause@SimulationDriver@@QAEXXZ:PROC	; SimulationDriver::TogglePause
EXTRN	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ:PROC ; SimulationDriver::GetPlayerAircraft
EXTRN	??_Eerror_category@std@@UAEPAXI@Z:PROC		; std::error_category::`vector deleting destructor'
EXTRN	?_Syserror_map@std@@YAPBDH@Z:PROC		; std::_Syserror_map
EXTRN	?_Winerror_map@std@@YAPBDH@Z:PROC		; std::_Winerror_map
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_E_System_error_category@std@@UAEPAXI@Z:PROC	; std::_System_error_category::`vector deleting destructor'
EXTRN	?SetOTWDisplayMode@OTWDriverClass@@QAEXW4OTWDisplayMode@1@@Z:PROC ; OTWDriverClass::SetOTWDisplayMode
EXTRN	?GetOTWDisplayMode@OTWDriverClass@@QAE?AW4OTWDisplayMode@1@XZ:PROC ; OTWDriverClass::GetOTWDisplayMode
EXTRN	?SetDetail@OTWDriverClass@@QAEXH@Z:PROC		; OTWDriverClass::SetDetail
EXTRN	?SetFOV@OTWDriverClass@@QAEXM@Z:PROC		; OTWDriverClass::SetFOV
EXTRN	?GetFOV@OTWDriverClass@@QAEMXZ:PROC		; OTWDriverClass::GetFOV
EXTRN	?ViewTiltUp@OTWDriverClass@@QAEXXZ:PROC		; OTWDriverClass::ViewTiltUp
EXTRN	?ViewTiltDown@OTWDriverClass@@QAEXXZ:PROC	; OTWDriverClass::ViewTiltDown
EXTRN	?ViewTiltHold@OTWDriverClass@@QAEXXZ:PROC	; OTWDriverClass::ViewTiltHold
EXTRN	?ViewSpinLeft@OTWDriverClass@@QAEXXZ:PROC	; OTWDriverClass::ViewSpinLeft
EXTRN	?ViewSpinRight@OTWDriverClass@@QAEXXZ:PROC	; OTWDriverClass::ViewSpinRight
EXTRN	?ViewSpinHold@OTWDriverClass@@QAEXXZ:PROC	; OTWDriverClass::ViewSpinHold
EXTRN	?ViewReset@OTWDriverClass@@QAEXXZ:PROC		; OTWDriverClass::ViewReset
EXTRN	?ViewZoomIn@OTWDriverClass@@QAEXXZ:PROC		; OTWDriverClass::ViewZoomIn
EXTRN	?ViewZoomOut@OTWDriverClass@@QAEXXZ:PROC	; OTWDriverClass::ViewZoomOut
EXTRN	?NVGToggle@OTWDriverClass@@QAEXXZ:PROC		; OTWDriverClass::NVGToggle
EXTRN	?IDTagToggle@OTWDriverClass@@QAEXXZ:PROC	; OTWDriverClass::IDTagToggle
EXTRN	?CampTagToggle@OTWDriverClass@@QAEXXZ:PROC	; OTWDriverClass::CampTagToggle
EXTRN	?ViewStepNext@OTWDriverClass@@QAEXXZ:PROC	; OTWDriverClass::ViewStepNext
EXTRN	?ViewStepPrev@OTWDriverClass@@QAEXXZ:PROC	; OTWDriverClass::ViewStepPrev
EXTRN	?TargetStepNext@OTWDriverClass@@QAEXXZ:PROC	; OTWDriverClass::TargetStepNext
EXTRN	?TargetStepPrev@OTWDriverClass@@QAEXXZ:PROC	; OTWDriverClass::TargetStepPrev
EXTRN	?ToggleGLOC@OTWDriverClass@@QAEXXZ:PROC		; OTWDriverClass::ToggleGLOC
EXTRN	?StepHeadingScale@OTWDriverClass@@QAEXXZ:PROC	; OTWDriverClass::StepHeadingScale
EXTRN	?EndFlight@OTWDriverClass@@QAEXXZ:PROC		; OTWDriverClass::EndFlight
EXTRN	?ToggleBilinearFilter@OTWDriverClass@@QAEXXZ:PROC ; OTWDriverClass::ToggleBilinearFilter
EXTRN	?ToggleEyeFly@OTWDriverClass@@QAEXXZ:PROC	; OTWDriverClass::ToggleEyeFly
EXTRN	?ToggleShading@OTWDriverClass@@QAEXXZ:PROC	; OTWDriverClass::ToggleShading
EXTRN	?ToggleHaze@OTWDriverClass@@QAEXXZ:PROC		; OTWDriverClass::ToggleHaze
EXTRN	?ToggleLocationDisplay@OTWDriverClass@@QAEXXZ:PROC ; OTWDriverClass::ToggleLocationDisplay
EXTRN	?ToggleAeroDisplay@OTWDriverClass@@QAEXXZ:PROC	; OTWDriverClass::ToggleAeroDisplay
EXTRN	?ToggleFlapDisplay@OTWDriverClass@@QAEXXZ:PROC	; OTWDriverClass::ToggleFlapDisplay
EXTRN	?ToggleEngineDisplay@OTWDriverClass@@QAEXXZ:PROC ; OTWDriverClass::ToggleEngineDisplay
EXTRN	?StartLocationEntry@OTWDriverClass@@QAEXXZ:PROC	; OTWDriverClass::StartLocationEntry
EXTRN	?ScaleDown@OTWDriverClass@@QAEXXZ:PROC		; OTWDriverClass::ScaleDown
EXTRN	?ScaleUp@OTWDriverClass@@QAEXXZ:PROC		; OTWDriverClass::ScaleUp
EXTRN	?DetailDown@OTWDriverClass@@QAEXXZ:PROC		; OTWDriverClass::DetailDown
EXTRN	?DetailUp@OTWDriverClass@@QAEXXZ:PROC		; OTWDriverClass::DetailUp
EXTRN	?ToggleWeather@OTWDriverClass@@QAEXXZ:PROC	; OTWDriverClass::ToggleWeather
EXTRN	?RescaleAllObjects@OTWDriverClass@@QAEXXZ:PROC	; OTWDriverClass::RescaleAllObjects
EXTRN	?GlanceForward@OTWDriverClass@@QAEXXZ:PROC	; OTWDriverClass::GlanceForward
EXTRN	?GlanceAft@OTWDriverClass@@QAEXXZ:PROC		; OTWDriverClass::GlanceAft
EXTRN	?EyeFlyStateStep@OTWDriverClass@@QAEXXZ:PROC	; OTWDriverClass::EyeFlyStateStep
EXTRN	?ToggleActionCamera@OTWDriverClass@@QAEXXZ:PROC	; OTWDriverClass::ToggleActionCamera
EXTRN	?toggleDisplaceCamera@OTWDriverClass@@QAEXXZ:PROC ; OTWDriverClass::toggleDisplaceCamera
EXTRN	?ToggleInfoBar@OTWDriverClass@@QAEXXZ:PROC	; OTWDriverClass::ToggleInfoBar
EXTRN	?ToggleSubTitles@OTWDriverClass@@QAEXXZ:PROC	; OTWDriverClass::ToggleSubTitles
EXTRN	?Padlock_SetPriority@OTWDriverClass@@QAEXW4PadlockPriority@1@@Z:PROC ; OTWDriverClass::Padlock_SetPriority
EXTRN	?ToggleSidebar@OTWDriverClass@@QAEXXZ:PROC	; OTWDriverClass::ToggleSidebar
EXTRN	?SetNewMasterMode@MFDClass@@QAEXH@Z:PROC	; MFDClass::SetNewMasterMode
EXTRN	?ButtonPushed@MFDClass@@QAEXHH@Z:PROC		; MFDClass::ButtonPushed
EXTRN	?SetNewMode@MFDClass@@QAEXW4MfdMode@1@@Z:PROC	; MFDClass::SetNewMode
EXTRN	?IncreaseBrightness@MFDClass@@QAEXXZ:PROC	; MFDClass::IncreaseBrightness
EXTRN	?DecreaseBrightness@MFDClass@@QAEXXZ:PROC	; MFDClass::DecreaseBrightness
EXTRN	?MFDSwapDisplays@@YAXXZ:PROC			; MFDSwapDisplays
EXTRN	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z:PROC ; FindSensor
EXTRN	?ClearOverrideMode@FireControlComputer@@QAEXXZ:PROC ; FireControlComputer::ClearOverrideMode
EXTRN	?NextSubMode@FireControlComputer@@QAEXXZ:PROC	; FireControlComputer::NextSubMode
EXTRN	?SetMasterMode@FireControlComputer@@QAEXW4FCCMasterMode@1@@Z:PROC ; FireControlComputer::SetMasterMode
EXTRN	?WeaponStep@FireControlComputer@@QAEXXZ:PROC	; FireControlComputer::WeaponStep
EXTRN	?GetMainMasterMode@FireControlComputer@@QAE?AW4MASTERMODES@@XZ:PROC ; FireControlComputer::GetMainMasterMode
EXTRN	?ToggleLaserArm@FireControlComputer@@QAEXXZ:PROC ; FireControlComputer::ToggleLaserArm
EXTRN	?ToggleHSDZoom@FireControlComputer@@QAEXXZ:PROC	; FireControlComputer::ToggleHSDZoom
EXTRN	?EnterAAMasterMode@FireControlComputer@@QAEXXZ:PROC ; FireControlComputer::EnterAAMasterMode
EXTRN	?EnterAGMasterMode@FireControlComputer@@QAEXXZ:PROC ; FireControlComputer::EnterAGMasterMode
EXTRN	?EnterMissileOverrideMode@FireControlComputer@@QAEXXZ:PROC ; FireControlComputer::EnterMissileOverrideMode
EXTRN	?EnterDogfightMode@FireControlComputer@@QAEXXZ:PROC ; FireControlComputer::EnterDogfightMode
EXTRN	?StepMasterArm@SMSBaseClass@@QAEXXZ:PROC	; SMSBaseClass::StepMasterArm
EXTRN	?StepCatIII@SMSBaseClass@@QAEXXZ:PROC		; SMSBaseClass::StepCatIII
EXTRN	?StepMavSubMode@SMSBaseClass@@QAEX_N@Z:PROC	; SMSBaseClass::StepMavSubMode
EXTRN	?EmergencyJettison@SMSClass@@QAEXXZ:PROC	; SMSClass::EmergencyJettison
EXTRN	?IncrementRippleCount@SMSClass@@QAEXXZ:PROC	; SMSClass::IncrementRippleCount
EXTRN	?DecrementRippleCount@SMSClass@@QAEXXZ:PROC	; SMSClass::DecrementRippleCount
EXTRN	?IncrementRippleInterval@SMSClass@@QAEXXZ:PROC	; SMSClass::IncrementRippleInterval
EXTRN	?DecrementRippleInterval@SMSClass@@QAEXXZ:PROC	; SMSClass::DecrementRippleInterval
EXTRN	?IncrementBurstHeight@SMSClass@@QAEXXZ:PROC	; SMSClass::IncrementBurstHeight
EXTRN	?DecrementBurstHeight@SMSClass@@QAEXXZ:PROC	; SMSClass::DecrementBurstHeight
EXTRN	?StepAAWeapon@SMSClass@@QAEXXZ:PROC		; SMSClass::StepAAWeapon
EXTRN	?StepAGWeapon@SMSClass@@QAEXXZ:PROC		; SMSClass::StepAGWeapon
EXTRN	?SetDisplayMode@SmsDrawable@@QAEXW4SmsDisplayMode@1@@Z:PROC ; SmsDrawable::SetDisplayMode
EXTRN	?StepDisplayMode@SmsDrawable@@QAEXXZ:PROC	; SmsDrawable::StepDisplayMode
EXTRN	?TEFClose@AirframeClass@@QAEXXZ:PROC		; AirframeClass::TEFClose
EXTRN	?TEFMax@AirframeClass@@QAEXXZ:PROC		; AirframeClass::TEFMax
EXTRN	?TEFInc@AirframeClass@@QAEXXZ:PROC		; AirframeClass::TEFInc
EXTRN	?TEFDec@AirframeClass@@QAEXXZ:PROC		; AirframeClass::TEFDec
EXTRN	?LEFClose@AirframeClass@@QAEXXZ:PROC		; AirframeClass::LEFClose
EXTRN	?LEFMax@AirframeClass@@QAEXXZ:PROC		; AirframeClass::LEFMax
EXTRN	?LEFInc@AirframeClass@@QAEXXZ:PROC		; AirframeClass::LEFInc
EXTRN	?LEFDec@AirframeClass@@QAEXXZ:PROC		; AirframeClass::LEFDec
EXTRN	?CanopyToggle@AirframeClass@@QAEXXZ:PROC	; AirframeClass::CanopyToggle
EXTRN	?StepEpuSwitch@AirframeClass@@QAEXXZ:PROC	; AirframeClass::StepEpuSwitch
EXTRN	?HydrBreak@AirframeClass@@QAEXH@Z:PROC		; AirframeClass::HydrBreak
EXTRN	?JfsEngineStart@AirframeClass@@QAEXXZ:PROC	; AirframeClass::JfsEngineStart
EXTRN	?TogglePB@AirframeClass@@QAEXXZ:PROC		; AirframeClass::TogglePB
EXTRN	?ToggleHook@AirframeClass@@QAEXXZ:PROC		; AirframeClass::ToggleHook
EXTRN	?HookUp@AirframeClass@@QAEXXZ:PROC		; AirframeClass::HookUp
EXTRN	?HookDown@AirframeClass@@QAEXXZ:PROC		; AirframeClass::HookDown
EXTRN	?IncFuelSwitch@AirframeClass@@QAEXXZ:PROC	; AirframeClass::IncFuelSwitch
EXTRN	?DecFuelSwitch@AirframeClass@@QAEXXZ:PROC	; AirframeClass::DecFuelSwitch
EXTRN	?IncFuelPump@AirframeClass@@QAEXXZ:PROC		; AirframeClass::IncFuelPump
EXTRN	?DecFuelPump@AirframeClass@@QAEXXZ:PROC		; AirframeClass::DecFuelPump
EXTRN	?IncAirSource@AirframeClass@@QAEXXZ:PROC	; AirframeClass::IncAirSource
EXTRN	?DecAirSource@AirframeClass@@QAEXXZ:PROC	; AirframeClass::DecAirSource
EXTRN	?AddFuel@AirframeClass@@QAEHM@Z:PROC		; AirframeClass::AddFuel
EXTRN	?SetVoiceVolume@@YAXH@Z:PROC			; SetVoiceVolume
EXTRN	??0FalconDLinkMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z:PROC ; FalconDLinkMessage::FalconDLinkMessage
EXTRN	?ToggleUHFSrc@NavigationSystem@@QAEXXZ:PROC	; NavigationSystem::ToggleUHFSrc
EXTRN	?SetUHFSrc@NavigationSystem@@QAEXW4UHF_Mode_Type@1@@Z:PROC ; NavigationSystem::SetUHFSrc
EXTRN	?SetDomain@NavigationSystem@@QAEXW4Tacan_Channel_Src@1@W4Domain@TacanList@@@Z:PROC ; NavigationSystem::SetDomain
EXTRN	?GetDomain@NavigationSystem@@QAE?AW4Domain@TacanList@@W4Tacan_Channel_Src@1@@Z:PROC ; NavigationSystem::GetDomain
EXTRN	?ToggleDomain@NavigationSystem@@QAE?AW4Domain@TacanList@@W4Tacan_Channel_Src@1@@Z:PROC ; NavigationSystem::ToggleDomain
EXTRN	?ToggleControlSrc@NavigationSystem@@QAEXXZ:PROC	; NavigationSystem::ToggleControlSrc
EXTRN	?GetControlSrc@NavigationSystem@@QAE?AW4Tacan_Channel_Src@1@XZ:PROC ; NavigationSystem::GetControlSrc
EXTRN	?SetControlSrc@NavigationSystem@@QAEXW4Tacan_Channel_Src@1@@Z:PROC ; NavigationSystem::SetControlSrc
EXTRN	?SetInstrumentMode@NavigationSystem@@QAEXW4Instrument_Mode@1@@Z:PROC ; NavigationSystem::SetInstrumentMode
EXTRN	?GetInstrumentMode@NavigationSystem@@QAE?AW4Instrument_Mode@1@XZ:PROC ; NavigationSystem::GetInstrumentMode
EXTRN	?StepInstrumentMode@NavigationSystem@@QAEXXZ:PROC ; NavigationSystem::StepInstrumentMode
EXTRN	?GetTacanChannel@NavigationSystem@@QAEHW4Tacan_Channel_Src@1@H@Z:PROC ; NavigationSystem::GetTacanChannel
EXTRN	?GetTacanBand@NavigationSystem@@QAE?AW4StationSet@TacanList@@W4Tacan_Channel_Src@1@@Z:PROC ; NavigationSystem::GetTacanBand
EXTRN	?StepTacanChannelDigit@NavigationSystem@@QAEXW4Tacan_Channel_Src@1@HH@Z:PROC ; NavigationSystem::StepTacanChannelDigit
EXTRN	?StepTacanBand@NavigationSystem@@QAEXW4Tacan_Channel_Src@1@@Z:PROC ; NavigationSystem::StepTacanBand
EXTRN	?Transmit@@YAXH@Z:PROC				; Transmit
EXTRN	?DirectVoiceSetVolume@@YAXH@Z:PROC		; DirectVoiceSetVolume
EXTRN	?ToggleFullScreen@FalconDisplayConfiguration@@QAEXXZ:PROC ; FalconDisplayConfiguration::ToggleFullScreen
EXTRN	?ClearFault@FaultClass@@QAEXW4type_FSubSystem@1@W4type_FFunction@1@@Z:PROC ; FaultClass::ClearFault
EXTRN	?ClearFault@FackClass@@QAEXW4type_CSubSystem@@@Z:PROC ; FackClass::ClearFault
EXTRN	?GetFault@FackClass@@QAEHW4type_FSubSystem@FaultClass@@@Z:PROC ; FackClass::GetFault
EXTRN	?RandomFailure@FackClass@@QAEXXZ:PROC		; FackClass::RandomFailure
EXTRN	?SetCaution@FackClass@@QAEXW4type_CSubSystem@@@Z:PROC ; FackClass::SetCaution
EXTRN	?HandleInput@ICPClass@@QAEXHPAVCPButtonObject@@@Z:PROC ; ICPClass::HandleInput
EXTRN	?SetMFDButtonState@CPMisc@@QAEXHHH@Z:PROC	; CPMisc::SetMFDButtonState
EXTRN	?SetMasterCautionEvent@CPMisc@@QAEXXZ:PROC	; CPMisc::SetMasterCautionEvent
EXTRN	?GetButtonPointer@CockpitManager@@QAEPAVCPButtonObject@@H@Z:PROC ; CockpitManager::GetButtonPointer
EXTRN	?SetActivePanel@CockpitManager@@QAE_NH@Z:PROC	; CockpitManager::SetActivePanel
EXTRN	?UpdatePalette@CockpitManager@@QAEXXZ:PROC	; CockpitManager::UpdatePalette
EXTRN	?LoadCockpitDefaults@CockpitManager@@QAEXXZ:PROC ; CockpitManager::LoadCockpitDefaults
EXTRN	?SaveCockpitDefaults@CockpitManager@@QAEXXZ:PROC ; CockpitManager::SaveCockpitDefaults
EXTRN	?SetMasterVolume@CSoundMgr@@QAEJJ@Z:PROC	; CSoundMgr::SetMasterVolume
EXTRN	?GetMasterVolume@CSoundMgr@@QAEJXZ:PROC		; CSoundMgr::GetMasterVolume
EXTRN	?HudColorStep@HudClass@@QAEXXZ:PROC		; HudClass::HudColorStep
EXTRN	?SetLightLevel@HudClass@@QAEXXZ:PROC		; HudClass::SetLightLevel
EXTRN	?SetContrastLevel@HudClass@@QAEXXZ:PROC		; HudClass::SetContrastLevel
EXTRN	?GetScalesSwitch@HudClass@@QAEHXZ:PROC		; HudClass::GetScalesSwitch
EXTRN	?SetScalesSwitch@HudClass@@QAEXW4ScalesSwitch@1@@Z:PROC ; HudClass::SetScalesSwitch
EXTRN	?CycleScalesSwitch@HudClass@@QAEXXZ:PROC	; HudClass::CycleScalesSwitch
EXTRN	?GetFPMSwitch@HudClass@@QAEHXZ:PROC		; HudClass::GetFPMSwitch
EXTRN	?SetFPMSwitch@HudClass@@QAEXW4FPMSwitch@1@@Z:PROC ; HudClass::SetFPMSwitch
EXTRN	?CycleFPMSwitch@HudClass@@QAEXXZ:PROC		; HudClass::CycleFPMSwitch
EXTRN	?GetDriftCOSwitch@HudClass@@QAEHXZ:PROC		; HudClass::GetDriftCOSwitch
EXTRN	?SetDriftCOSwitch@HudClass@@QAEXW4DriftCOSwitch@1@@Z:PROC ; HudClass::SetDriftCOSwitch
EXTRN	?CycleDriftCOSwitch@HudClass@@QAEXXZ:PROC	; HudClass::CycleDriftCOSwitch
EXTRN	?GetDEDSwitch@HudClass@@QAEHXZ:PROC		; HudClass::GetDEDSwitch
EXTRN	?SetDEDSwitch@HudClass@@QAEXW4DEDSwitch@1@@Z:PROC ; HudClass::SetDEDSwitch
EXTRN	?CycleDEDSwitch@HudClass@@QAEXXZ:PROC		; HudClass::CycleDEDSwitch
EXTRN	?GetVelocitySwitch@HudClass@@QAEHXZ:PROC	; HudClass::GetVelocitySwitch
EXTRN	?SetVelocitySwitch@HudClass@@QAEXW4VelocitySwitch@1@@Z:PROC ; HudClass::SetVelocitySwitch
EXTRN	?CycleVelocitySwitch@HudClass@@QAEXXZ:PROC	; HudClass::CycleVelocitySwitch
EXTRN	?GetRadarSwitch@HudClass@@QAEHXZ:PROC		; HudClass::GetRadarSwitch
EXTRN	?SetRadarSwitch@HudClass@@QAEXW4RadarSwitch@1@@Z:PROC ; HudClass::SetRadarSwitch
EXTRN	?CycleRadarSwitch@HudClass@@QAEXXZ:PROC		; HudClass::CycleRadarSwitch
EXTRN	?GetBrightnessSwitch@HudClass@@QAEHXZ:PROC	; HudClass::GetBrightnessSwitch
EXTRN	?SetBrightnessSwitch@HudClass@@QAEXW4BrightnessSwitch@1@@Z:PROC ; HudClass::SetBrightnessSwitch
EXTRN	?CycleBrightnessSwitch@HudClass@@QAEXXZ:PROC	; HudClass::CycleBrightnessSwitch
EXTRN	?CycleBrightnessSwitchUp@HudClass@@QAEXXZ:PROC	; HudClass::CycleBrightnessSwitchUp
EXTRN	?CycleBrightnessSwitchDown@HudClass@@QAEXXZ:PROC ; HudClass::CycleBrightnessSwitchDown
EXTRN	?MoveRetCenter@HudClass@@QAEXXZ:PROC		; HudClass::MoveRetCenter
EXTRN	?IncState@CPHsi@@QAEXW4HSIButtonStates@1@M@Z:PROC ; CPHsi::IncState
EXTRN	?DecState@CPHsi@@QAEXW4HSIButtonStates@1@M@Z:PROC ; CPHsi::DecState
EXTRN	?GetValue@CPHsi@@QAEMW4HSIValues@1@@Z:PROC	; CPHsi::GetValue
EXTRN	?ToggleFOV@LaserPodClass@@QAEXXZ:PROC		; LaserPodClass::ToggleFOV
EXTRN	?BoresightTarget@HarmTargetingPod@@QAEXXZ:PROC	; HarmTargetingPod::BoresightTarget
EXTRN	?NextTarget@HarmTargetingPod@@QAEXXZ:PROC	; HarmTargetingPod::NextTarget
EXTRN	?PrevTarget@HarmTargetingPod@@QAEXXZ:PROC	; HarmTargetingPod::PrevTarget
EXTRN	??0FalconTrackMessage@@QAE@HVVU_ID@@PAVVuTargetEntity@@E@Z:PROC ; FalconTrackMessage::FalconTrackMessage
EXTRN	?Reset@PilotInputs@@QAEXXZ:PROC			; PilotInputs::Reset
EXTRN	?cycleCurrentEngine@PilotInputs@@QAEXXZ:PROC	; PilotInputs::cycleCurrentEngine
EXTRN	?ToggleFLIR@LantirnClass@@QAEXXZ:PROC		; LantirnClass::ToggleFLIR
EXTRN	?SetTimeCompression@@YAXH@Z:PROC		; SetTimeCompression
EXTRN	?SetDOFangle@DrawableBSP@@QAEXHM@Z:PROC		; DrawableBSP::SetDOFangle
EXTRN	?SetSwitchMask@DrawableBSP@@QAEXHK@Z:PROC	; DrawableBSP::SetSwitchMask
EXTRN	?RequestPlayerDivert@@YAXXZ:PROC		; RequestPlayerDivert
EXTRN	?FindLaserPod@@YAPAVSensorClass@@PAVSimMoverClass@@@Z:PROC ; FindLaserPod
EXTRN	?Previous@WinAmpFrontEnd@@QAEXXZ:PROC		; WinAmpFrontEnd::Previous
EXTRN	?Start@WinAmpFrontEnd@@QAEXXZ:PROC		; WinAmpFrontEnd::Start
EXTRN	?Stop@WinAmpFrontEnd@@QAEXXZ:PROC		; WinAmpFrontEnd::Stop
EXTRN	?Next@WinAmpFrontEnd@@QAEXXZ:PROC		; WinAmpFrontEnd::Next
EXTRN	?VolUp@WinAmpFrontEnd@@QAEXXZ:PROC		; WinAmpFrontEnd::VolUp
EXTRN	?VolDown@WinAmpFrontEnd@@QAEXXZ:PROC		; WinAmpFrontEnd::VolDown
EXTRN	?TogglePlayback@WinAmpFrontEnd@@QAEXXZ:PROC	; WinAmpFrontEnd::TogglePlayback
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A:DWORD ; vuLocalSessionEntity
EXTRN	?SimLibElapsedTime@@3KA:DWORD			; SimLibElapsedTime
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?SimDriver@@3VSimulationDriver@@A:BYTE		; SimDriver
EXTRN	?PlayerOptions@@3VPlayerOptionsClass@@A:BYTE	; PlayerOptions
EXTRN	?CommandsKeyCombo@@3HA:DWORD			; CommandsKeyCombo
EXTRN	?CommandsKeyComboMod@@3HA:DWORD			; CommandsKeyComboMod
EXTRN	?OTWDriver@@3VOTWDriverClass@@A:BYTE		; OTWDriver
EXTRN	?g_bRealisticAvionics@@3_NA:BYTE		; g_bRealisticAvionics
EXTRN	?MfdDisplay@@3PAPAVMFDClass@@A:BYTE		; MfdDisplay
EXTRN	?gNavigationSys@@3PAVNavigationSystem@@A:DWORD	; gNavigationSys
EXTRN	?FalconDisplay@@3VFalconDisplayConfiguration@@A:BYTE ; FalconDisplay
EXTRN	?cockpitFlightData@@3VFlightData@@A:BYTE	; cockpitFlightData
EXTRN	?gSoundDriver@@3PAVCSoundMgr@@A:DWORD		; gSoundDriver
EXTRN	?TheHud@@3PAVHudClass@@A:DWORD			; TheHud
EXTRN	?gCommsMgr@@3PAVUIComms@@A:DWORD		; gCommsMgr
EXTRN	?PitLightLevel@ColorBankClass@@2HA:DWORD	; ColorBankClass::PitLightLevel
EXTRN	?UserStickInputs@@3VPilotInputs@@A:BYTE		; UserStickInputs
EXTRN	?theLantirn@@3PAVLantirnClass@@A:DWORD		; theLantirn
EXTRN	?gameCompressionRatio@@3HA:DWORD		; gameCompressionRatio
EXTRN	?IO@@3VSIMLIB_IO_CLASS@@A:BYTE			; IO
EXTRN	?drawLabels@DrawableBSP@@2HA:DWORD		; DrawableBSP::drawLabels
EXTRN	?ShowVersion@@3HA:DWORD				; ShowVersion
EXTRN	?gSpeedyGonzales@@3MA:DWORD			; gSpeedyGonzales
EXTRN	?g_bEnableTrackIR@@3_NA:BYTE			; g_bEnableTrackIR
EXTRN	?g_bTrackIRon@@3_NA:BYTE			; g_bTrackIRon
EXTRN	?supercruise@@3HA:DWORD				; supercruise
EXTRN	?curColorIdx@@3HA:DWORD				; curColorIdx
EXTRN	?g_bMLU@@3_NA:BYTE				; g_bMLU
EXTRN	?g_bIFF@@3_NA:BYTE				; g_bIFF
EXTRN	?g_bINS@@3_NA:BYTE				; g_bINS
EXTRN	?g_fFOVIncrement@@3MA:DWORD			; g_fFOVIncrement
EXTRN	?g_fMaximumFOV@@3MA:DWORD			; g_fMaximumFOV
EXTRN	?g_fDefaultFOV@@3MA:DWORD			; g_fDefaultFOV
EXTRN	?g_fMinimumFOV@@3MA:DWORD			; g_fMinimumFOV
EXTRN	?g_fNarrowFOV@@3MA:DWORD			; g_fNarrowFOV
EXTRN	?g_fWideviewFOV@@3MA:DWORD			; g_fWideviewFOV
EXTRN	?g_b3DClickableCockpitDebug@@3_NA:BYTE		; g_b3DClickableCockpitDebug
EXTRN	?g_nMaxSimTimeAcceleration@@3HA:DWORD		; g_nMaxSimTimeAcceleration
EXTRN	?g_nShowDebugLabels@@3HA:DWORD			; g_nShowDebugLabels
EXTRN	?g_nMaxDebugLabel@@3HA:DWORD			; g_nMaxDebugLabel
EXTRN	?g_f3DHeadTilt@@3MA:DWORD			; g_f3DHeadTilt
EXTRN	?g_f3DPitFOV@@3MA:DWORD				; g_f3DPitFOV
EXTRN	?g_fAFRudderRight@@3MA:DWORD			; g_fAFRudderRight
EXTRN	?g_fAFRudderLeft@@3MA:DWORD			; g_fAFRudderLeft
EXTRN	?g_fAFThrottleDown@@3MA:DWORD			; g_fAFThrottleDown
EXTRN	?g_fAFThrottleUp@@3MA:DWORD			; g_fAFThrottleUp
EXTRN	?g_fAFAileronLeft@@3MA:DWORD			; g_fAFAileronLeft
EXTRN	?g_fAFAileronRight@@3MA:DWORD			; g_fAFAileronRight
EXTRN	?g_fAFElevatorDown@@3MA:DWORD			; g_fAFElevatorDown
EXTRN	?g_fAFElevatorUp@@3MA:DWORD			; g_fAFElevatorUp
EXTRN	?g_bUseAnalogIdleCutoff@@3_NA:BYTE		; g_bUseAnalogIdleCutoff
EXTRN	?g_bAGRadarFixes@@3_NA:BYTE			; g_bAGRadarFixes
EXTRN	?g_bExtViewOnGround@@3_NA:BYTE			; g_bExtViewOnGround
EXTRN	?gRefreshScoresList@@3JA:DWORD			; gRefreshScoresList
EXTRN	?g_bPilotEntertainment@@3_NA:BYTE		; g_bPilotEntertainment
EXTRN	?winamp@@3PAVWinAmpFrontEnd@@A:DWORD		; winamp
EXTRN	?clickableMouseMode@@3_NA:BYTE			; clickableMouseMode
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
_BSS	SEGMENT
?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Generic_object
_BSS	ENDS
;	COMDAT ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
_BSS	SEGMENT
?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Iostream_object
_BSS	ENDS
;	COMDAT ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
_BSS	SEGMENT
?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_System_object
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
_BSS	ENDS
;	COMDAT ?mslsteptimer@?1??SimMissileStep@@YAXKHPAX@Z@4KA
_BSS	SEGMENT
?mslsteptimer@?1??SimMissileStep@@YAXKHPAX@Z@4KA DD 01H DUP (?) ; `SimMissileStep'::`2'::mslsteptimer
_BSS	ENDS
;	COMDAT ?realEWSProgNum@?1??SimDropChaff@@YAXKHPAX@Z@4IA
_BSS	SEGMENT
?realEWSProgNum@?1??SimDropChaff@@YAXKHPAX@Z@4IA DD 01H DUP (?) ; `SimDropChaff'::`2'::realEWSProgNum
_BSS	ENDS
;	COMDAT ?thrrevtimer@?1??SimWheelBrakes@@YAXKHPAX@Z@4KA
_BSS	SEGMENT
?thrrevtimer@?1??SimWheelBrakes@@YAXKHPAX@Z@4KA DD 01H DUP (?) ; `SimWheelBrakes'::`2'::thrrevtimer
_BSS	ENDS
;	COMDAT ?tmstimer@?1??SimTMSRight@@YAXKHPAX@Z@4KA
_BSS	SEGMENT
?tmstimer@?1??SimTMSRight@@YAXKHPAX@Z@4KA DD 01H DUP (?) ; `SimTMSRight'::`2'::tmstimer
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@_W@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@_W@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<wchar_t>::id
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@c4fa0000
CONST	SEGMENT
__real@c4fa0000 DD 0c4fa0000r			; -2000
CONST	ENDS
;	COMDAT __real@c0e00000
CONST	SEGMENT
__real@c0e00000 DD 0c0e00000r			; -7
CONST	ENDS
;	COMDAT __real@c0000000
CONST	SEGMENT
__real@c0000000 DD 0c0000000r			; -2
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@bf000000
CONST	SEGMENT
__real@bf000000 DD 0bf000000r			; -0.5
CONST	ENDS
;	COMDAT __real@be800000
CONST	SEGMENT
__real@be800000 DD 0be800000r			; -0.25
CONST	ENDS
;	COMDAT __real@47c34f80
CONST	SEGMENT
__real@47c34f80 DD 047c34f80r			; 99999
CONST	ENDS
;	COMDAT __real@44fa0000
CONST	SEGMENT
__real@44fa0000 DD 044fa0000r			; 2000
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@42100000
CONST	SEGMENT
__real@42100000 DD 042100000r			; 36
CONST	ENDS
;	COMDAT __real@42000000
CONST	SEGMENT
__real@42000000 DD 042000000r			; 32
CONST	ENDS
;	COMDAT __real@41700000
CONST	SEGMENT
__real@41700000 DD 041700000r			; 15
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@40e00000
CONST	SEGMENT
__real@40e00000 DD 040e00000r			; 7
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@4040000000000000
CONST	SEGMENT
__real@4040000000000000 DQ 04040000000000000r	; 32
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ff4000000000000
CONST	SEGMENT
__real@3ff4000000000000 DQ 03ff4000000000000r	; 1.25
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fd80b03
CONST	SEGMENT
__real@3fd80b03 DD 03fd80b03r			; 1.68784
CONST	ENDS
;	COMDAT __real@3fc00000
CONST	SEGMENT
__real@3fc00000 DD 03fc00000r			; 1.5
CONST	ENDS
;	COMDAT __real@3f8147ae
CONST	SEGMENT
__real@3f8147ae DD 03f8147aer			; 1.01
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f20d845
CONST	SEGMENT
__real@3f20d845 DD 03f20d845r			; 0.6283
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT __real@3e4ccccd
CONST	SEGMENT
__real@3e4ccccd DD 03e4ccccdr			; 0.2
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3c8efa34
CONST	SEGMENT
__real@3c8efa34 DD 03c8efa34r			; 0.0174533
CONST	ENDS
;	COMDAT __real@3c23d70a
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error_category@std@@8 DD FLAT:??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error_category@std@@8
rdata$r	SEGMENT
??_R2_System_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error_category@std@@8
rdata$r	SEGMENT
??_R3_System_error_category@std@@8 DD 00H		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_System_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_System_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_System_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_System_error_category@std@@6B@ DD 00H		; std::_System_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error_category@std@@@8
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD FLAT:??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 00H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category@std@@@8
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
_DATA	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4error_category@std@@6B@
rdata$r	SEGMENT
??_R4error_category@std@@6B@ DD 00H			; std::error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVerror_category@std@@@8
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CNJIDIOC@VtResumeSampling?$AA@
CONST	SEGMENT
??_C@_0BB@CNJIDIOC@VtResumeSampling?$AA@ DB 'VtResumeSampling', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NIOBKLHM@VtPauseSampling?$AA@
CONST	SEGMENT
??_C@_0BA@NIOBKLHM@VtPauseSampling?$AA@ DB 'VtPauseSampling', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GJLGHHE@vtuneapi?4dll?$AA@
CONST	SEGMENT
??_C@_0N@GJLGHHE@vtuneapi?4dll?$AA@ DB 'vtuneapi.dll', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system?$AA@
CONST	SEGMENT
??_C@_06FHFOAHML@system?$AA@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_System_error_category@std@@6B@
CONST	SEGMENT
??_7_System_error_category@std@@6B@ DD FLAT:??_R4_System_error_category@std@@6B@ ; std::_System_error_category::`vftable'
	DD	FLAT:??_E_System_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_System_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ DB 'iostream stream error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream?$AA@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream?$AA@ DB 'iostream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DD FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DD	FLAT:??_E_Iostream_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
CONST	SEGMENT
??_C@_0O@BFJCFAAK@unknown?5error?$AA@ DB 'unknown error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic?$AA@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic?$AA@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7error_category@std@@6B@
CONST	SEGMENT
??_7error_category@std@@6B@ DD FLAT:??_R4error_category@std@@6B@ ; std::error_category::`vftable'
	DD	FLAT:??_Eerror_category@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
__ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
xdata$x	SEGMENT
__unwindtable$?SimICPLink@@YAXKHPAX@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SimICPLink@@YAXKHPAX@Z$0
__unwindtable$?ToggleSmoke@@YAXKHPAX@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ToggleSmoke@@YAXKHPAX@Z$0
__ehfuncinfo$?SimICPLink@@YAXKHPAX@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SimICPLink@@YAXKHPAX@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?ToggleSmoke@@YAXKHPAX@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ToggleSmoke@@YAXKHPAX@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Generic_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Iostream_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_System_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@D@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<char>::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@_W@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<wchar_t>::id$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 621  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();
; 624  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
_this$ = -24						; size = 4
tv73 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR __V0$[ebp]
	push	ecx
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<wchar_t>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@_W@std@@2V0locale@2@A ; std::numpunct<wchar_t>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<wchar_t>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<char>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<char>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 755  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp

; 756  : 		{	// destroy object at _Ptr
; 757  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>

; 758  : 		}

	pop	ebp
	ret	0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
	pop	ebp
	ret	0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	ebp
	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??1_System_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_System_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??0_System_error_category@std@@QAE@XZ	; std::_System_error_category::_System_error_category
	push	OFFSET ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_System_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??1_Iostream_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??0_Iostream_error_category@std@@QAE@XZ	; std::_Iostream_error_category::_Iostream_error_category
	push	OFFSET ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??1_Generic_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	push	OFFSET ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], -1
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 85   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 89   : 	}

	pop	ebp
	ret	0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 907  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
	add	esp, 8

; 910  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
	add	esp, 12					; 0000000cH
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_theHTS$1 = -24						; size = 4
_pFCC$2 = -20						; size = 4
_laserPod$3 = -16					; size = 4
_theRadar$4 = -12					; size = 4
_mavDisplay$5 = -8					; size = 4
_pac$ = -4						; size = 4
_state$ = 8						; size = 4
_xOff$ = 12						; size = 4
_yOff$ = 16						; size = 4
?SimCursorFunc@?A0x786e660c@@YAXHHH@Z PROC		; `anonymous namespace'::SimCursorFunc

; 1323 : void SimCursorFunc(int state, int xOff, int yOff){

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 1324 : 	// MD -- 20040110: disable keys if we are using analog axis for this control
; 1325 : 	// Also removed the ACM transition to SLEW mode from here and put it back into
; 1326 : 	// the ACMMode() function where it probably belonged anyway.  This needed to
; 1327 : 	// happen to make the "drop track" on reversion to SLEW mode work right for the
; 1328 : 	// analog support anyway.
; 1329 : 	if ((IO.AnalogIsUsed(AXIS_CURSOR_X) == true) && (IO.AnalogIsUsed(AXIS_CURSOR_Y) == true)){

	push	11					; 0000000bH
	mov	ecx, OFFSET ?IO@@3VSIMLIB_IO_CLASS@@A	; IO
	call	?AnalogIsUsed@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z ; SIMLIB_IO_CLASS::AnalogIsUsed
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN13@SimCursorF
	push	12					; 0000000cH
	mov	ecx, OFFSET ?IO@@3VSIMLIB_IO_CLASS@@A	; IO
	call	?AnalogIsUsed@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z ; SIMLIB_IO_CLASS::AnalogIsUsed
	movzx	ecx, al
	cmp	ecx, 1
	jne	SHORT $LN13@SimCursorF

; 1330 : 		return;

	jmp	$LN14@SimCursorF
$LN13@SimCursorF:

; 1331 : 	}
; 1332 : 	AircraftClass *pac = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _pac$[ebp], eax

; 1333 : 	if (pac && pac->IsSetFlag(MOTION_OWNSHIP)){

	cmp	DWORD PTR _pac$[ebp], 0
	je	$LN14@SimCursorF
	push	65536					; 00010000H
	mov	ecx, DWORD PTR _pac$[ebp]
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN14@SimCursorF

; 1334 : 		RadarDopplerClass* theRadar = (RadarDopplerClass*)FindSensor(pac, SensorClass::Radar);

	push	1
	mov	edx, DWORD PTR _pac$[ebp]
	push	edx
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadar$4[ebp], eax

; 1335 : 		FireControlComputer* pFCC = pac->GetFCC();

	mov	eax, DWORD PTR _pac$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pac$[ebp]
	mov	eax, DWORD PTR [edx+460]
	call	eax
	mov	DWORD PTR _pFCC$2[ebp], eax

; 1336 : 		if (state & KEY_DOWN){

	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	$LN11@SimCursorF

; 1337 : 			LaserPodClass* laserPod = (LaserPodClass* )FindLaserPod (pac);

	mov	edx, DWORD PTR _pac$[ebp]
	push	edx
	call	?FindLaserPod@@YAPAVSensorClass@@PAVSimMoverClass@@@Z ; FindLaserPod
	add	esp, 4
	mov	DWORD PTR _laserPod$3[ebp], eax

; 1338 : 			MaverickDisplayClass* mavDisplay = NULL;

	mov	DWORD PTR _mavDisplay$5[ebp], 0

; 1339 : 			HarmTargetingPod *theHTS = (HarmTargetingPod*)FindSensor(pac, SensorClass::HTS);

	push	4
	mov	eax, DWORD PTR _pac$[ebp]
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theHTS$1[ebp], eax

; 1340 : 			if (pac->Sms->curWeaponType == wtAgm65 && pac->Sms->GetCurrentWeapon()){

	mov	ecx, DWORD PTR _pac$[ebp]
	mov	edx, DWORD PTR [ecx+940]
	cmp	DWORD PTR [edx+148], 4
	jne	SHORT $LN10@SimCursorF
	mov	eax, DWORD PTR _pac$[ebp]
	mov	ecx, DWORD PTR [eax+940]
	mov	edx, DWORD PTR _pac$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+940]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	test	eax, eax
	je	SHORT $LN10@SimCursorF

; 1341 : 				mavDisplay = (MaverickDisplayClass*)((MissileClass*)pac->Sms->curWeapon.get())->display;

	mov	eax, DWORD PTR _pac$[ebp]
	mov	ecx, DWORD PTR [eax+940]
	add	ecx, 164				; 000000a4H
	call	?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::get
	mov	ecx, DWORD PTR [eax+712]
	mov	DWORD PTR _mavDisplay$5[ebp], ecx
$LN10@SimCursorF:

; 1342 : 			}
; 1343 : 			if(
; 1344 : 				(theRadar && theRadar->IsSOI()) || 
; 1345 : 				(mavDisplay && mavDisplay->IsSOI()) || 
; 1346 : 				(laserPod && laserPod->IsSOI()) ||
; 1347 : 				(theHTS && pac->GetSOI() == SimVehicleClass::SOI_WEAPON) ||
; 1348 : 				(TheHud && TheHud->IsSOI())
; 1349 : 			){

	cmp	DWORD PTR _theRadar$4[ebp], 0
	je	SHORT $LN7@SimCursorF
	mov	ecx, DWORD PTR _theRadar$4[ebp]
	call	?IsSOI@DrawableClass@@QAEHXZ		; DrawableClass::IsSOI
	test	eax, eax
	jne	SHORT $LN8@SimCursorF
$LN7@SimCursorF:
	cmp	DWORD PTR _mavDisplay$5[ebp], 0
	je	SHORT $LN6@SimCursorF
	mov	ecx, DWORD PTR _mavDisplay$5[ebp]
	call	?IsSOI@DrawableClass@@QAEHXZ		; DrawableClass::IsSOI
	test	eax, eax
	jne	SHORT $LN8@SimCursorF
$LN6@SimCursorF:
	cmp	DWORD PTR _laserPod$3[ebp], 0
	je	SHORT $LN5@SimCursorF
	mov	ecx, DWORD PTR _laserPod$3[ebp]
	call	?IsSOI@DrawableClass@@QAEHXZ		; DrawableClass::IsSOI
	test	eax, eax
	jne	SHORT $LN8@SimCursorF
$LN5@SimCursorF:
	cmp	DWORD PTR _theHTS$1[ebp], 0
	je	SHORT $LN4@SimCursorF
	mov	ecx, DWORD PTR _pac$[ebp]
	call	?GetSOI@SimVehicleClass@@QAE?AW4SOI@1@XZ ; SimVehicleClass::GetSOI
	cmp	eax, 2
	je	SHORT $LN8@SimCursorF
$LN4@SimCursorF:
	cmp	DWORD PTR ?TheHud@@3PAVHudClass@@A, 0	; TheHud
	je	SHORT $LN9@SimCursorF
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?IsSOI@DrawableClass@@QAEHXZ		; DrawableClass::IsSOI
	test	eax, eax
	je	SHORT $LN9@SimCursorF
$LN8@SimCursorF:

; 1350 : 				pac->FCC->cursorXCmd = xOff;

	mov	edx, DWORD PTR _pac$[ebp]
	mov	eax, DWORD PTR [edx+936]
	mov	ecx, DWORD PTR _xOff$[ebp]
	mov	DWORD PTR [eax+196], ecx

; 1351 : 				pac->FCC->cursorYCmd = yOff;

	mov	edx, DWORD PTR _pac$[ebp]
	mov	eax, DWORD PTR [edx+936]
	mov	ecx, DWORD PTR _yOff$[ebp]
	mov	DWORD PTR [eax+200], ecx
	jmp	SHORT $LN3@SimCursorF
$LN9@SimCursorF:

; 1352 : 			}
; 1353 : 			else if	(pFCC && pFCC->IsSOI){

	cmp	DWORD PTR _pFCC$2[ebp], 0
	je	SHORT $LN3@SimCursorF
	mov	edx, DWORD PTR _pFCC$2[ebp]
	movzx	eax, BYTE PTR [edx+464]
	test	eax, eax
	je	SHORT $LN3@SimCursorF

; 1354 : 				pac->FCC->HSDCursorXCmd = xOff;

	mov	ecx, DWORD PTR _pac$[ebp]
	mov	edx, DWORD PTR [ecx+936]
	mov	eax, DWORD PTR _xOff$[ebp]
	mov	DWORD PTR [edx+204], eax

; 1355 : 				pac->FCC->HSDCursorYCmd = yOff;

	mov	ecx, DWORD PTR _pac$[ebp]
	mov	edx, DWORD PTR [ecx+936]
	mov	eax, DWORD PTR _yOff$[ebp]
	mov	DWORD PTR [edx+208], eax
$LN3@SimCursorF:

; 1356 : 			}
; 1357 : 		}
; 1358 : 		else {

	jmp	SHORT $LN14@SimCursorF
$LN11@SimCursorF:

; 1359 : 			pac->FCC->cursorXCmd = pac->FCC->cursorYCmd = 
; 1360 : 				pac->FCC->HSDCursorXCmd = pac->FCC->HSDCursorYCmd = 0;

	mov	ecx, DWORD PTR _pac$[ebp]
	mov	edx, DWORD PTR [ecx+936]
	mov	DWORD PTR [edx+208], 0
	mov	eax, DWORD PTR _pac$[ebp]
	mov	ecx, DWORD PTR [eax+936]
	mov	DWORD PTR [ecx+204], 0
	mov	edx, DWORD PTR _pac$[ebp]
	mov	eax, DWORD PTR [edx+936]
	mov	DWORD PTR [eax+200], 0
	mov	ecx, DWORD PTR _pac$[ebp]
	mov	edx, DWORD PTR [ecx+936]
	mov	DWORD PTR [edx+196], 0
$LN14@SimCursorF:

; 1361 : 		}
; 1362 : 	}
; 1363 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimCursorFunc@?A0x786e660c@@YAXHHH@Z ENDP		; `anonymous namespace'::SimCursorFunc
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
?VtuneNoop@@YAHXZ PROC					; VtuneNoop

; 146  : BOOL VtuneNoop(void) {

	push	ebp
	mov	ebp, esp

; 147  : 	return FALSE;

	xor	eax, eax

; 148  : }

	pop	ebp
	ret	0
?VtuneNoop@@YAHXZ ENDP					; VtuneNoop
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simio.h
;	COMDAT ?AnalogIsUsed@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_id$ = 8						; size = 4
?AnalogIsUsed@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z PROC ; SIMLIB_IO_CLASS::AnalogIsUsed, COMDAT
; _this$ = ecx

; 237  : 	bool	AnalogIsUsed(GameAxis_t id) { return ( analog[id].isUsed); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _id$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [ecx+eax+12]
	mov	esp, ebp
	pop	ebp
	ret	4
?AnalogIsUsed@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z ENDP ; SIMLIB_IO_CLASS::AnalogIsUsed
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\lantirn.h
;	COMDAT ?SetTFRMode@LantirnClass@@QAEXW4TfrMode@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_mode$ = 8						; size = 4
?SetTFRMode@LantirnClass@@QAEXW4TfrMode@1@@Z PROC	; LantirnClass::SetTFRMode, COMDAT
; _this$ = ecx

; 43   :     void    SetTFRMode (TfrMode mode) { m_tfrmode = mode; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _mode$[ebp]
	mov	DWORD PTR [eax+168], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetTFRMode@LantirnClass@@QAEXW4TfrMode@1@@Z ENDP	; LantirnClass::SetTFRMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\lantirn.h
;	COMDAT ?GetTFRMode@LantirnClass@@QAE?AW4TfrMode@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTFRMode@LantirnClass@@QAE?AW4TfrMode@1@XZ PROC	; LantirnClass::GetTFRMode, COMDAT
; _this$ = ecx

; 42   :     TfrMode GetTFRMode(void) { return m_tfrmode; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+168]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetTFRMode@LantirnClass@@QAE?AW4TfrMode@1@XZ ENDP	; LantirnClass::GetTFRMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\pilotinputs.h
;	COMDAT ?selectBothEngines@PilotInputs@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?selectBothEngines@PilotInputs@@QAEXXZ PROC		; PilotInputs::selectBothEngines, COMDAT
; _this$ = ecx

; 53   : 	  void selectBothEngines() { currentlyActiveEngine = Both_Engines; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+100], 2
	mov	esp, ebp
	pop	ebp
	ret	0
?selectBothEngines@PilotInputs@@QAEXXZ ENDP		; PilotInputs::selectBothEngines
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\pilotinputs.h
;	COMDAT ?selectRightEngine@PilotInputs@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?selectRightEngine@PilotInputs@@QAEXXZ PROC		; PilotInputs::selectRightEngine, COMDAT
; _this$ = ecx

; 52   : 	  void selectRightEngine() { currentlyActiveEngine = Right_Engine; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+100], 1
	mov	esp, ebp
	pop	ebp
	ret	0
?selectRightEngine@PilotInputs@@QAEXXZ ENDP		; PilotInputs::selectRightEngine
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\pilotinputs.h
;	COMDAT ?selectLeftEngine@PilotInputs@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?selectLeftEngine@PilotInputs@@QAEXXZ PROC		; PilotInputs::selectLeftEngine, COMDAT
; _this$ = ecx

; 51   : 	  void selectLeftEngine() { currentlyActiveEngine = Left_Engine; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+100], 0
	mov	esp, ebp
	pop	ebp
	ret	0
?selectLeftEngine@PilotInputs@@QAEXXZ ENDP		; PilotInputs::selectLeftEngine
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\pilotinputs.h
;	COMDAT ?getCurrentEngine@PilotInputs@@QAE?AW4Engine_t@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getCurrentEngine@PilotInputs@@QAE?AW4Engine_t@1@XZ PROC ; PilotInputs::getCurrentEngine, COMDAT
; _this$ = ecx

; 49   : 	  Engine_t getCurrentEngine() { return currentlyActiveEngine; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+100]
	mov	esp, ebp
	pop	ebp
	ret	0
?getCurrentEngine@PilotInputs@@QAE?AW4Engine_t@1@XZ ENDP ; PilotInputs::getCurrentEngine
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\playerrwr.h
;	COMDAT ?ShowLowAltPriority@PlayerRwrClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ShowLowAltPriority@PlayerRwrClass@@QAEHXZ PROC		; PlayerRwrClass::ShowLowAltPriority, COMDAT
; _this$ = ecx

; 44   : 	int ShowLowAltPriority (void)		{return lowAltPriority;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+592]
	mov	esp, ebp
	pop	ebp
	ret	0
?ShowLowAltPriority@PlayerRwrClass@@QAEHXZ ENDP		; PlayerRwrClass::ShowLowAltPriority
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\playerrwr.h
;	COMDAT ?ShowSearch@PlayerRwrClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ShowSearch@PlayerRwrClass@@QAEHXZ PROC			; PlayerRwrClass::ShowSearch, COMDAT
; _this$ = ecx

; 43   : 	int ShowSearch (void)		{return showSearch;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+636]
	mov	esp, ebp
	pop	ebp
	ret	0
?ShowSearch@PlayerRwrClass@@QAEHXZ ENDP			; PlayerRwrClass::ShowSearch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\playerrwr.h
;	COMDAT ?ShowNaval@PlayerRwrClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ShowNaval@PlayerRwrClass@@QAEHXZ PROC			; PlayerRwrClass::ShowNaval, COMDAT
; _this$ = ecx

; 42   : 	int ShowNaval (void)		{return showNaval;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+632]
	mov	esp, ebp
	pop	ebp
	ret	0
?ShowNaval@PlayerRwrClass@@QAEHXZ ENDP			; PlayerRwrClass::ShowNaval
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\playerrwr.h
;	COMDAT ?ShowUnknowns@PlayerRwrClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ShowUnknowns@PlayerRwrClass@@QAEHXZ PROC		; PlayerRwrClass::ShowUnknowns, COMDAT
; _this$ = ecx

; 41   : 	int ShowUnknowns (void)		{return showUnknowns;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+628]
	mov	esp, ebp
	pop	ebp
	ret	0
?ShowUnknowns@PlayerRwrClass@@QAEHXZ ENDP		; PlayerRwrClass::ShowUnknowns
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\playerrwr.h
;	COMDAT ?TargetSep@PlayerRwrClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?TargetSep@PlayerRwrClass@@QAEHXZ PROC			; PlayerRwrClass::TargetSep, COMDAT
; _this$ = ecx

; 40   : 	int TargetSep (void)		{return targetSep;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+624]
	mov	esp, ebp
	pop	ebp
	ret	0
?TargetSep@PlayerRwrClass@@QAEHXZ ENDP			; PlayerRwrClass::TargetSep
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\playerrwr.h
;	COMDAT ?IsPriority@PlayerRwrClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsPriority@PlayerRwrClass@@QAEHXZ PROC			; PlayerRwrClass::IsPriority, COMDAT
; _this$ = ecx

; 39   : 	int IsPriority (void)		{return priorityMode;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+620]
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPriority@PlayerRwrClass@@QAEHXZ ENDP			; PlayerRwrClass::IsPriority
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\laserpod.h
;	COMDAT ?TogglePolarity@LaserPodClass@@QAEXXZ
_TEXT	SEGMENT
tv68 = -8						; size = 4
_this$ = -4						; size = 4
?TogglePolarity@LaserPodClass@@QAEXXZ PROC		; LaserPodClass::TogglePolarity, COMDAT
; _this$ = ecx

; 36   : 	void TogglePolarity(void)	{BHOT = !BHOT;};

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+80]
	test	ecx, ecx
	jne	SHORT $LN3@TogglePola
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@TogglePola
$LN3@TogglePola:
	mov	DWORD PTR tv68[ebp], 0
$LN4@TogglePola:
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR tv68[ebp]
	mov	BYTE PTR [edx+80], al
	mov	esp, ebp
	pop	ebp
	ret	0
?TogglePolarity@LaserPodClass@@QAEXXZ ENDP		; LaserPodClass::TogglePolarity
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\mavdisp.h
;	COMDAT ?ToggleFOV@MaverickDisplayClass@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ToggleFOV@MaverickDisplayClass@@QAEXXZ PROC		; MaverickDisplayClass::ToggleFOV, COMDAT
; _this$ = ecx

; 33   :       void ToggleFOV (void) {toggleFOV = TRUE;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+48], 1
	mov	esp, ebp
	pop	ebp
	ret	0
?ToggleFOV@MaverickDisplayClass@@QAEXXZ ENDP		; MaverickDisplayClass::ToggleFOV
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\include\uicomms.h
;	COMDAT ?Online@UIComms@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Online@UIComms@@QAEHXZ PROC				; UIComms::Online, COMDAT
; _this$ = ecx

; 118  : 		BOOL Online()					{ return(Online_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+64]
	mov	esp, ebp
	pop	ebp
	ret	0
?Online@UIComms@@QAEHXZ ENDP				; UIComms::Online
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\kneeboard.h
;	COMDAT ?GetPage@KneeBoard@@QAE?AW4Page@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPage@KneeBoard@@QAE?AW4Page@1@XZ PROC		; KneeBoard::GetPage, COMDAT
; _this$ = ecx

; 31   : 	Page GetPage( void )	{ return page; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetPage@KneeBoard@@QAE?AW4Page@1@XZ ENDP		; KneeBoard::GetPage
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\kneeboard.h
;	COMDAT ?SetPage@KneeBoard@@QAEXW4Page@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_p$ = 8							; size = 4
?SetPage@KneeBoard@@QAEXW4Page@1@@Z PROC		; KneeBoard::SetPage, COMDAT
; _this$ = ecx

; 30   : 	void SetPage( Page p )	{ page = p; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax+8], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetPage@KneeBoard@@QAEXW4Page@1@@Z ENDP		; KneeBoard::SetPage
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\hud.h
;	COMDAT ?ResetMaxG@HudClass@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ResetMaxG@HudClass@@QAEXXZ PROC			; HudClass::ResetMaxG, COMDAT
; _this$ = ecx

; 351  : 	void ResetMaxG(void)	{maxGs = 1;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+4832], xmm0
	mov	esp, ebp
	pop	ebp
	ret	0
?ResetMaxG@HudClass@@QAEXXZ ENDP			; HudClass::ResetMaxG
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\cpmanager.h
;	COMDAT ?AltPanel@CockpitManager@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AltPanel@CockpitManager@@QAEHXZ PROC			; CockpitManager::AltPanel, COMDAT
; _this$ = ecx

; 598  : 	int      AltPanel(void) { return mAltPanel;};		//Wombat778 4-13-04

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+96]
	mov	esp, ebp
	pop	ebp
	ret	0
?AltPanel@CockpitManager@@QAEHXZ ENDP			; CockpitManager::AltPanel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\cpmanager.h
;	COMDAT ?GetActivePanel@CockpitManager@@QAEPAVCPPanel@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetActivePanel@CockpitManager@@QAEPAVCPPanel@@XZ PROC	; CockpitManager::GetActivePanel, COMDAT
; _this$ = ecx

; 576  : 	CPPanel*	GetActivePanel()	{return mpActivePanel;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+172]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetActivePanel@CockpitManager@@QAEPAVCPPanel@@XZ ENDP	; CockpitManager::GetActivePanel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\icp.h
;	COMDAT ?GetICPSecondaryMode@ICPClass@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetICPSecondaryMode@ICPClass@@QAEJXZ PROC		; ICPClass::GetICPSecondaryMode, COMDAT
; _this$ = ecx

; 568  : 	long GetICPSecondaryMode(void) {return mICPSecondaryMode;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetICPSecondaryMode@ICPClass@@QAEJXZ ENDP		; ICPClass::GetICPSecondaryMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\icp.h
;	COMDAT ?GetICPPrimaryMode@ICPClass@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetICPPrimaryMode@ICPClass@@QAEJXZ PROC		; ICPClass::GetICPPrimaryMode, COMDAT
; _this$ = ecx

; 567  : 	long GetICPPrimaryMode(void) {return mICPPrimaryMode;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetICPPrimaryMode@ICPClass@@QAEJXZ ENDP		; ICPClass::GetICPPrimaryMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\icp.h
;	COMDAT ?IsICPSet@ICPClass@@QAEHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_testFlag$ = 8						; size = 4
?IsICPSet@ICPClass@@QAEHH@Z PROC			; ICPClass::IsICPSet, COMDAT
; _this$ = ecx

; 499  : 	int IsICPSet (int testFlag) {return ICPModeFlags & testFlag ? 1 : 0;};

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1376]
	and	ecx, DWORD PTR _testFlag$[ebp]
	je	SHORT $LN3@IsICPSet
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsICPSet
$LN3@IsICPSet:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsICPSet:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsICPSet@ICPClass@@QAEHH@Z ENDP			; ICPClass::IsICPSet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\icp.h
;	COMDAT ?ClearICPFlag@ICPClass@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newFlag$ = 8						; size = 4
?ClearICPFlag@ICPClass@@QAEXH@Z PROC			; ICPClass::ClearICPFlag, COMDAT
; _this$ = ecx

; 498  : 	void ClearICPFlag (int newFlag) {ICPModeFlags &= ~newFlag;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _newFlag$[ebp]
	not	eax
	mov	ecx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [ecx+1376]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1376], eax
	mov	esp, ebp
	pop	ebp
	ret	4
?ClearICPFlag@ICPClass@@QAEXH@Z ENDP			; ICPClass::ClearICPFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\icp.h
;	COMDAT ?SetICPFlag@ICPClass@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newFlag$ = 8						; size = 4
?SetICPFlag@ICPClass@@QAEXH@Z PROC			; ICPClass::SetICPFlag, COMDAT
; _this$ = ecx

; 497  : 	void SetICPFlag (int newFlag) {ICPModeFlags |= newFlag;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1376]
	or	ecx, DWORD PTR _newFlag$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1376], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetICPFlag@ICPClass@@QAEXH@Z ENDP			; ICPClass::SetICPFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fack.h
;	COMDAT ?ClearWarnReset@FackClass@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ClearWarnReset@FackClass@@QAEXXZ PROC			; FackClass::ClearWarnReset, COMDAT
; _this$ = ecx

; 45   :     void	ClearWarnReset(void) {NeedsWarnReset = FALSE;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	esp, ebp
	pop	ebp
	ret	0
?ClearWarnReset@FackClass@@QAEXXZ ENDP			; FackClass::ClearWarnReset
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fack.h
;	COMDAT ?SetManWarnReset@FackClass@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SetManWarnReset@FackClass@@QAEXXZ PROC			; FackClass::SetManWarnReset, COMDAT
; _this$ = ecx

; 43   : 	void	SetManWarnReset(void)	{DidManWarnReset = TRUE;};	//MI

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 1
	mov	esp, ebp
	pop	ebp
	ret	0
?SetManWarnReset@FackClass@@QAEXXZ ENDP			; FackClass::SetManWarnReset
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fack.h
;	COMDAT ?ClearMasterCaution@FackClass@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ClearMasterCaution@FackClass@@QAEXXZ PROC		; FackClass::ClearMasterCaution, COMDAT
; _this$ = ecx

; 37   :     void        ClearMasterCaution(void) {mMasterCaution = FALSE;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	esp, ebp
	pop	ebp
	ret	0
?ClearMasterCaution@FackClass@@QAEXXZ ENDP		; FackClass::ClearMasterCaution
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fack.h
;	COMDAT ?MasterCaution@FackClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?MasterCaution@FackClass@@QAEHXZ PROC			; FackClass::MasterCaution, COMDAT
; _this$ = ecx

; 35   :     int		MasterCaution(void) {return mMasterCaution;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	esp, ebp
	pop	ebp
	ret	0
?MasterCaution@FackClass@@QAEHXZ ENDP			; FackClass::MasterCaution
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fack.h
;	COMDAT ?ClearAvioncFault@FackClass@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ClearAvioncFault@FackClass@@QAEXXZ PROC		; FackClass::ClearAvioncFault, COMDAT
; _this$ = ecx

; 30   :     void	ClearAvioncFault (void) {NeedAckAvioncFault = FALSE;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+560], 0
	mov	esp, ebp
	pop	ebp
	ret	0
?ClearAvioncFault@FackClass@@QAEXXZ ENDP		; FackClass::ClearAvioncFault
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fack.h
;	COMDAT ?ClearFault@FackClass@@QAEXW4type_FSubSystem@FaultClass@@W4type_FFunction@3@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ss$ = 8						; size = 4
_type$ = 12						; size = 4
?ClearFault@FackClass@@QAEXW4type_FSubSystem@FaultClass@@W4type_FFunction@3@@Z PROC ; FackClass::ClearFault, COMDAT
; _this$ = ecx

; 28   :     void	ClearFault(FaultClass::type_FSubSystem ss, FaultClass::type_FFunction type) { mFaults.ClearFault(ss, type); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ss$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?ClearFault@FaultClass@@QAEXW4type_FSubSystem@1@W4type_FFunction@1@@Z ; FaultClass::ClearFault
	mov	esp, ebp
	pop	ebp
	ret	8
?ClearFault@FackClass@@QAEXW4type_FSubSystem@FaultClass@@W4type_FFunction@3@@Z ENDP ; FackClass::ClearFault
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\button.h
;	COMDAT ?GetCurrentState@CPButtonObject@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCurrentState@CPButtonObject@@QBEHXZ PROC		; CPButtonObject::GetCurrentState, COMDAT
; _this$ = ecx

; 153  : 	int				GetCurrentState() const { return mCurrentState; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+28]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCurrentState@CPButtonObject@@QBEHXZ ENDP		; CPButtonObject::GetCurrentState
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radardoppler.h
;	COMDAT ?twsTrackDirectory@RadarDopplerClass@@QAEPAVTWSTrackList@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?twsTrackDirectory@RadarDopplerClass@@QAEPAVTWSTrackList@1@XZ PROC ; RadarDopplerClass::twsTrackDirectory, COMDAT
; _this$ = ecx

; 423  : 	TWSTrackList* twsTrackDirectory() { return TWSTrackDirectory; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+532]
	mov	esp, ebp
	pop	ebp
	ret	0
?twsTrackDirectory@RadarDopplerClass@@QAEPAVTWSTrackList@1@XZ ENDP ; RadarDopplerClass::twsTrackDirectory
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radardoppler.h
;	COMDAT ?ToggleFlag@RadarDopplerClass@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_flag$ = 8						; size = 4
?ToggleFlag@RadarDopplerClass@@QAEXH@Z PROC		; RadarDopplerClass::ToggleFlag, COMDAT
; _this$ = ecx

; 239  : 	void ToggleFlag (int flag) {flags ^= flag; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+492]
	xor	ecx, DWORD PTR _flag$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+492], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?ToggleFlag@RadarDopplerClass@@QAEXH@Z ENDP		; RadarDopplerClass::ToggleFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radardoppler.h
;	COMDAT ?ClearFlagBit@RadarDopplerClass@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newFlag$ = 8						; size = 4
?ClearFlagBit@RadarDopplerClass@@QAEXH@Z PROC		; RadarDopplerClass::ClearFlagBit, COMDAT
; _this$ = ecx

; 238  : 	void ClearFlagBit (int newFlag) {flags &= ~newFlag;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _newFlag$[ebp]
	not	eax
	mov	ecx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [ecx+492]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+492], eax
	mov	esp, ebp
	pop	ebp
	ret	4
?ClearFlagBit@RadarDopplerClass@@QAEXH@Z ENDP		; RadarDopplerClass::ClearFlagBit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radardoppler.h
;	COMDAT ?IsSet@RadarDopplerClass@@QAEHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_newFlag$ = 8						; size = 4
?IsSet@RadarDopplerClass@@QAEHH@Z PROC			; RadarDopplerClass::IsSet, COMDAT
; _this$ = ecx

; 236  :    int  IsSet (int newFlag) {return (newFlag & flags) ? TRUE : FALSE;}; //MI moved to public

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newFlag$[ebp]
	and	ecx, DWORD PTR [eax+492]
	je	SHORT $LN3@IsSet
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsSet
$LN3@IsSet:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsSet:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsSet@RadarDopplerClass@@QAEHH@Z ENDP			; RadarDopplerClass::IsSet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?IsEmitting@RadarClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsEmitting@RadarClass@@QAEHXZ PROC			; RadarClass::IsEmitting, COMDAT
; _this$ = ecx

; 93   : 	int IsEmitting (void)						{ return isEmitting; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+76]
	mov	esp, ebp
	pop	ebp
	ret	0
?IsEmitting@RadarClass@@QAEHXZ ENDP			; RadarClass::IsEmitting
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?IsSet@AirframeClass@@QBEHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_testFlag$ = 8						; size = 4
?IsSet@AirframeClass@@QBEHH@Z PROC			; AirframeClass::IsSet, COMDAT
; _this$ = ecx

; 1216 : 	int IsSet (int testFlag) const {return flags & testFlag ? 1 : 0;}

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	and	ecx, DWORD PTR _testFlag$[ebp]
	je	SHORT $LN3@IsSet
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsSet
$LN3@IsSet:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsSet:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsSet@AirframeClass@@QBEHH@Z ENDP			; AirframeClass::IsSet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?ClearFlag@AirframeClass@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newFlag$ = 8						; size = 4
?ClearFlag@AirframeClass@@QAEXH@Z PROC			; AirframeClass::ClearFlag, COMDAT
; _this$ = ecx

; 1215 : 	void ClearFlag (int newFlag) {flags &= ~newFlag;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _newFlag$[ebp]
	not	eax
	mov	ecx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [ecx+88]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+88], eax
	mov	esp, ebp
	pop	ebp
	ret	4
?ClearFlag@AirframeClass@@QAEXH@Z ENDP			; AirframeClass::ClearFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?SetFlag@AirframeClass@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newFlag$ = 8						; size = 4
?SetFlag@AirframeClass@@QAEXH@Z PROC			; AirframeClass::SetFlag, COMDAT
; _this$ = ecx

; 1214 : 	void SetFlag (int newFlag) {flags |= newFlag;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	or	ecx, DWORD PTR _newFlag$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+88], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetFlag@AirframeClass@@QAEXH@Z ENDP			; AirframeClass::SetFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?ExternalFuel@AirframeClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ExternalFuel@AirframeClass@@QAEMXZ PROC		; AirframeClass::ExternalFuel, COMDAT
; _this$ = ecx

; 1184 : 	float ExternalFuel (void) {return externalFuel;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+32]
	mov	esp, ebp
	pop	ebp
	ret	0
?ExternalFuel@AirframeClass@@QAEMXZ ENDP		; AirframeClass::ExternalFuel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?Fuel@AirframeClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Fuel@AirframeClass@@QAEMXZ PROC			; AirframeClass::Fuel, COMDAT
; _this$ = ecx

; 1183 : 	float Fuel (void) {return fuel;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+20]
	mov	esp, ebp
	pop	ebp
	ret	0
?Fuel@AirframeClass@@QAEMXZ ENDP			; AirframeClass::Fuel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?Throtl@AirframeClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Throtl@AirframeClass@@QAEMXZ PROC			; AirframeClass::Throtl, COMDAT
; _this$ = ecx

; 1168 : 	float Throtl (void) {return throtl;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1512]
	mov	esp, ebp
	pop	ebp
	ret	0
?Throtl@AirframeClass@@QAEMXZ ENDP			; AirframeClass::Throtl
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?GeneratorBreak@AirframeClass@@QAEXW4Generator@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_gen$ = 8						; size = 4
?GeneratorBreak@AirframeClass@@QAEXW4Generator@1@@Z PROC ; AirframeClass::GeneratorBreak, COMDAT
; _this$ = ecx

; 1134 : 	void GeneratorBreak(Generator gen) { generators |= (gen<<1); GeneratorOff(gen);  };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _gen$[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	or	eax, DWORD PTR [ecx+1804]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1804], eax
	mov	eax, DWORD PTR _gen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GeneratorOff@AirframeClass@@QAEXW4Generator@1@@Z ; AirframeClass::GeneratorOff
	mov	esp, ebp
	pop	ebp
	ret	4
?GeneratorBreak@AirframeClass@@QAEXW4Generator@1@@Z ENDP ; AirframeClass::GeneratorBreak
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?GeneratorOff@AirframeClass@@QAEXW4Generator@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_gen$ = 8						; size = 4
?GeneratorOff@AirframeClass@@QAEXW4Generator@1@@Z PROC	; AirframeClass::GeneratorOff, COMDAT
; _this$ = ecx

; 1133 : 	void GeneratorOff (Generator gen) { generators &= ~gen; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _gen$[ebp]
	not	eax
	mov	ecx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [ecx+1804]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1804], eax
	mov	esp, ebp
	pop	ebp
	ret	4
?GeneratorOff@AirframeClass@@QAEXW4Generator@1@@Z ENDP	; AirframeClass::GeneratorOff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?GetAirSource@AirframeClass@@QAE?AW4AirSource@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAirSource@AirframeClass@@QAE?AW4AirSource@1@XZ PROC	; AirframeClass::GetAirSource, COMDAT
; _this$ = ecx

; 1112 : 	AirSource GetAirSource() { return airSource; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1800]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetAirSource@AirframeClass@@QAE?AW4AirSource@1@XZ ENDP	; AirframeClass::GetAirSource
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?SetAirSource@AirframeClass@@QAEXW4AirSource@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_as$ = 8						; size = 4
?SetAirSource@AirframeClass@@QAEXW4AirSource@1@@Z PROC	; AirframeClass::SetAirSource, COMDAT
; _this$ = ecx

; 1111 : 	void SetAirSource(AirSource as) { airSource = as; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _as$[ebp]
	mov	DWORD PTR [eax+1800], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetAirSource@AirframeClass@@QAEXW4AirSource@1@@Z ENDP	; AirframeClass::SetAirSource
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?GetFuelPump@AirframeClass@@QAE?AW4FuelPump@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFuelPump@AirframeClass@@QAE?AW4FuelPump@1@XZ PROC	; AirframeClass::GetFuelPump, COMDAT
; _this$ = ecx

; 1091 : 	FuelPump GetFuelPump() { return fuelPump; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1684]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFuelPump@AirframeClass@@QAE?AW4FuelPump@1@XZ ENDP	; AirframeClass::GetFuelPump
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?SetFuelPump@AirframeClass@@QAEXW4FuelPump@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_fp$ = 8						; size = 4
?SetFuelPump@AirframeClass@@QAEXW4FuelPump@1@@Z PROC	; AirframeClass::SetFuelPump, COMDAT
; _this$ = ecx

; 1090 : 	void SetFuelPump(FuelPump fp) { fuelPump = fp; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _fp$[ebp]
	mov	DWORD PTR [eax+1684], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetFuelPump@AirframeClass@@QAEXW4FuelPump@1@@Z ENDP	; AirframeClass::SetFuelPump
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?GetFuelSwitch@AirframeClass@@QAE?AW4FuelSwitch@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFuelSwitch@AirframeClass@@QAE?AW4FuelSwitch@1@XZ PROC ; AirframeClass::GetFuelSwitch, COMDAT
; _this$ = ecx

; 1082 : 	FuelSwitch GetFuelSwitch() { return fuelSwitch; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1680]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFuelSwitch@AirframeClass@@QAE?AW4FuelSwitch@1@XZ ENDP ; AirframeClass::GetFuelSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?SetFuelSwitch@AirframeClass@@QAEXW4FuelSwitch@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_fs$ = 8						; size = 4
?SetFuelSwitch@AirframeClass@@QAEXW4FuelSwitch@1@@Z PROC ; AirframeClass::SetFuelSwitch, COMDAT
; _this$ = ecx

; 1081 : 	void SetFuelSwitch(FuelSwitch fs) { fuelSwitch = fs; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _fs$[ebp]
	mov	DWORD PTR [eax+1680], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetFuelSwitch@AirframeClass@@QAEXW4FuelSwitch@1@@Z ENDP ; AirframeClass::SetFuelSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?ToggleEngineFlag@AirframeClass@@QAEXW4EngineFlags@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ef$ = 8						; size = 4
?ToggleEngineFlag@AirframeClass@@QAEXW4EngineFlags@1@@Z PROC ; AirframeClass::ToggleEngineFlag, COMDAT
; _this$ = ecx

; 1073 : 	void ToggleEngineFlag(EngineFlags ef) { engineFlags ^= ef; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1676]
	xor	ecx, DWORD PTR _ef$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1676], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?ToggleEngineFlag@AirframeClass@@QAEXW4EngineFlags@1@@Z ENDP ; AirframeClass::ToggleEngineFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?ClearEngineFlag@AirframeClass@@QAEXW4EngineFlags@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ef$ = 8						; size = 4
?ClearEngineFlag@AirframeClass@@QAEXW4EngineFlags@1@@Z PROC ; AirframeClass::ClearEngineFlag, COMDAT
; _this$ = ecx

; 1072 : 	void ClearEngineFlag(EngineFlags ef) { engineFlags &= ~ ef; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _ef$[ebp]
	not	eax
	mov	ecx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [ecx+1676]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1676], eax
	mov	esp, ebp
	pop	ebp
	ret	4
?ClearEngineFlag@AirframeClass@@QAEXW4EngineFlags@1@@Z ENDP ; AirframeClass::ClearEngineFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?SetEngineFlag@AirframeClass@@QAEXW4EngineFlags@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ef$ = 8						; size = 4
?SetEngineFlag@AirframeClass@@QAEXW4EngineFlags@1@@Z PROC ; AirframeClass::SetEngineFlag, COMDAT
; _this$ = ecx

; 1071 : 	void SetEngineFlag(EngineFlags ef) { engineFlags |= ef; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1676]
	or	ecx, DWORD PTR _ef$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1676], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetEngineFlag@AirframeClass@@QAEXW4EngineFlags@1@@Z ENDP ; AirframeClass::SetEngineFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?IsEngineFlag@AirframeClass@@QAEHW4EngineFlags@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_ef$ = 8						; size = 4
?IsEngineFlag@AirframeClass@@QAEHW4EngineFlags@1@@Z PROC ; AirframeClass::IsEngineFlag, COMDAT
; _this$ = ecx

; 1070 : 	int IsEngineFlag(EngineFlags ef) { return (engineFlags & ef) ? 1 : 0; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1676]
	and	ecx, DWORD PTR _ef$[ebp]
	je	SHORT $LN3@IsEngineFl
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsEngineFl
$LN3@IsEngineFl:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsEngineFl:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsEngineFlag@AirframeClass@@QAEHW4EngineFlags@1@@Z ENDP ; AirframeClass::IsEngineFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?HydraulicB@AirframeClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?HydraulicB@AirframeClass@@QAEHXZ PROC			; AirframeClass::HydraulicB, COMDAT
; _this$ = ecx

; 1040 : 	int HydraulicB() { return (hydrAB & HYDR_B_SYSTEM); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+1601]
	and	eax, 2
	mov	esp, ebp
	pop	ebp
	ret	0
?HydraulicB@AirframeClass@@QAEHXZ ENDP			; AirframeClass::HydraulicB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?HydraulicA@AirframeClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?HydraulicA@AirframeClass@@QAEHXZ PROC			; AirframeClass::HydraulicA, COMDAT
; _this$ = ecx

; 1039 : 	int HydraulicA() { return (hydrAB & HYDR_A_SYSTEM); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+1601]
	and	eax, 1
	mov	esp, ebp
	pop	ebp
	ret	0
?HydraulicA@AirframeClass@@QAEHXZ ENDP			; AirframeClass::HydraulicA
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?SetEpuSwitch@AirframeClass@@QAEXW4EpuState@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_mode$ = 8						; size = 4
?SetEpuSwitch@AirframeClass@@QAEXW4EpuState@1@@Z PROC	; AirframeClass::SetEpuSwitch, COMDAT
; _this$ = ecx

; 1022 : 	void SetEpuSwitch (EpuState mode) { epuState = mode; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _mode$[ebp]
	mov	DWORD PTR [eax+1596], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetEpuSwitch@AirframeClass@@QAEXW4EpuState@1@@Z ENDP	; AirframeClass::SetEpuSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?GetEpuSwitch@AirframeClass@@QAE?AW4EpuState@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetEpuSwitch@AirframeClass@@QAE?AW4EpuState@1@XZ PROC	; AirframeClass::GetEpuSwitch, COMDAT
; _this$ = ecx

; 1021 : 	EpuState GetEpuSwitch () { return epuState; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1596]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetEpuSwitch@AirframeClass@@QAE?AW4EpuState@1@XZ ENDP	; AirframeClass::GetEpuSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?HasDragChute@AirframeClass@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
?HasDragChute@AirframeClass@@QAE_NXZ PROC		; AirframeClass::HasDragChute, COMDAT
; _this$ = ecx

; 1007 : 	bool HasDragChute() { return auxaeroData->dragChuteCd > 0; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movss	xmm0, DWORD PTR [ecx+228]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN3@HasDragChu
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@HasDragChu
$LN3@HasDragChu:
	mov	DWORD PTR tv67[ebp], 0
$LN4@HasDragChu:
	mov	al, BYTE PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?HasDragChute@AirframeClass@@QAE_NXZ ENDP		; AirframeClass::HasDragChute
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?GetTypeAC@AirframeClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTypeAC@AirframeClass@@QAEHXZ PROC			; AirframeClass::GetTypeAC, COMDAT
; _this$ = ecx

; 809  : 	int GetTypeAC() {return auxaeroData->typeAC;};//TJL 02/28/04

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+3880]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetTypeAC@AirframeClass@@QAEHXZ ENDP			; AirframeClass::GetTypeAC
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?GetNumberEngines@AirframeClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNumberEngines@AirframeClass@@QAEHXZ PROC		; AirframeClass::GetNumberEngines, COMDAT
; _this$ = ecx

; 802  : 	int GetNumberEngines() {return auxaeroData->nEngines;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+344]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumberEngines@AirframeClass@@QAEHXZ ENDP		; AirframeClass::GetNumberEngines
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?GetDataLinkCapLevel@AirframeClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetDataLinkCapLevel@AirframeClass@@QAEHXZ PROC		; AirframeClass::GetDataLinkCapLevel, COMDAT
; _this$ = ecx

; 748  : 	int GetDataLinkCapLevel() { return auxaeroData->dataLinkCapLevel; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+2628]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDataLinkCapLevel@AirframeClass@@QAEHXZ ENDP		; AirframeClass::GetDataLinkCapLevel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\smsdraw.h
;	COMDAT ?DisplayMode@SmsDrawable@@QAE?AW4SmsDisplayMode@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DisplayMode@SmsDrawable@@QAE?AW4SmsDisplayMode@1@XZ PROC ; SmsDrawable::DisplayMode, COMDAT
; _this$ = ecx

; 26   : 	SmsDisplayMode DisplayMode(void) {return displayMode;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+304]
	mov	esp, ebp
	pop	ebp
	ret	0
?DisplayMode@SmsDrawable@@QAE?AW4SmsDisplayMode@1@XZ ENDP ; SmsDrawable::DisplayMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?SetAGBPair@SMSClass@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 1
?SetAGBPair@SMSClass@@QAEX_N@Z PROC			; SMSClass::SetAGBPair, COMDAT
; _this$ = ecx

; 325  : 	void SetAGBPair(bool x)           { agbProfile[curProfile].releasePair    = x; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR _x$[ebp]
	mov	BYTE PTR [edx+ecx+232], al
	mov	esp, ebp
	pop	ebp
	ret	4
?SetAGBPair@SMSClass@@QAEX_N@Z ENDP			; SMSClass::SetAGBPair
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?SetCoolState@SMSClass@@QAEXW4Aim9Mode@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_state$ = 8						; size = 4
?SetCoolState@SMSClass@@QAEXW4Aim9Mode@1@@Z PROC	; SMSClass::SetCoolState, COMDAT
; _this$ = ecx

; 271  : 	void SetCoolState (Aim9Mode state) { aim9mode = state; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [eax+180], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetCoolState@SMSClass@@QAEXW4Aim9Mode@1@@Z ENDP	; SMSClass::SetCoolState
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?GetCoolState@SMSClass@@QAE?AW4Aim9Mode@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCoolState@SMSClass@@QAE?AW4Aim9Mode@1@XZ PROC	; SMSClass::GetCoolState, COMDAT
; _this$ = ecx

; 270  : 	Aim9Mode GetCoolState() { return aim9mode; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+180]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCoolState@SMSClass@@QAE?AW4Aim9Mode@1@XZ ENDP	; SMSClass::GetCoolState
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?SetMasterArm@SMSBaseClass@@QAEXW4MasterArmState@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newState$ = 8						; size = 4
?SetMasterArm@SMSBaseClass@@QAEXW4MasterArmState@1@@Z PROC ; SMSBaseClass::SetMasterArm, COMDAT
; _this$ = ecx

; 93   : 	void SetMasterArm (MasterArmState newState) {masterArm = newState;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newState$[ebp]
	mov	DWORD PTR [eax+8], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetMasterArm@SMSBaseClass@@QAEXW4MasterArmState@1@@Z ENDP ; SMSBaseClass::SetMasterArm
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?MasterArm@SMSBaseClass@@QAE?AW4MasterArmState@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?MasterArm@SMSBaseClass@@QAE?AW4MasterArmState@1@XZ PROC ; SMSBaseClass::MasterArm, COMDAT
; _this$ = ecx

; 92   : 	MasterArmState MasterArm(void) {return masterArm;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?MasterArm@SMSBaseClass@@QAE?AW4MasterArmState@1@XZ ENDP ; SMSBaseClass::MasterArm
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h
;	COMDAT ?SetLastDesignate@FireControlComputer@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SetLastDesignate@FireControlComputer@@QAEXXZ PROC	; FireControlComputer::SetLastDesignate, COMDAT
; _this$ = ecx

; 326  : 	void SetLastDesignate(void)	{lastDesignate = TRUE;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+96], 1
	mov	esp, ebp
	pop	ebp
	ret	0
?SetLastDesignate@FireControlComputer@@QAEXXZ ENDP	; FireControlComputer::SetLastDesignate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h
;	COMDAT ?GetSubMode@FireControlComputer@@QAE?AW4FCCSubMode@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSubMode@FireControlComputer@@QAE?AW4FCCSubMode@1@XZ PROC ; FireControlComputer::GetSubMode, COMDAT
; _this$ = ecx

; 281  : 	FCCSubMode GetSubMode (void) {return (subMode);};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+148]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSubMode@FireControlComputer@@QAE?AW4FCCSubMode@1@XZ ENDP ; FireControlComputer::GetSubMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h
;	COMDAT ?IsNavMasterMode@FireControlComputer@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
?IsNavMasterMode@FireControlComputer@@QAEHXZ PROC	; FireControlComputer::IsNavMasterMode, COMDAT
; _this$ = ecx

; 280  : 	int IsNavMasterMode() { return GetMainMasterMode() == MM_NAV; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMainMasterMode@FireControlComputer@@QAE?AW4MASTERMODES@@XZ ; FireControlComputer::GetMainMasterMode
	cmp	eax, 2
	jne	SHORT $LN3@IsNavMaste
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsNavMaste
$LN3@IsNavMaste:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsNavMaste:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?IsNavMasterMode@FireControlComputer@@QAEHXZ ENDP	; FireControlComputer::IsNavMasterMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h
;	COMDAT ?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ PROC ; FireControlComputer::GetMasterMode, COMDAT
; _this$ = ecx

; 276  : 	FCCMasterMode GetMasterMode (void) {return (masterMode);};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+144]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ENDP ; FireControlComputer::GetMasterMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h
;	COMDAT ?GetLastNavMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetLastNavMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ PROC ; FireControlComputer::GetLastNavMasterMode, COMDAT
; _this$ = ecx

; 114  : 	FCCMasterMode GetLastNavMasterMode() { return lastNavMasterMode; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+76]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLastNavMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ENDP ; FireControlComputer::GetLastNavMasterMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sensclas.h
;	COMDAT ?CurrentTarget@SensorClass@@QAEPAVSimObjectType@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CurrentTarget@SensorClass@@QAEPAVSimObjectType@@XZ PROC ; SensorClass::CurrentTarget, COMDAT
; _this$ = ecx

; 46   : 	SimObjectType* CurrentTarget(void)	{ return lockedTarget; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+48]
	mov	esp, ebp
	pop	ebp
	ret	0
?CurrentTarget@SensorClass@@QAEPAVSimObjectType@@XZ ENDP ; SensorClass::CurrentTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\mfd.h
;	COMDAT ?GetCurMode@MFDClass@@QAE?AW4MfdMode@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCurMode@MFDClass@@QAE?AW4MfdMode@1@XZ PROC		; MFDClass::GetCurMode, COMDAT
; _this$ = ecx

; 114  : 	MfdMode GetCurMode(void)	{return mode;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCurMode@MFDClass@@QAE?AW4MfdMode@1@XZ ENDP		; MFDClass::GetCurMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\mfd.h
;	COMDAT ?CurMode@MFDClass@@QAE?AW4MfdMode@1@XZ
_TEXT	SEGMENT
tv68 = -8						; size = 4
_this$ = -4						; size = 4
?CurMode@MFDClass@@QAE?AW4MfdMode@1@XZ PROC		; MFDClass::CurMode, COMDAT
; _this$ = ecx

; 71   : 	MfdMode CurMode() { return mode == MfdMenu ? restoreMode : mode; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 1
	jne	SHORT $LN3@CurMode
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR tv68[ebp], edx
	jmp	SHORT $LN4@CurMode
$LN3@CurMode:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR tv68[ebp], ecx
$LN4@CurMode:
	mov	eax, DWORD PTR tv68[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?CurMode@MFDClass@@QAE?AW4MfdMode@1@XZ ENDP		; MFDClass::CurMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\drawable.h
;	COMDAT ?IsSOI@DrawableClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
?IsSOI@DrawableClass@@QAEHXZ PROC			; DrawableClass::IsSOI, COMDAT
; _this$ = ecx

; 141  :       int IsSOI (void) {return (drawFlags & SOI ? TRUE : FALSE);};

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 1
	je	SHORT $LN3@IsSOI
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsSOI
$LN3@IsSOI:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsSOI:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?IsSOI@DrawableClass@@QAEHXZ ENDP			; DrawableClass::IsSOI
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\otwdrive.h
;	COMDAT ?IsHeadTracking@OTWDriverClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsHeadTracking@OTWDriverClass@@QAEHXZ PROC		; OTWDriverClass::IsHeadTracking, COMDAT
; _this$ = ecx

; 885  :     int IsHeadTracking (void) {return mUseHeadTracking;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+34016]
	mov	esp, ebp
	pop	ebp
	ret	0
?IsHeadTracking@OTWDriverClass@@QAEHXZ ENDP		; OTWDriverClass::IsHeadTracking
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\otwdrive.h
;	COMDAT ?SetHeadTracking@OTWDriverClass@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_flag$ = 8						; size = 4
?SetHeadTracking@OTWDriverClass@@QAEXH@Z PROC		; OTWDriverClass::SetHeadTracking, COMDAT
; _this$ = ecx

; 884  :     void SetHeadTracking (int flag) {mUseHeadTracking = flag;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _flag$[ebp]
	mov	DWORD PTR [eax+34016], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetHeadTracking@OTWDriverClass@@QAEXH@Z ENDP		; OTWDriverClass::SetHeadTracking
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\otwdrive.h
;	COMDAT ?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ PROC ; OTWDriverClass::GetVirtualCockpit, COMDAT
; _this$ = ecx

; 882  : 	DrawableBSP *GetVirtualCockpit(){ return vrCockpit; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+33996]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ENDP ; OTWDriverClass::GetVirtualCockpit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\otwdrive.h
;	COMDAT ?SetCameraPanTilt@OTWDriverClass@@QAEXMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pan$ = 8						; size = 4
_tilt$ = 12						; size = 4
?SetCameraPanTilt@OTWDriverClass@@QAEXMM@Z PROC		; OTWDriverClass::SetCameraPanTilt, COMDAT
; _this$ = ecx

; 427  : 	  void SetCameraPanTilt(float pan, float tilt) {eyePan = pan, eyeTilt = tilt;};	

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _pan$[ebp]
	movss	DWORD PTR [eax+32272], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _tilt$[ebp]
	movss	DWORD PTR [ecx+32276], xmm0
	mov	esp, ebp
	pop	ebp
	ret	8
?SetCameraPanTilt@OTWDriverClass@@QAEXMM@Z ENDP		; OTWDriverClass::SetCameraPanTilt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\otwdrive.h
;	COMDAT ?GetFrontTextFlags@OTWDriverClass@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFrontTextFlags@OTWDriverClass@@QAEJXZ PROC		; OTWDriverClass::GetFrontTextFlags, COMDAT
; _this$ = ecx

; 371  : 	  long GetFrontTextFlags() { return(showFrontText); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+32352]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFrontTextFlags@OTWDriverClass@@QAEJXZ ENDP		; OTWDriverClass::GetFrontTextFlags
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\otwdrive.h
;	COMDAT ?SetFrontTextFlags@OTWDriverClass@@QAEXJ@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_flags$ = 8						; size = 4
?SetFrontTextFlags@OTWDriverClass@@QAEXJ@Z PROC		; OTWDriverClass::SetFrontTextFlags, COMDAT
; _this$ = ecx

; 370  :       void SetFrontTextFlags(long flags) { showFrontText=flags; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _flags$[ebp]
	mov	DWORD PTR [eax+32352], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetFrontTextFlags@OTWDriverClass@@QAEXJ@Z ENDP		; OTWDriverClass::SetFrontTextFlags
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\otwdrive.h
;	COMDAT ?SetScale@OTWDriverClass@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newScale$ = 8						; size = 4
?SetScale@OTWDriverClass@@QAEXM@Z PROC			; OTWDriverClass::SetScale, COMDAT
; _this$ = ecx

; 340  :       void SetScale (float newScale) {objectScale = newScale;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _newScale$[ebp]
	movss	DWORD PTR [eax+32124], xmm0
	mov	esp, ebp
	pop	ebp
	ret	4
?SetScale@OTWDriverClass@@QAEXM@Z ENDP			; OTWDriverClass::SetScale
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\playerop.h
;	COMDAT ?ClearSimFlag@PlayerOptionsClass@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_flag$ = 8						; size = 4
?ClearSimFlag@PlayerOptionsClass@@QAEXH@Z PROC		; PlayerOptionsClass::ClearSimFlag, COMDAT
; _this$ = ecx

; 188  : 	void ClearSimFlag (int flag)							{SimFlags &= ~flag;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _flag$[ebp]
	not	eax
	mov	ecx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [ecx+52]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+52], eax
	mov	esp, ebp
	pop	ebp
	ret	4
?ClearSimFlag@PlayerOptionsClass@@QAEXH@Z ENDP		; PlayerOptionsClass::ClearSimFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\playerop.h
;	COMDAT ?SetSimFlag@PlayerOptionsClass@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_flag$ = 8						; size = 4
?SetSimFlag@PlayerOptionsClass@@QAEXH@Z PROC		; PlayerOptionsClass::SetSimFlag, COMDAT
; _this$ = ecx

; 187  : 	void SetSimFlag (int flag)								{SimFlags |= flag;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	or	ecx, DWORD PTR _flag$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+52], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSimFlag@PlayerOptionsClass@@QAEXH@Z ENDP		; PlayerOptionsClass::SetSimFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\playerop.h
;	COMDAT ?Get3dTrackIR@PlayerOptionsClass@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Get3dTrackIR@PlayerOptionsClass@@QBE_NXZ PROC		; PlayerOptionsClass::Get3dTrackIR, COMDAT
; _this$ = ecx

; 180  : 	bool Get3dTrackIR(void) const                           { return TrackIR_3d; }			// Retro 27Dec2003

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+206]
	mov	esp, ebp
	pop	ebp
	ret	0
?Get3dTrackIR@PlayerOptionsClass@@QBE_NXZ ENDP		; PlayerOptionsClass::Get3dTrackIR
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\playerop.h
;	COMDAT ?InvulnerableOn@PlayerOptionsClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
?InvulnerableOn@PlayerOptionsClass@@QAEHXZ PROC		; PlayerOptionsClass::InvulnerableOn, COMDAT
; _this$ = ecx

; 158  : 	int	InvulnerableOn(void)								{ return (SimFlags & SIM_INVULNERABLE) && TRUE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	and	ecx, 512				; 00000200H
	je	SHORT $LN3@Invulnerab
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN3@Invulnerab
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@Invulnerab
$LN3@Invulnerab:
	mov	DWORD PTR tv68[ebp], 0
$LN4@Invulnerab:
	mov	eax, DWORD PTR tv68[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?InvulnerableOn@PlayerOptionsClass@@QAEHXZ ENDP		; PlayerOptionsClass::InvulnerableOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\playerop.h
;	COMDAT ?GetAutopilotMode@PlayerOptionsClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAutopilotMode@PlayerOptionsClass@@QAEHXZ PROC	; PlayerOptionsClass::GetAutopilotMode, COMDAT
; _this$ = ecx

; 143  : 	int GetAutopilotMode (void)								{ return SimAutopilotType; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+68]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetAutopilotMode@PlayerOptionsClass@@QAEHXZ ENDP	; PlayerOptionsClass::GetAutopilotMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\playerop.h
;	COMDAT ?GetAvionicsType@PlayerOptionsClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAvionicsType@PlayerOptionsClass@@QAEHXZ PROC	; PlayerOptionsClass::GetAvionicsType, COMDAT
; _this$ = ecx

; 142  : 	int GetAvionicsType (void)								{ return SimAvionicsType; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+64]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetAvionicsType@PlayerOptionsClass@@QAEHXZ ENDP	; PlayerOptionsClass::GetAvionicsType
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_System_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_System_error_category@std@@UAEPAXI@Z PROC		; std::_System_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_System_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_System_error_category@std@@UAEPAXI@Z ENDP		; std::_System_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_System_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_System_error_category@std@@UAE@XZ PROC		; std::_System_error_category::~_System_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_System_error_category@std@@UAE@XZ ENDP		; std::_System_error_category::~_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::_System_error_category::default_error_condition, COMDAT
; _this$ = ecx

; 641  : 		{	// make error_condition for error code (generic if possible)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 642  : 		if (_Syserror_map(_Errval))

	mov	eax, DWORD PTR __Errval$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@default_er

; 643  : 			return (error_condition(_Errval, generic_category()));

	call	?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@default_er

; 644  : 		else

	jmp	SHORT $LN3@default_er
$LN2@default_er:

; 645  : 			return (error_condition(_Errval, system_category()));

	call	?system_category@std@@YAABVerror_category@1@XZ ; std::system_category
	push	eax
	mov	edx, DWORD PTR __Errval$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@default_er:

; 646  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::_System_error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_System_error_category::message, COMDAT
; _this$ = ecx

; 634  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 635  : 		const char *_Name = _Winerror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Winerror_map@std@@YAPBDH@Z		; std::_Winerror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 636  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 637  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_System_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_System_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_System_error_category@std@@UBEPBDXZ PROC		; std::_System_error_category::name, COMDAT
; _this$ = ecx

; 629  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 630  : 		return ("system");

	mov	eax, OFFSET ??_C@_06FHFOAHML@system?$AA@

; 631  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_System_error_category@std@@UBEPBDXZ ENDP		; std::_System_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_System_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_System_error_category@std@@QAE@XZ PROC		; std::_System_error_category::_System_error_category, COMDAT
; _this$ = ecx

; 624  : 	_System_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_System_error_category@std@@6B@

; 625  : 		{	// default constructor
; 626  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_System_error_category@std@@QAE@XZ ENDP		; std::_System_error_category::_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Iostream_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Iostream_error_category@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iostream_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Iostream_error_category@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Iostream_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Iostream_error_category@std@@UAE@XZ PROC		; std::_Iostream_error_category::~_Iostream_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Iostream_error_category@std@@UAE@XZ ENDP		; std::_Iostream_error_category::~_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT
; _this$ = ecx

; 611  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 612  : 		if (_Errcode == (int)io_errc::stream)

	cmp	DWORD PTR __Errcode$[ebp], 1
	jne	SHORT $LN2@message

; 613  : 			return ("iostream stream error");

	push	OFFSET ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@message

; 614  : 		else

	jmp	SHORT $LN3@message
$LN2@message:

; 615  : 			return (_Generic_error_category::message(_Errcode));

	mov	ecx, DWORD PTR __Errcode$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@message:

; 616  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Iostream_error_category@std@@UBEPBDXZ PROC	; std::_Iostream_error_category::name, COMDAT
; _this$ = ecx

; 606  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 607  : 		return ("iostream");

	mov	eax, OFFSET ??_C@_08LLGCOLLL@iostream?$AA@

; 608  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Iostream_error_category@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Iostream_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iostream_error_category@std@@QAE@XZ PROC		; std::_Iostream_error_category::_Iostream_error_category, COMDAT
; _this$ = ecx

; 601  : 	_Iostream_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Iostream_error_category@std@@6B@

; 602  : 		{	// default constructor
; 603  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iostream_error_category@std@@QAE@XZ ENDP		; std::_Iostream_error_category::_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Generic_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Generic_error_category@std@@UAE@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Generic_error_category@std@@UAE@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 590  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 591  : 		const char *_Name = _Syserror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 592  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 593  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 585  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		return ("generic");

	mov	eax, OFFSET ??_C@_07DCLBNMLN@generic?$AA@

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Generic_error_category@std@@QAE@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT
; _this$ = ecx

; 580  : 	_Generic_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0error_category@std@@QAE@XZ		; std::error_category::error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Generic_error_category@std@@6B@

; 581  : 		{	// default constructor
; 582  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Generic_error_category@std@@QAE@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_condition@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv78 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8error_condition@std@@QBE_NABV01@@Z PROC		; std::error_condition::operator==, COMDAT
; _this$ = ecx

; 376  : 		{	// test if *this == _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 377  : 		return (category() == _Right.category()
; 378  : 			&& value() == _Right.value());

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	mov	ecx, eax
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	cmp	esi, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv78[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv78[ebp]

; 379  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??8error_condition@std@@QBE_NABV01@@Z ENDP		; std::error_condition::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 354  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 356  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 349  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 350  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 351  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 316  : 		{	// construct from error code and category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Cat$[ebp]
	mov	DWORD PTR [edx+4], eax

; 317  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 256  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 257  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 258  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 251  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 252  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 253  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gerror_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gerror_category@std@@UAEPAXI@Z PROC			; std::error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gerror_category@std@@UAEPAXI@Z ENDP			; std::error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv65 = -4						; size = 4
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 184  : 		{	// compare categories for equality

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 185  : 		return (this == &_Right);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv65[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv65[ebp]

; 186  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -4						; size = 4
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 415  : 	{	// test if conditions same for this category

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 416  : 	return (*this == _Code.category() && _Code.value() == _Errval);

	mov	ecx, DWORD PTR __Code$[ebp]
	call	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@equivalent
	mov	ecx, DWORD PTR __Code$[ebp]
	call	?value@error_code@std@@QBEHXZ		; std::error_code::value
	cmp	eax, DWORD PTR __Errval$[ebp]
	jne	SHORT $LN3@equivalent
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN4@equivalent
$LN3@equivalent:
	mov	DWORD PTR tv74[ebp], 0
$LN4@equivalent:
	mov	al, BYTE PTR tv74[ebp]

; 417  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 408  : 	{	// test if error code same condition

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 409  : 	return (default_error_condition(_Errval) == _Cond);

	mov	eax, DWORD PTR __Cond$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	ecx, eax
	call	??8error_condition@std@@QBE_NABV01@@Z	; std::error_condition::operator==

; 410  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 401  : 	{	// make error_condition for error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 402  : 	return (error_condition(_Errval, *this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 403  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 167  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 168  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0error_category@std@@QAE@XZ PROC			; std::error_category::error_category, COMDAT
; _this$ = ecx

; 162  : 	error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 163  : 		{	// default constructor
; 164  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0error_category@std@@QAE@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?system_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?system_category@std@@YAABVerror_category@1@XZ PROC	; std::system_category, COMDAT

; 679  : 	{	// get system_category

	push	ebp
	mov	ebp, esp

; 680  : 	return (_Error_objects<int>::_System_object);

	mov	eax, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object

; 681  : 	}

	pop	ebp
	ret	0
?system_category@std@@YAABVerror_category@1@XZ ENDP	; std::system_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?generic_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?generic_category@std@@YAABVerror_category@1@XZ PROC	; std::generic_category, COMDAT

; 669  : 	{	// get generic_category

	push	ebp
	mov	ebp, esp

; 670  : 	return (_Error_objects<int>::_Generic_object);

	mov	eax, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object

; 671  : 	}

	pop	ebp
	ret	0
?generic_category@std@@YAABVerror_category@1@XZ ENDP	; std::generic_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocale
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC				; std::locale::id::id, COMDAT
; _this$ = ecx

; 74   : 			{	// construct with specified stamp value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx

; 75   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h
;	COMDAT ?SetAVTR@SimulationDriver@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newFlag$ = 8						; size = 4
?SetAVTR@SimulationDriver@@QAEXH@Z PROC			; SimulationDriver::SetAVTR, COMDAT
; _this$ = ecx

; 101  : 	void SetAVTR (int newFlag) {avtrOn = newFlag; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newFlag$[ebp]
	mov	DWORD PTR [eax+356], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetAVTR@SimulationDriver@@QAEXH@Z ENDP			; SimulationDriver::SetAVTR
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h
;	COMDAT ?AVTROn@SimulationDriver@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AVTROn@SimulationDriver@@QAEHXZ PROC			; SimulationDriver::AVTROn, COMDAT
; _this$ = ecx

; 100  : 	int AVTROn (void) {return avtrOn;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+356]
	mov	esp, ebp
	pop	ebp
	ret	0
?AVTROn@SimulationDriver@@QAEHXZ ENDP			; SimulationDriver::AVTROn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h
;	COMDAT ?SetMotion@SimulationDriver@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newFlag$ = 8						; size = 4
?SetMotion@SimulationDriver@@QAEXH@Z PROC		; SimulationDriver::SetMotion, COMDAT
; _this$ = ecx

; 99   : 	void SetMotion (int newFlag) {motionOn = newFlag;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newFlag$[ebp]
	mov	DWORD PTR [eax+352], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetMotion@SimulationDriver@@QAEXH@Z ENDP		; SimulationDriver::SetMotion
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h
;	COMDAT ?MotionOn@SimulationDriver@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?MotionOn@SimulationDriver@@QAEHXZ PROC			; SimulationDriver::MotionOn, COMDAT
; _this$ = ecx

; 98   : 	int MotionOn(void) {return motionOn;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+352]
	mov	esp, ebp
	pop	ebp
	ret	0
?MotionOn@SimulationDriver@@QAEHXZ ENDP			; SimulationDriver::MotionOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h
;	COMDAT ?RunningTactical@SimulationDriver@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
tv80 = -8						; size = 4
tv76 = -4						; size = 4
?RunningTactical@SimulationDriver@@QBE_NXZ PROC		; SimulationDriver::RunningTactical, COMDAT
; _this$ = ecx

; 57   : 	bool RunningTactical() const             { return FalconLocalGame->GetGameType() == game_TacticalEngagement; }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@RunningTac
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN4@RunningTac
$LN3@RunningTac:
	mov	DWORD PTR tv76[ebp], 0
$LN4@RunningTac:
	mov	ecx, DWORD PTR tv76[ebp]
	call	?GetGameType@FalconGameEntity@@QAE?AW4FalconGameType@@XZ ; FalconGameEntity::GetGameType
	cmp	eax, 3
	jne	SHORT $LN5@RunningTac
	mov	DWORD PTR tv80[ebp], 1
	jmp	SHORT $LN6@RunningTac
$LN5@RunningTac:
	mov	DWORD PTR tv80[ebp], 0
$LN6@RunningTac:
	mov	al, BYTE PTR tv80[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?RunningTactical@SimulationDriver@@QBE_NXZ ENDP		; SimulationDriver::RunningTactical
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h
;	COMDAT ?RunningDogfight@SimulationDriver@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
tv80 = -8						; size = 4
tv76 = -4						; size = 4
?RunningDogfight@SimulationDriver@@QBE_NXZ PROC		; SimulationDriver::RunningDogfight, COMDAT
; _this$ = ecx

; 55   : 	bool RunningDogfight() const             { return FalconLocalGame->GetGameType() == game_Dogfight; }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@RunningDog
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN4@RunningDog
$LN3@RunningDog:
	mov	DWORD PTR tv76[ebp], 0
$LN4@RunningDog:
	mov	ecx, DWORD PTR tv76[ebp]
	call	?GetGameType@FalconGameEntity@@QAE?AW4FalconGameType@@XZ ; FalconGameEntity::GetGameType
	cmp	eax, 2
	jne	SHORT $LN5@RunningDog
	mov	DWORD PTR tv80[ebp], 1
	jmp	SHORT $LN6@RunningDog
$LN5@RunningDog:
	mov	DWORD PTR tv80[ebp], 0
$LN6@RunningDog:
	mov	al, BYTE PTR tv80[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?RunningDogfight@SimulationDriver@@QBE_NXZ ENDP		; SimulationDriver::RunningDogfight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetSPType@CampBaseClass@@QBEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSPType@CampBaseClass@@QBEEXZ PROC			; CampBaseClass::GetSPType, COMDAT
; _this$ = ecx

; 291  : 	uchar GetSPType (void) const						{	return (EntityType())->classInfo_[VU_SPTYPE]; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ ; VuEntity::EntityType
	mov	ecx, 1
	shl	ecx, 2
	mov	al, BYTE PTR [eax+ecx+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSPType@CampBaseClass@@QBEEXZ ENDP			; CampBaseClass::GetSPType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?SetEWSProg@AircraftClass@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_num$ = 8						; size = 4
?SetEWSProg@AircraftClass@@QAEXH@Z PROC			; AircraftClass::SetEWSProg, COMDAT
; _this$ = ecx

; 549  : 	void SetEWSProg(int num) { if ((num >= 0) && (num <= 3)) EWSProgNum = num; }  // MD: 4 position knob

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	cmp	DWORD PTR _num$[ebp], 0
	jl	SHORT $LN2@SetEWSProg
	cmp	DWORD PTR _num$[ebp], 3
	jg	SHORT $LN2@SetEWSProg
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _num$[ebp]
	mov	DWORD PTR [eax+1500], ecx
$LN2@SetEWSProg:
	mov	esp, ebp
	pop	ebp
	ret	4
?SetEWSProg@AircraftClass@@QAEXH@Z ENDP			; AircraftClass::SetEWSProg
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?SetPGM@AircraftClass@@QAEXW4EWSPGMSwitch@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_t$ = 8							; size = 4
?SetPGM@AircraftClass@@QAEXW4EWSPGMSwitch@1@@Z PROC	; AircraftClass::SetPGM, COMDAT
; _this$ = ecx

; 544  : 	void SetPGM (EWSPGMSwitch t) { EWSPgm = t; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+1496], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetPGM@AircraftClass@@QAEXW4EWSPGMSwitch@1@@Z ENDP	; AircraftClass::SetPGM
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?EWSPGM@AircraftClass@@QAE?AW4EWSPGMSwitch@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?EWSPGM@AircraftClass@@QAE?AW4EWSPGMSwitch@1@XZ PROC	; AircraftClass::EWSPGM, COMDAT
; _this$ = ecx

; 543  : 	EWSPGMSwitch EWSPGM() { return EWSPgm; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1496]
	mov	esp, ebp
	pop	ebp
	ret	0
?EWSPGM@AircraftClass@@QAE?AW4EWSPGMSwitch@1@XZ ENDP	; AircraftClass::EWSPGM
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?SetMainPower@AircraftClass@@QAEXW4MainPowerType@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_t$ = 8							; size = 4
?SetMainPower@AircraftClass@@QAEXW4MainPowerType@1@@Z PROC ; AircraftClass::SetMainPower, COMDAT
; _this$ = ecx

; 521  : 	void SetMainPower (MainPowerType t) { mainPower = t; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+1484], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetMainPower@AircraftClass@@QAEXW4MainPowerType@1@@Z ENDP ; AircraftClass::SetMainPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?MainPowerOn@AircraftClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
?MainPowerOn@AircraftClass@@QAEHXZ PROC			; AircraftClass::MainPowerOn, COMDAT
; _this$ = ecx

; 520  : 	BOOL MainPowerOn() { return mainPower == MainPowerMain; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1484], 2
	jne	SHORT $LN3@MainPowerO
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@MainPowerO
$LN3@MainPowerO:
	mov	DWORD PTR tv66[ebp], 0
$LN4@MainPowerO:
	mov	eax, DWORD PTR tv66[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?MainPowerOn@AircraftClass@@QAEHXZ ENDP			; AircraftClass::MainPowerOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?PowerToggle@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_fl$ = 8						; size = 4
?PowerToggle@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z PROC ; AircraftClass::PowerToggle, COMDAT
; _this$ = ecx

; 512  : 	void PowerToggle (AvionicsPowerFlags fl) { powerFlags ^= fl; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1480]
	xor	ecx, DWORD PTR _fl$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1480], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?PowerToggle@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ENDP ; AircraftClass::PowerToggle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?PowerOff@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_fl$ = 8						; size = 4
?PowerOff@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z PROC ; AircraftClass::PowerOff, COMDAT
; _this$ = ecx

; 511  : 	void PowerOff (AvionicsPowerFlags fl) { powerFlags &= ~fl; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _fl$[ebp]
	not	eax
	mov	ecx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [ecx+1480]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1480], eax
	mov	esp, ebp
	pop	ebp
	ret	4
?PowerOff@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ENDP ; AircraftClass::PowerOff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?PowerOn@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_fl$ = 8						; size = 4
?PowerOn@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z PROC ; AircraftClass::PowerOn, COMDAT
; _this$ = ecx

; 509  : 	void PowerOn (AvionicsPowerFlags fl) { powerFlags |= fl; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1480]
	or	ecx, DWORD PTR _fl$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1480], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?PowerOn@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ENDP ; AircraftClass::PowerOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?ClearAPFlag@AircraftClass@@QAEXW4APFlags@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_flag$ = 8						; size = 4
?ClearAPFlag@AircraftClass@@QAEXW4APFlags@1@@Z PROC	; AircraftClass::ClearAPFlag, COMDAT
; _this$ = ecx

; 440  : 	void ClearAPFlag (APFlags flag) {APFlag &= ~flag;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _flag$[ebp]
	not	eax
	mov	ecx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [ecx+1048]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1048], eax
	mov	esp, ebp
	pop	ebp
	ret	4
?ClearAPFlag@AircraftClass@@QAEXW4APFlags@1@@Z ENDP	; AircraftClass::ClearAPFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?SetAPFlag@AircraftClass@@QAEXW4APFlags@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_flag$ = 8						; size = 4
?SetAPFlag@AircraftClass@@QAEXW4APFlags@1@@Z PROC	; AircraftClass::SetAPFlag, COMDAT
; _this$ = ecx

; 439  : 	void SetAPFlag (APFlags flag) {APFlag |= flag;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1048]
	or	ecx, DWORD PTR _flag$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1048], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetAPFlag@AircraftClass@@QAEXW4APFlags@1@@Z ENDP	; AircraftClass::SetAPFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?IsOn@AircraftClass@@QAEHW4APFlags@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_flag$ = 8						; size = 4
?IsOn@AircraftClass@@QAEHW4APFlags@1@@Z PROC		; AircraftClass::IsOn, COMDAT
; _this$ = ecx

; 438  : 	int IsOn (APFlags flag) {return APFlag & flag ? 1 : 0;};

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1048]
	and	ecx, DWORD PTR _flag$[ebp]
	je	SHORT $LN3@IsOn
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsOn
$LN3@IsOn:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsOn:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsOn@AircraftClass@@QAEHW4APFlags@1@@Z ENDP		; AircraftClass::IsOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?RaltOff@AircraftClass@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?RaltOff@AircraftClass@@QAEXXZ PROC			; AircraftClass::RaltOff, COMDAT
; _this$ = ecx

; 419  : 	void RaltOff () { RALTStatus = ROFF; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1004], 0
	mov	esp, ebp
	pop	ebp
	ret	0
?RaltOff@AircraftClass@@QAEXXZ ENDP			; AircraftClass::RaltOff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?RaltStdby@AircraftClass@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?RaltStdby@AircraftClass@@QAEXXZ PROC			; AircraftClass::RaltStdby, COMDAT
; _this$ = ecx

; 418  : 	void RaltStdby () {RALTStatus = RSTANDBY;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1004], 1
	mov	esp, ebp
	pop	ebp
	ret	0
?RaltStdby@AircraftClass@@QAEXXZ ENDP			; AircraftClass::RaltStdby
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?RaltOn@AircraftClass@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?RaltOn@AircraftClass@@QAEXXZ PROC			; AircraftClass::RaltOn, COMDAT
; _this$ = ecx

; 417  : 	void RaltOn() {RALTStatus = RON;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1004], 2
	mov	esp, ebp
	pop	ebp
	ret	0
?RaltOn@AircraftClass@@QAEXXZ ENDP			; AircraftClass::RaltOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?IsComplex@AircraftClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
?IsComplex@AircraftClass@@QAEHXZ PROC			; AircraftClass::IsComplex, COMDAT
; _this$ = ecx

; 336  : 	int            IsComplex (void) {return ((acFlags & isComplex) ? TRUE : FALSE);}

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+964]
	and	ecx, 4
	je	SHORT $LN3@IsComplex
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsComplex
$LN3@IsComplex:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsComplex:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?IsComplex@AircraftClass@@QAEHXZ ENDP			; AircraftClass::IsComplex
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?IsF16@AircraftClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
?IsF16@AircraftClass@@QAEHXZ PROC			; AircraftClass::IsF16, COMDAT
; _this$ = ecx

; 335  : 	int            IsF16 (void) {return (acFlags & isF16 ? TRUE : FALSE);}

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+964]
	and	ecx, 1
	je	SHORT $LN3@IsF16
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsF16
$LN3@IsF16:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsF16:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?IsF16@AircraftClass@@QAEHXZ ENDP			; AircraftClass::IsF16
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?AutopilotType@AircraftClass@@QAE?AW4AutoPilotType@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AutopilotType@AircraftClass@@QAE?AW4AutoPilotType@1@XZ PROC ; AircraftClass::AutopilotType, COMDAT
; _this$ = ecx

; 329  : 	AutoPilotType	AutopilotType (void) {return autopilotType;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+968]
	mov	esp, ebp
	pop	ebp
	ret	0
?AutopilotType@AircraftClass@@QAE?AW4AutoPilotType@1@XZ ENDP ; AircraftClass::AutopilotType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?LEFState@AircraftClass@@QAEHW4LEFStateFlags@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_fl$ = 8						; size = 4
?LEFState@AircraftClass@@QAEHW4LEFStateFlags@1@@Z PROC	; AircraftClass::LEFState, COMDAT
; _this$ = ecx

; 275  : 	int LEFState(LEFStateFlags fl) { return (LEFFlags & fl) == (unsigned int)fl ? 1 : 0; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+864]
	and	ecx, DWORD PTR _fl$[ebp]
	cmp	ecx, DWORD PTR _fl$[ebp]
	jne	SHORT $LN3@LEFState
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@LEFState
$LN3@LEFState:
	mov	DWORD PTR tv67[ebp], 0
$LN4@LEFState:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?LEFState@AircraftClass@@QAEHW4LEFStateFlags@1@@Z ENDP	; AircraftClass::LEFState
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?AVTRState@AircraftClass@@QAEHW4AVTRStateFlags@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_fl$ = 8						; size = 4
?AVTRState@AircraftClass@@QAEHW4AVTRStateFlags@1@@Z PROC ; AircraftClass::AVTRState, COMDAT
; _this$ = ecx

; 251  : 	int AVTRState(AVTRStateFlags fl) { return (AVTRFlags & fl) == (unsigned int)fl ? 1 : 0; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+840]
	and	ecx, DWORD PTR _fl$[ebp]
	cmp	ecx, DWORD PTR _fl$[ebp]
	jne	SHORT $LN3@AVTRState
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@AVTRState
$LN3@AVTRState:
	mov	DWORD PTR tv67[ebp], 0
$LN4@AVTRState:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?AVTRState@AircraftClass@@QAEHW4AVTRStateFlags@1@@Z ENDP ; AircraftClass::AVTRState
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?AVTROff@AircraftClass@@QAEXW4AVTRStateFlags@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_fl$ = 8						; size = 4
?AVTROff@AircraftClass@@QAEXW4AVTRStateFlags@1@@Z PROC	; AircraftClass::AVTROff, COMDAT
; _this$ = ecx

; 250  : 	void AVTROff(AVTRStateFlags fl) { AVTRFlags &= ~fl; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _fl$[ebp]
	not	eax
	mov	ecx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [ecx+840]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+840], eax
	mov	esp, ebp
	pop	ebp
	ret	4
?AVTROff@AircraftClass@@QAEXW4AVTRStateFlags@1@@Z ENDP	; AircraftClass::AVTROff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?AVTROn@AircraftClass@@QAEXW4AVTRStateFlags@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_fl$ = 8						; size = 4
?AVTROn@AircraftClass@@QAEXW4AVTRStateFlags@1@@Z PROC	; AircraftClass::AVTROn, COMDAT
; _this$ = ecx

; 249  : 	void AVTROn(AVTRStateFlags fl) { AVTRFlags |= fl; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+840]
	or	ecx, DWORD PTR _fl$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+840], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?AVTROn@AircraftClass@@QAEXW4AVTRStateFlags@1@@Z ENDP	; AircraftClass::AVTROn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_fl$ = 8						; size = 4
?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z PROC	; AircraftClass::INSState, COMDAT
; _this$ = ecx

; 211  : 	int INSState(INSAlignFlags fl) { return (INSFlags & fl) == (unsigned int)fl ? 1 : 0; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+768]
	and	ecx, DWORD PTR _fl$[ebp]
	cmp	ecx, DWORD PTR _fl$[ebp]
	jne	SHORT $LN3@INSState
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@INSState
$LN3@INSState:
	mov	DWORD PTR tv67[ebp], 0
$LN4@INSState:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ENDP	; AircraftClass::INSState
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?INSOff@AircraftClass@@QAEXW4INSAlignFlags@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_fl$ = 8						; size = 4
?INSOff@AircraftClass@@QAEXW4INSAlignFlags@1@@Z PROC	; AircraftClass::INSOff, COMDAT
; _this$ = ecx

; 210  : 	void INSOff(INSAlignFlags fl) { INSFlags &= ~fl; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _fl$[ebp]
	not	eax
	mov	ecx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [ecx+768]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+768], eax
	mov	esp, ebp
	pop	ebp
	ret	4
?INSOff@AircraftClass@@QAEXW4INSAlignFlags@1@@Z ENDP	; AircraftClass::INSOff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?INSOn@AircraftClass@@QAEXW4INSAlignFlags@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_fl$ = 8						; size = 4
?INSOn@AircraftClass@@QAEXW4INSAlignFlags@1@@Z PROC	; AircraftClass::INSOn, COMDAT
; _this$ = ecx

; 209  : 	void INSOn(INSAlignFlags fl) { INSFlags |= fl; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+768]
	or	ecx, DWORD PTR _fl$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+768], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?INSOn@AircraftClass@@QAEXW4INSAlignFlags@1@@Z ENDP	; AircraftClass::INSOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?ExtlState@AircraftClass@@QBEHW4ExtlLightFlags@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv69 = -4						; size = 4
_fl$ = 8						; size = 4
?ExtlState@AircraftClass@@QBEHW4ExtlLightFlags@1@@Z PROC ; AircraftClass::ExtlState, COMDAT
; _this$ = ecx

; 188  : 	int ExtlState(ExtlLightFlags fl) const { return (IsAcStatusBitsSet(fl) ? 1 : 0); }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _fl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsAcStatusBitsSet@AircraftClass@@QBE_NH@Z ; AircraftClass::IsAcStatusBitsSet
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@ExtlState
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@ExtlState
$LN3@ExtlState:
	mov	DWORD PTR tv69[ebp], 0
$LN4@ExtlState:
	mov	eax, DWORD PTR tv69[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?ExtlState@AircraftClass@@QBEHW4ExtlLightFlags@1@@Z ENDP ; AircraftClass::ExtlState
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?ExtlOff@AircraftClass@@QAEXW4ExtlLightFlags@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_fl$ = 8						; size = 4
?ExtlOff@AircraftClass@@QAEXW4ExtlLightFlags@1@@Z PROC	; AircraftClass::ExtlOff, COMDAT
; _this$ = ecx

; 187  : 	void ExtlOff(ExtlLightFlags fl){ ClearAcStatusBits(fl); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _fl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearAcStatusBits@AircraftClass@@QAEXH@Z ; AircraftClass::ClearAcStatusBits
	mov	esp, ebp
	pop	ebp
	ret	4
?ExtlOff@AircraftClass@@QAEXW4ExtlLightFlags@1@@Z ENDP	; AircraftClass::ExtlOff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?ExtlOn@AircraftClass@@QAEXW4ExtlLightFlags@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_fl$ = 8						; size = 4
?ExtlOn@AircraftClass@@QAEXW4ExtlLightFlags@1@@Z PROC	; AircraftClass::ExtlOn, COMDAT
; _this$ = ecx

; 186  : 	void ExtlOn(ExtlLightFlags fl) { SetAcStatusBits(fl); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _fl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAcStatusBits@AircraftClass@@QAEXH@Z	; AircraftClass::SetAcStatusBits
	mov	esp, ebp
	pop	ebp
	ret	4
?ExtlOn@AircraftClass@@QAEXW4ExtlLightFlags@1@@Z ENDP	; AircraftClass::ExtlOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?IsAcStatusBitsSet@AircraftClass@@QBE_NH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_bits$ = 8						; size = 4
?IsAcStatusBitsSet@AircraftClass@@QBE_NH@Z PROC		; AircraftClass::IsAcStatusBitsSet, COMDAT
; _this$ = ecx

; 170  : 	bool IsAcStatusBitsSet(int bits) const { return (status_bits & bits) == bits; }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+760]
	and	ecx, DWORD PTR _bits$[ebp]
	cmp	ecx, DWORD PTR _bits$[ebp]
	jne	SHORT $LN3@IsAcStatus
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsAcStatus
$LN3@IsAcStatus:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsAcStatus:
	mov	al, BYTE PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsAcStatusBitsSet@AircraftClass@@QBE_NH@Z ENDP		; AircraftClass::IsAcStatusBitsSet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?GetSpotLight@AircraftClass@@QBE?AW4LightSwitch@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSpotLight@AircraftClass@@QBE?AW4LightSwitch@1@XZ PROC ; AircraftClass::GetSpotLight, COMDAT
; _this$ = ecx

; 113  : 	LightSwitch GetSpotLight() const { return spotLight; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+752]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSpotLight@AircraftClass@@QBE?AW4LightSwitch@1@XZ ENDP ; AircraftClass::GetSpotLight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?GetInstrumentLight@AircraftClass@@QBE?AW4LightSwitch@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetInstrumentLight@AircraftClass@@QBE?AW4LightSwitch@1@XZ PROC ; AircraftClass::GetInstrumentLight, COMDAT
; _this$ = ecx

; 112  : 	LightSwitch GetInstrumentLight() const { return instrumentLight; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+748]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetInstrumentLight@AircraftClass@@QBE?AW4LightSwitch@1@XZ ENDP ; AircraftClass::GetInstrumentLight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?GetInteriorLight@AircraftClass@@QBE?AW4LightSwitch@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetInteriorLight@AircraftClass@@QBE?AW4LightSwitch@1@XZ PROC ; AircraftClass::GetInteriorLight, COMDAT
; _this$ = ecx

; 111  : 	LightSwitch GetInteriorLight() const { return interiorLight; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+744]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetInteriorLight@AircraftClass@@QBE?AW4LightSwitch@1@XZ ENDP ; AircraftClass::GetInteriorLight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?SetSpotLight@AircraftClass@@QAEXW4LightSwitch@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_st$ = 8						; size = 4
?SetSpotLight@AircraftClass@@QAEXW4LightSwitch@1@@Z PROC ; AircraftClass::SetSpotLight, COMDAT
; _this$ = ecx

; 110  : 	void SetSpotLight(LightSwitch st) { spotLight = st; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _st$[ebp]
	mov	DWORD PTR [eax+752], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSpotLight@AircraftClass@@QAEXW4LightSwitch@1@@Z ENDP ; AircraftClass::SetSpotLight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?SetInstrumentLight@AircraftClass@@QAEXW4LightSwitch@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_st$ = 8						; size = 4
?SetInstrumentLight@AircraftClass@@QAEXW4LightSwitch@1@@Z PROC ; AircraftClass::SetInstrumentLight, COMDAT
; _this$ = ecx

; 109  : 	void SetInstrumentLight(LightSwitch st) { instrumentLight = st; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _st$[ebp]
	mov	DWORD PTR [eax+748], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetInstrumentLight@AircraftClass@@QAEXW4LightSwitch@1@@Z ENDP ; AircraftClass::SetInstrumentLight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?SetInteriorLight@AircraftClass@@QAEXW4LightSwitch@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_st$ = 8						; size = 4
?SetInteriorLight@AircraftClass@@QAEXW4LightSwitch@1@@Z PROC ; AircraftClass::SetInteriorLight, COMDAT
; _this$ = ecx

; 108  : 	void SetInteriorLight(LightSwitch st) { interiorLight = st; if (st){ SetAcStatusBits(ACSTATUS_PITLIGHT); } };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _st$[ebp]
	mov	DWORD PTR [eax+744], ecx
	cmp	DWORD PTR _st$[ebp], 0
	je	SHORT $LN2@SetInterio
	push	256					; 00000100H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAcStatusBits@AircraftClass@@QAEXH@Z	; AircraftClass::SetAcStatusBits
$LN2@SetInterio:
	mov	esp, ebp
	pop	ebp
	ret	4
?SetInteriorLight@AircraftClass@@QAEXW4LightSwitch@1@@Z ENDP ; AircraftClass::SetInteriorLight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ PROC ; VuBin<SimWeaponClass>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ENDP ; VuBin<SimWeaponClass>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ PROC		; VuBin<SimWeaponClass>::operator bool, COMDAT
; _this$ = ecx

; 40   : 	operator bool() const{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 		return e != NULL;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@operator
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv66[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv66[ebp]

; 42   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ ENDP		; VuBin<SimWeaponClass>::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simveh.h
;	COMDAT ?GetSOI@SimVehicleClass@@QAE?AW4SOI@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSOI@SimVehicleClass@@QAE?AW4SOI@1@XZ PROC		; SimVehicleClass::GetSOI, COMDAT
; _this$ = ecx

; 64   : 	SOI GetSOI(void)	{return curSOI;};	//MI

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+724]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSOI@SimVehicleClass@@QAE?AW4SOI@1@XZ ENDP		; SimVehicleClass::GetSOI
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simmover.h
;	COMDAT ?SetSwitch@SimMoverClass@@QAEXHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_num$ = 8						; size = 4
_val$ = 12						; size = 4
?SetSwitch@SimMoverClass@@QAEXHH@Z PROC			; SimMoverClass::SetSwitch, COMDAT
; _this$ = ecx

; 134  : 	void SetSwitch (int num, int val) { ShiAssert(num < numSwitches); if (num < numSwitches) { switchData[num] = val; switchChange[num] = TRUE;} }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _num$[ebp]
	cmp	ecx, DWORD PTR [eax+604]
	jge	SHORT $LN2@SetSwitch
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+592]
	mov	ecx, DWORD PTR _num$[ebp]
	mov	edx, DWORD PTR _val$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+596]
	mov	edx, DWORD PTR _num$[ebp]
	mov	DWORD PTR [ecx+edx*4], 1
$LN2@SetSwitch:
	mov	esp, ebp
	pop	ebp
	ret	8
?SetSwitch@SimMoverClass@@QAEXHH@Z ENDP			; SimMoverClass::SetSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
;	COMDAT ?IsSetFlag@SimBaseClass@@QBEHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
_flag$ = 8						; size = 4
?IsSetFlag@SimBaseClass@@QBEHH@Z PROC			; SimBaseClass::IsSetFlag, COMDAT
; _this$ = ecx

; 178  : 	int  IsSetFlag(int flag) const { return ((specialData.flags & flag) ? TRUE : FALSE); }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+172]
	and	ecx, DWORD PTR _flag$[ebp]
	je	SHORT $LN3@IsSetFlag
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@IsSetFlag
$LN3@IsSetFlag:
	mov	DWORD PTR tv68[ebp], 0
$LN4@IsSetFlag:
	mov	eax, DWORD PTR tv68[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsSetFlag@SimBaseClass@@QBEHH@Z ENDP			; SimBaseClass::IsSetFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcsess.h
;	COMDAT ?SetBubbleRatio@FalconSessionEntity@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ratio$ = 8						; size = 4
?SetBubbleRatio@FalconSessionEntity@@QAEXM@Z PROC	; FalconSessionEntity::SetBubbleRatio, COMDAT
; _this$ = ecx

; 182  : 	void SetBubbleRatio (float ratio)	{ bubbleRatio = ratio;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _ratio$[ebp]
	movss	DWORD PTR [eax+496], xmm0
	mov	esp, ebp
	pop	ebp
	ret	4
?SetBubbleRatio@FalconSessionEntity@@QAEXM@Z ENDP	; FalconSessionEntity::SetBubbleRatio
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcsess.h
;	COMDAT ?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ PROC ; FalconSessionEntity::GetGame, COMDAT
; _this$ = ecx

; 154  : 	FalconGameEntity* GetGame (void)              { return (FalconGameEntity*)VuSessionEntity::Game(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ ; VuSessionEntity::Game
	mov	esp, ebp
	pop	ebp
	ret	0
?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ENDP ; FalconSessionEntity::GetGame
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\rules.h
;	COMDAT ?InvulnerableOn@RulesClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv72 = -4						; size = 4
?InvulnerableOn@RulesClass@@QAEHXZ PROC			; RulesClass::InvulnerableOn, COMDAT
; _this$ = ecx

; 75   : 		int	InvulnerableOn(void)								{ return (SimFlags & SIM_INVULNERABLE) && TRUE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	and	ecx, 512				; 00000200H
	je	SHORT $LN3@Invulnerab
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN3@Invulnerab
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN4@Invulnerab
$LN3@Invulnerab:
	mov	DWORD PTR tv72[ebp], 0
$LN4@Invulnerab:
	mov	eax, DWORD PTR tv72[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?InvulnerableOn@RulesClass@@QAEHXZ ENDP			; RulesClass::InvulnerableOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\rules.h
;	COMDAT ?ExternalViewOn@RulesClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv73 = -4						; size = 4
?ExternalViewOn@RulesClass@@QAEHXZ PROC			; RulesClass::ExternalViewOn, COMDAT
; _this$ = ecx

; 74   : 		int ExternalViewOn (void)								{ return (GeneralFlags & GEN_EXTERNAL_VIEW) && TRUE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+72]
	and	ecx, 32					; 00000020H
	je	SHORT $LN3@ExternalVi
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN3@ExternalVi
	mov	DWORD PTR tv73[ebp], 1
	jmp	SHORT $LN4@ExternalVi
$LN3@ExternalVi:
	mov	DWORD PTR tv73[ebp], 0
$LN4@ExternalVi:
	mov	eax, DWORD PTR tv73[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?ExternalViewOn@RulesClass@@QAEHXZ ENDP			; RulesClass::ExternalViewOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\rules.h
;	COMDAT ?WeatherOn@RulesClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv72 = -4						; size = 4
?WeatherOn@RulesClass@@QAEHXZ PROC			; RulesClass::WeatherOn, COMDAT
; _this$ = ecx

; 71   : 		int WeatherOn (void)									{ return !(GeneralFlags & GEN_NO_WEATHER); }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+72]
	and	ecx, 1
	jne	SHORT $LN3@WeatherOn
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN4@WeatherOn
$LN3@WeatherOn:
	mov	DWORD PTR tv72[ebp], 0
$LN4@WeatherOn:
	mov	eax, DWORD PTR tv72[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?WeatherOn@RulesClass@@QAEHXZ ENDP			; RulesClass::WeatherOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\rules.h
;	COMDAT ?BlackoutOn@RulesClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv71 = -4						; size = 4
?BlackoutOn@RulesClass@@QAEHXZ PROC			; RulesClass::BlackoutOn, COMDAT
; _this$ = ecx

; 63   : 		int BlackoutOn (void)									{ return !(SimFlags & SIM_NO_BLACKOUT); }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	and	ecx, 2
	jne	SHORT $LN3@BlackoutOn
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN4@BlackoutOn
$LN3@BlackoutOn:
	mov	DWORD PTR tv71[ebp], 0
$LN4@BlackoutOn:
	mov	eax, DWORD PTR tv71[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?BlackoutOn@RulesClass@@QAEHXZ ENDP			; RulesClass::BlackoutOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\rules.h
;	COMDAT ?GetPadlockMode@RulesClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPadlockMode@RulesClass@@QAEHXZ PROC			; RulesClass::GetPadlockMode, COMDAT
; _this$ = ecx

; 61   : 		int GetPadlockMode (void)								{ return SimPadlockMode; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+52]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetPadlockMode@RulesClass@@QAEHXZ ENDP			; RulesClass::GetPadlockMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWStepHudContrastUp@@YAXKHPAX@Z PROC			; OTWStepHudContrastUp

; 2996 : {

	push	ebp
	mov	ebp, esp

; 2997 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN2@OTWStepHud
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@OTWStepHud
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@OTWStepHud

; 2998 :     {
; 2999 : 		if(TheHud)

	cmp	DWORD PTR ?TheHud@@3PAVHudClass@@A, 0	; TheHud
	je	SHORT $LN2@OTWStepHud

; 3000 : 		{
; 3001 : 			TheHud->ContWheelPos += 0.1F;

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR [ecx+5140]
	addss	xmm0, DWORD PTR __real@3dcccccd
	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	DWORD PTR [edx+5140], xmm0

; 3002 : 			if(TheHud->ContWheelPos > 1.0F) TheHud->ContWheelPos = 1.0F;

	mov	eax, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR [eax+5140]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN1@OTWStepHud
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [ecx+5140], xmm0
$LN1@OTWStepHud:

; 3003 : 			TheHud->SetContrastLevel();

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?SetContrastLevel@HudClass@@QAEXXZ	; HudClass::SetContrastLevel
$LN2@OTWStepHud:

; 3004 : 		}
; 3005 :     }
; 3006 : }

	pop	ebp
	ret	0
?OTWStepHudContrastUp@@YAXKHPAX@Z ENDP			; OTWStepHudContrastUp
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWStepHudContrastDn@@YAXKHPAX@Z PROC			; OTWStepHudContrastDn

; 2981 : {

	push	ebp
	mov	ebp, esp

; 2982 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN1@OTWStepHud
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN1@OTWStepHud
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN1@OTWStepHud

; 2983 :   {
; 2984 : 		if(TheHud)

	cmp	DWORD PTR ?TheHud@@3PAVHudClass@@A, 0	; TheHud
	je	$LN1@OTWStepHud

; 2985 : 		{
; 2986 : 			TheHud->ContWheelPos -= 0.1F;

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR [ecx+5140]
	subss	xmm0, DWORD PTR __real@3dcccccd
	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	DWORD PTR [edx+5140], xmm0

; 2987 : 			if(TheHud->ContWheelPos < 0.0F) TheHud->ContWheelPos = 0.0F;

	mov	eax, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [eax+5140]
	jbe	SHORT $LN2@OTWStepHud
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+5140], xmm0
$LN2@OTWStepHud:

; 2988 : 			TheHud->SetContrastLevel();

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?SetContrastLevel@HudClass@@QAEXXZ	; HudClass::SetContrastLevel

; 2989 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN1@OTWStepHud

; 2990 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_ICP_BRT_WHEEL, 1<<(((int)(TheHud->ContWheelPos*10))+1));

	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR [edx+5140]
	mulss	xmm0, DWORD PTR __real@41200000
	cvttss2si ecx, xmm0
	add	ecx, 1
	mov	eax, 1
	shl	eax, cl
	push	eax
	push	146					; 00000092H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN1@OTWStepHud:

; 2991 :     }
; 2992 : 	}
; 2993 : }

	pop	ebp
	ret	0
?OTWStepHudContrastDn@@YAXKHPAX@Z ENDP			; OTWStepHudContrastDn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_curPanel$1 = -4					; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimToggleAltView@@YAXKHPAX@Z PROC			; SimToggleAltView

; 10941: {

	push	ebp
	mov	ebp, esp
	push	ecx

; 10942: 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN7@SimToggleA
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN7@SimToggleA
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN7@SimToggleA

; 10943:     {
; 10944: 		CPPanel* curPanel = OTWDriver.pCockpitManager->GetActivePanel();

	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	call	?GetActivePanel@CockpitManager@@QAEPAVCPPanel@@XZ ; CockpitManager::GetActivePanel
	mov	DWORD PTR _curPanel$1[ebp], eax

; 10945: 		if(!curPanel)

	cmp	DWORD PTR _curPanel$1[ebp], 0
	jne	SHORT $LN5@SimToggleA

; 10946: 			return;

	jmp	SHORT $LN7@SimToggleA
$LN5@SimToggleA:

; 10947: 		if(curPanel->mIdNum == OTWDriver.pCockpitManager->AltPanel())

	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	call	?AltPanel@CockpitManager@@QAEHXZ	; CockpitManager::AltPanel
	mov	ecx, DWORD PTR _curPanel$1[ebp]
	cmp	DWORD PTR [ecx+4], eax
	jne	SHORT $LN4@SimToggleA

; 10948: 		{
; 10949: 			//Switch it off
; 10950: 			if(SimDriver.GetPlayerAircraft()->WideView)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	movzx	edx, BYTE PTR [eax+1818]
	test	edx, edx
	je	SHORT $LN3@SimToggleA

; 10951: 				OTWDriver.pCockpitManager->SetActivePanel(91100);

	push	91100					; 000163dcH
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	call	?SetActivePanel@CockpitManager@@QAE_NH@Z ; CockpitManager::SetActivePanel

; 10952: 			else

	jmp	SHORT $LN2@SimToggleA
$LN3@SimToggleA:

; 10953: 				OTWDriver.pCockpitManager->SetActivePanel(1100);

	push	1100					; 0000044cH
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	call	?SetActivePanel@CockpitManager@@QAE_NH@Z ; CockpitManager::SetActivePanel
$LN2@SimToggleA:

; 10954: 		}
; 10955: 		else

	jmp	SHORT $LN7@SimToggleA
$LN4@SimToggleA:

; 10956: 		{
; 10957: 			//Switch it on
; 10958: 			OTWDriver.pCockpitManager->SetActivePanel(OTWDriver.pCockpitManager->AltPanel());

	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	call	?AltPanel@CockpitManager@@QAEHXZ	; CockpitManager::AltPanel
	push	eax
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	call	?SetActivePanel@CockpitManager@@QAE_NH@Z ; CockpitManager::SetActivePanel
$LN7@SimToggleA:

; 10959: 		}			   
; 10960:     }
; 10961: }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimToggleAltView@@YAXKHPAX@Z ENDP			; SimToggleAltView
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_curPanel$1 = -4					; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimToggleRearView@@YAXKHPAX@Z PROC			; SimToggleRearView

; 10918: {

	push	ebp
	mov	ebp, esp
	push	ecx

; 10919: 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN7@SimToggleR
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN7@SimToggleR
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN7@SimToggleR

; 10920:     {
; 10921: 		CPPanel* curPanel = OTWDriver.pCockpitManager->GetActivePanel();

	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	call	?GetActivePanel@CockpitManager@@QAEPAVCPPanel@@XZ ; CockpitManager::GetActivePanel
	mov	DWORD PTR _curPanel$1[ebp], eax

; 10922: 		if(!curPanel)

	cmp	DWORD PTR _curPanel$1[ebp], 0
	jne	SHORT $LN5@SimToggleR

; 10923: 			return;

	jmp	SHORT $LN7@SimToggleR
$LN5@SimToggleR:

; 10924: 		if(curPanel->mIdNum == 5100)

	mov	ecx, DWORD PTR _curPanel$1[ebp]
	cmp	DWORD PTR [ecx+4], 5100			; 000013ecH
	jne	SHORT $LN4@SimToggleR

; 10925: 		{
; 10926: 			//Switch it off
; 10927: 			if(SimDriver.GetPlayerAircraft()->WideView)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	movzx	edx, BYTE PTR [eax+1818]
	test	edx, edx
	je	SHORT $LN3@SimToggleR

; 10928: 				OTWDriver.pCockpitManager->SetActivePanel(91100);

	push	91100					; 000163dcH
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	call	?SetActivePanel@CockpitManager@@QAE_NH@Z ; CockpitManager::SetActivePanel

; 10929: 			else

	jmp	SHORT $LN2@SimToggleR
$LN3@SimToggleR:

; 10930: 				OTWDriver.pCockpitManager->SetActivePanel(1100);

	push	1100					; 0000044cH
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	call	?SetActivePanel@CockpitManager@@QAE_NH@Z ; CockpitManager::SetActivePanel
$LN2@SimToggleR:

; 10931: 		}
; 10932: 		else

	jmp	SHORT $LN7@SimToggleR
$LN4@SimToggleR:

; 10933: 		{
; 10934: 			//Switch it on
; 10935: 			OTWDriver.pCockpitManager->SetActivePanel(5100);

	push	5100					; 000013ecH
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	call	?SetActivePanel@CockpitManager@@QAE_NH@Z ; CockpitManager::SetActivePanel
$LN7@SimToggleR:

; 10936: 		}			   
; 10937:     }
; 10938: }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimToggleRearView@@YAXKHPAX@Z ENDP			; SimToggleRearView
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv68 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?ToggleClickablePitMode@@YAXKHPAX@Z PROC		; ToggleClickablePitMode

; 10882: {

	push	ebp
	mov	ebp, esp
	push	ecx

; 10883: 	if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@ToggleClic

; 10884: 	{
; 10885: #if 0	// Retro 15Feb2004
; 10886: 		PlayerOptions.SetClickablePitMode(!PlayerOptions.GetClickablePitMode());
; 10887: #else	// Retro 15Feb2004
; 10888: extern bool clickableMouseMode;
; 10889: 		clickableMouseMode = !clickableMouseMode;

	movzx	ecx, BYTE PTR ?clickableMouseMode@@3_NA	; clickableMouseMode
	test	ecx, ecx
	jne	SHORT $LN4@ToggleClic
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN5@ToggleClic
$LN4@ToggleClic:
	mov	DWORD PTR tv68[ebp], 0
$LN5@ToggleClic:
	mov	dl, BYTE PTR tv68[ebp]
	mov	BYTE PTR ?clickableMouseMode@@3_NA, dl	; clickableMouseMode
$LN2@ToggleClic:

; 10890: #endif
; 10891: 	}
; 10892: }

	mov	esp, ebp
	pop	ebp
	ret	0
?ToggleClickablePitMode@@YAXKHPAX@Z ENDP		; ToggleClickablePitMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?ToggleTIR@@YAXKHPAX@Z PROC				; ToggleTIR

; 10896: {

	push	ebp
	mov	ebp, esp

; 10897: 	if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN5@ToggleTIR

; 10898: 	{
; 10899: 		if ((g_bEnableTrackIR) && (PlayerOptions.Get3dTrackIR() == true)) // TIR running?

	movzx	ecx, BYTE PTR ?g_bEnableTrackIR@@3_NA	; g_bEnableTrackIR
	test	ecx, ecx
	je	SHORT $LN5@ToggleTIR
	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?Get3dTrackIR@PlayerOptionsClass@@QBE_NXZ ; PlayerOptionsClass::Get3dTrackIR
	movzx	edx, al
	cmp	edx, 1
	jne	SHORT $LN5@ToggleTIR

; 10900: 		{
; 10901: 			if (OTWDriver.IsHeadTracking())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?IsHeadTracking@OTWDriverClass@@QAEHXZ	; OTWDriverClass::IsHeadTracking
	test	eax, eax
	je	SHORT $LN2@ToggleTIR

; 10902: 			{
; 10903: 				OTWDriver.SetHeadTracking(FALSE); // 3D pit mouselook On and TIR is Off.

	push	0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?SetHeadTracking@OTWDriverClass@@QAEXH@Z ; OTWDriverClass::SetHeadTracking

; 10904: 				g_bTrackIRon = false; // Tell trackir

	mov	BYTE PTR ?g_bTrackIRon@@3_NA, 0		; g_bTrackIRon

; 10905: 			}
; 10906: 			else

	jmp	SHORT $LN5@ToggleTIR
$LN2@ToggleTIR:

; 10907: 			{
; 10908: 				OTWDriver.SetHeadTracking(TRUE); // 3D pit mouselook Off and TIR is On.

	push	1
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?SetHeadTracking@OTWDriverClass@@QAEXH@Z ; OTWDriverClass::SetHeadTracking

; 10909: 				g_bTrackIRon = true; // Tell trackir

	mov	BYTE PTR ?g_bTrackIRon@@3_NA, 1		; g_bTrackIRon
$LN5@ToggleTIR:

; 10910: 			}
; 10911: 		}
; 10912: 	}
; 10913: }

	pop	ebp
	ret	0
?ToggleTIR@@YAXKHPAX@Z ENDP				; ToggleTIR
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?selectBothEngines@@YAXKHPAX@Z PROC			; selectBothEngines

; 10871: {

	push	ebp
	mov	ebp, esp

; 10872: 	if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@selectBoth

; 10873: 	{
; 10874: 		UserStickInputs.selectBothEngines();

	mov	ecx, OFFSET ?UserStickInputs@@3VPilotInputs@@A ; UserStickInputs
	call	?selectBothEngines@PilotInputs@@QAEXXZ	; PilotInputs::selectBothEngines
$LN2@selectBoth:

; 10875: 	}
; 10876: }

	pop	ebp
	ret	0
?selectBothEngines@@YAXKHPAX@Z ENDP			; selectBothEngines
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?selectRightEngine@@YAXKHPAX@Z PROC			; selectRightEngine

; 10863: {

	push	ebp
	mov	ebp, esp

; 10864: 	if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@selectRigh

; 10865: 	{
; 10866: 		UserStickInputs.selectRightEngine();

	mov	ecx, OFFSET ?UserStickInputs@@3VPilotInputs@@A ; UserStickInputs
	call	?selectRightEngine@PilotInputs@@QAEXXZ	; PilotInputs::selectRightEngine
$LN2@selectRigh:

; 10867: 	}
; 10868: }

	pop	ebp
	ret	0
?selectRightEngine@@YAXKHPAX@Z ENDP			; selectRightEngine
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?selectLeftEngine@@YAXKHPAX@Z PROC			; selectLeftEngine

; 10855: {

	push	ebp
	mov	ebp, esp

; 10856: 	if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@selectLeft

; 10857: 	{
; 10858: 		UserStickInputs.selectLeftEngine();

	mov	ecx, OFFSET ?UserStickInputs@@3VPilotInputs@@A ; UserStickInputs
	call	?selectLeftEngine@PilotInputs@@QAEXXZ	; PilotInputs::selectLeftEngine
$LN2@selectLeft:

; 10859: 	}
; 10860: }

	pop	ebp
	ret	0
?selectLeftEngine@@YAXKHPAX@Z ENDP			; selectLeftEngine
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?CycleEngine@@YAXKHPAX@Z PROC				; CycleEngine

; 10847: {

	push	ebp
	mov	ebp, esp

; 10848: 	if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@CycleEngin

; 10849: 	{
; 10850: 		UserStickInputs.cycleCurrentEngine();

	mov	ecx, OFFSET ?UserStickInputs@@3VPilotInputs@@A ; UserStickInputs
	call	?cycleCurrentEngine@PilotInputs@@QAEXXZ	; PilotInputs::cycleCurrentEngine
$LN2@CycleEngin:

; 10851: 	}
; 10852: }

	pop	ebp
	ret	0
?CycleEngine@@YAXKHPAX@Z ENDP				; CycleEngine
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?WinAmpVolumeDown@@YAXKHPAX@Z PROC			; WinAmpVolumeDown

; 10834: {

	push	ebp
	mov	ebp, esp

; 10835: 	if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@WinAmpVolu

; 10836: 	{
; 10837: 		if ((g_bPilotEntertainment)&&(winamp))

	movzx	ecx, BYTE PTR ?g_bPilotEntertainment@@3_NA ; g_bPilotEntertainment
	test	ecx, ecx
	je	SHORT $LN3@WinAmpVolu
	cmp	DWORD PTR ?winamp@@3PAVWinAmpFrontEnd@@A, 0 ; winamp
	je	SHORT $LN3@WinAmpVolu

; 10838: 		{
; 10839: 			winamp->VolDown();

	mov	ecx, DWORD PTR ?winamp@@3PAVWinAmpFrontEnd@@A ; winamp
	call	?VolDown@WinAmpFrontEnd@@QAEXXZ		; WinAmpFrontEnd::VolDown
$LN3@WinAmpVolu:

; 10840: 		}
; 10841: 	}
; 10842: }

	pop	ebp
	ret	0
?WinAmpVolumeDown@@YAXKHPAX@Z ENDP			; WinAmpVolumeDown
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?WinAmpVolumeUp@@YAXKHPAX@Z PROC			; WinAmpVolumeUp

; 10824: {

	push	ebp
	mov	ebp, esp

; 10825: 	if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@WinAmpVolu

; 10826: 	{
; 10827: 		if ((g_bPilotEntertainment)&&(winamp))

	movzx	ecx, BYTE PTR ?g_bPilotEntertainment@@3_NA ; g_bPilotEntertainment
	test	ecx, ecx
	je	SHORT $LN3@WinAmpVolu
	cmp	DWORD PTR ?winamp@@3PAVWinAmpFrontEnd@@A, 0 ; winamp
	je	SHORT $LN3@WinAmpVolu

; 10828: 		{
; 10829: 			winamp->VolUp();

	mov	ecx, DWORD PTR ?winamp@@3PAVWinAmpFrontEnd@@A ; winamp
	call	?VolUp@WinAmpFrontEnd@@QAEXXZ		; WinAmpFrontEnd::VolUp
$LN3@WinAmpVolu:

; 10830: 		}
; 10831: 	}
; 10832: }

	pop	ebp
	ret	0
?WinAmpVolumeUp@@YAXKHPAX@Z ENDP			; WinAmpVolumeUp
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?WinAmpTogglePlayback@@YAXKHPAX@Z PROC			; WinAmpTogglePlayback

; 10814: {

	push	ebp
	mov	ebp, esp

; 10815: 	if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@WinAmpTogg

; 10816: 	{
; 10817: 		if ((g_bPilotEntertainment)&&(winamp))

	movzx	ecx, BYTE PTR ?g_bPilotEntertainment@@3_NA ; g_bPilotEntertainment
	test	ecx, ecx
	je	SHORT $LN3@WinAmpTogg
	cmp	DWORD PTR ?winamp@@3PAVWinAmpFrontEnd@@A, 0 ; winamp
	je	SHORT $LN3@WinAmpTogg

; 10818: 		{
; 10819: 			winamp->TogglePlayback();

	mov	ecx, DWORD PTR ?winamp@@3PAVWinAmpFrontEnd@@A ; winamp
	call	?TogglePlayback@WinAmpFrontEnd@@QAEXXZ	; WinAmpFrontEnd::TogglePlayback
$LN3@WinAmpTogg:

; 10820: 		}
; 10821: 	}
; 10822: }

	pop	ebp
	ret	0
?WinAmpTogglePlayback@@YAXKHPAX@Z ENDP			; WinAmpTogglePlayback
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?WinAmpStartPlayback@@YAXKHPAX@Z PROC			; WinAmpStartPlayback

; 10804: {

	push	ebp
	mov	ebp, esp

; 10805: 	if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@WinAmpStar

; 10806: 	{
; 10807: 		if ((g_bPilotEntertainment)&&(winamp))

	movzx	ecx, BYTE PTR ?g_bPilotEntertainment@@3_NA ; g_bPilotEntertainment
	test	ecx, ecx
	je	SHORT $LN3@WinAmpStar
	cmp	DWORD PTR ?winamp@@3PAVWinAmpFrontEnd@@A, 0 ; winamp
	je	SHORT $LN3@WinAmpStar

; 10808: 		{
; 10809: 			winamp->Start();

	mov	ecx, DWORD PTR ?winamp@@3PAVWinAmpFrontEnd@@A ; winamp
	call	?Start@WinAmpFrontEnd@@QAEXXZ		; WinAmpFrontEnd::Start
$LN3@WinAmpStar:

; 10810: 		}
; 10811: 	}
; 10812: }

	pop	ebp
	ret	0
?WinAmpStartPlayback@@YAXKHPAX@Z ENDP			; WinAmpStartPlayback
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?WinAmpStopPlayback@@YAXKHPAX@Z PROC			; WinAmpStopPlayback

; 10794: {

	push	ebp
	mov	ebp, esp

; 10795: 	if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@WinAmpStop

; 10796: 	{
; 10797: 		if ((g_bPilotEntertainment)&&(winamp))

	movzx	ecx, BYTE PTR ?g_bPilotEntertainment@@3_NA ; g_bPilotEntertainment
	test	ecx, ecx
	je	SHORT $LN3@WinAmpStop
	cmp	DWORD PTR ?winamp@@3PAVWinAmpFrontEnd@@A, 0 ; winamp
	je	SHORT $LN3@WinAmpStop

; 10798: 		{
; 10799: 			winamp->Stop();

	mov	ecx, DWORD PTR ?winamp@@3PAVWinAmpFrontEnd@@A ; winamp
	call	?Stop@WinAmpFrontEnd@@QAEXXZ		; WinAmpFrontEnd::Stop
$LN3@WinAmpStop:

; 10800: 		}
; 10801: 	}
; 10802: }

	pop	ebp
	ret	0
?WinAmpStopPlayback@@YAXKHPAX@Z ENDP			; WinAmpStopPlayback
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?WinAmpPreviousTrack@@YAXKHPAX@Z PROC			; WinAmpPreviousTrack

; 10784: {

	push	ebp
	mov	ebp, esp

; 10785: 	if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@WinAmpPrev

; 10786: 	{
; 10787: 		if ((g_bPilotEntertainment)&&(winamp))

	movzx	ecx, BYTE PTR ?g_bPilotEntertainment@@3_NA ; g_bPilotEntertainment
	test	ecx, ecx
	je	SHORT $LN3@WinAmpPrev
	cmp	DWORD PTR ?winamp@@3PAVWinAmpFrontEnd@@A, 0 ; winamp
	je	SHORT $LN3@WinAmpPrev

; 10788: 		{
; 10789: 			winamp->Previous();

	mov	ecx, DWORD PTR ?winamp@@3PAVWinAmpFrontEnd@@A ; winamp
	call	?Previous@WinAmpFrontEnd@@QAEXXZ	; WinAmpFrontEnd::Previous
$LN3@WinAmpPrev:

; 10790: 		}
; 10791: 	}
; 10792: }

	pop	ebp
	ret	0
?WinAmpPreviousTrack@@YAXKHPAX@Z ENDP			; WinAmpPreviousTrack
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?WinAmpNextTrack@@YAXKHPAX@Z PROC			; WinAmpNextTrack

; 10774: {

	push	ebp
	mov	ebp, esp

; 10775: 	if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@WinAmpNext

; 10776: 	{
; 10777: 		if ((g_bPilotEntertainment)&&(winamp))

	movzx	ecx, BYTE PTR ?g_bPilotEntertainment@@3_NA ; g_bPilotEntertainment
	test	ecx, ecx
	je	SHORT $LN3@WinAmpNext
	cmp	DWORD PTR ?winamp@@3PAVWinAmpFrontEnd@@A, 0 ; winamp
	je	SHORT $LN3@WinAmpNext

; 10778: 		{
; 10779: 			winamp->Next();

	mov	ecx, DWORD PTR ?winamp@@3PAVWinAmpFrontEnd@@A ; winamp
	call	?Next@WinAmpFrontEnd@@QAEXXZ		; WinAmpFrontEnd::Next
$LN3@WinAmpNext:

; 10780: 		}
; 10781: 	}
; 10782: }

	pop	ebp
	ret	0
?WinAmpNextTrack@@YAXKHPAX@Z ENDP			; WinAmpNextTrack
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?ToggleDisplacementCam@@YAXKHPAX@Z PROC			; ToggleDisplacementCam

; 10763: {

	push	ebp
	mov	ebp, esp

; 10764:    if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@ToggleDisp

; 10765:    {
; 10766: 	   OTWDriver.toggleDisplaceCamera();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?toggleDisplaceCamera@OTWDriverClass@@QAEXXZ ; OTWDriverClass::toggleDisplaceCamera
$LN2@ToggleDisp:

; 10767:    }
; 10768: }

	pop	ebp
	ret	0
?ToggleDisplacementCam@@YAXKHPAX@Z ENDP			; ToggleDisplacementCam
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?ToggleInfoBar@@YAXKHPAX@Z PROC				; ToggleInfoBar

; 10754: {

	push	ebp
	mov	ebp, esp

; 10755:    if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@ToggleInfo

; 10756:    {
; 10757: 	   OTWDriver.ToggleInfoBar();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?ToggleInfoBar@OTWDriverClass@@QAEXXZ	; OTWDriverClass::ToggleInfoBar
$LN2@ToggleInfo:

; 10758:    }
; 10759: }

	pop	ebp
	ret	0
?ToggleInfoBar@@YAXKHPAX@Z ENDP				; ToggleInfoBar
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?ToggleSubTitles@@YAXKHPAX@Z PROC			; ToggleSubTitles

; 10747: {

	push	ebp
	mov	ebp, esp

; 10748:    if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@ToggleSubT

; 10749:    {
; 10750: 	   OTWDriver.ToggleSubTitles();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?ToggleSubTitles@OTWDriverClass@@QAEXXZ	; OTWDriverClass::ToggleSubTitles
$LN2@ToggleSubT:

; 10751:    }
; 10752: }

	pop	ebp
	ret	0
?ToggleSubTitles@@YAXKHPAX@Z ENDP			; ToggleSubTitles
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?Profiler_HistoryFwdFast@@YAXKHPAX@Z PROC		; Profiler_HistoryFwdFast

; 10620: {

	push	ebp
	mov	ebp, esp

; 10621: #ifdef Prof_ENABLED
; 10622: 	if (state & KEY_DOWN)
; 10623: 	{
; 10624: 		Prof_move_frame(10);
; 10625: 	}
; 10626: #endif	// Prof_ENABLED
; 10627: }

	pop	ebp
	ret	0
?Profiler_HistoryFwdFast@@YAXKHPAX@Z ENDP		; Profiler_HistoryFwdFast
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?Profiler_HistoryBackFast@@YAXKHPAX@Z PROC		; Profiler_HistoryBackFast

; 10600: {

	push	ebp
	mov	ebp, esp

; 10601: #ifdef Prof_ENABLED
; 10602: 	if (state & KEY_DOWN)
; 10603: 	{
; 10604: 		Prof_move_frame(-10);
; 10605: 	}
; 10606: #endif	// Prof_ENABLED
; 10607: }

	pop	ebp
	ret	0
?Profiler_HistoryBackFast@@YAXKHPAX@Z ENDP		; Profiler_HistoryBackFast
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?Profiler_HistoryFwd@@YAXKHPAX@Z PROC			; Profiler_HistoryFwd

; 10610: {

	push	ebp
	mov	ebp, esp

; 10611: #ifdef Prof_ENABLED
; 10612: 	if (state & KEY_DOWN)
; 10613: 	{
; 10614: 		Prof_move_frame(1);
; 10615: 	}
; 10616: #endif	// Prof_ENABLED
; 10617: }

	pop	ebp
	ret	0
?Profiler_HistoryFwd@@YAXKHPAX@Z ENDP			; Profiler_HistoryFwd
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?Profiler_HistoryBack@@YAXKHPAX@Z PROC			; Profiler_HistoryBack

; 10590: {

	push	ebp
	mov	ebp, esp

; 10591: #ifdef Prof_ENABLED
; 10592: 	if (state & KEY_DOWN)
; 10593: 	{
; 10594: 		Prof_move_frame(-1);
; 10595: 	}
; 10596: #endif	// Prof_ENABLED
; 10597: }

	pop	ebp
	ret	0
?Profiler_HistoryBack@@YAXKHPAX@Z ENDP			; Profiler_HistoryBack
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?ToggleProfiler@@YAXKHPAX@Z PROC			; ToggleProfiler

; 10580: {

	push	ebp
	mov	ebp, esp

; 10581: #ifdef Prof_ENABLED
; 10582:    if (state & KEY_DOWN)
; 10583:    {
; 10584: 	  OTWDriver.ToggleProfilerActive();
; 10585:    }
; 10586: #endif	// Prof_ENABLED
; 10587: }

	pop	ebp
	ret	0
?ToggleProfiler@@YAXKHPAX@Z ENDP			; ToggleProfiler
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?ToggleProfilerDisplay@@YAXKHPAX@Z PROC			; ToggleProfilerDisplay

; 10630: {

	push	ebp
	mov	ebp, esp

; 10631: #ifdef Prof_ENABLED
; 10632:    if (state & KEY_DOWN)
; 10633:    {
; 10634: 		OTWDriver.ToggleProfilerDisplay();
; 10635:    }
; 10636: #endif	// Prof_ENABLED
; 10637: }

	pop	ebp
	ret	0
?ToggleProfilerDisplay@@YAXKHPAX@Z ENDP			; ToggleProfilerDisplay
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?Profiler_Self@@YAXKHPAX@Z PROC				; Profiler_Self

; 10640: {

	push	ebp
	mov	ebp, esp

; 10641: #ifdef Prof_ENABLED
; 10642:    if (state & KEY_DOWN)
; 10643:    {
; 10644: 	   if (OTWDriver.IsProfilerDisplaying())
; 10645: 	   {
; 10646: 			Prof_set_report_mode(Prof_SELF_TIME);
; 10647: 	   }
; 10648:    }
; 10649: #endif	// Prof_ENABLED
; 10650: }

	pop	ebp
	ret	0
?Profiler_Self@@YAXKHPAX@Z ENDP				; Profiler_Self
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?Profiler_Hier@@YAXKHPAX@Z PROC				; Profiler_Hier

; 10653: {

	push	ebp
	mov	ebp, esp

; 10654: #ifdef Prof_ENABLED
; 10655:    if (state & KEY_DOWN)
; 10656:    {
; 10657: 	   if (OTWDriver.IsProfilerDisplaying())
; 10658: 	   {
; 10659: 			Prof_set_report_mode(Prof_HIERARCHICAL_TIME);
; 10660: 	   }
; 10661:    }
; 10662: #endif	// Prof_ENABLED
; 10663: }

	pop	ebp
	ret	0
?Profiler_Hier@@YAXKHPAX@Z ENDP				; Profiler_Hier
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?Profiler_Select@@YAXKHPAX@Z PROC			; Profiler_Select

; 10666: {

	push	ebp
	mov	ebp, esp

; 10667: #ifdef Prof_ENABLED
; 10668:    if (state & KEY_DOWN)
; 10669:    {
; 10670: 	   if (OTWDriver.IsProfilerDisplaying())
; 10671: 	   {
; 10672: 			Prof_select();
; 10673: 	   }
; 10674:    }
; 10675: #endif	// Prof_ENABLED
; 10676: }

	pop	ebp
	ret	0
?Profiler_Select@@YAXKHPAX@Z ENDP			; Profiler_Select
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?Profiler_Parent@@YAXKHPAX@Z PROC			; Profiler_Parent

; 10679: {

	push	ebp
	mov	ebp, esp

; 10680: #ifdef Prof_ENABLED
; 10681:    if (state & KEY_DOWN)
; 10682:    {
; 10683: 	   if (OTWDriver.IsProfilerDisplaying())
; 10684: 	   {
; 10685: 			Prof_select_parent();
; 10686: 	   }
; 10687:    }
; 10688: #endif	// Prof_ENABLED
; 10689: }

	pop	ebp
	ret	0
?Profiler_Parent@@YAXKHPAX@Z ENDP			; Profiler_Parent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?Profiler_CursorUp@@YAXKHPAX@Z PROC			; Profiler_CursorUp

; 10692: {

	push	ebp
	mov	ebp, esp

; 10693: #ifdef Prof_ENABLED
; 10694:    if (state & KEY_DOWN)
; 10695:    {
; 10696: 	   if (OTWDriver.IsProfilerDisplaying())
; 10697: 	   {
; 10698: 			int virtualCursor = Prof_get_cursor();
; 10699: 			virtualCursor--;
; 10700: 			Prof_set_cursor(virtualCursor);
; 10701: 		}
; 10702:    }
; 10703: #endif	// Prof_ENABLED
; 10704: }

	pop	ebp
	ret	0
?Profiler_CursorUp@@YAXKHPAX@Z ENDP			; Profiler_CursorUp
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?Profiler_CursorDown@@YAXKHPAX@Z PROC			; Profiler_CursorDown

; 10707: {

	push	ebp
	mov	ebp, esp

; 10708: #ifdef Prof_ENABLED
; 10709:    if (state & KEY_DOWN)
; 10710:    {
; 10711: 	   if (OTWDriver.IsProfilerDisplaying())
; 10712: 	   {
; 10713: 			int virtualCursor = Prof_get_cursor();
; 10714: 			virtualCursor++;
; 10715: 			Prof_set_cursor(virtualCursor);
; 10716: 	   }
; 10717:    }
; 10718: #endif	// Prof_ENABLED
; 10719: }

	pop	ebp
	ret	0
?Profiler_CursorDown@@YAXKHPAX@Z ENDP			; Profiler_CursorDown
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?ToggleVtune@@YAXKHPAX@Z PROC				; ToggleVtune

; 158  : {

	push	ebp
	mov	ebp, esp

; 159  : 	if(!hlib)

	cmp	DWORD PTR ?hlib@@3PAUHINSTANCE__@@A, 0	; hlib
	jne	SHORT $LN6@ToggleVtun

; 160  : 	{
; 161  : 		hlib = LoadLibrary( "vtuneapi.dll" );

	push	OFFSET ??_C@_0N@GJLGHHE@vtuneapi?4dll?$AA@
	call	DWORD PTR __imp__LoadLibraryA@4
	mov	DWORD PTR ?hlib@@3PAUHINSTANCE__@@A, eax ; hlib

; 162  : 		ShiAssert( hlib );
; 163  : 
; 164  : 		pauseFn  = (int (__cdecl *)(void))GetProcAddress( hlib, "VtPauseSampling" );

	push	OFFSET ??_C@_0BA@NIOBKLHM@VtPauseSampling?$AA@
	mov	eax, DWORD PTR ?hlib@@3PAUHINSTANCE__@@A ; hlib
	push	eax
	call	DWORD PTR __imp__GetProcAddress@8
	mov	DWORD PTR ?pauseFn@@3P6AHXZA, eax	; pauseFn

; 165  : 		if (!pauseFn)

	cmp	DWORD PTR ?pauseFn@@3P6AHXZA, 0		; pauseFn
	jne	SHORT $LN5@ToggleVtun

; 166  : 			pauseFn = VtuneNoop;

	mov	DWORD PTR ?pauseFn@@3P6AHXZA, OFFSET ?VtuneNoop@@YAHXZ ; pauseFn, VtuneNoop
$LN5@ToggleVtun:

; 167  : 		resumeFn = (int (__cdecl *)(void))GetProcAddress( hlib, "VtResumeSampling" );

	push	OFFSET ??_C@_0BB@CNJIDIOC@VtResumeSampling?$AA@
	mov	ecx, DWORD PTR ?hlib@@3PAUHINSTANCE__@@A ; hlib
	push	ecx
	call	DWORD PTR __imp__GetProcAddress@8
	mov	DWORD PTR ?resumeFn@@3P6AHXZA, eax	; resumeFn

; 168  : 		if (!resumeFn)

	cmp	DWORD PTR ?resumeFn@@3P6AHXZA, 0	; resumeFn
	jne	SHORT $LN6@ToggleVtun

; 169  : 			resumeFn = VtuneNoop;

	mov	DWORD PTR ?resumeFn@@3P6AHXZA, OFFSET ?VtuneNoop@@YAHXZ ; resumeFn, VtuneNoop
$LN6@ToggleVtun:

; 170  : 	}
; 171  : 
; 172  : 	if (state & KEY_DOWN)

	mov	edx, DWORD PTR _state$[ebp]
	and	edx, 8
	je	SHORT $LN7@ToggleVtun

; 173  : 	{
; 174  : 		if(doVtune)

	cmp	DWORD PTR ?doVtune@@3HA, 0		; doVtune
	je	SHORT $LN2@ToggleVtun

; 175  : 		{
; 176  : 			doVtune = FALSE;

	mov	DWORD PTR ?doVtune@@3HA, 0		; doVtune

; 177  : 			pauseFn();

	call	DWORD PTR ?pauseFn@@3P6AHXZA		; pauseFn

; 178  : //			MonoPrint( "VTUNE PAUSED\n" );
; 179  : 		}
; 180  : 		else

	jmp	SHORT $LN7@ToggleVtun
$LN2@ToggleVtun:

; 181  : 		{
; 182  : //			MonoPrint( "VTUNE RECORDING\n" );
; 183  : 			doVtune = TRUE;

	mov	DWORD PTR ?doVtune@@3HA, 1		; doVtune

; 184  : 			resumeFn();

	call	DWORD PTR ?resumeFn@@3P6AHXZA		; resumeFn
$LN7@ToggleVtun:

; 185  : 		}
; 186  : 	}
; 187  : }

	pop	ebp
	ret	0
?ToggleVtune@@YAXKHPAX@Z ENDP				; ToggleVtune
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimSpeedyGonzalesDown@@YAXKHPAX@Z PROC			; SimSpeedyGonzalesDown

; 895  : {

	push	ebp
	mov	ebp, esp

; 896  : 	if ((state & KEY_DOWN) && (!gCommsMgr->Online()))

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimSpeedyG
	mov	ecx, DWORD PTR ?gCommsMgr@@3PAVUIComms@@A ; gCommsMgr
	call	?Online@UIComms@@QAEHXZ			; UIComms::Online
	test	eax, eax
	jne	SHORT $LN2@SimSpeedyG

; 897  : 	{
; 898  : 		gSpeedyGonzales /= 1.25;

	cvtss2sd xmm0, DWORD PTR ?gSpeedyGonzales@@3MA
	divsd	xmm0, QWORD PTR __real@3ff4000000000000
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR ?gSpeedyGonzales@@3MA, xmm0
$LN2@SimSpeedyG:

; 899  : 	}
; 900  : 	
; 901  : 	if (gSpeedyGonzales < 1.0)

	cvtss2sd xmm0, DWORD PTR ?gSpeedyGonzales@@3MA
	movsd	xmm1, QWORD PTR __real@3ff0000000000000
	comisd	xmm1, xmm0
	jbe	SHORT $LN1@SimSpeedyG

; 902  : 	{
; 903  : 		gSpeedyGonzales = 1.0;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR ?gSpeedyGonzales@@3MA, xmm0
$LN1@SimSpeedyG:

; 904  : 	}
; 905  : 
; 906  : //	MonoPrint ("Speedy Down %f\n", gSpeedyGonzales);
; 907  : }

	pop	ebp
	ret	0
?SimSpeedyGonzalesDown@@YAXKHPAX@Z ENDP			; SimSpeedyGonzalesDown
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimSpeedyGonzalesUp@@YAXKHPAX@Z PROC			; SimSpeedyGonzalesUp

; 880  : {

	push	ebp
	mov	ebp, esp

; 881  : 	if ((state & KEY_DOWN) && (!gCommsMgr->Online()))

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimSpeedyG
	mov	ecx, DWORD PTR ?gCommsMgr@@3PAVUIComms@@A ; gCommsMgr
	call	?Online@UIComms@@QAEHXZ			; UIComms::Online
	test	eax, eax
	jne	SHORT $LN2@SimSpeedyG

; 882  : 	{
; 883  : 		gSpeedyGonzales *= 1.25;

	cvtss2sd xmm0, DWORD PTR ?gSpeedyGonzales@@3MA
	mulsd	xmm0, QWORD PTR __real@3ff4000000000000
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR ?gSpeedyGonzales@@3MA, xmm0
$LN2@SimSpeedyG:

; 884  : 	}
; 885  : 	
; 886  : 	if (gSpeedyGonzales >= 32.0)

	cvtss2sd xmm0, DWORD PTR ?gSpeedyGonzales@@3MA
	comisd	xmm0, QWORD PTR __real@4040000000000000
	jb	SHORT $LN1@SimSpeedyG

; 887  : 	{
; 888  : 		gSpeedyGonzales = 32.0;

	movss	xmm0, DWORD PTR __real@42000000
	movss	DWORD PTR ?gSpeedyGonzales@@3MA, xmm0
$LN1@SimSpeedyG:

; 889  : 	}
; 890  : 	
; 891  : //	MonoPrint ("Speedy Up %f\n", gSpeedyGonzales);
; 892  : }

	pop	ebp
	ret	0
?SimSpeedyGonzalesUp@@YAXKHPAX@Z ENDP			; SimSpeedyGonzalesUp
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?LoadCockpitDefaults@@YAXKHPAX@Z PROC			; LoadCockpitDefaults

; 5838 : {

	push	ebp
	mov	ebp, esp

; 5839 :    if (OTWDriver.pCockpitManager && (state & KEY_DOWN))

	cmp	DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684, 0
	je	SHORT $LN2@LoadCockpi
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@LoadCockpi

; 5840 :    {
; 5841 :       OTWDriver.pCockpitManager->LoadCockpitDefaults();

	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	call	?LoadCockpitDefaults@CockpitManager@@QAEXXZ ; CockpitManager::LoadCockpitDefaults
$LN2@LoadCockpi:

; 5842 :    }
; 5843 : }

	pop	ebp
	ret	0
?LoadCockpitDefaults@@YAXKHPAX@Z ENDP			; LoadCockpitDefaults
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SaveCockpitDefaults@@YAXKHPAX@Z PROC			; SaveCockpitDefaults

; 5830 : {

	push	ebp
	mov	ebp, esp

; 5831 :    if (OTWDriver.pCockpitManager && (state & KEY_DOWN))

	cmp	DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684, 0
	je	SHORT $LN2@SaveCockpi
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SaveCockpi

; 5832 :    {
; 5833 :       OTWDriver.pCockpitManager->SaveCockpitDefaults();

	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	call	?SaveCockpitDefaults@CockpitManager@@QAEXXZ ; CockpitManager::SaveCockpitDefaults
$LN2@SaveCockpi:

; 5834 :    }
; 5835 : }

	pop	ebp
	ret	0
?SaveCockpitDefaults@@YAXKHPAX@Z ENDP			; SaveCockpitDefaults
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_ac$ = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimToggleExtLights@@YAXKHPAX@Z PROC			; SimToggleExtLights

; 8952 : void SimToggleExtLights(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp
	push	ecx

; 8953 : // JPO changes 
; 8954 :     // only applies if complex aircraft and also sets the extra status flags.
; 8955 : 	AircraftClass *ac = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _ac$[ebp], eax

; 8956 : 	if (!ac){ return; }

	cmp	DWORD PTR _ac$[ebp], 0
	jne	SHORT $LN6@SimToggleE
	jmp	$LN7@SimToggleE
$LN6@SimToggleE:

; 8957 :     if (ac->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN) && ac->IsComplex()) 

	push	65536					; 00010000H
	mov	ecx, DWORD PTR _ac$[ebp]
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN7@SimToggleE
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN7@SimToggleE
	mov	ecx, DWORD PTR _ac$[ebp]
	call	?IsComplex@AircraftClass@@QAEHXZ	; AircraftClass::IsComplex
	test	eax, eax
	je	$LN7@SimToggleE

; 8958 : 	{
; 8959 : 		if (ac->IsAcStatusBitsSet(AircraftClass::ACSTATUS_EXT_LIGHTS))

	push	4
	mov	ecx, DWORD PTR _ac$[ebp]
	call	?IsAcStatusBitsSet@AircraftClass@@QBE_NH@Z ; AircraftClass::IsAcStatusBitsSet
	movzx	ecx, al
	test	ecx, ecx
	je	$LN4@SimToggleE

; 8960 : 		{
; 8961 : 			// lights are on
; 8962 : 			ac->SetSwitch(COMP_TAIL_STROBE, FALSE);

	push	0
	push	7
	mov	ecx, DWORD PTR _ac$[ebp]
	call	?SetSwitch@SimMoverClass@@QAEXHH@Z	; SimMoverClass::SetSwitch

; 8963 : 			ac->SetSwitch(COMP_NAV_LIGHTS, FALSE);

	push	0
	push	8
	mov	ecx, DWORD PTR _ac$[ebp]
	call	?SetSwitch@SimMoverClass@@QAEXHH@Z	; SimMoverClass::SetSwitch

; 8964 : 			ac->ClearAcStatusBits(
; 8965 : 				AircraftClass::ACSTATUS_EXT_LIGHTS | AircraftClass::ACSTATUS_EXT_NAVLIGHTS |
; 8966 : 				AircraftClass::ACSTATUS_EXT_NAVLIGHTSFLASH | AircraftClass::ACSTATUS_EXT_TAILSTROBE	);

	push	92					; 0000005cH
	mov	ecx, DWORD PTR _ac$[ebp]
	call	?ClearAcStatusBits@AircraftClass@@QAEXH@Z ; AircraftClass::ClearAcStatusBits

; 8967 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN3@SimToggleE

; 8968 : 			{
; 8969 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_EXT_LITE_MSTR, 1);

	push	1
	push	186					; 000000baH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 8970 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_ANTI_COLL, 1);

	push	1
	push	187					; 000000bbH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 8971 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_EXT_WING, 1);

	push	1
	push	189					; 000000bdH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 8972 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_EXT_FUSELAGE, 1);

	push	1
	push	190					; 000000beH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN3@SimToggleE:

; 8973 : 			}
; 8974 : 		}
; 8975 : 		else 

	jmp	$LN7@SimToggleE
$LN4@SimToggleE:

; 8976 : 		{
; 8977 : 			ac->SetSwitch(COMP_TAIL_STROBE, TRUE);

	push	1
	push	7
	mov	ecx, DWORD PTR _ac$[ebp]
	call	?SetSwitch@SimMoverClass@@QAEXHH@Z	; SimMoverClass::SetSwitch

; 8978 : 			ac->SetSwitch(COMP_NAV_LIGHTS, TRUE);

	push	1
	push	8
	mov	ecx, DWORD PTR _ac$[ebp]
	call	?SetSwitch@SimMoverClass@@QAEXHH@Z	; SimMoverClass::SetSwitch

; 8979 : 			ac->SetAcStatusBits(
; 8980 : 				AircraftClass::ACSTATUS_EXT_LIGHTS | AircraftClass::ACSTATUS_EXT_NAVLIGHTS |
; 8981 : 				AircraftClass::ACSTATUS_EXT_NAVLIGHTSFLASH | AircraftClass::ACSTATUS_EXT_TAILSTROBE	);

	push	92					; 0000005cH
	mov	ecx, DWORD PTR _ac$[ebp]
	call	?SetAcStatusBits@AircraftClass@@QAEXH@Z	; AircraftClass::SetAcStatusBits

; 8982 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN7@SimToggleE

; 8983 : 			{
; 8984 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_EXT_LITE_MSTR, 2);

	push	2
	push	186					; 000000baH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 8985 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_ANTI_COLL, 2);

	push	2
	push	187					; 000000bbH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 8986 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_EXT_WING, 2);

	push	2
	push	189					; 000000bdH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 8987 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_EXT_FUSELAGE, 2);

	push	2
	push	190					; 000000beH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN7@SimToggleE:

; 8988 : 			}
; 8989 : 		}
; 8990 :   }
; 8991 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimToggleExtLights@@YAXKHPAX@Z ENDP			; SimToggleExtLights
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_hr$ = -4						; size = 4
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimTransmitCom2@@YAXKHPAX@Z PROC			; SimTransmitCom2

; 5784 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 5785 : 	    HRESULT             hr = S_OK;

	mov	DWORD PTR _hr$[ebp], 0

; 5786 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimTransmi
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimTransmi
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimTransmi

; 5787 : 	{
; 5788 : 	Transmit(2);

	push	2
	call	?Transmit@@YAXH@Z			; Transmit
	add	esp, 4

; 5789 : 	}
; 5790 : 	else

	jmp	SHORT $LN3@SimTransmi
$LN2@SimTransmi:

; 5791 : 	{
; 5792 : 	Transmit(0);

	push	0
	call	?Transmit@@YAXH@Z			; Transmit
	add	esp, 4
$LN3@SimTransmi:

; 5793 : 	}
; 5794 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimTransmitCom2@@YAXKHPAX@Z ENDP			; SimTransmitCom2
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_hr$ = -4						; size = 4
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimTransmitCom1@@YAXKHPAX@Z PROC			; SimTransmitCom1

; 5772 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 5773 : 	    HRESULT             hr = S_OK;

	mov	DWORD PTR _hr$[ebp], 0

; 5774 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimTransmi
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimTransmi
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimTransmi

; 5775 : 	{
; 5776 : 	Transmit(1);

	push	1
	call	?Transmit@@YAXH@Z			; Transmit
	add	esp, 4

; 5777 : 	}
; 5778 : 	else

	jmp	SHORT $LN3@SimTransmi
$LN2@SimTransmi:

; 5779 : 	{
; 5780 : 	Transmit(0);

	push	0
	call	?Transmit@@YAXH@Z			; Transmit
	add	esp, 4
$LN3@SimTransmi:

; 5781 : 	}
; 5782 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimTransmitCom1@@YAXKHPAX@Z ENDP			; SimTransmitCom1
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimToggleUHFMaster@@YAXKHPAX@Z PROC			; SimToggleUHFMaster

; 5763 : void SimToggleUHFMaster(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 5764 : //	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)) {
; 5765 : //		gNavigationSys->ToggleUHFSrc();
; 5766 : //	}
; 5767 : }

	pop	ebp
	ret	0
?SimToggleUHFMaster@@YAXKHPAX@Z ENDP			; SimToggleUHFMaster
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimTACANAATR@@YAXKHPAX@Z PROC				; SimTACANAATR

; 5746 : void SimTACANAATR(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 5747 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimTACANAA

; 5748 : 		return;

	jmp	SHORT $LN4@SimTACANAA
$LN3@SimTACANAA:

; 5749 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)) 

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimTACANAA
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimTACANAA
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimTACANAA

; 5750 : 	{
; 5751 : 		gNavigationSys->SetDomain(NavigationSystem::AUXCOMM, TacanList::AA);

	push	0
	push	1
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?SetDomain@NavigationSystem@@QAEXW4Tacan_Channel_Src@1@W4Domain@TacanList@@@Z ; NavigationSystem::SetDomain

; 5752 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimTACANAA

; 5753 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_AUX_COMM_MSTR, 2);

	push	2
	push	180					; 000000b4H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimTACANAA:

; 5754 : 	}
; 5755 : }

	pop	ebp
	ret	0
?SimTACANAATR@@YAXKHPAX@Z ENDP				; SimTACANAATR
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimTACANTR@@YAXKHPAX@Z PROC				; SimTACANTR

; 5735 : void SimTACANTR(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 5736 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimTACANTR

; 5737 : 		return;

	jmp	SHORT $LN4@SimTACANTR
$LN3@SimTACANTR:

; 5738 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimTACANTR
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimTACANTR
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimTACANTR

; 5739 : 	{
; 5740 : 		gNavigationSys->SetDomain(NavigationSystem::AUXCOMM, TacanList::AG);

	push	1
	push	1
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?SetDomain@NavigationSystem@@QAEXW4Tacan_Channel_Src@1@W4Domain@TacanList@@@Z ; NavigationSystem::SetDomain

; 5741 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimTACANTR

; 5742 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_AUX_COMM_MSTR, 1);

	push	1
	push	180					; 000000b4H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimTACANTR:

; 5743 : 	}
; 5744 : }

	pop	ebp
	ret	0
?SimTACANTR@@YAXKHPAX@Z ENDP				; SimTACANTR
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$1 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimToggleAuxComAATR@@YAXKHPAX@Z PROC			; SimToggleAuxComAATR

; 5722 : void SimToggleAuxComAATR(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp
	push	ecx

; 5723 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)) 

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimToggleA
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimToggleA
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimToggleA

; 5724 : 	{
; 5725 : 		gNavigationSys->ToggleDomain(NavigationSystem::AUXCOMM);

	push	1
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?ToggleDomain@NavigationSystem@@QAE?AW4Domain@TacanList@@W4Tacan_Channel_Src@1@@Z ; NavigationSystem::ToggleDomain

; 5726 : 		int val = 1<<gNavigationSys->GetDomain(NavigationSystem::AUXCOMM);

	push	1
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetDomain@NavigationSystem@@QAE?AW4Domain@TacanList@@W4Tacan_Channel_Src@1@@Z ; NavigationSystem::GetDomain
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	mov	DWORD PTR _val$1[ebp], edx

; 5727 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN3@SimToggleA

; 5728 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_AUX_COMM_MSTR, val);

	mov	eax, DWORD PTR _val$1[ebp]
	push	eax
	push	180					; 000000b4H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN3@SimToggleA:

; 5729 : 	}
; 5730 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimToggleAuxComAATR@@YAXKHPAX@Z ENDP			; SimToggleAuxComAATR
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimAuxComUFC@@YAXKHPAX@Z PROC				; SimAuxComUFC

; 5710 : void SimAuxComUFC(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 5711 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimAuxComU

; 5712 : 		return;

	jmp	SHORT $LN4@SimAuxComU
$LN3@SimAuxComU:

; 5713 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)) 

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimAuxComU
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimAuxComU
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimAuxComU

; 5714 : 	{
; 5715 : 		gNavigationSys->SetControlSrc(NavigationSystem::ICP);

	push	0
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?SetControlSrc@NavigationSystem@@QAEXW4Tacan_Channel_Src@1@@Z ; NavigationSystem::SetControlSrc

; 5716 : 		gNavigationSys->SetUHFSrc(NavigationSystem::UHF_Mode_Type::UHF_NORM);

	push	0
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?SetUHFSrc@NavigationSystem@@QAEXW4UHF_Mode_Type@1@@Z ; NavigationSystem::SetUHFSrc

; 5717 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimAuxComU

; 5718 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_AUX_COMM_SRC, 2);

	push	2
	push	181					; 000000b5H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimAuxComU:

; 5719 : 	}
; 5720 : }

	pop	ebp
	ret	0
?SimAuxComUFC@@YAXKHPAX@Z ENDP				; SimAuxComUFC
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimAuxComBackup@@YAXKHPAX@Z PROC			; SimAuxComBackup

; 5698 : void SimAuxComBackup(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 5699 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimAuxComB

; 5700 : 		return;

	jmp	SHORT $LN4@SimAuxComB
$LN3@SimAuxComB:

; 5701 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)) 

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimAuxComB
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimAuxComB
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimAuxComB

; 5702 : 	{
; 5703 : 		gNavigationSys->SetControlSrc(NavigationSystem::AUXCOMM);

	push	1
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?SetControlSrc@NavigationSystem@@QAEXW4Tacan_Channel_Src@1@@Z ; NavigationSystem::SetControlSrc

; 5704 : 		gNavigationSys->SetUHFSrc(NavigationSystem::UHF_Mode_Type::UHF_BACKUP);

	push	1
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?SetUHFSrc@NavigationSystem@@QAEXW4UHF_Mode_Type@1@@Z ; NavigationSystem::SetUHFSrc

; 5705 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimAuxComB

; 5706 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_AUX_COMM_SRC, 1);

	push	1
	push	181					; 000000b5H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimAuxComB:

; 5707 : 	}
; 5708 : }

	pop	ebp
	ret	0
?SimAuxComBackup@@YAXKHPAX@Z ENDP			; SimAuxComBackup
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimToggleAuxComMaster@@YAXKHPAX@Z PROC			; SimToggleAuxComMaster

; 5683 : void SimToggleAuxComMaster(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 5684 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)) 

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN5@SimToggleA
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN5@SimToggleA
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN5@SimToggleA

; 5685 : 	{
; 5686 : 		gNavigationSys->ToggleControlSrc();

	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?ToggleControlSrc@NavigationSystem@@QAEXXZ ; NavigationSystem::ToggleControlSrc

; 5687 : 		gNavigationSys->ToggleUHFSrc();  // MD -- 20031121: added here to match reality

	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?ToggleUHFSrc@NavigationSystem@@QAEXXZ	; NavigationSystem::ToggleUHFSrc

; 5688 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN5@SimToggleA

; 5689 : 			if(gNavigationSys->GetControlSrc() == NavigationSystem::AUXCOMM)

	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetControlSrc@NavigationSystem@@QAE?AW4Tacan_Channel_Src@1@XZ ; NavigationSystem::GetControlSrc
	cmp	eax, 1
	jne	SHORT $LN2@SimToggleA

; 5690 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_AUX_COMM_SRC, 1);

	push	1
	push	181					; 000000b5H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 5691 : 			else

	jmp	SHORT $LN5@SimToggleA
$LN2@SimToggleA:

; 5692 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_AUX_COMM_SRC, 2);

	push	2
	push	181					; 000000b5H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN5@SimToggleA:

; 5693 : 	}
; 5694 : }

	pop	ebp
	ret	0
?SimToggleAuxComMaster@@YAXKHPAX@Z ENDP			; SimToggleAuxComMaster
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCycleBandAuxComDigit@@YAXKHPAX@Z PROC		; SimCycleBandAuxComDigit

; 5671 : void SimCycleBandAuxComDigit(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 5672 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)) 

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN5@SimCycleBa
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN5@SimCycleBa
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN5@SimCycleBa

; 5673 : 	{
; 5674 : 		gNavigationSys->StepTacanBand(NavigationSystem::AUXCOMM);

	push	1
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?StepTacanBand@NavigationSystem@@QAEXW4Tacan_Channel_Src@1@@Z ; NavigationSystem::StepTacanBand

; 5675 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN5@SimCycleBa

; 5676 : 			if(gNavigationSys->GetTacanBand(NavigationSystem::AUXCOMM) == TacanList::X)

	push	1
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetTacanBand@NavigationSystem@@QAE?AW4StationSet@TacanList@@W4Tacan_Channel_Src@1@@Z ; NavigationSystem::GetTacanBand
	test	eax, eax
	jne	SHORT $LN2@SimCycleBa

; 5677 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_TACAN_BAND, 1);

	push	1
	push	182					; 000000b6H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 5678 : 			else

	jmp	SHORT $LN5@SimCycleBa
$LN2@SimCycleBa:

; 5679 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_TACAN_BAND, 2);

	push	2
	push	182					; 000000b6H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN5@SimCycleBa:

; 5680 : 	}
; 5681 : }

	pop	ebp
	ret	0
?SimCycleBandAuxComDigit@@YAXKHPAX@Z ENDP		; SimCycleBandAuxComDigit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$1 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCycleRightAuxComDigit@@YAXKHPAX@Z PROC		; SimCycleRightAuxComDigit

; 5653 : void SimCycleRightAuxComDigit(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp
	push	ecx

; 5654 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)) 

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN1@SimCycleRi
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN1@SimCycleRi
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN1@SimCycleRi

; 5655 : 	{
; 5656 : 		gNavigationSys->StepTacanChannelDigit(NavigationSystem::AUXCOMM, 0);

	push	1
	push	0
	push	1
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?StepTacanChannelDigit@NavigationSystem@@QAEXW4Tacan_Channel_Src@1@HH@Z ; NavigationSystem::StepTacanChannelDigit

; 5657 : 		int val = gNavigationSys->GetTacanChannel(NavigationSystem::AUXCOMM, 0);

	push	0
	push	1
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetTacanChannel@NavigationSystem@@QAEHW4Tacan_Channel_Src@1@H@Z ; NavigationSystem::GetTacanChannel
	mov	DWORD PTR _val$1[ebp], eax

; 5658 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN1@SimCycleRi

; 5659 : 			OTWDriver.GetVirtualCockpit()->SetDOFangle( COMP_3DPIT_TACAN_RIGHT, val * 0.6283F);

	cvtsi2ss xmm0, DWORD PTR _val$1[ebp]
	mulss	xmm0, DWORD PTR __real@3f20d845
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	147					; 00000093H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle
$LN1@SimCycleRi:

; 5660 : 	}
; 5661 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimCycleRightAuxComDigit@@YAXKHPAX@Z ENDP		; SimCycleRightAuxComDigit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$1 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCycleCenterAuxComDigit@@YAXKHPAX@Z PROC		; SimCycleCenterAuxComDigit

; 5633 : void SimCycleCenterAuxComDigit(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp
	push	ecx

; 5634 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)) 

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN1@SimCycleCe
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN1@SimCycleCe
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN1@SimCycleCe

; 5635 : 	{
; 5636 : 		gNavigationSys->StepTacanChannelDigit(NavigationSystem::AUXCOMM, 1);

	push	1
	push	1
	push	1
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?StepTacanChannelDigit@NavigationSystem@@QAEXW4Tacan_Channel_Src@1@HH@Z ; NavigationSystem::StepTacanChannelDigit

; 5637 : 		int val = gNavigationSys->GetTacanChannel(NavigationSystem::AUXCOMM, 1);

	push	1
	push	1
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetTacanChannel@NavigationSystem@@QAEHW4Tacan_Channel_Src@1@H@Z ; NavigationSystem::GetTacanChannel
	mov	DWORD PTR _val$1[ebp], eax

; 5638 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN1@SimCycleCe

; 5639 : 			OTWDriver.GetVirtualCockpit()->SetDOFangle( COMP_3DPIT_TACAN_CENTER, val * 0.6283F);

	cvtsi2ss xmm0, DWORD PTR _val$1[ebp]
	mulss	xmm0, DWORD PTR __real@3f20d845
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	146					; 00000092H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle
$LN1@SimCycleCe:

; 5640 : 	}
; 5641 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimCycleCenterAuxComDigit@@YAXKHPAX@Z ENDP		; SimCycleCenterAuxComDigit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$1 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCycleLeftAuxComDigit@@YAXKHPAX@Z PROC		; SimCycleLeftAuxComDigit

; 5612 : void SimCycleLeftAuxComDigit(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp
	push	ecx

; 5613 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)) 

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN1@SimCycleLe
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN1@SimCycleLe
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN1@SimCycleLe

; 5614 : 	{
; 5615 : 		gNavigationSys->StepTacanChannelDigit(NavigationSystem::AUXCOMM, 2);

	push	1
	push	2
	push	1
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?StepTacanChannelDigit@NavigationSystem@@QAEXW4Tacan_Channel_Src@1@HH@Z ; NavigationSystem::StepTacanChannelDigit

; 5616 : 		int val = gNavigationSys->GetTacanChannel(NavigationSystem::AUXCOMM, 2);

	push	2
	push	1
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetTacanChannel@NavigationSystem@@QAEHW4Tacan_Channel_Src@1@H@Z ; NavigationSystem::GetTacanChannel
	mov	DWORD PTR _val$1[ebp], eax

; 5617 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN1@SimCycleLe

; 5618 : 			OTWDriver.GetVirtualCockpit()->SetDOFangle( COMP_3DPIT_TACAN_LEFT, val * 0.6283F); // radians per digit

	cvtsi2ss xmm0, DWORD PTR _val$1[ebp]
	mulss	xmm0, DWORD PTR __real@3f20d845
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	145					; 00000091H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle
$LN1@SimCycleLe:

; 5619 : 	}
; 5620 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimCycleLeftAuxComDigit@@YAXKHPAX@Z ENDP		; SimCycleLeftAuxComDigit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?ExtinguishMasterCaution@@YAXKHPAX@Z PROC		; ExtinguishMasterCaution

; 5598 : void ExtinguishMasterCaution(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 5599 : 	
; 5600 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@Extinguish
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@Extinguish
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN4@Extinguish

; 5601 : 	{
; 5602 : 		if(SimDriver.GetPlayerAircraft()->mFaults->MasterCaution() == TRUE) {

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+928]
	call	?MasterCaution@FackClass@@QAEHXZ	; FackClass::MasterCaution
	cmp	eax, 1
	jne	SHORT $LN2@Extinguish

; 5603 : 			SimDriver.GetPlayerAircraft()->mFaults->ClearMasterCaution();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+928]
	call	?ClearMasterCaution@FackClass@@QAEXXZ	; FackClass::ClearMasterCaution

; 5604 : 		}
; 5605 : 		else {

	jmp	SHORT $LN4@Extinguish
$LN2@Extinguish:

; 5606 : 			OTWDriver.pCockpitManager->mMiscStates.SetMasterCautionEvent();

	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMasterCautionEvent@CPMisc@@QAEXXZ	; CPMisc::SetMasterCautionEvent
$LN4@Extinguish:

; 5607 : 		}
; 5608 : 	}
; 5609 : 
; 5610 : }

	pop	ebp
	ret	0
?ExtinguishMasterCaution@@YAXKHPAX@Z ENDP		; ExtinguishMasterCaution
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimHUDBrightnessDown@@YAXKHPAX@Z PROC			; SimHUDBrightnessDown

; 5583 : {

	push	ebp
	mov	ebp, esp

; 5584 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimHUDBrig

; 5585 : 		return;

	jmp	SHORT $LN4@SimHUDBrig
$LN3@SimHUDBrig:

; 5586 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimHUDBrig
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimHUDBrig
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimHUDBrig

; 5587 : 	{
; 5588 : 		TheHud->CycleBrightnessSwitchDown();

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?CycleBrightnessSwitchDown@HudClass@@QAEXXZ ; HudClass::CycleBrightnessSwitchDown

; 5589 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimHUDBrig

; 5590 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HUD_DAY_NITE, 1<<(TheHud->GetBrightnessSwitch()-1));

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?GetBrightnessSwitch@HudClass@@QAEHXZ	; HudClass::GetBrightnessSwitch
	sub	eax, 1
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	push	edx
	push	204					; 000000ccH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimHUDBrig:

; 5591 : 	}
; 5592 : }

	pop	ebp
	ret	0
?SimHUDBrightnessDown@@YAXKHPAX@Z ENDP			; SimHUDBrightnessDown
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimHUDBrightnessUp@@YAXKHPAX@Z PROC			; SimHUDBrightnessUp

; 5572 : {

	push	ebp
	mov	ebp, esp

; 5573 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimHUDBrig

; 5574 : 		return;

	jmp	SHORT $LN4@SimHUDBrig
$LN3@SimHUDBrig:

; 5575 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimHUDBrig
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimHUDBrig
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimHUDBrig

; 5576 : 	{
; 5577 : 		TheHud->CycleBrightnessSwitchUp();

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?CycleBrightnessSwitchUp@HudClass@@QAEXXZ ; HudClass::CycleBrightnessSwitchUp

; 5578 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimHUDBrig

; 5579 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HUD_DAY_NITE, 1<<(TheHud->GetBrightnessSwitch()-1));

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?GetBrightnessSwitch@HudClass@@QAEHXZ	; HudClass::GetBrightnessSwitch
	sub	eax, 1
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	push	edx
	push	204					; 000000ccH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimHUDBrig:

; 5580 : 	}
; 5581 : }

	pop	ebp
	ret	0
?SimHUDBrightnessUp@@YAXKHPAX@Z ENDP			; SimHUDBrightnessUp
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimHUDBrtNight@@YAXKHPAX@Z PROC			; SimHUDBrtNight

; 5559 : {

	push	ebp
	mov	ebp, esp

; 5560 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimHUDBrtN

; 5561 : 		return;

	jmp	SHORT $LN4@SimHUDBrtN
$LN3@SimHUDBrtN:

; 5562 : 	if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimHUDBrtN
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimHUDBrtN
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimHUDBrtN

; 5563 : 	{
; 5564 : 		TheHud->SetBrightnessSwitch(HudClass::NIGHT);

	push	3
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?SetBrightnessSwitch@HudClass@@QAEXW4BrightnessSwitch@1@@Z ; HudClass::SetBrightnessSwitch

; 5565 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimHUDBrtN

; 5566 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HUD_DAY_NITE, 4);

	push	4
	push	204					; 000000ccH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimHUDBrtN:

; 5567 : 	}
; 5568 : }

	pop	ebp
	ret	0
?SimHUDBrtNight@@YAXKHPAX@Z ENDP			; SimHUDBrtNight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimHUDBrtAuto@@YAXKHPAX@Z PROC				; SimHUDBrtAuto

; 5547 : {

	push	ebp
	mov	ebp, esp

; 5548 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimHUDBrtA

; 5549 : 		return;

	jmp	SHORT $LN4@SimHUDBrtA
$LN3@SimHUDBrtA:

; 5550 : 	if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimHUDBrtA
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimHUDBrtA
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimHUDBrtA

; 5551 : 	{
; 5552 : 		TheHud->SetBrightnessSwitch(HudClass::BRIGHT_AUTO);

	push	2
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?SetBrightnessSwitch@HudClass@@QAEXW4BrightnessSwitch@1@@Z ; HudClass::SetBrightnessSwitch

; 5553 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimHUDBrtA

; 5554 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HUD_DAY_NITE, 1);

	push	1
	push	204					; 000000ccH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimHUDBrtA:

; 5555 : 	}
; 5556 : }

	pop	ebp
	ret	0
?SimHUDBrtAuto@@YAXKHPAX@Z ENDP				; SimHUDBrtAuto
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimHUDBrtDay@@YAXKHPAX@Z PROC				; SimHUDBrtDay

; 5535 : {

	push	ebp
	mov	ebp, esp

; 5536 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimHUDBrtD

; 5537 : 		return;

	jmp	SHORT $LN4@SimHUDBrtD
$LN3@SimHUDBrtD:

; 5538 : 	if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimHUDBrtD
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimHUDBrtD
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimHUDBrtD

; 5539 : 	{
; 5540 : 		TheHud->SetBrightnessSwitch(HudClass::DAY);

	push	1
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?SetBrightnessSwitch@HudClass@@QAEXW4BrightnessSwitch@1@@Z ; HudClass::SetBrightnessSwitch

; 5541 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimHUDBrtD

; 5542 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HUD_DAY_NITE, 2);

	push	2
	push	204					; 000000ccH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimHUDBrtD:

; 5543 : 	}
; 5544 : }

	pop	ebp
	ret	0
?SimHUDBrtDay@@YAXKHPAX@Z ENDP				; SimHUDBrtDay
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimHUDBrightness@@YAXKHPAX@Z PROC			; SimHUDBrightness

; 5522 : void SimHUDBrightness(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 5523 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimHUDBrig
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimHUDBrig
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimHUDBrig

; 5524 : 	 {
; 5525 : 			TheHud->CycleBrightnessSwitch();

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?CycleBrightnessSwitch@HudClass@@QAEXXZ	; HudClass::CycleBrightnessSwitch

; 5526 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN3@SimHUDBrig

; 5527 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HUD_DAY_NITE, 1<<(TheHud->GetBrightnessSwitch()-1));

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?GetBrightnessSwitch@HudClass@@QAEHXZ	; HudClass::GetBrightnessSwitch
	sub	eax, 1
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	push	edx
	push	204					; 000000ccH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN3@SimHUDBrig:

; 5528 : 	 }
; 5529 : }

	pop	ebp
	ret	0
?SimHUDBrightness@@YAXKHPAX@Z ENDP			; SimHUDBrightness
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimHUDAltAuto@@YAXKHPAX@Z PROC				; SimHUDAltAuto

; 5507 : {

	push	ebp
	mov	ebp, esp

; 5508 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimHUDAltA

; 5509 : 		return;

	jmp	SHORT $LN4@SimHUDAltA
$LN3@SimHUDAltA:

; 5510 : 	if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP))  // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimHUDAltA
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimHUDAltA
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimHUDAltA

; 5511 : 	{
; 5512 : 		TheHud->SetRadarSwitch(HudClass::RADAR_AUTO);

	push	2
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?SetRadarSwitch@HudClass@@QAEXW4RadarSwitch@1@@Z ; HudClass::SetRadarSwitch

; 5513 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimHUDAltA

; 5514 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HUD_RAL_BARO, 1);

	push	1
	push	203					; 000000cbH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimHUDAltA:

; 5515 : 	}
; 5516 : }

	pop	ebp
	ret	0
?SimHUDAltAuto@@YAXKHPAX@Z ENDP				; SimHUDAltAuto
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimHUDAltBaro@@YAXKHPAX@Z PROC				; SimHUDAltBaro

; 5495 : {

	push	ebp
	mov	ebp, esp

; 5496 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimHUDAltB

; 5497 : 		return;

	jmp	SHORT $LN4@SimHUDAltB
$LN3@SimHUDAltB:

; 5498 : 	if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP))  // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimHUDAltB
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimHUDAltB
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimHUDAltB

; 5499 : 	{
; 5500 : 		TheHud->SetRadarSwitch(HudClass::BARO);

	push	1
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?SetRadarSwitch@HudClass@@QAEXW4RadarSwitch@1@@Z ; HudClass::SetRadarSwitch

; 5501 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimHUDAltB

; 5502 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HUD_RAL_BARO, 2);

	push	2
	push	203					; 000000cbH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimHUDAltB:

; 5503 : 	}
; 5504 : }

	pop	ebp
	ret	0
?SimHUDAltBaro@@YAXKHPAX@Z ENDP				; SimHUDAltBaro
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimHUDAltRadar@@YAXKHPAX@Z PROC			; SimHUDAltRadar

; 5483 : {

	push	ebp
	mov	ebp, esp

; 5484 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimHUDAltR

; 5485 : 		return;

	jmp	SHORT $LN4@SimHUDAltR
$LN3@SimHUDAltR:

; 5486 : 	if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP))  // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimHUDAltR
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimHUDAltR
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimHUDAltR

; 5487 : 	{
; 5488 : 		TheHud->SetRadarSwitch(HudClass::ALT_RADAR);

	push	0
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?SetRadarSwitch@HudClass@@QAEXW4RadarSwitch@1@@Z ; HudClass::SetRadarSwitch

; 5489 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimHUDAltR

; 5490 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HUD_RAL_BARO, 4);

	push	4
	push	203					; 000000cbH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimHUDAltR:

; 5491 : 	}
; 5492 : }

	pop	ebp
	ret	0
?SimHUDAltRadar@@YAXKHPAX@Z ENDP			; SimHUDAltRadar
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimHUDRadar@@YAXKHPAX@Z PROC				; SimHUDRadar

; 5462 : void SimHUDRadar(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 5463 :   if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP))  // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN7@SimHUDRada
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN7@SimHUDRada
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN7@SimHUDRada

; 5464 : 	{
; 5465 : 		TheHud->CycleRadarSwitch();

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?CycleRadarSwitch@HudClass@@QAEXXZ	; HudClass::CycleRadarSwitch

; 5466 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN7@SimHUDRada

; 5467 : 		{
; 5468 : 			if (TheHud->GetRadarSwitch() == HudClass::ALT_RADAR)

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?GetRadarSwitch@HudClass@@QAEHXZ	; HudClass::GetRadarSwitch
	test	eax, eax
	jne	SHORT $LN4@SimHUDRada

; 5469 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HUD_RAL_BARO, 4);

	push	4
	push	203					; 000000cbH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 5470 : 			else

	jmp	SHORT $LN7@SimHUDRada
$LN4@SimHUDRada:

; 5471 : 			if (TheHud->GetRadarSwitch() == HudClass::BARO)

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?GetRadarSwitch@HudClass@@QAEHXZ	; HudClass::GetRadarSwitch
	cmp	eax, 1
	jne	SHORT $LN2@SimHUDRada

; 5472 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HUD_RAL_BARO, 2);

	push	2
	push	203					; 000000cbH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 5473 : 			else

	jmp	SHORT $LN7@SimHUDRada
$LN2@SimHUDRada:

; 5474 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HUD_RAL_BARO, 1);

	push	1
	push	203					; 000000cbH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN7@SimHUDRada:

; 5475 : 		}
; 5476 : 	}
; 5477 : }

	pop	ebp
	ret	0
?SimHUDRadar@@YAXKHPAX@Z ENDP				; SimHUDRadar
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimHUDVelocityGND@@YAXKHPAX@Z PROC			; SimHUDVelocityGND

; 5447 : {

	push	ebp
	mov	ebp, esp

; 5448 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimHUDVelo

; 5449 : 		return;

	jmp	SHORT $LN4@SimHUDVelo
$LN3@SimHUDVelo:

; 5450 : 	if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP))  // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimHUDVelo
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimHUDVelo
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimHUDVelo

; 5451 : 	{
; 5452 : 		TheHud->SetVelocitySwitch(HudClass::GND_SPD);

	push	2
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?SetVelocitySwitch@HudClass@@QAEXW4VelocitySwitch@1@@Z ; HudClass::SetVelocitySwitch

; 5453 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimHUDVelo

; 5454 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HUD_VELOCITY, 1);

	push	1
	push	202					; 000000caH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimHUDVelo:

; 5455 : 	}
; 5456 : }

	pop	ebp
	ret	0
?SimHUDVelocityGND@@YAXKHPAX@Z ENDP			; SimHUDVelocityGND
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimHUDVelocityTAS@@YAXKHPAX@Z PROC			; SimHUDVelocityTAS

; 5435 : {

	push	ebp
	mov	ebp, esp

; 5436 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimHUDVelo

; 5437 : 		return;

	jmp	SHORT $LN4@SimHUDVelo
$LN3@SimHUDVelo:

; 5438 : 	if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP))  // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimHUDVelo
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimHUDVelo
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimHUDVelo

; 5439 : 	{
; 5440 : 		TheHud->SetVelocitySwitch(HudClass::TAS);

	push	1
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?SetVelocitySwitch@HudClass@@QAEXW4VelocitySwitch@1@@Z ; HudClass::SetVelocitySwitch

; 5441 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimHUDVelo

; 5442 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HUD_VELOCITY, 2);

	push	2
	push	202					; 000000caH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimHUDVelo:

; 5443 : 	}
; 5444 : }

	pop	ebp
	ret	0
?SimHUDVelocityTAS@@YAXKHPAX@Z ENDP			; SimHUDVelocityTAS
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimHUDVelocityCAS@@YAXKHPAX@Z PROC			; SimHUDVelocityCAS

; 5423 : {

	push	ebp
	mov	ebp, esp

; 5424 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimHUDVelo

; 5425 : 		return;

	jmp	SHORT $LN4@SimHUDVelo
$LN3@SimHUDVelo:

; 5426 : 	if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP))  // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimHUDVelo
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimHUDVelo
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimHUDVelo

; 5427 : 	{
; 5428 : 		TheHud->SetVelocitySwitch(HudClass::CAS);

	push	0
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?SetVelocitySwitch@HudClass@@QAEXW4VelocitySwitch@1@@Z ; HudClass::SetVelocitySwitch

; 5429 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimHUDVelo

; 5430 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HUD_VELOCITY, 4);

	push	4
	push	202					; 000000caH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimHUDVelo:

; 5431 : 	}
; 5432 : }

	pop	ebp
	ret	0
?SimHUDVelocityCAS@@YAXKHPAX@Z ENDP			; SimHUDVelocityCAS
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimHUDVelocity@@YAXKHPAX@Z PROC			; SimHUDVelocity

; 5402 : void SimHUDVelocity(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 5403 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP))  // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN7@SimHUDVelo
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN7@SimHUDVelo
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN7@SimHUDVelo

; 5404 : 	 {
; 5405 : 			TheHud->CycleVelocitySwitch();

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?CycleVelocitySwitch@HudClass@@QAEXXZ	; HudClass::CycleVelocitySwitch

; 5406 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN7@SimHUDVelo

; 5407 : 			{
; 5408 : 				if (TheHud->GetVelocitySwitch() == HudClass::CAS)

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?GetVelocitySwitch@HudClass@@QAEHXZ	; HudClass::GetVelocitySwitch
	test	eax, eax
	jne	SHORT $LN4@SimHUDVelo

; 5409 : 					OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HUD_VELOCITY, 4);

	push	4
	push	202					; 000000caH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 5410 : 				else

	jmp	SHORT $LN7@SimHUDVelo
$LN4@SimHUDVelo:

; 5411 : 				if (TheHud->GetVelocitySwitch() == HudClass::TAS)

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?GetVelocitySwitch@HudClass@@QAEHXZ	; HudClass::GetVelocitySwitch
	cmp	eax, 1
	jne	SHORT $LN2@SimHUDVelo

; 5412 : 					OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HUD_VELOCITY, 2);

	push	2
	push	202					; 000000caH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 5413 : 				else

	jmp	SHORT $LN7@SimHUDVelo
$LN2@SimHUDVelo:

; 5414 : 					OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HUD_VELOCITY, 1);

	push	1
	push	202					; 000000caH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN7@SimHUDVelo:

; 5415 : 			}
; 5416 : 	 }
; 5417 : }

	pop	ebp
	ret	0
?SimHUDVelocity@@YAXKHPAX@Z ENDP			; SimHUDVelocity
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimHUDDEDDED@@YAXKHPAX@Z PROC				; SimHUDDEDDED

; 5387 : {

	push	ebp
	mov	ebp, esp

; 5388 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimHUDDEDD

; 5389 : 		return;

	jmp	SHORT $LN4@SimHUDDEDD
$LN3@SimHUDDEDD:

; 5390 : 	if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP))

	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimHUDDEDD
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimHUDDEDD
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimHUDDEDD

; 5391 : 	{ 
; 5392 : 	  TheHud->SetDEDSwitch(HudClass::DED_DATA);

	push	0
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?SetDEDSwitch@HudClass@@QAEXW4DEDSwitch@1@@Z ; HudClass::SetDEDSwitch

; 5393 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimHUDDEDD

; 5394 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HUD_DED_PFL, 4);

	push	4
	push	200					; 000000c8H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimHUDDEDD:

; 5395 : 	}
; 5396 : }

	pop	ebp
	ret	0
?SimHUDDEDDED@@YAXKHPAX@Z ENDP				; SimHUDDEDDED
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimHUDDEDPFL@@YAXKHPAX@Z PROC				; SimHUDDEDPFL

; 5375 : {

	push	ebp
	mov	ebp, esp

; 5376 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimHUDDEDP

; 5377 : 		return;

	jmp	SHORT $LN4@SimHUDDEDP
$LN3@SimHUDDEDP:

; 5378 : 	if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP))

	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimHUDDEDP
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimHUDDEDP
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimHUDDEDP

; 5379 : 	{
; 5380 : 	  TheHud->SetDEDSwitch(HudClass::PFL_DATA);

	push	2
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?SetDEDSwitch@HudClass@@QAEXW4DEDSwitch@1@@Z ; HudClass::SetDEDSwitch

; 5381 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimHUDDEDP

; 5382 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HUD_DED_PFL, 2);

	push	2
	push	200					; 000000c8H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimHUDDEDP:

; 5383 : 	}
; 5384 : }

	pop	ebp
	ret	0
?SimHUDDEDPFL@@YAXKHPAX@Z ENDP				; SimHUDDEDPFL
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimHUDDEDOff@@YAXKHPAX@Z PROC				; SimHUDDEDOff

; 5363 : {

	push	ebp
	mov	ebp, esp

; 5364 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimHUDDEDO

; 5365 : 		return;

	jmp	SHORT $LN4@SimHUDDEDO
$LN3@SimHUDDEDO:

; 5366 : 	if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP))

	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimHUDDEDO
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimHUDDEDO
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimHUDDEDO

; 5367 : 	{
; 5368 : 	  TheHud->SetDEDSwitch(HudClass::DED_OFF);

	push	1
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?SetDEDSwitch@HudClass@@QAEXW4DEDSwitch@1@@Z ; HudClass::SetDEDSwitch

; 5369 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimHUDDEDO

; 5370 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HUD_DED_PFL, 1);

	push	1
	push	200					; 000000c8H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimHUDDEDO:

; 5371 : 	}
; 5372 : }

	pop	ebp
	ret	0
?SimHUDDEDOff@@YAXKHPAX@Z ENDP				; SimHUDDEDOff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimHUDDED@@YAXKHPAX@Z PROC				; SimHUDDED

; 5342 : {

	push	ebp
	mov	ebp, esp

; 5343 : 	if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP))  // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN7@SimHUDDED
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN7@SimHUDDED
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN7@SimHUDDED

; 5344 : 	{
; 5345 : 		TheHud->CycleDEDSwitch();

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?CycleDEDSwitch@HudClass@@QAEXXZ	; HudClass::CycleDEDSwitch

; 5346 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN7@SimHUDDED

; 5347 : 		{
; 5348 : 			if (TheHud->GetDEDSwitch() == HudClass::PFL_DATA)

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?GetDEDSwitch@HudClass@@QAEHXZ		; HudClass::GetDEDSwitch
	cmp	eax, 2
	jne	SHORT $LN4@SimHUDDED

; 5349 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HUD_DED_PFL, 2);

	push	2
	push	200					; 000000c8H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 5350 : 			else

	jmp	SHORT $LN7@SimHUDDED
$LN4@SimHUDDED:

; 5351 : 			if (TheHud->GetDEDSwitch() == HudClass::DED_DATA)

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?GetDEDSwitch@HudClass@@QAEHXZ		; HudClass::GetDEDSwitch
	test	eax, eax
	jne	SHORT $LN2@SimHUDDED

; 5352 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HUD_DED_PFL, 4);

	push	4
	push	200					; 000000c8H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 5353 : 			else

	jmp	SHORT $LN7@SimHUDDED
$LN2@SimHUDDED:

; 5354 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HUD_DED_PFL, 1);

	push	1
	push	200					; 000000c8H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN7@SimHUDDED:

; 5355 : 		}
; 5356 : 	}
; 5357 : }

	pop	ebp
	ret	0
?SimHUDDED@@YAXKHPAX@Z ENDP				; SimHUDDED
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimHUDFPM@@YAXKHPAX@Z PROC				; SimHUDFPM

; 5331 : void SimHUDFPM(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 5332 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimHUDFPM
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimHUDFPM
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimHUDFPM

; 5333 : 		TheHud->CycleFPMSwitch();

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?CycleFPMSwitch@HudClass@@QAEXXZ	; HudClass::CycleFPMSwitch
$LN2@SimHUDFPM:

; 5334 : 	}
; 5335 : }

	pop	ebp
	ret	0
?SimHUDFPM@@YAXKHPAX@Z ENDP				; SimHUDFPM
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimScalesOff@@YAXKHPAX@Z PROC				; SimScalesOff

; 2635 : {

	push	ebp
	mov	ebp, esp

; 2636 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimScalesO

; 2637 : 		return;

	jmp	SHORT $LN4@SimScalesO
$LN3@SimScalesO:

; 2638 : 	if ((state & KEY_DOWN) && (SimDriver.GetPlayerAircraft()) && (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)))

	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimScalesO
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimScalesO
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimScalesO

; 2639 : 	{
; 2640 : 		TheHud->SetScalesSwitch(HudClass::SS_OFF);

	push	3
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?SetScalesSwitch@HudClass@@QAEXW4ScalesSwitch@1@@Z ; HudClass::SetScalesSwitch

; 2641 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimScalesO

; 2642 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HUD_VAH, 1);

	push	1
	push	198					; 000000c6H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimScalesO:

; 2643 : 	}
; 2644 : }

	pop	ebp
	ret	0
?SimScalesOff@@YAXKHPAX@Z ENDP				; SimScalesOff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimScalesVAH@@YAXKHPAX@Z PROC				; SimScalesVAH

; 2623 : {

	push	ebp
	mov	ebp, esp

; 2624 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimScalesV

; 2625 : 		return;

	jmp	SHORT $LN4@SimScalesV
$LN3@SimScalesV:

; 2626 : 	if ((state & KEY_DOWN) && (SimDriver.GetPlayerAircraft()) && (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)))

	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimScalesV
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimScalesV
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimScalesV

; 2627 : 	{
; 2628 : 		TheHud->SetScalesSwitch(HudClass::VAH);

	push	1
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?SetScalesSwitch@HudClass@@QAEXW4ScalesSwitch@1@@Z ; HudClass::SetScalesSwitch

; 2629 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimScalesV

; 2630 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HUD_VAH, 4);

	push	4
	push	198					; 000000c6H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimScalesV:

; 2631 : 	}
; 2632 : }

	pop	ebp
	ret	0
?SimScalesVAH@@YAXKHPAX@Z ENDP				; SimScalesVAH
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimScalesVVVAH@@YAXKHPAX@Z PROC			; SimScalesVVVAH

; 2611 : {

	push	ebp
	mov	ebp, esp

; 2612 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimScalesV

; 2613 : 		return;

	jmp	SHORT $LN4@SimScalesV
$LN3@SimScalesV:

; 2614 : 	if ((state & KEY_DOWN) && (SimDriver.GetPlayerAircraft()) && (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)))

	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimScalesV
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimScalesV
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimScalesV

; 2615 : 	{
; 2616 : 		TheHud->SetScalesSwitch(HudClass::VV_VAH);

	push	0
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?SetScalesSwitch@HudClass@@QAEXW4ScalesSwitch@1@@Z ; HudClass::SetScalesSwitch

; 2617 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimScalesV

; 2618 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HUD_VAH, 2);

	push	2
	push	198					; 000000c6H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimScalesV:

; 2619 : 	}
; 2620 : }

	pop	ebp
	ret	0
?SimScalesVVVAH@@YAXKHPAX@Z ENDP			; SimScalesVVVAH
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimHUDScales@@YAXKHPAX@Z PROC				; SimHUDScales

; 5321 : void SimHUDScales(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 5322 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimHUDScal
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimHUDScal
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimHUDScal

; 5323 : 		TheHud->CycleScalesSwitch();

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?CycleScalesSwitch@HudClass@@QAEXXZ	; HudClass::CycleScalesSwitch
$LN2@SimHUDScal:

; 5324 : 	}
; 5325 : }

	pop	ebp
	ret	0
?SimHUDScales@@YAXKHPAX@Z ENDP				; SimHUDScales
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_pradar$1 = -12						; size = 4
_pradar$2 = -8						; size = 4
_pradar$3 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
_pButton$ = 16						; size = 4
?SimICPAG@@YAXKHPAX@Z PROC				; SimICPAG

; 5198 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 5199 : 	if (!SimDriver.GetPlayerAircraft() || !SimDriver.GetPlayerAircraft()->IsSetFlag( MOTION_OWNSHIP )) // 2002-02-15 ADDED BY S.G. Do it once here and removed the corresponding line from below

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN16@SimICPAG
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	jne	SHORT $LN17@SimICPAG
$LN16@SimICPAG:

; 5200 : 		return;

	jmp	$LN18@SimICPAG
$LN17@SimICPAG:

; 5201 : 
; 5202 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	$LN15@SimICPAG

; 5203 : 	{
; 5204 : 		//MI Original Code
; 5205 : 	   if (state & KEY_DOWN && !((AircraftClass*)SimDriver.GetPlayerAircraft())->ejectTriggered) {

	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	$LN14@SimICPAG
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1796], 0
	jne	$LN14@SimICPAG

; 5206 : 
; 5207 : 			OTWDriver.pCockpitManager->mpIcp->HandleInput(AG_BUTTON, (CPButtonObject*)pButton);

	mov	edx, DWORD PTR _pButton$[ebp]
	push	edx
	push	12					; 0000000cH
	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [eax+688]
	call	?HandleInput@ICPClass@@QAEXHPAVCPButtonObject@@@Z ; ICPClass::HandleInput

; 5208 : 			SimDriver.GetPlayerAircraft()->FCC->SetMasterMode(FireControlComputer::AirGroundBomb);

	push	5
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?SetMasterMode@FireControlComputer@@QAEXW4FCCMasterMode@1@@Z ; FireControlComputer::SetMasterMode

; 5209 : 
; 5210 : 			// Put the radar in the its default AG mode
; 5211 : 			RadarClass* pradar = (RadarClass*) FindSensor (SimDriver.GetPlayerAircraft(), SensorClass::Radar);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _pradar$3[ebp], eax

; 5212 : 			if (pradar)

	cmp	DWORD PTR _pradar$3[ebp], 0
	je	SHORT $LN13@SimICPAG

; 5213 : 				pradar->DefaultAGMode();

	mov	ecx, DWORD PTR _pradar$3[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pradar$3[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
$LN13@SimICPAG:

; 5214 : 
; 5215 : 			// Configure the MFDs
; 5216 : 			MfdDisplay[0]->SetNewMode(MFDClass::FCRMode);

	push	10					; 0000000aH
	mov	ecx, 4
	imul	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?SetNewMode@MFDClass@@QAEXW4MfdMode@1@@Z ; MFDClass::SetNewMode

; 5217 : 			MfdDisplay[1]->SetNewMode(MFDClass::SMSMode);

	push	11					; 0000000bH
	mov	edx, 4
	shl	edx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[edx]
	call	?SetNewMode@MFDClass@@QAEXW4MfdMode@1@@Z ; MFDClass::SetNewMode
$LN14@SimICPAG:

; 5218 : 		}
; 5219 : 	}
; 5220 : 	else

	jmp	$LN18@SimICPAG
$LN15@SimICPAG:

; 5221 : 	{
; 5222 : 		//MI 3/1/2002 if we're in DF or MRM, don't do anything
; 5223 : 		if(SimDriver.GetPlayerAircraft()->FCC && (SimDriver.GetPlayerAircraft()->FCC->GetMasterMode() == 
; 5224 : 			FireControlComputer::Dogfight || SimDriver.GetPlayerAircraft()->FCC->GetMasterMode() == FireControlComputer::MissileOverride))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+936], 0
	je	SHORT $LN11@SimICPAG
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 9
	je	SHORT $LN10@SimICPAG
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN11@SimICPAG
$LN10@SimICPAG:

; 5225 : 			return;

	jmp	$LN18@SimICPAG
$LN11@SimICPAG:

; 5226 : 
; 5227 : 		if (SimDriver.GetPlayerAircraft()->Sms)	//JPO CTDfix	//Set our display mode

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+940], 0
	je	SHORT $LN9@SimICPAG

; 5228 : 			SimDriver.GetPlayerAircraft()->Sms->drawable->SetDisplayMode(SmsDrawable::Wpn);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	eax, DWORD PTR [eax+940]
	mov	ecx, DWORD PTR [eax+160]
	call	?SetDisplayMode@SmsDrawable@@QAEXW4SmsDisplayMode@1@@Z ; SmsDrawable::SetDisplayMode
$LN9@SimICPAG:

; 5229 : 		//MI added/modified for ICP Stuff
; 5230 : 		if (state & KEY_DOWN && !((AircraftClass*)SimDriver.GetPlayerAircraft())->ejectTriggered) 

	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	$LN18@SimICPAG
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1796], 0
	jne	$LN18@SimICPAG

; 5231 : 		{
; 5232 : 		   //Have we pushed this button before?
; 5233 : 		   if(OTWDriver.pCockpitManager->mpIcp->IsICPSet(ICPClass::MODE_A_G))

	push	2
	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [edx+688]
	call	?IsICPSet@ICPClass@@QAEHH@Z		; ICPClass::IsICPSet
	test	eax, eax
	je	$LN7@SimICPAG

; 5234 : 		   {
; 5235 : 			   //Yes, we pushed it before. Let's go back into NAV mode
; 5236 : 			   //Set our FCC into NAV mode
; 5237 : 			   //SimDriver.GetPlayerAircraft()->FCC->SetMasterMode(FireControlComputer::Nav);
; 5238 : 			   SimDriver.GetPlayerAircraft()->FCC->SetMasterMode( SimDriver.GetPlayerAircraft()->FCC->GetLastNavMasterMode() ); //ASSOCIATOR

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?GetLastNavMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetLastNavMasterMode
	push	eax
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?SetMasterMode@FireControlComputer@@QAEXW4FCCMasterMode@1@@Z ; FireControlComputer::SetMasterMode

; 5239 : 
; 5240 : 			   //passes our puttonstate to the ICP
; 5241 : 			   OTWDriver.pCockpitManager->mpIcp->HandleInput(NAV_BUTTON, (CPButtonObject*)pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	10					; 0000000aH
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [ecx+688]
	call	?HandleInput@ICPClass@@QAEXHPAVCPButtonObject@@@Z ; ICPClass::HandleInput

; 5242 : 			   
; 5243 : 			   // Put the radar in the its default AA mode
; 5244 : 			   RadarClass* pradar = (RadarClass*) FindSensor (SimDriver.GetPlayerAircraft(), SensorClass::Radar);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _pradar$2[ebp], eax

; 5245 : 			   if (pradar)

	cmp	DWORD PTR _pradar$2[ebp], 0
	je	SHORT $LN6@SimICPAG

; 5246 : 					pradar->DefaultAGMode();

	mov	edx, DWORD PTR _pradar$2[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pradar$2[ebp]
	mov	edx, DWORD PTR [eax+148]
	call	edx
$LN6@SimICPAG:

; 5247 : 
; 5248 : 			   // Configure the MFDs
; 5249 : 			   		// Configure the MFDs
; 5250 : 			   MfdDisplay[0]->SetNewMasterMode(SimDriver.GetPlayerAircraft()->FCC->GetMainMasterMode());

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?GetMainMasterMode@FireControlComputer@@QAE?AW4MASTERMODES@@XZ ; FireControlComputer::GetMainMasterMode
	push	eax
	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[eax]
	call	?SetNewMasterMode@MFDClass@@QAEXH@Z	; MFDClass::SetNewMasterMode

; 5251 : 			   MfdDisplay[1]->SetNewMasterMode(SimDriver.GetPlayerAircraft()->FCC->GetMainMasterMode());

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?GetMainMasterMode@FireControlComputer@@QAE?AW4MASTERMODES@@XZ ; FireControlComputer::GetMainMasterMode
	push	eax
	mov	ecx, 4
	shl	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?SetNewMasterMode@MFDClass@@QAEXH@Z	; MFDClass::SetNewMasterMode

; 5252 : 
; 5253 : 
; 5254 : 			   //Clear the flag indicating we are in A_G mode
; 5255 : 			   //This is so we know that we have to go into A_G mode next time
; 5256 : 			   OTWDriver.pCockpitManager->mpIcp->ClearICPFlag(ICPClass::MODE_A_G);

	push	2
	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [edx+688]
	call	?ClearICPFlag@ICPClass@@QAEXH@Z		; ICPClass::ClearICPFlag

; 5257 : 
; 5258 : 			   //If our A_A NAV mode flag is set, clear it so we get into
; 5259 : 			   //A_A mode when we push that button
; 5260 : 			   if(OTWDriver.pCockpitManager->mpIcp->IsICPSet(ICPClass::MODE_A_A))

	push	1
	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [eax+688]
	call	?IsICPSet@ICPClass@@QAEHH@Z		; ICPClass::IsICPSet
	test	eax, eax
	je	SHORT $LN5@SimICPAG

; 5261 : 				   OTWDriver.pCockpitManager->mpIcp->ClearICPFlag(ICPClass::MODE_A_A);

	push	1
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [ecx+688]
	call	?ClearICPFlag@ICPClass@@QAEXH@Z		; ICPClass::ClearICPFlag
$LN5@SimICPAG:

; 5262 : 
; 5263 : 		   }

	jmp	$LN18@SimICPAG
$LN7@SimICPAG:

; 5264 : 		   else if (SimDriver.GetPlayerAircraft()->Sms)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+940], 0
	je	$LN18@SimICPAG

; 5265 : 		   {
; 5266 : 			   SimDriver.GetPlayerAircraft()->FCC->EnterAGMasterMode();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?EnterAGMasterMode@FireControlComputer@@QAEXXZ ; FireControlComputer::EnterAGMasterMode

; 5267 : 			   //passes our puttonstate to the ICP
; 5268 : 			   OTWDriver.pCockpitManager->mpIcp->HandleInput(AG_BUTTON, (CPButtonObject*)pButton);

	mov	edx, DWORD PTR _pButton$[ebp]
	push	edx
	push	12					; 0000000cH
	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [eax+688]
	call	?HandleInput@ICPClass@@QAEXHPAVCPButtonObject@@@Z ; ICPClass::HandleInput

; 5269 : 
; 5270 : 			   // Put the radar in the its default AG mode
; 5271 : 			   //Makes us go into NAV mode next time we push it.
; 5272 : 			   RadarClass* pradar = (RadarClass*) FindSensor (SimDriver.GetPlayerAircraft(), SensorClass::Radar);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _pradar$1[ebp], eax

; 5273 : 			   if (pradar)

	cmp	DWORD PTR _pradar$1[ebp], 0
	je	SHORT $LN2@SimICPAG

; 5274 : 					pradar->DefaultAGMode();

	mov	ecx, DWORD PTR _pradar$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pradar$1[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
$LN2@SimICPAG:

; 5275 : 
; 5276 : 			   // Configure the MFDs
; 5277 : 			   MfdDisplay[0]->SetNewMasterMode(SimDriver.GetPlayerAircraft()->FCC->GetMainMasterMode());

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?GetMainMasterMode@FireControlComputer@@QAE?AW4MASTERMODES@@XZ ; FireControlComputer::GetMainMasterMode
	push	eax
	mov	ecx, 4
	imul	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?SetNewMasterMode@MFDClass@@QAEXH@Z	; MFDClass::SetNewMasterMode

; 5278 : 			   MfdDisplay[1]->SetNewMasterMode(SimDriver.GetPlayerAircraft()->FCC->GetMainMasterMode());

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?GetMainMasterMode@FireControlComputer@@QAE?AW4MASTERMODES@@XZ ; FireControlComputer::GetMainMasterMode
	push	eax
	mov	edx, 4
	shl	edx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[edx]
	call	?SetNewMasterMode@MFDClass@@QAEXH@Z	; MFDClass::SetNewMasterMode

; 5279 : 
; 5280 : 			   //Set the Flag that we've been here before
; 5281 : 			   OTWDriver.pCockpitManager->mpIcp->SetICPFlag(ICPClass::MODE_A_G);

	push	2
	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [eax+688]
	call	?SetICPFlag@ICPClass@@QAEXH@Z		; ICPClass::SetICPFlag

; 5282 : 
; 5283 : 			   //If our A_A mode flag is set, clear it so we get into
; 5284 : 			   //A_A mode when we push the A_A button
; 5285 : 			   if(OTWDriver.pCockpitManager->mpIcp->IsICPSet(ICPClass::MODE_A_A))

	push	1
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [ecx+688]
	call	?IsICPSet@ICPClass@@QAEHH@Z		; ICPClass::IsICPSet
	test	eax, eax
	je	SHORT $LN18@SimICPAG

; 5286 : 				   OTWDriver.pCockpitManager->mpIcp->ClearICPFlag(ICPClass::MODE_A_A);

	push	1
	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [edx+688]
	call	?ClearICPFlag@ICPClass@@QAEXH@Z		; ICPClass::ClearICPFlag
$LN18@SimICPAG:

; 5287 : 		   }
; 5288 : 	   }
; 5289 : 	}
; 5290 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimICPAG@@YAXKHPAX@Z ENDP				; SimICPAG
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_pradar$1 = -16						; size = 4
_pradar$2 = -12						; size = 4
_pradar$3 = -8						; size = 4
_playerAC$ = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
_pButton$ = 16						; size = 4
?SimICPAA@@YAXKHPAX@Z PROC				; SimICPAA

; 5053 : void SimICPAA(unsigned long, int state, void* pButton){

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 5054 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 5055 : 	if (!playerAC || !playerAC->IsSetFlag( MOTION_OWNSHIP )){

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	SHORT $LN16@SimICPAA
	push	65536					; 00010000H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	jne	SHORT $LN17@SimICPAA
$LN16@SimICPAA:

; 5056 : 		// 2002-02-15 ADDED BY S.G. Do it once here and removed the corresponding line from below
; 5057 : 		return;

	jmp	$LN18@SimICPAA
$LN17@SimICPAA:

; 5058 : 	}
; 5059 : 
; 5060 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	$LN15@SimICPAA

; 5061 : 	{
; 5062 : 		//MI Original code
; 5063 : 		if (state & KEY_DOWN && !playerAC->ejectTriggered) {

	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	$LN14@SimICPAA
	mov	edx, DWORD PTR _playerAC$[ebp]
	cmp	DWORD PTR [edx+1796], 0
	jne	$LN14@SimICPAA

; 5064 : 
; 5065 : 			OTWDriver.pCockpitManager->mpIcp->HandleInput(AA_BUTTON, (CPButtonObject*)pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	11					; 0000000bH
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [ecx+688]
	call	?HandleInput@ICPClass@@QAEXHPAVCPButtonObject@@@Z ; ICPClass::HandleInput

; 5066 : 			playerAC->FCC->SetMasterMode(FireControlComputer::AAGun);

	push	0
	mov	edx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [edx+936]
	call	?SetMasterMode@FireControlComputer@@QAEXW4FCCMasterMode@1@@Z ; FireControlComputer::SetMasterMode

; 5067 : 
; 5068 : 			// Put the radar in the its default AA mode
; 5069 : 			RadarClass* pradar = (RadarClass*) FindSensor(playerAC, SensorClass::Radar);

	push	1
	mov	eax, DWORD PTR _playerAC$[ebp]
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _pradar$3[ebp], eax

; 5070 : 			// sfr: @todo remove JB check
; 5071 : 			if (pradar && !F4IsBadReadPtr(pradar, sizeof(RadarClass))){

	cmp	DWORD PTR _pradar$3[ebp], 0
	je	SHORT $LN13@SimICPAA
	push	132					; 00000084H
	mov	ecx, DWORD PTR _pradar$3[ebp]
	push	ecx
	call	?F4IsBadReadPtr@@YA_NPBXI@Z		; F4IsBadReadPtr
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN13@SimICPAA

; 5072 : 				// JB 010404 CTD
; 5073 : 				pradar->DefaultAAMode();

	mov	eax, DWORD PTR _pradar$3[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pradar$3[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN13@SimICPAA:

; 5074 : 			}
; 5075 : 
; 5076 : 			// Configure the MFDs
; 5077 : 			MfdDisplay[0]->SetNewMode(MFDClass::FCRMode);

	push	10					; 0000000aH
	mov	ecx, 4
	imul	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?SetNewMode@MFDClass@@QAEXW4MfdMode@1@@Z ; MFDClass::SetNewMode

; 5078 : 			MfdDisplay[1]->SetNewMode(MFDClass::SMSMode);

	push	11					; 0000000bH
	mov	edx, 4
	shl	edx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[edx]
	call	?SetNewMode@MFDClass@@QAEXW4MfdMode@1@@Z ; MFDClass::SetNewMode
$LN14@SimICPAA:

; 5079 : 		}
; 5080 : 	}
; 5081 : 	else

	jmp	$LN18@SimICPAA
$LN15@SimICPAA:

; 5082 : 	{
; 5083 : 		//MI 3/1/2002 if we're in DF or MRM, don't do anything
; 5084 : 		if (
; 5085 : 			playerAC->FCC && 
; 5086 : 			(
; 5087 : 				playerAC->FCC->GetMasterMode() == FireControlComputer::Dogfight || 
; 5088 : 				playerAC->FCC->GetMasterMode() == FireControlComputer::MissileOverride
; 5089 : 			)
; 5090 : 		){

	mov	eax, DWORD PTR _playerAC$[ebp]
	cmp	DWORD PTR [eax+936], 0
	je	SHORT $LN11@SimICPAA
	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [ecx+936]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 9
	je	SHORT $LN10@SimICPAA
	mov	edx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [edx+936]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN11@SimICPAA
$LN10@SimICPAA:

; 5091 : 			return;

	jmp	$LN18@SimICPAA
$LN11@SimICPAA:

; 5092 : 		}
; 5093 : 
; 5094 : 		//Set our display mode
; 5095 : 		// Marco edit - SimDriver.GetPlayerAircraft() was often 00000000 in dogfight - CTD S.G. Caugth above now
; 5096 : 		if (playerAC->Sms){

	mov	eax, DWORD PTR _playerAC$[ebp]
	cmp	DWORD PTR [eax+940], 0
	je	SHORT $LN9@SimICPAA

; 5097 : 			if (playerAC->Sms->drawable){

	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	edx, DWORD PTR [ecx+940]
	cmp	DWORD PTR [edx+160], 0
	je	SHORT $LN9@SimICPAA

; 5098 : 				//me123 ctd in dogfight games on entry...this was 00000000
; 5099 : 				playerAC->Sms->drawable->SetDisplayMode(SmsDrawable::Wpn);

	push	2
	mov	eax, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [eax+940]
	mov	ecx, DWORD PTR [ecx+160]
	call	?SetDisplayMode@SmsDrawable@@QAEXW4SmsDisplayMode@1@@Z ; SmsDrawable::SetDisplayMode
$LN9@SimICPAA:

; 5100 : 			}
; 5101 : 		}
; 5102 : 
; 5103 : 	   //MI added/modified for ICP Stuff
; 5104 : 	   if (state & KEY_DOWN && !playerAC->ejectTriggered){ 

	mov	edx, DWORD PTR _state$[ebp]
	and	edx, 8
	je	$LN18@SimICPAA
	mov	eax, DWORD PTR _playerAC$[ebp]
	cmp	DWORD PTR [eax+1796], 0
	jne	$LN18@SimICPAA

; 5105 : 		   //Player hit the button. Is our MODE_A_A Flag set?
; 5106 : 		   //Since we start in NAV Mode by default, we want to get into
; 5107 : 		   //A_A mode the first time we push the button
; 5108 : 		   if(OTWDriver.pCockpitManager->mpIcp->IsICPSet(ICPClass::MODE_A_A))

	push	1
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [ecx+688]
	call	?IsICPSet@ICPClass@@QAEHH@Z		; ICPClass::IsICPSet
	test	eax, eax
	je	$LN6@SimICPAA

; 5109 : 		   {
; 5110 : 			   //Player pushed this button previously, so let's go back
; 5111 : 			   //to NAV mode
; 5112 : 			   //SimDriver.GetPlayerAircraft()->FCC->SetMasterMode(FireControlComputer::Nav);
; 5113 : 			   playerAC->FCC->SetMasterMode( playerAC->FCC->GetLastNavMasterMode() ); //ASSOCIATOR

	mov	edx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [edx+936]
	call	?GetLastNavMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetLastNavMasterMode
	push	eax
	mov	eax, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [eax+936]
	call	?SetMasterMode@FireControlComputer@@QAEXW4FCCMasterMode@1@@Z ; FireControlComputer::SetMasterMode

; 5114 : 			   
; 5115 : 			   //passes our puttonstate to the ICP
; 5116 : 			   OTWDriver.pCockpitManager->mpIcp->HandleInput(NAV_BUTTON, (CPButtonObject*)pButton);

	mov	ecx, DWORD PTR _pButton$[ebp]
	push	ecx
	push	10					; 0000000aH
	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [edx+688]
	call	?HandleInput@ICPClass@@QAEXHPAVCPButtonObject@@@Z ; ICPClass::HandleInput

; 5117 : 			   
; 5118 : 			   // Put the radar in the its default AA mode
; 5119 : 			   RadarClass* pradar = (RadarClass*) FindSensor (playerAC, SensorClass::Radar);

	push	1
	mov	eax, DWORD PTR _playerAC$[ebp]
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _pradar$2[ebp], eax

; 5120 : 			   if (pradar){

	cmp	DWORD PTR _pradar$2[ebp], 0
	je	SHORT $LN5@SimICPAA

; 5121 : 					pradar->DefaultAAMode();			   

	mov	ecx, DWORD PTR _pradar$2[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pradar$2[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN5@SimICPAA:

; 5122 : 			   }
; 5123 : 
; 5124 : 			   // Configure the MFDs
; 5125 : 			   MfdDisplay[0]->SetNewMasterMode(playerAC->FCC->GetMainMasterMode());

	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [ecx+936]
	call	?GetMainMasterMode@FireControlComputer@@QAE?AW4MASTERMODES@@XZ ; FireControlComputer::GetMainMasterMode
	push	eax
	mov	edx, 4
	imul	edx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[edx]
	call	?SetNewMasterMode@MFDClass@@QAEXH@Z	; MFDClass::SetNewMasterMode

; 5126 : 			   MfdDisplay[1]->SetNewMasterMode(playerAC->FCC->GetMainMasterMode());

	mov	eax, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [eax+936]
	call	?GetMainMasterMode@FireControlComputer@@QAE?AW4MASTERMODES@@XZ ; FireControlComputer::GetMainMasterMode
	push	eax
	mov	ecx, 4
	shl	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?SetNewMasterMode@MFDClass@@QAEXH@Z	; MFDClass::SetNewMasterMode

; 5127 : 
; 5128 : 			   //Clear the flag indicating we are in A_A mode
; 5129 : 			   //This is so we know that we have to go into A_A mode next time
; 5130 : 			   OTWDriver.pCockpitManager->mpIcp->ClearICPFlag(ICPClass::MODE_A_A);

	push	1
	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [edx+688]
	call	?ClearICPFlag@ICPClass@@QAEXH@Z		; ICPClass::ClearICPFlag

; 5131 : 
; 5132 : 			   //If our A_G mode flag is set, clear it so we get into
; 5133 : 			   //A_G mode when we push the A_G button
; 5134 : 			   if(OTWDriver.pCockpitManager->mpIcp->IsICPSet(ICPClass::MODE_A_G)){

	push	2
	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [eax+688]
	call	?IsICPSet@ICPClass@@QAEHH@Z		; ICPClass::IsICPSet
	test	eax, eax
	je	SHORT $LN4@SimICPAA

; 5135 : 				   OTWDriver.pCockpitManager->mpIcp->ClearICPFlag(ICPClass::MODE_A_G);

	push	2
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [ecx+688]
	call	?ClearICPFlag@ICPClass@@QAEXH@Z		; ICPClass::ClearICPFlag
$LN4@SimICPAA:

; 5136 : 			   }
; 5137 : 		   }
; 5138 : 		   //no, we press this button the first time
; 5139 : 		   else {

	jmp	$LN18@SimICPAA
$LN6@SimICPAA:

; 5140 : 				playerAC->FCC->EnterAAMasterMode();

	mov	edx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [edx+936]
	call	?EnterAAMasterMode@FireControlComputer@@QAEXXZ ; FireControlComputer::EnterAAMasterMode

; 5141 : 								
; 5142 : 			   //passes our puttonstate to the ICP
; 5143 : 			   OTWDriver.pCockpitManager->mpIcp->HandleInput(AA_BUTTON, (CPButtonObject*)pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	11					; 0000000bH
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [ecx+688]
	call	?HandleInput@ICPClass@@QAEXHPAVCPButtonObject@@@Z ; ICPClass::HandleInput

; 5144 : 			   
; 5145 : 			   // Put the radar in the its default AA mode
; 5146 : 			   RadarClass* pradar = (RadarClass*) FindSensor (playerAC, SensorClass::Radar);

	push	1
	mov	edx, DWORD PTR _playerAC$[ebp]
	push	edx
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _pradar$1[ebp], eax

; 5147 : 			   if (pradar){

	cmp	DWORD PTR _pradar$1[ebp], 0
	je	SHORT $LN2@SimICPAA

; 5148 : 					pradar->DefaultAAMode();

	mov	eax, DWORD PTR _pradar$1[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pradar$1[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN2@SimICPAA:

; 5149 : 			   }
; 5150 : 
; 5151 : 			   // Configure the MFDs
; 5152 : 			   MfdDisplay[0]->SetNewMasterMode(playerAC->FCC->GetMainMasterMode());

	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [ecx+936]
	call	?GetMainMasterMode@FireControlComputer@@QAE?AW4MASTERMODES@@XZ ; FireControlComputer::GetMainMasterMode
	push	eax
	mov	edx, 4
	imul	edx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[edx]
	call	?SetNewMasterMode@MFDClass@@QAEXH@Z	; MFDClass::SetNewMasterMode

; 5153 : 			   MfdDisplay[1]->SetNewMasterMode(playerAC->FCC->GetMainMasterMode());

	mov	eax, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [eax+936]
	call	?GetMainMasterMode@FireControlComputer@@QAE?AW4MASTERMODES@@XZ ; FireControlComputer::GetMainMasterMode
	push	eax
	mov	ecx, 4
	shl	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?SetNewMasterMode@MFDClass@@QAEXH@Z	; MFDClass::SetNewMasterMode

; 5154 : 			   
; 5155 : 			   //Set the flag indicating that we pushed the button
; 5156 : 			   //so we go into NAV mode the next time we push it
; 5157 : 			   OTWDriver.pCockpitManager->mpIcp->SetICPFlag(ICPClass::MODE_A_A);

	push	1
	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [edx+688]
	call	?SetICPFlag@ICPClass@@QAEXH@Z		; ICPClass::SetICPFlag

; 5158 : 
; 5159 : 			   //If our A_G NAV mode flag is set, clear it so we get into
; 5160 : 			   //A_G mode when we push that button
; 5161 : 			   if(OTWDriver.pCockpitManager->mpIcp->IsICPSet(ICPClass::MODE_A_G)){

	push	2
	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [eax+688]
	call	?IsICPSet@ICPClass@@QAEHH@Z		; ICPClass::IsICPSet
	test	eax, eax
	je	SHORT $LN18@SimICPAA

; 5162 : 				   OTWDriver.pCockpitManager->mpIcp->ClearICPFlag(ICPClass::MODE_A_G);

	push	2
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [ecx+688]
	call	?ClearICPFlag@ICPClass@@QAEXH@Z		; ICPClass::ClearICPFlag
$LN18@SimICPAA:

; 5163 : 			   }
; 5164 : 		   }
; 5165 : 	   } 	
; 5166 : 	}
; 5167 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimICPAA@@YAXKHPAX@Z ENDP				; SimICPAA
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_pradar$1 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
_pButton$ = 16						; size = 4
?SimICPNav@@YAXKHPAX@Z PROC				; SimICPNav

; 4985 : void SimICPNav(unsigned long, int state, void* pButton) {

	push	ebp
	mov	ebp, esp
	push	ecx

; 4986 : 
; 4987 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag( MOTION_OWNSHIP ) && !((AircraftClass*)SimDriver.GetPlayerAircraft())->ejectTriggered) {

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN9@SimICPNav
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN9@SimICPNav
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN9@SimICPNav
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1796], 0
	jne	$LN9@SimICPNav

; 4988 : 
; 4989 : 		OTWDriver.pCockpitManager->mpIcp->HandleInput(NAV_BUTTON, (CPButtonObject*)pButton);

	mov	ecx, DWORD PTR _pButton$[ebp]
	push	ecx
	push	10					; 0000000aH
	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [edx+688]
	call	?HandleInput@ICPClass@@QAEXHPAVCPButtonObject@@@Z ; ICPClass::HandleInput

; 4990 : if (
; 4991 : 	 F4IsBadReadPtr(SimDriver.GetPlayerAircraft(), sizeof(AircraftClass)) || // JB 010317 CTD
; 4992 : 	 !SimDriver.GetPlayerAircraft()->FCC || // JB 010307 CTD
; 4993 : 	 F4IsBadReadPtr(SimDriver.GetPlayerAircraft()->FCC, sizeof(FireControlComputer)) || // JB 010307 CTD
; 4994 : 	 SimDriver.GetPlayerAircraft()->FCC->GetMasterMode() == FireControlComputer::MissileOverride ||
; 4995 : 	 SimDriver.GetPlayerAircraft()->FCC->GetMasterMode() == FireControlComputer::Dogfight) return;

	push	3624					; 00000e28H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?F4IsBadReadPtr@@YA_NPBXI@Z		; F4IsBadReadPtr
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN6@SimICPNav
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+936], 0
	je	SHORT $LN6@SimICPNav
	push	524					; 0000020cH
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	push	ecx
	call	?F4IsBadReadPtr@@YA_NPBXI@Z		; F4IsBadReadPtr
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN6@SimICPNav
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN6@SimICPNav
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 9
	jne	SHORT $LN7@SimICPNav
$LN6@SimICPNav:
	jmp	$LN9@SimICPNav
$LN7@SimICPNav:

; 4996 : 
; 4997 : 		// Select our FCC/HUD mode based on the NAV sub mode (ILS or not)
; 4998 : 		if (OTWDriver.pCockpitManager->mpIcp->GetICPSecondaryMode() == ILS_MODE) {

	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [eax+688]
	call	?GetICPSecondaryMode@ICPClass@@QAEJXZ	; ICPClass::GetICPSecondaryMode
	cmp	eax, 4
	jne	SHORT $LN5@SimICPNav

; 4999 : 			SimDriver.GetPlayerAircraft()->FCC->SetMasterMode(FireControlComputer::ILS);

	push	3
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?SetMasterMode@FireControlComputer@@QAEXW4FCCMasterMode@1@@Z ; FireControlComputer::SetMasterMode

; 5000 : 		} else {

	jmp	SHORT $LN4@SimICPNav
$LN5@SimICPNav:

; 5001 : 			SimDriver.GetPlayerAircraft()->FCC->SetMasterMode(FireControlComputer::Nav);

	push	4
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?SetMasterMode@FireControlComputer@@QAEXW4FCCMasterMode@1@@Z ; FireControlComputer::SetMasterMode
$LN4@SimICPNav:

; 5002 : 		}
; 5003 : 
; 5004 : 		// Put the radar in the its default AA mode
; 5005 : 		RadarClass* pradar = (RadarClass*) FindSensor (SimDriver.GetPlayerAircraft(), SensorClass::Radar);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _pradar$1[ebp], eax

; 5006 : 		if (pradar && !F4IsBadCodePtr((FARPROC) pradar)) // JB 010220 CTD

	cmp	DWORD PTR _pradar$1[ebp], 0
	je	SHORT $LN3@SimICPNav
	mov	ecx, DWORD PTR _pradar$1[ebp]
	push	ecx
	call	?F4IsBadCodePtr@@YA_NPAX@Z		; F4IsBadCodePtr
	add	esp, 4
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN3@SimICPNav

; 5007 : 			pradar->DefaultAAMode();

	mov	eax, DWORD PTR _pradar$1[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pradar$1[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN3@SimICPNav:

; 5008 : 		
; 5009 : 		if (g_bRealisticAvionics) {

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN2@SimICPNav

; 5010 : 		    MfdDisplay[0]->SetNewMasterMode(SimDriver.GetPlayerAircraft()->FCC->GetMainMasterMode());

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?GetMainMasterMode@FireControlComputer@@QAE?AW4MASTERMODES@@XZ ; FireControlComputer::GetMainMasterMode
	push	eax
	mov	edx, 4
	imul	edx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[edx]
	call	?SetNewMasterMode@MFDClass@@QAEXH@Z	; MFDClass::SetNewMasterMode

; 5011 : 		    MfdDisplay[1]->SetNewMasterMode(SimDriver.GetPlayerAircraft()->FCC->GetMainMasterMode());

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?GetMainMasterMode@FireControlComputer@@QAE?AW4MASTERMODES@@XZ ; FireControlComputer::GetMainMasterMode
	push	eax
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[eax]
	call	?SetNewMasterMode@MFDClass@@QAEXH@Z	; MFDClass::SetNewMasterMode

; 5012 : 		} else {

	jmp	SHORT $LN9@SimICPNav
$LN2@SimICPNav:

; 5013 : 		    // Configure the MFDs
; 5014 : 		    MfdDisplay[0]->SetNewMode(MFDClass::FCRMode);

	push	10					; 0000000aH
	mov	ecx, 4
	imul	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?SetNewMode@MFDClass@@QAEXW4MfdMode@1@@Z ; MFDClass::SetNewMode

; 5015 : 		    MfdDisplay[1]->SetNewMode(MFDClass::FCCMode);

	push	9
	mov	edx, 4
	shl	edx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[edx]
	call	?SetNewMode@MFDClass@@QAEXW4MfdMode@1@@Z ; MFDClass::SetNewMode
$LN9@SimICPNav:

; 5016 : 		}
; 5017 : 	}
; 5018 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimICPNav@@YAXKHPAX@Z ENDP				; SimICPNav
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
_pButton$ = 16						; size = 4
?SimICPCom2@@YAXKHPAX@Z PROC				; SimICPCom2

; 4975 : void SimICPCom2(unsigned long, int state, void* pButton) {

	push	ebp
	mov	ebp, esp

; 4976 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag( MOTION_OWNSHIP ) && !((AircraftClass*)SimDriver.GetPlayerAircraft())->ejectTriggered) {

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimICPCom2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimICPCom2
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimICPCom2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1796], 0
	jne	SHORT $LN2@SimICPCom2

; 4977 : 		OTWDriver.pCockpitManager->mpIcp->HandleInput(COMM2_BUTTON, (CPButtonObject*)pButton);

	mov	ecx, DWORD PTR _pButton$[ebp]
	push	ecx
	push	7
	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [edx+688]
	call	?HandleInput@ICPClass@@QAEXHPAVCPButtonObject@@@Z ; ICPClass::HandleInput
$LN2@SimICPCom2:

; 4978 : 	}
; 4979 : }

	pop	ebp
	ret	0
?SimICPCom2@@YAXKHPAX@Z ENDP				; SimICPCom2
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
_pButton$ = 16						; size = 4
?SimICPCom1@@YAXKHPAX@Z PROC				; SimICPCom1

; 4968 : void SimICPCom1(unsigned long, int state, void* pButton) {

	push	ebp
	mov	ebp, esp

; 4969 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag( MOTION_OWNSHIP ) && !((AircraftClass*)SimDriver.GetPlayerAircraft())->ejectTriggered) {

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimICPCom1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimICPCom1
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimICPCom1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1796], 0
	jne	SHORT $LN2@SimICPCom1

; 4970 : 		OTWDriver.pCockpitManager->mpIcp->HandleInput(COMM1_BUTTON, (CPButtonObject*)pButton);

	mov	ecx, DWORD PTR _pButton$[ebp]
	push	ecx
	push	6
	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [edx+688]
	call	?HandleInput@ICPClass@@QAEXHPAVCPButtonObject@@@Z ; ICPClass::HandleInput
$LN2@SimICPCom1:

; 4971 : 	}
; 4972 : }

	pop	ebp
	ret	0
?SimICPCom1@@YAXKHPAX@Z ENDP				; SimICPCom1
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
_pButton$ = 16						; size = 4
?SimICPEnter@@YAXKHPAX@Z PROC				; SimICPEnter

; 4958 : void SimICPEnter(unsigned long, int state, void* pButton) {

	push	ebp
	mov	ebp, esp

; 4959 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag( MOTION_OWNSHIP ) && !((AircraftClass*)SimDriver.GetPlayerAircraft())->ejectTriggered) {

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimICPEnte
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimICPEnte
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimICPEnte
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1796], 0
	jne	SHORT $LN2@SimICPEnte

; 4960 : 		OTWDriver.pCockpitManager->mpIcp->HandleInput(ENTR_BUTTON, (CPButtonObject*)pButton);

	mov	ecx, DWORD PTR _pButton$[ebp]
	push	ecx
	push	15					; 0000000fH
	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [edx+688]
	call	?HandleInput@ICPClass@@QAEXHPAVCPButtonObject@@@Z ; ICPClass::HandleInput
$LN2@SimICPEnte:

; 4961 : 	}
; 4962 : }

	pop	ebp
	ret	0
?SimICPEnter@@YAXKHPAX@Z ENDP				; SimICPEnter
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
_pButton$ = 16						; size = 4
?SimICPMark@@YAXKHPAX@Z PROC				; SimICPMark

; 4948 : void SimICPMark(unsigned long, int state, void* pButton) {

	push	ebp
	mov	ebp, esp

; 4949 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag( MOTION_OWNSHIP ) && !((AircraftClass*)SimDriver.GetPlayerAircraft())->ejectTriggered) {

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimICPMark
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimICPMark
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimICPMark
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1796], 0
	jne	SHORT $LN2@SimICPMark

; 4950 : 		OTWDriver.pCockpitManager->mpIcp->HandleInput(MARK_BUTTON, (CPButtonObject*)pButton);

	mov	ecx, DWORD PTR _pButton$[ebp]
	push	ecx
	push	3
	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [edx+688]
	call	?HandleInput@ICPClass@@QAEXHPAVCPButtonObject@@@Z ; ICPClass::HandleInput
$LN2@SimICPMark:

; 4951 : 	}
; 4952 : }

	pop	ebp
	ret	0
?SimICPMark@@YAXKHPAX@Z ENDP				; SimICPMark
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
_pButton$ = 16						; size = 4
?SimICPStpt@@YAXKHPAX@Z PROC				; SimICPStpt

; 4938 : void SimICPStpt(unsigned long, int state, void* pButton) {

	push	ebp
	mov	ebp, esp

; 4939 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag( MOTION_OWNSHIP ) && !((AircraftClass*)SimDriver.GetPlayerAircraft())->ejectTriggered) {

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimICPStpt
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimICPStpt
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimICPStpt
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1796], 0
	jne	SHORT $LN2@SimICPStpt

; 4940 : 		OTWDriver.pCockpitManager->mpIcp->HandleInput(STPT_BUTTON, (CPButtonObject*)pButton);

	mov	ecx, DWORD PTR _pButton$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [edx+688]
	call	?HandleInput@ICPClass@@QAEXHPAVCPButtonObject@@@Z ; ICPClass::HandleInput
$LN2@SimICPStpt:

; 4941 : 	}
; 4942 : }

	pop	ebp
	ret	0
?SimICPStpt@@YAXKHPAX@Z ENDP				; SimICPStpt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
_pButton$ = 16						; size = 4
?SimICPCrus@@YAXKHPAX@Z PROC				; SimICPCrus

; 4928 : void SimICPCrus(unsigned long, int state, void* pButton) {

	push	ebp
	mov	ebp, esp

; 4929 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag( MOTION_OWNSHIP ) && !((AircraftClass*)SimDriver.GetPlayerAircraft())->ejectTriggered) {

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimICPCrus
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimICPCrus
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimICPCrus
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1796], 0
	jne	SHORT $LN2@SimICPCrus

; 4930 : 		OTWDriver.pCockpitManager->mpIcp->HandleInput(CRUS_BUTTON, (CPButtonObject*)pButton);

	mov	ecx, DWORD PTR _pButton$[ebp]
	push	ecx
	push	5
	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [edx+688]
	call	?HandleInput@ICPClass@@QAEXHPAVCPButtonObject@@@Z ; ICPClass::HandleInput
$LN2@SimICPCrus:

; 4931 : 	}
; 4932 : }

	pop	ebp
	ret	0
?SimICPCrus@@YAXKHPAX@Z ENDP				; SimICPCrus
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
$T2 = -44						; size = 8
$T3 = -36						; size = 4
tv147 = -32						; size = 4
$T4 = -28						; size = 4
tv134 = -24						; size = 4
_playerAC$ = -20					; size = 4
_pmsg$5 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
_pButton$ = 16						; size = 4
?SimICPLink@@YAXKHPAX@Z PROC				; SimICPLink

; 4879 : void SimICPLink(unsigned long, int state, void* pButton) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SimICPLink@@YAXKHPAX@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 4880 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 4881 : 	if (
; 4882 : 		state & KEY_DOWN && playerAC && playerAC->IsSetFlag( MOTION_OWNSHIP ) && !playerAC->ejectTriggered
; 4883 : 	){

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN2@SimICPLink
	cmp	DWORD PTR _playerAC$[ebp], 0
	je	$LN2@SimICPLink
	push	65536					; 00010000H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN2@SimICPLink
	mov	ecx, DWORD PTR _playerAC$[ebp]
	cmp	DWORD PTR [ecx+1796], 0
	jne	$LN2@SimICPLink

; 4884 : 		// test code
; 4885 : 		FalconDLinkMessage *pmsg;
; 4886 : 		pmsg = new FalconDLinkMessage (SimDriver.GetPlayerAircraft()->Id(), FalconLocalGame);

	push	123					; 0000007bH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T4[ebp], 0
	je	SHORT $LN6@SimICPLink
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN4@SimICPLink
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv134[ebp], eax
	jmp	SHORT $LN5@SimICPLink
$LN4@SimICPLink:
	mov	DWORD PTR tv134[ebp], 0
$LN5@SimICPLink:
	push	1
	mov	eax, DWORD PTR tv134[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR $T4[ebp]
	call	??0FalconDLinkMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z ; FalconDLinkMessage::FalconDLinkMessage
	mov	DWORD PTR tv147[ebp], eax
	jmp	SHORT $LN7@SimICPLink
$LN6@SimICPLink:
	mov	DWORD PTR tv147[ebp], 0
$LN7@SimICPLink:
	mov	ecx, DWORD PTR tv147[ebp]
	mov	DWORD PTR $T3[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T3[ebp]
	mov	DWORD PTR _pmsg$5[ebp], edx

; 4887 : 		
; 4888 : 		pmsg->dataBlock.numPoints	= 4;

	mov	eax, DWORD PTR _pmsg$5[ebp]
	mov	BYTE PTR [eax+48], 4

; 4889 : 		pmsg->dataBlock.targetType	= 50;

	mov	ecx, 50					; 00000032H
	mov	edx, DWORD PTR _pmsg$5[ebp]
	mov	WORD PTR [edx+49], cx

; 4890 : 		pmsg->dataBlock.threatType	= 90;

	mov	eax, 90					; 0000005aH
	mov	ecx, DWORD PTR _pmsg$5[ebp]
	mov	WORD PTR [ecx+51], ax

; 4891 :    
; 4892 : 		
; 4893 : 		pmsg->dataBlock.ptype[0]	= FalconDLinkMessage::IP;

	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _pmsg$5[ebp]
	mov	DWORD PTR [eax+edx+53], 1

; 4894 : 		pmsg->dataBlock.px[0]		= 300;

	mov	ecx, 2
	imul	ecx, 0
	mov	edx, 300				; 0000012cH
	mov	eax, DWORD PTR _pmsg$5[ebp]
	mov	WORD PTR [eax+ecx+73], dx

; 4895 : 		pmsg->dataBlock.py[0]		= 300;

	mov	ecx, 2
	imul	ecx, 0
	mov	edx, 300				; 0000012cH
	mov	eax, DWORD PTR _pmsg$5[ebp]
	mov	WORD PTR [eax+ecx+83], dx

; 4896 : 		pmsg->dataBlock.pz[0]		= 300;

	mov	ecx, 2
	imul	ecx, 0
	mov	edx, 300				; 0000012cH
	mov	eax, DWORD PTR _pmsg$5[ebp]
	mov	WORD PTR [eax+ecx+93], dx

; 4897 : 		pmsg->dataBlock.arrivalTime[0]	= SimLibElapsedTime;

	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _pmsg$5[ebp]
	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [edx+ecx+103], eax

; 4898 : 
; 4899 : 		pmsg->dataBlock.ptype[1]	= FalconDLinkMessage::TGT;

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pmsg$5[ebp]
	mov	DWORD PTR [edx+ecx+53], 2

; 4900 : 		pmsg->dataBlock.px[1]		= 400;

	mov	eax, 2
	shl	eax, 0
	mov	ecx, 400				; 00000190H
	mov	edx, DWORD PTR _pmsg$5[ebp]
	mov	WORD PTR [edx+eax+73], cx

; 4901 : 		pmsg->dataBlock.py[1]		= 500;

	mov	eax, 2
	shl	eax, 0
	mov	ecx, 500				; 000001f4H
	mov	edx, DWORD PTR _pmsg$5[ebp]
	mov	WORD PTR [edx+eax+83], cx

; 4902 : 		pmsg->dataBlock.pz[1]		= 600;

	mov	eax, 2
	shl	eax, 0
	mov	ecx, 600				; 00000258H
	mov	edx, DWORD PTR _pmsg$5[ebp]
	mov	WORD PTR [edx+eax+93], cx

; 4903 : 		pmsg->dataBlock.arrivalTime[1]		= SimLibElapsedTime;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pmsg$5[ebp]
	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [ecx+eax+103], edx

; 4904 : 
; 4905 : 		pmsg->dataBlock.ptype[2]	= FalconDLinkMessage::EGR;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pmsg$5[ebp]
	mov	DWORD PTR [ecx+eax+53], 3

; 4906 : 		pmsg->dataBlock.px[2]		= 500;

	mov	edx, 2
	shl	edx, 1
	mov	eax, 500				; 000001f4H
	mov	ecx, DWORD PTR _pmsg$5[ebp]
	mov	WORD PTR [ecx+edx+73], ax

; 4907 : 		pmsg->dataBlock.py[2]		= 800;

	mov	edx, 2
	shl	edx, 1
	mov	eax, 800				; 00000320H
	mov	ecx, DWORD PTR _pmsg$5[ebp]
	mov	WORD PTR [ecx+edx+83], ax

; 4908 : 		pmsg->dataBlock.pz[2]		= 400;

	mov	edx, 2
	shl	edx, 1
	mov	eax, 400				; 00000190H
	mov	ecx, DWORD PTR _pmsg$5[ebp]
	mov	WORD PTR [ecx+edx+93], ax

; 4909 : 		pmsg->dataBlock.arrivalTime[2]	= SimLibElapsedTime;

	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pmsg$5[ebp]
	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [eax+edx+103], ecx

; 4910 : 
; 4911 : 		pmsg->dataBlock.ptype[3]	= FalconDLinkMessage::CP;

	mov	edx, 4
	imul	edx, 3
	mov	eax, DWORD PTR _pmsg$5[ebp]
	mov	DWORD PTR [eax+edx+53], 4

; 4912 : 		pmsg->dataBlock.px[3]		= 600;

	mov	ecx, 2
	imul	ecx, 3
	mov	edx, 600				; 00000258H
	mov	eax, DWORD PTR _pmsg$5[ebp]
	mov	WORD PTR [eax+ecx+73], dx

; 4913 : 		pmsg->dataBlock.py[3]		= 700;

	mov	ecx, 2
	imul	ecx, 3
	mov	edx, 700				; 000002bcH
	mov	eax, DWORD PTR _pmsg$5[ebp]
	mov	WORD PTR [eax+ecx+83], dx

; 4914 : 		pmsg->dataBlock.pz[3]		= 300;

	mov	ecx, 2
	imul	ecx, 3
	mov	edx, 300				; 0000012cH
	mov	eax, DWORD PTR _pmsg$5[ebp]
	mov	WORD PTR [eax+ecx+93], dx

; 4915 : 		pmsg->dataBlock.arrivalTime[3]	= SimLibElapsedTime;

	mov	ecx, 4
	imul	ecx, 3
	mov	edx, DWORD PTR _pmsg$5[ebp]
	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [edx+ecx+103], eax

; 4916 : 	
; 4917 : 		FalconSendMessage (pmsg, TRUE);

	push	1
	mov	ecx, DWORD PTR _pmsg$5[ebp]
	push	ecx
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8

; 4918 : 		//end test code
; 4919 : 
; 4920 : 		OTWDriver.pCockpitManager->mpIcp->HandleInput(DLINK_BUTTON, (CPButtonObject*)pButton);

	mov	edx, DWORD PTR _pButton$[ebp]
	push	edx
	push	2
	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [eax+688]
	call	?HandleInput@ICPClass@@QAEXHPAVCPButtonObject@@@Z ; ICPClass::HandleInput
$LN2@SimICPLink:

; 4921 : 	}
; 4922 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SimICPLink@@YAXKHPAX@Z$0:
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?SimICPLink@@YAXKHPAX@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SimICPLink@@YAXKHPAX@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SimICPLink@@YAXKHPAX@Z ENDP				; SimICPLink
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
_pButton$ = 16						; size = 4
?SimICPNext@@YAXKHPAX@Z PROC				; SimICPNext

; 4866 : {

	push	ebp
	mov	ebp, esp

; 4867 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag( MOTION_OWNSHIP ) && !((AircraftClass*)SimDriver.GetPlayerAircraft())->ejectTriggered) 

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimICPNext
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimICPNext
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimICPNext
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1796], 0
	jne	SHORT $LN3@SimICPNext

; 4868 : 	 {
; 4869 : 			OTWDriver.pCockpitManager->mpIcp->HandleInput(NEXT_BUTTON, (CPButtonObject*)pButton);

	mov	ecx, DWORD PTR _pButton$[ebp]
	push	ecx
	push	14					; 0000000eH
	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [edx+688]
	call	?HandleInput@ICPClass@@QAEXHPAVCPButtonObject@@@Z ; ICPClass::HandleInput

; 4870 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN3@SimICPNext

; 4871 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_ICP_NEXT, 2);

	push	2
	push	132					; 00000084H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN3@SimICPNext:

; 4872 : 	 }
; 4873 : }

	pop	ebp
	ret	0
?SimICPNext@@YAXKHPAX@Z ENDP				; SimICPNext
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
_pButton$ = 16						; size = 4
?SimICPPrevious@@YAXKHPAX@Z PROC			; SimICPPrevious

; 4852 : {

	push	ebp
	mov	ebp, esp

; 4853 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag( MOTION_OWNSHIP ) && !((AircraftClass*)SimDriver.GetPlayerAircraft())->ejectTriggered) 

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimICPPrev
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimICPPrev
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimICPPrev
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1796], 0
	jne	SHORT $LN3@SimICPPrev

; 4854 : 	 {
; 4855 : 			OTWDriver.pCockpitManager->mpIcp->HandleInput(PREV_BUTTON, (CPButtonObject*)pButton);

	mov	ecx, DWORD PTR _pButton$[ebp]
	push	ecx
	push	13					; 0000000dH
	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [edx+688]
	call	?HandleInput@ICPClass@@QAEXHPAVCPButtonObject@@@Z ; ICPClass::HandleInput

; 4856 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN3@SimICPPrev

; 4857 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_ICP_NEXT, 4);

	push	4
	push	132					; 00000084H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN3@SimICPPrev:

; 4858 : 	 }
; 4859 : }

	pop	ebp
	ret	0
?SimICPPrevious@@YAXKHPAX@Z ENDP			; SimICPPrevious
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
_pButton$ = 16						; size = 4
?SimICPFAck@@YAXKHPAX@Z PROC				; SimICPFAck

; 4838 : void SimICPFAck(unsigned long, int state, void* pButton) {

	push	ebp
	mov	ebp, esp

; 4839 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag( MOTION_OWNSHIP ) && !((AircraftClass*)SimDriver.GetPlayerAircraft())->ejectTriggered) {

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimICPFAck
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimICPFAck
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimICPFAck
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1796], 0
	jne	SHORT $LN3@SimICPFAck

; 4840 : 		OTWDriver.pCockpitManager->mpIcp->HandleInput(FACK_BUTTON, (CPButtonObject*)pButton);

	mov	ecx, DWORD PTR _pButton$[ebp]
	push	ecx
	push	8
	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [edx+688]
	call	?HandleInput@ICPClass@@QAEXHPAVCPButtonObject@@@Z ; ICPClass::HandleInput

; 4841 : 		if(g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN3@SimICPFAck

; 4842 : 			SimDriver.GetPlayerAircraft()->mFaults->ClearAvioncFault();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+928]
	call	?ClearAvioncFault@FackClass@@QAEXXZ	; FackClass::ClearAvioncFault
$LN3@SimICPFAck:

; 4843 : 	}
; 4844 : }

	pop	ebp
	ret	0
?SimICPFAck@@YAXKHPAX@Z ENDP				; SimICPFAck
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
_pButton$ = 16						; size = 4
?SimICPALOW@@YAXKHPAX@Z PROC				; SimICPALOW

; 4829 : void SimICPALOW(unsigned long, int state, void* pButton) {

	push	ebp
	mov	ebp, esp

; 4830 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag( MOTION_OWNSHIP ) && !((AircraftClass*)SimDriver.GetPlayerAircraft())->ejectTriggered) {

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimICPALOW
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimICPALOW
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimICPALOW
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1796], 0
	jne	SHORT $LN2@SimICPALOW

; 4831 : 		OTWDriver.pCockpitManager->mpIcp->HandleInput(ALOW_BUTTON, (CPButtonObject*)pButton);

	mov	ecx, DWORD PTR _pButton$[ebp]
	push	ecx
	push	9
	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [edx+688]
	call	?HandleInput@ICPClass@@QAEXHPAVCPButtonObject@@@Z ; ICPClass::HandleInput
$LN2@SimICPALOW:

; 4832 : 	}
; 4833 : }

	pop	ebp
	ret	0
?SimICPALOW@@YAXKHPAX@Z ENDP				; SimICPALOW
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
_pButton$ = 16						; size = 4
?SimICPTILS@@YAXKHPAX@Z PROC				; SimICPTILS

; 4777 : {

	push	ebp
	mov	ebp, esp

; 4778 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	$LN13@SimICPTILS

; 4779 : 	{
; 4780 : 		//MI Original code
; 4781 : 		if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag( MOTION_OWNSHIP ) && !((AircraftClass*)SimDriver.GetPlayerAircraft())->ejectTriggered) {

	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	$LN12@SimICPTILS
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN12@SimICPTILS
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN12@SimICPTILS
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1796], 0
	jne	SHORT $LN12@SimICPTILS

; 4782 : 			OTWDriver.pCockpitManager->mpIcp->HandleInput(ILS_BUTTON, (CPButtonObject*)pButton);

	mov	edx, DWORD PTR _pButton$[ebp]
	push	edx
	push	4
	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [eax+688]
	call	?HandleInput@ICPClass@@QAEXHPAVCPButtonObject@@@Z ; ICPClass::HandleInput

; 4783 : 
; 4784 : 			// If we're in NAV mode, update the FCC/HUD mode
; 4785 : 			if (OTWDriver.pCockpitManager->mpIcp->GetICPPrimaryMode() == NAV_MODE) {

	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [ecx+688]
	call	?GetICPPrimaryMode@ICPClass@@QAEJXZ	; ICPClass::GetICPPrimaryMode
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN12@SimICPTILS

; 4786 : 				if (OTWDriver.pCockpitManager->mpIcp->GetICPSecondaryMode() == ILS_MODE) {

	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [edx+688]
	call	?GetICPSecondaryMode@ICPClass@@QAEJXZ	; ICPClass::GetICPSecondaryMode
	cmp	eax, 4
	jne	SHORT $LN10@SimICPTILS

; 4787 : 					SimDriver.GetPlayerAircraft()->FCC->SetMasterMode(FireControlComputer::ILS);

	push	3
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?SetMasterMode@FireControlComputer@@QAEXW4FCCMasterMode@1@@Z ; FireControlComputer::SetMasterMode

; 4788 : 				} else {

	jmp	SHORT $LN12@SimICPTILS
$LN10@SimICPTILS:

; 4789 : 					SimDriver.GetPlayerAircraft()->FCC->SetMasterMode(FireControlComputer::Nav);

	push	4
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?SetMasterMode@FireControlComputer@@QAEXW4FCCMasterMode@1@@Z ; FireControlComputer::SetMasterMode
$LN12@SimICPTILS:

; 4790 : 				}
; 4791 : 			}
; 4792 : 		}
; 4793 : 	}
; 4794 : 	else

	jmp	$LN14@SimICPTILS
$LN13@SimICPTILS:

; 4795 : 	{
; 4796 : 		//MI modified/added for ICP stuff
; 4797 : 	    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag( MOTION_OWNSHIP ) && !((AircraftClass*)SimDriver.GetPlayerAircraft())->ejectTriggered) 

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN7@SimICPTILS
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN7@SimICPTILS
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN7@SimICPTILS
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1796], 0
	jne	SHORT $LN7@SimICPTILS

; 4798 : 		{
; 4799 : 	 	   OTWDriver.pCockpitManager->mpIcp->HandleInput(ILS_BUTTON, (CPButtonObject*)pButton);

	mov	ecx, DWORD PTR _pButton$[ebp]
	push	ecx
	push	4
	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [edx+688]
	call	?HandleInput@ICPClass@@QAEXHPAVCPButtonObject@@@Z ; ICPClass::HandleInput
$LN7@SimICPTILS:

; 4800 : 		}
; 4801 : 
; 4802 : 	    if(!OTWDriver.pCockpitManager->mpIcp->IsICPSet(ICPClass::MODE_CNI))

	push	128					; 00000080H
	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [eax+688]
	call	?IsICPSet@ICPClass@@QAEHH@Z		; ICPClass::IsICPSet
	test	eax, eax
	jne	SHORT $LN6@SimICPTILS

; 4803 : 		    return;

	jmp	$LN14@SimICPTILS

; 4804 : 	    else

	jmp	$LN14@SimICPTILS
$LN6@SimICPTILS:

; 4805 : 		{
; 4806 : 		    // If we're in NAV mode, update the FCC/HUD mode
; 4807 : 		    //if (OTWDriver.pCockpitManager->mpIcp->GetICPPrimaryMode() == NAV_MODE) 
; 4808 : 			if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->FCC && SimDriver.GetPlayerAircraft()->FCC->IsNavMasterMode())

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN14@SimICPTILS
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+936], 0
	je	SHORT $LN14@SimICPTILS
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?IsNavMasterMode@FireControlComputer@@QAEHXZ ; FireControlComputer::IsNavMasterMode
	test	eax, eax
	je	SHORT $LN14@SimICPTILS

; 4809 : 			{  
; 4810 : 			    if (OTWDriver.pCockpitManager->mpIcp->GetICPSecondaryMode() == ILS_MODE &&
; 4811 : 					(gNavigationSys->GetInstrumentMode() == NavigationSystem::ILS_NAV ||
; 4812 : 					 gNavigationSys->GetInstrumentMode() == NavigationSystem::ILS_TACAN))

	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [ecx+688]
	call	?GetICPSecondaryMode@ICPClass@@QAEJXZ	; ICPClass::GetICPSecondaryMode
	cmp	eax, 4
	jne	SHORT $LN3@SimICPTILS
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetInstrumentMode@NavigationSystem@@QAE?AW4Instrument_Mode@1@XZ ; NavigationSystem::GetInstrumentMode
	cmp	eax, 1
	je	SHORT $LN2@SimICPTILS
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetInstrumentMode@NavigationSystem@@QAE?AW4Instrument_Mode@1@XZ ; NavigationSystem::GetInstrumentMode
	cmp	eax, 2
	jne	SHORT $LN3@SimICPTILS
$LN2@SimICPTILS:

; 4813 : 				{
; 4814 : 				    SimDriver.GetPlayerAircraft()->FCC->SetMasterMode(FireControlComputer::ILS);

	push	3
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?SetMasterMode@FireControlComputer@@QAEXW4FCCMasterMode@1@@Z ; FireControlComputer::SetMasterMode

; 4815 : 				} 
; 4816 : 			    else	 

	jmp	SHORT $LN14@SimICPTILS
$LN3@SimICPTILS:

; 4817 : 				{
; 4818 : 				    SimDriver.GetPlayerAircraft()->FCC->SetMasterMode(FireControlComputer::Nav);

	push	4
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?SetMasterMode@FireControlComputer@@QAEXW4FCCMasterMode@1@@Z ; FireControlComputer::SetMasterMode
$LN14@SimICPTILS:

; 4819 : 				}
; 4820 : 			} 
; 4821 : 		} 
; 4822 : 	}
; 4823 : }

	pop	ebp
	ret	0
?SimICPTILS@@YAXKHPAX@Z ENDP				; SimICPTILS
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_GAINDOWN_L@@YAXKHPAX@Z PROC			; SimCBEOSB_GAINDOWN_L

; 4746 : {

	push	ebp
	mov	ebp, esp

; 4747 : 	if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4748 : 	{
; 4749 : 		MfdDisplay[0]->DecreaseBrightness();

	mov	ecx, 4
	imul	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?DecreaseBrightness@MFDClass@@QAEXXZ	; MFDClass::DecreaseBrightness
$LN2@SimCBEOSB_:

; 4750 : 	}
; 4751 : }

	pop	ebp
	ret	0
?SimCBEOSB_GAINDOWN_L@@YAXKHPAX@Z ENDP			; SimCBEOSB_GAINDOWN_L
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_GAINDOWN_R@@YAXKHPAX@Z PROC			; SimCBEOSB_GAINDOWN_R

; 4738 : {

	push	ebp
	mov	ebp, esp

; 4739 : 	if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4740 : 	{
; 4741 : 		MfdDisplay[1]->DecreaseBrightness();

	mov	ecx, 4
	shl	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?DecreaseBrightness@MFDClass@@QAEXXZ	; MFDClass::DecreaseBrightness
$LN2@SimCBEOSB_:

; 4742 : 	}
; 4743 : }

	pop	ebp
	ret	0
?SimCBEOSB_GAINDOWN_R@@YAXKHPAX@Z ENDP			; SimCBEOSB_GAINDOWN_R
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_GAINUP_L@@YAXKHPAX@Z PROC			; SimCBEOSB_GAINUP_L

; 4711 : {

	push	ebp
	mov	ebp, esp

; 4712 : 	if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4713 : 	{
; 4714 : 		MfdDisplay[0]->IncreaseBrightness();

	mov	ecx, 4
	imul	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?IncreaseBrightness@MFDClass@@QAEXXZ	; MFDClass::IncreaseBrightness
$LN2@SimCBEOSB_:

; 4715 : 	}
; 4716 : }

	pop	ebp
	ret	0
?SimCBEOSB_GAINUP_L@@YAXKHPAX@Z ENDP			; SimCBEOSB_GAINUP_L
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_GAINUP_R@@YAXKHPAX@Z PROC			; SimCBEOSB_GAINUP_R

; 4703 : {

	push	ebp
	mov	ebp, esp

; 4704 : 	if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4705 : 	{
; 4706 : 		MfdDisplay[1]->IncreaseBrightness();

	mov	ecx, 4
	shl	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?IncreaseBrightness@MFDClass@@QAEXXZ	; MFDClass::IncreaseBrightness
$LN2@SimCBEOSB_:

; 4707 : 	}
; 4708 : }

	pop	ebp
	ret	0
?SimCBEOSB_GAINUP_R@@YAXKHPAX@Z ENDP			; SimCBEOSB_GAINUP_R
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_GAINDOWN_F@@YAXKHPAX@Z PROC			; SimCBEOSB_GAINDOWN_F

; 4764 : {

	push	ebp
	mov	ebp, esp

; 4765 : 	if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4766 : 	{
; 4767 : 		MfdDisplay[3]->DecreaseBrightness();

	mov	ecx, 4
	imul	ecx, 3
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?DecreaseBrightness@MFDClass@@QAEXXZ	; MFDClass::DecreaseBrightness
$LN2@SimCBEOSB_:

; 4768 : 	}
; 4769 : }

	pop	ebp
	ret	0
?SimCBEOSB_GAINDOWN_F@@YAXKHPAX@Z ENDP			; SimCBEOSB_GAINDOWN_F
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_GAINDOWN_T@@YAXKHPAX@Z PROC			; SimCBEOSB_GAINDOWN_T

; 4756 : {

	push	ebp
	mov	ebp, esp

; 4757 : 	if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4758 : 	{
; 4759 : 		MfdDisplay[2]->DecreaseBrightness();

	mov	ecx, 4
	shl	ecx, 1
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?DecreaseBrightness@MFDClass@@QAEXXZ	; MFDClass::DecreaseBrightness
$LN2@SimCBEOSB_:

; 4760 : 	}
; 4761 : }

	pop	ebp
	ret	0
?SimCBEOSB_GAINDOWN_T@@YAXKHPAX@Z ENDP			; SimCBEOSB_GAINDOWN_T
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_GAINUP_F@@YAXKHPAX@Z PROC			; SimCBEOSB_GAINUP_F

; 4729 : {

	push	ebp
	mov	ebp, esp

; 4730 : 	if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4731 : 	{
; 4732 : 		MfdDisplay[3]->IncreaseBrightness();

	mov	ecx, 4
	imul	ecx, 3
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?IncreaseBrightness@MFDClass@@QAEXXZ	; MFDClass::IncreaseBrightness
$LN2@SimCBEOSB_:

; 4733 : 	}
; 4734 : }

	pop	ebp
	ret	0
?SimCBEOSB_GAINUP_F@@YAXKHPAX@Z ENDP			; SimCBEOSB_GAINUP_F
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_GAINUP_T@@YAXKHPAX@Z PROC			; SimCBEOSB_GAINUP_T

; 4721 : {

	push	ebp
	mov	ebp, esp

; 4722 : 	if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4723 : 	{
; 4724 : 		MfdDisplay[2]->IncreaseBrightness();

	mov	ecx, 4
	shl	ecx, 1
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?IncreaseBrightness@MFDClass@@QAEXXZ	; MFDClass::IncreaseBrightness
$LN2@SimCBEOSB_:

; 4725 : 	}
; 4726 : }

	pop	ebp
	ret	0
?SimCBEOSB_GAINUP_T@@YAXKHPAX@Z ENDP			; SimCBEOSB_GAINUP_T
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_20F@@YAXKHPAX@Z PROC				; SimCBEOSB_20F

; 4695 : void SimCBEOSB_20F(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4696 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { 

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4697 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(3, 20, 1);			

	push	1
	push	20					; 00000014H
	push	3
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4698 : 	   MfdDisplay[3]->ButtonPushed(19,3);

	push	3
	push	19					; 00000013H
	mov	ecx, 4
	imul	ecx, 3
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4699 : 	}
; 4700 : }

	pop	ebp
	ret	0
?SimCBEOSB_20F@@YAXKHPAX@Z ENDP				; SimCBEOSB_20F
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_19F@@YAXKHPAX@Z PROC				; SimCBEOSB_19F

; 4661 : void SimCBEOSB_19F(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4662 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { 

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4663 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(3, 19, 1);			

	push	1
	push	19					; 00000013H
	push	3
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4664 : 	   MfdDisplay[3]->ButtonPushed(18,3);

	push	3
	push	18					; 00000012H
	mov	ecx, 4
	imul	ecx, 3
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4665 : 	}
; 4666 : }

	pop	ebp
	ret	0
?SimCBEOSB_19F@@YAXKHPAX@Z ENDP				; SimCBEOSB_19F
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_18F@@YAXKHPAX@Z PROC				; SimCBEOSB_18F

; 4627 : void SimCBEOSB_18F(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4628 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) {

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4629 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(3, 18, 1);			

	push	1
	push	18					; 00000012H
	push	3
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4630 : 	   MfdDisplay[3]->ButtonPushed(17,3);

	push	3
	push	17					; 00000011H
	mov	ecx, 4
	imul	ecx, 3
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4631 : 	}
; 4632 : }

	pop	ebp
	ret	0
?SimCBEOSB_18F@@YAXKHPAX@Z ENDP				; SimCBEOSB_18F
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_17F@@YAXKHPAX@Z PROC				; SimCBEOSB_17F

; 4593 : void SimCBEOSB_17F(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4594 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { 

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4595 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(3, 17, 1);			

	push	1
	push	17					; 00000011H
	push	3
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4596 : 	   MfdDisplay[3]->ButtonPushed(16,3);

	push	3
	push	16					; 00000010H
	mov	ecx, 4
	imul	ecx, 3
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4597 : 	}
; 4598 : }

	pop	ebp
	ret	0
?SimCBEOSB_17F@@YAXKHPAX@Z ENDP				; SimCBEOSB_17F
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_16F@@YAXKHPAX@Z PROC				; SimCBEOSB_16F

; 4559 : void SimCBEOSB_16F(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4560 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { 

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4561 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(3, 16, 1);			

	push	1
	push	16					; 00000010H
	push	3
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4562 : 	   MfdDisplay[3]->ButtonPushed(15,3);

	push	3
	push	15					; 0000000fH
	mov	ecx, 4
	imul	ecx, 3
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4563 : 	}
; 4564 : }

	pop	ebp
	ret	0
?SimCBEOSB_16F@@YAXKHPAX@Z ENDP				; SimCBEOSB_16F
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_15F@@YAXKHPAX@Z PROC				; SimCBEOSB_15F

; 4525 : void SimCBEOSB_15F(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4526 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { 

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4527 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(3, 15, 1);			

	push	1
	push	15					; 0000000fH
	push	3
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4528 : 	   MfdDisplay[3]->ButtonPushed(14,3);

	push	3
	push	14					; 0000000eH
	mov	ecx, 4
	imul	ecx, 3
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4529 : 	}
; 4530 : }

	pop	ebp
	ret	0
?SimCBEOSB_15F@@YAXKHPAX@Z ENDP				; SimCBEOSB_15F
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_14F@@YAXKHPAX@Z PROC				; SimCBEOSB_14F

; 4492 : void SimCBEOSB_14F(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4493 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { 

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4494 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(3, 14, 1);			

	push	1
	push	14					; 0000000eH
	push	3
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4495 : 	   MfdDisplay[3]->ButtonPushed(13,3);

	push	3
	push	13					; 0000000dH
	mov	ecx, 4
	imul	ecx, 3
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4496 : 	}
; 4497 : }

	pop	ebp
	ret	0
?SimCBEOSB_14F@@YAXKHPAX@Z ENDP				; SimCBEOSB_14F
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_13F@@YAXKHPAX@Z PROC				; SimCBEOSB_13F

; 4459 : void SimCBEOSB_13F(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4460 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { 

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4461 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(3, 13, 1);			

	push	1
	push	13					; 0000000dH
	push	3
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4462 : 	   MfdDisplay[3]->ButtonPushed(12,3);

	push	3
	push	12					; 0000000cH
	mov	ecx, 4
	imul	ecx, 3
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4463 : 	}
; 4464 : }

	pop	ebp
	ret	0
?SimCBEOSB_13F@@YAXKHPAX@Z ENDP				; SimCBEOSB_13F
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_12F@@YAXKHPAX@Z PROC				; SimCBEOSB_12F

; 4426 : void SimCBEOSB_12F(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4427 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { 

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4428 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(3, 12, 1);			

	push	1
	push	12					; 0000000cH
	push	3
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4429 : 	   MfdDisplay[3]->ButtonPushed(11,3);

	push	3
	push	11					; 0000000bH
	mov	ecx, 4
	imul	ecx, 3
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4430 : 	}
; 4431 : }

	pop	ebp
	ret	0
?SimCBEOSB_12F@@YAXKHPAX@Z ENDP				; SimCBEOSB_12F
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_11F@@YAXKHPAX@Z PROC				; SimCBEOSB_11F

; 4392 : void SimCBEOSB_11F(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4393 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { 

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4394 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(3, 11, 1);			

	push	1
	push	11					; 0000000bH
	push	3
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4395 : 	   MfdDisplay[3]->ButtonPushed(10,3);

	push	3
	push	10					; 0000000aH
	mov	ecx, 4
	imul	ecx, 3
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4396 : 	}
; 4397 : }

	pop	ebp
	ret	0
?SimCBEOSB_11F@@YAXKHPAX@Z ENDP				; SimCBEOSB_11F
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_10F@@YAXKHPAX@Z PROC				; SimCBEOSB_10F

; 4357 : void SimCBEOSB_10F(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4358 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { 

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4359 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(3, 10, 1);			

	push	1
	push	10					; 0000000aH
	push	3
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4360 : 	   MfdDisplay[3]->ButtonPushed(9,3);

	push	3
	push	9
	mov	ecx, 4
	imul	ecx, 3
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4361 : 	}
; 4362 : }

	pop	ebp
	ret	0
?SimCBEOSB_10F@@YAXKHPAX@Z ENDP				; SimCBEOSB_10F
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_9F@@YAXKHPAX@Z PROC				; SimCBEOSB_9F

; 4322 : void SimCBEOSB_9F(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4323 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { 

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4324 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(3, 9, 1);			

	push	1
	push	9
	push	3
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4325 : 	   MfdDisplay[3]->ButtonPushed(8,3);

	push	3
	push	8
	mov	ecx, 4
	imul	ecx, 3
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4326 : 	}
; 4327 : }

	pop	ebp
	ret	0
?SimCBEOSB_9F@@YAXKHPAX@Z ENDP				; SimCBEOSB_9F
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_8F@@YAXKHPAX@Z PROC				; SimCBEOSB_8F

; 4287 : void SimCBEOSB_8F(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4288 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { 

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4289 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(3, 8, 1);			

	push	1
	push	8
	push	3
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4290 : 	   MfdDisplay[3]->ButtonPushed(7,3);

	push	3
	push	7
	mov	ecx, 4
	imul	ecx, 3
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4291 : 	}
; 4292 : }

	pop	ebp
	ret	0
?SimCBEOSB_8F@@YAXKHPAX@Z ENDP				; SimCBEOSB_8F
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_7F@@YAXKHPAX@Z PROC				; SimCBEOSB_7F

; 4253 : void SimCBEOSB_7F(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4254 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { 

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4255 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(3, 7, 1);		

	push	1
	push	7
	push	3
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4256 : 	   MfdDisplay[3]->ButtonPushed(6,3);

	push	3
	push	6
	mov	ecx, 4
	imul	ecx, 3
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4257 : 	}
; 4258 : }

	pop	ebp
	ret	0
?SimCBEOSB_7F@@YAXKHPAX@Z ENDP				; SimCBEOSB_7F
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_6F@@YAXKHPAX@Z PROC				; SimCBEOSB_6F

; 4219 : void SimCBEOSB_6F(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4220 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { 

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4221 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(3, 6, 1);			

	push	1
	push	6
	push	3
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4222 : 	   MfdDisplay[3]->ButtonPushed(5,3);

	push	3
	push	5
	mov	ecx, 4
	imul	ecx, 3
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4223 : 	}
; 4224 : }

	pop	ebp
	ret	0
?SimCBEOSB_6F@@YAXKHPAX@Z ENDP				; SimCBEOSB_6F
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_5F@@YAXKHPAX@Z PROC				; SimCBEOSB_5F

; 4184 : void SimCBEOSB_5F(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4185 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { 

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4186 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(3, 5, 1);			

	push	1
	push	5
	push	3
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4187 : 	   MfdDisplay[3]->ButtonPushed(4,3);

	push	3
	push	4
	mov	ecx, 4
	imul	ecx, 3
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4188 : 	}
; 4189 : }

	pop	ebp
	ret	0
?SimCBEOSB_5F@@YAXKHPAX@Z ENDP				; SimCBEOSB_5F
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_4F@@YAXKHPAX@Z PROC				; SimCBEOSB_4F

; 4149 : void SimCBEOSB_4F(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4150 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { 

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4151 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(3, 4, 1);			

	push	1
	push	4
	push	3
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4152 : 	   MfdDisplay[3]->ButtonPushed(3,3);

	push	3
	push	3
	mov	ecx, 4
	imul	ecx, 3
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4153 : 	}
; 4154 : }

	pop	ebp
	ret	0
?SimCBEOSB_4F@@YAXKHPAX@Z ENDP				; SimCBEOSB_4F
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_3F@@YAXKHPAX@Z PROC				; SimCBEOSB_3F

; 4115 : void SimCBEOSB_3F(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4116 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { 

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4117 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(3, 3, 1);			

	push	1
	push	3
	push	3
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4118 : 	   MfdDisplay[3]->ButtonPushed(2,3);

	push	3
	push	2
	mov	ecx, 4
	imul	ecx, 3
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4119 : 	}
; 4120 : }

	pop	ebp
	ret	0
?SimCBEOSB_3F@@YAXKHPAX@Z ENDP				; SimCBEOSB_3F
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_2F@@YAXKHPAX@Z PROC				; SimCBEOSB_2F

; 4080 : void SimCBEOSB_2F(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4081 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { 

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4082 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(3, 2, 1);			

	push	1
	push	2
	push	3
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4083 : 	   MfdDisplay[3]->ButtonPushed(1,3);

	push	3
	push	1
	mov	ecx, 4
	imul	ecx, 3
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4084 : 	}
; 4085 : }

	pop	ebp
	ret	0
?SimCBEOSB_2F@@YAXKHPAX@Z ENDP				; SimCBEOSB_2F
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_1F@@YAXKHPAX@Z PROC				; SimCBEOSB_1F

; 4046 : void SimCBEOSB_1F(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4047 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { 

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4048 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(3, 1, 1);			

	push	1
	push	1
	push	3
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4049 : 	   MfdDisplay[3]->ButtonPushed(0,3);

	push	3
	push	0
	mov	ecx, 4
	imul	ecx, 3
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4050 : 	}
; 4051 : }

	pop	ebp
	ret	0
?SimCBEOSB_1F@@YAXKHPAX@Z ENDP				; SimCBEOSB_1F
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_20T@@YAXKHPAX@Z PROC				; SimCBEOSB_20T

; 4688 : void SimCBEOSB_20T(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4689 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { 

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4690 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(2, 20, 1);

	push	1
	push	20					; 00000014H
	push	2
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4691 : 		MfdDisplay[2]->ButtonPushed(19,2);

	push	2
	push	19					; 00000013H
	mov	ecx, 4
	shl	ecx, 1
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4692 : 	}
; 4693 : }

	pop	ebp
	ret	0
?SimCBEOSB_20T@@YAXKHPAX@Z ENDP				; SimCBEOSB_20T
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_19T@@YAXKHPAX@Z PROC				; SimCBEOSB_19T

; 4654 : void SimCBEOSB_19T(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4655 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { 

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4656 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(2, 19, 1);

	push	1
	push	19					; 00000013H
	push	2
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4657 : 		MfdDisplay[2]->ButtonPushed(18,2);

	push	2
	push	18					; 00000012H
	mov	ecx, 4
	shl	ecx, 1
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4658 : 	}
; 4659 : }

	pop	ebp
	ret	0
?SimCBEOSB_19T@@YAXKHPAX@Z ENDP				; SimCBEOSB_19T
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_18T@@YAXKHPAX@Z PROC				; SimCBEOSB_18T

; 4620 : void SimCBEOSB_18T(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4621 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { 

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4622 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(2, 18, 1);

	push	1
	push	18					; 00000012H
	push	2
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4623 : 		MfdDisplay[2]->ButtonPushed(17,2);

	push	2
	push	17					; 00000011H
	mov	ecx, 4
	shl	ecx, 1
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4624 : 	}
; 4625 : }

	pop	ebp
	ret	0
?SimCBEOSB_18T@@YAXKHPAX@Z ENDP				; SimCBEOSB_18T
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_17T@@YAXKHPAX@Z PROC				; SimCBEOSB_17T

; 4586 : void SimCBEOSB_17T(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4587 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) {

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4588 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(2, 17, 1);

	push	1
	push	17					; 00000011H
	push	2
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4589 : 		MfdDisplay[2]->ButtonPushed(16,2);

	push	2
	push	16					; 00000010H
	mov	ecx, 4
	shl	ecx, 1
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4590 : 	}
; 4591 : }

	pop	ebp
	ret	0
?SimCBEOSB_17T@@YAXKHPAX@Z ENDP				; SimCBEOSB_17T
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_16T@@YAXKHPAX@Z PROC				; SimCBEOSB_16T

; 4552 : void SimCBEOSB_16T(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4553 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { 

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4554 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(2, 16, 1);

	push	1
	push	16					; 00000010H
	push	2
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4555 : 		MfdDisplay[2]->ButtonPushed(15,2);

	push	2
	push	15					; 0000000fH
	mov	ecx, 4
	shl	ecx, 1
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4556 : 	}
; 4557 : }

	pop	ebp
	ret	0
?SimCBEOSB_16T@@YAXKHPAX@Z ENDP				; SimCBEOSB_16T
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_15T@@YAXKHPAX@Z PROC				; SimCBEOSB_15T

; 4518 : void SimCBEOSB_15T(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4519 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { 

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4520 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(2, 15, 1);

	push	1
	push	15					; 0000000fH
	push	2
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4521 : 		MfdDisplay[2]->ButtonPushed(14,2);

	push	2
	push	14					; 0000000eH
	mov	ecx, 4
	shl	ecx, 1
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4522 : 	}
; 4523 : }

	pop	ebp
	ret	0
?SimCBEOSB_15T@@YAXKHPAX@Z ENDP				; SimCBEOSB_15T
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_14T@@YAXKHPAX@Z PROC				; SimCBEOSB_14T

; 4485 : void SimCBEOSB_14T(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4486 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { 

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4487 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(2, 14, 1);

	push	1
	push	14					; 0000000eH
	push	2
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4488 : 		MfdDisplay[2]->ButtonPushed(13,2);

	push	2
	push	13					; 0000000dH
	mov	ecx, 4
	shl	ecx, 1
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4489 : 	}
; 4490 : }

	pop	ebp
	ret	0
?SimCBEOSB_14T@@YAXKHPAX@Z ENDP				; SimCBEOSB_14T
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_13T@@YAXKHPAX@Z PROC				; SimCBEOSB_13T

; 4452 : void SimCBEOSB_13T(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4453 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { 

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4454 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(2, 13, 1);

	push	1
	push	13					; 0000000dH
	push	2
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4455 : 		MfdDisplay[2]->ButtonPushed(12,2);

	push	2
	push	12					; 0000000cH
	mov	ecx, 4
	shl	ecx, 1
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4456 : 	}
; 4457 : }

	pop	ebp
	ret	0
?SimCBEOSB_13T@@YAXKHPAX@Z ENDP				; SimCBEOSB_13T
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_12T@@YAXKHPAX@Z PROC				; SimCBEOSB_12T

; 4419 : void SimCBEOSB_12T(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4420 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { 

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4421 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(2, 12, 1);

	push	1
	push	12					; 0000000cH
	push	2
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4422 : 		MfdDisplay[2]->ButtonPushed(11,2);

	push	2
	push	11					; 0000000bH
	mov	ecx, 4
	shl	ecx, 1
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4423 : 	}
; 4424 : }

	pop	ebp
	ret	0
?SimCBEOSB_12T@@YAXKHPAX@Z ENDP				; SimCBEOSB_12T
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_11T@@YAXKHPAX@Z PROC				; SimCBEOSB_11T

; 4385 : void SimCBEOSB_11T(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4386 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { 

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4387 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(2, 11, 1);

	push	1
	push	11					; 0000000bH
	push	2
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4388 : 		MfdDisplay[2]->ButtonPushed(10,2);

	push	2
	push	10					; 0000000aH
	mov	ecx, 4
	shl	ecx, 1
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4389 : 	}
; 4390 : }

	pop	ebp
	ret	0
?SimCBEOSB_11T@@YAXKHPAX@Z ENDP				; SimCBEOSB_11T
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_10T@@YAXKHPAX@Z PROC				; SimCBEOSB_10T

; 4350 : void SimCBEOSB_10T(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4351 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { 

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4352 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(2, 10, 1);

	push	1
	push	10					; 0000000aH
	push	2
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4353 : 		MfdDisplay[2]->ButtonPushed(9,2);

	push	2
	push	9
	mov	ecx, 4
	shl	ecx, 1
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4354 : 	}
; 4355 : }

	pop	ebp
	ret	0
?SimCBEOSB_10T@@YAXKHPAX@Z ENDP				; SimCBEOSB_10T
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_9T@@YAXKHPAX@Z PROC				; SimCBEOSB_9T

; 4315 : void SimCBEOSB_9T(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4316 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) {

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4317 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(2, 9, 1);

	push	1
	push	9
	push	2
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4318 : 		MfdDisplay[2]->ButtonPushed(8,2);

	push	2
	push	8
	mov	ecx, 4
	shl	ecx, 1
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4319 : 	}
; 4320 : }

	pop	ebp
	ret	0
?SimCBEOSB_9T@@YAXKHPAX@Z ENDP				; SimCBEOSB_9T
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_8T@@YAXKHPAX@Z PROC				; SimCBEOSB_8T

; 4280 : void SimCBEOSB_8T(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4281 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { 

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4282 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(2, 8, 1);

	push	1
	push	8
	push	2
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4283 : 		MfdDisplay[2]->ButtonPushed(7,2);

	push	2
	push	7
	mov	ecx, 4
	shl	ecx, 1
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4284 : 	}
; 4285 : }

	pop	ebp
	ret	0
?SimCBEOSB_8T@@YAXKHPAX@Z ENDP				; SimCBEOSB_8T
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_7T@@YAXKHPAX@Z PROC				; SimCBEOSB_7T

; 4246 : void SimCBEOSB_7T(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4247 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { 

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4248 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(2, 7, 1);

	push	1
	push	7
	push	2
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4249 : 		MfdDisplay[2]->ButtonPushed(6,2);

	push	2
	push	6
	mov	ecx, 4
	shl	ecx, 1
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4250 : 	}
; 4251 : }

	pop	ebp
	ret	0
?SimCBEOSB_7T@@YAXKHPAX@Z ENDP				; SimCBEOSB_7T
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_6T@@YAXKHPAX@Z PROC				; SimCBEOSB_6T

; 4212 : void SimCBEOSB_6T(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4213 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { 

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4214 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(2, 6, 1);

	push	1
	push	6
	push	2
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4215 : 		MfdDisplay[2]->ButtonPushed(5,2);

	push	2
	push	5
	mov	ecx, 4
	shl	ecx, 1
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4216 : 	}
; 4217 : }

	pop	ebp
	ret	0
?SimCBEOSB_6T@@YAXKHPAX@Z ENDP				; SimCBEOSB_6T
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_5T@@YAXKHPAX@Z PROC				; SimCBEOSB_5T

; 4177 : void SimCBEOSB_5T(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4178 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) {

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4179 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(2, 5, 1);

	push	1
	push	5
	push	2
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4180 : 		MfdDisplay[2]->ButtonPushed(4,2);

	push	2
	push	4
	mov	ecx, 4
	shl	ecx, 1
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4181 : 	}
; 4182 : }

	pop	ebp
	ret	0
?SimCBEOSB_5T@@YAXKHPAX@Z ENDP				; SimCBEOSB_5T
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_4T@@YAXKHPAX@Z PROC				; SimCBEOSB_4T

; 4142 : void SimCBEOSB_4T(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4143 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { 

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4144 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(2, 4, 1);

	push	1
	push	4
	push	2
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4145 : 		MfdDisplay[2]->ButtonPushed(3,2);

	push	2
	push	3
	mov	ecx, 4
	shl	ecx, 1
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4146 : 	}
; 4147 : }

	pop	ebp
	ret	0
?SimCBEOSB_4T@@YAXKHPAX@Z ENDP				; SimCBEOSB_4T
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_3T@@YAXKHPAX@Z PROC				; SimCBEOSB_3T

; 4108 : void SimCBEOSB_3T(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4109 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { 

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4110 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(2, 3, 1);

	push	1
	push	3
	push	2
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4111 : 		MfdDisplay[2]->ButtonPushed(2,2);

	push	2
	push	2
	mov	ecx, 4
	shl	ecx, 1
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4112 : 	}
; 4113 : }

	pop	ebp
	ret	0
?SimCBEOSB_3T@@YAXKHPAX@Z ENDP				; SimCBEOSB_3T
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_2T@@YAXKHPAX@Z PROC				; SimCBEOSB_2T

; 4073 : void SimCBEOSB_2T(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4074 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { 

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4075 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(2, 2, 1);

	push	1
	push	2
	push	2
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4076 : 		MfdDisplay[2]->ButtonPushed(1,2);

	push	2
	push	1
	mov	ecx, 4
	shl	ecx, 1
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4077 : 	}
; 4078 : }

	pop	ebp
	ret	0
?SimCBEOSB_2T@@YAXKHPAX@Z ENDP				; SimCBEOSB_2T
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_1T@@YAXKHPAX@Z PROC				; SimCBEOSB_1T

; 4039 : void SimCBEOSB_1T(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4040 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { 

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4041 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(2, 1, 1);

	push	1
	push	1
	push	2
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4042 : 		MfdDisplay[2]->ButtonPushed(0,2);

	push	2
	push	0
	mov	ecx, 4
	shl	ecx, 1
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4043 : 	}
; 4044 : }

	pop	ebp
	ret	0
?SimCBEOSB_1T@@YAXKHPAX@Z ENDP				; SimCBEOSB_1T
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_20R@@YAXKHPAX@Z PROC				; SimCBEOSB_20R

; 4679 : void SimCBEOSB_20R(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4680 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4681 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(1, 20, 1);

	push	1
	push	20					; 00000014H
	push	1
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4682 : 		MfdDisplay[1]->ButtonPushed(19,1);

	push	1
	push	19					; 00000013H
	mov	ecx, 4
	shl	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4683 : 	}
; 4684 : }

	pop	ebp
	ret	0
?SimCBEOSB_20R@@YAXKHPAX@Z ENDP				; SimCBEOSB_20R
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_19R@@YAXKHPAX@Z PROC				; SimCBEOSB_19R

; 4645 : void SimCBEOSB_19R(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4646 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4647 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(1, 19, 1);

	push	1
	push	19					; 00000013H
	push	1
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4648 : 		MfdDisplay[1]->ButtonPushed(18,1);

	push	1
	push	18					; 00000012H
	mov	ecx, 4
	shl	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4649 : 	}
; 4650 : }

	pop	ebp
	ret	0
?SimCBEOSB_19R@@YAXKHPAX@Z ENDP				; SimCBEOSB_19R
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_18R@@YAXKHPAX@Z PROC				; SimCBEOSB_18R

; 4611 : void SimCBEOSB_18R(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4612 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4613 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(1, 18, 1);

	push	1
	push	18					; 00000012H
	push	1
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4614 : 		MfdDisplay[1]->ButtonPushed(17,1);

	push	1
	push	17					; 00000011H
	mov	ecx, 4
	shl	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4615 : 	}
; 4616 : }

	pop	ebp
	ret	0
?SimCBEOSB_18R@@YAXKHPAX@Z ENDP				; SimCBEOSB_18R
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_17R@@YAXKHPAX@Z PROC				; SimCBEOSB_17R

; 4577 : void SimCBEOSB_17R(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4578 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4579 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(1, 17, 1);

	push	1
	push	17					; 00000011H
	push	1
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4580 : 		MfdDisplay[1]->ButtonPushed(16,1);

	push	1
	push	16					; 00000010H
	mov	ecx, 4
	shl	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4581 : 	}
; 4582 : }

	pop	ebp
	ret	0
?SimCBEOSB_17R@@YAXKHPAX@Z ENDP				; SimCBEOSB_17R
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_16R@@YAXKHPAX@Z PROC				; SimCBEOSB_16R

; 4543 : void SimCBEOSB_16R(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4544 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4545 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(1, 16, 1);

	push	1
	push	16					; 00000010H
	push	1
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4546 : 		MfdDisplay[1]->ButtonPushed(15,1);

	push	1
	push	15					; 0000000fH
	mov	ecx, 4
	shl	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4547 : 	}
; 4548 : }

	pop	ebp
	ret	0
?SimCBEOSB_16R@@YAXKHPAX@Z ENDP				; SimCBEOSB_16R
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_15R@@YAXKHPAX@Z PROC				; SimCBEOSB_15R

; 4509 : void SimCBEOSB_15R(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4510 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4511 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(1, 15, 1);

	push	1
	push	15					; 0000000fH
	push	1
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4512 : 		MfdDisplay[1]->ButtonPushed(14,1);

	push	1
	push	14					; 0000000eH
	mov	ecx, 4
	shl	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4513 : 	}
; 4514 : }

	pop	ebp
	ret	0
?SimCBEOSB_15R@@YAXKHPAX@Z ENDP				; SimCBEOSB_15R
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_14R@@YAXKHPAX@Z PROC				; SimCBEOSB_14R

; 4476 : void SimCBEOSB_14R(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4477 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4478 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(1, 14, 1);

	push	1
	push	14					; 0000000eH
	push	1
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4479 : 		MfdDisplay[1]->ButtonPushed(13,1);

	push	1
	push	13					; 0000000dH
	mov	ecx, 4
	shl	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4480 : 	}
; 4481 : }

	pop	ebp
	ret	0
?SimCBEOSB_14R@@YAXKHPAX@Z ENDP				; SimCBEOSB_14R
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_13R@@YAXKHPAX@Z PROC				; SimCBEOSB_13R

; 4443 : void SimCBEOSB_13R(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4444 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4445 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(1, 13, 1);

	push	1
	push	13					; 0000000dH
	push	1
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4446 : 		MfdDisplay[1]->ButtonPushed(12,1);

	push	1
	push	12					; 0000000cH
	mov	ecx, 4
	shl	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4447 : 	}
; 4448 : }

	pop	ebp
	ret	0
?SimCBEOSB_13R@@YAXKHPAX@Z ENDP				; SimCBEOSB_13R
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_12R@@YAXKHPAX@Z PROC				; SimCBEOSB_12R

; 4410 : void SimCBEOSB_12R(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4411 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4412 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(1, 12, 1);

	push	1
	push	12					; 0000000cH
	push	1
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4413 : 		MfdDisplay[1]->ButtonPushed(11,1);

	push	1
	push	11					; 0000000bH
	mov	ecx, 4
	shl	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4414 : 	}
; 4415 : }

	pop	ebp
	ret	0
?SimCBEOSB_12R@@YAXKHPAX@Z ENDP				; SimCBEOSB_12R
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_11R@@YAXKHPAX@Z PROC				; SimCBEOSB_11R

; 4376 : void SimCBEOSB_11R(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4377 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4378 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(1, 11, 1);

	push	1
	push	11					; 0000000bH
	push	1
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4379 : 		MfdDisplay[1]->ButtonPushed(10,1);

	push	1
	push	10					; 0000000aH
	mov	ecx, 4
	shl	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4380 : 	}
; 4381 : }

	pop	ebp
	ret	0
?SimCBEOSB_11R@@YAXKHPAX@Z ENDP				; SimCBEOSB_11R
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_10R@@YAXKHPAX@Z PROC				; SimCBEOSB_10R

; 4341 : void SimCBEOSB_10R(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4342 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4343 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(1, 10, 1);

	push	1
	push	10					; 0000000aH
	push	1
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4344 : 		MfdDisplay[1]->ButtonPushed(9,1);

	push	1
	push	9
	mov	ecx, 4
	shl	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4345 : 	}
; 4346 : }

	pop	ebp
	ret	0
?SimCBEOSB_10R@@YAXKHPAX@Z ENDP				; SimCBEOSB_10R
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_9R@@YAXKHPAX@Z PROC				; SimCBEOSB_9R

; 4306 : void SimCBEOSB_9R(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4307 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4308 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(1, 9, 1);

	push	1
	push	9
	push	1
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4309 : 		MfdDisplay[1]->ButtonPushed(8,1);

	push	1
	push	8
	mov	ecx, 4
	shl	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4310 : 	}
; 4311 : }

	pop	ebp
	ret	0
?SimCBEOSB_9R@@YAXKHPAX@Z ENDP				; SimCBEOSB_9R
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_8R@@YAXKHPAX@Z PROC				; SimCBEOSB_8R

; 4271 : void SimCBEOSB_8R(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4272 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4273 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(1, 8, 1);

	push	1
	push	8
	push	1
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4274 : 		MfdDisplay[1]->ButtonPushed(7,1);

	push	1
	push	7
	mov	ecx, 4
	shl	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4275 : 	}
; 4276 : }

	pop	ebp
	ret	0
?SimCBEOSB_8R@@YAXKHPAX@Z ENDP				; SimCBEOSB_8R
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_7R@@YAXKHPAX@Z PROC				; SimCBEOSB_7R

; 4237 : void SimCBEOSB_7R(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4238 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4239 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(1, 7, 1);

	push	1
	push	7
	push	1
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4240 : 		MfdDisplay[1]->ButtonPushed(6,1);

	push	1
	push	6
	mov	ecx, 4
	shl	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4241 : 	}
; 4242 : }

	pop	ebp
	ret	0
?SimCBEOSB_7R@@YAXKHPAX@Z ENDP				; SimCBEOSB_7R
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_6R@@YAXKHPAX@Z PROC				; SimCBEOSB_6R

; 4203 : void SimCBEOSB_6R(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4204 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4205 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(1, 6, 1);

	push	1
	push	6
	push	1
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4206 : 		MfdDisplay[1]->ButtonPushed(5,1);

	push	1
	push	5
	mov	ecx, 4
	shl	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4207 : 	}
; 4208 : }

	pop	ebp
	ret	0
?SimCBEOSB_6R@@YAXKHPAX@Z ENDP				; SimCBEOSB_6R
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_5R@@YAXKHPAX@Z PROC				; SimCBEOSB_5R

; 4168 : void SimCBEOSB_5R(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4169 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4170 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(1, 5, 1);

	push	1
	push	5
	push	1
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4171 : 		MfdDisplay[1]->ButtonPushed(4,1);

	push	1
	push	4
	mov	ecx, 4
	shl	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4172 : 	}
; 4173 : }

	pop	ebp
	ret	0
?SimCBEOSB_5R@@YAXKHPAX@Z ENDP				; SimCBEOSB_5R
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_4R@@YAXKHPAX@Z PROC				; SimCBEOSB_4R

; 4133 : void SimCBEOSB_4R(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4134 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4135 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(1, 4, 1);

	push	1
	push	4
	push	1
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4136 : 		MfdDisplay[1]->ButtonPushed(3,1);

	push	1
	push	3
	mov	ecx, 4
	shl	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4137 : 	}
; 4138 : }

	pop	ebp
	ret	0
?SimCBEOSB_4R@@YAXKHPAX@Z ENDP				; SimCBEOSB_4R
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_3R@@YAXKHPAX@Z PROC				; SimCBEOSB_3R

; 4099 : void SimCBEOSB_3R(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4100 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4101 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(1, 3, 1);

	push	1
	push	3
	push	1
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4102 : 		MfdDisplay[1]->ButtonPushed(2,1);

	push	1
	push	2
	mov	ecx, 4
	shl	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4103 : 	}
; 4104 : }

	pop	ebp
	ret	0
?SimCBEOSB_3R@@YAXKHPAX@Z ENDP				; SimCBEOSB_3R
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_2R@@YAXKHPAX@Z PROC				; SimCBEOSB_2R

; 4064 : void SimCBEOSB_2R(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4065 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4066 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(1, 2, 1);

	push	1
	push	2
	push	1
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4067 : 		MfdDisplay[1]->ButtonPushed(1,1);

	push	1
	push	1
	mov	ecx, 4
	shl	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4068 : 	}
; 4069 : }

	pop	ebp
	ret	0
?SimCBEOSB_2R@@YAXKHPAX@Z ENDP				; SimCBEOSB_2R
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_1R@@YAXKHPAX@Z PROC				; SimCBEOSB_1R

; 4030 : void SimCBEOSB_1R(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4031 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4032 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(1, 1, 1);			//Wombat778 4-12-04 changed from 0,1,1 to 1,1,1.  This must have been a bug.

	push	1
	push	1
	push	1
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4033 : 	   MfdDisplay[1]->ButtonPushed(0,1);

	push	1
	push	0
	mov	ecx, 4
	shl	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4034 : 	}
; 4035 : }

	pop	ebp
	ret	0
?SimCBEOSB_1R@@YAXKHPAX@Z ENDP				; SimCBEOSB_1R
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_20L@@YAXKHPAX@Z PROC				; SimCBEOSB_20L

; 4672 : void SimCBEOSB_20L(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4673 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4674 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(0, 20, 1);

	push	1
	push	20					; 00000014H
	push	0
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4675 : 		MfdDisplay[0]->ButtonPushed(19,0);

	push	0
	push	19					; 00000013H
	mov	ecx, 4
	imul	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4676 : 	}
; 4677 : }

	pop	ebp
	ret	0
?SimCBEOSB_20L@@YAXKHPAX@Z ENDP				; SimCBEOSB_20L
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_19L@@YAXKHPAX@Z PROC				; SimCBEOSB_19L

; 4638 : void SimCBEOSB_19L(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4639 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4640 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(0, 19, 1);

	push	1
	push	19					; 00000013H
	push	0
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4641 : 		MfdDisplay[0]->ButtonPushed(18,0);

	push	0
	push	18					; 00000012H
	mov	ecx, 4
	imul	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4642 : 	}
; 4643 : }

	pop	ebp
	ret	0
?SimCBEOSB_19L@@YAXKHPAX@Z ENDP				; SimCBEOSB_19L
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_18L@@YAXKHPAX@Z PROC				; SimCBEOSB_18L

; 4604 : void SimCBEOSB_18L(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4605 : 	if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4606 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(0, 18, 1);

	push	1
	push	18					; 00000012H
	push	0
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4607 : 		MfdDisplay[0]->ButtonPushed(17,0);

	push	0
	push	17					; 00000011H
	mov	ecx, 4
	imul	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4608 : 	}
; 4609 : }

	pop	ebp
	ret	0
?SimCBEOSB_18L@@YAXKHPAX@Z ENDP				; SimCBEOSB_18L
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_17L@@YAXKHPAX@Z PROC				; SimCBEOSB_17L

; 4570 : void SimCBEOSB_17L(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4571 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4572 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(0, 17, 1);

	push	1
	push	17					; 00000011H
	push	0
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4573 : 		MfdDisplay[0]->ButtonPushed(16,0);

	push	0
	push	16					; 00000010H
	mov	ecx, 4
	imul	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4574 : 	}
; 4575 : }

	pop	ebp
	ret	0
?SimCBEOSB_17L@@YAXKHPAX@Z ENDP				; SimCBEOSB_17L
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_16L@@YAXKHPAX@Z PROC				; SimCBEOSB_16L

; 4536 : void SimCBEOSB_16L(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4537 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4538 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(0, 16, 1);

	push	1
	push	16					; 00000010H
	push	0
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4539 : 		MfdDisplay[0]->ButtonPushed(15,0);

	push	0
	push	15					; 0000000fH
	mov	ecx, 4
	imul	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4540 : 	}
; 4541 : }

	pop	ebp
	ret	0
?SimCBEOSB_16L@@YAXKHPAX@Z ENDP				; SimCBEOSB_16L
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_15L@@YAXKHPAX@Z PROC				; SimCBEOSB_15L

; 4502 : void SimCBEOSB_15L(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4503 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4504 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(0, 15, 1);

	push	1
	push	15					; 0000000fH
	push	0
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4505 : 		MfdDisplay[0]->ButtonPushed(14,0);

	push	0
	push	14					; 0000000eH
	mov	ecx, 4
	imul	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4506 : 	}
; 4507 : }

	pop	ebp
	ret	0
?SimCBEOSB_15L@@YAXKHPAX@Z ENDP				; SimCBEOSB_15L
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_14L@@YAXKHPAX@Z PROC				; SimCBEOSB_14L

; 4469 : void SimCBEOSB_14L(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4470 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4471 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(0, 14, 1);

	push	1
	push	14					; 0000000eH
	push	0
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4472 : 		MfdDisplay[0]->ButtonPushed(13,0);

	push	0
	push	13					; 0000000dH
	mov	ecx, 4
	imul	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4473 : 	}
; 4474 : }

	pop	ebp
	ret	0
?SimCBEOSB_14L@@YAXKHPAX@Z ENDP				; SimCBEOSB_14L
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_13L@@YAXKHPAX@Z PROC				; SimCBEOSB_13L

; 4436 : void SimCBEOSB_13L(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4437 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4438 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(0, 13, 1);

	push	1
	push	13					; 0000000dH
	push	0
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4439 : 		MfdDisplay[0]->ButtonPushed(12,0);

	push	0
	push	12					; 0000000cH
	mov	ecx, 4
	imul	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4440 : 	}
; 4441 : }

	pop	ebp
	ret	0
?SimCBEOSB_13L@@YAXKHPAX@Z ENDP				; SimCBEOSB_13L
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_12L@@YAXKHPAX@Z PROC				; SimCBEOSB_12L

; 4403 : void SimCBEOSB_12L(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4404 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4405 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(0, 12, 1);

	push	1
	push	12					; 0000000cH
	push	0
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4406 : 		MfdDisplay[0]->ButtonPushed(11,0);

	push	0
	push	11					; 0000000bH
	mov	ecx, 4
	imul	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4407 : 	}
; 4408 : }

	pop	ebp
	ret	0
?SimCBEOSB_12L@@YAXKHPAX@Z ENDP				; SimCBEOSB_12L
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_11L@@YAXKHPAX@Z PROC				; SimCBEOSB_11L

; 4369 : void SimCBEOSB_11L(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4370 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4371 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(0, 11, 1);

	push	1
	push	11					; 0000000bH
	push	0
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4372 : 		MfdDisplay[0]->ButtonPushed(10,0);

	push	0
	push	10					; 0000000aH
	mov	ecx, 4
	imul	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4373 : 	}
; 4374 : }

	pop	ebp
	ret	0
?SimCBEOSB_11L@@YAXKHPAX@Z ENDP				; SimCBEOSB_11L
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_10L@@YAXKHPAX@Z PROC				; SimCBEOSB_10L

; 4333 : void SimCBEOSB_10L(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4334 : 	//MI
; 4335 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4336 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(0, 10, 1);

	push	1
	push	10					; 0000000aH
	push	0
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4337 : 		MfdDisplay[0]->ButtonPushed(9,0);

	push	0
	push	9
	mov	ecx, 4
	imul	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4338 : 	}
; 4339 : }

	pop	ebp
	ret	0
?SimCBEOSB_10L@@YAXKHPAX@Z ENDP				; SimCBEOSB_10L
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_9L@@YAXKHPAX@Z PROC				; SimCBEOSB_9L

; 4299 : void SimCBEOSB_9L(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4300 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4301 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(0, 9, 1);

	push	1
	push	9
	push	0
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4302 : 		MfdDisplay[0]->ButtonPushed(8,0);

	push	0
	push	8
	mov	ecx, 4
	imul	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4303 : 	}
; 4304 : }

	pop	ebp
	ret	0
?SimCBEOSB_9L@@YAXKHPAX@Z ENDP				; SimCBEOSB_9L
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_8L@@YAXKHPAX@Z PROC				; SimCBEOSB_8L

; 4264 : void SimCBEOSB_8L(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4265 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4266 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(0, 8, 1);

	push	1
	push	8
	push	0
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4267 : 		MfdDisplay[0]->ButtonPushed(7,0);

	push	0
	push	7
	mov	ecx, 4
	imul	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4268 : 	}
; 4269 : }

	pop	ebp
	ret	0
?SimCBEOSB_8L@@YAXKHPAX@Z ENDP				; SimCBEOSB_8L
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_7L@@YAXKHPAX@Z PROC				; SimCBEOSB_7L

; 4230 : void SimCBEOSB_7L(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4231 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4232 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(0, 7, 1);

	push	1
	push	7
	push	0
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4233 : 		MfdDisplay[0]->ButtonPushed(6,0);

	push	0
	push	6
	mov	ecx, 4
	imul	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4234 : 	}
; 4235 : }

	pop	ebp
	ret	0
?SimCBEOSB_7L@@YAXKHPAX@Z ENDP				; SimCBEOSB_7L
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_6L@@YAXKHPAX@Z PROC				; SimCBEOSB_6L

; 4196 : void SimCBEOSB_6L(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4197 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4198 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(0, 6, 1);

	push	1
	push	6
	push	0
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4199 : 		MfdDisplay[0]->ButtonPushed(5,0);

	push	0
	push	5
	mov	ecx, 4
	imul	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4200 : 	}
; 4201 : }

	pop	ebp
	ret	0
?SimCBEOSB_6L@@YAXKHPAX@Z ENDP				; SimCBEOSB_6L
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_5L@@YAXKHPAX@Z PROC				; SimCBEOSB_5L

; 4161 : void SimCBEOSB_5L(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4162 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4163 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(0, 5, 1);

	push	1
	push	5
	push	0
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4164 : 	   MfdDisplay[0]->ButtonPushed(4,0);

	push	0
	push	4
	mov	ecx, 4
	imul	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4165 : 	}
; 4166 : }

	pop	ebp
	ret	0
?SimCBEOSB_5L@@YAXKHPAX@Z ENDP				; SimCBEOSB_5L
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_4L@@YAXKHPAX@Z PROC				; SimCBEOSB_4L

; 4126 : void SimCBEOSB_4L(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4127 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4128 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(0, 4, 1);

	push	1
	push	4
	push	0
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4129 : 		MfdDisplay[0]->ButtonPushed(3,0);

	push	0
	push	3
	mov	ecx, 4
	imul	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4130 : 	}
; 4131 : }

	pop	ebp
	ret	0
?SimCBEOSB_4L@@YAXKHPAX@Z ENDP				; SimCBEOSB_4L
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_3L@@YAXKHPAX@Z PROC				; SimCBEOSB_3L

; 4092 : void SimCBEOSB_3L(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4093 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4094 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(0, 3, 1);

	push	1
	push	3
	push	0
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4095 : 		MfdDisplay[0]->ButtonPushed(2,0);

	push	0
	push	2
	mov	ecx, 4
	imul	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4096 : 	}
; 4097 : }

	pop	ebp
	ret	0
?SimCBEOSB_3L@@YAXKHPAX@Z ENDP				; SimCBEOSB_3L
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_2L@@YAXKHPAX@Z PROC				; SimCBEOSB_2L

; 4057 : void SimCBEOSB_2L(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4058 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4059 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(0, 2, 1);

	push	1
	push	2
	push	0
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4060 : 		MfdDisplay[0]->ButtonPushed(1,0);

	push	0
	push	1
	mov	ecx, 4
	imul	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4061 : 	}
; 4062 : }

	pop	ebp
	ret	0
?SimCBEOSB_2L@@YAXKHPAX@Z ENDP				; SimCBEOSB_2L
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCBEOSB_1L@@YAXKHPAX@Z PROC				; SimCBEOSB_1L

; 4023 : void SimCBEOSB_1L(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp

; 4024 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected...

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimCBEOSB_
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimCBEOSB_

; 4025 : 		OTWDriver.pCockpitManager->mMiscStates.SetMFDButtonState(0, 1, 1);

	push	1
	push	1
	push	0
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetMFDButtonState@CPMisc@@QAEXHHH@Z	; CPMisc::SetMFDButtonState

; 4026 : 		MfdDisplay[0]->ButtonPushed(0,0);

	push	0
	push	0
	mov	ecx, 4
	imul	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?ButtonPushed@MFDClass@@QAEXHH@Z	; MFDClass::ButtonPushed
$LN2@SimCBEOSB_:

; 4027 : 	}
; 4028 : }

	pop	ebp
	ret	0
?SimCBEOSB_1L@@YAXKHPAX@Z ENDP				; SimCBEOSB_1L
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv150 = -24						; size = 4
tv149 = -20						; size = 4
tv142 = -16						; size = 4
tv131 = -12						; size = 4
tv130 = -8						; size = 4
tv91 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?IncreaseAlow@@YAXKHPAX@Z PROC				; IncreaseAlow

; 5798 : void IncreaseAlow(unsigned long, int state , void*) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 5799 : 	//MI
; 5800 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN1@IncreaseAl
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN1@IncreaseAl
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN1@IncreaseAl

; 5801 : 	{
; 5802 : 		if(TheHud && TheHud->lowAltWarning >= 1000.0F) {

	cmp	DWORD PTR ?TheHud@@3PAVHudClass@@A, 0	; TheHud
	je	$LN3@IncreaseAl
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR [ecx+4960]
	comiss	xmm0, DWORD PTR __real@447a0000
	jb	$LN3@IncreaseAl

; 5803 : 			TheHud->lowAltWarning += 1000.0F;

	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR [edx+4960]
	addss	xmm0, DWORD PTR __real@447a0000
	mov	eax, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	DWORD PTR [eax+4960], xmm0

; 5804 : 			TheHud->lowAltWarning = min(max(0.0F, TheHud->lowAltWarning), 99999.0F);

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [ecx+4960]
	jbe	SHORT $LN7@IncreaseAl
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv91[ebp], xmm0
	jmp	SHORT $LN8@IncreaseAl
$LN7@IncreaseAl:
	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR [edx+4960]
	movss	DWORD PTR tv91[ebp], xmm0
$LN8@IncreaseAl:
	movss	xmm0, DWORD PTR __real@47c34f80
	comiss	xmm0, DWORD PTR tv91[ebp]
	jbe	SHORT $LN11@IncreaseAl
	mov	eax, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [eax+4960]
	jbe	SHORT $LN9@IncreaseAl
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv130[ebp], xmm0
	jmp	SHORT $LN10@IncreaseAl
$LN9@IncreaseAl:
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR [ecx+4960]
	movss	DWORD PTR tv130[ebp], xmm0
$LN10@IncreaseAl:
	movss	xmm0, DWORD PTR tv130[ebp]
	movss	DWORD PTR tv131[ebp], xmm0
	jmp	SHORT $LN12@IncreaseAl
$LN11@IncreaseAl:
	movss	xmm0, DWORD PTR __real@47c34f80
	movss	DWORD PTR tv131[ebp], xmm0
$LN12@IncreaseAl:
	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR tv131[ebp]
	movss	DWORD PTR [edx+4960], xmm0
	jmp	$LN1@IncreaseAl
$LN3@IncreaseAl:

; 5805 : 		}
; 5806 : 		else if(TheHud){

	cmp	DWORD PTR ?TheHud@@3PAVHudClass@@A, 0	; TheHud
	je	$LN1@IncreaseAl

; 5807 : 			TheHud->lowAltWarning += 100.0F;

	mov	eax, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR [eax+4960]
	addss	xmm0, DWORD PTR __real@42c80000
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	DWORD PTR [ecx+4960], xmm0

; 5808 : 			TheHud->lowAltWarning = min(max(0.0F, TheHud->lowAltWarning), 99999.0F);

	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [edx+4960]
	jbe	SHORT $LN13@IncreaseAl
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv142[ebp], xmm0
	jmp	SHORT $LN14@IncreaseAl
$LN13@IncreaseAl:
	mov	eax, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR [eax+4960]
	movss	DWORD PTR tv142[ebp], xmm0
$LN14@IncreaseAl:
	movss	xmm0, DWORD PTR __real@47c34f80
	comiss	xmm0, DWORD PTR tv142[ebp]
	jbe	SHORT $LN17@IncreaseAl
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [ecx+4960]
	jbe	SHORT $LN15@IncreaseAl
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv149[ebp], xmm0
	jmp	SHORT $LN16@IncreaseAl
$LN15@IncreaseAl:
	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR [edx+4960]
	movss	DWORD PTR tv149[ebp], xmm0
$LN16@IncreaseAl:
	movss	xmm0, DWORD PTR tv149[ebp]
	movss	DWORD PTR tv150[ebp], xmm0
	jmp	SHORT $LN18@IncreaseAl
$LN17@IncreaseAl:
	movss	xmm0, DWORD PTR __real@47c34f80
	movss	DWORD PTR tv150[ebp], xmm0
$LN18@IncreaseAl:
	mov	eax, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR tv150[ebp]
	movss	DWORD PTR [eax+4960], xmm0
$LN1@IncreaseAl:

; 5809 : 		}
; 5810 : 	}
; 5811 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IncreaseAlow@@YAXKHPAX@Z ENDP				; IncreaseAlow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv150 = -24						; size = 4
tv149 = -20						; size = 4
tv142 = -16						; size = 4
tv131 = -12						; size = 4
tv130 = -8						; size = 4
tv91 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?DecreaseAlow@@YAXKHPAX@Z PROC				; DecreaseAlow

; 5814 : void DecreaseAlow(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 5815 : 	//MI
; 5816 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN1@DecreaseAl
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN1@DecreaseAl
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN1@DecreaseAl

; 5817 : 	{
; 5818 : 		if(TheHud && TheHud->lowAltWarning > 1000.0F) {

	cmp	DWORD PTR ?TheHud@@3PAVHudClass@@A, 0	; TheHud
	je	$LN3@DecreaseAl
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR [ecx+4960]
	comiss	xmm0, DWORD PTR __real@447a0000
	jbe	$LN3@DecreaseAl

; 5819 : 			TheHud->lowAltWarning -= 1000.0F;

	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR [edx+4960]
	subss	xmm0, DWORD PTR __real@447a0000
	mov	eax, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	DWORD PTR [eax+4960], xmm0

; 5820 : 			TheHud->lowAltWarning = min(max(0.0F, TheHud->lowAltWarning), 99999.0F);

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [ecx+4960]
	jbe	SHORT $LN7@DecreaseAl
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv91[ebp], xmm0
	jmp	SHORT $LN8@DecreaseAl
$LN7@DecreaseAl:
	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR [edx+4960]
	movss	DWORD PTR tv91[ebp], xmm0
$LN8@DecreaseAl:
	movss	xmm0, DWORD PTR __real@47c34f80
	comiss	xmm0, DWORD PTR tv91[ebp]
	jbe	SHORT $LN11@DecreaseAl
	mov	eax, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [eax+4960]
	jbe	SHORT $LN9@DecreaseAl
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv130[ebp], xmm0
	jmp	SHORT $LN10@DecreaseAl
$LN9@DecreaseAl:
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR [ecx+4960]
	movss	DWORD PTR tv130[ebp], xmm0
$LN10@DecreaseAl:
	movss	xmm0, DWORD PTR tv130[ebp]
	movss	DWORD PTR tv131[ebp], xmm0
	jmp	SHORT $LN12@DecreaseAl
$LN11@DecreaseAl:
	movss	xmm0, DWORD PTR __real@47c34f80
	movss	DWORD PTR tv131[ebp], xmm0
$LN12@DecreaseAl:
	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR tv131[ebp]
	movss	DWORD PTR [edx+4960], xmm0
	jmp	$LN1@DecreaseAl
$LN3@DecreaseAl:

; 5821 : 		}
; 5822 : 		else if(TheHud){

	cmp	DWORD PTR ?TheHud@@3PAVHudClass@@A, 0	; TheHud
	je	$LN1@DecreaseAl

; 5823 : 			TheHud->lowAltWarning -= 100.0F;

	mov	eax, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR [eax+4960]
	subss	xmm0, DWORD PTR __real@42c80000
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	DWORD PTR [ecx+4960], xmm0

; 5824 : 			TheHud->lowAltWarning = min(max(0.0F, TheHud->lowAltWarning), 99999.0F);

	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [edx+4960]
	jbe	SHORT $LN13@DecreaseAl
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv142[ebp], xmm0
	jmp	SHORT $LN14@DecreaseAl
$LN13@DecreaseAl:
	mov	eax, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR [eax+4960]
	movss	DWORD PTR tv142[ebp], xmm0
$LN14@DecreaseAl:
	movss	xmm0, DWORD PTR __real@47c34f80
	comiss	xmm0, DWORD PTR tv142[ebp]
	jbe	SHORT $LN17@DecreaseAl
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [ecx+4960]
	jbe	SHORT $LN15@DecreaseAl
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv149[ebp], xmm0
	jmp	SHORT $LN16@DecreaseAl
$LN15@DecreaseAl:
	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR [edx+4960]
	movss	DWORD PTR tv149[ebp], xmm0
$LN16@DecreaseAl:
	movss	xmm0, DWORD PTR tv149[ebp]
	movss	DWORD PTR tv150[ebp], xmm0
	jmp	SHORT $LN18@DecreaseAl
$LN17@DecreaseAl:
	movss	xmm0, DWORD PTR __real@47c34f80
	movss	DWORD PTR tv150[ebp], xmm0
$LN18@DecreaseAl:
	mov	eax, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR tv150[ebp]
	movss	DWORD PTR [eax+4960], xmm0
$LN1@DecreaseAl:

; 5825 : 		}
; 5826 : 	}
; 5827 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DecreaseAlow@@YAXKHPAX@Z ENDP				; DecreaseAlow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimHSIIlsNav@@YAXKHPAX@Z PROC				; SimHSIIlsNav

; 4001 : {

	push	ebp
	mov	ebp, esp

; 4002 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN4@SimHSIIlsN

; 4003 : 		return;

	jmp	$LN5@SimHSIIlsN
$LN4@SimHSIIlsN:

; 4004 : 
; 4005 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)) {

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN5@SimHSIIlsN
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN5@SimHSIIlsN
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	$LN5@SimHSIIlsN

; 4006 : 		if(g_bRealisticAvionics && g_bINS && SimDriver.GetPlayerAircraft())

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	SHORT $LN2@SimHSIIlsN
	movzx	eax, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	eax, eax
	je	SHORT $LN2@SimHSIIlsN
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimHSIIlsN

; 4007 : 		{
; 4008 : 			SimDriver.GetPlayerAircraft()->LOCValid = TRUE;	//Flag not visible

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	BYTE PTR [eax+837], 1

; 4009 : 			SimDriver.GetPlayerAircraft()->GSValid = TRUE;	//Flag not visible

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	BYTE PTR [eax+836], 1
$LN2@SimHSIIlsN:

; 4010 : 		}
; 4011 : 		gNavigationSys->SetInstrumentMode(NavigationSystem::ILS_NAV);

	push	1
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?SetInstrumentMode@NavigationSystem@@QAEXW4Instrument_Mode@1@@Z ; NavigationSystem::SetInstrumentMode

; 4012 : 		SimDriver.GetPlayerAircraft()->FCC->SetMasterMode(FireControlComputer::ILS);

	push	3
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?SetMasterMode@FireControlComputer@@QAEXW4FCCMasterMode@1@@Z ; FireControlComputer::SetMasterMode

; 4013 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN5@SimHSIIlsN

; 4014 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HSI_MODE, 4);

	push	4
	push	156					; 0000009cH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN5@SimHSIIlsN:

; 4015 : 	}
; 4016 : }

	pop	ebp
	ret	0
?SimHSIIlsNav@@YAXKHPAX@Z ENDP				; SimHSIIlsNav
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimHSINav@@YAXKHPAX@Z PROC				; SimHSINav

; 3983 : {

	push	ebp
	mov	ebp, esp

; 3984 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN4@SimHSINav

; 3985 : 		return;

	jmp	$LN5@SimHSINav
$LN4@SimHSINav:

; 3986 : 
; 3987 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)) {

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN5@SimHSINav
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN5@SimHSINav
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	$LN5@SimHSINav

; 3988 : 		if(g_bRealisticAvionics && g_bINS && SimDriver.GetPlayerAircraft())

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	SHORT $LN2@SimHSINav
	movzx	eax, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	eax, eax
	je	SHORT $LN2@SimHSINav
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimHSINav

; 3989 : 		{
; 3990 : 			SimDriver.GetPlayerAircraft()->LOCValid = TRUE;	//Flag not visible

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	BYTE PTR [eax+837], 1

; 3991 : 			SimDriver.GetPlayerAircraft()->GSValid = TRUE;	//Flag not visible

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	BYTE PTR [eax+836], 1
$LN2@SimHSINav:

; 3992 : 		}
; 3993 : 		gNavigationSys->SetInstrumentMode(NavigationSystem::NAV);

	push	0
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?SetInstrumentMode@NavigationSystem@@QAEXW4Instrument_Mode@1@@Z ; NavigationSystem::SetInstrumentMode

; 3994 : 		SimDriver.GetPlayerAircraft()->FCC->SetMasterMode(FireControlComputer::Nav);

	push	4
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?SetMasterMode@FireControlComputer@@QAEXW4FCCMasterMode@1@@Z ; FireControlComputer::SetMasterMode

; 3995 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN5@SimHSINav

; 3996 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HSI_MODE, 4);

	push	4
	push	156					; 0000009cH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN5@SimHSINav:

; 3997 : 	}
; 3998 : }

	pop	ebp
	ret	0
?SimHSINav@@YAXKHPAX@Z ENDP				; SimHSINav
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimHSITcn@@YAXKHPAX@Z PROC				; SimHSITcn

; 3965 : {

	push	ebp
	mov	ebp, esp

; 3966 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN4@SimHSITcn

; 3967 : 		return;

	jmp	$LN5@SimHSITcn
$LN4@SimHSITcn:

; 3968 : 
; 3969 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)) {

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN5@SimHSITcn
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN5@SimHSITcn
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	$LN5@SimHSITcn

; 3970 : 		if(g_bRealisticAvionics && g_bINS && SimDriver.GetPlayerAircraft())

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	SHORT $LN2@SimHSITcn
	movzx	eax, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	eax, eax
	je	SHORT $LN2@SimHSITcn
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimHSITcn

; 3971 : 		{
; 3972 : 			SimDriver.GetPlayerAircraft()->LOCValid = TRUE;	//Flag not visible

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	BYTE PTR [eax+837], 1

; 3973 : 			SimDriver.GetPlayerAircraft()->GSValid = TRUE;	//Flag not visible

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	BYTE PTR [eax+836], 1
$LN2@SimHSITcn:

; 3974 : 		}
; 3975 : 		gNavigationSys->SetInstrumentMode(NavigationSystem::TACAN);

	push	3
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?SetInstrumentMode@NavigationSystem@@QAEXW4Instrument_Mode@1@@Z ; NavigationSystem::SetInstrumentMode

; 3976 : 		SimDriver.GetPlayerAircraft()->FCC->SetMasterMode(FireControlComputer::Nav);

	push	4
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?SetMasterMode@FireControlComputer@@QAEXW4FCCMasterMode@1@@Z ; FireControlComputer::SetMasterMode

; 3977 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN5@SimHSITcn

; 3978 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HSI_MODE, 2);

	push	2
	push	156					; 0000009cH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN5@SimHSITcn:

; 3979 : 	}
; 3980 : }

	pop	ebp
	ret	0
?SimHSITcn@@YAXKHPAX@Z ENDP				; SimHSITcn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimHSIIlsTcn@@YAXKHPAX@Z PROC				; SimHSIIlsTcn

; 3947 : {

	push	ebp
	mov	ebp, esp

; 3948 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN4@SimHSIIlsT

; 3949 : 		return;

	jmp	$LN5@SimHSIIlsT
$LN4@SimHSIIlsT:

; 3950 : 
; 3951 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)) {

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN5@SimHSIIlsT
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN5@SimHSIIlsT
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	$LN5@SimHSIIlsT

; 3952 : 		if(g_bRealisticAvionics && g_bINS && SimDriver.GetPlayerAircraft())

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	SHORT $LN2@SimHSIIlsT
	movzx	eax, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	eax, eax
	je	SHORT $LN2@SimHSIIlsT
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimHSIIlsT

; 3953 : 		{
; 3954 : 			SimDriver.GetPlayerAircraft()->LOCValid = TRUE;	//Flag not visible

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	BYTE PTR [eax+837], 1

; 3955 : 			SimDriver.GetPlayerAircraft()->GSValid = TRUE;	//Flag not visible

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	BYTE PTR [eax+836], 1
$LN2@SimHSIIlsT:

; 3956 : 		}
; 3957 : 		gNavigationSys->SetInstrumentMode(NavigationSystem::ILS_TACAN);

	push	2
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?SetInstrumentMode@NavigationSystem@@QAEXW4Instrument_Mode@1@@Z ; NavigationSystem::SetInstrumentMode

; 3958 : 		SimDriver.GetPlayerAircraft()->FCC->SetMasterMode(FireControlComputer::ILS);

	push	3
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?SetMasterMode@FireControlComputer@@QAEXW4FCCMasterMode@1@@Z ; FireControlComputer::SetMasterMode

; 3959 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN5@SimHSIIlsT

; 3960 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HSI_MODE, 1);

	push	1
	push	156					; 0000009cH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN5@SimHSIIlsT:

; 3961 : 	}
; 3962 : }

	pop	ebp
	ret	0
?SimHSIIlsTcn@@YAXKHPAX@Z ENDP				; SimHSIIlsTcn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimStepHSIMode@@YAXKHPAX@Z PROC			; SimStepHSIMode

; 3919 : {

	push	ebp
	mov	ebp, esp

; 3920 :   if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)) 

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN11@SimStepHSI
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN11@SimStepHSI
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN11@SimStepHSI

; 3921 : 	{
; 3922 : 		gNavigationSys->StepInstrumentMode();

	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?StepInstrumentMode@NavigationSystem@@QAEXXZ ; NavigationSystem::StepInstrumentMode

; 3923 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	$LN11@SimStepHSI

; 3924 : 		{
; 3925 : 			if (gNavigationSys->GetInstrumentMode() == NavigationSystem::ILS_TACAN) 

	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetInstrumentMode@NavigationSystem@@QAE?AW4Instrument_Mode@1@XZ ; NavigationSystem::GetInstrumentMode
	cmp	eax, 2
	jne	SHORT $LN8@SimStepHSI

; 3926 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HSI_MODE, 1);

	push	1
	push	156					; 0000009cH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 3927 : 			else

	jmp	$LN11@SimStepHSI
$LN8@SimStepHSI:

; 3928 : 			if (gNavigationSys->GetInstrumentMode() == NavigationSystem::TACAN) 

	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetInstrumentMode@NavigationSystem@@QAE?AW4Instrument_Mode@1@XZ ; NavigationSystem::GetInstrumentMode
	cmp	eax, 3
	jne	SHORT $LN6@SimStepHSI

; 3929 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HSI_MODE, 2);

	push	2
	push	156					; 0000009cH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 3930 : 			else

	jmp	SHORT $LN11@SimStepHSI
$LN6@SimStepHSI:

; 3931 : 			if (gNavigationSys->GetInstrumentMode() == NavigationSystem::NAV) 

	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetInstrumentMode@NavigationSystem@@QAE?AW4Instrument_Mode@1@XZ ; NavigationSystem::GetInstrumentMode
	test	eax, eax
	jne	SHORT $LN4@SimStepHSI

; 3932 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HSI_MODE, 4);

	push	4
	push	156					; 0000009cH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 3933 : 			else

	jmp	SHORT $LN11@SimStepHSI
$LN4@SimStepHSI:

; 3934 : 			if (gNavigationSys->GetInstrumentMode() == NavigationSystem::ILS_NAV) 

	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetInstrumentMode@NavigationSystem@@QAE?AW4Instrument_Mode@1@XZ ; NavigationSystem::GetInstrumentMode
	cmp	eax, 1
	jne	SHORT $LN2@SimStepHSI

; 3935 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HSI_MODE, 8);

	push	8
	push	156					; 0000009cH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 3936 : 			else

	jmp	SHORT $LN11@SimStepHSI
$LN2@SimStepHSI:

; 3937 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HSI_MODE, 1);

	push	1
	push	156					; 0000009cH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN11@SimStepHSI:

; 3938 : 		}
; 3939 : 	}
; 3940 : }

	pop	ebp
	ret	0
?SimStepHSIMode@@YAXKHPAX@Z ENDP			; SimStepHSIMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimSilenceHorn@@YAXKHPAX@Z PROC			; SimSilenceHorn

; 3909 : {

	push	ebp
	mov	ebp, esp

; 3910 :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)) {

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimSilence
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimSilence
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimSilence

; 3911 : 		ShiAssert(SimDriver.GetPlayerAircraft()->af);
; 3912 : 		SimDriver.GetPlayerAircraft()->af->SetFlag(AirframeClass::HornSilenced);

	push	1048576					; 00100000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?SetFlag@AirframeClass@@QAEXH@Z		; AirframeClass::SetFlag

; 3913 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN3@SimSilence

; 3914 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_SILENCE_HORN, 2);

	push	2
	push	134					; 00000086H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN3@SimSilence:

; 3915 : 	}
; 3916 : }

	pop	ebp
	ret	0
?SimSilenceHorn@@YAXKHPAX@Z ENDP			; SimSilenceHorn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimMPO@@YAXKHPAX@Z PROC				; SimMPO

; 3890 : {

	push	ebp
	mov	ebp, esp

; 3891 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN4@SimMPO

; 3892 : 		return;

	jmp	SHORT $LN5@SimMPO
$LN4@SimMPO:

; 3893 : 
; 3894 :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) {

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN5@SimMPO
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN5@SimMPO

; 3895 : 	   if (state & KEY_DOWN)

	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN2@SimMPO

; 3896 : 		   SimDriver.GetPlayerAircraft()->af->SetFlag(AirframeClass::MPOverride);

	push	262144					; 00040000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?SetFlag@AirframeClass@@QAEXH@Z		; AirframeClass::SetFlag

; 3897 : 	   else

	jmp	SHORT $LN5@SimMPO
$LN2@SimMPO:

; 3898 : 		   SimDriver.GetPlayerAircraft()->af->ClearFlag(AirframeClass::MPOverride);

	push	262144					; 00040000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?ClearFlag@AirframeClass@@QAEXH@Z	; AirframeClass::ClearFlag
$LN5@SimMPO:

; 3899 :    }
; 3900 : }

	pop	ebp
	ret	0
?SimMPO@@YAXKHPAX@Z ENDP				; SimMPO
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimMPOToggle@@YAXKHPAX@Z PROC				; SimMPOToggle

; 3867 : {

	push	ebp
	mov	ebp, esp

; 3868 :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)) 

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN6@SimMPOTogg
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN6@SimMPOTogg
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN6@SimMPOTogg

; 3869 : 	 {
; 3870 : 	   ShiAssert(SimDriver.GetPlayerAircraft()->af);
; 3871 : 	   if(SimDriver.GetPlayerAircraft()->af->IsSet(AirframeClass::MPOverride))

	push	262144					; 00040000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN4@SimMPOTogg

; 3872 : 	   {
; 3873 : 		   SimDriver.GetPlayerAircraft()->af->ClearFlag(AirframeClass::MPOverride);

	push	262144					; 00040000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?ClearFlag@AirframeClass@@QAEXH@Z	; AirframeClass::ClearFlag

; 3874 : 			 if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN3@SimMPOTogg

; 3875 : 					OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_MPO, 1);

	push	1
	push	174					; 000000aeH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN3@SimMPOTogg:

; 3876 : 	   }
; 3877 : 	   else

	jmp	SHORT $LN6@SimMPOTogg
$LN4@SimMPOTogg:

; 3878 : 	   {
; 3879 : 		   SimDriver.GetPlayerAircraft()->af->SetFlag(AirframeClass::MPOverride);

	push	262144					; 00040000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?SetFlag@AirframeClass@@QAEXH@Z		; AirframeClass::SetFlag

; 3880 : 			 if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN6@SimMPOTogg

; 3881 : 					OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_MPO, 2);

	push	2
	push	174					; 000000aeH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN6@SimMPOTogg:

; 3882 : 	   }
; 3883 : 	}
; 3884 : }

	pop	ebp
	ret	0
?SimMPOToggle@@YAXKHPAX@Z ENDP				; SimMPOToggle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
_pButton$ = 16						; size = 4
?SimAVTRToggle@@YAXKHPAX@Z PROC				; SimAVTRToggle

; 3851 : {

	push	ebp
	mov	ebp, esp

; 3852 :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)) {

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimAVTRTog
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimAVTRTog
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN4@SimAVTRTog

; 3853 : 		// edg: folded my command function in here.  Not sure if
; 3854 : 		// a simdriver setting needs to be made, but keeping it in
; 3855 : 		ACMIToggleRecording ( val, state, pButton);

	mov	ecx, DWORD PTR _pButton$[ebp]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	call	?ACMIToggleRecording@@YAXKHPAX@Z	; ACMIToggleRecording
	add	esp, 12					; 0000000cH

; 3856 : 		if(SimDriver.AVTROn() == TRUE) {

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?AVTROn@SimulationDriver@@QAEHXZ	; SimulationDriver::AVTROn
	cmp	eax, 1
	jne	SHORT $LN2@SimAVTRTog

; 3857 : 			SimDriver.SetAVTR(FALSE);

	push	0
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?SetAVTR@SimulationDriver@@QAEXH@Z	; SimulationDriver::SetAVTR

; 3858 : 		}
; 3859 : 		else {

	jmp	SHORT $LN4@SimAVTRTog
$LN2@SimAVTRTog:

; 3860 : 			SimDriver.SetAVTR(TRUE);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?SetAVTR@SimulationDriver@@QAEXH@Z	; SimulationDriver::SetAVTR
$LN4@SimAVTRTog:

; 3861 : 		}
; 3862 : 	}
; 3863 : }

	pop	ebp
	ret	0
?SimAVTRToggle@@YAXKHPAX@Z ENDP				; SimAVTRToggle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$1 = -8						; size = 4
tv138 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimHsiHdgDecBy1@@YAXKHPAX@Z PROC			; SimHsiHdgDecBy1

; 3840 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3841 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected... Vince, you should know better than this ;-)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN1@SimHsiHdgD
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN1@SimHsiHdgD

; 3842 : 		OTWDriver.pCockpitManager->mpHsi->DecState(CPHsi::HSI_STA_HDG_STATE, 1.0F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	1
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [ecx+692]
	call	?DecState@CPHsi@@QAEXW4HSIButtonStates@1@M@Z ; CPHsi::DecState

; 3843 : 		//int val = (int)(OTWDriver.pCockpitManager->mpHsi->GetValue(CPHsi::HSI_VAL_DESIRED_HEADING)/36.0f)+1;
; 3844 : 		int val = 1<<(int)(OTWDriver.pCockpitManager->mpHsi->GetValue(CPHsi::HSI_VAL_DESIRED_HEADING)/36.0f);

	push	5
	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [edx+692]
	call	?GetValue@CPHsi@@QAEMW4HSIValues@1@@Z	; CPHsi::GetValue
	fstp	DWORD PTR tv138[ebp]
	movss	xmm0, DWORD PTR tv138[ebp]
	divss	xmm0, DWORD PTR __real@42100000
	cvttss2si ecx, xmm0
	mov	eax, 1
	shl	eax, cl
	mov	DWORD PTR _val$1[ebp], eax

; 3845 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN1@SimHsiHdgD

; 3846 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HSI_HEADING, val);

	mov	ecx, DWORD PTR _val$1[ebp]
	push	ecx
	push	157					; 0000009dH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN1@SimHsiHdgD:

; 3847 : 	}
; 3848 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimHsiHdgDecBy1@@YAXKHPAX@Z ENDP			; SimHsiHdgDecBy1
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$1 = -8						; size = 4
tv138 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimHsiHdgIncBy1@@YAXKHPAX@Z PROC			; SimHsiHdgIncBy1

; 3829 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3830 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected... Vince, you should know better than this ;-)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN1@SimHsiHdgI
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN1@SimHsiHdgI

; 3831 : 		OTWDriver.pCockpitManager->mpHsi->IncState(CPHsi::HSI_STA_HDG_STATE, 1.0F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	1
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [ecx+692]
	call	?IncState@CPHsi@@QAEXW4HSIButtonStates@1@M@Z ; CPHsi::IncState

; 3832 : 		//int val = (int)(OTWDriver.pCockpitManager->mpHsi->GetValue(CPHsi::HSI_VAL_DESIRED_HEADING)/36.0f)+1;
; 3833 : 		int val = 1<<(int)(OTWDriver.pCockpitManager->mpHsi->GetValue(CPHsi::HSI_VAL_DESIRED_HEADING)/36.0f);

	push	5
	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [edx+692]
	call	?GetValue@CPHsi@@QAEMW4HSIValues@1@@Z	; CPHsi::GetValue
	fstp	DWORD PTR tv138[ebp]
	movss	xmm0, DWORD PTR tv138[ebp]
	divss	xmm0, DWORD PTR __real@42100000
	cvttss2si ecx, xmm0
	mov	eax, 1
	shl	eax, cl
	mov	DWORD PTR _val$1[ebp], eax

; 3834 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN1@SimHsiHdgI

; 3835 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HSI_HEADING, val);

	mov	ecx, DWORD PTR _val$1[ebp]
	push	ecx
	push	157					; 0000009dH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN1@SimHsiHdgI:

; 3836 : 	}
; 3837 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimHsiHdgIncBy1@@YAXKHPAX@Z ENDP			; SimHsiHdgIncBy1
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$1 = -8						; size = 4
tv138 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimHsiCrsDecBy1@@YAXKHPAX@Z PROC			; SimHsiCrsDecBy1

; 3818 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3819 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected... Vince, you should know better than this ;-)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN1@SimHsiCrsD
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN1@SimHsiCrsD

; 3820 : 		OTWDriver.pCockpitManager->mpHsi->DecState(CPHsi::HSI_STA_CRS_STATE, 1.0F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	0
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [ecx+692]
	call	?DecState@CPHsi@@QAEXW4HSIButtonStates@1@M@Z ; CPHsi::DecState

; 3821 : 		//int val = (int)(OTWDriver.pCockpitManager->mpHsi->GetValue(CPHsi::HSI_VAL_DESIRED_CRS)/36.0f)+1;
; 3822 : 		int val = 1<<(int)(OTWDriver.pCockpitManager->mpHsi->GetValue(CPHsi::HSI_VAL_DESIRED_CRS)/36.0f);

	push	1
	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [edx+692]
	call	?GetValue@CPHsi@@QAEMW4HSIValues@1@@Z	; CPHsi::GetValue
	fstp	DWORD PTR tv138[ebp]
	movss	xmm0, DWORD PTR tv138[ebp]
	divss	xmm0, DWORD PTR __real@42100000
	cvttss2si ecx, xmm0
	mov	eax, 1
	shl	eax, cl
	mov	DWORD PTR _val$1[ebp], eax

; 3823 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN1@SimHsiCrsD

; 3824 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HSI_COURSE, val);

	mov	ecx, DWORD PTR _val$1[ebp]
	push	ecx
	push	158					; 0000009eH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN1@SimHsiCrsD:

; 3825 : 	}
; 3826 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimHsiCrsDecBy1@@YAXKHPAX@Z ENDP			; SimHsiCrsDecBy1
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$1 = -8						; size = 4
tv138 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimHsiCrsIncBy1@@YAXKHPAX@Z PROC			; SimHsiCrsIncBy1

; 3807 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3808 : 	if (state & KEY_DOWN && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected... Vince, you should know better than this ;-)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN1@SimHsiCrsI
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN1@SimHsiCrsI

; 3809 : 		OTWDriver.pCockpitManager->mpHsi->IncState(CPHsi::HSI_STA_CRS_STATE, 1.0F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	0
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [ecx+692]
	call	?IncState@CPHsi@@QAEXW4HSIButtonStates@1@M@Z ; CPHsi::IncState

; 3810 : 		//int val = (int)(OTWDriver.pCockpitManager->mpHsi->GetValue(CPHsi::HSI_VAL_DESIRED_CRS)/36.0f)+1;
; 3811 : 		int val = 1<<(int)(OTWDriver.pCockpitManager->mpHsi->GetValue(CPHsi::HSI_VAL_DESIRED_CRS)/36.0f);

	push	1
	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [edx+692]
	call	?GetValue@CPHsi@@QAEMW4HSIValues@1@@Z	; CPHsi::GetValue
	fstp	DWORD PTR tv138[ebp]
	movss	xmm0, DWORD PTR tv138[ebp]
	divss	xmm0, DWORD PTR __real@42100000
	cvttss2si ecx, xmm0
	mov	eax, 1
	shl	eax, cl
	mov	DWORD PTR _val$1[ebp], eax

; 3812 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN1@SimHsiCrsI

; 3813 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HSI_COURSE, val);

	mov	ecx, DWORD PTR _val$1[ebp]
	push	ecx
	push	158					; 0000009eH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN1@SimHsiCrsI:

; 3814 : 	}
; 3815 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimHsiCrsIncBy1@@YAXKHPAX@Z ENDP			; SimHsiCrsIncBy1
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$1 = -8						; size = 4
tv138 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimHsiHeadingDec@@YAXKHPAX@Z PROC			; SimHsiHeadingDec

; 3795 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3796 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected... Vince, you should know better than this ;-)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN1@SimHsiHead
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN1@SimHsiHead

; 3797 : 		OTWDriver.pCockpitManager->mpHsi->DecState(CPHsi::HSI_STA_HDG_STATE);

	push	ecx
	movss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR [esp], xmm0
	push	1
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [ecx+692]
	call	?DecState@CPHsi@@QAEXW4HSIButtonStates@1@M@Z ; CPHsi::DecState

; 3798 : 		//int val = (int)(OTWDriver.pCockpitManager->mpHsi->GetValue(CPHsi::HSI_VAL_DESIRED_HEADING)/36.0f)+1;
; 3799 : 		int val = 1<<(int)(OTWDriver.pCockpitManager->mpHsi->GetValue(CPHsi::HSI_VAL_DESIRED_HEADING)/36.0f);

	push	5
	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [edx+692]
	call	?GetValue@CPHsi@@QAEMW4HSIValues@1@@Z	; CPHsi::GetValue
	fstp	DWORD PTR tv138[ebp]
	movss	xmm0, DWORD PTR tv138[ebp]
	divss	xmm0, DWORD PTR __real@42100000
	cvttss2si ecx, xmm0
	mov	eax, 1
	shl	eax, cl
	mov	DWORD PTR _val$1[ebp], eax

; 3800 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN1@SimHsiHead

; 3801 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HSI_HEADING, val);

	mov	ecx, DWORD PTR _val$1[ebp]
	push	ecx
	push	157					; 0000009dH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN1@SimHsiHead:

; 3802 : 	}
; 3803 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimHsiHeadingDec@@YAXKHPAX@Z ENDP			; SimHsiHeadingDec
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$1 = -8						; size = 4
tv138 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimHsiHeadingInc@@YAXKHPAX@Z PROC			; SimHsiHeadingInc

; 3784 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3785 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected... Vince, you should know better than this ;-)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN1@SimHsiHead
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN1@SimHsiHead

; 3786 : 		OTWDriver.pCockpitManager->mpHsi->IncState(CPHsi::HSI_STA_HDG_STATE);

	push	ecx
	movss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR [esp], xmm0
	push	1
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [ecx+692]
	call	?IncState@CPHsi@@QAEXW4HSIButtonStates@1@M@Z ; CPHsi::IncState

; 3787 : 		//int val = (int)(OTWDriver.pCockpitManager->mpHsi->GetValue(CPHsi::HSI_VAL_DESIRED_HEADING)/36.0f)+1;
; 3788 : 		int val = 1<<(int)(OTWDriver.pCockpitManager->mpHsi->GetValue(CPHsi::HSI_VAL_DESIRED_HEADING)/36.0f);

	push	5
	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [edx+692]
	call	?GetValue@CPHsi@@QAEMW4HSIValues@1@@Z	; CPHsi::GetValue
	fstp	DWORD PTR tv138[ebp]
	movss	xmm0, DWORD PTR tv138[ebp]
	divss	xmm0, DWORD PTR __real@42100000
	cvttss2si ecx, xmm0
	mov	eax, 1
	shl	eax, cl
	mov	DWORD PTR _val$1[ebp], eax

; 3789 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN1@SimHsiHead

; 3790 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HSI_HEADING, val);

	mov	ecx, DWORD PTR _val$1[ebp]
	push	ecx
	push	157					; 0000009dH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN1@SimHsiHead:

; 3791 : 	}
; 3792 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimHsiHeadingInc@@YAXKHPAX@Z ENDP			; SimHsiHeadingInc
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$1 = -8						; size = 4
tv138 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimHsiCourseDec@@YAXKHPAX@Z PROC			; SimHsiCourseDec

; 3773 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3774 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected... Vince, you should know better than this ;-)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN1@SimHsiCour
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN1@SimHsiCour

; 3775 : 		OTWDriver.pCockpitManager->mpHsi->DecState(CPHsi::HSI_STA_CRS_STATE);

	push	ecx
	movss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR [esp], xmm0
	push	0
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [ecx+692]
	call	?DecState@CPHsi@@QAEXW4HSIButtonStates@1@M@Z ; CPHsi::DecState

; 3776 : 		//int val = (int)(OTWDriver.pCockpitManager->mpHsi->GetValue(CPHsi::HSI_VAL_DESIRED_CRS)/36.0f)+1;
; 3777 : 		int val = 1<<(int)(OTWDriver.pCockpitManager->mpHsi->GetValue(CPHsi::HSI_VAL_DESIRED_CRS)/36.0f);

	push	1
	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [edx+692]
	call	?GetValue@CPHsi@@QAEMW4HSIValues@1@@Z	; CPHsi::GetValue
	fstp	DWORD PTR tv138[ebp]
	movss	xmm0, DWORD PTR tv138[ebp]
	divss	xmm0, DWORD PTR __real@42100000
	cvttss2si ecx, xmm0
	mov	eax, 1
	shl	eax, cl
	mov	DWORD PTR _val$1[ebp], eax

; 3778 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN1@SimHsiCour

; 3779 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HSI_COURSE, val);

	mov	ecx, DWORD PTR _val$1[ebp]
	push	ecx
	push	158					; 0000009eH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN1@SimHsiCour:

; 3780 : 	}
; 3781 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimHsiCourseDec@@YAXKHPAX@Z ENDP			; SimHsiCourseDec
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$1 = -8						; size = 4
tv138 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimHsiCourseInc@@YAXKHPAX@Z PROC			; SimHsiCourseInc

; 3762 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3763 : 	if (state & KEY_DOWN && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { // 2002-02-15 MODIFIED BY S.G. Any cockpit stuff is valid only if the player hasn't ejected... Vince, you should know better than this ;-)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN1@SimHsiCour
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN1@SimHsiCour

; 3764 : 		OTWDriver.pCockpitManager->mpHsi->IncState(CPHsi::HSI_STA_CRS_STATE);

	push	ecx
	movss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR [esp], xmm0
	push	0
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [ecx+692]
	call	?IncState@CPHsi@@QAEXW4HSIButtonStates@1@M@Z ; CPHsi::IncState

; 3765 : 		//int val = (int)(OTWDriver.pCockpitManager->mpHsi->GetValue(CPHsi::HSI_VAL_DESIRED_CRS)/36.0f)+1;
; 3766 : 		int val = 1<<(int)(OTWDriver.pCockpitManager->mpHsi->GetValue(CPHsi::HSI_VAL_DESIRED_CRS)/36.0f);

	push	1
	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [edx+692]
	call	?GetValue@CPHsi@@QAEMW4HSIValues@1@@Z	; CPHsi::GetValue
	fstp	DWORD PTR tv138[ebp]
	movss	xmm0, DWORD PTR tv138[ebp]
	divss	xmm0, DWORD PTR __real@42100000
	cvttss2si ecx, xmm0
	mov	eax, 1
	shl	eax, cl
	mov	DWORD PTR _val$1[ebp], eax

; 3767 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN1@SimHsiCour

; 3768 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HSI_COURSE, val);

	mov	ecx, DWORD PTR _val$1[ebp]
	push	ecx
	push	158					; 0000009eH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN1@SimHsiCour:

; 3769 : 	}
; 3770 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimHsiCourseInc@@YAXKHPAX@Z ENDP			; SimHsiCourseInc
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimSimMasterArm@@YAXKHPAX@Z PROC			; SimSimMasterArm

; 1761 : {

	push	ebp
	mov	ebp, esp

; 1762 :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN) && SimDriver.GetPlayerAircraft()->Sms)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimSimMast
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimSimMast
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimSimMast
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+940], 0
	je	SHORT $LN3@SimSimMast

; 1763 :    {
; 1764 :       SimDriver.GetPlayerAircraft()->Sms->SetMasterArm(SMSBaseClass::Sim);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+940]
	call	?SetMasterArm@SMSBaseClass@@QAEXW4MasterArmState@1@@Z ; SMSBaseClass::SetMasterArm

; 1765 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN3@SimSimMast

; 1766 : 					OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_MASTER_ARM, 2);

	push	2
	push	135					; 00000087H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN3@SimSimMast:

; 1767 :    }
; 1768 : }

	pop	ebp
	ret	0
?SimSimMasterArm@@YAXKHPAX@Z ENDP			; SimSimMasterArm
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimSafeMasterArm@@YAXKHPAX@Z PROC			; SimSafeMasterArm

; 1751 : {

	push	ebp
	mov	ebp, esp

; 1752 :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN) && SimDriver.GetPlayerAircraft()->Sms)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimSafeMas
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimSafeMas
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimSafeMas
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+940], 0
	je	SHORT $LN3@SimSafeMas

; 1753 :    {
; 1754 :       SimDriver.GetPlayerAircraft()->Sms->SetMasterArm(SMSBaseClass::Safe);

	push	0
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+940]
	call	?SetMasterArm@SMSBaseClass@@QAEXW4MasterArmState@1@@Z ; SMSBaseClass::SetMasterArm

; 1755 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN3@SimSafeMas

; 1756 : 					OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_MASTER_ARM, 3);

	push	3
	push	135					; 00000087H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN3@SimSafeMas:

; 1757 :    }
; 1758 : }

	pop	ebp
	ret	0
?SimSafeMasterArm@@YAXKHPAX@Z ENDP			; SimSafeMasterArm
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimArmMasterArm@@YAXKHPAX@Z PROC			; SimArmMasterArm

; 1743 : {

	push	ebp
	mov	ebp, esp

; 1744 :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN) && SimDriver.GetPlayerAircraft()->Sms)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimArmMast
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimArmMast
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimArmMast
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+940], 0
	je	SHORT $LN2@SimArmMast

; 1745 :    {
; 1746 :       SimDriver.GetPlayerAircraft()->Sms->SetMasterArm(SMSBaseClass::Arm);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+940]
	call	?SetMasterArm@SMSBaseClass@@QAEXW4MasterArmState@1@@Z ; SMSBaseClass::SetMasterArm
$LN2@SimArmMast:

; 1747 :    }
; 1748 : }

	pop	ebp
	ret	0
?SimArmMasterArm@@YAXKHPAX@Z ENDP			; SimArmMasterArm
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimStepMasterArm@@YAXKHPAX@Z PROC			; SimStepMasterArm

; 1721 : {

	push	ebp
	mov	ebp, esp

; 1722 :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN) && SimDriver.GetPlayerAircraft()->Sms)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN7@SimStepMas
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN7@SimStepMas
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN7@SimStepMas
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+940], 0
	je	$LN7@SimStepMas

; 1723 :    {
; 1724 :       SimDriver.GetPlayerAircraft()->Sms->StepMasterArm();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+940]
	call	?StepMasterArm@SMSBaseClass@@QAEXXZ	; SMSBaseClass::StepMasterArm

; 1725 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	$LN7@SimStepMas

; 1726 : 			{
; 1727 : 				if (SimDriver.GetPlayerAircraft()->Sms->MasterArm() == SMSBaseClass::Arm)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+940]
	call	?MasterArm@SMSBaseClass@@QAE?AW4MasterArmState@1@XZ ; SMSBaseClass::MasterArm
	cmp	eax, 2
	jne	SHORT $LN4@SimStepMas

; 1728 : 				{
; 1729 : 					OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_MASTER_ARM, 2);

	push	2
	push	135					; 00000087H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 1730 : 				}
; 1731 : 				else

	jmp	SHORT $LN7@SimStepMas
$LN4@SimStepMas:

; 1732 : 				if (SimDriver.GetPlayerAircraft()->Sms->MasterArm() ==  SMSBaseClass::Sim)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+940]
	call	?MasterArm@SMSBaseClass@@QAE?AW4MasterArmState@1@XZ ; SMSBaseClass::MasterArm
	cmp	eax, 1
	jne	SHORT $LN2@SimStepMas

; 1733 : 				{
; 1734 : 					OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_MASTER_ARM, 3);

	push	3
	push	135					; 00000087H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 1735 : 				}
; 1736 : 				else // safe

	jmp	SHORT $LN7@SimStepMas
$LN2@SimStepMas:

; 1737 : 					OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_MASTER_ARM, 1);

	push	1
	push	135					; 00000087H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN7@SimStepMas:

; 1738 : 			}
; 1739 :    }
; 1740 : }

	pop	ebp
	ret	0
?SimStepMasterArm@@YAXKHPAX@Z ENDP			; SimStepMasterArm
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SoundOff@@YAXKHPAX@Z PROC				; SoundOff

; 3750 : {

	push	ebp
	mov	ebp, esp

; 3751 : 	if(state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN4@SoundOff

; 3752 : 	{
; 3753 : 		if(gSoundDriver->GetMasterVolume() <= -7000)

	mov	ecx, DWORD PTR ?gSoundDriver@@3PAVCSoundMgr@@A ; gSoundDriver
	call	?GetMasterVolume@CSoundMgr@@QAEJXZ	; CSoundMgr::GetMasterVolume
	cmp	eax, -7000				; ffffe4a8H
	jg	SHORT $LN2@SoundOff

; 3754 : 			gSoundDriver->SetMasterVolume(PlayerOptions.GroupVol[MASTER_SOUND_GROUP]);

	mov	ecx, 4
	imul	ecx, 9
	mov	edx, DWORD PTR ?PlayerOptions@@3VPlayerOptionsClass@@A[ecx+120]
	push	edx
	mov	ecx, DWORD PTR ?gSoundDriver@@3PAVCSoundMgr@@A ; gSoundDriver
	call	?SetMasterVolume@CSoundMgr@@QAEJJ@Z	; CSoundMgr::SetMasterVolume

; 3755 : 		else

	jmp	SHORT $LN4@SoundOff
$LN2@SoundOff:

; 3756 : 			gSoundDriver->SetMasterVolume(-10000);

	push	-10000					; ffffd8f0H
	mov	ecx, DWORD PTR ?gSoundDriver@@3PAVCSoundMgr@@A ; gSoundDriver
	call	?SetMasterVolume@CSoundMgr@@QAEJJ@Z	; CSoundMgr::SetMasterVolume
$LN4@SoundOff:

; 3757 : 	}
; 3758 : }

	pop	ebp
	ret	0
?SoundOff@@YAXKHPAX@Z ENDP				; SoundOff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimRandomError@@YAXKHPAX@Z PROC			; SimRandomError

; 10372: {

	push	ebp
	mov	ebp, esp

; 10373: 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN6@SimRandomE
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN6@SimRandomE
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN6@SimRandomE

; 10374:     {
; 10375: 		SimDriver.GetPlayerAircraft()->mFaults->RandomFailure();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+928]
	call	?RandomFailure@FackClass@@QAEXXZ	; FackClass::RandomFailure

; 10376: 		/*
; 10377: 		int	failures;	//How many things can possibly fail?
; 10378: 		long failuresPossible; //which Systems are allowed to fail? (Here:All [All Bits set to 1])
; 10379: 
; 10380: 		//failuresPossible = 1 + long((2 ^ FaultClass::NumFaultListSubSystems - 1) * rand()/(RAND_MAX + 1.0));
; 10381: 		failuresPossible = 134217728-1; //1 + long(134217728 * rand()/(RAND_MAX + 1.0)); //2^27
; 10382: 
; 10383: 		//failures = 1 + int(27 * rand()/(RAND_MAX + 1.0));	//Generate between 1 and 10 errors (theoretical max: 27)
; 10384: 		failures = 27;
; 10385: 		failures = 999;
; 10386: 		
; 10387: 		((AircraftClass*)SimDriver.GetPlayerAircraft())->AddFault(failures, failuresPossible, 1, 1);
; 10388: 		*/
; 10389: 		//THW Now that the systems are broken, add some more damage ;-) [another blatant copy from codec]
; 10390: 		if (rand() % 100 < 20) { // 20% failure chance of A system

	call	_rand
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	cmp	edx, 20					; 00000014H
	jge	SHORT $LN4@SimRandomE

; 10391: 			SimDriver.GetPlayerAircraft()->af->HydrBreak (AirframeClass::HYDR_A_SYSTEM);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?HydrBreak@AirframeClass@@QAEXH@Z	; AirframeClass::HydrBreak
$LN4@SimRandomE:

; 10392: 		}
; 10393: 		if (rand() % 100 < 20) { // 20% failure chance of B system

	call	_rand
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	cmp	edx, 20					; 00000014H
	jge	SHORT $LN3@SimRandomE

; 10394: 			SimDriver.GetPlayerAircraft()->af->HydrBreak (AirframeClass::HYDR_B_SYSTEM);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?HydrBreak@AirframeClass@@QAEXH@Z	; AirframeClass::HydrBreak
$LN3@SimRandomE:

; 10395: 		}
; 10396: 		// also break the generators now and then
; 10397: 		if (rand() % 7 == 1)

	call	_rand
	cdq
	mov	ecx, 7
	idiv	ecx
	cmp	edx, 1
	jne	SHORT $LN2@SimRandomE

; 10398: 			SimDriver.GetPlayerAircraft()->af->GeneratorBreak(AirframeClass::GenStdby);

	push	64					; 00000040H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?GeneratorBreak@AirframeClass@@QAEXW4Generator@1@@Z ; AirframeClass::GeneratorBreak
$LN2@SimRandomE:

; 10399: 		if (rand() % 7 == 1)

	call	_rand
	cdq
	mov	ecx, 7
	idiv	ecx
	cmp	edx, 1
	jne	SHORT $LN6@SimRandomE

; 10400: 			SimDriver.GetPlayerAircraft()->af->GeneratorBreak(AirframeClass::GenMain);

	push	1024					; 00000400H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?GeneratorBreak@AirframeClass@@QAEXW4Generator@1@@Z ; AirframeClass::GeneratorBreak
$LN6@SimRandomE:

; 10401:     }
; 10402: }

	pop	ebp
	ret	0
?SimRandomError@@YAXKHPAX@Z ENDP			; SimRandomError
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv145 = -8						; size = 4
tv88 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimECMConsent@@YAXKHPAX@Z PROC				; SimECMConsent

; 3725 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3726 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN6@SimECMCons

; 3727 : 		return;

	jmp	$LN7@SimECMCons
$LN6@SimECMCons:

; 3728 : 
; 3729 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN7@SimECMCons
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN7@SimECMCons
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	$LN7@SimECMCons

; 3730 : 	{
; 3731 :          // Can't turn on ECM w/ broken blanker
; 3732 :          if (SimDriver.GetPlayerAircraft()->HasSPJamming() && !SimDriver.GetPlayerAircraft()->mFaults->GetFault(FaultClass::blkr_fault))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR tv88[ebp], eax
	mov	edx, DWORD PTR tv88[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv88[ebp]
	mov	edx, DWORD PTR [eax+276]
	call	edx
	test	eax, eax
	je	$LN7@SimECMCons
	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFault@FackClass@@QAEHW4type_FSubSystem@FaultClass@@@Z ; FackClass::GetFault
	test	eax, eax
	jne	$LN7@SimECMCons

; 3733 : 		 {
; 3734 : 			 //MI no Jammer with WOW, unless ground Jett is on
; 3735 : 			 if(g_bRealisticAvionics && SimDriver.GetPlayerAircraft()->Sms)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN3@SimECMCons
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+940], 0
	je	SHORT $LN3@SimECMCons

; 3736 : 			 {
; 3737 : 				 if(SimDriver.GetPlayerAircraft()->OnGround() && !SimDriver.GetPlayerAircraft()->Sms->GndJett)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR tv145[ebp], eax
	mov	ecx, DWORD PTR tv145[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv145[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	je	SHORT $LN3@SimECMCons
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+940]
	movzx	edx, BYTE PTR [ecx+13]
	test	edx, edx
	jne	SHORT $LN3@SimECMCons

; 3738 : 					 return;

	jmp	SHORT $LN7@SimECMCons
$LN3@SimECMCons:

; 3739 : 			 }
; 3740 : 			 SimDriver.GetPlayerAircraft()->SetFlag(ECM_ON);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetFlag@SimBaseClass@@QAEXH@Z		; SimBaseClass::SetFlag

; 3741 : 			 
; 3742 : 			 //MI EWS stuff
; 3743 : 			 if(g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN7@SimECMCons

; 3744 : 				 SimDriver.GetPlayerAircraft()->ManualECM = TRUE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	BYTE PTR [eax+1012], 1
$LN7@SimECMCons:

; 3745 : 		 }
; 3746 : 	}
; 3747 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimECMConsent@@YAXKHPAX@Z ENDP				; SimECMConsent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimECMStandby@@YAXKHPAX@Z PROC				; SimECMStandby

; 3704 : {

	push	ebp
	mov	ebp, esp

; 3705 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN4@SimECMStan

; 3706 : 		return;

	jmp	SHORT $LN5@SimECMStan
$LN4@SimECMStan:

; 3707 : 
; 3708 :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN5@SimECMStan
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN5@SimECMStan
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN5@SimECMStan

; 3709 :    {
; 3710 : 		 // Can't turn off ECM w/ ECM pod broken
; 3711 : 		 if (!SimDriver.GetPlayerAircraft()->mFaults->GetFault(FaultClass::epod_fault))

	push	10					; 0000000aH
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFault@FackClass@@QAEHW4type_FSubSystem@FaultClass@@@Z ; FackClass::GetFault
	test	eax, eax
	jne	SHORT $LN5@SimECMStan

; 3712 : 		 {
; 3713 : 			SimDriver.GetPlayerAircraft()->UnSetFlag(ECM_ON);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?UnSetFlag@SimBaseClass@@QAEXH@Z	; SimBaseClass::UnSetFlag

; 3714 : 			//MI EWS stuff
; 3715 : 			if(g_bRealisticAvionics)

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	SHORT $LN5@SimECMStan

; 3716 : 				SimDriver.GetPlayerAircraft()->ManualECM = FALSE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	BYTE PTR [eax+1012], 0
$LN5@SimECMStan:

; 3717 : 		 }     
; 3718 :    }
; 3719 : }

	pop	ebp
	ret	0
?SimECMStandby@@YAXKHPAX@Z ENDP				; SimECMStandby
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv173 = -8						; size = 4
tv148 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimECMOn@@YAXKHPAX@Z PROC				; SimECMOn

; 3665 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3666 :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN10@SimECMOn
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN10@SimECMOn
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN10@SimECMOn

; 3667 :    {
; 3668 :       if (SimDriver.GetPlayerAircraft()->IsSetFlag(ECM_ON))

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN8@SimECMOn

; 3669 :       {
; 3670 :          // Can't turn off ECM w/ ECM pod broken
; 3671 :          if (!SimDriver.GetPlayerAircraft()->mFaults->GetFault(FaultClass::epod_fault))

	push	10					; 0000000aH
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFault@FackClass@@QAEHW4type_FSubSystem@FaultClass@@@Z ; FackClass::GetFault
	test	eax, eax
	jne	SHORT $LN7@SimECMOn

; 3672 : 		 {
; 3673 :             SimDriver.GetPlayerAircraft()->UnSetFlag(ECM_ON);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?UnSetFlag@SimBaseClass@@QAEXH@Z	; SimBaseClass::UnSetFlag

; 3674 : 			//MI EWS stuff
; 3675 : 			if(g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN7@SimECMOn

; 3676 : 				SimDriver.GetPlayerAircraft()->ManualECM = FALSE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	BYTE PTR [eax+1012], 0
$LN7@SimECMOn:

; 3677 : 		 }
; 3678 :       }
; 3679 :       else

	jmp	$LN10@SimECMOn
$LN8@SimECMOn:

; 3680 :       {
; 3681 :          // Can't turn on ECM w/ broken blanker
; 3682 :          if (SimDriver.GetPlayerAircraft()->HasSPJamming() && !SimDriver.GetPlayerAircraft()->mFaults->GetFault(FaultClass::blkr_fault))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR tv148[ebp], eax
	mov	edx, DWORD PTR tv148[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv148[ebp]
	mov	edx, DWORD PTR [eax+276]
	call	edx
	test	eax, eax
	je	$LN10@SimECMOn
	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFault@FackClass@@QAEHW4type_FSubSystem@FaultClass@@@Z ; FackClass::GetFault
	test	eax, eax
	jne	$LN10@SimECMOn

; 3683 : 		 {
; 3684 : 			 //MI no Jammer with WOW, unless ground Jett is on
; 3685 : 			 if(g_bRealisticAvionics && SimDriver.GetPlayerAircraft()->Sms)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN3@SimECMOn
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+940], 0
	je	SHORT $LN3@SimECMOn

; 3686 : 			 {
; 3687 : 				 if(SimDriver.GetPlayerAircraft()->OnGround() && !SimDriver.GetPlayerAircraft()->Sms->GndJett)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR tv173[ebp], eax
	mov	ecx, DWORD PTR tv173[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv173[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	je	SHORT $LN3@SimECMOn
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+940]
	movzx	edx, BYTE PTR [ecx+13]
	test	edx, edx
	jne	SHORT $LN3@SimECMOn

; 3688 : 					 return;

	jmp	SHORT $LN10@SimECMOn
$LN3@SimECMOn:

; 3689 : 			 }
; 3690 : 			 SimDriver.GetPlayerAircraft()->SetFlag(ECM_ON);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetFlag@SimBaseClass@@QAEXH@Z		; SimBaseClass::SetFlag

; 3691 : 			 
; 3692 : 			 //MI EWS stuff
; 3693 : 			 if(g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN10@SimECMOn

; 3694 : 				 SimDriver.GetPlayerAircraft()->ManualECM = TRUE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	BYTE PTR [eax+1012], 1
$LN10@SimECMOn:

; 3695 : 		 }
; 3696 :       }
; 3697 :    }
; 3698 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimECMOn@@YAXKHPAX@Z ENDP				; SimECMOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv91 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimWheelBrakes@@YAXKHPAX@Z PROC			; SimWheelBrakes

; 3423 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 3424 : 	//Cobra double tap to turn on thrust reverse
; 3425 : 	static VU_TIME thrrevtimer = 0;
; 3426 : 	
; 3427 : 
; 3428 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN10@SimWheelBr
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN10@SimWheelBr

; 3429 : 	{
; 3430 : 		if( state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN9@SimWheelBr

; 3431 : 		{
; 3432 : 			if (thrrevtimer == 0)  

	cmp	DWORD PTR ?thrrevtimer@?1??SimWheelBrakes@@YAXKHPAX@Z@4KA, 0
	jne	SHORT $LN8@SimWheelBr

; 3433 : 			{
; 3434 : 				thrrevtimer = SimLibElapsedTime;

	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR ?thrrevtimer@?1??SimWheelBrakes@@YAXKHPAX@Z@4KA, ecx
$LN8@SimWheelBr:

; 3435 : 			}
; 3436 : 		}
; 3437 : 		else

	jmp	SHORT $LN10@SimWheelBr
$LN9@SimWheelBr:

; 3438 : 		{   
; 3439 : 			if(SimLibElapsedTime - thrrevtimer <= 500 && SimDriver.GetPlayerAircraft()->af->thrustReverse < 2)

	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	sub	edx, DWORD PTR ?thrrevtimer@?1??SimWheelBrakes@@YAXKHPAX@Z@4KA
	cmp	edx, 500				; 000001f4H
	ja	SHORT $LN6@SimWheelBr
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	eax, DWORD PTR [eax+932]
	cmp	DWORD PTR [eax+1592], 2
	jge	SHORT $LN6@SimWheelBr

; 3440 : 			{
; 3441 : 				SimDriver.GetPlayerAircraft()->af->thrustReverse += 1;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	add	ecx, 1592				; 00000638H
	mov	DWORD PTR tv91[ebp], ecx
	mov	edx, DWORD PTR tv91[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR tv91[ebp]
	mov	DWORD PTR [ecx], eax

; 3442 : 			}
; 3443 : 			else

	jmp	SHORT $LN5@SimWheelBr
$LN6@SimWheelBr:

; 3444 : 			{
; 3445 : 				SimDriver.GetPlayerAircraft()->af->thrustReverse = 0;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+932]
	mov	DWORD PTR [edx+1592], 0
$LN5@SimWheelBr:

; 3446 : 			}
; 3447 : 		thrrevtimer = 0;

	mov	DWORD PTR ?thrrevtimer@?1??SimWheelBrakes@@YAXKHPAX@Z@4KA, 0
$LN10@SimWheelBr:

; 3448 : 		}
; 3449 : 	}
; 3450 : 
; 3451 : 	// MD -- 20040106: adding support for analog wheel braking channel.
; 3452 : 	// Right now there is no support for differential braking!
; 3453 : 	if (IO.AnalogIsUsed(AXIS_BRAKE_LEFT))

	push	8
	mov	ecx, OFFSET ?IO@@3VSIMLIB_IO_CLASS@@A	; IO
	call	?AnalogIsUsed@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z ; SIMLIB_IO_CLASS::AnalogIsUsed
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@SimWheelBr

; 3454 : 		return;

	jmp	SHORT $LN11@SimWheelBr
$LN4@SimWheelBr:

; 3455 : 	
; 3456 :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN11@SimWheelBr
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN11@SimWheelBr

; 3457 :    {
; 3458 : 	   //TJL 01/05/04 JFS/Brake Accumulators have 75 seconds of brake power stored.
; 3459 : 	   //Removed the HydB condition as this is not realistic.
; 3460 : 	   //TODO: If HydB is 0 or Engine RPM <12% then 75 seconds of accumulator braking.
; 3461 :       //if (SimDriver.GetPlayerAircraft()->af->HydraulicB() == 0) return;
; 3462 :       if (state & KEY_DOWN && !SimDriver.GetPlayerAircraft()->af->IsSet(AirframeClass::GearBroken))

	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN2@SimWheelBr
	push	2048					; 00000800H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	jne	SHORT $LN2@SimWheelBr

; 3463 :          SimDriver.GetPlayerAircraft()->af->SetFlag(AirframeClass::WheelBrakes);

	push	8
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?SetFlag@AirframeClass@@QAEXH@Z		; AirframeClass::SetFlag

; 3464 :       else

	jmp	SHORT $LN11@SimWheelBr
$LN2@SimWheelBr:

; 3465 :          SimDriver.GetPlayerAircraft()->af->ClearFlag(AirframeClass::WheelBrakes);

	push	8
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?ClearFlag@AirframeClass@@QAEXH@Z	; AirframeClass::ClearFlag
$LN11@SimWheelBr:

; 3466 :    }
; 3467 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimWheelBrakes@@YAXKHPAX@Z ENDP			; SimWheelBrakes
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv95 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimEmergencyJettison@@YAXKHPAX@Z PROC			; SimEmergencyJettison

; 3603 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 3604 :  	if(SimDriver.GetPlayerAircraft() != NULL && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN1@SimEmergen
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN1@SimEmergen

; 3605 :  	{
; 3606 : 		if(!SimDriver.GetPlayerAircraft()->Sms || !SimDriver.GetPlayerAircraft()->Sms->drawable)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+940], 0
	je	SHORT $LN10@SimEmergen
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	eax, DWORD PTR [eax+940]
	cmp	DWORD PTR [eax+160], 0
	jne	SHORT $LN11@SimEmergen
$LN10@SimEmergen:

; 3607 : 			return;

	jmp	$LN13@SimEmergen
$LN11@SimEmergen:

; 3608 : 		//MI
; 3609 :  		if(g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN8@SimEmergen

; 3610 :  		{
; 3611 :  			//not if we're on the ground an our switch isn't set
; 3612 :  			if(SimDriver.GetPlayerAircraft()->OnGround() && 
; 3613 :  				SimDriver.GetPlayerAircraft()->Sms && !SimDriver.GetPlayerAircraft()->Sms->GndJett)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR tv95[ebp], eax
	mov	edx, DWORD PTR tv95[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv95[ebp]
	mov	edx, DWORD PTR [eax+148]
	call	edx
	test	eax, eax
	je	SHORT $LN8@SimEmergen
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+940], 0
	je	SHORT $LN8@SimEmergen
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	eax, DWORD PTR [eax+940]
	movzx	ecx, BYTE PTR [eax+13]
	test	ecx, ecx
	jne	SHORT $LN8@SimEmergen

; 3614 :  			{
; 3615 :  				return;

	jmp	$LN13@SimEmergen
$LN8@SimEmergen:

; 3616 :  			}
; 3617 : 		}
; 3618 :  		//Emergency Jettison is only happening if we hold the button more then 1 sec
; 3619 :  		//if(((AircraftClass *)SimDriver.GetPlayerAircraft())->EmerJettTriggered == FALSE)
; 3620 :  		{
; 3621 :  			if(state & KEY_DOWN)

	mov	edx, DWORD PTR _state$[ebp]
	and	edx, 8
	je	$LN7@SimEmergen

; 3622 :  			{
; 3623 :  				//MI
; 3624 :  				if(g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	$LN6@SimEmergen

; 3625 :  				{
; 3626 : 					//Set our display mode
; 3627 : 					if(MfdDisplay[1]->GetCurMode() != MFDClass::SMSMode || 
; 3628 : 						SimDriver.GetPlayerAircraft()->Sms->drawable->DisplayMode() != SmsDrawable::EmergJet)

	mov	ecx, 4
	shl	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?GetCurMode@MFDClass@@QAE?AW4MfdMode@1@XZ ; MFDClass::GetCurMode
	cmp	eax, 11					; 0000000bH
	jne	SHORT $LN4@SimEmergen
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+940]
	mov	ecx, DWORD PTR [edx+160]
	call	?DisplayMode@SmsDrawable@@QAE?AW4SmsDisplayMode@1@XZ ; SmsDrawable::DisplayMode
	cmp	eax, 4
	je	$LN3@SimEmergen
$LN4@SimEmergen:

; 3629 : 					{
; 3630 : 						MfdDisplay[0]->EmergStoreMode = MfdDisplay[0]->CurMode();

	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[eax]
	call	?CurMode@MFDClass@@QAE?AW4MfdMode@1@XZ	; MFDClass::CurMode
	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	mov	DWORD PTR [edx+128], eax

; 3631 : 						MfdDisplay[1]->EmergStoreMode = MfdDisplay[1]->CurMode();

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[eax]
	call	?CurMode@MFDClass@@QAE?AW4MfdMode@1@XZ	; MFDClass::CurMode
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	mov	DWORD PTR [edx+128], eax

; 3632 : 						MfdDisplay[1]->SetNewMode(MFDClass::SMSMode);

	push	11					; 0000000bH
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[eax]
	call	?SetNewMode@MFDClass@@QAEXW4MfdMode@1@@Z ; MFDClass::SetNewMode

; 3633 : 						if(SimDriver.GetPlayerAircraft()->Sms->drawable->DisplayMode() !=
; 3634 : 							SmsDrawable::EmergJet)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+940]
	mov	ecx, DWORD PTR [ecx+160]
	call	?DisplayMode@SmsDrawable@@QAE?AW4SmsDisplayMode@1@XZ ; SmsDrawable::DisplayMode
	cmp	eax, 4
	je	SHORT $LN3@SimEmergen

; 3635 : 						{
; 3636 : 							SimDriver.GetPlayerAircraft()->Sms->drawable->EmergStoreMode = 
; 3637 : 								SimDriver.GetPlayerAircraft()->Sms->drawable->DisplayMode();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+940]
	mov	ecx, DWORD PTR [edx+160]
	call	?DisplayMode@SmsDrawable@@QAE?AW4SmsDisplayMode@1@XZ ; SmsDrawable::DisplayMode
	mov	esi, eax
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	eax, DWORD PTR [eax+940]
	mov	ecx, DWORD PTR [eax+160]
	mov	DWORD PTR [ecx+200], esi

; 3638 : 
; 3639 : 							SimDriver.GetPlayerAircraft()->Sms->drawable->SetDisplayMode(
; 3640 : 								SmsDrawable::EmergJet);

	push	4
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+940]
	mov	ecx, DWORD PTR [edx+160]
	call	?SetDisplayMode@SmsDrawable@@QAEXW4SmsDisplayMode@1@@Z ; SmsDrawable::SetDisplayMode
$LN3@SimEmergen:

; 3641 : 						}
; 3642 : 					}
; 3643 : 					// Start the timer
; 3644 : 					((AircraftClass *)SimDriver.GetPlayerAircraft())->JettCountown = 1.0;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+1812], xmm0

; 3645 : 					((AircraftClass *)SimDriver.GetPlayerAircraft())->doJettCountdown = TRUE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	BYTE PTR [eax+1816], 1

; 3646 : 				}
; 3647 :  				else

	jmp	SHORT $LN2@SimEmergen
$LN6@SimEmergen:

; 3648 :  				{
; 3649 :  					SimDriver.GetPlayerAircraft()->Sms->EmergencyJettison();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+940]
	call	?EmergencyJettison@SMSClass@@QAEXXZ	; SMSClass::EmergencyJettison
$LN2@SimEmergen:

; 3650 :  				}
; 3651 :  			}
; 3652 :  			else

	jmp	SHORT $LN1@SimEmergen
$LN7@SimEmergen:

; 3653 :  			{
; 3654 : 				MfdDisplay[1]->SetNewMode(MfdDisplay[1]->EmergStoreMode);

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[eax]
	mov	edx, DWORD PTR [ecx+128]
	push	edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[eax]
	call	?SetNewMode@MFDClass@@QAEXW4MfdMode@1@@Z ; MFDClass::SetNewMode

; 3655 : 				SimDriver.GetPlayerAircraft()->Sms->drawable->SetDisplayMode(
; 3656 : 					SimDriver.GetPlayerAircraft()->Sms->drawable->EmergStoreMode);

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+940]
	mov	edx, DWORD PTR [ecx+160]
	mov	eax, DWORD PTR [edx+200]
	push	eax
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+940]
	mov	ecx, DWORD PTR [ecx+160]
	call	?SetDisplayMode@SmsDrawable@@QAEXW4SmsDisplayMode@1@@Z ; SmsDrawable::SetDisplayMode

; 3657 : 				// Cancel the timer
; 3658 :  				((AircraftClass *)SimDriver.GetPlayerAircraft())->doJettCountdown = FALSE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	BYTE PTR [eax+1816], 0
$LN1@SimEmergen:
$LN13@SimEmergen:

; 3659 :  			}
; 3660 :  		}
; 3661 :  	}
; 3662 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?SimEmergencyJettison@@YAXKHPAX@Z ENDP			; SimEmergencyJettison
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimSelectiveJettison@@YAXKHPAX@Z PROC			; SimSelectiveJettison

; 3594 : {

	push	ebp
	mov	ebp, esp

; 3595 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimSelecti
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimSelecti
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimSelecti

; 3596 : 	{
; 3597 : 	if (SimDriver.GetPlayerAircraft()->Sms && SimDriver.GetPlayerAircraft()->Sms->drawable)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+940], 0
	je	SHORT $LN3@SimSelecti
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+940]
	cmp	DWORD PTR [ecx+160], 0
	je	SHORT $LN3@SimSelecti

; 3598 :          SimDriver.GetPlayerAircraft()->Sms->drawable->SetDisplayMode(SmsDrawable::SelJet);

	push	3
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+940]
	mov	ecx, DWORD PTR [edx+160]
	call	?SetDisplayMode@SmsDrawable@@QAEXW4SmsDisplayMode@1@@Z ; SmsDrawable::SetDisplayMode
$LN3@SimSelecti:

; 3599 : 	}
; 3600 : }

	pop	ebp
	ret	0
?SimSelectiveJettison@@YAXKHPAX@Z ENDP			; SimSelectiveJettison
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?ACMIToggleRecording@@YAXKHPAX@Z PROC			; ACMIToggleRecording

; 3587 : {

	push	ebp
	mov	ebp, esp

; 3588 :    if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@ACMIToggle

; 3589 : 	  SimDriver.doFile = TRUE;

	mov	DWORD PTR ?SimDriver@@3VSimulationDriver@@A+40, 1
$LN2@ACMIToggle:

; 3590 : }

	pop	ebp
	ret	0
?ACMIToggleRecording@@YAXKHPAX@Z ENDP			; ACMIToggleRecording
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?FOVDefault@@YAXKHPAX@Z PROC				; FOVDefault

; 3561 : {

	push	ebp
	mov	ebp, esp

; 3562 :    if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN1@FOVDefault

; 3563 :    {
; 3564 : 			if (OTWDriver.GetOTWDisplayMode() == OTWDriverClass::Mode3DCockpit)

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetOTWDisplayMode@OTWDriverClass@@QAE?AW4OTWDisplayMode@1@XZ ; OTWDriverClass::GetOTWDisplayMode
	cmp	eax, 3
	jne	SHORT $LN2@FOVDefault

; 3565 : 			{
; 3566 : 				narrowFOV = FALSE;

	mov	DWORD PTR ?narrowFOV@@3HA, 0		; narrowFOV

; 3567 : 				OTWDriver.ViewReset();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?ViewReset@OTWDriverClass@@QAEXXZ	; OTWDriverClass::ViewReset

; 3568 : 				OTWDriver.SetCameraPanTilt(0.0f, (g_f3DHeadTilt * DTR));

	movss	xmm0, DWORD PTR ?g_f3DHeadTilt@@3MA
	mulss	xmm0, DWORD PTR __real@3c8efa34
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?SetCameraPanTilt@OTWDriverClass@@QAEXMM@Z ; OTWDriverClass::SetCameraPanTilt

; 3569 : 				OTWDriver.SetFOV( g_f3DPitFOV * DTR ); // Cobra

	movss	xmm0, DWORD PTR ?g_f3DPitFOV@@3MA
	mulss	xmm0, DWORD PTR __real@3c8efa34
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?SetFOV@OTWDriverClass@@QAEXM@Z		; OTWDriverClass::SetFOV

; 3570 : 			}
; 3571 : 			else

	jmp	SHORT $LN1@FOVDefault
$LN2@FOVDefault:

; 3572 : 			{
; 3573 : 				narrowFOV = FALSE;

	mov	DWORD PTR ?narrowFOV@@3HA, 0		; narrowFOV

; 3574 : 				OTWDriver.SetFOV( g_fDefaultFOV * DTR );		//Wombat778 10-31-2003 changed to default FOV

	movss	xmm0, DWORD PTR ?g_fDefaultFOV@@3MA
	mulss	xmm0, DWORD PTR __real@3c8efa34
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?SetFOV@OTWDriverClass@@QAEXM@Z		; OTWDriverClass::SetFOV
$LN1@FOVDefault:

; 3575 : 			}
; 3576 :    }
; 3577 : }

	pop	ebp
	ret	0
?FOVDefault@@YAXKHPAX@Z ENDP				; FOVDefault
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv132 = -12						; size = 4
tv94 = -8						; size = 4
tv89 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?FOVIncrease@@YAXKHPAX@Z PROC				; FOVIncrease

; 3544 : {													

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 3545 :    if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN1@FOVIncreas

; 3546 :    {
; 3547 : 	   if (OTWDriver.GetFOV() <= (g_fMaximumFOV - g_fFOVIncrement) * DTR)		//10/11/03 Ensure that we never set the FOV to greater than the max

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetFOV@OTWDriverClass@@QAEMXZ		; OTWDriverClass::GetFOV
	fstp	DWORD PTR tv89[ebp]
	movss	xmm0, DWORD PTR ?g_fMaximumFOV@@3MA
	subss	xmm0, DWORD PTR ?g_fFOVIncrement@@3MA
	mulss	xmm0, DWORD PTR __real@3c8efa34
	comiss	xmm0, DWORD PTR tv89[ebp]
	jb	$LN1@FOVIncreas

; 3548 : 	   {
; 3549 : 				narrowFOV = TRUE;								

	mov	DWORD PTR ?narrowFOV@@3HA, 1		; narrowFOV

; 3550 : 				OTWDriver.SetFOV( OTWDriver.GetFOV()  + (g_fFOVIncrement * DTR ) );

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetFOV@OTWDriverClass@@QAEMXZ		; OTWDriverClass::GetFOV
	fstp	DWORD PTR tv94[ebp]
	movss	xmm0, DWORD PTR tv94[ebp]
	movss	xmm1, DWORD PTR ?g_fFOVIncrement@@3MA
	mulss	xmm1, DWORD PTR __real@3c8efa34
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?SetFOV@OTWDriverClass@@QAEXM@Z		; OTWDriverClass::SetFOV

; 3551 : 		 
; 3552 : 				if (OTWDriver.GetFOV() == g_fDefaultFOV * DTR)			//Wombat778 10-31-2003 changed to Default FOV //set narrowFOV to false if we are back to the default FOV

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetFOV@OTWDriverClass@@QAEMXZ		; OTWDriverClass::GetFOV
	fstp	DWORD PTR tv132[ebp]
	movss	xmm0, DWORD PTR tv132[ebp]
	movss	xmm1, DWORD PTR ?g_fDefaultFOV@@3MA
	mulss	xmm1, DWORD PTR __real@3c8efa34
	ucomiss	xmm0, xmm1
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@FOVIncreas

; 3553 : 					narrowFOV = FALSE;

	mov	DWORD PTR ?narrowFOV@@3HA, 0		; narrowFOV

; 3554 : 				else

	jmp	SHORT $LN1@FOVIncreas
$LN2@FOVIncreas:

; 3555 : 					narrowFOV = TRUE;

	mov	DWORD PTR ?narrowFOV@@3HA, 1		; narrowFOV
$LN1@FOVIncreas:

; 3556 : 	   }
; 3557 :    }
; 3558 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FOVIncrease@@YAXKHPAX@Z ENDP				; FOVIncrease
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv132 = -12						; size = 4
tv94 = -8						; size = 4
tv89 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?FOVDecrease@@YAXKHPAX@Z PROC				; FOVDecrease

; 3527 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 3528 :    if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN1@FOVDecreas

; 3529 :    {
; 3530 :       if (OTWDriver.GetFOV() > (g_fMinimumFOV + g_fFOVIncrement) * DTR)	//Added g_fMinimumFOV //Ensure that we never set the FOV to 0 or less

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetFOV@OTWDriverClass@@QAEMXZ		; OTWDriverClass::GetFOV
	fstp	DWORD PTR tv89[ebp]
	movss	xmm0, DWORD PTR tv89[ebp]
	movss	xmm1, DWORD PTR ?g_fMinimumFOV@@3MA
	addss	xmm1, DWORD PTR ?g_fFOVIncrement@@3MA
	mulss	xmm1, DWORD PTR __real@3c8efa34
	comiss	xmm0, xmm1
	jbe	SHORT $LN1@FOVDecreas

; 3531 :       {
; 3532 :          OTWDriver.SetFOV( OTWDriver.GetFOV()  - (g_fFOVIncrement * DTR ) );

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetFOV@OTWDriverClass@@QAEMXZ		; OTWDriverClass::GetFOV
	fstp	DWORD PTR tv94[ebp]
	movss	xmm0, DWORD PTR tv94[ebp]
	movss	xmm1, DWORD PTR ?g_fFOVIncrement@@3MA
	mulss	xmm1, DWORD PTR __real@3c8efa34
	subss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?SetFOV@OTWDriverClass@@QAEXM@Z		; OTWDriverClass::SetFOV

; 3533 : 		 
; 3534 : 				if (OTWDriver.GetFOV() == g_fDefaultFOV * DTR)	//Wombat778 10-31-2003 changed to default FOV  //set narrowFOV to false if we are back to the default FOV

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetFOV@OTWDriverClass@@QAEMXZ		; OTWDriverClass::GetFOV
	fstp	DWORD PTR tv132[ebp]
	movss	xmm0, DWORD PTR tv132[ebp]
	movss	xmm1, DWORD PTR ?g_fDefaultFOV@@3MA
	mulss	xmm1, DWORD PTR __real@3c8efa34
	ucomiss	xmm0, xmm1
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@FOVDecreas

; 3535 : 					narrowFOV = FALSE;

	mov	DWORD PTR ?narrowFOV@@3HA, 0		; narrowFOV

; 3536 : 				else

	jmp	SHORT $LN1@FOVDecreas
$LN2@FOVDecreas:

; 3537 : 					narrowFOV = TRUE;

	mov	DWORD PTR ?narrowFOV@@3HA, 1		; narrowFOV
$LN1@FOVDecreas:

; 3538 :    
; 3539 :       }
; 3540 :    }
; 3541 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FOVDecrease@@YAXKHPAX@Z ENDP				; FOVDecrease
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv91 = -8						; size = 4
tv85 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?FOVToggle@@YAXKHPAX@Z PROC				; FOVToggle

; 3507 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3508 :    if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN1@FOVToggle

; 3509 :    {
; 3510 : 			if (fabs(OTWDriver.GetFOV() -  ( g_fDefaultFOV * DTR)) < 1.0f * DTR ) 	

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetFOV@OTWDriverClass@@QAEMXZ		; OTWDriverClass::GetFOV
	fstp	DWORD PTR tv85[ebp]
	movss	xmm0, DWORD PTR tv85[ebp]
	movss	xmm1, DWORD PTR ?g_fDefaultFOV@@3MA
	mulss	xmm1, DWORD PTR __real@3c8efa34
	subss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv91[ebp]
	movss	xmm0, DWORD PTR __real@3c8efa34
	comiss	xmm0, DWORD PTR tv91[ebp]
	jbe	SHORT $LN2@FOVToggle

; 3511 : 												//Wombat778 2/19/03 changed to so that minor differences in FOV will be allowed 10/31/2003 changed to g_fDefaultFOV 
; 3512 : 				                //Wombat778 Original "> 30.0F"  9-27-2003  This change will set the FOV to 20 
; 3513 : 												//degrees when it is at 60, and will set it to 60, whenever it is not at 60;
; 3514 :       {
; 3515 :          narrowFOV = TRUE;

	mov	DWORD PTR ?narrowFOV@@3HA, 1		; narrowFOV

; 3516 :          OTWDriver.SetFOV( g_fNarrowFOV * DTR );		//Wombat778 2-21-2004  Changed to g_fNarrowFov

	movss	xmm0, DWORD PTR ?g_fNarrowFOV@@3MA
	mulss	xmm0, DWORD PTR __real@3c8efa34
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?SetFOV@OTWDriverClass@@QAEXM@Z		; OTWDriverClass::SetFOV

; 3517 :       }
; 3518 :       else

	jmp	SHORT $LN1@FOVToggle
$LN2@FOVToggle:

; 3519 :       {
; 3520 :          narrowFOV = FALSE;

	mov	DWORD PTR ?narrowFOV@@3HA, 0		; narrowFOV

; 3521 :          OTWDriver.SetFOV( g_fDefaultFOV * DTR );		//Wombat778 10-31-2003 changed to default FOV

	movss	xmm0, DWORD PTR ?g_fDefaultFOV@@3MA
	mulss	xmm0, DWORD PTR __real@3c8efa34
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?SetFOV@OTWDriverClass@@QAEXM@Z		; OTWDriverClass::SetFOV
$LN1@FOVToggle:

; 3522 :       }
; 3523 :    }
; 3524 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FOVToggle@@YAXKHPAX@Z ENDP				; FOVToggle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?PrettyScreenShot@@YAXKHPAX@Z PROC			; PrettyScreenShot

; 3492 : {

	push	ebp
	mov	ebp, esp

; 3493 :    if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@PrettyScre

; 3494 :    {
; 3495 : 	   // my little screen shot state machine.. see OTWDriver.h
; 3496 : 	   if (OTWDriver.takePrettyScreenShot == OTWDriverClass::OFF)

	cmp	DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+32032, 0
	jne	SHORT $LN3@PrettyScre

; 3497 : 	   {
; 3498 : 		  OTWDriver.takePrettyScreenShot = OTWDriverClass::EXECUTE;

	mov	DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+32032, 1

; 3499 : 		  // note state labels, deactivate them for shot
; 3500 : 		  OTWDriver.LabelState = DrawableBSP::drawLabels;

	mov	ecx, DWORD PTR ?drawLabels@DrawableBSP@@2HA ; DrawableBSP::drawLabels
	mov	DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+32036, ecx

; 3501 : 		  DrawableBSP::drawLabels = FALSE;

	mov	DWORD PTR ?drawLabels@DrawableBSP@@2HA, 0 ; DrawableBSP::drawLabels
$LN3@PrettyScre:

; 3502 : 	   }
; 3503 :    }
; 3504 : }

	pop	ebp
	ret	0
?PrettyScreenShot@@YAXKHPAX@Z ENDP			; PrettyScreenShot
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?ScreenShot@@YAXKHPAX@Z PROC				; ScreenShot

; 3484 : {

	push	ebp
	mov	ebp, esp

; 3485 : 	if (state & KEY_DOWN){

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@ScreenShot

; 3486 : 		OTWDriver.takeScreenShot = TRUE;

	mov	DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+32028, 1
$LN2@ScreenShot:

; 3487 : 	}
; 3488 : }

	pop	ebp
	ret	0
?ScreenShot@@YAXKHPAX@Z ENDP				; ScreenShot
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimMotionFreeze@@YAXKHPAX@Z PROC			; SimMotionFreeze

; 3470 : {

	push	ebp
	mov	ebp, esp

; 3471 : 	if (
; 3472 : 		(state & KEY_DOWN) && 
; 3473 : 		(SimDriver.GetPlayerAircraft()) && 
; 3474 : 		(SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP))
; 3475 : 	){

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimMotionF
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimMotionF
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimMotionF

; 3476 : 		SimDriver.SetMotion(1 - SimDriver.MotionOn());

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?MotionOn@SimulationDriver@@QAEHXZ	; SimulationDriver::MotionOn
	mov	ecx, 1
	sub	ecx, eax
	push	ecx
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?SetMotion@SimulationDriver@@QAEXH@Z	; SimulationDriver::SetMotion

; 3477 : 		SetTimeCompression(1);

	push	1
	call	?SetTimeCompression@@YAXH@Z		; SetTimeCompression
	add	esp, 4

; 3478 : 		F4HearVoices();

	call	_F4HearVoices
$LN2@SimMotionF:

; 3479 : 	}
; 3480 : }

	pop	ebp
	ret	0
?SimMotionFreeze@@YAXKHPAX@Z ENDP			; SimMotionFreeze
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimToggleChatMode@@YAXKHPAX@Z PROC			; SimToggleChatMode

; 3376 : {

	push	ebp
	mov	ebp, esp

; 3377 :    if (SimDriver.GetPlayerAircraft())

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft

; 3378 :    {
; 3379 : //	   F4ChatToggleXmitReceive();
; 3380 :    }
; 3381 : }

	pop	ebp
	ret	0
?SimToggleChatMode@@YAXKHPAX@Z ENDP			; SimToggleChatMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTW900View@@YAXKHPAX@Z PROC				; OTW900View

; 3363 : void OTW900View(unsigned long, int state, void*){

	push	ebp
	mov	ebp, esp

; 3364 :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)) {

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@OTW900View
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@OTW900View
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@OTW900View

; 3365 : 		OTWDriver.pCockpitManager->SetActivePanel(900);	//106 = id for 9:00 panel

	push	900					; 00000384H
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	call	?SetActivePanel@CockpitManager@@QAE_NH@Z ; CockpitManager::SetActivePanel
$LN2@OTW900View:

; 3366 : 	}
; 3367 : }

	pop	ebp
	ret	0
?OTW900View@@YAXKHPAX@Z ENDP				; OTW900View
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTW800View@@YAXKHPAX@Z PROC				; OTW800View

; 3357 : void OTW800View(unsigned long, int state, void*){

	push	ebp
	mov	ebp, esp

; 3358 :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)) {

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@OTW800View
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@OTW800View
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@OTW800View

; 3359 : 		OTWDriver.pCockpitManager->SetActivePanel(800);	//105 = id for 8:00 panel

	push	800					; 00000320H
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	call	?SetActivePanel@CockpitManager@@QAE_NH@Z ; CockpitManager::SetActivePanel
$LN2@OTW800View:

; 3360 : 	}
; 3361 : }

	pop	ebp
	ret	0
?OTW800View@@YAXKHPAX@Z ENDP				; OTW800View
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTW400View@@YAXKHPAX@Z PROC				; OTW400View

; 3351 : void OTW400View(unsigned long, int state, void*){

	push	ebp
	mov	ebp, esp

; 3352 :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)) {

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@OTW400View
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@OTW400View
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@OTW400View

; 3353 : 		OTWDriver.pCockpitManager->SetActivePanel(400);	//104 = id for 4:00 panel

	push	400					; 00000190H
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	call	?SetActivePanel@CockpitManager@@QAE_NH@Z ; CockpitManager::SetActivePanel
$LN2@OTW400View:

; 3354 : 	}
; 3355 : }

	pop	ebp
	ret	0
?OTW400View@@YAXKHPAX@Z ENDP				; OTW400View
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTW300View@@YAXKHPAX@Z PROC				; OTW300View

; 3344 : {

	push	ebp
	mov	ebp, esp

; 3345 :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)) 

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@OTW300View
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@OTW300View
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@OTW300View

; 3346 :    {
; 3347 : 		OTWDriver.pCockpitManager->SetActivePanel(300);	//103 = id for 3:00 panel

	push	300					; 0000012cH
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	call	?SetActivePanel@CockpitManager@@QAE_NH@Z ; CockpitManager::SetActivePanel
$LN2@OTW300View:

; 3348 :    } 
; 3349 : }

	pop	ebp
	ret	0
?OTW300View@@YAXKHPAX@Z ENDP				; OTW300View
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTW200View@@YAXKHPAX@Z PROC				; OTW200View

; 3336 : void OTW200View(unsigned long, int state, void*){

	push	ebp
	mov	ebp, esp

; 3337 : 	if ((state & KEY_DOWN) && (SimDriver.GetPlayerAircraft()) && (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)))

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@OTW200View
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@OTW200View
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@OTW200View

; 3338 : 	{
; 3339 : 		OTWDriver.pCockpitManager->SetActivePanel(200);	//102 = id for 2:00 panel

	push	200					; 000000c8H
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	call	?SetActivePanel@CockpitManager@@QAE_NH@Z ; CockpitManager::SetActivePanel
$LN2@OTW200View:

; 3340 : 	}
; 3341 : }

	pop	ebp
	ret	0
?OTW200View@@YAXKHPAX@Z ENDP				; OTW200View
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTW1000View@@YAXKHPAX@Z PROC				; OTW1000View

; 3330 : void OTW1000View(unsigned long, int state, void*){

	push	ebp
	mov	ebp, esp

; 3331 :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)) {

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@OTW1000Vie
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@OTW1000Vie
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@OTW1000Vie

; 3332 : 		OTWDriver.pCockpitManager->SetActivePanel(500);	//101 = id for 10:00 panel

	push	500					; 000001f4H
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	call	?SetActivePanel@CockpitManager@@QAE_NH@Z ; CockpitManager::SetActivePanel
$LN2@OTW1000Vie:

; 3333 : 	}
; 3334 : }

	pop	ebp
	ret	0
?OTW1000View@@YAXKHPAX@Z ENDP				; OTW1000View
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTW1200RView@@YAXKHPAX@Z PROC				; OTW1200RView

; 3369 : void OTW1200RView(unsigned long, int state, void*){

	push	ebp
	mov	ebp, esp

; 3370 :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)) {

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@OTW1200RVi
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@OTW1200RVi
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@OTW1200RVi

; 3371 : 		OTWDriver.pCockpitManager->SetActivePanel(700);	//106 = id for 9:00 panel

	push	700					; 000002bcH
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	call	?SetActivePanel@CockpitManager@@QAE_NH@Z ; CockpitManager::SetActivePanel
$LN2@OTW1200RVi:

; 3372 : 	}
; 3373 : }

	pop	ebp
	ret	0
?OTW1200RView@@YAXKHPAX@Z ENDP				; OTW1200RView
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTW1200LView@@YAXKHPAX@Z PROC				; OTW1200LView

; 3324 : void OTW1200LView (unsigned long, int state, void*){

	push	ebp
	mov	ebp, esp

; 3325 :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)) {

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@OTW1200LVi
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@OTW1200LVi
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@OTW1200LVi

; 3326 : 		OTWDriver.pCockpitManager->SetActivePanel(600 );	//100 = id for 12:00 panel

	push	600					; 00000258H
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	call	?SetActivePanel@CockpitManager@@QAE_NH@Z ; CockpitManager::SetActivePanel
$LN2@OTW1200LVi:

; 3327 : 	}
; 3328 : }

	pop	ebp
	ret	0
?OTW1200LView@@YAXKHPAX@Z ENDP				; OTW1200LView
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTW1200HUDView@@YAXKHPAX@Z PROC			; OTW1200HUDView

; 3301 : void OTW1200HUDView (unsigned long, int state, void*){

	push	ebp
	mov	ebp, esp

; 3302 :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)) {

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@OTW1200HUD
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@OTW1200HUD
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@OTW1200HUD

; 3303 : 		OTWDriver.pCockpitManager->SetActivePanel(0);	//0 = id for 12:00 hud panel

	push	0
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	call	?SetActivePanel@CockpitManager@@QAE_NH@Z ; CockpitManager::SetActivePanel
$LN2@OTW1200HUD:

; 3304 : 	}
; 3305 : }

	pop	ebp
	ret	0
?OTW1200HUDView@@YAXKHPAX@Z ENDP			; OTW1200HUDView
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTW1200DView@@YAXKHPAX@Z PROC				; OTW1200DView

; 3295 : void OTW1200DView (unsigned long, int state, void*){

	push	ebp
	mov	ebp, esp

; 3296 :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)) {

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@OTW1200DVi
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@OTW1200DVi
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@OTW1200DVi

; 3297 : 		OTWDriver.pCockpitManager->SetActivePanel(100);	//100 = id for 12:00 Down panel

	push	100					; 00000064H
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	call	?SetActivePanel@CockpitManager@@QAE_NH@Z ; CockpitManager::SetActivePanel
$LN2@OTW1200DVi:

; 3298 : 	}
; 3299 : }

	pop	ebp
	ret	0
?OTW1200DView@@YAXKHPAX@Z ENDP				; OTW1200DView
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTW1200View@@YAXKHPAX@Z PROC				; OTW1200View

; 3308 : {

	push	ebp
	mov	ebp, esp

; 3309 :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)) 

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN6@OTW1200Vie
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN6@OTW1200Vie
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN6@OTW1200Vie

; 3310 :    {
; 3311 : 	   //MI check for nightlighting
; 3312 : 	   if(SimDriver.GetPlayerAircraft())

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@OTW1200Vie

; 3313 : 	   {
; 3314 : 		   if(SimDriver.GetPlayerAircraft()->WideView)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	movzx	ecx, BYTE PTR [eax+1818]
	test	ecx, ecx
	je	SHORT $LN3@OTW1200Vie

; 3315 : 			   OTWDriver.pCockpitManager->SetActivePanel(91100);

	push	91100					; 000163dcH
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	call	?SetActivePanel@CockpitManager@@QAE_NH@Z ; CockpitManager::SetActivePanel

; 3316 : 		   else

	jmp	SHORT $LN2@OTW1200Vie
$LN3@OTW1200Vie:

; 3317 : 			   OTWDriver.pCockpitManager->SetActivePanel(1100);

	push	1100					; 0000044cH
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	call	?SetActivePanel@CockpitManager@@QAE_NH@Z ; CockpitManager::SetActivePanel
$LN2@OTW1200Vie:

; 3318 : 	   }
; 3319 : 	   else

	jmp	SHORT $LN6@OTW1200Vie
$LN4@OTW1200Vie:

; 3320 : 		   OTWDriver.pCockpitManager->SetActivePanel(1100);	//1100 = id for 12:00 50-50 panel

	push	1100					; 0000044cH
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	call	?SetActivePanel@CockpitManager@@QAE_NH@Z ; CockpitManager::SetActivePanel
$LN6@OTW1200Vie:

; 3321 : 	}
; 3322 : }

	pop	ebp
	ret	0
?OTW1200View@@YAXKHPAX@Z ENDP				; OTW1200View
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv95 = -12						; size = 4
tv81 = -8						; size = 4
_pac$ = -4						; size = 4
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimRegen@@YAXKHPAX@Z PROC				; SimRegen

; 10502: {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 10503: 	AircraftClass *pac = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _pac$[ebp], eax

; 10504: 	if(state & KEY_DOWN && pac){

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN3@SimRegen
	cmp	DWORD PTR _pac$[ebp], 0
	je	$LN3@SimRegen

; 10505: 		if (FalconLocalGame && FalconLocalGame->GetGameType() == game_Dogfight) {

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@SimRegen
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv81[ebp], eax
	jmp	SHORT $LN6@SimRegen
$LN5@SimRegen:
	mov	DWORD PTR tv81[ebp], 0
$LN6@SimRegen:
	cmp	DWORD PTR tv81[ebp], 0
	je	SHORT $LN3@SimRegen
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN7@SimRegen
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv95[ebp], eax
	jmp	SHORT $LN8@SimRegen
$LN7@SimRegen:
	mov	DWORD PTR tv95[ebp], 0
$LN8@SimRegen:
	mov	ecx, DWORD PTR tv95[ebp]
	call	?GetGameType@FalconGameEntity@@QAE?AW4FalconGameType@@XZ ; FalconGameEntity::GetGameType
	cmp	eax, 2
	jne	SHORT $LN3@SimRegen

; 10506: 			pac->SetFalcFlag(FEC_REGENERATING);

	push	8
	mov	ecx, DWORD PTR _pac$[ebp]
	call	?SetFalcFlag@FalconEntity@@QAEXH@Z	; FalconEntity::SetFalcFlag

; 10507: 			pac->SetDead(1);

	push	1
	mov	eax, DWORD PTR _pac$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pac$[ebp]
	mov	eax, DWORD PTR [edx+364]
	call	eax
$LN3@SimRegen:

; 10508: 		}
; 10509: 	}
; 10510: }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimRegen@@YAXKHPAX@Z ENDP				; SimRegen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCATIII@@YAXKHPAX@Z PROC				; SimCATIII

; 3281 : {

	push	ebp
	mov	ebp, esp

; 3282 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimCATIII

; 3283 : 		return;

	jmp	$LN4@SimCATIII
$LN3@SimCATIII:

; 3284 : 
; 3285 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN) && SimDriver.GetPlayerAircraft()->Sms)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimCATIII
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimCATIII
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimCATIII
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+940], 0
	je	SHORT $LN4@SimCATIII

; 3286 : 	{
; 3287 : 		SimDriver.GetPlayerAircraft()->af->SetFlag(AirframeClass::CATLimiterIII);

	push	2097152					; 00200000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?SetFlag@AirframeClass@@QAEXH@Z		; AirframeClass::SetFlag

; 3288 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimCATIII

; 3289 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_STORES_CAT, 2);

	push	2
	push	138					; 0000008aH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimCATIII:

; 3290 : 	}
; 3291 : }

	pop	ebp
	ret	0
?SimCATIII@@YAXKHPAX@Z ENDP				; SimCATIII
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCATI@@YAXKHPAX@Z PROC				; SimCATI

; 3268 : {

	push	ebp
	mov	ebp, esp

; 3269 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimCATI

; 3270 : 		return;

	jmp	$LN4@SimCATI
$LN3@SimCATI:

; 3271 : 
; 3272 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN) && SimDriver.GetPlayerAircraft()->Sms)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimCATI
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimCATI
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimCATI
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+940], 0
	je	SHORT $LN4@SimCATI

; 3273 : 	{
; 3274 : 		SimDriver.GetPlayerAircraft()->af->ClearFlag(AirframeClass::CATLimiterIII);

	push	2097152					; 00200000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?ClearFlag@AirframeClass@@QAEXH@Z	; AirframeClass::ClearFlag

; 3275 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimCATI

; 3276 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_STORES_CAT, 1);

	push	1
	push	138					; 0000008aH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimCATI:

; 3277 : 	}
; 3278 : }

	pop	ebp
	ret	0
?SimCATI@@YAXKHPAX@Z ENDP				; SimCATI
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_playerAC$ = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCATSwitch@@YAXKHPAX@Z PROC				; SimCATSwitch

; 3249 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 3250 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 3251 : 	if (playerAC && playerAC->IsSetFlag(MOTION_OWNSHIP) &&  (state & KEY_DOWN) &&  playerAC->Sms){

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	$LN5@SimCATSwit
	push	65536					; 00010000H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN5@SimCATSwit
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN5@SimCATSwit
	mov	ecx, DWORD PTR _playerAC$[ebp]
	cmp	DWORD PTR [ecx+940], 0
	je	SHORT $LN5@SimCATSwit

; 3252 : 		// MI Changed to what we have before, so everything works like before
; 3253 : 		// SimDriver.GetPlayerAircraft()->Sms->ChooseLimiterMode(127); // 127 means check Cat config
; 3254 : 		SimDriver.GetPlayerAircraft()->Sms->StepCatIII();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+940]
	call	?StepCatIII@SMSBaseClass@@QAEXXZ	; SMSBaseClass::StepCatIII

; 3255 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN5@SimCATSwit

; 3256 : 		{
; 3257 : 			if(SimDriver.GetPlayerAircraft()->af->IsSet(AirframeClass::CATLimiterIII))

	push	2097152					; 00200000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN2@SimCATSwit

; 3258 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_STORES_CAT, 2);

	push	2
	push	138					; 0000008aH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 3259 : 			else

	jmp	SHORT $LN5@SimCATSwit
$LN2@SimCATSwit:

; 3260 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_STORES_CAT, 1);

	push	1
	push	138					; 0000008aH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN5@SimCATSwit:

; 3261 : 		}
; 3262 : 	}
; 3263 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimCATSwitch@@YAXKHPAX@Z ENDP				; SimCATSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimDriftCOOff@@YAXKHPAX@Z PROC				; SimDriftCOOff

; 3234 : {

	push	ebp
	mov	ebp, esp

; 3235 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimDriftCO

; 3236 : 		return;

	jmp	SHORT $LN4@SimDriftCO
$LN3@SimDriftCO:

; 3237 : 	if (state & KEY_DOWN && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) // 2002-02-15 MODIFIED BY S.G. Only valid when not ejected

	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimDriftCO
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimDriftCO

; 3238 : 	{
; 3239 : 		TheHud->SetDriftCOSwitch(HudClass::DRIFT_CO_OFF);

	push	0
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?SetDriftCOSwitch@HudClass@@QAEXW4DriftCOSwitch@1@@Z ; HudClass::SetDriftCOSwitch

; 3240 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimDriftCO

; 3241 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_ICP_DRIFTCO, 1);

	push	1
	push	129					; 00000081H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimDriftCO:

; 3242 : 	}
; 3243 : }

	pop	ebp
	ret	0
?SimDriftCOOff@@YAXKHPAX@Z ENDP				; SimDriftCOOff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimDriftCOOn@@YAXKHPAX@Z PROC				; SimDriftCOOn

; 3222 : {

	push	ebp
	mov	ebp, esp

; 3223 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimDriftCO

; 3224 : 		return;

	jmp	SHORT $LN4@SimDriftCO
$LN3@SimDriftCO:

; 3225 : 	if (state & KEY_DOWN && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) // 2002-02-15 MODIFIED BY S.G. Only valid when not ejected

	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimDriftCO
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimDriftCO

; 3226 : 	{
; 3227 : 		TheHud->SetDriftCOSwitch(HudClass::DRIFT_CO_ON);

	push	1
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?SetDriftCOSwitch@HudClass@@QAEXW4DriftCOSwitch@1@@Z ; HudClass::SetDriftCOSwitch

; 3228 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimDriftCO

; 3229 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_ICP_DRIFTCO, 2);

	push	2
	push	129					; 00000081H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimDriftCO:

; 3230 : 	}
; 3231 : }

	pop	ebp
	ret	0
?SimDriftCOOn@@YAXKHPAX@Z ENDP				; SimDriftCOOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimDriftCO@@YAXKHPAX@Z PROC				; SimDriftCO

; 3206 : {

	push	ebp
	mov	ebp, esp

; 3207 : 	if (state & KEY_DOWN && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) // 2002-02-15 MODIFIED BY S.G. Only valid when not ejected

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimDriftCO
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimDriftCO

; 3208 : 	{
; 3209 : 		TheHud->CycleDriftCOSwitch();

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?CycleDriftCOSwitch@HudClass@@QAEXXZ	; HudClass::CycleDriftCOSwitch

; 3210 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN3@SimDriftCO

; 3211 : 			//OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_ICP_DRIFTCO, TheHud->GetDriftCOSwitch()+1);
; 3212 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_ICP_DRIFTCO, 1<<TheHud->GetDriftCOSwitch());

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?GetDriftCOSwitch@HudClass@@QAEHXZ	; HudClass::GetDriftCOSwitch
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	push	edx
	push	129					; 00000081H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN3@SimDriftCO:

; 3213 : 	}
; 3214 : }

	pop	ebp
	ret	0
?SimDriftCO@@YAXKHPAX@Z ENDP				; SimDriftCO
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SuperCruise@@YAXKHPAX@Z PROC				; SuperCruise

; 3197 : {

	push	ebp
	mov	ebp, esp

; 3198 : 	if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SuperCruis

; 3199 : 	{
; 3200 : 		supercruise = 1 - supercruise;

	mov	ecx, 1
	sub	ecx, DWORD PTR ?supercruise@@3HA	; supercruise
	mov	DWORD PTR ?supercruise@@3HA, ecx	; supercruise
$LN2@SuperCruis:

; 3201 : 	}
; 3202 : }

	pop	ebp
	ret	0
?SuperCruise@@YAXKHPAX@Z ENDP				; SuperCruise
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?KevinsFistOfGod@@YAXKHPAX@Z PROC			; KevinsFistOfGod

; 3191 : {

	push	ebp
	mov	ebp, esp

; 3192 : 	if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@KevinsFist

; 3193 : 		RequestPlayerDivert();

	call	?RequestPlayerDivert@@YAXXZ		; RequestPlayerDivert
$LN2@KevinsFist:

; 3194 : }

	pop	ebp
	ret	0
?KevinsFistOfGod@@YAXKHPAX@Z ENDP			; KevinsFistOfGod
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?CommandsSetKeyCombo@@YAXKHPAX@Z PROC			; CommandsSetKeyCombo

; 3182 : {

	push	ebp
	mov	ebp, esp

; 3183 :    if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@CommandsSe

; 3184 :    {
; 3185 :       CommandsKeyCombo = val;

	mov	ecx, DWORD PTR _val$[ebp]
	mov	DWORD PTR ?CommandsKeyCombo@@3HA, ecx	; CommandsKeyCombo

; 3186 :       CommandsKeyComboMod = state & MODS_MASK;

	mov	edx, DWORD PTR _state$[ebp]
	and	edx, 7
	mov	DWORD PTR ?CommandsKeyComboMod@@3HA, edx ; CommandsKeyComboMod
$LN2@CommandsSe:

; 3187 :    }
; 3188 : }

	pop	ebp
	ret	0
?CommandsSetKeyCombo@@YAXKHPAX@Z ENDP			; CommandsSetKeyCombo
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWStateStep@@YAXKHPAX@Z PROC				; OTWStateStep

; 3175 : {

	push	ebp
	mov	ebp, esp

; 3176 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) // 2002-02-15 MODIFIED BY S.G. ToggleEyeFly brings you to another AC and can crash when you're ejected since your class isn't AircraftClass anymore

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@OTWStateSt
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@OTWStateSt

; 3177 :       OTWDriver.EyeFlyStateStep();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?EyeFlyStateStep@OTWDriverClass@@QAEXXZ	; OTWDriverClass::EyeFlyStateStep
$LN2@OTWStateSt:

; 3178 : }

	pop	ebp
	ret	0
?OTWStateStep@@YAXKHPAX@Z ENDP				; OTWStateStep
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWCheckSix@@YAXKHPAX@Z PROC				; OTWCheckSix

; 3168 : {

	push	ebp
	mov	ebp, esp

; 3169 : 	if ((SimDriver.GetPlayerAircraft()) && (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@OTWCheckSi
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@OTWCheckSi

; 3170 : 		OTWDriver.GlanceAft();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GlanceAft@OTWDriverClass@@QAEXXZ	; OTWDriverClass::GlanceAft
$LN2@OTWCheckSi:

; 3171 : }

	pop	ebp
	ret	0
?OTWCheckSix@@YAXKHPAX@Z ENDP				; OTWCheckSix
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWGlanceForward@@YAXKHPAX@Z PROC			; OTWGlanceForward

; 3162 : {

	push	ebp
	mov	ebp, esp

; 3163 : 	if ((SimDriver.GetPlayerAircraft()) && (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@OTWGlanceF
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@OTWGlanceF

; 3164 : 		OTWDriver.GlanceForward();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GlanceForward@OTWDriverClass@@QAEXXZ	; OTWDriverClass::GlanceForward
$LN2@OTWGlanceF:

; 3165 : }

	pop	ebp
	ret	0
?OTWGlanceForward@@YAXKHPAX@Z ENDP			; OTWGlanceForward
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWSwapMFDS@@YAXKHPAX@Z PROC				; OTWSwapMFDS

; 3156 : {

	push	ebp
	mov	ebp, esp

; 3157 :    if ((state & KEY_DOWN) && (SimDriver.GetPlayerAircraft()) && (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)))

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@OTWSwapMFD
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@OTWSwapMFD
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@OTWSwapMFD

; 3158 :       MFDSwapDisplays();

	call	?MFDSwapDisplays@@YAXXZ			; MFDSwapDisplays
$LN2@OTWSwapMFD:

; 3159 : }

	pop	ebp
	ret	0
?OTWSwapMFDS@@YAXKHPAX@Z ENDP				; OTWSwapMFDS
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWViewZoomOut@@YAXKHPAX@Z PROC			; OTWViewZoomOut

; 3143 : {

	push	ebp
	mov	ebp, esp

; 3144 :    if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@OTWViewZoo

; 3145 :    {
; 3146 :       OTWDriver.ViewZoomOut();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?ViewZoomOut@OTWDriverClass@@QAEXXZ	; OTWDriverClass::ViewZoomOut
$LN2@OTWViewZoo:

; 3147 : 	  /*
; 3148 : 	  ** edg: what is this?!
; 3149 : 	  ** leave it our becuase its causing a CRASH when ejected
; 3150 :       ((AircraftClass*)SimDriver.GetPlayerAircraft())->AddFault(1, (1 << theFault), 1, 0);
; 3151 : 	  */
; 3152 :    }
; 3153 : }

	pop	ebp
	ret	0
?OTWViewZoomOut@@YAXKHPAX@Z ENDP			; OTWViewZoomOut
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWViewZoomIn@@YAXKHPAX@Z PROC				; OTWViewZoomIn

; 3126 : {

	push	ebp
	mov	ebp, esp

; 3127 :    if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@OTWViewZoo

; 3128 :    {
; 3129 :       OTWDriver.ViewZoomIn();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?ViewZoomIn@OTWDriverClass@@QAEXXZ	; OTWDriverClass::ViewZoomIn
$LN2@OTWViewZoo:

; 3130 : 
; 3131 : 	  /*
; 3132 : 	  ** edg: what is this?!
; 3133 : 	  ** leave it our becuase its causing a CRASH when ejected
; 3134 :       theFault = theFault ++;
; 3135 :       if (theFault > 32)
; 3136 :          theFault = 0;
; 3137 :       MonoPrint ("Next fail %s\n", FaultClass::mpFSubSystemNames[theFault]);
; 3138 : 	  */
; 3139 :    }
; 3140 : }

	pop	ebp
	ret	0
?OTWViewZoomIn@@YAXKHPAX@Z ENDP				; OTWViewZoomIn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWViewReset@@YAXKHPAX@Z PROC				; OTWViewReset

; 3120 : {

	push	ebp
	mov	ebp, esp

; 3121 :    if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@OTWViewRes

; 3122 :       OTWDriver.ViewReset();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?ViewReset@OTWDriverClass@@QAEXXZ	; OTWDriverClass::ViewReset
$LN2@OTWViewRes:

; 3123 : }

	pop	ebp
	ret	0
?OTWViewReset@@YAXKHPAX@Z ENDP				; OTWViewReset
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWViewUpRight@@YAXKHPAX@Z PROC			; OTWViewUpRight

; 3044 : {

	push	ebp
	mov	ebp, esp

; 3045 :    if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@OTWViewUpR

; 3046 :    {
; 3047 :       OTWDriver.ViewTiltUp();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?ViewTiltUp@OTWDriverClass@@QAEXXZ	; OTWDriverClass::ViewTiltUp

; 3048 : 	  OTWDriver.ViewSpinRight();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?ViewSpinRight@OTWDriverClass@@QAEXXZ	; OTWDriverClass::ViewSpinRight

; 3049 : 	  }
; 3050 :    else

	jmp	SHORT $LN3@OTWViewUpR
$LN2@OTWViewUpR:

; 3051 :       OTWDriver.ViewTiltHold();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?ViewTiltHold@OTWDriverClass@@QAEXXZ	; OTWDriverClass::ViewTiltHold
$LN3@OTWViewUpR:

; 3052 : }

	pop	ebp
	ret	0
?OTWViewUpRight@@YAXKHPAX@Z ENDP			; OTWViewUpRight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWViewUpLeft@@YAXKHPAX@Z PROC				; OTWViewUpLeft

; 3055 : {

	push	ebp
	mov	ebp, esp

; 3056 :    if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@OTWViewUpL

; 3057 :    {
; 3058 :       OTWDriver.ViewTiltUp();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?ViewTiltUp@OTWDriverClass@@QAEXXZ	; OTWDriverClass::ViewTiltUp

; 3059 : 	  OTWDriver.ViewSpinLeft();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?ViewSpinLeft@OTWDriverClass@@QAEXXZ	; OTWDriverClass::ViewSpinLeft

; 3060 : 	  }
; 3061 :    else

	jmp	SHORT $LN3@OTWViewUpL
$LN2@OTWViewUpL:

; 3062 :       OTWDriver.ViewTiltHold();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?ViewTiltHold@OTWDriverClass@@QAEXXZ	; OTWDriverClass::ViewTiltHold
$LN3@OTWViewUpL:

; 3063 : }

	pop	ebp
	ret	0
?OTWViewUpLeft@@YAXKHPAX@Z ENDP				; OTWViewUpLeft
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWViewDownRight@@YAXKHPAX@Z PROC			; OTWViewDownRight

; 3066 : {

	push	ebp
	mov	ebp, esp

; 3067 :    if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@OTWViewDow

; 3068 :    {
; 3069 :       OTWDriver.ViewTiltDown();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?ViewTiltDown@OTWDriverClass@@QAEXXZ	; OTWDriverClass::ViewTiltDown

; 3070 : 	  OTWDriver.ViewSpinRight();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?ViewSpinRight@OTWDriverClass@@QAEXXZ	; OTWDriverClass::ViewSpinRight

; 3071 : 	  }
; 3072 :    else

	jmp	SHORT $LN3@OTWViewDow
$LN2@OTWViewDow:

; 3073 :       OTWDriver.ViewTiltHold();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?ViewTiltHold@OTWDriverClass@@QAEXXZ	; OTWDriverClass::ViewTiltHold
$LN3@OTWViewDow:

; 3074 : }

	pop	ebp
	ret	0
?OTWViewDownRight@@YAXKHPAX@Z ENDP			; OTWViewDownRight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWViewDownLeft@@YAXKHPAX@Z PROC			; OTWViewDownLeft

; 3077 : {

	push	ebp
	mov	ebp, esp

; 3078 :    if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@OTWViewDow

; 3079 :    {
; 3080 :       OTWDriver.ViewTiltDown();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?ViewTiltDown@OTWDriverClass@@QAEXXZ	; OTWDriverClass::ViewTiltDown

; 3081 : 	  OTWDriver.ViewSpinLeft();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?ViewSpinLeft@OTWDriverClass@@QAEXXZ	; OTWDriverClass::ViewSpinLeft

; 3082 : 	  }
; 3083 :    else

	jmp	SHORT $LN3@OTWViewDow
$LN2@OTWViewDow:

; 3084 :       OTWDriver.ViewTiltHold();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?ViewTiltHold@OTWDriverClass@@QAEXXZ	; OTWDriverClass::ViewTiltHold
$LN3@OTWViewDow:

; 3085 : }

	pop	ebp
	ret	0
?OTWViewDownLeft@@YAXKHPAX@Z ENDP			; OTWViewDownLeft
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWViewDown@@YAXKHPAX@Z PROC				; OTWViewDown

; 3096 : {

	push	ebp
	mov	ebp, esp

; 3097 :    if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@OTWViewDow

; 3098 :       OTWDriver.ViewTiltDown();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?ViewTiltDown@OTWDriverClass@@QAEXXZ	; OTWDriverClass::ViewTiltDown

; 3099 :    else

	jmp	SHORT $LN3@OTWViewDow
$LN2@OTWViewDow:

; 3100 :       OTWDriver.ViewTiltHold();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?ViewTiltHold@OTWDriverClass@@QAEXXZ	; OTWDriverClass::ViewTiltHold
$LN3@OTWViewDow:

; 3101 : }

	pop	ebp
	ret	0
?OTWViewDown@@YAXKHPAX@Z ENDP				; OTWViewDown
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWViewUp@@YAXKHPAX@Z PROC				; OTWViewUp

; 3088 : {

	push	ebp
	mov	ebp, esp

; 3089 :    if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@OTWViewUp

; 3090 :       OTWDriver.ViewTiltUp();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?ViewTiltUp@OTWDriverClass@@QAEXXZ	; OTWDriverClass::ViewTiltUp

; 3091 :    else

	jmp	SHORT $LN3@OTWViewUp
$LN2@OTWViewUp:

; 3092 :       OTWDriver.ViewTiltHold();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?ViewTiltHold@OTWDriverClass@@QAEXXZ	; OTWDriverClass::ViewTiltHold
$LN3@OTWViewUp:

; 3093 : }

	pop	ebp
	ret	0
?OTWViewUp@@YAXKHPAX@Z ENDP				; OTWViewUp
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWViewRight@@YAXKHPAX@Z PROC				; OTWViewRight

; 3112 : {

	push	ebp
	mov	ebp, esp

; 3113 :    if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@OTWViewRig

; 3114 :       OTWDriver.ViewSpinRight();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?ViewSpinRight@OTWDriverClass@@QAEXXZ	; OTWDriverClass::ViewSpinRight

; 3115 :    else

	jmp	SHORT $LN3@OTWViewRig
$LN2@OTWViewRig:

; 3116 :       OTWDriver.ViewSpinHold();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?ViewSpinHold@OTWDriverClass@@QAEXXZ	; OTWDriverClass::ViewSpinHold
$LN3@OTWViewRig:

; 3117 : }

	pop	ebp
	ret	0
?OTWViewRight@@YAXKHPAX@Z ENDP				; OTWViewRight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWViewLeft@@YAXKHPAX@Z PROC				; OTWViewLeft

; 3104 : {

	push	ebp
	mov	ebp, esp

; 3105 :    if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@OTWViewLef

; 3106 :       OTWDriver.ViewSpinLeft();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?ViewSpinLeft@OTWDriverClass@@QAEXXZ	; OTWDriverClass::ViewSpinLeft

; 3107 :    else

	jmp	SHORT $LN3@OTWViewLef
$LN2@OTWViewLef:

; 3108 :       OTWDriver.ViewSpinHold();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?ViewSpinHold@OTWDriverClass@@QAEXXZ	; OTWDriverClass::ViewSpinHold
$LN3@OTWViewLef:

; 3109 : }

	pop	ebp
	ret	0
?OTWViewLeft@@YAXKHPAX@Z ENDP				; OTWViewLeft
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv77 = -12						; size = 8
tv74 = -4						; size = 4
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWSetScale@@YAXKHPAX@Z PROC				; OTWSetScale

; 3035 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 3036 :    if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN1@OTWSetScal

; 3037 :    {
; 3038 :       OTWDriver.SetScale((float)(val - DIK_1 + 1));

	mov	ecx, DWORD PTR _val$[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv74[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv74[ebp]
	mov	edx, DWORD PTR tv74[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv77[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv77[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?SetScale@OTWDriverClass@@QAEXM@Z	; OTWDriverClass::SetScale

; 3039 :       OTWDriver.RescaleAllObjects();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?RescaleAllObjects@OTWDriverClass@@QAEXXZ ; OTWDriverClass::RescaleAllObjects
$LN1@OTWSetScal:

; 3040 :    }
; 3041 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?OTWSetScale@@YAXKHPAX@Z ENDP				; OTWSetScale
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWToggleAutoScale@@YAXKHPAX@Z PROC			; OTWToggleAutoScale

; 3028 : {

	push	ebp
	mov	ebp, esp

; 3029 :    if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@OTWToggleA

; 3030 : 	   FalconDisplay.ToggleFullScreen();

	mov	ecx, OFFSET ?FalconDisplay@@3VFalconDisplayConfiguration@@A ; FalconDisplay
	call	?ToggleFullScreen@FalconDisplayConfiguration@@QAEXXZ ; FalconDisplayConfiguration::ToggleFullScreen
$LN2@OTWToggleA:

; 3031 :       //OTWDriver.ToggleAutoScale();
; 3032 : }

	pop	ebp
	ret	0
?OTWToggleAutoScale@@YAXKHPAX@Z ENDP			; OTWToggleAutoScale
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWToggleFrameRate@@YAXKHPAX@Z PROC			; OTWToggleFrameRate

; 3022 : {

	push	ebp
	mov	ebp, esp

; 3023 :    if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@OTWToggleF

; 3024 :       ShowFrameRate = 1 - ShowFrameRate;

	mov	ecx, 1
	sub	ecx, DWORD PTR ?ShowFrameRate@@3HA	; ShowFrameRate
	mov	DWORD PTR ?ShowFrameRate@@3HA, ecx	; ShowFrameRate
$LN2@OTWToggleF:

; 3025 : }

	pop	ebp
	ret	0
?OTWToggleFrameRate@@YAXKHPAX@Z ENDP			; OTWToggleFrameRate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWEnterPosition@@YAXKHPAX@Z PROC			; OTWEnterPosition

; 3016 : {

	push	ebp
	mov	ebp, esp

; 3017 :    if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@OTWEnterPo

; 3018 :       OTWDriver.StartLocationEntry();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?StartLocationEntry@OTWDriverClass@@QAEXXZ ; OTWDriverClass::StartLocationEntry
$LN2@OTWEnterPo:

; 3019 : }

	pop	ebp
	ret	0
?OTWEnterPosition@@YAXKHPAX@Z ENDP			; OTWEnterPosition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWToggleEyeFly@@YAXKHPAX@Z PROC			; OTWToggleEyeFly

; 3010 : {

	push	ebp
	mov	ebp, esp

; 3011 :    if (state & KEY_DOWN && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) // 2002-02-15 MODIFIED BY S.G. ToggleEyeFly brings you to another AC and can crash when you're ejected since your class isn't AircraftClass anymore

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@OTWToggleE
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@OTWToggleE

; 3012 :       OTWDriver.ToggleEyeFly();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?ToggleEyeFly@OTWDriverClass@@QAEXXZ	; OTWDriverClass::ToggleEyeFly
$LN2@OTWToggleE:

; 3013 : }

	pop	ebp
	ret	0
?OTWToggleEyeFly@@YAXKHPAX@Z ENDP			; OTWToggleEyeFly
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWStepHudColor@@YAXKHPAX@Z PROC			; OTWStepHudColor

; 2967 : {

	push	ebp
	mov	ebp, esp

; 2968 :    if ((state & KEY_DOWN) && (SimDriver.GetPlayerAircraft()) && (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)))

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN4@OTWStepHud
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@OTWStepHud
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@OTWStepHud

; 2969 : 	 {
; 2970 : 		if(TheHud)

	cmp	DWORD PTR ?TheHud@@3PAVHudClass@@A, 0	; TheHud
	je	SHORT $LN4@OTWStepHud

; 2971 : 		{
; 2972 :       TheHud->HudColorStep();

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?HudColorStep@HudClass@@QAEXXZ		; HudClass::HudColorStep

; 2973 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@OTWStepHud

; 2974 : 				//OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_ICP_BRT_WHEEL, curColorIdx+1);
; 2975 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_ICP_BRT_WHEEL, 1<<curColorIdx);

	mov	edx, 1
	mov	ecx, DWORD PTR ?curColorIdx@@3HA	; curColorIdx
	shl	edx, cl
	push	edx
	push	146					; 00000092H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@OTWStepHud:

; 2976 : 		}
; 2977 : 	 }
; 2978 : }

	pop	ebp
	ret	0
?OTWStepHudColor@@YAXKHPAX@Z ENDP			; OTWStepHudColor
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv78 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWToggleClouds@@YAXKHPAX@Z PROC			; OTWToggleClouds

; 2961 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2962 :    if (state & KEY_DOWN && FalconLocalGame->rules.WeatherOn())

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@OTWToggleC
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@OTWToggleC
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv78[ebp], eax
	jmp	SHORT $LN5@OTWToggleC
$LN4@OTWToggleC:
	mov	DWORD PTR tv78[ebp], 0
$LN5@OTWToggleC:
	mov	ecx, DWORD PTR tv78[ebp]
	add	ecx, 356				; 00000164H
	call	?WeatherOn@RulesClass@@QAEHXZ		; RulesClass::WeatherOn
	test	eax, eax
	je	SHORT $LN2@OTWToggleC

; 2963 :       OTWDriver.ToggleWeather();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?ToggleWeather@OTWDriverClass@@QAEXXZ	; OTWDriverClass::ToggleWeather
$LN2@OTWToggleC:

; 2964 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?OTWToggleClouds@@YAXKHPAX@Z ENDP			; OTWToggleClouds
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWObjDetailUp@@YAXKHPAX@Z PROC			; OTWObjDetailUp

; 2941 : {

	push	ebp
	mov	ebp, esp

; 2942 :    if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@OTWObjDeta

; 2943 :       OTWDriver.DetailUp();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?DetailUp@OTWDriverClass@@QAEXXZ	; OTWDriverClass::DetailUp
$LN2@OTWObjDeta:

; 2944 : }

	pop	ebp
	ret	0
?OTWObjDetailUp@@YAXKHPAX@Z ENDP			; OTWObjDetailUp
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWObjDetailDown@@YAXKHPAX@Z PROC			; OTWObjDetailDown

; 2935 : {

	push	ebp
	mov	ebp, esp

; 2936 :    if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@OTWObjDeta

; 2937 :       OTWDriver.DetailDown();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?DetailDown@OTWDriverClass@@QAEXXZ	; OTWDriverClass::DetailDown
$LN2@OTWObjDeta:

; 2938 : }

	pop	ebp
	ret	0
?OTWObjDetailDown@@YAXKHPAX@Z ENDP			; OTWObjDetailDown
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWSetObjDetail@@YAXKHPAX@Z PROC			; OTWSetObjDetail

; 2929 : {

	push	ebp
	mov	ebp, esp

; 2930 :    if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@OTWSetObjD

; 2931 :       OTWDriver.SetDetail(val - DIK_1);

	mov	ecx, DWORD PTR _val$[ebp]
	sub	ecx, 2
	push	ecx
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?SetDetail@OTWDriverClass@@QAEXH@Z	; OTWDriverClass::SetDetail
$LN2@OTWSetObjD:

; 2932 : }

	pop	ebp
	ret	0
?OTWSetObjDetail@@YAXKHPAX@Z ENDP			; OTWSetObjDetail
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWScaleUp@@YAXKHPAX@Z PROC				; OTWScaleUp

; 2923 : {

	push	ebp
	mov	ebp, esp

; 2924 :    if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@OTWScaleUp

; 2925 :       OTWDriver.ScaleUp();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?ScaleUp@OTWDriverClass@@QAEXXZ		; OTWDriverClass::ScaleUp
$LN2@OTWScaleUp:

; 2926 : }

	pop	ebp
	ret	0
?OTWScaleUp@@YAXKHPAX@Z ENDP				; OTWScaleUp
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWScaleDown@@YAXKHPAX@Z PROC				; OTWScaleDown

; 2917 : {

	push	ebp
	mov	ebp, esp

; 2918 :    if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@OTWScaleDo

; 2919 :       OTWDriver.ScaleDown();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?ScaleDown@OTWDriverClass@@QAEXXZ	; OTWDriverClass::ScaleDown
$LN2@OTWScaleDo:

; 2920 : }

	pop	ebp
	ret	0
?OTWScaleDown@@YAXKHPAX@Z ENDP				; OTWScaleDown
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv78 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWToggleActionCamera@@YAXKHPAX@Z PROC			; OTWToggleActionCamera

; 2453 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2454 : 	if (state & KEY_DOWN && FalconLocalGame->rules.ExternalViewOn())

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@OTWToggleA
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@OTWToggleA
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv78[ebp], eax
	jmp	SHORT $LN5@OTWToggleA
$LN4@OTWToggleA:
	mov	DWORD PTR tv78[ebp], 0
$LN5@OTWToggleA:
	mov	ecx, DWORD PTR tv78[ebp]
	add	ecx, 356				; 00000164H
	call	?ExternalViewOn@RulesClass@@QAEHXZ	; RulesClass::ExternalViewOn
	test	eax, eax
	je	SHORT $LN2@OTWToggleA

; 2455 :       OTWDriver.ToggleActionCamera();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?ToggleActionCamera@OTWDriverClass@@QAEXXZ ; OTWDriverClass::ToggleActionCamera
$LN2@OTWToggleA:

; 2456 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?OTWToggleActionCamera@@YAXKHPAX@Z ENDP			; OTWToggleActionCamera
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWToggleEngineDisplay@@YAXKHPAX@Z PROC		; OTWToggleEngineDisplay

; 2910 : {

	push	ebp
	mov	ebp, esp

; 2911 :    if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@OTWToggleE

; 2912 :       OTWDriver.ToggleEngineDisplay();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?ToggleEngineDisplay@OTWDriverClass@@QAEXXZ ; OTWDriverClass::ToggleEngineDisplay
$LN2@OTWToggleE:

; 2913 : }

	pop	ebp
	ret	0
?OTWToggleEngineDisplay@@YAXKHPAX@Z ENDP		; OTWToggleEngineDisplay
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWToggleFlapDisplay@@YAXKHPAX@Z PROC			; OTWToggleFlapDisplay

; 2903 : {

	push	ebp
	mov	ebp, esp

; 2904 :    if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@OTWToggleF

; 2905 :       OTWDriver.ToggleFlapDisplay();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?ToggleFlapDisplay@OTWDriverClass@@QAEXXZ ; OTWDriverClass::ToggleFlapDisplay
$LN2@OTWToggleF:

; 2906 : }

	pop	ebp
	ret	0
?OTWToggleFlapDisplay@@YAXKHPAX@Z ENDP			; OTWToggleFlapDisplay
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWToggleAeroDisplay@@YAXKHPAX@Z PROC			; OTWToggleAeroDisplay

; 2896 : {

	push	ebp
	mov	ebp, esp

; 2897 :    if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@OTWToggleA

; 2898 :       OTWDriver.ToggleAeroDisplay();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?ToggleAeroDisplay@OTWDriverClass@@QAEXXZ ; OTWDriverClass::ToggleAeroDisplay
$LN2@OTWToggleA:

; 2899 : }

	pop	ebp
	ret	0
?OTWToggleAeroDisplay@@YAXKHPAX@Z ENDP			; OTWToggleAeroDisplay
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWToggleLocationDisplay@@YAXKHPAX@Z PROC		; OTWToggleLocationDisplay

; 2890 : {

	push	ebp
	mov	ebp, esp

; 2891 :    if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@OTWToggleL

; 2892 :       OTWDriver.ToggleLocationDisplay();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?ToggleLocationDisplay@OTWDriverClass@@QAEXXZ ; OTWDriverClass::ToggleLocationDisplay
$LN2@OTWToggleL:

; 2893 : }

	pop	ebp
	ret	0
?OTWToggleLocationDisplay@@YAXKHPAX@Z ENDP		; OTWToggleLocationDisplay
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWToggleHaze@@YAXKHPAX@Z PROC				; OTWToggleHaze

; 2884 : {

	push	ebp
	mov	ebp, esp

; 2885 :    if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@OTWToggleH

; 2886 :       OTWDriver.ToggleHaze();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?ToggleHaze@OTWDriverClass@@QAEXXZ	; OTWDriverClass::ToggleHaze
$LN2@OTWToggleH:

; 2887 : }

	pop	ebp
	ret	0
?OTWToggleHaze@@YAXKHPAX@Z ENDP				; OTWToggleHaze
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWToggleShading@@YAXKHPAX@Z PROC			; OTWToggleShading

; 2878 : {

	push	ebp
	mov	ebp, esp

; 2879 :    if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@OTWToggleS

; 2880 :       OTWDriver.ToggleShading();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?ToggleShading@OTWDriverClass@@QAEXXZ	; OTWDriverClass::ToggleShading
$LN2@OTWToggleS:

; 2881 : }

	pop	ebp
	ret	0
?OTWToggleShading@@YAXKHPAX@Z ENDP			; OTWToggleShading
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWToggleBilinearFilter@@YAXKHPAX@Z PROC		; OTWToggleBilinearFilter

; 2872 : {

	push	ebp
	mov	ebp, esp

; 2873 :    if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@OTWToggleB

; 2874 :       OTWDriver.ToggleBilinearFilter();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?ToggleBilinearFilter@OTWDriverClass@@QAEXXZ ; OTWDriverClass::ToggleBilinearFilter
$LN2@OTWToggleB:

; 2875 : }

	pop	ebp
	ret	0
?OTWToggleBilinearFilter@@YAXKHPAX@Z ENDP		; OTWToggleBilinearFilter
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWSelect3DCockpitMode@@YAXKHPAX@Z PROC		; OTWSelect3DCockpitMode

; 2866 : {

	push	ebp
	mov	ebp, esp

; 2867 :    if ((state & KEY_DOWN) && (SimDriver.GetPlayerAircraft()) && (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)))

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@OTWSelect3
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@OTWSelect3
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@OTWSelect3

; 2868 :       OTWDriver.SetOTWDisplayMode(OTWDriverClass::Mode3DCockpit);

	push	3
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?SetOTWDisplayMode@OTWDriverClass@@QAEXW4OTWDisplayMode@1@@Z ; OTWDriverClass::SetOTWDisplayMode
$LN2@OTWSelect3:

; 2869 : }

	pop	ebp
	ret	0
?OTWSelect3DCockpitMode@@YAXKHPAX@Z ENDP		; OTWSelect3DCockpitMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWSelect2DCockpitMode@@YAXKHPAX@Z PROC		; OTWSelect2DCockpitMode

; 2858 : {

	push	ebp
	mov	ebp, esp

; 2859 :    if ((state & KEY_DOWN) && (SimDriver.GetPlayerAircraft()) && (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)))

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@OTWSelect2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@OTWSelect2
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@OTWSelect2

; 2860 : 	{
; 2861 : 		OTWDriver.SetOTWDisplayMode(OTWDriverClass::Mode2DCockpit);

	push	2
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?SetOTWDisplayMode@OTWDriverClass@@QAEXW4OTWDisplayMode@1@@Z ; OTWDriverClass::SetOTWDisplayMode
$LN2@OTWSelect2:

; 2862 : 	}
; 2863 : }

	pop	ebp
	ret	0
?OTWSelect2DCockpitMode@@YAXKHPAX@Z ENDP		; OTWSelect2DCockpitMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWShowVersion@@YAXKHPAX@Z PROC			; OTWShowVersion

; 2846 : {

	push	ebp
	mov	ebp, esp

; 2847 :    if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN4@OTWShowVer

; 2848 :    {
; 2849 :       if (ShowVersion != 1)

	cmp	DWORD PTR ?ShowVersion@@3HA, 1		; ShowVersion
	je	SHORT $LN2@OTWShowVer

; 2850 :          ShowVersion = 1;

	mov	DWORD PTR ?ShowVersion@@3HA, 1		; ShowVersion

; 2851 :       else

	jmp	SHORT $LN4@OTWShowVer
$LN2@OTWShowVer:

; 2852 :          ShowVersion = 0;

	mov	DWORD PTR ?ShowVersion@@3HA, 0		; ShowVersion
$LN4@OTWShowVer:

; 2853 :    }
; 2854 : }

	pop	ebp
	ret	0
?OTWShowVersion@@YAXKHPAX@Z ENDP			; OTWShowVersion
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWShowTestVersion@@YAXKHPAX@Z PROC			; OTWShowTestVersion

; 2835 : {

	push	ebp
	mov	ebp, esp

; 2836 :    if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN4@OTWShowTes

; 2837 :    {
; 2838 :       if (ShowVersion != 2)

	cmp	DWORD PTR ?ShowVersion@@3HA, 2		; ShowVersion
	je	SHORT $LN2@OTWShowTes

; 2839 :          ShowVersion = 2;

	mov	DWORD PTR ?ShowVersion@@3HA, 2		; ShowVersion

; 2840 :       else

	jmp	SHORT $LN4@OTWShowTes
$LN2@OTWShowTes:

; 2841 :          ShowVersion = 0;

	mov	DWORD PTR ?ShowVersion@@3HA, 0		; ShowVersion
$LN4@OTWShowTes:

; 2842 :    }
; 2843 : }

	pop	ebp
	ret	0
?OTWShowTestVersion@@YAXKHPAX@Z ENDP			; OTWShowTestVersion
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv154 = -16						; size = 4
tv142 = -12						; size = 4
tv93 = -8						; size = 4
tv76 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWSelectSatelliteMode@@YAXKHPAX@Z PROC		; OTWSelectSatelliteMode

; 2817 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 2818 :    if (FalconLocalGame && SimDriver.GetPlayerAircraft() && (FalconLocalGame->rules.ExternalViewOn() ||
; 2819 :        !FalconLocalGame->rules.ExternalViewOn() && SimDriver.GetPlayerAircraft()->OnGround()&&
; 2820 : 	   g_bExtViewOnGround) && \
; 2821 :        (state & KEY_DOWN) &&  \
; 2822 :        (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)))

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@OTWSelectS
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN6@OTWSelectS
$LN5@OTWSelectS:
	mov	DWORD PTR tv76[ebp], 0
$LN6@OTWSelectS:
	cmp	DWORD PTR tv76[ebp], 0
	je	$LN3@OTWSelectS
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN3@OTWSelectS
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN7@OTWSelectS
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv93[ebp], eax
	jmp	SHORT $LN8@OTWSelectS
$LN7@OTWSelectS:
	mov	DWORD PTR tv93[ebp], 0
$LN8@OTWSelectS:
	mov	ecx, DWORD PTR tv93[ebp]
	add	ecx, 356				; 00000164H
	call	?ExternalViewOn@RulesClass@@QAEHXZ	; RulesClass::ExternalViewOn
	test	eax, eax
	jne	SHORT $LN1@OTWSelectS
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN9@OTWSelectS
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv142[ebp], eax
	jmp	SHORT $LN10@OTWSelectS
$LN9@OTWSelectS:
	mov	DWORD PTR tv142[ebp], 0
$LN10@OTWSelectS:
	mov	ecx, DWORD PTR tv142[ebp]
	add	ecx, 356				; 00000164H
	call	?ExternalViewOn@RulesClass@@QAEHXZ	; RulesClass::ExternalViewOn
	test	eax, eax
	jne	SHORT $LN3@OTWSelectS
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR tv154[ebp], eax
	mov	eax, DWORD PTR tv154[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv154[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	je	SHORT $LN3@OTWSelectS
	movzx	ecx, BYTE PTR ?g_bExtViewOnGround@@3_NA	; g_bExtViewOnGround
	test	ecx, ecx
	je	SHORT $LN3@OTWSelectS
$LN1@OTWSelectS:
	mov	edx, DWORD PTR _state$[ebp]
	and	edx, 8
	je	SHORT $LN3@OTWSelectS
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@OTWSelectS

; 2823 :       OTWDriver.SetOTWDisplayMode(OTWDriverClass::ModeSatellite);

	push	14					; 0000000eH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?SetOTWDisplayMode@OTWDriverClass@@QAEXW4OTWDisplayMode@1@@Z ; OTWDriverClass::SetOTWDisplayMode
$LN3@OTWSelectS:

; 2824 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?OTWSelectSatelliteMode@@YAXKHPAX@Z ENDP		; OTWSelectSatelliteMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv90 = -8						; size = 4
tv76 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWSelectFlybyMode@@YAXKHPAX@Z PROC			; OTWSelectFlybyMode

; 2827 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2828 :    if (FalconLocalGame && FalconLocalGame->rules.ExternalViewOn() && \
; 2829 : 	   (state & KEY_DOWN) && (SimDriver.GetPlayerAircraft()) && \
; 2830 : 	   (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)))

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@OTWSelectF
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN5@OTWSelectF
$LN4@OTWSelectF:
	mov	DWORD PTR tv76[ebp], 0
$LN5@OTWSelectF:
	cmp	DWORD PTR tv76[ebp], 0
	je	SHORT $LN2@OTWSelectF
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@OTWSelectF
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv90[ebp], eax
	jmp	SHORT $LN7@OTWSelectF
$LN6@OTWSelectF:
	mov	DWORD PTR tv90[ebp], 0
$LN7@OTWSelectF:
	mov	ecx, DWORD PTR tv90[ebp]
	add	ecx, 356				; 00000164H
	call	?ExternalViewOn@RulesClass@@QAEHXZ	; RulesClass::ExternalViewOn
	test	eax, eax
	je	SHORT $LN2@OTWSelectF
	mov	edx, DWORD PTR _state$[ebp]
	and	edx, 8
	je	SHORT $LN2@OTWSelectF
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@OTWSelectF
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@OTWSelectF

; 2831 :       OTWDriver.SetOTWDisplayMode(OTWDriverClass::ModeFlyby);

	push	16					; 00000010H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?SetOTWDisplayMode@OTWDriverClass@@QAEXW4OTWDisplayMode@1@@Z ; OTWDriverClass::SetOTWDisplayMode
$LN2@OTWSelectF:

; 2832 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?OTWSelectFlybyMode@@YAXKHPAX@Z ENDP			; OTWSelectFlybyMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv90 = -8						; size = 4
tv76 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWSelectWeaponMode@@YAXKHPAX@Z PROC			; OTWSelectWeaponMode

; 2808 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2809 :    if (FalconLocalGame && FalconLocalGame->rules.ExternalViewOn() && \
; 2810 : 	   (state & KEY_DOWN) && (SimDriver.GetPlayerAircraft()) && \
; 2811 : 	   (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)))

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@OTWSelectW
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN5@OTWSelectW
$LN4@OTWSelectW:
	mov	DWORD PTR tv76[ebp], 0
$LN5@OTWSelectW:
	cmp	DWORD PTR tv76[ebp], 0
	je	SHORT $LN2@OTWSelectW
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@OTWSelectW
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv90[ebp], eax
	jmp	SHORT $LN7@OTWSelectW
$LN6@OTWSelectW:
	mov	DWORD PTR tv90[ebp], 0
$LN7@OTWSelectW:
	mov	ecx, DWORD PTR tv90[ebp]
	add	ecx, 356				; 00000164H
	call	?ExternalViewOn@RulesClass@@QAEHXZ	; RulesClass::ExternalViewOn
	test	eax, eax
	je	SHORT $LN2@OTWSelectW
	mov	edx, DWORD PTR _state$[ebp]
	and	edx, 8
	je	SHORT $LN2@OTWSelectW
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@OTWSelectW
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@OTWSelectW

; 2812 :       OTWDriver.SetOTWDisplayMode(OTWDriverClass::ModeWeapon);

	push	13					; 0000000dH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?SetOTWDisplayMode@OTWDriverClass@@QAEXW4OTWDisplayMode@1@@Z ; OTWDriverClass::SetOTWDisplayMode
$LN2@OTWSelectW:

; 2813 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?OTWSelectWeaponMode@@YAXKHPAX@Z ENDP			; OTWSelectWeaponMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv90 = -8						; size = 4
tv76 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWSelectTargetMode@@YAXKHPAX@Z PROC			; OTWSelectTargetMode

; 2800 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2801 :    if (FalconLocalGame && FalconLocalGame->rules.ExternalViewOn() && \
; 2802 : 	   (state & KEY_DOWN) && (SimDriver.GetPlayerAircraft()) && \
; 2803 : 	   (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)))

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@OTWSelectT
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN5@OTWSelectT
$LN4@OTWSelectT:
	mov	DWORD PTR tv76[ebp], 0
$LN5@OTWSelectT:
	cmp	DWORD PTR tv76[ebp], 0
	je	SHORT $LN2@OTWSelectT
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@OTWSelectT
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv90[ebp], eax
	jmp	SHORT $LN7@OTWSelectT
$LN6@OTWSelectT:
	mov	DWORD PTR tv90[ebp], 0
$LN7@OTWSelectT:
	mov	ecx, DWORD PTR tv90[ebp]
	add	ecx, 356				; 00000164H
	call	?ExternalViewOn@RulesClass@@QAEHXZ	; RulesClass::ExternalViewOn
	test	eax, eax
	je	SHORT $LN2@OTWSelectT
	mov	edx, DWORD PTR _state$[ebp]
	and	edx, 8
	je	SHORT $LN2@OTWSelectT
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@OTWSelectT
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@OTWSelectT

; 2804 :       OTWDriver.SetOTWDisplayMode(OTWDriverClass::ModeTarget);

	push	12					; 0000000cH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?SetOTWDisplayMode@OTWDriverClass@@QAEXW4OTWDisplayMode@1@@Z ; OTWDriverClass::SetOTWDisplayMode
$LN2@OTWSelectT:

; 2805 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?OTWSelectTargetMode@@YAXKHPAX@Z ENDP			; OTWSelectTargetMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv90 = -8						; size = 4
tv76 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWSelectGroundEnemyMode@@YAXKHPAX@Z PROC		; OTWSelectGroundEnemyMode

; 2792 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2793 :    if (FalconLocalGame && FalconLocalGame->rules.ExternalViewOn() && \
; 2794 : 	   (state & KEY_DOWN) && (SimDriver.GetPlayerAircraft()) && \
; 2795 : 	   (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)))

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@OTWSelectG
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN5@OTWSelectG
$LN4@OTWSelectG:
	mov	DWORD PTR tv76[ebp], 0
$LN5@OTWSelectG:
	cmp	DWORD PTR tv76[ebp], 0
	je	SHORT $LN2@OTWSelectG
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@OTWSelectG
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv90[ebp], eax
	jmp	SHORT $LN7@OTWSelectG
$LN6@OTWSelectG:
	mov	DWORD PTR tv90[ebp], 0
$LN7@OTWSelectG:
	mov	ecx, DWORD PTR tv90[ebp]
	add	ecx, 356				; 00000164H
	call	?ExternalViewOn@RulesClass@@QAEHXZ	; RulesClass::ExternalViewOn
	test	eax, eax
	je	SHORT $LN2@OTWSelectG
	mov	edx, DWORD PTR _state$[ebp]
	and	edx, 8
	je	SHORT $LN2@OTWSelectG
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@OTWSelectG
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@OTWSelectG

; 2796 :       OTWDriver.SetOTWDisplayMode(OTWDriverClass::ModeGroundEnemy);

	push	11					; 0000000bH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?SetOTWDisplayMode@OTWDriverClass@@QAEXW4OTWDisplayMode@1@@Z ; OTWDriverClass::SetOTWDisplayMode
$LN2@OTWSelectG:

; 2797 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?OTWSelectGroundEnemyMode@@YAXKHPAX@Z ENDP		; OTWSelectGroundEnemyMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv90 = -8						; size = 4
tv76 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWSelectAirEnemyMode@@YAXKHPAX@Z PROC			; OTWSelectAirEnemyMode

; 2784 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2785 :    if (FalconLocalGame && FalconLocalGame->rules.ExternalViewOn() && \
; 2786 : 	   (state & KEY_DOWN) && (SimDriver.GetPlayerAircraft()) && \
; 2787 : 	   (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)))

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@OTWSelectA
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN5@OTWSelectA
$LN4@OTWSelectA:
	mov	DWORD PTR tv76[ebp], 0
$LN5@OTWSelectA:
	cmp	DWORD PTR tv76[ebp], 0
	je	SHORT $LN2@OTWSelectA
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@OTWSelectA
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv90[ebp], eax
	jmp	SHORT $LN7@OTWSelectA
$LN6@OTWSelectA:
	mov	DWORD PTR tv90[ebp], 0
$LN7@OTWSelectA:
	mov	ecx, DWORD PTR tv90[ebp]
	add	ecx, 356				; 00000164H
	call	?ExternalViewOn@RulesClass@@QAEHXZ	; RulesClass::ExternalViewOn
	test	eax, eax
	je	SHORT $LN2@OTWSelectA
	mov	edx, DWORD PTR _state$[ebp]
	and	edx, 8
	je	SHORT $LN2@OTWSelectA
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@OTWSelectA
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@OTWSelectA

; 2788 :       OTWDriver.SetOTWDisplayMode(OTWDriverClass::ModeAirEnemy);

	push	10					; 0000000aH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?SetOTWDisplayMode@OTWDriverClass@@QAEXW4OTWDisplayMode@1@@Z ; OTWDriverClass::SetOTWDisplayMode
$LN2@OTWSelectA:

; 2789 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?OTWSelectAirEnemyMode@@YAXKHPAX@Z ENDP			; OTWSelectAirEnemyMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv90 = -8						; size = 4
tv76 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWSelectGroundFriendlyMode@@YAXKHPAX@Z PROC		; OTWSelectGroundFriendlyMode

; 2776 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2777 :    if (FalconLocalGame && FalconLocalGame->rules.ExternalViewOn() && \
; 2778 : 	   (state & KEY_DOWN) && (SimDriver.GetPlayerAircraft()) && \
; 2779 : 	   (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)))

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@OTWSelectG
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN5@OTWSelectG
$LN4@OTWSelectG:
	mov	DWORD PTR tv76[ebp], 0
$LN5@OTWSelectG:
	cmp	DWORD PTR tv76[ebp], 0
	je	SHORT $LN2@OTWSelectG
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@OTWSelectG
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv90[ebp], eax
	jmp	SHORT $LN7@OTWSelectG
$LN6@OTWSelectG:
	mov	DWORD PTR tv90[ebp], 0
$LN7@OTWSelectG:
	mov	ecx, DWORD PTR tv90[ebp]
	add	ecx, 356				; 00000164H
	call	?ExternalViewOn@RulesClass@@QAEHXZ	; RulesClass::ExternalViewOn
	test	eax, eax
	je	SHORT $LN2@OTWSelectG
	mov	edx, DWORD PTR _state$[ebp]
	and	edx, 8
	je	SHORT $LN2@OTWSelectG
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@OTWSelectG
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@OTWSelectG

; 2780 :       OTWDriver.SetOTWDisplayMode(OTWDriverClass::ModeGroundFriendly);

	push	9
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?SetOTWDisplayMode@OTWDriverClass@@QAEXW4OTWDisplayMode@1@@Z ; OTWDriverClass::SetOTWDisplayMode
$LN2@OTWSelectG:

; 2781 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?OTWSelectGroundFriendlyMode@@YAXKHPAX@Z ENDP		; OTWSelectGroundFriendlyMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv90 = -8						; size = 4
tv76 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWSelectIncomingMode@@YAXKHPAX@Z PROC			; OTWSelectIncomingMode

; 2768 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2769 :    if (FalconLocalGame && FalconLocalGame->rules.ExternalViewOn() && \
; 2770 : 	   (state & KEY_DOWN) && (SimDriver.GetPlayerAircraft()) && \
; 2771 : 	   (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)))

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@OTWSelectI
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN5@OTWSelectI
$LN4@OTWSelectI:
	mov	DWORD PTR tv76[ebp], 0
$LN5@OTWSelectI:
	cmp	DWORD PTR tv76[ebp], 0
	je	SHORT $LN2@OTWSelectI
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@OTWSelectI
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv90[ebp], eax
	jmp	SHORT $LN7@OTWSelectI
$LN6@OTWSelectI:
	mov	DWORD PTR tv90[ebp], 0
$LN7@OTWSelectI:
	mov	ecx, DWORD PTR tv90[ebp]
	add	ecx, 356				; 00000164H
	call	?ExternalViewOn@RulesClass@@QAEHXZ	; RulesClass::ExternalViewOn
	test	eax, eax
	je	SHORT $LN2@OTWSelectI
	mov	edx, DWORD PTR _state$[ebp]
	and	edx, 8
	je	SHORT $LN2@OTWSelectI
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@OTWSelectI
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@OTWSelectI

; 2772 :       OTWDriver.SetOTWDisplayMode(OTWDriverClass::ModeIncoming);

	push	15					; 0000000fH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?SetOTWDisplayMode@OTWDriverClass@@QAEXW4OTWDisplayMode@1@@Z ; OTWDriverClass::SetOTWDisplayMode
$LN2@OTWSelectI:

; 2773 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?OTWSelectIncomingMode@@YAXKHPAX@Z ENDP			; OTWSelectIncomingMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv90 = -8						; size = 4
tv76 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWSelectAirFriendlyMode@@YAXKHPAX@Z PROC		; OTWSelectAirFriendlyMode

; 2760 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2761 :    if (FalconLocalGame && FalconLocalGame->rules.ExternalViewOn() && \
; 2762 : 	   (state & KEY_DOWN) && (SimDriver.GetPlayerAircraft()) && \
; 2763 : 	   (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)))

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@OTWSelectA
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN5@OTWSelectA
$LN4@OTWSelectA:
	mov	DWORD PTR tv76[ebp], 0
$LN5@OTWSelectA:
	cmp	DWORD PTR tv76[ebp], 0
	je	SHORT $LN2@OTWSelectA
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@OTWSelectA
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv90[ebp], eax
	jmp	SHORT $LN7@OTWSelectA
$LN6@OTWSelectA:
	mov	DWORD PTR tv90[ebp], 0
$LN7@OTWSelectA:
	mov	ecx, DWORD PTR tv90[ebp]
	add	ecx, 356				; 00000164H
	call	?ExternalViewOn@RulesClass@@QAEHXZ	; RulesClass::ExternalViewOn
	test	eax, eax
	je	SHORT $LN2@OTWSelectA
	mov	edx, DWORD PTR _state$[ebp]
	and	edx, 8
	je	SHORT $LN2@OTWSelectA
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@OTWSelectA
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@OTWSelectA

; 2764 :       OTWDriver.SetOTWDisplayMode(OTWDriverClass::ModeAirFriendly);

	push	8
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?SetOTWDisplayMode@OTWDriverClass@@QAEXW4OTWDisplayMode@1@@Z ; OTWDriverClass::SetOTWDisplayMode
$LN2@OTWSelectA:

; 2765 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?OTWSelectAirFriendlyMode@@YAXKHPAX@Z ENDP		; OTWSelectAirFriendlyMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv154 = -16						; size = 4
tv142 = -12						; size = 4
tv93 = -8						; size = 4
tv76 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWSelectOrbitMode@@YAXKHPAX@Z PROC			; OTWSelectOrbitMode

; 2725 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 2726 : 	if (FalconLocalGame && SimDriver.GetPlayerAircraft()) //added SimDriver check

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN7@OTWSelectO
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN8@OTWSelectO
$LN7@OTWSelectO:
	mov	DWORD PTR tv76[ebp], 0
$LN8@OTWSelectO:
	cmp	DWORD PTR tv76[ebp], 0
	je	$LN5@OTWSelectO
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN5@OTWSelectO

; 2727 : 	{
; 2728 : 		if(FalconLocalGame->rules.ExternalViewOn() || (!FalconLocalGame->rules.ExternalViewOn()
; 2729 : 			&& SimDriver.GetPlayerAircraft()->OnGround()&& g_bExtViewOnGround))

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN9@OTWSelectO
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv93[ebp], eax
	jmp	SHORT $LN10@OTWSelectO
$LN9@OTWSelectO:
	mov	DWORD PTR tv93[ebp], 0
$LN10@OTWSelectO:
	mov	ecx, DWORD PTR tv93[ebp]
	add	ecx, 356				; 00000164H
	call	?ExternalViewOn@RulesClass@@QAEHXZ	; RulesClass::ExternalViewOn
	test	eax, eax
	jne	SHORT $LN2@OTWSelectO
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN11@OTWSelectO
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv142[ebp], eax
	jmp	SHORT $LN12@OTWSelectO
$LN11@OTWSelectO:
	mov	DWORD PTR tv142[ebp], 0
$LN12@OTWSelectO:
	mov	ecx, DWORD PTR tv142[ebp]
	add	ecx, 356				; 00000164H
	call	?ExternalViewOn@RulesClass@@QAEHXZ	; RulesClass::ExternalViewOn
	test	eax, eax
	jne	SHORT $LN5@OTWSelectO
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR tv154[ebp], eax
	mov	eax, DWORD PTR tv154[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv154[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	je	SHORT $LN5@OTWSelectO
	movzx	ecx, BYTE PTR ?g_bExtViewOnGround@@3_NA	; g_bExtViewOnGround
	test	ecx, ecx
	je	SHORT $LN5@OTWSelectO
$LN2@OTWSelectO:

; 2730 : 		{
; 2731 : 			if(state & KEY_DOWN)

	mov	edx, DWORD PTR _state$[ebp]
	and	edx, 8
	je	SHORT $LN5@OTWSelectO

; 2732 : 			{
; 2733 : 				// if(SimDriver.GetPlayerAircraft())
; 2734 : 				// {
; 2735 : 				// if(SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP))
; 2736 : 				OTWDriver.SetOTWDisplayMode(OTWDriverClass::ModeOrbit);

	push	6
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?SetOTWDisplayMode@OTWDriverClass@@QAEXW4OTWDisplayMode@1@@Z ; OTWDriverClass::SetOTWDisplayMode
$LN5@OTWSelectO:

; 2737 : 				// }
; 2738 : 			}
; 2739 : 		}
; 2740 : 	}
; 2741 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?OTWSelectOrbitMode@@YAXKHPAX@Z ENDP			; OTWSelectOrbitMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv90 = -8						; size = 4
tv76 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWSelectChaseMode@@YAXKHPAX@Z PROC			; OTWSelectChaseMode

; 2716 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2717 :    if (FalconLocalGame && FalconLocalGame->rules.ExternalViewOn() && \
; 2718 : 		(state & KEY_DOWN) && (SimDriver.GetPlayerAircraft()) && \
; 2719 : 		(SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) )

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@OTWSelectC
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN5@OTWSelectC
$LN4@OTWSelectC:
	mov	DWORD PTR tv76[ebp], 0
$LN5@OTWSelectC:
	cmp	DWORD PTR tv76[ebp], 0
	je	SHORT $LN2@OTWSelectC
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@OTWSelectC
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv90[ebp], eax
	jmp	SHORT $LN7@OTWSelectC
$LN6@OTWSelectC:
	mov	DWORD PTR tv90[ebp], 0
$LN7@OTWSelectC:
	mov	ecx, DWORD PTR tv90[ebp]
	add	ecx, 356				; 00000164H
	call	?ExternalViewOn@RulesClass@@QAEHXZ	; RulesClass::ExternalViewOn
	test	eax, eax
	je	SHORT $LN2@OTWSelectC
	mov	edx, DWORD PTR _state$[ebp]
	and	edx, 8
	je	SHORT $LN2@OTWSelectC
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@OTWSelectC
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@OTWSelectC

; 2720 : 		OTWDriver.SetOTWDisplayMode(OTWDriverClass::ModeChase);

	push	7
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?SetOTWDisplayMode@OTWDriverClass@@QAEXW4OTWDisplayMode@1@@Z ; OTWDriverClass::SetOTWDisplayMode
$LN2@OTWSelectC:

; 2721 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?OTWSelectChaseMode@@YAXKHPAX@Z ENDP			; OTWSelectChaseMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv78 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWToggleGLOC@@YAXKHPAX@Z PROC				; OTWToggleGLOC

; 2709 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2710 :    if ((state & KEY_DOWN) && !FalconLocalGame->rules.BlackoutOn() && \
; 2711 : 	   (SimDriver.GetPlayerAircraft()) && (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)))

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@OTWToggleG
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@OTWToggleG
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv78[ebp], eax
	jmp	SHORT $LN5@OTWToggleG
$LN4@OTWToggleG:
	mov	DWORD PTR tv78[ebp], 0
$LN5@OTWToggleG:
	mov	ecx, DWORD PTR tv78[ebp]
	add	ecx, 356				; 00000164H
	call	?BlackoutOn@RulesClass@@QAEHXZ		; RulesClass::BlackoutOn
	test	eax, eax
	jne	SHORT $LN2@OTWToggleG
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@OTWToggleG
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@OTWToggleG

; 2712 :       OTWDriver.ToggleGLOC();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?ToggleGLOC@OTWDriverClass@@QAEXXZ	; OTWDriverClass::ToggleGLOC
$LN2@OTWToggleG:

; 2713 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?OTWToggleGLOC@@YAXKHPAX@Z ENDP				; OTWToggleGLOC
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWSelectHUDMode@@YAXKHPAX@Z PROC			; OTWSelectHUDMode

; 2703 : {

	push	ebp
	mov	ebp, esp

; 2704 : 	if ((state & KEY_DOWN) && (SimDriver.GetPlayerAircraft()) && (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)))

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@OTWSelectH
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@OTWSelectH
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@OTWSelectH

; 2705 : 		OTWDriver.SetOTWDisplayMode(OTWDriverClass::ModeHud);

	push	1
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?SetOTWDisplayMode@OTWDriverClass@@QAEXW4OTWDisplayMode@1@@Z ; OTWDriverClass::SetOTWDisplayMode
$LN2@OTWSelectH:

; 2706 : }

	pop	ebp
	ret	0
?OTWSelectHUDMode@@YAXKHPAX@Z ENDP			; OTWSelectHUDMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWStepHeadingScale@@YAXKHPAX@Z PROC			; OTWStepHeadingScale

; 2697 : {

	push	ebp
	mov	ebp, esp

; 2698 :    if ((state & KEY_DOWN) && (SimDriver.GetPlayerAircraft()) && (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)))

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@OTWStepHea
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@OTWStepHea
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@OTWStepHea

; 2699 :       OTWDriver.StepHeadingScale();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?StepHeadingScale@OTWDriverClass@@QAEXXZ ; OTWDriverClass::StepHeadingScale
$LN2@OTWStepHea:

; 2700 : }

	pop	ebp
	ret	0
?OTWStepHeadingScale@@YAXKHPAX@Z ENDP			; OTWStepHeadingScale
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimPitchLadderATTFPM@@YAXKHPAX@Z PROC			; SimPitchLadderATTFPM

; 2685 : {

	push	ebp
	mov	ebp, esp

; 2686 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimPitchLa

; 2687 : 		return;

	jmp	SHORT $LN4@SimPitchLa
$LN3@SimPitchLa:

; 2688 :    if ((state & KEY_DOWN) && (SimDriver.GetPlayerAircraft()) && (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)))

	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimPitchLa
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimPitchLa
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimPitchLa

; 2689 :    {
; 2690 : 	   TheHud->SetFPMSwitch(HudClass::ATT_FPM);

	push	0
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?SetFPMSwitch@HudClass@@QAEXW4FPMSwitch@1@@Z ; HudClass::SetFPMSwitch

; 2691 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimPitchLa

; 2692 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HUD_FPM_LADD, 4);

	push	4
	push	199					; 000000c7H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimPitchLa:

; 2693 :    }
; 2694 : }

	pop	ebp
	ret	0
?SimPitchLadderATTFPM@@YAXKHPAX@Z ENDP			; SimPitchLadderATTFPM
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimPitchLadderFPM@@YAXKHPAX@Z PROC			; SimPitchLadderFPM

; 2673 : {

	push	ebp
	mov	ebp, esp

; 2674 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimPitchLa

; 2675 : 		return;

	jmp	SHORT $LN4@SimPitchLa
$LN3@SimPitchLa:

; 2676 :    if ((state & KEY_DOWN) && (SimDriver.GetPlayerAircraft()) && (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)))

	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimPitchLa
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimPitchLa
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimPitchLa

; 2677 :    {
; 2678 : 	   TheHud->SetFPMSwitch(HudClass::FPM);

	push	1
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?SetFPMSwitch@HudClass@@QAEXW4FPMSwitch@1@@Z ; HudClass::SetFPMSwitch

; 2679 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimPitchLa

; 2680 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HUD_FPM_LADD, 2);

	push	2
	push	199					; 000000c7H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimPitchLa:

; 2681 :    }
; 2682 : }

	pop	ebp
	ret	0
?SimPitchLadderFPM@@YAXKHPAX@Z ENDP			; SimPitchLadderFPM
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimPitchLadderOff@@YAXKHPAX@Z PROC			; SimPitchLadderOff

; 2661 : {

	push	ebp
	mov	ebp, esp

; 2662 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimPitchLa

; 2663 : 		return;

	jmp	SHORT $LN4@SimPitchLa
$LN3@SimPitchLa:

; 2664 :    if ((state & KEY_DOWN) && (SimDriver.GetPlayerAircraft()) && (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)))

	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimPitchLa
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimPitchLa
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimPitchLa

; 2665 :    {
; 2666 : 	   TheHud->SetFPMSwitch(HudClass::FPM_OFF);

	push	2
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?SetFPMSwitch@HudClass@@QAEXW4FPMSwitch@1@@Z ; HudClass::SetFPMSwitch

; 2667 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimPitchLa

; 2668 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HUD_FPM_LADD, 1);

	push	1
	push	199					; 000000c7H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimPitchLa:

; 2669 :    }
; 2670 : }

	pop	ebp
	ret	0
?SimPitchLadderOff@@YAXKHPAX@Z ENDP			; SimPitchLadderOff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWTogglePitchLadder@@YAXKHPAX@Z PROC			; OTWTogglePitchLadder

; 2647 : {

	push	ebp
	mov	ebp, esp

; 2648 :    if ((state & KEY_DOWN) && (SimDriver.GetPlayerAircraft()) && (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)))

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@OTWToggleP
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@OTWToggleP
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@OTWToggleP

; 2649 :    {
; 2650 : 		TheHud->CycleFPMSwitch();

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?CycleFPMSwitch@HudClass@@QAEXXZ	; HudClass::CycleFPMSwitch

; 2651 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN3@OTWToggleP

; 2652 : 			//OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HUD_FPM_LADD, TheHud->GetFPMSwitch()+1);
; 2653 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HUD_FPM_LADD, 1<<TheHud->GetFPMSwitch());

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?GetFPMSwitch@HudClass@@QAEHXZ		; HudClass::GetFPMSwitch
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	push	edx
	push	199					; 000000c7H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN3@OTWToggleP:

; 2654 :    }
; 2655 : }

	pop	ebp
	ret	0
?OTWTogglePitchLadder@@YAXKHPAX@Z ENDP			; OTWTogglePitchLadder
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWToggleScales@@YAXKHPAX@Z PROC			; OTWToggleScales

; 2594 : {

	push	ebp
	mov	ebp, esp

; 2595 :    if ((state & KEY_DOWN) && (SimDriver.GetPlayerAircraft()) && (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)))

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN5@OTWToggleS
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN5@OTWToggleS
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN5@OTWToggleS

; 2596 :    {
; 2597 : 		TheHud->CycleScalesSwitch();

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?CycleScalesSwitch@HudClass@@QAEXXZ	; HudClass::CycleScalesSwitch

; 2598 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN5@OTWToggleS

; 2599 : 			if (TheHud->GetScalesSwitch() < 3)

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?GetScalesSwitch@HudClass@@QAEHXZ	; HudClass::GetScalesSwitch
	cmp	eax, 3
	jge	SHORT $LN2@OTWToggleS

; 2600 : 				//OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HUD_VAH, 3 - TheHud->GetScalesSwitch());
; 2601 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HUD_VAH, 1<<(2 - TheHud->GetScalesSwitch()));

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?GetScalesSwitch@HudClass@@QAEHXZ	; HudClass::GetScalesSwitch
	mov	ecx, 2
	sub	ecx, eax
	mov	edx, 1
	shl	edx, cl
	push	edx
	push	198					; 000000c6H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2602 : 			else

	jmp	SHORT $LN5@OTWToggleS
$LN2@OTWToggleS:

; 2603 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HUD_VAH, 1);

	push	1
	push	198					; 000000c6H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN5@OTWToggleS:

; 2604 :    }
; 2605 : }

	pop	ebp
	ret	0
?OTWToggleScales@@YAXKHPAX@Z ENDP			; OTWToggleScales
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWStepMFD4@@YAXKHPAX@Z PROC				; OTWStepMFD4

; 2580 : {

	push	ebp
	mov	ebp, esp

; 2581 :    if ((state & KEY_DOWN) && (SimDriver.GetPlayerAircraft()) && (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)))

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN4@OTWStepMFD
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN4@OTWStepMFD
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@OTWStepMFD

; 2582 :    {
; 2583 :       MfdDisplay[3]->changeMode = TRUE_NEXT;

	mov	ecx, 4
	imul	ecx, 3
	mov	edx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	mov	BYTE PTR [edx+4], 1

; 2584 : 	  //MI
; 2585 : 	  if(SimDriver.GetPlayerAircraft()->FCC && SimDriver.GetPlayerAircraft()->FCC->IsSOI && g_bRealisticAvionics)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+936], 0
	je	SHORT $LN4@OTWStepMFD
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	eax, DWORD PTR [eax+936]
	movzx	ecx, BYTE PTR [eax+464]
	test	ecx, ecx
	je	SHORT $LN4@OTWStepMFD
	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	SHORT $LN4@OTWStepMFD

; 2586 : 	  {
; 2587 : 		  if(MfdDisplay[3]->CurMode() == MFDClass::FCCMode)

	mov	eax, 4
	imul	eax, 3
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[eax]
	call	?CurMode@MFDClass@@QAE?AW4MfdMode@1@XZ	; MFDClass::CurMode
	cmp	eax, 9
	jne	SHORT $LN4@OTWStepMFD

; 2588 : 			  SimDriver.GetPlayerAircraft()->StepSOI(2);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?StepSOI@SimVehicleClass@@QAEXH@Z	; SimVehicleClass::StepSOI
$LN4@OTWStepMFD:

; 2589 : 	  }
; 2590 :    }
; 2591 : }

	pop	ebp
	ret	0
?OTWStepMFD4@@YAXKHPAX@Z ENDP				; OTWStepMFD4
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWStepMFD3@@YAXKHPAX@Z PROC				; OTWStepMFD3

; 2566 : {

	push	ebp
	mov	ebp, esp

; 2567 :    if ((state & KEY_DOWN) && (SimDriver.GetPlayerAircraft()) && (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)))

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN4@OTWStepMFD
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN4@OTWStepMFD
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@OTWStepMFD

; 2568 :    {
; 2569 :       MfdDisplay[2]->changeMode = TRUE_NEXT;

	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	mov	BYTE PTR [edx+4], 1

; 2570 : 	  //MI
; 2571 : 	  if(SimDriver.GetPlayerAircraft()->FCC && SimDriver.GetPlayerAircraft()->FCC->IsSOI && g_bRealisticAvionics)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+936], 0
	je	SHORT $LN4@OTWStepMFD
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	eax, DWORD PTR [eax+936]
	movzx	ecx, BYTE PTR [eax+464]
	test	ecx, ecx
	je	SHORT $LN4@OTWStepMFD
	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	SHORT $LN4@OTWStepMFD

; 2572 : 	  {
; 2573 : 		  if(MfdDisplay[2]->CurMode() == MFDClass::FCCMode)

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[eax]
	call	?CurMode@MFDClass@@QAE?AW4MfdMode@1@XZ	; MFDClass::CurMode
	cmp	eax, 9
	jne	SHORT $LN4@OTWStepMFD

; 2574 : 			  SimDriver.GetPlayerAircraft()->StepSOI(2);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?StepSOI@SimVehicleClass@@QAEXH@Z	; SimVehicleClass::StepSOI
$LN4@OTWStepMFD:

; 2575 : 	  }
; 2576 :    }
; 2577 : }

	pop	ebp
	ret	0
?OTWStepMFD3@@YAXKHPAX@Z ENDP				; OTWStepMFD3
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWStepMFD2@@YAXKHPAX@Z PROC				; OTWStepMFD2

; 2552 : {

	push	ebp
	mov	ebp, esp

; 2553 :    if ((state & KEY_DOWN) && (SimDriver.GetPlayerAircraft()) && (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)))

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN4@OTWStepMFD
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN4@OTWStepMFD
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@OTWStepMFD

; 2554 :    {
; 2555 :       MfdDisplay[1]->changeMode = TRUE_NEXT;

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	mov	BYTE PTR [edx+4], 1

; 2556 : 	  //MI
; 2557 : 	  if(SimDriver.GetPlayerAircraft()->FCC && SimDriver.GetPlayerAircraft()->FCC->IsSOI && g_bRealisticAvionics)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+936], 0
	je	SHORT $LN4@OTWStepMFD
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	eax, DWORD PTR [eax+936]
	movzx	ecx, BYTE PTR [eax+464]
	test	ecx, ecx
	je	SHORT $LN4@OTWStepMFD
	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	SHORT $LN4@OTWStepMFD

; 2558 : 	  {
; 2559 : 		  if(MfdDisplay[1]->CurMode() == MFDClass::FCCMode)

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[eax]
	call	?CurMode@MFDClass@@QAE?AW4MfdMode@1@XZ	; MFDClass::CurMode
	cmp	eax, 9
	jne	SHORT $LN4@OTWStepMFD

; 2560 : 			  SimDriver.GetPlayerAircraft()->StepSOI(2);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?StepSOI@SimVehicleClass@@QAEXH@Z	; SimVehicleClass::StepSOI
$LN4@OTWStepMFD:

; 2561 : 	  }
; 2562 :    } 
; 2563 : }

	pop	ebp
	ret	0
?OTWStepMFD2@@YAXKHPAX@Z ENDP				; OTWStepMFD2
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWStepMFD1@@YAXKHPAX@Z PROC				; OTWStepMFD1

; 2538 : {

	push	ebp
	mov	ebp, esp

; 2539 :    if ((state & KEY_DOWN) && (SimDriver.GetPlayerAircraft()) && (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)))

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN4@OTWStepMFD
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN4@OTWStepMFD
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@OTWStepMFD

; 2540 :    {
; 2541 :       MfdDisplay[0]->changeMode = TRUE_NEXT;

	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	mov	BYTE PTR [edx+4], 1

; 2542 : 	  //MI
; 2543 : 	  if(SimDriver.GetPlayerAircraft()->FCC && SimDriver.GetPlayerAircraft()->FCC->IsSOI && g_bRealisticAvionics)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+936], 0
	je	SHORT $LN4@OTWStepMFD
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	eax, DWORD PTR [eax+936]
	movzx	ecx, BYTE PTR [eax+464]
	test	ecx, ecx
	je	SHORT $LN4@OTWStepMFD
	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	SHORT $LN4@OTWStepMFD

; 2544 : 	  {
; 2545 : 		  if(MfdDisplay[0]->CurMode() == MFDClass::FCCMode)

	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[eax]
	call	?CurMode@MFDClass@@QAE?AW4MfdMode@1@XZ	; MFDClass::CurMode
	cmp	eax, 9
	jne	SHORT $LN4@OTWStepMFD

; 2546 : 			  SimDriver.GetPlayerAircraft()->StepSOI(2);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?StepSOI@SimVehicleClass@@QAEXH@Z	; SimVehicleClass::StepSOI
$LN4@OTWStepMFD:

; 2547 : 	  }
; 2548 :    } 
; 2549 : }

	pop	ebp
	ret	0
?OTWStepMFD1@@YAXKHPAX@Z ENDP				; OTWStepMFD1
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv76 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWSelectEFOVPadlockModeAG@@YAXKHPAX@Z PROC		; OTWSelectEFOVPadlockModeAG

; 2488 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2489 :    if ( (FalconLocalGame->rules.GetPadlockMode() != PDDisabled) && (state & KEY_DOWN) && \
; 2490 : 	   (SimDriver.GetPlayerAircraft()) && (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)))

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@OTWSelectE
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN5@OTWSelectE
$LN4@OTWSelectE:
	mov	DWORD PTR tv76[ebp], 0
$LN5@OTWSelectE:
	mov	ecx, DWORD PTR tv76[ebp]
	add	ecx, 356				; 00000164H
	call	?GetPadlockMode@RulesClass@@QAEHXZ	; RulesClass::GetPadlockMode
	cmp	eax, 2
	je	SHORT $LN2@OTWSelectE
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN2@OTWSelectE
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@OTWSelectE
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@OTWSelectE

; 2491 :    {
; 2492 : 	  OTWDriver.Padlock_SetPriority(OTWDriverClass::PriorityAG);

	push	2
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?Padlock_SetPriority@OTWDriverClass@@QAEXW4PadlockPriority@1@@Z ; OTWDriverClass::Padlock_SetPriority

; 2493 : 	  OTWDriver.SetOTWDisplayMode(OTWDriverClass::ModePadlockEFOV);

	push	5
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?SetOTWDisplayMode@OTWDriverClass@@QAEXW4OTWDisplayMode@1@@Z ; OTWDriverClass::SetOTWDisplayMode
$LN2@OTWSelectE:

; 2494 :    }
; 2495 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?OTWSelectEFOVPadlockModeAG@@YAXKHPAX@Z ENDP		; OTWSelectEFOVPadlockModeAG
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv76 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWSelectEFOVPadlockModeAA@@YAXKHPAX@Z PROC		; OTWSelectEFOVPadlockModeAA

; 2477 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2478 :    if ( (FalconLocalGame->rules.GetPadlockMode() != PDDisabled) && (state & KEY_DOWN) && \
; 2479 : 	   (SimDriver.GetPlayerAircraft()) && (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)))

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@OTWSelectE
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN5@OTWSelectE
$LN4@OTWSelectE:
	mov	DWORD PTR tv76[ebp], 0
$LN5@OTWSelectE:
	mov	ecx, DWORD PTR tv76[ebp]
	add	ecx, 356				; 00000164H
	call	?GetPadlockMode@RulesClass@@QAEHXZ	; RulesClass::GetPadlockMode
	cmp	eax, 2
	je	SHORT $LN2@OTWSelectE
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN2@OTWSelectE
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@OTWSelectE
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@OTWSelectE

; 2480 :    {
; 2481 : 	  OTWDriver.Padlock_SetPriority(OTWDriverClass::PriorityAA);

	push	1
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?Padlock_SetPriority@OTWDriverClass@@QAEXW4PadlockPriority@1@@Z ; OTWDriverClass::Padlock_SetPriority

; 2482 : 	  OTWDriver.SetOTWDisplayMode(OTWDriverClass::ModePadlockEFOV);

	push	5
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?SetOTWDisplayMode@OTWDriverClass@@QAEXW4OTWDisplayMode@1@@Z ; OTWDriverClass::SetOTWDisplayMode
$LN2@OTWSelectE:

; 2483 :    }
; 2484 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?OTWSelectEFOVPadlockModeAA@@YAXKHPAX@Z ENDP		; OTWSelectEFOVPadlockModeAA
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv76 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWSelectEFOVPadlockMode@@YAXKHPAX@Z PROC		; OTWSelectEFOVPadlockMode

; 2459 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2460 :    if ( (FalconLocalGame->rules.GetPadlockMode() != PDDisabled) && (state & KEY_DOWN) && \
; 2461 : 	   (SimDriver.GetPlayerAircraft()) && (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)))

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@OTWSelectE
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN5@OTWSelectE
$LN4@OTWSelectE:
	mov	DWORD PTR tv76[ebp], 0
$LN5@OTWSelectE:
	mov	ecx, DWORD PTR tv76[ebp]
	add	ecx, 356				; 00000164H
	call	?GetPadlockMode@RulesClass@@QAEHXZ	; RulesClass::GetPadlockMode
	cmp	eax, 2
	je	SHORT $LN2@OTWSelectE
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN2@OTWSelectE
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@OTWSelectE
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@OTWSelectE

; 2462 :    {
; 2463 : 	  // 20020-03-12 MODIFIED BY S.G. Not working, lets try with three different functions, one that doesn't care, one that checks for AA and one for AG
; 2464 : /*	  if (state & CTRL_KEY)
; 2465 : 		 OTWDriver.Padlock_SetPriority(OTWDriverClass::PriorityAG);
; 2466 : 	  else
; 2467 : 		 OTWDriver.Padlock_SetPriority(OTWDriverClass::PriorityAA);
; 2468 : */
; 2469 : 	  OTWDriver.Padlock_SetPriority(OTWDriverClass::PriorityNone);

	push	0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?Padlock_SetPriority@OTWDriverClass@@QAEXW4PadlockPriority@1@@Z ; OTWDriverClass::Padlock_SetPriority

; 2470 : 	  // END OF MODIFIED SECTION
; 2471 : 	  OTWDriver.SetOTWDisplayMode(OTWDriverClass::ModePadlockEFOV);

	push	5
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?SetOTWDisplayMode@OTWDriverClass@@QAEXW4OTWDisplayMode@1@@Z ; OTWDriverClass::SetOTWDisplayMode
$LN2@OTWSelectE:

; 2472 :    }
; 2473 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?OTWSelectEFOVPadlockMode@@YAXKHPAX@Z ENDP		; OTWSelectEFOVPadlockMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv76 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWSelectF3PadlockModeAG@@YAXKHPAX@Z PROC		; OTWSelectF3PadlockModeAG

; 2528 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2529 :    if ( (FalconLocalGame->rules.GetPadlockMode() != PDDisabled) && (state & KEY_DOWN) && \
; 2530 : 	   (SimDriver.GetPlayerAircraft()) && (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)))

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@OTWSelectF
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN5@OTWSelectF
$LN4@OTWSelectF:
	mov	DWORD PTR tv76[ebp], 0
$LN5@OTWSelectF:
	mov	ecx, DWORD PTR tv76[ebp]
	add	ecx, 356				; 00000164H
	call	?GetPadlockMode@RulesClass@@QAEHXZ	; RulesClass::GetPadlockMode
	cmp	eax, 2
	je	SHORT $LN2@OTWSelectF
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN2@OTWSelectF
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@OTWSelectF
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@OTWSelectF

; 2531 :    {
; 2532 : 	  OTWDriver.Padlock_SetPriority(OTWDriverClass::PriorityAG);

	push	2
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?Padlock_SetPriority@OTWDriverClass@@QAEXW4PadlockPriority@1@@Z ; OTWDriverClass::Padlock_SetPriority

; 2533 : 	  OTWDriver.SetOTWDisplayMode(OTWDriverClass::ModePadlockF3);

	push	4
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?SetOTWDisplayMode@OTWDriverClass@@QAEXW4OTWDisplayMode@1@@Z ; OTWDriverClass::SetOTWDisplayMode
$LN2@OTWSelectF:

; 2534 :    }
; 2535 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?OTWSelectF3PadlockModeAG@@YAXKHPAX@Z ENDP		; OTWSelectF3PadlockModeAG
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv76 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWSelectF3PadlockModeAA@@YAXKHPAX@Z PROC		; OTWSelectF3PadlockModeAA

; 2517 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2518 :    if ( (FalconLocalGame->rules.GetPadlockMode() != PDDisabled) && (state & KEY_DOWN) && \
; 2519 : 	   (SimDriver.GetPlayerAircraft()) && (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)))

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@OTWSelectF
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN5@OTWSelectF
$LN4@OTWSelectF:
	mov	DWORD PTR tv76[ebp], 0
$LN5@OTWSelectF:
	mov	ecx, DWORD PTR tv76[ebp]
	add	ecx, 356				; 00000164H
	call	?GetPadlockMode@RulesClass@@QAEHXZ	; RulesClass::GetPadlockMode
	cmp	eax, 2
	je	SHORT $LN2@OTWSelectF
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN2@OTWSelectF
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@OTWSelectF
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@OTWSelectF

; 2520 :    {
; 2521 : 	  OTWDriver.Padlock_SetPriority(OTWDriverClass::PriorityAA);

	push	1
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?Padlock_SetPriority@OTWDriverClass@@QAEXW4PadlockPriority@1@@Z ; OTWDriverClass::Padlock_SetPriority

; 2522 : 	  OTWDriver.SetOTWDisplayMode(OTWDriverClass::ModePadlockF3);

	push	4
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?SetOTWDisplayMode@OTWDriverClass@@QAEXW4OTWDisplayMode@1@@Z ; OTWDriverClass::SetOTWDisplayMode
$LN2@OTWSelectF:

; 2523 :    }
; 2524 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?OTWSelectF3PadlockModeAA@@YAXKHPAX@Z ENDP		; OTWSelectF3PadlockModeAA
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv76 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWSelectF3PadlockMode@@YAXKHPAX@Z PROC		; OTWSelectF3PadlockMode

; 2498 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2499 :    if ( (FalconLocalGame->rules.GetPadlockMode() != PDDisabled) && (state & KEY_DOWN) && \
; 2500 : 	   (SimDriver.GetPlayerAircraft()) && (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)))

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@OTWSelectF
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN5@OTWSelectF
$LN4@OTWSelectF:
	mov	DWORD PTR tv76[ebp], 0
$LN5@OTWSelectF:
	mov	ecx, DWORD PTR tv76[ebp]
	add	ecx, 356				; 00000164H
	call	?GetPadlockMode@RulesClass@@QAEHXZ	; RulesClass::GetPadlockMode
	cmp	eax, 2
	je	SHORT $LN2@OTWSelectF
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN2@OTWSelectF
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@OTWSelectF
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@OTWSelectF

; 2501 :    {
; 2502 : 	  // 20020-03-12 ADDED BY S.G. If we ask for, allow multi state padlocking by choosing what to look for	  
; 2503 : 	  // 20020-03-12 MODIFIED BY S.G. Not working, lets try with three different functions, one that doesn't care, one that checks for AA and one for AG
; 2504 : /*	  if (state & CTRL_KEY)
; 2505 : 		 OTWDriver.Padlock_SetPriority(OTWDriverClass::PriorityAG);
; 2506 : 	  else
; 2507 : 		 OTWDriver.Padlock_SetPriority(OTWDriverClass::PriorityAA);
; 2508 : */
; 2509 : 	  OTWDriver.Padlock_SetPriority(OTWDriverClass::PriorityNone);

	push	0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?Padlock_SetPriority@OTWDriverClass@@QAEXW4PadlockPriority@1@@Z ; OTWDriverClass::Padlock_SetPriority

; 2510 : 	  // END OF MODIFIED SECTION
; 2511 : 	  OTWDriver.SetOTWDisplayMode(OTWDriverClass::ModePadlockF3);

	push	4
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?SetOTWDisplayMode@OTWDriverClass@@QAEXW4OTWDisplayMode@1@@Z ; OTWDriverClass::SetOTWDisplayMode
$LN2@OTWSelectF:

; 2512 :    }
; 2513 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?OTWSelectF3PadlockMode@@YAXKHPAX@Z ENDP		; OTWSelectF3PadlockMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWToggleCampNames@@YAXKHPAX@Z PROC			; OTWToggleCampNames

; 2447 : {

	push	ebp
	mov	ebp, esp

; 2448 :    if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@OTWToggleC

; 2449 :       OTWDriver.CampTagToggle();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?CampTagToggle@OTWDriverClass@@QAEXXZ	; OTWDriverClass::CampTagToggle
$LN2@OTWToggleC:

; 2450 : }

	pop	ebp
	ret	0
?OTWToggleCampNames@@YAXKHPAX@Z ENDP			; OTWToggleCampNames
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWToggleNames@@YAXKHPAX@Z PROC			; OTWToggleNames

; 2441 : {

	push	ebp
	mov	ebp, esp

; 2442 :    if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@OTWToggleN

; 2443 :       OTWDriver.IDTagToggle();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?IDTagToggle@OTWDriverClass@@QAEXXZ	; OTWDriverClass::IDTagToggle
$LN2@OTWToggleN:

; 2444 : }

	pop	ebp
	ret	0
?OTWToggleNames@@YAXKHPAX@Z ENDP			; OTWToggleNames
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv91 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWStepPrevPadlockAG@@YAXKHPAX@Z PROC			; OTWStepPrevPadlockAG

; 2428 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2429 : 	if ((state & KEY_DOWN) && (SimDriver.GetPlayerAircraft()) && (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP))) {

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN4@OTWStepPre
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN4@OTWStepPre
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN4@OTWStepPre

; 2430 : 		// 2002-02-08 ADDED BY S.G. If we're not in PadlockF3 or PadlockEFOV mode, we need to switch to it first...
; 2431 : 		if (FalconLocalGame->rules.GetPadlockMode() != PDDisabled && OTWDriver.GetOTWDisplayMode() != OTWDriverClass::ModePadlockF3 && OTWDriver.GetOTWDisplayMode() != OTWDriverClass::ModePadlockEFOV) {

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@OTWStepPre
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv91[ebp], eax
	jmp	SHORT $LN7@OTWStepPre
$LN6@OTWStepPre:
	mov	DWORD PTR tv91[ebp], 0
$LN7@OTWStepPre:
	mov	ecx, DWORD PTR tv91[ebp]
	add	ecx, 356				; 00000164H
	call	?GetPadlockMode@RulesClass@@QAEHXZ	; RulesClass::GetPadlockMode
	cmp	eax, 2
	je	SHORT $LN2@OTWStepPre
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetOTWDisplayMode@OTWDriverClass@@QAE?AW4OTWDisplayMode@1@XZ ; OTWDriverClass::GetOTWDisplayMode
	cmp	eax, 4
	je	SHORT $LN2@OTWStepPre
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetOTWDisplayMode@OTWDriverClass@@QAE?AW4OTWDisplayMode@1@XZ ; OTWDriverClass::GetOTWDisplayMode
	cmp	eax, 5
	je	SHORT $LN2@OTWStepPre

; 2432 : 			OTWDriver.Padlock_SetPriority(OTWDriverClass::PriorityAG);

	push	2
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?Padlock_SetPriority@OTWDriverClass@@QAEXW4PadlockPriority@1@@Z ; OTWDriverClass::Padlock_SetPriority

; 2433 : 			OTWDriver.SetOTWDisplayMode(OTWDriverClass::ModePadlockF3);

	push	4
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?SetOTWDisplayMode@OTWDriverClass@@QAEXW4OTWDisplayMode@1@@Z ; OTWDriverClass::SetOTWDisplayMode

; 2434 : 		}
; 2435 : 		else // END OF ADDED SECTION 2002-02-08

	jmp	SHORT $LN4@OTWStepPre
$LN2@OTWStepPre:

; 2436 : 			OTWDriver.TargetStepPrev();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?TargetStepPrev@OTWDriverClass@@QAEXXZ	; OTWDriverClass::TargetStepPrev
$LN4@OTWStepPre:

; 2437 : 	}
; 2438 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?OTWStepPrevPadlockAG@@YAXKHPAX@Z ENDP			; OTWStepPrevPadlockAG
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv91 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWStepPrevPadlockAA@@YAXKHPAX@Z PROC			; OTWStepPrevPadlockAA

; 2414 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2415 : 	if ((state & KEY_DOWN) && (SimDriver.GetPlayerAircraft()) && (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP))) {

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN4@OTWStepPre
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN4@OTWStepPre
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN4@OTWStepPre

; 2416 : 		// 2002-02-08 ADDED BY S.G. If we're not in PadlockF3 or PadlockEFOV mode, we need to switch to it first...
; 2417 : 		if (FalconLocalGame->rules.GetPadlockMode() != PDDisabled && OTWDriver.GetOTWDisplayMode() != OTWDriverClass::ModePadlockF3 && OTWDriver.GetOTWDisplayMode() != OTWDriverClass::ModePadlockEFOV) {

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@OTWStepPre
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv91[ebp], eax
	jmp	SHORT $LN7@OTWStepPre
$LN6@OTWStepPre:
	mov	DWORD PTR tv91[ebp], 0
$LN7@OTWStepPre:
	mov	ecx, DWORD PTR tv91[ebp]
	add	ecx, 356				; 00000164H
	call	?GetPadlockMode@RulesClass@@QAEHXZ	; RulesClass::GetPadlockMode
	cmp	eax, 2
	je	SHORT $LN2@OTWStepPre
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetOTWDisplayMode@OTWDriverClass@@QAE?AW4OTWDisplayMode@1@XZ ; OTWDriverClass::GetOTWDisplayMode
	cmp	eax, 4
	je	SHORT $LN2@OTWStepPre
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetOTWDisplayMode@OTWDriverClass@@QAE?AW4OTWDisplayMode@1@XZ ; OTWDriverClass::GetOTWDisplayMode
	cmp	eax, 5
	je	SHORT $LN2@OTWStepPre

; 2418 : 			OTWDriver.Padlock_SetPriority(OTWDriverClass::PriorityAA);

	push	1
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?Padlock_SetPriority@OTWDriverClass@@QAEXW4PadlockPriority@1@@Z ; OTWDriverClass::Padlock_SetPriority

; 2419 : 			OTWDriver.SetOTWDisplayMode(OTWDriverClass::ModePadlockF3);

	push	4
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?SetOTWDisplayMode@OTWDriverClass@@QAEXW4OTWDisplayMode@1@@Z ; OTWDriverClass::SetOTWDisplayMode

; 2420 : 		}
; 2421 : 		else // END OF ADDED SECTION 2002-02-08

	jmp	SHORT $LN4@OTWStepPre
$LN2@OTWStepPre:

; 2422 : 			OTWDriver.TargetStepPrev();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?TargetStepPrev@OTWDriverClass@@QAEXXZ	; OTWDriverClass::TargetStepPrev
$LN4@OTWStepPre:

; 2423 : 	}
; 2424 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?OTWStepPrevPadlockAA@@YAXKHPAX@Z ENDP			; OTWStepPrevPadlockAA
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv91 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWStepPrevPadlock@@YAXKHPAX@Z PROC			; OTWStepPrevPadlock

; 2400 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2401 : 	if ((state & KEY_DOWN) && (SimDriver.GetPlayerAircraft()) && (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP))) {

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN4@OTWStepPre
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN4@OTWStepPre
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN4@OTWStepPre

; 2402 : 		// 2002-02-08 ADDED BY S.G. If we're not in PadlockF3 or PadlockEFOV mode, we need to switch to it first...
; 2403 : 		if (FalconLocalGame->rules.GetPadlockMode() != PDDisabled && OTWDriver.GetOTWDisplayMode() != OTWDriverClass::ModePadlockF3 && OTWDriver.GetOTWDisplayMode() != OTWDriverClass::ModePadlockEFOV) {

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@OTWStepPre
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv91[ebp], eax
	jmp	SHORT $LN7@OTWStepPre
$LN6@OTWStepPre:
	mov	DWORD PTR tv91[ebp], 0
$LN7@OTWStepPre:
	mov	ecx, DWORD PTR tv91[ebp]
	add	ecx, 356				; 00000164H
	call	?GetPadlockMode@RulesClass@@QAEHXZ	; RulesClass::GetPadlockMode
	cmp	eax, 2
	je	SHORT $LN2@OTWStepPre
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetOTWDisplayMode@OTWDriverClass@@QAE?AW4OTWDisplayMode@1@XZ ; OTWDriverClass::GetOTWDisplayMode
	cmp	eax, 4
	je	SHORT $LN2@OTWStepPre
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetOTWDisplayMode@OTWDriverClass@@QAE?AW4OTWDisplayMode@1@XZ ; OTWDriverClass::GetOTWDisplayMode
	cmp	eax, 5
	je	SHORT $LN2@OTWStepPre

; 2404 : 			OTWDriver.Padlock_SetPriority(OTWDriverClass::PriorityNone);

	push	0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?Padlock_SetPriority@OTWDriverClass@@QAEXW4PadlockPriority@1@@Z ; OTWDriverClass::Padlock_SetPriority

; 2405 : 			OTWDriver.SetOTWDisplayMode(OTWDriverClass::ModePadlockF3);

	push	4
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?SetOTWDisplayMode@OTWDriverClass@@QAEXW4OTWDisplayMode@1@@Z ; OTWDriverClass::SetOTWDisplayMode

; 2406 : 		}
; 2407 : 		else // END OF ADDED SECTION 2002-02-08

	jmp	SHORT $LN4@OTWStepPre
$LN2@OTWStepPre:

; 2408 : 			OTWDriver.TargetStepPrev();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?TargetStepPrev@OTWDriverClass@@QAEXXZ	; OTWDriverClass::TargetStepPrev
$LN4@OTWStepPre:

; 2409 : 	}
; 2410 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?OTWStepPrevPadlock@@YAXKHPAX@Z ENDP			; OTWStepPrevPadlock
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv91 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWStepNextPadlockAG@@YAXKHPAX@Z PROC			; OTWStepNextPadlockAG

; 2387 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2388 : 	if ((state & KEY_DOWN) && (SimDriver.GetPlayerAircraft()) && (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP))) {

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN4@OTWStepNex
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN4@OTWStepNex
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN4@OTWStepNex

; 2389 : 		// 2002-02-08 ADDED BY S.G. If we're not in PadlockF3 or PadlockEFOV mode, we need to switch to it first...
; 2390 : 		if (FalconLocalGame->rules.GetPadlockMode() != PDDisabled && OTWDriver.GetOTWDisplayMode() != OTWDriverClass::ModePadlockF3 && OTWDriver.GetOTWDisplayMode() != OTWDriverClass::ModePadlockEFOV) {

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@OTWStepNex
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv91[ebp], eax
	jmp	SHORT $LN7@OTWStepNex
$LN6@OTWStepNex:
	mov	DWORD PTR tv91[ebp], 0
$LN7@OTWStepNex:
	mov	ecx, DWORD PTR tv91[ebp]
	add	ecx, 356				; 00000164H
	call	?GetPadlockMode@RulesClass@@QAEHXZ	; RulesClass::GetPadlockMode
	cmp	eax, 2
	je	SHORT $LN2@OTWStepNex
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetOTWDisplayMode@OTWDriverClass@@QAE?AW4OTWDisplayMode@1@XZ ; OTWDriverClass::GetOTWDisplayMode
	cmp	eax, 4
	je	SHORT $LN2@OTWStepNex
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetOTWDisplayMode@OTWDriverClass@@QAE?AW4OTWDisplayMode@1@XZ ; OTWDriverClass::GetOTWDisplayMode
	cmp	eax, 5
	je	SHORT $LN2@OTWStepNex

; 2391 : 			OTWDriver.Padlock_SetPriority(OTWDriverClass::PriorityAG);

	push	2
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?Padlock_SetPriority@OTWDriverClass@@QAEXW4PadlockPriority@1@@Z ; OTWDriverClass::Padlock_SetPriority

; 2392 : 			OTWDriver.SetOTWDisplayMode(OTWDriverClass::ModePadlockF3);

	push	4
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?SetOTWDisplayMode@OTWDriverClass@@QAEXW4OTWDisplayMode@1@@Z ; OTWDriverClass::SetOTWDisplayMode

; 2393 : 		}
; 2394 : 		else // END OF ADDED SECTION 2002-02-08

	jmp	SHORT $LN4@OTWStepNex
$LN2@OTWStepNex:

; 2395 : 			OTWDriver.TargetStepNext();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?TargetStepNext@OTWDriverClass@@QAEXXZ	; OTWDriverClass::TargetStepNext
$LN4@OTWStepNex:

; 2396 : 	}
; 2397 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?OTWStepNextPadlockAG@@YAXKHPAX@Z ENDP			; OTWStepNextPadlockAG
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv91 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWStepNextPadlockAA@@YAXKHPAX@Z PROC			; OTWStepNextPadlockAA

; 2373 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2374 : 	if ((state & KEY_DOWN) && (SimDriver.GetPlayerAircraft()) && (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP))) {

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN4@OTWStepNex
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN4@OTWStepNex
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN4@OTWStepNex

; 2375 : 		// 2002-02-08 ADDED BY S.G. If we're not in PadlockF3 or PadlockEFOV mode, we need to switch to it first...
; 2376 : 		if (FalconLocalGame->rules.GetPadlockMode() != PDDisabled && OTWDriver.GetOTWDisplayMode() != OTWDriverClass::ModePadlockF3 && OTWDriver.GetOTWDisplayMode() != OTWDriverClass::ModePadlockEFOV) {

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@OTWStepNex
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv91[ebp], eax
	jmp	SHORT $LN7@OTWStepNex
$LN6@OTWStepNex:
	mov	DWORD PTR tv91[ebp], 0
$LN7@OTWStepNex:
	mov	ecx, DWORD PTR tv91[ebp]
	add	ecx, 356				; 00000164H
	call	?GetPadlockMode@RulesClass@@QAEHXZ	; RulesClass::GetPadlockMode
	cmp	eax, 2
	je	SHORT $LN2@OTWStepNex
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetOTWDisplayMode@OTWDriverClass@@QAE?AW4OTWDisplayMode@1@XZ ; OTWDriverClass::GetOTWDisplayMode
	cmp	eax, 4
	je	SHORT $LN2@OTWStepNex
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetOTWDisplayMode@OTWDriverClass@@QAE?AW4OTWDisplayMode@1@XZ ; OTWDriverClass::GetOTWDisplayMode
	cmp	eax, 5
	je	SHORT $LN2@OTWStepNex

; 2377 : 			OTWDriver.Padlock_SetPriority(OTWDriverClass::PriorityAA);

	push	1
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?Padlock_SetPriority@OTWDriverClass@@QAEXW4PadlockPriority@1@@Z ; OTWDriverClass::Padlock_SetPriority

; 2378 : 			OTWDriver.SetOTWDisplayMode(OTWDriverClass::ModePadlockF3);

	push	4
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?SetOTWDisplayMode@OTWDriverClass@@QAEXW4OTWDisplayMode@1@@Z ; OTWDriverClass::SetOTWDisplayMode

; 2379 : 		}
; 2380 : 		else // END OF ADDED SECTION 2002-02-08

	jmp	SHORT $LN4@OTWStepNex
$LN2@OTWStepNex:

; 2381 : 			OTWDriver.TargetStepNext();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?TargetStepNext@OTWDriverClass@@QAEXXZ	; OTWDriverClass::TargetStepNext
$LN4@OTWStepNex:

; 2382 : 	}
; 2383 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?OTWStepNextPadlockAA@@YAXKHPAX@Z ENDP			; OTWStepNextPadlockAA
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv91 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWStepNextPadlock@@YAXKHPAX@Z PROC			; OTWStepNextPadlock

; 2359 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2360 : 	if ((state & KEY_DOWN) && (SimDriver.GetPlayerAircraft()) && (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP))) {

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN4@OTWStepNex
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN4@OTWStepNex
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN4@OTWStepNex

; 2361 : 		// 2002-02-08 ADDED BY S.G. If we're not in PadlockF3 or PadlockEFOV mode, we need to switch to it first...
; 2362 : 		if (FalconLocalGame->rules.GetPadlockMode() != PDDisabled && OTWDriver.GetOTWDisplayMode() != OTWDriverClass::ModePadlockF3 && OTWDriver.GetOTWDisplayMode() != OTWDriverClass::ModePadlockEFOV) {

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@OTWStepNex
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv91[ebp], eax
	jmp	SHORT $LN7@OTWStepNex
$LN6@OTWStepNex:
	mov	DWORD PTR tv91[ebp], 0
$LN7@OTWStepNex:
	mov	ecx, DWORD PTR tv91[ebp]
	add	ecx, 356				; 00000164H
	call	?GetPadlockMode@RulesClass@@QAEHXZ	; RulesClass::GetPadlockMode
	cmp	eax, 2
	je	SHORT $LN2@OTWStepNex
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetOTWDisplayMode@OTWDriverClass@@QAE?AW4OTWDisplayMode@1@XZ ; OTWDriverClass::GetOTWDisplayMode
	cmp	eax, 4
	je	SHORT $LN2@OTWStepNex
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetOTWDisplayMode@OTWDriverClass@@QAE?AW4OTWDisplayMode@1@XZ ; OTWDriverClass::GetOTWDisplayMode
	cmp	eax, 5
	je	SHORT $LN2@OTWStepNex

; 2363 : 			OTWDriver.Padlock_SetPriority(OTWDriverClass::PriorityNone);

	push	0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?Padlock_SetPriority@OTWDriverClass@@QAEXW4PadlockPriority@1@@Z ; OTWDriverClass::Padlock_SetPriority

; 2364 : 			OTWDriver.SetOTWDisplayMode(OTWDriverClass::ModePadlockF3);

	push	4
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?SetOTWDisplayMode@OTWDriverClass@@QAEXW4OTWDisplayMode@1@@Z ; OTWDriverClass::SetOTWDisplayMode

; 2365 : 		}
; 2366 : 		else // END OF ADDED SECTION 2002-02-08

	jmp	SHORT $LN4@OTWStepNex
$LN2@OTWStepNex:

; 2367 : 			OTWDriver.TargetStepNext();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?TargetStepNext@OTWDriverClass@@QAEXXZ	; OTWDriverClass::TargetStepNext
$LN4@OTWStepNex:

; 2368 : 	}
; 2369 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?OTWStepNextPadlock@@YAXKHPAX@Z ENDP			; OTWStepNextPadlock
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWStepPrevAC@@YAXKHPAX@Z PROC				; OTWStepPrevAC

; 2353 : {

	push	ebp
	mov	ebp, esp

; 2354 :    if ((state & KEY_DOWN))

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@OTWStepPre

; 2355 :       OTWDriver.ViewStepPrev();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?ViewStepPrev@OTWDriverClass@@QAEXXZ	; OTWDriverClass::ViewStepPrev
$LN2@OTWStepPre:

; 2356 : }

	pop	ebp
	ret	0
?OTWStepPrevAC@@YAXKHPAX@Z ENDP				; OTWStepPrevAC
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWStepNextAC@@YAXKHPAX@Z PROC				; OTWStepNextAC

; 2347 : {

	push	ebp
	mov	ebp, esp

; 2348 :    if ((state & KEY_DOWN))

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@OTWStepNex

; 2349 :       OTWDriver.ViewStepNext();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?ViewStepNext@OTWDriverClass@@QAEXXZ	; OTWDriverClass::ViewStepNext
$LN2@OTWStepNex:

; 2350 : }

	pop	ebp
	ret	0
?OTWStepNextAC@@YAXKHPAX@Z ENDP				; OTWStepNextAC
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWTimeOfDayStep@@YAXKHPAX@Z PROC			; OTWTimeOfDayStep

; 2338 : 	{

	push	ebp
	mov	ebp, esp

; 2339 : 	#ifdef _DEBUG
; 2340 : 	   if ((state & KEY_DOWN) && (SimDriver.GetPlayerAircraft()) && (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)))
; 2341 : 		  OTWDriver.todOffset += 1800.0F;
; 2342 : 	#endif
; 2343 : 	}

	pop	ebp
	ret	0
?OTWTimeOfDayStep@@YAXKHPAX@Z ENDP			; OTWTimeOfDayStep
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?AFIdle@@YAXKHPAX@Z PROC				; AFIdle

; 2324 : {

	push	ebp
	mov	ebp, esp

; 2325 :    if ((state & KEY_DOWN) && (SimDriver.GetPlayerAircraft()) && (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)))

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN1@AFIdle
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN1@AFIdle
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN1@AFIdle

; 2326 :       throttleOffset = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR ?throttleOffset@@3MA, xmm0
$LN1@AFIdle:

; 2327 : }

	pop	ebp
	ret	0
?AFIdle@@YAXKHPAX@Z ENDP				; AFIdle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv80 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?AFABOn@@YAXKHPAX@Z PROC				; AFABOn

; 2318 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2319 :    if ((state & KEY_DOWN) && (SimDriver.GetPlayerAircraft()) && (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)))

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN1@AFABOn
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN1@AFABOn
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN1@AFABOn

; 2320 :       throttleOffset = max (1.01F, throttleOffset);

	movss	xmm0, DWORD PTR __real@3f8147ae
	comiss	xmm0, DWORD PTR ?throttleOffset@@3MA
	jbe	SHORT $LN4@AFABOn
	movss	xmm0, DWORD PTR __real@3f8147ae
	movss	DWORD PTR tv80[ebp], xmm0
	jmp	SHORT $LN5@AFABOn
$LN4@AFABOn:
	movss	xmm0, DWORD PTR ?throttleOffset@@3MA
	movss	DWORD PTR tv80[ebp], xmm0
$LN5@AFABOn:
	movss	xmm0, DWORD PTR tv80[ebp]
	movss	DWORD PTR ?throttleOffset@@3MA, xmm0
$LN1@AFABOn:

; 2321 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AFABOn@@YAXKHPAX@Z ENDP				; AFABOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?AFRudderRight@@YAXKHPAX@Z PROC				; AFRudderRight

; 2267 : {

	push	ebp
	mov	ebp, esp

; 2268 :    if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@AFRudderRi

; 2269 : //      rudderOffsetRate = -0.5F;
; 2270 : 		rudderOffsetRate = -g_fAFRudderRight;

	movss	xmm0, DWORD PTR ?g_fAFRudderRight@@3MA
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR ?rudderOffsetRate@@3MA, xmm0

; 2271 :    else

	jmp	SHORT $LN1@AFRudderRi
$LN2@AFRudderRi:

; 2272 :    {
; 2273 :       rudderOffsetRate = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR ?rudderOffsetRate@@3MA, xmm0
$LN1@AFRudderRi:

; 2274 :    }
; 2275 : }

	pop	ebp
	ret	0
?AFRudderRight@@YAXKHPAX@Z ENDP				; AFRudderRight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?AFRudderLeft@@YAXKHPAX@Z PROC				; AFRudderLeft

; 2256 : {

	push	ebp
	mov	ebp, esp

; 2257 :    if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@AFRudderLe

; 2258 : //      rudderOffsetRate = 0.5F;
; 2259 : 		rudderOffsetRate = g_fAFRudderLeft;

	movss	xmm0, DWORD PTR ?g_fAFRudderLeft@@3MA
	movss	DWORD PTR ?rudderOffsetRate@@3MA, xmm0

; 2260 :    else

	jmp	SHORT $LN1@AFRudderLe
$LN2@AFRudderLe:

; 2261 :    {
; 2262 :       rudderOffsetRate = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR ?rudderOffsetRate@@3MA, xmm0
$LN1@AFRudderLe:

; 2263 :    }
; 2264 : }

	pop	ebp
	ret	0
?AFRudderLeft@@YAXKHPAX@Z ENDP				; AFRudderLeft
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?AFThrottleDown@@YAXKHPAX@Z PROC			; AFThrottleDown

; 2240 : {

	push	ebp
	mov	ebp, esp

; 2241 : 	if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@AFThrottle

; 2242 : 	{
; 2243 : 		if(!UseKeyboardThrottle)

	cmp	DWORD PTR ?UseKeyboardThrottle@@3HA, 0	; UseKeyboardThrottle
	jne	SHORT $LN2@AFThrottle

; 2244 : 		{
; 2245 : 			UseKeyboardThrottle = TRUE;

	mov	DWORD PTR ?UseKeyboardThrottle@@3HA, 1	; UseKeyboardThrottle

; 2246 : 			throttleOffset = UserStickInputs.throttle;

	movss	xmm0, DWORD PTR ?UserStickInputs@@3VPilotInputs@@A+68
	movss	DWORD PTR ?throttleOffset@@3MA, xmm0
$LN2@AFThrottle:

; 2247 : 		}
; 2248 : //		throttleOffsetRate -= 0.01F;
; 2249 : 		throttleOffsetRate = -g_fAFThrottleDown;

	movss	xmm0, DWORD PTR ?g_fAFThrottleDown@@3MA
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR ?throttleOffsetRate@@3MA, xmm0

; 2250 : 	}
; 2251 : 	else

	jmp	SHORT $LN1@AFThrottle
$LN3@AFThrottle:

; 2252 : 		throttleOffsetRate = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR ?throttleOffsetRate@@3MA, xmm0
$LN1@AFThrottle:

; 2253 : }

	pop	ebp
	ret	0
?AFThrottleDown@@YAXKHPAX@Z ENDP			; AFThrottleDown
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?AFThrottleUp@@YAXKHPAX@Z PROC				; AFThrottleUp

; 2223 : {

	push	ebp
	mov	ebp, esp

; 2224 : 	if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@AFThrottle

; 2225 : 	{
; 2226 : 		if(!UseKeyboardThrottle)

	cmp	DWORD PTR ?UseKeyboardThrottle@@3HA, 0	; UseKeyboardThrottle
	jne	SHORT $LN2@AFThrottle

; 2227 : 		{
; 2228 : 			UseKeyboardThrottle = TRUE;

	mov	DWORD PTR ?UseKeyboardThrottle@@3HA, 1	; UseKeyboardThrottle

; 2229 : 			throttleOffset = UserStickInputs.throttle;

	movss	xmm0, DWORD PTR ?UserStickInputs@@3VPilotInputs@@A+68
	movss	DWORD PTR ?throttleOffset@@3MA, xmm0
$LN2@AFThrottle:

; 2230 : 		}			
; 2231 : 		//throttleOffsetRate += 0.01F;
; 2232 : 		throttleOffsetRate = g_fAFThrottleUp;

	movss	xmm0, DWORD PTR ?g_fAFThrottleUp@@3MA
	movss	DWORD PTR ?throttleOffsetRate@@3MA, xmm0

; 2233 : 	}
; 2234 : 	else

	jmp	SHORT $LN1@AFThrottle
$LN3@AFThrottle:

; 2235 : 		throttleOffsetRate = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR ?throttleOffsetRate@@3MA, xmm0
$LN1@AFThrottle:

; 2236 : }

	pop	ebp
	ret	0
?AFThrottleUp@@YAXKHPAX@Z ENDP				; AFThrottleUp
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?AFAileronRight@@YAXKHPAX@Z PROC			; AFAileronRight

; 2201 : {

	push	ebp
	mov	ebp, esp

; 2202 :    if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@AFAileronR

; 2203 : //      rollStickOffsetRate += 0.8F;
; 2204 : 		rollStickOffsetRate = g_fAFAileronRight;

	movss	xmm0, DWORD PTR ?g_fAFAileronRight@@3MA
	movss	DWORD PTR ?rollStickOffsetRate@@3MA, xmm0

; 2205 :    else

	jmp	SHORT $LN1@AFAileronR
$LN2@AFAileronR:

; 2206 :    {
; 2207 :       rollStickOffsetRate = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR ?rollStickOffsetRate@@3MA, xmm0
$LN1@AFAileronR:

; 2208 :    }
; 2209 : }

	pop	ebp
	ret	0
?AFAileronRight@@YAXKHPAX@Z ENDP			; AFAileronRight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?AFAileronLeft@@YAXKHPAX@Z PROC				; AFAileronLeft

; 2212 : {

	push	ebp
	mov	ebp, esp

; 2213 :    if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@AFAileronL

; 2214 : //      rollStickOffsetRate -= 0.8F;
; 2215 : 		rollStickOffsetRate = -g_fAFAileronLeft;

	movss	xmm0, DWORD PTR ?g_fAFAileronLeft@@3MA
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR ?rollStickOffsetRate@@3MA, xmm0

; 2216 :    else

	jmp	SHORT $LN1@AFAileronL
$LN2@AFAileronL:

; 2217 :    {
; 2218 :       rollStickOffsetRate = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR ?rollStickOffsetRate@@3MA, xmm0
$LN1@AFAileronL:

; 2219 :    }
; 2220 : }

	pop	ebp
	ret	0
?AFAileronLeft@@YAXKHPAX@Z ENDP				; AFAileronLeft
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?AFElevatorDown@@YAXKHPAX@Z PROC			; AFElevatorDown

; 2190 : {

	push	ebp
	mov	ebp, esp

; 2191 :    if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@AFElevator

; 2192 : //      pitchStickOffsetRate -= 0.5F;
; 2193 : 		pitchStickOffsetRate = -g_fAFElevatorDown;

	movss	xmm0, DWORD PTR ?g_fAFElevatorDown@@3MA
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR ?pitchStickOffsetRate@@3MA, xmm0

; 2194 :    else

	jmp	SHORT $LN1@AFElevator
$LN2@AFElevator:

; 2195 :    {
; 2196 :       pitchStickOffsetRate = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR ?pitchStickOffsetRate@@3MA, xmm0
$LN1@AFElevator:

; 2197 :    }
; 2198 : }

	pop	ebp
	ret	0
?AFElevatorDown@@YAXKHPAX@Z ENDP			; AFElevatorDown
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?AFElevatorUp@@YAXKHPAX@Z PROC				; AFElevatorUp

; 2179 : {

	push	ebp
	mov	ebp, esp

; 2180 :    if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@AFElevator

; 2181 : //      pitchStickOffsetRate = 0.5F;
; 2182 : 		pitchStickOffsetRate = g_fAFElevatorUp;

	movss	xmm0, DWORD PTR ?g_fAFElevatorUp@@3MA
	movss	DWORD PTR ?pitchStickOffsetRate@@3MA, xmm0

; 2183 :    else

	jmp	SHORT $LN1@AFElevator
$LN2@AFElevator:

; 2184 :    {
; 2185 :       pitchStickOffsetRate = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR ?pitchStickOffsetRate@@3MA, xmm0
$LN1@AFElevator:

; 2186 :    }
; 2187 : }

	pop	ebp
	ret	0
?AFElevatorUp@@YAXKHPAX@Z ENDP				; AFElevatorUp
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_tmpThrottle$1 = -4					; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?AFCoarseThrottleDown@@YAXKHPAX@Z PROC			; AFCoarseThrottleDown

; 2295 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2296 :    if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN1@AFCoarseTh

; 2297 :    {
; 2298 :    int tmpThrottle = FloatToInt32(throttleOffset * 100.0F);

	movss	xmm0, DWORD PTR ?throttleOffset@@3MA
	mulss	xmm0, DWORD PTR __real@42c80000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _tmpThrottle$1[ebp], eax

; 2299 : 
; 2300 :       if (throttleOffset < 1.0F)

	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR ?throttleOffset@@3MA
	jbe	SHORT $LN2@AFCoarseTh

; 2301 :       {
; 2302 :          throttleOffset = (tmpThrottle - 25) * 0.01F;

	mov	ecx, DWORD PTR _tmpThrottle$1[ebp]
	sub	ecx, 25					; 00000019H
	cvtsi2ss xmm0, ecx
	mulss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR ?throttleOffset@@3MA, xmm0

; 2303 :       }
; 2304 :       else

	jmp	SHORT $LN1@AFCoarseTh
$LN2@AFCoarseTh:

; 2305 :       {
; 2306 :          throttleOffset = (tmpThrottle - 50/30) * 0.01F;

	mov	edx, DWORD PTR _tmpThrottle$1[ebp]
	sub	edx, 1
	cvtsi2ss xmm0, edx
	mulss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR ?throttleOffset@@3MA, xmm0
$LN1@AFCoarseTh:

; 2307 :       }
; 2308 :    }
; 2309 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AFCoarseThrottleDown@@YAXKHPAX@Z ENDP			; AFCoarseThrottleDown
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_tmpThrottle$1 = -4					; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?AFCoarseThrottleUp@@YAXKHPAX@Z PROC			; AFCoarseThrottleUp

; 2278 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2279 :    if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN1@AFCoarseTh

; 2280 :    {
; 2281 :    int tmpThrottle = FloatToInt32(throttleOffset * 100.0F);

	movss	xmm0, DWORD PTR ?throttleOffset@@3MA
	mulss	xmm0, DWORD PTR __real@42c80000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _tmpThrottle$1[ebp], eax

; 2282 : 
; 2283 :       if (throttleOffset < 1.0F)

	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR ?throttleOffset@@3MA
	jbe	SHORT $LN2@AFCoarseTh

; 2284 :       {
; 2285 :          throttleOffset = (tmpThrottle + 25) * 0.01F;

	mov	ecx, DWORD PTR _tmpThrottle$1[ebp]
	add	ecx, 25					; 00000019H
	cvtsi2ss xmm0, ecx
	mulss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR ?throttleOffset@@3MA, xmm0

; 2286 :       }
; 2287 :       else

	jmp	SHORT $LN1@AFCoarseTh
$LN2@AFCoarseTh:

; 2288 :       {
; 2289 :          throttleOffset = (tmpThrottle + 50/30) * 0.01F;

	mov	edx, DWORD PTR _tmpThrottle$1[ebp]
	add	edx, 1
	cvtsi2ss xmm0, edx
	mulss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR ?throttleOffset@@3MA, xmm0
$LN1@AFCoarseTh:

; 2290 :       }
; 2291 :    }
; 2292 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AFCoarseThrottleUp@@YAXKHPAX@Z ENDP			; AFCoarseThrottleUp
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?AFGearDown@@YAXKHPAX@Z PROC				; AFGearDown

; 2159 : {

	push	ebp
	mov	ebp, esp

; 2160 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN5@AFGearDown

; 2161 : 		return;

	jmp	$LN6@AFGearDown
$LN5@AFGearDown:

; 2162 : 
; 2163 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && SimDriver.GetPlayerAircraft()->af && (state & KEY_DOWN)) // 2002-02-15 MODIFIED BY S.G. Uncommented the ...IsSetFlag(MOTION_OWNSHIP) section and moved it before the ...af check since MOTION_OWNSHIP is only cleared when we're ejected (and we have no gears when ejected anyway)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN4@AFGearDown
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN4@AFGearDown
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+932], 0
	je	$LN4@AFGearDown
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	$LN4@AFGearDown

; 2164 : 	{
; 2165 : 	   if(SimDriver.GetPlayerAircraft()->af->IsSet(AirframeClass::InAir))

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN2@AFGearDown

; 2166 : 	   {
; 2167 : 		   if ( SimDriver.GetPlayerAircraft()->mFaults->GetFault( FaultClass::gear_fault ) ||
; 2168 : 			   SimDriver.GetPlayerAircraft()->af->HydraulicB() == 0 ||
; 2169 : 			   SimDriver.GetPlayerAircraft()->af->altGearDeployed)

	push	15					; 0000000fH
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFault@FackClass@@QAEHW4type_FSubSystem@FaultClass@@@Z ; FackClass::GetFault
	test	eax, eax
	jne	SHORT $LN1@AFGearDown
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?HydraulicB@AirframeClass@@QAEHXZ	; AirframeClass::HydraulicB
	test	eax, eax
	je	SHORT $LN1@AFGearDown
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+932]
	movzx	eax, BYTE PTR [edx+1572]
	test	eax, eax
	je	SHORT $LN2@AFGearDown
$LN1@AFGearDown:

; 2170 : 		   {
; 2171 : 			   return;

	jmp	SHORT $LN6@AFGearDown
$LN2@AFGearDown:

; 2172 : 		   }
; 2173 : 	   }
; 2174 : 	   SimDriver.GetPlayerAircraft()->af->gearHandle = 1.0F;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [ecx+1556], xmm0
$LN4@AFGearDown:
$LN6@AFGearDown:

; 2175 :    }
; 2176 : }

	pop	ebp
	ret	0
?AFGearDown@@YAXKHPAX@Z ENDP				; AFGearDown
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?AFGearUp@@YAXKHPAX@Z PROC				; AFGearUp

; 2139 : {

	push	ebp
	mov	ebp, esp

; 2140 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN5@AFGearUp

; 2141 : 		return;

	jmp	$LN6@AFGearUp
$LN5@AFGearUp:

; 2142 : 
; 2143 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && SimDriver.GetPlayerAircraft()->af && (state & KEY_DOWN)) // 2002-02-15 MODIFIED BY S.G. Uncommented the ...IsSetFlag(MOTION_OWNSHIP) section and moved it before the ...af check since MOTION_OWNSHIP is only cleared when we're ejected (and we have no gears when ejected anyway)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN4@AFGearUp
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN4@AFGearUp
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+932], 0
	je	$LN4@AFGearUp
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	$LN4@AFGearUp

; 2144 : 	{
; 2145 : 	   if(SimDriver.GetPlayerAircraft()->af->IsSet(AirframeClass::InAir))

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN2@AFGearUp

; 2146 : 	   {
; 2147 : 		   if ( SimDriver.GetPlayerAircraft()->mFaults->GetFault( FaultClass::gear_fault ) ||
; 2148 : 			   SimDriver.GetPlayerAircraft()->af->HydraulicB() == 0 ||
; 2149 : 			   SimDriver.GetPlayerAircraft()->af->altGearDeployed)

	push	15					; 0000000fH
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFault@FackClass@@QAEHW4type_FSubSystem@FaultClass@@@Z ; FackClass::GetFault
	test	eax, eax
	jne	SHORT $LN1@AFGearUp
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?HydraulicB@AirframeClass@@QAEHXZ	; AirframeClass::HydraulicB
	test	eax, eax
	je	SHORT $LN1@AFGearUp
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+932]
	movzx	eax, BYTE PTR [edx+1572]
	test	eax, eax
	je	SHORT $LN2@AFGearUp
$LN1@AFGearUp:

; 2150 : 		   {
; 2151 : 			   return;

	jmp	SHORT $LN6@AFGearUp
$LN2@AFGearUp:

; 2152 : 		   }
; 2153 : 	   }
; 2154 : 	   SimDriver.GetPlayerAircraft()->af->gearHandle = -1.0F;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [ecx+1556], xmm0
$LN4@AFGearUp:
$LN6@AFGearUp:

; 2155 :    }
; 2156 : }

	pop	ebp
	ret	0
?AFGearUp@@YAXKHPAX@Z ENDP				; AFGearUp
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?AFGearToggle@@YAXKHPAX@Z PROC				; AFGearToggle

; 2096 : {

	push	ebp
	mov	ebp, esp

; 2097 :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && SimDriver.GetPlayerAircraft()->af && (state & KEY_DOWN)) // 2002-02-15 MODIFIED BY S.G. Uncommented the ...IsSetFlag(MOTION_OWNSHIP) section and moved it before the ...af check since MOTION_OWNSHIP is only cleared when we're ejected (and we have no gears when ejected anyway)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN1@AFGearTogg
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN1@AFGearTogg
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+932], 0
	je	$LN1@AFGearTogg
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN1@AFGearTogg

; 2098 :    {
; 2099 :        // check to see if gear is working
; 2100 : 	   //MI but we want to be able to move our handle with no hydraulics,
; 2101 : 	   //at least when on ground as nothing happens with the gear anyway
; 2102 : 	   if(SimDriver.GetPlayerAircraft()->af->IsSet(AirframeClass::InAir))

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN4@AFGearTogg

; 2103 : 	   {
; 2104 : 		   if ( SimDriver.GetPlayerAircraft()->mFaults->GetFault( FaultClass::gear_fault ) ||
; 2105 : 			   SimDriver.GetPlayerAircraft()->af->HydraulicB() == 0 ||
; 2106 : 			   SimDriver.GetPlayerAircraft()->af->altGearDeployed)

	push	15					; 0000000fH
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFault@FackClass@@QAEHW4type_FSubSystem@FaultClass@@@Z ; FackClass::GetFault
	test	eax, eax
	jne	SHORT $LN3@AFGearTogg
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?HydraulicB@AirframeClass@@QAEHXZ	; AirframeClass::HydraulicB
	test	eax, eax
	je	SHORT $LN3@AFGearTogg
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	movzx	edx, BYTE PTR [ecx+1572]
	test	edx, edx
	je	SHORT $LN4@AFGearTogg
$LN3@AFGearTogg:

; 2107 : 		   {
; 2108 : 			   return;

	jmp	SHORT $LN7@AFGearTogg
$LN4@AFGearTogg:

; 2109 : 		   }
; 2110 : 	   }
; 2111 :        
; 2112 :          if (SimDriver.GetPlayerAircraft()->af->gearHandle > 0.0F)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	eax, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [eax+1556]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN2@AFGearTogg

; 2113 : 		 {
; 2114 :             SimDriver.GetPlayerAircraft()->af->gearHandle = -1.0F;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [ecx+1556], xmm0

; 2115 : 			/*
; 2116 : 	   		F4SoundFXSetPos( SFX_GEARUP, TRUE,
; 2117 : 				SimDriver.GetPlayerAircraft()->XPos(),
; 2118 : 				SimDriver.GetPlayerAircraft()->YPos(),
; 2119 : 				SimDriver.GetPlayerAircraft()->ZPos(), 1.0f );
; 2120 : 			 */
; 2121 : 		 }
; 2122 :          else

	jmp	SHORT $LN1@AFGearTogg
$LN2@AFGearTogg:

; 2123 : 		 {
; 2124 :             SimDriver.GetPlayerAircraft()->af->gearHandle = 1.0F;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+1556], xmm0
$LN1@AFGearTogg:
$LN7@AFGearTogg:

; 2125 : 			/*
; 2126 : 	   		F4SoundFXSetPos( SFX_GEARDN, TRUE,
; 2127 : 				SimDriver.GetPlayerAircraft()->XPos(),
; 2128 : 				SimDriver.GetPlayerAircraft()->YPos(),
; 2129 : 				SimDriver.GetPlayerAircraft()->ZPos(), 1.0f );
; 2130 : 			*/
; 2131 : 		 }
; 2132 :    }
; 2133 : }

	pop	ebp
	ret	0
?AFGearToggle@@YAXKHPAX@Z ENDP				; AFGearToggle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?AFBrakesToggle@@YAXKHPAX@Z PROC			; AFBrakesToggle

; 2053 : {

	push	ebp
	mov	ebp, esp

; 2054 :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN3@AFBrakesTo
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN3@AFBrakesTo

; 2055 :    {
; 2056 :       if (SimDriver.GetPlayerAircraft()->af->HydraulicA() == 0) return;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?HydraulicA@AirframeClass@@QAEHXZ	; AirframeClass::HydraulicA
	test	eax, eax
	jne	SHORT $LN4@AFBrakesTo
	jmp	$LN6@AFBrakesTo
$LN4@AFBrakesTo:

; 2057 :       if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN3@AFBrakesTo

; 2058 :       {
; 2059 : 				//Close the brake
; 2060 : 				if(SimDriver.GetPlayerAircraft()->af->dbrake > 0)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [ecx+1548]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN2@AFBrakesTo

; 2061 : 				{
; 2062 : 					SimDriver.GetPlayerAircraft()->af->speedBrake = -1.0F;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [edx+1560], xmm0

; 2063 : 					SimDriver.GetPlayerAircraft()->brakePos = 4;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR [eax+1588], 4

; 2064 : 				}
; 2065 : 				else

	jmp	SHORT $LN1@AFBrakesTo
$LN2@AFBrakesTo:

; 2066 : 				{
; 2067 : 					SimDriver.GetPlayerAircraft()->af->speedBrake = 1.0F;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	eax, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+1560], xmm0

; 2068 : 					SimDriver.GetPlayerAircraft()->brakePos = 3;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR [eax+1588], 3
$LN1@AFBrakesTo:

; 2069 : 				}
; 2070 : 
; 2071 : 				SimDriver.GetPlayerAircraft()->af->BrakesToggle = TRUE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	mov	BYTE PTR [ecx+1617], 1
$LN3@AFBrakesTo:
$LN6@AFBrakesTo:

; 2072 :       }
; 2073 :    }
; 2074 : }

	pop	ebp
	ret	0
?AFBrakesToggle@@YAXKHPAX@Z ENDP			; AFBrakesToggle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?AFBrakesIn@@YAXKHPAX@Z PROC				; AFBrakesIn

; 2077 : {

	push	ebp
	mov	ebp, esp
	push	esi

; 2078 :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN1@AFBrakesIn
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN1@AFBrakesIn

; 2079 :    {
; 2080 :       if (SimDriver.GetPlayerAircraft()->af->HydraulicA() == 0) return;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?HydraulicA@AirframeClass@@QAEHXZ	; AirframeClass::HydraulicA
	test	eax, eax
	jne	SHORT $LN4@AFBrakesIn
	jmp	$LN6@AFBrakesIn
$LN4@AFBrakesIn:

; 2081 :       if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN3@AFBrakesIn

; 2082 : 	  {
; 2083 :          SimDriver.GetPlayerAircraft()->af->speedBrake = -1.0F;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [ecx+1560], xmm0

; 2084 : 		 SimDriver.GetPlayerAircraft()->speedBrakeState = SimDriver.GetPlayerAircraft()->af->dbrake;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	esi, DWORD PTR [eax+932]
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [esi+1548]
	mov	DWORD PTR [eax+1592], edx

; 2085 : 		 if(SimDriver.GetPlayerAircraft()->af->dbrake == 0.00f)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	eax, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [eax+1548]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@AFBrakesIn

; 2086 : 		 {
; 2087 : 			SimDriver.GetPlayerAircraft()->brakePos = 4;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR [eax+1588], 4
$LN2@AFBrakesIn:

; 2088 : 		 }
; 2089 : 	  }
; 2090 :       else

	jmp	SHORT $LN1@AFBrakesIn
$LN3@AFBrakesIn:

; 2091 :          SimDriver.GetPlayerAircraft()->af->speedBrake = 0.0F;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+1560], xmm0
$LN1@AFBrakesIn:
$LN6@AFBrakesIn:

; 2092 :    }
; 2093 : }

	pop	esi
	pop	ebp
	ret	0
?AFBrakesIn@@YAXKHPAX@Z ENDP				; AFBrakesIn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?AFBrakesOut@@YAXKHPAX@Z PROC				; AFBrakesOut

; 2036 : {

	push	ebp
	mov	ebp, esp

; 2037 :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN1@AFBrakesOu
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN1@AFBrakesOu

; 2038 :    {
; 2039 :       if (SimDriver.GetPlayerAircraft()->af->HydraulicA() == 0) return;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?HydraulicA@AirframeClass@@QAEHXZ	; AirframeClass::HydraulicA
	test	eax, eax
	jne	SHORT $LN3@AFBrakesOu
	jmp	SHORT $LN5@AFBrakesOu
$LN3@AFBrakesOu:

; 2040 :       if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@AFBrakesOu

; 2041 :       {
; 2042 :         SimDriver.GetPlayerAircraft()->af->speedBrake = 1.0F;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [ecx+1560], xmm0

; 2043 : 				SimDriver.GetPlayerAircraft()->brakePos = 3;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR [eax+1588], 3

; 2044 :       }
; 2045 :       else

	jmp	SHORT $LN1@AFBrakesOu
$LN2@AFBrakesOu:

; 2046 :       {
; 2047 :          SimDriver.GetPlayerAircraft()->af->speedBrake = 0.0F;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+1560], xmm0
$LN1@AFBrakesOu:
$LN5@AFBrakesOu:

; 2048 :       }
; 2049 :    }
; 2050 : }

	pop	ebp
	ret	0
?AFBrakesOut@@YAXKHPAX@Z ENDP				; AFBrakesOut
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimEject@@YAXKHPAX@Z PROC				; SimEject

; 1837 : {

	push	ebp
	mov	ebp, esp

; 1838 : 	if(SimDriver.GetPlayerAircraft() != NULL && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN1@SimEject
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN1@SimEject

; 1839 : 	{
; 1840 : 		// We only want to eject if the eject key combo is held 
; 1841 : 		// for > 1 second.
; 1842 : 		if(((AircraftClass *)SimDriver.GetPlayerAircraft())->ejectTriggered == FALSE)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1796], 0
	jne	$LN1@SimEject

; 1843 : 		{
; 1844 : 			if(state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN5@SimEject

; 1845 : 			{
; 1846 : 				//MI
; 1847 : 				if(g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN4@SimEject

; 1848 : 				{
; 1849 : 					if(((AircraftClass*)SimDriver.GetPlayerAircraft())->SeatArmed)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	movzx	edx, BYTE PTR [eax+1052]
	test	edx, edx
	je	SHORT $LN3@SimEject

; 1850 : 					{
; 1851 : 						// Start the timer
; 1852 : 						((AircraftClass *)SimDriver.GetPlayerAircraft())->ejectCountdown = 0.5; //THW 2004-02-17 Changed from 1.0 to 0.5 seconds

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [eax+1800], xmm0

; 1853 : 						((AircraftClass *)SimDriver.GetPlayerAircraft())->doEjectCountdown = TRUE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR [eax+1804], 1
$LN3@SimEject:

; 1854 : 					}
; 1855 : 				}
; 1856 : 				else

	jmp	SHORT $LN2@SimEject
$LN4@SimEject:

; 1857 : 				{
; 1858 : 					// Start the timer
; 1859 : 					((AircraftClass *)SimDriver.GetPlayerAircraft())->ejectCountdown = 0.5; //THW 2004-02-17 Changed from 1.0 to 0.5 seconds

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [eax+1800], xmm0

; 1860 : 					((AircraftClass *)SimDriver.GetPlayerAircraft())->doEjectCountdown = TRUE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR [eax+1804], 1
$LN2@SimEject:

; 1861 : 				}
; 1862 : 			}
; 1863 : 			else

	jmp	SHORT $LN1@SimEject
$LN5@SimEject:

; 1864 : 			{
; 1865 : 				// Cancel the timer
; 1866 : 				((AircraftClass *)SimDriver.GetPlayerAircraft())->doEjectCountdown = FALSE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR [eax+1804], 0
$LN1@SimEject:

; 1867 : 			}
; 1868 : 		}
; 1869 : 	}
; 1870 : }

	pop	ebp
	ret	0
?SimEject@@YAXKHPAX@Z ENDP				; SimEject
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
_pButton$ = 16						; size = 4
?SimNextNavMode@@YAXKHPAX@Z PROC			; SimNextNavMode

; 1825 : {

	push	ebp
	mov	ebp, esp

; 1826 : 	if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag( MOTION_OWNSHIP ) && !((AircraftClass*)SimDriver.GetPlayerAircraft())->ejectTriggered)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN4@SimNextNav
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimNextNav
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimNextNav
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1796], 0
	jne	SHORT $LN4@SimNextNav

; 1827 : 	{
; 1828 : 		if (OTWDriver.pCockpitManager->mpIcp->GetICPPrimaryMode() != NAV_MODE) {

	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [ecx+688]
	call	?GetICPPrimaryMode@ICPClass@@QAEJXZ	; ICPClass::GetICPPrimaryMode
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN2@SimNextNav

; 1829 : 			SimICPNav(val, state, pButton);

	mov	edx, DWORD PTR _pButton$[ebp]
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	mov	ecx, DWORD PTR _val$[ebp]
	push	ecx
	call	?SimICPNav@@YAXKHPAX@Z			; SimICPNav
	add	esp, 12					; 0000000cH

; 1830 : 		} else {

	jmp	SHORT $LN4@SimNextNav
$LN2@SimNextNav:

; 1831 : 			SimICPTILS(val, state, OTWDriver.pCockpitManager->GetButtonPointer( ICP_ILS_BUTTON_ID ));

	push	1015					; 000003f7H
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	call	?GetButtonPointer@CockpitManager@@QAEPAVCPButtonObject@@H@Z ; CockpitManager::GetButtonPointer
	push	eax
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	call	?SimICPTILS@@YAXKHPAX@Z			; SimICPTILS
	add	esp, 12					; 0000000cH
$LN4@SimNextNav:

; 1832 : 		}
; 1833 : 	}
; 1834 : }

	pop	ebp
	ret	0
?SimNextNavMode@@YAXKHPAX@Z ENDP			; SimNextNavMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_pradar$1 = -8						; size = 4
_Sms$ = -4						; size = 4
_val$ = 8						; size = 4
_state$ = 12						; size = 4
_pButton$ = 16						; size = 4
?SimNextAGWeapon@@YAXKHPAX@Z PROC			; SimNextAGWeapon

; 1771 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1772 : SMSClass* Sms;
; 1773 : 
; 1774 : 	if( F4IsBadReadPtr(SimDriver.GetPlayerAircraft(), sizeof(AircraftClass)) || !SimDriver.GetPlayerAircraft()->FCC || // JB 010305 CTD
; 1775 : 		 F4IsBadReadPtr(SimDriver.GetPlayerAircraft()->FCC, sizeof(FireControlComputer)) || // JB 010305 CTD
; 1776 : 		 SimDriver.GetPlayerAircraft()->FCC->GetMasterMode() == FireControlComputer::MissileOverride ||
; 1777 : 		 SimDriver.GetPlayerAircraft()->FCC->GetMasterMode() == FireControlComputer::Dogfight ) 

	push	3624					; 00000e28H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?F4IsBadReadPtr@@YA_NPBXI@Z		; F4IsBadReadPtr
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN10@SimNextAGW
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+936], 0
	je	SHORT $LN10@SimNextAGW
	push	524					; 0000020cH
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	push	ecx
	call	?F4IsBadReadPtr@@YA_NPBXI@Z		; F4IsBadReadPtr
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN10@SimNextAGW
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN10@SimNextAGW
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 9
	jne	SHORT $LN11@SimNextAGW
$LN10@SimNextAGW:

; 1778 : 		return;

	jmp	$LN12@SimNextAGW
$LN11@SimNextAGW:

; 1779 : 
; 1780 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN12@SimNextAGW
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN12@SimNextAGW
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN12@SimNextAGW

; 1781 : 	{
; 1782 : 		if(!g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	jne	$LN8@SimNextAGW

; 1783 : 		{
; 1784 : 			//MI original code
; 1785 : 			if ( ((CPButtonObject*)pButton)->GetCurrentState() == CPBUTTON_OFF ) {

	mov	ecx, DWORD PTR _pButton$[ebp]
	call	?GetCurrentState@CPButtonObject@@QBEHXZ	; CPButtonObject::GetCurrentState
	test	eax, eax
	jne	SHORT $LN7@SimNextAGW

; 1786 : 				SimICPAG(val, state, pButton);

	mov	edx, DWORD PTR _pButton$[ebp]
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	mov	ecx, DWORD PTR _val$[ebp]
	push	ecx
	call	?SimICPAG@@YAXKHPAX@Z			; SimICPAG
	add	esp, 12					; 0000000cH

; 1787 : 				Sms = SimDriver.GetPlayerAircraft()->Sms;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+940]
	mov	DWORD PTR _Sms$[ebp], edx

; 1788 : 				if (Sms)

	cmp	DWORD PTR _Sms$[ebp], 0
	je	SHORT $LN6@SimNextAGW

; 1789 : 			    //Sms->GetNextWeapon(wdGround); // MLR 2/8/2004 - changed
; 1790 : 			    Sms->StepAGWeapon();

	mov	ecx, DWORD PTR _Sms$[ebp]
	call	?StepAGWeapon@SMSClass@@QAEXXZ		; SMSClass::StepAGWeapon
$LN6@SimNextAGW:

; 1791 : 			} else {

	jmp	SHORT $LN5@SimNextAGW
$LN7@SimNextAGW:

; 1792 : 				Sms = SimDriver.GetPlayerAircraft()->Sms;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	eax, DWORD PTR [eax+940]
	mov	DWORD PTR _Sms$[ebp], eax

; 1793 : 				if (Sms)

	cmp	DWORD PTR _Sms$[ebp], 0
	je	SHORT $LN4@SimNextAGW

; 1794 : 			    //Sms->GetNextWeapon(wdGround); // MLR 2/8/2004 - changed
; 1795 : 			    Sms->StepAGWeapon();

	mov	ecx, DWORD PTR _Sms$[ebp]
	call	?StepAGWeapon@SMSClass@@QAEXXZ		; SMSClass::StepAGWeapon
$LN4@SimNextAGW:

; 1796 : 			   OTWDriver.pCockpitManager->mpIcp->HandleInput(AG_BUTTON, (CPButtonObject*)pButton);

	mov	ecx, DWORD PTR _pButton$[ebp]
	push	ecx
	push	12					; 0000000cH
	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [edx+688]
	call	?HandleInput@ICPClass@@QAEXHPAVCPButtonObject@@@Z ; ICPClass::HandleInput

; 1797 : 			   MfdDisplay[0]->SetNewMode(MFDClass::FCRMode);

	push	10					; 0000000aH
	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[eax]
	call	?SetNewMode@MFDClass@@QAEXW4MfdMode@1@@Z ; MFDClass::SetNewMode

; 1798 : 			   MfdDisplay[1]->SetNewMode(MFDClass::SMSMode);

	push	11					; 0000000bH
	mov	ecx, 4
	shl	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?SetNewMode@MFDClass@@QAEXW4MfdMode@1@@Z ; MFDClass::SetNewMode
$LN5@SimNextAGW:

; 1799 : 			}
; 1800 : 		}
; 1801 : 		else

	jmp	$LN12@SimNextAGW
$LN8@SimNextAGW:

; 1802 : 		{	
; 1803 : 			 //MI modified for ICP
; 1804 : 			Sms = SimDriver.GetPlayerAircraft()->Sms;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+940]
	mov	DWORD PTR _Sms$[ebp], edx

; 1805 : 			if (Sms) 

	cmp	DWORD PTR _Sms$[ebp], 0
	je	SHORT $LN2@SimNextAGW

; 1806 : 			{
; 1807 : 			    //Sms->GetNextWeapon(wdGround); // MLR 2/8/2004 - changed
; 1808 : 			    Sms->StepAGWeapon();

	mov	ecx, DWORD PTR _Sms$[ebp]
	call	?StepAGWeapon@SMSClass@@QAEXXZ		; SMSClass::StepAGWeapon

; 1809 : 				Sms->drawable->SetDisplayMode(SmsDrawable::Wpn);

	push	2
	mov	eax, DWORD PTR _Sms$[ebp]
	mov	ecx, DWORD PTR [eax+160]
	call	?SetDisplayMode@SmsDrawable@@QAEXW4SmsDisplayMode@1@@Z ; SmsDrawable::SetDisplayMode
$LN2@SimNextAGW:

; 1810 : 			}
; 1811 : 			//Put the radar in the its default AG mode
; 1812 : 			RadarClass* pradar = (RadarClass*) FindSensor (SimDriver.GetPlayerAircraft(), SensorClass::Radar);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _pradar$1[ebp], eax

; 1813 : 			if (pradar)

	cmp	DWORD PTR _pradar$1[ebp], 0
	je	SHORT $LN1@SimNextAGW

; 1814 : 				pradar->DefaultAGMode();

	mov	ecx, DWORD PTR _pradar$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pradar$1[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
$LN1@SimNextAGW:

; 1815 : 			OTWDriver.pCockpitManager->mpIcp->SetICPFlag(ICPClass::MODE_A_G);

	push	2
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [ecx+688]
	call	?SetICPFlag@ICPClass@@QAEXH@Z		; ICPClass::SetICPFlag

; 1816 : 			OTWDriver.pCockpitManager->mpIcp->ClearICPFlag(ICPClass::MODE_A_A);

	push	1
	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [edx+688]
	call	?ClearICPFlag@ICPClass@@QAEXH@Z		; ICPClass::ClearICPFlag

; 1817 : 			// Configure the MFDs
; 1818 : 			MfdDisplay[0]->SetNewMasterMode(SimDriver.GetPlayerAircraft()->FCC->GetMainMasterMode());

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?GetMainMasterMode@FireControlComputer@@QAE?AW4MASTERMODES@@XZ ; FireControlComputer::GetMainMasterMode
	push	eax
	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[eax]
	call	?SetNewMasterMode@MFDClass@@QAEXH@Z	; MFDClass::SetNewMasterMode

; 1819 : 			MfdDisplay[1]->SetNewMasterMode(SimDriver.GetPlayerAircraft()->FCC->GetMainMasterMode());

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?GetMainMasterMode@FireControlComputer@@QAE?AW4MASTERMODES@@XZ ; FireControlComputer::GetMainMasterMode
	push	eax
	mov	ecx, 4
	shl	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?SetNewMasterMode@MFDClass@@QAEXH@Z	; MFDClass::SetNewMasterMode
$LN12@SimNextAGW:

; 1820 : 		}
; 1821 : 	}
; 1822 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimNextAGWeapon@@YAXKHPAX@Z ENDP			; SimNextAGWeapon
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_pradar$1 = -8						; size = 4
_Sms$ = -4						; size = 4
_val$ = 8						; size = 4
_state$ = 12						; size = 4
_pButton$ = 16						; size = 4
?SimNextAAWeapon@@YAXKHPAX@Z PROC			; SimNextAAWeapon

; 1644 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1645 : 	SMSClass* Sms;
; 1646 : 
; 1647 :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN10@SimNextAAW
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN10@SimNextAAW
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN10@SimNextAAW

; 1648 :    {
; 1649 : 	   if(!g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	jne	$LN8@SimNextAAW

; 1650 : 	   {
; 1651 : 		   //MI original Code
; 1652 : 		   if ( ((CPButtonObject*)pButton)->GetCurrentState() == CPBUTTON_OFF ) {

	mov	ecx, DWORD PTR _pButton$[ebp]
	call	?GetCurrentState@CPButtonObject@@QBEHXZ	; CPButtonObject::GetCurrentState
	test	eax, eax
	jne	SHORT $LN7@SimNextAAW

; 1653 : 			   SimICPAA(val, state, pButton);

	mov	edx, DWORD PTR _pButton$[ebp]
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	mov	ecx, DWORD PTR _val$[ebp]
	push	ecx
	call	?SimICPAA@@YAXKHPAX@Z			; SimICPAA
	add	esp, 12					; 0000000cH

; 1654 : 			   Sms = SimDriver.GetPlayerAircraft()->Sms;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+940]
	mov	DWORD PTR _Sms$[ebp], edx

; 1655 : 			   if (Sms)

	cmp	DWORD PTR _Sms$[ebp], 0
	je	SHORT $LN6@SimNextAAW

; 1656 : 			    //Sms->GetNextWeapon(wdGround); // MLR 2/8/2004 - changed
; 1657 : 			    Sms->StepAAWeapon();

	mov	ecx, DWORD PTR _Sms$[ebp]
	call	?StepAAWeapon@SMSClass@@QAEXXZ		; SMSClass::StepAAWeapon
$LN6@SimNextAAW:

; 1658 : 		   } else {

	jmp	SHORT $LN5@SimNextAAW
$LN7@SimNextAAW:

; 1659 : 			   Sms = SimDriver.GetPlayerAircraft()->Sms;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	eax, DWORD PTR [eax+940]
	mov	DWORD PTR _Sms$[ebp], eax

; 1660 : 			   if (Sms)

	cmp	DWORD PTR _Sms$[ebp], 0
	je	SHORT $LN4@SimNextAAW

; 1661 : 			    //Sms->GetNextWeapon(wdGround); // MLR 2/8/2004 - changed
; 1662 : 			    Sms->StepAAWeapon();

	mov	ecx, DWORD PTR _Sms$[ebp]
	call	?StepAAWeapon@SMSClass@@QAEXXZ		; SMSClass::StepAAWeapon
$LN4@SimNextAAW:

; 1663 : 			   OTWDriver.pCockpitManager->mpIcp->HandleInput(AA_BUTTON, (CPButtonObject*)pButton);

	mov	ecx, DWORD PTR _pButton$[ebp]
	push	ecx
	push	11					; 0000000bH
	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [edx+688]
	call	?HandleInput@ICPClass@@QAEXHPAVCPButtonObject@@@Z ; ICPClass::HandleInput

; 1664 : 			   MfdDisplay[0]->SetNewMode(MFDClass::FCRMode);

	push	10					; 0000000aH
	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[eax]
	call	?SetNewMode@MFDClass@@QAEXW4MfdMode@1@@Z ; MFDClass::SetNewMode

; 1665 : 			   MfdDisplay[1]->SetNewMode(MFDClass::SMSMode);

	push	11					; 0000000bH
	mov	ecx, 4
	shl	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?SetNewMode@MFDClass@@QAEXW4MfdMode@1@@Z ; MFDClass::SetNewMode
$LN5@SimNextAAW:

; 1666 : 		   }
; 1667 : 	   }
; 1668 : 	   else

	jmp	$LN10@SimNextAAW
$LN8@SimNextAAW:

; 1669 : 	   {
; 1670 : 		   //MI modified for ICP
; 1671 : 		   /* // MLR 2/8/2004 - 
; 1672 : 			if( SimDriver.GetPlayerAircraft()->FCC->GetSubMode() == (FireControlComputer::STRAF) ||	// ASSOCIATOR: Added a STAF check here so we can get out of it
; 1673 : 			   SimDriver.GetPlayerAircraft()->FCC->GetMasterMode() != (FireControlComputer::AAGun) &&
; 1674 : 			   SimDriver.GetPlayerAircraft()->FCC->GetMasterMode() != (FireControlComputer::Missile) &&
; 1675 : 			   SimDriver.GetPlayerAircraft()->FCC->GetMasterMode() != (FireControlComputer::Dogfight) &&
; 1676 : 			   SimDriver.GetPlayerAircraft()->FCC->GetMasterMode() != (FireControlComputer::MissileOverride))
; 1677 : 				  SimDriver.GetPlayerAircraft()->FCC->SetMasterMode( SimDriver.GetPlayerAircraft()->FCC->GetLastAaMasterMode() );
; 1678 : 			*/
; 1679 : 		   Sms = SimDriver.GetPlayerAircraft()->Sms;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+940]
	mov	DWORD PTR _Sms$[ebp], edx

; 1680 : 		   // MLR 2/8/2004 - renamed function
; 1681 : 		   //Sms->StepWeaponClass();	// ASSOCIATOR: now it steps the weapon type instead of Missile stepping each weapon 
; 1682 : 		   Sms->StepAAWeapon();	// ASSOCIATOR: now it steps the weapon type instead of Missile stepping each weapon 

	mov	ecx, DWORD PTR _Sms$[ebp]
	call	?StepAAWeapon@SMSClass@@QAEXXZ		; SMSClass::StepAAWeapon

; 1683 : 
; 1684 : 		   // ASSOCIATOR: This whole section is redundant now and is handled in a central place in the SelectWeapon method
; 1685 : 		   /*if (Sms && SimDriver.GetPlayerAircraft()->FCC->GetMasterMode() != FireControlComputer::Dogfight && 
; 1686 : 					SimDriver.GetPlayerAircraft()->FCC->GetMasterMode() != FireControlComputer::MissileOverride ) 
; 1687 : 		   {
; 1688 : 			   //Sms->GetNextWeapon(wdAir);
; 1689 : 			   Sms->curWeaponDomain = wdAir;
; 1690 : 			   Sms->StepWeaponClass();
; 1691 : 
; 1692 : 			   Sms->drawable->SetDisplayMode(SmsDrawable::Wpn);
; 1693 : 			   
; 1694 : 			   // ASSOCIATOR 03/12/03: Commented out this section becasue with new fixes it is redundant
; 1695 : 			   // Marco Edit - Dogfight check for AIM120
; 1696 : 			   //if (SimDriver.GetPlayerAircraft()->FCC->GetMasterMode() == (FireControlComputer::Dogfight) && Sms->curWeaponType == wtAim120)
; 1697 : 			   //{
; 1698 : 			   //	SimDriver.GetPlayerAircraft()->FCC->SetDgftSubMode(FireControlComputer::Aim120);
; 1699 : 			   //}
; 1700 : 			}
; 1701 : 			*/
; 1702 : 	
; 1703 : 			// ASSOCIATOR 03/12/03: Put the radar in the its default AA mode but not while in Dogfight mode
; 1704 : 			if( SimDriver.GetPlayerAircraft()->FCC->GetMasterMode() != FireControlComputer::Dogfight )

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 9
	je	SHORT $LN2@SimNextAAW

; 1705 : 			{
; 1706 : 				// Put the radar in the its default AA mode
; 1707 : 				RadarClass* pradar = (RadarClass*) FindSensor (SimDriver.GetPlayerAircraft(), SensorClass::Radar);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _pradar$1[ebp], eax

; 1708 : 				if (pradar)

	cmp	DWORD PTR _pradar$1[ebp], 0
	je	SHORT $LN2@SimNextAAW

; 1709 : 					pradar->DefaultAAMode();

	mov	eax, DWORD PTR _pradar$1[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pradar$1[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN2@SimNextAAW:

; 1710 : 			}
; 1711 : 
; 1712 : 		   OTWDriver.pCockpitManager->mpIcp->SetICPFlag(ICPClass::MODE_A_A);

	push	1
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [ecx+688]
	call	?SetICPFlag@ICPClass@@QAEXH@Z		; ICPClass::SetICPFlag

; 1713 : 		   OTWDriver.pCockpitManager->mpIcp->ClearICPFlag(ICPClass::MODE_A_G);

	push	2
	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [edx+688]
	call	?ClearICPFlag@ICPClass@@QAEXH@Z		; ICPClass::ClearICPFlag

; 1714 : 		   MfdDisplay[0]->SetNewMasterMode(SimDriver.GetPlayerAircraft()->FCC->GetMainMasterMode());

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?GetMainMasterMode@FireControlComputer@@QAE?AW4MASTERMODES@@XZ ; FireControlComputer::GetMainMasterMode
	push	eax
	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[eax]
	call	?SetNewMasterMode@MFDClass@@QAEXH@Z	; MFDClass::SetNewMasterMode

; 1715 : 		   MfdDisplay[1]->SetNewMasterMode(SimDriver.GetPlayerAircraft()->FCC->GetMainMasterMode());

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?GetMainMasterMode@FireControlComputer@@QAE?AW4MASTERMODES@@XZ ; FireControlComputer::GetMainMasterMode
	push	eax
	mov	ecx, 4
	shl	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?SetNewMasterMode@MFDClass@@QAEXH@Z	; MFDClass::SetNewMasterMode
$LN10@SimNextAAW:

; 1716 : 	   }
; 1717 :    }
; 1718 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimNextAAWeapon@@YAXKHPAX@Z ENDP			; SimNextAAWeapon
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimEndFlight@@YAXKHPAX@Z PROC				; SimEndFlight

; 1637 : {

	push	ebp
	mov	ebp, esp

; 1638 : 	if ((state & KEY_DOWN)){

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimEndFlig

; 1639 : 		OTWDriver.EndFlight();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?EndFlight@OTWDriverClass@@QAEXXZ	; OTWDriverClass::EndFlight
$LN2@SimEndFlig:

; 1640 : 	}
; 1641 : }

	pop	ebp
	ret	0
?SimEndFlight@@YAXKHPAX@Z ENDP				; SimEndFlight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimFCCSubModeStep@@YAXKHPAX@Z PROC			; SimFCCSubModeStep

; 1627 : {

	push	ebp
	mov	ebp, esp

; 1628 : 	if (
; 1629 : 		SimDriver.GetPlayerAircraft() && 
; 1630 : 		SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)
; 1631 : 	){

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimFCCSubM
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimFCCSubM
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimFCCSubM

; 1632 : 		SimDriver.GetPlayerAircraft()->FCC->NextSubMode();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?NextSubMode@FireControlComputer@@QAEXXZ ; FireControlComputer::NextSubMode
$LN2@SimFCCSubM:

; 1633 : 	}
; 1634 : }

	pop	ebp
	ret	0
?SimFCCSubModeStep@@YAXKHPAX@Z ENDP			; SimFCCSubModeStep
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv90 = -8						; size = 4
tv76 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimToggleInvincible@@YAXKHPAX@Z PROC			; SimToggleInvincible

; 1606 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1607 : 	
; 1608 : 	if(FalconLocalGame && !FalconLocalGame->rules.InvulnerableOn())

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN7@SimToggleI
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN8@SimToggleI
$LN7@SimToggleI:
	mov	DWORD PTR tv76[ebp], 0
$LN8@SimToggleI:
	cmp	DWORD PTR tv76[ebp], 0
	je	SHORT $LN4@SimToggleI
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN9@SimToggleI
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv90[ebp], eax
	jmp	SHORT $LN10@SimToggleI
$LN9@SimToggleI:
	mov	DWORD PTR tv90[ebp], 0
$LN10@SimToggleI:
	mov	ecx, DWORD PTR tv90[ebp]
	add	ecx, 356				; 00000164H
	call	?InvulnerableOn@RulesClass@@QAEHXZ	; RulesClass::InvulnerableOn
	test	eax, eax
	jne	SHORT $LN4@SimToggleI

; 1609 : 		return;	

	jmp	SHORT $LN5@SimToggleI
$LN4@SimToggleI:

; 1610 : 	
; 1611 : 	if (state & KEY_DOWN)

	mov	edx, DWORD PTR _state$[ebp]
	and	edx, 8
	je	SHORT $LN5@SimToggleI

; 1612 : 	{
; 1613 : 		if(PlayerOptions.InvulnerableOn())

	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?InvulnerableOn@PlayerOptionsClass@@QAEHXZ ; PlayerOptionsClass::InvulnerableOn
	test	eax, eax
	je	SHORT $LN2@SimToggleI

; 1614 : 			{
; 1615 : 			PlayerOptions.ClearSimFlag(SIM_INVULNERABLE);

	push	512					; 00000200H
	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?ClearSimFlag@PlayerOptionsClass@@QAEXH@Z ; PlayerOptionsClass::ClearSimFlag

; 1616 : 			SimDriver.GetPlayerAircraft()->UnSetFalcFlag(FEC_INVULNERABLE);

	push	32					; 00000020H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?UnSetFalcFlag@FalconEntity@@QAEXH@Z	; FalconEntity::UnSetFalcFlag

; 1617 : 			}
; 1618 : 		else

	jmp	SHORT $LN5@SimToggleI
$LN2@SimToggleI:

; 1619 : 			{
; 1620 : 			PlayerOptions.SetSimFlag(SIM_INVULNERABLE);

	push	512					; 00000200H
	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?SetSimFlag@PlayerOptionsClass@@QAEXH@Z	; PlayerOptionsClass::SetSimFlag

; 1621 : 			SimDriver.GetPlayerAircraft()->SetFalcFlag(FEC_INVULNERABLE);

	push	32					; 00000020H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetFalcFlag@FalconEntity@@QAEXH@Z	; FalconEntity::SetFalcFlag
$LN5@SimToggleI:

; 1622 : 			}
; 1623 : 	}
; 1624 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimToggleInvincible@@YAXKHPAX@Z ENDP			; SimToggleInvincible
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimHSDRangeStepDown@@YAXKHPAX@Z PROC			; SimHSDRangeStepDown

; 1597 : {

	push	ebp
	mov	ebp, esp

; 1598 :    //if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)) // JB 010220 CTD
; 1599 : 	 if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && !F4IsBadReadPtr(SimDriver.GetPlayerAircraft(), sizeof(AircraftClass)) && SimDriver.GetPlayerAircraft()->FCC && !F4IsBadWritePtr(SimDriver.GetPlayerAircraft()->FCC, sizeof(FireControlComputer)) && (state & KEY_DOWN)) // JB 010220 CTD

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN2@SimHSDRang
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimHSDRang
	push	3624					; 00000e28H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?F4IsBadReadPtr@@YA_NPBXI@Z		; F4IsBadReadPtr
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@SimHSDRang
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+936], 0
	je	SHORT $LN2@SimHSDRang
	push	524					; 0000020cH
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	push	ecx
	call	?F4IsBadWritePtr@@YA_NPAXI@Z		; F4IsBadWritePtr
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@SimHSDRang
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimHSDRang

; 1600 :    {
; 1601 :       SimDriver.GetPlayerAircraft()->FCC->HSDRangeStepCmd = -1;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	mov	BYTE PTR [ecx+195], -1
$LN2@SimHSDRang:

; 1602 :    }
; 1603 : }

	pop	ebp
	ret	0
?SimHSDRangeStepDown@@YAXKHPAX@Z ENDP			; SimHSDRangeStepDown
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimHSDRangeStepUp@@YAXKHPAX@Z PROC			; SimHSDRangeStepUp

; 1588 : {

	push	ebp
	mov	ebp, esp

; 1589 :    //if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)) // JB 010220 CTD
; 1590 : 	 if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && !F4IsBadReadPtr(SimDriver.GetPlayerAircraft(), sizeof(AircraftClass)) && SimDriver.GetPlayerAircraft()->FCC && !F4IsBadWritePtr(SimDriver.GetPlayerAircraft()->FCC, sizeof(FireControlComputer)) && (state & KEY_DOWN)) // JB 010220 CTD

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN2@SimHSDRang
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimHSDRang
	push	3624					; 00000e28H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?F4IsBadReadPtr@@YA_NPBXI@Z		; F4IsBadReadPtr
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@SimHSDRang
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+936], 0
	je	SHORT $LN2@SimHSDRang
	push	524					; 0000020cH
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	push	ecx
	call	?F4IsBadWritePtr@@YA_NPAXI@Z		; F4IsBadWritePtr
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@SimHSDRang
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimHSDRang

; 1591 :    {
; 1592 :       SimDriver.GetPlayerAircraft()->FCC->HSDRangeStepCmd = 1;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	mov	BYTE PTR [ecx+195], 1
$LN2@SimHSDRang:

; 1593 :    }
; 1594 : }

	pop	ebp
	ret	0
?SimHSDRangeStepUp@@YAXKHPAX@Z ENDP			; SimHSDRangeStepUp
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_theRwr$1 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimToggleDropPattern@@YAXKHPAX@Z PROC			; SimToggleDropPattern

; 217  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 218  :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimToggleD
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimToggleD
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimToggleD

; 219  :    {
; 220  : 	PlayerRwrClass* theRwr = (PlayerRwrClass*)FindSensor(SimDriver.GetPlayerAircraft(), SensorClass::RWR);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRwr$1[ebp], eax

; 221  : 
; 222  : 		if(theRwr)

	cmp	DWORD PTR _theRwr$1[ebp], 0
	je	SHORT $LN3@SimToggleD

; 223  :       {
; 224  : 			theRwr->ToggleAutoDrop();

	mov	ecx, DWORD PTR _theRwr$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRwr$1[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
$LN3@SimToggleD:

; 225  : 		}
; 226  : 	}
; 227  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimToggleDropPattern@@YAXKHPAX@Z ENDP			; SimToggleDropPattern
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_playerAC$ = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimDropFlare@@YAXKHPAX@Z PROC				; SimDropFlare

; 1569 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1570 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 1571 : 	if (playerAC && playerAC->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	$LN5@SimDropFla
	push	65536					; 00010000H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN5@SimDropFla
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN5@SimDropFla

; 1572 : 	{
; 1573 : 		// RV - Biker - Hack AC with IFF now can drop programmed EWS (player only)
; 1574 : 		// if(!g_bRealisticAvionics || !SimDriver.GetPlayerAircraft()->af->platform->IsF16())
; 1575 : 		if (
; 1576 : 			!g_bRealisticAvionics || 
; 1577 : 			!(playerAC->af->platform->IsF16() || playerAC->af->platform->GetiffEnabled())
; 1578 : 		){

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN2@SimDropFla
	mov	edx, DWORD PTR _playerAC$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+1088]
	call	?IsF16@AircraftClass@@QAEHXZ		; AircraftClass::IsF16
	test	eax, eax
	jne	SHORT $LN3@SimDropFla
	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+1088]
	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+1088]
	mov	edx, DWORD PTR [eax+476]
	call	edx
	test	eax, eax
	jne	SHORT $LN3@SimDropFla
$LN2@SimDropFla:

; 1579 : 		   playerAC->dropFlareCmd = TRUE;

	mov	eax, DWORD PTR _playerAC$[ebp]
	mov	BYTE PTR [eax+961], 1

; 1580 : 		}
; 1581 : 		else {

	jmp	SHORT $LN5@SimDropFla
$LN3@SimDropFla:

; 1582 : 			SimDropProgrammed(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimDropProgrammed@@YAXKHPAX@Z		; SimDropProgrammed
	add	esp, 12					; 0000000cH
$LN5@SimDropFla:

; 1583 : 		}
; 1584 : 	}
; 1585 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimDropFlare@@YAXKHPAX@Z ENDP				; SimDropFlare
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv94 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimDropChaff@@YAXKHPAX@Z PROC				; SimDropChaff

; 1535 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1536 : 	static unsigned int realEWSProgNum = FALSE;
; 1537 :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN9@SimDropCha
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN9@SimDropCha
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN9@SimDropCha

; 1538 :    {
; 1539 : 	   
; 1540 : 	   //MI
; 1541 :        // RV - Biker - Hack AC with IFF now can drop programmed EWS (player only)
; 1542 :        // if(!g_bRealisticAvionics || !SimDriver.GetPlayerAircraft()->af->platform->IsF16())
; 1543 :        if(!g_bRealisticAvionics || !(SimDriver.GetPlayerAircraft()->af->platform->IsF16() || SimDriver.GetPlayerAircraft()->af->platform->GetiffEnabled()))

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN7@SimDropCha
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+932]
	mov	ecx, DWORD PTR [edx+1088]
	call	?IsF16@AircraftClass@@QAEHXZ		; AircraftClass::IsF16
	test	eax, eax
	jne	SHORT $LN8@SimDropCha
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	eax, DWORD PTR [eax+932]
	mov	ecx, DWORD PTR [eax+1088]
	mov	DWORD PTR tv94[ebp], ecx
	mov	edx, DWORD PTR tv94[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv94[ebp]
	mov	edx, DWORD PTR [eax+476]
	call	edx
	test	eax, eax
	jne	SHORT $LN8@SimDropCha
$LN7@SimDropCha:

; 1544 : 		   SimDriver.GetPlayerAircraft()->dropChaffCmd = TRUE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	BYTE PTR [eax+960], 1
	jmp	SHORT $LN6@SimDropCha
$LN8@SimDropCha:

; 1545 : 	   else if (g_bMLU)

	movzx	eax, BYTE PTR ?g_bMLU@@3_NA		; g_bMLU
	test	eax, eax
	je	SHORT $LN5@SimDropCha

; 1546 : 	   {
; 1547 : 		//me123 hack hack  i want the posibility to assign two programs...so now a chaff hit will default to program 1
; 1548 : 			
; 1549 : 			if (!realEWSProgNum) realEWSProgNum= SimDriver.GetPlayerAircraft()->EWSProgNum;

	cmp	DWORD PTR ?realEWSProgNum@?1??SimDropChaff@@YAXKHPAX@Z@4IA, 0
	jne	SHORT $LN4@SimDropCha
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+1500]
	mov	DWORD PTR ?realEWSProgNum@?1??SimDropChaff@@YAXKHPAX@Z@4IA, ecx
$LN4@SimDropCha:

; 1550 : 			SimDriver.GetPlayerAircraft()->EWSProgNum = 0;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR [eax+1500], 0

; 1551 : 		    SimDriver.GetPlayerAircraft()->DropEWS();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?DropEWS@AircraftClass@@QAEXXZ		; AircraftClass::DropEWS

; 1552 : 		    SimDropProgrammed(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimDropProgrammed@@YAXKHPAX@Z		; SimDropProgrammed
	add	esp, 12					; 0000000cH

; 1553 : 
; 1554 : 	   }
; 1555 : 	   else

	jmp	SHORT $LN6@SimDropCha
$LN5@SimDropCha:

; 1556 : 	   {
; 1557 : 		   SimDropProgrammed(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimDropProgrammed@@YAXKHPAX@Z		; SimDropProgrammed
	add	esp, 12					; 0000000cH
$LN6@SimDropCha:

; 1558 : 	   }
; 1559 :    }
; 1560 :    else if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) &&

	jmp	SHORT $LN10@SimDropCha
$LN9@SimDropCha:

; 1561 : 	   g_bMLU)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN10@SimDropCha
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN10@SimDropCha
	movzx	edx, BYTE PTR ?g_bMLU@@3_NA		; g_bMLU
	test	edx, edx
	je	SHORT $LN10@SimDropCha

; 1562 :    {
; 1563 : 	   SimDriver.GetPlayerAircraft()->EWSProgNum = realEWSProgNum ;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR ?realEWSProgNum@?1??SimDropChaff@@YAXKHPAX@Z@4IA
	mov	DWORD PTR [eax+1500], ecx

; 1564 : 	   realEWSProgNum = FALSE;

	mov	DWORD PTR ?realEWSProgNum@?1??SimDropChaff@@YAXKHPAX@Z@4IA, 0
$LN10@SimDropCha:

; 1565 :    }
; 1566 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimDropChaff@@YAXKHPAX@Z ENDP				; SimDropChaff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_wpn$1 = -12						; size = 4
tv88 = -8						; size = 4
_pac$ = -4						; size = 4
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimToggleMissileTDBPUncage@@YAXKHPAX@Z PROC		; SimToggleMissileTDBPUncage

; 1521 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1522 : 	AircraftClass *pac = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _pac$[ebp], eax

; 1523 : 	if (pac && pac->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN) && pac->Sms){

	cmp	DWORD PTR _pac$[ebp], 0
	je	$LN4@SimToggleM
	push	65536					; 00010000H
	mov	ecx, DWORD PTR _pac$[ebp]
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimToggleM
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN4@SimToggleM
	mov	ecx, DWORD PTR _pac$[ebp]
	cmp	DWORD PTR [ecx+940], 0
	je	SHORT $LN4@SimToggleM

; 1524 : 		SimWeaponClass* wpn = SimDriver.GetPlayerAircraft()->Sms->GetCurrentWeapon();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+940]
	mov	DWORD PTR tv88[ebp], edx
	mov	eax, DWORD PTR tv88[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv88[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _wpn$1[ebp], eax

; 1525 : 		if (g_bRealisticAvionics && wpn && ((CampBaseClass*)wpn)->GetSPType() == SPTYPE_AIM9P){

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN2@SimToggleM
	cmp	DWORD PTR _wpn$1[ebp], 0
	je	SHORT $LN2@SimToggleM
	mov	ecx, DWORD PTR _wpn$1[ebp]
	call	?GetSPType@CampBaseClass@@QBEEXZ	; CampBaseClass::GetSPType
	movzx	edx, al
	cmp	edx, 17					; 00000011H
	jne	SHORT $LN2@SimToggleM

; 1526 : 			pac->FCC->missileTDBPCmd = FALSE;

	mov	eax, DWORD PTR _pac$[ebp]
	mov	ecx, DWORD PTR [eax+936]
	mov	BYTE PTR [ecx+190], 0

; 1527 : 		}
; 1528 : 		else {

	jmp	SHORT $LN4@SimToggleM
$LN2@SimToggleM:

; 1529 : 			pac->FCC->missileTDBPCmd = TRUE;

	mov	edx, DWORD PTR _pac$[ebp]
	mov	eax, DWORD PTR [edx+936]
	mov	BYTE PTR [eax+190], 1
$LN4@SimToggleM:

; 1530 : 		}
; 1531 : 	}
; 1532 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimToggleMissileTDBPUncage@@YAXKHPAX@Z ENDP		; SimToggleMissileTDBPUncage
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimToggleMissileBoreSlave@@YAXKHPAX@Z PROC		; SimToggleMissileBoreSlave

; 1512 : {

	push	ebp
	mov	ebp, esp

; 1513 :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimToggleM
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimToggleM
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimToggleM

; 1514 :    {
; 1515 :       SimDriver.GetPlayerAircraft()->FCC->missileSlaveCmd = TRUE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	mov	BYTE PTR [ecx+189], 1
$LN2@SimToggleM:

; 1516 :    }
; 1517 : }

	pop	ebp
	ret	0
?SimToggleMissileBoreSlave@@YAXKHPAX@Z ENDP		; SimToggleMissileBoreSlave
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_wpn$1 = -8						; size = 4
_pac$ = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimToggleMissileSpotScan@@YAXKHPAX@Z PROC		; SimToggleMissileSpotScan

; 1497 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1498 : 	AircraftClass *pac = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _pac$[ebp], eax

; 1499 : 	if (pac && pac->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN) && pac->Sms){

	cmp	DWORD PTR _pac$[ebp], 0
	je	$LN4@SimToggleM
	push	65536					; 00010000H
	mov	ecx, DWORD PTR _pac$[ebp]
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimToggleM
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN4@SimToggleM
	mov	ecx, DWORD PTR _pac$[ebp]
	cmp	DWORD PTR [ecx+940], 0
	je	SHORT $LN4@SimToggleM

; 1500 : 		SimWeaponClass* wpn = pac->Sms->GetCurrentWeapon();

	mov	edx, DWORD PTR _pac$[ebp]
	mov	eax, DWORD PTR [edx+940]
	mov	ecx, DWORD PTR _pac$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+940]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _wpn$1[ebp], eax

; 1501 : 		if (g_bRealisticAvionics && wpn && ((CampBaseClass*)wpn)->GetSPType() == SPTYPE_AIM9P){

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN2@SimToggleM
	cmp	DWORD PTR _wpn$1[ebp], 0
	je	SHORT $LN2@SimToggleM
	mov	ecx, DWORD PTR _wpn$1[ebp]
	call	?GetSPType@CampBaseClass@@QBEEXZ	; CampBaseClass::GetSPType
	movzx	edx, al
	cmp	edx, 17					; 00000011H
	jne	SHORT $LN2@SimToggleM

; 1502 : 			pac->FCC->missileSpotScanCmd = FALSE;

	mov	eax, DWORD PTR _pac$[ebp]
	mov	ecx, DWORD PTR [eax+936]
	mov	BYTE PTR [ecx+188], 0

; 1503 : 		}
; 1504 : 		else {

	jmp	SHORT $LN4@SimToggleM
$LN2@SimToggleM:

; 1505 : 			pac->FCC->missileSpotScanCmd = TRUE;

	mov	edx, DWORD PTR _pac$[ebp]
	mov	eax, DWORD PTR [edx+936]
	mov	BYTE PTR [eax+188], 1
$LN4@SimToggleM:

; 1506 : 		}
; 1507 : 	}
; 1508 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimToggleMissileSpotScan@@YAXKHPAX@Z ENDP		; SimToggleMissileSpotScan
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_pac$ = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimToggleMissileCage@@YAXKHPAX@Z PROC			; SimToggleMissileCage

; 1483 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1484 : 	AircraftClass *pac = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _pac$[ebp], eax

; 1485 : 	if (pac && pac->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)){

	cmp	DWORD PTR _pac$[ebp], 0
	je	$LN3@SimToggleM
	push	65536					; 00010000H
	mov	ecx, DWORD PTR _pac$[ebp]
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimToggleM
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimToggleM

; 1486 : 		//MI check for MAV Displays
; 1487 : 		if (pac->Sms->curWeaponType == wtAgm65 && pac->Sms->curWeapon.get() && pac->Sms->Powered){ 

	mov	ecx, DWORD PTR _pac$[ebp]
	mov	edx, DWORD PTR [ecx+940]
	cmp	DWORD PTR [edx+148], 4
	jne	SHORT $LN1@SimToggleM
	mov	eax, DWORD PTR _pac$[ebp]
	mov	ecx, DWORD PTR [eax+940]
	add	ecx, 164				; 000000a4H
	call	?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::get
	test	eax, eax
	je	SHORT $LN1@SimToggleM
	mov	ecx, DWORD PTR _pac$[ebp]
	mov	edx, DWORD PTR [ecx+940]
	movzx	eax, BYTE PTR [edx+16]
	test	eax, eax
	je	SHORT $LN1@SimToggleM

; 1488 : 			static_cast<MissileClass*>(pac->Sms->curWeapon.get())->Covered = FALSE;

	mov	ecx, DWORD PTR _pac$[ebp]
	mov	ecx, DWORD PTR [ecx+940]
	add	ecx, 164				; 000000a4H
	call	?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::get
	mov	BYTE PTR [eax+812], 0

; 1489 : 			return;

	jmp	SHORT $LN3@SimToggleM
$LN1@SimToggleM:

; 1490 : 		}
; 1491 : 		pac->FCC->missileCageCmd = TRUE;

	mov	edx, DWORD PTR _pac$[ebp]
	mov	eax, DWORD PTR [edx+936]
	mov	BYTE PTR [eax+187], 1
$LN3@SimToggleM:

; 1492 : 	}
; 1493 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimToggleMissileCage@@YAXKHPAX@Z ENDP			; SimToggleMissileCage
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimDeselectOverride@@YAXKHPAX@Z PROC			; SimDeselectOverride

; 1473 : {

	push	ebp
	mov	ebp, esp

; 1474 :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimDeselec
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimDeselec
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimDeselec

; 1475 :    {
; 1476 : 	   SimDriver.GetPlayerAircraft()->FCC->ClearOverrideMode();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?ClearOverrideMode@FireControlComputer@@QAEXXZ ; FireControlComputer::ClearOverrideMode

; 1477 : 	   MfdDisplay[1]->SetNewMasterMode(SimDriver.GetPlayerAircraft()->FCC->GetMainMasterMode());

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?GetMainMasterMode@FireControlComputer@@QAE?AW4MASTERMODES@@XZ ; FireControlComputer::GetMainMasterMode
	push	eax
	mov	ecx, 4
	shl	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?SetNewMasterMode@MFDClass@@QAEXH@Z	; MFDClass::SetNewMasterMode
$LN2@SimDeselec:

; 1478 :    }
; 1479 : }

	pop	ebp
	ret	0
?SimDeselectOverride@@YAXKHPAX@Z ENDP			; SimDeselectOverride
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimSelectMRMOverride@@YAXKHPAX@Z PROC			; SimSelectMRMOverride

; 1450 : {

	push	ebp
	mov	ebp, esp

; 1451 :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN5@SimSelectM
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN5@SimSelectM
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN5@SimSelectM

; 1452 :    {
; 1453 : 	   if(SimDriver.GetPlayerAircraft()->FCC->GetMasterMode() == FireControlComputer::MissileOverride)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN3@SimSelectM

; 1454 : 		   return;

	jmp	$LN5@SimSelectM
$LN3@SimSelectM:

; 1455 : 
; 1456 : 
; 1457 : 	   //SimDriver.GetPlayerAircraft()->FCC->SetMasterMode(FireControlComputer::MissileOverride);
; 1458 : 	   SimDriver.GetPlayerAircraft()->FCC->EnterMissileOverrideMode(); // MLR 4/11/2004 - 

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?EnterMissileOverrideMode@FireControlComputer@@QAEXXZ ; FireControlComputer::EnterMissileOverrideMode

; 1459 : 	   MfdDisplay[1]->SetNewMasterMode(SimDriver.GetPlayerAircraft()->FCC->GetMainMasterMode());

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?GetMainMasterMode@FireControlComputer@@QAE?AW4MASTERMODES@@XZ ; FireControlComputer::GetMainMasterMode
	push	eax
	mov	ecx, 4
	shl	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?SetNewMasterMode@MFDClass@@QAEXH@Z	; MFDClass::SetNewMasterMode

; 1460 : 	   if(SimDriver.GetPlayerAircraft()->Sms && SimDriver.GetPlayerAircraft()->Sms->drawable)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+940], 0
	je	SHORT $LN2@SimSelectM
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+940]
	cmp	DWORD PTR [edx+160], 0
	je	SHORT $LN2@SimSelectM

; 1461 : 		   SimDriver.GetPlayerAircraft()->Sms->drawable->SetDisplayMode(SmsDrawable::Wpn);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	eax, DWORD PTR [eax+940]
	mov	ecx, DWORD PTR [eax+160]
	call	?SetDisplayMode@SmsDrawable@@QAEXW4SmsDisplayMode@1@@Z ; SmsDrawable::SetDisplayMode
$LN2@SimSelectM:

; 1462 : 
; 1463 : 	   //MI 02/02/02
; 1464 : 	   if(SimDriver.GetPlayerAircraft()->Sms && SimDriver.GetPlayerAircraft()->Sms->GetCoolState() == SMSClass::WARM 
; 1465 : 		   && SimDriver.GetPlayerAircraft()->Sms->MasterArm() == SMSClass::Arm)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+940], 0
	je	SHORT $LN5@SimSelectM
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+940]
	call	?GetCoolState@SMSClass@@QAE?AW4Aim9Mode@1@XZ ; SMSClass::GetCoolState
	test	eax, eax
	jne	SHORT $LN5@SimSelectM
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+940]
	call	?MasterArm@SMSBaseClass@@QAE?AW4MasterArmState@1@XZ ; SMSBaseClass::MasterArm
	cmp	eax, 2
	jne	SHORT $LN5@SimSelectM

; 1466 : 	   {
; 1467 : 		   SimDriver.GetPlayerAircraft()->Sms->SetCoolState(SMSClass::COOLING);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+940]
	call	?SetCoolState@SMSClass@@QAEXW4Aim9Mode@1@@Z ; SMSClass::SetCoolState
$LN5@SimSelectM:

; 1468 : 	   }
; 1469 :    }
; 1470 : }

	pop	ebp
	ret	0
?SimSelectMRMOverride@@YAXKHPAX@Z ENDP			; SimSelectMRMOverride
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimSelectSRMOverride@@YAXKHPAX@Z PROC			; SimSelectSRMOverride

; 1428 : {

	push	ebp
	mov	ebp, esp

; 1429 :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN5@SimSelectS
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN5@SimSelectS
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN5@SimSelectS

; 1430 :    {
; 1431 : 	   if(SimDriver.GetPlayerAircraft()->FCC->GetMasterMode() == FireControlComputer::Dogfight)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 9
	jne	SHORT $LN3@SimSelectS

; 1432 : 		   return;

	jmp	$LN5@SimSelectS
$LN3@SimSelectS:

; 1433 : 
; 1434 : 	   //SimDriver.GetPlayerAircraft()->FCC->SetMasterMode(FireControlComputer::Dogfight);
; 1435 : 	   SimDriver.GetPlayerAircraft()->FCC->EnterDogfightMode(); // MLR 4/11/2004 - 

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?EnterDogfightMode@FireControlComputer@@QAEXXZ ; FireControlComputer::EnterDogfightMode

; 1436 : 	   MfdDisplay[1]->SetNewMasterMode(SimDriver.GetPlayerAircraft()->FCC->GetMainMasterMode());

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?GetMainMasterMode@FireControlComputer@@QAE?AW4MASTERMODES@@XZ ; FireControlComputer::GetMainMasterMode
	push	eax
	mov	ecx, 4
	shl	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?SetNewMasterMode@MFDClass@@QAEXH@Z	; MFDClass::SetNewMasterMode

; 1437 : 	   if(SimDriver.GetPlayerAircraft()->Sms && SimDriver.GetPlayerAircraft()->Sms->drawable)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+940], 0
	je	SHORT $LN2@SimSelectS
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+940]
	cmp	DWORD PTR [edx+160], 0
	je	SHORT $LN2@SimSelectS

; 1438 : 		   SimDriver.GetPlayerAircraft()->Sms->drawable->SetDisplayMode(SmsDrawable::Wpn);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	eax, DWORD PTR [eax+940]
	mov	ecx, DWORD PTR [eax+160]
	call	?SetDisplayMode@SmsDrawable@@QAEXW4SmsDisplayMode@1@@Z ; SmsDrawable::SetDisplayMode
$LN2@SimSelectS:

; 1439 : 
; 1440 : 	   //MI 02/02/02
; 1441 : 	   if(SimDriver.GetPlayerAircraft()->Sms && SimDriver.GetPlayerAircraft()->Sms->GetCoolState() == SMSClass::WARM 
; 1442 : 		   && SimDriver.GetPlayerAircraft()->Sms->MasterArm() == SMSClass::Arm)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+940], 0
	je	SHORT $LN5@SimSelectS
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+940]
	call	?GetCoolState@SMSClass@@QAE?AW4Aim9Mode@1@XZ ; SMSClass::GetCoolState
	test	eax, eax
	jne	SHORT $LN5@SimSelectS
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+940]
	call	?MasterArm@SMSBaseClass@@QAE?AW4MasterArmState@1@XZ ; SMSBaseClass::MasterArm
	cmp	eax, 2
	jne	SHORT $LN5@SimSelectS

; 1443 : 	   {
; 1444 : 		   SimDriver.GetPlayerAircraft()->Sms->SetCoolState(SMSClass::COOLING);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+940]
	call	?SetCoolState@SMSClass@@QAEXW4Aim9Mode@1@@Z ; SMSClass::SetCoolState
$LN5@SimSelectS:

; 1445 : 	   }
; 1446 :    }
; 1447 : }

	pop	ebp
	ret	0
?SimSelectSRMOverride@@YAXKHPAX@Z ENDP			; SimSelectSRMOverride
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimStepSMSRight@@YAXKHPAX@Z PROC			; SimStepSMSRight

; 1424 : {

	push	ebp
	mov	ebp, esp

; 1425 : }

	pop	ebp
	ret	0
?SimStepSMSRight@@YAXKHPAX@Z ENDP			; SimStepSMSRight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_Sms$ = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimStepSMSLeft@@YAXKHPAX@Z PROC			; SimStepSMSLeft

; 1409 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1410 : SMSClass* Sms;
; 1411 : 
; 1412 :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimStepSMS
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimStepSMS
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimStepSMS

; 1413 :    {
; 1414 :       Sms = SimDriver.GetPlayerAircraft()->Sms;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+940]
	mov	DWORD PTR _Sms$[ebp], ecx

; 1415 : 
; 1416 :       if (Sms)

	cmp	DWORD PTR _Sms$[ebp], 0
	je	SHORT $LN3@SimStepSMS

; 1417 :       {
; 1418 :          Sms->drawable->StepDisplayMode();

	mov	edx, DWORD PTR _Sms$[ebp]
	mov	ecx, DWORD PTR [edx+160]
	call	?StepDisplayMode@SmsDrawable@@QAEXXZ	; SmsDrawable::StepDisplayMode
$LN3@SimStepSMS:

; 1419 :       }
; 1420 :    }
; 1421 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimStepSMSLeft@@YAXKHPAX@Z ENDP			; SimStepSMSLeft
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv144 = -12						; size = 4
tv92 = -8						; size = 4
tv81 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimToggleAutopilot@@YAXKHPAX@Z PROC			; SimToggleAutopilot

; 1380 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1381 :     if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN13@SimToggleA
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN13@SimToggleA
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN13@SimToggleA

; 1382 :     {
; 1383 : 	switch (PlayerOptions.GetAutopilotMode())

	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?GetAutopilotMode@PlayerOptionsClass@@QAEHXZ ; PlayerOptionsClass::GetAutopilotMode
	mov	DWORD PTR tv81[ebp], eax
	cmp	DWORD PTR tv81[ebp], 0
	je	SHORT $LN9@SimToggleA
	cmp	DWORD PTR tv81[ebp], 1
	je	SHORT $LN8@SimToggleA
	cmp	DWORD PTR tv81[ebp], 2
	je	SHORT $LN5@SimToggleA
	jmp	$LN13@SimToggleA
$LN9@SimToggleA:

; 1384 : 	{
; 1385 : 	case APIntelligent: // allowed even in realistic.
; 1386 : 	    SimDriver.GetPlayerAircraft()->ToggleAutopilot();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?ToggleAutopilot@AircraftClass@@QAEXXZ	; AircraftClass::ToggleAutopilot

; 1387 : 	    break;

	jmp	$LN13@SimToggleA
$LN8@SimToggleA:

; 1388 : 	    
; 1389 : 	case APEnhanced:
; 1390 : 	    if (!SimDriver.GetPlayerAircraft()->OnGround() || 
; 1391 : 		SimDriver.GetPlayerAircraft()->AutopilotType() == AircraftClass::CombatAP)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR tv92[ebp], eax
	mov	ecx, DWORD PTR tv92[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv92[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	je	SHORT $LN6@SimToggleA
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?AutopilotType@AircraftClass@@QAE?AW4AutoPilotType@1@XZ ; AircraftClass::AutopilotType
	cmp	eax, 2
	jne	SHORT $LN7@SimToggleA
$LN6@SimToggleA:

; 1392 : 		SimDriver.GetPlayerAircraft()->ToggleAutopilot();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?ToggleAutopilot@AircraftClass@@QAEXXZ	; AircraftClass::ToggleAutopilot
$LN7@SimToggleA:

; 1393 : 	    break;

	jmp	SHORT $LN13@SimToggleA
$LN5@SimToggleA:

; 1394 : 	case APNormal: // POGO/JPO - if auto pilot normal, && realistic, this isn't used.
; 1395 : 		if ((!SimDriver.GetPlayerAircraft()->OnGround() || SimDriver.GetPlayerAircraft()->AutopilotType() == AircraftClass::CombatAP))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR tv144[ebp], eax
	mov	ecx, DWORD PTR tv144[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv144[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	je	SHORT $LN3@SimToggleA
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?AutopilotType@AircraftClass@@QAE?AW4AutoPilotType@1@XZ ; AircraftClass::AutopilotType
	cmp	eax, 2
	jne	SHORT $LN13@SimToggleA
$LN3@SimToggleA:

; 1396 : 		{
; 1397 : 			if (!g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	jne	SHORT $LN2@SimToggleA

; 1398 : 				SimDriver.GetPlayerAircraft()->ToggleAutopilot();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?ToggleAutopilot@AircraftClass@@QAEXXZ	; AircraftClass::ToggleAutopilot

; 1399 : 			else

	jmp	SHORT $LN13@SimToggleA
$LN2@SimToggleA:

; 1400 : 				SimRightAPSwitch(0, state, NULL);

	push	0
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	push	0
	call	?SimRightAPSwitch@@YAXKHPAX@Z		; SimRightAPSwitch
	add	esp, 12					; 0000000cH
$LN13@SimToggleA:

; 1401 : 		}
; 1402 :     break;
; 1403 : 	}
; 1404 :     }
; 1405 :     
; 1406 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimToggleAutopilot@@YAXKHPAX@Z ENDP			; SimToggleAutopilot
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCursorRight@@YAXKHPAX@Z PROC			; SimCursorRight

; 1366 : void SimCursorRight(unsigned long, int state, void*){

	push	ebp
	mov	ebp, esp

; 1367 : 	SimCursorFunc(state, 1, 0);

	push	0
	push	1
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	?SimCursorFunc@?A0x786e660c@@YAXHHH@Z	; `anonymous namespace'::SimCursorFunc
	add	esp, 12					; 0000000cH

; 1368 : }

	pop	ebp
	ret	0
?SimCursorRight@@YAXKHPAX@Z ENDP			; SimCursorRight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCursorLeft@@YAXKHPAX@Z PROC				; SimCursorLeft

; 1369 : void SimCursorLeft(unsigned long, int state, void*){

	push	ebp
	mov	ebp, esp

; 1370 : 	SimCursorFunc(state, -1, 0);

	push	0
	push	-1
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	?SimCursorFunc@?A0x786e660c@@YAXHHH@Z	; `anonymous namespace'::SimCursorFunc
	add	esp, 12					; 0000000cH

; 1371 : }

	pop	ebp
	ret	0
?SimCursorLeft@@YAXKHPAX@Z ENDP				; SimCursorLeft
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCursorDown@@YAXKHPAX@Z PROC				; SimCursorDown

; 1375 : void SimCursorDown(unsigned long, int state, void*){

	push	ebp
	mov	ebp, esp

; 1376 : 	SimCursorFunc(state, 0,  -1);

	push	-1
	push	0
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	?SimCursorFunc@?A0x786e660c@@YAXHHH@Z	; `anonymous namespace'::SimCursorFunc
	add	esp, 12					; 0000000cH

; 1377 : }

	pop	ebp
	ret	0
?SimCursorDown@@YAXKHPAX@Z ENDP				; SimCursorDown
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCursorUp@@YAXKHPAX@Z PROC				; SimCursorUp

; 1372 : void SimCursorUp(unsigned long, int state, void*){

	push	ebp
	mov	ebp, esp

; 1373 : 	SimCursorFunc(state, 0, 1);

	push	1
	push	0
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	?SimCursorFunc@?A0x786e660c@@YAXHHH@Z	; `anonymous namespace'::SimCursorFunc
	add	esp, 12					; 0000000cH

; 1374 : }

	pop	ebp
	ret	0
?SimCursorUp@@YAXKHPAX@Z ENDP				; SimCursorUp
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_masterMode$1 = -4					; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimMissileStep@@YAXKHPAX@Z PROC			; SimMissileStep

; 986  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 987  : 	static VU_TIME mslsteptimer = 0;
; 988  : 
; 989  : 	if ( SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) ) 

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN19@SimMissile
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN19@SimMissile

; 990  : 	{
; 991  : 		if (!SimDriver.GetPlayerAircraft()->af->IsSet(AirframeClass::InAir) )

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	jne	SHORT $LN17@SimMissile

; 992  : 		{
; 993  : 			//if (g_bHardCoreReal)	MI
; 994  : 			if(g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN16@SimMissile

; 995  : 			{
; 996  : 				if( state & KEY_DOWN)

	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN16@SimMissile

; 997  : 				{
; 998  : 					if (!SimDriver.GetPlayerAircraft()->af->IsSet(AirframeClass::NoseSteerOn))	

	push	4194304					; 00400000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	jne	SHORT $LN14@SimMissile

; 999  : 						SimDriver.GetPlayerAircraft()->af->SetFlag(AirframeClass::NoseSteerOn);

	push	4194304					; 00400000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?SetFlag@AirframeClass@@QAEXH@Z		; AirframeClass::SetFlag

; 1000 : 					else 

	jmp	SHORT $LN16@SimMissile
$LN14@SimMissile:

; 1001 : 						SimDriver.GetPlayerAircraft()->af->ClearFlag(AirframeClass::NoseSteerOn);

	push	4194304					; 00400000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?ClearFlag@AirframeClass@@QAEXH@Z	; AirframeClass::ClearFlag
$LN16@SimMissile:

; 1002 : 				}
; 1003 : 			}
; 1004 : 			return;

	jmp	$LN19@SimMissile
$LN17@SimMissile:

; 1005 : 		}
; 1006 : 	
; 1007 : 		if( state & KEY_DOWN)

	mov	edx, DWORD PTR _state$[ebp]
	and	edx, 8
	je	SHORT $LN12@SimMissile

; 1008 : 		{
; 1009 : 			if (mslsteptimer == 0)  

	cmp	DWORD PTR ?mslsteptimer@?1??SimMissileStep@@YAXKHPAX@Z@4KA, 0
	jne	SHORT $LN11@SimMissile

; 1010 : 			{
; 1011 : 				mslsteptimer = SimLibElapsedTime;

	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR ?mslsteptimer@?1??SimMissileStep@@YAXKHPAX@Z@4KA, eax
$LN11@SimMissile:

; 1012 : 			}
; 1013 : 		}
; 1014 : 		else

	jmp	$LN19@SimMissile
$LN12@SimMissile:

; 1015 : 		{   
; 1016 : 			FireControlComputer::FCCMasterMode masterMode;
; 1017 : 			masterMode = SimDriver.GetPlayerAircraft()->FCC->GetMasterMode();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	mov	DWORD PTR _masterMode$1[ebp], eax

; 1018 : 			if(SimLibElapsedTime - mslsteptimer >= 500)

	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	sub	ecx, DWORD PTR ?mslsteptimer@?1??SimMissileStep@@YAXKHPAX@Z@4KA
	cmp	ecx, 500				; 000001f4H
	jb	SHORT $LN9@SimMissile

; 1019 : 			{
; 1020 : 				
; 1021 : 				if  (  masterMode == FireControlComputer::Missile
; 1022 : 					|| masterMode == FireControlComputer::Dogfight
; 1023 : 					|| masterMode == FireControlComputer::MissileOverride
; 1024 : 					|| masterMode == FireControlComputer::AAGun /*Cobra TJL 11/12/04*/
; 1025 : 					) 

	cmp	DWORD PTR _masterMode$1[ebp], 2
	je	SHORT $LN7@SimMissile
	cmp	DWORD PTR _masterMode$1[ebp], 9
	je	SHORT $LN7@SimMissile
	cmp	DWORD PTR _masterMode$1[ebp], 10	; 0000000aH
	je	SHORT $LN7@SimMissile
	cmp	DWORD PTR _masterMode$1[ebp], 0
	jne	SHORT $LN8@SimMissile
$LN7@SimMissile:

; 1026 : 				{
; 1027 : 					SimDriver.GetPlayerAircraft()->Sms->StepAAWeapon();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+940]
	call	?StepAAWeapon@SMSClass@@QAEXXZ		; SMSClass::StepAAWeapon
$LN8@SimMissile:

; 1028 : 				}
; 1029 : 
; 1030 : 				if(		masterMode == FireControlComputer::AirGroundBomb
; 1031 : 					||	masterMode == FireControlComputer::AirGroundMissile
; 1032 : 					||	masterMode == FireControlComputer::AirGroundHARM
; 1033 : 					||	masterMode == FireControlComputer::AirGroundLaser
; 1034 : 					||	masterMode == FireControlComputer::AirGroundRocket )

	cmp	DWORD PTR _masterMode$1[ebp], 5
	je	SHORT $LN5@SimMissile
	cmp	DWORD PTR _masterMode$1[ebp], 6
	je	SHORT $LN5@SimMissile
	cmp	DWORD PTR _masterMode$1[ebp], 7
	je	SHORT $LN5@SimMissile
	cmp	DWORD PTR _masterMode$1[ebp], 8
	je	SHORT $LN5@SimMissile
	cmp	DWORD PTR _masterMode$1[ebp], 13	; 0000000dH
	jne	SHORT $LN6@SimMissile
$LN5@SimMissile:

; 1035 : 				{
; 1036 : 					SimDriver.GetPlayerAircraft()->Sms->StepAGWeapon();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+940]
	call	?StepAGWeapon@SMSClass@@QAEXXZ		; SMSClass::StepAGWeapon
$LN6@SimMissile:

; 1037 : 				}
; 1038 : 			}
; 1039 : 			else

	jmp	SHORT $LN4@SimMissile
$LN9@SimMissile:

; 1040 : 			{
; 1041 : 				// COBRA - RED - in Bombs Mode, step thru FCC Sub modes
; 1042 : 				if(		masterMode == FireControlComputer::AirGroundBomb
; 1043 : 					||	masterMode == FireControlComputer::AirGroundLaser)

	cmp	DWORD PTR _masterMode$1[ebp], 5
	je	SHORT $LN2@SimMissile
	cmp	DWORD PTR _masterMode$1[ebp], 8
	jne	SHORT $LN3@SimMissile
$LN2@SimMissile:

; 1044 : 					SimDriver.GetPlayerAircraft()->FCC->NextSubMode();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?NextSubMode@FireControlComputer@@QAEXXZ ; FireControlComputer::NextSubMode

; 1045 : 				else

	jmp	SHORT $LN4@SimMissile
$LN3@SimMissile:

; 1046 : 					SimDriver.GetPlayerAircraft()->FCC->WeaponStep();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?WeaponStep@FireControlComputer@@QAEXXZ	; FireControlComputer::WeaponStep
$LN4@SimMissile:

; 1047 : 			}
; 1048 : 			mslsteptimer = 0;

	mov	DWORD PTR ?mslsteptimer@?1??SimMissileStep@@YAXKHPAX@Z@4KA, 0
$LN19@SimMissile:

; 1049 : 		}
; 1050 : 	}
; 1051 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimMissileStep@@YAXKHPAX@Z ENDP			; SimMissileStep
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimTrigger@@YAXKHPAX@Z PROC				; SimTrigger

; 959  : {

	push	ebp
	mov	ebp, esp

; 960  :    if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN6@SimTrigger

; 961  :    {
; 962  : 	   keyboardTriggerOverride = TRUE;

	mov	DWORD PTR ?keyboardTriggerOverride@@3HA, 1 ; keyboardTriggerOverride

; 963  : 	   if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && SimDriver.GetPlayerAircraft()->AVTRState(AircraftClass::AVTRStateFlags::AVTR_AUTO)) // 2002-02-15 ADDED BY S.G. Check if MOTION_OWNSHIP before going in otherwise it might CTD just after eject

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN5@SimTrigger
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN5@SimTrigger
	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?AVTRState@AircraftClass@@QAEHW4AVTRStateFlags@1@@Z ; AircraftClass::AVTRState
	test	eax, eax
	je	SHORT $LN5@SimTrigger

; 964  : 	   { 
; 965  : 		   if(SimDriver.GetPlayerAircraft()->Sms && SimDriver.GetPlayerAircraft()->Sms->MasterArm() ==
; 966  : 			   SMSBaseClass::Safe)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+940], 0
	je	SHORT $LN4@SimTrigger
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+940]
	call	?MasterArm@SMSBaseClass@@QAE?AW4MasterArmState@1@XZ ; SMSBaseClass::MasterArm
	test	eax, eax
	jne	SHORT $LN4@SimTrigger

; 967  : 			   return;

	jmp	SHORT $LN7@SimTrigger
$LN4@SimTrigger:

; 968  : 
; 969  : 		   if(SimDriver.AVTROn() == FALSE)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?AVTROn@SimulationDriver@@QAEHXZ	; SimulationDriver::AVTROn
	test	eax, eax
	jne	SHORT $LN3@SimTrigger

; 970  : 		   {
; 971  : 			   SimDriver.SetAVTR(TRUE);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?SetAVTR@SimulationDriver@@QAEXH@Z	; SimulationDriver::SetAVTR

; 972  : 			   SimDriver.GetPlayerAircraft()->AddAVTRSeconds();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?AddAVTRSeconds@AircraftClass@@QAEXXZ	; AircraftClass::AddAVTRSeconds

; 973  : 			   ACMIToggleRecording(0, state, NULL);

	push	0
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	push	0
	call	?ACMIToggleRecording@@YAXKHPAX@Z	; ACMIToggleRecording
	add	esp, 12					; 0000000cH

; 974  : 		   }
; 975  : 		   else

	jmp	SHORT $LN5@SimTrigger
$LN3@SimTrigger:

; 976  : 			   SimDriver.GetPlayerAircraft()->AddAVTRSeconds();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?AddAVTRSeconds@AircraftClass@@QAEXXZ	; AircraftClass::AddAVTRSeconds
$LN5@SimTrigger:

; 977  : 	   }
; 978  :    } 
; 979  :    else

	jmp	SHORT $LN7@SimTrigger
$LN6@SimTrigger:

; 980  :    {
; 981  :       keyboardTriggerOverride = FALSE;

	mov	DWORD PTR ?keyboardTriggerOverride@@3HA, 0 ; keyboardTriggerOverride
$LN7@SimTrigger:

; 982  :    }
; 983  : }

	pop	ebp
	ret	0
?SimTrigger@@YAXKHPAX@Z ENDP				; SimTrigger
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimPickle@@YAXKHPAX@Z PROC				; SimPickle

; 910  : {

	push	ebp
	mov	ebp, esp

; 911  :    if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN9@SimPickle

; 912  :    {
; 913  :       keyboardPickleOverride = TRUE;

	mov	DWORD PTR ?keyboardPickleOverride@@3HA, 1 ; keyboardPickleOverride

; 914  : 	  //MI
; 915  : 	  if(g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	$LN8@SimPickle

; 916  : 	  {
; 917  : 		  if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && SimDriver.GetPlayerAircraft()->AVTRState(AircraftClass::AVTRStateFlags::AVTR_AUTO)) // 2002-02-15 MODIFIED BY S.G. Check if MOTION_OWNSHIP before going in otherwise it might CTD just after eject

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN7@SimPickle
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN7@SimPickle
	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?AVTRState@AircraftClass@@QAEHW4AVTRStateFlags@1@@Z ; AircraftClass::AVTRState
	test	eax, eax
	je	SHORT $LN7@SimPickle

; 918  : 		  { 
; 919  : 			  if(SimDriver.GetPlayerAircraft()->Sms && SimDriver.GetPlayerAircraft()->Sms->MasterArm() ==
; 920  : 				SMSBaseClass::Safe)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+940], 0
	je	SHORT $LN6@SimPickle
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+940]
	call	?MasterArm@SMSBaseClass@@QAE?AW4MasterArmState@1@XZ ; SMSBaseClass::MasterArm
	test	eax, eax
	jne	SHORT $LN6@SimPickle

; 921  : 				return;

	jmp	$LN10@SimPickle
$LN6@SimPickle:

; 922  : 
; 923  : 			  if(SimDriver.AVTROn() == FALSE)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?AVTROn@SimulationDriver@@QAEHXZ	; SimulationDriver::AVTROn
	test	eax, eax
	jne	SHORT $LN5@SimPickle

; 924  : 			  {
; 925  : 				  SimDriver.SetAVTR(TRUE);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?SetAVTR@SimulationDriver@@QAEXH@Z	; SimulationDriver::SetAVTR

; 926  : 				  SimDriver.GetPlayerAircraft()->AddAVTRSeconds();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?AddAVTRSeconds@AircraftClass@@QAEXXZ	; AircraftClass::AddAVTRSeconds

; 927  : 				  ACMIToggleRecording(0, state, NULL);

	push	0
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	push	0
	call	?ACMIToggleRecording@@YAXKHPAX@Z	; ACMIToggleRecording
	add	esp, 12					; 0000000cH

; 928  : 			  }
; 929  : 			  else

	jmp	SHORT $LN7@SimPickle
$LN5@SimPickle:

; 930  : 				  SimDriver.GetPlayerAircraft()->AddAVTRSeconds();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?AddAVTRSeconds@AircraftClass@@QAEXXZ	; AircraftClass::AddAVTRSeconds
$LN7@SimPickle:

; 931  : 		  }
; 932  : 		  
; 933  : 		  //Targeting Pod, Fire laser automatically
; 934  : 
; 935  : 		//JAM 04Jan04 - Fixing pickle-after-ejaculate-CTD.
; 936  : 		if( SimDriver.GetPlayerAircraft() && // MLR 5/4/2004 - <-- THIS IS NULL!!! Fixing pickle-after-ejaculate-CTD.
; 937  : 			!((AircraftClass*)SimDriver.GetPlayerAircraft())->ejectTriggered &&
; 938  : 			!((AircraftClass*)SimDriver.GetPlayerAircraft())->doEjectCountdown) 

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN8@SimPickle
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1796], 0
	jne	$LN8@SimPickle
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1804], 0
	jne	SHORT $LN8@SimPickle

; 939  : 			//&& !((AircraftClass*)SimDriver.GetPlayerAircraft())->ejectCountdown)		//Wombat778 4-02-04	Removed, as the ejectcountdown value is not a stable number, and causes the laser NEVER to fire automatically
; 940  : 		{
; 941  : 			if(SimDriver.GetPlayerAircraft()->FCC
; 942  : 			&&SimDriver.GetPlayerAircraft()->FCC->LaserArm
; 943  : 			&&SimDriver.GetPlayerAircraft()->FCC->GetMasterMode() == FireControlComputer::AirGroundLaser)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+936], 0
	je	SHORT $LN8@SimPickle
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	eax, DWORD PTR [eax+936]
	movzx	ecx, BYTE PTR [eax+420]
	test	ecx, ecx
	je	SHORT $LN8@SimPickle
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 8
	jne	SHORT $LN8@SimPickle

; 944  : 			{
; 945  : 				SimDriver.GetPlayerAircraft()->FCC->CheckForLaserFire = TRUE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+936]
	mov	BYTE PTR [edx+422], 1

; 946  : 				SimDriver.GetPlayerAircraft()->FCC->LaserWasFired = FALSE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	eax, DWORD PTR [eax+936]
	mov	BYTE PTR [eax+421], 0
$LN8@SimPickle:

; 947  : 			}
; 948  : 		}
; 949  : 		//JAM
; 950  : 	  }
; 951  :    }
; 952  :    else

	jmp	SHORT $LN10@SimPickle
$LN9@SimPickle:

; 953  :    {
; 954  :       keyboardPickleOverride = FALSE;

	mov	DWORD PTR ?keyboardPickleOverride@@3HA, 0 ; keyboardPickleOverride
$LN10@SimPickle:

; 955  :    }
; 956  : }

	pop	ebp
	ret	0
?SimPickle@@YAXKHPAX@Z ENDP				; SimPickle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimTogglePaused@@YAXKHPAX@Z PROC			; SimTogglePaused

; 874  : {

	push	ebp
	mov	ebp, esp

; 875  :    if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimToggleP

; 876  :       SimDriver.TogglePause();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?TogglePause@SimulationDriver@@QAEXXZ	; SimulationDriver::TogglePause
$LN2@SimToggleP:

; 877  : }

	pop	ebp
	ret	0
?SimTogglePaused@@YAXKHPAX@Z ENDP			; SimTogglePaused
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimPrevWaypoint@@YAXKHPAX@Z PROC			; SimPrevWaypoint

; 858  : {

	push	ebp
	mov	ebp, esp

; 859  :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimPrevWay
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimPrevWay
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimPrevWay

; 860  :    {
; 861  :       SimDriver.GetPlayerAircraft()->FCC->waypointStepCmd = -1;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	mov	BYTE PTR [ecx+194], -1
$LN2@SimPrevWay:

; 862  :    }
; 863  : }

	pop	ebp
	ret	0
?SimPrevWaypoint@@YAXKHPAX@Z ENDP			; SimPrevWaypoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimNextWaypoint@@YAXKHPAX@Z PROC			; SimNextWaypoint

; 866  : {

	push	ebp
	mov	ebp, esp

; 867  :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimNextWay
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimNextWay
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimNextWay

; 868  :    {
; 869  :       SimDriver.GetPlayerAircraft()->FCC->waypointStepCmd = 1;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	mov	BYTE PTR [ecx+194], 1
$LN2@SimNextWay:

; 870  :    }
; 871  : }

	pop	ebp
	ret	0
?SimNextWaypoint@@YAXKHPAX@Z ENDP			; SimNextWaypoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_theRwr$1 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimRWRHandoff@@YAXKHPAX@Z PROC				; SimRWRHandoff

; 832  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 833  :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN5@SimRWRHand
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN5@SimRWRHand
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN5@SimRWRHand

; 834  :    {
; 835  :    PlayerRwrClass* theRwr = (PlayerRwrClass*)FindSensor(SimDriver.GetPlayerAircraft(), SensorClass::RWR);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRwr$1[ebp], eax

; 836  : 
; 837  :       if (theRwr)

	cmp	DWORD PTR _theRwr$1[ebp], 0
	je	SHORT $LN5@SimRWRHand

; 838  :       {
; 839  : 				if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN2@SimRWRHand

; 840  : 					OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_RWR_HNDOFF, 2);

	push	2
	push	154					; 0000009aH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN2@SimRWRHand:

; 841  : 
; 842  :          theRwr->SelectNextEmitter();

	mov	ecx, DWORD PTR _theRwr$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRwr$1[ebp]
	mov	eax, DWORD PTR [edx+108]
	call	eax

; 843  : 
; 844  : // JB 010727 RP5 RWR
; 845  : // 2001-02-15 ADDED BY S.G. SO WE HEAR THE SOUND ***RIGHT AWAY*** I WON'T PASS A targetList (although I could) SO NOT ALL OF THE ROUTINE IS DONE
; 846  : //            IN 1.08i2, DoAudio PROCESSES THE WHOLE CONTACT LIST BY ITSELF AND NOT JUST THE PASSED CONTACT. SINCE 1.07 DOESN'T I'M STUCK AT DOING THIS :-(
; 847  : //            THIS WON'T BE FPS INTENSIVE ANYWAY SINCE IT ONLY RUNS WHEN THE HANDOFF BUTTON IS PRESSED
; 848  : //            LATER ON, I MIGHT MAKE THIS CODE 1.08i2 'COMPATIBLE'
; 849  : 				 theRwr->Exec(NULL);

	push	0
	mov	ecx, DWORD PTR _theRwr$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRwr$1[ebp]
	mov	eax, DWORD PTR [edx+44]
	call	eax

; 850  : 
; 851  : 				if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN5@SimRWRHand

; 852  : 					OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_RWR_HNDOFF, 1);

	push	1
	push	154					; 0000009aH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN5@SimRWRHand:

; 853  :       }
; 854  :    }
; 855  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimRWRHandoff@@YAXKHPAX@Z ENDP				; SimRWRHandoff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_theRwr$1 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimRWRSetSearch@@YAXKHPAX@Z PROC			; SimRWRSetSearch

; 814  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 815  :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN6@SimRWRSetS
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN6@SimRWRSetS
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN6@SimRWRSetS

; 816  :    {
; 817  :    PlayerRwrClass* theRwr = (PlayerRwrClass*)FindSensor(SimDriver.GetPlayerAircraft(), SensorClass::RWR);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRwr$1[ebp], eax

; 818  : 
; 819  :       if (theRwr)

	cmp	DWORD PTR _theRwr$1[ebp], 0
	je	SHORT $LN6@SimRWRSetS

; 820  :       {
; 821  :          theRwr->ToggleSearch();

	mov	ecx, DWORD PTR _theRwr$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRwr$1[ebp]
	mov	eax, DWORD PTR [edx+104]
	call	eax

; 822  : 				if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN6@SimRWRSetS

; 823  : 					if (theRwr->ShowSearch() != FALSE)

	mov	ecx, DWORD PTR _theRwr$1[ebp]
	call	?ShowSearch@PlayerRwrClass@@QAEHXZ	; PlayerRwrClass::ShowSearch
	test	eax, eax
	je	SHORT $LN2@SimRWRSetS

; 824  : 						OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_RWR_SEARCH, 2);

	push	2
	push	149					; 00000095H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 825  : 					else

	jmp	SHORT $LN6@SimRWRSetS
$LN2@SimRWRSetS:

; 826  : 						OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_RWR_SEARCH, 1);

	push	1
	push	149					; 00000095H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN6@SimRWRSetS:

; 827  :       }
; 828  :    }
; 829  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimRWRSetSearch@@YAXKHPAX@Z ENDP			; SimRWRSetSearch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_theRwr$1 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimRWRSetGroundPriority@@YAXKHPAX@Z PROC		; SimRWRSetGroundPriority

; 796  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 797  :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN6@SimRWRSetG
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN6@SimRWRSetG
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN6@SimRWRSetG

; 798  :    {
; 799  :    PlayerRwrClass* theRwr = (PlayerRwrClass*)FindSensor(SimDriver.GetPlayerAircraft(), SensorClass::RWR);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRwr$1[ebp], eax

; 800  : 
; 801  :       if (theRwr)

	cmp	DWORD PTR _theRwr$1[ebp], 0
	je	SHORT $LN6@SimRWRSetG

; 802  :       {
; 803  :          theRwr->ToggleLowAltPriority();

	mov	ecx, DWORD PTR _theRwr$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRwr$1[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax

; 804  : 				if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN6@SimRWRSetG

; 805  : 					if (theRwr->ShowLowAltPriority() != FALSE)

	mov	ecx, DWORD PTR _theRwr$1[ebp]
	call	?ShowLowAltPriority@PlayerRwrClass@@QAEHXZ ; PlayerRwrClass::ShowLowAltPriority
	test	eax, eax
	je	SHORT $LN2@SimRWRSetG

; 806  : 						OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_RWR_GND_PRI, 2);

	push	2
	push	150					; 00000096H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 807  : 					else

	jmp	SHORT $LN6@SimRWRSetG
$LN2@SimRWRSetG:

; 808  : 						OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_RWR_GND_PRI, 1);

	push	1
	push	150					; 00000096H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN6@SimRWRSetG:

; 809  :       }
; 810  :    }
; 811  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimRWRSetGroundPriority@@YAXKHPAX@Z ENDP		; SimRWRSetGroundPriority
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_theRwr$1 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimRWRSetNaval@@YAXKHPAX@Z PROC			; SimRWRSetNaval

; 778  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 779  :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN6@SimRWRSetN
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN6@SimRWRSetN
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN6@SimRWRSetN

; 780  :    {
; 781  :    PlayerRwrClass* theRwr = (PlayerRwrClass*)FindSensor(SimDriver.GetPlayerAircraft(), SensorClass::RWR);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRwr$1[ebp], eax

; 782  : 
; 783  :       if (theRwr)

	cmp	DWORD PTR _theRwr$1[ebp], 0
	je	SHORT $LN6@SimRWRSetN

; 784  :       {
; 785  :          theRwr->ToggleNaval ();

	mov	ecx, DWORD PTR _theRwr$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRwr$1[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax

; 786  : 				if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN6@SimRWRSetN

; 787  : 					if (theRwr->ShowNaval() != FALSE)

	mov	ecx, DWORD PTR _theRwr$1[ebp]
	call	?ShowNaval@PlayerRwrClass@@QAEHXZ	; PlayerRwrClass::ShowNaval
	test	eax, eax
	je	SHORT $LN2@SimRWRSetN

; 788  : 						OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_RWR_NAVAL, 2);

	push	2
	push	155					; 0000009bH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 789  : 					else

	jmp	SHORT $LN6@SimRWRSetN
$LN2@SimRWRSetN:

; 790  : 						OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_RWR_NAVAL, 1);

	push	1
	push	155					; 0000009bH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN6@SimRWRSetN:

; 791  :       }
; 792  :    }
; 793  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimRWRSetNaval@@YAXKHPAX@Z ENDP			; SimRWRSetNaval
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_theRwr$1 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimRWRSetUnknowns@@YAXKHPAX@Z PROC			; SimRWRSetUnknowns

; 760  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 761  :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN6@SimRWRSetU
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN6@SimRWRSetU
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN6@SimRWRSetU

; 762  :    {
; 763  :    PlayerRwrClass* theRwr = (PlayerRwrClass*)FindSensor(SimDriver.GetPlayerAircraft(), SensorClass::RWR);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRwr$1[ebp], eax

; 764  : 
; 765  :       if (theRwr)

	cmp	DWORD PTR _theRwr$1[ebp], 0
	je	SHORT $LN6@SimRWRSetU

; 766  :       {
; 767  :           theRwr->ToggleUnknowns ();

	mov	ecx, DWORD PTR _theRwr$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRwr$1[ebp]
	mov	eax, DWORD PTR [edx+96]
	call	eax

; 768  : 				if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN6@SimRWRSetU

; 769  : 					if (theRwr->ShowUnknowns() != FALSE)

	mov	ecx, DWORD PTR _theRwr$1[ebp]
	call	?ShowUnknowns@PlayerRwrClass@@QAEHXZ	; PlayerRwrClass::ShowUnknowns
	test	eax, eax
	je	SHORT $LN2@SimRWRSetU

; 770  : 						OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_RWR_UNKS, 2);

	push	2
	push	151					; 00000097H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 771  : 					else

	jmp	SHORT $LN6@SimRWRSetU
$LN2@SimRWRSetU:

; 772  : 						OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_RWR_UNKS, 1);

	push	1
	push	151					; 00000097H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN6@SimRWRSetU:

; 773  :       }
; 774  :    }
; 775  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimRWRSetUnknowns@@YAXKHPAX@Z ENDP			; SimRWRSetUnknowns
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_theRwr$1 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimRWRSetTargetSep@@YAXKHPAX@Z PROC			; SimRWRSetTargetSep

; 742  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 743  :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN6@SimRWRSetT
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN6@SimRWRSetT
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN6@SimRWRSetT

; 744  :    {
; 745  :    PlayerRwrClass* theRwr = (PlayerRwrClass*)FindSensor(SimDriver.GetPlayerAircraft(), SensorClass::RWR);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRwr$1[ebp], eax

; 746  : 
; 747  :       if (theRwr)

	cmp	DWORD PTR _theRwr$1[ebp], 0
	je	SHORT $LN6@SimRWRSetT

; 748  :       {
; 749  :         theRwr->ToggleTargetSep ();

	mov	ecx, DWORD PTR _theRwr$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRwr$1[ebp]
	mov	eax, DWORD PTR [edx+92]
	call	eax

; 750  : 				if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN6@SimRWRSetT

; 751  : 					if (theRwr->TargetSep() != FALSE)

	mov	ecx, DWORD PTR _theRwr$1[ebp]
	call	?TargetSep@PlayerRwrClass@@QAEHXZ	; PlayerRwrClass::TargetSep
	test	eax, eax
	je	SHORT $LN2@SimRWRSetT

; 752  : 						OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_RWR_TGT_SEP, 2);

	push	2
	push	152					; 00000098H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 753  : 					else

	jmp	SHORT $LN6@SimRWRSetT
$LN2@SimRWRSetT:

; 754  : 						OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_RWR_TGT_SEP, 1);

	push	1
	push	152					; 00000098H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN6@SimRWRSetT:

; 755  :       }
; 756  :    }
; 757  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimRWRSetTargetSep@@YAXKHPAX@Z ENDP			; SimRWRSetTargetSep
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_theRwr$1 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimRWRSetPriority@@YAXKHPAX@Z PROC			; SimRWRSetPriority

; 711  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 712  :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN6@SimRWRSetP
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN6@SimRWRSetP
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN6@SimRWRSetP

; 713  :    {
; 714  :    PlayerRwrClass* theRwr = (PlayerRwrClass*)FindSensor(SimDriver.GetPlayerAircraft(), SensorClass::RWR);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRwr$1[ebp], eax

; 715  : 
; 716  :       if (theRwr)

	cmp	DWORD PTR _theRwr$1[ebp], 0
	je	SHORT $LN6@SimRWRSetP

; 717  :       {
; 718  :         theRwr->TogglePriority ();

	mov	ecx, DWORD PTR _theRwr$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRwr$1[ebp]
	mov	eax, DWORD PTR [edx+88]
	call	eax

; 719  : 				if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN6@SimRWRSetP

; 720  : 					if (theRwr->IsPriority() != FALSE)

	mov	ecx, DWORD PTR _theRwr$1[ebp]
	call	?IsPriority@PlayerRwrClass@@QAEHXZ	; PlayerRwrClass::IsPriority
	test	eax, eax
	je	SHORT $LN2@SimRWRSetP

; 721  : 						OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_RWR_PRIORITY, 2);

	push	2
	push	153					; 00000099H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 722  : 					else

	jmp	SHORT $LN6@SimRWRSetP
$LN2@SimRWRSetP:

; 723  : 						OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_RWR_PRIORITY, 1);

	push	1
	push	153					; 00000099H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN6@SimRWRSetP:

; 724  :       }
; 725  :    }
; 726  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimRWRSetPriority@@YAXKHPAX@Z ENDP			; SimRWRSetPriority
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_theRadar$1 = -4					; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimRadarElevationCenter@@YAXKHPAX@Z PROC		; SimRadarElevationCenter

; 697  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 698  :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimRadarEl
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimRadarEl
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimRadarEl

; 699  :    {
; 700  :    RadarClass* theRadar = (RadarClass*)FindSensor(SimDriver.GetPlayerAircraft(), SensorClass::Radar);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadar$1[ebp], eax

; 701  :       if (theRadar)

	cmp	DWORD PTR _theRadar$1[ebp], 0
	je	SHORT $LN3@SimRadarEl

; 702  :       {
; 703  : 		theRadar->StepAAelvation( 0 );

	push	0
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx+144]
	call	eax
$LN3@SimRadarEl:

; 704  :       }
; 705  :    }
; 706  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimRadarElevationCenter@@YAXKHPAX@Z ENDP		; SimRadarElevationCenter
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_theRadar$1 = -4					; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimRadarElevationUp@@YAXKHPAX@Z PROC			; SimRadarElevationUp

; 683  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 684  :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimRadarEl
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimRadarEl
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimRadarEl

; 685  :    {
; 686  :    RadarClass* theRadar = (RadarClass*)FindSensor(SimDriver.GetPlayerAircraft(), SensorClass::Radar);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadar$1[ebp], eax

; 687  :       if (theRadar)

	cmp	DWORD PTR _theRadar$1[ebp], 0
	je	SHORT $LN3@SimRadarEl

; 688  :       {
; 689  : // 2001-02-21 MODIFIED BY S.G. MOVES TOO MUCH
; 690  : //		theRadar->StepAAelvation( 8 );
; 691  : 		theRadar->StepAAelvation( 4 );

	push	4
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx+144]
	call	eax
$LN3@SimRadarEl:

; 692  :       }
; 693  :    }
; 694  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimRadarElevationUp@@YAXKHPAX@Z ENDP			; SimRadarElevationUp
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_theRadar$1 = -4					; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimRadarElevationDown@@YAXKHPAX@Z PROC			; SimRadarElevationDown

; 669  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 670  :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimRadarEl
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimRadarEl
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimRadarEl

; 671  :    {
; 672  :    RadarClass* theRadar = (RadarClass*)FindSensor(SimDriver.GetPlayerAircraft(), SensorClass::Radar);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadar$1[ebp], eax

; 673  :       if (theRadar)

	cmp	DWORD PTR _theRadar$1[ebp], 0
	je	SHORT $LN3@SimRadarEl

; 674  :       {
; 675  : // 2001-02-21 MODIFIED BY S.G. MOVES TOO MUCH
; 676  : 		//theRadar->StepAAelvation( -8 );
; 677  : 		theRadar->StepAAelvation( -4 );

	push	-4					; fffffffcH
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx+144]
	call	eax
$LN3@SimRadarEl:

; 678  :       }
; 679  :    }
; 680  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimRadarElevationDown@@YAXKHPAX@Z ENDP			; SimRadarElevationDown
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_theRadar$1 = -4					; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimACM30x20@@YAXKHPAX@Z PROC				; SimACM30x20

; 658  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 659  :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimACM30x2
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimACM30x2
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimACM30x2

; 660  :    {
; 661  :    RadarClass* theRadar = (RadarClass*)FindSensor(SimDriver.GetPlayerAircraft(), SensorClass::Radar);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadar$1[ebp], eax

; 662  : 
; 663  :       if (theRadar && theRadar->IsSOI())

	cmp	DWORD PTR _theRadar$1[ebp], 0
	je	SHORT $LN3@SimACM30x2
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	call	?IsSOI@DrawableClass@@QAEHXZ		; DrawableClass::IsSOI
	test	eax, eax
	je	SHORT $LN3@SimACM30x2

; 664  :          theRadar->SelectACM30x20();

	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx+132]
	call	eax
$LN3@SimACM30x2:

; 665  :    }
; 666  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimACM30x20@@YAXKHPAX@Z ENDP				; SimACM30x20
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_theRadar$1 = -4					; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimACMSlew@@YAXKHPAX@Z PROC				; SimACMSlew

; 647  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 648  :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimACMSlew
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimACMSlew
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimACMSlew

; 649  :    {
; 650  :    RadarClass* theRadar = (RadarClass*)FindSensor(SimDriver.GetPlayerAircraft(), SensorClass::Radar);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadar$1[ebp], eax

; 651  : 
; 652  :       if (theRadar && theRadar->IsSOI())

	cmp	DWORD PTR _theRadar$1[ebp], 0
	je	SHORT $LN3@SimACMSlew
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	call	?IsSOI@DrawableClass@@QAEHXZ		; DrawableClass::IsSOI
	test	eax, eax
	je	SHORT $LN3@SimACMSlew

; 653  :          theRadar->SelectACMSlew();

	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx+128]
	call	eax
$LN3@SimACMSlew:

; 654  :    }
; 655  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimACMSlew@@YAXKHPAX@Z ENDP				; SimACMSlew
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimDropTrack@@YAXKHPAX@Z PROC				; SimDropTrack

; 582  : {

	push	ebp
	mov	ebp, esp

; 583  :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN12@SimDropTra
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN12@SimDropTra

; 584  :    {
; 585  :       if ( state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN10@SimDropTra

; 586  : 	  {
; 587  : 		  //MI
; 588  : 		  if(g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN9@SimDropTra

; 589  : 		  {
; 590  : 			  if(SimDriver.GetPlayerAircraft()->FCC)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+936], 0
	je	SHORT $LN8@SimDropTra

; 591  : 			  {
; 592  : 				  if(SimDriver.GetPlayerAircraft()->FCC->IsSOI)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+936]
	movzx	eax, BYTE PTR [edx+464]
	test	eax, eax
	je	SHORT $LN7@SimDropTra

; 593  : 					SimDriver.GetPlayerAircraft()->FCC->HSDDesignate = -1;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	mov	DWORD PTR [ecx+480], -1

; 594  : 				  else

	jmp	SHORT $LN8@SimDropTra
$LN7@SimDropTra:

; 595  : 					  SimDriver.GetPlayerAircraft()->FCC->dropTrackCmd = TRUE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+936]
	mov	BYTE PTR [edx+185], 1
$LN8@SimDropTra:

; 596  : 			  }
; 597  : 		  }
; 598  : 		  else

	jmp	SHORT $LN5@SimDropTra
$LN9@SimDropTra:

; 599  : 			  SimDriver.GetPlayerAircraft()->FCC->dropTrackCmd = TRUE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	eax, DWORD PTR [eax+936]
	mov	BYTE PTR [eax+185], 1
$LN5@SimDropTra:

; 600  : 	  }
; 601  :       else

	jmp	SHORT $LN12@SimDropTra
$LN10@SimDropTra:

; 602  : 	  {
; 603  : 		  //MI
; 604  : 		  if(g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN3@SimDropTra

; 605  : 		  {
; 606  : 			  if(SimDriver.GetPlayerAircraft()->FCC)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+936], 0
	je	SHORT $LN2@SimDropTra

; 607  : 			  {
; 608  : 				  SimDriver.GetPlayerAircraft()->FCC->HSDDesignate = 0;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+936]
	mov	DWORD PTR [edx+480], 0

; 609  : 				  SimDriver.GetPlayerAircraft()->FCC->dropTrackCmd = FALSE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	eax, DWORD PTR [eax+936]
	mov	BYTE PTR [eax+185], 0
$LN2@SimDropTra:

; 610  : 			  }
; 611  : 		  }
; 612  : 		  else

	jmp	SHORT $LN12@SimDropTra
$LN3@SimDropTra:

; 613  : 			  SimDriver.GetPlayerAircraft()->FCC->dropTrackCmd = FALSE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	mov	BYTE PTR [ecx+185], 0
$LN12@SimDropTra:

; 614  : 	  }
; 615  :    }
; 616  : }

	pop	ebp
	ret	0
?SimDropTrack@@YAXKHPAX@Z ENDP				; SimDropTrack
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_theRadar$1 = -4					; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimACMVertical@@YAXKHPAX@Z PROC			; SimACMVertical

; 636  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 637  :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimACMVert
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimACMVert
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimACMVert

; 638  :    {
; 639  :    RadarClass* theRadar = (RadarClass*)FindSensor(SimDriver.GetPlayerAircraft(), SensorClass::Radar);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadar$1[ebp], eax

; 640  : 
; 641  :       if (theRadar && theRadar->IsSOI())

	cmp	DWORD PTR _theRadar$1[ebp], 0
	je	SHORT $LN3@SimACMVert
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	call	?IsSOI@DrawableClass@@QAEHXZ		; DrawableClass::IsSOI
	test	eax, eax
	je	SHORT $LN3@SimACMVert

; 642  :          theRadar->SelectACMVertical();

	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx+120]
	call	eax
$LN3@SimACMVert:

; 643  :    }
; 644  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimACMVertical@@YAXKHPAX@Z ENDP			; SimACMVertical
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimDesignate@@YAXKHPAX@Z PROC				; SimDesignate

; 545  : {

	push	ebp
	mov	ebp, esp

; 546  :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN12@SimDesigna
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN12@SimDesigna

; 547  :    {
; 548  :       if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN10@SimDesigna

; 549  :       {
; 550  : 		  //MI
; 551  : 		  if(g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN9@SimDesigna

; 552  : 		  {
; 553  : 			  if(SimDriver.GetPlayerAircraft()->FCC)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+936], 0
	je	SHORT $LN8@SimDesigna

; 554  : 			  {
; 555  : 				  if(SimDriver.GetPlayerAircraft()->FCC->IsSOI)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+936]
	movzx	eax, BYTE PTR [edx+464]
	test	eax, eax
	je	SHORT $LN7@SimDesigna

; 556  : 					SimDriver.GetPlayerAircraft()->FCC->HSDDesignate = 1;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	mov	DWORD PTR [ecx+480], 1

; 557  : 				  else

	jmp	SHORT $LN8@SimDesigna
$LN7@SimDesigna:

; 558  : 					  SimDriver.GetPlayerAircraft()->FCC->designateCmd = TRUE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+936]
	mov	BYTE PTR [edx+184], 1
$LN8@SimDesigna:

; 559  : 			  }
; 560  : 		  }
; 561  : 		  else

	jmp	SHORT $LN5@SimDesigna
$LN9@SimDesigna:

; 562  : 			  SimDriver.GetPlayerAircraft()->FCC->designateCmd = TRUE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	eax, DWORD PTR [eax+936]
	mov	BYTE PTR [eax+184], 1
$LN5@SimDesigna:

; 563  :       }
; 564  :       else

	jmp	SHORT $LN12@SimDesigna
$LN10@SimDesigna:

; 565  :       {
; 566  : 		  //MI
; 567  : 		  if(g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN3@SimDesigna

; 568  : 		  {
; 569  : 			  if(SimDriver.GetPlayerAircraft()->FCC)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+936], 0
	je	SHORT $LN2@SimDesigna

; 570  : 			  {
; 571  : 				  SimDriver.GetPlayerAircraft()->FCC->HSDDesignate = 0;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+936]
	mov	DWORD PTR [edx+480], 0

; 572  : 				  SimDriver.GetPlayerAircraft()->FCC->designateCmd = FALSE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	eax, DWORD PTR [eax+936]
	mov	BYTE PTR [eax+184], 0
$LN2@SimDesigna:

; 573  : 			  }
; 574  : 		  }
; 575  : 		  else

	jmp	SHORT $LN12@SimDesigna
$LN3@SimDesigna:

; 576  : 			  SimDriver.GetPlayerAircraft()->FCC->designateCmd = FALSE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	mov	BYTE PTR [ecx+184], 0
$LN12@SimDesigna:

; 577  :       }
; 578  :    }
; 579  : }

	pop	ebp
	ret	0
?SimDesignate@@YAXKHPAX@Z ENDP				; SimDesignate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_theHTS$1 = -8						; size = 4
_theRadar$2 = -4					; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimACMBoresight@@YAXKHPAX@Z PROC			; SimACMBoresight

; 619  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 620  :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN5@SimACMBore
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN5@SimACMBore
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN5@SimACMBore

; 621  :    {
; 622  :       RadarClass* theRadar = (RadarClass*)FindSensor(SimDriver.GetPlayerAircraft(), SensorClass::Radar);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadar$2[ebp], eax

; 623  :       if (theRadar)

	cmp	DWORD PTR _theRadar$2[ebp], 0
	je	SHORT $LN3@SimACMBore

; 624  :          theRadar->SelectACMBore();

	mov	ecx, DWORD PTR _theRadar$2[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$2[ebp]
	mov	eax, DWORD PTR [edx+124]
	call	eax
$LN3@SimACMBore:

; 625  : 
; 626  : // M.N. added full realism mode
; 627  : 	  if (PlayerOptions.GetAvionicsType() != ATRealistic && PlayerOptions.GetAvionicsType() != ATRealisticAV) {

	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?GetAvionicsType@PlayerOptionsClass@@QAEHXZ ; PlayerOptionsClass::GetAvionicsType
	cmp	eax, 2
	je	SHORT $LN5@SimACMBore
	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?GetAvionicsType@PlayerOptionsClass@@QAEHXZ ; PlayerOptionsClass::GetAvionicsType
	cmp	eax, 3
	je	SHORT $LN5@SimACMBore

; 628  : 		  HarmTargetingPod *theHTS = (HarmTargetingPod*)FindSensor(SimDriver.GetPlayerAircraft(), SensorClass::HTS);

	push	4
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theHTS$1[ebp], eax

; 629  : 		  if (theHTS)

	cmp	DWORD PTR _theHTS$1[ebp], 0
	je	SHORT $LN5@SimACMBore

; 630  : 			  theHTS->BoresightTarget();

	mov	ecx, DWORD PTR _theHTS$1[ebp]
	call	?BoresightTarget@HarmTargetingPod@@QAEXXZ ; HarmTargetingPod::BoresightTarget
$LN5@SimACMBore:

; 631  : 	  }
; 632  :    }
; 633  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimACMBoresight@@YAXKHPAX@Z ENDP			; SimACMBoresight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_theRadar$1 = -4					; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimRadarCursorZero@@YAXKHPAX@Z PROC			; SimRadarCursorZero

; 523  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 524  :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimRadarCu
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimRadarCu
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimRadarCu

; 525  :    {
; 526  :    RadarClass* theRadar = (RadarClass*)FindSensor(SimDriver.GetPlayerAircraft(), SensorClass::Radar);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadar$1[ebp], eax

; 527  : 
; 528  :       if (theRadar)

	cmp	DWORD PTR _theRadar$1[ebp], 0
	je	SHORT $LN3@SimRadarCu

; 529  :          theRadar->ToggleAGcursorZero();

	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx+180]
	call	eax
$LN3@SimRadarCu:

; 530  :    }
; 531  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimRadarCursorZero@@YAXKHPAX@Z ENDP			; SimRadarCursorZero
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_theRadar$1 = -4					; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimRadarSnowplow@@YAXKHPAX@Z PROC			; SimRadarSnowplow

; 512  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 513  :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimRadarSn
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimRadarSn
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimRadarSn

; 514  :    {
; 515  :    RadarClass* theRadar = (RadarClass*)FindSensor(SimDriver.GetPlayerAircraft(), SensorClass::Radar);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadar$1[ebp], eax

; 516  : 
; 517  :       if (theRadar)

	cmp	DWORD PTR _theRadar$1[ebp], 0
	je	SHORT $LN3@SimRadarSn

; 518  :          theRadar->ToggleAGsnowPlow();

	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx+172]
	call	eax
$LN3@SimRadarSn:

; 519  :    }
; 520  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimRadarSnowplow@@YAXKHPAX@Z ENDP			; SimRadarSnowplow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_theRadar$1 = -4					; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimRadarFreeze@@YAXKHPAX@Z PROC			; SimRadarFreeze

; 501  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 502  :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimRadarFr
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimRadarFr
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimRadarFr

; 503  :    {
; 504  :    RadarClass* theRadar = (RadarClass*)FindSensor(SimDriver.GetPlayerAircraft(), SensorClass::Radar);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadar$1[ebp], eax

; 505  : 
; 506  :       if (theRadar)

	cmp	DWORD PTR _theRadar$1[ebp], 0
	je	SHORT $LN3@SimRadarFr

; 507  :          theRadar->ToggleAGfreeze();

	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx+168]
	call	eax
$LN3@SimRadarFr:

; 508  :    }
; 509  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimRadarFreeze@@YAXKHPAX@Z ENDP			; SimRadarFreeze
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_laserPod$1 = -16					; size = 4
_mavDisplay$2 = -12					; size = 4
_theRadar$3 = -8					; size = 4
_pac$ = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimSOIFOVStep@@YAXKHPAX@Z PROC				; SimSOIFOVStep

; 476  : void SimSOIFOVStep(unsigned long, int state, void*){

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 477  : 	AircraftClass *pac = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _pac$[ebp], eax

; 478  : 
; 479  : 	if (pac && pac->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN) && pac->Sms){

	cmp	DWORD PTR _pac$[ebp], 0
	je	$LN9@SimSOIFOVS
	push	65536					; 00010000H
	mov	ecx, DWORD PTR _pac$[ebp]
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN9@SimSOIFOVS
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN9@SimSOIFOVS
	mov	ecx, DWORD PTR _pac$[ebp]
	cmp	DWORD PTR [ecx+940], 0
	je	$LN9@SimSOIFOVS

; 480  : 		RadarClass* theRadar = (RadarClass*)FindSensor(pac, SensorClass::Radar);

	push	1
	mov	edx, DWORD PTR _pac$[ebp]
	push	edx
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadar$3[ebp], eax

; 481  : 		if (theRadar && theRadar->IsSOI()){

	cmp	DWORD PTR _theRadar$3[ebp], 0
	je	SHORT $LN7@SimSOIFOVS
	mov	ecx, DWORD PTR _theRadar$3[ebp]
	call	?IsSOI@DrawableClass@@QAEHXZ		; DrawableClass::IsSOI
	test	eax, eax
	je	SHORT $LN7@SimSOIFOVS

; 482  : 			theRadar->StepAGfov();

	mov	eax, DWORD PTR _theRadar$3[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _theRadar$3[ebp]
	mov	eax, DWORD PTR [edx+156]
	call	eax
	jmp	$LN9@SimSOIFOVS
$LN7@SimSOIFOVS:

; 483  : 		}
; 484  : 		else if (pac->Sms->curWeaponType == wtAgm65 && pac->Sms->curWeapon){

	mov	ecx, DWORD PTR _pac$[ebp]
	mov	edx, DWORD PTR [ecx+940]
	cmp	DWORD PTR [edx+148], 4
	jne	SHORT $LN5@SimSOIFOVS
	mov	eax, DWORD PTR _pac$[ebp]
	mov	ecx, DWORD PTR [eax+940]
	add	ecx, 164				; 000000a4H
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@SimSOIFOVS

; 485  : 			MaverickDisplayClass* mavDisplay = 
; 486  : 				(MaverickDisplayClass*)((MissileClass*)pac->Sms->curWeapon.get())->display;

	mov	edx, DWORD PTR _pac$[ebp]
	mov	ecx, DWORD PTR [edx+940]
	add	ecx, 164				; 000000a4H
	call	?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::get
	mov	eax, DWORD PTR [eax+712]
	mov	DWORD PTR _mavDisplay$2[ebp], eax

; 487  : 			if (mavDisplay->IsSOI()){

	mov	ecx, DWORD PTR _mavDisplay$2[ebp]
	call	?IsSOI@DrawableClass@@QAEHXZ		; DrawableClass::IsSOI
	test	eax, eax
	je	SHORT $LN4@SimSOIFOVS

; 488  : 				mavDisplay->ToggleFOV();

	mov	ecx, DWORD PTR _mavDisplay$2[ebp]
	call	?ToggleFOV@MaverickDisplayClass@@QAEXXZ	; MaverickDisplayClass::ToggleFOV
$LN4@SimSOIFOVS:

; 489  : 			}
; 490  : 		}

	jmp	SHORT $LN9@SimSOIFOVS
$LN5@SimSOIFOVS:

; 491  : 		else if (pac->Sms->curWeaponClass == wcGbuWpn){

	mov	ecx, DWORD PTR _pac$[ebp]
	mov	edx, DWORD PTR [ecx+940]
	cmp	DWORD PTR [edx+156], 9
	jne	SHORT $LN9@SimSOIFOVS

; 492  : 			LaserPodClass* laserPod = (LaserPodClass* )FindLaserPod(pac);

	mov	eax, DWORD PTR _pac$[ebp]
	push	eax
	call	?FindLaserPod@@YAPAVSensorClass@@PAVSimMoverClass@@@Z ; FindLaserPod
	add	esp, 4
	mov	DWORD PTR _laserPod$1[ebp], eax

; 493  : 			if (laserPod){

	cmp	DWORD PTR _laserPod$1[ebp], 0
	je	SHORT $LN9@SimSOIFOVS

; 494  : 				laserPod->ToggleFOV();

	mov	ecx, DWORD PTR _laserPod$1[ebp]
	call	?ToggleFOV@LaserPodClass@@QAEXXZ	; LaserPodClass::ToggleFOV
$LN9@SimSOIFOVS:

; 495  : 			}
; 496  : 		}
; 497  : 	}
; 498  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimSOIFOVStep@@YAXKHPAX@Z ENDP				; SimSOIFOVStep
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_mavDisplay$1 = -12					; size = 4
_laserPod$2 = -8					; size = 4
_pac$ = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimMaverickFOVStep@@YAXKHPAX@Z PROC			; SimMaverickFOVStep

; 459  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 460  : 	AircraftClass *pac = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _pac$[ebp], eax

; 461  : 	if (pac && pac->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN) && pac->Sms){

	cmp	DWORD PTR _pac$[ebp], 0
	je	$LN6@SimMaveric
	push	65536					; 00010000H
	mov	ecx, DWORD PTR _pac$[ebp]
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN6@SimMaveric
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN6@SimMaveric
	mov	ecx, DWORD PTR _pac$[ebp]
	cmp	DWORD PTR [ecx+940], 0
	je	$LN6@SimMaveric

; 462  : 		if (pac->Sms->curWeaponType == wtAgm65 && pac->Sms->curWeapon.get()){

	mov	edx, DWORD PTR _pac$[ebp]
	mov	eax, DWORD PTR [edx+940]
	cmp	DWORD PTR [eax+148], 4
	jne	SHORT $LN4@SimMaveric
	mov	ecx, DWORD PTR _pac$[ebp]
	mov	ecx, DWORD PTR [ecx+940]
	add	ecx, 164				; 000000a4H
	call	?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::get
	test	eax, eax
	je	SHORT $LN4@SimMaveric

; 463  : 			MaverickDisplayClass* mavDisplay = 
; 464  : 				(MaverickDisplayClass*)((MissileClass*)pac->Sms->curWeapon.get())->display;

	mov	edx, DWORD PTR _pac$[ebp]
	mov	ecx, DWORD PTR [edx+940]
	add	ecx, 164				; 000000a4H
	call	?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::get
	mov	eax, DWORD PTR [eax+712]
	mov	DWORD PTR _mavDisplay$1[ebp], eax

; 465  : 			mavDisplay->ToggleFOV();

	mov	ecx, DWORD PTR _mavDisplay$1[ebp]
	call	?ToggleFOV@MaverickDisplayClass@@QAEXXZ	; MaverickDisplayClass::ToggleFOV
	jmp	SHORT $LN6@SimMaveric
$LN4@SimMaveric:

; 466  : 		}
; 467  : 		else if (pac->Sms->curWeaponClass == wcGbuWpn){

	mov	ecx, DWORD PTR _pac$[ebp]
	mov	edx, DWORD PTR [ecx+940]
	cmp	DWORD PTR [edx+156], 9
	jne	SHORT $LN6@SimMaveric

; 468  : 			LaserPodClass* laserPod = (LaserPodClass* )FindLaserPod(pac);

	mov	eax, DWORD PTR _pac$[ebp]
	push	eax
	call	?FindLaserPod@@YAPAVSensorClass@@PAVSimMoverClass@@@Z ; FindLaserPod
	add	esp, 4
	mov	DWORD PTR _laserPod$2[ebp], eax

; 469  : 			if (laserPod){

	cmp	DWORD PTR _laserPod$2[ebp], 0
	je	SHORT $LN6@SimMaveric

; 470  : 				laserPod->ToggleFOV();

	mov	ecx, DWORD PTR _laserPod$2[ebp]
	call	?ToggleFOV@LaserPodClass@@QAEXXZ	; LaserPodClass::ToggleFOV
$LN6@SimMaveric:

; 471  : 			}
; 472  : 		}
; 473  : 	}
; 474  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimMaverickFOVStep@@YAXKHPAX@Z ENDP			; SimMaverickFOVStep
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_theRadar$1 = -4					; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimRadarFOVStep@@YAXKHPAX@Z PROC			; SimRadarFOVStep

; 448  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 449  :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimRadarFO
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimRadarFO
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimRadarFO

; 450  :    {
; 451  :    RadarClass* theRadar = (RadarClass*)FindSensor(SimDriver.GetPlayerAircraft(), SensorClass::Radar);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadar$1[ebp], eax

; 452  : 
; 453  :       if (theRadar)

	cmp	DWORD PTR _theRadar$1[ebp], 0
	je	SHORT $LN3@SimRadarFO

; 454  :          theRadar->StepAGfov();

	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx+156]
	call	eax
$LN3@SimRadarFO:

; 455  :    }
; 456  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimRadarFOVStep@@YAXKHPAX@Z ENDP			; SimRadarFOVStep
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_theRadar$1 = -4					; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimRadarAzimuthScanChange@@YAXKHPAX@Z PROC		; SimRadarAzimuthScanChange

; 534  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 535  :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimRadarAz
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimRadarAz
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimRadarAz

; 536  :    {
; 537  :    RadarClass* theRadar = (RadarClass*)FindSensor(SimDriver.GetPlayerAircraft(), SensorClass::Radar);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadar$1[ebp], eax

; 538  : 
; 539  :       if (theRadar)

	cmp	DWORD PTR _theRadar$1[ebp], 0
	je	SHORT $LN3@SimRadarAz

; 540  :          theRadar->StepAAscanWidth();

	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx+140]
	call	eax
$LN3@SimRadarAz:

; 541  :    }
; 542  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimRadarAzimuthScanChange@@YAXKHPAX@Z ENDP		; SimRadarAzimuthScanChange
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_theRadar$1 = -4					; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimRadarBarScanChange@@YAXKHPAX@Z PROC			; SimRadarBarScanChange

; 437  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 438  :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimRadarBa
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimRadarBa
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimRadarBa

; 439  :    {
; 440  :    RadarClass* theRadar = (RadarClass*)FindSensor(SimDriver.GetPlayerAircraft(), SensorClass::Radar);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadar$1[ebp], eax

; 441  : 
; 442  :       if (theRadar)

	cmp	DWORD PTR _theRadar$1[ebp], 0
	je	SHORT $LN3@SimRadarBa

; 443  :          theRadar->StepAAscanHeight();

	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx+136]
	call	eax
$LN3@SimRadarBa:

; 444  :    }
; 445  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimRadarBarScanChange@@YAXKHPAX@Z ENDP			; SimRadarBarScanChange
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_theHTS$1 = -8						; size = 4
_theRadar$2 = -4					; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimRadarPrevTarget@@YAXKHPAX@Z PROC			; SimRadarPrevTarget

; 419  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 420  :    // ASSOCIATOR: Added a g_bRealisticAvionics check here to fix a cheat
; 421  :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN) && !g_bRealisticAvionics )

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN5@SimRadarPr
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN5@SimRadarPr
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN5@SimRadarPr
	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	jne	SHORT $LN5@SimRadarPr

; 422  :    {
; 423  :       RadarClass* theRadar = (RadarClass*)FindSensor(SimDriver.GetPlayerAircraft(), SensorClass::Radar);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadar$2[ebp], eax

; 424  :       if (theRadar)

	cmp	DWORD PTR _theRadar$2[ebp], 0
	je	SHORT $LN3@SimRadarPr

; 425  :          theRadar->PrevTarget();

	mov	edx, DWORD PTR _theRadar$2[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _theRadar$2[ebp]
	mov	edx, DWORD PTR [eax+96]
	call	edx
$LN3@SimRadarPr:

; 426  : 
; 427  : // M.N. added full realism mode
; 428  : 	  if (PlayerOptions.GetAvionicsType() != ATRealistic && PlayerOptions.GetAvionicsType() != ATRealisticAV) {

	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?GetAvionicsType@PlayerOptionsClass@@QAEHXZ ; PlayerOptionsClass::GetAvionicsType
	cmp	eax, 2
	je	SHORT $LN5@SimRadarPr
	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?GetAvionicsType@PlayerOptionsClass@@QAEHXZ ; PlayerOptionsClass::GetAvionicsType
	cmp	eax, 3
	je	SHORT $LN5@SimRadarPr

; 429  : 		  HarmTargetingPod *theHTS = (HarmTargetingPod*)FindSensor(SimDriver.GetPlayerAircraft(), SensorClass::HTS);

	push	4
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theHTS$1[ebp], eax

; 430  : 		  if (theHTS)

	cmp	DWORD PTR _theHTS$1[ebp], 0
	je	SHORT $LN5@SimRadarPr

; 431  : 			  theHTS->PrevTarget();

	mov	ecx, DWORD PTR _theHTS$1[ebp]
	call	?PrevTarget@HarmTargetingPod@@QAEXXZ	; HarmTargetingPod::PrevTarget
$LN5@SimRadarPr:

; 432  : 	  }
; 433  :    }
; 434  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimRadarPrevTarget@@YAXKHPAX@Z ENDP			; SimRadarPrevTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_theHTS$1 = -8						; size = 4
_theRadar$2 = -4					; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimRadarNextTarget@@YAXKHPAX@Z PROC			; SimRadarNextTarget

; 401  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 402  :    // ASSOCIATOR: Added a g_bRealisticAvionics check here to fix a cheat
; 403  :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN) && !g_bRealisticAvionics )

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN5@SimRadarNe
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN5@SimRadarNe
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN5@SimRadarNe
	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	jne	SHORT $LN5@SimRadarNe

; 404  :    {
; 405  :       RadarClass* theRadar = (RadarClass*)FindSensor(SimDriver.GetPlayerAircraft(), SensorClass::Radar);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadar$2[ebp], eax

; 406  :       if (theRadar)

	cmp	DWORD PTR _theRadar$2[ebp], 0
	je	SHORT $LN3@SimRadarNe

; 407  :          theRadar->NextTarget();

	mov	edx, DWORD PTR _theRadar$2[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _theRadar$2[ebp]
	mov	edx, DWORD PTR [eax+92]
	call	edx
$LN3@SimRadarNe:

; 408  : 
; 409  : // M.N. added full realism mode
; 410  : 	  if (PlayerOptions.GetAvionicsType() != ATRealistic && PlayerOptions.GetAvionicsType() != ATRealisticAV) {

	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?GetAvionicsType@PlayerOptionsClass@@QAEHXZ ; PlayerOptionsClass::GetAvionicsType
	cmp	eax, 2
	je	SHORT $LN5@SimRadarNe
	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?GetAvionicsType@PlayerOptionsClass@@QAEHXZ ; PlayerOptionsClass::GetAvionicsType
	cmp	eax, 3
	je	SHORT $LN5@SimRadarNe

; 411  : 		  HarmTargetingPod *theHTS = (HarmTargetingPod*)FindSensor(SimDriver.GetPlayerAircraft(), SensorClass::HTS);

	push	4
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theHTS$1[ebp], eax

; 412  : 		  if (theHTS)

	cmp	DWORD PTR _theHTS$1[ebp], 0
	je	SHORT $LN5@SimRadarNe

; 413  : 			  theHTS->NextTarget();

	mov	ecx, DWORD PTR _theHTS$1[ebp]
	call	?NextTarget@HarmTargetingPod@@QAEXXZ	; HarmTargetingPod::NextTarget
$LN5@SimRadarNe:

; 414  : 	  }
; 415  :    }
; 416  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimRadarNextTarget@@YAXKHPAX@Z ENDP			; SimRadarNextTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_theRadar$1 = -4					; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimRadarRangeStepDown@@YAXKHPAX@Z PROC			; SimRadarRangeStepDown

; 373  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 374  :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN6@SimRadarRa
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN6@SimRadarRa
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN6@SimRadarRa

; 375  :    {
; 376  : 	   RadarDopplerClass* theRadar = (RadarDopplerClass*)FindSensor(SimDriver.GetPlayerAircraft(), SensorClass::Radar);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadar$1[ebp], eax

; 377  : 	   
; 378  : 	   if(theRadar)

	cmp	DWORD PTR _theRadar$1[ebp], 0
	je	SHORT $LN5@SimRadarRa

; 379  : 		   theRadar->RangeStep( -1 );

	push	-1
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx+88]
	call	eax
$LN5@SimRadarRa:

; 380  : 		// MD -- 20040305: saint asked that the range change commands behave like the OSBs that you
; 381  : 		// should use for changing the range.  This becomes more important now the GM range scale bump
; 382  : 		// actually works preperly.
; 383  : 		if(g_bRealisticAvionics && g_bAGRadarFixes)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN6@SimRadarRa
	movzx	edx, BYTE PTR ?g_bAGRadarFixes@@3_NA	; g_bAGRadarFixes
	test	edx, edx
	je	SHORT $LN6@SimRadarRa

; 384  : 		{
; 385  : 			if(theRadar->GetRadarMode() == RadarClass::GM ||
; 386  : 				theRadar->GetRadarMode() == RadarClass::GMT ||
; 387  : 				theRadar->GetRadarMode() == RadarClass::SEA)

	mov	eax, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 14					; 0000000eH
	je	SHORT $LN2@SimRadarRa
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 16					; 00000010H
	je	SHORT $LN2@SimRadarRa
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 17					; 00000011H
	jne	SHORT $LN6@SimRadarRa
$LN2@SimRadarRa:

; 388  : 			{
; 389  : 				if(theRadar->IsSet(RadarDopplerClass::AutoAGRange))

	push	4194304					; 00400000H
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	call	?IsSet@RadarDopplerClass@@QAEHH@Z	; RadarDopplerClass::IsSet
	test	eax, eax
	je	SHORT $LN6@SimRadarRa

; 390  : 				{
; 391  : 					theRadar->ClearFlagBit(RadarDopplerClass::AutoAGRange);

	push	4194304					; 00400000H
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	call	?ClearFlagBit@RadarDopplerClass@@QAEXH@Z ; RadarDopplerClass::ClearFlagBit

; 392  : 					theRadar->SetAutoAGRange(FALSE);

	push	0
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx+264]
	call	eax
$LN6@SimRadarRa:

; 393  : 				}
; 394  : 			}
; 395  : 		}
; 396  :    }
; 397  :    lTestFlag2 = 1 - lTestFlag2;

	mov	ecx, 1
	sub	ecx, DWORD PTR ?lTestFlag2@@3HA		; lTestFlag2
	mov	DWORD PTR ?lTestFlag2@@3HA, ecx		; lTestFlag2

; 398  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimRadarRangeStepDown@@YAXKHPAX@Z ENDP			; SimRadarRangeStepDown
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_theRadar$1 = -4					; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimRadarRangeStepUp@@YAXKHPAX@Z PROC			; SimRadarRangeStepUp

; 346  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 347  : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN6@SimRadarRa
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN6@SimRadarRa
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN6@SimRadarRa

; 348  : 	{
; 349  : 		RadarDopplerClass* theRadar = (RadarDopplerClass*)FindSensor(SimDriver.GetPlayerAircraft(), SensorClass::Radar);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadar$1[ebp], eax

; 350  : 		if(theRadar)

	cmp	DWORD PTR _theRadar$1[ebp], 0
	je	SHORT $LN5@SimRadarRa

; 351  : 			theRadar->RangeStep( 1 );

	push	1
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx+88]
	call	eax
$LN5@SimRadarRa:

; 352  : 		// MD -- 20040305: saint asked that the range change commands behave like the OSBs that you
; 353  : 		// should use for changing the range.  This becomes more important now the GM range scale bump
; 354  : 		// actually works preperly.
; 355  : 		if(g_bRealisticAvionics && g_bAGRadarFixes)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN6@SimRadarRa
	movzx	edx, BYTE PTR ?g_bAGRadarFixes@@3_NA	; g_bAGRadarFixes
	test	edx, edx
	je	SHORT $LN6@SimRadarRa

; 356  : 		{
; 357  : 			if(theRadar->GetRadarMode() == RadarClass::GM ||
; 358  : 				theRadar->GetRadarMode() == RadarClass::GMT ||
; 359  : 				theRadar->GetRadarMode() == RadarClass::SEA)

	mov	eax, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 14					; 0000000eH
	je	SHORT $LN2@SimRadarRa
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 16					; 00000010H
	je	SHORT $LN2@SimRadarRa
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 17					; 00000011H
	jne	SHORT $LN6@SimRadarRa
$LN2@SimRadarRa:

; 360  : 			{
; 361  : 				if(theRadar->IsSet(RadarDopplerClass::AutoAGRange))

	push	4194304					; 00400000H
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	call	?IsSet@RadarDopplerClass@@QAEHH@Z	; RadarDopplerClass::IsSet
	test	eax, eax
	je	SHORT $LN6@SimRadarRa

; 362  : 				{
; 363  : 					theRadar->ClearFlagBit(RadarDopplerClass::AutoAGRange);

	push	4194304					; 00400000H
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	call	?ClearFlagBit@RadarDopplerClass@@QAEXH@Z ; RadarDopplerClass::ClearFlagBit

; 364  : 					theRadar->SetAutoAGRange(FALSE);

	push	0
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx+264]
	call	eax
$LN6@SimRadarRa:

; 365  : 				}
; 366  : 			}
; 367  : 		}
; 368  : 	} 		   
; 369  : 	lTestFlag1 = 1 - lTestFlag1;

	mov	ecx, 1
	sub	ecx, DWORD PTR ?lTestFlag1@@3HA		; lTestFlag1
	mov	DWORD PTR ?lTestFlag1@@3HA, ecx		; lTestFlag1

; 370  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimRadarRangeStepUp@@YAXKHPAX@Z ENDP			; SimRadarRangeStepUp
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv131 = -8						; size = 4
_theRadar$1 = -4					; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimRadarStandby@@YAXKHPAX@Z PROC			; SimRadarStandby

; 333  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 334  :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimRadarSt
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimRadarSt
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimRadarSt

; 335  :    {
; 336  :    RadarClass* theRadar = (RadarClass*)FindSensor(SimDriver.GetPlayerAircraft(), SensorClass::Radar);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadar$1[ebp], eax

; 337  : 
; 338  :       if (theRadar)

	cmp	DWORD PTR _theRadar$1[ebp], 0
	je	SHORT $LN3@SimRadarSt

; 339  :       {
; 340  :          theRadar->SetEmitting( !theRadar->IsEmitting() );

	mov	ecx, DWORD PTR _theRadar$1[ebp]
	call	?IsEmitting@RadarClass@@QAEHXZ		; RadarClass::IsEmitting
	test	eax, eax
	jne	SHORT $LN5@SimRadarSt
	mov	DWORD PTR tv131[ebp], 1
	jmp	SHORT $LN6@SimRadarSt
$LN5@SimRadarSt:
	mov	DWORD PTR tv131[ebp], 0
$LN6@SimRadarSt:
	mov	ecx, DWORD PTR tv131[ebp]
	push	ecx
	mov	edx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [eax+84]
	call	edx
$LN3@SimRadarSt:

; 341  :       }
; 342  :    }
; 343  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimRadarStandby@@YAXKHPAX@Z ENDP			; SimRadarStandby
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_theRadar$1 = -4					; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimRadarGainDown@@YAXKHPAX@Z PROC			; SimRadarGainDown

; 320  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 321  :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimRadarGa
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimRadarGa
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimRadarGa

; 322  :    {
; 323  :    RadarClass* theRadar = (RadarClass*)FindSensor(SimDriver.GetPlayerAircraft(), SensorClass::Radar);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadar$1[ebp], eax

; 324  : 
; 325  :       if (theRadar)

	cmp	DWORD PTR _theRadar$1[ebp], 0
	je	SHORT $LN3@SimRadarGa

; 326  :       {
; 327  :          theRadar->StepAGgain( -1 );

	push	-1
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN3@SimRadarGa:

; 328  :       }
; 329  :    }
; 330  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimRadarGainDown@@YAXKHPAX@Z ENDP			; SimRadarGainDown
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_theRadar$1 = -4					; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimRadarGainUp@@YAXKHPAX@Z PROC			; SimRadarGainUp

; 307  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 308  :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimRadarGa
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimRadarGa
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimRadarGa

; 309  :    {
; 310  :    RadarClass* theRadar = (RadarClass*)FindSensor(SimDriver.GetPlayerAircraft(), SensorClass::Radar);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadar$1[ebp], eax

; 311  : 
; 312  :       if (theRadar)

	cmp	DWORD PTR _theRadar$1[ebp], 0
	je	SHORT $LN3@SimRadarGa

; 313  :       {
; 314  :          theRadar->StepAGgain( 1 );

	push	1
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN3@SimRadarGa:

; 315  :       }
; 316  :    }
; 317  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimRadarGainUp@@YAXKHPAX@Z ENDP			; SimRadarGainUp
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_theRadar$1 = -4					; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimRadarAGModeStep@@YAXKHPAX@Z PROC			; SimRadarAGModeStep

; 296  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 297  :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimRadarAG
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimRadarAG
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimRadarAG

; 298  :    {
; 299  :    RadarClass* theRadar = (RadarClass*)FindSensor(SimDriver.GetPlayerAircraft(), SensorClass::Radar);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadar$1[ebp], eax

; 300  : 
; 301  :       if (theRadar)

	cmp	DWORD PTR _theRadar$1[ebp], 0
	je	SHORT $LN3@SimRadarAG

; 302  :          theRadar->StepAGmode();

	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx+152]
	call	eax
$LN3@SimRadarAG:

; 303  :    }
; 304  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimRadarAGModeStep@@YAXKHPAX@Z ENDP			; SimRadarAGModeStep
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_theRadar$1 = -4					; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimRadarAAModeStep@@YAXKHPAX@Z PROC			; SimRadarAAModeStep

; 285  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 286  :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimRadarAA
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimRadarAA
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimRadarAA

; 287  :    {
; 288  :    RadarClass* theRadar = (RadarClass*)FindSensor(SimDriver.GetPlayerAircraft(), SensorClass::Radar);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadar$1[ebp], eax

; 289  : 
; 290  :       if (theRadar)

	cmp	DWORD PTR _theRadar$1[ebp], 0
	je	SHORT $LN3@SimRadarAA

; 291  :          theRadar->StepAAmode();

	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx+104]
	call	eax
$LN3@SimRadarAA:

; 292  :    }
; 293  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimRadarAAModeStep@@YAXKHPAX@Z ENDP			; SimRadarAAModeStep
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv90 = -8						; size = 4
tv76 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWTrackTargetToWeapon@@YAXKHPAX@Z PROC		; OTWTrackTargetToWeapon

; 2752 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2753 :    if (FalconLocalGame && FalconLocalGame->rules.ExternalViewOn() && \
; 2754 : 	   (state & KEY_DOWN) && (SimDriver.GetPlayerAircraft()) && \
; 2755 : 	   (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) )

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@OTWTrackTa
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN5@OTWTrackTa
$LN4@OTWTrackTa:
	mov	DWORD PTR tv76[ebp], 0
$LN5@OTWTrackTa:
	cmp	DWORD PTR tv76[ebp], 0
	je	SHORT $LN2@OTWTrackTa
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@OTWTrackTa
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv90[ebp], eax
	jmp	SHORT $LN7@OTWTrackTa
$LN6@OTWTrackTa:
	mov	DWORD PTR tv90[ebp], 0
$LN7@OTWTrackTa:
	mov	ecx, DWORD PTR tv90[ebp]
	add	ecx, 356				; 00000164H
	call	?ExternalViewOn@RulesClass@@QAEHXZ	; RulesClass::ExternalViewOn
	test	eax, eax
	je	SHORT $LN2@OTWTrackTa
	mov	edx, DWORD PTR _state$[ebp]
	and	edx, 8
	je	SHORT $LN2@OTWTrackTa
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@OTWTrackTa
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@OTWTrackTa

; 2756 :       OTWDriver.SetOTWDisplayMode(OTWDriverClass::ModeTargetToWeapon);

	push	18					; 00000012H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?SetOTWDisplayMode@OTWDriverClass@@QAEXW4OTWDisplayMode@1@@Z ; OTWDriverClass::SetOTWDisplayMode
$LN2@OTWTrackTa:

; 2757 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?OTWTrackTargetToWeapon@@YAXKHPAX@Z ENDP		; OTWTrackTargetToWeapon
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv90 = -8						; size = 4
tv76 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWTrackExternal@@YAXKHPAX@Z PROC			; OTWTrackExternal

; 2744 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2745 :    if (FalconLocalGame && FalconLocalGame->rules.ExternalViewOn() && 
; 2746 : 	   (state & KEY_DOWN) && (SimDriver.GetPlayerAircraft()) && 
; 2747 : 	   (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) )

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@OTWTrackEx
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN5@OTWTrackEx
$LN4@OTWTrackEx:
	mov	DWORD PTR tv76[ebp], 0
$LN5@OTWTrackEx:
	cmp	DWORD PTR tv76[ebp], 0
	je	SHORT $LN2@OTWTrackEx
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@OTWTrackEx
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv90[ebp], eax
	jmp	SHORT $LN7@OTWTrackEx
$LN6@OTWTrackEx:
	mov	DWORD PTR tv90[ebp], 0
$LN7@OTWTrackEx:
	mov	ecx, DWORD PTR tv90[ebp]
	add	ecx, 356				; 00000164H
	call	?ExternalViewOn@RulesClass@@QAEHXZ	; RulesClass::ExternalViewOn
	test	eax, eax
	je	SHORT $LN2@OTWTrackEx
	mov	edx, DWORD PTR _state$[ebp]
	and	edx, 8
	je	SHORT $LN2@OTWTrackEx
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@OTWTrackEx
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@OTWTrackEx

; 2748 :       OTWDriver.SetOTWDisplayMode(OTWDriverClass::ModeTargetToSelf);

	push	17					; 00000011H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?SetOTWDisplayMode@OTWDriverClass@@QAEXW4OTWDisplayMode@1@@Z ; OTWDriverClass::SetOTWDisplayMode
$LN2@OTWTrackEx:

; 2749 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?OTWTrackExternal@@YAXKHPAX@Z ENDP			; OTWTrackExternal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWToggleSidebar@@YAXKHPAX@Z PROC			; OTWToggleSidebar

; 277  : {	

	push	ebp
	mov	ebp, esp

; 278  :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@OTWToggleS
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@OTWToggleS
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@OTWToggleS

; 279  :    {
; 280  :       OTWDriver.ToggleSidebar();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?ToggleSidebar@OTWDriverClass@@QAEXXZ	; OTWDriverClass::ToggleSidebar
$LN2@OTWToggleS:

; 281  : 	}
; 282  : }

	pop	ebp
	ret	0
?OTWToggleSidebar@@YAXKHPAX@Z ENDP			; OTWToggleSidebar
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_flag$1 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?OTWToggleScoreDisplay@@YAXKHPAX@Z PROC			; OTWToggleScoreDisplay

; 254  : void OTWToggleScoreDisplay(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp
	push	ecx

; 255  : 	if (state & KEY_DOWN) {

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN8@OTWToggleS

; 256  : 		unsigned int	flag;
; 257  : 
; 258  : 		if (SimDriver.RunningDogfight()) {

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?RunningDogfight@SimulationDriver@@QBE_NXZ ; SimulationDriver::RunningDogfight
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@OTWToggleS

; 259  : 			flag = SHOW_DOGFIGHT_SCORES;

	mov	DWORD PTR _flag$1[ebp], 512		; 00000200H
	jmp	SHORT $LN5@OTWToggleS
$LN6@OTWToggleS:

; 260  : 		} else if (SimDriver.RunningTactical()) {

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?RunningTactical@SimulationDriver@@QBE_NXZ ; SimulationDriver::RunningTactical
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN4@OTWToggleS

; 261  : 			flag = SHOW_TE_SCORES;

	mov	DWORD PTR _flag$1[ebp], 256		; 00000100H

; 262  : 		} else {

	jmp	SHORT $LN5@OTWToggleS
$LN4@OTWToggleS:

; 263  : 			return;

	jmp	SHORT $LN8@OTWToggleS
$LN5@OTWToggleS:

; 264  : 		}
; 265  : 
; 266  : 		gRefreshScoresList = TRUE;

	mov	DWORD PTR ?gRefreshScoresList@@3JA, 1	; gRefreshScoresList

; 267  : 
; 268  : 		if (OTWDriver.GetFrontTextFlags() & flag) {

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetFrontTextFlags@OTWDriverClass@@QAEJXZ ; OTWDriverClass::GetFrontTextFlags
	and	eax, DWORD PTR _flag$1[ebp]
	je	SHORT $LN2@OTWToggleS

; 269  : 			OTWDriver.SetFrontTextFlags(OTWDriver.GetFrontTextFlags() & ~flag);

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetFrontTextFlags@OTWDriverClass@@QAEJXZ ; OTWDriverClass::GetFrontTextFlags
	mov	ecx, DWORD PTR _flag$1[ebp]
	not	ecx
	and	eax, ecx
	push	eax
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?SetFrontTextFlags@OTWDriverClass@@QAEXJ@Z ; OTWDriverClass::SetFrontTextFlags

; 270  : 		} else {

	jmp	SHORT $LN8@OTWToggleS
$LN2@OTWToggleS:

; 271  : 			OTWDriver.SetFrontTextFlags(OTWDriver.GetFrontTextFlags() | flag);

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetFrontTextFlags@OTWDriverClass@@QAEJXZ ; OTWDriverClass::GetFrontTextFlags
	or	eax, DWORD PTR _flag$1[ebp]
	push	eax
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?SetFrontTextFlags@OTWDriverClass@@QAEXJ@Z ; OTWDriverClass::SetFrontTextFlags
$LN8@OTWToggleS:

; 272  : 		}
; 273  : 	}
; 274  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?OTWToggleScoreDisplay@@YAXKHPAX@Z ENDP			; OTWToggleScoreDisplay
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?BombBurstDecrement@@YAXKHPAX@Z PROC			; BombBurstDecrement

; 1997 : {

	push	ebp
	mov	ebp, esp

; 1998 :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@BombBurstD
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@BombBurstD

; 1999 :    {
; 2000 :       if (state & KEY_DOWN && SimDriver.GetPlayerAircraft()->Sms)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@BombBurstD
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+940], 0
	je	SHORT $LN3@BombBurstD

; 2001 :       {
; 2002 :          SimDriver.GetPlayerAircraft()->Sms->DecrementBurstHeight();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+940]
	call	?DecrementBurstHeight@SMSClass@@QAEXXZ	; SMSClass::DecrementBurstHeight
$LN3@BombBurstD:

; 2003 :       }
; 2004 :    }
; 2005 : }

	pop	ebp
	ret	0
?BombBurstDecrement@@YAXKHPAX@Z ENDP			; BombBurstDecrement
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?BombBurstIncrement@@YAXKHPAX@Z PROC			; BombBurstIncrement

; 1986 : {

	push	ebp
	mov	ebp, esp

; 1987 :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@BombBurstI
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@BombBurstI

; 1988 :    {
; 1989 :       if (state & KEY_DOWN && SimDriver.GetPlayerAircraft()->Sms)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@BombBurstI
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+940], 0
	je	SHORT $LN3@BombBurstI

; 1990 :       {
; 1991 :          SimDriver.GetPlayerAircraft()->Sms->IncrementBurstHeight();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+940]
	call	?IncrementBurstHeight@SMSClass@@QAEXXZ	; SMSClass::IncrementBurstHeight
$LN3@BombBurstI:

; 1992 :       }
; 1993 :    }
; 1994 : }

	pop	ebp
	ret	0
?BombBurstIncrement@@YAXKHPAX@Z ENDP			; BombBurstIncrement
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?BombSGLRelease@@YAXKHPAX@Z PROC			; BombSGLRelease

; 2020 : {

	push	ebp
	mov	ebp, esp

; 2021 :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@BombSGLRel
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@BombSGLRel

; 2022 :    {
; 2023 :       if (state & KEY_DOWN && SimDriver.GetPlayerAircraft()->Sms)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@BombSGLRel
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+940], 0
	je	SHORT $LN3@BombSGLRel

; 2024 :       {
; 2025 :          //SimDriver.GetPlayerAircraft()->Sms->SetPair(FALSE);
; 2026 :          SimDriver.GetPlayerAircraft()->Sms->SetAGBPair(FALSE);

	push	0
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+940]
	call	?SetAGBPair@SMSClass@@QAEX_N@Z		; SMSClass::SetAGBPair
$LN3@BombSGLRel:

; 2027 :       }
; 2028 :    }
; 2029 : }

	pop	ebp
	ret	0
?BombSGLRelease@@YAXKHPAX@Z ENDP			; BombSGLRelease
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?BombPairRelease@@YAXKHPAX@Z PROC			; BombPairRelease

; 2008 : {

	push	ebp
	mov	ebp, esp

; 2009 :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@BombPairRe
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@BombPairRe

; 2010 :    {
; 2011 :       if (state & KEY_DOWN && SimDriver.GetPlayerAircraft()->Sms)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@BombPairRe
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+940], 0
	je	SHORT $LN3@BombPairRe

; 2012 :       {
; 2013 :          //SimDriver.GetPlayerAircraft()->Sms->SetPair(TRUE);
; 2014 :          SimDriver.GetPlayerAircraft()->Sms->SetAGBPair(TRUE);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+940]
	call	?SetAGBPair@SMSClass@@QAEX_N@Z		; SMSClass::SetAGBPair
$LN3@BombPairRe:

; 2015 :       }
; 2016 :    }
; 2017 : }

	pop	ebp
	ret	0
?BombPairRelease@@YAXKHPAX@Z ENDP			; BombPairRelease
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?BombIntervalDecrement@@YAXKHPAX@Z PROC			; BombIntervalDecrement

; 1975 : {

	push	ebp
	mov	ebp, esp

; 1976 :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@BombInterv
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@BombInterv

; 1977 :    {
; 1978 :       if (state & KEY_DOWN && SimDriver.GetPlayerAircraft()->Sms)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@BombInterv
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+940], 0
	je	SHORT $LN3@BombInterv

; 1979 :       {
; 1980 :          SimDriver.GetPlayerAircraft()->Sms->DecrementRippleInterval();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+940]
	call	?DecrementRippleInterval@SMSClass@@QAEXXZ ; SMSClass::DecrementRippleInterval
$LN3@BombInterv:

; 1981 :       }
; 1982 :    }
; 1983 : }

	pop	ebp
	ret	0
?BombIntervalDecrement@@YAXKHPAX@Z ENDP			; BombIntervalDecrement
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?BombRippleDecrement@@YAXKHPAX@Z PROC			; BombRippleDecrement

; 1964 : {

	push	ebp
	mov	ebp, esp

; 1965 :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@BombRipple
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@BombRipple

; 1966 :    {
; 1967 :       if (state & KEY_DOWN && SimDriver.GetPlayerAircraft()->Sms)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@BombRipple
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+940], 0
	je	SHORT $LN3@BombRipple

; 1968 :       {
; 1969 :          SimDriver.GetPlayerAircraft()->Sms->DecrementRippleCount();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+940]
	call	?DecrementRippleCount@SMSClass@@QAEXXZ	; SMSClass::DecrementRippleCount
$LN3@BombRipple:

; 1970 :       }
; 1971 :    }
; 1972 : }

	pop	ebp
	ret	0
?BombRippleDecrement@@YAXKHPAX@Z ENDP			; BombRippleDecrement
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?BombIntervalIncrement@@YAXKHPAX@Z PROC			; BombIntervalIncrement

; 1953 : {

	push	ebp
	mov	ebp, esp

; 1954 :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@BombInterv
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@BombInterv

; 1955 :    {
; 1956 :       if (state & KEY_DOWN && SimDriver.GetPlayerAircraft()->Sms)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@BombInterv
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+940], 0
	je	SHORT $LN3@BombInterv

; 1957 :       {
; 1958 :          SimDriver.GetPlayerAircraft()->Sms->IncrementRippleInterval();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+940]
	call	?IncrementRippleInterval@SMSClass@@QAEXXZ ; SMSClass::IncrementRippleInterval
$LN3@BombInterv:

; 1959 :       }
; 1960 :    }
; 1961 : }

	pop	ebp
	ret	0
?BombIntervalIncrement@@YAXKHPAX@Z ENDP			; BombIntervalIncrement
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?BombRippleIncrement@@YAXKHPAX@Z PROC			; BombRippleIncrement

; 1942 : {

	push	ebp
	mov	ebp, esp

; 1943 :    if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@BombRipple
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@BombRipple

; 1944 :    {
; 1945 :       if (state & KEY_DOWN && SimDriver.GetPlayerAircraft()->Sms)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@BombRipple
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+940], 0
	je	SHORT $LN3@BombRipple

; 1946 :       {
; 1947 :          SimDriver.GetPlayerAircraft()->Sms->IncrementRippleCount();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+940]
	call	?IncrementRippleCount@SMSClass@@QAEXXZ	; SMSClass::IncrementRippleCount
$LN3@BombRipple:

; 1948 :       }
; 1949 :    }
; 1950 : }

	pop	ebp
	ret	0
?BombRippleIncrement@@YAXKHPAX@Z ENDP			; BombRippleIncrement
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv80 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?AFABFull@@YAXKHPAX@Z PROC				; AFABFull

; 2312 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2313 :    if ((state & KEY_DOWN) && (SimDriver.GetPlayerAircraft()) && (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)))

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN1@AFABFull
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN1@AFABFull
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN1@AFABFull

; 2314 :       throttleOffset = max (1.50F, throttleOffset);

	movss	xmm0, DWORD PTR __real@3fc00000
	comiss	xmm0, DWORD PTR ?throttleOffset@@3MA
	jbe	SHORT $LN4@AFABFull
	movss	xmm0, DWORD PTR __real@3fc00000
	movss	DWORD PTR tv80[ebp], xmm0
	jmp	SHORT $LN5@AFABFull
$LN4@AFABFull:
	movss	xmm0, DWORD PTR ?throttleOffset@@3MA
	movss	DWORD PTR tv80[ebp], xmm0
$LN5@AFABFull:
	movss	xmm0, DWORD PTR tv80[ebp]
	movss	DWORD PTR ?throttleOffset@@3MA, xmm0
$LN1@AFABFull:

; 2315 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AFABFull@@YAXKHPAX@Z ENDP				; AFABFull
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCycleDebugLabels@@YAXKHPAX@Z PROC			; SimCycleDebugLabels

; 10485: {

	push	ebp
	mov	ebp, esp

; 10486: 	if(state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN5@SimCycleDe

; 10487: 	{
; 10488: 		if (g_nShowDebugLabels > 0)

	cmp	DWORD PTR ?g_nShowDebugLabels@@3HA, 0	; g_nShowDebugLabels
	jle	SHORT $LN3@SimCycleDe

; 10489: 		{
; 10490: 			g_nShowDebugLabels *= 2;

	mov	ecx, DWORD PTR ?g_nShowDebugLabels@@3HA	; g_nShowDebugLabels
	shl	ecx, 1
	mov	DWORD PTR ?g_nShowDebugLabels@@3HA, ecx	; g_nShowDebugLabels

; 10491: 			if (g_nShowDebugLabels >= g_nMaxDebugLabel)

	mov	edx, DWORD PTR ?g_nShowDebugLabels@@3HA	; g_nShowDebugLabels
	cmp	edx, DWORD PTR ?g_nMaxDebugLabel@@3HA	; g_nMaxDebugLabel
	jl	SHORT $LN2@SimCycleDe

; 10492: 				g_nShowDebugLabels = 0;

	mov	DWORD PTR ?g_nShowDebugLabels@@3HA, 0	; g_nShowDebugLabels
$LN2@SimCycleDe:

; 10493: 		}
; 10494: 		else

	jmp	SHORT $LN5@SimCycleDe
$LN3@SimCycleDe:

; 10495: 			g_nShowDebugLabels = 1;

	mov	DWORD PTR ?g_nShowDebugLabels@@3HA, 1	; g_nShowDebugLabels
$LN5@SimCycleDe:

; 10496: 	}
; 10497: }

	pop	ebp
	ret	0
?SimCycleDebugLabels@@YAXKHPAX@Z ENDP			; SimCycleDebugLabels
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_fueltodump$1 = -32					; size = 4
tv174 = -28						; size = 4
tv183 = -24						; size = 4
tv169 = -20						; size = 4
tv164 = -16						; size = 4
tv181 = -12						; size = 4
tv159 = -8						; size = 4
tv140 = -4						; size = 4
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimFuelDump@@YAXKHPAX@Z PROC				; SimFuelDump

; 10476: {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 10477: 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN1@SimFuelDum
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN1@SimFuelDum
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN1@SimFuelDum

; 10478: 	{
; 10479: 		float fueltodump = max((SimDriver.GetPlayerAircraft()->af->Fuel() +	SimDriver.GetPlayerAircraft()->af->ExternalFuel()) / 15.0f, 100);

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?Fuel@AirframeClass@@QAEMXZ		; AirframeClass::Fuel
	fstp	DWORD PTR tv159[ebp]
	movss	xmm0, DWORD PTR tv159[ebp]
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	movss	DWORD PTR tv181[ebp], xmm0
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?ExternalFuel@AirframeClass@@QAEMXZ	; AirframeClass::ExternalFuel
	fstp	DWORD PTR tv164[ebp]
	movss	xmm0, DWORD PTR tv181[ebp]
	addss	xmm0, DWORD PTR tv164[ebp]
	divss	xmm0, DWORD PTR __real@41700000
	comiss	xmm0, DWORD PTR __real@42c80000
	jbe	SHORT $LN4@SimFuelDum
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?Fuel@AirframeClass@@QAEMXZ		; AirframeClass::Fuel
	fstp	DWORD PTR tv169[ebp]
	movss	xmm0, DWORD PTR tv169[ebp]
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	movss	DWORD PTR tv183[ebp], xmm0
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?ExternalFuel@AirframeClass@@QAEMXZ	; AirframeClass::ExternalFuel
	fstp	DWORD PTR tv174[ebp]
	movss	xmm0, DWORD PTR tv183[ebp]
	addss	xmm0, DWORD PTR tv174[ebp]
	divss	xmm0, DWORD PTR __real@41700000
	movss	DWORD PTR tv140[ebp], xmm0
	jmp	SHORT $LN5@SimFuelDum
$LN4@SimFuelDum:
	movss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR tv140[ebp], xmm0
$LN5@SimFuelDum:
	movss	xmm0, DWORD PTR tv140[ebp]
	movss	DWORD PTR _fueltodump$1[ebp], xmm0

; 10480: 		SimDriver.GetPlayerAircraft()->af->AddFuel(-fueltodump);

	movss	xmm0, DWORD PTR _fueltodump$1[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?AddFuel@AirframeClass@@QAEHM@Z		; AirframeClass::AddFuel
$LN1@SimFuelDum:

; 10481: 	}
; 10482: }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimFuelDump@@YAXKHPAX@Z ENDP				; SimFuelDump
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_newcomp$ = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?TimeAccelerateDec@@YAXKHPAX@Z PROC			; TimeAccelerateDec

; 1924 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1925 : 	int newcomp;
; 1926 : 
; 1927 : 	if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@TimeAccele

; 1928 : 	{
; 1929 : 		newcomp = gameCompressionRatio / 2;

	mov	eax, DWORD PTR ?gameCompressionRatio@@3HA ; gameCompressionRatio
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _newcomp$[ebp], eax

; 1930 : 		if (newcomp == 0)

	jne	SHORT $LN1@TimeAccele

; 1931 : 			newcomp = 1;

	mov	DWORD PTR _newcomp$[ebp], 1
$LN1@TimeAccele:

; 1932 : 
; 1933 : 		SetTimeCompression (newcomp);

	mov	ecx, DWORD PTR _newcomp$[ebp]
	push	ecx
	call	?SetTimeCompression@@YAXH@Z		; SetTimeCompression
	add	esp, 4

; 1934 : 	
; 1935 : 		F4HearVoices();

	call	_F4HearVoices
$LN3@TimeAccele:

; 1936 : 	}	  
; 1937 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?TimeAccelerateDec@@YAXKHPAX@Z ENDP			; TimeAccelerateDec
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_newcomp$ = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?TimeAccelerateInc@@YAXKHPAX@Z PROC			; TimeAccelerateInc

; 1908 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1909 : 	int newcomp;
; 1910 : 
; 1911 : 	if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@TimeAccele

; 1912 : 	{
; 1913 : 		newcomp = gameCompressionRatio * 2;

	mov	ecx, DWORD PTR ?gameCompressionRatio@@3HA ; gameCompressionRatio
	shl	ecx, 1
	mov	DWORD PTR _newcomp$[ebp], ecx

; 1914 : 		if (newcomp > g_nMaxSimTimeAcceleration)

	mov	edx, DWORD PTR _newcomp$[ebp]
	cmp	edx, DWORD PTR ?g_nMaxSimTimeAcceleration@@3HA ; g_nMaxSimTimeAcceleration
	jle	SHORT $LN1@TimeAccele

; 1915 : 			newcomp = g_nMaxSimTimeAcceleration;

	mov	eax, DWORD PTR ?g_nMaxSimTimeAcceleration@@3HA ; g_nMaxSimTimeAcceleration
	mov	DWORD PTR _newcomp$[ebp], eax
$LN1@TimeAccele:

; 1916 : 
; 1917 : 		SetTimeCompression (newcomp);

	mov	ecx, DWORD PTR _newcomp$[ebp]
	push	ecx
	call	?SetTimeCompression@@YAXH@Z		; SetTimeCompression
	add	esp, 4

; 1918 : 	
; 1919 : 		F4HearVoices();

	call	_F4HearVoices
$LN3@TimeAccele:

; 1920 : 	}	  
; 1921 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?TimeAccelerateInc@@YAXKHPAX@Z ENDP			; TimeAccelerateInc
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?TimeAccelerateMaxToggle@@YAXKHPAX@Z PROC		; TimeAccelerateMaxToggle

; 1891 : {

	push	ebp
	mov	ebp, esp

; 1892 :    // edg: it's ok to accel time when ejected....
; 1893 :    // if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP))
; 1894 :    {
; 1895 :       if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN4@TimeAccele

; 1896 :       {
; 1897 :          if (gameCompressionRatio != 4)

	cmp	DWORD PTR ?gameCompressionRatio@@3HA, 4	; gameCompressionRatio
	je	SHORT $LN2@TimeAccele

; 1898 :             SetTimeCompression (4);

	push	4
	call	?SetTimeCompression@@YAXH@Z		; SetTimeCompression
	add	esp, 4

; 1899 :          else

	jmp	SHORT $LN1@TimeAccele
$LN2@TimeAccele:

; 1900 :             SetTimeCompression (1);

	push	1
	call	?SetTimeCompression@@YAXH@Z		; SetTimeCompression
	add	esp, 4
$LN1@TimeAccele:

; 1901 : 		 F4HearVoices();

	call	_F4HearVoices
$LN4@TimeAccele:

; 1902 :       }
; 1903 :    }
; 1904 : }

	pop	ebp
	ret	0
?TimeAccelerateMaxToggle@@YAXKHPAX@Z ENDP		; TimeAccelerateMaxToggle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?TimeAccelerate@@YAXKHPAX@Z PROC			; TimeAccelerate

; 1875 : {

	push	ebp
	mov	ebp, esp

; 1876 :    // edg: it's ok to accel time when ejected....
; 1877 :    // if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP))
; 1878 :    {
; 1879 :       if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN4@TimeAccele

; 1880 :       {
; 1881 :          if (gameCompressionRatio != 2)

	cmp	DWORD PTR ?gameCompressionRatio@@3HA, 2	; gameCompressionRatio
	je	SHORT $LN2@TimeAccele

; 1882 :             SetTimeCompression (2);

	push	2
	call	?SetTimeCompression@@YAXH@Z		; SetTimeCompression
	add	esp, 4

; 1883 :          else

	jmp	SHORT $LN1@TimeAccele
$LN2@TimeAccele:

; 1884 :             SetTimeCompression (1);

	push	1
	call	?SetTimeCompression@@YAXH@Z		; SetTimeCompression
	add	esp, 4
$LN1@TimeAccele:

; 1885 : 		 F4HearVoices();

	call	_F4HearVoices
$LN4@TimeAccele:

; 1886 :       }	  
; 1887 :    }
; 1888 : }

	pop	ebp
	ret	0
?TimeAccelerate@@YAXKHPAX@Z ENDP			; TimeAccelerate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
$T2 = -48						; size = 8
$T3 = -40						; size = 8
$T4 = -32						; size = 4
tv149 = -28						; size = 4
$T5 = -24						; size = 4
tv135 = -20						; size = 4
_trackMsg$6 = -16					; size = 4
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?ToggleSmoke@@YAXKHPAX@Z PROC				; ToggleSmoke

; 230  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ToggleSmoke@@YAXKHPAX@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 231  :    	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN4@ToggleSmok
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN4@ToggleSmok
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN4@ToggleSmok

; 232  :    	{
; 233  : 		// toggle our current smoke state
; 234  : 		gDoOwnshipSmoke ^= 1;

	mov	ecx, DWORD PTR ?gDoOwnshipSmoke@@3HA	; gDoOwnshipSmoke
	xor	ecx, 1
	mov	DWORD PTR ?gDoOwnshipSmoke@@3HA, ecx	; gDoOwnshipSmoke

; 235  : 
; 236  : 		// edg: I'm not sure if there's a better message to handle this,
; 237  : 		// but I'm using track message
; 238  : 		// HACK HACK HACK!  This should be status info on the aircraft concerned...
; 239  : 		FalconTrackMessage* trackMsg = new FalconTrackMessage(1, SimDriver.GetPlayerAircraft()->Id(), FalconLocalGame );

	push	60					; 0000003cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T5[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T5[ebp], 0
	je	SHORT $LN8@ToggleSmok
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN6@ToggleSmok
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv135[ebp], eax
	jmp	SHORT $LN7@ToggleSmok
$LN6@ToggleSmok:
	mov	DWORD PTR tv135[ebp], 0
$LN7@ToggleSmok:
	push	1
	mov	eax, DWORD PTR tv135[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	push	1
	mov	ecx, DWORD PTR $T5[ebp]
	call	??0FalconTrackMessage@@QAE@HVVU_ID@@PAVVuTargetEntity@@E@Z ; FalconTrackMessage::FalconTrackMessage
	mov	DWORD PTR tv149[ebp], eax
	jmp	SHORT $LN9@ToggleSmok
$LN8@ToggleSmok:
	mov	DWORD PTR tv149[ebp], 0
$LN9@ToggleSmok:
	mov	ecx, DWORD PTR tv149[ebp]
	mov	DWORD PTR $T4[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T4[ebp]
	mov	DWORD PTR _trackMsg$6[ebp], edx

; 240  : 		ShiAssert( trackMsg );
; 241  : 		if ( gDoOwnshipSmoke )

	cmp	DWORD PTR ?gDoOwnshipSmoke@@3HA, 0	; gDoOwnshipSmoke
	je	SHORT $LN2@ToggleSmok

; 242  : 			trackMsg->dataBlock.trackType = Track_SmokeOn;

	mov	eax, DWORD PTR _trackMsg$6[ebp]
	mov	ecx, DWORD PTR [eax+48]
	and	ecx, -65536				; ffff0000H
	or	ecx, 6
	mov	edx, DWORD PTR _trackMsg$6[ebp]
	mov	DWORD PTR [edx+48], ecx

; 243  : 		else

	jmp	SHORT $LN1@ToggleSmok
$LN2@ToggleSmok:

; 244  : 			trackMsg->dataBlock.trackType = Track_SmokeOff;

	mov	eax, DWORD PTR _trackMsg$6[ebp]
	mov	ecx, DWORD PTR [eax+48]
	and	ecx, -65536				; ffff0000H
	or	ecx, 7
	mov	edx, DWORD PTR _trackMsg$6[ebp]
	mov	DWORD PTR [edx+48], ecx
$LN1@ToggleSmok:

; 245  : 		trackMsg->dataBlock.id = SimDriver.GetPlayerAircraft()->Id();

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _trackMsg$6[ebp]
	mov	DWORD PTR [eax+52], ecx
	mov	DWORD PTR [eax+56], edx

; 246  : 	
; 247  : 		// Send our track list
; 248  : 		FalconSendMessage (trackMsg, TRUE);

	push	1
	mov	ecx, DWORD PTR _trackMsg$6[ebp]
	push	ecx
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8
$LN4@ToggleSmok:

; 249  : 	}
; 250  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?ToggleSmoke@@YAXKHPAX@Z$0:
	mov	eax, DWORD PTR $T5[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?ToggleSmoke@@YAXKHPAX@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ToggleSmoke@@YAXKHPAX@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ToggleSmoke@@YAXKHPAX@Z ENDP				; ToggleSmoke
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?ToggleNVGMode@@YAXKHPAX@Z PROC				; ToggleNVGMode

; 210  : {

	push	ebp
	mov	ebp, esp

; 211  : 	if (state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@ToggleNVGM

; 212  : 		OTWDriver.NVGToggle();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?NVGToggle@OTWDriverClass@@QAEXXZ	; OTWDriverClass::NVGToggle
$LN2@ToggleNVGM:

; 213  : }

	pop	ebp
	ret	0
?ToggleNVGMode@@YAXKHPAX@Z ENDP				; ToggleNVGMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_board$1 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?KneeboardTogglePage@@YAXKHPAX@Z PROC			; KneeboardTogglePage

; 192  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 193  : 	if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag( MOTION_OWNSHIP ) && !((AircraftClass*)SimDriver.GetPlayerAircraft())->ejectTriggered)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN6@KneeboardT
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN6@KneeboardT
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN6@KneeboardT
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1796], 0
	jne	SHORT $LN6@KneeboardT

; 194  : 	{
; 195  : 		KneeBoard *board = OTWDriver.pCockpitManager->mpKneeBoard;

	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	edx, DWORD PTR [ecx+700]
	mov	DWORD PTR _board$1[ebp], edx

; 196  : 		ShiAssert( board );
; 197  : 
; 198  : 		if (board->GetPage() == KneeBoard::MAP) {

	mov	ecx, DWORD PTR _board$1[ebp]
	call	?GetPage@KneeBoard@@QAE?AW4Page@1@XZ	; KneeBoard::GetPage
	cmp	eax, 1
	jne	SHORT $LN4@KneeboardT

; 199  : 			board->SetPage( KneeBoard::BRIEF );

	push	0
	mov	ecx, DWORD PTR _board$1[ebp]
	call	?SetPage@KneeBoard@@QAEXW4Page@1@@Z	; KneeBoard::SetPage
	jmp	SHORT $LN6@KneeboardT
$LN4@KneeboardT:

; 200  : 		}
; 201  : 		else if (board->GetPage() == KneeBoard::BRIEF) {

	mov	ecx, DWORD PTR _board$1[ebp]
	call	?GetPage@KneeBoard@@QAE?AW4Page@1@XZ	; KneeBoard::GetPage
	test	eax, eax
	jne	SHORT $LN2@KneeboardT

; 202  : 		    board->SetPage(KneeBoard::STEERPOINT);

	push	2
	mov	ecx, DWORD PTR _board$1[ebp]
	call	?SetPage@KneeBoard@@QAEXW4Page@1@@Z	; KneeBoard::SetPage

; 203  : 		} else {

	jmp	SHORT $LN6@KneeboardT
$LN2@KneeboardT:

; 204  : 			board->SetPage( KneeBoard::MAP );

	push	1
	mov	ecx, DWORD PTR _board$1[ebp]
	call	?SetPage@KneeBoard@@QAEXW4Page@1@@Z	; KneeBoard::SetPage
$LN6@KneeboardT:

; 205  : 		}
; 206  : 	}
; 207  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?KneeboardTogglePage@@YAXKHPAX@Z ENDP			; KneeboardTogglePage
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
?BreakToggle@@YAXKHPAX@Z PROC				; BreakToggle

; 3903 : {

	push	ebp
	mov	ebp, esp

; 3904 : 	// You can set a global flag here if you want.
; 3905 : 	// This (might) be mapped to "Ctrl-z, t"
; 3906 : }

	pop	ebp
	ret	0
?BreakToggle@@YAXKHPAX@Z ENDP				; BreakToggle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv141 = -8						; size = 4
_theRwr$1 = -4						; size = 4
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimRwrPower@@YAXKHPAX@Z PROC				; SimRwrPower

; 8796 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 8797 :     if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN6@SimRwrPowe
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN6@SimRwrPowe
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN6@SimRwrPowe

; 8798 :     { 
; 8799 : 			PlayerRwrClass* theRwr = (PlayerRwrClass*)FindSensor(SimDriver.GetPlayerAircraft(), SensorClass::RWR);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRwr$1[ebp], eax

; 8800 : 			if(theRwr) 

	cmp	DWORD PTR _theRwr$1[ebp], 0
	je	$LN6@SimRwrPowe

; 8801 : 			{
; 8802 : 				theRwr->SetPower(!theRwr->IsOn());

	mov	ecx, DWORD PTR _theRwr$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRwr$1[ebp]
	mov	eax, DWORD PTR [edx+32]
	call	eax
	test	eax, eax
	jne	SHORT $LN8@SimRwrPowe
	mov	DWORD PTR tv141[ebp], 1
	jmp	SHORT $LN9@SimRwrPowe
$LN8@SimRwrPowe:
	mov	DWORD PTR tv141[ebp], 0
$LN9@SimRwrPowe:
	mov	ecx, DWORD PTR tv141[ebp]
	push	ecx
	mov	edx, DWORD PTR _theRwr$1[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _theRwr$1[ebp]
	mov	edx, DWORD PTR [eax+28]
	call	edx

; 8803 : 				if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN6@SimRwrPowe

; 8804 : 				 if (theRwr->IsOn())

	mov	eax, DWORD PTR _theRwr$1[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _theRwr$1[ebp]
	mov	eax, DWORD PTR [edx+32]
	call	eax
	test	eax, eax
	je	SHORT $LN2@SimRwrPowe

; 8805 : 						OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_RWR_PWR, 2);

	push	2
	push	148					; 00000094H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 8806 : 					else

	jmp	SHORT $LN6@SimRwrPowe
$LN2@SimRwrPowe:

; 8807 : 						OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_RWR_PWR, 1);

	push	1
	push	148					; 00000094H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN6@SimRwrPowe:

; 8808 : 			}
; 8809 :     }
; 8810 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimRwrPower@@YAXKHPAX@Z ENDP				; SimRwrPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimHUDOff@@YAXKHPAX@Z PROC				; SimHUDOff

; 6833 : {

	push	ebp
	mov	ebp, esp

; 6834 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimHUDOff

; 6835 : 		return;

	jmp	SHORT $LN4@SimHUDOff
$LN3@SimHUDOff:

; 6836 : 
; 6837 :   if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimHUDOff
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimHUDOff
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimHUDOff

; 6838 : 	{
; 6839 : 		SimDriver.GetPlayerAircraft()->PowerOff(AircraftClass::HUDPower);

	push	2048					; 00000800H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerOff@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerOff

; 6840 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimHUDOff

; 6841 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HUD_PWR, 1);

	push	1
	push	147					; 00000093H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimHUDOff:

; 6842 : 	}
; 6843 : }

	pop	ebp
	ret	0
?SimHUDOff@@YAXKHPAX@Z ENDP				; SimHUDOff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimHUDOn@@YAXKHPAX@Z PROC				; SimHUDOn

; 6820 : {

	push	ebp
	mov	ebp, esp

; 6821 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimHUDOn

; 6822 : 		return;

	jmp	SHORT $LN4@SimHUDOn
$LN3@SimHUDOn:

; 6823 : 
; 6824 :   if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimHUDOn
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimHUDOn
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimHUDOn

; 6825 : 	{
; 6826 : 		SimDriver.GetPlayerAircraft()->PowerOn(AircraftClass::HUDPower);

	push	2048					; 00000800H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerOn@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerOn

; 6827 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimHUDOn

; 6828 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HUD_PWR, 2);

	push	2
	push	147					; 00000093H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimHUDOn:

; 6829 : 	}
; 6830 : }

	pop	ebp
	ret	0
?SimHUDOn@@YAXKHPAX@Z ENDP				; SimHUDOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimHUDPower@@YAXKHPAX@Z PROC				; SimHUDPower

; 6808 : {

	push	ebp
	mov	ebp, esp

; 6809 :   if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimHUDPowe
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimHUDPowe
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimHUDPowe

; 6810 : 	{
; 6811 : 		SimDriver.GetPlayerAircraft()->PowerToggle (AircraftClass::HUDPower);

	push	2048					; 00000800H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerToggle@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerToggle

; 6812 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN3@SimHUDPowe

; 6813 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HUD_PWR, SimDriver.GetPlayerAircraft()->HasPower(AircraftClass::HUDPower)+1);

	push	2048					; 00000800H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::HasPower
	add	eax, 1
	push	eax
	push	147					; 00000093H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN3@SimHUDPowe:

; 6814 : 	}
; 6815 : }

	pop	ebp
	ret	0
?SimHUDPower@@YAXKHPAX@Z ENDP				; SimHUDPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimFCROff@@YAXKHPAX@Z PROC				; SimFCROff

; 6795 : {

	push	ebp
	mov	ebp, esp

; 6796 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimFCROff

; 6797 : 		return;

	jmp	SHORT $LN4@SimFCROff
$LN3@SimFCROff:

; 6798 : 
; 6799 :   if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimFCROff
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimFCROff
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimFCROff

; 6800 : 	{
; 6801 : 		SimDriver.GetPlayerAircraft()->PowerOff(AircraftClass::FCRPower);

	push	1024					; 00000400H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerOff@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerOff

; 6802 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimFCROff

; 6803 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_FCR_PWR, 1);

	push	1
	push	196					; 000000c4H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimFCROff:

; 6804 : 	}
; 6805 : }

	pop	ebp
	ret	0
?SimFCROff@@YAXKHPAX@Z ENDP				; SimFCROff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimFCROn@@YAXKHPAX@Z PROC				; SimFCROn

; 6782 : {

	push	ebp
	mov	ebp, esp

; 6783 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimFCROn

; 6784 : 		return;

	jmp	SHORT $LN4@SimFCROn
$LN3@SimFCROn:

; 6785 : 
; 6786 :   if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimFCROn
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimFCROn
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimFCROn

; 6787 : 	{
; 6788 : 		SimDriver.GetPlayerAircraft()->PowerOn(AircraftClass::FCRPower);

	push	1024					; 00000400H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerOn@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerOn

; 6789 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimFCROn

; 6790 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_FCR_PWR, 2);

	push	2
	push	196					; 000000c4H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimFCROn:

; 6791 : 	}
; 6792 : }

	pop	ebp
	ret	0
?SimFCROn@@YAXKHPAX@Z ENDP				; SimFCROn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimFCRPower@@YAXKHPAX@Z PROC				; SimFCRPower

; 6770 : {

	push	ebp
	mov	ebp, esp

; 6771 :     if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimFCRPowe
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimFCRPowe
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimFCRPowe

; 6772 : 		{
; 6773 : 			SimDriver.GetPlayerAircraft()->PowerToggle (AircraftClass::FCRPower);

	push	1024					; 00000400H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerToggle@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerToggle

; 6774 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN3@SimFCRPowe

; 6775 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_FCR_PWR, SimDriver.GetPlayerAircraft()->HasPower(AircraftClass::FCRPower)+1);

	push	1024					; 00000400H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::HasPower
	add	eax, 1
	push	eax
	push	196					; 000000c4H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN3@SimFCRPowe:

; 6776 : 		}
; 6777 : }

	pop	ebp
	ret	0
?SimFCRPower@@YAXKHPAX@Z ENDP				; SimFCRPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimLeftHptOff@@YAXKHPAX@Z PROC				; SimLeftHptOff

; 6750 : {

	push	ebp
	mov	ebp, esp

; 6751 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimLeftHpt

; 6752 : 		return;

	jmp	SHORT $LN4@SimLeftHpt
$LN3@SimLeftHpt:

; 6753 : 
; 6754 :     if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimLeftHpt
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimLeftHpt
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimLeftHpt

; 6755 : 		{
; 6756 : 			SimDriver.GetPlayerAircraft()->PowerOff(AircraftClass::LeftHptPower);

	push	128					; 00000080H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerOff@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerOff

; 6757 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimLeftHpt

; 6758 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_LEFT_HPT_PWR, 1);

	push	1
	push	194					; 000000c2H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimLeftHpt:

; 6759 : 		}
; 6760 : }

	pop	ebp
	ret	0
?SimLeftHptOff@@YAXKHPAX@Z ENDP				; SimLeftHptOff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimLeftHptOn@@YAXKHPAX@Z PROC				; SimLeftHptOn

; 6737 : {

	push	ebp
	mov	ebp, esp

; 6738 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimLeftHpt

; 6739 : 		return;

	jmp	SHORT $LN4@SimLeftHpt
$LN3@SimLeftHpt:

; 6740 : 
; 6741 :     if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimLeftHpt
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimLeftHpt
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimLeftHpt

; 6742 : 		{
; 6743 : 			SimDriver.GetPlayerAircraft()->PowerOn(AircraftClass::LeftHptPower);

	push	128					; 00000080H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerOn@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerOn

; 6744 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimLeftHpt

; 6745 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_LEFT_HPT_PWR, 2);

	push	2
	push	194					; 000000c2H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimLeftHpt:

; 6746 : 		}
; 6747 : }

	pop	ebp
	ret	0
?SimLeftHptOn@@YAXKHPAX@Z ENDP				; SimLeftHptOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimLeftHptPower@@YAXKHPAX@Z PROC			; SimLeftHptPower

; 6719 : {

	push	ebp
	mov	ebp, esp

; 6720 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN5@SimLeftHpt

; 6721 : 		return;

	jmp	$LN6@SimLeftHpt
$LN5@SimLeftHpt:

; 6722 : 
; 6723 :     if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN6@SimLeftHpt
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN6@SimLeftHpt
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN6@SimLeftHpt

; 6724 : 		{
; 6725 : 			SimDriver.GetPlayerAircraft()->PowerToggle (AircraftClass::LeftHptPower);

	push	128					; 00000080H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerToggle@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerToggle

; 6726 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN6@SimLeftHpt

; 6727 : 				if (SimDriver.GetPlayerAircraft()->HasPower(AircraftClass::LeftHptPower))

	push	128					; 00000080H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::HasPower
	test	eax, eax
	je	SHORT $LN2@SimLeftHpt

; 6728 : 					OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_LEFT_HPT_PWR, 2);

	push	2
	push	194					; 000000c2H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 6729 : 				else

	jmp	SHORT $LN6@SimLeftHpt
$LN2@SimLeftHpt:

; 6730 : 					OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_LEFT_HPT_PWR, 1);

	push	1
	push	194					; 000000c2H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN6@SimLeftHpt:

; 6731 : 		}
; 6732 : }

	pop	ebp
	ret	0
?SimLeftHptPower@@YAXKHPAX@Z ENDP			; SimLeftHptPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimRightHptOff@@YAXKHPAX@Z PROC			; SimRightHptOff

; 6701 : {

	push	ebp
	mov	ebp, esp

; 6702 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN4@SimRightHp

; 6703 : 		return;

	jmp	$LN5@SimRightHp
$LN4@SimRightHp:

; 6704 : 
; 6705 :     if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN5@SimRightHp
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN5@SimRightHp
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN5@SimRightHp

; 6706 : 	{
; 6707 : 		SimDriver.GetPlayerAircraft()->PowerOff(AircraftClass::RightHptPower);

	push	256					; 00000100H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerOff@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerOff

; 6708 : 		if(SimDriver.GetPlayerAircraft()->FCC)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+936], 0
	je	SHORT $LN5@SimRightHp

; 6709 : 		{
; 6710 : 			SimDriver.GetPlayerAircraft()->FCC->LaserFire = FALSE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+936]
	mov	BYTE PTR [edx+423], 0

; 6711 : 			SimDriver.GetPlayerAircraft()->FCC->InhibitFire = TRUE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	eax, DWORD PTR [eax+936]
	mov	BYTE PTR [eax+425], 1

; 6712 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN5@SimRightHp

; 6713 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_RIGHT_HPT_PWR, 1);

	push	1
	push	195					; 000000c3H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN5@SimRightHp:

; 6714 : 		}
; 6715 : 	}
; 6716 : }

	pop	ebp
	ret	0
?SimRightHptOff@@YAXKHPAX@Z ENDP			; SimRightHptOff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimRightHptOn@@YAXKHPAX@Z PROC				; SimRightHptOn

; 6683 : {

	push	ebp
	mov	ebp, esp

; 6684 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN4@SimRightHp

; 6685 : 		return;

	jmp	$LN5@SimRightHp
$LN4@SimRightHp:

; 6686 : 
; 6687 :     if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN5@SimRightHp
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN5@SimRightHp
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN5@SimRightHp

; 6688 : 	{
; 6689 : 		SimDriver.GetPlayerAircraft()->PowerOn(AircraftClass::RightHptPower);

	push	256					; 00000100H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerOn@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerOn

; 6690 : 		if(SimDriver.GetPlayerAircraft()->FCC)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+936], 0
	je	SHORT $LN5@SimRightHp

; 6691 : 		{
; 6692 : 			SimDriver.GetPlayerAircraft()->FCC->LaserFire = FALSE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+936]
	mov	BYTE PTR [edx+423], 0

; 6693 : 			SimDriver.GetPlayerAircraft()->FCC->InhibitFire = FALSE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	eax, DWORD PTR [eax+936]
	mov	BYTE PTR [eax+425], 0

; 6694 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN5@SimRightHp

; 6695 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_RIGHT_HPT_PWR, 2);

	push	2
	push	195					; 000000c3H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN5@SimRightHp:

; 6696 : 		}
; 6697 : 	}
; 6698 : }

	pop	ebp
	ret	0
?SimRightHptOn@@YAXKHPAX@Z ENDP				; SimRightHptOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimRightHptPower@@YAXKHPAX@Z PROC			; SimRightHptPower

; 6652 : {

	push	ebp
	mov	ebp, esp

; 6653 :     if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN8@SimRightHp
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN8@SimRightHp
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN8@SimRightHp

; 6654 : 	{
; 6655 : 		SimDriver.GetPlayerAircraft()->PowerToggle (AircraftClass::RightHptPower);

	push	256					; 00000100H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerToggle@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerToggle

; 6656 : 		//MI
; 6657 : 		if(g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	$LN8@SimRightHp

; 6658 : 		{
; 6659 : 			if(SimDriver.GetPlayerAircraft()->FCC)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+936], 0
	je	$LN8@SimRightHp

; 6660 : 			{
; 6661 : 				if(SimDriver.GetPlayerAircraft()->HasPower(AircraftClass::RightHptPower))

	push	256					; 00000100H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::HasPower
	test	eax, eax
	je	SHORT $LN4@SimRightHp

; 6662 : 				{
; 6663 : 					SimDriver.GetPlayerAircraft()->FCC->LaserFire = FALSE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+936]
	mov	BYTE PTR [edx+423], 0

; 6664 : 					SimDriver.GetPlayerAircraft()->FCC->InhibitFire = FALSE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	eax, DWORD PTR [eax+936]
	mov	BYTE PTR [eax+425], 0

; 6665 : 					if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN3@SimRightHp

; 6666 : 						OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_RIGHT_HPT_PWR, 2);

	push	2
	push	195					; 000000c3H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN3@SimRightHp:

; 6667 : 				}
; 6668 : 				else

	jmp	SHORT $LN8@SimRightHp
$LN4@SimRightHp:

; 6669 : 				{
; 6670 : 					SimDriver.GetPlayerAircraft()->FCC->LaserFire = FALSE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	mov	BYTE PTR [ecx+423], 0

; 6671 : 					SimDriver.GetPlayerAircraft()->FCC->InhibitFire = TRUE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+936]
	mov	BYTE PTR [edx+425], 1

; 6672 : 					if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN8@SimRightHp

; 6673 : 						OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_RIGHT_HPT_PWR, 1);

	push	1
	push	195					; 000000c3H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN8@SimRightHp:

; 6674 : 				}
; 6675 : 			}
; 6676 : 		}
; 6677 : 	}
; 6678 : }

	pop	ebp
	ret	0
?SimRightHptPower@@YAXKHPAX@Z ENDP			; SimRightHptPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimTISLPower@@YAXKHPAX@Z PROC				; SimTISLPower

; 6764 : {

	push	ebp
	mov	ebp, esp

; 6765 :     if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimTISLPow
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimTISLPow
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimTISLPow

; 6766 : 		SimDriver.GetPlayerAircraft()->PowerToggle (AircraftClass::TISLPower);

	push	512					; 00000200H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerToggle@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerToggle
$LN2@SimTISLPow:

; 6767 : }

	pop	ebp
	ret	0
?SimTISLPower@@YAXKHPAX@Z ENDP				; SimTISLPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimMAPOff@@YAXKHPAX@Z PROC				; SimMAPOff

; 6639 : {

	push	ebp
	mov	ebp, esp

; 6640 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimMAPOff

; 6641 : 		return;

	jmp	SHORT $LN4@SimMAPOff
$LN3@SimMAPOff:

; 6642 : 
; 6643 :     if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimMAPOff
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimMAPOff
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimMAPOff

; 6644 : 		{
; 6645 : 			SimDriver.GetPlayerAircraft()->PowerOff(AircraftClass::MAPPower);

	push	64					; 00000040H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerOff@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerOff

; 6646 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimMAPOff

; 6647 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_MAP_PWR, 1);

	push	1
	push	215					; 000000d7H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimMAPOff:

; 6648 : 		}
; 6649 : }

	pop	ebp
	ret	0
?SimMAPOff@@YAXKHPAX@Z ENDP				; SimMAPOff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimMAPOn@@YAXKHPAX@Z PROC				; SimMAPOn

; 6626 : {

	push	ebp
	mov	ebp, esp

; 6627 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimMAPOn

; 6628 : 		return;

	jmp	SHORT $LN4@SimMAPOn
$LN3@SimMAPOn:

; 6629 : 
; 6630 :     if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimMAPOn
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimMAPOn
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimMAPOn

; 6631 : 		{
; 6632 : 			SimDriver.GetPlayerAircraft()->PowerOn(AircraftClass::MAPPower);

	push	64					; 00000040H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerOn@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerOn

; 6633 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimMAPOn

; 6634 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_MAP_PWR, 2);

	push	2
	push	215					; 000000d7H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimMAPOn:

; 6635 : 		}
; 6636 : }

	pop	ebp
	ret	0
?SimMAPOn@@YAXKHPAX@Z ENDP				; SimMAPOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimMAPPower@@YAXKHPAX@Z PROC				; SimMAPPower

; 6613 : {

	push	ebp
	mov	ebp, esp

; 6614 :     if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimMAPPowe
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimMAPPowe
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimMAPPowe

; 6615 : 		{
; 6616 : 			SimDriver.GetPlayerAircraft()->PowerToggle (AircraftClass::MAPPower);

	push	64					; 00000040H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerToggle@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerToggle

; 6617 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN3@SimMAPPowe

; 6618 : 				//OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_MAP_PWR, SimDriver.GetPlayerAircraft()->HasPower(AircraftClass::MAPPower)+1);
; 6619 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_MAP_PWR, 1<<SimDriver.GetPlayerAircraft()->HasPower(AircraftClass::MAPPower));

	push	64					; 00000040H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::HasPower
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	push	edx
	push	215					; 000000d7H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN3@SimMAPPowe:

; 6620 : 		}
; 6621 : }

	pop	ebp
	ret	0
?SimMAPPower@@YAXKHPAX@Z ENDP				; SimMAPPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimDLOff@@YAXKHPAX@Z PROC				; SimDLOff

; 6600 : {

	push	ebp
	mov	ebp, esp

; 6601 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimDLOff

; 6602 : 		return;

	jmp	SHORT $LN4@SimDLOff
$LN3@SimDLOff:

; 6603 : 
; 6604 :     if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimDLOff
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimDLOff
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimDLOff

; 6605 : 		{
; 6606 : 			SimDriver.GetPlayerAircraft()->PowerOff(AircraftClass::DLPower);

	push	32					; 00000020H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerOff@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerOff

; 6607 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimDLOff

; 6608 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_DL_PWR, 1);

	push	1
	push	214					; 000000d6H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimDLOff:

; 6609 : 		}
; 6610 : }

	pop	ebp
	ret	0
?SimDLOff@@YAXKHPAX@Z ENDP				; SimDLOff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimDLOn@@YAXKHPAX@Z PROC				; SimDLOn

; 6583 : {

	push	ebp
	mov	ebp, esp

; 6584 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN5@SimDLOn

; 6585 : 		return;

	jmp	$LN6@SimDLOn
$LN5@SimDLOn:

; 6586 : 
; 6587 :     if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN6@SimDLOn
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN6@SimDLOn
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN6@SimDLOn

; 6588 : 		{
; 6589 : 			// RV - Biker
; 6590 : 			if (SimDriver.GetPlayerAircraft()->af->GetDataLinkCapLevel() > 0)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?GetDataLinkCapLevel@AirframeClass@@QAEHXZ ; AirframeClass::GetDataLinkCapLevel
	test	eax, eax
	jle	SHORT $LN3@SimDLOn

; 6591 : 				SimDriver.GetPlayerAircraft()->PowerOn(AircraftClass::DLPower);

	push	32					; 00000020H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerOn@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerOn

; 6592 : 			else

	jmp	SHORT $LN2@SimDLOn
$LN3@SimDLOn:

; 6593 : 				SimDriver.GetPlayerAircraft()->PowerOff (AircraftClass::DLPower);

	push	32					; 00000020H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerOff@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerOff
$LN2@SimDLOn:

; 6594 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN6@SimDLOn

; 6595 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_DL_PWR, 2);

	push	2
	push	214					; 000000d6H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN6@SimDLOn:

; 6596 : 		}
; 6597 : }

	pop	ebp
	ret	0
?SimDLOn@@YAXKHPAX@Z ENDP				; SimDLOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimDLPower@@YAXKHPAX@Z PROC				; SimDLPower

; 6566 : {

	push	ebp
	mov	ebp, esp

; 6567 :     if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN5@SimDLPower
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN5@SimDLPower
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN5@SimDLPower

; 6568 : 		{
; 6569 : 			// RV - Biker
; 6570 : 			if (SimDriver.GetPlayerAircraft()->af->GetDataLinkCapLevel() > 0)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?GetDataLinkCapLevel@AirframeClass@@QAEHXZ ; AirframeClass::GetDataLinkCapLevel
	test	eax, eax
	jle	SHORT $LN3@SimDLPower

; 6571 : 				SimDriver.GetPlayerAircraft()->PowerToggle (AircraftClass::DLPower);

	push	32					; 00000020H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerToggle@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerToggle

; 6572 : 			else

	jmp	SHORT $LN2@SimDLPower
$LN3@SimDLPower:

; 6573 : 				SimDriver.GetPlayerAircraft()->PowerOff (AircraftClass::DLPower);

	push	32					; 00000020H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerOff@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerOff
$LN2@SimDLPower:

; 6574 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN5@SimDLPower

; 6575 : 				//OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_DL_PWR, SimDriver.GetPlayerAircraft()->HasPower(AircraftClass::DLPower)+1);
; 6576 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_DL_PWR, 1<<SimDriver.GetPlayerAircraft()->HasPower(AircraftClass::DLPower));

	push	32					; 00000020H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::HasPower
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	push	edx
	push	214					; 000000d6H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN5@SimDLPower:

; 6577 : 		}
; 6578 : }

	pop	ebp
	ret	0
?SimDLPower@@YAXKHPAX@Z ENDP				; SimDLPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimGPSOff@@YAXKHPAX@Z PROC				; SimGPSOff

; 6553 : {

	push	ebp
	mov	ebp, esp

; 6554 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimGPSOff

; 6555 : 		return;

	jmp	SHORT $LN4@SimGPSOff
$LN3@SimGPSOff:

; 6556 : 
; 6557 :     if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimGPSOff
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimGPSOff
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimGPSOff

; 6558 : 		{
; 6559 : 			SimDriver.GetPlayerAircraft()->PowerOff(AircraftClass::GPSPower);

	push	16					; 00000010H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerOff@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerOff

; 6560 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimGPSOff

; 6561 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_GPS_PWR, 1);

	push	1
	push	213					; 000000d5H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimGPSOff:

; 6562 : 		}
; 6563 : }

	pop	ebp
	ret	0
?SimGPSOff@@YAXKHPAX@Z ENDP				; SimGPSOff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimGPSOn@@YAXKHPAX@Z PROC				; SimGPSOn

; 6540 : {

	push	ebp
	mov	ebp, esp

; 6541 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimGPSOn

; 6542 : 		return;

	jmp	SHORT $LN4@SimGPSOn
$LN3@SimGPSOn:

; 6543 : 
; 6544 :     if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimGPSOn
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimGPSOn
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimGPSOn

; 6545 : 		{
; 6546 : 			SimDriver.GetPlayerAircraft()->PowerOn(AircraftClass::GPSPower);

	push	16					; 00000010H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerOn@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerOn

; 6547 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimGPSOn

; 6548 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_GPS_PWR, 2);

	push	2
	push	213					; 000000d5H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimGPSOn:

; 6549 : 		}
; 6550 : }

	pop	ebp
	ret	0
?SimGPSOn@@YAXKHPAX@Z ENDP				; SimGPSOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimGPSPower@@YAXKHPAX@Z PROC				; SimGPSPower

; 6527 : {

	push	ebp
	mov	ebp, esp

; 6528 :     if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimGPSPowe
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimGPSPowe
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimGPSPowe

; 6529 : 		{
; 6530 : 			SimDriver.GetPlayerAircraft()->PowerToggle (AircraftClass::GPSPower);

	push	16					; 00000010H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerToggle@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerToggle

; 6531 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN3@SimGPSPowe

; 6532 : 				//OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_GPS_PWR, SimDriver.GetPlayerAircraft()->HasPower(AircraftClass::GPSPower)+1);
; 6533 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_GPS_PWR, 1<<SimDriver.GetPlayerAircraft()->HasPower(AircraftClass::GPSPower));

	push	16					; 00000010H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::HasPower
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	push	edx
	push	213					; 000000d5H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN3@SimGPSPowe:

; 6534 : 		}
; 6535 : }

	pop	ebp
	ret	0
?SimGPSPower@@YAXKHPAX@Z ENDP				; SimGPSPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimUFCOff@@YAXKHPAX@Z PROC				; SimUFCOff

; 6514 : {

	push	ebp
	mov	ebp, esp

; 6515 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimUFCOff

; 6516 : 		return;

	jmp	SHORT $LN4@SimUFCOff
$LN3@SimUFCOff:

; 6517 : 
; 6518 :     if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimUFCOff
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimUFCOff
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimUFCOff

; 6519 : 		{
; 6520 : 			SimDriver.GetPlayerAircraft()->PowerOff(AircraftClass::UFCPower);

	push	8
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerOff@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerOff

; 6521 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimUFCOff

; 6522 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_UFC_PWR, 1);

	push	1
	push	212					; 000000d4H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimUFCOff:

; 6523 : 		}
; 6524 : }

	pop	ebp
	ret	0
?SimUFCOff@@YAXKHPAX@Z ENDP				; SimUFCOff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimUFCOn@@YAXKHPAX@Z PROC				; SimUFCOn

; 6501 : {

	push	ebp
	mov	ebp, esp

; 6502 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimUFCOn

; 6503 : 		return;

	jmp	SHORT $LN4@SimUFCOn
$LN3@SimUFCOn:

; 6504 : 
; 6505 :     if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimUFCOn
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimUFCOn
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimUFCOn

; 6506 : 		{
; 6507 : 			SimDriver.GetPlayerAircraft()->PowerOn(AircraftClass::UFCPower);

	push	8
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerOn@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerOn

; 6508 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimUFCOn

; 6509 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_UFC_PWR, 2);

	push	2
	push	212					; 000000d4H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimUFCOn:

; 6510 : 		}
; 6511 : }

	pop	ebp
	ret	0
?SimUFCOn@@YAXKHPAX@Z ENDP				; SimUFCOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimUFCPower@@YAXKHPAX@Z PROC				; SimUFCPower

; 6488 : {

	push	ebp
	mov	ebp, esp

; 6489 :     if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimUFCPowe
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimUFCPowe
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimUFCPowe

; 6490 : 		{
; 6491 : 			SimDriver.GetPlayerAircraft()->PowerToggle (AircraftClass::UFCPower);

	push	8
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerToggle@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerToggle

; 6492 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN3@SimUFCPowe

; 6493 : 				//OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_UFC_PWR, SimDriver.GetPlayerAircraft()->HasPower(AircraftClass::UFCPower)+1);
; 6494 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_UFC_PWR, 1<<SimDriver.GetPlayerAircraft()->HasPower(AircraftClass::UFCPower));

	push	8
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::HasPower
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	push	edx
	push	212					; 000000d4H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN3@SimUFCPowe:

; 6495 : 		}
; 6496 : }

	pop	ebp
	ret	0
?SimUFCPower@@YAXKHPAX@Z ENDP				; SimUFCPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimMFDOff@@YAXKHPAX@Z PROC				; SimMFDOff

; 6475 : {

	push	ebp
	mov	ebp, esp

; 6476 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimMFDOff

; 6477 : 		return;

	jmp	SHORT $LN4@SimMFDOff
$LN3@SimMFDOff:

; 6478 : 
; 6479 :     if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimMFDOff
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimMFDOff
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimMFDOff

; 6480 : 		{
; 6481 : 			SimDriver.GetPlayerAircraft()->PowerOff(AircraftClass::MFDPower);

	push	4
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerOff@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerOff

; 6482 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimMFDOff

; 6483 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_MFD_PWR, 1);

	push	1
	push	211					; 000000d3H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimMFDOff:

; 6484 : 		}
; 6485 : }

	pop	ebp
	ret	0
?SimMFDOff@@YAXKHPAX@Z ENDP				; SimMFDOff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimMFDOn@@YAXKHPAX@Z PROC				; SimMFDOn

; 6462 : {

	push	ebp
	mov	ebp, esp

; 6463 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimMFDOn

; 6464 : 		return;

	jmp	SHORT $LN4@SimMFDOn
$LN3@SimMFDOn:

; 6465 : 
; 6466 :     if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimMFDOn
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimMFDOn
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimMFDOn

; 6467 : 		{
; 6468 : 			SimDriver.GetPlayerAircraft()->PowerOn(AircraftClass::MFDPower);

	push	4
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerOn@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerOn

; 6469 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimMFDOn

; 6470 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_MFD_PWR, 2);

	push	2
	push	211					; 000000d3H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimMFDOn:

; 6471 : 		}
; 6472 : }

	pop	ebp
	ret	0
?SimMFDOn@@YAXKHPAX@Z ENDP				; SimMFDOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimMFDPower@@YAXKHPAX@Z PROC				; SimMFDPower

; 6449 : {

	push	ebp
	mov	ebp, esp

; 6450 :     if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimMFDPowe
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimMFDPowe
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimMFDPowe

; 6451 : 		{
; 6452 : 			SimDriver.GetPlayerAircraft()->PowerToggle (AircraftClass::MFDPower);

	push	4
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerToggle@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerToggle

; 6453 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN3@SimMFDPowe

; 6454 : 				//OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_MFD_PWR, SimDriver.GetPlayerAircraft()->HasPower(AircraftClass::MFDPower)+1);
; 6455 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_MFD_PWR, 1<<SimDriver.GetPlayerAircraft()->HasPower(AircraftClass::MFDPower));

	push	4
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::HasPower
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	push	edx
	push	211					; 000000d3H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN3@SimMFDPowe:

; 6456 : 		}
; 6457 : }

	pop	ebp
	ret	0
?SimMFDPower@@YAXKHPAX@Z ENDP				; SimMFDPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimFCCOff@@YAXKHPAX@Z PROC				; SimFCCOff

; 6436 : {

	push	ebp
	mov	ebp, esp

; 6437 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimFCCOff

; 6438 : 		return;

	jmp	SHORT $LN4@SimFCCOff
$LN3@SimFCCOff:

; 6439 : 
; 6440 :     if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimFCCOff
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimFCCOff
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimFCCOff

; 6441 : 		{
; 6442 : 			SimDriver.GetPlayerAircraft()->PowerOff(AircraftClass::FCCPower);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerOff@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerOff

; 6443 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimFCCOff

; 6444 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_FCC_PWR, 1);

	push	1
	push	209					; 000000d1H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimFCCOff:

; 6445 : 		}
; 6446 : }

	pop	ebp
	ret	0
?SimFCCOff@@YAXKHPAX@Z ENDP				; SimFCCOff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimFCCOn@@YAXKHPAX@Z PROC				; SimFCCOn

; 6423 : {

	push	ebp
	mov	ebp, esp

; 6424 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimFCCOn

; 6425 : 		return;

	jmp	SHORT $LN4@SimFCCOn
$LN3@SimFCCOn:

; 6426 : 
; 6427 :     if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimFCCOn
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimFCCOn
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimFCCOn

; 6428 : 		{
; 6429 : 			SimDriver.GetPlayerAircraft()->PowerOn(AircraftClass::FCCPower);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerOn@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerOn

; 6430 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimFCCOn

; 6431 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_FCC_PWR, 2);

	push	2
	push	209					; 000000d1H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimFCCOn:

; 6432 : 		}
; 6433 : }

	pop	ebp
	ret	0
?SimFCCOn@@YAXKHPAX@Z ENDP				; SimFCCOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimFCCPower@@YAXKHPAX@Z PROC				; SimFCCPower

; 6410 : {

	push	ebp
	mov	ebp, esp

; 6411 :     if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimFCCPowe
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimFCCPowe
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimFCCPowe

; 6412 : 		{
; 6413 : 			SimDriver.GetPlayerAircraft()->PowerToggle (AircraftClass::FCCPower);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerToggle@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerToggle

; 6414 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN3@SimFCCPowe

; 6415 : 				//OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_FCC_PWR, SimDriver.GetPlayerAircraft()->HasPower(AircraftClass::FCCPower)+1);
; 6416 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_FCC_PWR, 1<<SimDriver.GetPlayerAircraft()->HasPower(AircraftClass::FCCPower));

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::HasPower
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	push	edx
	push	209					; 000000d1H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN3@SimFCCPowe:

; 6417 : 		}
; 6418 : }

	pop	ebp
	ret	0
?SimFCCPower@@YAXKHPAX@Z ENDP				; SimFCCPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimSMSOff@@YAXKHPAX@Z PROC				; SimSMSOff

; 6397 : {

	push	ebp
	mov	ebp, esp

; 6398 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimSMSOff

; 6399 : 		return;

	jmp	SHORT $LN4@SimSMSOff
$LN3@SimSMSOff:

; 6400 : 
; 6401 :     if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimSMSOff
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimSMSOff
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimSMSOff

; 6402 : 		{
; 6403 : 			SimDriver.GetPlayerAircraft()->PowerOff(AircraftClass::SMSPower);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerOff@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerOff

; 6404 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimSMSOff

; 6405 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_SMS_PWR, 1);

	push	1
	push	210					; 000000d2H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimSMSOff:

; 6406 : 		}
; 6407 : }

	pop	ebp
	ret	0
?SimSMSOff@@YAXKHPAX@Z ENDP				; SimSMSOff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimSMSOn@@YAXKHPAX@Z PROC				; SimSMSOn

; 6384 : {

	push	ebp
	mov	ebp, esp

; 6385 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimSMSOn

; 6386 : 		return;

	jmp	SHORT $LN4@SimSMSOn
$LN3@SimSMSOn:

; 6387 : 
; 6388 :     if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimSMSOn
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimSMSOn
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimSMSOn

; 6389 : 		{
; 6390 : 			SimDriver.GetPlayerAircraft()->PowerOn(AircraftClass::SMSPower);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerOn@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerOn

; 6391 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimSMSOn

; 6392 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_SMS_PWR, 2);

	push	2
	push	210					; 000000d2H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimSMSOn:

; 6393 : 		}
; 6394 : }

	pop	ebp
	ret	0
?SimSMSOn@@YAXKHPAX@Z ENDP				; SimSMSOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimSMSPower@@YAXKHPAX@Z PROC				; SimSMSPower

; 6371 : {

	push	ebp
	mov	ebp, esp

; 6372 :     if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimSMSPowe
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimSMSPowe
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimSMSPowe

; 6373 : 		{
; 6374 : 			SimDriver.GetPlayerAircraft()->PowerToggle(AircraftClass::SMSPower);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerToggle@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerToggle

; 6375 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN3@SimSMSPowe

; 6376 : 				//OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_SMS_PWR, SimDriver.GetPlayerAircraft()->HasPower(AircraftClass::SMSPower)+1);
; 6377 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_SMS_PWR, SimDriver.GetPlayerAircraft()->HasPower(AircraftClass::SMSPower));

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::HasPower
	push	eax
	push	210					; 000000d2H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN3@SimSMSPowe:

; 6378 : 		}
; 6379 : }

	pop	ebp
	ret	0
?SimSMSPower@@YAXKHPAX@Z ENDP				; SimSMSPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_theRadard$1 = -4					; size = 4
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimRangeKnobUp@@YAXKHPAX@Z PROC			; SimRangeKnobUp

; 10540: {

	push	ebp
	mov	ebp, esp
	push	ecx

; 10541: 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN7@SimRangeKn

; 10542: 		return;

	jmp	$LN8@SimRangeKn
$LN7@SimRangeKn:

; 10543: 
; 10544: 	// MD -- 20040108: adding support for analog RNG knob.
; 10545: 	// This key does nothing if the RNG is an analog control.
; 10546: 	if (IO.AnalogIsUsed(AXIS_RANGE_KNOB))

	push	13					; 0000000dH
	mov	ecx, OFFSET ?IO@@3VSIMLIB_IO_CLASS@@A	; IO
	call	?AnalogIsUsed@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z ; SIMLIB_IO_CLASS::AnalogIsUsed
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@SimRangeKn

; 10547: 		return;

	jmp	$LN8@SimRangeKn
$LN6@SimRangeKn:

; 10548: 
; 10549: 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN8@SimRangeKn
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN8@SimRangeKn
	mov	edx, DWORD PTR _state$[ebp]
	and	edx, 8
	je	$LN8@SimRangeKn

; 10550: 	{ 
; 10551: 		RadarDopplerClass* theRadard = (RadarDopplerClass*)FindSensor(SimDriver.GetPlayerAircraft(), SensorClass::Radar);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadard$1[ebp], eax

; 10552: 		//MI
; 10553: 		if(theRadard) 

	cmp	DWORD PTR _theRadard$1[ebp], 0
	je	SHORT $LN8@SimRangeKn

; 10554: 		{			   
; 10555: 			if(theRadard->GetRadarMode() == RadarClass::GM ||
; 10556: 				theRadard->GetRadarMode() == RadarClass::GMT ||
; 10557: 				theRadard->GetRadarMode() == RadarClass::SEA)

	mov	eax, DWORD PTR _theRadard$1[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _theRadard$1[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 14					; 0000000eH
	je	SHORT $LN2@SimRangeKn
	mov	ecx, DWORD PTR _theRadard$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadard$1[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 16					; 00000010H
	je	SHORT $LN2@SimRangeKn
	mov	ecx, DWORD PTR _theRadard$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadard$1[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 17					; 00000011H
	jne	SHORT $LN3@SimRangeKn
$LN2@SimRangeKn:

; 10558: 			{
; 10559: 				theRadard->StepAGgain(1);

	push	1
	mov	ecx, DWORD PTR _theRadard$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadard$1[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax

; 10560: 			}
; 10561: 			else

	jmp	SHORT $LN8@SimRangeKn
$LN3@SimRangeKn:

; 10562: 				theRadard->RangeStep(1);

	push	1
	mov	ecx, DWORD PTR _theRadard$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadard$1[ebp]
	mov	eax, DWORD PTR [edx+88]
	call	eax
$LN8@SimRangeKn:

; 10563: 		}
; 10564: 	}
; 10565: }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimRangeKnobUp@@YAXKHPAX@Z ENDP			; SimRangeKnobUp
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_theRadard$1 = -4					; size = 4
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimRangeKnobDown@@YAXKHPAX@Z PROC			; SimRangeKnobDown

; 10513: {

	push	ebp
	mov	ebp, esp
	push	ecx

; 10514: 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN7@SimRangeKn

; 10515: 		return;

	jmp	$LN8@SimRangeKn
$LN7@SimRangeKn:

; 10516: 
; 10517: 	// MD -- 20040108: adding support for analog RNG knob.
; 10518: 	// This key does nothing if the RNG is an analog control.
; 10519: 	if (IO.AnalogIsUsed(AXIS_RANGE_KNOB))

	push	13					; 0000000dH
	mov	ecx, OFFSET ?IO@@3VSIMLIB_IO_CLASS@@A	; IO
	call	?AnalogIsUsed@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z ; SIMLIB_IO_CLASS::AnalogIsUsed
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@SimRangeKn

; 10520: 		return;

	jmp	$LN8@SimRangeKn
$LN6@SimRangeKn:

; 10521: 
; 10522: 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN8@SimRangeKn
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN8@SimRangeKn
	mov	edx, DWORD PTR _state$[ebp]
	and	edx, 8
	je	$LN8@SimRangeKn

; 10523: 	{ 
; 10524: 		RadarDopplerClass* theRadard = (RadarDopplerClass*)FindSensor(SimDriver.GetPlayerAircraft(), SensorClass::Radar);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadard$1[ebp], eax

; 10525: 		//MI
; 10526: 		if(theRadard) 

	cmp	DWORD PTR _theRadard$1[ebp], 0
	je	SHORT $LN8@SimRangeKn

; 10527: 		{			   
; 10528: 			if(theRadard->GetRadarMode() == RadarClass::GM ||
; 10529: 				theRadard->GetRadarMode() == RadarClass::GMT ||
; 10530: 				theRadard->GetRadarMode() == RadarClass::SEA)

	mov	eax, DWORD PTR _theRadard$1[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _theRadard$1[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 14					; 0000000eH
	je	SHORT $LN2@SimRangeKn
	mov	ecx, DWORD PTR _theRadard$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadard$1[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 16					; 00000010H
	je	SHORT $LN2@SimRangeKn
	mov	ecx, DWORD PTR _theRadard$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadard$1[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 17					; 00000011H
	jne	SHORT $LN3@SimRangeKn
$LN2@SimRangeKn:

; 10531: 			{
; 10532: 				theRadard->StepAGgain(-1);

	push	-1
	mov	ecx, DWORD PTR _theRadard$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadard$1[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax

; 10533: 			}
; 10534: 			else

	jmp	SHORT $LN8@SimRangeKn
$LN3@SimRangeKn:

; 10535: 				theRadard->RangeStep(-1);

	push	-1
	mov	ecx, DWORD PTR _theRadard$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadard$1[ebp]
	mov	eax, DWORD PTR [edx+88]
	call	eax
$LN8@SimRangeKn:

; 10536: 		}
; 10537: 	}
; 10538: } 

	mov	esp, ebp
	pop	ebp
	ret	0
?SimRangeKnobDown@@YAXKHPAX@Z ENDP			; SimRangeKnobDown
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_curPanel$1 = -4					; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimToggleGhostMFDs@@YAXKHPAX@Z PROC			; SimToggleGhostMFDs

; 10453: {

	push	ebp
	mov	ebp, esp
	push	ecx

; 10454: 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN7@SimToggleG
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN7@SimToggleG
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN7@SimToggleG

; 10455:   {
; 10456: 		CPPanel* curPanel = OTWDriver.pCockpitManager->GetActivePanel();

	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	call	?GetActivePanel@CockpitManager@@QAEPAVCPPanel@@XZ ; CockpitManager::GetActivePanel
	mov	DWORD PTR _curPanel$1[ebp], eax

; 10457: 		if(!curPanel)

	cmp	DWORD PTR _curPanel$1[ebp], 0
	jne	SHORT $LN5@SimToggleG

; 10458: 			return;

	jmp	SHORT $LN7@SimToggleG
$LN5@SimToggleG:

; 10459: 		if(curPanel->mIdNum == 5000)

	mov	ecx, DWORD PTR _curPanel$1[ebp]
	cmp	DWORD PTR [ecx+4], 5000			; 00001388H
	jne	SHORT $LN4@SimToggleG

; 10460: 		{
; 10461: 			//Switch it off
; 10462: 			if(SimDriver.GetPlayerAircraft()->WideView)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	movzx	edx, BYTE PTR [eax+1818]
	test	edx, edx
	je	SHORT $LN3@SimToggleG

; 10463: 				OTWDriver.pCockpitManager->SetActivePanel(91100);

	push	91100					; 000163dcH
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	call	?SetActivePanel@CockpitManager@@QAE_NH@Z ; CockpitManager::SetActivePanel

; 10464: 			else

	jmp	SHORT $LN2@SimToggleG
$LN3@SimToggleG:

; 10465: 				OTWDriver.pCockpitManager->SetActivePanel(1100);

	push	1100					; 0000044cH
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	call	?SetActivePanel@CockpitManager@@QAE_NH@Z ; CockpitManager::SetActivePanel
$LN2@SimToggleG:

; 10466: 		}
; 10467: 		else

	jmp	SHORT $LN7@SimToggleG
$LN4@SimToggleG:

; 10468: 		{
; 10469: 			//Switch it on
; 10470: 			OTWDriver.pCockpitManager->SetActivePanel(5000);

	push	5000					; 00001388H
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	call	?SetActivePanel@CockpitManager@@QAE_NH@Z ; CockpitManager::SetActivePanel
$LN7@SimToggleG:

; 10471: 		}			   
; 10472:   }
; 10473: }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimToggleGhostMFDs@@YAXKHPAX@Z ENDP			; SimToggleGhostMFDs
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_curPanel$1 = -4					; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimToggleCockpit@@YAXKHPAX@Z PROC			; SimToggleCockpit

; 10405: {

	push	ebp
	mov	ebp, esp
	push	ecx

; 10406: 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN1@SimToggleC
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN1@SimToggleC
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN1@SimToggleC

; 10407:   {
; 10408: 		CPPanel* curPanel = OTWDriver.pCockpitManager->GetActivePanel();

	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	call	?GetActivePanel@CockpitManager@@QAEPAVCPPanel@@XZ ; CockpitManager::GetActivePanel
	mov	DWORD PTR _curPanel$1[ebp], eax

; 10409: 		if(!curPanel)

	cmp	DWORD PTR _curPanel$1[ebp], 0
	jne	SHORT $LN15@SimToggleC

; 10410: 			return;

	jmp	$LN17@SimToggleC
$LN15@SimToggleC:

; 10411: 		if(curPanel->mIdNum == 5000)

	mov	ecx, DWORD PTR _curPanel$1[ebp]
	cmp	DWORD PTR [ecx+4], 5000			; 00001388H
	jne	$LN14@SimToggleC

; 10412: 		{
; 10413: 			if(SimDriver.GetPlayerAircraft()->WideView)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	movzx	edx, BYTE PTR [eax+1818]
	test	edx, edx
	je	SHORT $LN13@SimToggleC

; 10414: 			{
; 10415: 				if (OTWDriver.pCockpitManager->SetActivePanel(1100))		//Wombat778 4-13-04 Check for the presence of the panel before changing variables

	push	1100					; 0000044cH
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	call	?SetActivePanel@CockpitManager@@QAE_NH@Z ; CockpitManager::SetActivePanel
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN11@SimToggleC

; 10416: 				{
; 10417: 					SimDriver.GetPlayerAircraft()->WideView = FALSE;				

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	BYTE PTR [eax+1818], 0

; 10418: 					if (g_fWideviewFOV)						//Wombat778 2-21-04  if g_fWideviewFOV has a value, then set FOV to default when switching to normal view

	movss	xmm0, DWORD PTR ?g_fWideviewFOV@@3MA
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN11@SimToggleC

; 10419: 						OTWDriver.SetFOV(g_fDefaultFOV*DTR);

	movss	xmm0, DWORD PTR ?g_fDefaultFOV@@3MA
	mulss	xmm0, DWORD PTR __real@3c8efa34
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?SetFOV@OTWDriverClass@@QAEXM@Z		; OTWDriverClass::SetFOV
$LN11@SimToggleC:

; 10420: 				}
; 10421: 			}
; 10422: 			else

	jmp	SHORT $LN8@SimToggleC
$LN13@SimToggleC:

; 10423: 			{
; 10424: 				if (OTWDriver.pCockpitManager->SetActivePanel(91100))		//Wombat778 4-13-04 Check for the presence of the panel before changing variables

	push	91100					; 000163dcH
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	call	?SetActivePanel@CockpitManager@@QAE_NH@Z ; CockpitManager::SetActivePanel
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN8@SimToggleC

; 10425: 				{
; 10426: 					SimDriver.GetPlayerAircraft()->WideView = TRUE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	BYTE PTR [eax+1818], 1

; 10427: 					if (g_fWideviewFOV)						//Wombat778 2-21-04  if g_fWideviewFOV has a value, then set it when switching to wideview

	movss	xmm0, DWORD PTR ?g_fWideviewFOV@@3MA
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN8@SimToggleC

; 10428: 						OTWDriver.SetFOV(g_fWideviewFOV*DTR);

	movss	xmm0, DWORD PTR ?g_fWideviewFOV@@3MA
	mulss	xmm0, DWORD PTR __real@3c8efa34
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?SetFOV@OTWDriverClass@@QAEXM@Z		; OTWDriverClass::SetFOV
$LN8@SimToggleC:

; 10429: 				}
; 10430: 			}	

	jmp	$LN1@SimToggleC
$LN14@SimToggleC:

; 10431: 		}
; 10432: 		else if(SimDriver.GetPlayerAircraft()->WideView)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	movzx	edx, BYTE PTR [eax+1818]
	test	edx, edx
	je	SHORT $LN6@SimToggleC

; 10433: 		{
; 10434: 			if (OTWDriver.pCockpitManager->SetActivePanel(curPanel->mIdNum - 90000)) //Wombat778 4-13-04 Check for the presence of the panel before changing variables

	mov	eax, DWORD PTR _curPanel$1[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 90000				; 00015f90H
	push	ecx
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	call	?SetActivePanel@CockpitManager@@QAE_NH@Z ; CockpitManager::SetActivePanel
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN4@SimToggleC

; 10435: 			{
; 10436: 				SimDriver.GetPlayerAircraft()->WideView = FALSE;			

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	BYTE PTR [eax+1818], 0

; 10437: 				if (g_fWideviewFOV)						//Wombat778 2-21-04  if g_fWideviewFOV has a value, then set FOV to default when switching to normal view

	movss	xmm0, DWORD PTR ?g_fWideviewFOV@@3MA
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN4@SimToggleC

; 10438: 					OTWDriver.SetFOV(g_fDefaultFOV*DTR);

	movss	xmm0, DWORD PTR ?g_fDefaultFOV@@3MA
	mulss	xmm0, DWORD PTR __real@3c8efa34
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?SetFOV@OTWDriverClass@@QAEXM@Z		; OTWDriverClass::SetFOV
$LN4@SimToggleC:

; 10439: 			}
; 10440: 		}
; 10441: 		else

	jmp	SHORT $LN1@SimToggleC
$LN6@SimToggleC:

; 10442: 		{
; 10443: 			if (OTWDriver.pCockpitManager->SetActivePanel(curPanel->mIdNum + 90000)) //Wombat778 4-13-04 Check for the presence of the panel before changing variables

	mov	eax, DWORD PTR _curPanel$1[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 90000				; 00015f90H
	push	ecx
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	call	?SetActivePanel@CockpitManager@@QAE_NH@Z ; CockpitManager::SetActivePanel
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@SimToggleC

; 10444: 			{
; 10445: 				SimDriver.GetPlayerAircraft()->WideView = TRUE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	BYTE PTR [eax+1818], 1

; 10446: 				if (g_fWideviewFOV)						//Wombat778 2-21-04  if g_fWideviewFOV has a value, then set it when switching to wideview

	movss	xmm0, DWORD PTR ?g_fWideviewFOV@@3MA
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN1@SimToggleC

; 10447: 					OTWDriver.SetFOV(g_fWideviewFOV*DTR);

	movss	xmm0, DWORD PTR ?g_fWideviewFOV@@3MA
	mulss	xmm0, DWORD PTR __real@3c8efa34
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?SetFOV@OTWDriverClass@@QAEXM@Z		; OTWDriverClass::SetFOV
$LN1@SimToggleC:
$LN17@SimToggleC:

; 10448: 			}
; 10449: 		}			   
; 10450:   }
; 10451: }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimToggleCockpit@@YAXKHPAX@Z ENDP			; SimToggleCockpit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimSymWheelDn@@YAXKHPAX@Z PROC				; SimSymWheelDn

; 10346: {

	push	ebp
	mov	ebp, esp

; 10347: 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN7@SimSymWhee

; 10348: 		return;

	jmp	$LN8@SimSymWhee
$LN7@SimSymWhee:

; 10349: 
; 10350: 	if (IO.AnalogIsUsed(AXIS_HUD_BRIGHTNESS) == true)	// Retro 4Jan2004

	push	18					; 00000012H
	mov	ecx, OFFSET ?IO@@3VSIMLIB_IO_CLASS@@A	; IO
	call	?AnalogIsUsed@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z ; SIMLIB_IO_CLASS::AnalogIsUsed
	movzx	ecx, al
	cmp	ecx, 1
	jne	SHORT $LN6@SimSymWhee

; 10351: 		return;

	jmp	$LN8@SimSymWhee
$LN6@SimSymWhee:

; 10352: 
; 10353: 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN1@SimSymWhee
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN1@SimSymWhee
	mov	edx, DWORD PTR _state$[ebp]
	and	edx, 8
	je	$LN1@SimSymWhee

; 10354:   {
; 10355: 		if(TheHud)

	cmp	DWORD PTR ?TheHud@@3PAVHudClass@@A, 0	; TheHud
	je	$LN1@SimSymWhee

; 10356: 		{
; 10357: 			// COBRA - RED - Rewritten in a more sensate way
; 10358: 			TheHud->SymWheelPos -= 0.1F;

	mov	eax, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR [eax+5136]
	subss	xmm0, DWORD PTR __real@3dcccccd
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	DWORD PTR [ecx+5136], xmm0

; 10359: 			if(TheHud->SymWheelPos < 0.0F) TheHud->SymWheelPos=0.0f;

	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [edx+5136]
	jbe	SHORT $LN3@SimSymWhee
	mov	eax, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+5136], xmm0
$LN3@SimSymWhee:

; 10360: 			if((TheHud->SymWheelPos < 0.1F)&&(SimDriver.GetPlayerAircraft()->HasPower(AircraftClass::HUDPower)))

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR __real@3dcccccd
	comiss	xmm0, DWORD PTR [ecx+5136]
	jbe	SHORT $LN2@SimSymWhee
	push	2048					; 00000800H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::HasPower
	test	eax, eax
	je	SHORT $LN2@SimSymWhee

; 10361: 				SimDriver.GetPlayerAircraft()->PowerOff(AircraftClass::HUDPower);

	push	2048					; 00000800H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerOff@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerOff
$LN2@SimSymWhee:

; 10362: 			TheHud->SetLightLevel();

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?SetLightLevel@HudClass@@QAEXXZ		; HudClass::SetLightLevel

; 10363: 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN1@SimSymWhee

; 10364: 				//OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_ICP_SYM_WHEEL, TheHud->SymWheelPos);
; 10365: 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_ICP_SYM_WHEEL, 1<<((int)(TheHud->SymWheelPos*10.0f)));

	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR [edx+5136]
	mulss	xmm0, DWORD PTR __real@41200000
	cvttss2si ecx, xmm0
	mov	eax, 1
	shl	eax, cl
	push	eax
	push	145					; 00000091H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN1@SimSymWhee:
$LN8@SimSymWhee:

; 10366: 		}
; 10367:   }
; 10368: }

	pop	ebp
	ret	0
?SimSymWheelDn@@YAXKHPAX@Z ENDP				; SimSymWheelDn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimSymWheelUp@@YAXKHPAX@Z PROC				; SimSymWheelUp

; 10320: {

	push	ebp
	mov	ebp, esp

; 10321: 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN7@SimSymWhee

; 10322: 		return;

	jmp	$LN8@SimSymWhee
$LN7@SimSymWhee:

; 10323: 
; 10324: 	if (IO.AnalogIsUsed(AXIS_HUD_BRIGHTNESS) == true)	// Retro 4Jan2004

	push	18					; 00000012H
	mov	ecx, OFFSET ?IO@@3VSIMLIB_IO_CLASS@@A	; IO
	call	?AnalogIsUsed@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z ; SIMLIB_IO_CLASS::AnalogIsUsed
	movzx	ecx, al
	cmp	ecx, 1
	jne	SHORT $LN6@SimSymWhee

; 10325: 		return;

	jmp	$LN8@SimSymWhee
$LN6@SimSymWhee:

; 10326: 
; 10327: 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN1@SimSymWhee
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN1@SimSymWhee
	mov	edx, DWORD PTR _state$[ebp]
	and	edx, 8
	je	$LN1@SimSymWhee

; 10328:   {
; 10329: 		if(TheHud)

	cmp	DWORD PTR ?TheHud@@3PAVHudClass@@A, 0	; TheHud
	je	$LN1@SimSymWhee

; 10330: 		{
; 10331: 			// COBRA - RED - Rewritten in a more sensate way
; 10332: 			TheHud->SymWheelPos += 0.1F;

	mov	eax, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR [eax+5136]
	addss	xmm0, DWORD PTR __real@3dcccccd
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	DWORD PTR [ecx+5136], xmm0

; 10333: 			if(TheHud->SymWheelPos > 1.0F) TheHud->SymWheelPos = 1.0F;

	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR [edx+5136]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN3@SimSymWhee
	mov	eax, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+5136], xmm0
$LN3@SimSymWhee:

; 10334: 			if((TheHud->SymWheelPos >= 0.1F)&&(!SimDriver.GetPlayerAircraft()->HasPower(AircraftClass::HUDPower))){

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR [ecx+5136]
	comiss	xmm0, DWORD PTR __real@3dcccccd
	jb	SHORT $LN2@SimSymWhee
	push	2048					; 00000800H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::HasPower
	test	eax, eax
	jne	SHORT $LN2@SimSymWhee

; 10335: 				SimDriver.GetPlayerAircraft()->PowerOn(AircraftClass::HUDPower);

	push	2048					; 00000800H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerOn@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerOn
$LN2@SimSymWhee:

; 10336: 				//TheHud->SymWheelPos = 1.0F;									// COBRA - RED - Power on at MAX Value
; 10337: 			}
; 10338: 			TheHud->SetLightLevel();

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?SetLightLevel@HudClass@@QAEXXZ		; HudClass::SetLightLevel

; 10339: 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN1@SimSymWhee

; 10340: 				//OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_ICP_SYM_WHEEL, TheHud->SymWheelPos);
; 10341: 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_ICP_SYM_WHEEL, 1<<((int)(TheHud->SymWheelPos*10.0f)));

	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR [edx+5136]
	mulss	xmm0, DWORD PTR __real@41200000
	cvttss2si ecx, xmm0
	mov	eax, 1
	shl	eax, cl
	push	eax
	push	145					; 00000091H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN1@SimSymWhee:
$LN8@SimSymWhee:

; 10342: 		}
; 10343:   }
; 10344: }

	pop	ebp
	ret	0
?SimSymWheelUp@@YAXKHPAX@Z ENDP				; SimSymWheelUp
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv81 = -4						; size = 4
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?Sim3DCkptHelpOnOff@@YAXKHPAX@Z PROC			; Sim3DCkptHelpOnOff

; 10303: {

	push	ebp
	mov	ebp, esp
	push	ecx

; 10304: 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@Sim3DCkptH
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@Sim3DCkptH
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@Sim3DCkptH

; 10305: 	{
; 10306: 		g_b3DClickableCockpitDebug = !g_b3DClickableCockpitDebug;

	movzx	ecx, BYTE PTR ?g_b3DClickableCockpitDebug@@3_NA ; g_b3DClickableCockpitDebug
	test	ecx, ecx
	jne	SHORT $LN4@Sim3DCkptH
	mov	DWORD PTR tv81[ebp], 1
	jmp	SHORT $LN5@Sim3DCkptH
$LN4@Sim3DCkptH:
	mov	DWORD PTR tv81[ebp], 0
$LN5@Sim3DCkptH:
	mov	dl, BYTE PTR tv81[ebp]
	mov	BYTE PTR ?g_b3DClickableCockpitDebug@@3_NA, dl ; g_b3DClickableCockpitDebug
$LN2@Sim3DCkptH:

; 10307: 	}
; 10308: }

	mov	esp, ebp
	pop	ebp
	ret	0
?Sim3DCkptHelpOnOff@@YAXKHPAX@Z ENDP			; Sim3DCkptHelpOnOff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_vall$1 = -4						; size = 4
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimStepComm2VolumeDown@@YAXKHPAX@Z PROC		; SimStepComm2VolumeDown

; 10282: {

	push	ebp
	mov	ebp, esp
	push	ecx

; 10283: 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN1@SimStepCom
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN1@SimStepCom
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN1@SimStepCom

; 10284: 	{
; 10285: 		if(OTWDriver.pCockpitManager && OTWDriver.pCockpitManager->mpIcp)

	cmp	DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684, 0
	je	SHORT $LN4@SimStepCom
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	cmp	DWORD PTR [ecx+688], 0
	je	SHORT $LN4@SimStepCom

; 10286: 			OTWDriver.pCockpitManager->mpIcp->Comm2Volume++;

	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	eax, DWORD PTR [edx+688]
	mov	ecx, DWORD PTR [eax+1672]
	add	ecx, 1
	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	eax, DWORD PTR [edx+688]
	mov	DWORD PTR [eax+1672], ecx
$LN4@SimStepCom:

; 10287: 		if(OTWDriver.pCockpitManager->mpIcp->Comm2Volume > 8)

	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	edx, DWORD PTR [ecx+688]
	cmp	DWORD PTR [edx+1672], 8
	jle	SHORT $LN3@SimStepCom

; 10288: 			OTWDriver.pCockpitManager->mpIcp->Comm2Volume = 8;

	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [eax+688]
	mov	DWORD PTR [ecx+1672], 8
$LN3@SimStepCom:

; 10289: 
; 10290:  // MLR 1/29/2004 - 
; 10291: 		PlayerOptions.GroupVol[COM2_SOUND_GROUP] = (int)(RESCALE(OTWDriver.pCockpitManager->mpIcp->Comm2Volume,7,0,-2000,0));

	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	eax, DWORD PTR [edx+688]
	cvtsi2ss xmm0, DWORD PTR [eax+1672]
	subss	xmm0, DWORD PTR __real@40e00000
	mulss	xmm0, DWORD PTR __real@44fa0000
	divss	xmm0, DWORD PTR __real@c0e00000
	addss	xmm0, DWORD PTR __real@c4fa0000
	cvttss2si ecx, xmm0
	mov	edx, 4
	shl	edx, 2
	mov	DWORD PTR ?PlayerOptions@@3VPlayerOptionsClass@@A[edx+120], ecx

; 10292: 		if(OTWDriver.pCockpitManager->mpIcp->Comm2Volume==8) PlayerOptions.GroupVol[COM2_SOUND_GROUP]=-10000;

	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [eax+688]
	cmp	DWORD PTR [ecx+1672], 8
	jne	SHORT $LN2@SimStepCom
	mov	edx, 4
	shl	edx, 2
	mov	DWORD PTR ?PlayerOptions@@3VPlayerOptionsClass@@A[edx+120], -10000 ; ffffd8f0H
$LN2@SimStepCom:

; 10293: 		SetVoiceVolume(1);

	push	1
	call	?SetVoiceVolume@@YAXH@Z			; SetVoiceVolume
	add	esp, 4

; 10294: 		DirectVoiceSetVolume(1);

	push	1
	call	?DirectVoiceSetVolume@@YAXH@Z		; DirectVoiceSetVolume
	add	esp, 4

; 10295: 		//int vall = 9 - OTWDriver.pCockpitManager->mpIcp->Comm2Volume;
; 10296: 		int vall = 1<<(8 - OTWDriver.pCockpitManager->mpIcp->Comm2Volume);

	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [eax+688]
	mov	edx, 8
	sub	edx, DWORD PTR [ecx+1672]
	mov	eax, 1
	mov	ecx, edx
	shl	eax, cl
	mov	DWORD PTR _vall$1[ebp], eax

; 10297: 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN1@SimStepCom

; 10298: 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_COMM2_VOL, vall);

	mov	ecx, DWORD PTR _vall$1[ebp]
	push	ecx
	push	170					; 000000aaH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN1@SimStepCom:

; 10299: 	}
; 10300: }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimStepComm2VolumeDown@@YAXKHPAX@Z ENDP		; SimStepComm2VolumeDown
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_vall$1 = -4						; size = 4
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimStepComm2VolumeUp@@YAXKHPAX@Z PROC			; SimStepComm2VolumeUp

; 10262: {

	push	ebp
	mov	ebp, esp
	push	ecx

; 10263: 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN1@SimStepCom
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN1@SimStepCom
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN1@SimStepCom

; 10264: 	{
; 10265: 		if(OTWDriver.pCockpitManager && OTWDriver.pCockpitManager->mpIcp)

	cmp	DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684, 0
	je	SHORT $LN4@SimStepCom
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	cmp	DWORD PTR [ecx+688], 0
	je	SHORT $LN4@SimStepCom

; 10266: 			OTWDriver.pCockpitManager->mpIcp->Comm2Volume--;

	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	eax, DWORD PTR [edx+688]
	mov	ecx, DWORD PTR [eax+1672]
	sub	ecx, 1
	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	eax, DWORD PTR [edx+688]
	mov	DWORD PTR [eax+1672], ecx
$LN4@SimStepCom:

; 10267: 		if(OTWDriver.pCockpitManager->mpIcp->Comm2Volume < 0)

	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	edx, DWORD PTR [ecx+688]
	cmp	DWORD PTR [edx+1672], 0
	jge	SHORT $LN3@SimStepCom

; 10268: 			OTWDriver.pCockpitManager->mpIcp->Comm2Volume = 0;

	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [eax+688]
	mov	DWORD PTR [ecx+1672], 0
$LN3@SimStepCom:

; 10269: 		
; 10270:  // MLR 1/29/2004 - 
; 10271: 		PlayerOptions.GroupVol[COM2_SOUND_GROUP] = (int)(RESCALE(OTWDriver.pCockpitManager->mpIcp->Comm2Volume,7,0,-2000,0));

	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	eax, DWORD PTR [edx+688]
	cvtsi2ss xmm0, DWORD PTR [eax+1672]
	subss	xmm0, DWORD PTR __real@40e00000
	mulss	xmm0, DWORD PTR __real@44fa0000
	divss	xmm0, DWORD PTR __real@c0e00000
	addss	xmm0, DWORD PTR __real@c4fa0000
	cvttss2si ecx, xmm0
	mov	edx, 4
	shl	edx, 2
	mov	DWORD PTR ?PlayerOptions@@3VPlayerOptionsClass@@A[edx+120], ecx

; 10272: 		if(OTWDriver.pCockpitManager->mpIcp->Comm2Volume==8) PlayerOptions.GroupVol[COM2_SOUND_GROUP]=-10000;

	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [eax+688]
	cmp	DWORD PTR [ecx+1672], 8
	jne	SHORT $LN2@SimStepCom
	mov	edx, 4
	shl	edx, 2
	mov	DWORD PTR ?PlayerOptions@@3VPlayerOptionsClass@@A[edx+120], -10000 ; ffffd8f0H
$LN2@SimStepCom:

; 10273: 		SetVoiceVolume(1);

	push	1
	call	?SetVoiceVolume@@YAXH@Z			; SetVoiceVolume
	add	esp, 4

; 10274: 		DirectVoiceSetVolume(1);

	push	1
	call	?DirectVoiceSetVolume@@YAXH@Z		; DirectVoiceSetVolume
	add	esp, 4

; 10275: 		//int vall = 9 - OTWDriver.pCockpitManager->mpIcp->Comm2Volume;
; 10276: 		int vall = 1<<(8 - OTWDriver.pCockpitManager->mpIcp->Comm2Volume);

	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [eax+688]
	mov	edx, 8
	sub	edx, DWORD PTR [ecx+1672]
	mov	eax, 1
	mov	ecx, edx
	shl	eax, cl
	mov	DWORD PTR _vall$1[ebp], eax

; 10277: 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN1@SimStepCom

; 10278: 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_COMM2_VOL, vall);

	mov	ecx, DWORD PTR _vall$1[ebp]
	push	ecx
	push	170					; 000000aaH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN1@SimStepCom:

; 10279: 	}
; 10280: }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimStepComm2VolumeUp@@YAXKHPAX@Z ENDP			; SimStepComm2VolumeUp
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_vall$1 = -4						; size = 4
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimStepComm1VolumeDown@@YAXKHPAX@Z PROC		; SimStepComm1VolumeDown

; 10243: {

	push	ebp
	mov	ebp, esp
	push	ecx

; 10244: 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN1@SimStepCom
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN1@SimStepCom
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN1@SimStepCom

; 10245: 	{
; 10246: 		if(OTWDriver.pCockpitManager && OTWDriver.pCockpitManager->mpIcp)

	cmp	DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684, 0
	je	SHORT $LN4@SimStepCom
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	cmp	DWORD PTR [ecx+688], 0
	je	SHORT $LN4@SimStepCom

; 10247: 			OTWDriver.pCockpitManager->mpIcp->Comm1Volume++;

	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	eax, DWORD PTR [edx+688]
	mov	ecx, DWORD PTR [eax+1668]
	add	ecx, 1
	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	eax, DWORD PTR [edx+688]
	mov	DWORD PTR [eax+1668], ecx
$LN4@SimStepCom:

; 10248: 		if(OTWDriver.pCockpitManager->mpIcp->Comm1Volume > 8)

	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	edx, DWORD PTR [ecx+688]
	cmp	DWORD PTR [edx+1668], 8
	jle	SHORT $LN3@SimStepCom

; 10249: 			OTWDriver.pCockpitManager->mpIcp->Comm1Volume = 8;

	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [eax+688]
	mov	DWORD PTR [ecx+1668], 8
$LN3@SimStepCom:

; 10250:  // MLR 1/29/2004 - 
; 10251: 		PlayerOptions.GroupVol[COM1_SOUND_GROUP] = (int)(RESCALE(OTWDriver.pCockpitManager->mpIcp->Comm1Volume,7,0,-2000,0));

	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	eax, DWORD PTR [edx+688]
	cvtsi2ss xmm0, DWORD PTR [eax+1668]
	subss	xmm0, DWORD PTR __real@40e00000
	mulss	xmm0, DWORD PTR __real@44fa0000
	divss	xmm0, DWORD PTR __real@c0e00000
	addss	xmm0, DWORD PTR __real@c4fa0000
	cvttss2si ecx, xmm0
	mov	edx, 4
	imul	edx, 3
	mov	DWORD PTR ?PlayerOptions@@3VPlayerOptionsClass@@A[edx+120], ecx

; 10252: 		if(OTWDriver.pCockpitManager->mpIcp->Comm1Volume==8) PlayerOptions.GroupVol[COM1_SOUND_GROUP]=-10000;

	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [eax+688]
	cmp	DWORD PTR [ecx+1668], 8
	jne	SHORT $LN2@SimStepCom
	mov	edx, 4
	imul	edx, 3
	mov	DWORD PTR ?PlayerOptions@@3VPlayerOptionsClass@@A[edx+120], -10000 ; ffffd8f0H
$LN2@SimStepCom:

; 10253: 		SetVoiceVolume(0);

	push	0
	call	?SetVoiceVolume@@YAXH@Z			; SetVoiceVolume
	add	esp, 4

; 10254: 		DirectVoiceSetVolume(0);

	push	0
	call	?DirectVoiceSetVolume@@YAXH@Z		; DirectVoiceSetVolume
	add	esp, 4

; 10255: 		//int vall = 9 - OTWDriver.pCockpitManager->mpIcp->Comm1Volume;
; 10256: 		int vall = 1<<(8 - OTWDriver.pCockpitManager->mpIcp->Comm1Volume);

	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [eax+688]
	mov	edx, 8
	sub	edx, DWORD PTR [ecx+1668]
	mov	eax, 1
	mov	ecx, edx
	shl	eax, cl
	mov	DWORD PTR _vall$1[ebp], eax

; 10257: 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN1@SimStepCom

; 10258: 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_COMM1_VOL, vall);

	mov	ecx, DWORD PTR _vall$1[ebp]
	push	ecx
	push	169					; 000000a9H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN1@SimStepCom:

; 10259: 	}
; 10260: }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimStepComm1VolumeDown@@YAXKHPAX@Z ENDP		; SimStepComm1VolumeDown
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_vall$1 = -4						; size = 4
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimStepComm1VolumeUp@@YAXKHPAX@Z PROC			; SimStepComm1VolumeUp

; 10224: {

	push	ebp
	mov	ebp, esp
	push	ecx

; 10225: 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN1@SimStepCom
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN1@SimStepCom
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN1@SimStepCom

; 10226: 	{
; 10227: 		if(OTWDriver.pCockpitManager && OTWDriver.pCockpitManager->mpIcp)

	cmp	DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684, 0
	je	SHORT $LN4@SimStepCom
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	cmp	DWORD PTR [ecx+688], 0
	je	SHORT $LN4@SimStepCom

; 10228: 			OTWDriver.pCockpitManager->mpIcp->Comm1Volume--;

	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	eax, DWORD PTR [edx+688]
	mov	ecx, DWORD PTR [eax+1668]
	sub	ecx, 1
	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	eax, DWORD PTR [edx+688]
	mov	DWORD PTR [eax+1668], ecx
$LN4@SimStepCom:

; 10229: 		if(OTWDriver.pCockpitManager->mpIcp->Comm1Volume < 0)

	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	edx, DWORD PTR [ecx+688]
	cmp	DWORD PTR [edx+1668], 0
	jge	SHORT $LN3@SimStepCom

; 10230: 			OTWDriver.pCockpitManager->mpIcp->Comm1Volume = 0;

	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [eax+688]
	mov	DWORD PTR [ecx+1668], 0
$LN3@SimStepCom:

; 10231:  // MLR 1/29/2004 - 
; 10232: 		PlayerOptions.GroupVol[COM1_SOUND_GROUP] = (int)(RESCALE(OTWDriver.pCockpitManager->mpIcp->Comm1Volume,7,0,-2000,0));

	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	eax, DWORD PTR [edx+688]
	cvtsi2ss xmm0, DWORD PTR [eax+1668]
	subss	xmm0, DWORD PTR __real@40e00000
	mulss	xmm0, DWORD PTR __real@44fa0000
	divss	xmm0, DWORD PTR __real@c0e00000
	addss	xmm0, DWORD PTR __real@c4fa0000
	cvttss2si ecx, xmm0
	mov	edx, 4
	imul	edx, 3
	mov	DWORD PTR ?PlayerOptions@@3VPlayerOptionsClass@@A[edx+120], ecx

; 10233: 		if(OTWDriver.pCockpitManager->mpIcp->Comm1Volume==8) PlayerOptions.GroupVol[COM1_SOUND_GROUP]=-10000;

	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [eax+688]
	cmp	DWORD PTR [ecx+1668], 8
	jne	SHORT $LN2@SimStepCom
	mov	edx, 4
	imul	edx, 3
	mov	DWORD PTR ?PlayerOptions@@3VPlayerOptionsClass@@A[edx+120], -10000 ; ffffd8f0H
$LN2@SimStepCom:

; 10234: 		SetVoiceVolume(0);

	push	0
	call	?SetVoiceVolume@@YAXH@Z			; SetVoiceVolume
	add	esp, 4

; 10235: 		DirectVoiceSetVolume(0);

	push	0
	call	?DirectVoiceSetVolume@@YAXH@Z		; DirectVoiceSetVolume
	add	esp, 4

; 10236: 		//int vall = 9 - OTWDriver.pCockpitManager->mpIcp->Comm1Volume;
; 10237: 		int vall = 1<<(8 - OTWDriver.pCockpitManager->mpIcp->Comm1Volume);

	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [eax+688]
	mov	edx, 8
	sub	edx, DWORD PTR [ecx+1668]
	mov	eax, 1
	mov	ecx, edx
	shl	eax, cl
	mov	DWORD PTR _vall$1[ebp], eax

; 10238: 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN1@SimStepCom

; 10239: 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_COMM1_VOL, vall);

	mov	ecx, DWORD PTR _vall$1[ebp]
	push	ecx
	push	169					; 000000a9H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN1@SimStepCom:

; 10240: 	}
; 10241: }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimStepComm1VolumeUp@@YAXKHPAX@Z ENDP			; SimStepComm1VolumeUp
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimCursorEnable@@YAXKHPAX@Z PROC			; SimCursorEnable

; 10192: {

	push	ebp
	mov	ebp, esp

; 10193: 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN8@SimCursorE

; 10194: 		return;

	jmp	$LN9@SimCursorE
$LN8@SimCursorE:

; 10195: 
; 10196: 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN9@SimCursorE
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN9@SimCursorE
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	$LN9@SimCursorE

; 10197:     {
; 10198: 		if(SimDriver.GetPlayerAircraft()->Sms)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+940], 0
	je	$LN9@SimCursorE

; 10199: 		{
; 10200: 			if(SimDriver.GetPlayerAircraft()->Sms->curWeaponType == wtAgm65 && SimDriver.GetPlayerAircraft()->Sms->curWeapon)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+940]
	cmp	DWORD PTR [edx+148], 4
	jne	SHORT $LN5@SimCursorE
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+940]
	add	ecx, 164				; 000000a4H
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@SimCursorE

; 10201: 				SimDriver.GetPlayerAircraft()->Sms->StepMavSubMode();

	push	0
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+940]
	call	?StepMavSubMode@SMSBaseClass@@QAEX_N@Z	; SMSBaseClass::StepMavSubMode
	jmp	SHORT $LN9@SimCursorE
$LN5@SimCursorE:

; 10202: 			else if(SimDriver.GetPlayerAircraft()->Sms->curWeaponType == wtAim9 || SimDriver.GetPlayerAircraft()->Sms->curWeaponType == wtAim120)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+940]
	cmp	DWORD PTR [ecx+148], 1
	je	SHORT $LN2@SimCursorE
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+940]
	cmp	DWORD PTR [edx+148], 2
	jne	SHORT $LN9@SimCursorE
$LN2@SimCursorE:

; 10203: 			{
; 10204: 				if(SimDriver.GetPlayerAircraft()->FCC)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+936], 0
	je	SHORT $LN9@SimCursorE

; 10205: 					SimDriver.GetPlayerAircraft()->FCC->missileSlaveCmd = TRUE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	eax, DWORD PTR [eax+936]
	mov	BYTE PTR [eax+189], 1
$LN9@SimCursorE:

; 10206: 			}
; 10207: 		}		
; 10208: 	}
; 10209: }

	pop	ebp
	ret	0
?SimCursorEnable@@YAXKHPAX@Z ENDP			; SimCursorEnable
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimRetDn@@YAXKHPAX@Z PROC				; SimRetDn

; 10173: {

	push	ebp
	mov	ebp, esp

; 10174: 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN5@SimRetDn

; 10175: 		return;

	jmp	$LN6@SimRetDn
$LN5@SimRetDn:

; 10176: 
; 10177: 	if (IO.AnalogIsUsed(AXIS_RET_DEPR) == false)	// Retro 3Jan2004

	push	19					; 00000013H
	mov	ecx, OFFSET ?IO@@3VSIMLIB_IO_CLASS@@A	; IO
	call	?AnalogIsUsed@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z ; SIMLIB_IO_CLASS::AnalogIsUsed
	movzx	ecx, al
	test	ecx, ecx
	jne	$LN6@SimRetDn

; 10178: 	{
; 10179: 		if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN6@SimRetDn
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN6@SimRetDn
	mov	edx, DWORD PTR _state$[ebp]
	and	edx, 8
	je	SHORT $LN6@SimRetDn

; 10180: 		{
; 10181: 			if(TheHud)

	cmp	DWORD PTR ?TheHud@@3PAVHudClass@@A, 0	; TheHud
	je	SHORT $LN6@SimRetDn

; 10182: 			{
; 10183: 				TheHud->RetPos +=1;

	mov	eax, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	ecx, DWORD PTR [eax+5124]
	add	ecx, 1
	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	DWORD PTR [edx+5124], ecx

; 10184: 				TheHud->MoveRetCenter();

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?MoveRetCenter@HudClass@@QAEXXZ		; HudClass::MoveRetCenter

; 10185: 				if(TheHud->ReticlePosition < 0)

	mov	eax, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	cmp	DWORD PTR [eax+5128], 0
	jge	SHORT $LN6@SimRetDn

; 10186: 					TheHud->ReticlePosition++;

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	edx, DWORD PTR [ecx+5128]
	add	edx, 1
	mov	eax, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	DWORD PTR [eax+5128], edx
$LN6@SimRetDn:

; 10187: 			}
; 10188: 		}
; 10189: 	}		// Retro 3Jan2004
; 10190: }

	pop	ebp
	ret	0
?SimRetDn@@YAXKHPAX@Z ENDP				; SimRetDn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimRetUp@@YAXKHPAX@Z PROC				; SimRetUp

; 10154: {

	push	ebp
	mov	ebp, esp

; 10155: 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN5@SimRetUp

; 10156: 		return;

	jmp	$LN6@SimRetUp
$LN5@SimRetUp:

; 10157: 
; 10158: 	if (IO.AnalogIsUsed(AXIS_RET_DEPR) == false)	// Retro 3Jan2004

	push	19					; 00000013H
	mov	ecx, OFFSET ?IO@@3VSIMLIB_IO_CLASS@@A	; IO
	call	?AnalogIsUsed@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z ; SIMLIB_IO_CLASS::AnalogIsUsed
	movzx	ecx, al
	test	ecx, ecx
	jne	$LN6@SimRetUp

; 10159: 	{
; 10160: 		if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN6@SimRetUp
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN6@SimRetUp
	mov	edx, DWORD PTR _state$[ebp]
	and	edx, 8
	je	SHORT $LN6@SimRetUp

; 10161: 		{
; 10162: 			if(TheHud)

	cmp	DWORD PTR ?TheHud@@3PAVHudClass@@A, 0	; TheHud
	je	SHORT $LN6@SimRetUp

; 10163: 			{
; 10164: 				TheHud->RetPos -= 1;

	mov	eax, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	ecx, DWORD PTR [eax+5124]
	sub	ecx, 1
	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	DWORD PTR [edx+5124], ecx

; 10165: 				TheHud->MoveRetCenter();

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?MoveRetCenter@HudClass@@QAEXXZ		; HudClass::MoveRetCenter

; 10166: 				if(TheHud->ReticlePosition > -12)

	mov	eax, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	cmp	DWORD PTR [eax+5128], -12		; fffffff4H
	jle	SHORT $LN6@SimRetUp

; 10167: 					TheHud->ReticlePosition--;

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	edx, DWORD PTR [ecx+5128]
	sub	edx, 1
	mov	eax, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	DWORD PTR [eax+5128], edx
$LN6@SimRetUp:

; 10168: 			}
; 10169: 		}
; 10170: 	}		// Retro 3Jan2004
; 10171: }

	pop	ebp
	ret	0
?SimRetUp@@YAXKHPAX@Z ENDP				; SimRetUp
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_laserPod$1 = -4					; size = 4
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimTriggerSecondDetent@@YAXKHPAX@Z PROC		; SimTriggerSecondDetent

; 9987 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 9988 : 	//if we push this one, we must have pushed the first stage as well
; 9989 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN13@SimTrigger

; 9990 : 		return;

	jmp	$LN14@SimTrigger
$LN13@SimTrigger:

; 9991 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN14@SimTrigger
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN14@SimTrigger

; 9992 : 	{
; 9993 : 		LaserPodClass* laserPod = (LaserPodClass* )FindLaserPod (SimDriver.GetPlayerAircraft());

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindLaserPod@@YAPAVSensorClass@@PAVSimMoverClass@@@Z ; FindLaserPod
	add	esp, 4
	mov	DWORD PTR _laserPod$1[ebp], eax

; 9994 : 		if(state & KEY_DOWN)

	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	$LN11@SimTrigger

; 9995 : 		{
; 9996 : 			//First, check for AVTR. The 30 seconds start when we release the trigger completely.
; 9997 : 			 if(SimDriver.GetPlayerAircraft()->AVTRState(AircraftClass::AVTRStateFlags::AVTR_AUTO))

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?AVTRState@AircraftClass@@QAEHW4AVTRStateFlags@1@@Z ; AircraftClass::AVTRState
	test	eax, eax
	je	SHORT $LN10@SimTrigger

; 9998 : 			 {
; 9999 : 				 if(SimDriver.GetPlayerAircraft()->Sms && SimDriver.GetPlayerAircraft()->Sms->MasterArm() ==
; 10000: 					 SMSBaseClass::Safe)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+940], 0
	je	SHORT $LN9@SimTrigger
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+940]
	call	?MasterArm@SMSBaseClass@@QAE?AW4MasterArmState@1@XZ ; SMSBaseClass::MasterArm
	test	eax, eax
	jne	SHORT $LN9@SimTrigger

; 10001: 					 return;

	jmp	$LN14@SimTrigger
$LN9@SimTrigger:

; 10002: 
; 10003: 				 if(SimDriver.AVTROn() == FALSE)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?AVTROn@SimulationDriver@@QAEHXZ	; SimulationDriver::AVTROn
	test	eax, eax
	jne	SHORT $LN8@SimTrigger

; 10004: 				 {
; 10005: 					 SimDriver.SetAVTR(TRUE);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?SetAVTR@SimulationDriver@@QAEXH@Z	; SimulationDriver::SetAVTR

; 10006: 					 SimDriver.GetPlayerAircraft()->AddAVTRSeconds();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?AddAVTRSeconds@AircraftClass@@QAEXXZ	; AircraftClass::AddAVTRSeconds

; 10007: 					 ACMIToggleRecording(0, state, NULL);

	push	0
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	push	0
	call	?ACMIToggleRecording@@YAXKHPAX@Z	; ACMIToggleRecording
	add	esp, 12					; 0000000cH

; 10008: 				 }
; 10009: 				 else

	jmp	SHORT $LN10@SimTrigger
$LN8@SimTrigger:

; 10010: 					 SimDriver.GetPlayerAircraft()->AddAVTRSeconds();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?AddAVTRSeconds@AircraftClass@@QAEXXZ	; AircraftClass::AddAVTRSeconds
$LN10@SimTrigger:

; 10011: 			 }
; 10012: 			//Gun
; 10013: 			if(SimDriver.GetPlayerAircraft()->FCC &&
; 10014: 				(SimDriver.GetPlayerAircraft()->FCC->GetMasterMode() == FireControlComputer::Dogfight ||
; 10015: 				SimDriver.GetPlayerAircraft()->FCC->GetMasterMode() == FireControlComputer::MissileOverride || 
; 10016: 				SimDriver.GetPlayerAircraft()->FCC->GetSubMode() == FireControlComputer::STRAF || 
; 10017: 				SimDriver.GetPlayerAircraft()->Sms->curWeaponType == wtGuns))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+936], 0
	je	SHORT $LN6@SimTrigger
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 9
	je	SHORT $LN5@SimTrigger
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN5@SimTrigger
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?GetSubMode@FireControlComputer@@QAE?AW4FCCSubMode@1@XZ ; FireControlComputer::GetSubMode
	cmp	eax, 12					; 0000000cH
	je	SHORT $LN5@SimTrigger
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	eax, DWORD PTR [eax+940]
	cmp	DWORD PTR [eax+148], 0
	jne	SHORT $LN6@SimTrigger
$LN5@SimTrigger:

; 10018: 			{
; 10019: 				SimDriver.GetPlayerAircraft()->GunFire = TRUE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	BYTE PTR [eax+884], 1
$LN6@SimTrigger:

; 10020: 			}
; 10021: 			//Targeting Pod, Fire laser
; 10022: 			if(laserPod && SimDriver.GetPlayerAircraft()->FCC->LaserArm && SimDriver.GetPlayerAircraft()->FCC->GetMasterMode()
; 10023: 				== FireControlComputer::AirGroundLaser)

	cmp	DWORD PTR _laserPod$1[ebp], 0
	je	$LN4@SimTrigger
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	movzx	edx, BYTE PTR [ecx+420]
	test	edx, edx
	je	SHORT $LN4@SimTrigger
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 8
	jne	SHORT $LN4@SimTrigger

; 10024: 			{
; 10025: 				if(!SimDriver.GetPlayerAircraft()->FCC->InhibitFire)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	eax, DWORD PTR [eax+936]
	movzx	ecx, BYTE PTR [eax+425]
	test	ecx, ecx
	jne	SHORT $LN4@SimTrigger

; 10026: 				{
; 10027: 					if(SimDriver.GetPlayerAircraft()->HasPower(AircraftClass::RightHptPower))

	push	256					; 00000100H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::HasPower
	test	eax, eax
	je	SHORT $LN4@SimTrigger

; 10028: 					{
; 10029: 						SimDriver.GetPlayerAircraft()->FCC->ManualFire = TRUE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+936]
	mov	BYTE PTR [edx+424], 1

; 10030: 						SimDriver.GetPlayerAircraft()->FCC->CheckForLaserFire = FALSE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	eax, DWORD PTR [eax+936]
	mov	BYTE PTR [eax+422], 0
$LN4@SimTrigger:

; 10031: 					}
; 10032: 				}
; 10033: 			}
; 10034: 		}
; 10035: 		else

	jmp	SHORT $LN14@SimTrigger
$LN11@SimTrigger:

; 10036: 		{
; 10037: 			SimDriver.GetPlayerAircraft()->GunFire = FALSE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	BYTE PTR [eax+884], 0

; 10038: 			SimDriver.GetPlayerAircraft()->FCC->ManualFire = TRUE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	mov	BYTE PTR [ecx+424], 1

; 10039: 			SimDriver.GetPlayerAircraft()->FCC->CheckForLaserFire = FALSE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+936]
	mov	BYTE PTR [edx+422], 0
$LN14@SimTrigger:

; 10040: 		}
; 10041: 		
; 10042: 	}
; 10043: }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimTriggerSecondDetent@@YAXKHPAX@Z ENDP		; SimTriggerSecondDetent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_laserPod$1 = -4					; size = 4
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimTriggerFirstDetent@@YAXKHPAX@Z PROC			; SimTriggerFirstDetent

; 9941 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 9942 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN11@SimTrigger

; 9943 : 		return;

	jmp	$LN12@SimTrigger
$LN11@SimTrigger:

; 9944 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN12@SimTrigger
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN12@SimTrigger

; 9945 : 	{
; 9946 : 		LaserPodClass* laserPod = (LaserPodClass* )FindLaserPod (SimDriver.GetPlayerAircraft());

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindLaserPod@@YAPAVSensorClass@@PAVSimMoverClass@@@Z ; FindLaserPod
	add	esp, 4
	mov	DWORD PTR _laserPod$1[ebp], eax

; 9947 : 		if(state & KEY_DOWN)

	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	$LN9@SimTrigger

; 9948 : 		{
; 9949 : 			//AVTR
; 9950 : 			if(SimDriver.GetPlayerAircraft()->AVTRState(AircraftClass::AVTRStateFlags::AVTR_AUTO))

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?AVTRState@AircraftClass@@QAEHW4AVTRStateFlags@1@@Z ; AircraftClass::AVTRState
	test	eax, eax
	je	SHORT $LN8@SimTrigger

; 9951 : 			{
; 9952 : 				if(SimDriver.GetPlayerAircraft()->Sms && SimDriver.GetPlayerAircraft()->Sms->MasterArm() ==
; 9953 : 					SMSBaseClass::Safe)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+940], 0
	je	SHORT $LN7@SimTrigger
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+940]
	call	?MasterArm@SMSBaseClass@@QAE?AW4MasterArmState@1@XZ ; SMSBaseClass::MasterArm
	test	eax, eax
	jne	SHORT $LN7@SimTrigger

; 9954 : 					return;

	jmp	$LN12@SimTrigger
$LN7@SimTrigger:

; 9955 : 
; 9956 : 				if(SimDriver.AVTROn() == FALSE)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?AVTROn@SimulationDriver@@QAEHXZ	; SimulationDriver::AVTROn
	test	eax, eax
	jne	SHORT $LN6@SimTrigger

; 9957 : 				{
; 9958 : 					SimDriver.SetAVTR(TRUE);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?SetAVTR@SimulationDriver@@QAEXH@Z	; SimulationDriver::SetAVTR

; 9959 : 					SimDriver.GetPlayerAircraft()->AddAVTRSeconds();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?AddAVTRSeconds@AircraftClass@@QAEXXZ	; AircraftClass::AddAVTRSeconds

; 9960 : 					ACMIToggleRecording(0, state, NULL);

	push	0
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	push	0
	call	?ACMIToggleRecording@@YAXKHPAX@Z	; ACMIToggleRecording
	add	esp, 12					; 0000000cH

; 9961 : 				}
; 9962 : 				else

	jmp	SHORT $LN8@SimTrigger
$LN6@SimTrigger:

; 9963 : 					SimDriver.GetPlayerAircraft()->AddAVTRSeconds();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?AddAVTRSeconds@AircraftClass@@QAEXXZ	; AircraftClass::AddAVTRSeconds
$LN8@SimTrigger:

; 9964 : 			}
; 9965 : 			//Targeting Pod, Fire laser
; 9966 : 			if(laserPod && SimDriver.GetPlayerAircraft()->FCC->LaserArm && SimDriver.GetPlayerAircraft()->FCC->GetMasterMode()
; 9967 : 				== FireControlComputer::AirGroundLaser)

	cmp	DWORD PTR _laserPod$1[ebp], 0
	je	$LN4@SimTrigger
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	eax, DWORD PTR [eax+936]
	movzx	ecx, BYTE PTR [eax+420]
	test	ecx, ecx
	je	SHORT $LN4@SimTrigger
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 8
	jne	SHORT $LN4@SimTrigger

; 9968 : 			{
; 9969 : 				if(!SimDriver.GetPlayerAircraft()->FCC->InhibitFire)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+936]
	movzx	eax, BYTE PTR [edx+425]
	test	eax, eax
	jne	SHORT $LN4@SimTrigger

; 9970 : 				{
; 9971 : 					if(SimDriver.GetPlayerAircraft()->HasPower(AircraftClass::RightHptPower))

	push	256					; 00000100H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::HasPower
	test	eax, eax
	je	SHORT $LN4@SimTrigger

; 9972 : 					{
; 9973 : 						SimDriver.GetPlayerAircraft()->FCC->ManualFire = TRUE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	mov	BYTE PTR [ecx+424], 1

; 9974 : 						SimDriver.GetPlayerAircraft()->FCC->CheckForLaserFire = FALSE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+936]
	mov	BYTE PTR [edx+422], 0
$LN4@SimTrigger:

; 9975 : 					}
; 9976 : 				}
; 9977 : 			}
; 9978 : 		}
; 9979 : 		else

	jmp	SHORT $LN12@SimTrigger
$LN9@SimTrigger:

; 9980 : 		{
; 9981 : 			SimDriver.GetPlayerAircraft()->FCC->ManualFire = FALSE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	eax, DWORD PTR [eax+936]
	mov	BYTE PTR [eax+424], 0

; 9982 : 			SimDriver.GetPlayerAircraft()->FCC->CheckForLaserFire = FALSE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	mov	BYTE PTR [ecx+422], 0
$LN12@SimTrigger:

; 9983 : 		}
; 9984 : 	}
; 9985 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimTriggerFirstDetent@@YAXKHPAX@Z ENDP			; SimTriggerFirstDetent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_vall$1 = -8						; size = 4
tv89 = -4						; size = 4
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimStepThreatVolumeUp@@YAXKHPAX@Z PROC			; SimStepThreatVolumeUp

; 9922 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 9923 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN5@SimStepThr

; 9924 : 		return;

	jmp	$LN6@SimStepThr
$LN5@SimStepThr:

; 9925 : 
; 9926 : 	if (IO.AnalogIsUsed(AXIS_THREAT_VOLUME) == false)	// Retro 3Jan2004

	push	17					; 00000011H
	mov	ecx, OFFSET ?IO@@3VSIMLIB_IO_CLASS@@A	; IO
	call	?AnalogIsUsed@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z ; SIMLIB_IO_CLASS::AnalogIsUsed
	movzx	ecx, al
	test	ecx, ecx
	jne	$LN6@SimStepThr

; 9927 : 	{
; 9928 : 		if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN6@SimStepThr
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN6@SimStepThr
	mov	edx, DWORD PTR _state$[ebp]
	and	edx, 8
	je	$LN6@SimStepThr

; 9929 : 		{
; 9930 : 			SimDriver.GetPlayerAircraft()->ThreatVolume--;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	add	eax, 880				; 00000370H
	mov	DWORD PTR tv89[ebp], eax
	mov	eax, DWORD PTR tv89[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	edx, DWORD PTR tv89[ebp]
	mov	DWORD PTR [edx], ecx

; 9931 : 			if(SimDriver.GetPlayerAircraft()->ThreatVolume < 0)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+880], 0
	jge	SHORT $LN2@SimStepThr

; 9932 : 				SimDriver.GetPlayerAircraft()->ThreatVolume = 0;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR [eax+880], 0
$LN2@SimStepThr:

; 9933 : 			//int vall = 9 - SimDriver.GetPlayerAircraft()->MissileVolume;
; 9934 : 			int vall = 1<<(8 - SimDriver.GetPlayerAircraft()->ThreatVolume);

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, 8
	sub	ecx, DWORD PTR [eax+880]
	mov	eax, 1
	shl	eax, cl
	mov	DWORD PTR _vall$1[ebp], eax

; 9935 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN6@SimStepThr

; 9936 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_THREAT_VOL, vall);

	mov	ecx, DWORD PTR _vall$1[ebp]
	push	ecx
	push	172					; 000000acH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN6@SimStepThr:

; 9937 : 		}
; 9938 : 	}	// Retro 3Jan2004
; 9939 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimStepThreatVolumeUp@@YAXKHPAX@Z ENDP			; SimStepThreatVolumeUp
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_vall$1 = -8						; size = 4
tv89 = -4						; size = 4
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimStepThreatVolumeDown@@YAXKHPAX@Z PROC		; SimStepThreatVolumeDown

; 9903 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 9904 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN5@SimStepThr

; 9905 : 		return;

	jmp	$LN6@SimStepThr
$LN5@SimStepThr:

; 9906 : 
; 9907 : 	if (IO.AnalogIsUsed(AXIS_THREAT_VOLUME) == false)	// Retro 3Jan2004

	push	17					; 00000011H
	mov	ecx, OFFSET ?IO@@3VSIMLIB_IO_CLASS@@A	; IO
	call	?AnalogIsUsed@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z ; SIMLIB_IO_CLASS::AnalogIsUsed
	movzx	ecx, al
	test	ecx, ecx
	jne	$LN6@SimStepThr

; 9908 : 	{
; 9909 : 		if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN6@SimStepThr
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN6@SimStepThr
	mov	edx, DWORD PTR _state$[ebp]
	and	edx, 8
	je	$LN6@SimStepThr

; 9910 : 		{
; 9911 : 			SimDriver.GetPlayerAircraft()->ThreatVolume++;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	add	eax, 880				; 00000370H
	mov	DWORD PTR tv89[ebp], eax
	mov	eax, DWORD PTR tv89[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR tv89[ebp]
	mov	DWORD PTR [edx], ecx

; 9912 : 			if(SimDriver.GetPlayerAircraft()->ThreatVolume > 8)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+880], 8
	jle	SHORT $LN2@SimStepThr

; 9913 : 				SimDriver.GetPlayerAircraft()->ThreatVolume = 8;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR [eax+880], 8
$LN2@SimStepThr:

; 9914 : 			//int vall = 9 - SimDriver.GetPlayerAircraft()->MissileVolume;
; 9915 : 			int vall = 1<<(8 - SimDriver.GetPlayerAircraft()->ThreatVolume);

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, 8
	sub	ecx, DWORD PTR [eax+880]
	mov	eax, 1
	shl	eax, cl
	mov	DWORD PTR _vall$1[ebp], eax

; 9916 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN6@SimStepThr

; 9917 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_THREAT_VOL, vall);

	mov	ecx, DWORD PTR _vall$1[ebp]
	push	ecx
	push	172					; 000000acH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN6@SimStepThr:

; 9918 : 		}
; 9919 : 	}	// Retro 3Jan2004
; 9920 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimStepThreatVolumeDown@@YAXKHPAX@Z ENDP		; SimStepThreatVolumeDown
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_vall$1 = -8						; size = 4
tv89 = -4						; size = 4
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimStepMissileVolumeUp@@YAXKHPAX@Z PROC		; SimStepMissileVolumeUp

; 9884 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 9885 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN5@SimStepMis

; 9886 : 		return;

	jmp	$LN6@SimStepMis
$LN5@SimStepMis:

; 9887 : 
; 9888 : 	if (IO.AnalogIsUsed(AXIS_MSL_VOLUME) == false)	// Retro 3Jan2004

	push	16					; 00000010H
	mov	ecx, OFFSET ?IO@@3VSIMLIB_IO_CLASS@@A	; IO
	call	?AnalogIsUsed@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z ; SIMLIB_IO_CLASS::AnalogIsUsed
	movzx	ecx, al
	test	ecx, ecx
	jne	$LN6@SimStepMis

; 9889 : 	{
; 9890 : 		if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN6@SimStepMis
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN6@SimStepMis
	mov	edx, DWORD PTR _state$[ebp]
	and	edx, 8
	je	$LN6@SimStepMis

; 9891 : 		{
; 9892 : 			SimDriver.GetPlayerAircraft()->MissileVolume--;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	add	eax, 876				; 0000036cH
	mov	DWORD PTR tv89[ebp], eax
	mov	eax, DWORD PTR tv89[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	edx, DWORD PTR tv89[ebp]
	mov	DWORD PTR [edx], ecx

; 9893 : 			if(SimDriver.GetPlayerAircraft()->MissileVolume < 0)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+876], 0
	jge	SHORT $LN2@SimStepMis

; 9894 : 				SimDriver.GetPlayerAircraft()->MissileVolume = 0;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR [eax+876], 0
$LN2@SimStepMis:

; 9895 : 			//int vall = 9 - SimDriver.GetPlayerAircraft()->MissileVolume;
; 9896 : 			int vall = 1<<(8 - SimDriver.GetPlayerAircraft()->MissileVolume);

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, 8
	sub	ecx, DWORD PTR [eax+876]
	mov	eax, 1
	shl	eax, cl
	mov	DWORD PTR _vall$1[ebp], eax

; 9897 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN6@SimStepMis

; 9898 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_MISSILE_VOL, vall);

	mov	ecx, DWORD PTR _vall$1[ebp]
	push	ecx
	push	171					; 000000abH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN6@SimStepMis:

; 9899 : 		}
; 9900 : 	}	// Retro 3Jan2004
; 9901 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimStepMissileVolumeUp@@YAXKHPAX@Z ENDP		; SimStepMissileVolumeUp
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_vall$1 = -8						; size = 4
tv89 = -4						; size = 4
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimStepMissileVolumeDown@@YAXKHPAX@Z PROC		; SimStepMissileVolumeDown

; 9865 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 9866 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN5@SimStepMis

; 9867 : 		return;

	jmp	$LN6@SimStepMis
$LN5@SimStepMis:

; 9868 : 
; 9869 : 	if (IO.AnalogIsUsed(AXIS_MSL_VOLUME) == false)	// Retro 3Jan2004

	push	16					; 00000010H
	mov	ecx, OFFSET ?IO@@3VSIMLIB_IO_CLASS@@A	; IO
	call	?AnalogIsUsed@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z ; SIMLIB_IO_CLASS::AnalogIsUsed
	movzx	ecx, al
	test	ecx, ecx
	jne	$LN6@SimStepMis

; 9870 : 	{
; 9871 : 		if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN6@SimStepMis
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN6@SimStepMis
	mov	edx, DWORD PTR _state$[ebp]
	and	edx, 8
	je	$LN6@SimStepMis

; 9872 : 		{
; 9873 : 			SimDriver.GetPlayerAircraft()->MissileVolume++;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	add	eax, 876				; 0000036cH
	mov	DWORD PTR tv89[ebp], eax
	mov	eax, DWORD PTR tv89[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR tv89[ebp]
	mov	DWORD PTR [edx], ecx

; 9874 : 			if(SimDriver.GetPlayerAircraft()->MissileVolume > 8)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+876], 8
	jle	SHORT $LN2@SimStepMis

; 9875 : 				SimDriver.GetPlayerAircraft()->MissileVolume = 8;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR [eax+876], 8
$LN2@SimStepMis:

; 9876 : 			//int vall = 9 - SimDriver.GetPlayerAircraft()->MissileVolume;
; 9877 : 			int vall = 1<<(8 - SimDriver.GetPlayerAircraft()->MissileVolume);

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, 8
	sub	ecx, DWORD PTR [eax+876]
	mov	eax, 1
	shl	eax, cl
	mov	DWORD PTR _vall$1[ebp], eax

; 9878 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN6@SimStepMis

; 9879 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_MISSILE_VOL, vall);

	mov	ecx, DWORD PTR _vall$1[ebp]
	push	ecx
	push	171					; 000000abH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN6@SimStepMis:

; 9880 : 		}
; 9881 : 	}	// Retro 3Jan2004
; 9882 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimStepMissileVolumeDown@@YAXKHPAX@Z ENDP		; SimStepMissileVolumeDown
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimTrimRollRight@@YAXKHPAX@Z PROC			; SimTrimRollRight

; 9854 : {

	push	ebp
	mov	ebp, esp

; 9855 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimTrimRol

; 9856 : 		return;

	jmp	SHORT $LN4@SimTrimRol
$LN3@SimTrimRol:

; 9857 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN1@SimTrimRol
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN1@SimTrimRol
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN1@SimTrimRol

; 9858 : 	{
; 9859 : 		rollManualTrim = 0.50F;

	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR ?rollManualTrim@@3MA, xmm0

; 9860 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN1@SimTrimRol

; 9861 : 			OTWDriver.GetVirtualCockpit()->SetDOFangle( COMP_3DPIT_TRIM_ROLL, cockpitFlightData.TrimRoll + 0.5f );

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+240
	addss	xmm0, DWORD PTR __real@3f000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	150					; 00000096H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle
$LN1@SimTrimRol:
$LN4@SimTrimRol:

; 9862 : 	}
; 9863 : }

	pop	ebp
	ret	0
?SimTrimRollRight@@YAXKHPAX@Z ENDP			; SimTrimRollRight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimTrimRollLeft@@YAXKHPAX@Z PROC			; SimTrimRollLeft

; 9843 : {

	push	ebp
	mov	ebp, esp

; 9844 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimTrimRol

; 9845 : 		return;

	jmp	SHORT $LN4@SimTrimRol
$LN3@SimTrimRol:

; 9846 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN1@SimTrimRol
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN1@SimTrimRol
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN1@SimTrimRol

; 9847 : 	{
; 9848 : 		rollManualTrim = -0.50F;

	movss	xmm0, DWORD PTR __real@bf000000
	movss	DWORD PTR ?rollManualTrim@@3MA, xmm0

; 9849 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN1@SimTrimRol

; 9850 : 			OTWDriver.GetVirtualCockpit()->SetDOFangle( COMP_3DPIT_TRIM_ROLL, cockpitFlightData.TrimRoll - 0.5f );

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+240
	subss	xmm0, DWORD PTR __real@3f000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	150					; 00000096H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle
$LN1@SimTrimRol:
$LN4@SimTrimRol:

; 9851 : 	}
; 9852 : }

	pop	ebp
	ret	0
?SimTrimRollLeft@@YAXKHPAX@Z ENDP			; SimTrimRollLeft
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimTrimYawRight@@YAXKHPAX@Z PROC			; SimTrimYawRight

; 9832 : {

	push	ebp
	mov	ebp, esp

; 9833 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimTrimYaw

; 9834 : 		return;

	jmp	SHORT $LN4@SimTrimYaw
$LN3@SimTrimYaw:

; 9835 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN1@SimTrimYaw
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN1@SimTrimYaw
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN1@SimTrimYaw

; 9836 : 	{
; 9837 : 		yawManualTrim = 2.0F;

	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR ?yawManualTrim@@3MA, xmm0

; 9838 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN1@SimTrimYaw

; 9839 : 			OTWDriver.GetVirtualCockpit()->SetDOFangle( COMP_3DPIT_TRIM_YAW, cockpitFlightData.TrimYaw + 2.0f );

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+244
	addss	xmm0, DWORD PTR __real@40000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	149					; 00000095H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle
$LN1@SimTrimYaw:
$LN4@SimTrimYaw:

; 9840 : 	}
; 9841 : }

	pop	ebp
	ret	0
?SimTrimYawRight@@YAXKHPAX@Z ENDP			; SimTrimYawRight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimTrimYawLeft@@YAXKHPAX@Z PROC			; SimTrimYawLeft

; 9821 : {

	push	ebp
	mov	ebp, esp

; 9822 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimTrimYaw

; 9823 : 		return;

	jmp	SHORT $LN4@SimTrimYaw
$LN3@SimTrimYaw:

; 9824 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN1@SimTrimYaw
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN1@SimTrimYaw
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN1@SimTrimYaw

; 9825 : 	{
; 9826 : 		yawManualTrim = -2.0F;

	movss	xmm0, DWORD PTR __real@c0000000
	movss	DWORD PTR ?yawManualTrim@@3MA, xmm0

; 9827 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN1@SimTrimYaw

; 9828 : 			OTWDriver.GetVirtualCockpit()->SetDOFangle( COMP_3DPIT_TRIM_YAW, cockpitFlightData.TrimYaw - 2.0f );

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+244
	subss	xmm0, DWORD PTR __real@40000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	149					; 00000095H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle
$LN1@SimTrimYaw:
$LN4@SimTrimYaw:

; 9829 : 	}
; 9830 : }

	pop	ebp
	ret	0
?SimTrimYawLeft@@YAXKHPAX@Z ENDP			; SimTrimYawLeft
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimTrimNoseDown@@YAXKHPAX@Z PROC			; SimTrimNoseDown

; 9810 : {

	push	ebp
	mov	ebp, esp

; 9811 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimTrimNos

; 9812 : 		return;

	jmp	SHORT $LN4@SimTrimNos
$LN3@SimTrimNos:

; 9813 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN1@SimTrimNos
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN1@SimTrimNos
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN1@SimTrimNos

; 9814 : 	{
; 9815 : 		pitchManualTrim = -0.50F;

	movss	xmm0, DWORD PTR __real@bf000000
	movss	DWORD PTR ?pitchManualTrim@@3MA, xmm0

; 9816 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN1@SimTrimNos

; 9817 : 			OTWDriver.GetVirtualCockpit()->SetDOFangle( COMP_3DPIT_TRIM_PITCH, cockpitFlightData.TrimPitch - 0.5f );

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+236
	subss	xmm0, DWORD PTR __real@3f000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	148					; 00000094H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle
$LN1@SimTrimNos:
$LN4@SimTrimNos:

; 9818 : 	}
; 9819 : }

	pop	ebp
	ret	0
?SimTrimNoseDown@@YAXKHPAX@Z ENDP			; SimTrimNoseDown
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimTrimNoseUp@@YAXKHPAX@Z PROC				; SimTrimNoseUp

; 9799 : {

	push	ebp
	mov	ebp, esp

; 9800 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimTrimNos

; 9801 : 		return;

	jmp	SHORT $LN4@SimTrimNos
$LN3@SimTrimNos:

; 9802 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN1@SimTrimNos
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN1@SimTrimNos
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN1@SimTrimNos

; 9803 : 	{
; 9804 : 		pitchManualTrim = 0.50F;

	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR ?pitchManualTrim@@3MA, xmm0

; 9805 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN1@SimTrimNos

; 9806 : 			OTWDriver.GetVirtualCockpit()->SetDOFangle( COMP_3DPIT_TRIM_PITCH, cockpitFlightData.TrimPitch + 0.5f );

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+236
	addss	xmm0, DWORD PTR __real@3f000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	148					; 00000094H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle
$LN1@SimTrimNos:
$LN4@SimTrimNos:

; 9807 : 	}
; 9808 : }

	pop	ebp
	ret	0
?SimTrimNoseUp@@YAXKHPAX@Z ENDP				; SimTrimNoseUp
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimABReset@@YAXKHPAX@Z PROC				; SimABReset

; 9796 : {

	push	ebp
	mov	ebp, esp

; 9797 : }

	pop	ebp
	ret	0
?SimABReset@@YAXKHPAX@Z ENDP				; SimABReset
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimMaxPower@@YAXKHPAX@Z PROC				; SimMaxPower

; 9793 : {

	push	ebp
	mov	ebp, esp

; 9794 : }

	pop	ebp
	ret	0
?SimMaxPower@@YAXKHPAX@Z ENDP				; SimMaxPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimTrimAPNORM@@YAXKHPAX@Z PROC				; SimTrimAPNORM

; 9780 : {

	push	ebp
	mov	ebp, esp

; 9781 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimTrimAPN

; 9782 : 		return;

	jmp	SHORT $LN4@SimTrimAPN
$LN3@SimTrimAPN:

; 9783 : 
; 9784 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimTrimAPN
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimTrimAPN
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimTrimAPN

; 9785 : 	{
; 9786 : 		SimDriver.GetPlayerAircraft()->TrimAPDisc = FALSE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	BYTE PTR [eax+850], 0

; 9787 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimTrimAPN

; 9788 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_TRIM_AP, 2);

	push	2
	push	191					; 000000bfH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimTrimAPN:

; 9789 : 	}
; 9790 : }

	pop	ebp
	ret	0
?SimTrimAPNORM@@YAXKHPAX@Z ENDP				; SimTrimAPNORM
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimTrimAPDISC@@YAXKHPAX@Z PROC				; SimTrimAPDISC

; 9764 : {

	push	ebp
	mov	ebp, esp

; 9765 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimTrimAPD

; 9766 : 		return;

	jmp	$LN4@SimTrimAPD
$LN3@SimTrimAPD:

; 9767 : 
; 9768 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN1@SimTrimAPD
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN1@SimTrimAPD
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN1@SimTrimAPD

; 9769 : 	{
; 9770 : 		SimDriver.GetPlayerAircraft()->TrimAPDisc = TRUE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	BYTE PTR [eax+850], 1

; 9771 : 		pitchRudderTrimRate = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR ?pitchRudderTrimRate@@3MA, xmm0

; 9772 : 		pitchAileronTrimRate = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR ?pitchAileronTrimRate@@3MA, xmm0

; 9773 : 		pitchElevatorTrimRate = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR ?pitchElevatorTrimRate@@3MA, xmm0

; 9774 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN1@SimTrimAPD

; 9775 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_TRIM_AP, 1);

	push	1
	push	191					; 000000bfH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN1@SimTrimAPD:
$LN4@SimTrimAPD:

; 9776 : 	}
; 9777 : }

	pop	ebp
	ret	0
?SimTrimAPDISC@@YAXKHPAX@Z ENDP				; SimTrimAPDISC
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimTrimAPDisc@@YAXKHPAX@Z PROC				; SimTrimAPDisc

; 9735 : {

	push	ebp
	mov	ebp, esp

; 9736 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN6@SimTrimAPD

; 9737 : 		return;

	jmp	$LN7@SimTrimAPD
$LN6@SimTrimAPD:

; 9738 : 
; 9739 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN1@SimTrimAPD
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN1@SimTrimAPD
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	$LN1@SimTrimAPD

; 9740 : 	{
; 9741 : 		if(SimDriver.GetPlayerAircraft()->TrimAPDisc)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	movzx	edx, BYTE PTR [eax+850]
	test	edx, edx
	je	SHORT $LN4@SimTrimAPD

; 9742 : 		{
; 9743 : 			SimDriver.GetPlayerAircraft()->TrimAPDisc = FALSE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	BYTE PTR [eax+850], 0

; 9744 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN3@SimTrimAPD

; 9745 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_TRIM_AP, 2);

	push	2
	push	191					; 000000bfH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN3@SimTrimAPD:

; 9746 : 		}
; 9747 : 		else 

	jmp	SHORT $LN1@SimTrimAPD
$LN4@SimTrimAPD:

; 9748 : 		{
; 9749 : 			SimDriver.GetPlayerAircraft()->TrimAPDisc = TRUE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	BYTE PTR [eax+850], 1

; 9750 : 			pitchRudderTrimRate = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR ?pitchRudderTrimRate@@3MA, xmm0

; 9751 : 			pitchAileronTrimRate = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR ?pitchAileronTrimRate@@3MA, xmm0

; 9752 : 			pitchElevatorTrimRate = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR ?pitchElevatorTrimRate@@3MA, xmm0

; 9753 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN1@SimTrimAPD

; 9754 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_TRIM_AP, 1);

	push	1
	push	191					; 000000bfH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN1@SimTrimAPD:
$LN7@SimTrimAPD:

; 9755 : 		}
; 9756 : 	}
; 9757 : }

	pop	ebp
	ret	0
?SimTrimAPDisc@@YAXKHPAX@Z ENDP				; SimTrimAPDisc
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimOverHeat@@YAXKHPAX@Z PROC				; SimOverHeat

; 9729 : {

	push	ebp
	mov	ebp, esp

; 9730 : }

	pop	ebp
	ret	0
?SimOverHeat@@YAXKHPAX@Z ENDP				; SimOverHeat
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimTestSwitch@@YAXKHPAX@Z PROC				; SimTestSwitch

; 9726 : {

	push	ebp
	mov	ebp, esp

; 9727 : }

	pop	ebp
	ret	0
?SimTestSwitch@@YAXKHPAX@Z ENDP				; SimTestSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimEPUGEN@@YAXKHPAX@Z PROC				; SimEPUGEN

; 9723 : {

	push	ebp
	mov	ebp, esp

; 9724 : }

	pop	ebp
	ret	0
?SimEPUGEN@@YAXKHPAX@Z ENDP				; SimEPUGEN
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimProbeHeat@@YAXKHPAX@Z PROC				; SimProbeHeat

; 9720 : {

	push	ebp
	mov	ebp, esp

; 9721 : }

	pop	ebp
	ret	0
?SimProbeHeat@@YAXKHPAX@Z ENDP				; SimProbeHeat
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimMalIndLights@@YAXKHPAX@Z PROC			; SimMalIndLights

; 9699 : {

	push	ebp
	mov	ebp, esp

; 9700 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN7@SimMalIndL

; 9701 : 		return;

	jmp	$LN8@SimMalIndL
$LN7@SimMalIndL:

; 9702 : 	if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN6@SimMalIndL

; 9703 : 	{
; 9704 : 		if (SimDriver.GetPlayerAircraft()->TestLights == TRUE)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	movzx	ecx, BYTE PTR [eax+849]
	cmp	ecx, 1
	jne	SHORT $LN5@SimMalIndL

; 9705 : 			SimDriver.GetPlayerAircraft()->TestLights = FALSE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	BYTE PTR [eax+849], 0

; 9706 : 		else

	jmp	SHORT $LN4@SimMalIndL
$LN5@SimMalIndL:

; 9707 : 			SimDriver.GetPlayerAircraft()->TestLights = TRUE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	BYTE PTR [eax+849], 1
$LN4@SimMalIndL:

; 9708 : 		return;

	jmp	SHORT $LN8@SimMalIndL
$LN6@SimMalIndL:

; 9709 : 	}
; 9710 : 
; 9711 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN8@SimMalIndL
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN8@SimMalIndL

; 9712 : 	{
; 9713 : 		if(state & KEY_DOWN)

	mov	edx, DWORD PTR _state$[ebp]
	and	edx, 8
	je	SHORT $LN2@SimMalIndL

; 9714 : 			SimDriver.GetPlayerAircraft()->TestLights = TRUE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	BYTE PTR [eax+849], 1

; 9715 : 		else

	jmp	SHORT $LN8@SimMalIndL
$LN2@SimMalIndL:

; 9716 : 			SimDriver.GetPlayerAircraft()->TestLights = FALSE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	BYTE PTR [eax+849], 0
$LN8@SimMalIndL:

; 9717 : 	}
; 9718 : }

	pop	ebp
	ret	0
?SimMalIndLights@@YAXKHPAX@Z ENDP			; SimMalIndLights
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimOBOGSBit@@YAXKHPAX@Z PROC				; SimOBOGSBit

; 9695 : {

	push	ebp
	mov	ebp, esp

; 9696 : }

	pop	ebp
	ret	0
?SimOBOGSBit@@YAXKHPAX@Z ENDP				; SimOBOGSBit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimFLTBIT@@YAXKHPAX@Z PROC				; SimFLTBIT

; 9692 : {

	push	ebp
	mov	ebp, esp

; 9693 : }

	pop	ebp
	ret	0
?SimFLTBIT@@YAXKHPAX@Z ENDP				; SimFLTBIT
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimFLCSReset@@YAXKHPAX@Z PROC				; SimFLCSReset

; 9689 : {

	push	ebp
	mov	ebp, esp

; 9690 : }

	pop	ebp
	ret	0
?SimFLCSReset@@YAXKHPAX@Z ENDP				; SimFLCSReset
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimManualFlyup@@YAXKHPAX@Z PROC			; SimManualFlyup

; 9686 : {

	push	ebp
	mov	ebp, esp

; 9687 : }

	pop	ebp
	ret	0
?SimManualFlyup@@YAXKHPAX@Z ENDP			; SimManualFlyup
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimAltFlapsExtend@@YAXKHPAX@Z PROC			; SimAltFlapsExtend

; 9673 : {

	push	ebp
	mov	ebp, esp

; 9674 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimAltFlap

; 9675 : 		return;

	jmp	SHORT $LN4@SimAltFlap
$LN3@SimAltFlap:

; 9676 : 
; 9677 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimAltFlap
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimAltFlap
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimAltFlap

; 9678 : 	{
; 9679 : 		SimDriver.GetPlayerAircraft()->TEFExtend = TRUE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	BYTE PTR [eax+851], 1

; 9680 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimAltFlap

; 9681 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_ALT_FLAPS, 2);

	push	2
	push	193					; 000000c1H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimAltFlap:

; 9682 : 	}
; 9683 : }

	pop	ebp
	ret	0
?SimAltFlapsExtend@@YAXKHPAX@Z ENDP			; SimAltFlapsExtend
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimAltFlapsNorm@@YAXKHPAX@Z PROC			; SimAltFlapsNorm

; 9660 : {

	push	ebp
	mov	ebp, esp

; 9661 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimAltFlap

; 9662 : 		return;

	jmp	SHORT $LN4@SimAltFlap
$LN3@SimAltFlap:

; 9663 : 
; 9664 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimAltFlap
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimAltFlap
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimAltFlap

; 9665 : 	{
; 9666 : 		SimDriver.GetPlayerAircraft()->TEFExtend = FALSE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	BYTE PTR [eax+851], 0

; 9667 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimAltFlap

; 9668 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_ALT_FLAPS, 1);

	push	1
	push	193					; 000000c1H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimAltFlap:

; 9669 : 	}
; 9670 : }

	pop	ebp
	ret	0
?SimAltFlapsNorm@@YAXKHPAX@Z ENDP			; SimAltFlapsNorm
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimAltFlaps@@YAXKHPAX@Z PROC				; SimAltFlaps

; 9636 : {

	push	ebp
	mov	ebp, esp

; 9637 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN6@SimAltFlap

; 9638 : 		return;

	jmp	$LN7@SimAltFlap
$LN6@SimAltFlap:

; 9639 : 
; 9640 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN7@SimAltFlap
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN7@SimAltFlap
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	$LN7@SimAltFlap

; 9641 : 	{
; 9642 : 		if(SimDriver.GetPlayerAircraft()->TEFExtend)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	movzx	edx, BYTE PTR [eax+851]
	test	edx, edx
	je	SHORT $LN4@SimAltFlap

; 9643 : 		{
; 9644 : 			SimDriver.GetPlayerAircraft()->TEFExtend = FALSE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	BYTE PTR [eax+851], 0

; 9645 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN3@SimAltFlap

; 9646 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_ALT_FLAPS, 1);

	push	1
	push	193					; 000000c1H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN3@SimAltFlap:

; 9647 : 		}
; 9648 : 		else

	jmp	SHORT $LN7@SimAltFlap
$LN4@SimAltFlap:

; 9649 : 		{
; 9650 : 			SimDriver.GetPlayerAircraft()->TEFExtend = TRUE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	BYTE PTR [eax+851], 1

; 9651 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN7@SimAltFlap

; 9652 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_ALT_FLAPS, 2);

	push	2
	push	193					; 000000c1H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN7@SimAltFlap:

; 9653 : 		}
; 9654 : 	}
; 9655 : }

	pop	ebp
	ret	0
?SimAltFlaps@@YAXKHPAX@Z ENDP				; SimAltFlaps
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimDigitalBUP@@YAXKHPAX@Z PROC				; SimDigitalBUP

; 9633 : {

	push	ebp
	mov	ebp, esp

; 9634 : }

	pop	ebp
	ret	0
?SimDigitalBUP@@YAXKHPAX@Z ENDP				; SimDigitalBUP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimLEFAuto@@YAXKHPAX@Z PROC				; SimLEFAuto

; 9616 : {

	push	ebp
	mov	ebp, esp

; 9617 : 	//don't bother
; 9618 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN4@SimLEFAuto

; 9619 : 		return;

	jmp	$LN5@SimLEFAuto
$LN4@SimLEFAuto:

; 9620 : 
; 9621 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN5@SimLEFAuto
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN5@SimLEFAuto
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN5@SimLEFAuto

; 9622 : 	{
; 9623 : 		SimDriver.GetPlayerAircraft()->LEFLocked = FALSE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	BYTE PTR [eax+853], 0

; 9624 : 		if(SimDriver.GetPlayerAircraft()->mFaults && !SimDriver.GetPlayerAircraft()->LEFState(AircraftClass::LEFSASYNCH))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+928], 0
	je	SHORT $LN2@SimLEFAuto
	push	32					; 00000020H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?LEFState@AircraftClass@@QAEHW4LEFStateFlags@1@@Z ; AircraftClass::LEFState
	test	eax, eax
	jne	SHORT $LN2@SimLEFAuto

; 9625 : 			SimDriver.GetPlayerAircraft()->mFaults->ClearFault(lef_fault);

	push	35					; 00000023H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+928]
	call	?ClearFault@FackClass@@QAEXW4type_CSubSystem@@@Z ; FackClass::ClearFault
$LN2@SimLEFAuto:

; 9626 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN5@SimLEFAuto

; 9627 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_LEF_FLAPS, 1);

	push	1
	push	192					; 000000c0H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN5@SimLEFAuto:

; 9628 : 	}	
; 9629 : }

	pop	ebp
	ret	0
?SimLEFAuto@@YAXKHPAX@Z ENDP				; SimLEFAuto
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimLEFLock@@YAXKHPAX@Z PROC				; SimLEFLock

; 9600 : {

	push	ebp
	mov	ebp, esp

; 9601 : 	//don't bother
; 9602 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN4@SimLEFLock

; 9603 : 		return;

	jmp	$LN5@SimLEFLock
$LN4@SimLEFLock:

; 9604 : 
; 9605 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN5@SimLEFLock
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN5@SimLEFLock
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN5@SimLEFLock

; 9606 : 	{
; 9607 : 		SimDriver.GetPlayerAircraft()->LEFLocked = TRUE;			

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	BYTE PTR [eax+853], 1

; 9608 : 		if(SimDriver.GetPlayerAircraft()->mFaults)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+928], 0
	je	SHORT $LN2@SimLEFLock

; 9609 : 			SimDriver.GetPlayerAircraft()->mFaults->SetCaution(lef_fault);

	push	35					; 00000023H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+928]
	call	?SetCaution@FackClass@@QAEXW4type_CSubSystem@@@Z ; FackClass::SetCaution
$LN2@SimLEFLock:

; 9610 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN5@SimLEFLock

; 9611 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_LEF_FLAPS, 2);

	push	2
	push	192					; 000000c0H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN5@SimLEFLock:

; 9612 : 	}	
; 9613 : }

	pop	ebp
	ret	0
?SimLEFLock@@YAXKHPAX@Z ENDP				; SimLEFLock
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimLEFLockSwitch@@YAXKHPAX@Z PROC			; SimLEFLockSwitch

; 9571 : {

	push	ebp
	mov	ebp, esp

; 9572 : 	//don't bother
; 9573 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN8@SimLEFLock

; 9574 : 		return;

	jmp	$LN9@SimLEFLock
$LN8@SimLEFLock:

; 9575 : 
; 9576 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN9@SimLEFLock
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN9@SimLEFLock
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	$LN9@SimLEFLock

; 9577 : 	{
; 9578 : 		if(SimDriver.GetPlayerAircraft()->LEFLocked)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	movzx	edx, BYTE PTR [eax+853]
	test	edx, edx
	je	SHORT $LN6@SimLEFLock

; 9579 : 		{
; 9580 : 			SimDriver.GetPlayerAircraft()->LEFLocked = FALSE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	BYTE PTR [eax+853], 0

; 9581 : 			if(SimDriver.GetPlayerAircraft()->mFaults && !SimDriver.GetPlayerAircraft()->LEFState(AircraftClass::LEFSASYNCH))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+928], 0
	je	SHORT $LN5@SimLEFLock
	push	32					; 00000020H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?LEFState@AircraftClass@@QAEHW4LEFStateFlags@1@@Z ; AircraftClass::LEFState
	test	eax, eax
	jne	SHORT $LN5@SimLEFLock

; 9582 : 				SimDriver.GetPlayerAircraft()->mFaults->ClearFault(lef_fault);

	push	35					; 00000023H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+928]
	call	?ClearFault@FackClass@@QAEXW4type_CSubSystem@@@Z ; FackClass::ClearFault
$LN5@SimLEFLock:

; 9583 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimLEFLock

; 9584 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_LEF_FLAPS, 1);

	push	1
	push	192					; 000000c0H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimLEFLock:

; 9585 : 		}
; 9586 : 		else

	jmp	SHORT $LN9@SimLEFLock
$LN6@SimLEFLock:

; 9587 : 		{
; 9588 : 			SimDriver.GetPlayerAircraft()->LEFLocked = TRUE;			

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	BYTE PTR [eax+853], 1

; 9589 : 			if(SimDriver.GetPlayerAircraft()->mFaults)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+928], 0
	je	SHORT $LN2@SimLEFLock

; 9590 : 				SimDriver.GetPlayerAircraft()->mFaults->SetCaution(lef_fault);

	push	35					; 00000023H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+928]
	call	?SetCaution@FackClass@@QAEXW4type_CSubSystem@@@Z ; FackClass::SetCaution
$LN2@SimLEFLock:

; 9591 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN9@SimLEFLock

; 9592 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_LEF_FLAPS, 2);

	push	2
	push	192					; 000000c0H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN9@SimLEFLock:

; 9593 : 		}
; 9594 : 	}	
; 9595 : }

	pop	ebp
	ret	0
?SimLEFLockSwitch@@YAXKHPAX@Z ENDP			; SimLEFLockSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimINSInFlt@@YAXKHPAX@Z PROC				; SimINSInFlt

; 9556 : {

	push	ebp
	mov	ebp, esp

; 9557 : 	//don't bother
; 9558 : 	if(!g_bINS || !g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	eax, eax
	je	SHORT $LN3@SimINSInFl
	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	jne	SHORT $LN4@SimINSInFl
$LN3@SimINSInFl:

; 9559 : 		return;

	jmp	SHORT $LN5@SimINSInFl
$LN4@SimINSInFl:

; 9560 : 
; 9561 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN5@SimINSInFl
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN5@SimINSInFl
	mov	edx, DWORD PTR _state$[ebp]
	and	edx, 8
	je	SHORT $LN5@SimINSInFl

; 9562 : 	{
; 9563 : 		SimDriver.GetPlayerAircraft()->SwitchINSToInFLT();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SwitchINSToInFLT@AircraftClass@@QAEXXZ	; AircraftClass::SwitchINSToInFLT

; 9564 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN5@SimINSInFl

; 9565 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_INS_MODE, 8);

	push	8
	push	216					; 000000d8H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN5@SimINSInFl:

; 9566 : 	}
; 9567 : }

	pop	ebp
	ret	0
?SimINSInFlt@@YAXKHPAX@Z ENDP				; SimINSInFlt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimINSNav@@YAXKHPAX@Z PROC				; SimINSNav

; 9542 : {

	push	ebp
	mov	ebp, esp

; 9543 : 	//don't bother
; 9544 : 	if(!g_bINS || !g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	eax, eax
	je	SHORT $LN3@SimINSNav
	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	jne	SHORT $LN4@SimINSNav
$LN3@SimINSNav:

; 9545 : 		return;

	jmp	SHORT $LN5@SimINSNav
$LN4@SimINSNav:

; 9546 : 
; 9547 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN5@SimINSNav
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN5@SimINSNav
	mov	edx, DWORD PTR _state$[ebp]
	and	edx, 8
	je	SHORT $LN5@SimINSNav

; 9548 : 	{
; 9549 : 		SimDriver.GetPlayerAircraft()->SwitchINSToNav();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SwitchINSToNav@AircraftClass@@QAEXXZ	; AircraftClass::SwitchINSToNav

; 9550 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN5@SimINSNav

; 9551 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_INS_MODE, 4);

	push	4
	push	216					; 000000d8H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN5@SimINSNav:

; 9552 : 	}
; 9553 : }

	pop	ebp
	ret	0
?SimINSNav@@YAXKHPAX@Z ENDP				; SimINSNav
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimINSNorm@@YAXKHPAX@Z PROC				; SimINSNorm

; 9528 : {

	push	ebp
	mov	ebp, esp

; 9529 : 	//don't bother
; 9530 : 	if(!g_bINS || !g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	eax, eax
	je	SHORT $LN3@SimINSNorm
	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	jne	SHORT $LN4@SimINSNorm
$LN3@SimINSNorm:

; 9531 : 		return;

	jmp	SHORT $LN5@SimINSNorm
$LN4@SimINSNorm:

; 9532 : 
; 9533 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN5@SimINSNorm
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN5@SimINSNorm
	mov	edx, DWORD PTR _state$[ebp]
	and	edx, 8
	je	SHORT $LN5@SimINSNorm

; 9534 : 	{
; 9535 : 		SimDriver.GetPlayerAircraft()->SwitchINSToAlign();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SwitchINSToAlign@AircraftClass@@QAEXXZ	; AircraftClass::SwitchINSToAlign

; 9536 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN5@SimINSNorm

; 9537 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_INS_MODE, 2);

	push	2
	push	216					; 000000d8H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN5@SimINSNorm:

; 9538 : 	}
; 9539 : }

	pop	ebp
	ret	0
?SimINSNorm@@YAXKHPAX@Z ENDP				; SimINSNorm
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimINSOff@@YAXKHPAX@Z PROC				; SimINSOff

; 9514 : {

	push	ebp
	mov	ebp, esp

; 9515 : 	//don't bother
; 9516 : 	if(!g_bINS || !g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	eax, eax
	je	SHORT $LN3@SimINSOff
	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	jne	SHORT $LN4@SimINSOff
$LN3@SimINSOff:

; 9517 : 		return;

	jmp	SHORT $LN5@SimINSOff
$LN4@SimINSOff:

; 9518 : 
; 9519 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN5@SimINSOff
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN5@SimINSOff
	mov	edx, DWORD PTR _state$[ebp]
	and	edx, 8
	je	SHORT $LN5@SimINSOff

; 9520 : 	{
; 9521 : 		SimDriver.GetPlayerAircraft()->SwitchINSToOff();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SwitchINSToOff@AircraftClass@@QAEXXZ	; AircraftClass::SwitchINSToOff

; 9522 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN5@SimINSOff

; 9523 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_INS_MODE, 1);

	push	1
	push	216					; 000000d8H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN5@SimINSOff:

; 9524 : 	}
; 9525 : }

	pop	ebp
	ret	0
?SimINSOff@@YAXKHPAX@Z ENDP				; SimINSOff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimINSDec@@YAXKHPAX@Z PROC				; SimINSDec

; 9482 : {

	push	ebp
	mov	ebp, esp

; 9483 : 	//don't bother
; 9484 : 	if(!g_bINS || !g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	eax, eax
	je	SHORT $LN10@SimINSDec
	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	jne	SHORT $LN11@SimINSDec
$LN10@SimINSDec:

; 9485 : 		return;

	jmp	$LN12@SimINSDec
$LN11@SimINSDec:

; 9486 : 
; 9487 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN12@SimINSDec
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN12@SimINSDec
	mov	edx, DWORD PTR _state$[ebp]
	and	edx, 8
	je	$LN12@SimINSDec

; 9488 : 	{
; 9489 : 		if(SimDriver.GetPlayerAircraft()->INSState(AircraftClass::INS_AlignFlight))

	push	16					; 00000010H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	je	SHORT $LN8@SimINSDec

; 9490 : 		{
; 9491 : 			SimDriver.GetPlayerAircraft()->SwitchINSToNav();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SwitchINSToNav@AircraftClass@@QAEXXZ	; AircraftClass::SwitchINSToNav

; 9492 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN7@SimINSDec

; 9493 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_INS_MODE, 4);

	push	4
	push	216					; 000000d8H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN7@SimINSDec:

; 9494 : 		}

	jmp	$LN12@SimINSDec
$LN8@SimINSDec:

; 9495 : 		else if(SimDriver.GetPlayerAircraft()->INSState(AircraftClass::INS_Nav))

	push	32					; 00000020H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	je	SHORT $LN5@SimINSDec

; 9496 : 		{
; 9497 : 			SimDriver.GetPlayerAircraft()->SwitchINSToAlign();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SwitchINSToAlign@AircraftClass@@QAEXXZ	; AircraftClass::SwitchINSToAlign

; 9498 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimINSDec

; 9499 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_INS_MODE, 2);

	push	2
	push	216					; 000000d8H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimINSDec:

; 9500 : 		}

	jmp	SHORT $LN12@SimINSDec
$LN5@SimINSDec:

; 9501 : 		else if(SimDriver.GetPlayerAircraft()->INSState(AircraftClass::INS_AlignNorm))

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	je	SHORT $LN12@SimINSDec

; 9502 : 		{
; 9503 : 			SimDriver.GetPlayerAircraft()->SwitchINSToOff();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SwitchINSToOff@AircraftClass@@QAEXXZ	; AircraftClass::SwitchINSToOff

; 9504 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN12@SimINSDec

; 9505 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_INS_MODE, 1);

	push	1
	push	216					; 000000d8H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN12@SimINSDec:

; 9506 : 		}
; 9507 : 	}
; 9508 : }

	pop	ebp
	ret	0
?SimINSDec@@YAXKHPAX@Z ENDP				; SimINSDec
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimINSInc@@YAXKHPAX@Z PROC				; SimINSInc

; 9453 : {

	push	ebp
	mov	ebp, esp

; 9454 : 	//don't bother
; 9455 : 	if(!g_bINS || !g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	eax, eax
	je	SHORT $LN10@SimINSInc
	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	jne	SHORT $LN11@SimINSInc
$LN10@SimINSInc:

; 9456 : 		return;

	jmp	$LN12@SimINSInc
$LN11@SimINSInc:

; 9457 : 
; 9458 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN12@SimINSInc
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN12@SimINSInc
	mov	edx, DWORD PTR _state$[ebp]
	and	edx, 8
	je	$LN12@SimINSInc

; 9459 : 	{
; 9460 : 		if(SimDriver.GetPlayerAircraft()->INSState(AircraftClass::INS_PowerOff))

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	je	SHORT $LN8@SimINSInc

; 9461 : 		{
; 9462 : 			SimDriver.GetPlayerAircraft()->SwitchINSToAlign();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SwitchINSToAlign@AircraftClass@@QAEXXZ	; AircraftClass::SwitchINSToAlign

; 9463 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN7@SimINSInc

; 9464 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_INS_MODE, 2);

	push	2
	push	216					; 000000d8H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN7@SimINSInc:

; 9465 : 		}

	jmp	$LN12@SimINSInc
$LN8@SimINSInc:

; 9466 : 		else if(SimDriver.GetPlayerAircraft()->INSState(AircraftClass::INS_AlignNorm))

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	je	SHORT $LN5@SimINSInc

; 9467 : 		{
; 9468 : 			SimDriver.GetPlayerAircraft()->SwitchINSToNav();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SwitchINSToNav@AircraftClass@@QAEXXZ	; AircraftClass::SwitchINSToNav

; 9469 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimINSInc

; 9470 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_INS_MODE, 4);

	push	4
	push	216					; 000000d8H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimINSInc:

; 9471 : 		}

	jmp	SHORT $LN12@SimINSInc
$LN5@SimINSInc:

; 9472 : 		else if(SimDriver.GetPlayerAircraft()->INSState(AircraftClass::INS_Nav))

	push	32					; 00000020H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	je	SHORT $LN12@SimINSInc

; 9473 : 		{
; 9474 : 			SimDriver.GetPlayerAircraft()->SwitchINSToInFLT();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SwitchINSToInFLT@AircraftClass@@QAEXXZ	; AircraftClass::SwitchINSToInFLT

; 9475 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN12@SimINSInc

; 9476 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_INS_MODE, 8);

	push	8
	push	216					; 000000d8H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN12@SimINSInc:

; 9477 : 		}
; 9478 : 	}
; 9479 : }

	pop	ebp
	ret	0
?SimINSInc@@YAXKHPAX@Z ENDP				; SimINSInc
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimIFFIn@@YAXKHPAX@Z PROC				; SimIFFIn

; 9430 : {

	push	ebp
	mov	ebp, esp

; 9431 : //Cobra 11/21/04  This comes from TMS Left.  We have commanded an interrogation
; 9432 : if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN6@SimIFFIn

; 9433 : 		return;

	jmp	$LN7@SimIFFIn
$LN6@SimIFFIn:

; 9434 : if (!SimDriver.GetPlayerAircraft()->iffEnabled)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+896], 0
	jne	SHORT $LN5@SimIFFIn

; 9435 : 	return;

	jmp	$LN7@SimIFFIn
$LN5@SimIFFIn:

; 9436 : 
; 9437 : 	if((state & KEY_DOWN) && (SimDriver.GetPlayerAircraft()) && (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)))

	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimIFFIn
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimIFFIn
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimIFFIn

; 9438 : 	{
; 9439 : 		SimDriver.GetPlayerAircraft()->runIFFInt = TRUE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	BYTE PTR [eax+901], 1

; 9440 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN3@SimIFFIn

; 9441 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_IFF_QUERY, 2);

	push	2
	push	143					; 0000008fH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN3@SimIFFIn:

; 9442 : 	}
; 9443 : 	else

	jmp	SHORT $LN7@SimIFFIn
$LN4@SimIFFIn:

; 9444 : 	{
; 9445 : 		SimDriver.GetPlayerAircraft()->interrogating = FALSE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	BYTE PTR [eax+900], 0

; 9446 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN7@SimIFFIn

; 9447 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_IFF_QUERY, 1);

	push	1
	push	143					; 0000008fH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN7@SimIFFIn:

; 9448 : 	}
; 9449 : 
; 9450 : }

	pop	ebp
	ret	0
?SimIFFIn@@YAXKHPAX@Z ENDP				; SimIFFIn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimIFFPower@@YAXKHPAX@Z PROC				; SimIFFPower

; 9407 : {

	push	ebp
	mov	ebp, esp

; 9408 : //Cobra 11/20/04 Ok, let's make this switch work
; 9409 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN6@SimIFFPowe

; 9410 : 		return;

	jmp	$LN7@SimIFFPowe
$LN6@SimIFFPowe:

; 9411 : 	if((state & KEY_DOWN) && (SimDriver.GetPlayerAircraft()) && (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)))

	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	$LN7@SimIFFPowe
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN7@SimIFFPowe
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN7@SimIFFPowe

; 9412 : 		{
; 9413 : 			if (!SimDriver.GetPlayerAircraft()->HasPower(AircraftClass::IFFPower))

	push	2097152					; 00200000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::HasPower
	test	eax, eax
	jne	SHORT $LN4@SimIFFPowe

; 9414 : 			{
; 9415 : 				SimDriver.GetPlayerAircraft()->PowerOn(AircraftClass::IFFPower);

	push	2097152					; 00200000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerOn@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerOn

; 9416 : 				if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN3@SimIFFPowe

; 9417 : 					OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_IFF_PWR, 2);

	push	2
	push	179					; 000000b3H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN3@SimIFFPowe:

; 9418 : 			}
; 9419 : 			else 

	jmp	SHORT $LN7@SimIFFPowe
$LN4@SimIFFPowe:

; 9420 : 			{
; 9421 : 				SimDriver.GetPlayerAircraft()->PowerOff(AircraftClass::IFFPower);

	push	2097152					; 00200000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerOff@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerOff

; 9422 : 				if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN7@SimIFFPowe

; 9423 : 					OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_IFF_PWR, 1);

	push	1
	push	179					; 000000b3H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN7@SimIFFPowe:

; 9424 : 			}
; 9425 : 		}
; 9426 : 
; 9427 : }

	pop	ebp
	ret	0
?SimIFFPower@@YAXKHPAX@Z ENDP				; SimIFFPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
_pButton$ = 16						; size = 4
?SimAutoAVTR@@YAXKHPAX@Z PROC				; SimAutoAVTR

; 9383 : {

	push	ebp
	mov	ebp, esp

; 9384 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN6@SimAutoAVT

; 9385 : 		return;

	jmp	$LN7@SimAutoAVT
$LN6@SimAutoAVT:

; 9386 : 	if((state & KEY_DOWN) && (SimDriver.GetPlayerAircraft()) && (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)))

	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	$LN7@SimAutoAVT
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN7@SimAutoAVT
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN7@SimAutoAVT

; 9387 : 	{
; 9388 : 		if(SimDriver.GetPlayerAircraft()->Sms && SimDriver.GetPlayerAircraft()->Sms->MasterArm() ==
; 9389 : 			SMSBaseClass::Safe)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+940], 0
	je	SHORT $LN4@SimAutoAVT
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+940]
	call	?MasterArm@SMSBaseClass@@QAE?AW4MasterArmState@1@XZ ; SMSBaseClass::MasterArm
	test	eax, eax
	jne	SHORT $LN4@SimAutoAVT

; 9390 : 			return;

	jmp	SHORT $LN7@SimAutoAVT
$LN4@SimAutoAVT:

; 9391 : 
; 9392 : 		if(!SimDriver.GetPlayerAircraft()->AVTRState(AircraftClass::AVTRStateFlags::AVTR_AUTO))

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?AVTRState@AircraftClass@@QAEHW4AVTRStateFlags@1@@Z ; AircraftClass::AVTRState
	test	eax, eax
	jne	SHORT $LN3@SimAutoAVT

; 9393 : 			return;

	jmp	SHORT $LN7@SimAutoAVT
$LN3@SimAutoAVT:

; 9394 : 
; 9395 : 		if(SimDriver.AVTROn() == FALSE)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?AVTROn@SimulationDriver@@QAEHXZ	; SimulationDriver::AVTROn
	test	eax, eax
	jne	SHORT $LN2@SimAutoAVT

; 9396 : 		{ 
; 9397 : 			SimDriver.SetAVTR(TRUE);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?SetAVTR@SimulationDriver@@QAEXH@Z	; SimulationDriver::SetAVTR

; 9398 : 			SimDriver.GetPlayerAircraft()->AddAVTRSeconds();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?AddAVTRSeconds@AircraftClass@@QAEXXZ	; AircraftClass::AddAVTRSeconds

; 9399 : 			ACMIToggleRecording(0, state, NULL);

	push	0
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	push	0
	call	?ACMIToggleRecording@@YAXKHPAX@Z	; ACMIToggleRecording
	add	esp, 12					; 0000000cH

; 9400 : 		}
; 9401 : 		else

	jmp	SHORT $LN7@SimAutoAVT
$LN2@SimAutoAVT:

; 9402 : 			SimDriver.GetPlayerAircraft()->AddAVTRSeconds();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?AddAVTRSeconds@AircraftClass@@QAEXXZ	; AircraftClass::AddAVTRSeconds
$LN7@SimAutoAVT:

; 9403 : 	}
; 9404 : }

	pop	ebp
	ret	0
?SimAutoAVTR@@YAXKHPAX@Z ENDP				; SimAutoAVTR
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
_pButton$ = 16						; size = 4
?SimAVTRSwitchOn@@YAXKHPAX@Z PROC			; SimAVTRSwitchOn

; 9362 : {

	push	ebp
	mov	ebp, esp

; 9363 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN4@SimAVTRSwi

; 9364 : 		return;

	jmp	$LN5@SimAVTRSwi
$LN4@SimAVTRSwi:

; 9365 : 
; 9366 : 	if((state & KEY_DOWN) && (SimDriver.GetPlayerAircraft()) && (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)))

	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	$LN5@SimAVTRSwi
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN5@SimAVTRSwi
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN5@SimAVTRSwi

; 9367 : 	{
; 9368 : 		SimDriver.GetPlayerAircraft()->AVTROn(AircraftClass::AVTRStateFlags::AVTR_ON);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?AVTROn@AircraftClass@@QAEXW4AVTRStateFlags@1@@Z ; AircraftClass::AVTROn

; 9369 : 		SimDriver.GetPlayerAircraft()->AVTROff(AircraftClass::AVTRStateFlags::AVTR_AUTO);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?AVTROff@AircraftClass@@QAEXW4AVTRStateFlags@1@@Z ; AircraftClass::AVTROff

; 9370 : 		SimDriver.GetPlayerAircraft()->AVTROff(AircraftClass::AVTRStateFlags::AVTR_OFF);	//just in case

	push	4
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?AVTROff@AircraftClass@@QAEXW4AVTRStateFlags@1@@Z ; AircraftClass::AVTROff

; 9371 : 		if(SimDriver.AVTROn() == FALSE)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?AVTROn@SimulationDriver@@QAEHXZ	; SimulationDriver::AVTROn
	test	eax, eax
	jne	SHORT $LN2@SimAVTRSwi

; 9372 : 		{
; 9373 : 			SimDriver.SetAVTR(TRUE);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?SetAVTR@SimulationDriver@@QAEXH@Z	; SimulationDriver::SetAVTR

; 9374 : 			ACMIToggleRecording ( val, state, pButton);

	mov	edx, DWORD PTR _pButton$[ebp]
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	mov	ecx, DWORD PTR _val$[ebp]
	push	ecx
	call	?ACMIToggleRecording@@YAXKHPAX@Z	; ACMIToggleRecording
	add	esp, 12					; 0000000cH
$LN2@SimAVTRSwi:

; 9375 : 		}
; 9376 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN5@SimAVTRSwi

; 9377 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_AVTR_SW, 4);

	push	4
	push	173					; 000000adH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN5@SimAVTRSwi:

; 9378 : 	}
; 9379 : }

	pop	ebp
	ret	0
?SimAVTRSwitchOn@@YAXKHPAX@Z ENDP			; SimAVTRSwitchOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
_pButton$ = 16						; size = 4
?SimAVTRSwitchAuto@@YAXKHPAX@Z PROC			; SimAVTRSwitchAuto

; 9347 : {

	push	ebp
	mov	ebp, esp

; 9348 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimAVTRSwi

; 9349 : 		return;

	jmp	$LN4@SimAVTRSwi
$LN3@SimAVTRSwi:

; 9350 : 
; 9351 : 	if((state & KEY_DOWN) && (SimDriver.GetPlayerAircraft()) && (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)))

	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	$LN4@SimAVTRSwi
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimAVTRSwi
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimAVTRSwi

; 9352 : 	{
; 9353 : 		SimDriver.GetPlayerAircraft()->AVTROn(AircraftClass::AVTRStateFlags::AVTR_AUTO);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?AVTROn@AircraftClass@@QAEXW4AVTRStateFlags@1@@Z ; AircraftClass::AVTROn

; 9354 : 		SimDriver.GetPlayerAircraft()->AVTROff(AircraftClass::AVTRStateFlags::AVTR_OFF);

	push	4
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?AVTROff@AircraftClass@@QAEXW4AVTRStateFlags@1@@Z ; AircraftClass::AVTROff

; 9355 : 		SimDriver.GetPlayerAircraft()->AVTROff(AircraftClass::AVTRStateFlags::AVTR_ON);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?AVTROff@AircraftClass@@QAEXW4AVTRStateFlags@1@@Z ; AircraftClass::AVTROff

; 9356 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimAVTRSwi

; 9357 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_AVTR_SW, 2);

	push	2
	push	173					; 000000adH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimAVTRSwi:

; 9358 : 	}
; 9359 : }

	pop	ebp
	ret	0
?SimAVTRSwitchAuto@@YAXKHPAX@Z ENDP			; SimAVTRSwitchAuto
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
_pButton$ = 16						; size = 4
?SimAVTRSwitchOff@@YAXKHPAX@Z PROC			; SimAVTRSwitchOff

; 9327 : {

	push	ebp
	mov	ebp, esp

; 9328 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN4@SimAVTRSwi

; 9329 : 		return;

	jmp	$LN5@SimAVTRSwi
$LN4@SimAVTRSwi:

; 9330 : 
; 9331 : 	if((state & KEY_DOWN) && (SimDriver.GetPlayerAircraft()) && (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)))

	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	$LN5@SimAVTRSwi
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN5@SimAVTRSwi
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN5@SimAVTRSwi

; 9332 : 	{
; 9333 : 		SimDriver.GetPlayerAircraft()->AVTROn(AircraftClass::AVTRStateFlags::AVTR_OFF);

	push	4
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?AVTROn@AircraftClass@@QAEXW4AVTRStateFlags@1@@Z ; AircraftClass::AVTROn

; 9334 : 		SimDriver.GetPlayerAircraft()->AVTROff(AircraftClass::AVTRStateFlags::AVTR_ON);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?AVTROff@AircraftClass@@QAEXW4AVTRStateFlags@1@@Z ; AircraftClass::AVTROff

; 9335 : 		SimDriver.GetPlayerAircraft()->AVTROff(AircraftClass::AVTRStateFlags::AVTR_AUTO);	//just in case

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?AVTROff@AircraftClass@@QAEXW4AVTRStateFlags@1@@Z ; AircraftClass::AVTROff

; 9336 : 		if(SimDriver.AVTROn() == TRUE) 

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?AVTROn@SimulationDriver@@QAEHXZ	; SimulationDriver::AVTROn
	cmp	eax, 1
	jne	SHORT $LN2@SimAVTRSwi

; 9337 : 		{
; 9338 : 			SimDriver.SetAVTR(FALSE);

	push	0
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?SetAVTR@SimulationDriver@@QAEXH@Z	; SimulationDriver::SetAVTR

; 9339 : 			ACMIToggleRecording( val, state, pButton);

	mov	edx, DWORD PTR _pButton$[ebp]
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	mov	ecx, DWORD PTR _val$[ebp]
	push	ecx
	call	?ACMIToggleRecording@@YAXKHPAX@Z	; ACMIToggleRecording
	add	esp, 12					; 0000000cH
$LN2@SimAVTRSwi:

; 9340 : 		}
; 9341 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN5@SimAVTRSwi

; 9342 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_AVTR_SW, 1);

	push	1
	push	173					; 000000adH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN5@SimAVTRSwi:

; 9343 : 	}
; 9344 : }

	pop	ebp
	ret	0
?SimAVTRSwitchOff@@YAXKHPAX@Z ENDP			; SimAVTRSwitchOff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
_pButton$ = 16						; size = 4
?SimAVTRSwitch@@YAXKHPAX@Z PROC				; SimAVTRSwitch

; 9279 : {

	push	ebp
	mov	ebp, esp

; 9280 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN11@SimAVTRSwi

; 9281 : 		return;

	jmp	$LN12@SimAVTRSwi
$LN11@SimAVTRSwi:

; 9282 : 
; 9283 : 	if((state & KEY_DOWN) && (SimDriver.GetPlayerAircraft()) && (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)))

	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	$LN12@SimAVTRSwi
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN12@SimAVTRSwi
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN12@SimAVTRSwi

; 9284 : 	{
; 9285 : 		//off-auto-on
; 9286 : 		if(SimDriver.GetPlayerAircraft()->AVTRState(AircraftClass::AVTRStateFlags::AVTR_OFF))

	push	4
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?AVTRState@AircraftClass@@QAEHW4AVTRStateFlags@1@@Z ; AircraftClass::AVTRState
	test	eax, eax
	je	SHORT $LN9@SimAVTRSwi

; 9287 : 		{
; 9288 : 			SimDriver.GetPlayerAircraft()->AVTROn(AircraftClass::AVTRStateFlags::AVTR_AUTO);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?AVTROn@AircraftClass@@QAEXW4AVTRStateFlags@1@@Z ; AircraftClass::AVTROn

; 9289 : 			SimDriver.GetPlayerAircraft()->AVTROff(AircraftClass::AVTRStateFlags::AVTR_OFF);

	push	4
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?AVTROff@AircraftClass@@QAEXW4AVTRStateFlags@1@@Z ; AircraftClass::AVTROff

; 9290 : 			SimDriver.GetPlayerAircraft()->AVTROff(AircraftClass::AVTRStateFlags::AVTR_ON);	//just in case

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?AVTROff@AircraftClass@@QAEXW4AVTRStateFlags@1@@Z ; AircraftClass::AVTROff

; 9291 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN8@SimAVTRSwi

; 9292 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_AVTR_SW, 2);

	push	2
	push	173					; 000000adH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN8@SimAVTRSwi:

; 9293 : 		}

	jmp	$LN12@SimAVTRSwi
$LN9@SimAVTRSwi:

; 9294 : 		else if(SimDriver.GetPlayerAircraft()->AVTRState(AircraftClass::AVTRStateFlags::AVTR_AUTO))

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?AVTRState@AircraftClass@@QAEHW4AVTRStateFlags@1@@Z ; AircraftClass::AVTRState
	test	eax, eax
	je	$LN6@SimAVTRSwi

; 9295 : 		{
; 9296 : 			SimDriver.GetPlayerAircraft()->AVTROn(AircraftClass::AVTRStateFlags::AVTR_ON);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?AVTROn@AircraftClass@@QAEXW4AVTRStateFlags@1@@Z ; AircraftClass::AVTROn

; 9297 : 			SimDriver.GetPlayerAircraft()->AVTROff(AircraftClass::AVTRStateFlags::AVTR_AUTO);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?AVTROff@AircraftClass@@QAEXW4AVTRStateFlags@1@@Z ; AircraftClass::AVTROff

; 9298 : 			SimDriver.GetPlayerAircraft()->AVTROff(AircraftClass::AVTRStateFlags::AVTR_OFF);	//just in case

	push	4
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?AVTROff@AircraftClass@@QAEXW4AVTRStateFlags@1@@Z ; AircraftClass::AVTROff

; 9299 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN5@SimAVTRSwi

; 9300 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_AVTR_SW, 4);

	push	4
	push	173					; 000000adH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN5@SimAVTRSwi:

; 9301 : 			if(SimDriver.AVTROn() == FALSE)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?AVTROn@SimulationDriver@@QAEHXZ	; SimulationDriver::AVTROn
	test	eax, eax
	jne	SHORT $LN4@SimAVTRSwi

; 9302 : 			{
; 9303 : 				SimDriver.SetAVTR(TRUE);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?SetAVTR@SimulationDriver@@QAEXH@Z	; SimulationDriver::SetAVTR

; 9304 : 				ACMIToggleRecording ( val, state, pButton);

	mov	edx, DWORD PTR _pButton$[ebp]
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	mov	ecx, DWORD PTR _val$[ebp]
	push	ecx
	call	?ACMIToggleRecording@@YAXKHPAX@Z	; ACMIToggleRecording
	add	esp, 12					; 0000000cH
$LN4@SimAVTRSwi:

; 9305 : 			}
; 9306 : 		}
; 9307 : 		else

	jmp	$LN12@SimAVTRSwi
$LN6@SimAVTRSwi:

; 9308 : 		{
; 9309 : 			SimDriver.GetPlayerAircraft()->AVTROn(AircraftClass::AVTRStateFlags::AVTR_OFF);

	push	4
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?AVTROn@AircraftClass@@QAEXW4AVTRStateFlags@1@@Z ; AircraftClass::AVTROn

; 9310 : 			SimDriver.GetPlayerAircraft()->AVTROff(AircraftClass::AVTRStateFlags::AVTR_ON);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?AVTROff@AircraftClass@@QAEXW4AVTRStateFlags@1@@Z ; AircraftClass::AVTROff

; 9311 : 			SimDriver.GetPlayerAircraft()->AVTROff(AircraftClass::AVTRStateFlags::AVTR_AUTO);	//just in case

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?AVTROff@AircraftClass@@QAEXW4AVTRStateFlags@1@@Z ; AircraftClass::AVTROff

; 9312 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN2@SimAVTRSwi

; 9313 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_AVTR_SW, 1);

	push	1
	push	173					; 000000adH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN2@SimAVTRSwi:

; 9314 : 			if(SimDriver.AVTROn() == TRUE) 

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?AVTROn@SimulationDriver@@QAEHXZ	; SimulationDriver::AVTROn
	cmp	eax, 1
	jne	SHORT $LN12@SimAVTRSwi

; 9315 : 			{
; 9316 : 				SimDriver.SetAVTR(FALSE);

	push	0
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?SetAVTR@SimulationDriver@@QAEXH@Z	; SimulationDriver::SetAVTR

; 9317 : 				ACMIToggleRecording( val, state, pButton);

	mov	edx, DWORD PTR _pButton$[ebp]
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	mov	ecx, DWORD PTR _val$[ebp]
	push	ecx
	call	?ACMIToggleRecording@@YAXKHPAX@Z	; ACMIToggleRecording
	add	esp, 12					; 0000000cH
$LN12@SimAVTRSwi:

; 9318 : 			}
; 9319 : 		}		
; 9320 : 	}
; 9321 : }

	pop	ebp
	ret	0
?SimAVTRSwitch@@YAXKHPAX@Z ENDP				; SimAVTRSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimDMSRight@@YAXKHPAX@Z PROC				; SimDMSRight

; 9267 : {

	push	ebp
	mov	ebp, esp

; 9268 : 	if((state & KEY_DOWN) && (SimDriver.GetPlayerAircraft()) && (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)))

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN4@SimDMSRigh
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN4@SimDMSRigh
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimDMSRigh

; 9269 : 	{
; 9270 : 		MfdDisplay[1]->changeMode = TRUE_NEXT;

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	mov	BYTE PTR [edx+4], 1

; 9271 : 		if(SimDriver.GetPlayerAircraft()->FCC && SimDriver.GetPlayerAircraft()->FCC->IsSOI && g_bRealisticAvionics)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+936], 0
	je	SHORT $LN4@SimDMSRigh
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	eax, DWORD PTR [eax+936]
	movzx	ecx, BYTE PTR [eax+464]
	test	ecx, ecx
	je	SHORT $LN4@SimDMSRigh
	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	SHORT $LN4@SimDMSRigh

; 9272 : 		{ 
; 9273 : 		  if(MfdDisplay[1]->CurMode() == MFDClass::FCCMode)

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[eax]
	call	?CurMode@MFDClass@@QAE?AW4MfdMode@1@XZ	; MFDClass::CurMode
	cmp	eax, 9
	jne	SHORT $LN4@SimDMSRigh

; 9274 : 			  SimDriver.GetPlayerAircraft()->StepSOI(2);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?StepSOI@SimVehicleClass@@QAEXH@Z	; SimVehicleClass::StepSOI
$LN4@SimDMSRigh:

; 9275 : 		} 
; 9276 : 	}
; 9277 : }

	pop	ebp
	ret	0
?SimDMSRight@@YAXKHPAX@Z ENDP				; SimDMSRight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimDMSDown@@YAXKHPAX@Z PROC				; SimDMSDown

; 9256 : {

	push	ebp
	mov	ebp, esp

; 9257 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN2@SimDMSDown

; 9258 : 		return;

	jmp	SHORT $LN3@SimDMSDown
$LN2@SimDMSDown:

; 9259 : 
; 9260 : 	//Down toggles between MFD's
; 9261 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimDMSDown
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimDMSDown
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN3@SimDMSDown

; 9262 : 	{
; 9263 : 		SimDriver.GetPlayerAircraft()->StepSOI(2);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?StepSOI@SimVehicleClass@@QAEXH@Z	; SimVehicleClass::StepSOI
$LN3@SimDMSDown:

; 9264 : 	}
; 9265 : }

	pop	ebp
	ret	0
?SimDMSDown@@YAXKHPAX@Z ENDP				; SimDMSDown
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimDMSLeft@@YAXKHPAX@Z PROC				; SimDMSLeft

; 9240 : {

	push	ebp
	mov	ebp, esp

; 9241 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN4@SimDMSLeft

; 9242 : 		return;

	jmp	$LN5@SimDMSLeft
$LN4@SimDMSLeft:

; 9243 : 
; 9244 : 	if ((state & KEY_DOWN) && (SimDriver.GetPlayerAircraft()) && (SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)))

	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	$LN5@SimDMSLeft
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN5@SimDMSLeft
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN5@SimDMSLeft

; 9245 : 	{
; 9246 : 		MfdDisplay[0]->changeMode = TRUE_NEXT;

	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[edx]
	mov	BYTE PTR [eax+4], 1

; 9247 : 		if(SimDriver.GetPlayerAircraft()->FCC && SimDriver.GetPlayerAircraft()->FCC->IsSOI && g_bRealisticAvionics)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+936], 0
	je	SHORT $LN5@SimDMSLeft
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	movzx	edx, BYTE PTR [ecx+464]
	test	edx, edx
	je	SHORT $LN5@SimDMSLeft
	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN5@SimDMSLeft

; 9248 : 		{ 
; 9249 : 			if(MfdDisplay[0]->CurMode() == MFDClass::FCCMode)

	mov	ecx, 4
	imul	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?CurMode@MFDClass@@QAE?AW4MfdMode@1@XZ	; MFDClass::CurMode
	cmp	eax, 9
	jne	SHORT $LN5@SimDMSLeft

; 9250 : 				SimDriver.GetPlayerAircraft()->StepSOI(2);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?StepSOI@SimVehicleClass@@QAEXH@Z	; SimVehicleClass::StepSOI
$LN5@SimDMSLeft:

; 9251 : 		}
; 9252 : 	}		
; 9253 : }

	pop	ebp
	ret	0
?SimDMSLeft@@YAXKHPAX@Z ENDP				; SimDMSLeft
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimDMSUp@@YAXKHPAX@Z PROC				; SimDMSUp

; 9229 : {

	push	ebp
	mov	ebp, esp

; 9230 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN2@SimDMSUp

; 9231 : 		return;

	jmp	SHORT $LN3@SimDMSUp
$LN2@SimDMSUp:

; 9232 : 
; 9233 : 	//Up always goes to the HUD (where possible)
; 9234 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimDMSUp
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimDMSUp
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN3@SimDMSUp

; 9235 : 	{
; 9236 : 		SimDriver.GetPlayerAircraft()->StepSOI(1);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?StepSOI@SimVehicleClass@@QAEXH@Z	; SimVehicleClass::StepSOI
$LN3@SimDMSUp:

; 9237 : 	}
; 9238 : }

	pop	ebp
	ret	0
?SimDMSUp@@YAXKHPAX@Z ENDP				; SimDMSUp
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimWingLightOff@@YAXKHPAX@Z PROC			; SimWingLightOff

; 9158 : {

	push	ebp
	mov	ebp, esp

; 9159 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimWingLig

; 9160 : 		return;

	jmp	$LN4@SimWingLig
$LN3@SimWingLig:

; 9161 : 
; 9162 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)
; 9163 : 		&& SimDriver.GetPlayerAircraft()->af->IsSet(AirframeClass::HasComplexGear))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN4@SimWingLig
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimWingLig
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimWingLig
	push	16777216				; 01000000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN4@SimWingLig

; 9164 : 	{    
; 9165 : 		SimDriver.GetPlayerAircraft()->ClearAcStatusBits(AircraftClass::ACSTATUS_EXT_NAVLIGHTS);

	push	8
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?ClearAcStatusBits@AircraftClass@@QAEXH@Z ; AircraftClass::ClearAcStatusBits

; 9166 : 		SimDriver.GetPlayerAircraft()->ExtlOff(AircraftClass::ExtlLightFlags::Extl_Wing_Tail);

	push	8
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?ExtlOff@AircraftClass@@QAEXW4ExtlLightFlags@1@@Z ; AircraftClass::ExtlOff

; 9167 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimWingLig

; 9168 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_EXT_WING, 1);

	push	1
	push	189					; 000000bdH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimWingLig:

; 9169 : 	}
; 9170 : }

	pop	ebp
	ret	0
?SimWingLightOff@@YAXKHPAX@Z ENDP			; SimWingLightOff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimWingLightBrt@@YAXKHPAX@Z PROC			; SimWingLightBrt

; 9143 : {

	push	ebp
	mov	ebp, esp

; 9144 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimWingLig

; 9145 : 		return;

	jmp	$LN4@SimWingLig
$LN3@SimWingLig:

; 9146 : 
; 9147 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)
; 9148 : 		&& SimDriver.GetPlayerAircraft()->af->IsSet(AirframeClass::HasComplexGear))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN4@SimWingLig
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimWingLig
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimWingLig
	push	16777216				; 01000000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN4@SimWingLig

; 9149 : 	{    
; 9150 : 		SimDriver.GetPlayerAircraft()->SetAcStatusBits(AircraftClass::ACSTATUS_EXT_NAVLIGHTS);

	push	8
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetAcStatusBits@AircraftClass@@QAEXH@Z	; AircraftClass::SetAcStatusBits

; 9151 : 		SimDriver.GetPlayerAircraft()->ExtlOn(AircraftClass::ExtlLightFlags::Extl_Wing_Tail);

	push	8
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?ExtlOn@AircraftClass@@QAEXW4ExtlLightFlags@1@@Z ; AircraftClass::ExtlOn

; 9152 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimWingLig

; 9153 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_EXT_WING, 4);

	push	4
	push	189					; 000000bdH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimWingLig:

; 9154 : 	}
; 9155 : }

	pop	ebp
	ret	0
?SimWingLightBrt@@YAXKHPAX@Z ENDP			; SimWingLightBrt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_ac$1 = -4						; size = 4
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimExtlWing@@YAXKHPAX@Z PROC				; SimExtlWing

; 9112 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 9113 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN6@SimExtlWin

; 9114 : 		return;

	jmp	$LN7@SimExtlWin
$LN6@SimExtlWin:

; 9115 : 
; 9116 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)
; 9117 : 		&& SimDriver.GetPlayerAircraft()->af->IsSet(AirframeClass::HasComplexGear))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN7@SimExtlWin
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN7@SimExtlWin
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	$LN7@SimExtlWin
	push	16777216				; 01000000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	$LN7@SimExtlWin

; 9118 : 	{    
; 9119 : 		AircraftClass *ac = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _ac$1[ebp], eax

; 9120 : 
; 9121 : 		if(ac->ExtlState(AircraftClass::ExtlLightFlags::Extl_Wing_Tail))

	push	8
	mov	ecx, DWORD PTR _ac$1[ebp]
	call	?ExtlState@AircraftClass@@QBEHW4ExtlLightFlags@1@@Z ; AircraftClass::ExtlState
	test	eax, eax
	je	SHORT $LN4@SimExtlWin

; 9122 : 		{
; 9123 : 			ac->ClearAcStatusBits(AircraftClass::ACSTATUS_EXT_NAVLIGHTS);

	push	8
	mov	ecx, DWORD PTR _ac$1[ebp]
	call	?ClearAcStatusBits@AircraftClass@@QAEXH@Z ; AircraftClass::ClearAcStatusBits

; 9124 : 		  ac->ExtlOff(AircraftClass::ExtlLightFlags::Extl_Wing_Tail);

	push	8
	mov	ecx, DWORD PTR _ac$1[ebp]
	call	?ExtlOff@AircraftClass@@QAEXW4ExtlLightFlags@1@@Z ; AircraftClass::ExtlOff

; 9125 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN3@SimExtlWin

; 9126 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_EXT_WING, 1);

	push	1
	push	189					; 000000bdH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN3@SimExtlWin:

; 9127 : 		}
; 9128 : 		else

	jmp	SHORT $LN7@SimExtlWin
$LN4@SimExtlWin:

; 9129 : 		{
; 9130 : 			ac->SetAcStatusBits(AircraftClass::ACSTATUS_EXT_NAVLIGHTS);

	push	8
	mov	ecx, DWORD PTR _ac$1[ebp]
	call	?SetAcStatusBits@AircraftClass@@QAEXH@Z	; AircraftClass::SetAcStatusBits

; 9131 : 			ac->ExtlOn(AircraftClass::ExtlLightFlags::Extl_Wing_Tail);

	push	8
	mov	ecx, DWORD PTR _ac$1[ebp]
	call	?ExtlOn@AircraftClass@@QAEXW4ExtlLightFlags@1@@Z ; AircraftClass::ExtlOn

; 9132 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN7@SimExtlWin

; 9133 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_EXT_WING, 2);

	push	2
	push	189					; 000000bdH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN7@SimExtlWin:

; 9134 : 		}
; 9135 : 	}
; 9136 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimExtlWing@@YAXKHPAX@Z ENDP				; SimExtlWing
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimLightsFlash@@YAXKHPAX@Z PROC			; SimLightsFlash

; 9214 : {

	push	ebp
	mov	ebp, esp

; 9215 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimLightsF

; 9216 : 		return;

	jmp	$LN4@SimLightsF
$LN3@SimLightsF:

; 9217 : 
; 9218 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN) 
; 9219 : 		&& SimDriver.GetPlayerAircraft()->af->IsSet(AirframeClass::HasComplexGear))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimLightsF
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimLightsF
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimLightsF
	push	16777216				; 01000000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN4@SimLightsF

; 9220 : 	{
; 9221 : 		SimDriver.GetPlayerAircraft()->ExtlOn(AircraftClass::ExtlLightFlags::Extl_Flash);

	push	64					; 00000040H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?ExtlOn@AircraftClass@@QAEXW4ExtlLightFlags@1@@Z ; AircraftClass::ExtlOn

; 9222 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimLightsF

; 9223 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_EXT_FLASH, 2);

	push	2
	push	188					; 000000bcH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimLightsF:

; 9224 : 	}
; 9225 : }

	pop	ebp
	ret	0
?SimLightsFlash@@YAXKHPAX@Z ENDP			; SimLightsFlash
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimLightsSteady@@YAXKHPAX@Z PROC			; SimLightsSteady

; 9200 : {

	push	ebp
	mov	ebp, esp

; 9201 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimLightsS

; 9202 : 		return;

	jmp	$LN4@SimLightsS
$LN3@SimLightsS:

; 9203 : 
; 9204 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN) 
; 9205 : 		&& SimDriver.GetPlayerAircraft()->af->IsSet(AirframeClass::HasComplexGear))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimLightsS
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimLightsS
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimLightsS
	push	16777216				; 01000000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN4@SimLightsS

; 9206 : 	{
; 9207 : 		SimDriver.GetPlayerAircraft()->ExtlOff(AircraftClass::ExtlLightFlags::Extl_Flash);

	push	64					; 00000040H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?ExtlOff@AircraftClass@@QAEXW4ExtlLightFlags@1@@Z ; AircraftClass::ExtlOff

; 9208 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimLightsS

; 9209 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_EXT_FLASH, 1);

	push	1
	push	188					; 000000bcH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimLightsS:

; 9210 : 	}
; 9211 : }

	pop	ebp
	ret	0
?SimLightsSteady@@YAXKHPAX@Z ENDP			; SimLightsSteady
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_ac$1 = -4						; size = 4
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimExtlSteady@@YAXKHPAX@Z PROC				; SimExtlSteady

; 9173 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 9174 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN6@SimExtlSte

; 9175 : 		return;

	jmp	$LN7@SimExtlSte
$LN6@SimExtlSte:

; 9176 : 
; 9177 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)
; 9178 : 		&& SimDriver.GetPlayerAircraft()->af->IsSet(AirframeClass::HasComplexGear))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN7@SimExtlSte
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN7@SimExtlSte
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	$LN7@SimExtlSte
	push	16777216				; 01000000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN7@SimExtlSte

; 9179 : 	{    
; 9180 : 		AircraftClass *ac = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _ac$1[ebp], eax

; 9181 : 
; 9182 : 		if(ac->ExtlState(AircraftClass::ExtlLightFlags::Extl_Flash))

	push	64					; 00000040H
	mov	ecx, DWORD PTR _ac$1[ebp]
	call	?ExtlState@AircraftClass@@QBEHW4ExtlLightFlags@1@@Z ; AircraftClass::ExtlState
	test	eax, eax
	je	SHORT $LN4@SimExtlSte

; 9183 : 		{
; 9184 : 		  ac->ExtlOff(AircraftClass::ExtlLightFlags::Extl_Flash);

	push	64					; 00000040H
	mov	ecx, DWORD PTR _ac$1[ebp]
	call	?ExtlOff@AircraftClass@@QAEXW4ExtlLightFlags@1@@Z ; AircraftClass::ExtlOff

; 9185 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN3@SimExtlSte

; 9186 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_EXT_FLASH, 2);

	push	2
	push	188					; 000000bcH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN3@SimExtlSte:

; 9187 : 		}
; 9188 : 		else

	jmp	SHORT $LN7@SimExtlSte
$LN4@SimExtlSte:

; 9189 : 		{
; 9190 : 			ac->ExtlOn(AircraftClass::ExtlLightFlags::Extl_Flash);

	push	64					; 00000040H
	mov	ecx, DWORD PTR _ac$1[ebp]
	call	?ExtlOn@AircraftClass@@QAEXW4ExtlLightFlags@1@@Z ; AircraftClass::ExtlOn

; 9191 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN7@SimExtlSte

; 9192 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_EXT_FLASH, 1);

	push	1
	push	188					; 000000bcH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN7@SimExtlSte:

; 9193 : 		}
; 9194 : 	}
; 9195 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimExtlSteady@@YAXKHPAX@Z ENDP				; SimExtlSteady
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimAntiCollOff@@YAXKHPAX@Z PROC			; SimAntiCollOff

; 9096 : {

	push	ebp
	mov	ebp, esp

; 9097 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimAntiCol

; 9098 : 		return;

	jmp	$LN4@SimAntiCol
$LN3@SimAntiCol:

; 9099 : 
; 9100 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN) 
; 9101 : 		&& SimDriver.GetPlayerAircraft()->af->IsSet(AirframeClass::HasComplexGear))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN4@SimAntiCol
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN4@SimAntiCol
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimAntiCol
	push	16777216				; 01000000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN4@SimAntiCol

; 9102 : 	{
; 9103 : 		SimDriver.GetPlayerAircraft()->SetSwitch(COMP_TAIL_STROBE, FALSE);

	push	0
	push	7
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetSwitch@SimMoverClass@@QAEXHH@Z	; SimMoverClass::SetSwitch

; 9104 : 		SimDriver.GetPlayerAircraft()->ClearAcStatusBits(AircraftClass::ACSTATUS_EXT_TAILSTROBE);

	push	16					; 00000010H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?ClearAcStatusBits@AircraftClass@@QAEXH@Z ; AircraftClass::ClearAcStatusBits

; 9105 : 		SimDriver.GetPlayerAircraft()->ExtlOff(AircraftClass::ExtlLightFlags::Extl_Anti_Coll);

	push	16					; 00000010H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?ExtlOff@AircraftClass@@QAEXW4ExtlLightFlags@1@@Z ; AircraftClass::ExtlOff

; 9106 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimAntiCol

; 9107 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_ANTI_COLL, 1);

	push	1
	push	187					; 000000bbH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimAntiCol:

; 9108 : 	}
; 9109 : }

	pop	ebp
	ret	0
?SimAntiCollOff@@YAXKHPAX@Z ENDP			; SimAntiCollOff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimAntiCollOn@@YAXKHPAX@Z PROC				; SimAntiCollOn

; 9080 : {

	push	ebp
	mov	ebp, esp

; 9081 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimAntiCol

; 9082 : 		return;

	jmp	$LN4@SimAntiCol
$LN3@SimAntiCol:

; 9083 : 
; 9084 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN) 
; 9085 : 		&& SimDriver.GetPlayerAircraft()->af->IsSet(AirframeClass::HasComplexGear))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN4@SimAntiCol
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN4@SimAntiCol
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimAntiCol
	push	16777216				; 01000000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN4@SimAntiCol

; 9086 : 	{
; 9087 : 		SimDriver.GetPlayerAircraft()->SetSwitch(COMP_TAIL_STROBE, TRUE);

	push	1
	push	7
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetSwitch@SimMoverClass@@QAEXHH@Z	; SimMoverClass::SetSwitch

; 9088 : 		SimDriver.GetPlayerAircraft()->SetAcStatusBits(AircraftClass::ACSTATUS_EXT_TAILSTROBE);

	push	16					; 00000010H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetAcStatusBits@AircraftClass@@QAEXH@Z	; AircraftClass::SetAcStatusBits

; 9089 : 		SimDriver.GetPlayerAircraft()->ExtlOn(AircraftClass::ExtlLightFlags::Extl_Anti_Coll);

	push	16					; 00000010H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?ExtlOn@AircraftClass@@QAEXW4ExtlLightFlags@1@@Z ; AircraftClass::ExtlOn

; 9090 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimAntiCol

; 9091 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_ANTI_COLL, 2);

	push	2
	push	187					; 000000bbH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimAntiCol:

; 9092 : 	}
; 9093 : }

	pop	ebp
	ret	0
?SimAntiCollOn@@YAXKHPAX@Z ENDP				; SimAntiCollOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_ac$1 = -4						; size = 4
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimExtlAntiColl@@YAXKHPAX@Z PROC			; SimExtlAntiColl

; 9049 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 9050 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN6@SimExtlAnt

; 9051 : 		return;

	jmp	$LN7@SimExtlAnt
$LN6@SimExtlAnt:

; 9052 : 
; 9053 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN) 
; 9054 : 		&& SimDriver.GetPlayerAircraft()->af->IsSet(AirframeClass::HasComplexGear))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN7@SimExtlAnt
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN7@SimExtlAnt
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	$LN7@SimExtlAnt
	push	16777216				; 01000000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	$LN7@SimExtlAnt

; 9055 : 	{
; 9056 : 		AircraftClass *ac = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _ac$1[ebp], eax

; 9057 : 
; 9058 : 		if(ac->ExtlState(AircraftClass::ExtlLightFlags::Extl_Anti_Coll))

	push	16					; 00000010H
	mov	ecx, DWORD PTR _ac$1[ebp]
	call	?ExtlState@AircraftClass@@QBEHW4ExtlLightFlags@1@@Z ; AircraftClass::ExtlState
	test	eax, eax
	je	SHORT $LN4@SimExtlAnt

; 9059 : 		{
; 9060 : 			ac->SetSwitch(COMP_TAIL_STROBE, FALSE);

	push	0
	push	7
	mov	ecx, DWORD PTR _ac$1[ebp]
	call	?SetSwitch@SimMoverClass@@QAEXHH@Z	; SimMoverClass::SetSwitch

; 9061 : 			ac->ClearAcStatusBits(AircraftClass::ACSTATUS_EXT_TAILSTROBE);

	push	16					; 00000010H
	mov	ecx, DWORD PTR _ac$1[ebp]
	call	?ClearAcStatusBits@AircraftClass@@QAEXH@Z ; AircraftClass::ClearAcStatusBits

; 9062 : 			ac->ExtlOff(AircraftClass::ExtlLightFlags::Extl_Anti_Coll);

	push	16					; 00000010H
	mov	ecx, DWORD PTR _ac$1[ebp]
	call	?ExtlOff@AircraftClass@@QAEXW4ExtlLightFlags@1@@Z ; AircraftClass::ExtlOff

; 9063 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN3@SimExtlAnt

; 9064 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_ANTI_COLL, 2);

	push	2
	push	187					; 000000bbH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN3@SimExtlAnt:

; 9065 : 		}
; 9066 : 		else

	jmp	SHORT $LN7@SimExtlAnt
$LN4@SimExtlAnt:

; 9067 : 		{
; 9068 : 			ac->SetSwitch(COMP_TAIL_STROBE, TRUE);

	push	1
	push	7
	mov	ecx, DWORD PTR _ac$1[ebp]
	call	?SetSwitch@SimMoverClass@@QAEXHH@Z	; SimMoverClass::SetSwitch

; 9069 : 			ac->SetAcStatusBits(AircraftClass::ACSTATUS_EXT_TAILSTROBE);

	push	16					; 00000010H
	mov	ecx, DWORD PTR _ac$1[ebp]
	call	?SetAcStatusBits@AircraftClass@@QAEXH@Z	; AircraftClass::SetAcStatusBits

; 9070 : 			ac->ExtlOn(AircraftClass::ExtlLightFlags::Extl_Anti_Coll);

	push	16					; 00000010H
	mov	ecx, DWORD PTR _ac$1[ebp]
	call	?ExtlOn@AircraftClass@@QAEXW4ExtlLightFlags@1@@Z ; AircraftClass::ExtlOn

; 9071 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN7@SimExtlAnt

; 9072 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_ANTI_COLL, 1);

	push	1
	push	187					; 000000bbH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN7@SimExtlAnt:

; 9073 : 		}
; 9074 : 	}
; 9075 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimExtlAntiColl@@YAXKHPAX@Z ENDP			; SimExtlAntiColl
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimExtlMasterOff@@YAXKHPAX@Z PROC			; SimExtlMasterOff

; 9035 : {

	push	ebp
	mov	ebp, esp

; 9036 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimExtlMas

; 9037 : 		return;

	jmp	$LN4@SimExtlMas
$LN3@SimExtlMas:

; 9038 : 
; 9039 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)
; 9040 :     && SimDriver.GetPlayerAircraft()->af->IsSet(AirframeClass::HasComplexGear))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimExtlMas
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimExtlMas
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimExtlMas
	push	16777216				; 01000000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN4@SimExtlMas

; 9041 : 	{  
; 9042 : 		SimDriver.GetPlayerAircraft()->ExtlOff(AircraftClass::ExtlLightFlags::Extl_Main_Power);

	push	4
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?ExtlOff@AircraftClass@@QAEXW4ExtlLightFlags@1@@Z ; AircraftClass::ExtlOff

; 9043 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimExtlMas

; 9044 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_EXT_LITE_MSTR, 1);

	push	1
	push	186					; 000000baH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimExtlMas:

; 9045 : 	}
; 9046 : }

	pop	ebp
	ret	0
?SimExtlMasterOff@@YAXKHPAX@Z ENDP			; SimExtlMasterOff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimExtlMasterNorm@@YAXKHPAX@Z PROC			; SimExtlMasterNorm

; 9021 : {

	push	ebp
	mov	ebp, esp

; 9022 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimExtlMas

; 9023 : 		return;

	jmp	$LN4@SimExtlMas
$LN3@SimExtlMas:

; 9024 : 
; 9025 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)
; 9026 : 		&& SimDriver.GetPlayerAircraft()->af->IsSet(AirframeClass::HasComplexGear))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimExtlMas
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimExtlMas
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimExtlMas
	push	16777216				; 01000000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN4@SimExtlMas

; 9027 : 	{  
; 9028 : 		SimDriver.GetPlayerAircraft()->ExtlOn(AircraftClass::ExtlLightFlags::Extl_Main_Power);

	push	4
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?ExtlOn@AircraftClass@@QAEXW4ExtlLightFlags@1@@Z ; AircraftClass::ExtlOn

; 9029 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimExtlMas

; 9030 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_EXT_LITE_MSTR, 2);

	push	2
	push	186					; 000000baH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimExtlMas:

; 9031 : 	}
; 9032 : }

	pop	ebp
	ret	0
?SimExtlMasterNorm@@YAXKHPAX@Z ENDP			; SimExtlMasterNorm
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_ac$1 = -4						; size = 4
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimExtlPower@@YAXKHPAX@Z PROC				; SimExtlPower

; 8994 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 8995 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN6@SimExtlPow

; 8996 : 		return;

	jmp	$LN7@SimExtlPow
$LN6@SimExtlPow:

; 8997 : 
; 8998 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)
; 8999 : 		&& SimDriver.GetPlayerAircraft()->af->IsSet(AirframeClass::HasComplexGear))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN7@SimExtlPow
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN7@SimExtlPow
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	$LN7@SimExtlPow
	push	16777216				; 01000000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN7@SimExtlPow

; 9000 : 	{  
; 9001 : 		AircraftClass *ac = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _ac$1[ebp], eax

; 9002 : 
; 9003 : 		if(ac->ExtlState(AircraftClass::ExtlLightFlags::Extl_Main_Power))

	push	4
	mov	ecx, DWORD PTR _ac$1[ebp]
	call	?ExtlState@AircraftClass@@QBEHW4ExtlLightFlags@1@@Z ; AircraftClass::ExtlState
	test	eax, eax
	je	SHORT $LN4@SimExtlPow

; 9004 : 		{
; 9005 : 			ac->ExtlOff(AircraftClass::ExtlLightFlags::Extl_Main_Power);

	push	4
	mov	ecx, DWORD PTR _ac$1[ebp]
	call	?ExtlOff@AircraftClass@@QAEXW4ExtlLightFlags@1@@Z ; AircraftClass::ExtlOff

; 9006 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN3@SimExtlPow

; 9007 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_EXT_LITE_MSTR, 1);

	push	1
	push	186					; 000000baH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN3@SimExtlPow:

; 9008 : 		}
; 9009 : 		else

	jmp	SHORT $LN7@SimExtlPow
$LN4@SimExtlPow:

; 9010 : 		{
; 9011 : 			ac->ExtlOn(AircraftClass::ExtlLightFlags::Extl_Main_Power);	

	push	4
	mov	ecx, DWORD PTR _ac$1[ebp]
	call	?ExtlOn@AircraftClass@@QAEXW4ExtlLightFlags@1@@Z ; AircraftClass::ExtlOn

; 9012 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN7@SimExtlPow

; 9013 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_EXT_LITE_MSTR, 2);

	push	2
	push	186					; 000000baH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN7@SimExtlPow:

; 9014 : 		}
; 9015 : 	}
; 9016 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimExtlPower@@YAXKHPAX@Z ENDP				; SimExtlPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv132 = -4						; size = 4
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimGndJettOff@@YAXKHPAX@Z PROC				; SimGndJettOff

; 8937 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 8938 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN4@SimGndJett

; 8939 : 		return;

	jmp	$LN5@SimGndJett
$LN4@SimGndJett:

; 8940 : 
; 8941 :     if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN5@SimGndJett
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN5@SimGndJett
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN5@SimGndJett

; 8942 :     {
; 8943 : 		if(SimDriver.GetPlayerAircraft()->Sms)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+940], 0
	je	SHORT $LN5@SimGndJett

; 8944 : 		{
; 8945 : 			SimDriver.GetPlayerAircraft()->Sms->GndJett = FALSE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+940]
	mov	BYTE PTR [edx+13], 0

; 8946 : 			if(SimDriver.GetPlayerAircraft()->OnGround())  // Jammer is disabled when on the ground unless GND JETT is enabled

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR tv132[ebp], eax
	mov	eax, DWORD PTR tv132[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv132[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	je	SHORT $LN5@SimGndJett

; 8947 : 				SimDriver.GetPlayerAircraft()->UnSetFlag(ECM_ON);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?UnSetFlag@SimBaseClass@@QAEXH@Z	; SimBaseClass::UnSetFlag
$LN5@SimGndJett:

; 8948 : 		}
; 8949 : 	}
; 8950 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimGndJettOff@@YAXKHPAX@Z ENDP				; SimGndJettOff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimGndJettOn@@YAXKHPAX@Z PROC				; SimGndJettOn

; 8923 : {

	push	ebp
	mov	ebp, esp

; 8924 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimGndJett

; 8925 : 		return;

	jmp	SHORT $LN4@SimGndJett
$LN3@SimGndJett:

; 8926 : 
; 8927 :     if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimGndJett
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimGndJett
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimGndJett

; 8928 :     {
; 8929 : 		if(SimDriver.GetPlayerAircraft()->Sms)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+940], 0
	je	SHORT $LN4@SimGndJett

; 8930 : 		{
; 8931 : 			SimDriver.GetPlayerAircraft()->Sms->GndJett = TRUE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+940]
	mov	BYTE PTR [edx+13], 1
$LN4@SimGndJett:

; 8932 : 		}
; 8933 : 	}
; 8934 : }

	pop	ebp
	ret	0
?SimGndJettOn@@YAXKHPAX@Z ENDP				; SimGndJettOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv142 = -4						; size = 4
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimGndJettEnable@@YAXKHPAX@Z PROC			; SimGndJettEnable

; 8899 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 8900 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN6@SimGndJett

; 8901 : 		return;

	jmp	$LN7@SimGndJett
$LN6@SimGndJett:

; 8902 : 
; 8903 :     if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN7@SimGndJett
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN7@SimGndJett
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	$LN7@SimGndJett

; 8904 :     {
; 8905 : 		if(SimDriver.GetPlayerAircraft()->Sms)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+940], 0
	je	SHORT $LN7@SimGndJett

; 8906 : 		{
; 8907 : 			if(SimDriver.GetPlayerAircraft()->Sms->GndJett)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+940]
	movzx	eax, BYTE PTR [edx+13]
	test	eax, eax
	je	SHORT $LN3@SimGndJett

; 8908 : 			{
; 8909 : 				SimDriver.GetPlayerAircraft()->Sms->GndJett = FALSE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+940]
	mov	BYTE PTR [ecx+13], 0

; 8910 : 				//No jammer when on ground
; 8911 : 				if(SimDriver.GetPlayerAircraft()->OnGround())

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR tv142[ebp], eax
	mov	edx, DWORD PTR tv142[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv142[ebp]
	mov	edx, DWORD PTR [eax+148]
	call	edx
	test	eax, eax
	je	SHORT $LN2@SimGndJett

; 8912 : 					SimDriver.GetPlayerAircraft()->UnSetFlag(ECM_ON);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?UnSetFlag@SimBaseClass@@QAEXH@Z	; SimBaseClass::UnSetFlag
$LN2@SimGndJett:

; 8913 : 			}
; 8914 : 			else

	jmp	SHORT $LN7@SimGndJett
$LN3@SimGndJett:

; 8915 : 				SimDriver.GetPlayerAircraft()->Sms->GndJett = TRUE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	eax, DWORD PTR [eax+940]
	mov	BYTE PTR [eax+13], 1
$LN7@SimGndJett:

; 8916 : 		}
; 8917 : 	}
; 8918 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimGndJettEnable@@YAXKHPAX@Z ENDP			; SimGndJettEnable
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_laserPod$1 = -20					; size = 4
_mavDisplay$2 = -16					; size = 4
_pac$ = -12						; size = 4
_theRadar$3 = -8					; size = 4
_HasMavs$4 = -1						; size = 1
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimPinkySwitch@@YAXKHPAX@Z PROC			; SimPinkySwitch

; 8851 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 8852 : 	if(!g_bRealisticAvionics){

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN17@SimPinkySw

; 8853 : 		return;

	jmp	$LN18@SimPinkySw
$LN17@SimPinkySw:

; 8854 : 	}
; 8855 : 
; 8856 : 	AircraftClass *pac = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _pac$[ebp], eax

; 8857 : 	if (pac && pac->IsSetFlag(MOTION_OWNSHIP) && pac->Sms){

	cmp	DWORD PTR _pac$[ebp], 0
	je	$LN18@SimPinkySw
	push	65536					; 00010000H
	mov	ecx, DWORD PTR _pac$[ebp]
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN18@SimPinkySw
	mov	ecx, DWORD PTR _pac$[ebp]
	cmp	DWORD PTR [ecx+940], 0
	je	$LN18@SimPinkySw

; 8858 : 		if(state & KEY_DOWN){

	mov	edx, DWORD PTR _state$[ebp]
	and	edx, 8
	je	$LN18@SimPinkySw

; 8859 : 			if(g_bRealisticAvionics){

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	$LN18@SimPinkySw

; 8860 : 				//check what all we got first
; 8861 : 				RadarDopplerClass* theRadar = (RadarDopplerClass*)FindSensor(pac, SensorClass::Radar);

	push	1
	mov	ecx, DWORD PTR _pac$[ebp]
	push	ecx
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadar$3[ebp], eax

; 8862 : 				bool HasMavs = FALSE;

	mov	BYTE PTR _HasMavs$4[ebp], 0

; 8863 : 				LaserPodClass* laserPod = (LaserPodClass* )FindLaserPod (pac);

	mov	edx, DWORD PTR _pac$[ebp]
	push	edx
	call	?FindLaserPod@@YAPAVSensorClass@@PAVSimMoverClass@@@Z ; FindLaserPod
	add	esp, 4
	mov	DWORD PTR _laserPod$1[ebp], eax

; 8864 : 				MaverickDisplayClass* mavDisplay = NULL;

	mov	DWORD PTR _mavDisplay$2[ebp], 0

; 8865 : 				if (pac->Sms->curWeaponType == wtAgm65 && pac->Sms->curWeapon){

	mov	eax, DWORD PTR _pac$[ebp]
	mov	ecx, DWORD PTR [eax+940]
	cmp	DWORD PTR [ecx+148], 4
	jne	SHORT $LN13@SimPinkySw
	mov	edx, DWORD PTR _pac$[ebp]
	mov	ecx, DWORD PTR [edx+940]
	add	ecx, 164				; 000000a4H
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN13@SimPinkySw

; 8866 : 					HasMavs = TRUE;

	mov	BYTE PTR _HasMavs$4[ebp], 1

; 8867 : 					mavDisplay = (MaverickDisplayClass*)((MissileClass*)pac->Sms->GetCurrentWeapon())->display;

	mov	ecx, DWORD PTR _pac$[ebp]
	mov	edx, DWORD PTR [ecx+940]
	mov	eax, DWORD PTR _pac$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+940]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	ecx, DWORD PTR [eax+712]
	mov	DWORD PTR _mavDisplay$2[ebp], ecx
$LN13@SimPinkySw:

; 8868 : 				}
; 8869 : 				//now check what to toggle
; 8870 : 				if(theRadar && theRadar->IsSOI())

	cmp	DWORD PTR _theRadar$3[ebp], 0
	je	$LN12@SimPinkySw
	mov	ecx, DWORD PTR _theRadar$3[ebp]
	call	?IsSOI@DrawableClass@@QAEHXZ		; DrawableClass::IsSOI
	test	eax, eax
	je	$LN12@SimPinkySw

; 8871 : 				{
; 8872 : 					//Toggle EXP and NORM
; 8873 : 					if(theRadar->GetRadarMode() == RadarClass::RWS ||
; 8874 : 						theRadar->GetRadarMode() == RadarClass::LRS ||
; 8875 : 						theRadar->GetRadarMode() == RadarClass::SAM ||
; 8876 : 						theRadar->GetRadarMode() == RadarClass::TWS)

	mov	edx, DWORD PTR _theRadar$3[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _theRadar$3[ebp]
	mov	edx, DWORD PTR [eax+220]
	call	edx
	cmp	eax, 2
	je	SHORT $LN10@SimPinkySw
	mov	eax, DWORD PTR _theRadar$3[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _theRadar$3[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 3
	je	SHORT $LN10@SimPinkySw
	mov	ecx, DWORD PTR _theRadar$3[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$3[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN10@SimPinkySw
	mov	ecx, DWORD PTR _theRadar$3[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$3[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 4
	jne	SHORT $LN11@SimPinkySw
$LN10@SimPinkySw:

; 8877 : 					{
; 8878 : 						theRadar->ToggleFlag(RadarDopplerClass::EXP);

	push	2
	mov	ecx, DWORD PTR _theRadar$3[ebp]
	call	?ToggleFlag@RadarDopplerClass@@QAEXH@Z	; RadarDopplerClass::ToggleFlag

; 8879 : 					}
; 8880 : 					else if(theRadar->GetRadarMode() == RadarClass::GM ||

	jmp	SHORT $LN9@SimPinkySw
$LN11@SimPinkySw:

; 8881 : 						theRadar->GetRadarMode() == RadarClass::GMT ||
; 8882 : 						theRadar->GetRadarMode() == RadarClass::SEA)

	mov	ecx, DWORD PTR _theRadar$3[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$3[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 14					; 0000000eH
	je	SHORT $LN7@SimPinkySw
	mov	ecx, DWORD PTR _theRadar$3[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$3[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 16					; 00000010H
	je	SHORT $LN7@SimPinkySw
	mov	ecx, DWORD PTR _theRadar$3[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$3[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 17					; 00000011H
	jne	SHORT $LN9@SimPinkySw
$LN7@SimPinkySw:

; 8883 : 					{ 
; 8884 : 						theRadar->StepAGfov();

	mov	ecx, DWORD PTR _theRadar$3[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$3[ebp]
	mov	eax, DWORD PTR [edx+156]
	call	eax
$LN9@SimPinkySw:

; 8885 : 					} 
; 8886 : 				}

	jmp	$LN18@SimPinkySw
$LN12@SimPinkySw:

; 8887 : 				else if(SimDriver.GetPlayerAircraft()->FCC && SimDriver.GetPlayerAircraft()->FCC->IsSOI)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+936], 0
	je	SHORT $LN5@SimPinkySw
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	movzx	edx, BYTE PTR [ecx+464]
	test	edx, edx
	je	SHORT $LN5@SimPinkySw

; 8888 : 					SimDriver.GetPlayerAircraft()->FCC->ToggleHSDZoom();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?ToggleHSDZoom@FireControlComputer@@QAEXXZ ; FireControlComputer::ToggleHSDZoom
	jmp	SHORT $LN18@SimPinkySw
$LN5@SimPinkySw:

; 8889 : 				else if(HasMavs && mavDisplay && mavDisplay->IsSOI())

	movzx	eax, BYTE PTR _HasMavs$4[ebp]
	test	eax, eax
	je	SHORT $LN3@SimPinkySw
	cmp	DWORD PTR _mavDisplay$2[ebp], 0
	je	SHORT $LN3@SimPinkySw
	mov	ecx, DWORD PTR _mavDisplay$2[ebp]
	call	?IsSOI@DrawableClass@@QAEHXZ		; DrawableClass::IsSOI
	test	eax, eax
	je	SHORT $LN3@SimPinkySw

; 8890 : 					mavDisplay->ToggleFOV();

	mov	ecx, DWORD PTR _mavDisplay$2[ebp]
	call	?ToggleFOV@MaverickDisplayClass@@QAEXXZ	; MaverickDisplayClass::ToggleFOV
	jmp	SHORT $LN18@SimPinkySw
$LN3@SimPinkySw:

; 8891 : 				else if(laserPod && laserPod->IsSOI())

	cmp	DWORD PTR _laserPod$1[ebp], 0
	je	SHORT $LN18@SimPinkySw
	mov	ecx, DWORD PTR _laserPod$1[ebp]
	call	?IsSOI@DrawableClass@@QAEHXZ		; DrawableClass::IsSOI
	test	eax, eax
	je	SHORT $LN18@SimPinkySw

; 8892 : 					laserPod->ToggleFOV();

	mov	ecx, DWORD PTR _laserPod$1[ebp]
	call	?ToggleFOV@LaserPodClass@@QAEXXZ	; LaserPodClass::ToggleFOV
$LN18@SimPinkySw:

; 8893 : 			}
; 8894 : 		}
; 8895 : 	}
; 8896 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimPinkySwitch@@YAXKHPAX@Z ENDP			; SimPinkySwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv160 = -12						; size = 4
tv88 = -8						; size = 4
_theRwr$1 = -4						; size = 4
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimDropProgrammed@@YAXKHPAX@Z PROC			; SimDropProgrammed

; 8813 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 8814 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN11@SimDropPro

; 8815 : 		return;

	jmp	$LN12@SimDropPro
$LN11@SimDropPro:

; 8816 : 
; 8817 :     if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN12@SimDropPro
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN12@SimDropPro
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	$LN12@SimDropPro

; 8818 :     {
; 8819 : 		if(SimDriver.GetPlayerAircraft()->OnGround())

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR tv88[ebp], eax
	mov	edx, DWORD PTR tv88[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv88[ebp]
	mov	edx, DWORD PTR [eax+148]
	call	edx
	test	eax, eax
	je	SHORT $LN9@SimDropPro

; 8820 : 			return;

	jmp	$LN12@SimDropPro
$LN9@SimDropPro:

; 8821 : 
; 8822 : 		//drop our program manually
; 8823 : 		if(g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	$LN12@SimDropPro

; 8824 : 		{
; 8825 : 			PlayerRwrClass* theRwr = (PlayerRwrClass*)FindSensor(SimDriver.GetPlayerAircraft(), SensorClass::RWR);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRwr$1[ebp], eax

; 8826 : 
; 8827 : 			//Check for Power and Failure
; 8828 : 			if(!SimDriver.GetPlayerAircraft()->HasPower(AircraftClass::UFCPower) ||
; 8829 : 				SimDriver.GetPlayerAircraft()->mFaults->GetFault(FaultClass::ufc_fault) ||
; 8830 : 				SimDriver.GetPlayerAircraft()->IsExploding())

	push	8
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::HasPower
	test	eax, eax
	je	SHORT $LN6@SimDropPro
	push	28					; 0000001cH
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFault@FackClass@@QAEHW4type_FSubSystem@FaultClass@@@Z ; FackClass::GetFault
	test	eax, eax
	jne	SHORT $LN6@SimDropPro
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR tv160[ebp], eax
	mov	ecx, DWORD PTR tv160[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv160[ebp]
	mov	eax, DWORD PTR [edx+208]
	call	eax
	test	eax, eax
	je	SHORT $LN7@SimDropPro
$LN6@SimDropPro:

; 8831 : 				return;

	jmp	SHORT $LN12@SimDropPro
$LN7@SimDropPro:

; 8832 : 
; 8833 : 			//Check for our switch
; 8834 : 			if(SimDriver.GetPlayerAircraft()->EWSPGM() == AircraftClass::EWSPGMSwitch::Off ||
; 8835 : 				SimDriver.GetPlayerAircraft()->EWSPGM() == AircraftClass::EWSPGMSwitch::Stby)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?EWSPGM@AircraftClass@@QAE?AW4EWSPGMSwitch@1@XZ ; AircraftClass::EWSPGM
	test	eax, eax
	je	SHORT $LN4@SimDropPro
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?EWSPGM@AircraftClass@@QAE?AW4EWSPGMSwitch@1@XZ ; AircraftClass::EWSPGM
	cmp	eax, 1
	jne	SHORT $LN5@SimDropPro
$LN4@SimDropPro:

; 8836 : 				return;

	jmp	SHORT $LN12@SimDropPro
$LN5@SimDropPro:

; 8837 : 
; 8838 : 			if(theRwr)

	cmp	DWORD PTR _theRwr$1[ebp], 0
	je	SHORT $LN12@SimDropPro

; 8839 : 			{
; 8840 : 				SimDriver.GetPlayerAircraft()->DropEWS();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?DropEWS@AircraftClass@@QAEXXZ		; AircraftClass::DropEWS

; 8841 : 				if(g_bMLU && val)

	movzx	ecx, BYTE PTR ?g_bMLU@@3_NA		; g_bMLU
	test	ecx, ecx
	je	SHORT $LN2@SimDropPro
	cmp	DWORD PTR _val$[ebp], 0
	je	SHORT $LN2@SimDropPro

; 8842 : 					theRwr->ReleaseManual = 2;

	mov	edx, DWORD PTR _theRwr$1[ebp]
	mov	DWORD PTR [edx+604], 2

; 8843 : 				else

	jmp	SHORT $LN12@SimDropPro
$LN2@SimDropPro:

; 8844 : 					theRwr->ReleaseManual = TRUE;

	mov	eax, DWORD PTR _theRwr$1[ebp]
	mov	DWORD PTR [eax+604], 1
$LN12@SimDropPro:

; 8845 : 			}
; 8846 : 		}
; 8847 :     }
; 8848 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimDropProgrammed@@YAXKHPAX@Z ENDP			; SimDropProgrammed
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_theRadar$1 = -4					; size = 4
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimRFSilent@@YAXKHPAX@Z PROC				; SimRFSilent

; 8772 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 8773 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN6@SimRFSilen

; 8774 : 		return;

	jmp	$LN7@SimRFSilen
$LN6@SimRFSilen:

; 8775 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN7@SimRFSilen
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN7@SimRFSilen
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	$LN7@SimRFSilen

; 8776 : 	{ 
; 8777 : 		if(state & KEY_DOWN)

	mov	edx, DWORD PTR _state$[ebp]
	and	edx, 8
	je	$LN7@SimRFSilen

; 8778 : 		{
; 8779 : 			RadarDopplerClass* theRadar = (RadarDopplerClass*)FindSensor(SimDriver.GetPlayerAircraft(), SensorClass::Radar);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadar$1[ebp], eax

; 8780 : 			if (theRadar)

	cmp	DWORD PTR _theRadar$1[ebp], 0
	je	SHORT $LN3@SimRFSilen

; 8781 : 				theRadar->SetEmitting(FALSE);

	push	0
	mov	eax, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx+84]
	call	eax
$LN3@SimRFSilen:

; 8782 : 			//store our current AP mode
; 8783 : 			if(SimDriver.GetPlayerAircraft()->AutopilotType() == AircraftClass::LantirnAP) 

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?AutopilotType@AircraftClass@@QAE?AW4AutoPilotType@1@XZ ; AircraftClass::AutopilotType
	cmp	eax, 3
	jne	SHORT $LN2@SimRFSilen

; 8784 : 			{
; 8785 : 				SimDriver.GetPlayerAircraft()->lastapType = SimDriver.GetPlayerAircraft()->AutopilotType();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?AutopilotType@AircraftClass@@QAE?AW4AutoPilotType@1@XZ ; AircraftClass::AutopilotType
	mov	esi, eax
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR [eax+972], esi

; 8786 : 				SimDriver.GetPlayerAircraft()->SetAutopilot(AircraftClass::APOff);

	push	4
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetAutopilot@AircraftClass@@QAEXW4AutoPilotType@1@@Z ; AircraftClass::SetAutopilot
$LN2@SimRFSilen:

; 8787 : 			}
; 8788 : 			SimDriver.GetPlayerAircraft()->RFState = 2;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR [eax+1520], 2

; 8789 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN7@SimRFSilen

; 8790 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_RF_QUIET, 4);

	push	4
	push	142					; 0000008eH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN7@SimRFSilen:

; 8791 : 		}
; 8792 : 	}
; 8793 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?SimRFSilent@@YAXKHPAX@Z ENDP				; SimRFSilent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_theRadar$1 = -4					; size = 4
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimRFQuiet@@YAXKHPAX@Z PROC				; SimRFQuiet

; 8751 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 8752 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN7@SimRFQuiet

; 8753 : 		return;

	jmp	$LN8@SimRFQuiet
$LN7@SimRFQuiet:

; 8754 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN8@SimRFQuiet
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN8@SimRFQuiet
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	$LN8@SimRFQuiet

; 8755 : 	{ 
; 8756 : 		if(state & KEY_DOWN)

	mov	edx, DWORD PTR _state$[ebp]
	and	edx, 8
	je	$LN8@SimRFQuiet

; 8757 : 		{
; 8758 : 			RadarDopplerClass* theRadar = (RadarDopplerClass*)FindSensor(SimDriver.GetPlayerAircraft(), SensorClass::Radar);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadar$1[ebp], eax

; 8759 : 			if (theRadar)

	cmp	DWORD PTR _theRadar$1[ebp], 0
	je	SHORT $LN4@SimRFQuiet

; 8760 : 				theRadar->SetEmitting(FALSE);

	push	0
	mov	eax, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx+84]
	call	eax
$LN4@SimRFQuiet:

; 8761 : 			if (SimDriver.GetPlayerAircraft()->RFState == 2) //restore AP if the RF was in "silent"

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1520], 2
	jne	SHORT $LN3@SimRFQuiet

; 8762 : 				if (SimDriver.GetPlayerAircraft()->lastapType == AircraftClass::LantirnAP)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+972], 3
	jne	SHORT $LN3@SimRFQuiet

; 8763 : 					SimDriver.GetPlayerAircraft()->SetAutopilot(SimDriver.GetPlayerAircraft()->lastapType);

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+972]
	push	ecx
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetAutopilot@AircraftClass@@QAEXW4AutoPilotType@1@@Z ; AircraftClass::SetAutopilot
$LN3@SimRFQuiet:

; 8764 : 			SimDriver.GetPlayerAircraft()->RFState = 1;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR [eax+1520], 1

; 8765 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN8@SimRFQuiet

; 8766 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_RF_QUIET, 1);

	push	1
	push	142					; 0000008eH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN8@SimRFQuiet:

; 8767 : 		}
; 8768 : 	}
; 8769 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimRFQuiet@@YAXKHPAX@Z ENDP				; SimRFQuiet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_theRadar$1 = -4					; size = 4
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimRFNorm@@YAXKHPAX@Z PROC				; SimRFNorm

; 8730 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 8731 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN7@SimRFNorm

; 8732 : 		return;

	jmp	$LN8@SimRFNorm
$LN7@SimRFNorm:

; 8733 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN8@SimRFNorm
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN8@SimRFNorm
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	$LN8@SimRFNorm

; 8734 : 	{ 
; 8735 : 		if(state & KEY_DOWN)

	mov	edx, DWORD PTR _state$[ebp]
	and	edx, 8
	je	$LN8@SimRFNorm

; 8736 : 		{
; 8737 : 			RadarDopplerClass* theRadar = (RadarDopplerClass*)FindSensor(SimDriver.GetPlayerAircraft(), SensorClass::Radar);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadar$1[ebp], eax

; 8738 : 			if (theRadar)

	cmp	DWORD PTR _theRadar$1[ebp], 0
	je	SHORT $LN4@SimRFNorm

; 8739 : 				theRadar->SetEmitting(TRUE);

	push	1
	mov	eax, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx+84]
	call	eax
$LN4@SimRFNorm:

; 8740 : 			if (SimDriver.GetPlayerAircraft()->RFState == 2) //restore AP if the RF was in "silent"

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1520], 2
	jne	SHORT $LN3@SimRFNorm

; 8741 : 				if (SimDriver.GetPlayerAircraft()->lastapType == AircraftClass::LantirnAP)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+972], 3
	jne	SHORT $LN3@SimRFNorm

; 8742 : 					SimDriver.GetPlayerAircraft()->SetAutopilot(SimDriver.GetPlayerAircraft()->lastapType);

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+972]
	push	ecx
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetAutopilot@AircraftClass@@QAEXW4AutoPilotType@1@@Z ; AircraftClass::SetAutopilot
$LN3@SimRFNorm:

; 8743 : 			SimDriver.GetPlayerAircraft()->RFState = 0;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR [eax+1520], 0

; 8744 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN8@SimRFNorm

; 8745 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_RF_QUIET, 2);

	push	2
	push	142					; 0000008eH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN8@SimRFNorm:

; 8746 : 		}
; 8747 : 	}
; 8748 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimRFNorm@@YAXKHPAX@Z ENDP				; SimRFNorm
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_theRadar$1 = -4					; size = 4
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimRFSwitch@@YAXKHPAX@Z PROC				; SimRFSwitch

; 8676 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 8677 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN14@SimRFSwitc
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN14@SimRFSwitc
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN14@SimRFSwitc

; 8678 : 	{ 
; 8679 : 		if(state & KEY_DOWN)

	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	$LN14@SimRFSwitc

; 8680 : 		{
; 8681 : 			if(g_bRealisticAvionics)

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	$LN14@SimRFSwitc

; 8682 : 			{
; 8683 : 				RadarDopplerClass* theRadar = (RadarDopplerClass*)FindSensor(SimDriver.GetPlayerAircraft(), SensorClass::Radar);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadar$1[ebp], eax

; 8684 : 				if(theRadar)

	cmp	DWORD PTR _theRadar$1[ebp], 0
	je	$LN14@SimRFSwitc

; 8685 : 				{
; 8686 : 					if(SimDriver.GetPlayerAircraft()->RFState == 0)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1520], 0
	jne	SHORT $LN9@SimRFSwitc

; 8687 : 					{
; 8688 : 						//QUIET --> no Radar
; 8689 : 						SimDriver.GetPlayerAircraft()->RFState = 1;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR [eax+1520], 1

; 8690 : 						theRadar->SetEmitting(FALSE);

	push	0
	mov	eax, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx+84]
	call	eax

; 8691 : 						if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN8@SimRFSwitc

; 8692 : 							OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_RF_QUIET, 1);

	push	1
	push	142					; 0000008eH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN8@SimRFSwitc:

; 8693 : 					}

	jmp	$LN14@SimRFSwitc
$LN9@SimRFSwitc:

; 8694 : 					else if(SimDriver.GetPlayerAircraft()->RFState == 1)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1520], 1
	jne	$LN6@SimRFSwitc

; 8695 : 					{
; 8696 : 						//store our current AP mode
; 8697 : 						if(SimDriver.GetPlayerAircraft()->AutopilotType() == AircraftClass::LantirnAP) 

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?AutopilotType@AircraftClass@@QAE?AW4AutoPilotType@1@XZ ; AircraftClass::AutopilotType
	cmp	eax, 3
	jne	SHORT $LN5@SimRFSwitc

; 8698 : 						{
; 8699 : 							SimDriver.GetPlayerAircraft()->lastapType = SimDriver.GetPlayerAircraft()->AutopilotType();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?AutopilotType@AircraftClass@@QAE?AW4AutoPilotType@1@XZ ; AircraftClass::AutopilotType
	mov	esi, eax
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR [eax+972], esi

; 8700 : 							SimDriver.GetPlayerAircraft()->SetAutopilot(AircraftClass::APOff);

	push	4
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetAutopilot@AircraftClass@@QAEXW4AutoPilotType@1@@Z ; AircraftClass::SetAutopilot
$LN5@SimRFSwitc:

; 8701 : 						}
; 8702 : 						//SILENT --> No CARA, no TFR, no Radar
; 8703 : 						SimDriver.GetPlayerAircraft()->RFState = 2;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR [eax+1520], 2

; 8704 : 						theRadar->SetEmitting(FALSE);

	push	0
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx+84]
	call	eax

; 8705 : 						if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimRFSwitc

; 8706 : 							OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_RF_QUIET, 4);

	push	4
	push	142					; 0000008eH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimRFSwitc:

; 8707 : 					}
; 8708 : 					else

	jmp	SHORT $LN14@SimRFSwitc
$LN6@SimRFSwitc:

; 8709 : 					{
; 8710 : 						//NORM
; 8711 : 						SimDriver.GetPlayerAircraft()->RFState = 0;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR [eax+1520], 0

; 8712 : 						theRadar->SetEmitting(TRUE);

	push	1
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx+84]
	call	eax

; 8713 : 						//restore AP
; 8714 : 						// MD -- 20031214: but only for LantirnAP -- ASSOCI8TOR found this old SP3 bug
; 8715 : 						if (SimDriver.GetPlayerAircraft()->lastapType == AircraftClass::LantirnAP)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+972], 3
	jne	SHORT $LN2@SimRFSwitc

; 8716 : 							SimDriver.GetPlayerAircraft()->SetAutopilot(SimDriver.GetPlayerAircraft()->lastapType);

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+972]
	push	ecx
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetAutopilot@AircraftClass@@QAEXW4AutoPilotType@1@@Z ; AircraftClass::SetAutopilot
$LN2@SimRFSwitc:

; 8717 : 						if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN14@SimRFSwitc

; 8718 : 							OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_RF_QUIET, 2);

	push	2
	push	142					; 0000008eH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN14@SimRFSwitc:

; 8719 : 					}
; 8720 : 				}
; 8721 : 			}
; 8722 : 		}
; 8723 : 	}
; 8724 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?SimRFSwitch@@YAXKHPAX@Z ENDP				; SimRFSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimVMSOff@@YAXKHPAX@Z PROC				; SimVMSOff

; 8663 : {

	push	ebp
	mov	ebp, esp

; 8664 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimVMSOff

; 8665 : 		return;

	jmp	SHORT $LN4@SimVMSOff
$LN3@SimVMSOff:

; 8666 : 
; 8667 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimVMSOff
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimVMSOff
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimVMSOff

; 8668 : 	{ 
; 8669 : 		SimDriver.GetPlayerAircraft()->playBetty = FALSE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	BYTE PTR [eax+1516], 0

; 8670 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimVMSOff

; 8671 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_VMS_PWR, 1);

	push	1
	push	208					; 000000d0H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimVMSOff:

; 8672 : 	}
; 8673 : }

	pop	ebp
	ret	0
?SimVMSOff@@YAXKHPAX@Z ENDP				; SimVMSOff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimVMSOn@@YAXKHPAX@Z PROC				; SimVMSOn

; 8650 : {

	push	ebp
	mov	ebp, esp

; 8651 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimVMSOn

; 8652 : 		return;

	jmp	SHORT $LN4@SimVMSOn
$LN3@SimVMSOn:

; 8653 : 
; 8654 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimVMSOn
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimVMSOn
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimVMSOn

; 8655 : 	{ 
; 8656 : 		SimDriver.GetPlayerAircraft()->playBetty = TRUE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	BYTE PTR [eax+1516], 1

; 8657 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimVMSOn

; 8658 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_VMS_PWR, 2);

	push	2
	push	208					; 000000d0H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimVMSOn:

; 8659 : 	}
; 8660 : }

	pop	ebp
	ret	0
?SimVMSOn@@YAXKHPAX@Z ENDP				; SimVMSOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimInhibitVMS@@YAXKHPAX@Z PROC				; SimInhibitVMS

; 8630 : {

	push	ebp
	mov	ebp, esp

; 8631 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN6@SimInhibit
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN6@SimInhibit
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN6@SimInhibit

; 8632 : 	{ 
; 8633 : 		if(g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN6@SimInhibit

; 8634 : 		{
; 8635 : 			SimDriver.GetPlayerAircraft()->ToggleBetty();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?ToggleBetty@AircraftClass@@QAEXXZ	; AircraftClass::ToggleBetty

; 8636 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN6@SimInhibit

; 8637 : 			{
; 8638 : 				if (SimDriver.GetPlayerAircraft()->playBetty)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	movzx	edx, BYTE PTR [eax+1516]
	test	edx, edx
	je	SHORT $LN2@SimInhibit

; 8639 : 					OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_VMS_PWR, 1);

	push	1
	push	208					; 000000d0H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 8640 : 				else

	jmp	SHORT $LN6@SimInhibit
$LN2@SimInhibit:

; 8641 : 					OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_VMS_PWR, 2);

	push	2
	push	208					; 000000d0H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN6@SimInhibit:

; 8642 : 			}
; 8643 : 		}
; 8644 : 	}
; 8645 : }

	pop	ebp
	ret	0
?SimInhibitVMS@@YAXKHPAX@Z ENDP				; SimInhibitVMS
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_theRwr$1 = -4						; size = 4
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimEWSProgFour@@YAXKHPAX@Z PROC			; SimEWSProgFour

; 8516 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 8517 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN4@SimEWSProg

; 8518 : 		return;

	jmp	$LN5@SimEWSProg
$LN4@SimEWSProg:

; 8519 :   if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN5@SimEWSProg
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN5@SimEWSProg
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN5@SimEWSProg

; 8520 :   { 
; 8521 : 		PlayerRwrClass* theRwr = (PlayerRwrClass*)FindSensor(SimDriver.GetPlayerAircraft(), SensorClass::RWR);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRwr$1[ebp], eax

; 8522 : 		if(theRwr)

	cmp	DWORD PTR _theRwr$1[ebp], 0
	je	SHORT $LN2@SimEWSProg

; 8523 : 		{
; 8524 : 			theRwr->InEWSLoop = FALSE;

	mov	edx, DWORD PTR _theRwr$1[ebp]
	mov	BYTE PTR [edx+600], 0

; 8525 : 			theRwr->ReleaseManual = FALSE;

	mov	eax, DWORD PTR _theRwr$1[ebp]
	mov	DWORD PTR [eax+604], 0
$LN2@SimEWSProg:

; 8526 : 		}
; 8527 : 		SimDriver.GetPlayerAircraft()->SetEWSProg(3);  // Fourth knob position is three

	push	3
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetEWSProg@AircraftClass@@QAEXH@Z	; AircraftClass::SetEWSProg

; 8528 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN5@SimEWSProg

; 8529 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_EWS_PROG, 8);

	push	8
	push	166					; 000000a6H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN5@SimEWSProg:

; 8530 :   }
; 8531 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimEWSProgFour@@YAXKHPAX@Z ENDP			; SimEWSProgFour
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_theRwr$1 = -4						; size = 4
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimEWSProgThree@@YAXKHPAX@Z PROC			; SimEWSProgThree

; 8498 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 8499 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN4@SimEWSProg

; 8500 : 		return;

	jmp	$LN5@SimEWSProg
$LN4@SimEWSProg:

; 8501 :   if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN5@SimEWSProg
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN5@SimEWSProg
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN5@SimEWSProg

; 8502 :   { 
; 8503 : 		PlayerRwrClass* theRwr = (PlayerRwrClass*)FindSensor(SimDriver.GetPlayerAircraft(), SensorClass::RWR);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRwr$1[ebp], eax

; 8504 : 		if(theRwr)

	cmp	DWORD PTR _theRwr$1[ebp], 0
	je	SHORT $LN2@SimEWSProg

; 8505 : 		{
; 8506 : 			theRwr->InEWSLoop = FALSE;

	mov	edx, DWORD PTR _theRwr$1[ebp]
	mov	BYTE PTR [edx+600], 0

; 8507 : 			theRwr->ReleaseManual = FALSE;

	mov	eax, DWORD PTR _theRwr$1[ebp]
	mov	DWORD PTR [eax+604], 0
$LN2@SimEWSProg:

; 8508 : 		}
; 8509 : 		SimDriver.GetPlayerAircraft()->SetEWSProg(2);  // Third knob position is two

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetEWSProg@AircraftClass@@QAEXH@Z	; AircraftClass::SetEWSProg

; 8510 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN5@SimEWSProg

; 8511 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_EWS_PROG, 4);

	push	4
	push	166					; 000000a6H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN5@SimEWSProg:

; 8512 :   }
; 8513 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimEWSProgThree@@YAXKHPAX@Z ENDP			; SimEWSProgThree
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_theRwr$1 = -4						; size = 4
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimEWSProgTwo@@YAXKHPAX@Z PROC				; SimEWSProgTwo

; 8480 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 8481 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN4@SimEWSProg

; 8482 : 		return;

	jmp	$LN5@SimEWSProg
$LN4@SimEWSProg:

; 8483 :   if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN5@SimEWSProg
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN5@SimEWSProg
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN5@SimEWSProg

; 8484 :   { 
; 8485 : 		PlayerRwrClass* theRwr = (PlayerRwrClass*)FindSensor(SimDriver.GetPlayerAircraft(), SensorClass::RWR);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRwr$1[ebp], eax

; 8486 : 		if(theRwr)

	cmp	DWORD PTR _theRwr$1[ebp], 0
	je	SHORT $LN2@SimEWSProg

; 8487 : 		{
; 8488 : 			theRwr->InEWSLoop = FALSE;

	mov	edx, DWORD PTR _theRwr$1[ebp]
	mov	BYTE PTR [edx+600], 0

; 8489 : 			theRwr->ReleaseManual = FALSE;

	mov	eax, DWORD PTR _theRwr$1[ebp]
	mov	DWORD PTR [eax+604], 0
$LN2@SimEWSProg:

; 8490 : 		}
; 8491 : 		SimDriver.GetPlayerAircraft()->SetEWSProg(1);  // Second knob position is one

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetEWSProg@AircraftClass@@QAEXH@Z	; AircraftClass::SetEWSProg

; 8492 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN5@SimEWSProg

; 8493 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_EWS_PROG, 2);

	push	2
	push	166					; 000000a6H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN5@SimEWSProg:

; 8494 :   }
; 8495 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimEWSProgTwo@@YAXKHPAX@Z ENDP				; SimEWSProgTwo
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_theRwr$1 = -4						; size = 4
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimEWSProgOne@@YAXKHPAX@Z PROC				; SimEWSProgOne

; 8462 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 8463 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN4@SimEWSProg

; 8464 : 		return;

	jmp	$LN5@SimEWSProg
$LN4@SimEWSProg:

; 8465 :   if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN5@SimEWSProg
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN5@SimEWSProg
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN5@SimEWSProg

; 8466 :   {
; 8467 : 		PlayerRwrClass* theRwr = (PlayerRwrClass*)FindSensor(SimDriver.GetPlayerAircraft(), SensorClass::RWR);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRwr$1[ebp], eax

; 8468 : 		if(theRwr)

	cmp	DWORD PTR _theRwr$1[ebp], 0
	je	SHORT $LN2@SimEWSProg

; 8469 : 		{
; 8470 : 			theRwr->InEWSLoop = FALSE;

	mov	edx, DWORD PTR _theRwr$1[ebp]
	mov	BYTE PTR [edx+600], 0

; 8471 : 			theRwr->ReleaseManual = FALSE;

	mov	eax, DWORD PTR _theRwr$1[ebp]
	mov	DWORD PTR [eax+604], 0
$LN2@SimEWSProg:

; 8472 : 		}
; 8473 : 		SimDriver.GetPlayerAircraft()->SetEWSProg(0);  // First knob position is zero

	push	0
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetEWSProg@AircraftClass@@QAEXH@Z	; AircraftClass::SetEWSProg

; 8474 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN5@SimEWSProg

; 8475 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_EWS_PROG, 1);

	push	1
	push	166					; 000000a6H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN5@SimEWSProg:

; 8476 :   }
; 8477 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimEWSProgOne@@YAXKHPAX@Z ENDP				; SimEWSProgOne
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$1 = -4						; size = 4
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimEWSProgInc@@YAXKHPAX@Z PROC				; SimEWSProgInc

; 8436 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 8437 :   if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimEWSProg
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimEWSProg
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimEWSProg

; 8438 :   { 
; 8439 : 		SimDriver.GetPlayerAircraft()->IncEWSProg();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IncEWSProg@AircraftClass@@QAEXXZ	; AircraftClass::IncEWSProg

; 8440 : 		int val = SimDriver.GetPlayerAircraft()->EWSProgNum+1;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+1500]
	add	ecx, 1
	mov	DWORD PTR _val$1[ebp], ecx

; 8441 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN3@SimEWSProg

; 8442 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_EWS_PROG, val);

	mov	edx, DWORD PTR _val$1[ebp]
	push	edx
	push	166					; 000000a6H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN3@SimEWSProg:

; 8443 :   }
; 8444 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimEWSProgInc@@YAXKHPAX@Z ENDP				; SimEWSProgInc
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$1 = -4						; size = 4
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimEWSProgDec@@YAXKHPAX@Z PROC				; SimEWSProgDec

; 8446 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 8447 :   if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimEWSProg
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimEWSProg
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimEWSProg

; 8448 :   { 
; 8449 : 		SimDriver.GetPlayerAircraft()->DecEWSProg();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?DecEWSProg@AircraftClass@@QAEXXZ	; AircraftClass::DecEWSProg

; 8450 : 		int val = SimDriver.GetPlayerAircraft()->EWSProgNum+1;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+1500]
	add	ecx, 1
	mov	DWORD PTR _val$1[ebp], ecx

; 8451 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN3@SimEWSProg

; 8452 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_EWS_PROG, val);

	mov	edx, DWORD PTR _val$1[ebp]
	push	edx
	push	166					; 000000a6H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN3@SimEWSProg:

; 8453 :   }
; 8454 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimEWSProgDec@@YAXKHPAX@Z ENDP				; SimEWSProgDec
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimEWSModeAuto@@YAXKHPAX@Z PROC			; SimEWSModeAuto

; 8424 : {

	push	ebp
	mov	ebp, esp

; 8425 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimEWSMode

; 8426 : 		return;

	jmp	SHORT $LN4@SimEWSMode
$LN3@SimEWSMode:

; 8427 :   if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimEWSMode
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimEWSMode
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimEWSMode

; 8428 :   { 
; 8429 : 		SimDriver.GetPlayerAircraft()->SetPGM(AircraftClass::EWSPGMSwitch::Auto);

	push	4
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetPGM@AircraftClass@@QAEXW4EWSPGMSwitch@1@@Z ; AircraftClass::SetPGM

; 8430 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimEWSMode

; 8431 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_EWS_MODE, 16);

	push	16					; 00000010H
	push	165					; 000000a5H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimEWSMode:

; 8432 :   }
; 8433 : }

	pop	ebp
	ret	0
?SimEWSModeAuto@@YAXKHPAX@Z ENDP			; SimEWSModeAuto
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimEWSModeSemi@@YAXKHPAX@Z PROC			; SimEWSModeSemi

; 8412 : {

	push	ebp
	mov	ebp, esp

; 8413 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimEWSMode

; 8414 : 		return;

	jmp	SHORT $LN4@SimEWSMode
$LN3@SimEWSMode:

; 8415 :   if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimEWSMode
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimEWSMode
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimEWSMode

; 8416 :   { 
; 8417 : 		SimDriver.GetPlayerAircraft()->SetPGM(AircraftClass::EWSPGMSwitch::Semi);

	push	3
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetPGM@AircraftClass@@QAEXW4EWSPGMSwitch@1@@Z ; AircraftClass::SetPGM

; 8418 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimEWSMode

; 8419 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_EWS_MODE, 8);

	push	8
	push	165					; 000000a5H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimEWSMode:

; 8420 :   }
; 8421 : }

	pop	ebp
	ret	0
?SimEWSModeSemi@@YAXKHPAX@Z ENDP			; SimEWSModeSemi
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_theRwr$1 = -4						; size = 4
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimEWSModeMan@@YAXKHPAX@Z PROC				; SimEWSModeMan

; 8391 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 8392 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN6@SimEWSMode

; 8393 : 		return;

	jmp	$LN7@SimEWSMode
$LN6@SimEWSMode:

; 8394 :     if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN7@SimEWSMode
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN7@SimEWSMode
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	$LN7@SimEWSMode

; 8395 :     { 
; 8396 : 		if ((SimDriver.GetPlayerAircraft()->EWSPGM() == AircraftClass::EWSPGMSwitch::Off) ||
; 8397 : 			(SimDriver.GetPlayerAircraft()->EWSPGM() == AircraftClass::EWSPGMSwitch::Stby)) {

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?EWSPGM@AircraftClass@@QAE?AW4EWSPGMSwitch@1@XZ ; AircraftClass::EWSPGM
	test	eax, eax
	je	SHORT $LN3@SimEWSMode
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?EWSPGM@AircraftClass@@QAE?AW4EWSPGMSwitch@1@XZ ; AircraftClass::EWSPGM
	cmp	eax, 1
	jne	SHORT $LN4@SimEWSMode
$LN3@SimEWSMode:

; 8398 : 			PlayerRwrClass* theRwr = (PlayerRwrClass*)FindSensor(SimDriver.GetPlayerAircraft(), SensorClass::RWR);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRwr$1[ebp], eax

; 8399 : 			if(theRwr)

	cmp	DWORD PTR _theRwr$1[ebp], 0
	je	SHORT $LN4@SimEWSMode

; 8400 : 			{	
; 8401 : 				theRwr->InEWSLoop = FALSE;

	mov	edx, DWORD PTR _theRwr$1[ebp]
	mov	BYTE PTR [edx+600], 0

; 8402 : 				theRwr->ReleaseManual = FALSE;

	mov	eax, DWORD PTR _theRwr$1[ebp]
	mov	DWORD PTR [eax+604], 0

; 8403 : 				if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimEWSMode

; 8404 : 					OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_EWS_MODE, 4);

	push	4
	push	165					; 000000a5H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimEWSMode:

; 8405 : 			}
; 8406 : 		}
; 8407 : 		SimDriver.GetPlayerAircraft()->SetPGM(AircraftClass::EWSPGMSwitch::Man);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetPGM@AircraftClass@@QAEXW4EWSPGMSwitch@1@@Z ; AircraftClass::SetPGM
$LN7@SimEWSMode:

; 8408 :     }
; 8409 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimEWSModeMan@@YAXKHPAX@Z ENDP				; SimEWSModeMan
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_theRwr$1 = -4						; size = 4
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimEWSModeStby@@YAXKHPAX@Z PROC			; SimEWSModeStby

; 8373 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 8374 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN4@SimEWSMode

; 8375 : 		return;

	jmp	$LN5@SimEWSMode
$LN4@SimEWSMode:

; 8376 :     if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN5@SimEWSMode
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN5@SimEWSMode
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN5@SimEWSMode

; 8377 :     { 
; 8378 : 			SimDriver.GetPlayerAircraft()->SetPGM(AircraftClass::EWSPGMSwitch::Stby);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetPGM@AircraftClass@@QAEXW4EWSPGMSwitch@1@@Z ; AircraftClass::SetPGM

; 8379 : 			PlayerRwrClass* theRwr = (PlayerRwrClass*)FindSensor(SimDriver.GetPlayerAircraft(), SensorClass::RWR);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRwr$1[ebp], eax

; 8380 : 			if(theRwr)

	cmp	DWORD PTR _theRwr$1[ebp], 0
	je	SHORT $LN5@SimEWSMode

; 8381 : 			{
; 8382 : 				theRwr->InEWSLoop = FALSE;

	mov	edx, DWORD PTR _theRwr$1[ebp]
	mov	BYTE PTR [edx+600], 0

; 8383 : 				theRwr->ReleaseManual = FALSE;

	mov	eax, DWORD PTR _theRwr$1[ebp]
	mov	DWORD PTR [eax+604], 0

; 8384 : 				if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN5@SimEWSMode

; 8385 : 					OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_EWS_MODE, 2);

	push	2
	push	165					; 000000a5H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN5@SimEWSMode:

; 8386 : 			}
; 8387 :     }
; 8388 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimEWSModeStby@@YAXKHPAX@Z ENDP			; SimEWSModeStby
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_theRwr$1 = -4						; size = 4
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimEWSModeOff@@YAXKHPAX@Z PROC				; SimEWSModeOff

; 8355 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 8356 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN4@SimEWSMode

; 8357 : 		return;

	jmp	$LN5@SimEWSMode
$LN4@SimEWSMode:

; 8358 :   if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN5@SimEWSMode
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN5@SimEWSMode
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN5@SimEWSMode

; 8359 :   { 
; 8360 : 		SimDriver.GetPlayerAircraft()->SetPGM(AircraftClass::EWSPGMSwitch::Off);

	push	0
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetPGM@AircraftClass@@QAEXW4EWSPGMSwitch@1@@Z ; AircraftClass::SetPGM

; 8361 : 		PlayerRwrClass* theRwr = (PlayerRwrClass*)FindSensor(SimDriver.GetPlayerAircraft(), SensorClass::RWR);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRwr$1[ebp], eax

; 8362 : 		if(theRwr)

	cmp	DWORD PTR _theRwr$1[ebp], 0
	je	SHORT $LN5@SimEWSMode

; 8363 : 		{
; 8364 : 			theRwr->InEWSLoop = FALSE;

	mov	edx, DWORD PTR _theRwr$1[ebp]
	mov	BYTE PTR [edx+600], 0

; 8365 : 			theRwr->ReleaseManual = FALSE;

	mov	eax, DWORD PTR _theRwr$1[ebp]
	mov	DWORD PTR [eax+604], 0

; 8366 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN5@SimEWSMode

; 8367 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_EWS_MODE, 1);

	push	1
	push	165					; 000000a5H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN5@SimEWSMode:

; 8368 : 		}
; 8369 : 	} 
; 8370 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimEWSModeOff@@YAXKHPAX@Z ENDP				; SimEWSModeOff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$1 = -4						; size = 4
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimEWSPGMInc@@YAXKHPAX@Z PROC				; SimEWSPGMInc

; 8329 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 8330 :   if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimEWSPGMI
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimEWSPGMI
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimEWSPGMI

; 8331 :   { 
; 8332 : 		SimDriver.GetPlayerAircraft()->IncEWSPGM();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IncEWSPGM@AircraftClass@@QAEXXZ	; AircraftClass::IncEWSPGM

; 8333 : 		int val = SimDriver.GetPlayerAircraft()->EWSPGM()+ 1;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?EWSPGM@AircraftClass@@QAE?AW4EWSPGMSwitch@1@XZ ; AircraftClass::EWSPGM
	add	eax, 1
	mov	DWORD PTR _val$1[ebp], eax

; 8334 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN3@SimEWSPGMI

; 8335 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_EWS_MODE, val);

	mov	ecx, DWORD PTR _val$1[ebp]
	push	ecx
	push	165					; 000000a5H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN3@SimEWSPGMI:

; 8336 :   }
; 8337 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimEWSPGMInc@@YAXKHPAX@Z ENDP				; SimEWSPGMInc
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$1 = -4						; size = 4
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimEWSPGMDec@@YAXKHPAX@Z PROC				; SimEWSPGMDec

; 8339 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 8340 :   if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimEWSPGMD
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimEWSPGMD
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimEWSPGMD

; 8341 :   { 
; 8342 : 		SimDriver.GetPlayerAircraft()->DecEWSPGM();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?DecEWSPGM@AircraftClass@@QAEXXZ	; AircraftClass::DecEWSPGM

; 8343 : 		int val = SimDriver.GetPlayerAircraft()->EWSPGM()+ 1;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?EWSPGM@AircraftClass@@QAE?AW4EWSPGMSwitch@1@XZ ; AircraftClass::EWSPGM
	add	eax, 1
	mov	DWORD PTR _val$1[ebp], eax

; 8344 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN3@SimEWSPGMD

; 8345 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_EWS_MODE, val);

	mov	ecx, DWORD PTR _val$1[ebp]
	push	ecx
	push	165					; 000000a5H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN3@SimEWSPGMD:

; 8346 :   }
; 8347 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimEWSPGMDec@@YAXKHPAX@Z ENDP				; SimEWSPGMDec
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimEWSFlareOff@@YAXKHPAX@Z PROC			; SimEWSFlareOff

; 8317 : {

	push	ebp
	mov	ebp, esp

; 8318 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimEWSFlar

; 8319 : 		return;

	jmp	SHORT $LN4@SimEWSFlar
$LN3@SimEWSFlar:

; 8320 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimEWSFlar
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimEWSFlar
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimEWSFlar

; 8321 : 	{ 
; 8322 : 		SimDriver.GetPlayerAircraft()->PowerOff(AircraftClass::EWSFlarePower);

	push	32768					; 00008000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerOff@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerOff

; 8323 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimEWSFlar

; 8324 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_EWS_FLARE_PWR, 1);

	push	1
	push	164					; 000000a4H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimEWSFlar:

; 8325 : 	}
; 8326 : }

	pop	ebp
	ret	0
?SimEWSFlareOff@@YAXKHPAX@Z ENDP			; SimEWSFlareOff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimEWSFlareOn@@YAXKHPAX@Z PROC				; SimEWSFlareOn

; 8305 : {

	push	ebp
	mov	ebp, esp

; 8306 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimEWSFlar

; 8307 : 		return;

	jmp	SHORT $LN4@SimEWSFlar
$LN3@SimEWSFlar:

; 8308 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimEWSFlar
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimEWSFlar
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimEWSFlar

; 8309 : 	{ 
; 8310 : 		SimDriver.GetPlayerAircraft()->PowerOn(AircraftClass::EWSFlarePower);

	push	32768					; 00008000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerOn@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerOn

; 8311 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimEWSFlar

; 8312 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_EWS_FLARE_PWR, 2);

	push	2
	push	164					; 000000a4H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimEWSFlar:

; 8313 : 	}
; 8314 : }

	pop	ebp
	ret	0
?SimEWSFlareOn@@YAXKHPAX@Z ENDP				; SimEWSFlareOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimEWSFlarePower@@YAXKHPAX@Z PROC			; SimEWSFlarePower

; 8292 : {

	push	ebp
	mov	ebp, esp

; 8293 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimEWSFlar
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimEWSFlar
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimEWSFlar

; 8294 : 	{ 
; 8295 : 		SimDriver.GetPlayerAircraft()->PowerToggle(AircraftClass::EWSFlarePower);

	push	32768					; 00008000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerToggle@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerToggle

; 8296 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN3@SimEWSFlar

; 8297 : 			//OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_EWS_FLARE_PWR, SimDriver.GetPlayerAircraft()->HasPower(AircraftClass::EWSFlarePower)+1);
; 8298 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_EWS_FLARE_PWR, 1<<SimDriver.GetPlayerAircraft()->HasPower(AircraftClass::EWSFlarePower));

	push	32768					; 00008000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::HasPower
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	push	edx
	push	164					; 000000a4H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN3@SimEWSFlar:

; 8299 : 	}
; 8300 : }

	pop	ebp
	ret	0
?SimEWSFlarePower@@YAXKHPAX@Z ENDP			; SimEWSFlarePower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimEWSChaffOff@@YAXKHPAX@Z PROC			; SimEWSChaffOff

; 8280 : {

	push	ebp
	mov	ebp, esp

; 8281 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimEWSChaf

; 8282 : 		return;

	jmp	SHORT $LN4@SimEWSChaf
$LN3@SimEWSChaf:

; 8283 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimEWSChaf
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimEWSChaf
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimEWSChaf

; 8284 : 	{ 
; 8285 : 		SimDriver.GetPlayerAircraft()->PowerOff(AircraftClass::EWSChaffPower);

	push	16384					; 00004000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerOff@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerOff

; 8286 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimEWSChaf

; 8287 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_EWS_CHAFF_PWR, 1);

	push	1
	push	163					; 000000a3H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimEWSChaf:

; 8288 : 	}
; 8289 : }

	pop	ebp
	ret	0
?SimEWSChaffOff@@YAXKHPAX@Z ENDP			; SimEWSChaffOff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimEWSChaffOn@@YAXKHPAX@Z PROC				; SimEWSChaffOn

; 8268 : {

	push	ebp
	mov	ebp, esp

; 8269 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimEWSChaf

; 8270 : 		return;

	jmp	SHORT $LN4@SimEWSChaf
$LN3@SimEWSChaf:

; 8271 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimEWSChaf
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimEWSChaf
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimEWSChaf

; 8272 : 	{ 
; 8273 : 		SimDriver.GetPlayerAircraft()->PowerOn(AircraftClass::EWSChaffPower);

	push	16384					; 00004000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerOn@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerOn

; 8274 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimEWSChaf

; 8275 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_EWS_CHAFF_PWR, 2);

	push	2
	push	163					; 000000a3H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimEWSChaf:

; 8276 : 	}
; 8277 : }

	pop	ebp
	ret	0
?SimEWSChaffOn@@YAXKHPAX@Z ENDP				; SimEWSChaffOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimEWSChaffPower@@YAXKHPAX@Z PROC			; SimEWSChaffPower

; 8255 : {

	push	ebp
	mov	ebp, esp

; 8256 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimEWSChaf
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimEWSChaf
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimEWSChaf

; 8257 : 	{ 
; 8258 : 		SimDriver.GetPlayerAircraft()->PowerToggle(AircraftClass::EWSChaffPower);

	push	16384					; 00004000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerToggle@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerToggle

; 8259 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN3@SimEWSChaf

; 8260 : 			//OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_EWS_CHAFF_PWR, SimDriver.GetPlayerAircraft()->HasPower(AircraftClass::EWSChaffPower)+1);
; 8261 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_EWS_CHAFF_PWR, 1<<SimDriver.GetPlayerAircraft()->HasPower(AircraftClass::EWSChaffPower));

	push	16384					; 00004000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::HasPower
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	push	edx
	push	163					; 000000a3H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN3@SimEWSChaf:

; 8262 : 	}
; 8263 : }

	pop	ebp
	ret	0
?SimEWSChaffPower@@YAXKHPAX@Z ENDP			; SimEWSChaffPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimEWSJammerOff@@YAXKHPAX@Z PROC			; SimEWSJammerOff

; 8243 : {

	push	ebp
	mov	ebp, esp

; 8244 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimEWSJamm

; 8245 : 		return;

	jmp	SHORT $LN4@SimEWSJamm
$LN3@SimEWSJamm:

; 8246 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimEWSJamm
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimEWSJamm
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimEWSJamm

; 8247 : 	{ 
; 8248 : 		SimDriver.GetPlayerAircraft()->PowerOff(AircraftClass::EWSJammerPower);

	push	8192					; 00002000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerOff@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerOff

; 8249 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimEWSJamm

; 8250 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_EWS_JMR_PWR, 1);

	push	1
	push	162					; 000000a2H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimEWSJamm:

; 8251 : 	}
; 8252 : }

	pop	ebp
	ret	0
?SimEWSJammerOff@@YAXKHPAX@Z ENDP			; SimEWSJammerOff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimEWSJammerOn@@YAXKHPAX@Z PROC			; SimEWSJammerOn

; 8231 : {

	push	ebp
	mov	ebp, esp

; 8232 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimEWSJamm

; 8233 : 		return;

	jmp	SHORT $LN4@SimEWSJamm
$LN3@SimEWSJamm:

; 8234 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimEWSJamm
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimEWSJamm
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimEWSJamm

; 8235 : 	{ 
; 8236 : 		SimDriver.GetPlayerAircraft()->PowerOn(AircraftClass::EWSJammerPower);

	push	8192					; 00002000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerOn@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerOn

; 8237 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimEWSJamm

; 8238 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_EWS_JMR_PWR, 2);

	push	2
	push	162					; 000000a2H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimEWSJamm:

; 8239 : 	}
; 8240 : }

	pop	ebp
	ret	0
?SimEWSJammerOn@@YAXKHPAX@Z ENDP			; SimEWSJammerOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimEWSJammerPower@@YAXKHPAX@Z PROC			; SimEWSJammerPower

; 8218 : {

	push	ebp
	mov	ebp, esp

; 8219 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimEWSJamm
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimEWSJamm
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimEWSJamm

; 8220 : 	{ 
; 8221 : 		SimDriver.GetPlayerAircraft()->PowerToggle(AircraftClass::EWSJammerPower);

	push	8192					; 00002000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerToggle@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerToggle

; 8222 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN3@SimEWSJamm

; 8223 : 			//OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_EWS_JMR_PWR, SimDriver.GetPlayerAircraft()->HasPower(AircraftClass::EWSJammerPower)+1);
; 8224 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_EWS_JMR_PWR, 1<<SimDriver.GetPlayerAircraft()->HasPower(AircraftClass::EWSJammerPower));

	push	8192					; 00002000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::HasPower
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	push	edx
	push	162					; 000000a2H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN3@SimEWSJamm:

; 8225 : 	}
; 8226 : }

	pop	ebp
	ret	0
?SimEWSJammerPower@@YAXKHPAX@Z ENDP			; SimEWSJammerPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimEWSRWROff@@YAXKHPAX@Z PROC				; SimEWSRWROff

; 8205 : {

	push	ebp
	mov	ebp, esp

; 8206 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimEWSRWRO

; 8207 : 		return;

	jmp	SHORT $LN4@SimEWSRWRO
$LN3@SimEWSRWRO:

; 8208 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimEWSRWRO
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimEWSRWRO
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimEWSRWRO

; 8209 : 	{ 
; 8210 : 		SimDriver.GetPlayerAircraft()->PowerOff(AircraftClass::EWSRWRPower);

	push	4096					; 00001000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerOff@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerOff

; 8211 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimEWSRWRO

; 8212 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_EWS_RWR_PWR, 1);

	push	1
	push	161					; 000000a1H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimEWSRWRO:

; 8213 : 	}
; 8214 : }

	pop	ebp
	ret	0
?SimEWSRWROff@@YAXKHPAX@Z ENDP				; SimEWSRWROff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimEWSRWROn@@YAXKHPAX@Z PROC				; SimEWSRWROn

; 8193 : {

	push	ebp
	mov	ebp, esp

; 8194 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimEWSRWRO

; 8195 : 		return;

	jmp	SHORT $LN4@SimEWSRWRO
$LN3@SimEWSRWRO:

; 8196 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimEWSRWRO
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimEWSRWRO
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimEWSRWRO

; 8197 : 	{ 
; 8198 : 		SimDriver.GetPlayerAircraft()->PowerOn(AircraftClass::EWSRWRPower);

	push	4096					; 00001000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerOn@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerOn

; 8199 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimEWSRWRO

; 8200 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_EWS_RWR_PWR, 2);

	push	2
	push	161					; 000000a1H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimEWSRWRO:

; 8201 : 	}
; 8202 : }

	pop	ebp
	ret	0
?SimEWSRWROn@@YAXKHPAX@Z ENDP				; SimEWSRWROn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimEWSRWRPower@@YAXKHPAX@Z PROC			; SimEWSRWRPower

; 8180 : {

	push	ebp
	mov	ebp, esp

; 8181 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimEWSRWRP
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimEWSRWRP
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimEWSRWRP

; 8182 : 	{ 
; 8183 : 		SimDriver.GetPlayerAircraft()->PowerToggle(AircraftClass::EWSRWRPower);

	push	4096					; 00001000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerToggle@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerToggle

; 8184 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN3@SimEWSRWRP

; 8185 : 			//OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_EWS_RWR_PWR, SimDriver.GetPlayerAircraft()->HasPower(AircraftClass::EWSRWRPower)+1);
; 8186 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_EWS_RWR_PWR, 1<<SimDriver.GetPlayerAircraft()->HasPower(AircraftClass::EWSRWRPower));

	push	4096					; 00001000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::HasPower
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	push	edx
	push	161					; 000000a1H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN3@SimEWSRWRP:

; 8187 : 	}
; 8188 : }

	pop	ebp
	ret	0
?SimEWSRWRPower@@YAXKHPAX@Z ENDP			; SimEWSRWRPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimSeatOff@@YAXKHPAX@Z PROC				; SimSeatOff

; 8165 : {

	push	ebp
	mov	ebp, esp

; 8166 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN4@SimSeatOff

; 8167 : 		return;

	jmp	$LN5@SimSeatOff
$LN4@SimSeatOff:

; 8168 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN5@SimSeatOff
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN5@SimSeatOff
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN5@SimSeatOff

; 8169 : 	{ 
; 8170 : 		if(g_bRealisticAvionics)

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	SHORT $LN5@SimSeatOff

; 8171 : 		{
; 8172 : 			SimDriver.GetPlayerAircraft()->SeatArmed = FALSE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	BYTE PTR [eax+1052], 0

; 8173 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN5@SimSeatOff

; 8174 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask(COMP_3DPIT_SEAT_ARM, SimDriver.GetPlayerAircraft()->SeatArmed+1);

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	movzx	eax, BYTE PTR [eax+1052]
	add	eax, 1
	push	eax
	push	221					; 000000ddH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN5@SimSeatOff:

; 8175 : 		}
; 8176 : 	}
; 8177 : }

	pop	ebp
	ret	0
?SimSeatOff@@YAXKHPAX@Z ENDP				; SimSeatOff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimSeatOn@@YAXKHPAX@Z PROC				; SimSeatOn

; 8150 : {

	push	ebp
	mov	ebp, esp

; 8151 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN4@SimSeatOn

; 8152 : 		return;

	jmp	$LN5@SimSeatOn
$LN4@SimSeatOn:

; 8153 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN5@SimSeatOn
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN5@SimSeatOn
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN5@SimSeatOn

; 8154 : 	{ 
; 8155 : 		if(g_bRealisticAvionics)

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	SHORT $LN5@SimSeatOn

; 8156 : 		{
; 8157 : 			SimDriver.GetPlayerAircraft()->SeatArmed = TRUE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	BYTE PTR [eax+1052], 1

; 8158 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN5@SimSeatOn

; 8159 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask(COMP_3DPIT_SEAT_ARM, SimDriver.GetPlayerAircraft()->SeatArmed+1);

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	movzx	eax, BYTE PTR [eax+1052]
	add	eax, 1
	push	eax
	push	221					; 000000ddH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN5@SimSeatOn:

; 8160 : 		}
; 8161 : 	}
; 8162 : }

	pop	ebp
	ret	0
?SimSeatOn@@YAXKHPAX@Z ENDP				; SimSeatOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimSeatArm@@YAXKHPAX@Z PROC				; SimSeatArm

; 8134 : {

	push	ebp
	mov	ebp, esp

; 8135 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimSeatArm
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimSeatArm
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN4@SimSeatArm

; 8136 : 	{ 
; 8137 : 		if(g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN4@SimSeatArm

; 8138 : 		{
; 8139 : 			SimDriver.GetPlayerAircraft()->StepSeatArm();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?StepSeatArm@AircraftClass@@QAEXXZ	; AircraftClass::StepSeatArm

; 8140 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimSeatArm

; 8141 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask(COMP_3DPIT_SEAT_ARM, SimDriver.GetPlayerAircraft()->SeatArmed+1);

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	movzx	edx, BYTE PTR [eax+1052]
	add	edx, 1
	push	edx
	push	221					; 000000ddH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimSeatArm:

; 8142 : 		}
; 8143 : 	}
; 8144 : }

	pop	ebp
	ret	0
?SimSeatArm@@YAXKHPAX@Z ENDP				; SimSeatArm
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_theRadar$1 = -12					; size = 4
_theRadar$2 = -8					; size = 4
_theRadar$3 = -4					; size = 4
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimTMSRight@@YAXKHPAX@Z PROC				; SimTMSRight

; 8031 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 8032 : static VU_TIME tmstimer = 0;
; 8033 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN39@SimTMSRigh
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN39@SimTMSRigh

; 8034 : 	{
; 8035 : 		if(g_bMLU)

	movzx	eax, BYTE PTR ?g_bMLU@@3_NA		; g_bMLU
	test	eax, eax
	je	$LN37@SimTMSRigh

; 8036 : 		{
; 8037 : 			if(state & KEY_DOWN && (!g_bMLU || !tmstimer || SimLibElapsedTime - tmstimer < 500))

	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN36@SimTMSRigh
	movzx	edx, BYTE PTR ?g_bMLU@@3_NA		; g_bMLU
	test	edx, edx
	je	SHORT $LN35@SimTMSRigh
	cmp	DWORD PTR ?tmstimer@?1??SimTMSRight@@YAXKHPAX@Z@4KA, 0
	je	SHORT $LN35@SimTMSRigh
	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	sub	eax, DWORD PTR ?tmstimer@?1??SimTMSRight@@YAXKHPAX@Z@4KA
	cmp	eax, 500				; 000001f4H
	jae	SHORT $LN36@SimTMSRigh
$LN35@SimTMSRigh:

; 8038 : 			{
; 8039 : 				if (!tmstimer)  tmstimer = SimLibElapsedTime;

	cmp	DWORD PTR ?tmstimer@?1??SimTMSRight@@YAXKHPAX@Z@4KA, 0
	jne	SHORT $LN34@SimTMSRigh
	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR ?tmstimer@?1??SimTMSRight@@YAXKHPAX@Z@4KA, ecx
$LN34@SimTMSRigh:

; 8040 : 			}
; 8041 : 			else

	jmp	$LN33@SimTMSRigh
$LN36@SimTMSRigh:

; 8042 : 			{
; 8043 : 				if (SimLibElapsedTime - tmstimer < 500 || !g_bMLU)

	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	sub	edx, DWORD PTR ?tmstimer@?1??SimTMSRight@@YAXKHPAX@Z@4KA
	cmp	edx, 500				; 000001f4H
	jb	SHORT $LN31@SimTMSRigh
	movzx	eax, BYTE PTR ?g_bMLU@@3_NA		; g_bMLU
	test	eax, eax
	jne	$LN32@SimTMSRigh
$LN31@SimTMSRigh:

; 8044 : 				{
; 8045 : 					if(g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	$LN30@SimTMSRigh

; 8046 : 					{
; 8047 : 						RadarDopplerClass* theRadar = (RadarDopplerClass*)FindSensor(SimDriver.GetPlayerAircraft(), SensorClass::Radar);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadar$3[ebp], eax

; 8048 : 						if(theRadar)

	cmp	DWORD PTR _theRadar$3[ebp], 0
	je	$LN30@SimTMSRigh

; 8049 : 						{
; 8050 : 							//ACM Modes
; 8051 : 							if(theRadar->GetRadarMode() == RadarClass::ACM_30x20 ||
; 8052 : 								theRadar->GetRadarMode() == RadarClass::ACM_SLEW ||
; 8053 : 								theRadar->GetRadarMode() == RadarClass::ACM_BORE ||
; 8054 : 								theRadar->GetRadarMode() == RadarClass::ACM_10x60)

	mov	edx, DWORD PTR _theRadar$3[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _theRadar$3[ebp]
	mov	edx, DWORD PTR [eax+220]
	call	edx
	cmp	eax, 6
	je	SHORT $LN27@SimTMSRigh
	mov	eax, DWORD PTR _theRadar$3[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _theRadar$3[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 7
	je	SHORT $LN27@SimTMSRigh
	mov	ecx, DWORD PTR _theRadar$3[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$3[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 8
	je	SHORT $LN27@SimTMSRigh
	mov	ecx, DWORD PTR _theRadar$3[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$3[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 9
	jne	SHORT $LN28@SimTMSRigh
$LN27@SimTMSRigh:

; 8055 : 							{
; 8056 : 								SimDriver.GetPlayerAircraft()->FCC->dropTrackCmd = FALSE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	mov	BYTE PTR [ecx+185], 0

; 8057 : 								theRadar->SelectACM30x20();

	mov	edx, DWORD PTR _theRadar$3[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _theRadar$3[ebp]
	mov	edx, DWORD PTR [eax+132]
	call	edx

; 8058 : 								theRadar->SetEmitting(TRUE);

	push	1
	mov	eax, DWORD PTR _theRadar$3[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _theRadar$3[ebp]
	mov	eax, DWORD PTR [edx+84]
	call	eax

; 8059 : 							}
; 8060 : 							else if(theRadar->GetRadarMode() == RadarClass::RWS ||

	jmp	$LN30@SimTMSRigh
$LN28@SimTMSRigh:

; 8061 : 									theRadar->GetRadarMode() == RadarClass::LRS ||
; 8062 : 									theRadar->GetRadarMode() == RadarClass::VS ||
; 8063 : 									theRadar->GetRadarMode() == RadarClass::SAM)

	mov	ecx, DWORD PTR _theRadar$3[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$3[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 2
	je	SHORT $LN24@SimTMSRigh
	mov	ecx, DWORD PTR _theRadar$3[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$3[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 3
	je	SHORT $LN24@SimTMSRigh
	mov	ecx, DWORD PTR _theRadar$3[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$3[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 5
	je	SHORT $LN24@SimTMSRigh
	mov	ecx, DWORD PTR _theRadar$3[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$3[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN25@SimTMSRigh
$LN24@SimTMSRigh:

; 8064 : 								theRadar->SelectTWS();

	mov	ecx, DWORD PTR _theRadar$3[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$3[ebp]
	mov	eax, DWORD PTR [edx+224]
	call	eax
	jmp	SHORT $LN30@SimTMSRigh
$LN25@SimTMSRigh:

; 8065 : 							else if(theRadar->GetRadarMode() == RadarClass::TWS)

	mov	ecx, DWORD PTR _theRadar$3[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$3[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 4
	jne	SHORT $LN30@SimTMSRigh

; 8066 : 								theRadar->NextTarget();

	mov	ecx, DWORD PTR _theRadar$3[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$3[ebp]
	mov	eax, DWORD PTR [edx+92]
	call	eax
$LN30@SimTMSRigh:

; 8067 : 						}
; 8068 : 					}
; 8069 : 				}
; 8070 : 				else 

	jmp	$LN21@SimTMSRigh
$LN32@SimTMSRigh:

; 8071 : 				{
; 8072 : 						RadarDopplerClass* theRadar = (RadarDopplerClass*)FindSensor(SimDriver.GetPlayerAircraft(), SensorClass::Radar);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadar$1[ebp], eax

; 8073 : 						if(theRadar)

	cmp	DWORD PTR _theRadar$1[ebp], 0
	je	$LN21@SimTMSRigh

; 8074 : 						{
; 8075 : 							//ACM Modes
; 8076 : 							if(theRadar->GetRadarMode() == RadarClass::ACM_30x20 ||
; 8077 : 								theRadar->GetRadarMode() == RadarClass::ACM_SLEW ||
; 8078 : 								theRadar->GetRadarMode() == RadarClass::ACM_BORE ||
; 8079 : 								theRadar->GetRadarMode() == RadarClass::ACM_10x60)

	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 6
	je	SHORT $LN18@SimTMSRigh
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 7
	je	SHORT $LN18@SimTMSRigh
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 8
	je	SHORT $LN18@SimTMSRigh
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 9
	jne	SHORT $LN19@SimTMSRigh
$LN18@SimTMSRigh:

; 8080 : 							{
; 8081 : 								SimDriver.GetPlayerAircraft()->FCC->dropTrackCmd = FALSE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	mov	BYTE PTR [ecx+185], 0

; 8082 : 								theRadar->SelectACM30x20();

	mov	edx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [eax+132]
	call	edx

; 8083 : 								theRadar->SetEmitting(TRUE);

	push	1
	mov	eax, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx+84]
	call	eax

; 8084 : 							}
; 8085 : 							else if(theRadar->GetRadarMode() == RadarClass::RWS ||

	jmp	SHORT $LN21@SimTMSRigh
$LN19@SimTMSRigh:

; 8086 : 									theRadar->GetRadarMode() == RadarClass::LRS ||
; 8087 : 									theRadar->GetRadarMode() == RadarClass::SAM)

	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 2
	je	SHORT $LN15@SimTMSRigh
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 3
	je	SHORT $LN15@SimTMSRigh
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN16@SimTMSRigh
$LN15@SimTMSRigh:

; 8088 : 								theRadar->SelectTWS();

	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx+224]
	call	eax
	jmp	SHORT $LN21@SimTMSRigh
$LN16@SimTMSRigh:

; 8089 : 							else if(theRadar->GetRadarMode() == RadarClass::TWS)

	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 4
	jne	SHORT $LN21@SimTMSRigh

; 8090 : 								theRadar->SelectRWS();

	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx+228]
	call	eax
$LN21@SimTMSRigh:

; 8091 : 						}
; 8092 : 				}
; 8093 : 			tmstimer = 0;

	mov	DWORD PTR ?tmstimer@?1??SimTMSRight@@YAXKHPAX@Z@4KA, 0

; 8094 : 			SimDriver.GetPlayerAircraft()->FCC->dropTrackCmd = FALSE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	mov	BYTE PTR [ecx+185], 0
$LN33@SimTMSRigh:

; 8095 : 			}
; 8096 : 		}
; 8097 : 		else

	jmp	$LN39@SimTMSRigh
$LN37@SimTMSRigh:

; 8098 : 		{
; 8099 : 			if(state & KEY_DOWN)

	mov	edx, DWORD PTR _state$[ebp]
	and	edx, 8
	je	$LN11@SimTMSRigh

; 8100 : 			{
; 8101 : 				if(g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	$LN10@SimTMSRigh

; 8102 : 				{
; 8103 : 					RadarDopplerClass* theRadar = (RadarDopplerClass*)FindSensor(SimDriver.GetPlayerAircraft(), SensorClass::Radar);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadar$2[ebp], eax

; 8104 : 					if(theRadar)

	cmp	DWORD PTR _theRadar$2[ebp], 0
	je	$LN10@SimTMSRigh

; 8105 : 					{
; 8106 : 						//ACM Modes
; 8107 : 						if(theRadar->GetRadarMode() == RadarClass::ACM_30x20 ||
; 8108 : 							theRadar->GetRadarMode() == RadarClass::ACM_SLEW ||
; 8109 : 							theRadar->GetRadarMode() == RadarClass::ACM_BORE ||
; 8110 : 							theRadar->GetRadarMode() == RadarClass::ACM_10x60)

	mov	ecx, DWORD PTR _theRadar$2[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$2[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 6
	je	SHORT $LN7@SimTMSRigh
	mov	ecx, DWORD PTR _theRadar$2[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$2[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 7
	je	SHORT $LN7@SimTMSRigh
	mov	ecx, DWORD PTR _theRadar$2[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$2[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 8
	je	SHORT $LN7@SimTMSRigh
	mov	ecx, DWORD PTR _theRadar$2[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$2[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 9
	jne	SHORT $LN8@SimTMSRigh
$LN7@SimTMSRigh:

; 8111 : 						{
; 8112 : 							SimDriver.GetPlayerAircraft()->FCC->dropTrackCmd = FALSE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	mov	BYTE PTR [ecx+185], 0

; 8113 : 							theRadar->SelectACM30x20();

	mov	edx, DWORD PTR _theRadar$2[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _theRadar$2[ebp]
	mov	edx, DWORD PTR [eax+132]
	call	edx

; 8114 : 							theRadar->SetEmitting(TRUE);

	push	1
	mov	eax, DWORD PTR _theRadar$2[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _theRadar$2[ebp]
	mov	eax, DWORD PTR [edx+84]
	call	eax

; 8115 : 						}
; 8116 : 						else if(theRadar->GetRadarMode() == RadarClass::RWS ||

	jmp	$LN10@SimTMSRigh
$LN8@SimTMSRigh:

; 8117 : 								theRadar->GetRadarMode() == RadarClass::LRS ||
; 8118 : 								theRadar->GetRadarMode() == RadarClass::VS ||
; 8119 : 								theRadar->GetRadarMode() == RadarClass::SAM)

	mov	ecx, DWORD PTR _theRadar$2[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$2[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 2
	je	SHORT $LN4@SimTMSRigh
	mov	ecx, DWORD PTR _theRadar$2[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$2[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 3
	je	SHORT $LN4@SimTMSRigh
	mov	ecx, DWORD PTR _theRadar$2[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$2[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 5
	je	SHORT $LN4@SimTMSRigh
	mov	ecx, DWORD PTR _theRadar$2[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$2[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN5@SimTMSRigh
$LN4@SimTMSRigh:

; 8120 : 							theRadar->SelectTWS();

	mov	ecx, DWORD PTR _theRadar$2[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$2[ebp]
	mov	eax, DWORD PTR [edx+224]
	call	eax
	jmp	SHORT $LN10@SimTMSRigh
$LN5@SimTMSRigh:

; 8121 : 						else if(theRadar->GetRadarMode() == RadarClass::TWS)

	mov	ecx, DWORD PTR _theRadar$2[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$2[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 4
	jne	SHORT $LN10@SimTMSRigh

; 8122 : 							theRadar->NextTarget();

	mov	ecx, DWORD PTR _theRadar$2[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$2[ebp]
	mov	eax, DWORD PTR [edx+92]
	call	eax
$LN10@SimTMSRigh:

; 8123 : 					}
; 8124 : 				}
; 8125 : 			}
; 8126 : 			else

	jmp	SHORT $LN39@SimTMSRigh
$LN11@SimTMSRigh:

; 8127 : 			{
; 8128 : 				SimDriver.GetPlayerAircraft()->FCC->dropTrackCmd = FALSE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	mov	BYTE PTR [ecx+185], 0
$LN39@SimTMSRigh:

; 8129 : 			}
; 8130 : 		}
; 8131 : 	}
; 8132 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimTMSRight@@YAXKHPAX@Z ENDP				; SimTMSRight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_theRadar$1 = -4					; size = 4
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimTMSDown@@YAXKHPAX@Z PROC				; SimTMSDown

; 7970 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 7971 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN21@SimTMSDown
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN21@SimTMSDown

; 7972 : 	{
; 7973 : 		if(state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN19@SimTMSDown

; 7974 : 		{
; 7975 : 			if(g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	$LN18@SimTMSDown

; 7976 : 			{
; 7977 : 				RadarDopplerClass* theRadar = (RadarDopplerClass*)FindSensor(SimDriver.GetPlayerAircraft(), SensorClass::Radar);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadar$1[ebp], eax

; 7978 : 				if(theRadar && theRadar->IsSOI())

	cmp	DWORD PTR _theRadar$1[ebp], 0
	je	$LN17@SimTMSDown
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	call	?IsSOI@DrawableClass@@QAEHXZ		; DrawableClass::IsSOI
	test	eax, eax
	je	$LN17@SimTMSDown

; 7979 : 				{
; 7980 : 					//ACM Modes
; 7981 : 					if(theRadar->GetRadarMode() == RadarClass::ACM_30x20 ||
; 7982 : 						theRadar->GetRadarMode() == RadarClass::ACM_SLEW ||
; 7983 : 						theRadar->GetRadarMode() == RadarClass::ACM_BORE ||
; 7984 : 						theRadar->GetRadarMode() == RadarClass::ACM_10x60)

	mov	edx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [eax+220]
	call	edx
	cmp	eax, 6
	je	SHORT $LN15@SimTMSDown
	mov	eax, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 7
	je	SHORT $LN15@SimTMSDown
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 8
	je	SHORT $LN15@SimTMSDown
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 9
	jne	SHORT $LN16@SimTMSDown
$LN15@SimTMSDown:

; 7985 : 					{
; 7986 : 						//First, drop our track
; 7987 : 						SimDriver.GetPlayerAircraft()->FCC->dropTrackCmd = FALSE;//Changed from TRUE

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	mov	BYTE PTR [ecx+185], 0

; 7988 : 						theRadar->SelectACMVertical();//Cobra BMS bug fix 01/29/05

	mov	edx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [eax+120]
	call	edx

; 7989 : 					}
; 7990 : 					else if(theRadar->GetRadarMode() == RadarClass::ACM_30x20 ||

	jmp	$LN17@SimTMSDown
$LN16@SimTMSDown:

; 7991 : 						theRadar->GetRadarMode() == RadarClass::ACM_SLEW ||
; 7992 : 						theRadar->GetRadarMode() == RadarClass::ACM_BORE)

	mov	eax, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 6
	je	SHORT $LN12@SimTMSDown
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 7
	je	SHORT $LN12@SimTMSDown
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 8
	jne	SHORT $LN13@SimTMSDown
$LN12@SimTMSDown:

; 7993 : 					{
; 7994 : 						theRadar->SelectACMVertical();

	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx+120]
	call	eax
	jmp	$LN17@SimTMSDown
$LN13@SimTMSDown:

; 7995 : 					}
; 7996 : 					else if(theRadar->GetRadarMode() == RadarClass::TWS)

	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 4
	jne	SHORT $LN10@SimTMSDown

; 7997 : 					{
; 7998 : 						// MD -- 20040118: revised TWS mode function -- only select RWS if the TWS track directory is empty
; 7999 : 						if(theRadar->CurrentTarget() || theRadar->twsTrackDirectory())

	mov	ecx, DWORD PTR _theRadar$1[ebp]
	call	?CurrentTarget@SensorClass@@QAEPAVSimObjectType@@XZ ; SensorClass::CurrentTarget
	test	eax, eax
	jne	SHORT $LN8@SimTMSDown
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	call	?twsTrackDirectory@RadarDopplerClass@@QAEPAVTWSTrackList@1@XZ ; RadarDopplerClass::twsTrackDirectory
	test	eax, eax
	je	SHORT $LN9@SimTMSDown
$LN8@SimTMSDown:

; 8000 : 						{
; 8001 : 							//First, drop our track
; 8002 : 							SimDriver.GetPlayerAircraft()->FCC->dropTrackCmd = TRUE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	mov	BYTE PTR [ecx+185], 1

; 8003 : 						}
; 8004 : 						else // if(!theRadar->CurrentTarget())  

	jmp	SHORT $LN7@SimTMSDown
$LN9@SimTMSDown:

; 8005 : 						{
; 8006 : 							theRadar->SelectRWS();

	mov	edx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [eax+228]
	call	edx
$LN7@SimTMSDown:

; 8007 : 						}

	jmp	SHORT $LN17@SimTMSDown
$LN10@SimTMSDown:

; 8008 : 					}
; 8009 : 					else if(theRadar->GetRadarMode() == RadarClass::SAM && theRadar->IsSet(RadarDopplerClass::STTingTarget))

	mov	eax, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN5@SimTMSDown
	push	65536					; 00010000H
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	call	?IsSet@RadarDopplerClass@@QAEHH@Z	; RadarDopplerClass::IsSet
	test	eax, eax
	je	SHORT $LN5@SimTMSDown

; 8010 : 						theRadar->SelectSAM();

	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx+232]
	call	eax

; 8011 : 					else

	jmp	SHORT $LN17@SimTMSDown
$LN5@SimTMSDown:

; 8012 : 						SimDriver.GetPlayerAircraft()->FCC->dropTrackCmd = TRUE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	mov	BYTE PTR [ecx+185], 1
$LN17@SimTMSDown:

; 8013 : 				}
; 8014 : 				if(SimDriver.GetPlayerAircraft()->FCC && SimDriver.GetPlayerAircraft()->FCC->IsSOI)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+936], 0
	je	SHORT $LN3@SimTMSDown
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+936]
	movzx	eax, BYTE PTR [edx+464]
	test	eax, eax
	je	SHORT $LN3@SimTMSDown

; 8015 : 				{
; 8016 : 					SimDriver.GetPlayerAircraft()->FCC->HSDDesignate = -1;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	mov	DWORD PTR [ecx+480], -1

; 8017 : 					return;

	jmp	SHORT $LN21@SimTMSDown

; 8018 : 				}
; 8019 : 				else

	jmp	SHORT $LN18@SimTMSDown
$LN3@SimTMSDown:

; 8020 : 					SimDriver.GetPlayerAircraft()->FCC->dropTrackCmd = TRUE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+936]
	mov	BYTE PTR [edx+185], 1
$LN18@SimTMSDown:

; 8021 : 			}
; 8022 : 		}
; 8023 : 		else

	jmp	SHORT $LN21@SimTMSDown
$LN19@SimTMSDown:

; 8024 : 		{
; 8025 : 			SimDriver.GetPlayerAircraft()->FCC->dropTrackCmd = FALSE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	eax, DWORD PTR [eax+936]
	mov	BYTE PTR [eax+185], 0

; 8026 : 			SimDriver.GetPlayerAircraft()->FCC->HSDDesignate = 0;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	mov	DWORD PTR [ecx+480], 0
$LN21@SimTMSDown:

; 8027 : 		}
; 8028 : 	}
; 8029 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimTMSDown@@YAXKHPAX@Z ENDP				; SimTMSDown
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv211 = -28						; size = 4
_m$1 = -24						; size = 4
_mavDisplay$2 = -20					; size = 4
_laserPod$3 = -16					; size = 4
_theRadar$4 = -12					; size = 4
_pac$ = -8						; size = 4
_HasMavs$ = -1						; size = 1
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimTMSLeft@@YAXKHPAX@Z PROC				; SimTMSLeft

; 7924 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 7925 : 	AircraftClass *pac = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _pac$[ebp], eax

; 7926 : 	bool HasMavs;
; 7927 : 	if (pac && pac->IsSetFlag(MOTION_OWNSHIP)){ 

	cmp	DWORD PTR _pac$[ebp], 0
	je	$LN14@SimTMSLeft
	push	65536					; 00010000H
	mov	ecx, DWORD PTR _pac$[ebp]
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN14@SimTMSLeft

; 7928 : 		if(state & KEY_DOWN){

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN12@SimTMSLeft

; 7929 : 			if(g_bRealisticAvionics && !g_bMLU){

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	$LN11@SimTMSLeft
	movzx	edx, BYTE PTR ?g_bMLU@@3_NA		; g_bMLU
	test	edx, edx
	jne	$LN11@SimTMSLeft

; 7930 : 				RadarDopplerClass* theRadar = (RadarDopplerClass*)FindSensor(pac, SensorClass::Radar);

	push	1
	mov	eax, DWORD PTR _pac$[ebp]
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadar$4[ebp], eax

; 7931 : 				LaserPodClass *laserPod = (LaserPodClass* )FindLaserPod(pac);

	mov	ecx, DWORD PTR _pac$[ebp]
	push	ecx
	call	?FindLaserPod@@YAPAVSensorClass@@PAVSimMoverClass@@@Z ; FindLaserPod
	add	esp, 4
	mov	DWORD PTR _laserPod$3[ebp], eax

; 7932 : 				MaverickDisplayClass* mavDisplay = NULL;

	mov	DWORD PTR _mavDisplay$2[ebp], 0

; 7933 : 				if (pac->Sms->curWeaponType == wtAgm65 && pac->Sms->curWeapon){

	mov	edx, DWORD PTR _pac$[ebp]
	mov	eax, DWORD PTR [edx+940]
	cmp	DWORD PTR [eax+148], 4
	jne	SHORT $LN10@SimTMSLeft
	mov	ecx, DWORD PTR _pac$[ebp]
	mov	ecx, DWORD PTR [ecx+940]
	add	ecx, 164				; 000000a4H
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN10@SimTMSLeft

; 7934 : 					HasMavs = TRUE;

	mov	BYTE PTR _HasMavs$[ebp], 1

; 7935 : 					mavDisplay = (MaverickDisplayClass*)((MissileClass*)pac->Sms->curWeapon.get())->display;

	mov	eax, DWORD PTR _pac$[ebp]
	mov	ecx, DWORD PTR [eax+940]
	add	ecx, 164				; 000000a4H
	call	?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::get
	mov	ecx, DWORD PTR [eax+712]
	mov	DWORD PTR _mavDisplay$2[ebp], ecx
$LN10@SimTMSLeft:

; 7936 : 				}
; 7937 : 				if(theRadar && theRadar->IsSOI()){

	cmp	DWORD PTR _theRadar$4[ebp], 0
	je	SHORT $LN9@SimTMSLeft
	mov	ecx, DWORD PTR _theRadar$4[ebp]
	call	?IsSOI@DrawableClass@@QAEHXZ		; DrawableClass::IsSOI
	test	eax, eax
	je	SHORT $LN9@SimTMSLeft

; 7938 : 					if(theRadar->DrawRCR){

	mov	edx, DWORD PTR _theRadar$4[ebp]
	movzx	eax, BYTE PTR [edx+132]
	test	eax, eax
	je	SHORT $LN8@SimTMSLeft

; 7939 : 						theRadar->DrawRCR = FALSE;

	mov	ecx, DWORD PTR _theRadar$4[ebp]
	mov	BYTE PTR [ecx+132], 0
$LN8@SimTMSLeft:

; 7940 : 					}
; 7941 : 					//Cobra
; 7942 : 					if(g_bIFF){

	movzx	edx, BYTE PTR ?g_bIFF@@3_NA		; g_bIFF
	test	edx, edx
	je	SHORT $LN7@SimTMSLeft

; 7943 : 						SimIFFIn(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimIFFIn@@YAXKHPAX@Z			; SimIFFIn
	add	esp, 12					; 0000000cH

; 7944 : 					}
; 7945 : 					else{

	jmp	SHORT $LN9@SimTMSLeft
$LN7@SimTMSLeft:

; 7946 : 						theRadar->DrawRCR = TRUE;

	mov	eax, DWORD PTR _theRadar$4[ebp]
	mov	BYTE PTR [eax+132], 1
$LN9@SimTMSLeft:

; 7947 : 					}
; 7948 : 				}
; 7949 : 				
; 7950 : 				//laserpod, toggle BHOT
; 7951 : 				if(laserPod && laserPod->IsSOI()){

	cmp	DWORD PTR _laserPod$3[ebp], 0
	je	SHORT $LN5@SimTMSLeft
	mov	ecx, DWORD PTR _laserPod$3[ebp]
	call	?IsSOI@DrawableClass@@QAEHXZ		; DrawableClass::IsSOI
	test	eax, eax
	je	SHORT $LN5@SimTMSLeft

; 7952 : 					laserPod->TogglePolarity();

	mov	ecx, DWORD PTR _laserPod$3[ebp]
	call	?TogglePolarity@LaserPodClass@@QAEXXZ	; LaserPodClass::TogglePolarity
	jmp	SHORT $LN11@SimTMSLeft
$LN5@SimTMSLeft:

; 7953 : 				}
; 7954 : 				else if (mavDisplay && mavDisplay->IsSOI()){

	cmp	DWORD PTR _mavDisplay$2[ebp], 0
	je	SHORT $LN11@SimTMSLeft
	mov	ecx, DWORD PTR _mavDisplay$2[ebp]
	call	?IsSOI@DrawableClass@@QAEHXZ		; DrawableClass::IsSOI
	test	eax, eax
	je	SHORT $LN11@SimTMSLeft

; 7955 : 					MissileClass *m = static_cast<MissileClass*>(pac->Sms->GetCurrentWeapon());

	mov	ecx, DWORD PTR _pac$[ebp]
	mov	edx, DWORD PTR [ecx+940]
	mov	eax, DWORD PTR _pac$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+940]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _m$1[ebp], eax

; 7956 : 					m->HOC = !m->HOC;

	mov	ecx, DWORD PTR _m$1[ebp]
	movzx	edx, BYTE PTR [ecx+813]
	test	edx, edx
	jne	SHORT $LN16@SimTMSLeft
	mov	DWORD PTR tv211[ebp], 1
	jmp	SHORT $LN17@SimTMSLeft
$LN16@SimTMSLeft:
	mov	DWORD PTR tv211[ebp], 0
$LN17@SimTMSLeft:
	mov	eax, DWORD PTR _m$1[ebp]
	mov	cl, BYTE PTR tv211[ebp]
	mov	BYTE PTR [eax+813], cl
$LN11@SimTMSLeft:

; 7957 : 				}
; 7958 : 			}
; 7959 : 			//else if(g_bRealisticAvionics && g_bIFF)
; 7960 : 				//SimIFFIn(0, KEY_DOWN, NULL);
; 7961 : 		}

	jmp	SHORT $LN14@SimTMSLeft
$LN12@SimTMSLeft:

; 7962 : 		//else if(g_bRealisticAvionics && g_bMLU)
; 7963 : 			//SimIFFIn(0, 0, NULL);
; 7964 : 		else if (g_bRealisticAvionics && g_bIFF){

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	SHORT $LN14@SimTMSLeft
	movzx	eax, BYTE PTR ?g_bIFF@@3_NA		; g_bIFF
	test	eax, eax
	je	SHORT $LN14@SimTMSLeft

; 7965 : 			SimIFFIn(0,0,NULL);

	push	0
	push	0
	push	0
	call	?SimIFFIn@@YAXKHPAX@Z			; SimIFFIn
	add	esp, 12					; 0000000cH
$LN14@SimTMSLeft:

; 7966 : 		}
; 7967 : 	}
; 7968 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimTMSLeft@@YAXKHPAX@Z ENDP				; SimTMSLeft
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_theHTS$1 = -24						; size = 4
_laserPod$2 = -20					; size = 4
_mavDisplay$3 = -16					; size = 4
_theRadar$4 = -12					; size = 4
_pac$ = -8						; size = 4
_HasMavs$5 = -1						; size = 1
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimTMSUp@@YAXKHPAX@Z PROC				; SimTMSUp

; 7850 : void SimTMSUp(unsigned long val, int state, void *){

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 7851 : 	AircraftClass *pac = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _pac$[ebp], eax

; 7852 : 	if(pac && pac->IsSetFlag(MOTION_OWNSHIP)){

	cmp	DWORD PTR _pac$[ebp], 0
	je	$LN1@SimTMSUp
	push	65536					; 00010000H
	mov	ecx, DWORD PTR _pac$[ebp]
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN1@SimTMSUp

; 7853 : 		if(state & KEY_DOWN){

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN22@SimTMSUp

; 7854 : 			if(g_bRealisticAvionics){

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	$LN2@SimTMSUp

; 7855 : 				RadarDopplerClass* theRadar = (RadarDopplerClass*)FindSensor(pac, SensorClass::Radar);

	push	1
	mov	edx, DWORD PTR _pac$[ebp]
	push	edx
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadar$4[ebp], eax

; 7856 : 				bool HasMavs = FALSE;

	mov	BYTE PTR _HasMavs$5[ebp], 0

; 7857 : 				LaserPodClass* laserPod = (LaserPodClass* )FindLaserPod (pac);

	mov	eax, DWORD PTR _pac$[ebp]
	push	eax
	call	?FindLaserPod@@YAPAVSensorClass@@PAVSimMoverClass@@@Z ; FindLaserPod
	add	esp, 4
	mov	DWORD PTR _laserPod$2[ebp], eax

; 7858 : 				MaverickDisplayClass* mavDisplay = NULL;

	mov	DWORD PTR _mavDisplay$3[ebp], 0

; 7859 : 				HarmTargetingPod *theHTS = (HarmTargetingPod*)FindSensor(pac, SensorClass::HTS);

	push	4
	mov	ecx, DWORD PTR _pac$[ebp]
	push	ecx
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theHTS$1[ebp], eax

; 7860 : 				if (pac->Sms->curWeaponType == wtAgm65 && pac->Sms->curWeapon){

	mov	edx, DWORD PTR _pac$[ebp]
	mov	eax, DWORD PTR [edx+940]
	cmp	DWORD PTR [eax+148], 4
	jne	SHORT $LN20@SimTMSUp
	mov	ecx, DWORD PTR _pac$[ebp]
	mov	ecx, DWORD PTR [ecx+940]
	add	ecx, 164				; 000000a4H
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN20@SimTMSUp

; 7861 : 					HasMavs = TRUE;

	mov	BYTE PTR _HasMavs$5[ebp], 1

; 7862 : 					mavDisplay = (MaverickDisplayClass*)((MissileClass*)pac->Sms->curWeapon.get())->display;

	mov	eax, DWORD PTR _pac$[ebp]
	mov	ecx, DWORD PTR [eax+940]
	add	ecx, 164				; 000000a4H
	call	?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::get
	mov	ecx, DWORD PTR [eax+712]
	mov	DWORD PTR _mavDisplay$3[ebp], ecx
$LN20@SimTMSUp:

; 7863 : 				}
; 7864 : 				
; 7865 : 				if (pac->FCC && pac->FCC->IsSOI){

	mov	edx, DWORD PTR _pac$[ebp]
	cmp	DWORD PTR [edx+936], 0
	je	SHORT $LN19@SimTMSUp
	mov	eax, DWORD PTR _pac$[ebp]
	mov	ecx, DWORD PTR [eax+936]
	movzx	edx, BYTE PTR [ecx+464]
	test	edx, edx
	je	SHORT $LN19@SimTMSUp

; 7866 : 					pac->FCC->HSDDesignate = 1;

	mov	eax, DWORD PTR _pac$[ebp]
	mov	ecx, DWORD PTR [eax+936]
	mov	DWORD PTR [ecx+480], 1

; 7867 : 					return;

	jmp	$LN24@SimTMSUp
	jmp	$LN2@SimTMSUp
$LN19@SimTMSUp:

; 7868 : 				}
; 7869 : 				else if (theRadar && theRadar->IsSOI()){

	cmp	DWORD PTR _theRadar$4[ebp], 0
	je	$LN17@SimTMSUp
	mov	ecx, DWORD PTR _theRadar$4[ebp]
	call	?IsSOI@DrawableClass@@QAEHXZ		; DrawableClass::IsSOI
	test	eax, eax
	je	$LN17@SimTMSUp

; 7870 : 					//ACM Modes
; 7871 : 					if (
; 7872 : 						theRadar->GetRadarMode() == RadarClass::ACM_30x20 ||
; 7873 : 						theRadar->GetRadarMode() == RadarClass::ACM_SLEW ||
; 7874 : 						theRadar->GetRadarMode() == RadarClass::ACM_BORE ||
; 7875 : 						theRadar->GetRadarMode() == RadarClass::ACM_10x60
; 7876 : 					){

	mov	edx, DWORD PTR _theRadar$4[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _theRadar$4[ebp]
	mov	edx, DWORD PTR [eax+220]
	call	edx
	cmp	eax, 6
	je	SHORT $LN15@SimTMSUp
	mov	eax, DWORD PTR _theRadar$4[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _theRadar$4[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 7
	je	SHORT $LN15@SimTMSUp
	mov	ecx, DWORD PTR _theRadar$4[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$4[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 8
	je	SHORT $LN15@SimTMSUp
	mov	ecx, DWORD PTR _theRadar$4[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$4[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 9
	jne	SHORT $LN16@SimTMSUp
$LN15@SimTMSUp:

; 7877 : 						pac->FCC->dropTrackCmd = FALSE;

	mov	ecx, DWORD PTR _pac$[ebp]
	mov	edx, DWORD PTR [ecx+936]
	mov	BYTE PTR [edx+185], 0

; 7878 : 						theRadar->SelectACMBore();

	mov	eax, DWORD PTR _theRadar$4[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _theRadar$4[ebp]
	mov	eax, DWORD PTR [edx+124]
	call	eax

; 7879 : 					}
; 7880 : 					else if(

	jmp	$LN13@SimTMSUp
$LN16@SimTMSUp:

; 7881 : 						theRadar->GetRadarMode() == RadarClass::RWS ||
; 7882 : 						theRadar->GetRadarMode() == RadarClass::LRS ||
; 7883 : 						theRadar->GetRadarMode() == RadarClass::VS ||
; 7884 : 						theRadar->GetRadarMode() == RadarClass::TWS ||
; 7885 : 						theRadar->GetRadarMode() == RadarClass::SAM ||
; 7886 : 						theRadar->IsAG())

	mov	ecx, DWORD PTR _theRadar$4[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$4[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 2
	je	SHORT $LN12@SimTMSUp
	mov	ecx, DWORD PTR _theRadar$4[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$4[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 3
	je	SHORT $LN12@SimTMSUp
	mov	ecx, DWORD PTR _theRadar$4[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$4[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 5
	je	SHORT $LN12@SimTMSUp
	mov	ecx, DWORD PTR _theRadar$4[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$4[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 4
	je	SHORT $LN12@SimTMSUp
	mov	ecx, DWORD PTR _theRadar$4[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$4[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN12@SimTMSUp
	mov	ecx, DWORD PTR _theRadar$4[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRadar$4[ebp]
	mov	eax, DWORD PTR [edx+188]
	call	eax
	test	eax, eax
	je	SHORT $LN13@SimTMSUp
$LN12@SimTMSUp:

; 7887 : 					{
; 7888 : 						pac->FCC->designateCmd = TRUE;

	mov	ecx, DWORD PTR _pac$[ebp]
	mov	edx, DWORD PTR [ecx+936]
	mov	BYTE PTR [edx+184], 1
$LN13@SimTMSUp:

; 7889 : 					}
; 7890 : 				}

	jmp	$LN2@SimTMSUp
$LN17@SimTMSUp:

; 7891 : 				else if(TheHud && TheHud->IsSOI()){

	cmp	DWORD PTR ?TheHud@@3PAVHudClass@@A, 0	; TheHud
	je	SHORT $LN10@SimTMSUp
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?IsSOI@DrawableClass@@QAEHXZ		; DrawableClass::IsSOI
	test	eax, eax
	je	SHORT $LN10@SimTMSUp

; 7892 : 					pac->FCC->designateCmd = TRUE;

	mov	eax, DWORD PTR _pac$[ebp]
	mov	ecx, DWORD PTR [eax+936]
	mov	BYTE PTR [ecx+184], 1
	jmp	$LN2@SimTMSUp
$LN10@SimTMSUp:

; 7893 : 				}
; 7894 : 				else if(HasMavs && mavDisplay && mavDisplay->IsSOI())

	movzx	edx, BYTE PTR _HasMavs$5[ebp]
	test	edx, edx
	je	SHORT $LN8@SimTMSUp
	cmp	DWORD PTR _mavDisplay$3[ebp], 0
	je	SHORT $LN8@SimTMSUp
	mov	ecx, DWORD PTR _mavDisplay$3[ebp]
	call	?IsSOI@DrawableClass@@QAEHXZ		; DrawableClass::IsSOI
	test	eax, eax
	je	SHORT $LN8@SimTMSUp

; 7895 : 				{
; 7896 : 					if (
; 7897 : 						pac->Sms->curWeapon && !((MissileClass*)pac->Sms->curWeapon.get())->Covered &&
; 7898 : 						pac->Sms->MavCoolTimer < 0.0F
; 7899 : 					){

	mov	eax, DWORD PTR _pac$[ebp]
	mov	ecx, DWORD PTR [eax+940]
	add	ecx, 164				; 000000a4H
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN7@SimTMSUp
	mov	edx, DWORD PTR _pac$[ebp]
	mov	ecx, DWORD PTR [edx+940]
	add	ecx, 164				; 000000a4H
	call	?get@?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::get
	movzx	eax, BYTE PTR [eax+812]
	test	eax, eax
	jne	SHORT $LN7@SimTMSUp
	mov	ecx, DWORD PTR _pac$[ebp]
	mov	edx, DWORD PTR [ecx+940]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [edx+20]
	jbe	SHORT $LN7@SimTMSUp

; 7900 : 						pac->FCC->designateCmd = TRUE;

	mov	eax, DWORD PTR _pac$[ebp]
	mov	ecx, DWORD PTR [eax+936]
	mov	BYTE PTR [ecx+184], 1
$LN7@SimTMSUp:

; 7901 : 					}
; 7902 : 				}

	jmp	SHORT $LN2@SimTMSUp
$LN8@SimTMSUp:

; 7903 : 				else if (laserPod && laserPod->IsSOI()){

	cmp	DWORD PTR _laserPod$2[ebp], 0
	je	SHORT $LN5@SimTMSUp
	mov	ecx, DWORD PTR _laserPod$2[ebp]
	call	?IsSOI@DrawableClass@@QAEHXZ		; DrawableClass::IsSOI
	test	eax, eax
	je	SHORT $LN5@SimTMSUp

; 7904 : 					if (pac->FCC->preDesignate)

	mov	edx, DWORD PTR _pac$[ebp]
	mov	eax, DWORD PTR [edx+936]
	movsx	ecx, BYTE PTR [eax+182]
	test	ecx, ecx
	je	SHORT $LN4@SimTMSUp

; 7905 : 					{
; 7906 : 						pac->FCC->SetLastDesignate();

	mov	edx, DWORD PTR _pac$[ebp]
	mov	ecx, DWORD PTR [edx+936]
	call	?SetLastDesignate@FireControlComputer@@QAEXXZ ; FireControlComputer::SetLastDesignate

; 7907 : 						pac->FCC->preDesignate = FALSE;

	mov	eax, DWORD PTR _pac$[ebp]
	mov	ecx, DWORD PTR [eax+936]
	mov	BYTE PTR [ecx+182], 0
$LN4@SimTMSUp:

; 7908 : 					}
; 7909 : 					pac->FCC->designateCmd = TRUE;

	mov	edx, DWORD PTR _pac$[ebp]
	mov	eax, DWORD PTR [edx+936]
	mov	BYTE PTR [eax+184], 1
	jmp	SHORT $LN2@SimTMSUp
$LN5@SimTMSUp:

; 7910 : 				}
; 7911 : 				else if (theHTS){

	cmp	DWORD PTR _theHTS$1[ebp], 0
	je	SHORT $LN2@SimTMSUp

; 7912 : 					pac->FCC->designateCmd = TRUE;

	mov	ecx, DWORD PTR _pac$[ebp]
	mov	edx, DWORD PTR [ecx+936]
	mov	BYTE PTR [edx+184], 1
$LN2@SimTMSUp:

; 7913 : 				}
; 7914 : 			}
; 7915 : 		}
; 7916 : 		else {

	jmp	SHORT $LN1@SimTMSUp
$LN22@SimTMSUp:

; 7917 : 			pac->FCC->designateCmd = FALSE;

	mov	eax, DWORD PTR _pac$[ebp]
	mov	ecx, DWORD PTR [eax+936]
	mov	BYTE PTR [ecx+184], 0

; 7918 : 			pac->FCC->dropTrackCmd = FALSE;

	mov	edx, DWORD PTR _pac$[ebp]
	mov	eax, DWORD PTR [edx+936]
	mov	BYTE PTR [eax+185], 0

; 7919 : 			pac->FCC->HSDDesignate = 0;

	mov	ecx, DWORD PTR _pac$[ebp]
	mov	edx, DWORD PTR [ecx+936]
	mov	DWORD PTR [edx+480], 0
$LN1@SimTMSUp:
$LN24@SimTMSUp:

; 7920 : 		}
; 7921 : 	}
; 7922 : } 

	mov	esp, ebp
	pop	ebp
	ret	0
?SimTMSUp@@YAXKHPAX@Z ENDP				; SimTMSUp
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimReticleOff@@YAXKHPAX@Z PROC				; SimReticleOff

; 7748 : {

	push	ebp
	mov	ebp, esp

; 7749 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimReticle

; 7750 : 		return;

	jmp	SHORT $LN4@SimReticle
$LN3@SimReticle:

; 7751 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimReticle
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimReticle
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimReticle

; 7752 : 	{
; 7753 : 		TheHud->WhichMode = 0;	// OFF

	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	DWORD PTR [edx+5016], 0

; 7754 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimReticle

; 7755 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HUD_RETICLE, 1);

	push	1
	push	201					; 000000c9H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimReticle:

; 7756 : 	}
; 7757 : }

	pop	ebp
	ret	0
?SimReticleOff@@YAXKHPAX@Z ENDP				; SimReticleOff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimReticleStby@@YAXKHPAX@Z PROC			; SimReticleStby

; 7736 : {

	push	ebp
	mov	ebp, esp

; 7737 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimReticle

; 7738 : 		return;

	jmp	SHORT $LN4@SimReticle
$LN3@SimReticle:

; 7739 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimReticle
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimReticle
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimReticle

; 7740 : 	{
; 7741 : 		TheHud->WhichMode = 2;	// STBY

	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	DWORD PTR [edx+5016], 2

; 7742 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimReticle

; 7743 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HUD_RETICLE, 4);

	push	4
	push	201					; 000000c9H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimReticle:

; 7744 : 	}
; 7745 : }

	pop	ebp
	ret	0
?SimReticleStby@@YAXKHPAX@Z ENDP			; SimReticleStby
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimReticlePri@@YAXKHPAX@Z PROC				; SimReticlePri

; 7724 : {

	push	ebp
	mov	ebp, esp

; 7725 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimReticle

; 7726 : 		return;

	jmp	SHORT $LN4@SimReticle
$LN3@SimReticle:

; 7727 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimReticle
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimReticle
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimReticle

; 7728 : 	{
; 7729 : 		TheHud->WhichMode = 1;	// PRI

	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	DWORD PTR [edx+5016], 1

; 7730 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimReticle

; 7731 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HUD_RETICLE, 2);

	push	2
	push	201					; 000000c9H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimReticle:

; 7732 : 	}
; 7733 : }

	pop	ebp
	ret	0
?SimReticlePri@@YAXKHPAX@Z ENDP				; SimReticlePri
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimReticleSwitch@@YAXKHPAX@Z PROC			; SimReticleSwitch

; 7696 : {

	push	ebp
	mov	ebp, esp

; 7697 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN9@SimReticle
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN9@SimReticle
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN9@SimReticle

; 7698 : 	{
; 7699 : 		if(TheHud->WhichMode == 0)	// Off

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	cmp	DWORD PTR [ecx+5016], 0
	jne	SHORT $LN7@SimReticle

; 7700 : 		{
; 7701 : 			TheHud->WhichMode = 1;	// PRI

	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	DWORD PTR [edx+5016], 1

; 7702 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN6@SimReticle

; 7703 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HUD_RETICLE, 2);

	push	2
	push	201					; 000000c9H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN6@SimReticle:

; 7704 : 		}

	jmp	SHORT $LN9@SimReticle
$LN7@SimReticle:

; 7705 : 		else if(TheHud->WhichMode == 1)	// PRI

	mov	eax, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	cmp	DWORD PTR [eax+5016], 1
	jne	SHORT $LN4@SimReticle

; 7706 : 		{
; 7707 : 			TheHud->WhichMode = 2;	// STBY

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	DWORD PTR [ecx+5016], 2

; 7708 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN3@SimReticle

; 7709 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HUD_RETICLE, 4);

	push	4
	push	201					; 000000c9H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN3@SimReticle:

; 7710 : 		}
; 7711 : 		else

	jmp	SHORT $LN9@SimReticle
$LN4@SimReticle:

; 7712 : 		{
; 7713 : 			TheHud->WhichMode = 0;	// Off

	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	DWORD PTR [edx+5016], 0

; 7714 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN9@SimReticle

; 7715 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HUD_RETICLE, 1);

	push	1
	push	201					; 000000c9H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN9@SimReticle:

; 7716 : 		}
; 7717 : 	}
; 7718 : }

	pop	ebp
	ret	0
?SimReticleSwitch@@YAXKHPAX@Z ENDP			; SimReticleSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimWarnReset@@YAXKHPAX@Z PROC				; SimWarnReset

; 7677 : {

	push	ebp
	mov	ebp, esp

; 7678 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN4@SimWarnRes
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimWarnRes
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN4@SimWarnRes

; 7679 : 	{
; 7680 : 		SimDriver.GetPlayerAircraft()->mFaults->ClearWarnReset();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+928]
	call	?ClearWarnReset@FackClass@@QAEXXZ	; FackClass::ClearWarnReset

; 7681 : 		SimDriver.GetPlayerAircraft()->mFaults->SetManWarnReset();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+928]
	call	?SetManWarnReset@FackClass@@QAEXXZ	; FackClass::SetManWarnReset

; 7682 : 		TheHud->ResetMaxG();

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?ResetMaxG@HudClass@@QAEXXZ		; HudClass::ResetMaxG

; 7683 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN2@SimWarnRes

; 7684 : 		{
; 7685 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_ICP_DRIFTCO, 4);

	push	4
	push	129					; 00000081H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 7686 : 			// Delay....then off = momentary switch
; 7687 : 			//OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_ICP_DRIFTCO, 0);
; 7688 : 		}
; 7689 : 	else

	jmp	SHORT $LN4@SimWarnRes
$LN2@SimWarnRes:

; 7690 : 		{
; 7691 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_ICP_DRIFTCO, 1);

	push	1
	push	129					; 00000081H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimWarnRes:

; 7692 : 		}
; 7693 : 	}
; 7694 : }

	pop	ebp
	ret	0
?SimWarnReset@@YAXKHPAX@Z ENDP				; SimWarnReset
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimAPOverride@@YAXKHPAX@Z PROC				; SimAPOverride

; 7623 : {

	push	ebp
	mov	ebp, esp
	push	esi

; 7624 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN10@SimAPOverr
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN10@SimAPOverr

; 7625 : 	{
; 7626 : 		if(state & KEY_DOWN)

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN8@SimAPOverr

; 7627 : 		{
; 7628 : 		    // JPO - save AP type.
; 7629 : 			//MI only if it's != APOFF
; 7630 : 			if(SimDriver.GetPlayerAircraft()->AutopilotType() != AircraftClass::APOff)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?AutopilotType@AircraftClass@@QAE?AW4AutoPilotType@1@XZ ; AircraftClass::AutopilotType
	cmp	eax, 4
	je	SHORT $LN7@SimAPOverr

; 7631 : 				SimDriver.GetPlayerAircraft()->lastapType = SimDriver.GetPlayerAircraft()->AutopilotType();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?AutopilotType@AircraftClass@@QAE?AW4AutoPilotType@1@XZ ; AircraftClass::AutopilotType
	mov	esi, eax
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR [eax+972], esi
$LN7@SimAPOverr:

; 7632 : 			if(SimDriver.GetPlayerAircraft()->autopilotType != AircraftClass::APOff)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+968], 4
	je	SHORT $LN6@SimAPOverr

; 7633 : 				SimDriver.GetPlayerAircraft()->SetAutopilot(AircraftClass::APOff);

	push	4
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetAutopilot@AircraftClass@@QAEXW4AutoPilotType@1@@Z ; AircraftClass::SetAutopilot
$LN6@SimAPOverr:

; 7634 : 		    SimDriver.GetPlayerAircraft()->SetAPFlag(AircraftClass::Override);

	push	32					; 00000020H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetAPFlag@AircraftClass@@QAEXW4APFlags@1@@Z ; AircraftClass::SetAPFlag

; 7635 : 		}
; 7636 : 		else

	jmp	$LN10@SimAPOverr
$LN8@SimAPOverr:

; 7637 : 		{
; 7638 : 			SimDriver.GetPlayerAircraft()->SetAutopilot(SimDriver.GetPlayerAircraft()->lastapType);

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+972]
	push	ecx
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetAutopilot@AircraftClass@@QAEXW4AutoPilotType@1@@Z ; AircraftClass::SetAutopilot

; 7639 : 		    SimDriver.GetPlayerAircraft()->ClearAPFlag(AircraftClass::Override);

	push	32					; 00000020H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?ClearAPFlag@AircraftClass@@QAEXW4APFlags@1@@Z ; AircraftClass::ClearAPFlag

; 7640 : 		    if (SimDriver.GetPlayerAircraft()->lastapType != AircraftClass::LantirnAP) { // JPO - lantirn stays

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+972], 3
	je	$LN10@SimAPOverr

; 7641 : 				SimDriver.GetPlayerAircraft()->SetAPParameters();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetAPParameters@AircraftClass@@QAEXXZ	; AircraftClass::SetAPParameters

; 7642 : 				if(SimDriver.GetPlayerAircraft()->IsOn(AircraftClass::RollHold))

	push	8
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsOn@AircraftClass@@QAEHW4APFlags@1@@Z	; AircraftClass::IsOn
	test	eax, eax
	je	SHORT $LN3@SimAPOverr

; 7643 : 					SimDriver.GetPlayerAircraft()->SetNewRoll();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetNewRoll@AircraftClass@@QAEXXZ	; AircraftClass::SetNewRoll
$LN3@SimAPOverr:

; 7644 : 				if(SimDriver.GetPlayerAircraft()->IsOn(AircraftClass::AttHold))

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsOn@AircraftClass@@QAEHW4APFlags@1@@Z	; AircraftClass::IsOn
	test	eax, eax
	je	SHORT $LN2@SimAPOverr

; 7645 : 					SimDriver.GetPlayerAircraft()->SetNewPitch();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetNewPitch@AircraftClass@@QAEXXZ	; AircraftClass::SetNewPitch
$LN2@SimAPOverr:

; 7646 : 				if(SimDriver.GetPlayerAircraft()->IsOn(AircraftClass::AltHold))

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsOn@AircraftClass@@QAEHW4APFlags@1@@Z	; AircraftClass::IsOn
	test	eax, eax
	je	SHORT $LN10@SimAPOverr

; 7647 : 					SimDriver.GetPlayerAircraft()->SetNewAlt();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetNewAlt@AircraftClass@@QAEXXZ	; AircraftClass::SetNewAlt
$LN10@SimAPOverr:

; 7648 : 		    }
; 7649 : 		}
; 7650 : 	}
; 7651 : }

	pop	esi
	pop	ebp
	ret	0
?SimAPOverride@@YAXKHPAX@Z ENDP				; SimAPOverride
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimLeftAPDown@@YAXKHPAX@Z PROC				; SimLeftAPDown

; 7608 : {

	push	ebp
	mov	ebp, esp

; 7609 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimLeftAPD

; 7610 : 		return;

	jmp	$LN4@SimLeftAPD
$LN3@SimLeftAPD:

; 7611 : 	//This is the left switch, going to the HDG SEL position.
; 7612 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)) {

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN4@SimLeftAPD
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimLeftAPD
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimLeftAPD

; 7613 : 		SimDriver.GetPlayerAircraft()->ClearAPFlag(AircraftClass::RollHold);

	push	8
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?ClearAPFlag@AircraftClass@@QAEXW4APFlags@1@@Z ; AircraftClass::ClearAPFlag

; 7614 : 		SimDriver.GetPlayerAircraft()->ClearAPFlag(AircraftClass::HDGSel);

	push	16					; 00000010H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?ClearAPFlag@AircraftClass@@QAEXW4APFlags@1@@Z ; AircraftClass::ClearAPFlag

; 7615 : 		SimDriver.GetPlayerAircraft()->SetAPFlag(AircraftClass::StrgSel);

	push	4
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetAPFlag@AircraftClass@@QAEXW4APFlags@1@@Z ; AircraftClass::SetAPFlag

; 7616 : 
; 7617 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimLeftAPD

; 7618 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_LT_AP_SW, 4);

	push	4
	push	137					; 00000089H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimLeftAPD:

; 7619 : 	}
; 7620 : }

	pop	ebp
	ret	0
?SimLeftAPDown@@YAXKHPAX@Z ENDP				; SimLeftAPDown
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimLeftAPMid@@YAXKHPAX@Z PROC				; SimLeftAPMid

; 7588 : {

	push	ebp
	mov	ebp, esp

; 7589 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN5@SimLeftAPM

; 7590 : 		return;

	jmp	$LN6@SimLeftAPM
$LN5@SimLeftAPM:

; 7591 : 	//This is the left switch, going to the HDG SEL position.
; 7592 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)) {

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN6@SimLeftAPM
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN6@SimLeftAPM
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	$LN6@SimLeftAPM

; 7593 : 		SimDriver.GetPlayerAircraft()->ClearAPFlag(AircraftClass::StrgSel);

	push	4
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?ClearAPFlag@AircraftClass@@QAEXW4APFlags@1@@Z ; AircraftClass::ClearAPFlag

; 7594 : 		SimDriver.GetPlayerAircraft()->ClearAPFlag(AircraftClass::HDGSel);

	push	16					; 00000010H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?ClearAPFlag@AircraftClass@@QAEXW4APFlags@1@@Z ; AircraftClass::ClearAPFlag

; 7595 : 		SimDriver.GetPlayerAircraft()->SetAPFlag(AircraftClass::RollHold);

	push	8
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetAPFlag@AircraftClass@@QAEXW4APFlags@1@@Z ; AircraftClass::SetAPFlag

; 7596 : 		if((SimDriver.GetPlayerAircraft()->IsOn(AircraftClass::AttHold)) || (SimDriver.GetPlayerAircraft()->IsOn(AircraftClass::AltHold))) {

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsOn@AircraftClass@@QAEHW4APFlags@1@@Z	; AircraftClass::IsOn
	test	eax, eax
	jne	SHORT $LN2@SimLeftAPM
	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsOn@AircraftClass@@QAEHW4APFlags@1@@Z	; AircraftClass::IsOn
	test	eax, eax
	je	SHORT $LN3@SimLeftAPM
$LN2@SimLeftAPM:

; 7597 : 			SimDriver.GetPlayerAircraft()->SetNewRoll();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetNewRoll@AircraftClass@@QAEXXZ	; AircraftClass::SetNewRoll
$LN3@SimLeftAPM:

; 7598 : 			// MD -- 20031108: fixing AP ATT HLD modes.  Roll switch should set roll not pitch.
; 7599 : 			// SimDriver.GetPlayerAircraft()->SetNewPitch();
; 7600 : 		}
; 7601 : 
; 7602 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN6@SimLeftAPM

; 7603 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_LT_AP_SW, 1);

	push	1
	push	137					; 00000089H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN6@SimLeftAPM:

; 7604 : 	}
; 7605 : }

	pop	ebp
	ret	0
?SimLeftAPMid@@YAXKHPAX@Z ENDP				; SimLeftAPMid
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimLeftAPUp@@YAXKHPAX@Z PROC				; SimLeftAPUp

; 7573 : {

	push	ebp
	mov	ebp, esp

; 7574 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimLeftAPU

; 7575 : 		return;

	jmp	$LN4@SimLeftAPU
$LN3@SimLeftAPU:

; 7576 : 	//This is the left switch, going to the HDG SEL position.
; 7577 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)) {

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN4@SimLeftAPU
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimLeftAPU
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimLeftAPU

; 7578 : 		SimDriver.GetPlayerAircraft()->ClearAPFlag(AircraftClass::StrgSel);

	push	4
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?ClearAPFlag@AircraftClass@@QAEXW4APFlags@1@@Z ; AircraftClass::ClearAPFlag

; 7579 : 		SimDriver.GetPlayerAircraft()->ClearAPFlag(AircraftClass::RollHold);

	push	8
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?ClearAPFlag@AircraftClass@@QAEXW4APFlags@1@@Z ; AircraftClass::ClearAPFlag

; 7580 : 		SimDriver.GetPlayerAircraft()->SetAPFlag(AircraftClass::HDGSel);

	push	16					; 00000010H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetAPFlag@AircraftClass@@QAEXW4APFlags@1@@Z ; AircraftClass::SetAPFlag

; 7581 : 
; 7582 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimLeftAPU

; 7583 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_LT_AP_SW, 2);

	push	2
	push	137					; 00000089H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimLeftAPU:

; 7584 : 	}
; 7585 : }

	pop	ebp
	ret	0
?SimLeftAPUp@@YAXKHPAX@Z ENDP				; SimLeftAPUp
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimRightAPDown@@YAXKHPAX@Z PROC			; SimRightAPDown

; 7497 : {

	push	ebp
	mov	ebp, esp

; 7498 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN4@SimRightAP

; 7499 : 		return;

	jmp	$LN5@SimRightAP
$LN4@SimRightAP:

; 7500 : 	//This is the right switch, going to the ATT HOLD position
; 7501 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)) {

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN5@SimRightAP
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN5@SimRightAP
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	$LN5@SimRightAP

; 7502 : 		SimDriver.GetPlayerAircraft()->ClearAPFlag(AircraftClass::AltHold);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?ClearAPFlag@AircraftClass@@QAEXW4APFlags@1@@Z ; AircraftClass::ClearAPFlag

; 7503 : 		//can't be both
; 7504 : 		SimDriver.GetPlayerAircraft()->SetAPFlag(AircraftClass::AttHold);	//down

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetAPFlag@AircraftClass@@QAEXW4APFlags@1@@Z ; AircraftClass::SetAPFlag

; 7505 : 		SimDriver.GetPlayerAircraft()->SetNewPitch();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetNewPitch@AircraftClass@@QAEXXZ	; AircraftClass::SetNewPitch

; 7506 : 		// MD -- 20031108: fixing AP ATT HLD modes.  Pitch switch should not set roll unless the
; 7507 : 		// roll mode is set to roll hold.
; 7508 : 		if ( (!SimDriver.GetPlayerAircraft()->IsOn(AircraftClass::StrgSel)) && (!SimDriver.GetPlayerAircraft()->IsOn(AircraftClass::HDGSel))) {

	push	4
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsOn@AircraftClass@@QAEHW4APFlags@1@@Z	; AircraftClass::IsOn
	test	eax, eax
	jne	SHORT $LN2@SimRightAP
	push	16					; 00000010H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsOn@AircraftClass@@QAEHW4APFlags@1@@Z	; AircraftClass::IsOn
	test	eax, eax
	jne	SHORT $LN2@SimRightAP

; 7509 : 			SimDriver.GetPlayerAircraft()->SetAPFlag(AircraftClass::RollHold); // needed in case this is the first time and switch is still in default position

	push	8
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetAPFlag@AircraftClass@@QAEXW4APFlags@1@@Z ; AircraftClass::SetAPFlag

; 7510 : 			SimDriver.GetPlayerAircraft()->SetNewRoll();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetNewRoll@AircraftClass@@QAEXXZ	; AircraftClass::SetNewRoll
$LN2@SimRightAP:

; 7511 : 		}
; 7512 : 		//Tell us what we want
; 7513 : 		SimDriver.GetPlayerAircraft()->SetAPParameters();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetAPParameters@AircraftClass@@QAEXXZ	; AircraftClass::SetAPParameters

; 7514 : 		// now apply power
; 7515 : 		SimDriver.GetPlayerAircraft()->PowerOn(AircraftClass::APPower);

	push	262144					; 00040000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerOn@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerOn

; 7516 : 
; 7517 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN5@SimRightAP

; 7518 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_RT_AP_SW, 4);

	push	4
	push	136					; 00000088H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN5@SimRightAP:

; 7519 : 	}
; 7520 : }

	pop	ebp
	ret	0
?SimRightAPDown@@YAXKHPAX@Z ENDP			; SimRightAPDown
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimRightAPMid@@YAXKHPAX@Z PROC				; SimRightAPMid

; 7479 : {

	push	ebp
	mov	ebp, esp

; 7480 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimRightAP

; 7481 : 		return;

	jmp	$LN4@SimRightAP
$LN3@SimRightAP:

; 7482 : 	//This is the right switch, going to the A/P OFF position
; 7483 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)) {

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN4@SimRightAP
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimRightAP
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimRightAP

; 7484 : 		SimDriver.GetPlayerAircraft()->ClearAPFlag(AircraftClass::AttHold);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?ClearAPFlag@AircraftClass@@QAEXW4APFlags@1@@Z ; AircraftClass::ClearAPFlag

; 7485 : 		SimDriver.GetPlayerAircraft()->ClearAPFlag(AircraftClass::AltHold);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?ClearAPFlag@AircraftClass@@QAEXW4APFlags@1@@Z ; AircraftClass::ClearAPFlag

; 7486 : 		//take the juice
; 7487 : 		SimDriver.GetPlayerAircraft()->PowerOff(AircraftClass::APPower);

	push	262144					; 00040000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerOff@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerOff

; 7488 : 		//Tell us what we want
; 7489 : 		SimDriver.GetPlayerAircraft()->SetAutopilot(AircraftClass::APOff);

	push	4
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetAutopilot@AircraftClass@@QAEXW4AutoPilotType@1@@Z ; AircraftClass::SetAutopilot

; 7490 : 
; 7491 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimRightAP

; 7492 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_RT_AP_SW, 1);

	push	1
	push	136					; 00000088H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimRightAP:

; 7493 : 	}
; 7494 : }

	pop	ebp
	ret	0
?SimRightAPMid@@YAXKHPAX@Z ENDP				; SimRightAPMid
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimRightAPUp@@YAXKHPAX@Z PROC				; SimRightAPUp

; 7452 : {

	push	ebp
	mov	ebp, esp

; 7453 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN4@SimRightAP

; 7454 : 		return;

	jmp	$LN5@SimRightAP
$LN4@SimRightAP:

; 7455 : 	//This is the right switch, going to the ALT HOLD position
; 7456 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)) {

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN5@SimRightAP
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN5@SimRightAP
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	$LN5@SimRightAP

; 7457 : 		SimDriver.GetPlayerAircraft()->ClearAPFlag(AircraftClass::AttHold);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?ClearAPFlag@AircraftClass@@QAEXW4APFlags@1@@Z ; AircraftClass::ClearAPFlag

; 7458 : 		//can't be both
; 7459 : 		SimDriver.GetPlayerAircraft()->SetAPFlag(AircraftClass::AltHold);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetAPFlag@AircraftClass@@QAEXW4APFlags@1@@Z ; AircraftClass::SetAPFlag

; 7460 : 		//tell us what we should hold
; 7461 : 		SimDriver.GetPlayerAircraft()->SetNewAlt();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetNewAlt@AircraftClass@@QAEXXZ	; AircraftClass::SetNewAlt

; 7462 : 		// MD -- 20031108: fixing AP ATT HLD modes.  Pitch switch should not set roll unless the
; 7463 : 		// roll mode is set to roll hold.
; 7464 : 		if ( (!SimDriver.GetPlayerAircraft()->IsOn(AircraftClass::StrgSel)) && (!SimDriver.GetPlayerAircraft()->IsOn(AircraftClass::HDGSel))) {

	push	4
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsOn@AircraftClass@@QAEHW4APFlags@1@@Z	; AircraftClass::IsOn
	test	eax, eax
	jne	SHORT $LN2@SimRightAP
	push	16					; 00000010H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsOn@AircraftClass@@QAEHW4APFlags@1@@Z	; AircraftClass::IsOn
	test	eax, eax
	jne	SHORT $LN2@SimRightAP

; 7465 : 			SimDriver.GetPlayerAircraft()->SetAPFlag(AircraftClass::RollHold); // needed in case this is the first time and switch is still in default position

	push	8
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetAPFlag@AircraftClass@@QAEXW4APFlags@1@@Z ; AircraftClass::SetAPFlag

; 7466 : 			SimDriver.GetPlayerAircraft()->SetNewRoll();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetNewRoll@AircraftClass@@QAEXXZ	; AircraftClass::SetNewRoll
$LN2@SimRightAP:

; 7467 : 		}
; 7468 : 		//Tell us what we want
; 7469 : 		SimDriver.GetPlayerAircraft()->SetAPParameters();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetAPParameters@AircraftClass@@QAEXXZ	; AircraftClass::SetAPParameters

; 7470 : 				// now apply power
; 7471 : 		SimDriver.GetPlayerAircraft()->PowerOn(AircraftClass::APPower);

	push	262144					; 00040000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerOn@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerOn

; 7472 : 
; 7473 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN5@SimRightAP

; 7474 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_RT_AP_SW, 2);

	push	2
	push	136					; 00000088H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN5@SimRightAP:

; 7475 : 	}
; 7476 : }

	pop	ebp
	ret	0
?SimRightAPUp@@YAXKHPAX@Z ENDP				; SimRightAPUp
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimLeftAPSwitch@@YAXKHPAX@Z PROC			; SimLeftAPSwitch

; 7524 : {

	push	ebp
	mov	ebp, esp

; 7525 : 	//This is the right switch, in the upper position.
; 7526 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN14@SimLeftAPS
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN14@SimLeftAPS
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN14@SimLeftAPS

; 7527 : 	{
; 7528 : 		//Middle position
; 7529 : 		if(SimDriver.GetPlayerAircraft()->IsOn(AircraftClass::RollHold))

	push	8
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsOn@AircraftClass@@QAEHW4APFlags@1@@Z	; AircraftClass::IsOn
	test	eax, eax
	je	SHORT $LN12@SimLeftAPS

; 7530 : 		{
; 7531 : 			SimDriver.GetPlayerAircraft()->ClearAPFlag(AircraftClass::RollHold);

	push	8
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?ClearAPFlag@AircraftClass@@QAEXW4APFlags@1@@Z ; AircraftClass::ClearAPFlag

; 7532 : 			SimDriver.GetPlayerAircraft()->ClearAPFlag(AircraftClass::HDGSel);

	push	16					; 00000010H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?ClearAPFlag@AircraftClass@@QAEXW4APFlags@1@@Z ; AircraftClass::ClearAPFlag

; 7533 : 			SimDriver.GetPlayerAircraft()->SetAPFlag(AircraftClass::StrgSel);	//waypoint AP

	push	4
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetAPFlag@AircraftClass@@QAEXW4APFlags@1@@Z ; AircraftClass::SetAPFlag
	jmp	$LN11@SimLeftAPS
$LN12@SimLeftAPS:

; 7534 : 		}
; 7535 : 		//down position
; 7536 : 		else if(SimDriver.GetPlayerAircraft()->IsOn(AircraftClass::StrgSel))

	push	4
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsOn@AircraftClass@@QAEHW4APFlags@1@@Z	; AircraftClass::IsOn
	test	eax, eax
	je	SHORT $LN10@SimLeftAPS

; 7537 : 		{
; 7538 : 			SimDriver.GetPlayerAircraft()->ClearAPFlag(AircraftClass::StrgSel);

	push	4
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?ClearAPFlag@AircraftClass@@QAEXW4APFlags@1@@Z ; AircraftClass::ClearAPFlag

; 7539 : 			SimDriver.GetPlayerAircraft()->ClearAPFlag(AircraftClass::RollHold);

	push	8
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?ClearAPFlag@AircraftClass@@QAEXW4APFlags@1@@Z ; AircraftClass::ClearAPFlag

; 7540 : 			SimDriver.GetPlayerAircraft()->SetAPFlag(AircraftClass::HDGSel);

	push	16					; 00000010H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetAPFlag@AircraftClass@@QAEXW4APFlags@1@@Z ; AircraftClass::SetAPFlag

; 7541 : 		}
; 7542 : 		//up position
; 7543 : 		else

	jmp	SHORT $LN11@SimLeftAPS
$LN10@SimLeftAPS:

; 7544 : 		{
; 7545 : 			SimDriver.GetPlayerAircraft()->ClearAPFlag(AircraftClass::HDGSel);

	push	16					; 00000010H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?ClearAPFlag@AircraftClass@@QAEXW4APFlags@1@@Z ; AircraftClass::ClearAPFlag

; 7546 : 			SimDriver.GetPlayerAircraft()->ClearAPFlag(AircraftClass::StrgSel);

	push	4
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?ClearAPFlag@AircraftClass@@QAEXW4APFlags@1@@Z ; AircraftClass::ClearAPFlag

; 7547 : 			SimDriver.GetPlayerAircraft()->SetAPFlag(AircraftClass::RollHold);

	push	8
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetAPFlag@AircraftClass@@QAEXW4APFlags@1@@Z ; AircraftClass::SetAPFlag
$LN11@SimLeftAPS:

; 7548 : 		}
; 7549 : 		if((SimDriver.GetPlayerAircraft()->IsOn(AircraftClass::AttHold)) || (SimDriver.GetPlayerAircraft()->IsOn(AircraftClass::AltHold)))

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsOn@AircraftClass@@QAEHW4APFlags@1@@Z	; AircraftClass::IsOn
	test	eax, eax
	jne	SHORT $LN7@SimLeftAPS
	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsOn@AircraftClass@@QAEHW4APFlags@1@@Z	; AircraftClass::IsOn
	test	eax, eax
	je	SHORT $LN8@SimLeftAPS
$LN7@SimLeftAPS:

; 7550 : 		{
; 7551 : 			if(SimDriver.GetPlayerAircraft()->IsOn(AircraftClass::RollHold))

	push	8
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsOn@AircraftClass@@QAEHW4APFlags@1@@Z	; AircraftClass::IsOn
	test	eax, eax
	je	SHORT $LN8@SimLeftAPS

; 7552 : 			{
; 7553 : 				SimDriver.GetPlayerAircraft()->SetNewRoll();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetNewRoll@AircraftClass@@QAEXXZ	; AircraftClass::SetNewRoll
$LN8@SimLeftAPS:

; 7554 : 			//	SimDriver.GetPlayerAircraft()->SetNewPitch();  // MD -- 20031109: no, just set roll here.
; 7555 : 			}
; 7556 : 		}
; 7557 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN14@SimLeftAPS

; 7558 : 		{
; 7559 : 			// Left switch Middle position
; 7560 : 			if(SimDriver.GetPlayerAircraft()->IsOn(AircraftClass::RollHold))

	push	8
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsOn@AircraftClass@@QAEHW4APFlags@1@@Z	; AircraftClass::IsOn
	test	eax, eax
	je	SHORT $LN4@SimLeftAPS

; 7561 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_LT_AP_SW, 4);

	push	4
	push	137					; 00000089H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
	jmp	SHORT $LN14@SimLeftAPS
$LN4@SimLeftAPS:

; 7562 : 			// Left switch down position
; 7563 : 			else if(SimDriver.GetPlayerAircraft()->IsOn(AircraftClass::StrgSel))

	push	4
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsOn@AircraftClass@@QAEHW4APFlags@1@@Z	; AircraftClass::IsOn
	test	eax, eax
	je	SHORT $LN2@SimLeftAPS

; 7564 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_LT_AP_SW, 1);

	push	1
	push	137					; 00000089H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 7565 : 			// Left switch up position
; 7566 : 			else

	jmp	SHORT $LN14@SimLeftAPS
$LN2@SimLeftAPS:

; 7567 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_LT_AP_SW, 2);

	push	2
	push	137					; 00000089H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN14@SimLeftAPS:

; 7568 : 		}
; 7569 : 	}
; 7570 : }

	pop	ebp
	ret	0
?SimLeftAPSwitch@@YAXKHPAX@Z ENDP			; SimLeftAPSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimRightAPSwitch@@YAXKHPAX@Z PROC			; SimRightAPSwitch

; 7375 : {

	push	ebp
	mov	ebp, esp

; 7376 : 	//This is the right switch, in the upper position.
; 7377 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN14@SimRightAP
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN14@SimRightAP
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN14@SimRightAP

; 7378 : 	{
; 7379 : 		if(g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	$LN14@SimRightAP

; 7380 : 		{
; 7381 : 			//We get Altitude hold now.?
; 7382 : 			if(SimDriver.GetPlayerAircraft()->IsOn(AircraftClass::AltHold))	//up

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsOn@AircraftClass@@QAEHW4APFlags@1@@Z	; AircraftClass::IsOn
	test	eax, eax
	je	$LN11@SimRightAP

; 7383 : 			{
; 7384 : 				//from Alt hold to Att hold
; 7385 : 				SimDriver.GetPlayerAircraft()->ClearAPFlag(AircraftClass::AltHold);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?ClearAPFlag@AircraftClass@@QAEXW4APFlags@1@@Z ; AircraftClass::ClearAPFlag

; 7386 : 				//can't be both
; 7387 : 				SimDriver.GetPlayerAircraft()->SetAPFlag(AircraftClass::AttHold);	//down

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetAPFlag@AircraftClass@@QAEXW4APFlags@1@@Z ; AircraftClass::SetAPFlag

; 7388 : 				SimDriver.GetPlayerAircraft()->SetNewPitch();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetNewPitch@AircraftClass@@QAEXXZ	; AircraftClass::SetNewPitch

; 7389 : 			//	SimDriver.GetPlayerAircraft()->SetNewRoll();  // ...but only if RollHold is selected.
; 7390 : 			// Following test and set is overkill but guards against the possibility that someone entered a jet that
; 7391 : 			// had the right switch in something other than center position as the default.
; 7392 : 				if ( (!SimDriver.GetPlayerAircraft()->IsOn(AircraftClass::StrgSel)) && (!SimDriver.GetPlayerAircraft()->IsOn(AircraftClass::StrgSel))) {

	push	4
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsOn@AircraftClass@@QAEHW4APFlags@1@@Z	; AircraftClass::IsOn
	test	eax, eax
	jne	SHORT $LN10@SimRightAP
	push	4
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsOn@AircraftClass@@QAEHW4APFlags@1@@Z	; AircraftClass::IsOn
	test	eax, eax
	jne	SHORT $LN10@SimRightAP

; 7393 : 					SimDriver.GetPlayerAircraft()->SetAPFlag(AircraftClass::RollHold); // needed in case this is the first time and switch is still in default position

	push	8
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetAPFlag@AircraftClass@@QAEXW4APFlags@1@@Z ; AircraftClass::SetAPFlag

; 7394 : 					SimDriver.GetPlayerAircraft()->SetNewRoll();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetNewRoll@AircraftClass@@QAEXXZ	; AircraftClass::SetNewRoll
$LN10@SimRightAP:

; 7395 : 				}
; 7396 : 				//Tell us what we want
; 7397 : 				SimDriver.GetPlayerAircraft()->SetAPParameters();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetAPParameters@AircraftClass@@QAEXXZ	; AircraftClass::SetAPParameters

; 7398 : 				// now apply power
; 7399 : 				SimDriver.GetPlayerAircraft()->PowerOn(AircraftClass::APPower);

	push	262144					; 00040000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerOn@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerOn

; 7400 : 			}
; 7401 : 			else

	jmp	$LN9@SimRightAP
$LN11@SimRightAP:

; 7402 : 				if(SimDriver.GetPlayerAircraft()->IsOn(AircraftClass::AttHold))

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsOn@AircraftClass@@QAEHW4APFlags@1@@Z	; AircraftClass::IsOn
	test	eax, eax
	je	SHORT $LN8@SimRightAP

; 7403 : 				{
; 7404 : 					//all off
; 7405 : 					SimDriver.GetPlayerAircraft()->ClearAPFlag(AircraftClass::AltHold);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?ClearAPFlag@AircraftClass@@QAEXW4APFlags@1@@Z ; AircraftClass::ClearAPFlag

; 7406 : 					SimDriver.GetPlayerAircraft()->ClearAPFlag(AircraftClass::AttHold);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?ClearAPFlag@AircraftClass@@QAEXW4APFlags@1@@Z ; AircraftClass::ClearAPFlag

; 7407 : 					// SimDriver.GetPlayerAircraft()->SetAPParameters(); <- replaced to fix the "SP3 pitch up on landing after AP use" bug
; 7408 : 					SimDriver.GetPlayerAircraft()->SetAutopilot(AircraftClass::APOff);

	push	4
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetAutopilot@AircraftClass@@QAEXW4AutoPilotType@1@@Z ; AircraftClass::SetAutopilot

; 7409 : 					//take the juice
; 7410 : 					SimDriver.GetPlayerAircraft()->PowerOff(AircraftClass::APPower);

	push	262144					; 00040000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerOff@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerOff

; 7411 : 				}
; 7412 : 				else

	jmp	$LN9@SimRightAP
$LN8@SimRightAP:

; 7413 : 				{
; 7414 : 					//from off to Alt Hold
; 7415 : 					SimDriver.GetPlayerAircraft()->SetAPFlag(AircraftClass::AltHold);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetAPFlag@AircraftClass@@QAEXW4APFlags@1@@Z ; AircraftClass::SetAPFlag

; 7416 : 					SimDriver.GetPlayerAircraft()->ClearAPFlag(AircraftClass::AttHold);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?ClearAPFlag@AircraftClass@@QAEXW4APFlags@1@@Z ; AircraftClass::ClearAPFlag

; 7417 : 					//tell us what we should hold
; 7418 : 					SimDriver.GetPlayerAircraft()->SetNewAlt();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetNewAlt@AircraftClass@@QAEXXZ	; AircraftClass::SetNewAlt

; 7419 : 					// MD -- 20031109: we should be holding roll at this point as well if the roll more switch is
; 7420 : 					// centered.  Also a good place to set the RollHold flag in case this is the first time that the
; 7421 : 					// AP has been activated.
; 7422 : 					if ( (!SimDriver.GetPlayerAircraft()->IsOn(AircraftClass::StrgSel)) && (!SimDriver.GetPlayerAircraft()->IsOn(AircraftClass::StrgSel))) {

	push	4
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsOn@AircraftClass@@QAEHW4APFlags@1@@Z	; AircraftClass::IsOn
	test	eax, eax
	jne	SHORT $LN6@SimRightAP
	push	4
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsOn@AircraftClass@@QAEHW4APFlags@1@@Z	; AircraftClass::IsOn
	test	eax, eax
	jne	SHORT $LN6@SimRightAP

; 7423 : 						SimDriver.GetPlayerAircraft()->SetAPFlag(AircraftClass::RollHold); // needed in case this is the first time and switch is still in default position

	push	8
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetAPFlag@AircraftClass@@QAEXW4APFlags@1@@Z ; AircraftClass::SetAPFlag

; 7424 : 						SimDriver.GetPlayerAircraft()->SetNewRoll();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetNewRoll@AircraftClass@@QAEXXZ	; AircraftClass::SetNewRoll
$LN6@SimRightAP:

; 7425 : 					}
; 7426 : 					//Tell us what we want
; 7427 : 					SimDriver.GetPlayerAircraft()->SetAPParameters();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetAPParameters@AircraftClass@@QAEXXZ	; AircraftClass::SetAPParameters

; 7428 : 					// now apply power
; 7429 : 					SimDriver.GetPlayerAircraft()->PowerOn(AircraftClass::APPower);

	push	262144					; 00040000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerOn@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerOn
$LN9@SimRightAP:

; 7430 : 				}
; 7431 : 
; 7432 : 				if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN14@SimRightAP

; 7433 : 				{
; 7434 : 					// Right switch up position
; 7435 : 					if(SimDriver.GetPlayerAircraft()->IsOn(AircraftClass::AltHold))

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsOn@AircraftClass@@QAEHW4APFlags@1@@Z	; AircraftClass::IsOn
	test	eax, eax
	je	SHORT $LN4@SimRightAP

; 7436 : 						OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_RT_AP_SW, 4);

	push	4
	push	136					; 00000088H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
	jmp	SHORT $LN14@SimRightAP
$LN4@SimRightAP:

; 7437 : 					// Right switch down position
; 7438 : 					else if(SimDriver.GetPlayerAircraft()->IsOn(AircraftClass::AttHold))

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsOn@AircraftClass@@QAEHW4APFlags@1@@Z	; AircraftClass::IsOn
	test	eax, eax
	je	SHORT $LN2@SimRightAP

; 7439 : 						OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_RT_AP_SW, 1);

	push	1
	push	136					; 00000088H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 7440 : 					// Right switch middle position (off)
; 7441 : 					else

	jmp	SHORT $LN14@SimRightAP
$LN2@SimRightAP:

; 7442 : 						OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_RT_AP_SW, 1);

	push	1
	push	136					; 00000088H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN14@SimRightAP:

; 7443 : 				}
; 7444 : 		}
; 7445 : 	}
; 7446 : }

	pop	ebp
	ret	0
?SimRightAPSwitch@@YAXKHPAX@Z ENDP			; SimRightAPSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimFuelDoorClose@@YAXKHPAX@Z PROC			; SimFuelDoorClose

; 7354 : {

	push	ebp
	mov	ebp, esp

; 7355 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimFuelDoo

; 7356 : 		return;

	jmp	SHORT $LN4@SimFuelDoo
$LN3@SimFuelDoo:

; 7357 : 	
; 7358 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimFuelDoo
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimFuelDoo
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimFuelDoo

; 7359 : 	{
; 7360 : 		SimDriver.GetPlayerAircraft()->af->ClearEngineFlag(AirframeClass::FuelDoorOpen);

	push	4
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?ClearEngineFlag@AirframeClass@@QAEXW4EngineFlags@1@@Z ; AirframeClass::ClearEngineFlag

; 7361 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimFuelDoo

; 7362 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_REFUEL_DOOR, 1);

	push	1
	push	183					; 000000b7H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimFuelDoo:

; 7363 : 	}
; 7364 : }

	pop	ebp
	ret	0
?SimFuelDoorClose@@YAXKHPAX@Z ENDP			; SimFuelDoorClose
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimFuelDoorOpen@@YAXKHPAX@Z PROC			; SimFuelDoorOpen

; 7341 : {

	push	ebp
	mov	ebp, esp

; 7342 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimFuelDoo

; 7343 : 		return;

	jmp	SHORT $LN4@SimFuelDoo
$LN3@SimFuelDoo:

; 7344 : 	
; 7345 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimFuelDoo
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimFuelDoo
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimFuelDoo

; 7346 : 	{
; 7347 : 		SimDriver.GetPlayerAircraft()->af->SetEngineFlag(AirframeClass::FuelDoorOpen);

	push	4
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?SetEngineFlag@AirframeClass@@QAEXW4EngineFlags@1@@Z ; AirframeClass::SetEngineFlag

; 7348 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimFuelDoo

; 7349 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_REFUEL_DOOR, 2);

	push	2
	push	183					; 000000b7H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimFuelDoo:

; 7350 : 	}
; 7351 : }

	pop	ebp
	ret	0
?SimFuelDoorOpen@@YAXKHPAX@Z ENDP			; SimFuelDoorOpen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimFuelDoorToggle@@YAXKHPAX@Z PROC			; SimFuelDoorToggle

; 7326 : {

	push	ebp
	mov	ebp, esp

; 7327 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN5@SimFuelDoo
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN5@SimFuelDoo
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN5@SimFuelDoo

; 7328 : 	{
; 7329 : 		SimDriver.GetPlayerAircraft()->af->ToggleEngineFlag(AirframeClass::FuelDoorOpen);

	push	4
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?ToggleEngineFlag@AirframeClass@@QAEXW4EngineFlags@1@@Z ; AirframeClass::ToggleEngineFlag

; 7330 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN5@SimFuelDoo

; 7331 : 			if (SimDriver.GetPlayerAircraft()->af->IsEngineFlag(AirframeClass::FuelDoorOpen))

	push	4
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?IsEngineFlag@AirframeClass@@QAEHW4EngineFlags@1@@Z ; AirframeClass::IsEngineFlag
	test	eax, eax
	je	SHORT $LN2@SimFuelDoo

; 7332 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_REFUEL_DOOR, 2);

	push	2
	push	183					; 000000b7H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 7333 : 			else

	jmp	SHORT $LN5@SimFuelDoo
$LN2@SimFuelDoo:

; 7334 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_REFUEL_DOOR, 1);

	push	1
	push	183					; 000000b7H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN5@SimFuelDoo:

; 7335 : 	}
; 7336 : }

	pop	ebp
	ret	0
?SimFuelDoorToggle@@YAXKHPAX@Z ENDP			; SimFuelDoorToggle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimLaserArmOff@@YAXKHPAX@Z PROC			; SimLaserArmOff

; 7309 : {

	push	ebp
	mov	ebp, esp

; 7310 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN4@SimLaserAr

; 7311 : 		return;

	jmp	$LN5@SimLaserAr
$LN4@SimLaserAr:

; 7312 : 	
; 7313 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN5@SimLaserAr
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN5@SimLaserAr
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN5@SimLaserAr

; 7314 : 	{
; 7315 : 		// Set state to OFF regarless of the Master Arm state.
; 7316 : 		if(SimDriver.GetPlayerAircraft()->FCC)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+936], 0
	je	SHORT $LN2@SimLaserAr

; 7317 : 			SimDriver.GetPlayerAircraft()->FCC->LaserArm = FALSE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+936]
	mov	BYTE PTR [edx+420], 0
$LN2@SimLaserAr:

; 7318 : 			SimDriver.GetPlayerAircraft()->FCC->LaserFire = FALSE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	eax, DWORD PTR [eax+936]
	mov	BYTE PTR [eax+423], 0

; 7319 : 
; 7320 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN5@SimLaserAr

; 7321 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_LASER_ARM, 1);

	push	1
	push	144					; 00000090H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN5@SimLaserAr:

; 7322 : 	}
; 7323 : }

	pop	ebp
	ret	0
?SimLaserArmOff@@YAXKHPAX@Z ENDP			; SimLaserArmOff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimLaserArmOn@@YAXKHPAX@Z PROC				; SimLaserArmOn

; 7291 : {

	push	ebp
	mov	ebp, esp

; 7292 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN5@SimLaserAr

; 7293 : 		return;

	jmp	$LN6@SimLaserAr
$LN5@SimLaserAr:

; 7294 : 	
; 7295 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN6@SimLaserAr
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN6@SimLaserAr
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	$LN6@SimLaserAr

; 7296 : 	{
; 7297 : 		if(SimDriver.GetPlayerAircraft()->Sms->MasterArm() != SMSBaseClass::MasterArmState::Arm)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+940]
	call	?MasterArm@SMSBaseClass@@QAE?AW4MasterArmState@1@XZ ; SMSBaseClass::MasterArm
	cmp	eax, 2
	je	SHORT $LN3@SimLaserAr

; 7298 : 			return;

	jmp	SHORT $LN6@SimLaserAr
$LN3@SimLaserAr:

; 7299 : 
; 7300 : 		if(SimDriver.GetPlayerAircraft()->FCC)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+936], 0
	je	SHORT $LN2@SimLaserAr

; 7301 : 			SimDriver.GetPlayerAircraft()->FCC->LaserArm = TRUE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+936]
	mov	BYTE PTR [edx+420], 1
$LN2@SimLaserAr:

; 7302 : 			SimDriver.GetPlayerAircraft()->FCC->LaserFire = FALSE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	eax, DWORD PTR [eax+936]
	mov	BYTE PTR [eax+423], 0

; 7303 : 
; 7304 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN6@SimLaserAr

; 7305 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_LASER_ARM, 2);

	push	2
	push	144					; 00000090H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN6@SimLaserAr:

; 7306 : 	}
; 7307 : }

	pop	ebp
	ret	0
?SimLaserArmOn@@YAXKHPAX@Z ENDP				; SimLaserArmOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimLaserArmToggle@@YAXKHPAX@Z PROC			; SimLaserArmToggle

; 7275 : {

	push	ebp
	mov	ebp, esp

; 7276 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN6@SimLaserAr
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN6@SimLaserAr
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN6@SimLaserAr

; 7277 : 	{
; 7278 : 		if(SimDriver.GetPlayerAircraft()->FCC)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+936], 0
	je	SHORT $LN4@SimLaserAr

; 7279 : 			SimDriver.GetPlayerAircraft()->FCC->ToggleLaserArm();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?ToggleLaserArm@FireControlComputer@@QAEXXZ ; FireControlComputer::ToggleLaserArm
$LN4@SimLaserAr:

; 7280 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN6@SimLaserAr

; 7281 : 			if (SimDriver.GetPlayerAircraft()->FCC->LaserArm)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	movzx	edx, BYTE PTR [ecx+420]
	test	edx, edx
	je	SHORT $LN2@SimLaserAr

; 7282 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_LASER_ARM, 2);

	push	2
	push	144					; 00000090H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 7283 : 			else

	jmp	SHORT $LN6@SimLaserAr
$LN2@SimLaserAr:

; 7284 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_LASER_ARM, 1);

	push	1
	push	144					; 00000090H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN6@SimLaserAr:

; 7285 : 	}
; 7286 : }

	pop	ebp
	ret	0
?SimLaserArmToggle@@YAXKHPAX@Z ENDP			; SimLaserArmToggle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimParkingBrakeOff@@YAXKHPAX@Z PROC			; SimParkingBrakeOff

; 7215 : {

	push	ebp
	mov	ebp, esp

; 7216 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimParking

; 7217 : 		return;

	jmp	$LN4@SimParking
$LN3@SimParking:

; 7218 : 	
; 7219 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)) {

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimParking
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimParking
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimParking

; 7220 : 		SimDriver.GetPlayerAircraft()->af->PBON = FALSE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+932]
	mov	BYTE PTR [edx+1616], 0

; 7221 : 		SimDriver.GetPlayerAircraft()->af->ClearFlag(AirframeClass::WheelBrakes);		

	push	8
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?ClearFlag@AirframeClass@@QAEXH@Z	; AirframeClass::ClearFlag

; 7222 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimParking

; 7223 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_PARK_BRAKE, 1);

	push	1
	push	141					; 0000008dH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimParking:

; 7224 : 	}
; 7225 : }

	pop	ebp
	ret	0
?SimParkingBrakeOff@@YAXKHPAX@Z ENDP			; SimParkingBrakeOff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimParkingBrakeOn@@YAXKHPAX@Z PROC			; SimParkingBrakeOn

; 7195 : {

	push	ebp
	mov	ebp, esp

; 7196 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN5@SimParking

; 7197 : 		return;

	jmp	$LN6@SimParking
$LN5@SimParking:

; 7198 : 	
; 7199 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)) {

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN1@SimParking
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN1@SimParking
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	$LN1@SimParking

; 7200 : 		if(SimDriver.GetPlayerAircraft()->af->vt > 1.0F * KNOTS_TO_FTPSEC) {

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [edx+1120]
	comiss	xmm0, DWORD PTR __real@3fd80b03
	jbe	SHORT $LN3@SimParking

; 7201 : 			SimDriver.GetPlayerAircraft()->af->PBON = FALSE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	eax, DWORD PTR [eax+932]
	mov	BYTE PTR [eax+1616], 0

; 7202 : 			SimDriver.GetPlayerAircraft()->af->ClearFlag(AirframeClass::WheelBrakes);

	push	8
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?ClearFlag@AirframeClass@@QAEXH@Z	; AirframeClass::ClearFlag

; 7203 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN2@SimParking

; 7204 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_PARK_BRAKE, 1);

	push	1
	push	141					; 0000008dH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN2@SimParking:

; 7205 : 			return;

	jmp	SHORT $LN6@SimParking
$LN3@SimParking:

; 7206 : 		}
; 7207 : 		SimDriver.GetPlayerAircraft()->af->PBON = TRUE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	mov	BYTE PTR [ecx+1616], 1

; 7208 : 		SimDriver.GetPlayerAircraft()->af->SetFlag(AirframeClass::WheelBrakes);		

	push	8
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?SetFlag@AirframeClass@@QAEXH@Z		; AirframeClass::SetFlag

; 7209 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN1@SimParking

; 7210 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_PARK_BRAKE, 2);

	push	2
	push	141					; 0000008dH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN1@SimParking:
$LN6@SimParking:

; 7211 : 	}
; 7212 : }

	pop	ebp
	ret	0
?SimParkingBrakeOn@@YAXKHPAX@Z ENDP			; SimParkingBrakeOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimParkingBrakeToggle@@YAXKHPAX@Z PROC			; SimParkingBrakeToggle

; 7180 : {

	push	ebp
	mov	ebp, esp

; 7181 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimParking
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimParking
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN4@SimParking

; 7182 : 		SimDriver.GetPlayerAircraft()->af->TogglePB();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?TogglePB@AirframeClass@@QAEXXZ		; AirframeClass::TogglePB
$LN4@SimParking:

; 7183 : 	if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN5@SimParking

; 7184 : 	{
; 7185 : 		if (SimDriver.GetPlayerAircraft()->af->PBON == TRUE)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	movzx	edx, BYTE PTR [ecx+1616]
	cmp	edx, 1
	jne	SHORT $LN2@SimParking

; 7186 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_PARK_BRAKE, 2);

	push	2
	push	141					; 0000008dH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 7187 : 		else

	jmp	SHORT $LN5@SimParking
$LN2@SimParking:

; 7188 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_PARK_BRAKE, 1);

	push	1
	push	141					; 0000008dH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN5@SimParking:

; 7189 : 	}
; 7190 : }

	pop	ebp
	ret	0
?SimParkingBrakeToggle@@YAXKHPAX@Z ENDP			; SimParkingBrakeToggle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_pac$ = -4						; size = 4
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimLandingLightOff@@YAXKHPAX@Z PROC			; SimLandingLightOff

; 7169 : void SimLandingLightOff(unsigned long val, int state, void *){

	push	ebp
	mov	ebp, esp
	push	ecx

; 7170 : 	AircraftClass *pac = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _pac$[ebp], eax

; 7171 : 	if (pac && pac->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	cmp	DWORD PTR _pac$[ebp], 0
	je	SHORT $LN3@SimLanding
	push	65536					; 00010000H
	mov	ecx, DWORD PTR _pac$[ebp]
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimLanding
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimLanding

; 7172 : 	{
; 7173 : 		pac->ClearAcStatusBits(AircraftClass::ACSTATUS_EXT_LANDINGLIGHT);

	push	32					; 00000020H
	mov	ecx, DWORD PTR _pac$[ebp]
	call	?ClearAcStatusBits@AircraftClass@@QAEXH@Z ; AircraftClass::ClearAcStatusBits

; 7174 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN3@SimLanding

; 7175 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_LAND_LIGHT, 1);

	push	1
	push	219					; 000000dbH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN3@SimLanding:

; 7176 : 	}
; 7177 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimLandingLightOff@@YAXKHPAX@Z ENDP			; SimLandingLightOff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_pac$ = -4						; size = 4
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimLandingLightOn@@YAXKHPAX@Z PROC			; SimLandingLightOn

; 7159 : void SimLandingLightOn(unsigned long val, int state, void *){

	push	ebp
	mov	ebp, esp
	push	ecx

; 7160 : 	AircraftClass *pac = SimDriver.GetPlayerAircraft();	

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _pac$[ebp], eax

; 7161 : 	if (pac && pac->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	cmp	DWORD PTR _pac$[ebp], 0
	je	SHORT $LN3@SimLanding
	push	65536					; 00010000H
	mov	ecx, DWORD PTR _pac$[ebp]
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimLanding
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimLanding

; 7162 : 	{
; 7163 : 		pac->SetAcStatusBits(AircraftClass::ACSTATUS_EXT_LANDINGLIGHT);

	push	32					; 00000020H
	mov	ecx, DWORD PTR _pac$[ebp]
	call	?SetAcStatusBits@AircraftClass@@QAEXH@Z	; AircraftClass::SetAcStatusBits

; 7164 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN3@SimLanding

; 7165 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_LAND_LIGHT, 2);

	push	2
	push	219					; 000000dbH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN3@SimLanding:

; 7166 : 	}
; 7167 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimLandingLightOn@@YAXKHPAX@Z ENDP			; SimLandingLightOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_pac$ = -4						; size = 4
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimLandingLightToggle@@YAXKHPAX@Z PROC			; SimLandingLightToggle

; 7138 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 7139 : 	AircraftClass *pac = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _pac$[ebp], eax

; 7140 : 	if(pac && pac->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	cmp	DWORD PTR _pac$[ebp], 0
	je	$LN6@SimLanding
	push	65536					; 00010000H
	mov	ecx, DWORD PTR _pac$[ebp]
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN6@SimLanding
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN6@SimLanding

; 7141 : 	{
; 7142 : 		if (pac->IsAcStatusBitsSet(AircraftClass::ACSTATUS_EXT_LANDINGLIGHT))

	push	32					; 00000020H
	mov	ecx, DWORD PTR _pac$[ebp]
	call	?IsAcStatusBitsSet@AircraftClass@@QBE_NH@Z ; AircraftClass::IsAcStatusBitsSet
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@SimLanding

; 7143 : 		{
; 7144 : 			pac->ClearAcStatusBits(AircraftClass::ACSTATUS_EXT_LANDINGLIGHT);

	push	32					; 00000020H
	mov	ecx, DWORD PTR _pac$[ebp]
	call	?ClearAcStatusBits@AircraftClass@@QAEXH@Z ; AircraftClass::ClearAcStatusBits

; 7145 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN3@SimLanding

; 7146 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_LAND_LIGHT, 1);

	push	1
	push	219					; 000000dbH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN3@SimLanding:

; 7147 : 		}
; 7148 : 		else

	jmp	SHORT $LN6@SimLanding
$LN4@SimLanding:

; 7149 : 		{
; 7150 : 			pac->SetAcStatusBits(AircraftClass::ACSTATUS_EXT_LANDINGLIGHT);

	push	32					; 00000020H
	mov	ecx, DWORD PTR _pac$[ebp]
	call	?SetAcStatusBits@AircraftClass@@QAEXH@Z	; AircraftClass::SetAcStatusBits

; 7151 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN6@SimLanding

; 7152 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_LAND_LIGHT, 2);

	push	2
	push	219					; 000000dbH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN6@SimLanding:

; 7153 : 		}
; 7154 : 	}
; 7155 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimLandingLightToggle@@YAXKHPAX@Z ENDP			; SimLandingLightToggle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
_pButton$ = 16						; size = 4
?SimRALTOFF@@YAXKHPAX@Z PROC				; SimRALTOFF

; 6350 : {

	push	ebp
	mov	ebp, esp

; 6351 :     if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimRALTOFF
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimRALTOFF
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimRALTOFF

; 6352 :     {
; 6353 : 			//Set it off here
; 6354 : 			SimDriver.GetPlayerAircraft()->af->platform->RaltOff();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	mov	ecx, DWORD PTR [ecx+1088]
	call	?RaltOff@AircraftClass@@QAEXXZ		; AircraftClass::RaltOff

; 6355 : 			//take the juice
; 6356 : 			SimDriver.GetPlayerAircraft()->PowerOff(AircraftClass::RaltPower);

	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerOff@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerOff

; 6357 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN3@SimRALTOFF

; 6358 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_RALT_PWR, 1);

	push	1
	push	197					; 000000c5H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN3@SimRALTOFF:

; 6359 :     }
; 6360 : }

	pop	ebp
	ret	0
?SimRALTOFF@@YAXKHPAX@Z ENDP				; SimRALTOFF
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
_pButton$ = 16						; size = 4
?SimRALTON@@YAXKHPAX@Z PROC				; SimRALTON

; 6339 : {

	push	ebp
	mov	ebp, esp

; 6340 :   if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimRALTON
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimRALTON
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimRALTON

; 6341 :   {
; 6342 : 		//Set it on here 
; 6343 : 		SimDriver.GetPlayerAircraft()->af->platform->RaltOn();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	mov	ecx, DWORD PTR [ecx+1088]
	call	?RaltOn@AircraftClass@@QAEXXZ		; AircraftClass::RaltOn

; 6344 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN3@SimRALTON

; 6345 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_RALT_PWR, 4);

	push	4
	push	197					; 000000c5H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN3@SimRALTON:

; 6346 :   }
; 6347 : }

	pop	ebp
	ret	0
?SimRALTON@@YAXKHPAX@Z ENDP				; SimRALTON
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
_pButton$ = 16						; size = 4
?SimRALTSTDBY@@YAXKHPAX@Z PROC				; SimRALTSTDBY

; 6329 : {

	push	ebp
	mov	ebp, esp

; 6330 :   if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimRALTSTD
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimRALTSTD
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimRALTSTD

; 6331 :   {
; 6332 : 		SimDriver.GetPlayerAircraft()->af->platform->RaltStdby();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	mov	ecx, DWORD PTR [ecx+1088]
	call	?RaltStdby@AircraftClass@@QAEXXZ	; AircraftClass::RaltStdby

; 6333 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN3@SimRALTSTD

; 6334 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_RALT_PWR, 2);

	push	2
	push	197					; 000000c5H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN3@SimRALTSTD:

; 6335 :   }
; 6336 : }

	pop	ebp
	ret	0
?SimRALTSTDBY@@YAXKHPAX@Z ENDP				; SimRALTSTDBY
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
_pButton$ = 16						; size = 4
?SimICPDEDSEQ@@YAXKHPAX@Z PROC				; SimICPDEDSEQ

; 6299 : {

	push	ebp
	mov	ebp, esp

; 6300 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimICPDEDS
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimICPDEDS
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN4@SimICPDEDS

; 6301 : 	{
; 6302 : 		if(g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN3@SimICPDEDS

; 6303 : 		{ 
; 6304 : 			//Player pushed the button, tell it to our ICP class
; 6305 : 			OTWDriver.pCockpitManager->mpIcp->HandleInput(SEQ_BUTTON, (CPButtonObject*)pButton);

	mov	edx, DWORD PTR _pButton$[ebp]
	push	edx
	push	31					; 0000001fH
	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [eax+688]
	call	?HandleInput@ICPClass@@QAEXHPAVCPButtonObject@@@Z ; ICPClass::HandleInput

; 6306 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN3@SimICPDEDS

; 6307 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_ICP_DED, 16);

	push	16					; 00000010H
	push	131					; 00000083H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN3@SimICPDEDS:

; 6308 : 		}
; 6309 : 	}
; 6310 : 	else

	jmp	SHORT $LN5@SimICPDEDS
$LN4@SimICPDEDS:

; 6311 : 	{
; 6312 : 		OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_ICP_DRIFTCO, 1);

	push	1
	push	129					; 00000081H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN5@SimICPDEDS:

; 6313 : 	}
; 6314 : }

	pop	ebp
	ret	0
?SimICPDEDSEQ@@YAXKHPAX@Z ENDP				; SimICPDEDSEQ
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
_pButton$ = 16						; size = 4
?SimICPCLEAR@@YAXKHPAX@Z PROC				; SimICPCLEAR

; 6317 : {

	push	ebp
	mov	ebp, esp

; 6318 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimICPCLEA
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimICPCLEA
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimICPCLEA

; 6319 : 	{
; 6320 : 		if(g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN3@SimICPCLEA

; 6321 : 		{ 
; 6322 : 			//Player pushed the button, tell it to our ICP class
; 6323 : 			OTWDriver.pCockpitManager->mpIcp->HandleInput(CLEAR_BUTTON, (CPButtonObject*)pButton);

	mov	edx, DWORD PTR _pButton$[ebp]
	push	edx
	push	30					; 0000001eH
	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [eax+688]
	call	?HandleInput@ICPClass@@QAEXHPAVCPButtonObject@@@Z ; ICPClass::HandleInput
$LN3@SimICPCLEA:

; 6324 : 		}
; 6325 : 	}		
; 6326 : }

	pop	ebp
	ret	0
?SimICPCLEAR@@YAXKHPAX@Z ENDP				; SimICPCLEAR
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
_pButton$ = 16						; size = 4
?SimICPDEDDOWN@@YAXKHPAX@Z PROC				; SimICPDEDDOWN

; 6281 : {

	push	ebp
	mov	ebp, esp

; 6282 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimICPDEDD
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimICPDEDD
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN4@SimICPDEDD

; 6283 : 	{
; 6284 : 		if(g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN3@SimICPDEDD

; 6285 : 		{ 
; 6286 : 			//Player pushed the button, tell it to our ICP class
; 6287 : 			OTWDriver.pCockpitManager->mpIcp->HandleInput(DOWN_BUTTON, (CPButtonObject*)pButton);

	mov	edx, DWORD PTR _pButton$[ebp]
	push	edx
	push	29					; 0000001dH
	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [eax+688]
	call	?HandleInput@ICPClass@@QAEXHPAVCPButtonObject@@@Z ; ICPClass::HandleInput

; 6288 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN3@SimICPDEDD

; 6289 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_ICP_DED, 8);

	push	8
	push	131					; 00000083H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN3@SimICPDEDD:

; 6290 : 		}
; 6291 : 	}		
; 6292 : 	else

	jmp	SHORT $LN5@SimICPDEDD
$LN4@SimICPDEDD:

; 6293 : 	{
; 6294 : 		OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_ICP_DRIFTCO, 1);

	push	1
	push	129					; 00000081H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN5@SimICPDEDD:

; 6295 : 	}
; 6296 : }

	pop	ebp
	ret	0
?SimICPDEDDOWN@@YAXKHPAX@Z ENDP				; SimICPDEDDOWN
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
_pButton$ = 16						; size = 4
?SimICPDEDUP@@YAXKHPAX@Z PROC				; SimICPDEDUP

; 6267 : {

	push	ebp
	mov	ebp, esp

; 6268 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimICPDEDU
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimICPDEDU
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN4@SimICPDEDU

; 6269 : 	{
; 6270 : 		if(g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN4@SimICPDEDU

; 6271 : 		{ 
; 6272 : 			//Player pushed the button, tell it to our ICP class
; 6273 : 			OTWDriver.pCockpitManager->mpIcp->HandleInput(UP_BUTTON, (CPButtonObject*)pButton);

	mov	edx, DWORD PTR _pButton$[ebp]
	push	edx
	push	28					; 0000001cH
	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [eax+688]
	call	?HandleInput@ICPClass@@QAEXHPAVCPButtonObject@@@Z ; ICPClass::HandleInput

; 6274 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimICPDEDU

; 6275 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_ICP_DED, 2);

	push	2
	push	131					; 00000083H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimICPDEDU:

; 6276 : 		}
; 6277 : 	}		
; 6278 : }

	pop	ebp
	ret	0
?SimICPDEDUP@@YAXKHPAX@Z ENDP				; SimICPDEDUP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
_pButton$ = 16						; size = 4
?SimICPResetDED@@YAXKHPAX@Z PROC			; SimICPResetDED

; 6249 : {

	push	ebp
	mov	ebp, esp

; 6250 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimICPRese
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimICPRese
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN4@SimICPRese

; 6251 : 	{
; 6252 : 		if(g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN3@SimICPRese

; 6253 : 		{ 
; 6254 : 			//Player pushed the button, tell it to our ICP class
; 6255 : 			OTWDriver.pCockpitManager->mpIcp->HandleInput(CNI_MODE, (CPButtonObject*)pButton);

	mov	edx, DWORD PTR _pButton$[ebp]
	push	edx
	push	27					; 0000001bH
	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [eax+688]
	call	?HandleInput@ICPClass@@QAEXHPAVCPButtonObject@@@Z ; ICPClass::HandleInput

; 6256 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN3@SimICPRese

; 6257 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_ICP_DED, 8);

	push	8
	push	131					; 00000083H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN3@SimICPRese:

; 6258 : 		}
; 6259 : 	}		
; 6260 : 	else

	jmp	SHORT $LN5@SimICPRese
$LN4@SimICPRese:

; 6261 : 	{
; 6262 : 		OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_ICP_DRIFTCO, 1);

	push	1
	push	129					; 00000081H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN5@SimICPRese:

; 6263 : 	}
; 6264 : }

	pop	ebp
	ret	0
?SimICPResetDED@@YAXKHPAX@Z ENDP			; SimICPResetDED
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_pradar$1 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
_pButton$ = 16						; size = 4
?SimICPAG1@@YAXKHPAX@Z PROC				; SimICPAG1

; 5294 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 5295 : 	if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag( MOTION_OWNSHIP ) && !((AircraftClass*)SimDriver.GetPlayerAircraft())->ejectTriggered && SimDriver.GetPlayerAircraft()->Sms) 

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN5@SimICPAG1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN5@SimICPAG1
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN5@SimICPAG1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1796], 0
	jne	$LN5@SimICPAG1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+940], 0
	je	$LN5@SimICPAG1

; 5296 : 	{
; 5297 : 		//MI 3/1/2002 if we're in DF or MRM, don't do anything
; 5298 : 		if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->FCC && (SimDriver.GetPlayerAircraft()->FCC->GetMasterMode() == 
; 5299 : 			FireControlComputer::Dogfight || SimDriver.GetPlayerAircraft()->FCC->GetMasterMode() == FireControlComputer::MissileOverride))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimICPAG1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+936], 0
	je	SHORT $LN3@SimICPAG1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 9
	je	SHORT $LN2@SimICPAG1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN3@SimICPAG1
$LN2@SimICPAG1:

; 5300 : 			return;

	jmp	$LN5@SimICPAG1
$LN3@SimICPAG1:

; 5301 : 
; 5302 : 		OTWDriver.pCockpitManager->mpIcp->HandleInput(AG_BUTTON, (CPButtonObject*)pButton);

	mov	ecx, DWORD PTR _pButton$[ebp]
	push	ecx
	push	12					; 0000000cH
	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [edx+688]
	call	?HandleInput@ICPClass@@QAEXHPAVCPButtonObject@@@Z ; ICPClass::HandleInput

; 5303 : 		SimDriver.GetPlayerAircraft()->FCC->SetMasterMode(FireControlComputer::AirGroundBomb);

	push	5
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?SetMasterMode@FireControlComputer@@QAEXW4FCCMasterMode@1@@Z ; FireControlComputer::SetMasterMode

; 5304 : 		//SimDriver.GetPlayerAircraft()->Sms->GetNextWeapon(wdGround); // MLR 2/8/2004 - 
; 5305 : 		SimDriver.GetPlayerAircraft()->Sms->StepAGWeapon();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+940]
	call	?StepAGWeapon@SMSClass@@QAEXXZ		; SMSClass::StepAGWeapon

; 5306 : 
; 5307 : 		// Put the radar in the its default AG mode
; 5308 : 		RadarClass* pradar = (RadarClass*) FindSensor (SimDriver.GetPlayerAircraft(), SensorClass::Radar);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _pradar$1[ebp], eax

; 5309 : 		if (pradar)

	cmp	DWORD PTR _pradar$1[ebp], 0
	je	SHORT $LN1@SimICPAG1

; 5310 : 			pradar->DefaultAGMode();

	mov	eax, DWORD PTR _pradar$1[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pradar$1[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
$LN1@SimICPAG1:

; 5311 : 
; 5312 : 		// Configure the MFDs
; 5313 : 		MfdDisplay[0]->SetNewMasterMode(SimDriver.GetPlayerAircraft()->FCC->GetMainMasterMode());

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?GetMainMasterMode@FireControlComputer@@QAE?AW4MASTERMODES@@XZ ; FireControlComputer::GetMainMasterMode
	push	eax
	mov	ecx, 4
	imul	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?SetNewMasterMode@MFDClass@@QAEXH@Z	; MFDClass::SetNewMasterMode

; 5314 : 		MfdDisplay[1]->SetNewMasterMode(SimDriver.GetPlayerAircraft()->FCC->GetMainMasterMode());

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?GetMainMasterMode@FireControlComputer@@QAE?AW4MASTERMODES@@XZ ; FireControlComputer::GetMainMasterMode
	push	eax
	mov	edx, 4
	shl	edx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[edx]
	call	?SetNewMasterMode@MFDClass@@QAEXH@Z	; MFDClass::SetNewMasterMode
$LN5@SimICPAG1:

; 5315 : 	}
; 5316 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimICPAG1@@YAXKHPAX@Z ENDP				; SimICPAG1
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_pradar$1 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
_pButton$ = 16						; size = 4
?SimICPAA1@@YAXKHPAX@Z PROC				; SimICPAA1

; 5171 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 5172 : 	if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag( MOTION_OWNSHIP ) && !((AircraftClass*)SimDriver.GetPlayerAircraft())->ejectTriggered) 

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN5@SimICPAA1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN5@SimICPAA1
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN5@SimICPAA1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1796], 0
	jne	$LN5@SimICPAA1

; 5173 : 	{
; 5174 : 		//MI 3/1/2002 if we're in DF or MRM, don't do anything
; 5175 : 		if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->FCC && (SimDriver.GetPlayerAircraft()->FCC->GetMasterMode() == 
; 5176 : 			FireControlComputer::Dogfight || SimDriver.GetPlayerAircraft()->FCC->GetMasterMode() == FireControlComputer::MissileOverride))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimICPAA1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+936], 0
	je	SHORT $LN3@SimICPAA1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 9
	je	SHORT $LN2@SimICPAA1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN3@SimICPAA1
$LN2@SimICPAA1:

; 5177 : 			return;

	jmp	$LN5@SimICPAA1
$LN3@SimICPAA1:

; 5178 : 
; 5179 : 		OTWDriver.pCockpitManager->mpIcp->HandleInput(AA_BUTTON, (CPButtonObject*)pButton);

	mov	ecx, DWORD PTR _pButton$[ebp]
	push	ecx
	push	11					; 0000000bH
	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [edx+688]
	call	?HandleInput@ICPClass@@QAEXHPAVCPButtonObject@@@Z ; ICPClass::HandleInput

; 5180 : 		SimDriver.GetPlayerAircraft()->FCC->SetMasterMode(FireControlComputer::AAGun);

	push	0
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?SetMasterMode@FireControlComputer@@QAEXW4FCCMasterMode@1@@Z ; FireControlComputer::SetMasterMode

; 5181 : 
; 5182 : 		// Put the radar in the its default AA mode
; 5183 : 		RadarClass* pradar = (RadarClass*) FindSensor (SimDriver.GetPlayerAircraft(), SensorClass::Radar);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _pradar$1[ebp], eax

; 5184 : 		if (pradar)

	cmp	DWORD PTR _pradar$1[ebp], 0
	je	SHORT $LN1@SimICPAA1

; 5185 : 			pradar->DefaultAAMode();

	mov	eax, DWORD PTR _pradar$1[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pradar$1[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN1@SimICPAA1:

; 5186 : 
; 5187 : 		// Configure the MFDs
; 5188 : 		MfdDisplay[0]->SetNewMasterMode(SimDriver.GetPlayerAircraft()->FCC->GetMainMasterMode());

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?GetMainMasterMode@FireControlComputer@@QAE?AW4MASTERMODES@@XZ ; FireControlComputer::GetMainMasterMode
	push	eax
	mov	ecx, 4
	imul	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?SetNewMasterMode@MFDClass@@QAEXH@Z	; MFDClass::SetNewMasterMode

; 5189 : 		MfdDisplay[1]->SetNewMasterMode(SimDriver.GetPlayerAircraft()->FCC->GetMainMasterMode());

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?GetMainMasterMode@FireControlComputer@@QAE?AW4MASTERMODES@@XZ ; FireControlComputer::GetMainMasterMode
	push	eax
	mov	edx, 4
	shl	edx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[edx]
	call	?SetNewMasterMode@MFDClass@@QAEXH@Z	; MFDClass::SetNewMasterMode
$LN5@SimICPAA1:

; 5190 : 	}
; 5191 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimICPAA1@@YAXKHPAX@Z ENDP				; SimICPAA1
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_pradar$1 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
_pButton$ = 16						; size = 4
?SimICPNav1@@YAXKHPAX@Z PROC				; SimICPNav1

; 5022 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 5023 : 	if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag( MOTION_OWNSHIP ) && !((AircraftClass*)SimDriver.GetPlayerAircraft())->ejectTriggered) 

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN5@SimICPNav1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN5@SimICPNav1
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN5@SimICPNav1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1796], 0
	jne	$LN5@SimICPNav1

; 5024 : 	{
; 5025 : 
; 5026 : 		OTWDriver.pCockpitManager->mpIcp->HandleInput(NAV_BUTTON, (CPButtonObject*)pButton);

	mov	ecx, DWORD PTR _pButton$[ebp]
	push	ecx
	push	10					; 0000000aH
	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [edx+688]
	call	?HandleInput@ICPClass@@QAEXHPAVCPButtonObject@@@Z ; ICPClass::HandleInput

; 5027 : 
; 5028 : 		// Select our FCC/HUD mode based on the NAV sub mode (ILS or not)
; 5029 : 		if (OTWDriver.pCockpitManager->mpIcp->GetICPSecondaryMode() == ILS_MODE) 

	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [eax+688]
	call	?GetICPSecondaryMode@ICPClass@@QAEJXZ	; ICPClass::GetICPSecondaryMode
	cmp	eax, 4
	jne	SHORT $LN3@SimICPNav1

; 5030 : 		{
; 5031 : 			SimDriver.GetPlayerAircraft()->FCC->SetMasterMode(FireControlComputer::ILS);

	push	3
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?SetMasterMode@FireControlComputer@@QAEXW4FCCMasterMode@1@@Z ; FireControlComputer::SetMasterMode

; 5032 : 		} 
; 5033 : 		else 

	jmp	SHORT $LN2@SimICPNav1
$LN3@SimICPNav1:

; 5034 : 		{
; 5035 : 			SimDriver.GetPlayerAircraft()->FCC->SetMasterMode(FireControlComputer::Nav);

	push	4
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?SetMasterMode@FireControlComputer@@QAEXW4FCCMasterMode@1@@Z ; FireControlComputer::SetMasterMode
$LN2@SimICPNav1:

; 5036 : 		}
; 5037 : 
; 5038 : 		// Put the radar in the its default AA mode
; 5039 : 		RadarClass* pradar = (RadarClass*) FindSensor (SimDriver.GetPlayerAircraft(), SensorClass::Radar);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _pradar$1[ebp], eax

; 5040 : 		if (pradar)

	cmp	DWORD PTR _pradar$1[ebp], 0
	je	SHORT $LN1@SimICPNav1

; 5041 : 			pradar->DefaultAAMode();

	mov	ecx, DWORD PTR _pradar$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pradar$1[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN1@SimICPNav1:

; 5042 : 
; 5043 : 		// Configure the MFDs
; 5044 : 		MfdDisplay[0]->SetNewMasterMode(SimDriver.GetPlayerAircraft()->FCC->GetMainMasterMode());

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?GetMainMasterMode@FireControlComputer@@QAE?AW4MASTERMODES@@XZ ; FireControlComputer::GetMainMasterMode
	push	eax
	mov	ecx, 4
	imul	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?SetNewMasterMode@MFDClass@@QAEXH@Z	; MFDClass::SetNewMasterMode

; 5045 : 		MfdDisplay[1]->SetNewMasterMode(SimDriver.GetPlayerAircraft()->FCC->GetMainMasterMode());

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	call	?GetMainMasterMode@FireControlComputer@@QAE?AW4MASTERMODES@@XZ ; FireControlComputer::GetMainMasterMode
	push	eax
	mov	edx, 4
	shl	edx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[edx]
	call	?SetNewMasterMode@MFDClass@@QAEXH@Z	; MFDClass::SetNewMasterMode
$LN5@SimICPNav1:

; 5046 : 	}
; 5047 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimICPNav1@@YAXKHPAX@Z ENDP				; SimICPNav1
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
_pButton$ = 16						; size = 4
?SimICPZERO@@YAXKHPAX@Z PROC				; SimICPZERO

; 6237 : {

	push	ebp
	mov	ebp, esp

; 6238 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimICPZERO
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimICPZERO
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimICPZERO

; 6239 : 	{
; 6240 : 		if(g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN3@SimICPZERO

; 6241 : 		{ 
; 6242 : 			//Player pushed the button, tell it to our ICP class
; 6243 : 			OTWDriver.pCockpitManager->mpIcp->HandleInput(ZERO_BUTTON, (CPButtonObject*)pButton);

	mov	edx, DWORD PTR _pButton$[ebp]
	push	edx
	push	26					; 0000001aH
	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [eax+688]
	call	?HandleInput@ICPClass@@QAEXHPAVCPButtonObject@@@Z ; ICPClass::HandleInput
$LN3@SimICPZERO:

; 6244 : 		}
; 6245 : 	}		
; 6246 : }

	pop	ebp
	ret	0
?SimICPZERO@@YAXKHPAX@Z ENDP				; SimICPZERO
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
_pButton$ = 16						; size = 4
?SimICPNINE@@YAXKHPAX@Z PROC				; SimICPNINE

; 6225 : {

	push	ebp
	mov	ebp, esp

; 6226 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimICPNINE
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimICPNINE
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimICPNINE

; 6227 : 	{
; 6228 : 		if(g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN3@SimICPNINE

; 6229 : 		{ 
; 6230 : 			//Player pushed the button, tell it to our ICP class
; 6231 : 			OTWDriver.pCockpitManager->mpIcp->HandleInput(NINE_BUTTON, (CPButtonObject*)pButton);

	mov	edx, DWORD PTR _pButton$[ebp]
	push	edx
	push	25					; 00000019H
	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [eax+688]
	call	?HandleInput@ICPClass@@QAEXHPAVCPButtonObject@@@Z ; ICPClass::HandleInput
$LN3@SimICPNINE:

; 6232 : 		}
; 6233 : 	}		
; 6234 : }

	pop	ebp
	ret	0
?SimICPNINE@@YAXKHPAX@Z ENDP				; SimICPNINE
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
_pButton$ = 16						; size = 4
?SimICPEIGHT@@YAXKHPAX@Z PROC				; SimICPEIGHT

; 6213 : {

	push	ebp
	mov	ebp, esp

; 6214 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimICPEIGH
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimICPEIGH
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimICPEIGH

; 6215 : 	{
; 6216 : 		if(g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN3@SimICPEIGH

; 6217 : 		{ 
; 6218 : 			//Player pushed the button, tell it to our ICP class
; 6219 : 			OTWDriver.pCockpitManager->mpIcp->HandleInput(EIGHT_BUTTON, (CPButtonObject*)pButton);

	mov	edx, DWORD PTR _pButton$[ebp]
	push	edx
	push	24					; 00000018H
	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [eax+688]
	call	?HandleInput@ICPClass@@QAEXHPAVCPButtonObject@@@Z ; ICPClass::HandleInput
$LN3@SimICPEIGH:

; 6220 : 		}
; 6221 : 	}		
; 6222 : }

	pop	ebp
	ret	0
?SimICPEIGHT@@YAXKHPAX@Z ENDP				; SimICPEIGHT
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
_pButton$ = 16						; size = 4
?SimICPSIX@@YAXKHPAX@Z PROC				; SimICPSIX

; 6194 : {

	push	ebp
	mov	ebp, esp

; 6195 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN5@SimICPSIX
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN5@SimICPSIX
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN5@SimICPSIX

; 6196 : 	{
; 6197 : 		if(g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN3@SimICPSIX

; 6198 : 		{ 
; 6199 : 			//Player pushed the button, tell it to our ICP class
; 6200 : 			OTWDriver.pCockpitManager->mpIcp->HandleInput(SIX_BUTTON, (CPButtonObject*)pButton);

	mov	edx, DWORD PTR _pButton$[ebp]
	push	edx
	push	23					; 00000017H
	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [eax+688]
	call	?HandleInput@ICPClass@@QAEXHPAVCPButtonObject@@@Z ; ICPClass::HandleInput

; 6201 : 		}
; 6202 : 		else

	jmp	SHORT $LN5@SimICPSIX
$LN3@SimICPSIX:

; 6203 : 		{
; 6204 : 			if (state & KEY_DOWN && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag( MOTION_OWNSHIP ) && !((AircraftClass*)SimDriver.GetPlayerAircraft())->ejectTriggered) 

	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN5@SimICPSIX
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN5@SimICPSIX
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN5@SimICPSIX
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1796], 0
	jne	SHORT $LN5@SimICPSIX

; 6205 : 			{
; 6206 : 				OTWDriver.pCockpitManager->mpIcp->HandleInput(DLINK_BUTTON, (CPButtonObject*)pButton);

	mov	edx, DWORD PTR _pButton$[ebp]
	push	edx
	push	2
	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [eax+688]
	call	?HandleInput@ICPClass@@QAEXHPAVCPButtonObject@@@Z ; ICPClass::HandleInput
$LN5@SimICPSIX:

; 6207 : 			}
; 6208 : 		}
; 6209 : 	}		
; 6210 : }

	pop	ebp
	ret	0
?SimICPSIX@@YAXKHPAX@Z ENDP				; SimICPSIX
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
_pButton$ = 16						; size = 4
?SimICPTHREE@@YAXKHPAX@Z PROC				; SimICPTHREE

; 6182 : {

	push	ebp
	mov	ebp, esp

; 6183 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimICPTHRE
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimICPTHRE
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimICPTHRE

; 6184 : 	{
; 6185 : 		if(g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN3@SimICPTHRE

; 6186 : 		{ 
; 6187 : 			//Player pushed the button, tell it to our ICP class
; 6188 : 			OTWDriver.pCockpitManager->mpIcp->HandleInput(THREE_BUTTON, (CPButtonObject*)pButton);

	mov	edx, DWORD PTR _pButton$[ebp]
	push	edx
	push	22					; 00000016H
	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [eax+688]
	call	?HandleInput@ICPClass@@QAEXHPAVCPButtonObject@@@Z ; ICPClass::HandleInput
$LN3@SimICPTHRE:

; 6189 : 		}
; 6190 : 	}		
; 6191 : }

	pop	ebp
	ret	0
?SimICPTHREE@@YAXKHPAX@Z ENDP				; SimICPTHREE
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
_pButton$ = 16						; size = 4
?SimICPLIST@@YAXKHPAX@Z PROC				; SimICPLIST

; 6170 : {

	push	ebp
	mov	ebp, esp

; 6171 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimICPLIST
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimICPLIST
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimICPLIST

; 6172 : 	{
; 6173 : 		if(g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN3@SimICPLIST

; 6174 : 		{ 
; 6175 : 			//Player pushed the button, tell it to our ICP class
; 6176 : 			OTWDriver.pCockpitManager->mpIcp->HandleInput(LIST_BUTTON, (CPButtonObject*)pButton);

	mov	edx, DWORD PTR _pButton$[ebp]
	push	edx
	push	21					; 00000015H
	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [eax+688]
	call	?HandleInput@ICPClass@@QAEXHPAVCPButtonObject@@@Z ; ICPClass::HandleInput
$LN3@SimICPLIST:

; 6177 : 		}
; 6178 : 	}		
; 6179 : }

	pop	ebp
	ret	0
?SimICPLIST@@YAXKHPAX@Z ENDP				; SimICPLIST
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
_pButton$ = 16						; size = 4
?SimICPIFF@@YAXKHPAX@Z PROC				; SimICPIFF

; 6158 : {

	push	ebp
	mov	ebp, esp

; 6159 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimICPIFF
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimICPIFF
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimICPIFF

; 6160 : 	{
; 6161 : 		if(g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN3@SimICPIFF

; 6162 : 		{ 
; 6163 : 			//Player pushed the button, tell it to our ICP class
; 6164 : 			OTWDriver.pCockpitManager->mpIcp->HandleInput(IFF_BUTTON, (CPButtonObject*)pButton);

	mov	edx, DWORD PTR _pButton$[ebp]
	push	edx
	push	20					; 00000014H
	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [eax+688]
	call	?HandleInput@ICPClass@@QAEXHPAVCPButtonObject@@@Z ; ICPClass::HandleInput
$LN3@SimICPIFF:

; 6165 : 		}
; 6166 : 	}		
; 6167 : }

	pop	ebp
	ret	0
?SimICPIFF@@YAXKHPAX@Z ENDP				; SimICPIFF
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimFuelTransWing@@YAXKHPAX@Z PROC			; SimFuelTransWing

; 10734: {

	push	ebp
	mov	ebp, esp

; 10735: 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimFuelTra

; 10736: 		return;

	jmp	SHORT $LN4@SimFuelTra
$LN3@SimFuelTra:

; 10737: 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimFuelTra
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimFuelTra
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimFuelTra

; 10738: 	{
; 10739: 		SimDriver.GetPlayerAircraft()->af->SetEngineFlag(AirframeClass::WingFirst);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?SetEngineFlag@AirframeClass@@QAEXW4EngineFlags@1@@Z ; AirframeClass::SetEngineFlag

; 10740: 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimFuelTra

; 10741: 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_FUEL_EXT_TRANS, 2);

	push	2
	push	160					; 000000a0H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimFuelTra:

; 10742: 	}
; 10743: }

	pop	ebp
	ret	0
?SimFuelTransWing@@YAXKHPAX@Z ENDP			; SimFuelTransWing
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimFuelTransNorm@@YAXKHPAX@Z PROC			; SimFuelTransNorm

; 10722: {

	push	ebp
	mov	ebp, esp

; 10723: 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimFuelTra

; 10724: 		return;

	jmp	SHORT $LN4@SimFuelTra
$LN3@SimFuelTra:

; 10725: 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimFuelTra
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimFuelTra
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimFuelTra

; 10726: 	{
; 10727: 		SimDriver.GetPlayerAircraft()->af->ClearEngineFlag(AirframeClass::WingFirst);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?ClearEngineFlag@AirframeClass@@QAEXW4EngineFlags@1@@Z ; AirframeClass::ClearEngineFlag

; 10728: 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimFuelTra

; 10729: 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_FUEL_EXT_TRANS, 1);

	push	1
	push	160					; 000000a0H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimFuelTra:

; 10730: 	}
; 10731: }

	pop	ebp
	ret	0
?SimFuelTransNorm@@YAXKHPAX@Z ENDP			; SimFuelTransNorm
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimExtFuelTrans@@YAXKHPAX@Z PROC			; SimExtFuelTrans

; 10570: {

	push	ebp
	mov	ebp, esp

; 10571: 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN2@SimExtFuel

; 10572: 		return;

	jmp	SHORT $LN3@SimExtFuel
$LN2@SimExtFuel:

; 10573: 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimExtFuel
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimExtFuel
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN3@SimExtFuel

; 10574: 		SimDriver.GetPlayerAircraft()->af->ToggleEngineFlag(AirframeClass::WingFirst);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?ToggleEngineFlag@AirframeClass@@QAEXW4EngineFlags@1@@Z ; AirframeClass::ToggleEngineFlag
$LN3@SimExtFuel:

; 10575: }

	pop	ebp
	ret	0
?SimExtFuelTrans@@YAXKHPAX@Z ENDP			; SimExtFuelTrans
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv84 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimReverseThrusterToggle@@YAXKHPAX@Z PROC		; SimReverseThrusterToggle

; 3384 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 3385 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && SimDriver.GetPlayerAircraft()->OnGround())

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN6@SimReverse
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN6@SimReverse
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR tv84[ebp], eax
	mov	eax, DWORD PTR tv84[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv84[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	je	$LN6@SimReverse

; 3386 : 	{
; 3387 : 		if (SimDriver.GetPlayerAircraft()->af->thrustReverse == 0)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	cmp	DWORD PTR [ecx+1592], 0
	jne	SHORT $LN4@SimReverse

; 3388 : 		{
; 3389 : 			SimDriver.GetPlayerAircraft()->af->thrustReverse = 2;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+932]
	mov	DWORD PTR [edx+1592], 2

; 3390 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN3@SimReverse

; 3391 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_REV_THRUSTER, 2);

	push	2
	push	218					; 000000daH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN3@SimReverse:

; 3392 : 		}
; 3393 : 		else

	jmp	SHORT $LN6@SimReverse
$LN4@SimReverse:

; 3394 : 		{
; 3395 : 			SimDriver.GetPlayerAircraft()->af->thrustReverse = 0;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	eax, DWORD PTR [eax+932]
	mov	DWORD PTR [eax+1592], 0

; 3396 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN6@SimReverse

; 3397 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_REV_THRUSTER, 1);

	push	1
	push	218					; 000000daH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN6@SimReverse:

; 3398 : 		}
; 3399 : 	}
; 3400 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimReverseThrusterToggle@@YAXKHPAX@Z ENDP		; SimReverseThrusterToggle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv84 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimReverseThrusterOff@@YAXKHPAX@Z PROC			; SimReverseThrusterOff

; 3413 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 3414 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && SimDriver.GetPlayerAircraft()->OnGround())

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimReverse
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimReverse
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR tv84[ebp], eax
	mov	eax, DWORD PTR tv84[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv84[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	je	SHORT $LN3@SimReverse

; 3415 : 	{
; 3416 : 		SimDriver.GetPlayerAircraft()->af->thrustReverse = 0;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	mov	DWORD PTR [ecx+1592], 0

; 3417 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN3@SimReverse

; 3418 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_REV_THRUSTER, 1);

	push	1
	push	218					; 000000daH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN3@SimReverse:

; 3419 : 	}
; 3420 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimReverseThrusterOff@@YAXKHPAX@Z ENDP			; SimReverseThrusterOff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv84 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimReverseThrusterOn@@YAXKHPAX@Z PROC			; SimReverseThrusterOn

; 3403 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 3404 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && SimDriver.GetPlayerAircraft()->OnGround())

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimReverse
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimReverse
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR tv84[ebp], eax
	mov	eax, DWORD PTR tv84[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv84[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	je	SHORT $LN3@SimReverse

; 3405 : 	{
; 3406 : 		SimDriver.GetPlayerAircraft()->af->thrustReverse = 2;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	mov	DWORD PTR [ecx+1592], 2

; 3407 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN3@SimReverse

; 3408 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_REV_THRUSTER, 2);

	push	2
	push	218					; 000000daH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN3@SimReverse:

; 3409 : 	}
; 3410 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimReverseThrusterOn@@YAXKHPAX@Z ENDP			; SimReverseThrusterOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?AFCanopyToggle@@YAXKHPAX@Z PROC			; AFCanopyToggle

; 10212: {

	push	ebp
	mov	ebp, esp

; 10213:   if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN5@AFCanopyTo
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN5@AFCanopyTo
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN5@AFCanopyTo

; 10214:   {
; 10215: 		SimDriver.GetPlayerAircraft()->af->CanopyToggle();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?CanopyToggle@AirframeClass@@QAEXXZ	; AirframeClass::CanopyToggle

; 10216: 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN5@AFCanopyTo

; 10217: 			if (SimDriver.GetPlayerAircraft()->af->canopyState == true)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	movzx	edx, BYTE PTR [ecx+1588]
	cmp	edx, 1
	jne	SHORT $LN2@AFCanopyTo

; 10218: 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_CANOPY, 2);

	push	2
	push	175					; 000000afH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 10219: 			else

	jmp	SHORT $LN5@AFCanopyTo
$LN2@AFCanopyTo:

; 10220: 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_CANOPY, 1);

	push	1
	push	175					; 000000afH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN5@AFCanopyTo:

; 10221:   }
; 10222: }

	pop	ebp
	ret	0
?AFCanopyToggle@@YAXKHPAX@Z ENDP			; AFCanopyToggle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv90 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?AFDragChute@@YAXKHPAX@Z PROC				; AFDragChute

; 10132: {

	push	ebp
	mov	ebp, esp
	push	ecx

; 10133:     if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN9@AFDragChut
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN9@AFDragChut
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN9@AFDragChut

; 10134:     {
; 10135: 			if (SimDriver.GetPlayerAircraft()->af->HasDragChute())

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?HasDragChute@AirframeClass@@QAE_NXZ	; AirframeClass::HasDragChute
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN7@AFDragChut

; 10136: 				switch (SimDriver.GetPlayerAircraft()->af->dragChute) 

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+932]
	mov	eax, DWORD PTR [edx+1584]
	mov	DWORD PTR tv90[ebp], eax
	cmp	DWORD PTR tv90[ebp], 0
	je	SHORT $LN4@AFDragChut
	cmp	DWORD PTR tv90[ebp], 0
	jle	SHORT $LN7@AFDragChut
	cmp	DWORD PTR tv90[ebp], 2
	jle	SHORT $LN3@AFDragChut
	jmp	SHORT $LN7@AFDragChut
$LN4@AFDragChut:

; 10137: 				{
; 10138: 					case AirframeClass::DRAGC_STOWED:
; 10139: 						SimDriver.GetPlayerAircraft()->af->dragChute = AirframeClass::DRAGC_DEPLOYED;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	mov	DWORD PTR [ecx+1584], 1

; 10140: 						break;

	jmp	SHORT $LN7@AFDragChut
$LN3@AFDragChut:

; 10141: 					case AirframeClass::DRAGC_DEPLOYED:
; 10142: 					case AirframeClass::DRAGC_TRAILING:
; 10143: 						SimDriver.GetPlayerAircraft()->af->dragChute = AirframeClass::DRAGC_JETTISONNED;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+932]
	mov	DWORD PTR [edx+1584], 4
$LN7@AFDragChut:

; 10144: 						break;
; 10145: 				}
; 10146: 			if (SimDriver.GetPlayerAircraft()->af->dragChute == AirframeClass::DRAGC_STOWED)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	eax, DWORD PTR [eax+932]
	cmp	DWORD PTR [eax+1584], 0
	jne	SHORT $LN2@AFDragChut

; 10147: 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_DRAGCHUTE, 1);

	push	1
	push	220					; 000000dcH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 10148: 			else

	jmp	SHORT $LN9@AFDragChut
$LN2@AFDragChut:

; 10149: 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_DRAGCHUTE, 2);

	push	2
	push	220					; 000000dcH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN9@AFDragChut:

; 10150:     }
; 10151: }

	mov	esp, ebp
	pop	ebp
	ret	0
?AFDragChute@@YAXKHPAX@Z ENDP				; AFDragChute
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?AFDecLEF@@YAXKHPAX@Z PROC				; AFDecLEF

; 10124: {

	push	ebp
	mov	ebp, esp

; 10125:     if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@AFDecLEF
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@AFDecLEF
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@AFDecLEF

; 10126:     {
; 10127: 		SimDriver.GetPlayerAircraft()->af->LEFDec();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?LEFDec@AirframeClass@@QAEXXZ		; AirframeClass::LEFDec
$LN2@AFDecLEF:

; 10128:     }
; 10129: }

	pop	ebp
	ret	0
?AFDecLEF@@YAXKHPAX@Z ENDP				; AFDecLEF
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?AFIncLEF@@YAXKHPAX@Z PROC				; AFIncLEF

; 10116: {

	push	ebp
	mov	ebp, esp

; 10117:     if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@AFIncLEF
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@AFIncLEF
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@AFIncLEF

; 10118:     {
; 10119: 		SimDriver.GetPlayerAircraft()->af->LEFInc();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?LEFInc@AirframeClass@@QAEXXZ		; AirframeClass::LEFInc
$LN2@AFIncLEF:

; 10120:     }
; 10121: }

	pop	ebp
	ret	0
?AFIncLEF@@YAXKHPAX@Z ENDP				; AFIncLEF
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?AFNoLEF@@YAXKHPAX@Z PROC				; AFNoLEF

; 10108: {

	push	ebp
	mov	ebp, esp

; 10109:     if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@AFNoLEF
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@AFNoLEF
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@AFNoLEF

; 10110:     {
; 10111: 		SimDriver.GetPlayerAircraft()->af->LEFClose();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?LEFClose@AirframeClass@@QAEXXZ		; AirframeClass::LEFClose
$LN2@AFNoLEF:

; 10112:     }
; 10113: }

	pop	ebp
	ret	0
?AFNoLEF@@YAXKHPAX@Z ENDP				; AFNoLEF
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?AFFullLEF@@YAXKHPAX@Z PROC				; AFFullLEF

; 10100: {

	push	ebp
	mov	ebp, esp

; 10101:     if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@AFFullLEF
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@AFFullLEF
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@AFFullLEF

; 10102:     {
; 10103: 		SimDriver.GetPlayerAircraft()->af->LEFMax();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?LEFMax@AirframeClass@@QAEXXZ		; AirframeClass::LEFMax
$LN2@AFFullLEF:

; 10104:     }
; 10105: }

	pop	ebp
	ret	0
?AFFullLEF@@YAXKHPAX@Z ENDP				; AFFullLEF
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_playerAC$ = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?AFDecFlap@@YAXKHPAX@Z PROC				; AFDecFlap

; 10091: void AFDecFlap(unsigned long, int state, void*){

	push	ebp
	mov	ebp, esp
	push	ecx

; 10092: 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 10093:     if(playerAC && playerAC->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)){

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	SHORT $LN2@AFDecFlap
	push	65536					; 00010000H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@AFDecFlap
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@AFDecFlap

; 10094: 		playerAC->af->TEFDec();

	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [ecx+932]
	call	?TEFDec@AirframeClass@@QAEXXZ		; AirframeClass::TEFDec

; 10095: 		playerAC->af->flapPos = 4;//TJL 02/28/04

	mov	edx, DWORD PTR _playerAC$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	DWORD PTR [eax+836], 4
$LN2@AFDecFlap:

; 10096:     }
; 10097: }

	mov	esp, ebp
	pop	ebp
	ret	0
?AFDecFlap@@YAXKHPAX@Z ENDP				; AFDecFlap
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_playerAC$ = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?AFIncFlap@@YAXKHPAX@Z PROC				; AFIncFlap

; 10084: {

	push	ebp
	mov	ebp, esp
	push	ecx

; 10085: 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 10086:     if (playerAC && playerAC->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)){

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	SHORT $LN2@AFIncFlap
	push	65536					; 00010000H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@AFIncFlap
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@AFIncFlap

; 10087: 		playerAC->af->TEFInc();

	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [ecx+932]
	call	?TEFInc@AirframeClass@@QAEXXZ		; AirframeClass::TEFInc

; 10088: 		playerAC->af->flapPos = 0;//TJL 02/28/04

	mov	edx, DWORD PTR _playerAC$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	DWORD PTR [eax+836], 0
$LN2@AFIncFlap:

; 10089:     }
; 10090: }

	mov	esp, ebp
	pop	ebp
	ret	0
?AFIncFlap@@YAXKHPAX@Z ENDP				; AFIncFlap
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?AFNoFlap@@YAXKHPAX@Z PROC				; AFNoFlap

; 10076: {

	push	ebp
	mov	ebp, esp

; 10077:     if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@AFNoFlap
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@AFNoFlap
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@AFNoFlap

; 10078:     {
; 10079: 		SimDriver.GetPlayerAircraft()->af->TEFClose();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?TEFClose@AirframeClass@@QAEXXZ		; AirframeClass::TEFClose

; 10080: 		SimDriver.GetPlayerAircraft()->af->flapPos = 3;//TJL 02/28/04

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	mov	DWORD PTR [ecx+836], 3
$LN2@AFNoFlap:

; 10081:     }
; 10082: }

	pop	ebp
	ret	0
?AFNoFlap@@YAXKHPAX@Z ENDP				; AFNoFlap
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv152 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?AFFullFlap@@YAXKHPAX@Z PROC				; AFFullFlap

; 10046: {

	push	ebp
	mov	ebp, esp
	push	ecx

; 10047:     if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN7@AFFullFlap
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN7@AFFullFlap
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN7@AFFullFlap

; 10048: 	//TJL 02/28/04 Adding Auto/Half/Full for F18's
; 10049: 	//10 = AUTO, 20 = HALF, 30 = FULL
; 10050: 	{
; 10051: 		if (SimDriver.GetPlayerAircraft()->af->GetTypeAC() == 8 ||
; 10052: 			SimDriver.GetPlayerAircraft()->af->GetTypeAC() == 9 ||
; 10053: 			SimDriver.GetPlayerAircraft()->af->GetTypeAC() == 10)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?GetTypeAC@AirframeClass@@QAEHXZ	; AirframeClass::GetTypeAC
	cmp	eax, 8
	je	SHORT $LN4@AFFullFlap
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?GetTypeAC@AirframeClass@@QAEHXZ	; AirframeClass::GetTypeAC
	cmp	eax, 9
	je	SHORT $LN4@AFFullFlap
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?GetTypeAC@AirframeClass@@QAEHXZ	; AirframeClass::GetTypeAC
	cmp	eax, 10					; 0000000aH
	jne	$LN5@AFFullFlap
$LN4@AFFullFlap:

; 10054: 		{
; 10055: 			if (
; 10056: 				SimDriver.GetPlayerAircraft()->af->flapPos != 10 &&
; 10057: 				SimDriver.GetPlayerAircraft()->af->flapPos != 20 &&
; 10058: 				SimDriver.GetPlayerAircraft()->af->flapPos != 30
; 10059: 			){

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	cmp	DWORD PTR [ecx+836], 10			; 0000000aH
	je	SHORT $LN3@AFFullFlap
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+932]
	cmp	DWORD PTR [edx+836], 20			; 00000014H
	je	SHORT $LN3@AFFullFlap
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	eax, DWORD PTR [eax+932]
	cmp	DWORD PTR [eax+836], 30			; 0000001eH
	je	SHORT $LN3@AFFullFlap

; 10060: 				SimDriver.GetPlayerAircraft()->af->flapPos = 10;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	mov	DWORD PTR [ecx+836], 10			; 0000000aH
$LN3@AFFullFlap:

; 10061: 			}
; 10062: 
; 10063: 			SimDriver.GetPlayerAircraft()->af->flapPos += 10;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+932]
	add	edx, 836				; 00000344H
	mov	DWORD PTR tv152[ebp], edx
	mov	eax, DWORD PTR tv152[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 10					; 0000000aH
	mov	edx, DWORD PTR tv152[ebp]
	mov	DWORD PTR [edx], ecx

; 10064: 			if (SimDriver.GetPlayerAircraft()->af->flapPos > 30){

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	eax, DWORD PTR [eax+932]
	cmp	DWORD PTR [eax+836], 30			; 0000001eH
	jle	SHORT $LN2@AFFullFlap

; 10065: 				SimDriver.GetPlayerAircraft()->af->flapPos = 10;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	mov	DWORD PTR [ecx+836], 10			; 0000000aH
$LN2@AFFullFlap:

; 10066: 			}
; 10067: 		}
; 10068: 		//orig code
; 10069: 		else {

	jmp	SHORT $LN7@AFFullFlap
$LN5@AFFullFlap:

; 10070: 			SimDriver.GetPlayerAircraft()->af->TEFMax();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?TEFMax@AirframeClass@@QAEXXZ		; AirframeClass::TEFMax

; 10071: 			SimDriver.GetPlayerAircraft()->af->flapPos = 0;//TJL 02/28/04

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+932]
	mov	DWORD PTR [edx+836], 0
$LN7@AFFullFlap:

; 10072: 		}
; 10073: 	}
; 10074: }

	mov	esp, ebp
	pop	ebp
	ret	0
?AFFullFlap@@YAXKHPAX@Z ENDP				; AFFullFlap
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimMainPowerMain@@YAXKHPAX@Z PROC			; SimMainPowerMain

; 8605 : {

	push	ebp
	mov	ebp, esp

; 8606 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN4@SimMainPow

; 8607 : 		return;

	jmp	$LN5@SimMainPow
$LN4@SimMainPow:

; 8608 :     if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN5@SimMainPow
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN5@SimMainPow
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	$LN5@SimMainPow

; 8609 :     { 
; 8610 : 			SimDriver.GetPlayerAircraft()->SetMainPower(AircraftClass::MainPowerMain);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetMainPower@AircraftClass@@QAEXW4MainPowerType@1@@Z ; AircraftClass::SetMainPower

; 8611 : 			// Probably overkill to repeat this here but just in case someone's cockpit or
; 8612 : 			// HOTAS programming has the power switch go direct from "off" to "main"...
; 8613 : 			if(!g_bINS)

	movzx	edx, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	edx, edx
	jne	$LN2@SimMainPow

; 8614 : 			{
; 8615 : 				SimDriver.GetPlayerAircraft()->INSOn(AircraftClass::INS_ADI_OFF_IN);

	push	128					; 00000080H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?INSOn@AircraftClass@@QAEXW4INSAlignFlags@1@@Z ; AircraftClass::INSOn

; 8616 : 				SimDriver.GetPlayerAircraft()->INSOn(AircraftClass::INS_ADI_AUX_IN);;

	push	256					; 00000100H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?INSOn@AircraftClass@@QAEXW4INSAlignFlags@1@@Z ; AircraftClass::INSOn

; 8617 : 				SimDriver.GetPlayerAircraft()->INSOn(AircraftClass::INS_HUD_STUFF);

	push	1024					; 00000400H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?INSOn@AircraftClass@@QAEXW4INSAlignFlags@1@@Z ; AircraftClass::INSOn

; 8618 : 				SimDriver.GetPlayerAircraft()->INSOn(AircraftClass::INS_HSI_OFF_IN);

	push	2048					; 00000800H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?INSOn@AircraftClass@@QAEXW4INSAlignFlags@1@@Z ; AircraftClass::INSOn

; 8619 : 				SimDriver.GetPlayerAircraft()->INSOn(AircraftClass::INS_HSD_STUFF);

	push	4096					; 00001000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?INSOn@AircraftClass@@QAEXW4INSAlignFlags@1@@Z ; AircraftClass::INSOn

; 8620 : 				SimDriver.GetPlayerAircraft()->INSOn(AircraftClass::BUP_ADI_OFF_IN);

	push	8192					; 00002000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?INSOn@AircraftClass@@QAEXW4INSAlignFlags@1@@Z ; AircraftClass::INSOn

; 8621 : 				SimDriver.GetPlayerAircraft()->GSValid = TRUE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	BYTE PTR [eax+836], 1

; 8622 : 				SimDriver.GetPlayerAircraft()->LOCValid = TRUE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	BYTE PTR [eax+837], 1
$LN2@SimMainPow:

; 8623 : 			}
; 8624 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN5@SimMainPow

; 8625 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_MAIN_PWR, 4);

	push	4
	push	177					; 000000b1H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN5@SimMainPow:

; 8626 :     }
; 8627 : }

	pop	ebp
	ret	0
?SimMainPowerMain@@YAXKHPAX@Z ENDP			; SimMainPowerMain
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimMainPowerBatt@@YAXKHPAX@Z PROC			; SimMainPowerBatt

; 8582 : {

	push	ebp
	mov	ebp, esp

; 8583 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN4@SimMainPow

; 8584 : 		return;

	jmp	$LN5@SimMainPow
$LN4@SimMainPow:

; 8585 :     if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN5@SimMainPow
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN5@SimMainPow
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	$LN5@SimMainPow

; 8586 :     { 
; 8587 : 			SimDriver.GetPlayerAircraft()->SetMainPower(AircraftClass::MainPowerBatt);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetMainPower@AircraftClass@@QAEXW4MainPowerType@1@@Z ; AircraftClass::SetMainPower

; 8588 : 			if(!g_bINS)

	movzx	edx, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	edx, edx
	jne	$LN2@SimMainPow

; 8589 : 			{
; 8590 : 				SimDriver.GetPlayerAircraft()->INSOn(AircraftClass::INS_ADI_OFF_IN);

	push	128					; 00000080H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?INSOn@AircraftClass@@QAEXW4INSAlignFlags@1@@Z ; AircraftClass::INSOn

; 8591 : 				SimDriver.GetPlayerAircraft()->INSOn(AircraftClass::INS_ADI_AUX_IN);;

	push	256					; 00000100H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?INSOn@AircraftClass@@QAEXW4INSAlignFlags@1@@Z ; AircraftClass::INSOn

; 8592 : 				SimDriver.GetPlayerAircraft()->INSOn(AircraftClass::INS_HUD_STUFF);

	push	1024					; 00000400H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?INSOn@AircraftClass@@QAEXW4INSAlignFlags@1@@Z ; AircraftClass::INSOn

; 8593 : 				SimDriver.GetPlayerAircraft()->INSOn(AircraftClass::INS_HSI_OFF_IN);

	push	2048					; 00000800H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?INSOn@AircraftClass@@QAEXW4INSAlignFlags@1@@Z ; AircraftClass::INSOn

; 8594 : 				SimDriver.GetPlayerAircraft()->INSOn(AircraftClass::INS_HSD_STUFF);

	push	4096					; 00001000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?INSOn@AircraftClass@@QAEXW4INSAlignFlags@1@@Z ; AircraftClass::INSOn

; 8595 : 				SimDriver.GetPlayerAircraft()->INSOn(AircraftClass::BUP_ADI_OFF_IN);

	push	8192					; 00002000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?INSOn@AircraftClass@@QAEXW4INSAlignFlags@1@@Z ; AircraftClass::INSOn

; 8596 : 				SimDriver.GetPlayerAircraft()->GSValid = TRUE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	BYTE PTR [eax+836], 1

; 8597 : 				SimDriver.GetPlayerAircraft()->LOCValid = TRUE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	BYTE PTR [eax+837], 1
$LN2@SimMainPow:

; 8598 : 			}
; 8599 :  			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN5@SimMainPow

; 8600 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_MAIN_PWR, 2);

	push	2
	push	177					; 000000b1H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN5@SimMainPow:

; 8601 :    }
; 8602 : }

	pop	ebp
	ret	0
?SimMainPowerBatt@@YAXKHPAX@Z ENDP			; SimMainPowerBatt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimMainPowerOff@@YAXKHPAX@Z PROC			; SimMainPowerOff

; 8559 : {

	push	ebp
	mov	ebp, esp

; 8560 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN4@SimMainPow

; 8561 : 		return;

	jmp	$LN5@SimMainPow
$LN4@SimMainPow:

; 8562 :     if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN5@SimMainPow
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN5@SimMainPow
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	$LN5@SimMainPow

; 8563 :     { 
; 8564 : 			SimDriver.GetPlayerAircraft()->SetMainPower(AircraftClass::MainPowerOff);

	push	0
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetMainPower@AircraftClass@@QAEXW4MainPowerType@1@@Z ; AircraftClass::SetMainPower

; 8565 : 			if(!g_bINS)

	movzx	edx, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	edx, edx
	jne	$LN2@SimMainPow

; 8566 : 			{
; 8567 : 				SimDriver.GetPlayerAircraft()->INSOff(AircraftClass::INS_ADI_OFF_IN);

	push	128					; 00000080H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?INSOff@AircraftClass@@QAEXW4INSAlignFlags@1@@Z ; AircraftClass::INSOff

; 8568 : 				SimDriver.GetPlayerAircraft()->INSOff(AircraftClass::INS_ADI_AUX_IN);;

	push	256					; 00000100H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?INSOff@AircraftClass@@QAEXW4INSAlignFlags@1@@Z ; AircraftClass::INSOff

; 8569 : 				SimDriver.GetPlayerAircraft()->INSOff(AircraftClass::INS_HUD_STUFF);

	push	1024					; 00000400H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?INSOff@AircraftClass@@QAEXW4INSAlignFlags@1@@Z ; AircraftClass::INSOff

; 8570 : 				SimDriver.GetPlayerAircraft()->INSOff(AircraftClass::INS_HSI_OFF_IN);

	push	2048					; 00000800H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?INSOff@AircraftClass@@QAEXW4INSAlignFlags@1@@Z ; AircraftClass::INSOff

; 8571 : 				SimDriver.GetPlayerAircraft()->INSOff(AircraftClass::INS_HSD_STUFF);

	push	4096					; 00001000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?INSOff@AircraftClass@@QAEXW4INSAlignFlags@1@@Z ; AircraftClass::INSOff

; 8572 : 				SimDriver.GetPlayerAircraft()->INSOff(AircraftClass::BUP_ADI_OFF_IN);

	push	8192					; 00002000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?INSOff@AircraftClass@@QAEXW4INSAlignFlags@1@@Z ; AircraftClass::INSOff

; 8573 : 				SimDriver.GetPlayerAircraft()->GSValid = FALSE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	BYTE PTR [eax+836], 0

; 8574 : 				SimDriver.GetPlayerAircraft()->LOCValid = FALSE;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	BYTE PTR [eax+837], 0
$LN2@SimMainPow:

; 8575 : 			}
; 8576 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN5@SimMainPow

; 8577 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_MAIN_PWR, 1);

	push	1
	push	177					; 000000b1H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN5@SimMainPow:

; 8578 :     }
; 8579 : }

	pop	ebp
	ret	0
?SimMainPowerOff@@YAXKHPAX@Z ENDP			; SimMainPowerOff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimMainPowerInc@@YAXKHPAX@Z PROC			; SimMainPowerInc

; 8534 : {

	push	ebp
	mov	ebp, esp

; 8535 :     if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN4@SimMainPow
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimMainPow
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN4@SimMainPow

; 8536 :     { 
; 8537 : 			SimDriver.GetPlayerAircraft()->IncMainPower();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IncMainPower@AircraftClass@@QAEXXZ	; AircraftClass::IncMainPower

; 8538 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimMainPow

; 8539 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimMainPow

; 8540 : 				//OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_MAIN_PWR, SimDriver.GetPlayerAircraft()->MainPowerOn()+1);
; 8541 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_MAIN_PWR, 1<<SimDriver.GetPlayerAircraft()->MainPowerOn());

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?MainPowerOn@AircraftClass@@QAEHXZ	; AircraftClass::MainPowerOn
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	push	edx
	push	177					; 000000b1H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimMainPow:

; 8542 :     }
; 8543 : }

	pop	ebp
	ret	0
?SimMainPowerInc@@YAXKHPAX@Z ENDP			; SimMainPowerInc
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimMainPowerDec@@YAXKHPAX@Z PROC			; SimMainPowerDec

; 8545 : {

	push	ebp
	mov	ebp, esp

; 8546 :     if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimMainPow
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimMainPow
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimMainPow

; 8547 :     { 
; 8548 : 			SimDriver.GetPlayerAircraft()->DecMainPower();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?DecMainPower@AircraftClass@@QAEXXZ	; AircraftClass::DecMainPower

; 8549 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN3@SimMainPow

; 8550 : 				//OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_MAIN_PWR, SimDriver.GetPlayerAircraft()->MainPowerOn()+1);
; 8551 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_MAIN_PWR, 1<<SimDriver.GetPlayerAircraft()->MainPowerOn());

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?MainPowerOn@AircraftClass@@QAEHXZ	; AircraftClass::MainPowerOn
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	push	edx
	push	177					; 000000b1H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN3@SimMainPow:

; 8552 :     }
; 8553 : }

	pop	ebp
	ret	0
?SimMainPowerDec@@YAXKHPAX@Z ENDP			; SimMainPowerDec
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimToggleTFR@@YAXKHPAX@Z PROC				; SimToggleTFR

; 7654 : {

	push	ebp
	mov	ebp, esp

; 7655 :     if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)) {

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN6@SimToggleT
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN6@SimToggleT
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN6@SimToggleT

; 7656 : 		if (SimDriver.GetPlayerAircraft()->AutopilotType() == AircraftClass::APOff) {

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?AutopilotType@AircraftClass@@QAE?AW4AutoPilotType@1@XZ ; AircraftClass::AutopilotType
	cmp	eax, 4
	jne	SHORT $LN4@SimToggleT

; 7657 : 			if (theLantirn->GetTFRMode() == LantirnClass::TFR_STBY)

	mov	ecx, DWORD PTR ?theLantirn@@3PAVLantirnClass@@A ; theLantirn
	call	?GetTFRMode@LantirnClass@@QAE?AW4TfrMode@1@XZ ; LantirnClass::GetTFRMode
	cmp	eax, 3
	jne	SHORT $LN3@SimToggleT

; 7658 : 			theLantirn->SetTFRMode(LantirnClass::TFR_NORM);

	push	4
	mov	ecx, DWORD PTR ?theLantirn@@3PAVLantirnClass@@A ; theLantirn
	call	?SetTFRMode@LantirnClass@@QAEXW4TfrMode@1@@Z ; LantirnClass::SetTFRMode
$LN3@SimToggleT:

; 7659 : 			SimDriver.GetPlayerAircraft()->SetAutopilot(AircraftClass::LantirnAP);

	push	3
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetAutopilot@AircraftClass@@QAEXW4AutoPilotType@1@@Z ; AircraftClass::SetAutopilot

; 7660 : 			//MI turn off any other AP modes
; 7661 : 			SimDriver.GetPlayerAircraft()->ClearAPFlag(AircraftClass::AltHold);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?ClearAPFlag@AircraftClass@@QAEXW4APFlags@1@@Z ; AircraftClass::ClearAPFlag

; 7662 : 			SimDriver.GetPlayerAircraft()->ClearAPFlag(AircraftClass::AttHold);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?ClearAPFlag@AircraftClass@@QAEXW4APFlags@1@@Z ; AircraftClass::ClearAPFlag

; 7663 : 			//MI update our lastAP state, for operating the RF Switch
; 7664 : 			SimDriver.GetPlayerAircraft()->lastapType = AircraftClass::LantirnAP;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR [eax+972], 3

; 7665 : 		}
; 7666 : 		else 

	jmp	SHORT $LN6@SimToggleT
$LN4@SimToggleT:

; 7667 : 		{
; 7668 : 			// MD -- 2003127: adding a check to put the TFR state back into standby
; 7669 : 			if (theLantirn->GetTFRMode() != LantirnClass::TFR_STBY)

	mov	ecx, DWORD PTR ?theLantirn@@3PAVLantirnClass@@A ; theLantirn
	call	?GetTFRMode@LantirnClass@@QAE?AW4TfrMode@1@XZ ; LantirnClass::GetTFRMode
	cmp	eax, 3
	je	SHORT $LN1@SimToggleT

; 7670 : 				theLantirn->SetTFRMode(LantirnClass::TFR_STBY);

	push	3
	mov	ecx, DWORD PTR ?theLantirn@@3PAVLantirnClass@@A ; theLantirn
	call	?SetTFRMode@LantirnClass@@QAEXW4TfrMode@1@@Z ; LantirnClass::SetTFRMode
$LN1@SimToggleT:

; 7671 : 			SimDriver.GetPlayerAircraft()->SetAutopilot(AircraftClass::APOff);

	push	4
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetAutopilot@AircraftClass@@QAEXW4AutoPilotType@1@@Z ; AircraftClass::SetAutopilot

; 7672 : 			SimDriver.GetPlayerAircraft()->lastapType = AircraftClass::APOff;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR [eax+972], 4
$LN6@SimToggleT:

; 7673 : 		}
; 7674 :     }
; 7675 : }

	pop	ebp
	ret	0
?SimToggleTFR@@YAXKHPAX@Z ENDP				; SimToggleTFR
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv83 = -4						; size = 4
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimSpotLight@@YAXKHPAX@Z PROC				; SimSpotLight

; 7825 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 7826 :   if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)) 

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN8@SimSpotLig
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN8@SimSpotLig
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN8@SimSpotLig

; 7827 : 	{
; 7828 : 		switch (SimDriver.GetPlayerAircraft()->GetSpotLight()) 

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?GetSpotLight@AircraftClass@@QBE?AW4LightSwitch@1@XZ ; AircraftClass::GetSpotLight
	mov	DWORD PTR tv83[ebp], eax
	cmp	DWORD PTR tv83[ebp], 1
	je	SHORT $LN3@SimSpotLig
	cmp	DWORD PTR tv83[ebp], 2
	je	SHORT $LN2@SimSpotLig

; 7829 : 		{
; 7830 : 			default:
; 7831 : 			case AircraftClass::LT_OFF:
; 7832 : 				SimDriver.GetPlayerAircraft()->SetSpotLight(AircraftClass::LT_LOW);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetSpotLight@AircraftClass@@QAEXW4LightSwitch@1@@Z ; AircraftClass::SetSpotLight

; 7833 : 				SimDriver.GetPlayerAircraft()->PowerOn(AircraftClass::SpotLightPower);

	push	536870912				; 20000000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerOn@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerOn

; 7834 : 				break;

	jmp	SHORT $LN5@SimSpotLig
$LN3@SimSpotLig:

; 7835 : 			case AircraftClass::LT_LOW:
; 7836 : 				SimDriver.GetPlayerAircraft()->SetSpotLight(AircraftClass::LT_NORMAL);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetSpotLight@AircraftClass@@QAEXW4LightSwitch@1@@Z ; AircraftClass::SetSpotLight

; 7837 : 				SimDriver.GetPlayerAircraft()->PowerOn(AircraftClass::SpotLightPower);

	push	536870912				; 20000000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerOn@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerOn

; 7838 : 				break;

	jmp	SHORT $LN5@SimSpotLig
$LN2@SimSpotLig:

; 7839 : 			case AircraftClass::LT_NORMAL:
; 7840 : 				SimDriver.GetPlayerAircraft()->SetSpotLight(AircraftClass::LT_OFF);

	push	0
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetSpotLight@AircraftClass@@QAEXW4LightSwitch@1@@Z ; AircraftClass::SetSpotLight

; 7841 : 				SimDriver.GetPlayerAircraft()->PowerOff(AircraftClass::SpotLightPower);

	push	536870912				; 20000000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?PowerOff@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerOff
$LN5@SimSpotLig:

; 7842 : 				break;
; 7843 : 		}
; 7844 : 
; 7845 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN8@SimSpotLig

; 7846 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_SPOT_LITE, 1<<SimDriver.GetPlayerAircraft()->GetSpotLight());

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?GetSpotLight@AircraftClass@@QBE?AW4LightSwitch@1@XZ ; AircraftClass::GetSpotLight
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	push	edx
	push	217					; 000000d9H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN8@SimSpotLig:

; 7847 :   }
; 7848 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimSpotLight@@YAXKHPAX@Z ENDP				; SimSpotLight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv83 = -4						; size = 4
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimInstrumentLight@@YAXKHPAX@Z PROC			; SimInstrumentLight

; 7793 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 7794 : 	//sfr: same here
; 7795 :   if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)) 

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN9@SimInstrum
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN9@SimInstrum
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN9@SimInstrum

; 7796 : 	{
; 7797 : 		switch (SimDriver.GetPlayerAircraft()->GetInstrumentLight()) 

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?GetInstrumentLight@AircraftClass@@QBE?AW4LightSwitch@1@XZ ; AircraftClass::GetInstrumentLight
	mov	DWORD PTR tv83[ebp], eax
	cmp	DWORD PTR tv83[ebp], 1
	je	SHORT $LN4@SimInstrum
	cmp	DWORD PTR tv83[ebp], 2
	je	SHORT $LN3@SimInstrum

; 7798 : 		{
; 7799 : 			default:
; 7800 : 			case AircraftClass::LT_OFF:
; 7801 : 				SimDriver.GetPlayerAircraft()->SetInstrumentLight(AircraftClass::LT_LOW);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetInstrumentLight@AircraftClass@@QAEXW4LightSwitch@1@@Z ; AircraftClass::SetInstrumentLight

; 7802 : 				break;

	jmp	SHORT $LN6@SimInstrum
$LN4@SimInstrum:

; 7803 : 			case AircraftClass::LT_LOW:
; 7804 : 				SimDriver.GetPlayerAircraft()->SetInstrumentLight(AircraftClass::LT_NORMAL);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetInstrumentLight@AircraftClass@@QAEXW4LightSwitch@1@@Z ; AircraftClass::SetInstrumentLight

; 7805 : 				break;

	jmp	SHORT $LN6@SimInstrum
$LN3@SimInstrum:

; 7806 : 			case AircraftClass::LT_NORMAL:
; 7807 : 				SimDriver.GetPlayerAircraft()->SetInstrumentLight(AircraftClass::LT_OFF);

	push	0
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetInstrumentLight@AircraftClass@@QAEXW4LightSwitch@1@@Z ; AircraftClass::SetInstrumentLight
$LN6@SimInstrum:

; 7808 : 				break;
; 7809 : 		}
; 7810 : 
; 7811 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN2@SimInstrum

; 7812 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_INSTR_LITE, 1<<SimDriver.GetPlayerAircraft()->GetInstrumentLight());

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?GetInstrumentLight@AircraftClass@@QBE?AW4LightSwitch@1@XZ ; AircraftClass::GetInstrumentLight
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	push	edx
	push	206					; 000000ceH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN2@SimInstrum:

; 7813 : 
; 7814 : 		TheColorBank.PitLightLevel = (int)SimDriver.GetPlayerAircraft()->GetInstrumentLight();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?GetInstrumentLight@AircraftClass@@QBE?AW4LightSwitch@1@XZ ; AircraftClass::GetInstrumentLight
	mov	DWORD PTR ?PitLightLevel@ColorBankClass@@2HA, eax ; ColorBankClass::PitLightLevel

; 7815 : 		//sfr: this is messing light system, interior has its own switch
; 7816 : 		//SimDriver.GetPlayerAircraft()->SetInteriorLight(AircraftClass::LT_OFF);
; 7817 : 
; 7818 : 		if (OTWDriver.pCockpitManager != NULL)

	cmp	DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684, 0
	je	SHORT $LN9@SimInstrum

; 7819 : 		{
; 7820 : 			OTWDriver.pCockpitManager->UpdatePalette();

	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	call	?UpdatePalette@CockpitManager@@QAEXXZ	; CockpitManager::UpdatePalette
$LN9@SimInstrum:

; 7821 : 		}
; 7822 :   }
; 7823 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimInstrumentLight@@YAXKHPAX@Z ENDP			; SimInstrumentLight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv79 = -8						; size = 4
_ac$ = -4						; size = 4
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimInteriorLight@@YAXKHPAX@Z PROC			; SimInteriorLight

; 7760 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 7761 : 	//sfr: i removed the power on calls, so we override old lighting system
; 7762 : 	AircraftClass *ac = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _ac$[ebp], eax

; 7763 : 	if (!ac) { return; }

	cmp	DWORD PTR _ac$[ebp], 0
	jne	SHORT $LN9@SimInterio
	jmp	$LN10@SimInterio
$LN9@SimInterio:

; 7764 : 
; 7765 :   if (ac->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)) 

	push	65536					; 00010000H
	mov	ecx, DWORD PTR _ac$[ebp]
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN10@SimInterio
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN10@SimInterio

; 7766 : 	{
; 7767 : 		switch (ac->GetInteriorLight()) 

	mov	ecx, DWORD PTR _ac$[ebp]
	call	?GetInteriorLight@AircraftClass@@QBE?AW4LightSwitch@1@XZ ; AircraftClass::GetInteriorLight
	mov	DWORD PTR tv79[ebp], eax
	cmp	DWORD PTR tv79[ebp], 1
	je	SHORT $LN4@SimInterio
	cmp	DWORD PTR tv79[ebp], 2
	je	SHORT $LN3@SimInterio

; 7768 : 		{
; 7769 : 			default:
; 7770 : 			case AircraftClass::LT_OFF:
; 7771 : 				ac->SetInteriorLight(AircraftClass::LT_LOW);

	push	1
	mov	ecx, DWORD PTR _ac$[ebp]
	call	?SetInteriorLight@AircraftClass@@QAEXW4LightSwitch@1@@Z ; AircraftClass::SetInteriorLight

; 7772 : 				break;

	jmp	SHORT $LN6@SimInterio
$LN4@SimInterio:

; 7773 : 			case AircraftClass::LT_LOW:
; 7774 : 				ac->SetInteriorLight(AircraftClass::LT_NORMAL);

	push	2
	mov	ecx, DWORD PTR _ac$[ebp]
	call	?SetInteriorLight@AircraftClass@@QAEXW4LightSwitch@1@@Z ; AircraftClass::SetInteriorLight

; 7775 : 				break;

	jmp	SHORT $LN6@SimInterio
$LN3@SimInterio:

; 7776 : 			case AircraftClass::LT_NORMAL:
; 7777 : 				ac->SetInteriorLight(AircraftClass::LT_OFF);

	push	0
	mov	ecx, DWORD PTR _ac$[ebp]
	call	?SetInteriorLight@AircraftClass@@QAEXW4LightSwitch@1@@Z ; AircraftClass::SetInteriorLight
$LN6@SimInterio:

; 7778 : 				break;
; 7779 : 		}
; 7780 : 
; 7781 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN2@SimInterio

; 7782 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_INTERIOR_LITE, 1<<SimDriver.GetPlayerAircraft()->GetInteriorLight());

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?GetInteriorLight@AircraftClass@@QBE?AW4LightSwitch@1@XZ ; AircraftClass::GetInteriorLight
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	push	edx
	push	205					; 000000cdH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN2@SimInterio:

; 7783 : 
; 7784 : 		TheColorBank.PitLightLevel = (int)ac->GetInteriorLight();

	mov	ecx, DWORD PTR _ac$[ebp]
	call	?GetInteriorLight@AircraftClass@@QBE?AW4LightSwitch@1@XZ ; AircraftClass::GetInteriorLight
	mov	DWORD PTR ?PitLightLevel@ColorBankClass@@2HA, eax ; ColorBankClass::PitLightLevel

; 7785 : 		if (OTWDriver.pCockpitManager != NULL)

	cmp	DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684, 0
	je	SHORT $LN10@SimInterio

; 7786 : 		{
; 7787 : 			OTWDriver.pCockpitManager->UpdatePalette();

	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	call	?UpdatePalette@CockpitManager@@QAEXXZ	; CockpitManager::UpdatePalette
$LN10@SimInterio:

; 7788 : 		}
; 7789 :   }
; 7790 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimInteriorLight@@YAXKHPAX@Z ENDP			; SimInteriorLight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$1 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimDecRightAuxComDigit@@YAXKHPAX@Z PROC		; SimDecRightAuxComDigit

; 5662 : void SimDecRightAuxComDigit(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp
	push	ecx

; 5663 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)) 

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN1@SimDecRigh
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN1@SimDecRigh
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN1@SimDecRigh

; 5664 : 	{
; 5665 : 		gNavigationSys->StepTacanChannelDigit(NavigationSystem::AUXCOMM, 0, -1);

	push	-1
	push	0
	push	1
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?StepTacanChannelDigit@NavigationSystem@@QAEXW4Tacan_Channel_Src@1@HH@Z ; NavigationSystem::StepTacanChannelDigit

; 5666 : 		int val = gNavigationSys->GetTacanChannel(NavigationSystem::AUXCOMM, 0);

	push	0
	push	1
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetTacanChannel@NavigationSystem@@QAEHW4Tacan_Channel_Src@1@H@Z ; NavigationSystem::GetTacanChannel
	mov	DWORD PTR _val$1[ebp], eax

; 5667 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN1@SimDecRigh

; 5668 : 			OTWDriver.GetVirtualCockpit()->SetDOFangle( COMP_3DPIT_TACAN_RIGHT, val * 0.6283F);

	cvtsi2ss xmm0, DWORD PTR _val$1[ebp]
	mulss	xmm0, DWORD PTR __real@3f20d845
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	147					; 00000093H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle
$LN1@SimDecRigh:

; 5669 : 	}
; 5670 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimDecRightAuxComDigit@@YAXKHPAX@Z ENDP		; SimDecRightAuxComDigit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$1 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimDecCenterAuxComDigit@@YAXKHPAX@Z PROC		; SimDecCenterAuxComDigit

; 5643 : void SimDecCenterAuxComDigit(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp
	push	ecx

; 5644 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)) 

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN1@SimDecCent
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN1@SimDecCent
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN1@SimDecCent

; 5645 : 	{
; 5646 : 		gNavigationSys->StepTacanChannelDigit(NavigationSystem::AUXCOMM, 1, -1);

	push	-1
	push	1
	push	1
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?StepTacanChannelDigit@NavigationSystem@@QAEXW4Tacan_Channel_Src@1@HH@Z ; NavigationSystem::StepTacanChannelDigit

; 5647 : 		int val = gNavigationSys->GetTacanChannel(NavigationSystem::AUXCOMM, 1);

	push	1
	push	1
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetTacanChannel@NavigationSystem@@QAEHW4Tacan_Channel_Src@1@H@Z ; NavigationSystem::GetTacanChannel
	mov	DWORD PTR _val$1[ebp], eax

; 5648 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN1@SimDecCent

; 5649 : 			OTWDriver.GetVirtualCockpit()->SetDOFangle( COMP_3DPIT_TACAN_CENTER, val * 0.6283F);

	cvtsi2ss xmm0, DWORD PTR _val$1[ebp]
	mulss	xmm0, DWORD PTR __real@3f20d845
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	146					; 00000092H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle
$LN1@SimDecCent:

; 5650 : 	}
; 5651 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimDecCenterAuxComDigit@@YAXKHPAX@Z ENDP		; SimDecCenterAuxComDigit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$1 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimDecLeftAuxComDigit@@YAXKHPAX@Z PROC			; SimDecLeftAuxComDigit

; 5622 : void SimDecLeftAuxComDigit(unsigned long, int state, void*) {

	push	ebp
	mov	ebp, esp
	push	ecx

; 5623 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)) 

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN1@SimDecLeft
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN1@SimDecLeft
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN1@SimDecLeft

; 5624 : 	{
; 5625 : 		gNavigationSys->StepTacanChannelDigit(NavigationSystem::AUXCOMM, 2, -1);

	push	-1
	push	2
	push	1
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?StepTacanChannelDigit@NavigationSystem@@QAEXW4Tacan_Channel_Src@1@HH@Z ; NavigationSystem::StepTacanChannelDigit

; 5626 : 		int val = gNavigationSys->GetTacanChannel(NavigationSystem::AUXCOMM, 2);

	push	2
	push	1
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetTacanChannel@NavigationSystem@@QAEHW4Tacan_Channel_Src@1@H@Z ; NavigationSystem::GetTacanChannel
	mov	DWORD PTR _val$1[ebp], eax

; 5627 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN1@SimDecLeft

; 5628 : 			OTWDriver.GetVirtualCockpit()->SetDOFangle( COMP_3DPIT_TACAN_LEFT, val * 0.6283F);

	cvtsi2ss xmm0, DWORD PTR _val$1[ebp]
	mulss	xmm0, DWORD PTR __real@3f20d845
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	145					; 00000091H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle
$LN1@SimDecLeft:

; 5629 : 	}
; 5630 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimDecLeftAuxComDigit@@YAXKHPAX@Z ENDP			; SimDecLeftAuxComDigit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimAirSourceRam@@YAXKHPAX@Z PROC			; SimAirSourceRam

; 7122 : {

	push	ebp
	mov	ebp, esp

; 7123 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimAirSour

; 7124 : 		return;

	jmp	$LN4@SimAirSour
$LN3@SimAirSour:

; 7125 :   if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimAirSour
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimAirSour
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimAirSour

; 7126 : 	{
; 7127 : 		SimDriver.GetPlayerAircraft()->af->SetAirSource(AirframeClass::AS_RAM);

	push	3
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?SetAirSource@AirframeClass@@QAEXW4AirSource@1@@Z ; AirframeClass::SetAirSource

; 7128 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimAirSour

; 7129 : 			//OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_AIR_SOURCE, SimDriver.GetPlayerAircraft()->af->GetAirSource()+1);
; 7130 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_AIR_SOURCE, 1<<SimDriver.GetPlayerAircraft()->af->GetAirSource());

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?GetAirSource@AirframeClass@@QAE?AW4AirSource@1@XZ ; AirframeClass::GetAirSource
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	push	edx
	push	207					; 000000cfH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimAirSour:

; 7131 : 	}
; 7132 : }

	pop	ebp
	ret	0
?SimAirSourceRam@@YAXKHPAX@Z ENDP			; SimAirSourceRam
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimAirSourceDump@@YAXKHPAX@Z PROC			; SimAirSourceDump

; 7110 : {

	push	ebp
	mov	ebp, esp

; 7111 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimAirSour

; 7112 : 		return;

	jmp	$LN4@SimAirSour
$LN3@SimAirSour:

; 7113 :   if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimAirSour
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimAirSour
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimAirSour

; 7114 : 	{
; 7115 : 		SimDriver.GetPlayerAircraft()->af->SetAirSource(AirframeClass::AS_DUMP);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?SetAirSource@AirframeClass@@QAEXW4AirSource@1@@Z ; AirframeClass::SetAirSource

; 7116 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimAirSour

; 7117 : 			//OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_AIR_SOURCE, SimDriver.GetPlayerAircraft()->af->GetAirSource()+1);
; 7118 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_AIR_SOURCE, 1<<SimDriver.GetPlayerAircraft()->af->GetAirSource());

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?GetAirSource@AirframeClass@@QAE?AW4AirSource@1@XZ ; AirframeClass::GetAirSource
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	push	edx
	push	207					; 000000cfH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimAirSour:

; 7119 : 	}
; 7120 : }

	pop	ebp
	ret	0
?SimAirSourceDump@@YAXKHPAX@Z ENDP			; SimAirSourceDump
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimAirSourceNorm@@YAXKHPAX@Z PROC			; SimAirSourceNorm

; 7098 : {

	push	ebp
	mov	ebp, esp

; 7099 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimAirSour

; 7100 : 		return;

	jmp	$LN4@SimAirSour
$LN3@SimAirSour:

; 7101 :   if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimAirSour
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimAirSour
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimAirSour

; 7102 : 	{
; 7103 : 		SimDriver.GetPlayerAircraft()->af->SetAirSource(AirframeClass::AS_NORM);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?SetAirSource@AirframeClass@@QAEXW4AirSource@1@@Z ; AirframeClass::SetAirSource

; 7104 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimAirSour

; 7105 : 			//OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_AIR_SOURCE, SimDriver.GetPlayerAircraft()->af->GetAirSource()+1);
; 7106 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_AIR_SOURCE, 1<<SimDriver.GetPlayerAircraft()->af->GetAirSource());

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?GetAirSource@AirframeClass@@QAE?AW4AirSource@1@XZ ; AirframeClass::GetAirSource
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	push	edx
	push	207					; 000000cfH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimAirSour:

; 7107 : 	}
; 7108 : }

	pop	ebp
	ret	0
?SimAirSourceNorm@@YAXKHPAX@Z ENDP			; SimAirSourceNorm
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimAirSourceOff@@YAXKHPAX@Z PROC			; SimAirSourceOff

; 7085 : {

	push	ebp
	mov	ebp, esp

; 7086 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimAirSour

; 7087 : 		return;

	jmp	$LN4@SimAirSour
$LN3@SimAirSour:

; 7088 :   if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimAirSour
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimAirSour
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimAirSour

; 7089 : 	{
; 7090 : 		SimDriver.GetPlayerAircraft()->af->SetAirSource(AirframeClass::AS_OFF);

	push	0
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?SetAirSource@AirframeClass@@QAEXW4AirSource@1@@Z ; AirframeClass::SetAirSource

; 7091 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimAirSour

; 7092 : 			//OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_AIR_SOURCE, SimDriver.GetPlayerAircraft()->af->GetAirSource()+1);
; 7093 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_AIR_SOURCE, 1<<SimDriver.GetPlayerAircraft()->af->GetAirSource());

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?GetAirSource@AirframeClass@@QAE?AW4AirSource@1@XZ ; AirframeClass::GetAirSource
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	push	edx
	push	207					; 000000cfH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimAirSour:

; 7094 : 	}
; 7095 : }

	pop	ebp
	ret	0
?SimAirSourceOff@@YAXKHPAX@Z ENDP			; SimAirSourceOff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimDecAirSource@@YAXKHPAX@Z PROC			; SimDecAirSource

; 7071 : {

	push	ebp
	mov	ebp, esp

; 7072 :   if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimDecAirS
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimDecAirS
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimDecAirS

; 7073 : 	{
; 7074 : 		SimDriver.GetPlayerAircraft()->af->DecAirSource();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?DecAirSource@AirframeClass@@QAEXXZ	; AirframeClass::DecAirSource

; 7075 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN3@SimDecAirS

; 7076 : 			//OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_AIR_SOURCE, SimDriver.GetPlayerAircraft()->af->GetAirSource()+1);
; 7077 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_AIR_SOURCE, 1<<SimDriver.GetPlayerAircraft()->af->GetAirSource());

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?GetAirSource@AirframeClass@@QAE?AW4AirSource@1@XZ ; AirframeClass::GetAirSource
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	push	edx
	push	207					; 000000cfH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN3@SimDecAirS:

; 7078 : 	}
; 7079 : }

	pop	ebp
	ret	0
?SimDecAirSource@@YAXKHPAX@Z ENDP			; SimDecAirSource
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimIncAirSource@@YAXKHPAX@Z PROC			; SimIncAirSource

; 7060 : {

	push	ebp
	mov	ebp, esp

; 7061 :   if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimIncAirS
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimIncAirS
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimIncAirS

; 7062 : 	{
; 7063 : 		SimDriver.GetPlayerAircraft()->af->IncAirSource();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?IncAirSource@AirframeClass@@QAEXXZ	; AirframeClass::IncAirSource

; 7064 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN3@SimIncAirS

; 7065 : 			//OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_AIR_SOURCE, SimDriver.GetPlayerAircraft()->af->GetAirSource()+1);
; 7066 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_AIR_SOURCE, 1<<SimDriver.GetPlayerAircraft()->af->GetAirSource());

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?GetAirSource@AirframeClass@@QAE?AW4AirSource@1@XZ ; AirframeClass::GetAirSource
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	push	edx
	push	207					; 000000cfH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN3@SimIncAirS:

; 7067 : 	}
; 7068 : }

	pop	ebp
	ret	0
?SimIncAirSource@@YAXKHPAX@Z ENDP			; SimIncAirSource
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimMasterFuelOff@@YAXKHPAX@Z PROC			; SimMasterFuelOff

; 7048 : {

	push	ebp
	mov	ebp, esp

; 7049 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimMasterF

; 7050 : 		return;

	jmp	SHORT $LN4@SimMasterF
$LN3@SimMasterF:

; 7051 :   if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimMasterF
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimMasterF
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimMasterF

; 7052 : 	{
; 7053 : 		SimDriver.GetPlayerAircraft()->af->SetEngineFlag(AirframeClass::MasterFuelOff);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?SetEngineFlag@AirframeClass@@QAEXW4EngineFlags@1@@Z ; AirframeClass::SetEngineFlag

; 7054 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimMasterF

; 7055 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_REFUEL_MSTR, 1);

	push	1
	push	185					; 000000b9H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimMasterF:

; 7056 : 	}
; 7057 : }

	pop	ebp
	ret	0
?SimMasterFuelOff@@YAXKHPAX@Z ENDP			; SimMasterFuelOff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimMasterFuelOn@@YAXKHPAX@Z PROC			; SimMasterFuelOn

; 7036 : {

	push	ebp
	mov	ebp, esp

; 7037 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimMasterF

; 7038 : 		return;

	jmp	SHORT $LN4@SimMasterF
$LN3@SimMasterF:

; 7039 :   if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimMasterF
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimMasterF
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimMasterF

; 7040 : 	{
; 7041 : 		SimDriver.GetPlayerAircraft()->af->ClearEngineFlag(AirframeClass::MasterFuelOff);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?ClearEngineFlag@AirframeClass@@QAEXW4EngineFlags@1@@Z ; AirframeClass::ClearEngineFlag

; 7042 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimMasterF

; 7043 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_REFUEL_MSTR, 2);

	push	2
	push	185					; 000000b9H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimMasterF:

; 7044 : 	}
; 7045 : }

	pop	ebp
	ret	0
?SimMasterFuelOn@@YAXKHPAX@Z ENDP			; SimMasterFuelOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimToggleMasterFuel@@YAXKHPAX@Z PROC			; SimToggleMasterFuel

; 7021 : {

	push	ebp
	mov	ebp, esp

; 7022 :   if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN5@SimToggleM
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN5@SimToggleM
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN5@SimToggleM

; 7023 : 	{
; 7024 : 		SimDriver.GetPlayerAircraft()->af->ToggleEngineFlag(AirframeClass::MasterFuelOff);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?ToggleEngineFlag@AirframeClass@@QAEXW4EngineFlags@1@@Z ; AirframeClass::ToggleEngineFlag

; 7025 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN5@SimToggleM

; 7026 : 			if (SimDriver.GetPlayerAircraft()->af->IsEngineFlag(AirframeClass::MasterFuelOff))

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?IsEngineFlag@AirframeClass@@QAEHW4EngineFlags@1@@Z ; AirframeClass::IsEngineFlag
	test	eax, eax
	je	SHORT $LN2@SimToggleM

; 7027 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_REFUEL_MSTR, 1);

	push	1
	push	185					; 000000b9H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 7028 : 			else

	jmp	SHORT $LN5@SimToggleM
$LN2@SimToggleM:

; 7029 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_REFUEL_MSTR, 2);

	push	2
	push	185					; 000000b9H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN5@SimToggleM:

; 7030 : 	}
; 7031 : }

	pop	ebp
	ret	0
?SimToggleMasterFuel@@YAXKHPAX@Z ENDP			; SimToggleMasterFuel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimFuelPumpFwd@@YAXKHPAX@Z PROC			; SimFuelPumpFwd

; 7009 : {

	push	ebp
	mov	ebp, esp

; 7010 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimFuelPum

; 7011 : 		return;

	jmp	SHORT $LN4@SimFuelPum
$LN3@SimFuelPum:

; 7012 :     if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimFuelPum
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimFuelPum
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimFuelPum

; 7013 : 		{
; 7014 : 			SimDriver.GetPlayerAircraft()->af->SetFuelPump(AirframeClass::FP_FWD);

	push	3
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?SetFuelPump@AirframeClass@@QAEXW4FuelPump@1@@Z ; AirframeClass::SetFuelPump

; 7015 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimFuelPum

; 7016 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_REFUEL_PUMP, 8);

	push	8
	push	184					; 000000b8H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimFuelPum:

; 7017 : 		}
; 7018 : }

	pop	ebp
	ret	0
?SimFuelPumpFwd@@YAXKHPAX@Z ENDP			; SimFuelPumpFwd
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimFuelPumpAft@@YAXKHPAX@Z PROC			; SimFuelPumpAft

; 6997 : {

	push	ebp
	mov	ebp, esp

; 6998 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimFuelPum

; 6999 : 		return;

	jmp	SHORT $LN4@SimFuelPum
$LN3@SimFuelPum:

; 7000 :     if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimFuelPum
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimFuelPum
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimFuelPum

; 7001 : 		{
; 7002 : 			SimDriver.GetPlayerAircraft()->af->SetFuelPump(AirframeClass::FP_AFT);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?SetFuelPump@AirframeClass@@QAEXW4FuelPump@1@@Z ; AirframeClass::SetFuelPump

; 7003 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimFuelPum

; 7004 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_REFUEL_PUMP, 4);

	push	4
	push	184					; 000000b8H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimFuelPum:

; 7005 : 		}
; 7006 : }

	pop	ebp
	ret	0
?SimFuelPumpAft@@YAXKHPAX@Z ENDP			; SimFuelPumpAft
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimFuelPumpNorm@@YAXKHPAX@Z PROC			; SimFuelPumpNorm

; 6985 : {

	push	ebp
	mov	ebp, esp

; 6986 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimFuelPum

; 6987 : 		return;

	jmp	SHORT $LN4@SimFuelPum
$LN3@SimFuelPum:

; 6988 :     if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimFuelPum
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimFuelPum
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimFuelPum

; 6989 : 		{
; 6990 : 			SimDriver.GetPlayerAircraft()->af->SetFuelPump(AirframeClass::FP_NORM);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?SetFuelPump@AirframeClass@@QAEXW4FuelPump@1@@Z ; AirframeClass::SetFuelPump

; 6991 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimFuelPum

; 6992 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_REFUEL_PUMP, 2);

	push	2
	push	184					; 000000b8H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimFuelPum:

; 6993 : 		}
; 6994 : }

	pop	ebp
	ret	0
?SimFuelPumpNorm@@YAXKHPAX@Z ENDP			; SimFuelPumpNorm
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimFuelPumpOff@@YAXKHPAX@Z PROC			; SimFuelPumpOff

; 6973 : {

	push	ebp
	mov	ebp, esp

; 6974 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimFuelPum

; 6975 : 		return;

	jmp	SHORT $LN4@SimFuelPum
$LN3@SimFuelPum:

; 6976 :     if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimFuelPum
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimFuelPum
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimFuelPum

; 6977 : 		{
; 6978 : 			SimDriver.GetPlayerAircraft()->af->SetFuelPump(AirframeClass::FP_OFF);

	push	0
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?SetFuelPump@AirframeClass@@QAEXW4FuelPump@1@@Z ; AirframeClass::SetFuelPump

; 6979 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimFuelPum

; 6980 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_REFUEL_PUMP, 1);

	push	1
	push	184					; 000000b8H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimFuelPum:

; 6981 : 		}
; 6982 : }

	pop	ebp
	ret	0
?SimFuelPumpOff@@YAXKHPAX@Z ENDP			; SimFuelPumpOff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$1 = -4						; size = 4
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimDecFuelPump@@YAXKHPAX@Z PROC			; SimDecFuelPump

; 6958 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 6959 :     if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN3@SimDecFuel
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimDecFuel
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimDecFuel

; 6960 : 		{
; 6961 : 			SimDriver.GetPlayerAircraft()->af->DecFuelPump();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?DecFuelPump@AirframeClass@@QAEXXZ	; AirframeClass::DecFuelPump

; 6962 : 			//int val = SimDriver.GetPlayerAircraft()->af->GetFuelPump()+1;
; 6963 : 			int val = 1<<SimDriver.GetPlayerAircraft()->af->GetFuelPump();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?GetFuelPump@AirframeClass@@QAE?AW4FuelPump@1@XZ ; AirframeClass::GetFuelPump
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	mov	DWORD PTR _val$1[ebp], edx

; 6964 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN3@SimDecFuel

; 6965 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_REFUEL_PUMP, val);

	mov	eax, DWORD PTR _val$1[ebp]
	push	eax
	push	184					; 000000b8H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN3@SimDecFuel:

; 6966 : 		}
; 6967 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimDecFuelPump@@YAXKHPAX@Z ENDP			; SimDecFuelPump
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$1 = -4						; size = 4
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimIncFuelPump@@YAXKHPAX@Z PROC			; SimIncFuelPump

; 6945 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 6946 :     if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN3@SimIncFuel
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimIncFuel
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimIncFuel

; 6947 : 		{
; 6948 : 			SimDriver.GetPlayerAircraft()->af->IncFuelPump();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?IncFuelPump@AirframeClass@@QAEXXZ	; AirframeClass::IncFuelPump

; 6949 : 			SimDriver.GetPlayerAircraft()->af->SetFuelPump(AirframeClass::FP_OFF);

	push	0
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?SetFuelPump@AirframeClass@@QAEXW4FuelPump@1@@Z ; AirframeClass::SetFuelPump

; 6950 : 			//int val = SimDriver.GetPlayerAircraft()->af->GetFuelPump()+1;
; 6951 : 			int val = 1<<SimDriver.GetPlayerAircraft()->af->GetFuelPump();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?GetFuelPump@AirframeClass@@QAE?AW4FuelPump@1@XZ ; AirframeClass::GetFuelPump
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	mov	DWORD PTR _val$1[ebp], edx

; 6952 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN3@SimIncFuel

; 6953 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_REFUEL_PUMP, val);

	mov	eax, DWORD PTR _val$1[ebp]
	push	eax
	push	184					; 000000b8H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN3@SimIncFuel:

; 6954 : 		}
; 6955 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimIncFuelPump@@YAXKHPAX@Z ENDP			; SimIncFuelPump
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimFuelSwitchCenterExt@@YAXKHPAX@Z PROC		; SimFuelSwitchCenterExt

; 6933 : {

	push	ebp
	mov	ebp, esp

; 6934 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimFuelSwi

; 6935 : 		return;

	jmp	SHORT $LN4@SimFuelSwi
$LN3@SimFuelSwi:

; 6936 :     if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimFuelSwi
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimFuelSwi
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimFuelSwi

; 6937 : 		{
; 6938 : 			SimDriver.GetPlayerAircraft()->af->SetFuelSwitch(AirframeClass::FS_CENTEREXT);

	push	4
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?SetFuelSwitch@AirframeClass@@QAEXW4FuelSwitch@1@@Z ; AirframeClass::SetFuelSwitch

; 6939 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimFuelSwi

; 6940 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_FUEL_QTY, 16);

	push	16					; 00000010H
	push	159					; 0000009fH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimFuelSwi:

; 6941 : 		}
; 6942 : }

	pop	ebp
	ret	0
?SimFuelSwitchCenterExt@@YAXKHPAX@Z ENDP		; SimFuelSwitchCenterExt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimFuelSwitchWingExt@@YAXKHPAX@Z PROC			; SimFuelSwitchWingExt

; 6922 : {

	push	ebp
	mov	ebp, esp

; 6923 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimFuelSwi

; 6924 : 		return;

	jmp	SHORT $LN4@SimFuelSwi
$LN3@SimFuelSwi:

; 6925 :     if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimFuelSwi
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimFuelSwi
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimFuelSwi

; 6926 : 		{
; 6927 : 			SimDriver.GetPlayerAircraft()->af->SetFuelSwitch(AirframeClass::FS_WINGEXT);

	push	3
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?SetFuelSwitch@AirframeClass@@QAEXW4FuelSwitch@1@@Z ; AirframeClass::SetFuelSwitch

; 6928 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimFuelSwi

; 6929 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_FUEL_QTY, 8);

	push	8
	push	159					; 0000009fH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimFuelSwi:

; 6930 : 		}
; 6931 : }

	pop	ebp
	ret	0
?SimFuelSwitchWingExt@@YAXKHPAX@Z ENDP			; SimFuelSwitchWingExt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimFuelSwitchWingInt@@YAXKHPAX@Z PROC			; SimFuelSwitchWingInt

; 6911 : {

	push	ebp
	mov	ebp, esp

; 6912 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimFuelSwi

; 6913 : 		return;

	jmp	SHORT $LN4@SimFuelSwi
$LN3@SimFuelSwi:

; 6914 :     if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimFuelSwi
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimFuelSwi
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimFuelSwi

; 6915 : 		{
; 6916 : 			SimDriver.GetPlayerAircraft()->af->SetFuelSwitch(AirframeClass::FS_WINGINT);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?SetFuelSwitch@AirframeClass@@QAEXW4FuelSwitch@1@@Z ; AirframeClass::SetFuelSwitch

; 6917 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimFuelSwi

; 6918 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_FUEL_QTY, 4);

	push	4
	push	159					; 0000009fH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimFuelSwi:

; 6919 : 		}
; 6920 : }

	pop	ebp
	ret	0
?SimFuelSwitchWingInt@@YAXKHPAX@Z ENDP			; SimFuelSwitchWingInt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimFuelSwitchResv@@YAXKHPAX@Z PROC			; SimFuelSwitchResv

; 6900 : {

	push	ebp
	mov	ebp, esp

; 6901 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimFuelSwi

; 6902 : 		return;

	jmp	SHORT $LN4@SimFuelSwi
$LN3@SimFuelSwi:

; 6903 :     if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimFuelSwi
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimFuelSwi
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimFuelSwi

; 6904 : 		{
; 6905 : 			SimDriver.GetPlayerAircraft()->af->SetFuelSwitch(AirframeClass::FS_RESV);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?SetFuelSwitch@AirframeClass@@QAEXW4FuelSwitch@1@@Z ; AirframeClass::SetFuelSwitch

; 6906 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimFuelSwi

; 6907 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_FUEL_QTY, 2);

	push	2
	push	159					; 0000009fH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimFuelSwi:

; 6908 : 		}
; 6909 : }

	pop	ebp
	ret	0
?SimFuelSwitchResv@@YAXKHPAX@Z ENDP			; SimFuelSwitchResv
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimFuelSwitchNorm@@YAXKHPAX@Z PROC			; SimFuelSwitchNorm

; 6888 : {

	push	ebp
	mov	ebp, esp

; 6889 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimFuelSwi

; 6890 : 		return;

	jmp	SHORT $LN4@SimFuelSwi
$LN3@SimFuelSwi:

; 6891 :     if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimFuelSwi
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimFuelSwi
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimFuelSwi

; 6892 : 		{
; 6893 : 			SimDriver.GetPlayerAircraft()->af->SetFuelSwitch(AirframeClass::FS_NORM);

	push	0
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?SetFuelSwitch@AirframeClass@@QAEXW4FuelSwitch@1@@Z ; AirframeClass::SetFuelSwitch

; 6894 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimFuelSwi

; 6895 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_FUEL_QTY, 1);

	push	1
	push	159					; 0000009fH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimFuelSwi:

; 6896 : 		}
; 6897 : }

	pop	ebp
	ret	0
?SimFuelSwitchNorm@@YAXKHPAX@Z ENDP			; SimFuelSwitchNorm
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimFuelSwitchTest@@YAXKHPAX@Z PROC			; SimFuelSwitchTest

; 6876 : {

	push	ebp
	mov	ebp, esp

; 6877 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimFuelSwi

; 6878 : 		return;

	jmp	SHORT $LN4@SimFuelSwi
$LN3@SimFuelSwi:

; 6879 :     if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimFuelSwi
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimFuelSwi
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimFuelSwi

; 6880 : 		{
; 6881 : 			SimDriver.GetPlayerAircraft()->af->SetFuelSwitch(AirframeClass::FS_TEST);

	push	5
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?SetFuelSwitch@AirframeClass@@QAEXW4FuelSwitch@1@@Z ; AirframeClass::SetFuelSwitch

; 6882 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimFuelSwi

; 6883 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_FUEL_QTY, 32);

	push	32					; 00000020H
	push	159					; 0000009fH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimFuelSwi:

; 6884 : 		}
; 6885 : }

	pop	ebp
	ret	0
?SimFuelSwitchTest@@YAXKHPAX@Z ENDP			; SimFuelSwitchTest
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimDecFuelSwitch@@YAXKHPAX@Z PROC			; SimDecFuelSwitch

; 6862 : {

	push	ebp
	mov	ebp, esp

; 6863 :     if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimDecFuel
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimDecFuel
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimDecFuel

; 6864 : 		{
; 6865 : 			SimDriver.GetPlayerAircraft()->af->DecFuelSwitch();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?DecFuelSwitch@AirframeClass@@QAEXXZ	; AirframeClass::DecFuelSwitch

; 6866 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN3@SimDecFuel

; 6867 : 				//OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_FUEL_QTY, (SimDriver.GetPlayerAircraft()->af->GetFuelSwitch()+1));
; 6868 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_FUEL_QTY, 1<<(SimDriver.GetPlayerAircraft()->af->GetFuelSwitch()));

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?GetFuelSwitch@AirframeClass@@QAE?AW4FuelSwitch@1@XZ ; AirframeClass::GetFuelSwitch
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	push	edx
	push	159					; 0000009fH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN3@SimDecFuel:

; 6869 : 		}
; 6870 : }

	pop	ebp
	ret	0
?SimDecFuelSwitch@@YAXKHPAX@Z ENDP			; SimDecFuelSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimIncFuelSwitch@@YAXKHPAX@Z PROC			; SimIncFuelSwitch

; 6852 : {

	push	ebp
	mov	ebp, esp

; 6853 :     if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimIncFuel
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimIncFuel
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimIncFuel

; 6854 : 		{
; 6855 : 			SimDriver.GetPlayerAircraft()->af->IncFuelSwitch();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?IncFuelSwitch@AirframeClass@@QAEXXZ	; AirframeClass::IncFuelSwitch

; 6856 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN3@SimIncFuel

; 6857 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_FUEL_QTY, (SimDriver.GetPlayerAircraft()->af->GetFuelSwitch()+1));

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?GetFuelSwitch@AirframeClass@@QAE?AW4FuelSwitch@1@XZ ; AirframeClass::GetFuelSwitch
	add	eax, 1
	push	eax
	push	159					; 0000009fH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN3@SimIncFuel:

; 6858 : 		}
; 6859 : }

	pop	ebp
	ret	0
?SimIncFuelSwitch@@YAXKHPAX@Z ENDP			; SimIncFuelSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv81 = -4						; size = 4
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimToggleRealisticAvionics@@YAXKHPAX@Z PROC		; SimToggleRealisticAvionics

; 6846 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 6847 :     if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)) // 2002-02-10 MODIFIED BY S.G. Removed ; at the end of the if statement

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimToggleR
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimToggleR
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimToggleR

; 6848 : 		g_bRealisticAvionics = !g_bRealisticAvionics;

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	jne	SHORT $LN4@SimToggleR
	mov	DWORD PTR tv81[ebp], 1
	jmp	SHORT $LN5@SimToggleR
$LN4@SimToggleR:
	mov	DWORD PTR tv81[ebp], 0
$LN5@SimToggleR:
	mov	dl, BYTE PTR tv81[ebp]
	mov	BYTE PTR ?g_bRealisticAvionics@@3_NA, dl ; g_bRealisticAvionics
$LN2@SimToggleR:

; 6849 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimToggleRealisticAvionics@@YAXKHPAX@Z ENDP		; SimToggleRealisticAvionics
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
_pButton$ = 16						; size = 4
?SimFLIRToggle@@YAXKHPAX@Z PROC				; SimFLIRToggle

; 6363 : {

	push	ebp
	mov	ebp, esp

; 6364 :     if (theLantirn && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	cmp	DWORD PTR ?theLantirn@@3PAVLantirnClass@@A, 0 ; theLantirn
	je	SHORT $LN2@SimFLIRTog
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN2@SimFLIRTog
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@SimFLIRTog
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimFLIRTog

; 6365 :     {
; 6366 : 			theLantirn->ToggleFLIR();

	mov	ecx, DWORD PTR ?theLantirn@@3PAVLantirnClass@@A ; theLantirn
	call	?ToggleFLIR@LantirnClass@@QAEXXZ	; LantirnClass::ToggleFLIR
$LN2@SimFLIRTog:

; 6367 :     }
; 6368 : }

	pop	ebp
	ret	0
?SimFLIRToggle@@YAXKHPAX@Z ENDP				; SimFLIRToggle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?AFAlternateGearReset@@YAXKHPAX@Z PROC			; AFAlternateGearReset

; 6135 : {

	push	ebp
	mov	ebp, esp

; 6136 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@AFAlternat
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@AFAlternat

; 6137 : 	{
; 6138 : 		if (state & KEY_DOWN) {

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN4@AFAlternat

; 6139 : 			SimDriver.GetPlayerAircraft()->af->altGearDeployed = false;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	mov	BYTE PTR [ecx+1572], 0

; 6140 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@AFAlternat

; 6141 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_ALT_GEAR, 1);

	push	1
	push	140					; 0000008cH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@AFAlternat:

; 6142 : 		}
; 6143 : 	}
; 6144 : }

	pop	ebp
	ret	0
?AFAlternateGearReset@@YAXKHPAX@Z ENDP			; AFAlternateGearReset
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?AFAlternateGear@@YAXKHPAX@Z PROC			; AFAlternateGear

; 6122 : {

	push	ebp
	mov	ebp, esp

; 6123 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN1@AFAlternat
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN1@AFAlternat

; 6124 : 	{
; 6125 : 		if (state & KEY_DOWN) {

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN1@AFAlternat

; 6126 : 			SimDriver.GetPlayerAircraft()->af->gearHandle = 1.0F;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [ecx+1556], xmm0

; 6127 : 			SimDriver.GetPlayerAircraft()->af->altGearDeployed = true;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+932]
	mov	BYTE PTR [edx+1572], 1

; 6128 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN1@AFAlternat

; 6129 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_ALT_GEAR, 2);

	push	2
	push	140					; 0000008cH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN1@AFAlternat:

; 6130 : 		}
; 6131 : 	}
; 6132 : }

	pop	ebp
	ret	0
?AFAlternateGear@@YAXKHPAX@Z ENDP			; AFAlternateGear
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?AFResetTrim@@YAXKHPAX@Z PROC				; AFResetTrim

; 6147 : {

	push	ebp
	mov	ebp, esp

; 6148 : 	if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@AFResetTri
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@AFResetTri

; 6149 : 	{
; 6150 : 		if (state & KEY_DOWN) {

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@AFResetTri

; 6151 : 			UserStickInputs.Reset();

	mov	ecx, OFFSET ?UserStickInputs@@3VPilotInputs@@A ; UserStickInputs
	call	?Reset@PilotInputs@@QAEXXZ		; PilotInputs::Reset
$LN3@AFResetTri:

; 6152 : 		}
; 6153 : 	}
; 6154 : }

	pop	ebp
	ret	0
?AFResetTrim@@YAXKHPAX@Z ENDP				; AFResetTrim
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?AFElevatorTrimDown@@YAXKHPAX@Z PROC			; AFElevatorTrimDown

; 6105 : {

	push	ebp
	mov	ebp, esp

; 6106 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { // 2002-02-15 ADDED BY S.G. Moved outside the two if statement

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN1@AFElevator
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN1@AFElevator

; 6107 : 	//MI additions
; 6108 : 		if(g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN3@AFElevator

; 6109 : 		{
; 6110 : 			if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->TrimAPDisc)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@AFElevator
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	movzx	ecx, BYTE PTR [eax+850]
	test	ecx, ecx
	je	SHORT $LN3@AFElevator

; 6111 : 				return;

	jmp	SHORT $LN6@AFElevator
$LN3@AFElevator:

; 6112 : 		}
; 6113 : 
; 6114 : 		if (state & KEY_DOWN)

	mov	edx, DWORD PTR _state$[ebp]
	and	edx, 8
	je	SHORT $LN2@AFElevator

; 6115 : 			pitchElevatorTrimRate = 0.25F;

	movss	xmm0, DWORD PTR __real@3e800000
	movss	DWORD PTR ?pitchElevatorTrimRate@@3MA, xmm0

; 6116 : 		else

	jmp	SHORT $LN1@AFElevator
$LN2@AFElevator:

; 6117 : 			pitchElevatorTrimRate = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR ?pitchElevatorTrimRate@@3MA, xmm0
$LN1@AFElevator:
$LN6@AFElevator:

; 6118 : 	}
; 6119 : }

	pop	ebp
	ret	0
?AFElevatorTrimDown@@YAXKHPAX@Z ENDP			; AFElevatorTrimDown
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?AFElevatorTrimUp@@YAXKHPAX@Z PROC			; AFElevatorTrimUp

; 6088 : {

	push	ebp
	mov	ebp, esp

; 6089 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { // 2002-02-15 ADDED BY S.G. Moved outside the two if statement

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN1@AFElevator
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN1@AFElevator

; 6090 : 		//MI additions
; 6091 : 		if(g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN3@AFElevator

; 6092 : 		{
; 6093 : 			if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->TrimAPDisc)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@AFElevator
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	movzx	ecx, BYTE PTR [eax+850]
	test	ecx, ecx
	je	SHORT $LN3@AFElevator

; 6094 : 				return;

	jmp	SHORT $LN6@AFElevator
$LN3@AFElevator:

; 6095 : 		}
; 6096 : 
; 6097 : 		if (state & KEY_DOWN)

	mov	edx, DWORD PTR _state$[ebp]
	and	edx, 8
	je	SHORT $LN2@AFElevator

; 6098 : 			pitchElevatorTrimRate = -0.25F;

	movss	xmm0, DWORD PTR __real@be800000
	movss	DWORD PTR ?pitchElevatorTrimRate@@3MA, xmm0

; 6099 : 		else

	jmp	SHORT $LN1@AFElevator
$LN2@AFElevator:

; 6100 : 			pitchElevatorTrimRate = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR ?pitchElevatorTrimRate@@3MA, xmm0
$LN1@AFElevator:
$LN6@AFElevator:

; 6101 : 	}
; 6102 : }

	pop	ebp
	ret	0
?AFElevatorTrimUp@@YAXKHPAX@Z ENDP			; AFElevatorTrimUp
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?AFAileronTrimRight@@YAXKHPAX@Z PROC			; AFAileronTrimRight

; 6071 : {

	push	ebp
	mov	ebp, esp

; 6072 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { // 2002-02-15 ADDED BY S.G. Moved outside the two if statement

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN1@AFAileronT
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN1@AFAileronT

; 6073 : 		//MI additions
; 6074 : 		if(g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN3@AFAileronT

; 6075 : 		{
; 6076 : 			if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->TrimAPDisc)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@AFAileronT
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	movzx	ecx, BYTE PTR [eax+850]
	test	ecx, ecx
	je	SHORT $LN3@AFAileronT

; 6077 : 				return;

	jmp	SHORT $LN6@AFAileronT
$LN3@AFAileronT:

; 6078 : 		}
; 6079 : 
; 6080 : 		if (state & KEY_DOWN)

	mov	edx, DWORD PTR _state$[ebp]
	and	edx, 8
	je	SHORT $LN2@AFAileronT

; 6081 : 			pitchAileronTrimRate = 0.25F;

	movss	xmm0, DWORD PTR __real@3e800000
	movss	DWORD PTR ?pitchAileronTrimRate@@3MA, xmm0

; 6082 : 		else

	jmp	SHORT $LN1@AFAileronT
$LN2@AFAileronT:

; 6083 : 			pitchAileronTrimRate = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR ?pitchAileronTrimRate@@3MA, xmm0
$LN1@AFAileronT:
$LN6@AFAileronT:

; 6084 : 	}
; 6085 : }

	pop	ebp
	ret	0
?AFAileronTrimRight@@YAXKHPAX@Z ENDP			; AFAileronTrimRight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?AFAileronTrimLeft@@YAXKHPAX@Z PROC			; AFAileronTrimLeft

; 6054 : {

	push	ebp
	mov	ebp, esp

; 6055 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { // 2002-02-15 ADDED BY S.G. Moved outside the two if statement

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN1@AFAileronT
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN1@AFAileronT

; 6056 : 	//MI additions
; 6057 : 		if(g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN3@AFAileronT

; 6058 : 		{
; 6059 : 			if(SimDriver.GetPlayerAircraft()->TrimAPDisc)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	movzx	ecx, BYTE PTR [eax+850]
	test	ecx, ecx
	je	SHORT $LN3@AFAileronT

; 6060 : 				return;

	jmp	SHORT $LN6@AFAileronT
$LN3@AFAileronT:

; 6061 : 		}
; 6062 : 
; 6063 : 		if (state & KEY_DOWN)

	mov	edx, DWORD PTR _state$[ebp]
	and	edx, 8
	je	SHORT $LN2@AFAileronT

; 6064 : 			pitchAileronTrimRate = -0.25F;

	movss	xmm0, DWORD PTR __real@be800000
	movss	DWORD PTR ?pitchAileronTrimRate@@3MA, xmm0

; 6065 : 		else

	jmp	SHORT $LN1@AFAileronT
$LN2@AFAileronT:

; 6066 : 			pitchAileronTrimRate = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR ?pitchAileronTrimRate@@3MA, xmm0
$LN1@AFAileronT:
$LN6@AFAileronT:

; 6067 : 	}
; 6068 : }

	pop	ebp
	ret	0
?AFAileronTrimLeft@@YAXKHPAX@Z ENDP			; AFAileronTrimLeft
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?AFRudderTrimRight@@YAXKHPAX@Z PROC			; AFRudderTrimRight

; 6037 : {

	push	ebp
	mov	ebp, esp

; 6038 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { // 2002-02-15 ADDED BY S.G. Moved outside the two if statement

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN1@AFRudderTr
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN1@AFRudderTr

; 6039 : 	//MI additions
; 6040 : 		if(g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN3@AFRudderTr

; 6041 : 		{
; 6042 : 			if(SimDriver.GetPlayerAircraft()->TrimAPDisc)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	movzx	ecx, BYTE PTR [eax+850]
	test	ecx, ecx
	je	SHORT $LN3@AFRudderTr

; 6043 : 				return;

	jmp	SHORT $LN6@AFRudderTr
$LN3@AFRudderTr:

; 6044 : 		}
; 6045 : 
; 6046 : 		if (state & KEY_DOWN)

	mov	edx, DWORD PTR _state$[ebp]
	and	edx, 8
	je	SHORT $LN2@AFRudderTr

; 6047 : 			pitchRudderTrimRate = 0.25F;

	movss	xmm0, DWORD PTR __real@3e800000
	movss	DWORD PTR ?pitchRudderTrimRate@@3MA, xmm0

; 6048 : 		else

	jmp	SHORT $LN1@AFRudderTr
$LN2@AFRudderTr:

; 6049 : 			pitchRudderTrimRate = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR ?pitchRudderTrimRate@@3MA, xmm0
$LN1@AFRudderTr:
$LN6@AFRudderTr:

; 6050 : 	}
; 6051 : }

	pop	ebp
	ret	0
?AFRudderTrimRight@@YAXKHPAX@Z ENDP			; AFRudderTrimRight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?AFRudderTrimLeft@@YAXKHPAX@Z PROC			; AFRudderTrimLeft

; 6020 : {

	push	ebp
	mov	ebp, esp

; 6021 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP)) { // 2002-02-15 ADDED BY S.G. Moved outside the two if statement

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN1@AFRudderTr
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN1@AFRudderTr

; 6022 : 		//MI additions
; 6023 : 		if(g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN3@AFRudderTr

; 6024 : 		{
; 6025 : 			if(SimDriver.GetPlayerAircraft()->TrimAPDisc)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	movzx	ecx, BYTE PTR [eax+850]
	test	ecx, ecx
	je	SHORT $LN3@AFRudderTr

; 6026 : 				return;

	jmp	SHORT $LN6@AFRudderTr
$LN3@AFRudderTr:

; 6027 : 		}
; 6028 : 
; 6029 : 		if (state & KEY_DOWN)

	mov	edx, DWORD PTR _state$[ebp]
	and	edx, 8
	je	SHORT $LN2@AFRudderTr

; 6030 : 			pitchRudderTrimRate = -0.25F;

	movss	xmm0, DWORD PTR __real@be800000
	movss	DWORD PTR ?pitchRudderTrimRate@@3MA, xmm0

; 6031 : 		else

	jmp	SHORT $LN1@AFRudderTr
$LN2@AFRudderTr:

; 6032 : 			pitchRudderTrimRate = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR ?pitchRudderTrimRate@@3MA, xmm0
$LN1@AFRudderTr:
$LN6@AFRudderTr:

; 6033 : 	}
; 6034 : }

	pop	ebp
	ret	0
?AFRudderTrimLeft@@YAXKHPAX@Z ENDP			; AFRudderTrimLeft
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimEpuOn@@YAXKHPAX@Z PROC				; SimEpuOn

; 6007 : {

	push	ebp
	mov	ebp, esp

; 6008 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimEpuOn

; 6009 : 		return;

	jmp	SHORT $LN4@SimEpuOn
$LN3@SimEpuOn:

; 6010 :   if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)) 

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimEpuOn
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimEpuOn
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimEpuOn

; 6011 : 	{
; 6012 : 		SimDriver.GetPlayerAircraft()->af->SetEpuSwitch(AirframeClass::ON);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?SetEpuSwitch@AirframeClass@@QAEXW4EpuState@1@@Z ; AirframeClass::SetEpuSwitch

; 6013 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimEpuOn

; 6014 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_EPU, 4);

	push	4
	push	178					; 000000b2H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimEpuOn:

; 6015 :   }
; 6016 : }

	pop	ebp
	ret	0
?SimEpuOn@@YAXKHPAX@Z ENDP				; SimEpuOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimEpuAuto@@YAXKHPAX@Z PROC				; SimEpuAuto

; 5995 : {

	push	ebp
	mov	ebp, esp

; 5996 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimEpuAuto

; 5997 : 		return;

	jmp	SHORT $LN4@SimEpuAuto
$LN3@SimEpuAuto:

; 5998 :   if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)) 

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimEpuAuto
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimEpuAuto
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimEpuAuto

; 5999 : 	{
; 6000 : 		SimDriver.GetPlayerAircraft()->af->SetEpuSwitch(AirframeClass::AUTO);

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?SetEpuSwitch@AirframeClass@@QAEXW4EpuState@1@@Z ; AirframeClass::SetEpuSwitch

; 6001 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimEpuAuto

; 6002 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_EPU, 2);

	push	2
	push	178					; 000000b2H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimEpuAuto:

; 6003 :   }
; 6004 : }

	pop	ebp
	ret	0
?SimEpuAuto@@YAXKHPAX@Z ENDP				; SimEpuAuto
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimEpuOff@@YAXKHPAX@Z PROC				; SimEpuOff

; 5983 : {

	push	ebp
	mov	ebp, esp

; 5984 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimEpuOff

; 5985 : 		return;

	jmp	SHORT $LN4@SimEpuOff
$LN3@SimEpuOff:

; 5986 :   if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)) 

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimEpuOff
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimEpuOff
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimEpuOff

; 5987 : 	{
; 5988 : 		SimDriver.GetPlayerAircraft()->af->SetEpuSwitch(AirframeClass::OFF);

	push	0
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?SetEpuSwitch@AirframeClass@@QAEXW4EpuState@1@@Z ; AirframeClass::SetEpuSwitch

; 5989 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimEpuOff

; 5990 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_EPU, 1);

	push	1
	push	178					; 000000b2H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimEpuOff:

; 5991 :   }
; 5992 : }

	pop	ebp
	ret	0
?SimEpuOff@@YAXKHPAX@Z ENDP				; SimEpuOff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$1 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimEpuToggle@@YAXKHPAX@Z PROC				; SimEpuToggle

; 5968 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 5969 :   if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)) 

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN3@SimEpuTogg
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN3@SimEpuTogg
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN3@SimEpuTogg

; 5970 : 	{
; 5971 : 		// toggle EPU off/auto/on.
; 5972 : 		SimDriver.GetPlayerAircraft()->af->StepEpuSwitch();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?StepEpuSwitch@AirframeClass@@QAEXXZ	; AirframeClass::StepEpuSwitch

; 5973 : 		int val = SimDriver.GetPlayerAircraft()->af->GetEpuSwitch()+1;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?GetEpuSwitch@AirframeClass@@QAE?AW4EpuState@1@XZ ; AirframeClass::GetEpuSwitch
	add	eax, 1
	mov	DWORD PTR _val$1[ebp], eax

; 5974 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN3@SimEpuTogg

; 5975 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_EPU, val);

	mov	ecx, DWORD PTR _val$1[ebp]
	push	ecx
	push	178					; 000000b2H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN3@SimEpuTogg:

; 5976 :   }
; 5977 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimEpuToggle@@YAXKHPAX@Z ENDP				; SimEpuToggle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv162 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimJfsStart@@YAXKHPAX@Z PROC				; SimJfsStart

; 5946 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 5947 :   if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN)) 

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN1@SimJfsStar
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN1@SimJfsStar
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	$LN1@SimJfsStar

; 5948 : 	{
; 5949 : 		// if jfs allready running, clear it.
; 5950 : 		if (SimDriver.GetPlayerAircraft()->af->IsSet(AirframeClass::JfsStart)) 

	push	268435456				; 10000000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN5@SimJfsStar

; 5951 : 		{
; 5952 : 			SimDriver.GetPlayerAircraft()->af->ClearFlag(AirframeClass::JfsStart);

	push	268435456				; 10000000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?ClearFlag@AirframeClass@@QAEXH@Z	; AirframeClass::ClearFlag

; 5953 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimJfsStar

; 5954 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_JSF_START, 1);

	push	1
	push	176					; 000000b0H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimJfsStar:

; 5955 : 		}

	jmp	SHORT $LN1@SimJfsStar
$LN5@SimJfsStar:

; 5956 : 		// otherwise - if throttle is at idle, and accumulators charged, attempt JFS start
; 5957 : 		else if (SimDriver.GetPlayerAircraft()->af->Throtl() < 0.1f) 

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?Throtl@AirframeClass@@QAEMXZ		; AirframeClass::Throtl
	fstp	DWORD PTR tv162[ebp]
	movss	xmm0, DWORD PTR __real@3dcccccd
	comiss	xmm0, DWORD PTR tv162[ebp]
	jbe	SHORT $LN1@SimJfsStar

; 5958 : 		{
; 5959 : 			SimDriver.GetPlayerAircraft()->af->JfsEngineStart ();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?JfsEngineStart@AirframeClass@@QAEXXZ	; AirframeClass::JfsEngineStart

; 5960 : 			if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN1@SimJfsStar

; 5961 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_JSF_START, 2);

	push	2
	push	176					; 000000b0H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN1@SimJfsStar:

; 5962 : 		}
; 5963 :   }
; 5964 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimJfsStart@@YAXKHPAX@Z ENDP				; SimJfsStart
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv362 = -8						; size = 4
tv129 = -4						; size = 4
___formal$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimThrottleIdleDetent@@YAXKHPAX@Z PROC			; SimThrottleIdleDetent

; 5856 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 5857 : 	if (g_bUseAnalogIdleCutoff)

	movzx	eax, BYTE PTR ?g_bUseAnalogIdleCutoff@@3_NA ; g_bUseAnalogIdleCutoff
	test	eax, eax
	je	SHORT $LN23@SimThrottl

; 5858 : 		return;

	jmp	$LN24@SimThrottl
$LN23@SimThrottl:

; 5859 : 
; 5860 :   if (SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN1@SimThrottl
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN1@SimThrottl
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	$LN1@SimThrottl

; 5861 : 	{
; 5862 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN21@SimThrottl

; 5863 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_IDLE_DETENT, 2);

	push	2
	push	167					; 000000a7H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN21@SimThrottl:

; 5864 : 		//TJL 01/18/04 Multi-engine
; 5865 : 		if (SimDriver.GetPlayerAircraft()->af->GetNumberEngines() == 2)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?GetNumberEngines@AirframeClass@@QAEHXZ	; AirframeClass::GetNumberEngines
	cmp	eax, 2
	jne	$LN20@SimThrottl

; 5866 : 		{
; 5867 : 			switch (UserStickInputs.getCurrentEngine())

	mov	ecx, OFFSET ?UserStickInputs@@3VPilotInputs@@A ; UserStickInputs
	call	?getCurrentEngine@PilotInputs@@QAE?AW4Engine_t@1@XZ ; PilotInputs::getCurrentEngine
	mov	DWORD PTR tv129[ebp], eax
	cmp	DWORD PTR tv129[ebp], 0
	je	SHORT $LN17@SimThrottl
	cmp	DWORD PTR tv129[ebp], 1
	je	$LN13@SimThrottl
	cmp	DWORD PTR tv129[ebp], 2
	je	$LN9@SimThrottl
	jmp	$LN5@SimThrottl
$LN17@SimThrottl:

; 5868 : 			{
; 5869 : 				//case PilotInputs::Left_Engine:
; 5870 : 				case UserStickInputs.Left_Engine:
; 5871 : 					if (SimDriver.GetPlayerAircraft()->af->engine1Throttle < 0.1f)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR __real@3dcccccd
	comiss	xmm0, DWORD PTR [edx+1520]
	jbe	SHORT $LN16@SimThrottl

; 5872 : 					{
; 5873 : 						SimDriver.GetPlayerAircraft()->af->SetFlag(AirframeClass::EngineStopped);

	push	134217728				; 08000000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?SetFlag@AirframeClass@@QAEXH@Z		; AirframeClass::SetFlag

; 5874 : 						SimDriver.GetPlayerAircraft()->af->SetFlag(AirframeClass::EngineOff);

	push	32768					; 00008000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?SetFlag@AirframeClass@@QAEXH@Z		; AirframeClass::SetFlag
	jmp	SHORT $LN14@SimThrottl
$LN16@SimThrottl:

; 5875 : 					}
; 5876 : 					else if (SimDriver.GetPlayerAircraft()->af->rpm >= 0.20f)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	eax, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [eax+1212]
	comiss	xmm0, DWORD PTR __real@3e4ccccd
	jb	SHORT $LN14@SimThrottl

; 5877 : 					{
; 5878 : 						// engine light 
; 5879 : 						SimDriver.GetPlayerAircraft()->af->ClearFlag(AirframeClass::EngineStopped);

	push	134217728				; 08000000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?ClearFlag@AirframeClass@@QAEXH@Z	; AirframeClass::ClearFlag

; 5880 : 						SimDriver.GetPlayerAircraft()->af->ClearFlag(AirframeClass::EngineOff);

	push	32768					; 00008000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?ClearFlag@AirframeClass@@QAEXH@Z	; AirframeClass::ClearFlag

; 5881 : 						SimDriver.GetPlayerAircraft()->mFaults->ClearFault(FaultClass::eng_fault, FaultClass::fl_out);

	push	-2147483648				; 80000000H
	push	8
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+928]
	call	?ClearFault@FackClass@@QAEXW4type_FSubSystem@FaultClass@@W4type_FFunction@3@@Z ; FackClass::ClearFault
$LN14@SimThrottl:

; 5882 : 					}
; 5883 : 					break;

	jmp	$LN18@SimThrottl
$LN13@SimThrottl:

; 5884 : 
; 5885 : 				case UserStickInputs.Right_Engine:
; 5886 : 					if (SimDriver.GetPlayerAircraft()->af->engine2Throttle < 0.1f)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR __real@3dcccccd
	comiss	xmm0, DWORD PTR [ecx+1524]
	jbe	SHORT $LN12@SimThrottl

; 5887 : 					{
; 5888 : 						SimDriver.GetPlayerAircraft()->af->SetEngineFlag(AirframeClass::EngineStopped2);

	push	8
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?SetEngineFlag@AirframeClass@@QAEXW4EngineFlags@1@@Z ; AirframeClass::SetEngineFlag

; 5889 : 						SimDriver.GetPlayerAircraft()->af->SetFlag(AirframeClass::EngineOff2);

	push	536870912				; 20000000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?SetFlag@AirframeClass@@QAEXH@Z		; AirframeClass::SetFlag
	jmp	SHORT $LN10@SimThrottl
$LN12@SimThrottl:

; 5890 : 					}
; 5891 : 					else if (SimDriver.GetPlayerAircraft()->af->rpm2 >= 0.20f)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [edx+1216]
	comiss	xmm0, DWORD PTR __real@3e4ccccd
	jb	SHORT $LN10@SimThrottl

; 5892 : 					{
; 5893 : 						// engine light 
; 5894 : 						SimDriver.GetPlayerAircraft()->af->ClearEngineFlag(AirframeClass::EngineStopped2);

	push	8
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?ClearEngineFlag@AirframeClass@@QAEXW4EngineFlags@1@@Z ; AirframeClass::ClearEngineFlag

; 5895 : 						SimDriver.GetPlayerAircraft()->af->ClearFlag(AirframeClass::EngineOff);

	push	32768					; 00008000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?ClearFlag@AirframeClass@@QAEXH@Z	; AirframeClass::ClearFlag

; 5896 : 						SimDriver.GetPlayerAircraft()->mFaults->ClearFault(FaultClass::eng2_fault, FaultClass::fl_out);

	push	-2147483648				; 80000000H
	push	9
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+928]
	call	?ClearFault@FackClass@@QAEXW4type_FSubSystem@FaultClass@@W4type_FFunction@3@@Z ; FackClass::ClearFault
$LN10@SimThrottl:

; 5897 : 					}
; 5898 : 					break;

	jmp	$LN18@SimThrottl
$LN9@SimThrottl:

; 5899 : 
; 5900 : 				case UserStickInputs.Both_Engines:
; 5901 : 					if (SimDriver.GetPlayerAircraft()->af->engine1Throttle < 0.1f && 
; 5902 : 						SimDriver.GetPlayerAircraft()->af->engine2Throttle < 0.1f)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	eax, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR __real@3dcccccd
	comiss	xmm0, DWORD PTR [eax+1520]
	jbe	$LN8@SimThrottl
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR __real@3dcccccd
	comiss	xmm0, DWORD PTR [ecx+1524]
	jbe	SHORT $LN8@SimThrottl

; 5903 : 					{
; 5904 : 						SimDriver.GetPlayerAircraft()->af->SetFlag(AirframeClass::EngineStopped);

	push	134217728				; 08000000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?SetFlag@AirframeClass@@QAEXH@Z		; AirframeClass::SetFlag

; 5905 : 						SimDriver.GetPlayerAircraft()->af->SetEngineFlag(AirframeClass::EngineStopped2);

	push	8
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?SetEngineFlag@AirframeClass@@QAEXW4EngineFlags@1@@Z ; AirframeClass::SetEngineFlag

; 5906 : 						SimDriver.GetPlayerAircraft()->af->SetFlag(AirframeClass::EngineOff);

	push	32768					; 00008000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?SetFlag@AirframeClass@@QAEXH@Z		; AirframeClass::SetFlag

; 5907 : 						SimDriver.GetPlayerAircraft()->af->SetFlag(AirframeClass::EngineOff2);

	push	536870912				; 20000000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?SetFlag@AirframeClass@@QAEXH@Z		; AirframeClass::SetFlag

; 5908 : 					}
; 5909 : 					else if (SimDriver.GetPlayerAircraft()->af->rpm >= 0.20f && 

	jmp	$LN6@SimThrottl
$LN8@SimThrottl:

; 5910 : 							SimDriver.GetPlayerAircraft()->af->rpm >= 0.20f)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [edx+1212]
	comiss	xmm0, DWORD PTR __real@3e4ccccd
	jb	$LN6@SimThrottl
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	eax, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [eax+1212]
	comiss	xmm0, DWORD PTR __real@3e4ccccd
	jb	$LN6@SimThrottl

; 5911 : 					{
; 5912 : 						// engine light2
; 5913 : 						SimDriver.GetPlayerAircraft()->af->ClearFlag(AirframeClass::EngineStopped);

	push	134217728				; 08000000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?ClearFlag@AirframeClass@@QAEXH@Z	; AirframeClass::ClearFlag

; 5914 : 						SimDriver.GetPlayerAircraft()->af->ClearFlag(AirframeClass::EngineOff);

	push	32768					; 00008000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?ClearFlag@AirframeClass@@QAEXH@Z	; AirframeClass::ClearFlag

; 5915 : 						SimDriver.GetPlayerAircraft()->mFaults->ClearFault(FaultClass::eng_fault, FaultClass::fl_out);

	push	-2147483648				; 80000000H
	push	8
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+928]
	call	?ClearFault@FackClass@@QAEXW4type_FSubSystem@FaultClass@@W4type_FFunction@3@@Z ; FackClass::ClearFault

; 5916 : 						SimDriver.GetPlayerAircraft()->af->ClearEngineFlag(AirframeClass::EngineStopped2);

	push	8
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?ClearEngineFlag@AirframeClass@@QAEXW4EngineFlags@1@@Z ; AirframeClass::ClearEngineFlag

; 5917 : 						SimDriver.GetPlayerAircraft()->af->ClearFlag(AirframeClass::EngineOff2);

	push	536870912				; 20000000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?ClearFlag@AirframeClass@@QAEXH@Z	; AirframeClass::ClearFlag

; 5918 : 						SimDriver.GetPlayerAircraft()->mFaults->ClearFault(FaultClass::eng2_fault, FaultClass::fl_out);

	push	-2147483648				; 80000000H
	push	9
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+928]
	call	?ClearFault@FackClass@@QAEXW4type_FSubSystem@FaultClass@@W4type_FFunction@3@@Z ; FackClass::ClearFault
$LN6@SimThrottl:
$LN5@SimThrottl:
$LN18@SimThrottl:

; 5919 : 					}
; 5920 : 					break;
; 5921 : 
; 5922 : 				default:
; 5923 : 					break;
; 5924 : 			}
; 5925 : 		}
; 5926 : 		else

	jmp	$LN1@SimThrottl
$LN20@SimThrottl:

; 5927 : 		{
; 5928 : 		// Orig code 
; 5929 : 		// throttle to off?
; 5930 : 			if (SimDriver.GetPlayerAircraft()->af->Throtl() < 0.1f)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?Throtl@AirframeClass@@QAEMXZ		; AirframeClass::Throtl
	fstp	DWORD PTR tv362[ebp]
	movss	xmm0, DWORD PTR __real@3dcccccd
	comiss	xmm0, DWORD PTR tv362[ebp]
	jbe	SHORT $LN3@SimThrottl

; 5931 : 			{
; 5932 : 				SimDriver.GetPlayerAircraft()->af->SetFlag(AirframeClass::EngineStopped);

	push	134217728				; 08000000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?SetFlag@AirframeClass@@QAEXH@Z		; AirframeClass::SetFlag
	jmp	SHORT $LN1@SimThrottl
$LN3@SimThrottl:

; 5933 : 			}
; 5934 : 			else if (SimDriver.GetPlayerAircraft()->af->rpm >= 0.20f)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [ecx+1212]
	comiss	xmm0, DWORD PTR __real@3e4ccccd
	jb	SHORT $LN1@SimThrottl

; 5935 : 			{
; 5936 : 				// engine light 
; 5937 : 				SimDriver.GetPlayerAircraft()->af->ClearFlag(AirframeClass::EngineStopped);

	push	134217728				; 08000000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?ClearFlag@AirframeClass@@QAEXH@Z	; AirframeClass::ClearFlag

; 5938 : 				SimDriver.GetPlayerAircraft()->mFaults->ClearFault(FaultClass::eng_fault, FaultClass::fl_out);

	push	-2147483648				; 80000000H
	push	8
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+928]
	call	?ClearFault@FackClass@@QAEXW4type_FSubSystem@FaultClass@@W4type_FFunction@3@@Z ; FackClass::ClearFault
$LN1@SimThrottl:
$LN24@SimThrottl:

; 5939 : 			}
; 5940 : 		}
; 5941 :   }
; 5942 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimThrottleIdleDetent@@YAXKHPAX@Z ENDP			; SimThrottleIdleDetent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimHookDown@@YAXKHPAX@Z PROC				; SimHookDown

; 7261 : {

	push	ebp
	mov	ebp, esp

; 7262 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimHookDow

; 7263 : 		return;

	jmp	SHORT $LN4@SimHookDow
$LN3@SimHookDow:

; 7264 : 	
; 7265 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimHookDow
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimHookDow
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimHookDow

; 7266 : 	{
; 7267 : 		SimDriver.GetPlayerAircraft()->af->HookDown();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?HookDown@AirframeClass@@QAEXXZ		; AirframeClass::HookDown

; 7268 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimHookDow

; 7269 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HOOK, 2);

	push	2
	push	139					; 0000008bH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimHookDow:

; 7270 : 	}
; 7271 : }

	pop	ebp
	ret	0
?SimHookDown@@YAXKHPAX@Z ENDP				; SimHookDown
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimHookUp@@YAXKHPAX@Z PROC				; SimHookUp

; 7248 : {

	push	ebp
	mov	ebp, esp

; 7249 : 	if (!g_bRealisticAvionics)  // not intended for anything other than realistic mode

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN3@SimHookUp

; 7250 : 		return;

	jmp	SHORT $LN4@SimHookUp
$LN3@SimHookUp:

; 7251 : 	
; 7252 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN4@SimHookUp
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@SimHookUp
	mov	ecx, DWORD PTR _state$[ebp]
	and	ecx, 8
	je	SHORT $LN4@SimHookUp

; 7253 : 	{
; 7254 : 		SimDriver.GetPlayerAircraft()->af->HookUp();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?HookUp@AirframeClass@@QAEXXZ		; AirframeClass::HookUp

; 7255 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN4@SimHookUp

; 7256 : 			OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HOOK, 1);

	push	1
	push	139					; 0000008bH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN4@SimHookUp:

; 7257 : 	}
; 7258 : }

	pop	ebp
	ret	0
?SimHookUp@@YAXKHPAX@Z ENDP				; SimHookUp
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimHookToggle@@YAXKHPAX@Z PROC				; SimHookToggle

; 7229 : {

	push	ebp
	mov	ebp, esp

; 7230 : 	if(SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag(MOTION_OWNSHIP) && (state & KEY_DOWN) 
; 7231 : 		//&& SimDriver.GetPlayerAircraft()->mFaults->GetFault( FaultClass::hook_fault )
; 7232 : 		)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	$LN5@SimHookTog
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN5@SimHookTog
	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN5@SimHookTog

; 7233 : 	{
; 7234 : 		SimDriver.GetPlayerAircraft()->af->ToggleHook();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?ToggleHook@AirframeClass@@QAEXXZ	; AirframeClass::ToggleHook

; 7235 : 		if (OTWDriver.GetVirtualCockpit())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	test	eax, eax
	je	SHORT $LN5@SimHookTog

; 7236 : 		{
; 7237 : 			if (SimDriver.GetPlayerAircraft()->af->IsSet(AirframeClass::Hook))

	push	-2147483648				; 80000000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN2@SimHookTog

; 7238 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HOOK, 2);

	push	2
	push	139					; 0000008bH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 7239 : 			else

	jmp	SHORT $LN5@SimHookTog
$LN2@SimHookTog:

; 7240 : 				OTWDriver.GetVirtualCockpit()->SetSwitchMask( COMP_3DPIT_HOOK, 1);

	push	1
	push	139					; 0000008bH
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetVirtualCockpit@OTWDriverClass@@QAEPAVDrawableBSP@@XZ ; OTWDriverClass::GetVirtualCockpit
	mov	ecx, eax
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN5@SimHookTog:

; 7241 : 		}
; 7242 : 	}
; 7243 : }

	pop	ebp
	ret	0
?SimHookToggle@@YAXKHPAX@Z ENDP				; SimHookToggle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\siminput\commands.cpp
_TEXT	SEGMENT
tv88 = -12						; size = 8
tv85 = -4						; size = 4
_val$ = 8						; size = 4
_state$ = 12						; size = 4
___formal$ = 16						; size = 4
?SimSetBubbleSize@@YAXKHPAX@Z PROC			; SimSetBubbleSize

; 5847 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 5848 :    if (state & KEY_DOWN && !(gCommsMgr && gCommsMgr->Online()))

	mov	eax, DWORD PTR _state$[ebp]
	and	eax, 8
	je	SHORT $LN2@SimSetBubb
	cmp	DWORD PTR ?gCommsMgr@@3PAVUIComms@@A, 0	; gCommsMgr
	je	SHORT $LN1@SimSetBubb
	mov	ecx, DWORD PTR ?gCommsMgr@@3PAVUIComms@@A ; gCommsMgr
	call	?Online@UIComms@@QAEHXZ			; UIComms::Online
	test	eax, eax
	jne	SHORT $LN2@SimSetBubb
$LN1@SimSetBubb:

; 5849 :       FalconLocalSession->SetBubbleRatio(.5f + float(val - DIK_1) / 2.0f);

	mov	ecx, DWORD PTR _val$[ebp]
	sub	ecx, 2
	mov	DWORD PTR tv85[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv85[ebp]
	mov	edx, DWORD PTR tv85[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv88[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv88[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	addss	xmm0, DWORD PTR __real@3f000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?SetBubbleRatio@FalconSessionEntity@@QAEXM@Z ; FalconSessionEntity::SetBubbleRatio
$LN2@SimSetBubb:

; 5850 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SimSetBubbleSize@@YAXKHPAX@Z ENDP			; SimSetBubbleSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?UnSetFalcFlag@FalconEntity@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_flag$ = 8						; size = 4
?UnSetFalcFlag@FalconEntity@@QAEXH@Z PROC		; FalconEntity::UnSetFalcFlag, COMDAT
; _this$ = ecx

; 111  : 	void UnSetFalcFlag (int flag)				{ if (falconFlags & flag) {falconFlags &= ~flag; MakeFlagsDirty ();} };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+136]
	and	ecx, DWORD PTR _flag$[ebp]
	je	SHORT $LN2@UnSetFalcF
	mov	edx, DWORD PTR _flag$[ebp]
	not	edx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+136]
	and	ecx, edx
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+136], cl
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeFlagsDirty@FalconEntity@@QAEXXZ	; FalconEntity::MakeFlagsDirty
$LN2@UnSetFalcF:
	mov	esp, ebp
	pop	ebp
	ret	4
?UnSetFalcFlag@FalconEntity@@QAEXH@Z ENDP		; FalconEntity::UnSetFalcFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?SetFalcFlag@FalconEntity@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_flag$ = 8						; size = 4
?SetFalcFlag@FalconEntity@@QAEXH@Z PROC			; FalconEntity::SetFalcFlag, COMDAT
; _this$ = ecx

; 110  : 	void SetFalcFlag (int flag)					{ if (!(falconFlags & flag)) {falconFlags |= flag; MakeFlagsDirty();} };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+136]
	and	ecx, DWORD PTR _flag$[ebp]
	jne	SHORT $LN2@SetFalcFla
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+136]
	or	eax, DWORD PTR _flag$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+136], al
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeFlagsDirty@FalconEntity@@QAEXXZ	; FalconEntity::MakeFlagsDirty
$LN2@SetFalcFla:
	mov	esp, ebp
	pop	ebp
	ret	4
?SetFalcFlag@FalconEntity@@QAEXH@Z ENDP			; FalconEntity::SetFalcFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ PROC ; VuBin<VuSessionEntity>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ENDP ; VuBin<VuSessionEntity>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ PROC		; VuBin<VuSessionEntity>::operator bool, COMDAT
; _this$ = ecx

; 40   : 	operator bool() const{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 		return e != NULL;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@operator
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv66[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv66[ebp]

; 42   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ ENDP		; VuBin<VuSessionEntity>::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2275 : 		{	// report an out_of_range error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2276 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN2@Xran:

; 2277 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2270 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2271 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN2@Xlen:

; 2272 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Ptr$1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2253 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2254 : 		if (!_Built)

	movzx	eax, BYTE PTR __Built$[ebp]
	test	eax, eax
	jne	SHORT $LN4@Tidy
	jmp	SHORT $LN3@Tidy
$LN4@Tidy:

; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN3@Tidy

; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Ptr$1[ebp], eax

; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 2260 : 			if (0 < _Newsize)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN1@Tidy

; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$1[ebp]
	push	ecx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Tidy:

; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Ptr$1[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN3@Tidy:

; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2266 : 		_Eos(_Newsize);

	mov	edx, DWORD PTR __Newsize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2267 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2237 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	cmp	DWORD PTR __Ptr$[ebp], 0
	je	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	cmp	DWORD PTR __Ptr$[ebp], eax
	jb	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
$LN2@Inside:

; 2240 : 			return (false);	// don't ask

	xor	al, al
	jmp	SHORT $LN4@Inside

; 2241 : 		else

	jmp	SHORT $LN4@Inside
$LN3@Inside:

; 2242 : 			return (true);

	mov	al, 1
$LN4@Inside:

; 2243 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
tv136 = -12						; size = 4
tv129 = -8						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2224 : 		if (max_size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN6@Grow

; 2225 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN6@Grow:

; 2226 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN5@Grow

; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	jmp	SHORT $LN4@Grow
$LN5@Grow:

; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	movzx	edx, BYTE PTR __Trim$[ebp]
	test	edx, edx
	je	SHORT $LN3@Grow
	cmp	DWORD PTR __Newsize$[ebp], 16		; 00000010H
	jae	SHORT $LN3@Grow

; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jae	SHORT $LN9@Grow
	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv129[ebp], edx
	jmp	SHORT $LN10@Grow
$LN9@Grow:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR tv129[ebp], ecx
$LN10@Grow:
	mov	edx, DWORD PTR tv129[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
	jmp	SHORT $LN4@Grow
$LN3@Grow:

; 2231 : 		else if (_Newsize == 0)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $LN4@Grow

; 2232 : 			_Eos(0);	// new size is zero, just null terminate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN4@Grow:

; 2233 : 		return (0 < _Newsize);	// return true only if more work to do

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN11@Grow
	mov	DWORD PTR tv136[ebp], 1
	jmp	SHORT $LN12@Grow
$LN11@Grow:
	mov	DWORD PTR tv136[ebp], 0
$LN12@Grow:
	mov	al, BYTE PTR tv136[ebp]
$LN8@Grow:

; 2234 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [eax+16], ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 2219 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
tv205 = -48						; size = 4
tv204 = -44						; size = 4
tv203 = -40						; size = 4
tv202 = -36						; size = 4
__Ptr$ = -32						; size = 4
__Newres$ = -28						; size = 4
_this$ = -24						; size = 4
$T2 = -19						; size = 1
$T3 = -18						; size = 1
$T4 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Newres$[ebp], eax

; 2184 : 		if (max_size() < _Newres)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newres$[ebp]
	jae	SHORT $LN9@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx
	jmp	SHORT $LN8@Copy
$LN9@Copy:

; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)

	mov	eax, DWORD PTR __Newres$[ebp]
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	shr	ecx, 1
	cmp	ecx, eax
	ja	SHORT $LN7@Copy
	jmp	SHORT $LN8@Copy
$LN7@Copy:

; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+20]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, esi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], eax
	ja	SHORT $LN5@Copy

; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	shr	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR __Newres$[ebp], eax

; 2191 : 		else

	jmp	SHORT $LN8@Copy
$LN5@Copy:

; 2192 : 			_Newres = max_size();	// settle for max_size()

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	DWORD PTR __Newres$[ebp], eax
$LN8@Copy:

; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv202[ebp], eax
	mov	eax, DWORD PTR __Newres$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR tv202[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv203[ebp], eax
	mov	ecx, DWORD PTR tv203[ebp]
	mov	DWORD PTR __Ptr$[ebp], ecx
	jmp	SHORT $LN12@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2197 : 		_CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], edx

; 2199 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv204[ebp], eax
	mov	ecx, DWORD PTR __Newres$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR tv204[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv205[ebp], eax
	mov	edx, DWORD PTR tv205[ebp]
	mov	DWORD PTR __Ptr$[ebp], edx
	jmp	SHORT $LN14@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2203 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 2204 : 			_CATCH_END

	mov	eax, $LN17@Copy
	ret	0
$LN14@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2
$LN17@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2:

; 2205 : 		_CATCH_END

	mov	eax, $LN19@Copy
	ret	0
$LN12@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3
$LN19@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jbe	SHORT $LN1@Copy

; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements

	mov	eax, DWORD PTR __Oldlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Copy:

; 2210 : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);

	lea	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>

; 2212 : 		this->_Myres = _Newres;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newres$[ebp]
	mov	DWORD PTR [edx+20], eax

; 2213 : 		_Eos(_Oldlen);

	mov	ecx, DWORD PTR __Oldlen$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN11@Copy:

; 2214 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv75 = -12						; size = 4
__Num$ = -8						; size = 4
$T1 = -1						; size = 1
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1737 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1738 : 		size_type _Num = this->_Getal().max_size();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
	mov	DWORD PTR __Num$[ebp], eax

; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$[ebp], 1
	ja	SHORT $LN3@max_size
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	ecx, DWORD PTR __Num$[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv75[ebp], ecx
$LN4@max_size:
	mov	eax, DWORD PTR tv75[ebp]

; 1740 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1732 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1733 : 		return (this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]

; 1734 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$1 = -12					; size = 4
__Ptr$2 = -8						; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1317 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1318 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN4@erase

; 1319 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN4@erase:

; 1320 : 		if (this->_Mysize - _Off <= _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Off$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	ja	SHORT $LN3@erase

; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)

	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
	jmp	SHORT $LN2@erase
$LN3@erase:

; 1322 : 		else if (0 < _Count)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN2@erase

; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Ptr$2[ebp], eax

; 1325 : 			size_type _Newsize = this->_Mysize - _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Newsize$1[ebp], eax

; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	sub	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$2[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$2[ebp]
	push	eax
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 1327 : 			_Eos(_Newsize);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@erase:

; 1328 : 			}
; 1329 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN6@erase:

; 1330 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1309 : 		{	// erase elements [_Off, ...)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1310 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN1@erase

; 1311 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN1@erase:

; 1312 : 		_Eos(_Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1313 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@erase:

; 1314 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1142 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1145 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@assign

; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	jmp	SHORT $LN3@assign
$LN2@assign:

; 1132 : 
; 1133 : 		if (_Grow(_Count))

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@assign

; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1136 : 			_Eos(_Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@assign:

; 1137 : 			}
; 1138 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@assign:

; 1139 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1105 : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $LN5@assign

; 1106 : 			_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN5@assign:

; 1107 : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 1108 : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Num$[ebp]
	jae	SHORT $LN4@assign

; 1109 : 			_Num = _Count;	// trim _Num to size

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
$LN4@assign:

; 1110 : 
; 1111 : 		if (this == &_Right)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@assign

; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	mov	eax, DWORD PTR __Roff$[ebp]
	add	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	mov	ecx, DWORD PTR __Roff$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	jmp	SHORT $LN2@assign
$LN3@assign:

; 1113 : 		else if (_Grow(_Num))

	push	0
	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@assign

; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);

	mov	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1117 : 			_Eos(_Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@assign:

; 1118 : 			}
; 1119 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN7@assign:

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 791  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >

; 792  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 793  : 		assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 794  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 688  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 689  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 690  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 635  : 	_String_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >

; 636  : 		{	// construct allocator from _Al
; 637  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		{	// determine current pointer to buffer for nonmutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 522  : 		return (this->_BUF_SIZE <= this->_Myres
; 523  : 			? _STD addressof(*this->_Bx._Ptr)
; 524  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 525  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		{	// determine current pointer to buffer for mutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 515  : 		return (this->_BUF_SIZE <= this->_Myres
; 516  : 			? _STD addressof(*this->_Bx._Ptr)
; 517  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 518  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 496  : 	_String_val()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 497  : 		{	// initialize values
; 498  : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 499  : 		_Myres = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 500  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 913  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 914  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
	add	esp, 4

; 915  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 886  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 887  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate

; 888  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 875  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 877  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 830  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>

; 831  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 761  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp

; 762  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@D@std@@QBEIXZ	; std::allocator<char>::max_size

; 763  : 		}

	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

	or	eax, -1

; 629  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 590  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8

; 592  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 565  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 563  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 564  : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 565  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 551  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@move
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@move
$LN3@move:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@move:
	mov	eax, DWORD PTR tv69[ebp]

; 554  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 528  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@copy
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@copy
$LN3@copy:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@copy:
	mov	eax, DWORD PTR tv69[ebp]

; 531  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 521  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp
	push	ecx

; 522  : 		return (*_First == 0 ? 0
; 523  : 			: _CSTD strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@length
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN4@length
$LN3@length:
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR tv68[ebp], eax
$LN4@length:
	mov	eax, DWORD PTR tv68[ebp]

; 524  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 65   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 60   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 61   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ PROC	; VuEntity::EntityType, COMDAT
; _this$ = ecx

; 176  : 	VuEntityType *EntityType() const { return const_cast<VuEntityType*>(entityTypePtr_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+112]
	mov	esp, ebp
	pop	ebp
	ret	0
?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ ENDP	; VuEntity::EntityType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Id@VuEntity@@QBE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?Id@VuEntity@@QBE?AVVU_ID@@XZ PROC			; VuEntity::Id, COMDAT
; _this$ = ecx

; 131  : 	VU_ID Id() const	{ return share_.id_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?Id@VuEntity@@QBE?AVVU_ID@@XZ ENDP			; VuEntity::Id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
_TEXT	SEGMENT
_x$ = 8							; size = 4
?FloatToInt32@@YAHM@Z PROC				; FloatToInt32

; 179  : {

	push	ebp
	mov	ebp, esp

; 180  : #if WIN32
; 181  :   __asm {
; 182  :     fld dword ptr [x];

	fld	DWORD PTR _x$[ebp]

; 183  :     fistp dword ptr [x];

	fistp	DWORD PTR _x$[ebp]

; 184  :     mov eax,dword ptr [x];

	mov	eax, DWORD PTR _x$[ebp]

; 185  :   }
; 186  : #else 
; 187  : 	return static_cast<int>(x);	
; 188  : #endif
; 189  : }

	pop	ebp
	ret	0
?FloatToInt32@@YAHM@Z ENDP				; FloatToInt32
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?fabs@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?fabs@@YAMM@Z PROC					; fabs, COMDAT

; 517  :         {return (fabsf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_fabsf
	add	esp, 4
	pop	ebp
	ret	0
?fabs@@YAMM@Z ENDP					; fabs
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_fabsf	PROC						; COMDAT

; 392  :         {return ((float)fabs((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_fabsf	ENDP
_TEXT	ENDS
END
