; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\SIM\BOMB\LAU.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
PUBLIC	?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ	; VuEntity::EntityType
PUBLIC	?IsLauncher@BombClass@@UAEHXZ			; BombClass::IsLauncher
PUBLIC	?LauInit@BombClass@@QAEXXZ			; BombClass::LauInit
PUBLIC	?LauGetSalvoSize@BombClass@@QAEHXZ		; BombClass::LauGetSalvoSize
PUBLIC	?LauGetAttitude@BombClass@@QAEXAAM0@Z		; BombClass::LauGetAttitude
PUBLIC	?LauGetRoundsRemaining@BombClass@@QAEHXZ	; BombClass::LauGetRoundsRemaining
PUBLIC	?LauSetRoundsRemaining@BombClass@@QAEXH@Z	; BombClass::LauSetRoundsRemaining
PUBLIC	?LauAddRounds@BombClass@@QAEXH@Z		; BombClass::LauAddRounds
PUBLIC	?LauGetMaxRounds@BombClass@@QAEHXZ		; BombClass::LauGetMaxRounds
PUBLIC	?LauGetWeaponId@BombClass@@QAEHXZ		; BombClass::LauGetWeaponId
PUBLIC	?LauCheckTimer@BombClass@@QAEHXZ		; BombClass::LauCheckTimer
PUBLIC	?LauFireSalvo@BombClass@@QAEXXZ			; BombClass::LauFireSalvo
PUBLIC	?LauIsFiring@BombClass@@QAEHXZ			; BombClass::LauIsFiring
PUBLIC	?LauRemFiredRound@BombClass@@QAEXXZ		; BombClass::LauRemFiredRound
PUBLIC	__real@00000000
EXTRN	?SimLibElapsedTime@@3KA:DWORD			; SimLibElapsedTime
EXTRN	?WeaponDataTable@@3PAUWeaponClassDataType@@A:DWORD ; WeaponDataTable
EXTRN	?SimWeaponDataTable@@3PAUSimWeaponDataType@@A:DWORD ; SimWeaponDataTable
EXTRN	?RocketDataTable@@3PAURocketClassDataType@@A:DWORD ; RocketDataTable
EXTRN	?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A:DWORD ; Falcon4ClassTable
EXTRN	?NumRocketTypes@@3FA:WORD			; NumRocketTypes
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
_allocator_arg DB 01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\bomb\lau.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?LauRemFiredRound@BombClass@@QAEXXZ PROC		; BombClass::LauRemFiredRound
; _this$ = ecx

; 117  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 118  : 	lauRounds --;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+804]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+804], ecx

; 119  : 	lauFireCount --;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+820]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+820], ecx

; 120  : 
; 121  : 	if(lauRounds < 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+804], 0
	jge	SHORT $LN2@LauRemFire

; 122  : 		lauRounds = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+804], 0
$LN2@LauRemFire:

; 123  : 	if(lauFireCount < 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+820], 0
	jge	SHORT $LN3@LauRemFire

; 124  : 		lauFireCount = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+820], 0
$LN3@LauRemFire:

; 125  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?LauRemFiredRound@BombClass@@QAEXXZ ENDP		; BombClass::LauRemFiredRound
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\bomb\lau.cpp
_TEXT	SEGMENT
tv68 = -8						; size = 4
_this$ = -4						; size = 4
?LauIsFiring@BombClass@@QAEHXZ PROC			; BombClass::LauIsFiring
; _this$ = ecx

; 185  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 186  : 	return( lauRounds>0 && lauFireCount>0 );

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+804], 0
	jle	SHORT $LN3@LauIsFirin
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+820], 0
	jle	SHORT $LN3@LauIsFirin
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@LauIsFirin
$LN3@LauIsFirin:
	mov	DWORD PTR tv68[ebp], 0
$LN4@LauIsFirin:
	mov	eax, DWORD PTR tv68[ebp]

; 187  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?LauIsFiring@BombClass@@QAEHXZ ENDP			; BombClass::LauIsFiring
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\bomb\lau.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?LauFireSalvo@BombClass@@QAEXXZ PROC			; BombClass::LauFireSalvo
; _this$ = ecx

; 173  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 174  : 	if(auxData->lauSalvoSize>0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+832]
	cmp	DWORD PTR [ecx+32], 0
	jle	SHORT $LN3@LauFireSal

; 175  : 	{
; 176  : 		lauFireCount += auxData->lauSalvoSize;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+832]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+820]
	add	edx, DWORD PTR [eax+32]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+820], edx

; 177  : 		if(lauFireCount > lauRounds)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+820]
	cmp	eax, DWORD PTR [edx+804]
	jle	SHORT $LN2@LauFireSal

; 178  : 			lauFireCount = lauRounds;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+804]
	mov	DWORD PTR [ecx+820], eax
$LN2@LauFireSal:

; 179  : 	}
; 180  : 	else

	jmp	SHORT $LN4@LauFireSal
$LN3@LauFireSal:

; 181  : 		lauFireCount = lauRounds;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+804]
	mov	DWORD PTR [ecx+820], eax
$LN4@LauFireSal:

; 182  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?LauFireSalvo@BombClass@@QAEXXZ ENDP			; BombClass::LauFireSalvo
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\bomb\lau.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?LauCheckTimer@BombClass@@QAEHXZ PROC			; BombClass::LauCheckTimer
; _this$ = ecx

; 163  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 164  : 	if(lauTimer <= SimLibElapsedTime)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+824]
	cmp	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	ja	SHORT $LN1@LauCheckTi

; 165  : 	{
; 166  : 		lauTimer=SimLibElapsedTime + auxData->lauRippleTime; 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+832]
	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+824], ecx

; 167  : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN2@LauCheckTi
$LN1@LauCheckTi:

; 168  : 	}
; 169  : 	return 0;

	xor	eax, eax
$LN2@LauCheckTi:

; 170  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?LauCheckTimer@BombClass@@QAEHXZ ENDP			; BombClass::LauCheckTimer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\bomb\lau.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?LauGetWeaponId@BombClass@@QAEHXZ PROC			; BombClass::LauGetWeaponId
; _this$ = ecx

; 94   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 95   : 	return(lauWeaponId);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+812]

; 96   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?LauGetWeaponId@BombClass@@QAEHXZ ENDP			; BombClass::LauGetWeaponId
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\bomb\lau.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?LauGetMaxRounds@BombClass@@QAEHXZ PROC			; BombClass::LauGetMaxRounds
; _this$ = ecx

; 135  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 136  : 	return lauMaxRounds;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+808]

; 137  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?LauGetMaxRounds@BombClass@@QAEHXZ ENDP			; BombClass::LauGetMaxRounds
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\bomb\lau.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_count$ = 8						; size = 4
?LauAddRounds@BombClass@@QAEXH@Z PROC			; BombClass::LauAddRounds
; _this$ = ecx

; 107  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 108  : 	lauRounds += count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+804]
	add	ecx, DWORD PTR _count$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+804], ecx

; 109  : 	if(lauRounds > lauMaxRounds)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+804]
	cmp	edx, DWORD PTR [ecx+808]
	jle	SHORT $LN3@LauAddRoun

; 110  : 		lauRounds = lauMaxRounds;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	mov	DWORD PTR [eax+804], edx

; 111  : 	else

	jmp	SHORT $LN4@LauAddRoun
$LN3@LauAddRoun:

; 112  : 		if(lauRounds < 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+804], 0
	jge	SHORT $LN4@LauAddRoun

; 113  : 			lauRounds = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+804], 0
$LN4@LauAddRoun:

; 114  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?LauAddRounds@BombClass@@QAEXH@Z ENDP			; BombClass::LauAddRounds
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\bomb\lau.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_r$ = 8							; size = 4
?LauSetRoundsRemaining@BombClass@@QAEXH@Z PROC		; BombClass::LauSetRoundsRemaining
; _this$ = ecx

; 99   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 100  : 	if(r < lauMaxRounds)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _r$[ebp]
	cmp	ecx, DWORD PTR [eax+808]
	jge	SHORT $LN2@LauSetRoun

; 101  : 		lauRounds = r;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _r$[ebp]
	mov	DWORD PTR [edx+804], eax

; 102  : 	else

	jmp	SHORT $LN3@LauSetRoun
$LN2@LauSetRoun:

; 103  : 		lauRounds = lauMaxRounds;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	mov	DWORD PTR [ecx+804], eax
$LN3@LauSetRoun:

; 104  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?LauSetRoundsRemaining@BombClass@@QAEXH@Z ENDP		; BombClass::LauSetRoundsRemaining
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\bomb\lau.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?LauGetRoundsRemaining@BombClass@@QAEHXZ PROC		; BombClass::LauGetRoundsRemaining
; _this$ = ecx

; 130  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 131  : 	return lauRounds - lauFireCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+804]
	sub	eax, DWORD PTR [ecx+820]

; 132  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?LauGetRoundsRemaining@BombClass@@QAEHXZ ENDP		; BombClass::LauGetRoundsRemaining
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\bomb\lau.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elevation$ = 8						; size = 4
_azimuth$ = 12						; size = 4
?LauGetAttitude@BombClass@@QAEXAAM0@Z PROC		; BombClass::LauGetAttitude
; _this$ = ecx

; 149  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 150  : 	if(auxData)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+832], 0
	je	SHORT $LN2@LauGetAtti

; 151  : 	{
; 152  : 		elevation = auxData->lauElevation;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+832]
	mov	eax, DWORD PTR _elevation$[ebp]
	mov	ecx, DWORD PTR [edx+24]
	mov	DWORD PTR [eax], ecx

; 153  : 		azimuth   = auxData->lauAzimuth;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+832]
	mov	ecx, DWORD PTR _azimuth$[ebp]
	mov	edx, DWORD PTR [eax+28]
	mov	DWORD PTR [ecx], edx

; 154  : 	}
; 155  : 	else

	jmp	SHORT $LN1@LauGetAtti
$LN2@LauGetAtti:

; 156  : 	{
; 157  : 		elevation = 0;

	mov	eax, DWORD PTR _elevation$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax], xmm0

; 158  : 		azimuth   = 0;

	mov	ecx, DWORD PTR _azimuth$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx], xmm0
$LN1@LauGetAtti:

; 159  : 	}
; 160  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?LauGetAttitude@BombClass@@QAEXAAM0@Z ENDP		; BombClass::LauGetAttitude
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\bomb\lau.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?LauGetSalvoSize@BombClass@@QAEHXZ PROC			; BombClass::LauGetSalvoSize
; _this$ = ecx

; 140  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 141  : 	if(auxData)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+832], 0
	je	SHORT $LN1@LauGetSalv

; 142  : 	{
; 143  : 		return auxData->lauSalvoSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+832]
	mov	eax, DWORD PTR [edx+32]
	jmp	SHORT $LN2@LauGetSalv
$LN1@LauGetSalv:

; 144  : 	}
; 145  : 	return -1;

	or	eax, -1
$LN2@LauGetSalv:

; 146  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?LauGetSalvoSize@BombClass@@QAEHXZ ENDP			; BombClass::LauGetSalvoSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\bomb\lau.cpp
_TEXT	SEGMENT
_entryfound$1 = -28					; size = 4
_lauId$ = -24						; size = 4
_wpnDefinition$ = -20					; size = 4
_wc$ = -16						; size = 4
_classPtr$ = -12					; size = 4
_j$2 = -8						; size = 4
_this$ = -4						; size = 4
?LauInit@BombClass@@QAEXXZ PROC				; BombClass::LauInit
; _this$ = ecx

; 14   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 15   : 	Falcon4EntityClassType* classPtr;
; 16   : 	WeaponClassDataType* wc;
; 17   : 	SimWeaponDataType* wpnDefinition;
; 18   : 	int lauId;
; 19   : 
; 20   : 	lauFireCount = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+820], 0

; 21   : 
; 22   : 	classPtr = (Falcon4EntityClassType*)EntityType();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ ; VuEntity::EntityType
	mov	DWORD PTR _classPtr$[ebp], eax

; 23   : 	wc = (WeaponClassDataType*)classPtr->dataPtr;

	mov	ecx, DWORD PTR _classPtr$[ebp]
	mov	edx, DWORD PTR [ecx+77]
	mov	DWORD PTR _wc$[ebp], edx

; 24   : 	wpnDefinition = &SimWeaponDataTable[classPtr->vehicleDataIndex];

	mov	eax, DWORD PTR _classPtr$[ebp]
	movsx	ecx, WORD PTR [eax+74]
	imul	ecx, 52					; 00000034H
	add	ecx, DWORD PTR ?SimWeaponDataTable@@3PAUSimWeaponDataType@@A ; SimWeaponDataTable
	mov	DWORD PTR _wpnDefinition$[ebp], ecx

; 25   : 	lauId = (short)(((int)Falcon4ClassTable[wc->Index].dataPtr - (int)WeaponDataTable) / sizeof(WeaponClassDataType));

	mov	edx, DWORD PTR _wc$[ebp]
	movsx	eax, WORD PTR [edx]
	imul	eax, 81					; 00000051H
	mov	ecx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	eax, DWORD PTR [ecx+eax+77]
	sub	eax, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	xor	edx, edx
	mov	ecx, 60					; 0000003cH
	div	ecx
	movsx	edx, ax
	mov	DWORD PTR _lauId$[ebp], edx

; 26   : 
; 27   : 	if(wpnDefinition->weaponClass == wcRocketWpn)

	mov	eax, DWORD PTR _wpnDefinition$[ebp]
	cmp	DWORD PTR [eax+36], 1
	jne	$LN9@LauInit

; 28   : 	{
; 29   : 
; 30   : 		if(auxData && auxData->lauWeaponId)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+832], 0
	je	SHORT $LN8@LauInit
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+832]
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $LN8@LauInit

; 31   : 		{
; 32   : 			lauRounds    = lauMaxRounds = auxData->lauRounds;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+832]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+808], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	mov	DWORD PTR [edx+804], ecx

; 33   : 			lauWeaponId  = auxData->lauWeaponId;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+832]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+40]
	mov	DWORD PTR [ecx+812], edx

; 34   : 			lauSalvoSize = auxData->lauSalvoSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+832]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+32]
	mov	DWORD PTR [edx+816], eax

; 35   : 		}
; 36   : 		else

	jmp	$LN7@LauInit
$LN8@LauInit:

; 37   : 		{
; 38   : 			int j;
; 39   : 			int entryfound = 0;

	mov	DWORD PTR _entryfound$1[ebp], 0

; 40   : 			// read the rack dat file
; 41   : 			for (j=0; j<NumRocketTypes; j++)

	mov	DWORD PTR _j$2[ebp], 0
	jmp	SHORT $LN6@LauInit
$LN5@LauInit:
	mov	ecx, DWORD PTR _j$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$2[ebp], ecx
$LN6@LauInit:
	movsx	edx, WORD PTR ?NumRocketTypes@@3FA	; NumRocketTypes
	cmp	DWORD PTR _j$2[ebp], edx
	jge	$LN7@LauInit

; 42   : 			{
; 43   : 				if (lauId == RocketDataTable[j].weaponId)

	mov	eax, DWORD PTR _j$2[ebp]
	imul	eax, 6
	mov	ecx, DWORD PTR ?RocketDataTable@@3PAURocketClassDataType@@A ; RocketDataTable
	movsx	edx, WORD PTR [ecx+eax]
	cmp	DWORD PTR _lauId$[ebp], edx
	jne	SHORT $LN3@LauInit

; 44   : 				{
; 45   : 					if (RocketDataTable[j].nweaponId) // 0 = don't change weapon ID

	mov	eax, DWORD PTR _j$2[ebp]
	imul	eax, 6
	mov	ecx, DWORD PTR ?RocketDataTable@@3PAURocketClassDataType@@A ; RocketDataTable
	movsx	edx, WORD PTR [ecx+eax+2]
	test	edx, edx
	je	SHORT $LN2@LauInit

; 46   : 						lauWeaponId  = RocketDataTable[j].nweaponId;

	mov	eax, DWORD PTR _j$2[ebp]
	imul	eax, 6
	mov	ecx, DWORD PTR ?RocketDataTable@@3PAURocketClassDataType@@A ; RocketDataTable
	movsx	edx, WORD PTR [ecx+eax+2]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+812], edx
$LN2@LauInit:

; 47   : 					lauMaxRounds = RocketDataTable[j].weaponCount; 

	mov	ecx, DWORD PTR _j$2[ebp]
	imul	ecx, 6
	mov	edx, DWORD PTR ?RocketDataTable@@3PAURocketClassDataType@@A ; RocketDataTable
	movsx	eax, WORD PTR [edx+ecx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+808], eax

; 48   : 					lauRounds    = lauMaxRounds;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	mov	DWORD PTR [edx+804], ecx

; 49   : 					lauSalvoSize = lauRounds;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+804]
	mov	DWORD PTR [edx+816], ecx

; 50   : 
; 51   : 
; 52   : 					/*
; 53   : 					WeaponClass weapClass = (WeaponClass)SimWeaponDataTable[Falcon4ClassTable[WeaponDataTable[lauWeaponId].Index].vehicleDataIndex].weaponClass;  // MLR 1/28/2004 - hardPoint[i]->GetWeaponClass() is not correct
; 54   : 
; 55   : 					if(weapClass==wcGunWpn)
; 56   : 					{
; 57   : 						hardPoint[i]->weaponPointer = InitAGun (newOwnship, hardPoint[i]->weaponId, hardPoint[i]->weaponCount);
; 58   : 					}
; 59   : 					else
; 60   : 					{
; 61   : 						hardPoint[i]->weaponPointer = InitWeaponList (newOwnship, hardPoint[i]->weaponId,
; 62   : 							hardPoint[i]->GetWeaponClass(), hardPoint[i]->weaponCount, InitAMissile);
; 63   : 					}
; 64   : 					*/
; 65   : 
; 66   : 					entryfound = 1;

	mov	DWORD PTR _entryfound$1[ebp], 1

; 67   : 					break;

	jmp	SHORT $LN7@LauInit
$LN3@LauInit:

; 68   : 				}
; 69   : 			}

	jmp	$LN5@LauInit
$LN7@LauInit:

; 70   : 			/*
; 71   : 			if (!entryfound)	// use generic 2.75mm rocket
; 72   : 			{
; 73   : 				lauWeaponId  = gRocketId;
; 74   : 				lauMaxRounds = 19; 
; 75   : 				lauRounds    = lauMaxRounds;
; 76   : 				lauSalvoSize = lauRounds;
; 77   : 			}*/
; 78   : 		}
; 79   : 	}
; 80   : 	else

	jmp	SHORT $LN10@LauInit
$LN9@LauInit:

; 81   : 	{
; 82   : 		lauWeaponId=0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+812], 0
$LN10@LauInit:

; 83   : 	}
; 84   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?LauInit@BombClass@@QAEXXZ ENDP				; BombClass::LauInit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\bomb\lau.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsLauncher@BombClass@@UAEHXZ PROC			; BombClass::IsLauncher
; _this$ = ecx

; 87   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 88   : 	if(lauWeaponId)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+812], 0
	je	SHORT $LN1@IsLauncher

; 89   : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN2@IsLauncher
$LN1@IsLauncher:

; 90   : 	return 0;

	xor	eax, eax
$LN2@IsLauncher:

; 91   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsLauncher@BombClass@@UAEHXZ ENDP			; BombClass::IsLauncher
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ PROC	; VuEntity::EntityType, COMDAT
; _this$ = ecx

; 176  : 	VuEntityType *EntityType() const { return const_cast<VuEntityType*>(entityTypePtr_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+112]
	mov	esp, ebp
	pop	ebp
	ret	0
?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ ENDP	; VuEntity::EntityType
_TEXT	ENDS
END
