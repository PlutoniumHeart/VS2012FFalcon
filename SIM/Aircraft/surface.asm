; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\SIM\Aircraft\surface.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?ComplexGearDOF@@3PAHA				; ComplexGearDOF
PUBLIC	?ComplexGearDoorDOF@@3PAHA			; ComplexGearDoorDOF
PUBLIC	?ComplexGearSwitch@@3PAHA			; ComplexGearSwitch
PUBLIC	?ComplexGearDoorSwitch@@3PAHA			; ComplexGearDoorSwitch
PUBLIC	?ComplexGearHoleSwitch@@3PAHA			; ComplexGearHoleSwitch
PUBLIC	?ComplexGearBrokenSwitch@@3PAHA			; ComplexGearBrokenSwitch
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B ; std::ios_base::failure::_Stream_err
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
_BSS	SEGMENT
_stallShake DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B
CONST	SEGMENT
?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B DD 01H ; std::ios_base::failure::_Stream_err
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
_DATA	SEGMENT
_matrix33_ident DD 03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
?ComplexGearDOF@@3PAHA DD 013H				; ComplexGearDOF
	DD	014H
	DD	015H
	DD	044H
	DD	045H
	DD	046H
	DD	047H
	DD	048H
?ComplexGearDoorDOF@@3PAHA DD 016H			; ComplexGearDoorDOF
	DD	017H
	DD	018H
	DD	049H
	DD	04aH
	DD	04bH
	DD	04cH
	DD	04dH
?ComplexGearSwitch@@3PAHA DD 01H			; ComplexGearSwitch
	DD	02H
	DD	03H
	DD	020H
	DD	021H
	DD	022H
	DD	023H
	DD	024H
?ComplexGearDoorSwitch@@3PAHA DD 0eH			; ComplexGearDoorSwitch
	DD	0fH
	DD	010H
	DD	025H
	DD	026H
	DD	027H
	DD	028H
	DD	029H
?ComplexGearHoleSwitch@@3PAHA DD 011H			; ComplexGearHoleSwitch
	DD	012H
	DD	013H
	DD	02aH
	DD	02bH
	DD	02cH
	DD	02dH
	DD	02eH
?ComplexGearBrokenSwitch@@3PAHA DD 014H			; ComplexGearBrokenSwitch
	DD	015H
	DD	016H
	DD	030H
	DD	031H
	DD	032H
	DD	033H
	DD	034H
	ORG $+4
_matrix44_ident DD 03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
_DATA	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
PUBLIC	_fabsf
PUBLIC	_fmodf
PUBLIC	?fabs@@YAMM@Z					; fabs
PUBLIC	?fmod@@YAMMM@Z					; fmod
PUBLIC	?Id@VuEntity@@QBE?AVVU_ID@@XZ			; VuEntity::Id
PUBLIC	?Type@VuEntity@@QBEGXZ				; VuEntity::Type
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	?IsSetFalcFlag@FalconEntity@@QAEHH@Z		; FalconEntity::IsSetFalcFlag
PUBLIC	?IsPlayer@FalconEntity@@QAEHXZ			; FalconEntity::IsPlayer
PUBLIC	?IsSetFlag@SimBaseClass@@QBEHH@Z		; SimBaseClass::IsSetFlag
PUBLIC	?SetDOF@SimMoverClass@@QAEXHM@Z			; SimMoverClass::SetDOF
PUBLIC	?GetDOFValue@SimMoverClass@@QAEMH@Z		; SimMoverClass::GetDOFValue
PUBLIC	?SetSwitch@SimMoverClass@@QAEXHH@Z		; SimMoverClass::SetSwitch
PUBLIC	?GetSwitch@SimMoverClass@@QAEHH@Z		; SimMoverClass::GetSwitch
PUBLIC	?IsAcStatusBitsSet@AircraftClass@@QBE_NH@Z	; AircraftClass::IsAcStatusBitsSet
PUBLIC	?ExtlState@AircraftClass@@QBEHW4ExtlLightFlags@1@@Z ; AircraftClass::ExtlState
PUBLIC	?LEFState@AircraftClass@@QAEHW4LEFStateFlags@1@@Z ; AircraftClass::LEFState
PUBLIC	?CheckLEF@AircraftClass@@QAEMH@Z		; AircraftClass::CheckLEF
PUBLIC	?CopyAnimationsToPit@AircraftClass@@QAEXPAVDrawableBSP@@@Z ; AircraftClass::CopyAnimationsToPit
PUBLIC	?AutopilotType@AircraftClass@@QAE?AW4AutoPilotType@1@XZ ; AircraftClass::AutopilotType
PUBLIC	?IsComplex@AircraftClass@@QAEHXZ		; AircraftClass::IsComplex
PUBLIC	?MoveSurfaces@AircraftClass@@QAEXXZ		; AircraftClass::MoveSurfaces
PUBLIC	?RunLightSurfaces@AircraftClass@@QAEXXZ		; AircraftClass::RunLightSurfaces
PUBLIC	?RunGearSurfaces@AircraftClass@@QAEXXZ		; AircraftClass::RunGearSurfaces
PUBLIC	?CalculateSweepAndSpoiler@AircraftClass@@QAEXAAM0000@Z ; AircraftClass::CalculateSweepAndSpoiler
PUBLIC	?CalculateAileronAndFlap@AircraftClass@@AAEXMPAM000@Z ; AircraftClass::CalculateAileronAndFlap
PUBLIC	?CalculateLef@AircraftClass@@AAEXM@Z		; AircraftClass::CalculateLef
PUBLIC	?CalculateStab@AircraftClass@@AAEXMPAM0@Z	; AircraftClass::CalculateStab
PUBLIC	?CalculateRudder@AircraftClass@@AAEMM@Z		; AircraftClass::CalculateRudder
PUBLIC	?MoveDof@AircraftClass@@AAEXHMMHHH@Z		; AircraftClass::MoveDof
PUBLIC	?DeployDragChute@AircraftClass@@AAEXH@Z		; AircraftClass::DeployDragChute
PUBLIC	?GetHpDofType@AirframeClass@@QAEHH@Z		; AirframeClass::GetHpDofType
PUBLIC	?GetHpDofRate@AirframeClass@@QAEMH@Z		; AirframeClass::GetHpDofRate
PUBLIC	?GetGunSwitchType@AirframeClass@@QAEHXZ		; AirframeClass::GetGunSwitchType
PUBLIC	?GetGunDofType@AirframeClass@@QAEHXZ		; AirframeClass::GetGunDofType
PUBLIC	?GetGunDofRate@AirframeClass@@QAEMXZ		; AirframeClass::GetGunDofRate
PUBLIC	?IsEngineFlag@AirframeClass@@QAEHW4EngineFlags@1@@Z ; AirframeClass::IsEngineFlag
PUBLIC	?Throtl@AirframeClass@@QAEMXZ			; AirframeClass::Throtl
PUBLIC	?NumGear@AirframeClass@@QBEHXZ			; AirframeClass::NumGear
PUBLIC	?GetAeroData@AirframeClass@@QBEMH@Z		; AirframeClass::GetAeroData
PUBLIC	?IsSet@AirframeClass@@QBEHH@Z			; AirframeClass::IsSet
PUBLIC	?GetSimpleMode@AirframeClass@@QAEHXZ		; AirframeClass::GetSimpleMode
PUBLIC	?IsRecording@ACMIRecorder@@QAEHXZ		; ACMIRecorder::IsRecording
PUBLIC	??0id@locale@std@@QAE@I@Z			; std::locale::id::id
PUBLIC	?generic_category@std@@YAABVerror_category@1@XZ	; std::generic_category
PUBLIC	?system_category@std@@YAABVerror_category@1@XZ	; std::system_category
PUBLIC	??0error_category@std@@QAE@XZ			; std::error_category::error_category
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??8error_category@std@@QBE_NABV01@@Z		; std::error_category::operator==
PUBLIC	??_Gerror_category@std@@UAEPAXI@Z		; std::error_category::`scalar deleting destructor'
PUBLIC	?value@error_code@std@@QBEHXZ			; std::error_code::value
PUBLIC	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
PUBLIC	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?value@error_condition@std@@QBEHXZ		; std::error_condition::value
PUBLIC	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
PUBLIC	??8error_condition@std@@QBE_NABV01@@Z		; std::error_condition::operator==
PUBLIC	??0_Generic_error_category@std@@QAE@XZ		; std::_Generic_error_category::_Generic_error_category
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	??1_Generic_error_category@std@@UAE@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	??0_Iostream_error_category@std@@QAE@XZ		; std::_Iostream_error_category::_Iostream_error_category
PUBLIC	?name@_Iostream_error_category@std@@UBEPBDXZ	; std::_Iostream_error_category::name
PUBLIC	?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	??1_Iostream_error_category@std@@UAE@XZ		; std::_Iostream_error_category::~_Iostream_error_category
PUBLIC	??_G_Iostream_error_category@std@@UAEPAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	??0_System_error_category@std@@QAE@XZ		; std::_System_error_category::_System_error_category
PUBLIC	?name@_System_error_category@std@@UBEPBDXZ	; std::_System_error_category::name
PUBLIC	?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message
PUBLIC	?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition
PUBLIC	??1_System_error_category@std@@UAE@XZ		; std::_System_error_category::~_System_error_category
PUBLIC	??_G_System_error_category@std@@UAEPAXI@Z	; std::_System_error_category::`scalar deleting destructor'
PUBLIC	?Get3dTrackIR@PlayerOptionsClass@@QBE_NXZ	; PlayerOptionsClass::Get3dTrackIR
PUBLIC	?GetPlayerEntity@SimulationDriver@@QBEPAVSimMoverClass@@XZ ; SimulationDriver::GetPlayerEntity
PUBLIC	?AnalogIsUsed@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z ; SIMLIB_IO_CLASS::AnalogIsUsed
PUBLIC	?GetNumDOFs@DrawableBSP@@QAEHXZ			; DrawableBSP::GetNumDOFs
PUBLIC	?GetNumSwitches@DrawableBSP@@QAEHXZ		; DrawableBSP::GetNumSwitches
PUBLIC	?GenerateFastRandom@@YAJXZ			; GenerateFastRandom
PUBLIC	?PRANDFloatPos@@YAMXZ				; PRANDFloatPos
PUBLIC	?NumHardpoints@SMSBaseClass@@QAEHXZ		; SMSBaseClass::NumHardpoints
PUBLIC	?CurHardpoint@SMSBaseClass@@QAEHXZ		; SMSBaseClass::CurHardpoint
PUBLIC	?getYaw@TrackIR@@QAEMXZ				; TrackIR::getYaw
PUBLIC	?getPitch@TrackIR@@QAEMXZ			; TrackIR::getPitch
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??_7error_category@std@@6B@			; std::error_category::`vftable'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_C@_07DCLBNMLN@generic?$AA@			; `string'
PUBLIC	??_C@_0O@BFJCFAAK@unknown?5error?$AA@		; `string'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream?$AA@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	; `string'
PUBLIC	??_7_System_error_category@std@@6B@		; std::_System_error_category::`vftable'
PUBLIC	??_C@_06FHFOAHML@system?$AA@			; `string'
PUBLIC	?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
PUBLIC	?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
PUBLIC	?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
PUBLIC	?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
PUBLIC	?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
PUBLIC	?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA	; `GenerateFastRandom'::`2'::LastRandom
PUBLIC	??_C@_0BI@MOPJIONH@animSwingWingStages?5?$CFd?6?$AA@ ; `string'
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	?id@?$numpunct@_W@std@@2V0locale@2@A		; std::numpunct<wchar_t>::id
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_R4error_category@std@@6B@			; std::error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error_category@std@@6B@		; std::_System_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_System_error_category@std@@@8		; std::_System_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_System_error_category@std@@8		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error_category@std@@8		; std::_System_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error_category@std@@8	; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@3a83126f
PUBLIC	__real@3c8efa34
PUBLIC	__real@3da3d70a
PUBLIC	__real@3db2b8c1
PUBLIC	__real@3dcccccd
PUBLIC	__real@3e4ccccd
PUBLIC	__real@3eb2b8c1
PUBLIC	__real@3ecccccd
PUBLIC	__real@3f000000
PUBLIC	__real@3f19999a
PUBLIC	__real@3f32b8c1
PUBLIC	__real@3f333333
PUBLIC	__real@3f4ccccd
PUBLIC	__real@3f666666
PUBLIC	__real@3f800000
PUBLIC	__real@3f9c61a9
PUBLIC	__real@3fb2b8c1
PUBLIC	__real@3fc00000
PUBLIC	__real@3fc90fd9
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@40000000
PUBLIC	__real@40800000
PUBLIC	__real@40a00000
PUBLIC	__real@40c90fd9
PUBLIC	__real@40c90fdb
PUBLIC	__real@41555532
PUBLIC	__real@41700000
PUBLIC	__real@41900000
PUBLIC	__real@41a00000
PUBLIC	__real@41fb53cf
PUBLIC	__real@42040000
PUBLIC	__real@42480000
PUBLIC	__real@42c80000
PUBLIC	__real@42f00000
PUBLIC	__real@430706e2
PUBLIC	__real@43690000
PUBLIC	__real@438706e2
PUBLIC	__real@43b40000
PUBLIC	__real@44160000
PUBLIC	__real@447a0000
PUBLIC	__real@476a6000
PUBLIC	__real@477fff00
PUBLIC	__real@bdcccccd
PUBLIC	__real@be32b8c1
PUBLIC	__real@beb2b8c1
PUBLIC	__real@bf060a91
PUBLIC	__real@bf32b8c1
PUBLIC	__real@bf490fd9
PUBLIC	__real@bf800000
PUBLIC	__real@bf9c61a9
PUBLIC	__real@bfb2b8c1
PUBLIC	__real@bfc90fd9
PUBLIC	__xmm@41f00000000000000000000000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	_fabs:PROC
EXTRN	_fmod:PROC
EXTRN	_rand:PROC
EXTRN	_memcpy:PROC
EXTRN	_strlen:PROC
EXTRN	_memmove:PROC
EXTRN	_MonoPrint:PROC
EXTRN	?IsLocal@VuEntity@@QBEEXZ:PROC			; VuEntity::IsLocal
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	?Sfx@F4SoundPos@@QAEXHHMM@Z:PROC		; F4SoundPos::Sfx
EXTRN	?IsPlaying@F4SoundPos@@QAE_NHH@Z:PROC		; F4SoundPos::IsPlaying
EXTRN	?SetFlag@SimBaseClass@@QAEXH@Z:PROC		; SimBaseClass::SetFlag
EXTRN	?UnSetFlag@SimBaseClass@@QAEXH@Z:PROC		; SimBaseClass::UnSetFlag
EXTRN	?SetAcStatusBits@AircraftClass@@QAEXH@Z:PROC	; AircraftClass::SetAcStatusBits
EXTRN	?ClearAcStatusBits@AircraftClass@@QAEXH@Z:PROC	; AircraftClass::ClearAcStatusBits
EXTRN	?Lookup@TwoDimensionTable@@QAEMMM@Z:PROC	; TwoDimensionTable::Lookup
EXTRN	?LEFClose@AirframeClass@@QAEXXZ:PROC		; AirframeClass::LEFClose
EXTRN	?LEFMax@AirframeClass@@QAEXXZ:PROC		; AirframeClass::LEFMax
EXTRN	?Add@ACMI_Hash@@QAEJVVU_ID@@PADJ@Z:PROC		; ACMI_Hash::Add
EXTRN	?SwitchRecord@ACMIRecorder@@QAEXPAUACMISwitchRecord@@@Z:PROC ; ACMIRecorder::SwitchRecord
EXTRN	?DOFRecord@ACMIRecorder@@QAEXPAUACMIDOFRecord@@@Z:PROC ; ACMIRecorder::DOFRecord
EXTRN	??_Eerror_category@std@@UAEPAXI@Z:PROC		; std::error_category::`vector deleting destructor'
EXTRN	?_Syserror_map@std@@YAPBDH@Z:PROC		; std::_Syserror_map
EXTRN	?_Winerror_map@std@@YAPBDH@Z:PROC		; std::_Winerror_map
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_E_System_error_category@std@@UAEPAXI@Z:PROC	; std::_System_error_category::`vector deleting destructor'
EXTRN	?GetOTWDisplayMode@OTWDriverClass@@QAE?AW4OTWDisplayMode@1@XZ:PROC ; OTWDriverClass::GetOTWDisplayMode
EXTRN	?JoystickPlayEffect@@YAHHH@Z:PROC		; JoystickPlayEffect
EXTRN	?JoystickStopEffect@@YAXH@Z:PROC		; JoystickStopEffect
EXTRN	?SetDOFangle@DrawableBSP@@QAEXHM@Z:PROC		; DrawableBSP::SetDOFangle
EXTRN	?SetSwitchMask@DrawableBSP@@QAEXHK@Z:PROC	; DrawableBSP::SetSwitchMask
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	?SimLibMajorFrameTime@@3MA:DWORD		; SimLibMajorFrameTime
EXTRN	?SimLibElapsedTime@@3KA:DWORD			; SimLibElapsedTime
EXTRN	?aeroDataset@@3PAVAeroDataSet@@A:DWORD		; aeroDataset
EXTRN	?gACMIRec@@3VACMIRecorder@@A:BYTE		; gACMIRec
EXTRN	?ACMIIDTable@@3PAVACMI_Hash@@A:DWORD		; ACMIIDTable
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?PlayerOptions@@3VPlayerOptionsClass@@A:BYTE	; PlayerOptions
EXTRN	?OTWDriver@@3VOTWDriverClass@@A:BYTE		; OTWDriver
EXTRN	?SimDriver@@3VSimulationDriver@@A:BYTE		; SimDriver
EXTRN	?IO@@3VSIMLIB_IO_CLASS@@A:BYTE			; IO
EXTRN	?SFX_DEF@@3PAUSfxDef@@A:DWORD			; SFX_DEF
EXTRN	?g_bRealisticAvionics@@3_NA:BYTE		; g_bRealisticAvionics
EXTRN	?acmiSwitch@@3UACMISwitchRecord@@A:BYTE		; acmiSwitch
EXTRN	?DOFRec@@3UACMIDOFRecord@@A:BYTE		; DOFRec
EXTRN	?g_bNewFm@@3_NA:BYTE				; g_bNewFm
EXTRN	?g_bNewDamageEffects@@3_NA:BYTE			; g_bNewDamageEffects
EXTRN	?g_bRollLinkedNWSRudder@@3_NA:BYTE		; g_bRollLinkedNWSRudder
EXTRN	?g_fACMIAnimRecordTimer@@3MA:DWORD		; g_fACMIAnimRecordTimer
EXTRN	?g_bAnimPilotHead@@3_NA:BYTE			; g_bAnimPilotHead
EXTRN	?g_fPilotActInterval@@3MA:DWORD			; g_fPilotActInterval
EXTRN	?g_fPilotHeadMoveRate@@3MA:DWORD		; g_fPilotHeadMoveRate
EXTRN	?g_bEnableTrackIR@@3_NA:BYTE			; g_bEnableTrackIR
EXTRN	?theTrackIRObject@@3VTrackIR@@A:BYTE		; theTrackIRObject
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
_BSS	SEGMENT
?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Generic_object
_BSS	ENDS
;	COMDAT ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
_BSS	SEGMENT
?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Iostream_object
_BSS	ENDS
;	COMDAT ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
_BSS	SEGMENT
?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_System_object
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
_BSS	ENDS
;	COMDAT ?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA
_BSS	SEGMENT
?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA DD 01H DUP (?) ; `GenerateFastRandom'::`2'::LastRandom
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@_W@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@_W@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<wchar_t>::id
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@bfc90fd9
CONST	SEGMENT
__real@bfc90fd9 DD 0bfc90fd9r			; -1.5708
CONST	ENDS
;	COMDAT __real@bfb2b8c1
CONST	SEGMENT
__real@bfb2b8c1 DD 0bfb2b8c1r			; -1.39626
CONST	ENDS
;	COMDAT __real@bf9c61a9
CONST	SEGMENT
__real@bf9c61a9 DD 0bf9c61a9r			; -1.22173
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@bf490fd9
CONST	SEGMENT
__real@bf490fd9 DD 0bf490fd9r			; -0.785398
CONST	ENDS
;	COMDAT __real@bf32b8c1
CONST	SEGMENT
__real@bf32b8c1 DD 0bf32b8c1r			; -0.698132
CONST	ENDS
;	COMDAT __real@bf060a91
CONST	SEGMENT
__real@bf060a91 DD 0bf060a91r			; -0.523599
CONST	ENDS
;	COMDAT __real@beb2b8c1
CONST	SEGMENT
__real@beb2b8c1 DD 0beb2b8c1r			; -0.349066
CONST	ENDS
;	COMDAT __real@be32b8c1
CONST	SEGMENT
__real@be32b8c1 DD 0be32b8c1r			; -0.174533
CONST	ENDS
;	COMDAT __real@bdcccccd
CONST	SEGMENT
__real@bdcccccd DD 0bdcccccdr			; -0.1
CONST	ENDS
;	COMDAT __real@477fff00
CONST	SEGMENT
__real@477fff00 DD 0477fff00r			; 65535
CONST	ENDS
;	COMDAT __real@476a6000
CONST	SEGMENT
__real@476a6000 DD 0476a6000r			; 60000
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT __real@44160000
CONST	SEGMENT
__real@44160000 DD 044160000r			; 600
CONST	ENDS
;	COMDAT __real@43b40000
CONST	SEGMENT
__real@43b40000 DD 043b40000r			; 360
CONST	ENDS
;	COMDAT __real@438706e2
CONST	SEGMENT
__real@438706e2 DD 0438706e2r			; 270.054
CONST	ENDS
;	COMDAT __real@43690000
CONST	SEGMENT
__real@43690000 DD 043690000r			; 233
CONST	ENDS
;	COMDAT __real@430706e2
CONST	SEGMENT
__real@430706e2 DD 0430706e2r			; 135.027
CONST	ENDS
;	COMDAT __real@42f00000
CONST	SEGMENT
__real@42f00000 DD 042f00000r			; 120
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@42480000
CONST	SEGMENT
__real@42480000 DD 042480000r			; 50
CONST	ENDS
;	COMDAT __real@42040000
CONST	SEGMENT
__real@42040000 DD 042040000r			; 33
CONST	ENDS
;	COMDAT __real@41fb53cf
CONST	SEGMENT
__real@41fb53cf DD 041fb53cfr			; 31.4159
CONST	ENDS
;	COMDAT __real@41a00000
CONST	SEGMENT
__real@41a00000 DD 041a00000r			; 20
CONST	ENDS
;	COMDAT __real@41900000
CONST	SEGMENT
__real@41900000 DD 041900000r			; 18
CONST	ENDS
;	COMDAT __real@41700000
CONST	SEGMENT
__real@41700000 DD 041700000r			; 15
CONST	ENDS
;	COMDAT __real@41555532
CONST	SEGMENT
__real@41555532 DD 041555532r			; 13.3333
CONST	ENDS
;	COMDAT __real@40c90fdb
CONST	SEGMENT
__real@40c90fdb DD 040c90fdbr			; 6.28319
CONST	ENDS
;	COMDAT __real@40c90fd9
CONST	SEGMENT
__real@40c90fd9 DD 040c90fd9r			; 6.28318
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fc90fd9
CONST	SEGMENT
__real@3fc90fd9 DD 03fc90fd9r			; 1.5708
CONST	ENDS
;	COMDAT __real@3fc00000
CONST	SEGMENT
__real@3fc00000 DD 03fc00000r			; 1.5
CONST	ENDS
;	COMDAT __real@3fb2b8c1
CONST	SEGMENT
__real@3fb2b8c1 DD 03fb2b8c1r			; 1.39626
CONST	ENDS
;	COMDAT __real@3f9c61a9
CONST	SEGMENT
__real@3f9c61a9 DD 03f9c61a9r			; 1.22173
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f666666
CONST	SEGMENT
__real@3f666666 DD 03f666666r			; 0.9
CONST	ENDS
;	COMDAT __real@3f4ccccd
CONST	SEGMENT
__real@3f4ccccd DD 03f4ccccdr			; 0.8
CONST	ENDS
;	COMDAT __real@3f333333
CONST	SEGMENT
__real@3f333333 DD 03f333333r			; 0.7
CONST	ENDS
;	COMDAT __real@3f32b8c1
CONST	SEGMENT
__real@3f32b8c1 DD 03f32b8c1r			; 0.698132
CONST	ENDS
;	COMDAT __real@3f19999a
CONST	SEGMENT
__real@3f19999a DD 03f19999ar			; 0.6
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3ecccccd
CONST	SEGMENT
__real@3ecccccd DD 03ecccccdr			; 0.4
CONST	ENDS
;	COMDAT __real@3eb2b8c1
CONST	SEGMENT
__real@3eb2b8c1 DD 03eb2b8c1r			; 0.349066
CONST	ENDS
;	COMDAT __real@3e4ccccd
CONST	SEGMENT
__real@3e4ccccd DD 03e4ccccdr			; 0.2
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3db2b8c1
CONST	SEGMENT
__real@3db2b8c1 DD 03db2b8c1r			; 0.0872665
CONST	ENDS
;	COMDAT __real@3da3d70a
CONST	SEGMENT
__real@3da3d70a DD 03da3d70ar			; 0.08
CONST	ENDS
;	COMDAT __real@3c8efa34
CONST	SEGMENT
__real@3c8efa34 DD 03c8efa34r			; 0.0174533
CONST	ENDS
;	COMDAT __real@3a83126f
CONST	SEGMENT
__real@3a83126f DD 03a83126fr			; 0.001
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error_category@std@@8 DD FLAT:??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error_category@std@@8
rdata$r	SEGMENT
??_R2_System_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error_category@std@@8
rdata$r	SEGMENT
??_R3_System_error_category@std@@8 DD 00H		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_System_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_System_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_System_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_System_error_category@std@@6B@ DD 00H		; std::_System_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error_category@std@@@8
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD FLAT:??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 00H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category@std@@@8
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
_DATA	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4error_category@std@@6B@
rdata$r	SEGMENT
??_R4error_category@std@@6B@ DD 00H			; std::error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVerror_category@std@@@8
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ?smap@?O@??CopyAnimationsToPit@AircraftClass@@QAEXPAVDrawableBSP@@@Z@4QBHB
CONST	SEGMENT
?smap@?O@??CopyAnimationsToPit@AircraftClass@@QAEXPAVDrawableBSP@@@Z@4QBHB DD 019H ; `AircraftClass::CopyAnimationsToPit'::`14'::smap
	DD	00H
	DD	01aH
	DD	02H
	DD	01bH
	DD	02H
	DD	01cH
	DD	02H
	DD	06H
	DD	03H
	DD	05H
	DD	05H
	DD	018H
	DD	06H
	DD	017H
	DD	07H
CONST	ENDS
;	COMDAT ?dmap@?M@??CopyAnimationsToPit@AircraftClass@@QAEXPAVDrawableBSP@@@Z@4QBHB
CONST	SEGMENT
?dmap@?M@??CopyAnimationsToPit@AircraftClass@@QAEXPAVDrawableBSP@@@Z@4QBHB DD 00H ; `AircraftClass::CopyAnimationsToPit'::`12'::dmap
	DD	00H
	DD	01H
	DD	01H
	DD	02H
	DD	06H
	DD	03H
	DD	07H
	DD	04H
	DD	08H
	DD	0fH
	DD	0aH
	DD	010H
	DD	0aH
	DD	011H
	DD	0aH
	DD	012H
	DD	0aH
	DD	02eH
	DD	0bH
	DD	01dH
	DD	013H
	DD	01cH
	DD	014H
	DD	0aH
	DD	015H
	DD	09H
	DD	016H
	DD	01eH
	DD	017H
	DD	028H
	DD	028H
	DD	02aH
	DD	02aH
	DD	02bH
	DD	02bH
	DD	02cH
	DD	02cH
	DD	02dH
	DD	02dH
	DD	02fH
	DD	02fH
CONST	ENDS
;	COMDAT ?swdofs@?BBA@??MoveSurfaces@AircraftClass@@QAEXXZ@4QBHB
CONST	SEGMENT
?swdofs@?BBA@??MoveSurfaces@AircraftClass@@QAEXXZ@4QBHB DD 0bH ; `AircraftClass::MoveSurfaces'::`272'::swdofs
	DD	0cH
	DD	0dH
	DD	0eH
	DD	0fH
	DD	010H
	DD	011H
	DD	012H
CONST	ENDS
;	COMDAT ??_C@_0BI@MOPJIONH@animSwingWingStages?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BI@MOPJIONH@animSwingWingStages?5?$CFd?6?$AA@ DB 'animSwingWingSta'
	DB	'ges %d', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system?$AA@
CONST	SEGMENT
??_C@_06FHFOAHML@system?$AA@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_System_error_category@std@@6B@
CONST	SEGMENT
??_7_System_error_category@std@@6B@ DD FLAT:??_R4_System_error_category@std@@6B@ ; std::_System_error_category::`vftable'
	DD	FLAT:??_E_System_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_System_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ DB 'iostream stream error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream?$AA@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream?$AA@ DB 'iostream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DD FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DD	FLAT:??_E_Iostream_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
CONST	SEGMENT
??_C@_0O@BFJCFAAK@unknown?5error?$AA@ DB 'unknown error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic?$AA@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic?$AA@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7error_category@std@@6B@
CONST	SEGMENT
??_7error_category@std@@6B@ DD FLAT:??_R4error_category@std@@6B@ ; std::error_category::`vftable'
	DD	FLAT:??_Eerror_category@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
__ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Generic_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Iostream_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_System_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@D@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<char>::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@_W@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<wchar_t>::id$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 621  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();
; 624  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
_this$ = -24						; size = 4
tv73 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR __V0$[ebp]
	push	ecx
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<wchar_t>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@_W@std@@2V0locale@2@A ; std::numpunct<wchar_t>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<wchar_t>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<char>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<char>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 755  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp

; 756  : 		{	// destroy object at _Ptr
; 757  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>

; 758  : 		}

	pop	ebp
	ret	0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
	pop	ebp
	ret	0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	ebp
	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??1_System_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_System_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??0_System_error_category@std@@QAE@XZ	; std::_System_error_category::_System_error_category
	push	OFFSET ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_System_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??1_Iostream_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??0_Iostream_error_category@std@@QAE@XZ	; std::_Iostream_error_category::_Iostream_error_category
	push	OFFSET ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??1_Generic_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	push	OFFSET ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], -1
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 85   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 89   : 	}

	pop	ebp
	ret	0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 907  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
	add	esp, 8

; 910  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
	add	esp, 12					; 0000000cH
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\trackir.h
;	COMDAT ?getPitch@TrackIR@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getPitch@TrackIR@@QAEMXZ PROC				; TrackIR::getPitch, COMDAT
; _this$ = ecx

; 24   : 	float getPitch() { return pitch; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+24]
	mov	esp, ebp
	pop	ebp
	ret	0
?getPitch@TrackIR@@QAEMXZ ENDP				; TrackIR::getPitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\trackir.h
;	COMDAT ?getYaw@TrackIR@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getYaw@TrackIR@@QAEMXZ PROC				; TrackIR::getYaw, COMDAT
; _this$ = ecx

; 23   : 	float getYaw() { return yaw; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+20]
	mov	esp, ebp
	pop	ebp
	ret	0
?getYaw@TrackIR@@QAEMXZ ENDP				; TrackIR::getYaw
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?CurHardpoint@SMSBaseClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CurHardpoint@SMSBaseClass@@QAEHXZ PROC			; SMSBaseClass::CurHardpoint, COMDAT
; _this$ = ecx

; 88   : 	int CurHardpoint (void) {return curHardpoint;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+44]
	mov	esp, ebp
	pop	ebp
	ret	0
?CurHardpoint@SMSBaseClass@@QAEHXZ ENDP			; SMSBaseClass::CurHardpoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?NumHardpoints@SMSBaseClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?NumHardpoints@SMSBaseClass@@QAEHXZ PROC		; SMSBaseClass::NumHardpoints, COMDAT
; _this$ = ecx

; 87   : 	int NumHardpoints (void) {return numHardpoints;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+40]
	mov	esp, ebp
	pop	ebp
	ret	0
?NumHardpoints@SMSBaseClass@@QAEHXZ ENDP		; SMSBaseClass::NumHardpoints
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\fakerand.h
;	COMDAT ?PRANDFloatPos@@YAMXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_x$ = -4						; size = 4
?PRANDFloatPos@@YAMXZ PROC				; PRANDFloatPos, COMDAT

; 150  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 151  : //	return NRANDPOS;
; 152  : 	float	x=	(float)(GenerateFastRandom()&0xffff);

	call	?GenerateFastRandom@@YAJXZ		; GenerateFastRandom
	and	eax, 65535				; 0000ffffH
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _x$[ebp], xmm0

; 153  : 	return( x / 65535.0f);

	movss	xmm0, DWORD PTR _x$[ebp]
	divss	xmm0, DWORD PTR __real@477fff00
	movss	DWORD PTR tv72[ebp], xmm0
	fld	DWORD PTR tv72[ebp]

; 154  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PRANDFloatPos@@YAMXZ ENDP				; PRANDFloatPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\fakerand.h
;	COMDAT ?GenerateFastRandom@@YAJXZ
_TEXT	SEGMENT
_FastRandom$ = -4					; size = 4
?GenerateFastRandom@@YAJXZ PROC				; GenerateFastRandom, COMDAT

; 108  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 109  : 	static long LastRandom;
; 110  : 	long	FastRandom;														// The Random Variable
; 111  : 	_asm {	
; 112  : 			push	edx

	push	edx

; 113  : 			push	eax

	push	eax

; 114  : 			RDTSC

	rdtsc

; 115  : 			add	DWORD PTR FastRandom,edx

	add	DWORD PTR _FastRandom$[ebp], edx

; 116  : 			xor	DWORD PTR FastRandom,eax

	xor	DWORD PTR _FastRandom$[ebp], eax

; 117  : 			mov	eax, DWORD PTR LastRandom

	mov	eax, DWORD PTR ?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA ; `GenerateFastRandom'::`2'::LastRandom

; 118  : 			add	DWORD PTR FastRandom,eax

	add	DWORD PTR _FastRandom$[ebp], eax

; 119  : 			add	DWORD PTR LastRandom,edx

	add	DWORD PTR ?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA, edx ; `GenerateFastRandom'::`2'::LastRandom

; 120  : 			pop	eax

	pop	eax

; 121  : 			pop	edx

	pop	edx

; 122  : 	}
; 123  : 	return(FastRandom);

	mov	eax, DWORD PTR _FastRandom$[ebp]

; 124  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GenerateFastRandom@@YAJXZ ENDP				; GenerateFastRandom
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\drawbsp.h
;	COMDAT ?GetNumSwitches@DrawableBSP@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNumSwitches@DrawableBSP@@QAEHXZ PROC		; DrawableBSP::GetNumSwitches, COMDAT
; _this$ = ecx

; 37   : 	int	GetNumSwitches( void )			{ return instance.ParentObject->nSwitches; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+116]
	movsx	eax, WORD PTR [ecx+52]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumSwitches@DrawableBSP@@QAEHXZ ENDP		; DrawableBSP::GetNumSwitches
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\drawbsp.h
;	COMDAT ?GetNumDOFs@DrawableBSP@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNumDOFs@DrawableBSP@@QAEHXZ PROC			; DrawableBSP::GetNumDOFs, COMDAT
; _this$ = ecx

; 36   : 	int	GetNumDOFs( void )				{ return instance.ParentObject->nDOFs; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+116]
	movsx	eax, WORD PTR [ecx+54]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumDOFs@DrawableBSP@@QAEHXZ ENDP			; DrawableBSP::GetNumDOFs
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simio.h
;	COMDAT ?AnalogIsUsed@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_id$ = 8						; size = 4
?AnalogIsUsed@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z PROC ; SIMLIB_IO_CLASS::AnalogIsUsed, COMDAT
; _this$ = ecx

; 237  : 	bool	AnalogIsUsed(GameAxis_t id) { return ( analog[id].isUsed); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _id$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [ecx+eax+12]
	mov	esp, ebp
	pop	ebp
	ret	4
?AnalogIsUsed@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z ENDP ; SIMLIB_IO_CLASS::AnalogIsUsed
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h
;	COMDAT ?GetPlayerEntity@SimulationDriver@@QBEPAVSimMoverClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPlayerEntity@SimulationDriver@@QBEPAVSimMoverClass@@XZ PROC ; SimulationDriver::GetPlayerEntity, COMDAT
; _this$ = ecx

; 76   : 	SimMoverClass *GetPlayerEntity() const { return const_cast<SimMoverClass*>(playerEntity); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+56]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetPlayerEntity@SimulationDriver@@QBEPAVSimMoverClass@@XZ ENDP ; SimulationDriver::GetPlayerEntity
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\playerop.h
;	COMDAT ?Get3dTrackIR@PlayerOptionsClass@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Get3dTrackIR@PlayerOptionsClass@@QBE_NXZ PROC		; PlayerOptionsClass::Get3dTrackIR, COMDAT
; _this$ = ecx

; 180  : 	bool Get3dTrackIR(void) const                           { return TrackIR_3d; }			// Retro 27Dec2003

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+206]
	mov	esp, ebp
	pop	ebp
	ret	0
?Get3dTrackIR@PlayerOptionsClass@@QBE_NXZ ENDP		; PlayerOptionsClass::Get3dTrackIR
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_System_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_System_error_category@std@@UAEPAXI@Z PROC		; std::_System_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_System_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_System_error_category@std@@UAEPAXI@Z ENDP		; std::_System_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_System_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_System_error_category@std@@UAE@XZ PROC		; std::_System_error_category::~_System_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_System_error_category@std@@UAE@XZ ENDP		; std::_System_error_category::~_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::_System_error_category::default_error_condition, COMDAT
; _this$ = ecx

; 641  : 		{	// make error_condition for error code (generic if possible)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 642  : 		if (_Syserror_map(_Errval))

	mov	eax, DWORD PTR __Errval$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@default_er

; 643  : 			return (error_condition(_Errval, generic_category()));

	call	?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@default_er

; 644  : 		else

	jmp	SHORT $LN3@default_er
$LN2@default_er:

; 645  : 			return (error_condition(_Errval, system_category()));

	call	?system_category@std@@YAABVerror_category@1@XZ ; std::system_category
	push	eax
	mov	edx, DWORD PTR __Errval$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@default_er:

; 646  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::_System_error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_System_error_category::message, COMDAT
; _this$ = ecx

; 634  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 635  : 		const char *_Name = _Winerror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Winerror_map@std@@YAPBDH@Z		; std::_Winerror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 636  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 637  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_System_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_System_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_System_error_category@std@@UBEPBDXZ PROC		; std::_System_error_category::name, COMDAT
; _this$ = ecx

; 629  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 630  : 		return ("system");

	mov	eax, OFFSET ??_C@_06FHFOAHML@system?$AA@

; 631  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_System_error_category@std@@UBEPBDXZ ENDP		; std::_System_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_System_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_System_error_category@std@@QAE@XZ PROC		; std::_System_error_category::_System_error_category, COMDAT
; _this$ = ecx

; 624  : 	_System_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_System_error_category@std@@6B@

; 625  : 		{	// default constructor
; 626  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_System_error_category@std@@QAE@XZ ENDP		; std::_System_error_category::_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Iostream_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Iostream_error_category@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iostream_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Iostream_error_category@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Iostream_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Iostream_error_category@std@@UAE@XZ PROC		; std::_Iostream_error_category::~_Iostream_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Iostream_error_category@std@@UAE@XZ ENDP		; std::_Iostream_error_category::~_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT
; _this$ = ecx

; 611  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 612  : 		if (_Errcode == (int)io_errc::stream)

	cmp	DWORD PTR __Errcode$[ebp], 1
	jne	SHORT $LN2@message

; 613  : 			return ("iostream stream error");

	push	OFFSET ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@message

; 614  : 		else

	jmp	SHORT $LN3@message
$LN2@message:

; 615  : 			return (_Generic_error_category::message(_Errcode));

	mov	ecx, DWORD PTR __Errcode$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@message:

; 616  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Iostream_error_category@std@@UBEPBDXZ PROC	; std::_Iostream_error_category::name, COMDAT
; _this$ = ecx

; 606  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 607  : 		return ("iostream");

	mov	eax, OFFSET ??_C@_08LLGCOLLL@iostream?$AA@

; 608  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Iostream_error_category@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Iostream_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iostream_error_category@std@@QAE@XZ PROC		; std::_Iostream_error_category::_Iostream_error_category, COMDAT
; _this$ = ecx

; 601  : 	_Iostream_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Iostream_error_category@std@@6B@

; 602  : 		{	// default constructor
; 603  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iostream_error_category@std@@QAE@XZ ENDP		; std::_Iostream_error_category::_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Generic_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Generic_error_category@std@@UAE@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Generic_error_category@std@@UAE@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 590  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 591  : 		const char *_Name = _Syserror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 592  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 593  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 585  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		return ("generic");

	mov	eax, OFFSET ??_C@_07DCLBNMLN@generic?$AA@

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Generic_error_category@std@@QAE@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT
; _this$ = ecx

; 580  : 	_Generic_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0error_category@std@@QAE@XZ		; std::error_category::error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Generic_error_category@std@@6B@

; 581  : 		{	// default constructor
; 582  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Generic_error_category@std@@QAE@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_condition@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv78 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8error_condition@std@@QBE_NABV01@@Z PROC		; std::error_condition::operator==, COMDAT
; _this$ = ecx

; 376  : 		{	// test if *this == _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 377  : 		return (category() == _Right.category()
; 378  : 			&& value() == _Right.value());

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	mov	ecx, eax
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	cmp	esi, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv78[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv78[ebp]

; 379  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??8error_condition@std@@QBE_NABV01@@Z ENDP		; std::error_condition::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 354  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 356  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 349  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 350  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 351  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 316  : 		{	// construct from error code and category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Cat$[ebp]
	mov	DWORD PTR [edx+4], eax

; 317  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 256  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 257  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 258  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 251  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 252  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 253  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gerror_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gerror_category@std@@UAEPAXI@Z PROC			; std::error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gerror_category@std@@UAEPAXI@Z ENDP			; std::error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv65 = -4						; size = 4
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 184  : 		{	// compare categories for equality

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 185  : 		return (this == &_Right);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv65[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv65[ebp]

; 186  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -4						; size = 4
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 415  : 	{	// test if conditions same for this category

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 416  : 	return (*this == _Code.category() && _Code.value() == _Errval);

	mov	ecx, DWORD PTR __Code$[ebp]
	call	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@equivalent
	mov	ecx, DWORD PTR __Code$[ebp]
	call	?value@error_code@std@@QBEHXZ		; std::error_code::value
	cmp	eax, DWORD PTR __Errval$[ebp]
	jne	SHORT $LN3@equivalent
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN4@equivalent
$LN3@equivalent:
	mov	DWORD PTR tv74[ebp], 0
$LN4@equivalent:
	mov	al, BYTE PTR tv74[ebp]

; 417  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 408  : 	{	// test if error code same condition

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 409  : 	return (default_error_condition(_Errval) == _Cond);

	mov	eax, DWORD PTR __Cond$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	ecx, eax
	call	??8error_condition@std@@QBE_NABV01@@Z	; std::error_condition::operator==

; 410  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 401  : 	{	// make error_condition for error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 402  : 	return (error_condition(_Errval, *this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 403  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 167  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 168  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0error_category@std@@QAE@XZ PROC			; std::error_category::error_category, COMDAT
; _this$ = ecx

; 162  : 	error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 163  : 		{	// default constructor
; 164  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0error_category@std@@QAE@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?system_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?system_category@std@@YAABVerror_category@1@XZ PROC	; std::system_category, COMDAT

; 679  : 	{	// get system_category

	push	ebp
	mov	ebp, esp

; 680  : 	return (_Error_objects<int>::_System_object);

	mov	eax, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object

; 681  : 	}

	pop	ebp
	ret	0
?system_category@std@@YAABVerror_category@1@XZ ENDP	; std::system_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?generic_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?generic_category@std@@YAABVerror_category@1@XZ PROC	; std::generic_category, COMDAT

; 669  : 	{	// get generic_category

	push	ebp
	mov	ebp, esp

; 670  : 	return (_Error_objects<int>::_Generic_object);

	mov	eax, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object

; 671  : 	}

	pop	ebp
	ret	0
?generic_category@std@@YAABVerror_category@1@XZ ENDP	; std::generic_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocale
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC				; std::locale::id::id, COMDAT
; _this$ = ecx

; 74   : 			{	// construct with specified stamp value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx

; 75   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\include\acmirec.h
;	COMDAT ?IsRecording@ACMIRecorder@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsRecording@ACMIRecorder@@QAEHXZ PROC			; ACMIRecorder::IsRecording, COMDAT
; _this$ = ecx

; 319  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 320  : 		return _recording;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]

; 321  : 	};

	mov	esp, ebp
	pop	ebp
	ret	0
?IsRecording@ACMIRecorder@@QAEHXZ ENDP			; ACMIRecorder::IsRecording
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?GetSimpleMode@AirframeClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSimpleMode@AirframeClass@@QAEHXZ PROC		; AirframeClass::GetSimpleMode, COMDAT
; _this$ = ecx

; 1224 : 	int  GetSimpleMode(void) {return simpleMode;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+824]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSimpleMode@AirframeClass@@QAEHXZ ENDP		; AirframeClass::GetSimpleMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?IsSet@AirframeClass@@QBEHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_testFlag$ = 8						; size = 4
?IsSet@AirframeClass@@QBEHH@Z PROC			; AirframeClass::IsSet, COMDAT
; _this$ = ecx

; 1216 : 	int IsSet (int testFlag) const {return flags & testFlag ? 1 : 0;}

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	and	ecx, DWORD PTR _testFlag$[ebp]
	je	SHORT $LN3@IsSet
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsSet
$LN3@IsSet:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsSet:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsSet@AirframeClass@@QBEHH@Z ENDP			; AirframeClass::IsSet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?GetAeroData@AirframeClass@@QBEMH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_which$ = 8						; size = 4
?GetAeroData@AirframeClass@@QBEMH@Z PROC		; AirframeClass::GetAeroData, COMDAT
; _this$ = ecx

; 1207 : 	float GetAeroData(int which) const { return aeroDataset[vehicleIndex].inputData[which]; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+92]
	imul	ecx, 220				; 000000dcH
	add	ecx, DWORD PTR ?aeroDataset@@3PAVAeroDataSet@@A ; aeroDataset
	mov	edx, DWORD PTR _which$[ebp]
	fld	DWORD PTR [ecx+edx*4+16]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetAeroData@AirframeClass@@QBEMH@Z ENDP		; AirframeClass::GetAeroData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?NumGear@AirframeClass@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?NumGear@AirframeClass@@QBEHXZ PROC			; AirframeClass::NumGear, COMDAT
; _this$ = ecx

; 1206 : 	int NumGear(void) const	{return FloatToInt32(aeroDataset[vehicleIndex].inputData[AeroDataSet::NumGear]);}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+92]
	imul	ecx, 220				; 000000dcH
	add	ecx, DWORD PTR ?aeroDataset@@3PAVAeroDataSet@@A ; aeroDataset
	mov	edx, 4
	imul	edx, 13					; 0000000dH
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx+16]
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	esp, ebp
	pop	ebp
	ret	0
?NumGear@AirframeClass@@QBEHXZ ENDP			; AirframeClass::NumGear
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?Throtl@AirframeClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Throtl@AirframeClass@@QAEMXZ PROC			; AirframeClass::Throtl, COMDAT
; _this$ = ecx

; 1168 : 	float Throtl (void) {return throtl;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1512]
	mov	esp, ebp
	pop	ebp
	ret	0
?Throtl@AirframeClass@@QAEMXZ ENDP			; AirframeClass::Throtl
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?IsEngineFlag@AirframeClass@@QAEHW4EngineFlags@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_ef$ = 8						; size = 4
?IsEngineFlag@AirframeClass@@QAEHW4EngineFlags@1@@Z PROC ; AirframeClass::IsEngineFlag, COMDAT
; _this$ = ecx

; 1070 : 	int IsEngineFlag(EngineFlags ef) { return (engineFlags & ef) ? 1 : 0; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1676]
	and	ecx, DWORD PTR _ef$[ebp]
	je	SHORT $LN3@IsEngineFl
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsEngineFl
$LN3@IsEngineFl:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsEngineFl:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsEngineFlag@AirframeClass@@QAEHW4EngineFlags@1@@Z ENDP ; AirframeClass::IsEngineFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?GetGunDofRate@AirframeClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGunDofRate@AirframeClass@@QAEMXZ PROC		; AirframeClass::GetGunDofRate, COMDAT
; _this$ = ecx

; 764  : 	float GetGunDofRate() { return auxaeroData->gunSwitchDofRate.z; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+2848]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetGunDofRate@AirframeClass@@QAEMXZ ENDP		; AirframeClass::GetGunDofRate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?GetGunDofType@AirframeClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGunDofType@AirframeClass@@QAEHXZ PROC		; AirframeClass::GetGunDofType, COMDAT
; _this$ = ecx

; 763  : 	int GetGunDofType() { return int(auxaeroData->gunSwitchDofRate.y); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cvttss2si eax, DWORD PTR [ecx+2844]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetGunDofType@AirframeClass@@QAEHXZ ENDP		; AirframeClass::GetGunDofType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?GetGunSwitchType@AirframeClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGunSwitchType@AirframeClass@@QAEHXZ PROC		; AirframeClass::GetGunSwitchType, COMDAT
; _this$ = ecx

; 762  : 	int GetGunSwitchType() { return int(auxaeroData->gunSwitchDofRate.x); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cvttss2si eax, DWORD PTR [ecx+2840]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetGunSwitchType@AirframeClass@@QAEHXZ ENDP		; AirframeClass::GetGunSwitchType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?GetHpDofRate@AirframeClass@@QAEMH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_numHP$ = 8						; size = 4
?GetHpDofRate@AirframeClass@@QAEMH@Z PROC		; AirframeClass::GetHpDofRate, COMDAT
; _this$ = ecx

; 759  : 	float GetHpDofRate(int numHP) { return auxaeroData->hpSwitchDofRate[numHP].z; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _numHP$[ebp]
	imul	edx, 12					; 0000000cH
	fld	DWORD PTR [ecx+edx+2656]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetHpDofRate@AirframeClass@@QAEMH@Z ENDP		; AirframeClass::GetHpDofRate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?GetHpDofType@AirframeClass@@QAEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_numHP$ = 8						; size = 4
?GetHpDofType@AirframeClass@@QAEHH@Z PROC		; AirframeClass::GetHpDofType, COMDAT
; _this$ = ecx

; 758  : 	int GetHpDofType(int numHP) { return int(auxaeroData->hpSwitchDofRate[numHP].y); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _numHP$[ebp]
	imul	edx, 12					; 0000000cH
	cvttss2si eax, DWORD PTR [ecx+edx+2652]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetHpDofType@AirframeClass@@QAEHH@Z ENDP		; AirframeClass::GetHpDofType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\surface.cpp
_TEXT	SEGMENT
tv190 = -12						; size = 4
tv208 = -8						; size = 4
_this$ = -4						; size = 4
_type$ = 8						; size = 4
?DeployDragChute@AircraftClass@@AAEXH@Z PROC		; AircraftClass::DeployDragChute
; _this$ = ecx

; 379  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 380  : 	if (af->vcas < 20.0f && af->dragChute == AirframeClass::DRAGC_DEPLOYED)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR __real@41a00000
	comiss	xmm0, DWORD PTR [ecx+1124]
	jbe	SHORT $LN5@DeployDrag
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	cmp	DWORD PTR [eax+1584], 1
	jne	SHORT $LN5@DeployDrag

; 381  : 		af->dragChute = AirframeClass::DRAGC_TRAILING;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	DWORD PTR [edx+1584], 2
$LN5@DeployDrag:

; 382  : 	if (af->dragChute == AirframeClass::DRAGC_DEPLOYED &&
; 383  : 		af->vcas > af->auxaeroData->dragChuteMaxSpeed) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	cmp	DWORD PTR [ecx+1584], 1
	jne	SHORT $LN3@DeployDrag
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	ecx, DWORD PTR [edx+4]
	movss	xmm0, DWORD PTR [eax+1124]
	comiss	xmm0, DWORD PTR [ecx+232]
	jbe	SHORT $LN3@DeployDrag

; 384  : 		if ((af->vcas - af->auxaeroData->dragChuteMaxSpeed) / 100 > PRANDFloatPos())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	ecx, DWORD PTR [edx+4]
	movss	xmm0, DWORD PTR [eax+1124]
	subss	xmm0, DWORD PTR [ecx+232]
	divss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR tv208[ebp], xmm0
	call	?PRANDFloatPos@@YAMXZ			; PRANDFloatPos
	fstp	DWORD PTR tv190[ebp]
	movss	xmm0, DWORD PTR tv208[ebp]
	comiss	xmm0, DWORD PTR tv190[ebp]
	jbe	SHORT $LN3@DeployDrag

; 385  : 			af->dragChute = AirframeClass::DRAGC_RIPPED;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	DWORD PTR [eax+1584], 8
$LN3@DeployDrag:

; 386  : 	}
; 387  : 	if (af->dragChute != GetSwitch(type)) 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [ecx+932]
	mov	edx, DWORD PTR _type$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSwitch@SimMoverClass@@QAEHH@Z	; SimMoverClass::GetSwitch
	cmp	DWORD PTR [esi+1584], eax
	je	SHORT $LN2@DeployDrag

; 388  : 	{
; 389  : 		if (af->dragChute == AirframeClass::DRAGC_DEPLOYED)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	cmp	DWORD PTR [ecx+1584], 1
	jne	SHORT $LN1@DeployDrag

; 390  : 			SoundPos.Sfx(af->auxaeroData->sndDragChute); // MLR 5/16/2004 - 

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+2432]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 444				; 000001bcH
	call	?Sfx@F4SoundPos@@QAEXHHMM@Z		; F4SoundPos::Sfx
$LN1@DeployDrag:

; 391  : 			//F4SoundFXSetPos( af->auxaeroData->sndDragChute, TRUE, af->x, af->y, af->z, 1.0f );
; 392  : 		
; 393  : 		SetSwitch(type, af->dragChute);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+1584]
	push	edx
	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSwitch@SimMoverClass@@QAEXHH@Z	; SimMoverClass::SetSwitch
$LN2@DeployDrag:

; 394  : 	}
; 395  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?DeployDragChute@AircraftClass@@AAEXH@Z ENDP		; AircraftClass::DeployDragChute
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\surface.cpp
_TEXT	SEGMENT
_changeval$ = -16					; size = 4
_this$ = -12						; size = 4
_cdof$ = -8						; size = 4
_doend$ = -1						; size = 1
_dof$ = 8						; size = 4
_newval$ = 12						; size = 4
_rate$ = 16						; size = 4
_ssfx$ = 20						; size = 4
_lsfx$ = 24						; size = 4
_esfx$ = 28						; size = 4
?MoveDof@AircraftClass@@AAEXHMMHHH@Z PROC		; AircraftClass::MoveDof
; _this$ = ecx

; 334  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 335  : 	float changeval;
; 336  : 	float cdof = GetDOFValue(dof);

	mov	eax, DWORD PTR _dof$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDOFValue@SimMoverClass@@QAEMH@Z	; SimMoverClass::GetDOFValue
	fstp	DWORD PTR _cdof$[ebp]

; 337  : 	bool doend = false;

	mov	BYTE PTR _doend$[ebp], 0

; 338  : 	if (cdof == newval) return; // all done

	movss	xmm0, DWORD PTR _cdof$[ebp]
	ucomiss	xmm0, DWORD PTR _newval$[ebp]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@MoveDof
	jmp	$LN12@MoveDof
$LN11@MoveDof:

; 339  : 	
; 340  : 	changeval = rate * DTR * SimLibMajorFrameTime;

	movss	xmm0, DWORD PTR _rate$[ebp]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	mulss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	movss	DWORD PTR _changeval$[ebp], xmm0

; 341  : 	if (cdof > newval)

	movss	xmm0, DWORD PTR _cdof$[ebp]
	comiss	xmm0, DWORD PTR _newval$[ebp]
	jbe	SHORT $LN10@MoveDof

; 342  : 	{
; 343  : 		cdof -= changeval;

	movss	xmm0, DWORD PTR _cdof$[ebp]
	subss	xmm0, DWORD PTR _changeval$[ebp]
	movss	DWORD PTR _cdof$[ebp], xmm0

; 344  : 		if (cdof <= newval) {

	movss	xmm0, DWORD PTR _newval$[ebp]
	comiss	xmm0, DWORD PTR _cdof$[ebp]
	jb	SHORT $LN9@MoveDof

; 345  : 			cdof = newval;

	movss	xmm0, DWORD PTR _newval$[ebp]
	movss	DWORD PTR _cdof$[ebp], xmm0

; 346  : 			doend = true;

	mov	BYTE PTR _doend$[ebp], 1
$LN9@MoveDof:

; 347  : 		}
; 348  : 		SetDOF(dof, cdof);

	push	ecx
	movss	xmm0, DWORD PTR _cdof$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _dof$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDOF@SimMoverClass@@QAEXHM@Z		; SimMoverClass::SetDOF
	jmp	SHORT $LN7@MoveDof
$LN10@MoveDof:

; 349  : 	}
; 350  : 	else if (cdof < newval)

	movss	xmm0, DWORD PTR _newval$[ebp]
	comiss	xmm0, DWORD PTR _cdof$[ebp]
	jbe	SHORT $LN7@MoveDof

; 351  : 	{
; 352  : 		cdof += changeval;

	movss	xmm0, DWORD PTR _cdof$[ebp]
	addss	xmm0, DWORD PTR _changeval$[ebp]
	movss	DWORD PTR _cdof$[ebp], xmm0

; 353  : 		if (cdof >= newval) {

	movss	xmm0, DWORD PTR _cdof$[ebp]
	comiss	xmm0, DWORD PTR _newval$[ebp]
	jb	SHORT $LN6@MoveDof

; 354  : 			cdof = newval;

	movss	xmm0, DWORD PTR _newval$[ebp]
	movss	DWORD PTR _cdof$[ebp], xmm0

; 355  : 			doend = true;

	mov	BYTE PTR _doend$[ebp], 1
$LN6@MoveDof:

; 356  : 		}
; 357  : 		SetDOF(dof, cdof);

	push	ecx
	movss	xmm0, DWORD PTR _cdof$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _dof$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDOF@SimMoverClass@@QAEXHM@Z		; SimMoverClass::SetDOF
$LN7@MoveDof:

; 358  : 	}
; 359  : 	
; 360  : 	if (SFX_DEF && ssfx >= 0) 

	cmp	DWORD PTR ?SFX_DEF@@3PAUSfxDef@@A, 0	; SFX_DEF
	je	$LN1@MoveDof
	cmp	DWORD PTR _ssfx$[ebp], 0
	jl	$LN1@MoveDof

; 361  : 	{ // something to play
; 362  : 		// MLR 12/30/2003 - reorganized for clarity
; 363  : 		if (doend)

	movzx	eax, BYTE PTR _doend$[ebp]
	test	eax, eax
	je	SHORT $LN4@MoveDof

; 364  : 		{
; 365  : 			SoundPos.Sfx( esfx );

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	0
	mov	ecx, DWORD PTR _esfx$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 444				; 000001bcH
	call	?Sfx@F4SoundPos@@QAEXHHMM@Z		; F4SoundPos::Sfx

; 366  : 		}
; 367  : 		else 

	jmp	$LN1@MoveDof
$LN4@MoveDof:

; 368  : 		{
; 369  : 			if (!SoundPos.IsPlaying( ssfx) && // MLR 12/30/2003 - changed IsPlaying sound call
; 370  : 				!SoundPos.IsPlaying( lsfx))

	push	0
	mov	edx, DWORD PTR _ssfx$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 444				; 000001bcH
	call	?IsPlaying@F4SoundPos@@QAE_NHH@Z	; F4SoundPos::IsPlaying
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@MoveDof
	push	0
	mov	ecx, DWORD PTR _lsfx$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 444				; 000001bcH
	call	?IsPlaying@F4SoundPos@@QAE_NHH@Z	; F4SoundPos::IsPlaying
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@MoveDof

; 371  : 				SoundPos.Sfx( ssfx );

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	0
	mov	eax, DWORD PTR _ssfx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 444				; 000001bcH
	call	?Sfx@F4SoundPos@@QAEXHHMM@Z		; F4SoundPos::Sfx

; 372  : 			else

	jmp	SHORT $LN1@MoveDof
$LN2@MoveDof:

; 373  : 				SoundPos.Sfx(lsfx );

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	0
	mov	ecx, DWORD PTR _lsfx$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 444				; 000001bcH
	call	?Sfx@F4SoundPos@@QAEXHHMM@Z		; F4SoundPos::Sfx
$LN1@MoveDof:
$LN12@MoveDof:

; 374  : 		}
; 375  : 	}
; 376  : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?MoveDof@AircraftClass@@AAEXHMMHHH@Z ENDP		; AircraftClass::MoveDof
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\surface.cpp
_TEXT	SEGMENT
tv79 = -8						; size = 4
_this$ = -4						; size = 4
_qfactor$ = 8						; size = 4
?CalculateRudder@AircraftClass@@AAEMM@Z PROC		; AircraftClass::CalculateRudder
; _this$ = ecx

; 327  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 328  : 	return af->ypedal * af->auxaeroData->rudderMaxAngle * DTR * qfactor;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	edx, DWORD PTR [eax+4]
	movss	xmm0, DWORD PTR [ecx+1508]
	mulss	xmm0, DWORD PTR [edx+128]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	mulss	xmm0, DWORD PTR _qfactor$[ebp]
	movss	DWORD PTR tv79[ebp], xmm0
	fld	DWORD PTR tv79[ebp]

; 329  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?CalculateRudder@AircraftClass@@AAEMM@Z ENDP		; AircraftClass::CalculateRudder
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\surface.cpp
_TEXT	SEGMENT
tv189 = -40						; size = 4
tv188 = -36						; size = 4
tv179 = -32						; size = 4
tv165 = -28						; size = 4
tv164 = -24						; size = 4
tv149 = -20						; size = 4
tv129 = -16						; size = 4
tv128 = -12						; size = 4
tv81 = -8						; size = 4
_this$ = -4						; size = 4
_qfactor$ = 8						; size = 4
_sl$ = 12						; size = 4
_sr$ = 16						; size = 4
?CalculateStab@AircraftClass@@AAEXMPAM0@Z PROC		; AircraftClass::CalculateStab
; _this$ = ecx

; 316  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 317  : 	if (af->auxaeroData->elevatorRolls) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+240], 0
	je	$LN2@CalculateS

; 318  : 		*sl = max ( min (af->pstick - af->rstick, 1.0F), -1.0F) * qfactor * af->auxaeroData->elevonMaxAngle * DTR;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR [ecx+1500]
	subss	xmm0, DWORD PTR [eax+1504]
	movss	xmm1, DWORD PTR __real@3f800000
	comiss	xmm1, xmm0
	jbe	SHORT $LN5@CalculateS
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [edx+1500]
	subss	xmm0, DWORD PTR [ecx+1504]
	movss	DWORD PTR tv81[ebp], xmm0
	jmp	SHORT $LN6@CalculateS
$LN5@CalculateS:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv81[ebp], xmm0
$LN6@CalculateS:
	movss	xmm0, DWORD PTR tv81[ebp]
	comiss	xmm0, DWORD PTR __real@bf800000
	jbe	SHORT $LN9@CalculateS
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR [eax+1500]
	subss	xmm0, DWORD PTR [edx+1504]
	movss	xmm1, DWORD PTR __real@3f800000
	comiss	xmm1, xmm0
	jbe	SHORT $LN7@CalculateS
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR [ecx+1500]
	subss	xmm0, DWORD PTR [eax+1504]
	movss	DWORD PTR tv128[ebp], xmm0
	jmp	SHORT $LN8@CalculateS
$LN7@CalculateS:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv128[ebp], xmm0
$LN8@CalculateS:
	movss	xmm0, DWORD PTR tv128[ebp]
	movss	DWORD PTR tv129[ebp], xmm0
	jmp	SHORT $LN10@CalculateS
$LN9@CalculateS:
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR tv129[ebp], xmm0
$LN10@CalculateS:
	movss	xmm0, DWORD PTR tv129[ebp]
	mulss	xmm0, DWORD PTR _qfactor$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	mulss	xmm0, DWORD PTR [eax+136]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	mov	ecx, DWORD PTR _sl$[ebp]
	movss	DWORD PTR [ecx], xmm0

; 319  : 		*sr = max ( min (af->pstick + af->rstick, 1.0F), -1.0F) * qfactor * af->auxaeroData->elevonMaxAngle * DTR;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR [eax+1500]
	addss	xmm0, DWORD PTR [edx+1504]
	movss	xmm1, DWORD PTR __real@3f800000
	comiss	xmm1, xmm0
	jbe	SHORT $LN11@CalculateS
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR [ecx+1500]
	addss	xmm0, DWORD PTR [eax+1504]
	movss	DWORD PTR tv149[ebp], xmm0
	jmp	SHORT $LN12@CalculateS
$LN11@CalculateS:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv149[ebp], xmm0
$LN12@CalculateS:
	movss	xmm0, DWORD PTR tv149[ebp]
	comiss	xmm0, DWORD PTR __real@bf800000
	jbe	SHORT $LN15@CalculateS
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [edx+1500]
	addss	xmm0, DWORD PTR [ecx+1504]
	movss	xmm1, DWORD PTR __real@3f800000
	comiss	xmm1, xmm0
	jbe	SHORT $LN13@CalculateS
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR [eax+1500]
	addss	xmm0, DWORD PTR [edx+1504]
	movss	DWORD PTR tv164[ebp], xmm0
	jmp	SHORT $LN14@CalculateS
$LN13@CalculateS:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv164[ebp], xmm0
$LN14@CalculateS:
	movss	xmm0, DWORD PTR tv164[ebp]
	movss	DWORD PTR tv165[ebp], xmm0
	jmp	SHORT $LN16@CalculateS
$LN15@CalculateS:
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR tv165[ebp], xmm0
$LN16@CalculateS:
	movss	xmm0, DWORD PTR tv165[ebp]
	mulss	xmm0, DWORD PTR _qfactor$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	mulss	xmm0, DWORD PTR [edx+136]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	mov	eax, DWORD PTR _sr$[ebp]
	movss	DWORD PTR [eax], xmm0

; 320  : 	}
; 321  : 	else {

	jmp	$LN1@CalculateS
$LN2@CalculateS:

; 322  : 		*sr = *sl = max ( min (af->pstick, 1.0F), -1.0F) * qfactor * af->auxaeroData->elevonMaxAngle * DTR;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR [edx+1500]
	jbe	SHORT $LN17@CalculateS
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [ecx+1500]
	movss	DWORD PTR tv179[ebp], xmm0
	jmp	SHORT $LN18@CalculateS
$LN17@CalculateS:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv179[ebp], xmm0
$LN18@CalculateS:
	movss	xmm0, DWORD PTR tv179[ebp]
	comiss	xmm0, DWORD PTR __real@bf800000
	jbe	SHORT $LN21@CalculateS
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR [eax+1500]
	jbe	SHORT $LN19@CalculateS
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR [edx+1500]
	movss	DWORD PTR tv188[ebp], xmm0
	jmp	SHORT $LN20@CalculateS
$LN19@CalculateS:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv188[ebp], xmm0
$LN20@CalculateS:
	movss	xmm0, DWORD PTR tv188[ebp]
	movss	DWORD PTR tv189[ebp], xmm0
	jmp	SHORT $LN22@CalculateS
$LN21@CalculateS:
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR tv189[ebp], xmm0
$LN22@CalculateS:
	movss	xmm0, DWORD PTR tv189[ebp]
	mulss	xmm0, DWORD PTR _qfactor$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	mulss	xmm0, DWORD PTR [edx+136]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	mov	eax, DWORD PTR _sl$[ebp]
	movss	DWORD PTR [eax], xmm0
	mov	ecx, DWORD PTR _sr$[ebp]
	mov	edx, DWORD PTR _sl$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
$LN1@CalculateS:

; 323  : 	}
; 324  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?CalculateStab@AircraftClass@@AAEXMPAM0@Z ENDP		; AircraftClass::CalculateStab
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\surface.cpp
_TEXT	SEGMENT
tv227 = -24						; size = 4
tv190 = -20						; size = 4
tv187 = -16						; size = 4
tv168 = -12						; size = 4
tv137 = -8						; size = 4
_this$ = -4						; size = 4
_qfactor$ = 8						; size = 4
?CalculateLef@AircraftClass@@AAEXM@Z PROC		; AircraftClass::CalculateLef
; _this$ = ecx

; 256  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 257  : 	// LEF
; 258  : 	if (af->auxaeroData->hasLef == AUX_LEFTEF_MANUAL) 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+80], 1
	jne	SHORT $LN17@CalculateL

; 259  : 	{
; 260  : 		// use pilot input
; 261  : 		leftLEFAngle = af->lefPos * DTR;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [ecx+1576]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+868], xmm0

; 262  : 		rightLEFAngle = af->lefPos * DTR;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [ecx+1576]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+872], xmm0
	jmp	$LN1@CalculateL
$LN17@CalculateL:

; 263  : 	}
; 264  : 	else if (af->auxaeroData->hasLef == AUX_LEFTEF_TEF) { // LEF controlled by TEF

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+80], 4
	jne	$LN15@CalculateL

; 265  : 		if (af->tefPos > 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [ecx+1580]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN14@CalculateL

; 266  : 			af->LEFMax();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+932]
	call	?LEFMax@AirframeClass@@QAEXXZ		; AirframeClass::LEFMax
	jmp	SHORT $LN13@CalculateL
$LN14@CalculateL:

; 267  : 		else af->LEFClose();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	call	?LEFClose@AirframeClass@@QAEXXZ		; AirframeClass::LEFClose
$LN13@CalculateL:

; 268  : 		leftLEFAngle = af->lefPos * DTR;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR [edx+1576]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+868], xmm0

; 269  : 		rightLEFAngle = af->lefPos * DTR;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR [edx+1576]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+872], xmm0

; 270  : 	}
; 271  : 	else 

	jmp	$LN1@CalculateL
$LN15@CalculateL:

; 272  : 	{
; 273  : 		if (!af->IsSet(AirframeClass::InAir))

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	jne	SHORT $LN11@CalculateL

; 274  : 		{
; 275  : 			leftLEFAngle = rightLEFAngle = af->auxaeroData->lefGround * DTR;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+4]
	movss	xmm0, DWORD PTR [ecx+168]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	movss	DWORD PTR tv137[ebp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv137[ebp]
	movss	DWORD PTR [edx+872], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv137[ebp]
	movss	DWORD PTR [eax+868], xmm0
	jmp	$LN4@CalculateL
$LN11@CalculateL:

; 276  : 		}
; 277  : 		else if (!g_bNewFm && af->mach > af->auxaeroData->lefMaxMach)

	movzx	ecx, BYTE PTR ?g_bNewFm@@3_NA		; g_bNewFm
	test	ecx, ecx
	jne	SHORT $LN9@CalculateL
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	ecx, DWORD PTR [edx+4]
	movss	xmm0, DWORD PTR [eax+1144]
	comiss	xmm0, DWORD PTR [ecx+172]
	jbe	SHORT $LN9@CalculateL

; 278  : 		{
; 279  : 			leftLEFAngle = rightLEFAngle = 0;;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+872], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+868], xmm0
	jmp	$LN4@CalculateL
$LN9@CalculateL:

; 280  : 		}
; 281  : 		else if (af->auxaeroData->hasLef == AUX_LEFTEF_AOA)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+80], 2
	jne	$LN7@CalculateL

; 282  : 		{
; 283  : 			leftLEFAngle = max (min(af->alpha,af->auxaeroData->lefMaxAngle)* DTR, 0.0f);//me123 lef is controled my aoa not mach

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	eax, DWORD PTR [ecx+4]
	movss	xmm0, DWORD PTR [eax+104]
	comiss	xmm0, DWORD PTR [edx+1152]
	jbe	SHORT $LN20@CalculateL
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR [edx+1152]
	movss	DWORD PTR tv168[ebp], xmm0
	jmp	SHORT $LN21@CalculateL
$LN20@CalculateL:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	movss	xmm0, DWORD PTR [edx+104]
	movss	DWORD PTR tv168[ebp], xmm0
$LN21@CalculateL:
	movss	xmm0, DWORD PTR tv168[ebp]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN24@CalculateL
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	edx, DWORD PTR [eax+4]
	movss	xmm0, DWORD PTR [edx+104]
	comiss	xmm0, DWORD PTR [ecx+1152]
	jbe	SHORT $LN22@CalculateL
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [ecx+1152]
	movss	DWORD PTR tv187[ebp], xmm0
	jmp	SHORT $LN23@CalculateL
$LN22@CalculateL:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+4]
	movss	xmm0, DWORD PTR [ecx+104]
	movss	DWORD PTR tv187[ebp], xmm0
$LN23@CalculateL:
	movss	xmm0, DWORD PTR tv187[ebp]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	movss	DWORD PTR tv190[ebp], xmm0
	jmp	SHORT $LN25@CalculateL
$LN24@CalculateL:
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv190[ebp], xmm0
$LN25@CalculateL:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv190[ebp]
	movss	DWORD PTR [edx+868], xmm0

; 284  : 			rightLEFAngle = leftLEFAngle;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+868]
	mov	DWORD PTR [eax+872], edx

; 285  : 			//MI additions
; 286  : 			if(g_bRealisticAvionics && g_bNewFm)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN5@CalculateL
	movzx	ecx, BYTE PTR ?g_bNewFm@@3_NA		; g_bNewFm
	test	ecx, ecx
	je	SHORT $LN5@CalculateL

; 287  : 			{
; 288  : 				if(g_bNewDamageEffects)

	movzx	edx, BYTE PTR ?g_bNewDamageEffects@@3_NA ; g_bNewDamageEffects
	test	edx, edx
	je	SHORT $LN5@CalculateL

; 289  : 				{
; 290  : 					leftLEFAngle = CheckLEF(0);	//left

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckLEF@AircraftClass@@QAEMH@Z	; AircraftClass::CheckLEF
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+868]

; 291  : 					rightLEFAngle = CheckLEF(1);	//right

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckLEF@AircraftClass@@QAEMH@Z	; AircraftClass::CheckLEF
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+872]
$LN5@CalculateL:

; 292  : 				}
; 293  : 			}
; 294  : 		}					  	  
; 295  : 		else

	jmp	$LN4@CalculateL
$LN7@CalculateL:

; 296  : 		{
; 297  : 			leftLEFAngle = min ((af->auxaeroData->lefMaxMach - af->mach) / 0.2F, 1.0F) * af->auxaeroData->lefMaxAngle * DTR;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR [ecx+172]
	subss	xmm0, DWORD PTR [eax+1144]
	divss	xmm0, DWORD PTR __real@3e4ccccd
	movss	xmm1, DWORD PTR __real@3f800000
	comiss	xmm1, xmm0
	jbe	SHORT $LN26@CalculateL
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR [eax+172]
	subss	xmm0, DWORD PTR [edx+1144]
	divss	xmm0, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR tv227[ebp], xmm0
	jmp	SHORT $LN27@CalculateL
$LN26@CalculateL:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv227[ebp], xmm0
$LN27@CalculateL:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	movss	xmm0, DWORD PTR tv227[ebp]
	mulss	xmm0, DWORD PTR [edx+104]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+868], xmm0

; 298  : 			rightLEFAngle = leftLEFAngle;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+868]
	mov	DWORD PTR [ecx+872], eax
$LN4@CalculateL:

; 299  : 		}
; 300  : 		if(LEFLocked && g_bRealisticAvionics && g_bNewFm)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+853]
	test	edx, edx
	je	SHORT $LN1@CalculateL
	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN1@CalculateL
	movzx	ecx, BYTE PTR ?g_bNewFm@@3_NA		; g_bNewFm
	test	ecx, ecx
	je	SHORT $LN1@CalculateL

; 301  : 		{ 
; 302  : 			if (IsComplex()) {

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsComplex@AircraftClass@@QAEHXZ	; AircraftClass::IsComplex
	test	eax, eax
	je	SHORT $LN2@CalculateL

; 303  : 				leftLEFAngle = GetDOFValue(COMP_LT_LEF);

	push	9
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDOFValue@SimMoverClass@@QAEMH@Z	; SimMoverClass::GetDOFValue
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+868]

; 304  : 				rightLEFAngle = GetDOFValue(COMP_RT_LEF);

	push	10					; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDOFValue@SimMoverClass@@QAEMH@Z	; SimMoverClass::GetDOFValue
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+872]

; 305  : 			}
; 306  : 			else {

	jmp	SHORT $LN1@CalculateL
$LN2@CalculateL:

; 307  : 				leftLEFAngle = GetDOFValue(SIMP_LT_LEF);

	push	22					; 00000016H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDOFValue@SimMoverClass@@QAEMH@Z	; SimMoverClass::GetDOFValue
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+868]

; 308  : 				rightLEFAngle = GetDOFValue(SIMP_RT_LEF);

	push	21					; 00000015H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDOFValue@SimMoverClass@@QAEMH@Z	; SimMoverClass::GetDOFValue
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+872]
$LN1@CalculateL:

; 309  : 			}
; 310  : 			
; 311  : 		} 
; 312  : 	}
; 313  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?CalculateLef@AircraftClass@@AAEXM@Z ENDP		; AircraftClass::CalculateLef
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\surface.cpp
_TEXT	SEGMENT
_stabAngle$ = -40					; size = 4
tv142 = -36						; size = 4
tv141 = -32						; size = 4
tv138 = -28						; size = 4
tv93 = -24						; size = 4
_gdelta$1 = -20						; size = 4
tv75 = -16						; size = 4
_flapdelta$ = -12					; size = 4
_speeddelta$2 = -8					; size = 4
_this$ = -4						; size = 4
_qfactor$ = 8						; size = 4
_al$ = 12						; size = 4
_ar$ = 16						; size = 4
_fl$ = 20						; size = 4
_fr$ = 24						; size = 4
?CalculateAileronAndFlap@AircraftClass@@AAEXMPAM000@Z PROC ; AircraftClass::CalculateAileronAndFlap
; _this$ = ecx

; 118  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 119  : 	float stabAngle;
; 120  : 	float flapdelta = 0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _flapdelta$[ebp], xmm0

; 121  : 	
; 122  : 	// elevators always working
; 123  : 	stabAngle = af->rstick * qfactor * af->auxaeroData->aileronMaxAngle * DTR;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [ecx+1504]
	mulss	xmm0, DWORD PTR _qfactor$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+4]
	mulss	xmm0, DWORD PTR [ecx+132]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	movss	DWORD PTR _stabAngle$[ebp], xmm0

; 124  : 	
; 125  : 	
; 126  : 	switch (af->auxaeroData->hasTef) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR tv75[ebp], edx
	cmp	DWORD PTR tv75[ebp], 1
	je	SHORT $LN6@CalculateA
	cmp	DWORD PTR tv75[ebp], 1
	jle	$LN7@CalculateA
	cmp	DWORD PTR tv75[ebp], 3
	jle	SHORT $LN5@CalculateA
	jmp	$LN7@CalculateA
$LN6@CalculateA:

; 127  : 	case AUX_LEFTEF_MANUAL: // nothing special here, just set to what given
; 128  : 		flapdelta = af->tefPos * DTR;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [ecx+1580]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	movss	DWORD PTR _flapdelta$[ebp], xmm0

; 129  : 		break;

	jmp	$LN7@CalculateA
$LN5@CalculateA:

; 130  : 	case AUX_LEFTEF_AOA: // nothing uses this yet. So not sure what happens
; 131  : 	case AUX_LEFTEF_MACH: // dependendant on vcas (not MACH despite the name)
; 132  : 		{
; 133  : 			float gdelta;
; 134  : 			float speeddelta;
; 135  : 			
; 136  : 			if (TEFExtend) // forcibly extended

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+851]
	test	eax, eax
	je	SHORT $LN4@CalculateA

; 137  : 				gdelta = 1;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _gdelta$1[ebp], xmm0
	jmp	SHORT $LN1@CalculateA
$LN4@CalculateA:

; 138  : 			else if (af->auxaeroData->flapGearRelative) // else dependent on gear deployment

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+176], 0
	je	SHORT $LN2@CalculateA

; 139  : 				gdelta = max(0,af->gearPos);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [edx+1552]
	jbe	SHORT $LN11@CalculateA
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv93[ebp], xmm0
	jmp	SHORT $LN12@CalculateA
$LN11@CalculateA:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [ecx+1552]
	movss	DWORD PTR tv93[ebp], xmm0
$LN12@CalculateA:
	movss	xmm0, DWORD PTR tv93[ebp]
	movss	DWORD PTR _gdelta$1[ebp], xmm0
	jmp	SHORT $LN1@CalculateA
$LN2@CalculateA:

; 140  : 			else gdelta = 1; // else always

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _gdelta$1[ebp], xmm0
$LN1@CalculateA:

; 141  : 			
; 142  : 			// work out how much flap we would have at this vcas
; 143  : 			speeddelta = (af->auxaeroData->maxFlapVcas - af->vcas) / 
; 144  : 				af->auxaeroData->flapVcasRange;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR [ecx+180]
	subss	xmm0, DWORD PTR [eax+1124]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	divss	xmm0, DWORD PTR [eax+184]
	movss	DWORD PTR _speeddelta$2[ebp], xmm0

; 145  : 			speeddelta = max(0.0F,min(1.0F, speeddelta)); //limit to 0-1 range

	movss	xmm0, DWORD PTR _speeddelta$2[ebp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN13@CalculateA
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv138[ebp], xmm0
	jmp	SHORT $LN14@CalculateA
$LN13@CalculateA:
	movss	xmm0, DWORD PTR _speeddelta$2[ebp]
	movss	DWORD PTR tv138[ebp], xmm0
$LN14@CalculateA:
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR tv138[ebp]
	jbe	SHORT $LN17@CalculateA
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv142[ebp], xmm0
	jmp	SHORT $LN18@CalculateA
$LN17@CalculateA:
	movss	xmm0, DWORD PTR _speeddelta$2[ebp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN15@CalculateA
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv141[ebp], xmm0
	jmp	SHORT $LN16@CalculateA
$LN15@CalculateA:
	movss	xmm0, DWORD PTR _speeddelta$2[ebp]
	movss	DWORD PTR tv141[ebp], xmm0
$LN16@CalculateA:
	movss	xmm0, DWORD PTR tv141[ebp]
	movss	DWORD PTR tv142[ebp], xmm0
$LN18@CalculateA:
	movss	xmm0, DWORD PTR tv142[ebp]
	movss	DWORD PTR _speeddelta$2[ebp], xmm0

; 146  : 			
; 147  : 			// max flaps * speed dependent factor (0-1) * gear delta (0-1)
; 148  : 			flapdelta = af->auxaeroData->tefMaxAngle  * DTR * speeddelta * gdelta;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	movss	xmm0, DWORD PTR [eax+100]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	mulss	xmm0, DWORD PTR _speeddelta$2[ebp]
	mulss	xmm0, DWORD PTR _gdelta$1[ebp]
	movss	DWORD PTR _flapdelta$[ebp], xmm0
$LN7@CalculateA:

; 149  : 			break;
; 150  : 		}
; 151  : 	}
; 152  : 	
; 153  : 	*al = stabAngle;

	mov	ecx, DWORD PTR _al$[ebp]
	movss	xmm0, DWORD PTR _stabAngle$[ebp]
	movss	DWORD PTR [ecx], xmm0

; 154  : 	*ar = -stabAngle;

	movss	xmm0, DWORD PTR _stabAngle$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, DWORD PTR _ar$[ebp]
	movss	DWORD PTR [edx], xmm0

; 155  : 	*fl = flapdelta;

	mov	eax, DWORD PTR _fl$[ebp]
	movss	xmm0, DWORD PTR _flapdelta$[ebp]
	movss	DWORD PTR [eax], xmm0

; 156  : 	*fr = flapdelta;

	mov	ecx, DWORD PTR _fr$[ebp]
	movss	xmm0, DWORD PTR _flapdelta$[ebp]
	movss	DWORD PTR [ecx], xmm0

; 157  : 	
; 158  : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?CalculateAileronAndFlap@AircraftClass@@AAEXMPAM000@Z ENDP ; AircraftClass::CalculateAileronAndFlap
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\surface.cpp
_TEXT	SEGMENT
tv145 = -28						; size = 4
_ailangle$ = -24					; size = 4
_cursweep$ = -20					; size = 4
_spmax$ = -16						; size = 4
_l$1 = -12						; size = 4
_brakeangle$ = -8					; size = 4
_this$ = -4						; size = 4
_sweep$ = 8						; size = 4
_sl1$ = 12						; size = 4
_sr1$ = 16						; size = 4
_sl2$ = 20						; size = 4
_sr2$ = 24						; size = 4
?CalculateSweepAndSpoiler@AircraftClass@@QAEXAAM0000@Z PROC ; AircraftClass::CalculateSweepAndSpoiler
; _this$ = ecx

; 162  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 163  : 	float ailangle, brakeangle=0, spmax, cursweep;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _brakeangle$[ebp], xmm0

; 164  : 	
; 165  : 	
; 166  : 	// Wing sweep for complex models //////////////////
; 167  : 	sweep=0;

	mov	eax, DWORD PTR _sweep$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax], xmm0

; 168  : 	cursweep=0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _cursweep$[ebp], xmm0

; 169  : 	if (acFlags & hasSwing)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+964]
	and	edx, 2
	je	$LN22@CalculateS

; 170  : 	{
; 171  : 		if (af->auxaeroData->animSwingWingStages)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+3084], 0
	je	$LN16@CalculateS

; 172  : 		{
; 173  : 			int l;
; 174  : 			
; 175  : 			if(af->auxaeroData->animSwingWingStages>10 || af->auxaeroData->animSwingWingStages<0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+3084], 10		; 0000000aH
	jg	SHORT $LN19@CalculateS
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+3084], 0
	jge	SHORT $LN20@CalculateS
$LN19@CalculateS:

; 176  : 			{
; 177  : 				MonoPrint("animSwingWingStages %d\n",af->auxaeroData->animSwingWingStages);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+3084]
	push	eax
	push	OFFSET ??_C@_0BI@MOPJIONH@animSwingWingStages?5?$CFd?6?$AA@
	call	_MonoPrint
	add	esp, 8
$LN20@CalculateS:

; 178  : 			}
; 179  : 			
; 180  : 			
; 181  : 			// scan in reverse
; 182  : 			for(l=(af->auxaeroData->animSwingWingStages-1) ; l>=0 ; l--)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+3084]
	sub	ecx, 1
	mov	DWORD PTR _l$1[ebp], ecx
	jmp	SHORT $LN18@CalculateS
$LN17@CalculateS:
	mov	edx, DWORD PTR _l$1[ebp]
	sub	edx, 1
	mov	DWORD PTR _l$1[ebp], edx
$LN18@CalculateS:
	cmp	DWORD PTR _l$1[ebp], 0
	jl	SHORT $LN16@CalculateS

; 183  : 			{
; 184  : 				if(af->mach >= af->auxaeroData->animSwingWingMach[l])

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _l$1[ebp]
	movss	xmm0, DWORD PTR [ecx+1144]
	comiss	xmm0, DWORD PTR [edx+eax*4+3092]
	jb	SHORT $LN15@CalculateS

; 185  : 				{
; 186  : 					sweep=af->auxaeroData->animSwingWingAngle[l];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _sweep$[ebp]
	mov	edx, DWORD PTR _l$1[ebp]
	mov	eax, DWORD PTR [eax+edx*4+3132]
	mov	DWORD PTR [ecx], eax

; 187  : 					break; // break for loop

	jmp	SHORT $LN16@CalculateS
$LN15@CalculateS:

; 188  : 				}
; 189  : 			}

	jmp	SHORT $LN17@CalculateS
$LN16@CalculateS:

; 190  : 		}
; 191  : 		sweep*=DTR;

	mov	ecx, DWORD PTR _sweep$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	mov	edx, DWORD PTR _sweep$[ebp]
	movss	DWORD PTR [edx], xmm0

; 192  : 		
; 193  : 		// need to retrieve current sweep position
; 194  : 		cursweep = GetDOFValue((IsComplex() ? COMP_SWING_WING : SIMP_SWING_WING_1));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsComplex@AircraftClass@@QAEHXZ	; AircraftClass::IsComplex
	test	eax, eax
	je	SHORT $LN25@CalculateS
	mov	DWORD PTR tv145[ebp], 46		; 0000002eH
	jmp	SHORT $LN26@CalculateS
$LN25@CalculateS:
	mov	DWORD PTR tv145[ebp], 11		; 0000000bH
$LN26@CalculateS:
	mov	eax, DWORD PTR tv145[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDOFValue@SimMoverClass@@QAEMH@Z	; SimMoverClass::GetDOFValue
	fstp	DWORD PTR _cursweep$[ebp]

; 195  : 		swingWingAngle = cursweep; // MLR 3/5/2004 - 

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _cursweep$[ebp]
	movss	DWORD PTR [ecx+3544], xmm0
$LN22@CalculateS:

; 196  : 	}
; 197  : 	
; 198  : 	
; 199  : 	// spoiler /////////////////////////////////
; 200  : 	
; 201  : 	ailangle = af->rstick;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR [eax+1504]
	movss	DWORD PTR _ailangle$[ebp], xmm0

; 202  : 	
; 203  : 	if(cursweep<af->auxaeroData->animSpoiler1OffAtWingSweep * DTR)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	movss	xmm0, DWORD PTR [eax+3008]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	comiss	xmm0, DWORD PTR _cursweep$[ebp]
	jbe	$LN14@CalculateS

; 204  : 	{
; 205  : 		if(af->auxaeroData->animSpoiler1AirBrake)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+3012], 0
	je	SHORT $LN13@CalculateS

; 206  : 			brakeangle = af->dbrake;    

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR [edx+1548]
	movss	DWORD PTR _brakeangle$[ebp], xmm0
$LN13@CalculateS:

; 207  : 		
; 208  : 		
; 209  : 		sl1 = brakeangle - ailangle;

	movss	xmm0, DWORD PTR _brakeangle$[ebp]
	subss	xmm0, DWORD PTR _ailangle$[ebp]
	mov	eax, DWORD PTR _sl1$[ebp]
	movss	DWORD PTR [eax], xmm0

; 210  : 		sr1 = brakeangle + ailangle;

	movss	xmm0, DWORD PTR _brakeangle$[ebp]
	addss	xmm0, DWORD PTR _ailangle$[ebp]
	mov	ecx, DWORD PTR _sr1$[ebp]
	movss	DWORD PTR [ecx], xmm0

; 211  : 		
; 212  : 		// limit spoiler travel
; 213  : 		if(sl1>1) sl1=1.0;

	mov	edx, DWORD PTR _sl1$[ebp]
	movss	xmm0, DWORD PTR [edx]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN12@CalculateS
	mov	eax, DWORD PTR _sl1$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax], xmm0
$LN12@CalculateS:

; 214  : 		if(sr1>1) sr1=1.0;

	mov	ecx, DWORD PTR _sr1$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN11@CalculateS
	mov	edx, DWORD PTR _sr1$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx], xmm0
$LN11@CalculateS:

; 215  : 		if(sl1<0) sl1=0.0;

	mov	eax, DWORD PTR _sl1$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [eax]
	jbe	SHORT $LN10@CalculateS
	mov	ecx, DWORD PTR _sl1$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx], xmm0
$LN10@CalculateS:

; 216  : 		if(sr1<0) sr1=0.0;

	mov	edx, DWORD PTR _sr1$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [edx]
	jbe	SHORT $LN9@CalculateS
	mov	eax, DWORD PTR _sr1$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax], xmm0
$LN9@CalculateS:

; 217  : 		
; 218  : 		spmax=af->auxaeroData->animSpoiler1Max * DTR;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	movss	xmm0, DWORD PTR [eax+3000]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	movss	DWORD PTR _spmax$[ebp], xmm0

; 219  : 		sl1 *= spmax;

	mov	ecx, DWORD PTR _sl1$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR _spmax$[ebp]
	mov	edx, DWORD PTR _sl1$[ebp]
	movss	DWORD PTR [edx], xmm0

; 220  : 		sr1 *= spmax;

	mov	eax, DWORD PTR _sr1$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR _spmax$[ebp]
	mov	ecx, DWORD PTR _sr1$[ebp]
	movss	DWORD PTR [ecx], xmm0

; 221  : 	}
; 222  : 	else

	jmp	SHORT $LN8@CalculateS
$LN14@CalculateS:

; 223  : 	{
; 224  : 		sl1=sr1=0;

	mov	edx, DWORD PTR _sr1$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx], xmm0
	mov	eax, DWORD PTR _sl1$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax], xmm0
$LN8@CalculateS:

; 225  : 	}
; 226  : 	
; 227  : 	if(cursweep<af->auxaeroData->animSpoiler2OffAtWingSweep * DTR)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	movss	xmm0, DWORD PTR [eax+3024]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	comiss	xmm0, DWORD PTR _cursweep$[ebp]
	jbe	$LN7@CalculateS

; 228  : 	{
; 229  : 		if(af->auxaeroData->animSpoiler2AirBrake)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+3028], 0
	je	SHORT $LN6@CalculateS

; 230  : 			brakeangle = af->dbrake;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR [edx+1548]
	movss	DWORD PTR _brakeangle$[ebp], xmm0
$LN6@CalculateS:

; 231  : 		
; 232  : 		sl2 = brakeangle - ailangle;

	movss	xmm0, DWORD PTR _brakeangle$[ebp]
	subss	xmm0, DWORD PTR _ailangle$[ebp]
	mov	eax, DWORD PTR _sl2$[ebp]
	movss	DWORD PTR [eax], xmm0

; 233  : 		sr2 = brakeangle + ailangle;

	movss	xmm0, DWORD PTR _brakeangle$[ebp]
	addss	xmm0, DWORD PTR _ailangle$[ebp]
	mov	ecx, DWORD PTR _sr2$[ebp]
	movss	DWORD PTR [ecx], xmm0

; 234  : 		
; 235  : 		// limit spoiler travel
; 236  : 		if(sl2>1) sl2=1.0;

	mov	edx, DWORD PTR _sl2$[ebp]
	movss	xmm0, DWORD PTR [edx]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN5@CalculateS
	mov	eax, DWORD PTR _sl2$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax], xmm0
$LN5@CalculateS:

; 237  : 		if(sr2>1) sr2=1.0;

	mov	ecx, DWORD PTR _sr2$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN4@CalculateS
	mov	edx, DWORD PTR _sr2$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx], xmm0
$LN4@CalculateS:

; 238  : 		if(sl2<0) sl2=0.0;

	mov	eax, DWORD PTR _sl2$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [eax]
	jbe	SHORT $LN3@CalculateS
	mov	ecx, DWORD PTR _sl2$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx], xmm0
$LN3@CalculateS:

; 239  : 		if(sr2<0) sr2=0.0;

	mov	edx, DWORD PTR _sr2$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [edx]
	jbe	SHORT $LN2@CalculateS
	mov	eax, DWORD PTR _sr2$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax], xmm0
$LN2@CalculateS:

; 240  : 		
; 241  : 		spmax=af->auxaeroData->animSpoiler2Max * DTR;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	movss	xmm0, DWORD PTR [eax+3016]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	movss	DWORD PTR _spmax$[ebp], xmm0

; 242  : 		sl2 *= spmax;

	mov	ecx, DWORD PTR _sl2$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR _spmax$[ebp]
	mov	edx, DWORD PTR _sl2$[ebp]
	movss	DWORD PTR [edx], xmm0

; 243  : 		sr2 *= spmax;

	mov	eax, DWORD PTR _sr2$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR _spmax$[ebp]
	mov	ecx, DWORD PTR _sr2$[ebp]
	movss	DWORD PTR [ecx], xmm0

; 244  : 	}
; 245  : 	else

	jmp	SHORT $LN1@CalculateS
$LN7@CalculateS:

; 246  : 	{
; 247  : 		sl2=sr2=0;

	mov	edx, DWORD PTR _sr2$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx], xmm0
	mov	eax, DWORD PTR _sl2$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax], xmm0
$LN1@CalculateS:

; 248  : 	}
; 249  : 	
; 250  : 	
; 251  : 	
; 252  : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?CalculateSweepAndSpoiler@AircraftClass@@QAEXAAM0000@Z ENDP ; AircraftClass::CalculateSweepAndSpoiler
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\surface.cpp
_TEXT	SEGMENT
tv881 = -80						; size = 4
tv871 = -76						; size = 4
tv866 = -72						; size = 4
tv859 = -68						; size = 4
tv843 = -64						; size = 4
tv879 = -60						; size = 4
tv836 = -56						; size = 4
tv811 = -52						; size = 4
tv801 = -48						; size = 4
tv790 = -44						; size = 4
tv743 = -40						; size = 4
tv734 = -36						; size = 4
tv715 = -32						; size = 4
tv706 = -28						; size = 4
_pos$1 = -24						; size = 4
_pos$2 = -20						; size = 4
_numgear$ = -16						; size = 4
_ng$3 = -12						; size = 4
_i$ = -8						; size = 4
_this$ = -4						; size = 4
?RunGearSurfaces@AircraftClass@@QAEXXZ PROC		; AircraftClass::RunGearSurfaces
; _this$ = ecx

; 1426 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	mov	DWORD PTR _this$[ebp], ecx

; 1427 : 	// sfr: this is called in move surface, responsible for moving 
; 1428 : 	// surfaces related to landing gears.
; 1429 : 	// the run landing gear function makes the computations needed
; 1430 : 	int numgear;
; 1431 : 	//this function is only valid for airplanes with complex gear
; 1432 : 	int i;
; 1433 : 	
; 1434 : 	// MLR 2003-10-04  must limit the original MPS code to animating 3 gear & door sets, 
; 1435 : 	// there are no DOFs for the rest
; 1436 : 	numgear=af->NumGear();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	call	?NumGear@AirframeClass@@QBEHXZ		; AirframeClass::NumGear
	mov	DWORD PTR _numgear$[ebp], eax

; 1437 : 	if(numgear>8) numgear=8;  // MLR 2/22/2004 - the limit is now 8

	cmp	DWORD PTR _numgear$[ebp], 8
	jle	SHORT $LN45@RunGearSur
	mov	DWORD PTR _numgear$[ebp], 8
$LN45@RunGearSur:

; 1438 : 	
; 1439 : 	if (IsLocal ())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsLocal@VuEntity@@QBEEXZ		; VuEntity::IsLocal
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN41@RunGearSur

; 1440 : 	{
; 1441 : 		if ((af->gearHandle > 0.0F || OnGround()) && !af->IsSet(AirframeClass::GearBroken)){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR [eax+1556]
	comiss	xmm0, DWORD PTR __real@00000000
	ja	SHORT $LN42@RunGearSur
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	je	SHORT $LN43@RunGearSur
$LN42@RunGearSur:
	push	2048					; 00000800H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	jne	SHORT $LN43@RunGearSur

; 1442 : 			SetAcStatusBits(ACSTATUS_GEAR_DOWN);

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAcStatusBits@AircraftClass@@QAEXH@Z	; AircraftClass::SetAcStatusBits

; 1443 : 		}
; 1444 : 		else {

	jmp	SHORT $LN41@RunGearSur
$LN43@RunGearSur:

; 1445 : 			ClearAcStatusBits(ACSTATUS_GEAR_DOWN);

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearAcStatusBits@AircraftClass@@QAEXH@Z ; AircraftClass::ClearAcStatusBits
$LN41@RunGearSur:

; 1446 : 		}
; 1447 : 	}
; 1448 : 	
; 1449 : 	if(af->auxaeroData->animWheelRadius[0])

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, 4
	imul	edx, 0
	movss	xmm0, DWORD PTR [ecx+edx+3172]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN36@RunGearSur

; 1450 : 	{ // MLR 2003-10-04 animate wheels.
; 1451 : 		// F4 only supports 3 gears currently (2003-10-04)
; 1452 : 		int ng=af->NumGear();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	call	?NumGear@AirframeClass@@QBEHXZ		; AirframeClass::NumGear
	mov	DWORD PTR _ng$3[ebp], eax

; 1453 : 		if(ng>8) ng=8;

	cmp	DWORD PTR _ng$3[ebp], 8
	jle	SHORT $LN39@RunGearSur
	mov	DWORD PTR _ng$3[ebp], 8
$LN39@RunGearSur:

; 1454 : 		for(i = 0; i < ng; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN38@RunGearSur
$LN37@RunGearSur:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN38@RunGearSur:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _ng$3[ebp]
	jge	SHORT $LN36@RunGearSur

; 1455 : 		{			
; 1456 : 			//af->gear[i].WheelAngle+=af->gear[i].WheelRPS * SimLibMajorFrameTime;
; 1457 : 			//af->gear[i].WheelAngle=fmod(af->gear[i].WheelAngle,PI*2); // MLR 1/6/2004 - 
; 1458 : 			// sfr: does not belong here, moved to RunLangindGear
; 1459 : 			//af->gear[i].WheelRPS *= (1 - .4f * SimLibMajorFrameTime); // slows wheel down
; 1460 : 			SetDOF(COMP_WHEEL_1+i,af->gear[i].WheelAngle);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR [ecx+1256]
	push	ecx
	movss	xmm0, DWORD PTR [eax+edx+16]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 50					; 00000032H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDOF@SimMoverClass@@QAEXHM@Z		; SimMoverClass::SetDOF

; 1461 : 			SetDOF(COMP_GEAREXTENSION_1+i,af->gear[i].StrutExtension);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR [eax+1256]
	push	ecx
	movss	xmm0, DWORD PTR [edx+ecx+24]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 58					; 0000003aH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDOF@SimMoverClass@@QAEXHM@Z		; SimMoverClass::SetDOF

; 1462 : 		}

	jmp	SHORT $LN37@RunGearSur
$LN36@RunGearSur:

; 1463 : 	}
; 1464 : 	
; 1465 : 	for(i = 0; i < numgear; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN35@RunGearSur
$LN34@RunGearSur:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN35@RunGearSur:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _numgear$[ebp]
	jge	$LN33@RunGearSur

; 1466 : 	{			
; 1467 : 		//move the door
; 1468 : 		if (!(af->gear[i].flags & GearData::DoorStuck) && !(af->gear[i].flags & GearData::DoorBroken))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR [ecx+1256]
	mov	ecx, DWORD PTR [eax+edx+12]
	and	ecx, 4
	jne	$LN32@RunGearSur
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR [eax+1256]
	mov	eax, DWORD PTR [edx+ecx+12]
	and	eax, 8
	jne	$LN32@RunGearSur

; 1469 : 		{
; 1470 : 			float pos = af->gearPos * 2;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR [edx+1552]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR _pos$2[ebp], xmm0

; 1471 : 			if(pos > 1.0)

	cvtss2sd xmm0, DWORD PTR _pos$2[ebp]
	comisd	xmm0, QWORD PTR __real@3ff0000000000000
	jbe	SHORT $LN31@RunGearSur

; 1472 : 				pos=1.0;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _pos$2[ebp], xmm0
$LN31@RunGearSur:

; 1473 : 
; 1474 : 			// MLR 2/22/2004 - 
; 1475 : 			SetDOF(ComplexGearDoorDOF[i], pos * af->GetAeroData(AeroDataSet::NosGearRng + i*4) * DTR);

	mov	eax, DWORD PTR _i$[ebp]
	lea	ecx, DWORD PTR [eax*4+17]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+932]
	call	?GetAeroData@AirframeClass@@QBEMH@Z	; AirframeClass::GetAeroData
	fstp	DWORD PTR tv706[ebp]
	movss	xmm0, DWORD PTR tv706[ebp]
	mulss	xmm0, DWORD PTR _pos$2[ebp]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?ComplexGearDoorDOF@@3PAHA[eax*4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDOF@SimMoverClass@@QAEXHM@Z		; SimMoverClass::SetDOF

; 1476 : 		}
; 1477 : 		else

	jmp	SHORT $LN30@RunGearSur
$LN32@RunGearSur:

; 1478 : 			SetDOF(ComplexGearDoorDOF[i], af->GetAeroData(AeroDataSet::NosGearRng) * DTR);

	push	17					; 00000011H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+932]
	call	?GetAeroData@AirframeClass@@QBEMH@Z	; AirframeClass::GetAeroData
	fstp	DWORD PTR tv715[ebp]
	movss	xmm0, DWORD PTR tv715[ebp]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?ComplexGearDoorDOF@@3PAHA[eax*4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDOF@SimMoverClass@@QAEXHM@Z		; SimMoverClass::SetDOF
$LN30@RunGearSur:

; 1479 : 		
; 1480 : 		//move the gear
; 1481 : 		if (!(af->gear[i].flags & GearData::GearStuck) && !(af->gear[i].flags & GearData::GearBroken))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR [eax+1256]
	mov	eax, DWORD PTR [edx+ecx+12]
	and	eax, 1
	jne	$LN29@RunGearSur
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR [edx+1256]
	mov	edx, DWORD PTR [ecx+eax+12]
	and	edx, 2
	jne	$LN29@RunGearSur

; 1482 : 		{
; 1483 : 			float pos = (af->gearPos - .5f) * 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [ecx+1552]
	subss	xmm0, DWORD PTR __real@3f000000
	mulss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR _pos$1[ebp], xmm0

; 1484 : 			if (pos < 0.0)

	cvtss2sd xmm0, DWORD PTR _pos$1[ebp]
	movsd	xmm1, QWORD PTR __real@0000000000000000
	comisd	xmm1, xmm0
	jbe	SHORT $LN28@RunGearSur

; 1485 : 				pos=0.0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _pos$1[ebp], xmm0
$LN28@RunGearSur:

; 1486 : 
; 1487 : 			// MLR 2/22/2004 - 
; 1488 : 			SetDOF(ComplexGearDOF[i], pos * af->GetAeroData(AeroDataSet::NosGearRng + i*4) * DTR);

	mov	edx, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [edx*4+17]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+932]
	call	?GetAeroData@AirframeClass@@QBEMH@Z	; AirframeClass::GetAeroData
	fstp	DWORD PTR tv734[ebp]
	movss	xmm0, DWORD PTR tv734[ebp]
	mulss	xmm0, DWORD PTR _pos$1[ebp]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR ?ComplexGearDOF@@3PAHA[edx*4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDOF@SimMoverClass@@QAEXHM@Z		; SimMoverClass::SetDOF

; 1489 : 		}
; 1490 : 		else

	jmp	SHORT $LN27@RunGearSur
$LN29@RunGearSur:

; 1491 : 			SetDOF(ComplexGearDOF[i], af->GetAeroData(AeroDataSet::NosGearRng) * 0.6f * DTR);

	push	17					; 00000011H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+932]
	call	?GetAeroData@AirframeClass@@QBEMH@Z	; AirframeClass::GetAeroData
	fstp	DWORD PTR tv743[ebp]
	movss	xmm0, DWORD PTR tv743[ebp]
	mulss	xmm0, DWORD PTR __real@3f19999a
	mulss	xmm0, DWORD PTR __real@3c8efa34
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR ?ComplexGearDOF@@3PAHA[edx*4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDOF@SimMoverClass@@QAEXHM@Z		; SimMoverClass::SetDOF
$LN27@RunGearSur:

; 1492 : 		
; 1493 : 		if (af->gearPos >= 0.9F && ((af->gear[i].flags & GearData::DoorBroken) 
; 1494 : 					|| (af->gear[i].flags & GearData::DoorStuck) 
; 1495 : 					|| (af->gear[i].flags & GearData::GearStuck) 
; 1496 : 					|| (af->gear[i].flags & GearData::GearBroken)))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR [edx+1552]
	comiss	xmm0, DWORD PTR __real@3f666666
	jb	$LN26@RunGearSur
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR [ecx+1256]
	mov	ecx, DWORD PTR [eax+edx+12]
	and	ecx, 8
	jne	SHORT $LN25@RunGearSur
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR [eax+1256]
	mov	eax, DWORD PTR [edx+ecx+12]
	and	eax, 4
	jne	SHORT $LN25@RunGearSur
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR [edx+1256]
	mov	edx, DWORD PTR [ecx+eax+12]
	and	edx, 1
	jne	SHORT $LN25@RunGearSur
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR [ecx+1256]
	mov	ecx, DWORD PTR [eax+edx+12]
	and	ecx, 2
	je	$LN26@RunGearSur
$LN25@RunGearSur:

; 1497 : 		{
; 1498 : 			if ((af->gear[i].flags & GearData::DoorBroken) || (af->gear[i].flags & GearData::DoorStuck))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR [eax+1256]
	mov	eax, DWORD PTR [edx+ecx+12]
	and	eax, 8
	jne	SHORT $LN23@RunGearSur
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR [edx+1256]
	mov	edx, DWORD PTR [ecx+eax+12]
	and	edx, 4
	je	SHORT $LN24@RunGearSur
$LN23@RunGearSur:

; 1499 : 				SetSwitch (ComplexGearDoorSwitch[i], TRUE);

	push	1
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?ComplexGearDoorSwitch@@3PAHA[eax*4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSwitch@SimMoverClass@@QAEXHH@Z	; SimMoverClass::SetSwitch
$LN24@RunGearSur:

; 1500 : 			
; 1501 : 			if ((af->gear[i].flags & GearData::DoorBroken) || (af->gear[i].flags & GearData::DoorStuck))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR [eax+1256]
	mov	eax, DWORD PTR [edx+ecx+12]
	and	eax, 8
	jne	SHORT $LN21@RunGearSur
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR [edx+1256]
	mov	edx, DWORD PTR [ecx+eax+12]
	and	edx, 4
	je	SHORT $LN22@RunGearSur
$LN21@RunGearSur:

; 1502 : 				SetSwitch (ComplexGearHoleSwitch[i], TRUE);

	push	1
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?ComplexGearHoleSwitch@@3PAHA[eax*4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSwitch@SimMoverClass@@QAEXHH@Z	; SimMoverClass::SetSwitch
$LN22@RunGearSur:

; 1503 : 			
; 1504 : 			if ((af->gear[i].flags & GearData::GearBroken) || (af->gear[i].flags & GearData::GearStuck))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR [eax+1256]
	mov	eax, DWORD PTR [edx+ecx+12]
	and	eax, 2
	jne	SHORT $LN19@RunGearSur
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR [edx+1256]
	mov	edx, DWORD PTR [ecx+eax+12]
	and	edx, 1
	je	SHORT $LN20@RunGearSur
$LN19@RunGearSur:

; 1505 : 				SetSwitch (ComplexGearSwitch[i], TRUE);

	push	1
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?ComplexGearSwitch@@3PAHA[eax*4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSwitch@SimMoverClass@@QAEXHH@Z	; SimMoverClass::SetSwitch
$LN20@RunGearSur:

; 1506 : 		}
; 1507 : 		else

	jmp	$LN12@RunGearSur
$LN26@RunGearSur:

; 1508 : 		{
; 1509 : 			if(GetDOFValue(ComplexGearDoorDOF[i]) < 5.0F*DTR)

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR ?ComplexGearDoorDOF@@3PAHA[edx*4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDOFValue@SimMoverClass@@QAEMH@Z	; SimMoverClass::GetDOFValue
	fstp	DWORD PTR tv790[ebp]
	movss	xmm0, DWORD PTR __real@3db2b8c1
	comiss	xmm0, DWORD PTR tv790[ebp]
	jbe	SHORT $LN17@RunGearSur

; 1510 : 				SetSwitch (ComplexGearDoorSwitch[i], FALSE);

	push	0
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR ?ComplexGearDoorSwitch@@3PAHA[ecx*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSwitch@SimMoverClass@@QAEXHH@Z	; SimMoverClass::SetSwitch

; 1511 : 			else

	jmp	SHORT $LN16@RunGearSur
$LN17@RunGearSur:

; 1512 : 				SetSwitch (ComplexGearDoorSwitch[i], TRUE);

	push	1
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?ComplexGearDoorSwitch@@3PAHA[eax*4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSwitch@SimMoverClass@@QAEXHH@Z	; SimMoverClass::SetSwitch
$LN16@RunGearSur:

; 1513 : 			
; 1514 : 			if(GetDOFValue(ComplexGearDoorDOF[i]) > 5.0F*DTR)

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR ?ComplexGearDoorDOF@@3PAHA[edx*4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDOFValue@SimMoverClass@@QAEMH@Z	; SimMoverClass::GetDOFValue
	fstp	DWORD PTR tv801[ebp]
	movss	xmm0, DWORD PTR tv801[ebp]
	comiss	xmm0, DWORD PTR __real@3db2b8c1
	jbe	SHORT $LN15@RunGearSur

; 1515 : 				SetSwitch (ComplexGearHoleSwitch[i], TRUE);

	push	1
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR ?ComplexGearHoleSwitch@@3PAHA[ecx*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSwitch@SimMoverClass@@QAEXHH@Z	; SimMoverClass::SetSwitch

; 1516 : 			else

	jmp	SHORT $LN14@RunGearSur
$LN15@RunGearSur:

; 1517 : 				SetSwitch (ComplexGearHoleSwitch[i], FALSE);

	push	0
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?ComplexGearHoleSwitch@@3PAHA[eax*4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSwitch@SimMoverClass@@QAEXHH@Z	; SimMoverClass::SetSwitch
$LN14@RunGearSur:

; 1518 : 			
; 1519 : 			if(GetDOFValue(ComplexGearDOF[i]) > 5.0F*DTR)

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR ?ComplexGearDOF@@3PAHA[edx*4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDOFValue@SimMoverClass@@QAEMH@Z	; SimMoverClass::GetDOFValue
	fstp	DWORD PTR tv811[ebp]
	movss	xmm0, DWORD PTR tv811[ebp]
	comiss	xmm0, DWORD PTR __real@3db2b8c1
	jbe	SHORT $LN13@RunGearSur

; 1520 : 				SetSwitch (ComplexGearSwitch[i], TRUE);

	push	1
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR ?ComplexGearSwitch@@3PAHA[ecx*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSwitch@SimMoverClass@@QAEXHH@Z	; SimMoverClass::SetSwitch

; 1521 : 			else

	jmp	SHORT $LN12@RunGearSur
$LN13@RunGearSur:

; 1522 : 				SetSwitch (ComplexGearSwitch[i], FALSE);

	push	0
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?ComplexGearSwitch@@3PAHA[eax*4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSwitch@SimMoverClass@@QAEXHH@Z	; SimMoverClass::SetSwitch
$LN12@RunGearSur:

; 1523 : 		}
; 1524 : 	}

	jmp	$LN34@RunGearSur
$LN33@RunGearSur:

; 1525 : 	
; 1526 : 	if(af->IsSet(AirframeClass::NoseSteerOn))

	push	4194304					; 00400000H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	$LN11@RunGearSur

; 1527 : 	{
; 1528 : 		if(!(af->gear[0].flags & GearData::GearStuck))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, 28					; 0000001cH
	imul	edx, 0
	mov	eax, DWORD PTR [ecx+1256]
	mov	ecx, DWORD PTR [eax+edx+12]
	and	ecx, 1
	jne	$LN4@RunGearSur

; 1529 : 		{
; 1530 : 			// ASSOCIATOR 30/11/03 Added g_bRollLinkedNWSRudder for roll unlinked rudder on the ground
; 1531 : 			// RAS 05Apr04 chanded ypedal to lastYPedal and rstick to lastRStick so that nosewheel will track movement of plane
; 1532 : 			// lastRStick and lastYPedal defined in EOM.cpp
; 1533 : 			// RAS 06Apr04 changed 30.0F to 50.0F to make graphical nose wheel match rate of turn.  Acutal turn radius needs to be
; 1534 : 			// looked at.  Real F-16 nose wheel turns 32.0 degrees
; 1535 : 			if(IO.AnalogIsUsed(AXIS_YAW) && !af->IsSet(AirframeClass::IsDigital) || !g_bRollLinkedNWSRudder ) 	// Retro 31Dec2003

	push	2
	mov	ecx, OFFSET ?IO@@3VSIMLIB_IO_CLASS@@A	; IO
	call	?AnalogIsUsed@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z ; SIMLIB_IO_CLASS::AnalogIsUsed
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN7@RunGearSur
	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN8@RunGearSur
$LN7@RunGearSur:
	movzx	ecx, BYTE PTR ?g_bRollLinkedNWSRudder@@3_NA ; g_bRollLinkedNWSRudder
	test	ecx, ecx
	jne	SHORT $LN9@RunGearSur
$LN8@RunGearSur:

; 1536 : 			{
; 1537 : 				SetDOF(COMP_NOS_GEAR_ROT, -af->lastYPedal*50.0F*DTR*(0.5F + (80.0F*KNOTS_TO_FTPSEC - af->vt)/(160.0F * KNOTS_TO_FTPSEC)));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR [eax+832]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR __real@42480000
	mulss	xmm0, DWORD PTR __real@3c8efa34
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm1, DWORD PTR __real@430706e2
	subss	xmm1, DWORD PTR [edx+1120]
	divss	xmm1, DWORD PTR __real@438706e2
	addss	xmm1, DWORD PTR __real@3f000000
	mulss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	5
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDOF@SimMoverClass@@QAEXHM@Z		; SimMoverClass::SetDOF

; 1538 : 			}
; 1539 : 			else 

	jmp	$LN4@RunGearSur
$LN9@RunGearSur:

; 1540 : 			{
; 1541 : 				if( fabs(af->lastRStick) > fabs(af->lastYPedal) )  // ASSOCIATOR: Added check so that we can use rudder keys and stick

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+828]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv836[ebp]
	movss	xmm0, DWORD PTR tv836[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	push	ecx
	movss	xmm1, DWORD PTR [eax+832]
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv879[ebp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv843[ebp]
	movss	xmm0, DWORD PTR tv879[ebp]
	comiss	xmm0, DWORD PTR tv843[ebp]
	jbe	SHORT $LN5@RunGearSur

; 1542 : 				{
; 1543 : 					SetDOF(COMP_NOS_GEAR_ROT, af->lastRStick*50.0F*DTR*(0.5F + (80.0F*KNOTS_TO_FTPSEC - af->vt)/(160.0F * KNOTS_TO_FTPSEC)));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR [edx+828]
	mulss	xmm0, DWORD PTR __real@42480000
	mulss	xmm0, DWORD PTR __real@3c8efa34
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm1, DWORD PTR __real@430706e2
	subss	xmm1, DWORD PTR [ecx+1120]
	divss	xmm1, DWORD PTR __real@438706e2
	addss	xmm1, DWORD PTR __real@3f000000
	mulss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	5
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDOF@SimMoverClass@@QAEXHM@Z		; SimMoverClass::SetDOF

; 1544 : 				}
; 1545 : 				else 

	jmp	SHORT $LN4@RunGearSur
$LN5@RunGearSur:

; 1546 : 				{
; 1547 : 					SetDOF(COMP_NOS_GEAR_ROT, -af->lastYPedal*50.0F*DTR*(0.5F + (80.0F*KNOTS_TO_FTPSEC - af->vt)/(160.0F * KNOTS_TO_FTPSEC)));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR [eax+832]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR __real@42480000
	mulss	xmm0, DWORD PTR __real@3c8efa34
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm1, DWORD PTR __real@430706e2
	subss	xmm1, DWORD PTR [edx+1120]
	divss	xmm1, DWORD PTR __real@438706e2
	addss	xmm1, DWORD PTR __real@3f000000
	mulss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	5
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDOF@SimMoverClass@@QAEXHM@Z		; SimMoverClass::SetDOF
$LN4@RunGearSur:

; 1548 : 				}
; 1549 : 			}
; 1550 : 		}
; 1551 : 	}
; 1552 : 	else 

	jmp	SHORT $LN3@RunGearSur
$LN11@RunGearSur:

; 1553 : 		SetDOF(COMP_NOS_GEAR_ROT,GetDOFValue(COMP_NOS_GEAR_ROT)*0.9F);

	push	5
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDOFValue@SimMoverClass@@QAEMH@Z	; SimMoverClass::GetDOFValue
	fstp	DWORD PTR tv859[ebp]
	movss	xmm0, DWORD PTR tv859[ebp]
	mulss	xmm0, DWORD PTR __real@3f666666
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	5
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDOF@SimMoverClass@@QAEXHM@Z		; SimMoverClass::SetDOF
$LN3@RunGearSur:

; 1554 : 		
; 1555 : 	if (GetDOFValue(ComplexGearDOF[0]) == af->GetAeroData(AeroDataSet::NosGearRng)*DTR && !(af->gear[0].flags & GearData::DoorBroken))

	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR ?ComplexGearDOF@@3PAHA[eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDOFValue@SimMoverClass@@QAEMH@Z	; SimMoverClass::GetDOFValue
	fstp	DWORD PTR tv866[ebp]
	movss	xmm0, DWORD PTR tv866[ebp]
	push	17					; 00000011H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+932]
	movss	DWORD PTR tv881[ebp], xmm0
	call	?GetAeroData@AirframeClass@@QBEMH@Z	; AirframeClass::GetAeroData
	fstp	DWORD PTR tv871[ebp]
	movss	xmm0, DWORD PTR tv871[ebp]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	movss	xmm1, DWORD PTR tv881[ebp]
	ucomiss	xmm1, xmm0
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@RunGearSur
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, 28					; 0000001cH
	imul	edx, 0
	mov	eax, DWORD PTR [ecx+1256]
	mov	ecx, DWORD PTR [eax+edx+12]
	and	ecx, 8
	jne	SHORT $LN2@RunGearSur

; 1556 : 		SetSwitch (COMP_NOS_GEAR_ROD, TRUE);

	push	1
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSwitch@SimMoverClass@@QAEXHH@Z	; SimMoverClass::SetSwitch

; 1557 : 	else

	jmp	SHORT $LN1@RunGearSur
$LN2@RunGearSur:

; 1558 : 		SetSwitch (COMP_NOS_GEAR_ROD, FALSE);

	push	0
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSwitch@SimMoverClass@@QAEXHH@Z	; SimMoverClass::SetSwitch
$LN1@RunGearSur:

; 1559 : 	
; 1560 : 	
; 1561 : #if 0
; 1562 : 	if ( gACMIRec.IsRecording() )
; 1563 : 	{
; 1564 : 		acmiSwitch.hdr.time = SimLibElapsedTime * MSEC_TO_SEC + OTWDriver.todOffset;
; 1565 : 		acmiSwitch.data.type = Type();
; 1566 : 		acmiSwitch.data.uniqueID = ACMIIDTable->Add(Id(),NULL,0);//.num_;
; 1567 : 		DOFRec.hdr.time = SimLibElapsedTime * MSEC_TO_SEC + OTWDriver.todOffset;
; 1568 : 		DOFRec.data.type = Type();
; 1569 : 		DOFRec.data.uniqueID = ACMIIDTable->Add(Id(),NULL,0);//.num_;
; 1570 : 		
; 1571 : 		if ( switch1 != GetSwitch(COMP_NOS_GEAR_SW) )
; 1572 : 		{
; 1573 : 			acmiSwitch.data.switchNum = COMP_NOS_GEAR_SW;
; 1574 : 			acmiSwitch.data.switchVal = GetSwitch(COMP_NOS_GEAR_SW);
; 1575 : 			acmiSwitch.data.prevSwitchVal = switch1;
; 1576 : 			gACMIRec.SwitchRecord( &acmiSwitch );
; 1577 : 		}
; 1578 : 		if ( switch2 != GetSwitch(COMP_LT_GEAR_SW) )
; 1579 : 		{
; 1580 : 			acmiSwitch.data.switchNum = COMP_LT_GEAR_SW;
; 1581 : 			acmiSwitch.data.switchVal = GetSwitch(COMP_LT_GEAR_SW);
; 1582 : 			acmiSwitch.data.prevSwitchVal = switch2;
; 1583 : 			gACMIRec.SwitchRecord( &acmiSwitch );
; 1584 : 		}
; 1585 : 		if ( switch3 != GetSwitch(COMP_RT_GEAR_SW) )
; 1586 : 		{
; 1587 : 			acmiSwitch.data.switchNum = COMP_RT_GEAR_SW;
; 1588 : 			acmiSwitch.data.switchVal = GetSwitch(COMP_RT_GEAR_SW);
; 1589 : 			acmiSwitch.data.prevSwitchVal = switch3;
; 1590 : 			gACMIRec.SwitchRecord( &acmiSwitch );
; 1591 : 		}
; 1592 : 		if ( switch4 != GetSwitch(COMP_NOS_GEAR_ROD) )
; 1593 : 		{
; 1594 : 			acmiSwitch.data.switchNum = COMP_NOS_GEAR_ROD;
; 1595 : 			acmiSwitch.data.switchVal = GetSwitch(COMP_NOS_GEAR_ROD);
; 1596 : 			acmiSwitch.data.prevSwitchVal = switch4;
; 1597 : 			gACMIRec.SwitchRecord( &acmiSwitch );
; 1598 : 		}
; 1599 : 		if ( switch7 != GetSwitch(COMP_TAIL_STROBE) )
; 1600 : 		{
; 1601 : 			acmiSwitch.data.switchNum = COMP_TAIL_STROBE;
; 1602 : 			acmiSwitch.data.switchVal = GetSwitch(COMP_TAIL_STROBE);
; 1603 : 			acmiSwitch.data.prevSwitchVal = switch7;
; 1604 : 			gACMIRec.SwitchRecord( &acmiSwitch );
; 1605 : 		}
; 1606 : 		if ( switch8 != GetSwitch(COMP_NAV_LIGHTS) )
; 1607 : 		{
; 1608 : 			acmiSwitch.data.switchNum = COMP_NAV_LIGHTS;
; 1609 : 			acmiSwitch.data.switchVal = GetSwitch(COMP_NAV_LIGHTS);
; 1610 : 			acmiSwitch.data.prevSwitchVal = switch8;
; 1611 : 			gACMIRec.SwitchRecord( &acmiSwitch );
; 1612 : 		}
; 1613 : 		if ( switch9 != GetSwitch(COMP_LAND_LIGHTS) )
; 1614 : 		{
; 1615 : 			acmiSwitch.data.switchNum = COMP_LAND_LIGHTS;
; 1616 : 			acmiSwitch.data.switchVal = GetSwitch(COMP_LAND_LIGHTS);
; 1617 : 			acmiSwitch.data.prevSwitchVal = switch9;
; 1618 : 			gACMIRec.SwitchRecord( &acmiSwitch );
; 1619 : 		}
; 1620 : 		if ( switch14 != GetSwitch(COMP_NOS_GEAR_DR_SW) )
; 1621 : 		{
; 1622 : 			acmiSwitch.data.switchNum = COMP_NOS_GEAR_DR_SW;
; 1623 : 			acmiSwitch.data.switchVal = GetSwitch(COMP_NOS_GEAR_DR_SW);
; 1624 : 			acmiSwitch.data.prevSwitchVal = switch14;
; 1625 : 			gACMIRec.SwitchRecord( &acmiSwitch );
; 1626 : 		}
; 1627 : 		if ( switch15 != GetSwitch(COMP_LT_GEAR_DR_SW) )
; 1628 : 		{
; 1629 : 			acmiSwitch.data.switchNum = COMP_LT_GEAR_DR_SW;
; 1630 : 			acmiSwitch.data.switchVal = GetSwitch(COMP_LT_GEAR_DR_SW);
; 1631 : 			acmiSwitch.data.prevSwitchVal = switch15;
; 1632 : 			gACMIRec.SwitchRecord( &acmiSwitch );
; 1633 : 		}
; 1634 : 		if ( switch16 != GetSwitch(COMP_RT_GEAR_DR_SW) )
; 1635 : 		{
; 1636 : 			acmiSwitch.data.switchNum = COMP_RT_GEAR_DR_SW;
; 1637 : 			acmiSwitch.data.switchVal = GetSwitch(COMP_RT_GEAR_DR_SW);
; 1638 : 			acmiSwitch.data.prevSwitchVal = switch16;
; 1639 : 			gACMIRec.SwitchRecord( &acmiSwitch );
; 1640 : 		}
; 1641 : 		if ( switch17 != GetSwitch(COMP_NOS_GEAR_HOLE) )
; 1642 : 		{
; 1643 : 			acmiSwitch.data.switchNum = COMP_NOS_GEAR_HOLE;
; 1644 : 			acmiSwitch.data.switchVal = GetSwitch(COMP_NOS_GEAR_HOLE);
; 1645 : 			acmiSwitch.data.prevSwitchVal = switch17;
; 1646 : 			gACMIRec.SwitchRecord( &acmiSwitch );
; 1647 : 		}
; 1648 : 		if ( switch18 != GetSwitch(COMP_LT_GEAR_HOLE) )
; 1649 : 		{
; 1650 : 			acmiSwitch.data.switchNum = COMP_LT_GEAR_HOLE;
; 1651 : 			acmiSwitch.data.switchVal = GetSwitch(COMP_LT_GEAR_HOLE);
; 1652 : 			acmiSwitch.data.prevSwitchVal = switch18;
; 1653 : 			gACMIRec.SwitchRecord( &acmiSwitch );
; 1654 : 		}
; 1655 : 		if ( switch19 != GetSwitch(COMP_RT_GEAR_HOLE) )
; 1656 : 		{
; 1657 : 			acmiSwitch.data.switchNum = COMP_RT_GEAR_HOLE;
; 1658 : 			acmiSwitch.data.switchVal = GetSwitch(COMP_RT_GEAR_HOLE);
; 1659 : 			acmiSwitch.data.prevSwitchVal = switch19;
; 1660 : 			gACMIRec.SwitchRecord( &acmiSwitch );
; 1661 : 		}
; 1662 : 		/*		if ( switch20 != GetSwitch(COMP_BROKEN_NOS_GEAR) )
; 1663 : 		{
; 1664 : 		acmiSwitch.data.switchNum = COMP_BROKEN_NOS_GEAR;
; 1665 : 		acmiSwitch.data.switchVal = GetSwitch(COMP_BROKEN_NOS_GEAR);
; 1666 : 		acmiSwitch.data.prevSwitchVal = switch20;
; 1667 : 		gACMIRec.SwitchRecord( &acmiSwitch );
; 1668 : 		}
; 1669 : 		if ( switch21 != GetSwitch(COMP_BROKEN_LT_GEAR) )
; 1670 : 		{
; 1671 : 		acmiSwitch.data.switchNum = COMP_BROKEN_LT_GEAR;
; 1672 : 		acmiSwitch.data.switchVal = GetSwitch(COMP_BROKEN_LT_GEAR);
; 1673 : 		acmiSwitch.data.prevSwitchVal = switch21;
; 1674 : 		gACMIRec.SwitchRecord( &acmiSwitch );
; 1675 : 		}
; 1676 : 		if ( switch22 != GetSwitch(COMP_BROKEN_RT_GEAR) )
; 1677 : 		{
; 1678 : 		acmiSwitch.data.switchNum = COMP_BROKEN_RT_GEAR;
; 1679 : 		acmiSwitch.data.switchVal = GetSwitch(COMP_BROKEN_RT_GEAR);
; 1680 : 		acmiSwitch.data.prevSwitchVal = switch22;
; 1681 : 		gACMIRec.SwitchRecord( &acmiSwitch );
; 1682 : }*/
; 1683 : 		
; 1684 : 		if ( dof19 != GetDOFValue(COMP_NOS_GEAR) )
; 1685 : 		{
; 1686 : 			DOFRec.data.DOFNum = COMP_NOS_GEAR;
; 1687 : 			DOFRec.data.DOFVal = GetDOFValue(COMP_NOS_GEAR);
; 1688 : 			DOFRec.data.prevDOFVal = dof19;
; 1689 : 			gACMIRec.DOFRecord( &DOFRec );
; 1690 : 		}
; 1691 : 		if ( dof20 != GetDOFValue(COMP_LT_GEAR) )
; 1692 : 		{
; 1693 : 			DOFRec.data.DOFNum = COMP_LT_GEAR;
; 1694 : 			DOFRec.data.DOFVal = GetDOFValue(COMP_LT_GEAR);
; 1695 : 			DOFRec.data.prevDOFVal = dof20;
; 1696 : 			gACMIRec.DOFRecord( &DOFRec );
; 1697 : 		}
; 1698 : 		if ( dof21 != GetDOFValue(COMP_RT_GEAR) )
; 1699 : 		{
; 1700 : 			DOFRec.data.DOFNum = COMP_RT_GEAR;
; 1701 : 			DOFRec.data.DOFVal = GetDOFValue(COMP_RT_GEAR);
; 1702 : 			DOFRec.data.prevDOFVal = dof21;
; 1703 : 			gACMIRec.DOFRecord( &DOFRec );
; 1704 : 		}
; 1705 : 		if ( dof22 != GetDOFValue(COMP_NOS_GEAR_DR) )
; 1706 : 		{
; 1707 : 			DOFRec.data.DOFNum = COMP_NOS_GEAR_DR;
; 1708 : 			DOFRec.data.DOFVal = GetDOFValue(COMP_NOS_GEAR_DR);
; 1709 : 			DOFRec.data.prevDOFVal = dof22;
; 1710 : 			gACMIRec.DOFRecord( &DOFRec );
; 1711 : 		}
; 1712 : 		if ( dof23 != GetDOFValue(COMP_LT_GEAR_DR) )
; 1713 : 		{
; 1714 : 			DOFRec.data.DOFNum = COMP_LT_GEAR_DR;
; 1715 : 			DOFRec.data.DOFVal = GetDOFValue(COMP_LT_GEAR_DR);
; 1716 : 			DOFRec.data.prevDOFVal = dof23;
; 1717 : 			gACMIRec.DOFRecord( &DOFRec );
; 1718 : 		}
; 1719 : 		if ( dof24 != GetDOFValue(COMP_RT_GEAR_DR) )
; 1720 : 		{
; 1721 : 			DOFRec.data.DOFNum = COMP_RT_GEAR_DR;
; 1722 : 			DOFRec.data.DOFVal = GetDOFValue(COMP_RT_GEAR_DR);
; 1723 : 			DOFRec.data.prevDOFVal = dof24;
; 1724 : 			gACMIRec.DOFRecord( &DOFRec );
; 1725 : 		}
; 1726 : }
; 1727 : #endif
; 1728 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RunGearSurfaces@AircraftClass@@QAEXXZ ENDP		; AircraftClass::RunGearSurfaces
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\surface.cpp
_TEXT	SEGMENT
tv454 = -104						; size = 8
tv422 = -96						; size = 8
tv392 = -88						; size = 8
tv359 = -80						; size = 8
tv452 = -72						; size = 4
tv447 = -68						; size = 4
tv420 = -64						; size = 4
tv415 = -60						; size = 4
tv390 = -56						; size = 4
tv385 = -52						; size = 4
tv357 = -48						; size = 4
tv352 = -44						; size = 4
tv269 = -40						; size = 4
tv191 = -36						; size = 4
tv134 = -32						; size = 4
_strobeState$1 = -28					; size = 4
_FlashOff$2 = -24					; size = 4
_FlashOff$3 = -20					; size = 4
_navState$4 = -16					; size = 4
_this$ = -12						; size = 4
tv449 = -8						; size = 2
tv417 = -6						; size = 2
tv387 = -4						; size = 2
tv354 = -2						; size = 2
?RunLightSurfaces@AircraftClass@@QAEXXZ PROC		; AircraftClass::RunLightSurfaces
; _this$ = ecx

; 1291 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	DWORD PTR _this$[ebp], ecx

; 1292 : 	//SetSwitch(COMP_NAV_LIGHTS, light == 1);
; 1293 : 	//SetSwitch(COMP_NAV_LIGHTSFLASH, light == 2);
; 1294 : 	//SetSwitch(COMP_TAIL_STROBE, light == 3);
; 1295 : 	//SetSwitch(COMP_LAND_LIGHTS, light == 4);
; 1296 : 
; 1297 : 	if (!ExtlState(ExtlLightFlags::Extl_Main_Power))

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ExtlState@AircraftClass@@QBEHW4ExtlLightFlags@1@@Z ; AircraftClass::ExtlState
	test	eax, eax
	jne	SHORT $LN26@RunLightSu

; 1298 : 	{
; 1299 : 		// lights off
; 1300 : 		SetSwitch(COMP_NAV_LIGHTS, FALSE);

	push	0
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSwitch@SimMoverClass@@QAEXHH@Z	; SimMoverClass::SetSwitch

; 1301 : 		SetSwitch(COMP_TAIL_STROBE, FALSE);

	push	0
	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSwitch@SimMoverClass@@QAEXHH@Z	; SimMoverClass::SetSwitch

; 1302 : 		SetSwitch(COMP_LAND_LIGHTS, FALSE);

	push	0
	push	9
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSwitch@SimMoverClass@@QAEXHH@Z	; SimMoverClass::SetSwitch

; 1303 : 		//ExtlOff(AircraftClass::ExtlLightFlags::Extl_Anti_Coll);
; 1304 : 		//ExtlOff(AircraftClass::ExtlLightFlags::Extl_Wing_Tail);
; 1305 : 	}
; 1306 : 	else 

	jmp	$LN1@RunLightSu
$LN26@RunLightSu:

; 1307 : 	{
; 1308 : 		// check flags
; 1309 : 		// gear: landing lights on and gear down
; 1310 : 		SetSwitch(COMP_LAND_LIGHTS, IsAcStatusBitsSet(ACSTATUS_EXT_LANDINGLIGHT) && (af->gearPos == 1.0F));

	push	32					; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsAcStatusBitsSet@AircraftClass@@QBE_NH@Z ; AircraftClass::IsAcStatusBitsSet
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN29@RunLightSu
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR [edx+1552]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN29@RunLightSu
	mov	DWORD PTR tv134[ebp], 1
	jmp	SHORT $LN30@RunLightSu
$LN29@RunLightSu:
	mov	DWORD PTR tv134[ebp], 0
$LN30@RunLightSu:
	mov	eax, DWORD PTR tv134[ebp]
	push	eax
	push	9
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSwitch@SimMoverClass@@QAEXHH@Z	; SimMoverClass::SetSwitch

; 1311 : 
; 1312 : 		//----------------------------
; 1313 : 		// animWingFlashOnTime  0.4 * 1000.0f = 400
; 1314 : 		// animWingFlashOffTime  0.5 * 1000.0f = 500
; 1315 : 		//----------------------------
; 1316 : 		if (af->auxaeroData->animWingFlashOnTime == 0.0f) 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	movss	xmm0, DWORD PTR [eax+3060]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN24@RunLightSu

; 1317 : 			af->auxaeroData->animWingFlashOnTime = 0.4f;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	movss	xmm0, DWORD PTR __real@3ecccccd
	movss	DWORD PTR [eax+3060], xmm0
$LN24@RunLightSu:

; 1318 : 		if (af->auxaeroData->animWingFlashOffTime == 0.0f) 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	movss	xmm0, DWORD PTR [eax+3064]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN23@RunLightSu

; 1319 : 			af->auxaeroData->animWingFlashOffTime = 0.5f;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [eax+3064], xmm0
$LN23@RunLightSu:

; 1320 : 
; 1321 : 		// nav: if steady, set on 
; 1322 : 		int navState = FALSE;

	mov	DWORD PTR _navState$4[ebp], 0

; 1323 : 		if (ExtlState(Extl_Wing_Tail))

	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ExtlState@AircraftClass@@QBEHW4ExtlLightFlags@1@@Z ; AircraftClass::ExtlState
	test	eax, eax
	je	$LN22@RunLightSu

; 1324 : 		{
; 1325 : 			VU_TIME FlashOff = (VU_TIME)(af->auxaeroData->animWingFlashOffTime * 1000.0f);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	movss	xmm0, DWORD PTR [eax+3064]
	mulss	xmm0, DWORD PTR __real@447a0000
	movss	DWORD PTR tv352[ebp], xmm0
	fld	DWORD PTR tv352[ebp]
	fnstcw	WORD PTR tv354[ebp]
	movzx	eax, WORD PTR tv354[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv357[ebp], eax
	fldcw	WORD PTR tv357[ebp]
	fistp	QWORD PTR tv359[ebp]
	fldcw	WORD PTR tv354[ebp]
	mov	ecx, DWORD PTR tv359[ebp]
	mov	DWORD PTR _FlashOff$3[ebp], ecx

; 1326 : 
; 1327 : 			navState = TRUE;

	mov	DWORD PTR _navState$4[ebp], 1

; 1328 : 			if (ExtlState(Extl_Flash))

	push	64					; 00000040H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ExtlState@AircraftClass@@QBEHW4ExtlLightFlags@1@@Z ; AircraftClass::ExtlState
	test	eax, eax
	je	$LN21@RunLightSu

; 1329 : 			{
; 1330 : 				navState = GetSwitch(COMP_NAV_LIGHTS);

	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSwitch@SimMoverClass@@QAEHH@Z	; SimMoverClass::GetSwitch
	mov	DWORD PTR _navState$4[ebp], eax

; 1331 : 
; 1332 : 				// if timer not initialized or timed out, give it a random start
; 1333 : 				if(SimLibElapsedTime >= animWingFlashTimer)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	cmp	eax, DWORD PTR [edx+1844]
	jb	SHORT $LN20@RunLightSu

; 1334 : 				{
; 1335 : 					//if(SimLibElapsedTime - animWingFlashTimer > 3000) animWingFlashTimer = SimLibElapsedTime + (rand() % 3000);
; 1336 : 					if ((SimLibElapsedTime - animWingFlashTimer) > FlashOff) 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	sub	edx, DWORD PTR [ecx+1844]
	cmp	edx, DWORD PTR _FlashOff$3[ebp]
	jbe	SHORT $LN19@RunLightSu

; 1337 : 									animWingFlashTimer = SimLibElapsedTime + (rand() % FlashOff);

	call	_rand
	xor	edx, edx
	div	DWORD PTR _FlashOff$3[ebp]
	add	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1844], edx
$LN19@RunLightSu:

; 1338 : 				} 
; 1339 : 				else 

	jmp	SHORT $LN17@RunLightSu
$LN20@RunLightSu:

; 1340 : 				{
; 1341 : 					//if(animWingFlashTimer - SimLibElapsedTime > 3000) animWingFlashTimer = SimLibElapsedTime + (rand() % 3000);
; 1342 : 					if ((animWingFlashTimer - SimLibElapsedTime) > FlashOff) 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1844]
	sub	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	cmp	edx, DWORD PTR _FlashOff$3[ebp]
	jbe	SHORT $LN17@RunLightSu

; 1343 : 									animWingFlashTimer = SimLibElapsedTime + (rand() % FlashOff);

	call	_rand
	xor	edx, edx
	div	DWORD PTR _FlashOff$3[ebp]
	add	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1844], edx
$LN17@RunLightSu:

; 1344 : 				}
; 1345 : 
; 1346 : 				// make it blink
; 1347 : 				if (SimLibElapsedTime > animWingFlashTimer)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	cmp	edx, DWORD PTR [ecx+1844]
	jbe	$LN14@RunLightSu

; 1348 : 				{					
; 1349 : 					// blink time is small. random factor to avoid all blinking together
; 1350 : 					navState = !navState;

	cmp	DWORD PTR _navState$4[ebp], 0
	jne	SHORT $LN31@RunLightSu
	mov	DWORD PTR tv191[ebp], 1
	jmp	SHORT $LN32@RunLightSu
$LN31@RunLightSu:
	mov	DWORD PTR tv191[ebp], 0
$LN32@RunLightSu:
	mov	eax, DWORD PTR tv191[ebp]
	mov	DWORD PTR _navState$4[ebp], eax

; 1351 : 					
; 1352 : 					if (navState)

	cmp	DWORD PTR _navState$4[ebp], 0
	je	SHORT $LN15@RunLightSu

; 1353 : 					{
; 1354 : 						//animWingFlashTimer += 75;
; 1355 : 						animWingFlashTimer += (VU_TIME)(af->auxaeroData->animWingFlashOnTime * 1000.0f);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	movss	xmm0, DWORD PTR [eax+3060]
	mulss	xmm0, DWORD PTR __real@447a0000
	movss	DWORD PTR tv385[ebp], xmm0
	fld	DWORD PTR tv385[ebp]
	fnstcw	WORD PTR tv387[ebp]
	movzx	eax, WORD PTR tv387[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv390[ebp], eax
	fldcw	WORD PTR tv390[ebp]
	fistp	QWORD PTR tv392[ebp]
	fldcw	WORD PTR tv387[ebp]
	mov	ecx, DWORD PTR tv392[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+1844]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1844], ecx

; 1356 : 					}
; 1357 : 					else 

	jmp	SHORT $LN14@RunLightSu
$LN15@RunLightSu:

; 1358 : 					{
; 1359 : 						//animWingFlashTimer += 3000;
; 1360 : 						animWingFlashTimer += FlashOff;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1844]
	add	edx, DWORD PTR _FlashOff$3[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1844], edx
$LN14@RunLightSu:

; 1361 : 					}
; 1362 : 				}
; 1363 : 			} // Flashing
; 1364 : 			else 

	jmp	SHORT $LN13@RunLightSu
$LN21@RunLightSu:

; 1365 : 			{
; 1366 : 				navState = TRUE; // Steady

	mov	DWORD PTR _navState$4[ebp], 1
$LN13@RunLightSu:

; 1367 : 			}
; 1368 : 			// nav is controlling wing
; 1369 : 			SetSwitch(COMP_NAV_LIGHTS, navState);

	mov	ecx, DWORD PTR _navState$4[ebp]
	push	ecx
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSwitch@SimMoverClass@@QAEXHH@Z	; SimMoverClass::SetSwitch

; 1370 : 		}
; 1371 : 		else

	jmp	SHORT $LN12@RunLightSu
$LN22@RunLightSu:

; 1372 : 			SetSwitch(COMP_NAV_LIGHTS, 0); // Wing lights OFF

	push	0
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSwitch@SimMoverClass@@QAEXHH@Z	; SimMoverClass::SetSwitch
$LN12@RunLightSu:

; 1373 : 
; 1374 : 			//********************************************************
; 1375 : 			// FRB - Tail strobe support
; 1376 : 			// animStrobeOnTime  0.08 * 1000.0f = 80
; 1377 : 			// animStrobeOffTime  2.0 * 1000.0f = 2000
; 1378 : 			//-----------------------------
; 1379 : 		if (ExtlState(Extl_Anti_Coll)) // Tail strobe always flashing

	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ExtlState@AircraftClass@@QBEHW4ExtlLightFlags@1@@Z ; AircraftClass::ExtlState
	test	eax, eax
	je	$LN11@RunLightSu

; 1380 : 		{
; 1381 : 			if (af->auxaeroData->animStrobeOnTime == 0.0f) 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+4]
	movss	xmm0, DWORD PTR [ecx+3052]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN10@RunLightSu

; 1382 : 				af->auxaeroData->animStrobeOnTime = 0.08f;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+4]
	movss	xmm0, DWORD PTR __real@3da3d70a
	movss	DWORD PTR [ecx+3052], xmm0
$LN10@RunLightSu:

; 1383 : 			if (af->auxaeroData->animStrobeOffTime == 0.0f) 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+4]
	movss	xmm0, DWORD PTR [ecx+3056]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN9@RunLightSu

; 1384 : 				af->auxaeroData->animStrobeOffTime = 2.0f;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+4]
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [ecx+3056], xmm0
$LN9@RunLightSu:

; 1385 : 
; 1386 : 			VU_TIME FlashOff = (VU_TIME)(af->auxaeroData->animStrobeOffTime * 1000.0f);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+4]
	movss	xmm0, DWORD PTR [ecx+3056]
	mulss	xmm0, DWORD PTR __real@447a0000
	movss	DWORD PTR tv415[ebp], xmm0
	fld	DWORD PTR tv415[ebp]
	fnstcw	WORD PTR tv417[ebp]
	movzx	eax, WORD PTR tv417[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv420[ebp], eax
	fldcw	WORD PTR tv420[ebp]
	fistp	QWORD PTR tv422[ebp]
	fldcw	WORD PTR tv417[ebp]
	mov	edx, DWORD PTR tv422[ebp]
	mov	DWORD PTR _FlashOff$2[ebp], edx

; 1387 : 			int strobeState = FALSE;

	mov	DWORD PTR _strobeState$1[ebp], 0

; 1388 : 			strobeState = GetSwitch(COMP_TAIL_STROBE);

	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSwitch@SimMoverClass@@QAEHH@Z	; SimMoverClass::GetSwitch
	mov	DWORD PTR _strobeState$1[ebp], eax

; 1389 : 
; 1390 : 			if(SimLibElapsedTime >= animStrobeTimer)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	cmp	ecx, DWORD PTR [eax+1840]
	jb	SHORT $LN8@RunLightSu

; 1391 : 			{
; 1392 : 				//if(SimLibElapsedTime - animStrobeTimer > 1500) animStrobeTimer = SimLibElapsedTime + (rand() % 1500);
; 1393 : 				if ((SimLibElapsedTime - animStrobeTimer) > FlashOff) 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	sub	eax, DWORD PTR [edx+1840]
	cmp	eax, DWORD PTR _FlashOff$2[ebp]
	jbe	SHORT $LN7@RunLightSu

; 1394 : 								animStrobeTimer = SimLibElapsedTime + (rand() % FlashOff);

	call	_rand
	xor	edx, edx
	div	DWORD PTR _FlashOff$2[ebp]
	add	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1840], edx
$LN7@RunLightSu:

; 1395 : 			} 
; 1396 : 			else 

	jmp	SHORT $LN5@RunLightSu
$LN8@RunLightSu:

; 1397 : 			{
; 1398 : 				//if(animStrobeTimer - SimLibElapsedTime > 1500) animStrobeTimer = SimLibElapsedTime + (rand() % 1500);
; 1399 : 				if ((animStrobeTimer - SimLibElapsedTime) > FlashOff) 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1840]
	sub	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	cmp	eax, DWORD PTR _FlashOff$2[ebp]
	jbe	SHORT $LN5@RunLightSu

; 1400 : 								animStrobeTimer = SimLibElapsedTime + (rand() % FlashOff);

	call	_rand
	xor	edx, edx
	div	DWORD PTR _FlashOff$2[ebp]
	add	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1840], edx
$LN5@RunLightSu:

; 1401 : 			}
; 1402 : 
; 1403 : 			// make it blink
; 1404 : 			if (SimLibElapsedTime > animStrobeTimer)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	cmp	eax, DWORD PTR [edx+1840]
	jbe	$LN2@RunLightSu

; 1405 : 			{					
; 1406 : 				// blink time is small. random factor to avoid all blinking together
; 1407 : 				strobeState = !strobeState;

	cmp	DWORD PTR _strobeState$1[ebp], 0
	jne	SHORT $LN33@RunLightSu
	mov	DWORD PTR tv269[ebp], 1
	jmp	SHORT $LN34@RunLightSu
$LN33@RunLightSu:
	mov	DWORD PTR tv269[ebp], 0
$LN34@RunLightSu:
	mov	ecx, DWORD PTR tv269[ebp]
	mov	DWORD PTR _strobeState$1[ebp], ecx

; 1408 : 				
; 1409 : 				if (strobeState)

	cmp	DWORD PTR _strobeState$1[ebp], 0
	je	SHORT $LN3@RunLightSu

; 1410 : 				{
; 1411 : 					animStrobeTimer += (VU_TIME)(af->auxaeroData->animStrobeOnTime * 1000.0f);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+4]
	movss	xmm0, DWORD PTR [ecx+3052]
	mulss	xmm0, DWORD PTR __real@447a0000
	movss	DWORD PTR tv447[ebp], xmm0
	fld	DWORD PTR tv447[ebp]
	fnstcw	WORD PTR tv449[ebp]
	movzx	eax, WORD PTR tv449[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv452[ebp], eax
	fldcw	WORD PTR tv452[ebp]
	fistp	QWORD PTR tv454[ebp]
	fldcw	WORD PTR tv449[ebp]
	mov	edx, DWORD PTR tv454[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+1840]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1840], edx

; 1412 : 				}
; 1413 : 				else 

	jmp	SHORT $LN2@RunLightSu
$LN3@RunLightSu:

; 1414 : 				{
; 1415 : 					animStrobeTimer += FlashOff;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1840]
	add	eax, DWORD PTR _FlashOff$2[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1840], eax
$LN2@RunLightSu:

; 1416 : 				}
; 1417 : 			}
; 1418 : 			SetSwitch(COMP_TAIL_STROBE, strobeState);

	mov	edx, DWORD PTR _strobeState$1[ebp]
	push	edx
	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSwitch@SimMoverClass@@QAEXHH@Z	; SimMoverClass::SetSwitch

; 1419 : 		}
; 1420 : 		else

	jmp	SHORT $LN1@RunLightSu
$LN11@RunLightSu:

; 1421 : 			SetSwitch(COMP_TAIL_STROBE, 0); // Tail strobe OFF

	push	0
	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSwitch@SimMoverClass@@QAEXHH@Z	; SimMoverClass::SetSwitch
$LN1@RunLightSu:

; 1422 : 	} // Light Power
; 1423 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RunLightSurfaces@AircraftClass@@QAEXXZ ENDP		; AircraftClass::RunLightSurfaces
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\surface.cpp
_TEXT	SEGMENT
$T1 = -428						; size = 8
$T2 = -420						; size = 8
tv4126 = -412						; size = 8
tv3428 = -404						; size = 8
tv4144 = -396						; size = 8
tv3306 = -388						; size = 8
tv3688 = -380						; size = 4
_curDOF$3 = -376					; size = 4
_spoiler1l$4 = -372					; size = 4
_diff$5 = -368						; size = 4
tv4190 = -364						; size = 4
_spoiler2l$6 = -360					; size = 4
_leftStab$7 = -356					; size = 4
tv3436 = -352						; size = 4
tv4106 = -348						; size = 4
tv4288 = -344						; size = 4
tv4100 = -340						; size = 4
tv3118 = -336						; size = 4
_spoiler2r$8 = -332					; size = 4
_diff$9 = -328						; size = 4
_spoiler2l$10 = -324					; size = 4
_spoiler2r$11 = -320					; size = 4
_spoiler1r$12 = -316					; size = 4
_spoiler1r$13 = -312					; size = 4
_spoiler1l$14 = -308					; size = 4
tv4290 = -304						; size = 4
_rightStab$15 = -300					; size = 4
tv4292 = -296						; size = 4
_leftStab$16 = -292					; size = 4
tv3314 = -288						; size = 4
_vortexTrailsUsed$17 = -284				; size = 4
_thrpos$18 = -280					; size = 4
_diff$19 = -276						; size = 4
_deltaDOF$20 = -272					; size = 4
_diff$21 = -268						; size = 4
_rightStab$22 = -264					; size = 4
_ab$23 = -260						; size = 4
tv3137 = -256						; size = 4
_aileronleft$24 = -252					; size = 4
tv1773 = -248						; size = 4
tv4140 = -244						; size = 4
tv962 = -240						; size = 4
tv4122 = -236						; size = 4
tv1605 = -232						; size = 4
_dofs$25 = -228						; size = 4
_aileronrt$26 = -224					; size = 4
_sweep$27 = -220					; size = 4
tv1652 = -216						; size = 4
tv2343 = -212						; size = 4
_sweep$28 = -208					; size = 4
tv2342 = -204						; size = 4
tv766 = -200						; size = 4
tv2325 = -196						; size = 4
tv1926 = -192						; size = 4
tv2307 = -188						; size = 4
tv1751 = -184						; size = 4
tv2290 = -180						; size = 4
tv1622 = -176						; size = 4
tv2284 = -172						; size = 4
tv1601 = -168						; size = 4
tv2267 = -164						; size = 4
tv3424 = -160						; size = 4
tv71 = -156						; size = 4
tv3302 = -152						; size = 4
_aileronleft$29 = -148					; size = 4
_nHoldSec$30 = -144					; size = 4
tv1944 = -140						; size = 4
tv246 = -136						; size = 4
tv1943 = -132						; size = 4
_aileronrt$31 = -128					; size = 4
_curHP$32 = -124					; size = 4
_flapleft$33 = -120					; size = 4
_s$34 = -116						; size = 4
_doorAngle$35 = -112					; size = 4
_switches$36 = -108					; size = 4
_hookpos$37 = -104					; size = 4
_d$38 = -100						; size = 4
_flapleft$39 = -96					; size = 4
_flaprt$40 = -92					; size = 4
_flaprt$41 = -88					; size = 4
_abscale$42 = -84					; size = 4
_i$ = -80						; size = 4
_i$43 = -76						; size = 4
_abscale$44 = -72					; size = 4
_deltaDOF$45 = -68					; size = 4
_gFact$ = -64						; size = 4
_l$46 = -60						; size = 4
_curDOF$47 = -56					; size = 4
_qFactor$ = -52						; size = 4
_l$48 = -48						; size = 4
_nozpos$49 = -44					; size = 4
_nozpos$50 = -40					; size = 4
_l$51 = -36						; size = 4
_vortexTrailsCondition$52 = -29				; size = 1
_stabAngle$ = -28					; size = 4
_stage$ = -24						; size = 4
_rpm$ = -20						; size = 8
_curDOF$53 = -12					; size = 4
_l$54 = -8						; size = 4
_this$ = -4						; size = 4
?MoveSurfaces@AircraftClass@@QAEXXZ PROC		; AircraftClass::MoveSurfaces
; _this$ = ecx

; 398  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 428				; 000001acH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 399  : 	float qFactor, stabAngle;
; 400  : 	int gFact;
; 401  : 	int i, stage;
; 402  : 	
; 403  : 	qFactor = 100.0F / (max (af->vcas, 100.0F));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [ecx+1124]
	comiss	xmm0, DWORD PTR __real@42c80000
	jbe	SHORT $LN169@MoveSurfac
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR [eax+1124]
	movss	DWORD PTR tv71[ebp], xmm0
	jmp	SHORT $LN170@MoveSurfac
$LN169@MoveSurfac:
	movss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR tv71[ebp], xmm0
$LN170@MoveSurfac:
	movss	xmm0, DWORD PTR __real@42c80000
	divss	xmm0, DWORD PTR tv71[ebp]
	movss	DWORD PTR _qFactor$[ebp], xmm0

; 404  : 	
; 405  : 	// are we in easter-egg heli mode?
; 406  : 	if ( af && af->GetSimpleMode() == SIMPLE_MODE_HF )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+932], 0
	je	$LN166@MoveSurfac
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+932]
	call	?GetSimpleMode@AirframeClass@@QAEHXZ	; AirframeClass::GetSimpleMode
	cmp	eax, 2
	jne	$LN166@MoveSurfac

; 407  : 	{
; 408  : 	/*
; 409  : 	Switch and Dof settings for Helo
; 410  : 	sw0	bit1=fast moving blades; bit2=slow moving blades 	
; 411  : 	sw2	makes Muzzle flash visible	
; 412  : 	dof2	main rotor 	
; 413  : 	dof3	Muzzle Flash	
; 414  : 	dof4	tail or secondary rotor	
; 415  : 		*/
; 416  : 		// animate rotors
; 417  : 		if ( GetSwitch(HELI_ROTORS) != 1 )

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSwitch@SimMoverClass@@QAEHH@Z	; SimMoverClass::GetSwitch
	cmp	eax, 1
	je	SHORT $LN165@MoveSurfac

; 418  : 		{
; 419  : 			SetSwitch( HELI_ROTORS, 1);

	push	1
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSwitch@SimMoverClass@@QAEXHH@Z	; SimMoverClass::SetSwitch

; 420  : 			SetDOF( HELI_MAIN_ROTOR, 0.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDOF@SimMoverClass@@QAEXHM@Z		; SimMoverClass::SetDOF

; 421  : 			SetDOF( HELI_TAIL_ROTOR, 0.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDOF@SimMoverClass@@QAEXHM@Z		; SimMoverClass::SetDOF
$LN165@MoveSurfac:

; 422  : 		}
; 423  : 		
; 424  : 		// blades rotate at around 300 RPM which is 1800 DPS
; 425  : 		float curDOF = GetDOFValue( HELI_MAIN_ROTOR );

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDOFValue@SimMoverClass@@QAEMH@Z	; SimMoverClass::GetDOFValue
	fstp	DWORD PTR _curDOF$47[ebp]

; 426  : 		float deltaDOF = 1800.0f * DTR * SimLibMajorFrameTime;

	movss	xmm0, DWORD PTR __real@41fb53cf
	mulss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	movss	DWORD PTR _deltaDOF$20[ebp], xmm0

; 427  : 		curDOF += deltaDOF;

	movss	xmm0, DWORD PTR _curDOF$47[ebp]
	addss	xmm0, DWORD PTR _deltaDOF$20[ebp]
	movss	DWORD PTR _curDOF$47[ebp], xmm0

; 428  : 		if ( curDOF > 360.0f * DTR )

	movss	xmm0, DWORD PTR _curDOF$47[ebp]
	comiss	xmm0, DWORD PTR __real@40c90fd9
	jbe	SHORT $LN164@MoveSurfac

; 429  : 			curDOF -= 360.0f * DTR;

	movss	xmm0, DWORD PTR _curDOF$47[ebp]
	subss	xmm0, DWORD PTR __real@40c90fd9
	movss	DWORD PTR _curDOF$47[ebp], xmm0
$LN164@MoveSurfac:

; 430  : 		
; 431  : 		SetDOF( HELI_MAIN_ROTOR, curDOF );

	push	ecx
	movss	xmm0, DWORD PTR _curDOF$47[ebp]
	movss	DWORD PTR [esp], xmm0
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDOF@SimMoverClass@@QAEXHM@Z		; SimMoverClass::SetDOF

; 432  : 		SetDOF( HELI_TAIL_ROTOR, curDOF );

	push	ecx
	movss	xmm0, DWORD PTR _curDOF$47[ebp]
	movss	DWORD PTR [esp], xmm0
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDOF@SimMoverClass@@QAEXHM@Z		; SimMoverClass::SetDOF

; 433  : 		return;

	jmp	$LN167@MoveSurfac
$LN166@MoveSurfac:

; 434  : 	}
; 435  : 	
; 436  : 	float rpm[2];
; 437  : 	
; 438  : 	if(IsLocal())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsLocal@VuEntity@@QBEEXZ		; VuEntity::IsLocal
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN163@MoveSurfac

; 439  : 	{
; 440  : 		rpm[0]=af->rpm;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR [edx+1212]
	mov	DWORD PTR _rpm$[ebp+eax], ecx

; 441  : 		rpm[1]=af->rpm2;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR [eax+1216]
	mov	DWORD PTR _rpm$[ebp+ecx], edx

; 442  : 	}
; 443  : 	else

	jmp	SHORT $LN162@MoveSurfac
$LN163@MoveSurfac:

; 444  : 	{
; 445  : 		rpm[0]=specialData.powerOutput;

	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+188]
	mov	DWORD PTR _rpm$[ebp+eax], edx

; 446  : 		rpm[1]=specialData.powerOutput2;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+196]
	mov	DWORD PTR _rpm$[ebp+eax], edx
$LN162@MoveSurfac:

; 447  : 	}
; 448  : 	
; 449  : 	
; 450  : 	{ // MLR 2003-10-12 Throttle DOF (works on complex & simple - same ID)
; 451  : 		//SetDOF(COMP_THROTTLE,af->Throtl());	// simple eh?
; 452  : 		//ATARIBABY change for 2 engine ACs to be correct, help from Mike
; 453  : 		if(af->auxaeroData->nEngines==2)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+344], 2
	jne	SHORT $LN161@MoveSurfac

; 454  : 		{
; 455  : 			SetDOF(COMP_THROTTLE,af->engine1Throttle);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+1520]
	movss	DWORD PTR [esp], xmm0
	push	47					; 0000002fH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDOF@SimMoverClass@@QAEXHM@Z		; SimMoverClass::SetDOF

; 456  : //			SetDOF(COMP_THROTTLE2,af->engine2Throttle); i will add later with second engine needles too
; 457  : 		}
; 458  : 		else

	jmp	SHORT $LN160@MoveSurfac
$LN161@MoveSurfac:

; 459  : 		{
; 460  : 			SetDOF(COMP_THROTTLE,af->Throtl());	// simple eh?

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+932]
	call	?Throtl@AirframeClass@@QAEMXZ		; AirframeClass::Throtl
	push	ecx
	fstp	DWORD PTR [esp]
	push	47					; 0000002fH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDOF@SimMoverClass@@QAEXHM@Z		; SimMoverClass::SetDOF
$LN160@MoveSurfac:

; 461  : 		}
; 462  : 
; 463  : 		SetDOF(COMP_RPM,rpm[0]);

	mov	eax, 4
	imul	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR _rpm$[ebp+eax]
	movss	DWORD PTR [esp], xmm0
	push	48					; 00000030H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDOF@SimMoverClass@@QAEXHM@Z		; SimMoverClass::SetDOF

; 464  : 		
; 465  : 		// MLR 2003-10-12 Animated refuel probe
; 466  : 		MoveDof(COMP_REFUEL, (af->IsEngineFlag(AirframeClass::FuelDoorOpen) ? af->auxaeroData->animRefuelAngle * DTR : 0), af->auxaeroData->animRefuelRate);

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+932]
	call	?IsEngineFlag@AirframeClass@@QAEHW4EngineFlags@1@@Z ; AirframeClass::IsEngineFlag
	test	eax, eax
	je	SHORT $LN171@MoveSurfac
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+4]
	movss	xmm0, DWORD PTR [ecx+3204]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	movss	DWORD PTR tv246[ebp], xmm0
	jmp	SHORT $LN172@MoveSurfac
$LN171@MoveSurfac:
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv246[ebp], xmm0
$LN172@MoveSurfac:
	push	-1
	push	-1
	push	-1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+3208]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR tv246[ebp]
	movss	DWORD PTR [esp], xmm0
	push	41					; 00000029H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 467  : 	}
; 468  : 	
; 469  : 	{ // MLR - 2003-09-30 Prop code // MLR 1/14/2004 - made available for simple models
; 470  : 		// note, the scripts will be modified to read this dof, and supply it to the appropriate
; 471  : 		// dofs
; 472  : 		int l;
; 473  : 		float curDOF;
; 474  : 		// MLR 1/22/2004 - I forgot to use the RPMMult
; 475  : 		float deltaDOF = rpm[0] * af->auxaeroData->animEngineRPMMult * DTR; // replace the .01 with a global value

	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	eax, DWORD PTR [ecx+4]
	movss	xmm0, DWORD PTR _rpm$[ebp+edx]
	mulss	xmm0, DWORD PTR [eax+2996]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	movss	DWORD PTR _deltaDOF$45[ebp], xmm0

; 476  : 		
; 477  : 		curDOF = GetDOFValue( COMP_PROPELLOR );

	push	40					; 00000028H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDOFValue@SimMoverClass@@QAEMH@Z	; SimMoverClass::GetDOFValue
	fstp	DWORD PTR _curDOF$53[ebp]

; 478  : 		curDOF = fmod((curDOF + deltaDOF) , 6.28318531f);  // 2 * PI

	push	ecx
	movss	xmm0, DWORD PTR __real@40c90fdb
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _curDOF$53[ebp]
	addss	xmm0, DWORD PTR _deltaDOF$45[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?fmod@@YAMMM@Z				; fmod
	add	esp, 8
	fstp	DWORD PTR _curDOF$53[ebp]

; 479  : 		SetDOF( COMP_PROPELLOR, curDOF );

	push	ecx
	movss	xmm0, DWORD PTR _curDOF$53[ebp]
	movss	DWORD PTR [esp], xmm0
	push	40					; 00000028H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDOF@SimMoverClass@@QAEXHM@Z		; SimMoverClass::SetDOF

; 480  : 		if (IsComplex())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsComplex@AircraftClass@@QAEHXZ	; AircraftClass::IsComplex
	test	eax, eax
	je	$LN154@MoveSurfac

; 481  : 		{
; 482  : 			if(af->auxaeroData->nEngines==2)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+344], 2
	jne	$LN158@MoveSurfac

; 483  : 			{
; 484  : 				l=31;

	mov	DWORD PTR _l$51[ebp], 31		; 0000001fH

; 485  : 				curDOF = GetDOFValue( l );

	mov	ecx, DWORD PTR _l$51[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDOFValue@SimMoverClass@@QAEMH@Z	; SimMoverClass::GetDOFValue
	fstp	DWORD PTR _curDOF$53[ebp]

; 486  : 				curDOF = fmod((curDOF + deltaDOF) , 6.28318531f);  // 2 * PI

	push	ecx
	movss	xmm0, DWORD PTR __real@40c90fdb
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _curDOF$53[ebp]
	addss	xmm0, DWORD PTR _deltaDOF$45[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?fmod@@YAMMM@Z				; fmod
	add	esp, 8
	fstp	DWORD PTR _curDOF$53[ebp]

; 487  : 				SetDOF( l , curDOF );

	push	ecx
	movss	xmm0, DWORD PTR _curDOF$53[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _l$51[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDOF@SimMoverClass@@QAEXHM@Z		; SimMoverClass::SetDOF

; 488  : 				
; 489  : 				l=32;

	mov	DWORD PTR _l$51[ebp], 32		; 00000020H

; 490  : 				deltaDOF = rpm[1] * af->auxaeroData->animEngineRPMMult * DTR; // replace the .01 with a global value

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	ecx, DWORD PTR [edx+4]
	movss	xmm0, DWORD PTR _rpm$[ebp+eax]
	mulss	xmm0, DWORD PTR [ecx+2996]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	movss	DWORD PTR _deltaDOF$45[ebp], xmm0

; 491  : 				curDOF = GetDOFValue( l );

	mov	edx, DWORD PTR _l$51[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDOFValue@SimMoverClass@@QAEMH@Z	; SimMoverClass::GetDOFValue
	fstp	DWORD PTR _curDOF$53[ebp]

; 492  : 				curDOF = fmod((curDOF + deltaDOF) , 6.28318531f);  // 2 * PI

	push	ecx
	movss	xmm0, DWORD PTR __real@40c90fdb
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _curDOF$53[ebp]
	addss	xmm0, DWORD PTR _deltaDOF$45[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?fmod@@YAMMM@Z				; fmod
	add	esp, 8
	fstp	DWORD PTR _curDOF$53[ebp]

; 493  : 				SetDOF( l , curDOF );

	push	ecx
	movss	xmm0, DWORD PTR _curDOF$53[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _l$51[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDOF@SimMoverClass@@QAEXHM@Z		; SimMoverClass::SetDOF

; 494  : 			}
; 495  : 			else

	jmp	SHORT $LN154@MoveSurfac
$LN158@MoveSurfac:

; 496  : 			{
; 497  : 				for(l=31;l<37;l++)

	mov	DWORD PTR _l$51[ebp], 31		; 0000001fH
	jmp	SHORT $LN156@MoveSurfac
$LN155@MoveSurfac:
	mov	ecx, DWORD PTR _l$51[ebp]
	add	ecx, 1
	mov	DWORD PTR _l$51[ebp], ecx
$LN156@MoveSurfac:
	cmp	DWORD PTR _l$51[ebp], 37		; 00000025H
	jge	SHORT $LN154@MoveSurfac

; 498  : 				{
; 499  : 					curDOF = GetDOFValue( l );

	mov	edx, DWORD PTR _l$51[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDOFValue@SimMoverClass@@QAEMH@Z	; SimMoverClass::GetDOFValue
	fstp	DWORD PTR _curDOF$53[ebp]

; 500  : 					curDOF = fmod((curDOF + deltaDOF) , 6.28318531f);  // 2 * PI

	push	ecx
	movss	xmm0, DWORD PTR __real@40c90fdb
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _curDOF$53[ebp]
	addss	xmm0, DWORD PTR _deltaDOF$45[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?fmod@@YAMMM@Z				; fmod
	add	esp, 8
	fstp	DWORD PTR _curDOF$53[ebp]

; 501  : 					SetDOF( l , curDOF );

	push	ecx
	movss	xmm0, DWORD PTR _curDOF$53[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _l$51[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDOF@SimMoverClass@@QAEXHM@Z		; SimMoverClass::SetDOF

; 502  : 				}	

	jmp	SHORT $LN155@MoveSurfac
$LN154@MoveSurfac:

; 503  : 			}	
; 504  : 		}
; 505  : 	}
; 506  : 	
; 507  : 	
; 508  : 	if (IsComplex())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsComplex@AircraftClass@@QAEHXZ	; AircraftClass::IsComplex
	test	eax, eax
	je	$LN153@MoveSurfac

; 509  : 	{      
; 510  : 		// Tail Surface
; 511  : 		float leftStab, rightStab;
; 512  : 		CalculateStab(qFactor, &leftStab, &rightStab);

	lea	ecx, DWORD PTR _rightStab$22[ebp]
	push	ecx
	lea	edx, DWORD PTR _leftStab$7[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _qFactor$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateStab@AircraftClass@@AAEXMPAM0@Z ; AircraftClass::CalculateStab

; 513  : 		MoveDof(COMP_LT_STAB, -leftStab,  af->auxaeroData->elevRate);

	push	-1
	push	-1
	push	-1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	push	ecx
	movss	xmm0, DWORD PTR [edx+76]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _leftStab$7[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 514  : 		MoveDof(COMP_RT_STAB, -rightStab, af->auxaeroData->elevRate);

	push	-1
	push	-1
	push	-1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	push	ecx
	movss	xmm0, DWORD PTR [edx+76]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _rightStab$22[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 515  : 		
; 516  : 		float aileronleft, aileronrt;
; 517  : 		float flapleft, flaprt;
; 518  : 		
; 519  : 		// RV - Biker
; 520  : 		float doorAngle = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _doorAngle$35[ebp], xmm0

; 521  : 		
; 522  : 		// RV - Biker - Use DOFs defined in DAT files for opening gun and bomb bay doors
; 523  : 		if (GunFire || fireGun)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+884]
	test	ecx, ecx
	jne	SHORT $LN151@MoveSurfac
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+916], 0
	je	SHORT $LN152@MoveSurfac
$LN151@MoveSurfac:

; 524  : 			doorAngle = 90.0f * DTR;

	movss	xmm0, DWORD PTR __real@3fc90fd9
	movss	DWORD PTR _doorAngle$35[ebp], xmm0

; 525  : 		else

	jmp	SHORT $LN150@MoveSurfac
$LN152@MoveSurfac:

; 526  : 			doorAngle =  0.0f * DTR;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _doorAngle$35[ebp], xmm0
$LN150@MoveSurfac:

; 527  : 
; 528  : 		if (af->GetGunDofType() >= COMP_WEAPON_BAY_0 &&
; 529  : 			af->GetGunDofType() <= COMP_WEAPON_BAY_4 &&
; 530  : 			af->GetGunDofRate() > 0.0f) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	call	?GetGunDofType@AirframeClass@@QAEHXZ	; AirframeClass::GetGunDofType
	cmp	eax, 78					; 0000004eH
	jl	SHORT $LN149@MoveSurfac
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+932]
	call	?GetGunDofType@AirframeClass@@QAEHXZ	; AirframeClass::GetGunDofType
	cmp	eax, 82					; 00000052H
	jg	SHORT $LN149@MoveSurfac
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+932]
	call	?GetGunDofRate@AirframeClass@@QAEMXZ	; AirframeClass::GetGunDofRate
	fstp	DWORD PTR tv3118[ebp]
	movss	xmm0, DWORD PTR tv3118[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN149@MoveSurfac

; 531  : 
; 532  : 			MoveDof(af->GetGunDofType(), doorAngle, af->GetGunDofRate());

	push	-1
	push	-1
	push	-1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	call	?GetGunDofRate@AirframeClass@@QAEMXZ	; AirframeClass::GetGunDofRate
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	movss	xmm0, DWORD PTR _doorAngle$35[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+932]
	call	?GetGunDofType@AirframeClass@@QAEHXZ	; AirframeClass::GetGunDofType
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof
$LN149@MoveSurfac:

; 533  : 		}
; 534  : 
; 535  : 		if (af->GetGunSwitchType() >= COMP_WEAPON_BAY_0_SW &&
; 536  : 			af->GetGunSwitchType() <= COMP_WEAPON_BAY_4_SW) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+932]
	call	?GetGunSwitchType@AirframeClass@@QAEHXZ	; AirframeClass::GetGunSwitchType
	cmp	eax, 53					; 00000035H
	jl	SHORT $LN146@MoveSurfac
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	call	?GetGunSwitchType@AirframeClass@@QAEHXZ	; AirframeClass::GetGunSwitchType
	cmp	eax, 57					; 00000039H
	jg	SHORT $LN146@MoveSurfac

; 537  : 			
; 538  : 			if(GetDOFValue(af->GetGunDofType()) > 0.0f)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+932]
	call	?GetGunDofType@AirframeClass@@QAEHXZ	; AirframeClass::GetGunDofType
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDOFValue@SimMoverClass@@QAEMH@Z	; SimMoverClass::GetDOFValue
	fstp	DWORD PTR tv3137[ebp]
	movss	xmm0, DWORD PTR tv3137[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN147@MoveSurfac

; 539  : 				SetSwitch(af->GetGunSwitchType(), 1);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+932]
	call	?GetGunSwitchType@AirframeClass@@QAEHXZ	; AirframeClass::GetGunSwitchType
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSwitch@SimMoverClass@@QAEXHH@Z	; SimMoverClass::SetSwitch

; 540  : 			else

	jmp	SHORT $LN146@MoveSurfac
$LN147@MoveSurfac:

; 541  : 				SetSwitch(af->GetGunSwitchType(), 0);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	call	?GetGunSwitchType@AirframeClass@@QAEHXZ	; AirframeClass::GetGunSwitchType
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSwitch@SimMoverClass@@QAEXHH@Z	; SimMoverClass::SetSwitch
$LN146@MoveSurfac:

; 542  : 		}
; 543  : 		
; 544  : 		if(Sms) {

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+940], 0
	je	$LN142@MoveSurfac

; 545  : 			// RV - Biker - Which DOF and switch to use
; 546  : 			int curHP = Sms->CurHardpoint();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+940]
	call	?CurHardpoint@SMSBaseClass@@QAEHXZ	; SMSBaseClass::CurHardpoint
	mov	DWORD PTR _curHP$32[ebp], eax

; 547  : 			int curDOF = af->GetHpDofType(curHP);

	mov	eax, DWORD PTR _curHP$32[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+932]
	call	?GetHpDofType@AirframeClass@@QAEHH@Z	; AirframeClass::GetHpDofType
	mov	DWORD PTR _curDOF$3[ebp], eax

; 548  : 
; 549  : 			MoveDof(af->GetHpDofType(curHP), 90 * DTR, af->GetHpDofRate(curHP));

	push	-1
	push	-1
	push	-1
	mov	edx, DWORD PTR _curHP$32[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	call	?GetHpDofRate@AirframeClass@@QAEMH@Z	; AirframeClass::GetHpDofRate
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	movss	xmm0, DWORD PTR __real@3fc90fd9
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _curHP$32[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+932]
	call	?GetHpDofType@AirframeClass@@QAEHH@Z	; AirframeClass::GetHpDofType
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 550  : 
; 551  : 			for(int l = 0; l < Sms->NumHardpoints(); l++) {

	mov	DWORD PTR _l$46[ebp], 0
	jmp	SHORT $LN144@MoveSurfac
$LN143@MoveSurfac:
	mov	eax, DWORD PTR _l$46[ebp]
	add	eax, 1
	mov	DWORD PTR _l$46[ebp], eax
$LN144@MoveSurfac:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+940]
	call	?NumHardpoints@SMSBaseClass@@QAEHXZ	; SMSBaseClass::NumHardpoints
	cmp	DWORD PTR _l$46[ebp], eax
	jge	SHORT $LN142@MoveSurfac

; 552  : 				if(af->GetHpDofType(l) != curDOF)

	mov	edx, DWORD PTR _l$46[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	call	?GetHpDofType@AirframeClass@@QAEHH@Z	; AirframeClass::GetHpDofType
	cmp	eax, DWORD PTR _curDOF$3[ebp]
	je	SHORT $LN141@MoveSurfac

; 553  : 					MoveDof(af->GetHpDofType(l), 0 * DTR, af->GetHpDofRate(l));

	push	-1
	push	-1
	push	-1
	mov	ecx, DWORD PTR _l$46[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+932]
	call	?GetHpDofRate@AirframeClass@@QAEMH@Z	; AirframeClass::GetHpDofRate
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _l$46[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+932]
	call	?GetHpDofType@AirframeClass@@QAEHH@Z	; AirframeClass::GetHpDofType
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof
$LN141@MoveSurfac:

; 554  : 				
; 555  : 			}

	jmp	SHORT $LN143@MoveSurfac
$LN142@MoveSurfac:

; 556  : 			
; 557  : 			/*	if (af->GetHpSwitchType(l) >= COMP_WEAPON_BAY_0_SW &&
; 558  : 					af->GetHpSwitchType(l) <= COMP_WEAPON_BAY_4_SW) {
; 559  : 									
; 560  : 					if(GetDOFValue(af->GetHpDofType(l)) > 0.0f)
; 561  : 						SetSwitch(af->GetHpSwitchType(l), 1);
; 562  : 					else
; 563  : 						SetSwitch(af->GetHpSwitchType(l), 0);
; 564  : 				}
; 565  : 			}*/
; 566  : 		}
; 567  : 		
; 568  : 		CalculateAileronAndFlap(qFactor, &aileronleft, &aileronrt, &flapleft, &flaprt);

	lea	edx, DWORD PTR _flaprt$41[ebp]
	push	edx
	lea	eax, DWORD PTR _flapleft$39[ebp]
	push	eax
	lea	ecx, DWORD PTR _aileronrt$26[ebp]
	push	ecx
	lea	edx, DWORD PTR _aileronleft$24[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _qFactor$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateAileronAndFlap@AircraftClass@@AAEXMPAM000@Z ; AircraftClass::CalculateAileronAndFlap

; 569  : 		if (af->auxaeroData->hasFlapperons) 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+88], 0
	je	SHORT $LN140@MoveSurfac

; 570  : 		{
; 571  : 			MoveDof(COMP_LT_FLAP, aileronleft + flapleft, af->auxaeroData->tefRate);

	push	-1
	push	-1
	push	-1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	push	ecx
	movss	xmm0, DWORD PTR [edx+116]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _aileronleft$24[ebp]
	addss	xmm0, DWORD PTR _flapleft$39[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 572  : 			MoveDof(COMP_RT_FLAP, aileronrt + flaprt,  af->auxaeroData->tefRate);

	push	-1
	push	-1
	push	-1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	push	ecx
	movss	xmm0, DWORD PTR [edx+116]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _aileronrt$26[ebp]
	addss	xmm0, DWORD PTR _flaprt$41[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 573  : 		}
; 574  : 		else 

	jmp	$LN137@MoveSurfac
$LN140@MoveSurfac:

; 575  : 		{
; 576  : 			MoveDof(COMP_LT_FLAP, aileronleft, af->auxaeroData->animAileronRate); // MLR 2003-09-30 change because tefRate is to damn slow

	push	-1
	push	-1
	push	-1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	push	ecx
	movss	xmm0, DWORD PTR [edx+3048]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _aileronleft$24[ebp]
	movss	DWORD PTR [esp], xmm0
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 577  : 			MoveDof(COMP_RT_FLAP, aileronrt, af->auxaeroData->animAileronRate);   // MLR 2003-09-30 same as above

	push	-1
	push	-1
	push	-1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	push	ecx
	movss	xmm0, DWORD PTR [edx+3048]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _aileronrt$26[ebp]
	movss	DWORD PTR [esp], xmm0
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 578  : 			if (af->auxaeroData->hasTef == AUX_LEFTEF_MANUAL) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+84], 1
	jne	$LN138@MoveSurfac

; 579  : 				MoveDof(COMP_LT_TEF, flapleft, af->auxaeroData->tefRate, af->auxaeroData->sndFlapStart, af->auxaeroData->sndFlapLoop, af->auxaeroData->sndFlapEnd);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+2448]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+2444]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+2440]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	push	ecx
	movss	xmm0, DWORD PTR [edx+116]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _flapleft$39[ebp]
	movss	DWORD PTR [esp], xmm0
	push	28					; 0000001cH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 580  : 				MoveDof(COMP_RT_TEF, flaprt, af->auxaeroData->tefRate, af->auxaeroData->sndFlapStart, af->auxaeroData->sndFlapLoop, af->auxaeroData->sndFlapEnd);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+2448]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+2444]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+2440]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	push	ecx
	movss	xmm0, DWORD PTR [edx+116]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _flaprt$41[ebp]
	movss	DWORD PTR [esp], xmm0
	push	29					; 0000001dH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 581  : 			}
; 582  : 			else {

	jmp	SHORT $LN137@MoveSurfac
$LN138@MoveSurfac:

; 583  : 				MoveDof(COMP_LT_TEF, flapleft, af->auxaeroData->tefRate);

	push	-1
	push	-1
	push	-1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	push	ecx
	movss	xmm0, DWORD PTR [edx+116]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _flapleft$39[ebp]
	movss	DWORD PTR [esp], xmm0
	push	28					; 0000001cH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 584  : 				MoveDof(COMP_RT_TEF, flaprt, af->auxaeroData->tefRate);

	push	-1
	push	-1
	push	-1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	push	ecx
	movss	xmm0, DWORD PTR [edx+116]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _flaprt$41[ebp]
	movss	DWORD PTR [esp], xmm0
	push	29					; 0000001dH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof
$LN137@MoveSurfac:

; 585  : 			}
; 586  : 		}
; 587  : 
; 588  : 		// Thrust Reverser - FRB
; 589  : 		if (af->auxaeroData->hasThrRev)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+4028], 0
	je	$LN134@MoveSurfac

; 590  : 		{
; 591  : 			if (OnGround() && af->thrustReverse == 2)

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	je	SHORT $LN135@MoveSurfac
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	cmp	DWORD PTR [edx+1592], 2
	jne	SHORT $LN135@MoveSurfac

; 592  : 			{
; 593  : 				float thrpos = af->auxaeroData->animThrRevAngle * DTR;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	movss	xmm0, DWORD PTR [edx+3076]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	movss	DWORD PTR _thrpos$18[ebp], xmm0

; 594  : 				MoveDof(COMP_REVERSE_THRUSTER, thrpos, af->auxaeroData->animThrRevRate);

	push	-1
	push	-1
	push	-1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	push	ecx
	movss	xmm0, DWORD PTR [edx+3080]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _thrpos$18[ebp]
	movss	DWORD PTR [esp], xmm0
	push	154					; 0000009aH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 595  : 			}
; 596  : 			else // Close it

	jmp	SHORT $LN134@MoveSurfac
$LN135@MoveSurfac:

; 597  : 				MoveDof(COMP_REVERSE_THRUSTER, 0.0f, af->auxaeroData->animThrRevRate);

	push	-1
	push	-1
	push	-1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	push	ecx
	movss	xmm0, DWORD PTR [edx+3080]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	154					; 0000009aH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof
$LN134@MoveSurfac:

; 598  : 		}
; 599  : 
; 600  : 		// Cobra - FRB animated pilot's head
; 601  : 		if ((g_bAnimPilotHead) && ((!IsPlayer()) || ((IsPlayer()) && (!g_bEnableTrackIR))
; 602  : 					|| ((IsPlayer()) && (g_bEnableTrackIR) 
; 603  : 					&& ((PlayerOptions.Get3dTrackIR() == false) 
; 604  : 					|| (OTWDriver.GetOTWDisplayMode() != OTWDriverClass::Mode2DCockpit 
; 605  : 					&& OTWDriver.GetOTWDisplayMode() != OTWDriverClass::Mode3DCockpit))))) 

	movzx	eax, BYTE PTR ?g_bAnimPilotHead@@3_NA	; g_bAnimPilotHead
	test	eax, eax
	je	$LN106@MoveSurfac
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPlayer@FalconEntity@@QAEHXZ		; FalconEntity::IsPlayer
	test	eax, eax
	je	SHORT $LN130@MoveSurfac
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPlayer@FalconEntity@@QAEHXZ		; FalconEntity::IsPlayer
	test	eax, eax
	je	SHORT $LN131@MoveSurfac
	movzx	ecx, BYTE PTR ?g_bEnableTrackIR@@3_NA	; g_bEnableTrackIR
	test	ecx, ecx
	je	SHORT $LN130@MoveSurfac
$LN131@MoveSurfac:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPlayer@FalconEntity@@QAEHXZ		; FalconEntity::IsPlayer
	test	eax, eax
	je	$LN106@MoveSurfac
	movzx	edx, BYTE PTR ?g_bEnableTrackIR@@3_NA	; g_bEnableTrackIR
	test	edx, edx
	je	$LN106@MoveSurfac
	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?Get3dTrackIR@PlayerOptionsClass@@QBE_NXZ ; PlayerOptionsClass::Get3dTrackIR
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN130@MoveSurfac
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetOTWDisplayMode@OTWDriverClass@@QAE?AW4OTWDisplayMode@1@XZ ; OTWDriverClass::GetOTWDisplayMode
	cmp	eax, 2
	je	$LN106@MoveSurfac
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetOTWDisplayMode@OTWDriverClass@@QAE?AW4OTWDisplayMode@1@XZ ; OTWDriverClass::GetOTWDisplayMode
	cmp	eax, 3
	je	$LN106@MoveSurfac
$LN130@MoveSurfac:

; 606  : 		{
; 607  : 			long  nHoldSec = 3;

	mov	DWORD PTR _nHoldSec$30[ebp], 3

; 608  : 
; 609  : 			// Pilot animation timer
; 610  : 			if (SimLibElapsedTime > static_cast<SIM_ULONG>(af->AnimPilotTime))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	cmp	eax, DWORD PTR [edx+856]
	jbe	$LN129@MoveSurfac

; 611  : 			{
; 612  : 				if (!af->IsSet(AirframeClass::InAir)){

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	jne	SHORT $LN128@MoveSurfac

; 613  : 					af->AnimPilotScenario = 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	DWORD PTR [eax+876], 1
$LN128@MoveSurfac:

; 614  : 				}
; 615  : 				af->AnimPilotAct ++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+860]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	DWORD PTR [edx+860], eax

; 616  : 				if (af->AnimPilotAct > af->maxAnimPilotActs){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [ecx+860]
	cmp	ecx, DWORD PTR [eax+872]
	jle	SHORT $LN127@MoveSurfac

; 617  : 					af->AnimPilotAct = af->PA_End;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	DWORD PTR [eax+860], 11			; 0000000bH
$LN127@MoveSurfac:

; 618  : 				}
; 619  : 				af->AnimPilotTime = SimLibElapsedTime + (CampaignSeconds * nHoldSec);

	mov	ecx, DWORD PTR _nHoldSec$30[ebp]
	imul	ecx, 1000				; 000003e8H
	add	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	DWORD PTR [eax+856], ecx
$LN129@MoveSurfac:

; 620  : 			}
; 621  : 
; 622  : 			// WSO/RIO/Copilot animation timer
; 623  : 			if (SimLibElapsedTime > static_cast<SIM_ULONG>(af->AnimWSOTime))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	cmp	eax, DWORD PTR [edx+864]
	jbe	$LN126@MoveSurfac

; 624  : 			{
; 625  : 				if (!af->IsSet(AirframeClass::InAir)){

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	jne	SHORT $LN125@MoveSurfac

; 626  : 					af->AnimWSOScenario = 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	DWORD PTR [eax+880], 1
$LN125@MoveSurfac:

; 627  : 				}
; 628  : 				af->AnimWSOAct ++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+868]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	DWORD PTR [edx+868], eax

; 629  : 				if (af->AnimWSOAct > af->maxAnimPilotActs){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [ecx+868]
	cmp	ecx, DWORD PTR [eax+872]
	jle	SHORT $LN124@MoveSurfac

; 630  : 					af->AnimWSOAct = af->PA_End;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	DWORD PTR [eax+868], 11			; 0000000bH
$LN124@MoveSurfac:

; 631  : 				}
; 632  : 				af->AnimWSOTime = SimLibElapsedTime + (CampaignSeconds * nHoldSec * 2);

	mov	ecx, DWORD PTR _nHoldSec$30[ebp]
	imul	ecx, 1000				; 000003e8H
	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	lea	eax, DWORD PTR [edx+ecx*2]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	DWORD PTR [edx+864], eax
$LN126@MoveSurfac:

; 633  : 			}
; 634  : 
; 635  : 			if (af->AnimPilotAct)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	cmp	DWORD PTR [ecx+860], 0
	je	$LN121@MoveSurfac

; 636  : 			{
; 637  : 				switch (af->TheRoutine[af->AnimPilotScenario][af->AnimPilotAct])

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	ecx, DWORD PTR [edx+876]
	imul	ecx, 40					; 00000028H
	lea	edx, DWORD PTR [eax+ecx+888]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	eax, DWORD PTR [ecx+860]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv766[ebp], ecx
	cmp	DWORD PTR tv766[ebp], 11		; 0000000bH
	ja	$LN121@MoveSurfac
	mov	edx, DWORD PTR tv766[ebp]
	jmp	DWORD PTR $LN205@MoveSurfac[edx*4]
$LN120@MoveSurfac:

; 638  : 				{
; 639  : 					case af->PA_None:
; 640  : 					case af->PA_End:
; 641  : 						MoveDof(COMP_HEAD_LR, (0.0f*DTR), g_fPilotHeadMoveRate, -1);

	push	-1
	push	-1
	push	-1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fPilotHeadMoveRate@@3MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	25					; 00000019H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 642  : 						MoveDof(COMP_HEAD_UD, (0.0f*DTR), g_fPilotHeadMoveRate, -1);

	push	-1
	push	-1
	push	-1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fPilotHeadMoveRate@@3MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	26					; 0000001aH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 643  : 						af->AnimPilotTime = static_cast<int>(SimLibElapsedTime + (g_fPilotActInterval * CampaignMinutes * PRANDFloatPos()));

	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR tv3302[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv3302[ebp]
	mov	ecx, DWORD PTR tv3302[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv3306[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv3306[ebp]
	movss	xmm1, DWORD PTR ?g_fPilotActInterval@@3MA
	mulss	xmm1, DWORD PTR __real@476a6000
	movss	DWORD PTR tv4190[ebp], xmm0
	movss	DWORD PTR tv4288[ebp], xmm1
	call	?PRANDFloatPos@@YAMXZ			; PRANDFloatPos
	fstp	DWORD PTR tv3314[ebp]
	movss	xmm0, DWORD PTR tv4288[ebp]
	mulss	xmm0, DWORD PTR tv3314[ebp]
	movss	xmm1, DWORD PTR tv4190[ebp]
	addss	xmm1, xmm0
	cvttss2si edx, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	DWORD PTR [ecx+856], edx

; 644  : 						af->AnimPilotAct = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	DWORD PTR [eax+860], 0

; 645  : 						af->AnimPilotScenario = rand()%(af->maxAnimPilotScenarios-1);

	call	_rand
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	ecx, DWORD PTR [edx+884]
	sub	ecx, 1
	cdq
	idiv	ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	DWORD PTR [ecx+876], edx

; 646  : 						if (af->AnimPilotScenario >= af->maxAnimPilotScenarios)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [eax+876]
	cmp	eax, DWORD PTR [edx+884]
	jl	SHORT $LN119@MoveSurfac

; 647  : 							af->AnimPilotScenario = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	DWORD PTR [edx+876], 0
$LN119@MoveSurfac:

; 648  : 					break;

	jmp	$LN121@MoveSurfac
$LN118@MoveSurfac:

; 649  : 
; 650  : 					case af->PA_Forward:
; 651  : 						MoveDof(COMP_HEAD_LR, (0.0f*DTR), g_fPilotHeadMoveRate, -1);

	push	-1
	push	-1
	push	-1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fPilotHeadMoveRate@@3MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	25					; 00000019H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 652  : 						MoveDof(COMP_HEAD_UD, (0.0f*DTR), g_fPilotHeadMoveRate, -1);

	push	-1
	push	-1
	push	-1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fPilotHeadMoveRate@@3MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	26					; 0000001aH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 653  : 					break;

	jmp	$LN121@MoveSurfac
$LN117@MoveSurfac:

; 654  : 
; 655  : 					case af->PA_ForwardUp:
; 656  : 						MoveDof(COMP_HEAD_LR, (0.0f*DTR), g_fPilotHeadMoveRate, -1);

	push	-1
	push	-1
	push	-1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fPilotHeadMoveRate@@3MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	25					; 00000019H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 657  : 						MoveDof(COMP_HEAD_UD, (-40.0f*DTR), g_fPilotHeadMoveRate, -1);

	push	-1
	push	-1
	push	-1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fPilotHeadMoveRate@@3MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf32b8c1
	movss	DWORD PTR [esp], xmm0
	push	26					; 0000001aH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 658  : 					break;

	jmp	$LN121@MoveSurfac
$LN116@MoveSurfac:

; 659  : 
; 660  : 					case af->PA_ForwardDown:
; 661  : 						MoveDof(COMP_HEAD_LR, (0.0f*DTR), g_fPilotHeadMoveRate, -1);

	push	-1
	push	-1
	push	-1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fPilotHeadMoveRate@@3MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	25					; 00000019H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 662  : 						MoveDof(COMP_HEAD_UD, (20.0f*DTR), g_fPilotHeadMoveRate, -1);

	push	-1
	push	-1
	push	-1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fPilotHeadMoveRate@@3MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3eb2b8c1
	movss	DWORD PTR [esp], xmm0
	push	26					; 0000001aH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 663  : 					break;

	jmp	$LN121@MoveSurfac
$LN115@MoveSurfac:

; 664  : 
; 665  : 					case af->PA_Left:
; 666  : 						MoveDof(COMP_HEAD_LR, (40.0f*DTR), g_fPilotHeadMoveRate, -1);

	push	-1
	push	-1
	push	-1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fPilotHeadMoveRate@@3MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f32b8c1
	movss	DWORD PTR [esp], xmm0
	push	25					; 00000019H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 667  : 						MoveDof(COMP_HEAD_UD, (0.0f*DTR), g_fPilotHeadMoveRate, -1);

	push	-1
	push	-1
	push	-1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fPilotHeadMoveRate@@3MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	26					; 0000001aH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 668  : 					break;

	jmp	$LN121@MoveSurfac
$LN114@MoveSurfac:

; 669  : 
; 670  : 					case af->PA_Right:
; 671  : 						MoveDof(COMP_HEAD_LR, (-40.0f*DTR), g_fPilotHeadMoveRate, -1);

	push	-1
	push	-1
	push	-1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fPilotHeadMoveRate@@3MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf32b8c1
	movss	DWORD PTR [esp], xmm0
	push	25					; 00000019H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 672  : 						MoveDof(COMP_HEAD_UD, (0.0f*DTR), g_fPilotHeadMoveRate, -1);

	push	-1
	push	-1
	push	-1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fPilotHeadMoveRate@@3MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	26					; 0000001aH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 673  : 					break;

	jmp	$LN121@MoveSurfac
$LN113@MoveSurfac:

; 674  : 
; 675  : 					case af->PA_LeftBack:
; 676  : 						MoveDof(COMP_HEAD_LR, (70.0f*DTR), g_fPilotHeadMoveRate, -1);

	push	-1
	push	-1
	push	-1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fPilotHeadMoveRate@@3MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f9c61a9
	movss	DWORD PTR [esp], xmm0
	push	25					; 00000019H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 677  : 						MoveDof(COMP_HEAD_UD, (0.0f*DTR), g_fPilotHeadMoveRate, -1);

	push	-1
	push	-1
	push	-1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fPilotHeadMoveRate@@3MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	26					; 0000001aH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 678  : 					break;

	jmp	$LN121@MoveSurfac
$LN112@MoveSurfac:

; 679  : 
; 680  : 					case af->PA_RightBack:
; 681  : 						MoveDof(COMP_HEAD_LR, (-70.0f*DTR), g_fPilotHeadMoveRate, -1);

	push	-1
	push	-1
	push	-1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fPilotHeadMoveRate@@3MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf9c61a9
	movss	DWORD PTR [esp], xmm0
	push	25					; 00000019H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 682  : 						MoveDof(COMP_HEAD_UD, (0.0f*DTR), g_fPilotHeadMoveRate, -1);

	push	-1
	push	-1
	push	-1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fPilotHeadMoveRate@@3MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	26					; 0000001aH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 683  : 					break;

	jmp	$LN121@MoveSurfac
$LN111@MoveSurfac:

; 684  : 
; 685  : 					case af->PA_LeftBackUp:
; 686  : 						MoveDof(COMP_HEAD_LR, (80.0f*DTR), g_fPilotHeadMoveRate, -1);

	push	-1
	push	-1
	push	-1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fPilotHeadMoveRate@@3MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3fb2b8c1
	movss	DWORD PTR [esp], xmm0
	push	25					; 00000019H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 687  : 						MoveDof(COMP_HEAD_UD, (-90.0f*DTR), g_fPilotHeadMoveRate, -1);

	push	-1
	push	-1
	push	-1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fPilotHeadMoveRate@@3MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bfc90fd9
	movss	DWORD PTR [esp], xmm0
	push	26					; 0000001aH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 688  : 					break;

	jmp	$LN121@MoveSurfac
$LN110@MoveSurfac:

; 689  : 
; 690  : 					case af->PA_RightBackUp:
; 691  : 						MoveDof(COMP_HEAD_LR, (-80.0f*DTR), g_fPilotHeadMoveRate, -1);

	push	-1
	push	-1
	push	-1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fPilotHeadMoveRate@@3MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bfb2b8c1
	movss	DWORD PTR [esp], xmm0
	push	25					; 00000019H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 692  : 						MoveDof(COMP_HEAD_UD, (-90.0f*DTR), g_fPilotHeadMoveRate, -1);

	push	-1
	push	-1
	push	-1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fPilotHeadMoveRate@@3MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bfc90fd9
	movss	DWORD PTR [esp], xmm0
	push	26					; 0000001aH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 693  : 					break;

	jmp	SHORT $LN121@MoveSurfac
$LN109@MoveSurfac:

; 694  : 
; 695  : 					case af->PA_BackUp:
; 696  : 						MoveDof(COMP_HEAD_LR, (-90.0f*DTR), g_fPilotHeadMoveRate, -1);

	push	-1
	push	-1
	push	-1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fPilotHeadMoveRate@@3MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bfc90fd9
	movss	DWORD PTR [esp], xmm0
	push	25					; 00000019H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 697  : 						MoveDof(COMP_HEAD_UD, (-45.0f*DTR), g_fPilotHeadMoveRate, -1);

	push	-1
	push	-1
	push	-1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fPilotHeadMoveRate@@3MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf490fd9
	movss	DWORD PTR [esp], xmm0
	push	26					; 0000001aH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof
$LN121@MoveSurfac:

; 698  : 					break;
; 699  : 				}
; 700  : 			} // end Pilot animation
; 701  : 
; 702  : 			if (af->AnimWSOAct)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	cmp	DWORD PTR [ecx+868], 0
	je	$LN106@MoveSurfac

; 703  : 			{
; 704  : 				switch (af->TheRoutine[af->AnimWSOScenario][af->AnimWSOAct])

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	ecx, DWORD PTR [edx+880]
	imul	ecx, 40					; 00000028H
	lea	edx, DWORD PTR [eax+ecx+888]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	eax, DWORD PTR [ecx+868]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv962[ebp], ecx
	cmp	DWORD PTR tv962[ebp], 11		; 0000000bH
	ja	$LN106@MoveSurfac
	mov	edx, DWORD PTR tv962[ebp]
	jmp	DWORD PTR $LN206@MoveSurfac[edx*4]
$LN105@MoveSurfac:

; 705  : 				{
; 706  : 					case af->PA_None:
; 707  : 					case af->PA_End:
; 708  : 						MoveDof(COMP_HEAD2_LR, (0.0f*DTR), g_fPilotHeadMoveRate, -1);

	push	-1
	push	-1
	push	-1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fPilotHeadMoveRate@@3MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	27					; 0000001bH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 709  : 						MoveDof(COMP_HEAD2_UD, (0.0f*DTR), g_fPilotHeadMoveRate, -1);

	push	-1
	push	-1
	push	-1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fPilotHeadMoveRate@@3MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	49					; 00000031H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 710  : 						af->AnimWSOTime = static_cast<int>(SimLibElapsedTime + (g_fPilotActInterval * CampaignMinutes * PRANDFloatPos()));

	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR tv3424[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv3424[ebp]
	mov	ecx, DWORD PTR tv3424[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv3428[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv3428[ebp]
	movss	xmm1, DWORD PTR ?g_fPilotActInterval@@3MA
	mulss	xmm1, DWORD PTR __real@476a6000
	movss	DWORD PTR tv4290[ebp], xmm0
	movss	DWORD PTR tv4292[ebp], xmm1
	call	?PRANDFloatPos@@YAMXZ			; PRANDFloatPos
	fstp	DWORD PTR tv3436[ebp]
	movss	xmm0, DWORD PTR tv4292[ebp]
	mulss	xmm0, DWORD PTR tv3436[ebp]
	movss	xmm1, DWORD PTR tv4290[ebp]
	addss	xmm1, xmm0
	cvttss2si edx, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	DWORD PTR [ecx+864], edx

; 711  : 						af->AnimWSOAct = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	DWORD PTR [eax+868], 0

; 712  : 						af->AnimWSOScenario = rand()%(af->maxAnimPilotScenarios-1);

	call	_rand
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	ecx, DWORD PTR [edx+884]
	sub	ecx, 1
	cdq
	idiv	ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	DWORD PTR [ecx+880], edx

; 713  : 						if (af->AnimWSOScenario >= af->maxAnimPilotScenarios)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [eax+880]
	cmp	eax, DWORD PTR [edx+884]
	jl	SHORT $LN104@MoveSurfac

; 714  : 							af->AnimWSOScenario = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	DWORD PTR [edx+880], 0
$LN104@MoveSurfac:

; 715  : 					break;

	jmp	$LN106@MoveSurfac
$LN103@MoveSurfac:

; 716  : 
; 717  : 					case af->PA_Forward:
; 718  : 						MoveDof(COMP_HEAD2_LR, (0.0f*DTR), g_fPilotHeadMoveRate, -1);

	push	-1
	push	-1
	push	-1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fPilotHeadMoveRate@@3MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	27					; 0000001bH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 719  : 						MoveDof(COMP_HEAD2_UD, (0.0f*DTR), g_fPilotHeadMoveRate, -1);

	push	-1
	push	-1
	push	-1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fPilotHeadMoveRate@@3MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	49					; 00000031H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 720  : 					break;

	jmp	$LN106@MoveSurfac
$LN102@MoveSurfac:

; 721  : 
; 722  : 					case af->PA_ForwardUp:
; 723  : 						MoveDof(COMP_HEAD2_LR, (20.0f*DTR), g_fPilotHeadMoveRate, -1);

	push	-1
	push	-1
	push	-1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fPilotHeadMoveRate@@3MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3eb2b8c1
	movss	DWORD PTR [esp], xmm0
	push	27					; 0000001bH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 724  : 						MoveDof(COMP_HEAD2_UD, (0.0f*DTR), g_fPilotHeadMoveRate, -1);

	push	-1
	push	-1
	push	-1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fPilotHeadMoveRate@@3MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	49					; 00000031H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 725  : 					break;

	jmp	$LN106@MoveSurfac
$LN101@MoveSurfac:

; 726  : 
; 727  : 					case af->PA_ForwardDown:
; 728  : 						MoveDof(COMP_HEAD2_LR, (0.0f*DTR), g_fPilotHeadMoveRate, -1);

	push	-1
	push	-1
	push	-1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fPilotHeadMoveRate@@3MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	27					; 0000001bH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 729  : 						MoveDof(COMP_HEAD2_UD, (-10.0f*DTR), g_fPilotHeadMoveRate, -1);

	push	-1
	push	-1
	push	-1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fPilotHeadMoveRate@@3MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@be32b8c1
	movss	DWORD PTR [esp], xmm0
	push	49					; 00000031H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 730  : 					break;

	jmp	$LN106@MoveSurfac
$LN100@MoveSurfac:

; 731  : 
; 732  : 					case af->PA_Left:
; 733  : 						MoveDof(COMP_HEAD2_LR, (-20.0f*DTR), g_fPilotHeadMoveRate, -1);

	push	-1
	push	-1
	push	-1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fPilotHeadMoveRate@@3MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@beb2b8c1
	movss	DWORD PTR [esp], xmm0
	push	27					; 0000001bH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 734  : 						MoveDof(COMP_HEAD2_UD, (0.0f*DTR), g_fPilotHeadMoveRate, -1);

	push	-1
	push	-1
	push	-1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fPilotHeadMoveRate@@3MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	49					; 00000031H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 735  : 					break;

	jmp	$LN106@MoveSurfac
$LN99@MoveSurfac:

; 736  : 
; 737  : 					case af->PA_Right:
; 738  : 						MoveDof(COMP_HEAD2_LR, (0.0f*DTR), g_fPilotHeadMoveRate, -1);

	push	-1
	push	-1
	push	-1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fPilotHeadMoveRate@@3MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	27					; 0000001bH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 739  : 						MoveDof(COMP_HEAD2_UD, (-30.0f*DTR), g_fPilotHeadMoveRate, -1);

	push	-1
	push	-1
	push	-1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fPilotHeadMoveRate@@3MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf060a91
	movss	DWORD PTR [esp], xmm0
	push	49					; 00000031H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 740  : 					break;

	jmp	$LN106@MoveSurfac
$LN98@MoveSurfac:

; 741  : 
; 742  : 					case af->PA_LeftBack:
; 743  : 						MoveDof(COMP_HEAD2_LR, (40.0f*DTR), g_fPilotHeadMoveRate, -1);

	push	-1
	push	-1
	push	-1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fPilotHeadMoveRate@@3MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f32b8c1
	movss	DWORD PTR [esp], xmm0
	push	27					; 0000001bH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 744  : 						MoveDof(COMP_HEAD2_UD, (0.0f*DTR), g_fPilotHeadMoveRate, -1);

	push	-1
	push	-1
	push	-1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fPilotHeadMoveRate@@3MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	49					; 00000031H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 745  : 					break;

	jmp	$LN106@MoveSurfac
$LN97@MoveSurfac:

; 746  : 
; 747  : 					case af->PA_RightBack:
; 748  : 						MoveDof(COMP_HEAD2_LR, (-40.0f*DTR), g_fPilotHeadMoveRate, -1);

	push	-1
	push	-1
	push	-1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fPilotHeadMoveRate@@3MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf32b8c1
	movss	DWORD PTR [esp], xmm0
	push	27					; 0000001bH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 749  : 						MoveDof(COMP_HEAD2_UD, (-30.0f*DTR), g_fPilotHeadMoveRate, -1);

	push	-1
	push	-1
	push	-1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fPilotHeadMoveRate@@3MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf060a91
	movss	DWORD PTR [esp], xmm0
	push	49					; 00000031H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 750  : 					break;

	jmp	$LN106@MoveSurfac
$LN96@MoveSurfac:

; 751  : 
; 752  : 					case af->PA_LeftBackUp:
; 753  : 						MoveDof(COMP_HEAD2_LR, (40.0f*DTR), g_fPilotHeadMoveRate, -1);

	push	-1
	push	-1
	push	-1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fPilotHeadMoveRate@@3MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f32b8c1
	movss	DWORD PTR [esp], xmm0
	push	27					; 0000001bH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 754  : 						MoveDof(COMP_HEAD2_UD, (-20.0f*DTR), g_fPilotHeadMoveRate, -1);

	push	-1
	push	-1
	push	-1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fPilotHeadMoveRate@@3MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@beb2b8c1
	movss	DWORD PTR [esp], xmm0
	push	49					; 00000031H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 755  : 					break;

	jmp	$LN106@MoveSurfac
$LN95@MoveSurfac:

; 756  : 
; 757  : 					case af->PA_RightBackUp:
; 758  : 						MoveDof(COMP_HEAD2_LR, (-20.0f*DTR), g_fPilotHeadMoveRate, -1);

	push	-1
	push	-1
	push	-1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fPilotHeadMoveRate@@3MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@beb2b8c1
	movss	DWORD PTR [esp], xmm0
	push	27					; 0000001bH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 759  : 						MoveDof(COMP_HEAD2_UD, (-40.0f*DTR), g_fPilotHeadMoveRate, -1);

	push	-1
	push	-1
	push	-1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fPilotHeadMoveRate@@3MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf32b8c1
	movss	DWORD PTR [esp], xmm0
	push	49					; 00000031H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 760  : 					break;

	jmp	SHORT $LN106@MoveSurfac
$LN94@MoveSurfac:

; 761  : 
; 762  : 					case af->PA_BackUp:
; 763  : 						MoveDof(COMP_HEAD2_LR, (80.0f*DTR), g_fPilotHeadMoveRate, -1);

	push	-1
	push	-1
	push	-1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fPilotHeadMoveRate@@3MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3fb2b8c1
	movss	DWORD PTR [esp], xmm0
	push	27					; 0000001bH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 764  : 						MoveDof(COMP_HEAD2_UD, (-20.0f*DTR), g_fPilotHeadMoveRate, -1);

	push	-1
	push	-1
	push	-1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fPilotHeadMoveRate@@3MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@beb2b8c1
	movss	DWORD PTR [esp], xmm0
	push	49					; 00000031H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof
$LN106@MoveSurfac:

; 765  : 					break;
; 766  : 				}
; 767  : 			} // end WSO animation
; 768  : 		}
; 769  : 
; 770  : 		// Pilot animation tied to stick
; 771  : 		if (g_bAnimPilotHead && af->AnimPilotAct == 0)

	movzx	eax, BYTE PTR ?g_bAnimPilotHead@@3_NA	; g_bAnimPilotHead
	test	eax, eax
	je	$LN86@MoveSurfac
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	cmp	DWORD PTR [edx+860], 0
	jne	$LN86@MoveSurfac

; 772  : 		{
; 773  : 
; 774  : 			if((!g_bEnableTrackIR)||(!IsPlayer()) || ((g_bEnableTrackIR)&&(!PlayerOptions.Get3dTrackIR())))

	movzx	eax, BYTE PTR ?g_bEnableTrackIR@@3_NA	; g_bEnableTrackIR
	test	eax, eax
	je	SHORT $LN91@MoveSurfac
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPlayer@FalconEntity@@QAEHXZ		; FalconEntity::IsPlayer
	test	eax, eax
	je	SHORT $LN91@MoveSurfac
	movzx	ecx, BYTE PTR ?g_bEnableTrackIR@@3_NA	; g_bEnableTrackIR
	test	ecx, ecx
	je	$LN92@MoveSurfac
	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?Get3dTrackIR@PlayerOptionsClass@@QBE_NXZ ; PlayerOptionsClass::Get3dTrackIR
	movzx	edx, al
	test	edx, edx
	jne	$LN92@MoveSurfac
$LN91@MoveSurfac:

; 775  : 			{
; 776  : 				if ((af->rstick > -0.1f) && (af->rstick < 0.1f))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [ecx+1504]
	comiss	xmm0, DWORD PTR __real@bdcccccd
	jbe	SHORT $LN90@MoveSurfac
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR __real@3dcccccd
	comiss	xmm0, DWORD PTR [eax+1504]
	jbe	SHORT $LN90@MoveSurfac

; 777  : 				{
; 778  : 					MoveDof(COMP_HEAD_LR, (0.0f*DTR), g_fPilotHeadMoveRate, -1);

	push	-1
	push	-1
	push	-1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fPilotHeadMoveRate@@3MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	25					; 00000019H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 779  : 					MoveDof(COMP_HEAD2_LR, (0.0f*DTR), g_fPilotHeadMoveRate, -1);

	push	-1
	push	-1
	push	-1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fPilotHeadMoveRate@@3MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	27					; 0000001bH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 780  : 				}
; 781  : 				else

	jmp	$LN89@MoveSurfac
$LN90@MoveSurfac:

; 782  : 				{
; 783  : 					MoveDof(COMP_HEAD_LR, (-af->rstick * 120.0f * DTR), g_fPilotHeadMoveRate, -1);

	push	-1
	push	-1
	push	-1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fPilotHeadMoveRate@@3MA
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR [edx+1504]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR __real@42f00000
	mulss	xmm0, DWORD PTR __real@3c8efa34
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	25					; 00000019H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 784  : 					MoveDof(COMP_HEAD2_LR, (-af->rstick * 120.0f * DTR), g_fPilotHeadMoveRate, -1);

	push	-1
	push	-1
	push	-1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fPilotHeadMoveRate@@3MA
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [ecx+1504]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR __real@42f00000
	mulss	xmm0, DWORD PTR __real@3c8efa34
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	27					; 0000001bH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof
$LN89@MoveSurfac:

; 785  : 				}
; 786  : 
; 787  : 				if ((af->pstick > -0.1f) && (af->pstick < 0.1f))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR [eax+1500]
	comiss	xmm0, DWORD PTR __real@bdcccccd
	jbe	SHORT $LN88@MoveSurfac
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR __real@3dcccccd
	comiss	xmm0, DWORD PTR [edx+1500]
	jbe	SHORT $LN88@MoveSurfac

; 788  : 				{
; 789  : 					MoveDof(COMP_HEAD_UD, (0.0f*DTR), g_fPilotHeadMoveRate, -1);

	push	-1
	push	-1
	push	-1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fPilotHeadMoveRate@@3MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	26					; 0000001aH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 790  : 					MoveDof(COMP_HEAD2_UD, (0.0f*DTR), g_fPilotHeadMoveRate, -1);

	push	-1
	push	-1
	push	-1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fPilotHeadMoveRate@@3MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	49					; 00000031H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 791  : 				}
; 792  : 				else

	jmp	$LN87@MoveSurfac
$LN88@MoveSurfac:

; 793  : 				{
; 794  : 					MoveDof(COMP_HEAD_UD, (-af->pstick * 100.0f * DTR), g_fPilotHeadMoveRate, -1);

	push	-1
	push	-1
	push	-1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fPilotHeadMoveRate@@3MA
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [ecx+1500]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR __real@42c80000
	mulss	xmm0, DWORD PTR __real@3c8efa34
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	26					; 0000001aH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 795  : 					MoveDof(COMP_HEAD2_UD, (-af->pstick * 100.0f * DTR), g_fPilotHeadMoveRate, -1);

	push	-1
	push	-1
	push	-1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fPilotHeadMoveRate@@3MA
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR [eax+1500]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR __real@42c80000
	mulss	xmm0, DWORD PTR __real@3c8efa34
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	49					; 00000031H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof
$LN87@MoveSurfac:

; 796  : 				}
; 797  : 			} 
; 798  : 			else 

	jmp	$LN86@MoveSurfac
$LN92@MoveSurfac:

; 799  : 			{
; 800  : 				// Head TRACK IR Control
; 801  : 				//SetDOF( COMP_HEAD_LR, -theTrackIRObject.getYaw());
; 802  : 				//SetDOF( COMP_HEAD2_LR, -theTrackIRObject.getYaw());
; 803  : 				//SetDOF( COMP_HEAD_UD, theTrackIRObject.getPitch());
; 804  : 				//SetDOF( COMP_HEAD2_UD, theTrackIRObject.getPitch());
; 805  : 				MoveDof(COMP_HEAD_LR, theTrackIRObject.getYaw(), g_fPilotHeadMoveRate, -1);

	push	-1
	push	-1
	push	-1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fPilotHeadMoveRate@@3MA
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?theTrackIRObject@@3VTrackIR@@A ; theTrackIRObject
	call	?getYaw@TrackIR@@QAEMXZ			; TrackIR::getYaw
	push	ecx
	fstp	DWORD PTR [esp]
	push	25					; 00000019H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 806  : 				MoveDof(COMP_HEAD2_LR, theTrackIRObject.getYaw(), g_fPilotHeadMoveRate, -1);

	push	-1
	push	-1
	push	-1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fPilotHeadMoveRate@@3MA
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?theTrackIRObject@@3VTrackIR@@A ; theTrackIRObject
	call	?getYaw@TrackIR@@QAEMXZ			; TrackIR::getYaw
	push	ecx
	fstp	DWORD PTR [esp]
	push	27					; 0000001bH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 807  : 				MoveDof(COMP_HEAD_UD, theTrackIRObject.getPitch(), g_fPilotHeadMoveRate, -1);

	push	-1
	push	-1
	push	-1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fPilotHeadMoveRate@@3MA
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?theTrackIRObject@@3VTrackIR@@A ; theTrackIRObject
	call	?getPitch@TrackIR@@QAEMXZ		; TrackIR::getPitch
	push	ecx
	fstp	DWORD PTR [esp]
	push	26					; 0000001aH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 808  : 				MoveDof(COMP_HEAD2_UD, theTrackIRObject.getPitch(), g_fPilotHeadMoveRate, -1);

	push	-1
	push	-1
	push	-1
	push	ecx
	movss	xmm0, DWORD PTR ?g_fPilotHeadMoveRate@@3MA
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?theTrackIRObject@@3VTrackIR@@A ; theTrackIRObject
	call	?getPitch@TrackIR@@QAEMXZ		; TrackIR::getPitch
	push	ecx
	fstp	DWORD PTR [esp]
	push	49					; 00000031H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof
$LN86@MoveSurfac:

; 809  : 
; 810  : 			}
; 811  : 		}
; 812  : 
; 813  : 		// end Pilot head animation
; 814  : 
; 815  : 		{ // MLR - 2003-10-04 Tail hook
; 816  : 			float hookpos = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _hookpos$37[ebp], xmm0

; 817  : 			
; 818  : 			if(af->IsSet(AirframeClass::Hook)) {

	push	-2147483648				; 80000000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN83@MoveSurfac

; 819  : 				// RV - Biker - Do not lower hook when on carrier deck
; 820  : 				if (af->IsSet(AirframeClass::OnObject))

	push	1073741824				; 40000000H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN84@MoveSurfac

; 821  : 					hookpos = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _hookpos$37[ebp], xmm0

; 822  : 				else

	jmp	SHORT $LN83@MoveSurfac
$LN84@MoveSurfac:

; 823  : 					hookpos = af->auxaeroData->animHookAngle * DTR;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	movss	xmm0, DWORD PTR [edx+3068]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	movss	DWORD PTR _hookpos$37[ebp], xmm0
$LN83@MoveSurfac:

; 824  : 			}
; 825  : 
; 826  : 			MoveDof(COMP_TAILHOOK, hookpos, af->auxaeroData->animHookRate);

	push	-1
	push	-1
	push	-1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	push	ecx
	movss	xmm0, DWORD PTR [edx+3072]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _hookpos$37[ebp]
	movss	DWORD PTR [esp], xmm0
	push	37					; 00000025H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 827  : 		}
; 828  : 		
; 829  : 		{ // MLR - 2003-09-30 Spoiler code
; 830  : 			//TJL 01/04/04 adding wingSweep; //Cobra 10/30/04 TJL
; 831  : 			float spoiler1l,spoiler1r,spoiler2l,spoiler2r,sweep;
; 832  : 			CalculateSweepAndSpoiler(sweep,spoiler1l,spoiler1r,spoiler2l,spoiler2r);

	lea	eax, DWORD PTR _spoiler2r$11[ebp]
	push	eax
	lea	ecx, DWORD PTR _spoiler2l$6[ebp]
	push	ecx
	lea	edx, DWORD PTR _spoiler1r$13[ebp]
	push	edx
	lea	eax, DWORD PTR _spoiler1l$4[ebp]
	push	eax
	lea	ecx, DWORD PTR _sweep$28[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateSweepAndSpoiler@AircraftClass@@QAEXAAM0000@Z ; AircraftClass::CalculateSweepAndSpoiler

; 833  : 			MoveDof(COMP_LT_SPOILER1, spoiler1l, af->auxaeroData->animSpoiler1Rate);

	push	-1
	push	-1
	push	-1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+3004]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _spoiler1l$4[ebp]
	movss	DWORD PTR [esp], xmm0
	push	42					; 0000002aH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 834  : 			MoveDof(COMP_RT_SPOILER1, spoiler1r, af->auxaeroData->animSpoiler1Rate);

	push	-1
	push	-1
	push	-1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+3004]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _spoiler1r$13[ebp]
	movss	DWORD PTR [esp], xmm0
	push	43					; 0000002bH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 835  : 			MoveDof(COMP_LT_SPOILER2, spoiler2l, af->auxaeroData->animSpoiler2Rate);

	push	-1
	push	-1
	push	-1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+3020]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _spoiler2l$6[ebp]
	movss	DWORD PTR [esp], xmm0
	push	44					; 0000002cH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 836  : 			MoveDof(COMP_RT_SPOILER2, spoiler2r, af->auxaeroData->animSpoiler2Rate);

	push	-1
	push	-1
	push	-1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+3020]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _spoiler2r$11[ebp]
	movss	DWORD PTR [esp], xmm0
	push	45					; 0000002dH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 837  : 			MoveDof(COMP_SWING_WING,  sweep,     af->auxaeroData->animSwingWingRate);

	push	-1
	push	-1
	push	-1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+3088]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _sweep$28[ebp]
	movss	DWORD PTR [esp], xmm0
	push	46					; 0000002eH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 838  : 			wingSweep = sweep;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _sweep$28[ebp]
	movss	DWORD PTR [edx+1836], xmm0

; 839  : 		}
; 840  : 	//Cobra 10/30/04 TJL
; 841  : 	{	// intake ramps
; 842  :  			int l;
; 843  :  			for(l=0;l<3;l++)

	mov	DWORD PTR _l$48[ebp], 0
	jmp	SHORT $LN82@MoveSurfac
$LN81@MoveSurfac:
	mov	eax, DWORD PTR _l$48[ebp]
	add	eax, 1
	mov	DWORD PTR _l$48[ebp], eax
$LN82@MoveSurfac:
	cmp	DWORD PTR _l$48[ebp], 3
	jge	$LN80@MoveSurfac

; 844  :  			{
; 845  :  				MoveDof(COMP_INTAKE_1_RAMP_1 + l,af->auxaeroData->animIntakeRamp[0].table.Lookup(af->alpha, af->mach), af->auxaeroData->animIntakeRamp[0].Rate * DTR);

	push	-1
	push	-1
	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, 24					; 00000018H
	imul	ecx, 0
	movss	xmm0, DWORD PTR [eax+ecx+3956]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	push	ecx
	movss	xmm0, DWORD PTR [eax+1144]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	push	ecx
	movss	xmm0, DWORD PTR [edx+1152]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, 24					; 00000018H
	imul	eax, 0
	lea	ecx, DWORD PTR [edx+eax+3936]
	call	?Lookup@TwoDimensionTable@@QAEMMM@Z	; TwoDimensionTable::Lookup
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _l$48[ebp]
	add	ecx, 83					; 00000053H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 846  :  			}

	jmp	$LN81@MoveSurfac
$LN80@MoveSurfac:

; 847  :  			if(af->auxaeroData->nEngines == 2)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+344], 2
	jne	$LN76@MoveSurfac

; 848  :  			{
; 849  :  				for(l=0;l<3;l++)

	mov	DWORD PTR _l$48[ebp], 0
	jmp	SHORT $LN78@MoveSurfac
$LN77@MoveSurfac:
	mov	edx, DWORD PTR _l$48[ebp]
	add	edx, 1
	mov	DWORD PTR _l$48[ebp], edx
$LN78@MoveSurfac:
	cmp	DWORD PTR _l$48[ebp], 3
	jge	$LN76@MoveSurfac

; 850  :  				{
; 851  :  					MoveDof(COMP_INTAKE_2_RAMP_1 + l,af->auxaeroData->animIntakeRamp[0].table.Lookup(af->alpha, af->mach), af->auxaeroData->animIntakeRamp[0].Rate * DTR);

	push	-1
	push	-1
	push	-1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, 24					; 00000018H
	imul	eax, 0
	movss	xmm0, DWORD PTR [edx+eax+3956]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	push	ecx
	movss	xmm0, DWORD PTR [edx+1144]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+1152]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, 24					; 00000018H
	imul	edx, 0
	lea	ecx, DWORD PTR [ecx+edx+3936]
	call	?Lookup@TwoDimensionTable@@QAEMMM@Z	; TwoDimensionTable::Lookup
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _l$48[ebp]
	add	eax, 86					; 00000056H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 852  :  				}

	jmp	$LN77@MoveSurfac
$LN76@MoveSurfac:

; 853  :  			}
; 854  :  
; 855  :  		}
; 856  : 		
; 857  : 		
; 858  : 		// Rudder
; 859  : 		stabAngle = -CalculateRudder(qFactor);

	push	ecx
	movss	xmm0, DWORD PTR _qFactor$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateRudder@AircraftClass@@AAEMM@Z	; AircraftClass::CalculateRudder
	fstp	DWORD PTR tv3688[ebp]
	movss	xmm0, DWORD PTR tv3688[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _stabAngle$[ebp], xmm0

; 860  : 		SetDOF(COMP_RUDDER, stabAngle);

	push	ecx
	movss	xmm0, DWORD PTR _stabAngle$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDOF@SimMoverClass@@QAEXHM@Z		; SimMoverClass::SetDOF

; 861  : 		
; 862  : 		// LEF
; 863  : 		if (af->auxaeroData->hasLef) 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+80], 0
	je	$LN75@MoveSurfac

; 864  : 		{
; 865  : 			
; 866  : 			CalculateLef(qFactor);

	push	ecx
	movss	xmm0, DWORD PTR _qFactor$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateLef@AircraftClass@@AAEXM@Z	; AircraftClass::CalculateLef

; 867  : 			
; 868  : 			MoveDof(COMP_LT_LEF, leftLEFAngle, af->auxaeroData->lefRate);

	push	-1
	push	-1
	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	push	ecx
	movss	xmm0, DWORD PTR [eax+124]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+868]
	movss	DWORD PTR [esp], xmm0
	push	9
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 869  : 			MoveDof(COMP_RT_LEF, rightLEFAngle, af->auxaeroData->lefRate);

	push	-1
	push	-1
	push	-1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+124]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+872]
	movss	DWORD PTR [esp], xmm0
	push	10					; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof
$LN75@MoveSurfac:

; 870  : 		}
; 871  : 		// set light stuff
; 872  : 		RunLightSurfaces();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RunLightSurfaces@AircraftClass@@QAEXXZ	; AircraftClass::RunLightSurfaces

; 873  : 		// Set gear stuff
; 874  : 		RunGearSurfaces();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RunGearSurfaces@AircraftClass@@QAEXXZ	; AircraftClass::RunGearSurfaces

; 875  : 		
; 876  : 		
; 877  : 		{ // MLR - Exhaust Nozzle DOF
; 878  : 			float nozpos;
; 879  : 			if (rpm[0] < 1.0F) // Mil or less

	mov	eax, 4
	imul	eax, 0
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _rpm$[ebp+eax]
	jbe	$LN74@MoveSurfac

; 880  : 			{
; 881  : 				float diff;
; 882  : 				nozpos=(rpm[0] - 0.8f) * 5.f; 

	mov	ecx, 4
	imul	ecx, 0
	movss	xmm0, DWORD PTR _rpm$[ebp+ecx]
	subss	xmm0, DWORD PTR __real@3f4ccccd
	mulss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR _nozpos$50[ebp], xmm0

; 883  : 				if(nozpos<0) 

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _nozpos$50[ebp]
	jbe	SHORT $LN73@MoveSurfac

; 884  : 					nozpos=0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _nozpos$50[ebp], xmm0
$LN73@MoveSurfac:

; 885  : 				// noz is 0 - 1.0
; 886  : 				diff=af->auxaeroData->animExhNozMil - af->auxaeroData->animExhNozIdle;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	edx, DWORD PTR [eax+4]
	movss	xmm0, DWORD PTR [ecx+3036]
	subss	xmm0, DWORD PTR [edx+3032]
	movss	DWORD PTR _diff$9[ebp], xmm0

; 887  : 				nozpos=(af->auxaeroData->animExhNozIdle + diff * nozpos) * DTR;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	movss	xmm0, DWORD PTR _diff$9[ebp]
	mulss	xmm0, DWORD PTR _nozpos$50[ebp]
	addss	xmm0, DWORD PTR [edx+3032]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	movss	DWORD PTR _nozpos$50[ebp], xmm0

; 888  : 			}
; 889  : 			else

	jmp	$LN72@MoveSurfac
$LN74@MoveSurfac:

; 890  : 			{
; 891  : 				float diff;
; 892  : 				nozpos=(rpm[0] - 1.0f) * 50.f; 

	mov	eax, 4
	imul	eax, 0
	movss	xmm0, DWORD PTR _rpm$[ebp+eax]
	subss	xmm0, DWORD PTR __real@3f800000
	mulss	xmm0, DWORD PTR __real@42480000
	movss	DWORD PTR _nozpos$50[ebp], xmm0

; 893  : 				if(nozpos>1.0) 

	cvtss2sd xmm0, DWORD PTR _nozpos$50[ebp]
	comisd	xmm0, QWORD PTR __real@3ff0000000000000
	jbe	SHORT $LN71@MoveSurfac

; 894  : 					nozpos=1.0;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _nozpos$50[ebp], xmm0
$LN71@MoveSurfac:

; 895  : 				// noz is 0 - 1.0
; 896  : 				diff=af->auxaeroData->animExhNozAB - af->auxaeroData->animExhNozMil;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	ecx, DWORD PTR [edx+4]
	movss	xmm0, DWORD PTR [eax+3040]
	subss	xmm0, DWORD PTR [ecx+3036]
	movss	DWORD PTR _diff$5[ebp], xmm0

; 897  : 				nozpos=(af->auxaeroData->animExhNozMil + diff * nozpos) * DTR;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+4]
	movss	xmm0, DWORD PTR _diff$5[ebp]
	mulss	xmm0, DWORD PTR _nozpos$50[ebp]
	addss	xmm0, DWORD PTR [ecx+3036]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	movss	DWORD PTR _nozpos$50[ebp], xmm0
$LN72@MoveSurfac:

; 898  : 			}
; 899  : 			MoveDof(COMP_EXH_NOZ, nozpos, af->auxaeroData->animExhNozRate);

	push	-1
	push	-1
	push	-1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+3044]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _nozpos$50[ebp]
	movss	DWORD PTR [esp], xmm0
	push	39					; 00000027H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 900  : 		}
; 901  : 		
; 902  : 		{   // MLR This DOF is intended to be used with the BScaleNode
; 903  : 			float abscale=0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _abscale$42[ebp], xmm0

; 904  : 			
; 905  : 			if(rpm[0] > 1.0f)

	mov	edx, 4
	imul	edx, 0
	movss	xmm0, DWORD PTR _rpm$[ebp+edx]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN69@MoveSurfac

; 906  : 			{
; 907  : 				abscale=(rpm[0] - 1.0f) * 33.0f;

	mov	eax, 4
	imul	eax, 0
	movss	xmm0, DWORD PTR _rpm$[ebp+eax]
	subss	xmm0, DWORD PTR __real@3f800000
	mulss	xmm0, DWORD PTR __real@42040000
	movss	DWORD PTR _abscale$42[ebp], xmm0

; 908  : 				if(abscale > 1.0)

	cvtss2sd xmm0, DWORD PTR _abscale$42[ebp]
	comisd	xmm0, QWORD PTR __real@3ff0000000000000
	jbe	SHORT $LN69@MoveSurfac

; 909  : 					abscale=1.0;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _abscale$42[ebp], xmm0
$LN69@MoveSurfac:

; 910  : 			}
; 911  : 			SetDOF(COMP_ABDOF,abscale); // only goes from 0 - 1.0

	push	ecx
	movss	xmm0, DWORD PTR _abscale$42[ebp]
	movss	DWORD PTR [esp], xmm0
	push	38					; 00000026H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDOF@SimMoverClass@@QAEXHM@Z		; SimMoverClass::SetDOF

; 912  : 		}
; 913  : 		
; 914  : 		
; 915  : 		
; 916  : 		
; 917  : 		//need to reimplement using the GetAfterburnerStage()
; 918  : 		//	  since there isn't enough granularity in the powerOutput to show the noz
; 919  : 		//	  correctly
; 920  : 		// Nozzle position
; 921  : 		{
; 922  : 			int ab =0;

	mov	DWORD PTR _ab$23[ebp], 0

; 923  : 			if (rpm[0] < 1.0F) // Mil or less

	mov	ecx, 4
	imul	ecx, 0
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _rpm$[ebp+ecx]
	jbe	SHORT $LN68@MoveSurfac

; 924  : 			{
; 925  : 				stage = FloatToInt32((rpm[0] - 0.7F) * 13.3333F);

	mov	edx, 4
	imul	edx, 0
	movss	xmm0, DWORD PTR _rpm$[ebp+edx]
	subss	xmm0, DWORD PTR __real@3f333333
	mulss	xmm0, DWORD PTR __real@41555532
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _stage$[ebp], eax

; 926  : 			}
; 927  : 			else

	jmp	SHORT $LN67@MoveSurfac
$LN68@MoveSurfac:

; 928  : 			{
; 929  : 				stage = FloatToInt32((rpm[0] - 1.0F) * 233.0F) + 4;

	mov	eax, 4
	imul	eax, 0
	movss	xmm0, DWORD PTR _rpm$[ebp+eax]
	subss	xmm0, DWORD PTR __real@3f800000
	mulss	xmm0, DWORD PTR __real@43690000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	add	eax, 4
	mov	DWORD PTR _stage$[ebp], eax

; 930  : 				ab = 11;

	mov	DWORD PTR _ab$23[ebp], 11		; 0000000bH
$LN67@MoveSurfac:

; 931  : 			}
; 932  : 			
; 933  : 			stage = max (0, stage);

	cmp	DWORD PTR _stage$[ebp], 0
	jge	SHORT $LN173@MoveSurfac
	mov	DWORD PTR tv1601[ebp], 0
	jmp	SHORT $LN174@MoveSurfac
$LN173@MoveSurfac:
	mov	ecx, DWORD PTR _stage$[ebp]
	mov	DWORD PTR tv1601[ebp], ecx
$LN174@MoveSurfac:
	mov	edx, DWORD PTR tv1601[ebp]
	mov	DWORD PTR _stage$[ebp], edx

; 934  : 			
; 935  : 			
; 936  : 			if ((rpm[0] > 1.0F) != GetSwitch(COMP_AB))

	mov	eax, 4
	imul	eax, 0
	movss	xmm0, DWORD PTR _rpm$[ebp+eax]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN175@MoveSurfac
	mov	DWORD PTR tv1605[ebp], 1
	jmp	SHORT $LN176@MoveSurfac
$LN175@MoveSurfac:
	mov	DWORD PTR tv1605[ebp], 0
$LN176@MoveSurfac:
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSwitch@SimMoverClass@@QAEHH@Z	; SimMoverClass::GetSwitch
	cmp	DWORD PTR tv1605[ebp], eax
	je	SHORT $LN66@MoveSurfac

; 937  : 			{
; 938  : 				
; 939  : 				SetSwitch (COMP_AB, (rpm[0] > 1.0F));

	mov	ecx, 4
	imul	ecx, 0
	movss	xmm0, DWORD PTR _rpm$[ebp+ecx]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN177@MoveSurfac
	mov	DWORD PTR tv1622[ebp], 1
	jmp	SHORT $LN178@MoveSurfac
$LN177@MoveSurfac:
	mov	DWORD PTR tv1622[ebp], 0
$LN178@MoveSurfac:
	mov	edx, DWORD PTR tv1622[ebp]
	push	edx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSwitch@SimMoverClass@@QAEXHH@Z	; SimMoverClass::SetSwitch
$LN66@MoveSurfac:

; 940  : 			}
; 941  : 			
; 942  : 			// Afterbuner cone
; 943  : 			if (rpm[0] >= 1.0F)

	mov	eax, 4
	imul	eax, 0
	movss	xmm0, DWORD PTR _rpm$[ebp+eax]
	comiss	xmm0, DWORD PTR __real@3f800000
	jb	$LN62@MoveSurfac

; 944  : 			{
; 945  : 				for (i=0; i<6; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN64@MoveSurfac
$LN63@MoveSurfac:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN64@MoveSurfac:
	cmp	DWORD PTR _i$[ebp], 6
	jge	$LN62@MoveSurfac

; 946  : 				{
; 947  : 					VertexData[i] = max (0.0F, 18.0F - 600.0F * (rpm[0] - 1.0F));

	mov	edx, 4
	imul	edx, 0
	movss	xmm0, DWORD PTR _rpm$[ebp+edx]
	subss	xmm0, DWORD PTR __real@3f800000
	mulss	xmm0, DWORD PTR __real@44160000
	movss	xmm1, DWORD PTR __real@41900000
	subss	xmm1, xmm0
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, xmm1
	jbe	SHORT $LN179@MoveSurfac
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv1652[ebp], xmm0
	jmp	SHORT $LN180@MoveSurfac
$LN179@MoveSurfac:
	mov	eax, 4
	imul	eax, 0
	movss	xmm0, DWORD PTR _rpm$[ebp+eax]
	subss	xmm0, DWORD PTR __real@3f800000
	mulss	xmm0, DWORD PTR __real@44160000
	movss	xmm1, DWORD PTR __real@41900000
	subss	xmm1, xmm0
	movss	DWORD PTR tv1652[ebp], xmm1
$LN180@MoveSurfac:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+616]
	mov	eax, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR tv1652[ebp]
	movss	DWORD PTR [edx+eax*4], xmm0

; 948  : 				}

	jmp	$LN63@MoveSurfac
$LN62@MoveSurfac:

; 949  : 			}
; 950  : 			
; 951  : 			if (1 << stage != GetSwitch (COMP_EXH_NOZZLE))

	mov	esi, 1
	mov	ecx, DWORD PTR _stage$[ebp]
	shl	esi, cl
	push	10					; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSwitch@SimMoverClass@@QAEHH@Z	; SimMoverClass::GetSwitch
	cmp	esi, eax
	je	SHORT $LN61@MoveSurfac

; 952  : 			{
; 953  : 				SetSwitch (COMP_EXH_NOZZLE, 1 << stage);

	mov	edx, 1
	mov	ecx, DWORD PTR _stage$[ebp]
	shl	edx, cl
	push	edx
	push	10					; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSwitch@SimMoverClass@@QAEXHH@Z	; SimMoverClass::SetSwitch
$LN61@MoveSurfac:

; 954  : 			}
; 955  : 			
; 956  : 			if(af->auxaeroData->nEngines==2)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+344], 2
	jne	$LN60@MoveSurfac

; 957  : 			{ // MLR - Exhaust Nozzle DOF
; 958  : 				
; 959  : 				float nozpos;
; 960  : 				if (rpm[1] < 1.0F) // Mil or less

	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _rpm$[ebp+eax]
	jbe	$LN59@MoveSurfac

; 961  : 				{
; 962  : 					float diff;
; 963  : 					nozpos=(rpm[1] - 0.8f) * 5.0f; 

	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _rpm$[ebp+ecx]
	subss	xmm0, DWORD PTR __real@3f4ccccd
	mulss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR _nozpos$49[ebp], xmm0

; 964  : 					if(nozpos<0) 

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _nozpos$49[ebp]
	jbe	SHORT $LN58@MoveSurfac

; 965  : 						nozpos=0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _nozpos$49[ebp], xmm0
$LN58@MoveSurfac:

; 966  : 					// noz is 0 - 1.0
; 967  : 					diff=af->auxaeroData->animExhNozMil - af->auxaeroData->animExhNozIdle;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	edx, DWORD PTR [eax+4]
	movss	xmm0, DWORD PTR [ecx+3036]
	subss	xmm0, DWORD PTR [edx+3032]
	movss	DWORD PTR _diff$21[ebp], xmm0

; 968  : 					nozpos=(af->auxaeroData->animExhNozIdle + diff * nozpos) * DTR;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	movss	xmm0, DWORD PTR _diff$21[ebp]
	mulss	xmm0, DWORD PTR _nozpos$49[ebp]
	addss	xmm0, DWORD PTR [edx+3032]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	movss	DWORD PTR _nozpos$49[ebp], xmm0

; 969  : 				}
; 970  : 				else

	jmp	$LN57@MoveSurfac
$LN59@MoveSurfac:

; 971  : 				{
; 972  : 					float diff;
; 973  : 					nozpos=(rpm[1] - 1.0f) * 50.0f; 

	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _rpm$[ebp+eax]
	subss	xmm0, DWORD PTR __real@3f800000
	mulss	xmm0, DWORD PTR __real@42480000
	movss	DWORD PTR _nozpos$49[ebp], xmm0

; 974  : 					if(nozpos>1.0f) 

	movss	xmm0, DWORD PTR _nozpos$49[ebp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN56@MoveSurfac

; 975  : 						nozpos=1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _nozpos$49[ebp], xmm0
$LN56@MoveSurfac:

; 976  : 					// noz is 0 - 1.0
; 977  : 					diff=af->auxaeroData->animExhNozAB - af->auxaeroData->animExhNozMil;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	ecx, DWORD PTR [edx+4]
	movss	xmm0, DWORD PTR [eax+3040]
	subss	xmm0, DWORD PTR [ecx+3036]
	movss	DWORD PTR _diff$19[ebp], xmm0

; 978  : 					nozpos=(af->auxaeroData->animExhNozMil + diff * nozpos) * DTR;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+4]
	movss	xmm0, DWORD PTR _diff$19[ebp]
	mulss	xmm0, DWORD PTR _nozpos$49[ebp]
	addss	xmm0, DWORD PTR [ecx+3036]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	movss	DWORD PTR _nozpos$49[ebp], xmm0
$LN57@MoveSurfac:

; 979  : 				}
; 980  : 				MoveDof(COMP_EXH_NOZ2, nozpos, af->auxaeroData->animExhNozRate);

	push	-1
	push	-1
	push	-1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+3044]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _nozpos$49[ebp]
	movss	DWORD PTR [esp], xmm0
	push	67					; 00000043H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 981  : 				
; 982  : 				{   // MLR This DOF is intended to be used with the BScaleNode
; 983  : 					float abscale=0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _abscale$44[ebp], xmm0

; 984  : 					
; 985  : 					if(rpm[1] > 1.0f)

	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR _rpm$[ebp+edx]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN54@MoveSurfac

; 986  : 					{
; 987  : 						abscale=(rpm[1] - 1.0f) * 33.0f;

	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _rpm$[ebp+eax]
	subss	xmm0, DWORD PTR __real@3f800000
	mulss	xmm0, DWORD PTR __real@42040000
	movss	DWORD PTR _abscale$44[ebp], xmm0

; 988  : 						if(abscale > 1.0f)

	movss	xmm0, DWORD PTR _abscale$44[ebp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN54@MoveSurfac

; 989  : 							abscale=1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _abscale$44[ebp], xmm0
$LN54@MoveSurfac:

; 990  : 					}
; 991  : 					SetDOF(COMP_ABDOF2,abscale); // only goes from 0 - 1.0

	push	ecx
	movss	xmm0, DWORD PTR _abscale$44[ebp]
	movss	DWORD PTR [esp], xmm0
	push	66					; 00000042H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDOF@SimMoverClass@@QAEXHM@Z		; SimMoverClass::SetDOF

; 992  : 				}
; 993  : 				
; 994  : 				SetSwitch (COMP_AB2, (rpm[1] > 1.0F));

	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _rpm$[ebp+ecx]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN181@MoveSurfac
	mov	DWORD PTR tv1751[ebp], 1
	jmp	SHORT $LN182@MoveSurfac
$LN181@MoveSurfac:
	mov	DWORD PTR tv1751[ebp], 0
$LN182@MoveSurfac:
	mov	edx, DWORD PTR tv1751[ebp]
	push	edx
	push	30					; 0000001eH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSwitch@SimMoverClass@@QAEXHH@Z	; SimMoverClass::SetSwitch

; 995  : 				if (rpm[1] < 1.0F) // Mil or less

	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _rpm$[ebp+eax]
	jbe	SHORT $LN53@MoveSurfac

; 996  : 				{
; 997  : 					stage = FloatToInt32((rpm[1] - 0.7F) * 13.3333F);

	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _rpm$[ebp+ecx]
	subss	xmm0, DWORD PTR __real@3f333333
	mulss	xmm0, DWORD PTR __real@41555532
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _stage$[ebp], eax

; 998  : 				}
; 999  : 				else

	jmp	SHORT $LN52@MoveSurfac
$LN53@MoveSurfac:

; 1000 : 				{
; 1001 : 					stage = FloatToInt32((rpm[1] - 1.0F) * 233.0F) + 4;

	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR _rpm$[ebp+edx]
	subss	xmm0, DWORD PTR __real@3f800000
	mulss	xmm0, DWORD PTR __real@43690000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	add	eax, 4
	mov	DWORD PTR _stage$[ebp], eax
$LN52@MoveSurfac:

; 1002 : 				}
; 1003 : 				
; 1004 : 				stage = max (0, stage);

	cmp	DWORD PTR _stage$[ebp], 0
	jge	SHORT $LN183@MoveSurfac
	mov	DWORD PTR tv1773[ebp], 0
	jmp	SHORT $LN184@MoveSurfac
$LN183@MoveSurfac:
	mov	eax, DWORD PTR _stage$[ebp]
	mov	DWORD PTR tv1773[ebp], eax
$LN184@MoveSurfac:
	mov	ecx, DWORD PTR tv1773[ebp]
	mov	DWORD PTR _stage$[ebp], ecx

; 1005 : 				
; 1006 : 				SetSwitch (COMP_EXH_NOZZLE2, 1 << stage);

	mov	edx, 1
	mov	ecx, DWORD PTR _stage$[ebp]
	shl	edx, cl
	push	edx
	push	31					; 0000001fH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSwitch@SimMoverClass@@QAEXHH@Z	; SimMoverClass::SetSwitch

; 1007 : 			}
; 1008 : 			else

	jmp	SHORT $LN51@MoveSurfac
$LN60@MoveSurfac:

; 1009 : 			{
; 1010 : 				SetDOF(COMP_EXH_NOZ2,GetDOFValue(COMP_EXH_NOZ));

	push	39					; 00000027H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDOFValue@SimMoverClass@@QAEMH@Z	; SimMoverClass::GetDOFValue
	push	ecx
	fstp	DWORD PTR [esp]
	push	67					; 00000043H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDOF@SimMoverClass@@QAEXHM@Z		; SimMoverClass::SetDOF

; 1011 : 				SetDOF(COMP_ABDOF2,GetDOFValue(COMP_ABDOF));

	push	38					; 00000026H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDOFValue@SimMoverClass@@QAEMH@Z	; SimMoverClass::GetDOFValue
	push	ecx
	fstp	DWORD PTR [esp]
	push	66					; 00000042H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDOF@SimMoverClass@@QAEXHM@Z		; SimMoverClass::SetDOF

; 1012 : 				SetSwitch (COMP_AB2, GetSwitch(COMP_AB));

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSwitch@SimMoverClass@@QAEHH@Z	; SimMoverClass::GetSwitch
	push	eax
	push	30					; 0000001eH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSwitch@SimMoverClass@@QAEXHH@Z	; SimMoverClass::SetSwitch

; 1013 : 				SetSwitch (COMP_EXH_NOZZLE2, GetSwitch(COMP_EXH_NOZZLE));

	push	10					; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSwitch@SimMoverClass@@QAEHH@Z	; SimMoverClass::GetSwitch
	push	eax
	push	31					; 0000001fH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSwitch@SimMoverClass@@QAEXHH@Z	; SimMoverClass::SetSwitch
$LN51@MoveSurfac:

; 1014 : 			}
; 1015 : 		}
; 1016 : 		
; 1017 : 		
; 1018 : 		if (IsLocal ())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsLocal@VuEntity@@QBEEXZ		; VuEntity::IsLocal
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN50@MoveSurfac

; 1019 : 		{
; 1020 : 			if (af->dbrake < 0.4F)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR __real@3ecccccd
	comiss	xmm0, DWORD PTR [edx+1548]
	jbe	SHORT $LN49@MoveSurfac

; 1021 : 			{
; 1022 : 				UnSetFlag(AIR_BRAKES_OUT);

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnSetFlag@SimBaseClass@@QAEXH@Z	; SimBaseClass::UnSetFlag
	jmp	SHORT $LN47@MoveSurfac
$LN49@MoveSurfac:

; 1023 : 			}
; 1024 : 			else if (af->dbrake > 0.6F)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [ecx+1548]
	comiss	xmm0, DWORD PTR __real@3f19999a
	jbe	SHORT $LN47@MoveSurfac

; 1025 : 			{
; 1026 : 				SetFlag(AIR_BRAKES_OUT);

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFlag@SimBaseClass@@QAEXH@Z		; SimBaseClass::SetFlag
$LN47@MoveSurfac:

; 1027 : 			}
; 1028 : 		}
; 1029 : 		else

	jmp	SHORT $LN44@MoveSurfac
$LN50@MoveSurfac:

; 1030 : 		{
; 1031 : 			if (IsSetFlag (AIR_BRAKES_OUT))

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN45@MoveSurfac

; 1032 : 			{
; 1033 : 				af->dbrake = 1.0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+1548], xmm0

; 1034 : 			}
; 1035 : 			else

	jmp	SHORT $LN44@MoveSurfac
$LN45@MoveSurfac:

; 1036 : 			{
; 1037 : 				af->dbrake = 0.0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+1548], xmm0
$LN44@MoveSurfac:

; 1038 : 			}
; 1039 : 		}
; 1040 : 		
; 1041 : 		stabAngle = af->dbrake * af->auxaeroData->airbrakeMaxAngle * DTR;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	edx, DWORD PTR [eax+4]
	movss	xmm0, DWORD PTR [ecx+1548]
	mulss	xmm0, DWORD PTR [edx+140]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	movss	DWORD PTR _stabAngle$[ebp], xmm0

; 1042 : 		
; 1043 : 		SetDOF(COMP_LT_AIR_BRAKE_TOP, stabAngle);

	push	ecx
	movss	xmm0, DWORD PTR _stabAngle$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	15					; 0000000fH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDOF@SimMoverClass@@QAEXHM@Z		; SimMoverClass::SetDOF

; 1044 : 		SetDOF(COMP_LT_AIR_BRAKE_BOT, stabAngle);

	push	ecx
	movss	xmm0, DWORD PTR _stabAngle$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDOF@SimMoverClass@@QAEXHM@Z		; SimMoverClass::SetDOF

; 1045 : 		SetDOF(COMP_RT_AIR_BRAKE_TOP, stabAngle);

	push	ecx
	movss	xmm0, DWORD PTR _stabAngle$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	17					; 00000011H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDOF@SimMoverClass@@QAEXHM@Z		; SimMoverClass::SetDOF

; 1046 : 		SetDOF(COMP_RT_AIR_BRAKE_BOT, stabAngle);

	push	ecx
	movss	xmm0, DWORD PTR _stabAngle$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	18					; 00000012H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDOF@SimMoverClass@@QAEXHM@Z		; SimMoverClass::SetDOF

; 1047 : 		
; 1048 : 		gFact = min(7, max (0, FloatToInt32((af->nzcgb - 4.0F) * 1.5F)));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [ecx+1192]
	subss	xmm0, DWORD PTR __real@40800000
	mulss	xmm0, DWORD PTR __real@3fc00000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	test	eax, eax
	jge	SHORT $LN185@MoveSurfac
	mov	DWORD PTR tv1926[ebp], 0
	jmp	SHORT $LN186@MoveSurfac
$LN185@MoveSurfac:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR [eax+1192]
	subss	xmm0, DWORD PTR __real@40800000
	mulss	xmm0, DWORD PTR __real@3fc00000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR tv1926[ebp], eax
$LN186@MoveSurfac:
	cmp	DWORD PTR tv1926[ebp], 7
	jle	SHORT $LN189@MoveSurfac
	mov	DWORD PTR tv1944[ebp], 7
	jmp	$LN190@MoveSurfac
$LN189@MoveSurfac:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR [edx+1192]
	subss	xmm0, DWORD PTR __real@40800000
	mulss	xmm0, DWORD PTR __real@3fc00000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	test	eax, eax
	jge	SHORT $LN187@MoveSurfac
	mov	DWORD PTR tv1943[ebp], 0
	jmp	SHORT $LN188@MoveSurfac
$LN187@MoveSurfac:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [ecx+1192]
	subss	xmm0, DWORD PTR __real@40800000
	mulss	xmm0, DWORD PTR __real@3fc00000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR tv1943[ebp], eax
$LN188@MoveSurfac:
	mov	edx, DWORD PTR tv1943[ebp]
	mov	DWORD PTR tv1944[ebp], edx
$LN190@MoveSurfac:
	mov	eax, DWORD PTR tv1944[ebp]
	mov	DWORD PTR _gFact$[ebp], eax

; 1049 : 		if (gFact != GetSwitch (COMP_WING_VAPOR))

	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSwitch@SimMoverClass@@QAEHH@Z	; SimMoverClass::GetSwitch
	cmp	DWORD PTR _gFact$[ebp], eax
	je	SHORT $LN42@MoveSurfac

; 1050 : 		{
; 1051 : 			// RV - I-Hawk - the switch is used only if new vortex code isn't used
; 1052 : 			// or if the y position of the first (and basic) vortex trail is set to 0
; 1053 : 			// (or not defind as for sure if defined correctly, y position must be != then 0)
; 1054 : 			
; 1055 : 			bool vortexTrailsCondition = false;

	mov	BYTE PTR _vortexTrailsCondition$52[ebp], 0

; 1056 : 
; 1057 : #if NEW_VORTEX_TRAILS //I-Hawk, if Defined at aircraft.h
; 1058 : 
; 1059 : 			vortexTrailsCondition = true;

	mov	BYTE PTR _vortexTrailsCondition$52[ebp], 1

; 1060 : 
; 1061 : #endif
; 1062 : 
; 1063 : 			float vortexTrailsUsed = af->auxaeroData->vortex1Location.y;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	movss	xmm0, DWORD PTR [eax+544]
	movss	DWORD PTR _vortexTrailsUsed$17[ebp], xmm0

; 1064 : 
; 1065 : 			if ( (!vortexTrailsCondition) || (!vortexTrailsUsed) )

	movzx	ecx, BYTE PTR _vortexTrailsCondition$52[ebp]
	test	ecx, ecx
	je	SHORT $LN41@MoveSurfac
	movss	xmm0, DWORD PTR _vortexTrailsUsed$17[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN42@MoveSurfac
$LN41@MoveSurfac:

; 1066 : 			{
; 1067 :                 SetSwitch (COMP_WING_VAPOR, gFact);

	mov	edx, DWORD PTR _gFact$[ebp]
	push	edx
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSwitch@SimMoverClass@@QAEXHH@Z	; SimMoverClass::SetSwitch
$LN42@MoveSurfac:

; 1068 : 			}
; 1069 : 		}
; 1070 : 		
; 1071 : 		if (af->IsEngineFlag(AirframeClass::FuelDoorOpen) != GetSwitch(COMP_REFUEL_DR)) 

	push	4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	call	?IsEngineFlag@AirframeClass@@QAEHW4EngineFlags@1@@Z ; AirframeClass::IsEngineFlag
	mov	esi, eax
	push	13					; 0000000dH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSwitch@SimMoverClass@@QAEHH@Z	; SimMoverClass::GetSwitch
	cmp	esi, eax
	je	SHORT $LN40@MoveSurfac

; 1072 : 		{
; 1073 : 			
; 1074 : 			SetSwitch(COMP_REFUEL_DR, af->IsEngineFlag(AirframeClass::FuelDoorOpen));

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+932]
	call	?IsEngineFlag@AirframeClass@@QAEHW4EngineFlags@1@@Z ; AirframeClass::IsEngineFlag
	push	eax
	push	13					; 0000000dH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSwitch@SimMoverClass@@QAEXHH@Z	; SimMoverClass::SetSwitch
$LN40@MoveSurfac:

; 1075 : 		}
; 1076 : 		if (af->auxaeroData->dragChuteCd > 0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+4]
	movss	xmm0, DWORD PTR [ecx+228]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN39@MoveSurfac

; 1077 : 			DeployDragChute(COMP_DRAGCHUTE);

	push	24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DeployDragChute@AircraftClass@@AAEXH@Z	; AircraftClass::DeployDragChute
$LN39@MoveSurfac:

; 1078 : 		
; 1079 : 		if (IsLocal ())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsLocal@VuEntity@@QBEEXZ		; VuEntity::IsLocal
	movzx	edx, al
	test	edx, edx
	je	$LN38@MoveSurfac

; 1080 : 		{
; 1081 : 			if (af->canopyState) 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movzx	edx, BYTE PTR [ecx+1588]
	test	edx, edx
	je	$LN37@MoveSurfac

; 1082 : 			{ // canopy open
; 1083 : 				MoveDof (COMP_CANOPY_DOF, af->auxaeroData->canopyMaxAngle * DTR, af->auxaeroData->canopyRate,
; 1084 : 					af->auxaeroData->sndCanopyOpenStart,
; 1085 : 					af->auxaeroData->sndCanopyLoop,af->auxaeroData->sndCanopyOpenEnd
; 1086 : 				);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+2488]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+2500]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+2484]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	push	ecx
	movss	xmm0, DWORD PTR [edx+248]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	movss	xmm0, DWORD PTR [edx+244]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	30					; 0000001eH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 1087 : 				SetAcStatusBits(ACSTATUS_CANOPY);	//2004-03-23 Booster

	push	128					; 00000080H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAcStatusBits@AircraftClass@@QAEXH@Z	; AircraftClass::SetAcStatusBits

; 1088 : 			}
; 1089 : 			else 

	jmp	SHORT $LN36@MoveSurfac
$LN37@MoveSurfac:

; 1090 : 			{ // canopy shut
; 1091 : 				MoveDof (
; 1092 : 					COMP_CANOPY_DOF, 0, af->auxaeroData->canopyRate,
; 1093 : 					af->auxaeroData->sndCanopyCloseStart,
; 1094 : 					af->auxaeroData->sndCanopyLoop,af->auxaeroData->sndCanopyCloseEnd
; 1095 : 				);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+2496]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+2500]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+2492]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	push	ecx
	movss	xmm0, DWORD PTR [edx+248]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	30					; 0000001eH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 1096 : 				ClearAcStatusBits(ACSTATUS_CANOPY);  //2004-03-23 Booster 

	push	128					; 00000080H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearAcStatusBits@AircraftClass@@QAEXH@Z ; AircraftClass::ClearAcStatusBits
$LN36@MoveSurfac:

; 1097 : 			}
; 1098 : 		}
; 1099 : 		else

	jmp	$LN33@MoveSurfac
$LN38@MoveSurfac:

; 1100 : 		{
; 1101 : 			if (IsAcStatusBitsSet(ACSTATUS_CANOPY))  // 2004-03-23 Booster - Canopy open/close

	push	128					; 00000080H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsAcStatusBitsSet@AircraftClass@@QBE_NH@Z ; AircraftClass::IsAcStatusBitsSet
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN34@MoveSurfac

; 1102 : 			{
; 1103 : 				MoveDof (COMP_CANOPY_DOF, af->auxaeroData->canopyMaxAngle * DTR, af->auxaeroData->canopyRate);

	push	-1
	push	-1
	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	push	ecx
	movss	xmm0, DWORD PTR [eax+248]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	movss	xmm0, DWORD PTR [eax+244]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	30					; 0000001eH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 1104 : 			}
; 1105 : 			else

	jmp	SHORT $LN33@MoveSurfac
$LN34@MoveSurfac:

; 1106 : 			{
; 1107 : 				MoveDof (COMP_CANOPY_DOF, 0, af->auxaeroData->canopyRate);

	push	-1
	push	-1
	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	push	ecx
	movss	xmm0, DWORD PTR [eax+248]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	30					; 0000001eH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof
$LN33@MoveSurfac:

; 1108 : 			}
; 1109 : 		}
; 1110 : 		
; 1111 : 		
; 1112 : }
; 1113 : else // Simple Model 

	jmp	$LN19@MoveSurfac
$LN153@MoveSurfac:

; 1114 : {
; 1115 : 	float leftStab, rightStab;
; 1116 : 	CalculateStab(qFactor, &leftStab, &rightStab);

	lea	ecx, DWORD PTR _rightStab$15[ebp]
	push	ecx
	lea	edx, DWORD PTR _leftStab$16[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _qFactor$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateStab@AircraftClass@@AAEXMPAM0@Z ; AircraftClass::CalculateStab

; 1117 : 	SetDOF(SIMP_LT_STAB, -leftStab);

	movss	xmm0, DWORD PTR _leftStab$16[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDOF@SimMoverClass@@QAEXHM@Z		; SimMoverClass::SetDOF

; 1118 : 	SetDOF(SIMP_RT_STAB, -rightStab);

	movss	xmm0, DWORD PTR _rightStab$15[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDOF@SimMoverClass@@QAEXHM@Z		; SimMoverClass::SetDOF

; 1119 : 	
; 1120 : 	float aileronleft, aileronrt;
; 1121 : 	float flapleft, flaprt;
; 1122 : 	CalculateAileronAndFlap(qFactor, &aileronleft, &aileronrt, &flapleft, &flaprt);

	lea	eax, DWORD PTR _flaprt$40[ebp]
	push	eax
	lea	ecx, DWORD PTR _flapleft$33[ebp]
	push	ecx
	lea	edx, DWORD PTR _aileronrt$31[ebp]
	push	edx
	lea	eax, DWORD PTR _aileronleft$29[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _qFactor$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateAileronAndFlap@AircraftClass@@AAEXMPAM000@Z ; AircraftClass::CalculateAileronAndFlap

; 1123 : 	//      stabAngle = af->rstick * qFactor * af->auxaeroData->aileronMaxAngle * DTR;
; 1124 : 	if (af->auxaeroData->hasFlapperons) 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+88], 0
	je	SHORT $LN31@MoveSurfac

; 1125 : 	{
; 1126 : 		SetDOF(SIMP_LT_AILERON, aileronleft + flapleft);

	movss	xmm0, DWORD PTR _aileronleft$29[ebp]
	addss	xmm0, DWORD PTR _flapleft$33[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDOF@SimMoverClass@@QAEXHM@Z		; SimMoverClass::SetDOF

; 1127 : 		SetDOF(SIMP_RT_AILERON, aileronrt + flaprt);

	movss	xmm0, DWORD PTR _aileronrt$31[ebp]
	addss	xmm0, DWORD PTR _flaprt$40[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDOF@SimMoverClass@@QAEXHM@Z		; SimMoverClass::SetDOF

; 1128 : 	}
; 1129 : 	else 

	jmp	$LN28@MoveSurfac
$LN31@MoveSurfac:

; 1130 : 	{
; 1131 : 		SetDOF(SIMP_LT_AILERON, aileronleft);

	push	ecx
	movss	xmm0, DWORD PTR _aileronleft$29[ebp]
	movss	DWORD PTR [esp], xmm0
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDOF@SimMoverClass@@QAEXHM@Z		; SimMoverClass::SetDOF

; 1132 : 		SetDOF(SIMP_RT_AILERON, aileronrt);

	push	ecx
	movss	xmm0, DWORD PTR _aileronrt$31[ebp]
	movss	DWORD PTR [esp], xmm0
	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDOF@SimMoverClass@@QAEXHM@Z		; SimMoverClass::SetDOF

; 1133 : 		if (af->auxaeroData->hasTef == AUX_LEFTEF_MANUAL) {

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+84], 1
	jne	$LN29@MoveSurfac

; 1134 : 			MoveDof(SIMP_LT_TEF, flapleft, af->auxaeroData->tefRate, af->auxaeroData->sndFlapStart, af->auxaeroData->sndFlapLoop, af->auxaeroData->sndFlapEnd);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+2448]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+2444]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+2440]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	push	ecx
	movss	xmm0, DWORD PTR [eax+116]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _flapleft$33[ebp]
	movss	DWORD PTR [esp], xmm0
	push	20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 1135 : 			MoveDof(SIMP_RT_TEF, flaprt, af->auxaeroData->tefRate, af->auxaeroData->sndFlapStart, af->auxaeroData->sndFlapLoop, af->auxaeroData->sndFlapEnd);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+2448]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+2444]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+2440]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	push	ecx
	movss	xmm0, DWORD PTR [eax+116]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _flaprt$40[ebp]
	movss	DWORD PTR [esp], xmm0
	push	19					; 00000013H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 1136 : 		} else {

	jmp	SHORT $LN28@MoveSurfac
$LN29@MoveSurfac:

; 1137 : 			MoveDof(SIMP_LT_TEF, flapleft, af->auxaeroData->tefRate);

	push	-1
	push	-1
	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	push	ecx
	movss	xmm0, DWORD PTR [eax+116]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _flapleft$33[ebp]
	movss	DWORD PTR [esp], xmm0
	push	20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 1138 : 			MoveDof(SIMP_RT_TEF, flaprt, af->auxaeroData->tefRate);

	push	-1
	push	-1
	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	push	ecx
	movss	xmm0, DWORD PTR [eax+116]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _flaprt$40[ebp]
	movss	DWORD PTR [esp], xmm0
	push	19					; 00000013H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof
$LN28@MoveSurfac:

; 1139 : 		}
; 1140 : 	}
; 1141 : 	stabAngle = CalculateRudder(qFactor);

	push	ecx
	movss	xmm0, DWORD PTR _qFactor$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateRudder@AircraftClass@@AAEMM@Z	; AircraftClass::CalculateRudder
	fstp	DWORD PTR _stabAngle$[ebp]

; 1142 : 	SetDOF(SIMP_RUDDER_1, stabAngle);

	push	ecx
	movss	xmm0, DWORD PTR _stabAngle$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDOF@SimMoverClass@@QAEXHM@Z		; SimMoverClass::SetDOF

; 1143 : 	SetDOF(SIMP_RUDDER_2, stabAngle);

	push	ecx
	movss	xmm0, DWORD PTR _stabAngle$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	9
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDOF@SimMoverClass@@QAEXHM@Z		; SimMoverClass::SetDOF

; 1144 : 	
; 1145 : 	stabAngle = af->dbrake * af->auxaeroData->airbrakeMaxAngle * DTR;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	eax, DWORD PTR [ecx+4]
	movss	xmm0, DWORD PTR [edx+1548]
	mulss	xmm0, DWORD PTR [eax+140]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	movss	DWORD PTR _stabAngle$[ebp], xmm0

; 1146 : 	SetDOF(SIMP_AIR_BRAKE, stabAngle);

	push	ecx
	movss	xmm0, DWORD PTR _stabAngle$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	10					; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDOF@SimMoverClass@@QAEXHM@Z		; SimMoverClass::SetDOF

; 1147 : 	
; 1148 : 	if (af->auxaeroData->hasLef) {

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+80], 0
	je	$LN27@MoveSurfac

; 1149 : 		CalculateLef(qFactor);

	push	ecx
	movss	xmm0, DWORD PTR _qFactor$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateLef@AircraftClass@@AAEXM@Z	; AircraftClass::CalculateLef

; 1150 : 		MoveDof(SIMP_LT_LEF, leftLEFAngle, af->auxaeroData->lefRate, -1);

	push	-1
	push	-1
	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	push	ecx
	movss	xmm0, DWORD PTR [eax+124]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+868]
	movss	DWORD PTR [esp], xmm0
	push	22					; 00000016H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 1151 : 		MoveDof(SIMP_RT_LEF, rightLEFAngle, af->auxaeroData->lefRate, -1);

	push	-1
	push	-1
	push	-1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+124]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+872]
	movss	DWORD PTR [esp], xmm0
	push	21					; 00000015H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof
$LN27@MoveSurfac:

; 1152 : 	}
; 1153 : 	
; 1154 : 	if ((rpm[0] > 1.0F) != GetSwitch (SIMP_AB))

	mov	eax, 4
	imul	eax, 0
	movss	xmm0, DWORD PTR _rpm$[ebp+eax]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN191@MoveSurfac
	mov	DWORD PTR tv2267[ebp], 1
	jmp	SHORT $LN192@MoveSurfac
$LN191@MoveSurfac:
	mov	DWORD PTR tv2267[ebp], 0
$LN192@MoveSurfac:
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSwitch@SimMoverClass@@QAEHH@Z	; SimMoverClass::GetSwitch
	cmp	DWORD PTR tv2267[ebp], eax
	je	SHORT $LN26@MoveSurfac

; 1155 : 	{
; 1156 : 		
; 1157 : 		SetSwitch (SIMP_AB, rpm[0] > 1.0F);

	mov	ecx, 4
	imul	ecx, 0
	movss	xmm0, DWORD PTR _rpm$[ebp+ecx]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN193@MoveSurfac
	mov	DWORD PTR tv2284[ebp], 1
	jmp	SHORT $LN194@MoveSurfac
$LN193@MoveSurfac:
	mov	DWORD PTR tv2284[ebp], 0
$LN194@MoveSurfac:
	mov	edx, DWORD PTR tv2284[ebp]
	push	edx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSwitch@SimMoverClass@@QAEXHH@Z	; SimMoverClass::SetSwitch
$LN26@MoveSurfac:

; 1158 : 	}
; 1159 : 	
; 1160 : 	if ((af->gearPos > 0.5F) != GetSwitch (SIMP_GEAR))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [ecx+1552]
	comiss	xmm0, DWORD PTR __real@3f000000
	jbe	SHORT $LN195@MoveSurfac
	mov	DWORD PTR tv2290[ebp], 1
	jmp	SHORT $LN196@MoveSurfac
$LN195@MoveSurfac:
	mov	DWORD PTR tv2290[ebp], 0
$LN196@MoveSurfac:
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSwitch@SimMoverClass@@QAEHH@Z	; SimMoverClass::GetSwitch
	cmp	DWORD PTR tv2290[ebp], eax
	je	SHORT $LN25@MoveSurfac

; 1161 : 	{
; 1162 : 		
; 1163 : 		SetSwitch (SIMP_GEAR, af->gearPos > 0.5F);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR [eax+1552]
	comiss	xmm0, DWORD PTR __real@3f000000
	jbe	SHORT $LN197@MoveSurfac
	mov	DWORD PTR tv2307[ebp], 1
	jmp	SHORT $LN198@MoveSurfac
$LN197@MoveSurfac:
	mov	DWORD PTR tv2307[ebp], 0
$LN198@MoveSurfac:
	mov	ecx, DWORD PTR tv2307[ebp]
	push	ecx
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSwitch@SimMoverClass@@QAEXHH@Z	; SimMoverClass::SetSwitch
$LN25@MoveSurfac:

; 1164 : 	}
; 1165 : 	
; 1166 : 	gFact = min(7, max (0, FloatToInt32((af->nzcgb - 4.0F) * 1.5F)));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR [eax+1192]
	subss	xmm0, DWORD PTR __real@40800000
	mulss	xmm0, DWORD PTR __real@3fc00000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	test	eax, eax
	jge	SHORT $LN199@MoveSurfac
	mov	DWORD PTR tv2325[ebp], 0
	jmp	SHORT $LN200@MoveSurfac
$LN199@MoveSurfac:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR [edx+1192]
	subss	xmm0, DWORD PTR __real@40800000
	mulss	xmm0, DWORD PTR __real@3fc00000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR tv2325[ebp], eax
$LN200@MoveSurfac:
	cmp	DWORD PTR tv2325[ebp], 7
	jle	SHORT $LN203@MoveSurfac
	mov	DWORD PTR tv2343[ebp], 7
	jmp	$LN204@MoveSurfac
$LN203@MoveSurfac:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [ecx+1192]
	subss	xmm0, DWORD PTR __real@40800000
	mulss	xmm0, DWORD PTR __real@3fc00000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	test	eax, eax
	jge	SHORT $LN201@MoveSurfac
	mov	DWORD PTR tv2342[ebp], 0
	jmp	SHORT $LN202@MoveSurfac
$LN201@MoveSurfac:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR [eax+1192]
	subss	xmm0, DWORD PTR __real@40800000
	mulss	xmm0, DWORD PTR __real@3fc00000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR tv2342[ebp], eax
$LN202@MoveSurfac:
	mov	ecx, DWORD PTR tv2342[ebp]
	mov	DWORD PTR tv2343[ebp], ecx
$LN204@MoveSurfac:
	mov	edx, DWORD PTR tv2343[ebp]
	mov	DWORD PTR _gFact$[ebp], edx

; 1167 : 	if (gFact != GetSwitch (SIMP_WING_VAPOR))

	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSwitch@SimMoverClass@@QAEHH@Z	; SimMoverClass::GetSwitch
	cmp	DWORD PTR _gFact$[ebp], eax
	je	SHORT $LN24@MoveSurfac

; 1168 : 	{
; 1169 : 		
; 1170 : 		SetSwitch (SIMP_WING_VAPOR, gFact);

	mov	eax, DWORD PTR _gFact$[ebp]
	push	eax
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSwitch@SimMoverClass@@QAEXHH@Z	; SimMoverClass::SetSwitch
$LN24@MoveSurfac:

; 1171 : 	}
; 1172 : 	
; 1173 : 	
; 1174 : 	
; 1175 : 	
; 1176 : 	
; 1177 : 	{ // MLR - 2003-09-30 Spoiler & Wing Sweep code
; 1178 : 		//TJL 01/04/04 adding wingSweep;
; 1179 : 		float spoiler1l,spoiler1r,spoiler2l,spoiler2r,sweep;
; 1180 : 		CalculateSweepAndSpoiler(sweep,spoiler1l,spoiler1r,spoiler2l,spoiler2r);

	lea	ecx, DWORD PTR _spoiler2r$8[ebp]
	push	ecx
	lea	edx, DWORD PTR _spoiler2l$10[ebp]
	push	edx
	lea	eax, DWORD PTR _spoiler1r$12[ebp]
	push	eax
	lea	ecx, DWORD PTR _spoiler1l$14[ebp]
	push	ecx
	lea	edx, DWORD PTR _sweep$27[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateSweepAndSpoiler@AircraftClass@@QAEXAAM0000@Z ; AircraftClass::CalculateSweepAndSpoiler

; 1181 : 		MoveDof(SIMP_LT_SPOILER1, spoiler1l, af->auxaeroData->animSpoiler1Rate);

	push	-1
	push	-1
	push	-1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	push	ecx
	movss	xmm0, DWORD PTR [edx+3004]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _spoiler1l$14[ebp]
	movss	DWORD PTR [esp], xmm0
	push	42					; 0000002aH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 1182 : 		MoveDof(SIMP_RT_SPOILER1, spoiler1r, af->auxaeroData->animSpoiler1Rate);

	push	-1
	push	-1
	push	-1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	push	ecx
	movss	xmm0, DWORD PTR [edx+3004]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _spoiler1r$12[ebp]
	movss	DWORD PTR [esp], xmm0
	push	43					; 0000002bH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 1183 : 		MoveDof(SIMP_LT_SPOILER2, spoiler2l, af->auxaeroData->animSpoiler2Rate);

	push	-1
	push	-1
	push	-1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	push	ecx
	movss	xmm0, DWORD PTR [edx+3020]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _spoiler2l$10[ebp]
	movss	DWORD PTR [esp], xmm0
	push	44					; 0000002cH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 1184 : 		MoveDof(SIMP_RT_SPOILER2, spoiler2r, af->auxaeroData->animSpoiler2Rate);

	push	-1
	push	-1
	push	-1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	push	ecx
	movss	xmm0, DWORD PTR [edx+3020]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _spoiler2r$8[ebp]
	movss	DWORD PTR [esp], xmm0
	push	45					; 0000002dH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 1185 : 		wingSweep = sweep;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _sweep$27[ebp]
	movss	DWORD PTR [eax+1836], xmm0

; 1186 : 		if (acFlags & hasSwing)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+964]
	and	edx, 2
	je	SHORT $LN20@MoveSurfac

; 1187 : 		{
; 1188 : 			static const int swdofs[] = 
; 1189 : 			{SIMP_SWING_WING_1, SIMP_SWING_WING_2, SIMP_SWING_WING_3,
; 1190 : 			SIMP_SWING_WING_4,SIMP_SWING_WING_5,SIMP_SWING_WING_6,
; 1191 : 			SIMP_SWING_WING_7,SIMP_SWING_WING_8};
; 1192 : 			
; 1193 : 			MoveDof(SIMP_SWING_WING_1, sweep, 5.0f);

	push	-1
	push	-1
	push	-1
	push	ecx
	movss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _sweep$27[ebp]
	movss	DWORD PTR [esp], xmm0
	push	11					; 0000000bH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDof@AircraftClass@@AAEXHMMHHH@Z	; AircraftClass::MoveDof

; 1194 : 			for (int i = 1; i < sizeof(swdofs)/sizeof(swdofs[0]); i++)

	mov	DWORD PTR _i$43[ebp], 1
	jmp	SHORT $LN22@MoveSurfac
$LN21@MoveSurfac:
	mov	eax, DWORD PTR _i$43[ebp]
	add	eax, 1
	mov	DWORD PTR _i$43[ebp], eax
$LN22@MoveSurfac:
	cmp	DWORD PTR _i$43[ebp], 8
	jae	SHORT $LN20@MoveSurfac

; 1195 : 				SetDOF(swdofs[i], GetDOFValue(SIMP_SWING_WING_1));

	push	11					; 0000000bH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDOFValue@SimMoverClass@@QAEMH@Z	; SimMoverClass::GetDOFValue
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _i$43[ebp]
	mov	edx, DWORD PTR ?swdofs@?BBA@??MoveSurfaces@AircraftClass@@QAEXXZ@4QBHB[ecx*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDOF@SimMoverClass@@QAEXHM@Z		; SimMoverClass::SetDOF
	jmp	SHORT $LN21@MoveSurfac
$LN20@MoveSurfac:

; 1196 : 		}
; 1197 : 	}
; 1198 : 	
; 1199 : 	
; 1200 : 	
; 1201 : 	
; 1202 : 	if (af->auxaeroData->dragChuteCd > 0 )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	movss	xmm0, DWORD PTR [edx+228]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN19@MoveSurfac

; 1203 : 		DeployDragChute(SIMP_DRAGCHUTE);

	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DeployDragChute@AircraftClass@@AAEXH@Z	; AircraftClass::DeployDragChute
$LN19@MoveSurfac:

; 1204 : 	
; 1205 : }
; 1206 : 
; 1207 : // Check for stick shake
; 1208 : if (this == SimDriver.GetPlayerEntity())

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerEntity@SimulationDriver@@QBEPAVSimMoverClass@@XZ ; SimulationDriver::GetPlayerEntity
	cmp	DWORD PTR _this$[ebp], eax
	jne	$LN13@MoveSurfac

; 1209 : {
; 1210 : 	if (GetAlpha() > 15.0F && GetAlpha() < 20.0F)

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+408]
	call	eax
	fstp	DWORD PTR tv4100[ebp]
	movss	xmm0, DWORD PTR tv4100[ebp]
	comiss	xmm0, DWORD PTR __real@41700000
	jbe	SHORT $LN17@MoveSurfac
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+408]
	call	eax
	fstp	DWORD PTR tv4106[ebp]
	movss	xmm0, DWORD PTR __real@41a00000
	comiss	xmm0, DWORD PTR tv4106[ebp]
	jbe	SHORT $LN17@MoveSurfac

; 1211 : 	{
; 1212 : 		if (!stallShake)

	cmp	DWORD PTR _stallShake, 0
	jne	SHORT $LN15@MoveSurfac

; 1213 : 		{
; 1214 : 			if (this->AutopilotType() != AircraftClass::CombatAP)	// Retro 20Feb2004.. it can STOP regardless of AP status however..

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AutopilotType@AircraftClass@@QAE?AW4AutoPilotType@1@XZ ; AircraftClass::AutopilotType
	cmp	eax, 2
	je	SHORT $LN15@MoveSurfac

; 1215 : 			{
; 1216 : 				stallShake = TRUE;

	mov	DWORD PTR _stallShake, 1

; 1217 : 				JoystickPlayEffect (JoyStall1, 0);

	push	0
	push	7
	call	?JoystickPlayEffect@@YAHHH@Z		; JoystickPlayEffect
	add	esp, 8

; 1218 : 				JoystickPlayEffect (JoyStall2, 0);

	push	0
	push	8
	call	?JoystickPlayEffect@@YAHHH@Z		; JoystickPlayEffect
	add	esp, 8
$LN15@MoveSurfac:

; 1219 : 			}
; 1220 : 		}
; 1221 : 	}

	jmp	SHORT $LN13@MoveSurfac
$LN17@MoveSurfac:

; 1222 : 	else if (stallShake)

	cmp	DWORD PTR _stallShake, 0
	je	SHORT $LN13@MoveSurfac

; 1223 : 	{
; 1224 : 		stallShake = FALSE;

	mov	DWORD PTR _stallShake, 0

; 1225 : 		JoystickStopEffect (JoyStall1);

	push	7
	call	?JoystickStopEffect@@YAXH@Z		; JoystickStopEffect
	add	esp, 4

; 1226 : 		JoystickStopEffect (JoyStall2);

	push	8
	call	?JoystickStopEffect@@YAXH@Z		; JoystickStopEffect
	add	esp, 4
$LN13@MoveSurfac:

; 1227 : 	}
; 1228 : }
; 1229 : 
; 1230 : 
; 1231 : // this could be optimized
; 1232 : if ( gACMIRec.IsRecording() )

	mov	ecx, OFFSET ?gACMIRec@@3VACMIRecorder@@A ; gACMIRec
	call	?IsRecording@ACMIRecorder@@QAEHXZ	; ACMIRecorder::IsRecording
	test	eax, eax
	je	$LN2@MoveSurfac

; 1233 : {
; 1234 : 	acmiTimer-=SimLibMajorFrameTime;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1868]
	subss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+1868], xmm0

; 1235 : 	
; 1236 : 	if(acmiTimer<=0)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [eax+1868]
	jb	$LN2@MoveSurfac

; 1237 : 	{
; 1238 : 		acmiTimer=g_fACMIAnimRecordTimer;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR ?g_fACMIAnimRecordTimer@@3MA
	movss	DWORD PTR [ecx+1868], xmm0

; 1239 : 		
; 1240 : 		int l, dofs, switches;
; 1241 : 		dofs = ((DrawableBSP *)this->drawPointer)->GetNumDOFs();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+332]
	call	?GetNumDOFs@DrawableBSP@@QAEHXZ		; DrawableBSP::GetNumDOFs
	mov	DWORD PTR _dofs$25[ebp], eax

; 1242 : 		switches = ((DrawableBSP *)this->drawPointer)->GetNumSwitches();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+332]
	call	?GetNumSwitches@DrawableBSP@@QAEHXZ	; DrawableBSP::GetNumSwitches
	mov	DWORD PTR _switches$36[ebp], eax

; 1243 : 		if(dofs>=COMP_MAX_DOF)

	cmp	DWORD PTR _dofs$25[ebp], 163		; 000000a3H
	jl	SHORT $LN10@MoveSurfac

; 1244 : 			dofs=COMP_MAX_DOF-1;

	mov	DWORD PTR _dofs$25[ebp], 162		; 000000a2H
$LN10@MoveSurfac:

; 1245 : 		if(switches>=COMP_MAX_SWITCH)

	cmp	DWORD PTR _switches$36[ebp], 255	; 000000ffH
	jl	SHORT $LN9@MoveSurfac

; 1246 : 			switches=COMP_MAX_SWITCH-1;

	mov	DWORD PTR _switches$36[ebp], 254	; 000000feH
$LN9@MoveSurfac:

; 1247 : 		
; 1248 : 		acmiSwitch.hdr.time = SimLibElapsedTime * MSEC_TO_SEC + OTWDriver.todOffset;

	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR tv4122[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv4122[ebp]
	mov	edx, DWORD PTR tv4122[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv4126[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv4126[ebp]
	mulss	xmm0, DWORD PTR __real@3a83126f
	addss	xmm0, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+32052
	movss	DWORD PTR ?acmiSwitch@@3UACMISwitchRecord@@A+1, xmm0

; 1249 : 		acmiSwitch.data.type = Type();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Type@VuEntity@@QBEGXZ			; VuEntity::Type
	movzx	eax, ax
	mov	DWORD PTR ?acmiSwitch@@3UACMISwitchRecord@@A+5, eax

; 1250 : 		acmiSwitch.data.uniqueID = ACMIIDTable->Add(Id(),NULL,0);//.num_;

	push	0
	push	0
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR ?ACMIIDTable@@3PAVACMI_Hash@@A ; ACMIIDTable
	call	?Add@ACMI_Hash@@QAEJVVU_ID@@PADJ@Z	; ACMI_Hash::Add
	mov	DWORD PTR ?acmiSwitch@@3UACMISwitchRecord@@A+9, eax

; 1251 : 		
; 1252 : 		DOFRec.hdr.time = SimLibElapsedTime * MSEC_TO_SEC + OTWDriver.todOffset;

	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR tv4140[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv4140[ebp]
	mov	edx, DWORD PTR tv4140[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv4144[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv4144[ebp]
	mulss	xmm0, DWORD PTR __real@3a83126f
	addss	xmm0, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+32052
	movss	DWORD PTR ?DOFRec@@3UACMIDOFRecord@@A+1, xmm0

; 1253 : 		DOFRec.data.type = Type();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Type@VuEntity@@QBEGXZ			; VuEntity::Type
	movzx	eax, ax
	mov	DWORD PTR ?DOFRec@@3UACMIDOFRecord@@A+5, eax

; 1254 : 		DOFRec.data.uniqueID = ACMIIDTable->Add(Id(),NULL,0);//.num_;

	push	0
	push	0
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR ?ACMIIDTable@@3PAVACMI_Hash@@A ; ACMIIDTable
	call	?Add@ACMI_Hash@@QAEJVVU_ID@@PADJ@Z	; ACMI_Hash::Add
	mov	DWORD PTR ?DOFRec@@3UACMIDOFRecord@@A+9, eax

; 1255 : 		
; 1256 : 		for(l=0;l<COMP_MAX_DOF;l++)

	mov	DWORD PTR _l$54[ebp], 0
	jmp	SHORT $LN8@MoveSurfac
$LN7@MoveSurfac:
	mov	ecx, DWORD PTR _l$54[ebp]
	add	ecx, 1
	mov	DWORD PTR _l$54[ebp], ecx
$LN8@MoveSurfac:
	cmp	DWORD PTR _l$54[ebp], 163		; 000000a3H
	jge	$LN6@MoveSurfac

; 1257 : 		{
; 1258 : 			float d;
; 1259 : 			
; 1260 : 			d=GetDOFValue(l);

	mov	edx, DWORD PTR _l$54[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDOFValue@SimMoverClass@@QAEMH@Z	; SimMoverClass::GetDOFValue
	fstp	DWORD PTR _d$38[ebp]

; 1261 : 			if(((int)(acmiDOFValue[l]*360))!=((int)(d*360)))

	mov	eax, DWORD PTR _l$54[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4+1872]
	mulss	xmm0, DWORD PTR __real@43b40000
	cvttss2si edx, xmm0
	movss	xmm0, DWORD PTR _d$38[ebp]
	mulss	xmm0, DWORD PTR __real@43b40000
	cvttss2si eax, xmm0
	cmp	edx, eax
	je	SHORT $LN5@MoveSurfac

; 1262 : 			{
; 1263 : 				DOFRec.data.DOFNum = l;

	mov	ecx, DWORD PTR _l$54[ebp]
	mov	DWORD PTR ?DOFRec@@3UACMIDOFRecord@@A+13, ecx

; 1264 : 				DOFRec.data.DOFVal = d;

	movss	xmm0, DWORD PTR _d$38[ebp]
	movss	DWORD PTR ?DOFRec@@3UACMIDOFRecord@@A+17, xmm0

; 1265 : 				DOFRec.data.prevDOFVal = acmiDOFValue[l];

	mov	edx, DWORD PTR _l$54[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4+1872]
	movss	DWORD PTR ?DOFRec@@3UACMIDOFRecord@@A+21, xmm0

; 1266 : 				acmiDOFValue[l]=d;

	mov	ecx, DWORD PTR _l$54[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _d$38[ebp]
	movss	DWORD PTR [edx+ecx*4+1872], xmm0

; 1267 : 				gACMIRec.DOFRecord( &DOFRec );

	push	OFFSET ?DOFRec@@3UACMIDOFRecord@@A	; DOFRec
	mov	ecx, OFFSET ?gACMIRec@@3VACMIRecorder@@A ; gACMIRec
	call	?DOFRecord@ACMIRecorder@@QAEXPAUACMIDOFRecord@@@Z ; ACMIRecorder::DOFRecord
$LN5@MoveSurfac:

; 1268 : 			}
; 1269 : 		}

	jmp	$LN7@MoveSurfac
$LN6@MoveSurfac:

; 1270 : 		for(l=0;l<switches;l++)

	mov	DWORD PTR _l$54[ebp], 0
	jmp	SHORT $LN4@MoveSurfac
$LN3@MoveSurfac:
	mov	eax, DWORD PTR _l$54[ebp]
	add	eax, 1
	mov	DWORD PTR _l$54[ebp], eax
$LN4@MoveSurfac:
	mov	ecx, DWORD PTR _l$54[ebp]
	cmp	ecx, DWORD PTR _switches$36[ebp]
	jge	SHORT $LN2@MoveSurfac

; 1271 : 		{
; 1272 : 			int s;
; 1273 : 			
; 1274 : 			s=GetSwitch(l);

	mov	edx, DWORD PTR _l$54[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSwitch@SimMoverClass@@QAEHH@Z	; SimMoverClass::GetSwitch
	mov	DWORD PTR _s$34[ebp], eax

; 1275 : 			if(acmiSwitchValue[l]!=s)

	mov	eax, DWORD PTR _l$54[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+2524]
	cmp	edx, DWORD PTR _s$34[ebp]
	je	SHORT $LN1@MoveSurfac

; 1276 : 			{
; 1277 : 				acmiSwitch.data.switchNum	  = l;

	mov	eax, DWORD PTR _l$54[ebp]
	mov	DWORD PTR ?acmiSwitch@@3UACMISwitchRecord@@A+13, eax

; 1278 : 				acmiSwitch.data.switchVal	  = s;

	mov	ecx, DWORD PTR _s$34[ebp]
	mov	DWORD PTR ?acmiSwitch@@3UACMISwitchRecord@@A+17, ecx

; 1279 : 				acmiSwitch.data.prevSwitchVal = acmiSwitchValue[l];

	mov	edx, DWORD PTR _l$54[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+2524]
	mov	DWORD PTR ?acmiSwitch@@3UACMISwitchRecord@@A+21, ecx

; 1280 : 				acmiSwitchValue[l]=s;

	mov	edx, DWORD PTR _l$54[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _s$34[ebp]
	mov	DWORD PTR [eax+edx*4+2524], ecx

; 1281 : 				gACMIRec.SwitchRecord( &acmiSwitch );

	push	OFFSET ?acmiSwitch@@3UACMISwitchRecord@@A ; acmiSwitch
	mov	ecx, OFFSET ?gACMIRec@@3VACMIRecorder@@A ; gACMIRec
	call	?SwitchRecord@ACMIRecorder@@QAEXPAUACMISwitchRecord@@@Z ; ACMIRecorder::SwitchRecord
$LN1@MoveSurfac:

; 1282 : 			}
; 1283 : 		}

	jmp	SHORT $LN3@MoveSurfac
$LN2@MoveSurfac:
$LN167@MoveSurfac:

; 1284 : 	}
; 1285 : }
; 1286 : 
; 1287 : 
; 1288 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN205@MoveSurfac:
	DD	$LN120@MoveSurfac
	DD	$LN118@MoveSurfac
	DD	$LN116@MoveSurfac
	DD	$LN115@MoveSurfac
	DD	$LN114@MoveSurfac
	DD	$LN113@MoveSurfac
	DD	$LN112@MoveSurfac
	DD	$LN111@MoveSurfac
	DD	$LN110@MoveSurfac
	DD	$LN117@MoveSurfac
	DD	$LN109@MoveSurfac
	DD	$LN120@MoveSurfac
$LN206@MoveSurfac:
	DD	$LN105@MoveSurfac
	DD	$LN103@MoveSurfac
	DD	$LN101@MoveSurfac
	DD	$LN100@MoveSurfac
	DD	$LN99@MoveSurfac
	DD	$LN98@MoveSurfac
	DD	$LN97@MoveSurfac
	DD	$LN96@MoveSurfac
	DD	$LN95@MoveSurfac
	DD	$LN102@MoveSurfac
	DD	$LN94@MoveSurfac
	DD	$LN105@MoveSurfac
?MoveSurfaces@AircraftClass@@QAEXXZ ENDP		; AircraftClass::MoveSurfaces
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?IsComplex@AircraftClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
?IsComplex@AircraftClass@@QAEHXZ PROC			; AircraftClass::IsComplex, COMDAT
; _this$ = ecx

; 336  : 	int            IsComplex (void) {return ((acFlags & isComplex) ? TRUE : FALSE);}

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+964]
	and	ecx, 4
	je	SHORT $LN3@IsComplex
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsComplex
$LN3@IsComplex:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsComplex:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?IsComplex@AircraftClass@@QAEHXZ ENDP			; AircraftClass::IsComplex
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?AutopilotType@AircraftClass@@QAE?AW4AutoPilotType@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AutopilotType@AircraftClass@@QAE?AW4AutoPilotType@1@XZ PROC ; AircraftClass::AutopilotType, COMDAT
; _this$ = ecx

; 329  : 	AutoPilotType	AutopilotType (void) {return autopilotType;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+968]
	mov	esp, ebp
	pop	ebp
	ret	0
?AutopilotType@AircraftClass@@QAE?AW4AutoPilotType@1@XZ ENDP ; AircraftClass::AutopilotType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\surface.cpp
_TEXT	SEGMENT
_i$1 = -16						; size = 4
_i$2 = -12						; size = 4
_this$ = -8						; size = 4
_i$3 = -4						; size = 4
_PitBSP$ = 8						; size = 4
?CopyAnimationsToPit@AircraftClass@@QAEXPAVDrawableBSP@@@Z PROC ; AircraftClass::CopyAnimationsToPit
; _this$ = ecx

; 1778 : {	

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1779 : 	if(IsComplex())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsComplex@AircraftClass@@QAEHXZ	; AircraftClass::IsComplex
	test	eax, eax
	je	$LN20@CopyAnimat

; 1780 : 	{
; 1781 : 		// don't waste cycles on range checking.
; 1782 : 		// Get/SetDOFangle() does so itself. same with Switches
; 1783 : 		int i;
; 1784 : 		for(i = 0; i < COMP_MAX_DOF; i++)

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN19@CopyAnimat
$LN18@CopyAnimat:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN19@CopyAnimat:
	cmp	DWORD PTR _i$3[ebp], 163		; 000000a3H
	jge	SHORT $LN17@CopyAnimat

; 1785 : 		{
; 1786 : 			PitBSP->SetDOFangle(i, GetDOFValue(i));

	mov	ecx, DWORD PTR _i$3[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDOFValue@SimMoverClass@@QAEMH@Z	; SimMoverClass::GetDOFValue
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _i$3[ebp]
	push	edx
	mov	ecx, DWORD PTR _PitBSP$[ebp]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 1787 : 		}

	jmp	SHORT $LN18@CopyAnimat
$LN17@CopyAnimat:

; 1788 : 		
; 1789 : 		// some of the switches had to be reordered because the pits have conflicting switches
; 1790 : 		// copy 0 - 3 
; 1791 : 		for(i=  0; i < 4; i++)

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN16@CopyAnimat
$LN15@CopyAnimat:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN16@CopyAnimat:
	cmp	DWORD PTR _i$3[ebp], 4
	jge	SHORT $LN14@CopyAnimat

; 1792 : 			PitBSP->SetSwitchMask(i+COMP_PIT_AB, GetSwitch(i));

	mov	ecx, DWORD PTR _i$3[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSwitch@SimMoverClass@@QAEHH@Z	; SimMoverClass::GetSwitch
	push	eax
	mov	edx, DWORD PTR _i$3[ebp]
	add	edx, 25					; 00000019H
	push	edx
	mov	ecx, DWORD PTR _PitBSP$[ebp]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
	jmp	SHORT $LN15@CopyAnimat
$LN14@CopyAnimat:

; 1793 : 		
; 1794 : 		// copy 4 - 6
; 1795 : 		for(i = 4; i < 7; i++)

	mov	DWORD PTR _i$3[ebp], 4
	jmp	SHORT $LN13@CopyAnimat
$LN12@CopyAnimat:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN13@CopyAnimat:
	cmp	DWORD PTR _i$3[ebp], 7
	jge	SHORT $LN11@CopyAnimat

; 1796 : 			PitBSP->SetSwitchMask(i, GetSwitch(i));

	mov	ecx, DWORD PTR _i$3[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSwitch@SimMoverClass@@QAEHH@Z	; SimMoverClass::GetSwitch
	push	eax
	mov	edx, DWORD PTR _i$3[ebp]
	push	edx
	mov	ecx, DWORD PTR _PitBSP$[ebp]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
	jmp	SHORT $LN12@CopyAnimat
$LN11@CopyAnimat:

; 1797 : 		
; 1798 : 		// copy 7
; 1799 : 		PitBSP->SetSwitchMask(COMP_PIT_TAIL_STROBE, GetSwitch(COMP_TAIL_STROBE));

	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSwitch@SimMoverClass@@QAEHH@Z	; SimMoverClass::GetSwitch
	push	eax
	push	29					; 0000001dH
	mov	ecx, DWORD PTR _PitBSP$[ebp]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 1800 : 		
; 1801 : 		// copy 8-24
; 1802 : 		for(i = 8; i < COMP_PIT_AB; i++)

	mov	DWORD PTR _i$3[ebp], 8
	jmp	SHORT $LN10@CopyAnimat
$LN9@CopyAnimat:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN10@CopyAnimat:
	cmp	DWORD PTR _i$3[ebp], 25			; 00000019H
	jge	SHORT $LN8@CopyAnimat

; 1803 : 			PitBSP->SetSwitchMask(i, GetSwitch(i));

	mov	ecx, DWORD PTR _i$3[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSwitch@SimMoverClass@@QAEHH@Z	; SimMoverClass::GetSwitch
	push	eax
	mov	edx, DWORD PTR _i$3[ebp]
	push	edx
	mov	ecx, DWORD PTR _PitBSP$[ebp]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
	jmp	SHORT $LN9@CopyAnimat
$LN8@CopyAnimat:

; 1804 : 		
; 1805 : 		
; 1806 : #if COMP_MAX_SWITCH > 30 // just in case more switches are added.
; 1807 : 		// copy 30 - COMP_MAX_SWITCH
; 1808 : 		for(i = 30; i < COMP_MAX_SWITCH; i++)
; 1809 : 		{
; 1810 : 			PitBSP->SetSwitchMask(i, GetSwitch(i));
; 1811 : 		}
; 1812 : #endif
; 1813 : 		
; 1814 : 		
; 1815 : 	}
; 1816 : 	else

	jmp	$LN1@CopyAnimat
$LN20@CopyAnimat:

; 1817 : 	{
; 1818 : 		// map Simple model DOFs to complex model DOFs;
; 1819 : 		static const int dmap[] = { 
; 1820 : 			// PIT DOF             SIMPLE
; 1821 : 			COMP_LT_STAB,			SIMP_LT_STAB,
; 1822 : 				COMP_RT_STAB,			SIMP_RT_STAB,
; 1823 : 				COMP_LT_FLAP,			SIMP_LT_AILERON,
; 1824 : 				COMP_RT_FLAP,			SIMP_RT_AILERON,
; 1825 : 				COMP_RUDDER,			SIMP_RUDDER_1,
; 1826 : 				COMP_LT_AIR_BRAKE_TOP,	SIMP_AIR_BRAKE,
; 1827 : 				COMP_LT_AIR_BRAKE_BOT,	SIMP_AIR_BRAKE,
; 1828 : 				COMP_RT_AIR_BRAKE_TOP,	SIMP_AIR_BRAKE,
; 1829 : 				COMP_RT_AIR_BRAKE_BOT,	SIMP_AIR_BRAKE,
; 1830 : 				COMP_SWING_WING,		SIMP_SWING_WING_1,
; 1831 : 				COMP_RT_TEF,			SIMP_RT_TEF,
; 1832 : 				COMP_LT_TEF,			SIMP_LT_TEF,
; 1833 : 				COMP_RT_LEF,			SIMP_RT_LEF,
; 1834 : 				COMP_LT_LEF,			SIMP_LT_LEF,
; 1835 : 				COMP_CANOPY_DOF,		SIMP_CANOPY_DOF,
; 1836 : 				COMP_PROPELLOR,			SIMP_PROPELLOR,
; 1837 : 				COMP_LT_SPOILER1,		SIMP_LT_SPOILER1,
; 1838 : 				COMP_RT_SPOILER1,		SIMP_RT_SPOILER1,
; 1839 : 				COMP_LT_SPOILER2,		SIMP_LT_SPOILER2,
; 1840 : 				COMP_RT_SPOILER2,		SIMP_RT_SPOILER2,
; 1841 : 				COMP_THROTTLE,			SIMP_THROTTLE,
; 1842 : 		};
; 1843 : 		
; 1844 : 		static const int dmap_size = sizeof(dmap) / sizeof(dmap[0]) / 2;
; 1845 : 		
; 1846 : 		for(int i = 0; i < dmap_size; i++)

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN6@CopyAnimat
$LN5@CopyAnimat:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN6@CopyAnimat:
	cmp	DWORD PTR _i$2[ebp], 21			; 00000015H
	jge	SHORT $LN4@CopyAnimat

; 1847 : 		{
; 1848 : 			PitBSP->SetDOFangle(dmap[i*2], GetDOFValue(dmap[i*2+1]));

	mov	ecx, DWORD PTR _i$2[ebp]
	shl	ecx, 1
	mov	edx, DWORD PTR ?dmap@?M@??CopyAnimationsToPit@AircraftClass@@QAEXPAVDrawableBSP@@@Z@4QBHB[ecx*4+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDOFValue@SimMoverClass@@QAEMH@Z	; SimMoverClass::GetDOFValue
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _i$2[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR ?dmap@?M@??CopyAnimationsToPit@AircraftClass@@QAEXPAVDrawableBSP@@@Z@4QBHB[eax*4]
	push	ecx
	mov	ecx, DWORD PTR _PitBSP$[ebp]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 1849 : 		}

	jmp	SHORT $LN5@CopyAnimat
$LN4@CopyAnimat:

; 1850 : 		
; 1851 : 		
; 1852 : 		// map Simple model Switches to complex model Switches;
; 1853 : 		static const int smap[] = { 
; 1854 : 			// PIT SWITCH          SIMPLE
; 1855 : 			COMP_PIT_AB,			SIMP_AB,
; 1856 : 				COMP_PIT_NOS_GEAR_SW,	SIMP_GEAR,
; 1857 : 				COMP_PIT_LT_GEAR_SW,	SIMP_GEAR,
; 1858 : 				COMP_PIT_RT_GEAR_SW,	SIMP_GEAR,
; 1859 : 				COMP_WING_VAPOR,		SIMP_WING_VAPOR,
; 1860 : 				COMP_CANOPY,			SIMP_CANOPY,
; 1861 : 				COMP_DRAGCHUTE,			SIMP_DRAGCHUTE,
; 1862 : 				COMP_HOOK,				SIMP_HOOK
; 1863 : 		};
; 1864 : 		static const int smap_size = sizeof(smap) / sizeof(smap[0]) / 2;
; 1865 : 		
; 1866 : 		for (int i = 0; i < smap_size; i++){

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN3@CopyAnimat
$LN2@CopyAnimat:
	mov	edx, DWORD PTR _i$1[ebp]
	add	edx, 1
	mov	DWORD PTR _i$1[ebp], edx
$LN3@CopyAnimat:
	cmp	DWORD PTR _i$1[ebp], 8
	jge	SHORT $LN1@CopyAnimat

; 1867 : 			PitBSP->SetSwitchMask(smap[i*2], GetSwitch(smap[i*2+1]));

	mov	eax, DWORD PTR _i$1[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR ?smap@?O@??CopyAnimationsToPit@AircraftClass@@QAEXPAVDrawableBSP@@@Z@4QBHB[eax*4+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSwitch@SimMoverClass@@QAEHH@Z	; SimMoverClass::GetSwitch
	push	eax
	mov	edx, DWORD PTR _i$1[ebp]
	shl	edx, 1
	mov	eax, DWORD PTR ?smap@?O@??CopyAnimationsToPit@AircraftClass@@QAEXPAVDrawableBSP@@@Z@4QBHB[edx*4]
	push	eax
	mov	ecx, DWORD PTR _PitBSP$[ebp]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 1868 : 		}		

	jmp	SHORT $LN2@CopyAnimat
$LN1@CopyAnimat:

; 1869 : 	}
; 1870 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?CopyAnimationsToPit@AircraftClass@@QAEXPAVDrawableBSP@@@Z ENDP ; AircraftClass::CopyAnimationsToPit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\surface.cpp
_TEXT	SEGMENT
_rLEF$ = -16						; size = 4
_lLEF$ = -12						; size = 4
tv95 = -8						; size = 4
_this$ = -4						; size = 4
_side$ = 8						; size = 4
?CheckLEF@AircraftClass@@QAEMH@Z PROC			; AircraftClass::CheckLEF
; _this$ = ecx

; 1731 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1732 : 	float rLEF;
; 1733 : 	float lLEF;
; 1734 : 	if (IsComplex()) {

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsComplex@AircraftClass@@QAEHXZ	; AircraftClass::IsComplex
	test	eax, eax
	je	SHORT $LN15@CheckLEF

; 1735 : 		rLEF = GetDOFValue(COMP_RT_LEF);

	push	10					; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDOFValue@SimMoverClass@@QAEMH@Z	; SimMoverClass::GetDOFValue
	fstp	DWORD PTR _rLEF$[ebp]

; 1736 : 		lLEF = GetDOFValue(COMP_LT_LEF);

	push	9
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDOFValue@SimMoverClass@@QAEMH@Z	; SimMoverClass::GetDOFValue
	fstp	DWORD PTR _lLEF$[ebp]

; 1737 : 	}
; 1738 : 	else {

	jmp	SHORT $LN14@CheckLEF
$LN15@CheckLEF:

; 1739 : 		rLEF = GetDOFValue(SIMP_RT_LEF);

	push	21					; 00000015H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDOFValue@SimMoverClass@@QAEMH@Z	; SimMoverClass::GetDOFValue
	fstp	DWORD PTR _rLEF$[ebp]

; 1740 : 		lLEF = GetDOFValue(SIMP_LT_LEF);

	push	22					; 00000016H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDOFValue@SimMoverClass@@QAEMH@Z	; SimMoverClass::GetDOFValue
	fstp	DWORD PTR _lLEF$[ebp]
$LN14@CheckLEF:

; 1741 : 	}
; 1742 : 	//side 0 = left
; 1743 : 	switch(side)

	mov	eax, DWORD PTR _side$[ebp]
	mov	DWORD PTR tv95[ebp], eax
	cmp	DWORD PTR tv95[ebp], 0
	je	SHORT $LN11@CheckLEF
	cmp	DWORD PTR tv95[ebp], 1
	je	SHORT $LN6@CheckLEF
	jmp	$LN1@CheckLEF
$LN11@CheckLEF:

; 1744 : 	{
; 1745 : 	case 0:
; 1746 : 		//Left LEF
; 1747 : 		if(LEFState(LT_LEF_OUT) || LEFState(LEFSASYNCH))	//can't work anymore

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LEFState@AircraftClass@@QAEHW4LEFStateFlags@1@@Z ; AircraftClass::LEFState
	test	eax, eax
	jne	SHORT $LN9@CheckLEF
	push	32					; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LEFState@AircraftClass@@QAEHW4LEFStateFlags@1@@Z ; AircraftClass::LEFState
	test	eax, eax
	je	SHORT $LN10@CheckLEF
$LN9@CheckLEF:

; 1748 : 			leftLEFAngle = LTLEFAOA;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+856]
	mov	DWORD PTR [ecx+868], eax

; 1749 : 		else	//normal operation

	jmp	SHORT $LN7@CheckLEF
$LN10@CheckLEF:

; 1750 : 		{
; 1751 : 			if(LEFLocked)	

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+853]
	test	edx, edx
	je	SHORT $LN7@CheckLEF

; 1752 : 				leftLEFAngle = lLEF;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _lLEF$[ebp]
	movss	DWORD PTR [eax+868], xmm0
$LN7@CheckLEF:

; 1753 : 		}
; 1754 : 		return leftLEFAngle;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+868]
	jmp	SHORT $LN16@CheckLEF

; 1755 : 		break;

	jmp	SHORT $LN12@CheckLEF
$LN6@CheckLEF:

; 1756 : 	case 1:
; 1757 : 		//Right LEF
; 1758 : 		if(LEFState(RT_LEF_OUT) || LEFState(LEFSASYNCH))	//can't work anymore

	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LEFState@AircraftClass@@QAEHW4LEFStateFlags@1@@Z ; AircraftClass::LEFState
	test	eax, eax
	jne	SHORT $LN4@CheckLEF
	push	32					; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LEFState@AircraftClass@@QAEHW4LEFStateFlags@1@@Z ; AircraftClass::LEFState
	test	eax, eax
	je	SHORT $LN5@CheckLEF
$LN4@CheckLEF:

; 1759 : 			rightLEFAngle = RTLEFAOA;	//got set when we took hit

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+860]
	mov	DWORD PTR [edx+872], ecx

; 1760 : 		else	//normal operation

	jmp	SHORT $LN2@CheckLEF
$LN5@CheckLEF:

; 1761 : 		{
; 1762 : 			if(LEFLocked)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+853]
	test	eax, eax
	je	SHORT $LN2@CheckLEF

; 1763 : 				rightLEFAngle = rLEF;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _rLEF$[ebp]
	movss	DWORD PTR [ecx+872], xmm0
$LN2@CheckLEF:

; 1764 : 		}
; 1765 : 		
; 1766 : 		return rightLEFAngle;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+872]
	jmp	SHORT $LN16@CheckLEF

; 1767 : 		break;

	jmp	SHORT $LN12@CheckLEF
$LN1@CheckLEF:

; 1768 : 	default:
; 1769 : 		return 0.0F;

	fldz
	jmp	SHORT $LN16@CheckLEF
$LN12@CheckLEF:

; 1770 : 		break;
; 1771 : 	}
; 1772 : 	return 0.0F;

	fldz
$LN16@CheckLEF:

; 1773 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?CheckLEF@AircraftClass@@QAEMH@Z ENDP			; AircraftClass::CheckLEF
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?LEFState@AircraftClass@@QAEHW4LEFStateFlags@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_fl$ = 8						; size = 4
?LEFState@AircraftClass@@QAEHW4LEFStateFlags@1@@Z PROC	; AircraftClass::LEFState, COMDAT
; _this$ = ecx

; 275  : 	int LEFState(LEFStateFlags fl) { return (LEFFlags & fl) == (unsigned int)fl ? 1 : 0; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+864]
	and	ecx, DWORD PTR _fl$[ebp]
	cmp	ecx, DWORD PTR _fl$[ebp]
	jne	SHORT $LN3@LEFState
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@LEFState
$LN3@LEFState:
	mov	DWORD PTR tv67[ebp], 0
$LN4@LEFState:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?LEFState@AircraftClass@@QAEHW4LEFStateFlags@1@@Z ENDP	; AircraftClass::LEFState
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?ExtlState@AircraftClass@@QBEHW4ExtlLightFlags@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv69 = -4						; size = 4
_fl$ = 8						; size = 4
?ExtlState@AircraftClass@@QBEHW4ExtlLightFlags@1@@Z PROC ; AircraftClass::ExtlState, COMDAT
; _this$ = ecx

; 188  : 	int ExtlState(ExtlLightFlags fl) const { return (IsAcStatusBitsSet(fl) ? 1 : 0); }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _fl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsAcStatusBitsSet@AircraftClass@@QBE_NH@Z ; AircraftClass::IsAcStatusBitsSet
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@ExtlState
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@ExtlState
$LN3@ExtlState:
	mov	DWORD PTR tv69[ebp], 0
$LN4@ExtlState:
	mov	eax, DWORD PTR tv69[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?ExtlState@AircraftClass@@QBEHW4ExtlLightFlags@1@@Z ENDP ; AircraftClass::ExtlState
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?IsAcStatusBitsSet@AircraftClass@@QBE_NH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_bits$ = 8						; size = 4
?IsAcStatusBitsSet@AircraftClass@@QBE_NH@Z PROC		; AircraftClass::IsAcStatusBitsSet, COMDAT
; _this$ = ecx

; 170  : 	bool IsAcStatusBitsSet(int bits) const { return (status_bits & bits) == bits; }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+760]
	and	ecx, DWORD PTR _bits$[ebp]
	cmp	ecx, DWORD PTR _bits$[ebp]
	jne	SHORT $LN3@IsAcStatus
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsAcStatus
$LN3@IsAcStatus:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsAcStatus:
	mov	al, BYTE PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsAcStatusBitsSet@AircraftClass@@QBE_NH@Z ENDP		; AircraftClass::IsAcStatusBitsSet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simmover.h
;	COMDAT ?GetSwitch@SimMoverClass@@QAEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_num$ = 8						; size = 4
?GetSwitch@SimMoverClass@@QAEHH@Z PROC			; SimMoverClass::GetSwitch, COMDAT
; _this$ = ecx

; 135  : 	int GetSwitch (int num) { return num < numSwitches ? switchData[num] : 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _num$[ebp]
	cmp	ecx, DWORD PTR [eax+604]
	jge	SHORT $LN3@GetSwitch
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+592]
	mov	ecx, DWORD PTR _num$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR tv69[ebp], edx
	jmp	SHORT $LN4@GetSwitch
$LN3@GetSwitch:
	mov	DWORD PTR tv69[ebp], 0
$LN4@GetSwitch:
	mov	eax, DWORD PTR tv69[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetSwitch@SimMoverClass@@QAEHH@Z ENDP			; SimMoverClass::GetSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simmover.h
;	COMDAT ?SetSwitch@SimMoverClass@@QAEXHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_num$ = 8						; size = 4
_val$ = 12						; size = 4
?SetSwitch@SimMoverClass@@QAEXHH@Z PROC			; SimMoverClass::SetSwitch, COMDAT
; _this$ = ecx

; 134  : 	void SetSwitch (int num, int val) { ShiAssert(num < numSwitches); if (num < numSwitches) { switchData[num] = val; switchChange[num] = TRUE;} }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _num$[ebp]
	cmp	ecx, DWORD PTR [eax+604]
	jge	SHORT $LN2@SetSwitch
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+592]
	mov	ecx, DWORD PTR _num$[ebp]
	mov	edx, DWORD PTR _val$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+596]
	mov	edx, DWORD PTR _num$[ebp]
	mov	DWORD PTR [ecx+edx*4], 1
$LN2@SetSwitch:
	mov	esp, ebp
	pop	ebp
	ret	8
?SetSwitch@SimMoverClass@@QAEXHH@Z ENDP			; SimMoverClass::SetSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simmover.h
;	COMDAT ?GetDOFValue@SimMoverClass@@QAEMH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_dof$ = 8						; size = 4
?GetDOFValue@SimMoverClass@@QAEMH@Z PROC		; SimMoverClass::GetDOFValue, COMDAT
; _this$ = ecx

; 132  : 	float GetDOFValue (int dof) { ShiAssert(dof < numDofs); return dof < numDofs ? DOFData[dof] : 0;}

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _dof$[ebp]
	cmp	ecx, DWORD PTR [eax+600]
	jge	SHORT $LN3@GetDOFValu
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+612]
	mov	ecx, DWORD PTR _dof$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx*4]
	movss	DWORD PTR tv69[ebp], xmm0
	jmp	SHORT $LN4@GetDOFValu
$LN3@GetDOFValu:
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv69[ebp], xmm0
$LN4@GetDOFValu:
	fld	DWORD PTR tv69[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetDOFValue@SimMoverClass@@QAEMH@Z ENDP		; SimMoverClass::GetDOFValue
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simmover.h
;	COMDAT ?SetDOF@SimMoverClass@@QAEXHM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_dof$ = 8						; size = 4
_val$ = 12						; size = 4
?SetDOF@SimMoverClass@@QAEXHM@Z PROC			; SimMoverClass::SetDOF, COMDAT
; _this$ = ecx

; 130  : 	void SetDOF (int dof, float val) { ShiAssert(dof < numDofs); if (dof < numDofs) { DOFData[dof] = val;}}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _dof$[ebp]
	cmp	ecx, DWORD PTR [eax+600]
	jge	SHORT $LN1@SetDOF
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+612]
	mov	ecx, DWORD PTR _dof$[ebp]
	movss	xmm0, DWORD PTR _val$[ebp]
	movss	DWORD PTR [eax+ecx*4], xmm0
$LN1@SetDOF:
	mov	esp, ebp
	pop	ebp
	ret	8
?SetDOF@SimMoverClass@@QAEXHM@Z ENDP			; SimMoverClass::SetDOF
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
;	COMDAT ?IsSetFlag@SimBaseClass@@QBEHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
_flag$ = 8						; size = 4
?IsSetFlag@SimBaseClass@@QBEHH@Z PROC			; SimBaseClass::IsSetFlag, COMDAT
; _this$ = ecx

; 178  : 	int  IsSetFlag(int flag) const { return ((specialData.flags & flag) ? TRUE : FALSE); }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+172]
	and	ecx, DWORD PTR _flag$[ebp]
	je	SHORT $LN3@IsSetFlag
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@IsSetFlag
$LN3@IsSetFlag:
	mov	DWORD PTR tv68[ebp], 0
$LN4@IsSetFlag:
	mov	eax, DWORD PTR tv68[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsSetFlag@SimBaseClass@@QBEHH@Z ENDP			; SimBaseClass::IsSetFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsPlayer@FalconEntity@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsPlayer@FalconEntity@@QAEHXZ PROC			; FalconEntity::IsPlayer, COMDAT
; _this$ = ecx

; 113  : 	int IsPlayer (void)							{ return IsSetFalcFlag(FEC_HASPLAYERS); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSetFalcFlag@FalconEntity@@QAEHH@Z	; FalconEntity::IsSetFalcFlag
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPlayer@FalconEntity@@QAEHXZ ENDP			; FalconEntity::IsPlayer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsSetFalcFlag@FalconEntity@@QAEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_flag$ = 8						; size = 4
?IsSetFalcFlag@FalconEntity@@QAEHH@Z PROC		; FalconEntity::IsSetFalcFlag, COMDAT
; _this$ = ecx

; 112  : 	int IsSetFalcFlag (int flag)				{ return falconFlags & flag; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+136]
	and	eax, DWORD PTR _flag$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsSetFalcFlag@FalconEntity@@QAEHH@Z ENDP		; FalconEntity::IsSetFalcFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2275 : 		{	// report an out_of_range error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2276 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN2@Xran:

; 2277 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2270 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2271 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN2@Xlen:

; 2272 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Ptr$1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2253 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2254 : 		if (!_Built)

	movzx	eax, BYTE PTR __Built$[ebp]
	test	eax, eax
	jne	SHORT $LN4@Tidy
	jmp	SHORT $LN3@Tidy
$LN4@Tidy:

; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN3@Tidy

; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Ptr$1[ebp], eax

; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 2260 : 			if (0 < _Newsize)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN1@Tidy

; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$1[ebp]
	push	ecx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Tidy:

; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Ptr$1[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN3@Tidy:

; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2266 : 		_Eos(_Newsize);

	mov	edx, DWORD PTR __Newsize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2267 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2237 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	cmp	DWORD PTR __Ptr$[ebp], 0
	je	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	cmp	DWORD PTR __Ptr$[ebp], eax
	jb	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
$LN2@Inside:

; 2240 : 			return (false);	// don't ask

	xor	al, al
	jmp	SHORT $LN4@Inside

; 2241 : 		else

	jmp	SHORT $LN4@Inside
$LN3@Inside:

; 2242 : 			return (true);

	mov	al, 1
$LN4@Inside:

; 2243 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
tv136 = -12						; size = 4
tv129 = -8						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2224 : 		if (max_size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN6@Grow

; 2225 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN6@Grow:

; 2226 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN5@Grow

; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	jmp	SHORT $LN4@Grow
$LN5@Grow:

; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	movzx	edx, BYTE PTR __Trim$[ebp]
	test	edx, edx
	je	SHORT $LN3@Grow
	cmp	DWORD PTR __Newsize$[ebp], 16		; 00000010H
	jae	SHORT $LN3@Grow

; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jae	SHORT $LN9@Grow
	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv129[ebp], edx
	jmp	SHORT $LN10@Grow
$LN9@Grow:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR tv129[ebp], ecx
$LN10@Grow:
	mov	edx, DWORD PTR tv129[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
	jmp	SHORT $LN4@Grow
$LN3@Grow:

; 2231 : 		else if (_Newsize == 0)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $LN4@Grow

; 2232 : 			_Eos(0);	// new size is zero, just null terminate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN4@Grow:

; 2233 : 		return (0 < _Newsize);	// return true only if more work to do

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN11@Grow
	mov	DWORD PTR tv136[ebp], 1
	jmp	SHORT $LN12@Grow
$LN11@Grow:
	mov	DWORD PTR tv136[ebp], 0
$LN12@Grow:
	mov	al, BYTE PTR tv136[ebp]
$LN8@Grow:

; 2234 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [eax+16], ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 2219 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
tv205 = -48						; size = 4
tv204 = -44						; size = 4
tv203 = -40						; size = 4
tv202 = -36						; size = 4
__Ptr$ = -32						; size = 4
__Newres$ = -28						; size = 4
_this$ = -24						; size = 4
$T2 = -19						; size = 1
$T3 = -18						; size = 1
$T4 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Newres$[ebp], eax

; 2184 : 		if (max_size() < _Newres)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newres$[ebp]
	jae	SHORT $LN9@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx
	jmp	SHORT $LN8@Copy
$LN9@Copy:

; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)

	mov	eax, DWORD PTR __Newres$[ebp]
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	shr	ecx, 1
	cmp	ecx, eax
	ja	SHORT $LN7@Copy
	jmp	SHORT $LN8@Copy
$LN7@Copy:

; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+20]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, esi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], eax
	ja	SHORT $LN5@Copy

; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	shr	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR __Newres$[ebp], eax

; 2191 : 		else

	jmp	SHORT $LN8@Copy
$LN5@Copy:

; 2192 : 			_Newres = max_size();	// settle for max_size()

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	DWORD PTR __Newres$[ebp], eax
$LN8@Copy:

; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv202[ebp], eax
	mov	eax, DWORD PTR __Newres$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR tv202[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv203[ebp], eax
	mov	ecx, DWORD PTR tv203[ebp]
	mov	DWORD PTR __Ptr$[ebp], ecx
	jmp	SHORT $LN12@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2197 : 		_CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], edx

; 2199 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv204[ebp], eax
	mov	ecx, DWORD PTR __Newres$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR tv204[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv205[ebp], eax
	mov	edx, DWORD PTR tv205[ebp]
	mov	DWORD PTR __Ptr$[ebp], edx
	jmp	SHORT $LN14@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2203 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 2204 : 			_CATCH_END

	mov	eax, $LN17@Copy
	ret	0
$LN14@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2
$LN17@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2:

; 2205 : 		_CATCH_END

	mov	eax, $LN19@Copy
	ret	0
$LN12@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3
$LN19@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jbe	SHORT $LN1@Copy

; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements

	mov	eax, DWORD PTR __Oldlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Copy:

; 2210 : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);

	lea	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>

; 2212 : 		this->_Myres = _Newres;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newres$[ebp]
	mov	DWORD PTR [edx+20], eax

; 2213 : 		_Eos(_Oldlen);

	mov	ecx, DWORD PTR __Oldlen$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN11@Copy:

; 2214 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv75 = -12						; size = 4
__Num$ = -8						; size = 4
$T1 = -1						; size = 1
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1737 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1738 : 		size_type _Num = this->_Getal().max_size();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
	mov	DWORD PTR __Num$[ebp], eax

; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$[ebp], 1
	ja	SHORT $LN3@max_size
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	ecx, DWORD PTR __Num$[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv75[ebp], ecx
$LN4@max_size:
	mov	eax, DWORD PTR tv75[ebp]

; 1740 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1732 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1733 : 		return (this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]

; 1734 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$1 = -12					; size = 4
__Ptr$2 = -8						; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1317 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1318 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN4@erase

; 1319 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN4@erase:

; 1320 : 		if (this->_Mysize - _Off <= _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Off$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	ja	SHORT $LN3@erase

; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)

	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
	jmp	SHORT $LN2@erase
$LN3@erase:

; 1322 : 		else if (0 < _Count)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN2@erase

; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Ptr$2[ebp], eax

; 1325 : 			size_type _Newsize = this->_Mysize - _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Newsize$1[ebp], eax

; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	sub	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$2[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$2[ebp]
	push	eax
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 1327 : 			_Eos(_Newsize);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@erase:

; 1328 : 			}
; 1329 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN6@erase:

; 1330 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1309 : 		{	// erase elements [_Off, ...)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1310 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN1@erase

; 1311 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN1@erase:

; 1312 : 		_Eos(_Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1313 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@erase:

; 1314 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1142 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1145 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@assign

; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	jmp	SHORT $LN3@assign
$LN2@assign:

; 1132 : 
; 1133 : 		if (_Grow(_Count))

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@assign

; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1136 : 			_Eos(_Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@assign:

; 1137 : 			}
; 1138 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@assign:

; 1139 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1105 : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $LN5@assign

; 1106 : 			_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN5@assign:

; 1107 : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 1108 : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Num$[ebp]
	jae	SHORT $LN4@assign

; 1109 : 			_Num = _Count;	// trim _Num to size

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
$LN4@assign:

; 1110 : 
; 1111 : 		if (this == &_Right)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@assign

; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	mov	eax, DWORD PTR __Roff$[ebp]
	add	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	mov	ecx, DWORD PTR __Roff$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	jmp	SHORT $LN2@assign
$LN3@assign:

; 1113 : 		else if (_Grow(_Num))

	push	0
	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@assign

; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);

	mov	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1117 : 			_Eos(_Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@assign:

; 1118 : 			}
; 1119 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN7@assign:

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 791  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >

; 792  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 793  : 		assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 794  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 688  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 689  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 690  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 635  : 	_String_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >

; 636  : 		{	// construct allocator from _Al
; 637  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		{	// determine current pointer to buffer for nonmutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 522  : 		return (this->_BUF_SIZE <= this->_Myres
; 523  : 			? _STD addressof(*this->_Bx._Ptr)
; 524  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 525  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		{	// determine current pointer to buffer for mutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 515  : 		return (this->_BUF_SIZE <= this->_Myres
; 516  : 			? _STD addressof(*this->_Bx._Ptr)
; 517  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 518  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 496  : 	_String_val()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 497  : 		{	// initialize values
; 498  : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 499  : 		_Myres = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 500  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 913  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 914  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
	add	esp, 4

; 915  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 886  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 887  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate

; 888  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 875  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 877  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 830  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>

; 831  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 761  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp

; 762  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@D@std@@QBEIXZ	; std::allocator<char>::max_size

; 763  : 		}

	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

	or	eax, -1

; 629  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 590  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8

; 592  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 565  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 563  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 564  : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 565  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 551  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@move
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@move
$LN3@move:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@move:
	mov	eax, DWORD PTR tv69[ebp]

; 554  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 528  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@copy
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@copy
$LN3@copy:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@copy:
	mov	eax, DWORD PTR tv69[ebp]

; 531  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 521  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp
	push	ecx

; 522  : 		return (*_First == 0 ? 0
; 523  : 			: _CSTD strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@length
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN4@length
$LN3@length:
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR tv68[ebp], eax
$LN4@length:
	mov	eax, DWORD PTR tv68[ebp]

; 524  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 65   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 60   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 61   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Type@VuEntity@@QBEGXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Type@VuEntity@@QBEGXZ PROC				; VuEntity::Type, COMDAT
; _this$ = ecx

; 154  : 	ushort Type() const       { return share_.entityType_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?Type@VuEntity@@QBEGXZ ENDP				; VuEntity::Type
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Id@VuEntity@@QBE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?Id@VuEntity@@QBE?AVVU_ID@@XZ PROC			; VuEntity::Id, COMDAT
; _this$ = ecx

; 131  : 	VU_ID Id() const	{ return share_.id_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?Id@VuEntity@@QBE?AVVU_ID@@XZ ENDP			; VuEntity::Id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
_TEXT	SEGMENT
_x$ = 8							; size = 4
?FloatToInt32@@YAHM@Z PROC				; FloatToInt32

; 179  : {

	push	ebp
	mov	ebp, esp

; 180  : #if WIN32
; 181  :   __asm {
; 182  :     fld dword ptr [x];

	fld	DWORD PTR _x$[ebp]

; 183  :     fistp dword ptr [x];

	fistp	DWORD PTR _x$[ebp]

; 184  :     mov eax,dword ptr [x];

	mov	eax, DWORD PTR _x$[ebp]

; 185  :   }
; 186  : #else 
; 187  : 	return static_cast<int>(x);	
; 188  : #endif
; 189  : }

	pop	ebp
	ret	0
?FloatToInt32@@YAHM@Z ENDP				; FloatToInt32
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?fmod@@YAMMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
__Y$ = 12						; size = 4
?fmod@@YAMMM@Z PROC					; fmod, COMDAT

; 521  :         {return (fmodf(_X, _Y)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __Y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_fmodf
	add	esp, 8
	pop	ebp
	ret	0
?fmod@@YAMMM@Z ENDP					; fmod
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?fabs@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?fabs@@YAMM@Z PROC					; fabs, COMDAT

; 517  :         {return (fabsf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_fabsf
	add	esp, 4
	pop	ebp
	ret	0
?fabs@@YAMM@Z ENDP					; fabs
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _fmodf
_TEXT	SEGMENT
tv77 = -12						; size = 8
tv79 = -4						; size = 4
__X$ = 8						; size = 4
__Y$ = 12						; size = 4
_fmodf	PROC						; COMDAT

; 418  :         {return ((float)fmod((double)_X, (double)_Y)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __Y$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fmod
	add	esp, 16					; 00000010H
	fstp	QWORD PTR tv77[ebp]
	movsd	xmm0, QWORD PTR tv77[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv79[ebp], xmm0
	fld	DWORD PTR tv79[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_fmodf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_fabsf	PROC						; COMDAT

; 392  :         {return ((float)fabs((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_fabsf	ENDP
_TEXT	ENDS
END
